<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using the dbDAO GetRowsEx Method</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>

	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END--><h4><a name="jb2using_the_dbdao_getrowsex_method"></a>Using the dbDAO GetRowsEx Method</h4>
<p>
The <b>GetRowsEx</b> method retrieves multiple records and enables you to specify the data types of the fields stored in your application variables. It has the following parameters.</p>
<table>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<b>Parameter</b></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<b>Data type</b></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<b>Description</b></font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<i>pvBuffer</i></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
LPVOID</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Pointer to the buffer in which to store returned records.</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<i>CbRow</i></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
LONG</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Length of the record, in bytes.</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<i>Prb</i></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
LPDAORSETBINDING</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Pointer to the binding structure (see the following description).</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<i>Cbinding</i></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
LONG</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Number of bindings.</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<i>PvVarBuffer</i></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
LPVOID</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Pointer to the buffer in which to store variable-length data.</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<i>CbVarBuffer</i></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
LONG</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Length, in bytes, of <i>pvVarBuffer</i>.</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<i>Lrows</i></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
LONG</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Number of records requested.</font></td>
</tr>
</table><br>
<p>
The <b>DAORSETBINDING</b> structure specifies how data is to be copied from the records to the memory buffer. A separate binding structure must be filled in for each field retrieved. <b>DAORSETBINDING</b> is defined as follows:</p>
<pre><FONT FACE="Courier New" SIZE="3">typedef struct
&#09;{
&#09;DWORD   dwBindIndexType;
&#09;union
&#09;&#09;{
&#09;&#09;LONG    i;
&#09;&#09;LPCTSTR pstr;
&#09;&#09;};

&#09;DWORD   dwType;
&#09;DWORD   dwOffset;
&#09;DWORD   cb;

&#09;} DAORSETBINDING, *LPDAORSETBINDING;</font></pre>
<p>
The <b>DAORSETBINDING</b> structure has the following members.</p>
<table>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<b>Member</b></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<b>Description</b></font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<b>dwBindIndexType</b></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Value specifying whether a field is indicated by an index number or by name. This member is one of the following values:<p>
dbBindIndexINT (index)<BR>dbBindIndexSTR (name)</p>
</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<b>dwType</b></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Data type. This member is one of the following values:<p>
dbBindI2 (long)<BR>dbBindI4 (short)<BR>dbBindR4 (float)<BR>dbBindR8 (double)<BR>dbBindCY (currency)<BR>dbBindDATE (DATE)<BR>dbBindBOOL (VARIANT_BOOL)<BR>dbBindUI1 (unsigned char)<BR>dbBindVARIANT (VARIANT)<BR>dbBindWCHAR (wchar_t[])<BR>dbBindSTRING (same as dbBindWCHAR for Unicode, <BR>&#09;dbBindUI1 for ANSI)<BR>dbBindLPSTR (char_pointer) <BR>dbBindLPTSTR (wchar_pointer) <BR>dbBindLPSTRING (dbBindLPTSTR for Unicode, <BR>&#09;dbBindLPSTR for ANSI)<BR>dbBindBookmark (CdbBookmark)<BR>dbBindBlob (unsigned char pointer)</p>
</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<b>dwOffset</b></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Offset, in bytes, in the record buffer where the data is copied.</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<b>Cb</b></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Field length, in bytes.</font></td>
</tr>
</table><br>
<p>
The following code from the GetRows example shows how to use the <b>GetRowsEx</b> method. Note that the table schema is known <i>a priori</i>, allowing you to predefine a structure for the data.</p>
<p>
Two different binding schemes for retrieving string data are shown. If the size of the string is fixed, you can retrieve the strings directly into the structure. If you are using variable-length strings, they will be placed sequentially in a single large buffer, and a pointer into that buffer will be stored in the structure.</p>
<pre><FONT FACE="Courier New" SIZE="3">// Structure for GetRowsEx:
typedef struct
&#09;{
&#09;LONG&#09;lEmpId;
&#09;TCHAR&#09;*strLastName;
&#09;TCHAR&#09;strFirstName[20];
&#09;} EMP, *LPEMP ;

// Employee table binding: 
DAORSETBINDING&#09;Bindings[] = 
{
//Index Type&#09;&#09;Column&#09;&#09;Type&#09;&#09;&#09;Offset&#09;&#09;&#09;&#09;&#09;&#09;Size
{dbBindIndexINT,&#09;EMP_ID,&#09;&#09;dbBindI4,&#09;&#09;offsetof(EMP,lEmpId),&#09;&#09;sizeof(LONG)},
{dbBindIndexINT,&#09;EMP_LNAME,&#09;dbBindLPSTRING,&#09;offsetof(EMP,strLastName),&#09;sizeof(TCHAR *)},
{dbBindIndexINT,&#09;EMP_FNAME,&#09;dbBindSTRING,&#09;offsetof(EMP,strFirstName),&#09;sizeof(TCHAR) * 20}
};

// Perform C++ GetRowsEx against the Employee table.
void CGetRowsDlg::DoGetRowsEx() 
{
&#09;LPEMP&#09;&#09;&#09;pEmpRows = new EMP[MAX_EMP_REC];
&#09;CListBox&#09;&#09;*pListBox = (CListBox *)GetDlgItem(IDD_GETROWSLISTEX);
&#09;CString&#09;&#09;&#09;strLBRow;
&#09;TCHAR&#09;&#09;&#09;szId[16];
&#09;LONG&#09;&#09;&#09;lNumRecords;
&#09;LONG&#09;&#09;&#09;lCount;
&#09;TCHAR&#09;&#09;&#09;pBuf[MAX_EMP_REC * 15];&#09;&#09;// Allow average of 15 chars/name.

&#09;//Perform GetRows on Employee table.
&#09;//This GetRows uses a specific C++ structure.
&#09;try
&#09;&#09;{
&#09;&#09;lNumRecords = m_cEmpRecordSet.GetRowsEx(pEmpRows, sizeof(EMP),
&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&amp;Bindings[0], sizeof(Bindings) / sizeof(DAORSETBINDING),
&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;pBuf, sizeof(pBuf),
&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;&#09;MAX_EMP_REC); //arbitrarily get MAX_EMP_REC rows
&#09;&#09;}
&#09;catch (CdbException e)
&#09;&#09;{
&#09;&#09;//Differentiate between GetRowsEx Errors and other CdbExceptions.
&#09;&#09;//See defines in DAOGETRW.H.
&#09;&#09;if(&#09;e.m_hr == E_ROWTOOSHORT ||
&#09;&#09;&#09;e.m_hr == E_BADBINDINFO ||&#09;&#09;&#09;
&#09;&#09;&#09;e.m_hr == E_COLUMNUNAVAILABLE )
&#09;&#09;&#09;{
&#09;&#09;&#09;AfxMessageBox(_T(&quot;Error in GetRowsEx call.&quot;));
&#09;&#09;&#09;}&#09;
&#09;&#09;else
&#09;&#09;&#09;{
&#09;&#09;&#09;AfxMessageBox(_T(&quot;General CdbException&quot;));
&#09;&#09;&#09;}
&#09;&#09;delete [] pEmpRows;
&#09;&#09;return;
&#09;&#09;}


&#09;//Step through the returned rows. 
&#09;for (lCount = 0; lCount &lt; lNumRecords; lCount++)
&#09;&#09;{
&#09;&#09;strLBRow.Empty();
&#09;&#09;wsprintf(szId, _T(&quot;%d,  &quot;), pEmpRows[lCount].lEmpId);
&#09;&#09;strLBRow += szId;
&#09;&#09;strLBRow += pEmpRows[lCount].strLastName;
&#09;&#09;strLBRow += _T(&quot;, &quot;);
&#09;&#09;strLBRow += (LPCTSTR) pEmpRows[lCount].strFirstName;
&#09;&#09;pListBox-&gt;AddString(strLBRow);
&#09;&#09;}

&#09;delete [] pEmpRows;
}</font></pre>
</BODY>
</HTML>
