<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Common Pitfalls</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>

	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END--><h3><a name="jb2common_pitfalls"></a>Common Pitfalls</h3>
<p>
Many common mistakes can cause unnecessary bottlenecks when you are running queries. Following is a list of these common mistakes and what to do to correct them.
<ul>
<li>
Including expressions in query output. Placing expressions, such as an <b>IIf</b> on an output field of a query can cause optimization problems if the query is used as the input to another query. For example, consider the following two queries, where the first query is saved as Q1:<pre><FONT FACE="Courier New" SIZE="3">SELECT IIf(ShipVia = 2, 'United Package', 'Other') 
&#09;AS ShipperName 
FROM Orders;

SELECT * 
FROM Q1 
WHERE ShipperName = 'United Package';</font></pre>
<p>
Because Microsoft Jet can’t optimize the <b>IIf</b> expression in the first query, it can’t optimize the second query. Expressions can get buried so far down in a query tree that it’s easy to forget about them. If expressions are necessary in the output, try to place the expression in a control on a form or report.</p>
<p>
The following query replaces the previous two queries and is the optimal way to write this query:</p>
<pre><FONT FACE="Courier New" SIZE="3">SELECT * 
FROM Orders 
WHERE ShipVia = 2;</font></pre>
</li>
<li>
Using GROUP BY on too many fields. When you’re creating a totals query, use the GROUP BY clause on as few fields as necessary to achieve the query’s goal. The more fields in the GROUP BY clause, the longer the query takes to execute. Make sure you don’t include extraneous fields.<br><br></li>
<li>
Using GROUP BY in same query as a join. If possible, place a GROUP BY clause on a table and then join it to another table, rather than joining the two tables and using the GROUP BY clause in the same query as the join. For example, instead of this query<pre><FONT FACE="Courier New" SIZE="3">SELECT 
&#09;Orders.CustomerID, 
&#09;Count(Orders.OrderID) AS CountOfOrderID
FROM Customers 
INNER JOIN Orders 
ON Customers.CustomerID = Orders.CustomerID
GROUP BY Orders.CustomerID;</font></pre>
<p>
you may benefit by using two separate queries, as follows, where the first query is saved as SelectWithGroupByQ1:</p>
<pre><FONT FACE="Courier New" SIZE="3">SELECT Customers.CustomerID 
FROM Customers
GROUP BY Customers.CustomerID;

SELECT 
&#09;Orders.CustomerID, 
&#09;Count(Orders.OrderID) AS CountOfOrderID
FROM SelectWithGroupByQ1, INNER JOIN Orders
ON Q1.CustomerID = Orders.CustomerID
GROUP BY Orders.CustomerID;</font></pre>
</li>
<li>
Not including indexes on join fields. When you’re joining tables, always try to index the fields on both sides of a join. This can speed up query execution by allowing more sophisticated join strategies such as index and index-merge joins. The use of indexes also provides better statistics. For more information, see the “Join Strategies” section earlier in this chapter.<br><br></li>
<li>
Under-indexing fields. In appropriate circumstances, for example where the database is used solely for decision-support types of applications, you can place an index on all fields that have unique values and are used in a join or as a restriction. By using Rushmore query optimization, Microsoft Jet can take advantage of multiple indexes on a single table. This makes indexing many fields advantageous. However, keep in mind that adding indexes to fields can cause performance to suffer.<br><br></li>
<li>
Using <b>Count(</b><i>fieldname</i><b>)</b> instead of <b>Count(*)</b>. When you have to determine the number of records, you should use <b>Count(*)</b> rather than <b>Count(</b><i>fieldname</i><b>)</b> because there are Rushmore optimizations that allow <b>Count(*)</b> to be executed much more quickly than <b>Count(</b><i>fieldname</i><b>)</b>.</li>
</ul>
</BODY>
</HTML>
