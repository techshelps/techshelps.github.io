<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Use Indexes Cautiously</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>

	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END--><h4><a name="jb2use_indexes_cautiously"></a>Use Indexes Cautiously</h4>
<p>
Although having indexes can reduce the time it takes to retrieve data, they always carry a cost in maintenance and concurrency issues. When should a field be indexed? There is no strict answer for this because it depends on the type of application.</p>
<p>
The first guideline is that fields containing highly duplicated data should not be indexed (for example, fields with the Yes/No data type, and fields that represent gender, state abbreviations, or country codes).</p>
<p>
The second guideline is that fields should not be indexed simply to force Rushmore to use more than one index. An example of this would be indexing a field called City and a field called PostalCode in a customer table when the application is always going to be using both fields for retrieval purposes. In this instance, the PostalCode field is going to be the most unique index and would return a result set faster if the City field was not indexed. Because Rushmore doesn’t need to use the index on the City field, omitting the index on the City field will reduce overall disk I/O. Of course, if both values were not always being entered and they were used alternatively and equally, then having an index on both fields would probably be advantageous. Rushmore is best utilized on combined indexes when they are required to generate a unique result set.</p>
<p>
It is also important to remember that indexes create concurrency issues. One index page represents many data pages. Therefore, modifying an index page can cause users with data on an entirely different data page to be locked out when trying to update the indexed field.</p>
<p>
To see this behavior, open the Northwind database in Microsoft Access&nbsp;97 and turn on pessimistic locking by clicking <b>Edited Record</b> on the <b>Advanced</b> tab of the <b>Options</b> dialog box (<b>Tools</b> menu). Update a value in one indexed field in the Customers table, but don’t move to the next record. On another workstation, open the Customers table and try to edit another value in the same indexed field that the other workstation is editing. Next, try updating a value in a non-indexed field in the Customers table. What will become evident is that substantially more records of data are locked when you try to update a value in an indexed field than when you try to update a value in a non-indexed field.</p>
</BODY>
</HTML>
