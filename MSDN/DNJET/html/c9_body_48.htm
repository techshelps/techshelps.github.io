<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Transaction Behavior</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>

	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END--><h4><a name="jb2transaction_behavior"></a>Transaction Behavior</h4>
<p>
Often, to enforce data integrity, a set of operations must be considered as a single unit. For example, the transfer of funds from one bank account to another consists of two operations: entering a debit in one account and a matching credit in the other account. In practice, either both operations must succeed or neither operation should be processed.</p>
<p>
In this situation, the debit and credit operations are a single unit, or a <i>transaction</i>. A transaction is a set of operations that are committed (saved) if and only if all of the operations succeed. If any of the operations fail, all of the operations that succeeded are rolled back (canceled), and the data is returned to the state it was in before the transaction began.</p>
<p>
DAO supports three transaction methods: one for starting, one for committing, and one for rolling back a transaction:
<ul>
<li>
The <b>BeginTrans</b> method begins a new transaction.<br><br></li>
<li>
The <b>CommitTrans</b> method commits all changes made to data by the most recent <b>BeginTrans</b> method.<br><br></li>
<li>
The <b>Rollback</b> method rolls back, or cancels, all changes made to data by the most recent <b>BeginTrans</b> method.</li>
</ul>
<p>
<b>BeginTrans</b>, <b>CommitTrans</b>, and <b>Rollback</b> are all methods of the <b>Workspace</b> object.</p>
<p>
On most servers, transactions hold locks that prevent other users from updating or even reading data affected by the transaction until it’s committed or rolled back. You should therefore keep your transactions as short as possible and avoid beginning a transaction and then waiting for the user’s response before completing it.</p>
<p>
The following code shows a transfer using two common update operations, a withdrawal and a deposit. The transfer occurs in the context of a transaction. If either operation fails, the transaction makes sure that the operation as a whole fails.</p>
<pre><FONT FACE="Courier New" SIZE="3">Sub IncreaseRoyalty(strDbPath As String)
&#09;Dim wrk As Workspace, dbs As Database
&#09;Dim qdf As QueryDef

&#09;On Error GoTo Err_IncreaseRoyalty

&#09;Set wrk = DBEngine.Workspaces(0)
&#09;Set dbs = wrk.OpenDatabase(strDbPath)

&#09;' Begin the transaction.
&#09;wrk.BeginTrans

&#09;' Create a temporary SQL pass-through query.
&#09;Set qdf = dbs.CreateQueryDef(&quot;&quot;)
&#09;' Set QueryDef properties and execute.
&#09;With qdf
&#09;&#09;.Connect = &quot;ODBC;DSN=Pubs;UID=sa;PWD=;DATABASE=Pubs&quot;
&#09;&#09;.ReturnsRecords = False
&#09;&#09;.SQL = &quot;UPDATE Roysched SET Royalty = &quot; &amp; _
&#09;&#09;&#09;&quot;Royalty + 2 WHERE HiRange &lt; 6000&quot;
&#09;&#09;' Execute method will fail if error occurs.
&#09;&#09;.Execute dbFailOnError
&#09;End With
&#09;' Commit the transaction.
&#09;wrk.CommitTrans
&#09;
Exit_IncreaseRoyalty:
&#09;On Error Resume Next
&#09;dbs.Close
&#09;Set dbs = Nothing
&#09;Exit Sub

Err_IncreaseRoyalty:
&#09;' If one operation fails, roll them all back.
&#09;wrk.Rollback
&#09;VerboseErrorHandler
&#09;MsgBox &quot;Transaction rolled back!&quot;
&#09;Resume Exit_IncreaseRoyalty
End Sub</font></pre>
<h5>How Microsoft Jet Uses ODBC Transactions</h5>
<p>
When your DAO code does not use transaction methods explicitly, Microsoft Jet will use ODBC in <i>auto-commit</i> mode. In this mode, each SQL statement sent to the server has an implicit transaction around it; that is, the SQL statement has an immediate effect on the ODBC data and cannot be rolled back. Microsoft Jet stops using auto-commit mode and uses explicit ODBC transactions with:
<ul>
<li>
SQL statements that modify data (for example, UPDATE, INSERT, or APPEND).<br><br></li>
<li>
Explicit DAO transaction methods.</li>
</ul>
<p>
When using bulk operation SQL statements such as UPDATE, INSERT, and APPEND, Microsoft Jet places a transaction around the operation so that it can succeed or fail as a single entity. This is necessary because one such Microsoft Jet SQL statement may correspond to many individual server statements.</p>
<h5>DAO Transactions</h5>
<p>
Multiple concurrent transactions on <b>Recordset</b> objects against a single server are actually a single transaction because a single connection is being used to service updates for both dynasets. You should structure your transactions so that they do not overlap; transactions are intended to be atomic units.</p>
<p>
If the server supports transactions at all, Microsoft Jet assumes only single-level support; that is, no nesting of transactions. Therefore, if your application code nests transactions, only the outermost <b>BeginTrans</b>, <b>CommitTrans</b>, and <b>Rollback</b> methods are sent to the server; nested transactions are ignored without warning.</p>
<p>
These transaction semantics also apply to SQL pass-through queries that modify server data, so explicit transactions within the pass-through queries cannot be used.</p>
<p>
<b>See Also   </b>For more information on SQL pass-through queries, see “Using SQL Pass-Through Queries” earlier in this chapter.</p>
</BODY>
</HTML>
