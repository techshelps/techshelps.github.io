<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Retrieving Multiple Result Sets</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>

	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END--><h4><a name="jb2retrieving_multiple_result_sets"></a>Retrieving Multiple Result Sets</h4>
<p>
Any SQL statement can include multiple SELECT statements or stored procedures that invoke one or more SELECT statements. Each SELECT statement generates a result set that must be processed by your code or discarded before the resources are released and the next result set is made available. Because you don’t necessarily know how many result sets will be generated by a stored procedure, your code must be prepared to process an unknown number of result sets. Note that when a stored procedure returns multiple result sets, none of the result sets can be updated.</p>
<p>
You can use either client-side cursors or server-side cursors to retrieve multiple result sets. If you use client-side cursors, multiple result sets are returned no matter what type of <b>Recordset</b> object you open. If you use server-side cursors to retrieve multiple result sets, you must open a forward-only-type <b>Recordset</b> object.</p>
<p>
<b><font face="Symbol"><span style="font-family:symbol">&#219;</span></font>&#09;To retrieve multiple result sets</b>
<ol>
<li>
Set the workspace’s <b>DefaultCursorDriver</b> property to <b>dbUseServerCursor</b> to specify server-side cursors.<br><br></li>
<li>
Create a <b>QueryDef</b> object and set its <b>SQL</b> property to a valid SQL string that returns multiple <b>Recordset</b> objects.<br><br></li>
<li>
Set the <b>CacheSize</b> property of the <b>QueryDef</b> object to 1 to request that the server sends you one record at a time. When you retrieve records in this way, you don’t actually use the cursor.<br><br></li>
<li>
Open a <b>Recordset</b> object on the <b>QueryDef</b> object you just created. Specify <b>dbOpenForwardOnly</b> for the <i>type</i> argument of the <b>OpenRecordset</b> method.<br><br></li>
<li>
Use the <b>NextRecordset</b> method to access the next <b>Recordset</b> object in the group of <b>Recordset</b> objects returned by the server. This discards the current <b>Recordset</b> object and replaces it with the next <b>Recordset</b> object specified in your query’s SQL statement. If there are no more <b>Recordset</b> objects in the group of <b>Recordset</b> objects, then the return value of the <b>NextRecordset</b> method will be <b>False</b> and the current <b>Recordset</b> object will be empty.</li>
</ol>
<p>
The following example prints the values of each field for each record in each result set.</p>
<pre><FONT FACE="Courier New" SIZE="3">Function GetMultipleResults()
&#09;Dim wrk As Workspace, rst As Recordset, cnn As Connection, qdf As QueryDef
&#09;Dim fld As Field, strSQL As String, strConnect As String, fDone As Boolean

&#09;' Create ODBCDirect workspace.
&#09;Set wrk = DBEngine.CreateWorkspace(&quot;ODBCDirect&quot;, &quot;Admin&quot;, &quot;&quot;, dbUseODBC)
&#09;' Create connection string.
&#09;strConnect = &quot;ODBC;DSN=Pubs;DATABASE=Pubs;UID=sa;PWD=;&quot;
&#09;' Open connection.
&#09;Set cnn = wrk.OpenConnection(&quot;&quot;, dbDriverNoPrompt, False, strConnect)
&#09;' Create SQL statement.
&#09;strSQL = &quot;SELECT au_lname, au_fname FROM Authors; SELECT title FROM Titles;&quot;
&#09;' Set default cursor driver.
&#09;wrk.DefaultCursorDriver = dbUseServerCursor

&#09;' Create temporary QueryDef object.
&#09;Set qdf = cnn.CreateQueryDef(&quot;&quot;, strSQL)
&#09;qdf.CacheSize = 1
&#09;' Open recordset on QueryDef.
&#09;Set rst = qdf.OpenRecordset(dbOpenForwardOnly)

&#09;Do Until fDone = True
&#09;&#09;' Print values for each field in each record of recordset.
&#09;&#09;While Not rst.EOF
&#09;&#09;&#09;For Each fld In rst.Fields
&#09;&#09;&#09;&#09;Debug.Print fld.Value
&#09;&#09;&#09;Next fld
&#09;&#09;&#09;rst.MoveNext
&#09;&#09;Wend
&#09;&#09;fDone = Not rst.NextRecordset()
&#09;Loop
&#09;rst.Close
&#09;cnn.Close
&#09;wrk.Close
End Function</font></pre>
</BODY>
</HTML>
