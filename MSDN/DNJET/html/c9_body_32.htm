<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Caching Remote Data</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>

	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END--><h3><a name="jb2caching_remote_data"></a>Caching Remote Data</h3>
<p>
If you are using a Microsoft Jet workspace, you can use the Microsoft Jet <b>CacheSize</b> and <b>CacheStart</b> properties to store all or part of the data contained in a dynaset-type <b>Recordset</b> object in local memory. Local caching of records dramatically speeds up operations when moving through dynaset records in both directions, and shows significant improvements even when moving in a forward-only direction.</p>
<p>
To use caching, specify the number of records to be stored using the <b>CacheSize</b> property. The range of values you can use for the <b>CacheSize</b> property is between 5&nbsp;and 1200 records. If the size of the cache exceeds available memory, the excess records spill into a temporary disk file. Typically, you set the value of the <b>CacheSize</b> property to 100. To recover the cache memory, set the <b>CacheSize</b> property to 0. Specify the beginning record by setting the <b>CacheStart</b> property to the value of a bookmark using the <b>Bookmark</b> property. Then use the <b>FillCache</b> method to retrieve every value in the specified cache range and fill the cache with server data. For example, you might use the following code when you open your form:</p>
<pre><FONT FACE="Courier New" SIZE="3">With rst
&#09;.CacheSize = 20
&#09;.CacheStart = rst.Bookmark
&#09;.FillCache
End With</font></pre>
<p>
This code will preload an internal buffer with 20 records of data. As the user moves through those records, they display quickly because they won’t have to be retrieved from the server.</p>
<p>
This is more efficient than filling the cache as each record is retrieved, so if you know ahead of time that all records in the cache range will be visited, call the <b>FillCache</b> method every time you change the setting of the <b>CacheStart</b> property. Retrievals within the cache boundary occur locally, speeding display of the cached records in a datasheet or in a continuous form.</p>
<p>
As you move through records, the data you retrieve will be cached until you move out of the defined range. Once you’ve hit the end of the range defined by the <b>CacheSize</b> and <b>CacheStart</b> properties, you need to change the <b>CacheStart</b> property setting to stay synchronized with the set of records you’re working with. Then, caching will continue with the new range, reusing values appropriately if the new cache range overlaps the old.</p>
<p>
Using a cache can provide significant performance benefits. If the application requires backward scrolling within the cached region, the performance improvements will be even greater. Depending on your scenario, using a cache may be faster than using a read-only, forward-only-type <b>Recordset</b> object, especially if it contains Memo or Long Binary (OLE Object) fields that are referenced only occasionally.</p>
<p>
<b>See Also   </b>For more information about forward-only-type <b>Recordset</b> objects, see “Forward-Only-Type Recordsets” earlier in this chapter.</p>
<p>
The size of the cache you use is determined by the application’s needs. For example, if you are displaying these records to the user, then you might use a cache size determined by the number of records permitted on the screen. If the code has no user interaction, then you can make a tradeoff between local memory availability, network traffic, and record size.</p>
<p>
<b>Notes</b>
<ul>
<li>
One important distinction with caching ODBC data is that the cached data will include Memo fields but not Long Binary fields (such as OLE Object fields). Hence, the cache can get large if you have those types of fields in your result set. If it becomes too large, then the cache overflows onto disk. Although more expensive than in-memory cache, this is still usually better then generating more round-trips to the server. If you are using other Microsoft Jet data sources, then only a pointer to the database page containing the Memo or Long Binary field is stored in the cache, and the actual contents are only retrieved if the field itself is retrieved.<br><br></li>
<li>
You can’t use recordset caching with an ODBCDirect <b>Recordset</b> object, but you can change the default cache size by setting the <b>CacheSize</b> property of an ODBCDirect <b>QueryDef</b> object.</li>
</ul>
</BODY>
</HTML>
