<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Caching References to Objects and Collections</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>

	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END--><h3><a name="jb2caching_references_to_objects_and_collections"></a>Caching References to Objects and Collections</h3>
<p>
When you refer to an object or a collection more than once, you can improve performance by caching a reference to that object or collection. There are three ways to do this:
<ul>
<li>
By returning a reference to an object or collection and assigning it to an object variable<br><br></li>
<li>
By using the <b>For Each…Next</b> statement when you refer to each object in a collection<br><br></li>
<li>
By using the <b>With</b> statement when you refer to an object and its properties, methods, or collections repeatedly</li>
</ul>
<p>
When you refer to an object or collection more than once in your code, you may want to create an object variable and assign a reference to the object to that object variable. Not only does this make your code faster for lengthy operations, it also makes it easier to read.</p>
<p>
The following two examples both return the names of all tables in a database, all fields in each table, and the names and values of all properties on those fields. The first example, which stores references to objects in object variables, is considerably faster than the second. In these examples, <code>strDbPath</code> is the path to a database:</p>
<pre><FONT FACE="Courier New" SIZE="3">' 1 - Faster, easier to read.
Dim dbs As Database, tdf As TableDef
Dim fld As Field, prp As Property
&#09;
Set dbs = OpenDatabase(strDbPath)
For Each tdf In dbs.TableDefs
&#09;Debug.Print tdf.Name
&#09;For Each fld In tdf.Fields
&#09;&#09;Debug.Print fld.Name
&#09;&#09;For Each prp In fld.Properties
&#09;&#09;&#09;On Error Resume Next
&#09;&#09;&#09;Debug.Print prp.Name, prp.Value
&#09;&#09;Next prp
&#09;Next fld
Next tdf
dbs.Close
Set dbs = Nothing

' 2 - Slower, more cumbersome.
Dim intW As Integer, intX As Integer, intY As Integer
&#09;
OpenDatabase strDbPath
For intW = 0 To DBEngine(0)(0).TableDefs.Count - 1
&#09;Debug.Print DBEngine(0)(0).TableDefs(intW).Name
&#09;For intX = 0 To DBEngine(0)(0).TableDefs(intW).Fields.Count - 1
&#09;&#09;Debug.Print DBEngine(0)(0).TableDefs(intW).Fields(intX).Name
&#09;&#09;For intY = 0 To _
&#09;&#09;&#09;DBEngine(0)(0).TableDefs(intW).Fields(intX).Properties.Count - 1
&#09;&#09;&#09;On Error Resume Next
&#09;&#09;&#09;Debug.Print _
&#09;&#09;&#09;&#09;DBEngine(0)(0).TableDefs(intW).Fields(intX).Properties(intY).Name, _
&#09;&#09;&#09;&#09;DBEngine(0)(0).TableDefs(intW).Fields(intX).Properties(intY).Value
&#09;&#09;Next
&#09;Next
Next</font></pre>
<p>
You can improve performance by using the <b>For Each…Next</b> and <b>With…End With</b> statements. Both of these cache a reference to an object, so that your code doesn’t have to repeatedly retrieve the reference in order to use the object.</p>
<p>
The following example uses both of these statements to print all of the values in a recordset. In this example, <code>strDbPath</code> is the path to a database, and <code>strRstSource</code> is the source for a recordset:</p>
<pre><FONT FACE="Courier New" SIZE="3">Dim dbs As Database, tdf As TableDef
Dim rst As Recordset, fld As Field

Set dbs = OpenDatabase(strDbPath)
Set rst = dbs.OpenRecordset(strRstSource)

With rst
&#09;Do Until .EOF
&#09;&#09;For Each fld In rst.Fields
&#09;&#09;&#09;Debug.Print fld.Name, fld.Value
&#09;&#09;Next fld
&#09;&#09;.MoveNext
&#09;Loop
&#09;Debug.Print
End With
rst.Close
Set rst = Nothing
dbs.Close
Set dbs = Nothing</font></pre>
<p>
The following example uses a <b>For</b> loop rather than the <b>For Each…Next</b> statement, and it refers to the <b>Recordset</b> object variable explicitly each time it’s used rather than caching it with the <b>With</b> statement. The performance differences are not apparent for small recordsets, but become more significant with larger recordsets. When <code>strDbPath</code> is the path to the NorthwindTables database and <code>strRstSource</code> is the Orders table, the following example runs several seconds more slowly than the preceding one:</p>
<pre><FONT FACE="Courier New" SIZE="3">Dim dbs As Database, tdf As TableDef
Dim rst As Recordset, fld As Field
Dim intC As Integer

Set dbs = OpenDatabase(strDbPath)
Set rst = dbs.OpenRecordset(strRstSource)

Do Until rst.EOF
&#09;For intC = 0 To rst.Fields.Count - 1
&#09;&#09;Debug.Print rst.Fields(intC).Name, rst.Fields(intC).Value
&#09;Next
&#09;rst.MoveNext
Loop
Debug.Print
rst.Close
Set rst = Nothing
dbs.Close
Set dbs = Nothing</font></pre>
<p>
Another important consideration for performance is whether or not your object variables are strictly typed. When you strictly type an object variable, you declare the object variable according to the type of object that it will represent. In the following example, the object variables are not strictly typed according to the object type they are to represent. When a variable isn’t typed, Visual Basic automatically designates it as type <b>Variant</b>. This example is otherwise identical to the preceding example, but runs at nearly half the speed for the Orders table in the NorthwindTables database:</p>
<pre><FONT FACE="Courier New" SIZE="3">Dim dbs, tdf
Dim rst, fld
Dim intC

Set dbs = OpenDatabase(strDbPath)
Set rst = dbs.OpenRecordset(strRstSource)

Do Until rst.EOF
&#09;For intC = 0 To rst.Fields.Count - 1
&#09;&#09;Debug.Print rst.Fields(intC).Name, _
&#09;&#09;&#09;rst.Fields(intC).Value
&#09;Next
&#09;rst.MoveNext
Loop
Debug.Print
rst.Close
Set rst = Nothing
dbs.Close
Set dbs = Nothing</font></pre>
</BODY>
</HTML>
