<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Types of Locks</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>

	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END--><h4><a name="jb2types_of_locks"></a>Types of Locks</h4>
<p>
Microsoft Jet uses seven types of locks:
<ul>
<li>
User locks<br><br></li>
<li>
Write locks<br><br></li>
<li>
Read locks<br><br></li>
<li>
Commit locks (version 2<i>.x</i> only)<br><br></li>
<li>
Table-read locks<br><br></li>
<li>
Table-write locks<br><br></li>
<li>
Table deny-write locks</li>
</ul>
<p>
Using the extended byte range locks discussed earlier, these seven types are organized into six virtual regions of the locking information file in Microsoft Jet version 2<i>.x</i>, and five virtual regions in Microsoft Jet versions 3.0 and 3.5. These regions are used by Microsoft Jet to place extended byte range locks that range from 10000001 to 6FF800FFh. These locks are present only when users have the database open in shared or read-only mode.</p>
<h5>User Locks</h5>
<p>
User locks are used for modifying the commit byte values in the database header page (DBH), for writing the computer and user-level security account names in the correct location in the locking information file, and for retrieving the computer names and user-level security account names of users with conflicting locks. A user lock is obtained when the user opens the database and is <i>persistent</i> for as long as a user has the database open. (Persistence in this context indicates the duration of the lock, or how long the lock is held.) Only one user lock exists for each connected user; however, multiple instances of Microsoft Jet on the same computer create an additional user lock per instance.</p>
<p>
User locks are always in the range of 10000001h through 100000FFh and occupy only 1 byte.</p>
<h5>Write Locks</h5>
<p>
Write locks prevent users from changing data while another user is modifying data. A write lock is typically placed on data pages, index pages, or <i>long value pages</i>. Long value pages are a type of data page that contains ANSI SQL data types of CHARACTER VARYING, BIT, or BIT VARYING. These data types are known as Memo or OLE Object fields in Microsoft Access. The persistence of write locks is directly related to the duration of a transaction.</p>
<p>
In Microsoft Jet 2.<i>x</i> and 3.0, all SQL data manipulation language (DML) statements have <i>implicit transactions</i> (transactions automatically defined by Microsoft Jet) placed around them. Therefore, an UPDATE statement holds persistent write locks until the entire update is committed. The persistence of write locks is also determined by the type of locking chosen for recordset navigation and form editing (in Microsoft Access), and the presence of explicit transactions.</p>
<p>
In Microsoft Jet 3.5, SQL DML statements do not have implicit transactions placed around them.</p>
<p>
<b>See Also   </b>For more information about how Microsoft Jet 3.5 handles SQL DML statements, see Chapter&nbsp;13, “<a href="c13_body.htm">Optimizing Performance</a>.”</p>
<p>
Write locks are in the range of 20000000h through 2FF80FFh. They always span between 256 and 512&nbsp;bytes, and therefore are always exclusive locks.</p>
<h5>Read Locks (Microsoft Jet 2.x)</h5>
<p>
You use read locks, a type of shared lock, primarily for the immediate recycling of index pages (when the index page is no longer being used) and for ensuring that index pages in the engine’s cache are up-to-date. This type of lock is placed on long value pages and index pages. It’s used to prevent an index page from being recycled while that page is being referenced in the Microsoft Jet cache and to provide an integral view of the index.</p>
<p>
Read locks are placed in the range of 30000000 to 3FF800FFh. They occupy only 1&nbsp;byte.</p>
<p>
Read locks in version 2<i>.x</i> are perhaps the most troublesome locks to deal with because they can cause locking conflicts that are not obvious to the developer or user. The persistence of read locks is determined by:
<ul>
<li>
The LockedPageTimeout setting, specified in tenths of a second. This setting determines the amount of time the engine retains locks before releasing them. By increasing the LockedPageTimeout setting, read locks are retained for a longer period of time, which reduces the need for Microsoft Jet to re-read data pages into the cache. The LockedPageTimeout is set in the ISAM section of the corresponding .ini file (for example, Msacc20.ini) or in the Windows Registry (the \HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Jet\3.5\Engines\2.x key).<br><br></li>
<li>
The <b>Idle</b> method of the <b>DBEngine</b> object with the <b>dbFreeLocks</b> constant or <b>FreeLocks</b> method. However, these methods don’t always free all read locks when inside a transaction.</li>
</ul>
<p>
Read locks are typically placed when an index or long value page is read and placed in the Microsoft Jet cache. An example would be performing an SQL UPDATE statement on a table that has a primary key.</p>
<p>
<b>See Also   </b>For more information about Microsoft Jet configuration settings, see Appendix&nbsp;C, “<a href="apc_body.htm">Registry Settings</a>.”</p>
<h5>Read Locks (Microsoft Jet 3.0 and 3.5)</h5>
<p>
The primary purpose of read locks in Microsoft Jet 3.0 is to allow multiple users to read long value pages, simultaneously preventing others from writing to those pages. Microsoft Jet 3.0 and 3.5 have reduced the number of read locks placed on index pages, which directly results in greater concurrency and improved performance. Read locks placed on index pages are now placed only when referential integrity is being enforced. In Microsoft Jet 3.0, a read lock is persistent until the user moves to a new record. Thus, a read lock on a long value page remains until the user leaves that record. An exception to this is when a long value page contains data from more than one record of data. In this case, the engine releases the lock on that page. An example of this situation is when several records of Memo data are placed in one long value page.</p>
<p>
Microsoft Jet 3.0 and 3.5 read locks are placed in the same range as write locks: 20000000h through 2FF80FFh. They are differentiated from write locks in that they are shared locks and occupy only 1 byte.</p>
<p>
<b>Important   </b>Read locks are persistent in Microsoft Jet 3.0 until the user moves to a new record. Microsoft Jet 2.<i>x</i> leaves read locks until they time out or until the user uses the <b>Idle</b> method of the <b>DBEngine</b> object with the <b>dbFreeLocks</b> constant or uses the <b>FreeLocks</b> method. These statements are not supported in versions 3.0 and 3.5 unless the user references the DAO&nbsp;2.5/3.0 compatibility type library. For more information about the DAO 2.5/3.0 compatibility type library, see Chapter&nbsp;2, “<a href="c2_body.htm">Introducing Data Access Objects</a>.”</p>
<p>
In Microsoft Jet 3.5, using the <b>Idle</b> method of the <b>DBEngine</b> object without arguments allows Microsoft Jet to perform background tasks that may not be up-to-date because of intense data processing, which releases unneeded read locks. Additionally, you can use the <b>Idle</b> method with the <b>dbRefreshCache</b> constant to force any pending writes to the .mdb file and refresh Microsoft Jet’s cache with the most current data from the .mdb file. For more information about the using the <b>Idle</b> method of the <b>DBEngine</b> object in Microsoft Jet 3.5, see Chapter&nbsp;13, “<a href="c13_body.htm">Optimizing Performance</a>.”</p>
<h5>Commit Locks</h5>
<p>
Commit locks are present only in Microsoft Jet 2<i>.x</i>. They are similar to read locks, except that they are always exclusive locks. These locks are also placed in the 30001A01 to 3FF800FFh range. They are placed when index pages or long value pages are being written to the database file, and they conflict only with read locks. Read locks are typically placed on index pages whenever an index page is placed in the engine’s cache. Because index pages reference many data pages, users can experience locking conflicts even when they know other users are not editing data on the same page.</p>
<p>
One of the best ways to prevent these conflicts when using Microsoft Jet 2.<i>x</i> is to judiciously use the <b>Idle</b> method with the <b>dbFreeLocks</b> constant or the <b>FreeLocks</b> method.</p>
<p>
Commit locks do not exist in Microsoft Jet 3.0 and 3.5 because the range for read locks has been moved into the same range as write locks, thus eliminating the need for this type of lock.</p>
<h5>Table-Read Locks</h5>
<p>
Table-read locks are used to control placing a table in deny-read mode, which prevents other users from reading data from the table. Unlike the previous types of locks, table-read locks and the rest of the table-type locks are placed only on a special type of page called a <i>table header (TBH)</i> page. There is one TBH page for each table in the database, and each TBH page contains statistics about the table, such as record count, next counter value, field data types, and index types.</p>
<p>
Table-read locks are placed in the 40000000 to 4FF800FFh range and can be placed as shared locks or exclusive locks.</p>
<p>
When a table is opened, a shared table-read lock is placed. Deny-read mode is set when a <b>Recordset</b> object is opened through DAO using the <b>dbDenyRead</b> constant for the <i>options</i> argument of the <b>OpenRecordset</b> method. Microsoft Access also places a shared table-read lock on a table when the table is opened in Microsoft Access and the user has clicked <b>All Records</b> under <b>Default Record Locking</b> on the <b>Advanced</b> tab of the <b>Options</b> dialog box (<b>Tools</b> menu). The exclusive table-read lock prevents other users from acquiring shared locks when they try to open a table. The table-read locks are persistent until the user closes the table.</p>
<h5>Table-Write Locks</h5>
<p>
Table-write locks are used in conjunction with table deny-write locks and are placed in the 50000000 to 5FF800FFh range. These shared locks are persistent whenever a table is opened in a state that allows writing.</p>
<h5>Table Deny-Write Locks</h5>
<p>
These locks are used in conjunction with table-write locks and are explicitly set when opening a table in deny-write mode. These locks are placed in the 60000000 to 6FF800FFh range and have a persistent shared lock while a table is open in deny-write mode. An exclusive lock is placed, but not held, to determine which other users have the table opened in deny-write mode.</p>
</BODY>
</HTML>
