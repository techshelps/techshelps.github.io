<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Appendix B SQL Reference</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>

	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END--><h1><a name="jb2sql_reference"></a>Appendix B SQL Reference</h1>
<p>The following SQL statements define the Microsoft Jet SQL grammar, using the Backus-Naur Form (BNF).</p>
<p>This BNF follows the notation standards used by the American National Standards Institute (ANSI) in defining standard X.135-1992 (ANSI-SQL 92).</p>
<table>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<b>Symbol</b></font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<b>Meaning</b></font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
&lt;&gt;</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Angle brackets delimit character strings that are the names of syntactic elements.</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
::=</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Definition operator. Used in a production rule to separate the elements defined by the rule from its definition. &lt;defined_element&gt; ::= &lt;definition&gt;</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
{}</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Grouping delimiter. The portion of the formula within the braces is explicitly specified.</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
[]</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Optional elements delimiter. The portion of the formula within the brackets can be explicitly specified or it can be omitted.</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
|</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Alternative operator. The vertical bar indicates that the portion of the formula following the bar is an alternative to the portion preceding the bar. If the vertical bar appears at a position where it is not enclosed in braces or square brackets, it specifies a complete alternative for the element defined by the production rule. If the vertical bar appears in a portion of a formula enclosed in braces or square brackets, it specifies alternatives for the contents of the innermost pair of braces or brackets.</font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
...</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
Repeat indicator. The ellipsis indicates that the element to which it applies in a formula can be repeated any number of times. </font></td>
</tr>
<tr valign=top>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
!!</font></td>
<td><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
English text. Defines a syntactic element without the benefit of BNF notation.</font></td>
</tr>
</table><br>
<pre><FONT FACE="Courier New" SIZE="2">&lt;SQL-language-character&gt; ::=
      &lt;SQL-alpha-numeric-character&gt;
    | &lt;SQL-special-characters&gt;

&lt;SQL-alpha-numeric-character&gt; ::=
      &lt;lower-case-letter&gt;
    | &lt;upper-case-letter&gt;
    | &lt;digit&gt;

&lt;lower-case-letter&gt; ::= [a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z]

&lt;upper-case-letter&gt; ::= [A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z]

&lt;digit&gt; ::= [0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9]

&lt;SQL-special-characters&gt; ::=
    &lt;space&gt;
  | &lt;tab&gt;
  | &lt;newline&gt;
  | &lt;carriage-return&gt;
  | &lt;form-feed&gt;
  | &lt;double-quote&gt;
  | &lt;percent&gt;
  | &lt;ampersand&gt;
  | &lt;quote&gt;
  | &lt;asterisk&gt;
  | &lt;plus-sign&gt;
  | &lt;minus-sign&gt;
  | &lt;back-slash&gt;
  | &lt;solidus&gt;
  | &lt;colon&gt;
  | &lt;semicolon&gt;
  | &lt;less-than-character&gt;
  | &lt;equals-character&gt;
  | &lt;greater-than-character&gt;
  | &lt;question-mark&gt;
  | &lt;underscore&gt;
  | &lt;number-sign&gt;

&lt;space&gt; ::= !! space character

&lt;tab&gt; ::= !! tab character

&lt;newline&gt;  ::= !! newline character

&lt;carriage-return&gt; ::= !! carriage-return character

&lt;form-feed&gt; ::= !! form-feed character
&lt;double-quote&gt; ::= &quot;

&lt;back-quote&gt; ::= `

&lt;percent&gt; ::= %

&lt;ampersand&gt; ::= &amp;

&lt;quote&gt; ::= '

&lt;left-paren&gt; ::= (

&lt;right-paren&gt; ::= )

&lt;asterisk&gt; ::= *

&lt;plus-sign&gt; ::= +

&lt;comma&gt; ::= ,

&lt;minus sign&gt; ::= -

&lt;period&gt; ::= .

&lt;back-slash&gt; ::= \

&lt;solidus&gt; ::= /

&lt;colon&gt; ::= :

&lt;semicolon&gt; ::= ;

&lt;less-than-character&gt; ::= &lt;

&lt;equals-character&gt; ::= =

&lt;greater-than-character&gt; ::= &gt;

&lt;question-mark&gt; ::= ?

&lt;underscore&gt; ::= _

&lt;vertical-bar&gt; ::= |

&lt;left-bracket&gt; ::= [

&lt;right-bracket&gt; ::= ]

&lt;number-sign&gt; ::= #

&lt;whitespace&gt; ::= 
    &lt;space&gt;
  | &lt;tab&gt;
  | &lt;newline&gt;
  | &lt;carriage-return&gt;
  | &lt;form-feed&gt;

&lt;key-word&gt; ::=
    ALL | ANY | AS | ASC | AUTOINCREMENT | AVG 
  | BETWEEN | BINARY | BOOLEAN | BY | BYTE 
  | CHAR[ACTER] | COUNT | COUNTER | CURRENCY 
  | DATABASE | DATABASENAME | DATE | DATETIME | DELETE | DESC | DISTINCT | DISTINCTROW
  | DOUBLE
  | EXISTS 
  | FIRST | FLOAT | FROM 
  | GROUP 
  | HAVING 
  | IN | INNER | INSERT | INT | INTEGER | INTO 
  | JOIN 
  | LAST | LEFT | LEVEL | LIKE | LONG | LONGBINARY | LONGTEXT 
  | MAX | MIN 
  | NOT | NULL 
  | OLEOBJECT | ON | OPTION | ORDER | OUTER | OWNERACCESS 
  | PARAMETERS | PERCENT | PIVOT | PROCEDURE 
  | REAL | RIGHT 
  | SELECT | SET | SHORT | SINGLE | SMALLINT | SOME | STDEV | STDEVP | SUM 
  | TABLEID | TIMESTAMP | TEXT | TOP | TRANSFORM 
  | UPDATE 
  | VALUES | VAR | VARBINARY | VARCHAR | VARP 
  | WHERE | WITH 
  | YESNO

&lt;token&gt; ::=
    &lt;literal&gt; 
  | &lt;comparison-operator&gt; 
  | &lt;special-symbol&gt; 
  | &lt;identifier&gt; 
  | &lt;key-word&gt;

&lt;special-symbol&gt; ::=
    &lt;left-paren&gt;
  | &lt;right-paren&gt;
  | &lt;comma&gt;
  | &lt;period&gt;
  | &lt;colon&gt;
  | &lt;semicolon&gt;
  | &lt;equals-operator&gt;
  | &lt;asterisk&gt;
  | &lt;left-bracket&gt;
  | &lt;right-bracket&gt;
&lt;identifier&gt; ::= 
  &lt;SQL-alpha-numeric-character&gt; [&lt;SQL-language-character&gt;...]
  !! Note: Can include up to 64 characters.

&lt;identifier-delimiter&gt; ::=
    &lt;left-id-delim&gt;
  | &lt;right-id-delim&gt;

&lt;left-id-delim&gt; ::= !! Left identifier delimiter
    &lt;back-quote&gt;
  | &lt;left-bracket&gt;

&lt;right-id-delim&gt; ::= !! Right identifier delimiter
    &lt;back-quote&gt;
  | &lt;right-bracket&gt;

&lt;scalar-expression&gt; ::=
    &lt;numeric-scalar-expression&gt; 
  | &lt;character-string-literal&gt;

&lt;numeric-scalar-expression&gt; ::=
    &lt;term&gt; 
  | &lt;numeric-scalar-expression&gt; [&lt;plus-operator&gt; | &lt;minus-operator&gt;] &lt;term&gt;

&lt;term&gt; ::=
    &lt;factor&gt; 
  | &lt;term&gt; [&lt;multiplication-operator&gt; | &lt;divides-operator&gt;] &lt;factor&gt;

&lt;factor&gt; ::= [&lt;plus-operator&gt; | &lt;minus-operator&gt;]&lt;primary&gt;

&lt;primary&gt; ::= 
    &lt;atom&gt; 
  | &lt;column-reference&gt; 
  | &lt;function-reference&gt; 
  | &lt;left-paren&gt;&lt;scalar-expression&gt;&lt;right-paren&gt;

&lt;atom&gt; ::= 
    &lt;literal&gt; 
  | &lt;parameter-name&gt;

&lt;literal&gt; ::= 
    &lt;character-string-literal&gt; 
  | &lt;numeric-literal&gt; 
  | &lt;boolean-literal&gt; 
  | &lt;datetime-literal&gt; 
  | NULL

&lt;character-string-literal&gt; ::= {&lt;single-quote&gt; | &lt;double-quote&gt;} &lt;char-list&gt; {&lt;single-quote&gt; | &lt;double-quote&gt;}  !! Note that the leading and trailing delimiter must be the same.  Embedded delimiters must be doubled as in Visual Basic.
&lt;numeric-literal&gt; ::=
    &lt;exact-numeric-literal&gt; 
  | &lt;approximate-numeric-literal&gt;

&lt;exact-numeric-literal&gt; ::= &#09;
    &lt;signed-integer&gt;[&lt;period&gt;&lt;unsigned-integer&gt;] 
  |&lt;period&gt;&lt;unsigned-integer&gt;

&lt;approximate-numeric-literal&gt; ::= 
  &lt;exact-numeric-literal&gt;{E|e}&lt;signed-integer&gt;

&lt;signed-integer&gt; ::= 
  [&lt;plus-sign&gt; | &lt;minus-sign&gt;]&lt;unsigned-integer&gt;

&lt;unsigned-integer&gt; ::= &lt;digit&gt; ...

&lt;boolean-literal&gt; ::= {TRUE | FALSE | YES | NO | ON | OFF}

&lt;datetime-literal&gt; ::= &lt;number-sign&gt;&lt;date-time-text&gt;&lt;number-sign&gt;

&lt;date-time-text&gt; ::= !! any literal that can be parsed as a valid date/time by the
expression service

&lt;table-name&gt; ::=
    &lt;base-table-name&gt; 
  | &lt;query-name&gt; 
  | &lt;link-name&gt;

&lt;base-table-name&gt; ::= &lt;identifier&gt;

&lt;query-name&gt; ::= &lt;identifier&gt;

&lt;link-name&gt; ::= &lt;identifier&gt;

&lt;qualified-table-name&gt; ::= [[ &lt;connect-string&gt; &lt;period&gt; ] &lt;database-name&gt; &lt;period&gt;]
  &lt;table-name&gt;

&lt;connect-string&gt; ::= &lt;identifier&gt; !!&lt;connect-string&gt; specifies the data source to look for the given &lt;database-name&gt; in.  If the connect string starts with the name of a Microsoft Jet data provider followed by a semicolon, then the given database is opened using that data provider.  If the data provider is missing, or if it is &quot;ODBC&quot;, then the rest of the connect string is interpreted as an ODBC connect string.  In this case, a DSN field is added to the connect string containing the &lt;database-name&gt;.  If a DSN field had previously existed, it is replaced with this new DSN field.

&lt;column-reference&gt; ::= &lt;identifier&gt;

&lt;column-reference-list&gt; ::= &lt;column-reference&gt; [&lt;comma&gt; &lt;column-reference&gt; ...]

&lt;constraint-name&gt; ::= &lt;identifier&gt;
&lt;index-name&gt; ::= &lt;identifier&gt;

&lt;database-name&gt; ::= &lt;identifier&gt;

&lt;manipulation-statement&gt; ::=  [&lt;parameter-declaration&gt; &lt;semicolon&gt;] &lt;data-manipulation-language-statement&gt; &lt;semicolon&gt;  
!! Note: Microsoft Jet SQL data manipulation statements consist of an optional &lt;parameter-declaration&gt; followed by a single &lt;data-manipulation-language-statement&gt;.  Manipulation statements define stored or temporary query objects in Microsoft Jet.  Note that subqueries are not supported and similar functionality may be used by using one query as the input to another.

&lt;parameter-declaration&gt; ::= PARAMETERS &lt;parameter-definition-list&gt;

&lt;parameter-definition-list&gt; ::= &lt;parameter-definition&gt; [{&lt;comma&gt; &lt;parameter-definition&gt;} ...]

&lt;parameter-definition&gt; ::= &lt;parameter-name&gt; &lt;parameter-datatype&gt;

&lt;parameter-name&gt; ::= &lt;identifier&gt;

&lt;parameter-datatype&gt; ::= 
    &lt;Jet-parameter-datatype-name&gt; 
  | &lt;ANSI-SQL-parameter-datatype-name&gt;

&lt;Jet-parameter-datatype-name&gt; ::=
    BOOLEAN 
  | BYTE &lt;left-paren&gt; &lt;length&gt; &lt;right-paren&gt; 
  | SHORT 
  | LONG 
  | CURRENCY 
  | SINGLE 
  | DOUBLE 
  | DATETIME 
  | TEXT &lt;left-paren&gt; &lt;length&gt; &lt;right-paren&gt; 
  | BINARY 
  | LONGTEXT &lt;left-paren&gt; &lt;length&gt; &lt;right-paren&gt; 
  | LONGBINARY 
  | DATABASE 
  | TABLEID 
  | OLEOBJECT 
  | YESNO

&lt;ANSI-SQL-parameter-datatype-name&gt; ::= 
    SMALLINT 
  | INT[EGER] 
  | REAL 
  | FLOAT 
  | CHAR[ACTER] &lt;left-paren&gt; &lt;length&gt; &lt;right-paren&gt; 
  | VARCHAR &lt;left-paren&gt; &lt;length&gt; &lt;right-paren&gt;
&lt;data-definition-language-statement&gt; ::= 
    &lt;table-definition&gt;
  | &lt;alter-table-statement&gt;
  | &lt;drop-table-statement&gt;
  | &lt;index-definition&gt;
  | &lt;drop-index-statement&gt;

&lt;alter-table-statement&gt;  ::=
  ALTER TABLE &lt;base-table-name&gt;
  {ADD
    {COLUMN &lt;column-reference&gt;&gt; &lt;parameter-datatype&gt;[CONSTRAINT &lt;field-constraint&gt;]
  | CONSTRAINT &lt;table-constraint&gt; }
  | DROP {COLUMN &lt;column-reference&gt; | CONSTRAINT &lt;constraint-name&gt; }}

&lt;index-definition&gt;  ::= 
  CREATE  [ UNIQUE ] INDEX &lt;index-name&gt;
  ON &lt;base-table-name&gt; &lt;left-paren&gt; &lt;column-reference&gt; 
  [ASC|DESC][{&lt;comma&gt; &lt;column-reference&gt; [ASC|DESC]} ...] &lt;right-paren&gt;
  [WITH { PRIMARY | DISALLOW NULL | IGNORE NULL }]

&lt;table-definition&gt;  :==
  CREATE TABLE &lt;base-table-name&gt; 
  &lt;left-paren&gt; {&lt;column-reference&gt; &lt;parameter-datatype&gt;
   [CONSTRAINT &lt;field-constraint&gt;]}
  [{&lt;comma&gt; &lt;column-reference&gt; &lt;parameter-datatype&gt; 
  [CONSTRAINT &lt;field-constraint&gt;]}...]]]&lt;right-paren&gt;

&lt;drop-table-statement&gt;  ::=
  DROP TABLE &lt;base-table-name&gt; 

&lt;drop-index-statement&gt;  ::= 
  DROP  INDEX &lt;index-name&gt; ON &lt;base-table-name&gt; 

&lt;column-constraint-definition&gt; ::= &lt;constraint-name-definition&gt;
  &lt;column-constraint&gt;

&lt;column-constraint&gt; ::= &lt;unique-specification&gt; |
  &lt;references-specification&gt;

&lt;constraint-name-definition&gt; ::= CONSTRAINT &lt;constraint-name&gt;

&lt;table-constraint-definition&gt; ::= &lt;constraint-name-definition&gt;
  &lt;table-constraint&gt;

&lt;table-constraint&gt; ::=
    &lt;unique-constraint-definition&gt;
  | &lt;referential-constraint-definition&gt;

&lt;unique-constraint-definition&gt; ::=
  &lt;unique-specification&gt; &lt;left-paren&gt; &lt;column-reference-list&gt; &lt;right-paren&gt;
&lt;unique-specification&gt; ::= UNIQUE | PRIMARY KEY

&lt;referential-constraint-definition&gt; ::=
  FOREIGN KEY &lt;left-paren&gt; &lt;referencing-columns&gt; &lt;right-paren&gt;
  &lt;references-specification&gt;

&lt;references-specification&gt; ::=
  REFERENCES &lt;referenced-table-and-columns&gt;

&lt;referencing-columns&gt; ::= &lt;column-reference-list&gt;

&lt;referenced-table-and-columns&gt; ::= &lt;table-name&gt;
  &lt;left-paren&gt; &lt;reference-column-list&gt; &lt;right-paren&gt; 

&lt;reference-column-list&gt; ::= &lt;column-reference-list&gt;

&lt;data-manipulation-language-statement&gt;  :==
  &lt;delete-statement&gt;
  | &lt;insert-statement&gt;
  | &lt;select-statement&gt;
  | &lt;select-into-statement&gt;
  | &lt;transform-statement&gt; 
  | &lt;update-statement&gt;

&lt;delete-statement&gt; ::= DELETE &lt;from-clause&gt; [where-clause]

&lt;insert-statement&gt; ::=
  INSERT INTO &lt;table-name&gt; [IN external-database] &lt;insert-columns-and-source&gt;

&lt;insert-columns-and-source&gt; ::= 
  {&lt;left-paren&gt; &lt;column-reference-list&gt; &lt;right-paren&gt;}  {SELECT &lt;column-reference-list&gt; 
  FROM &lt;table-expression&gt; 
  | VALUES &lt;left-paren&gt;&lt;scalar-expression-list&gt;&lt;right-paren&gt;}

&lt;select-statement&gt; ::=
  SELECT &lt;set-quantifier&gt; &lt;select list&gt; &lt;table expression&gt;

&lt;table-expression&gt; ::= &#09;&lt;from-clause&gt;
  [&lt;where-clause&gt;]
  [&lt;group-by-clause&gt;]
  [&lt;having-clause&gt;]
  [&lt;order-by-clause&gt;]
  [&lt;with-owneraccess-clause]

&lt;select-list&gt; ::= 
    &lt;asterisk&gt; 
  | &lt;select-sublist&gt; [{&lt;comma&gt; &lt;select-sublist&gt;}...]

&lt;select-sublist&gt; ::= 
    &lt;column-qualifier&gt;&lt;period&gt;&lt;asterisk&gt; 
  | &lt;scalar-expression&gt; [AS &lt;column-reference&gt;]
&lt;from-clause&gt; ::= FROM &lt;table-reference-list&gt;

&lt;table-reference-list&gt; ::= 
  &lt;table-reference&gt; [{&lt;comma&gt; &lt;table-reference&gt;}...] [&lt;in-clause&gt;]

&lt;table-reference&gt; ::= 
  {&lt;from-table-name&gt; [AS &lt;correlation-name&gt;]} | &lt;joined-table&gt;

&lt;from-table-name&gt; ::= 
    &lt;table-name&gt; 
  | &lt;tableid-parameter&gt;

&lt;tableid-parameter&gt; ::= &lt;parameter&gt; &lt;identifier&gt; of type TABLEID

&lt;in-clause&gt; ::=  
  IN
    &lt;filename-path&gt;&#09;&#09;!! For local, Jet-native databases
  | {&lt;left-id-delim&gt;&lt;filename-path&gt;&lt;right-id-delim&gt; &lt;left-id-delim&gt;&lt;database-name&gt;&lt;right-id-delim&gt;}

&lt;filename-path&gt; ::= !! as defined by operating system

&lt;joined-table&gt; ::= 
  &lt;table-reference&gt; [ &lt;join-type&gt; ] JOIN &lt;table-reference&gt; ON &lt;search-condition&gt;

&lt;join-type&gt; ::=
    INNER 
  | LEFT 
  | RIGHT

&lt;where-clause&gt; ::= WHERE &lt;search-condition&gt;

&lt;search-condition&gt; ::=
    &lt;boolean-term&gt;
  | &lt;search-condition&gt; OR &lt;boolean-term&gt;

&lt;boolean-term&gt; ::= 
    &lt;boolean-factor&gt; 
  | &lt;boolean-term&gt; AND &lt;boolean-factor&gt;

&lt;boolean-factor&gt; ::= [ NOT ] &lt;boolean-primary&gt;

&lt;boolean-primary&gt; ::= 
    &lt;predicate&gt; 
  | &lt;left-paren&gt;&lt;search-condition&gt;&lt;right-paren&gt;

&lt;predicate&gt; ::=
    &lt;comparison-predicate&gt;
  | &lt;between-predicate&gt; 
  | &lt;in-predicate&gt; 
  | &lt;like-predicate&gt; 
  | &lt;null-predicate&gt;

&lt;comparison-predicate&gt; ::=
  &lt;scalar-expression&gt;&lt;comparison-operator&gt;&lt;scalar-expression&gt;

&lt;between-predicate&gt; ::=
  &lt;scalar-expression&gt; [NOT] BETWEEN &lt;scalar-expression&gt; AND &lt;scalar-expression&gt;
  !! The BETWEEN predicate y BETWEEN x AND z is semantically equivalent to (x &lt;= y AND y &lt;= z) OR (z &lt;= y AND y &lt;= x).

&lt;in-predicate&gt; ::= 
  &lt;scalar-expression&gt; [NOT] IN &lt;left-paren&gt; &lt;scalar-expression-list&gt; &lt;right-paren&gt;

&lt;scalar-expression-list&gt; ::= &lt;scalar-expression&gt; [{&lt;comma&gt; &lt;scalar-expression&gt;}...]

&lt;like-predicate&gt; ::= &lt;scalar-expression&gt; [NOT] LIKE 
    &lt;scalar-expression&gt;
  | &lt;pattern&gt;

&lt;pattern&gt; ::= 
    &lt;left-bracket&gt; &lt;char-list&gt; &lt;right-bracket&gt;  
    !! matches any single character in &lt;char-list&gt;
  | &lt;left-bracket&gt; &lt;bang&gt; &lt;char-list&gt; &lt;right-bracket&gt;  
    !! matches any single character not in &lt;char-list&gt;
  | &lt;left-bracket&gt; &lt;char-range&gt; &lt;right-bracket&gt;  
    !! matches any single character in &lt;char-range&gt;
  | &lt;left-bracket&gt; &lt;bang&gt; &lt;char-range&gt; &lt;right-bracket&gt; 
    !! matches any single character not in &lt;char-range&gt;

&lt;pattern-matching-character&gt; ::=
    &lt;question-mark&gt;  !! matches any single &lt;SQL-alphabetic-character&gt;
  | &lt;pound-sign&gt;  !! matches any single &lt;digit&gt;
  | &lt;asterisk&gt;  !! matches any sequence of zero or more &lt;SQL-alphabetic characters&gt;

&lt;dash&gt; ::= -

&lt;escape-character&gt; ::= ^

&lt;bang&gt; ::= !
&lt;char-list&gt; ::= 
    &lt;SQL-alpha-numeric-character&gt;
  | {&lt;escape-character&gt; &lt;special-symbol&gt;} 
    [[&lt;SQL-alpha-numeric-character&gt;
  | {&lt;escape-character&gt; &lt;special-symbol&gt;}] ...]

&lt;char-range&gt; ::= 
  &lt;SQL-alpha-numeric-character&gt; &lt;dash&gt; &lt;SQL-alpha-numeric-character&gt;  
  !! Where the first &lt;SQL-alpha-numeric-character&gt; has lower ordinal value than the
  !! second &lt;SQL-alpha-numeric-character&gt;

&lt;null-predicate&gt; ::= &lt;scalar-expression&gt; IS [NOT] NULL

&lt;group-by-clause&gt; ::= GROUP BY &lt;grouping-specification-list&gt;

&lt;grouping-specification-list&gt; ::= &lt;grouping-specification&gt;[{&lt;comma&gt; &lt;grouping-specification&gt;}...]

&lt;grouping-specification&gt; ::= 
    &lt;column-reference&gt; 
  | &lt;scalar-expression&gt;

&lt;having-clause&gt; ::= HAVING &lt;search-condition&gt;

&lt;order-by-clause&gt; ::= ORDER BY &lt;sort-specification-list&gt;

&lt;sort-specification-list&gt; ::= 
  &lt;sort-specification&gt; [{&lt;comma&gt; &lt;sort-specification&gt;}...]

&lt;sort-specification&gt; ::= 
  &lt;scalar-expression&gt; [ASC | DESC]

&lt;select-into-statement&gt;  ::=
  SELECT &lt;set-quantifier&gt; &lt;reference-column-list&gt;INTO &lt;base-table-name&gt; [in-clause]
   &lt;table-expression&gt;

&lt;transform-statement&gt; ::=
  TRANSFORM &lt;aggregate-function&gt; &lt;select-statement&gt; PIVOT &lt;pivot-field&gt;
  [IN &lt;left-paren&gt; &lt;scalar-expression&gt; [{&lt;comma&gt; &lt;scalar-expression&gt;}...]&lt;right-paren&gt;]

&lt;union-clause&gt; ::= 
  &lt;tabular-data&gt; UNION [ALL] &lt;tabular-data&gt; [{UNION [ ALL ] &lt;tabular-data&gt;}  ...]

&lt;update-statement&gt; ::=
  UPDATE &lt;table-reference-list&gt; SET &lt;set-clause-list&gt; [&lt;where-clause&gt;]

&lt;set-clause-list&gt; ::= &lt;set-clause&gt; [{&lt;comma&gt; &lt;set-clause&gt;}...]

&lt;set-clause&gt; ::=
  &lt;column-reference&gt; &lt;equals-operator&gt; 
    {&lt;scalar-expression&gt; 
  | NULL}

&lt;aggregate-reference&gt;::=
    {Avg 
  | Count 
  | First 
  | Last 
  | Min 
  | Max 
  | StDev 
  | StDevP 
  | Sum 
  | Var 
  | VarP} &lt;left-paren&gt;&lt;scalar-expression&gt;&lt;right-paren&gt;

&lt;comparison-operator&gt; ::=
    &lt;equals-operator&gt; 
  | &lt;greater-than-operator&gt; 
  | &lt;less-than-operator&gt; 
  | &lt;greater-than-or-equals-to-operator&gt; 
  | &lt;less-than-or-equals-to-operator&gt;
  | &lt;not-equals-operator&gt;

&lt;less-than-operator&gt; ::= &lt;less-than-character&gt;

&lt;greater-than-operator&gt; ::= &lt;greater-than-character&gt;

&lt;equals-operator&gt; ::= &lt;equals-character&gt;

&lt;greater-than-or-equals-to-operator&gt; :== &lt;greater-than-operator&gt; &lt;equals-operator&gt;

&lt;less-than-or-equals-to-operator&gt; ::= &lt;less-than-operator&gt; &lt;equals-operator&gt;

&lt;not-equals-operator&gt; ::= &lt;bang&gt; &lt;equals-operator&gt;

&lt;plus-operator&gt; ::= &lt;plus-sign&gt;

&lt;minus-operator&gt; ::= &lt;minus-sign&gt;

&lt;database-type&gt; ::=  
    {dBASE III
  | dBASE IV
  | Paradox 3.x
  | Paradox 4.x
  | Btrieve
  | FoxPro 2.5
  | Excel 3.0
  | Excel&nbsp;4.0
  | Excel&nbsp;5.0
  | ODBC
  }&lt;semicolon&gt;

&lt;pivot-field&gt; ::= &lt;identifier&gt;

&lt;set-quantifier&gt; ::= 
    ALL 
  | DISTINCT 
  | {TOP &lt;unsigned-integer&gt; [PERCENT]}

&lt;tabular-data&gt; ::=
    &lt;select-statement&gt; 
  | &lt;stored-query&gt; 
  | TABLE &lt;base_table_name&gt;</font></pre>
</BODY>
</HTML>
