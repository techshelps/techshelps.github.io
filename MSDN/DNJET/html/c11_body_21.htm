<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using the dbDAO GetRows Method</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>

	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END--><h4><a name="jb2using_the_dbdao_getrows_method"></a>Using the dbDAO GetRows Method</h4>
<p>
The <b>GetRows</b> method takes one parameter specifying the number of records to fetch, and returns the data as variants. Unlike Visual Basic, you cannot simply use subscripts to indicate the array field in a variant. Rather, the data is returned as an OLE <b>SafeArray</b>. The <i>parray</i> member of the variant points to an array descriptor. Individual fields are accessed by calling the <b>SafeArrayGetElement</b> function.</p>
<p>
<b>See Also   </b>For more information about using the <b>SafeArray</b> data type, see the <i>OLE Automation Programmer’s Reference</i> published by Microsoft Press.</p>
<p>
The following code from the GetRows sample (found in the \Samples\GetRows folder of the DAOSDK installation) shows how to use the <b>GetRows</b> method. Note that the table schema is known <i>a priori</i>, allowing you to hard-code the display functions.</p>
<pre><FONT FACE="Courier New" SIZE="3">void CGetRowsDlg::DoGetRows() 
{
&#09;COleVariant&#09;&#09;cRows;
&#09;COleVariant&#09;&#09;varField;
&#09;CString&#09;&#09;&#09;strLBRow;
&#09;TCHAR&#09;&#09;&#09;szId[32];
&#09;LONG&#09;&#09;&#09;lNumRecords;
&#09;LONG&#09;&#09;&#09;lIndex[2];
&#09;HRESULT&#09;&#09;&#09;hResult;
&#09;CListBox&#09;&#09;*pListBox = (CListBox *)GetDlgItem(IDD_GETROWSLIST);

&#09;//Perform GetRows on Employee table.
&#09;//This GetRows uses VARIANTS.
&#09;cRows = m_cEmpRecordSet.GetRows(MAX_EMP_REC); //Arbitrarily get MAX_EMP_REC rows.

&#09;//Find out how many records were actually retrieved.
&#09;//(SafeArrays are 1-based.)
&#09;SafeArrayGetUBound(cRows.parray, 2, &amp;lNumRecords);

&#09;//Clear the list box.
&#09;pListBox-&gt;ResetContent();
&#09;
&#09;for (lIndex[1] = 0; lIndex[1] &lt;= lNumRecords; lIndex[1]++)
&#09;&#09;{
&#09;&#09;strLBRow.Empty();//Clear the string.

&#09;&#09;lIndex[0] = EMP_ID;
&#09;&#09;&#09;
&#09;&#09;//Use OLE safe array function to access fields.
&#09;&#09;hResult = SafeArrayGetElement(cRows.parray, &amp;lIndex[0], &amp;varField);

&#09;&#09;//Watch out for bad variants.
&#09;&#09;if(FAILED(hResult))
&#09;&#09;&#09;break;

&#09;&#09;if(varField.vt == VT_I4) //Must be a long.
&#09;&#09;&#09;{
&#09;&#09;&#09;wsprintf(szId, _T(&quot;%d,  &quot;), varField.iVal);
&#09;&#09;&#09;}
&#09;&#09;else
&#09;&#09;&#09;{
&#09;&#09;&#09;lstrcpy(szId, _T(&quot;Unexpected Data Type&quot;));
&#09;&#09;&#09;}

&#09;&#09;strLBRow += (LPCTSTR)szId;

&#09;&#09;//Get last name.
&#09;&#09;lIndex[0] = EMP_LNAME;
&#09;&#09;SafeArrayGetElement(cRows.parray, &amp;lIndex[0], &amp;varField);
&#09;&#09;strLBRow += (LPCTSTR)varField.bstrVal;

&#09;&#09;//Get first name.
&#09;&#09;strLBRow += _T(&quot;, &quot;);
&#09;&#09;lIndex[0] = EMP_FNAME;
&#09;&#09;SafeArrayGetElement(cRows.parray, &amp;lIndex[0], &amp;varField);
&#09;&#09;strLBRow += (LPCTSTR)varField.bstrVal;

&#09;&#09;pListBox-&gt;AddString(strLBRow);
&#09;&#09;}
}</font></pre>
</BODY>
</HTML>
