<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IFilter::GetChunk</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_idxs_ifilter_getchunk"></a>IFilter::GetChunk</h2>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<pre><code>SCODE IFilter::GetChunk( STAT_CHUNK * pStat );
 </code></pre>
<p>
GetChunk positions the filter at the beginning of the next chunk and returns a description of the chunk in <i>pStat</i>. After this call, the chunk described in <i>pStat</i> is the <i>current chunk</i>. The chunk descriptor is owned by the caller, but the property name pointer which may be set in the property specification is owned by the callee and should <b>not</b> be freed. Several operations (see below) can only be applied to the current chunk. Before GetChunk. has been called for the first time, there is no current chunk. When the current chunk is the last chunk, additional call(s) to GetChunk return FILTER_E_END_OF_CHUNKS. If the next chunk is an embedding for which a filter is not available, this call returns FILTER_E_EMBEDDING_UNAVAILABLE. If the next chunk is in an unavailable link, this call returns FILTER_E_LINK_UNAVAILABLE. Access failure may also be reported with FILTER_E_PASSWORD and FILTER_E_ACCESS. After an error return code of anything other than FILTER_E_END_OF_CHUNKS the next call to IFilter still fetches the next chunk after the unavailable one.</p>
<p>
A description of the active chunk is placed in *<i>pStat</i>. This structure is defined as follows:</p>
<pre><code>typedef enum tagCHUNKSTATE
{
    CHUNK_TEXT       = 0x1,
    CHUNK_VALUE      = 0x2
} CHUNKSTATE;
 
typedef enum tagCHUNK_BREAKTYPE
{
    CHUNK_NO_BREAK = 0,
    CHUNK_EOW      = 1,
    CHUNK_EOS      = 2,
    CHUNK_EOP      = 3,
    CHUNK_EOC      = 4
} CHUNK_BREAKTYPE;
 
typedef tagSTAT_CHUNK
{
    ULONG              idChunk;
    CHUNK_BREAKTYPE    breakType;
    CHUNKSTATE         flags;
    LCID               locale;
    FULLPROPSPEC       attribute;
    ULONG              idChunkSource;
    ULONG              cwcStartSource;
    ULONG              cwcLenSource;
} STAT_CHUNK;
 </code></pre>
<p>
The chunk identifier for this chunk is returned in <i>idChunk</i>. It must be unique from every other chunk identifier returned by GetChunk during a single instantiation of IFilter. Chunk identifiers must be in increasing order. The order in which chunks are returned should correspond to the order of their text in the source document. Some search engines may take advantage of the inter-attribute proximity exposed between chunks of various attributes.</p>
<p>
The <i>breakType</i> field contains the type of break that precedes this chunk. These are defined as follows:
<dl>
<dt>
CHUNK_NO_BREAK</dt>
<dd>
This means that there is no break placed between this chunk and the previous chunk — the chunks are glued together. All of the information in <i>pStat</i> except for <i>breakType</i> and <i>idChunk</i> are taken from the most recent STAT_CHUNK that did not specify CHUNK_NO_BREAK. The other fields in <i>pStat</i> are not modified. On exit, they contain whatever value was in them on entry to GetChunk. Derived chunks cannot be glued using CHUNK_NO_BREAK. A single word cannot span more than two glued chunks.</dd>
<dt>
CHUNK_EOW</dt>
<dd>
This means that there is a word break placed between this chunk and the previous chunk that had the same attribute. Use of CHUNK_EOW should be minimized.
<p>
Clients of IFilter may choose a word breaking algorithm that is in conflict with CHUNK_EOW decisions made in an IFilter implementation. A content query returns optimal results when the word breaking algorithm used to split phrases in the user's query matches the algorithm used to split words in the documents. The former is always provided by the search engine. The search engine algorithm is also used to split words within a chunk, but many small chunks separated by CHUNK_EOW may affect its accuracy.
</dd>
<dt>
CHUNK_EOS</dt>
<dd>
This means that there is a sentence break placed between this chunk and the previous chunk that had the same attribute.</dd>
<dt>
CHUNK_EOP</dt>
<dd>
This means that there is a paragraph break placed between this chunk and the previous chunk that had the same attribute.</dd>
<dt>
CHUNK_EOC</dt>
<dd>
This means that there is a chapter break placed between this chunk and the previous chunk that had the same attribute.
</dd>
</dl>
<p>
A change in attribute implies a word, sentence, paragraph or chapter break.</p>
<p>
The <i>flags</i> field indicates whether this chunk should be treated as text (for example, a sequence of words) or value. If <i>flags</i> is CHUNK_TEXT then IFilter::GetText should be used to retrieve the contents of the chunk and parse it as a series of words. If <i>flags</i> is CHUNK_VALUE then IFilter::GetValue should be used to retrieve the value and treat it as a single property value. If the filter wishes the same text to be treated as both text and value it should be emitted twice in two different chunks.</p>
<p>
The <i>locale</i> field specifies the language and sub-language of this text. Chunk locale is used by document indexers to perform proper normalization of text. If the chunk is not text or a value of type VT_LPWSTR, VT_LPSTR or VT_BSTR. then this field is ignored.</p>
<p>
The <i>attribute</i> field specifies which attribute should be applied to this chunk. If the filter wishes the same text to have more than one attribute, the filter needs to emit the text once for each attribute in separate chunks.</p>
<p>
Take the following example that might appear in a book:</p>
<pre><code>The small detective exclaimed, "C'est finis!"
    
<b>    Confessions</b>
    
    The room was silent for several minutes. After thinking very hard
    about it, the young woman asked, "But how did you know?"
</code></pre>
<p>
This section might be broken into chunks as follows:</p>
<table cellspacing=4 cols=6>
<tr valign=top>
<th align=left width=5%>id</th>
<th align=left width=24%>Text</th>
<th align=left width=21%>breakType</th>
<th align=left width=15%>flags</th>
<th align=left width=20%>locale</th>
<th align=left width=15%>attribute</th>
</tr>
<tr valign=top>
<td width=5%>1</td>
<td width=24%>The small dete</td>
<td width=21%>N/A</td>
<td width=15%>CHUNK_TEXT</td>
<td width=20%>ENGLISH_UK</td>
<td width=15%>CONTENT</td>
</tr>
<tr valign=top>
<td width=5%>2</td>
<td width=24%>ctive exclaimed,</td>
<td width=21%>CHUNK_NO_BREAK</td>
<td width=15%>N/A</td>
<td width=20%>N/A</td>
<td width=15%>N/A</td>
</tr>
<tr valign=top>
<td width=5%>3</td>
<td width=24%>"C'est finis!"</td>
<td width=21%>CHUNK_EOW</td>
<td width=15%>CHUNK_TEXT</td>
<td width=20%>FRENCH_BELGIAN</td>
<td width=15%>CONTENT</td>
</tr>
<tr valign=top>
<td width=5%>4</td>
<td width=24%>Confessions</td>
<td width=21%>CHUNK_EOC</td>
<td width=15%>CHUNK_TEXT</td>
<td width=20%>ENGLISH_UK</td>
<td width=15%>CHAPTER_<br>
NAMES</td>
</tr>
<tr valign=top>
<td width=5%>5</td>
<td width=24%>Confessions</td>
<td width=21%>CHUNK_EOP</td>
<td width=15%>CHUNK_TEXT</td>
<td width=20%>ENGLISH_UK</td>
<td width=15%>CONTENT</td>
</tr>
<tr valign=top>
<td width=5%>6</td>
<td width=24%>The room was silent for several minutes.</td>
<td width=21%>CHUNK_EOP</td>
<td width=15%>CHUNK_TEXT</td>
<td width=20%>ENGLISH_UK</td>
<td width=15%>CONTENT</td>
</tr>
<tr valign=top>
<td width=5%>7</td>
<td width=24%>After thinking very hard about it, the young woman asked, "But how did you know?"</td>
<td width=21%>CHUNK_EOS</td>
<td width=15%>CHUNK_TEXT</td>
<td width=20%>ENGLISH_UK</td>
<td width=15%>CONTENT</td>
</tr>
</table><br>
<p>
If a GetChunk call to an IFilter implementation of an embedding or link returns FILTER_E_END_OF_CHUNKS, then it is the responsibility of the outer IFilter implementation to check to see if there are any more chunks outside of that embedding or link to be returned. For example, if a document has two embeddings and the first has returned FILTER_E_END_OF_CHUNKS, then the outer IFilter must call GetChunk on the IFilter for the next embedding.</p>
<p>
In addition, before returning the results of a call to GetChunk of an embedded or linked object, the implementation must check to make sure that the chunk identifier is unique, and if it is not, renumber the chunk and keep a mapping of the new chunk identifier.</p>
<p>
The fields </p>
<pre><code>ULONG    idChunkSource;
    ULONG    cwcStartSource;
    ULONG    cwcLenSource;
 </code></pre>
<p>
are used. to describe the source of a derived chunk. If the text of the current non-contents chunk (psuedo-property or property) is derived from some contents chunk, the <i>idChunkSource</i> is set to the identifier of the source chunk, <i>cwcStartSource</i> is set to the offset at which the source text for the chunk starts in the source chunk, and finally <i>cwcLenSource</i> is either set to zero or to the length of. the source text from which the current chunk was derived. Zero signifies that there is character-by-character correspondence between the source text and the derived text. A non-zero value means that there is no such direct correspondence. This information is useful for the search engine when it wants to highlight the hits. If the query is done for a pseudo-property, the search engine highlights the original text from which the text of the property has been derived. For instance, for a C++ code filter, when searching for SampleFunction in a pseudo-property "function definitions," the browser highlights the function header inside the contents of a file. If the chunk is not derived, <i>idChunkSource</i> must be the same as <i>idChunk</i>. If the filter attributes specify a pseudo-property only, then there is no content chunk from which the current pseudo-property chunk is derived. In this case, <i>idChunkSource</i> must be set to 0, which is an invalid chunk identifier.</p>
<p>&nbsp;</p></body>
</HTML>
