<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LocateCatalogs</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_idxs_locatecatalogs"></a>LocateCatalogs</h2>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
LocateCatalogs finds indexes that can be used to process queries for a files in a specified path. The machine and catalog parameter values returned by LocateCatalogs can be used to create an OLE DB ICommand object for issuing queries over a given scope.</p>
<pre><code><b>STDAPI LocateCatalogs(
  WCHAR const</b> * <i>pwszScope</i><b>,</b>
  <b>ULONG</b> <i>iBmk</i><b>,</b>
  <b>WCHAR *</b> <i>pwszMachine</i><b>,</b>
  <b>ULONG *</b> <i>pcMachine</i><b>,</b>
  <b>WCHAR *</b> <i>pwszCatalog</i><b>,</b>
  <b>ULONG *</b> <i>pcCatalog</i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>pwszScope</i></dt>
<dd>
[in] Points to a null-terminated string that specifies the scope for an Index Server query. The scope can be local (e.g., C:\directory) or a remote UNC (e.g., \\MACHINE\SHARE\directory). The scope cannot be a redirected drive letter, that is, a drive letter that refers to a drive on a remote machine. Scopes must be physical, not Internet Information Server virtual scopes.</dd>
<dt>
<i>iBmk</i></dt>
<dd>
[in] Specifies the 0-based bookmark of the result to be retrieved. Pass 0 to retrieve the first machine and catalog that index <i>pwszScope</i>, 1 to retrieve the second machine and catalog that index <i>pwszScope</i>, and so on. If no index for the bookmark is available, LocateCatalogs returns S_FALSE. </dd>
<dt>
<i>pwszMachine</i></dt>
<dd>
[out] Points to a buffer where a null-terminated string is written if the function is successful. The result string is the machine name on which a query over the scope <i>pwszScope</i> can be executed.</dd>
<dt>
<i>pcMachine</i></dt>
<dd>
[in/out] On input, points to a wide character count that specifies the size of <i>pwszMachine</i>. On output, specifies the count of characters used in <i>pwszMachine</i> if the function is successful, or the count of characters needed to store the name of the machine if the buffer is too small. If the buffer is too small, LocateCatalogs returns S_OK.</dd>
<dt>
<i>pwszCatalog</i></dt>
<dd>
[out] Points to a buffer where a null-terminated string is written if the function is successful. The result string is the machine name on which a query over the scope <i>pwszScope</i> can be executed.</dd>
<dt>
<i>pcCatalog</i></dt>
<dd>
[in/out] On input, points to a wide character count that specifies the size of <i>pwszCatalog</i>. On output, specifies the count of characters used in <i>pwszCatalog</i> if the function is successful, or the count of characters needed to store the name of the catalog if the buffer is too small. If the buffer is too small, LocateCatalogs returns S_OK.
</dd>
</dl>
<h4>Return Values</h4>
<p>
An HRESULT, S_OK if successful. If no machine and catalog can be found that index the scope, or <i>iBmk</i> is beyond the count of machines and catalogs that index the scope, the function returns S_FALSE. If there is an error, LocateCatalogs returns E_FAIL.</p>
<p>
If a machine and catalog match is found but the machine and catalog buffers aren't big enough, LocateCatalogs returns S_OK, and fills pcCatalog and pcMachine with the wide character required. Callers of LocateCatalogs must check the return code, <i>pcMachine</i>, and <i>pcCatalog</i> to determine if the call was successful.</p>
<h4>Remarks</h4>
<p>
LocateCatalogs is useful when it is not known what machine and catalog index a scope. If the machine and catalog are known, it's more efficient to execute a query without calling LocateCatalogs.</p>
<p>
LocateCatalogs does not verify that the machine and catalog returned are available. If an application fails to issue a query with the machine and catalog returned, it should increment <i>iBmk</i> and call LocateCatalogs again to get the next machine and catalog that index the scope.</p>
<h4>Example</h4>
<p>
This example enumerates all machines and catalogs capable of resolving queries over the scope "C:\directory".</p>
<pre><code>HRESULT hr = S_OK;
 
for ( ULONG iBmk = 0; S_OK == hr; iBmk++ )
{
    WCHAR awcMachine[ MAX_COMPUTERNAME_LENGTH + 1 ];
    const ULONG cwcMachineBuffer = sizeof awcMachine / sizeof WCHAR;
    ULONG cwcMachine = cwcMachineBuffer;
    WCHAR awcCatalog[ MAX_PATH + 1 ];
    const ULONG cwcCatalogBuffer = sizeof awcCatalog / sizeof WCHAR;
    ULONG cwcCatalog = cwcCatalogBuffer;
 
    hr = LocateCatalogs( L"c:\\directory",
                         iBmk,
                         awcMachine,
                         &amp;cwcMachine,
                         awcCatalog,
                         &amp;cwcCatalog );
    if ( ( hr == S_OK ) &amp;&amp;
         ( cwcMachine &lt;= cwcMachineBuffer ) &amp;&amp;
         ( cwcCatalog &lt;= cwcCatalogBuffer ) )
    {
        wprintf( L"matching machine and catalog: '%s', '%s'\n", 
                awcMachine, awcCatalog );
    }
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
