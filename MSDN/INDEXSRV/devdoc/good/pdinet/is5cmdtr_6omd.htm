<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ICommandTree::SetCommandTree</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_idxs_icommandtree_setcommandtree"></a>ICommandTree::SetCommandTree</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
Sets a command object's command tree, replacing the existing one or replacing a text command specified with ICommandText. The provided command tree is copied into the command object; thus, the consumer may delete the original tree or text without affecting the command object. Most error checking is deferred until one of the validation methods, optimization (see ICommandPrepare), or the ICommand::Execute method are invoked. This method only verifies that the command tree can indeed be copied into the command object's space.</p>
<pre><code><b>HRESULT SetCommandTree(
</b>  <b>DBCOMMANDTREE ** </b><i>ppRoot</i>, 
  <b>DBCOMMANDREUSE </b><i>dwCommandReuse</i>, 
  <b>BOOL </b><i>fCopy</i> 
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>ppRoot</i></dt>
<dd>
[in] The root of the command tree.</dd>
<dt>
<i>dwCommandReuse</i> </dt>
<dd>
[in] A bitmask that specifies whether state from the previous command is retained. If state that was not previously specified is marked for reuse, the flag is ignored and no error occurs. See ICommandText::SetCommandText for a description of these flags.</dd>
<dt>
<i>fCopy</i></dt>
<dd>
[in] If TRUE, the command tree is copied, and the caller retains ownership of the command tree's memory. If FALSE, the provider takes the entire tree, without copying, and set the caller's root pointer to a null pointer. When the command object needs to deallocate the tree, it will call IMalloc::Free once for each node in the tree.
<p>
If <i>fCopy</i> is FALSE, the consumer must not change the command tree without another call to SetCommandTree. The affect of any such changes is undefined. In particular, the provider can assume that the command tree has not changed between the calls that use the tree, such as SetCommandTree, ICommandValidate::ValidateSyntax or ValidateCompletely, ICommandPrepare::Prepare, and ICommand::Execute.

</dd>
</dl>
<h4>Return Value</h4>
<dl>
<dt>
S_OK</dt>
<dd>
The method succeeded.</dd>
<dt>
E_FAIL</dt>
<dd>
A provider-specific error occurred.</dd>
<dt>
E_INVALIDARG</dt>
<dd>
<i>pRoot</i> was a null pointer. <i>dwCommandReuse</i> was invalid.</dd>
<dt>
DB_E_OBJECTOPEN</dt>
<dd>
A rowset was open on the command object.
</dd>
</dl>
<h4>Comments</h4>
<p>
The following example shows how to build and set a simple command.</p>
<pre><code>hr = pICreateCommand-&gt;CreateCommand(IID_ICommand,
                                    (IUnknown **) &amp;pICommand);
pICreateCommand-&gt;Release();
 
// Build a command for the following query:
//    SELECT * FROM CUSTOMERS ORDER BY CITY
CreateSelectNode(&amp;pctSelect);
CreateProjectListAnchor(&amp;pctPLListAnchor);
 
pctSelectNode-&gt;pctFirsChild = pctPLListAnchor;
 
CreateProjectListNode("*", &amp;pctPLListNode);
CreateFromListAnchor(&amp;pctFListAnchor);
CreateFromListNode("CUSTOMERS", &amp;pctFLNode);
 
pctPLListAnchor-&gt;pctFirstChild = pctPLListNode;
pctPLListAnchor-&gt;pctNextSibling = pctFListAnchor;
 
CreateSortListAnchorNode(&amp;pctSLAnchor);
CreateSortListElementNode("ascending",&amp;pctSLNode);
CreateScalarIdNode("CITY", &amp;pctScalar);
 
pctFListAnchor-&gt;pctFirstChild = pctFLNode;
pctFListAnchor-&gt;pctNextSibling = pctSLAnchor;
 
pctSLAnchor-&gt;pctFirstChild = pctSLNode;
pctSLNode-&gt;pctFirstChild = pctScalar;
 
// Get  ICommandTree Interface
hr = pICommand-&gt;QueryInterface(IID_ICommandTree,
                               (IUnknown **) &amp;pICommandTree);
 
// Set Command Tree in Command Object
pICommandTree-&gt;SetCommandTree(&amp;pctSort, FALSE);
pICommandTree-&gt;Release();
 </code></pre>
<p>
The functions used to create the various nodes (e.g. CreateSelectNode) are simple wrappers that set values in the DBCOMMANDTREE structure; they are not part of the OLE DB specification. For example, the code for CreateFromListNode might be:</p>
<pre><code>void CreateFromListNode(
   PWSTR           szFromList,
   DBCOMMANDTREE ** ppctFLNode);
{
   // Allocate DBCOMMANDTREE structure. Place pointer to it in
   // *ppctFLNode. Code not shown.
 
   *ppctFLNode-&gt;op             = DBOP_from_list;
   *ppctFLNode-&gt;hrOperatorOk   = S_OK;
   *ppctFLNode-&gt;hrContextOk    = S_OK;
   *ppctFLNode-&gt;pctFirstChild  = NULL;
   *ppctFLNode-&gt;pctNextSibling = NULL;
   *ppctFLNode-&gt;eKind          = DBVALUEKIND_NAME;
   *ppctFLNode-&gt;pwszName       = szFromList;
}
 </code></pre>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
