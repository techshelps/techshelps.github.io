<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using the Java Debug Interfaces</title>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<BODY BGCOLOR="White" TOPMARGIN=0 LEFTMARGIN=0 VLINK="#006699" ALINK="#006699">
<A NAME="top"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_END-->
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="98%">
<TR>
<TD ROWSPAN=2 WIDTH=114 ALIGN="LEFT" VALIGN="TOP">
<IMG SRC="art/title_x3.gif" WIDTH="112" HEIGHT="108"  BORDER=0 ALT="Working with MS VM"><TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH="100%">
<TR><TD WIDTH=10>&nbsp;</TD><TD VALIGN="top"><FONT FACE="Verdana,Arial,Helvetica" SIZE=1></FONT></TD></TR></TABLE>
</TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR>
<TD WIDTH="355" VALIGN="bottom"><IMG SRC="art/virtual2.gif" WIDTH="355" HEIGHT="27"  BORDER=0 ALT="Microsoft VM"></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="bottom"><A HREF="jsdk_vm_jdebug4a_java_debug_interfaces.htm"><IMG SRC="art/prevnrm.gif" WIDTH="51" HEIGHT="38" BORDER=0 ALT="Previous"></A></TD>
<TD ALIGN="center" VALIGN="bottom"><A HREF="debugger.htm"><IMG SRC="art/homenrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="VM"></A></TD>
<TD ALIGN="center" VALIGN="bottom"><A HREF="Execution_Control.htm"><IMG SRC="art/nextnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Next"></A></TD>
</TR>
<TR>
<TD WIDTH="355" ALIGN="right" VALIGN="top"><FONT COLOR="#006699" SIZE="4" FACE="VERDANA,ARIAL,HELVETICA"><B>Java Language Debug Interfaces</B></FONT></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Previous</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">VM</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Next</FONT></TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD WIDTH=20>&nbsp;</TD>
<TD>
<BR>
<BR>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><h2 STYLE="color:#333366"><a name="jsdk_vm_jdebug4a_using_the_java_debug_interfaces">Using the Java Debug Interfaces</a></h2>
<p>
The following sections describe in detail how to use the Java debug interfaces. They include discussion of the following topics:</p>
<p>
<a href="#jsdk_vm_jdebug4a_general_considerations_when_using_the_java_debug_interfaces">General Considerations when Using the Java Debug Interfaces</a><br>
<a href="#jsdk_vm_jdebug4a_enabling_debugging_in_the_microsoft_vm">Enabling Debugging in the Microsoft VM</a><br>
<a href="#jsdk_vm_jdebug4a_registering_with_the_java_debug_manager">Registering with the Java Debug Manager</a><br>
<a href="#jsdk_vm_jdebug4a_enumerating_active_java_processes">Enumerating Active Java Processes</a><br>
<a href="#jsdk_vm_jdebug4a_registering_with_a_remote_process">Registering with a Remote Process</a><br>
<a href="#jsdk_vm_jdebug4a_implementing_callback_notification_interfaces">Implementing Callback Notification Interfaces</a><br>
<a href="#jsdk_vm_jdebug4a_retrieving_static_information">Retrieving Static Information</a><br>
<a href="#jsdk_vm_jdebug4a_enumerating_static_fields">Enumerating Static Fields</a><br>
<a href="#jsdk_vm_jdebug4a_enumerating_line_number_information">Enumerating Line Number Information</a><br>
<a href="#jsdk_vm_jdebug4a_retrieving_dynamic_information">Retrieving Dynamic Information</a><br>
<a href="#jsdk_vm_jdebug4a_enumerating_dynamic_fields">Enumerating Dynamic Fields</a><br>
<a href="#jsdk_vm_jdebug4a_controlling_execution">Controlling Execution</a><br>
<a href="#jsdk_vm_jdebug4a_enumerating_thread_groups_threads_and_stack_frames">Enumerating Thread Groups, Threads, and Stack Frames</a><br>
<a href="#jsdk_vm_jdebug4a_controlling_execution_with_remote_threads">Controlling Execution with Remote Threads</a><br>
<a href="#jsdk_vm_jdebug4a_accessing_call_stacks">Accessing Call Stacks</a><br>

<h2><a name="jsdk_vm_jdebug4a_general_considerations_when_using_the_java_debug_interfaces"></a>General Considerations when Using the Java Debug Interfaces</h2>
<p>
The Java debug interfaces consist of a large collection of COM objects with many methods. The design of many of these interfaces and methods, however, follow a consistent design pattern. </p>
<p>
Communication between the debugger and the VM is handled through COM interfaces. The debugger requests information and communicates with the VM by calling methods on COM objects implemented by the VM. Similarly, the Microsoft VM runtime notifies the debugger program of events, and then and provides the requested information by calling methods on COM objects that the debugger implements. The debugger registers these callbacks by calling a register callback method.</p>
<p>
The COM objects implemented by the Microsoft VM use consistent class factory and get methods to handle lists of similar objects. Many of the Getxx methods return an enumerator object. These different enumerator objects (for processes, threads, fields, and so on) implement a nearly identical set of methods. These methods support returning an array of objects, skipping some number of objects, resetting the enumerator to the beginning of the list, copying the current enumerator position to another object (cloning), and getting only the next object.</p>
<p>
The Java debug interfaces use a consistent hierarchy of objects. The enumeration methods allow the debugger program to move down the hierarchy of objects. Various Getxx methods (GetContainer, GetSuperClass, and so on) allow the debugger program to move up the hierarchy.</p>
<p>
Because the Java debug interfaces are based on COM, some general considerations apply when calling the interfaces that are implemented by the Microsoft VM. </p>
<p>
Any memory that a debugger program allocates for use as a buffer that is passed as a parameter to any of these COM interfaces (an [in,out] or an [out] parameter as documented in the reference section on the Java debug interfaces) must be allocated using the CoTaskMemAlloc function. When this memory is no longer needed, it must be released using the CoTaskMemFree function. This is a COM requirement because the memory is being allocated across processes. It is also a necessity for DCOM compatibility. </p>
<p>
If the debugger program continues to use any COM objects that are created as parameters to a method, the reference count for that object may need to be incremented to ensure that the object remains viable for the duration of the method call. This can be accomplished by calling the Addref method on the COM interface. The debugger program decrements the reference count on the object using the Release method when this object is no longer needed.</p>
<h2><a name="jsdk_vm_jdebug4a_enabling_debugging_in_the_microsoft_vm"></a>Enabling Debugging in the Microsoft VM</h2>
<p>
For the Java debug interfaces to be used, debugging must be enabled in the Microsoft VM before the Java application or applet begins execution. Debugging can be enabled in the Microsoft VM for Java in two ways:
<ul>
<li>
Defining particular environment variables<br><br></li>
<li>
Creating particular Win32 registry settings</li>
</ul>
<p>
The preferred method to enable debugging is to set special environment variables before starting the Microsoft VM (before launching Microsoft® Internet Explorer, for example) and executing the Java application or applet. Note that the value of these environment variables (when set) override the equivalent settings in the registry. The environment variables that may be used by a debugger are shown in the following table.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Environment Variable</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description and Values</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>MSJAVA_ENABLE_DEBUGGING</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enables debugging when set to some value greater than 0. Valid values must be less than the value of a GUID.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>MSJAVA_DEBUGGING_FLAGS</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Specifies options for debugging, most of which deal with issues when debugging a mixture of native code and Java.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>MSJAVA_ENABLE_FI</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enables the fast interpreter when set to some value that is non-zero. If this environment variable is not set and the equivalent registry value is not set, the fast interpreter is enabled by default.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>MSJAVA_ENABLE_JIT</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enables the Just-In-Time (JIT) compiler when set to some value that is non-zero. If this environment variable is not set and the equivalent registry value is not set, JIT is enabled by default.</FONT></TD>
</tr>
</table><br>
<p>
If the MSJAVA_ENABLE_DEBUGGING string exists in the Win32 environment space and is set to some value greater than 0 for a process, debugging is enabled in any Microsoft VM that subsequently begins executing within this environment. </p>
<p>
If the MSJAVA_DEBUGGING_FLAGS string exists in the Win32 environment space, the value it is set to specifies a set of options that control special features of the Microsoft VM. These options can be a combination of the following.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Option</B></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Value</B></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>MSJDBG_AD2_DEBUGGING</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x04</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>When set, this enables additional semantics, enabling some new Java interfaces and changing the behavior of some older Java interfaces.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>MSJDBG_NO_HARDWARE_BREAKPOINTS</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x08</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>When set, this notifies the Microsoft VM that hardware breakpoints should not be used on Microsoft® Windows NT® being run on Intel processors. If this value and the following value are not set, data breakpoints are available. When using a native debugger, such as Microsoft® Visual C++®, set this value. This option is ignored on DEC alpha systems running Windows NT. Hardware breakpoints are not used on Microsoft® Windows 95®.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>MSJDBG_NO_PAGE_BREAKPOINTS</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x10</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>When set, this notifies the Microsoft VM that memory page faults for data breakpoints should not be used (applies to both Microsoft® Windows 95 and Windows NT being run on Intel processors). If this value and the previous value are not set, data breakpoints are available. When using Visual C++ for debugging, set this value. This option is ignored on DEC alpha systems running Windows NT.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>MSJDBG_ENABLE_JIT_COMPILED_CODE_DEBUGGING</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x40</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>When set, this notifies the Microsoft VM that Just-In-Time (JIT) code debugging is disabled.</td>
</tr>
</table><br>
<p>
Debugging can also be enabled and debug options can be configured through the use of registry settings on Windows 95 and Windows NT. The registry settings that affect the Microsoft VM when used with these debug interfaces are located under the following keys:</p>
<p>
HKEY_LOCAL_MACHINE\Software\Microsoft\Java VM</p>
<p>
Note the presence of a space between Java and VM in this registry node. </p>
<p>
Under this node, the following entries and values may be entered or modified.</p>
<p class=dt>
<b>Debug</b></p>
<p class=indent>
When this key exists before the Microsoft VM begins execution, debugging will be enabled.</p>
<p class=dt>
<b>DebuggingFlags</b></p>
<p class=indent>
Set the value of this entry to a DWORD that indicates the value of the debug options. </p>
<p class=dt>
<b>MSDebug</b></p>
<p class=indent>
When this key exists before the Microsoft VM begins execution, active debugging (AD2) will be enabled.</p>
<p>
By default, when the Microsoft VM is installed, these registry entries are not created. </p>
<p>
HKEY_LOCAL_MACHINE\CurrentUser\Software\Microsoft\Java VM</p>
<p>
Note the presence of a space between Java and VM in this registry node. </p>
<p>
Under this node, the following entries and values may be entered or modified.</p>
<p class=dt>
<b>EnableFI</b></p>
<p class=indent>
Set the value of this entry to a DWORD that indicates whether the fast interpreter is enabled. A non-zero value enables the fast interpreter, while a value of zero disables this feature. The default value for this option is enabled.</p>
<p class=dt>
<b>EnableJIT</b></p>
<p class=indent>
Set the value of this entry to a DWORD that indicates whether the Just-In-Time (JIT) compiler is enabled. A non-zero value enables the JIT compiler, while a value of zero disables this feature. The default value for this option is enabled.</p>
<p class=dt>
<b>EnableJitCompiledCodeDebugging</b></p>
<p>
Set the value of this entry to a DWORD that indicates whether Just-In-Time (JIT) code debugging is enabled. A non-zero value enables JIT code debugging, while a value of zero disables this feature. The default value for this option is enabled. By default, when the Microsoft VM is installed, these registry entries are not created. Registry settings can be set using code similar to the following:</p>
<pre><code><font face="Lucida Sans Typewriter, Courier New, monospace" size="2">const char s_cszDebugKey[] = "Software\\Microsoft\\Java VM\\Debug";

// Create the Microsoft VM Debug key; return TRUE on success.
static BOOL CreateDebugKey(void)
{
    BOOL bResult;
    DWORD dwDisposition;
    HKEY hkeyDebug;

    bResult = ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, s_cszDebugKey, 0,
                NULL, 0, KEY_WRITE, NULL, &amp;hkeyDebug, &amp;dwDisposition) 
                == ERROR_SUCCESS);

    if (bResult) RegCloseKey(hkeyDebug);

    return(bResult);
}</font></code></pre>
<p>
Exercise caution when using these registry settings for enabling use of the Java debug interfaces because these settings will affect all Java applications and applets started under the Microsoft VM. Enabling debugging disables certain optimizations in the Microsoft VM and requires more resources to be used. This option may disable the JIT compiler and invoke a slower than usual version of the Java bytecode interpreter, which will slow down the execution of all Java applications and applets. If the Debug registry entry is not explicitly removed when debugging is no longer needed, the execution performance of all Java applications and applets will be adversely affected. Registry settings can be removed using code similar to the following.</p>
<pre><code><font face="Lucida Sans Typewriter, Courier New, monospace" size="2">// Delete the Microsoft VM Debug key; return TRUE is successful.
static BOOL DeleteDebugKey(void)
{
    return ( RegDeleteKey(HKEY_LOCAL_MACHINE, s_cszDebugKey) == 
           ERROR_SUCCESS);
}</font></code></pre>
<p>
Registry entries can also be removed or modified using the regedit.exe utility that is included with Windows 95 and Windows NT.</p>
<h2><a name="jsdk_vm_jdebug4a_registering_with_the_java_debug_manager"></a>Registering with the Java Debug Manager</h2>
<p>
To use the Java debug interfaces, a debugger program must call specific methods of the registration interfaces implemented by the Microsoft VM. Its registration interfaces are implemented as follows.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Registration Interfaces</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Inherits From</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteDebugManager</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object manages all the processes that can be debugged and connects a debugger program to them when requested. This COM object must be initialized first before any other registration interfaces are used. The debugger program must then call the RegisterCallback method on this object's interface to provide a callback through which the Microsoft VM communicates with the debugger.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteProcess</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object allows a debugger to enumerate all Java processes currently running in the Microsoft VM.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteProcess</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteProcess</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object inherits from the IEnumRemoteProcess interface (adds one new method) and allows a debugger to enumerate all Java processes currently running in the Microsoft VM.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteProcess</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>The interface pointer to this object represents a single Java process running within the Microsoft VM. Note that this object does not represent the Win32 operating system process that the Microsoft VM is being run in.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteProcessEx</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteProcess</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>The interface pointer to this object represents a single Java process running within the Microsoft VM. Note that this object does not represent the Win32 operating system process that the Microsoft VM is being run in. This interface inherits from IRemoteProcess and adds one new method.</FONT></TD>
</tr>
</table><br>
<p>
To register with the Microsoft VM, an application must first call the COM library function CoCreateInstance<b> </b>or CoCreateInstanceEx, passing in the class identifier (CLSID) of the debug manager, CLDID_RemoteJavaDebugManager, and interface identifier (IID) of the IRemoteDebugManager interface. CoCreateInstanceEx<b> </b>takes an additional parameter that specifies the host for use with DCOM. The COM library then uses the CLSID to find the entry for this object’s class in the system registry and starts the appropriate COM server. </p>
<p>
The CLSID for the IRemoteDebugManager is defined in the JDbgGUID.h file. The IID for the IRemoteDebugManager object and the other Java debug interfaces are defined in the JavaDbg.h file that is installed in the Include directory of the SDK for Java. The JavaDbg.h include file also contains function prototypes for the methods supported by these interfaces. </p>
<p>
The following sample code illustrates how these functions might be used to start a local server.</p>
<pre><code><font face="Lucida Sans Typewriter, Courier New, monospace" size="2">#include &lt;JavaDbg.h&gt;
#include &lt;JDbgGUID.h

    HRESULT hr;
    hr = CoInitialize(NULL);   // Initialize OLE on this thread.

    if (SUCCEEDED(hr)) {
        IRemoteDebugManager *pirdm;

        // Create a RemoteJavaDebugManager to initiate debugging.

        hr = CoCreateInstance(CLSID_RemoteJavaDebugManager, NULL,
                              CLSCTX_LOCAL_SERVER,
                              IID_IRemoteDebugManager,
                              (PVOID *)&amp;pirdm);

        if (hr == S_OK) {
            // Continue working if okay.
        }
        // Uninitialize OLE on this thread when done.
        CoUninitialize();
</font></code></pre>
<p>
The debugger program must then register with the Debug Manager in the Microsoft VM, passing its own callback interface pointer through which this virtual machine will communicate with the debugger. The callback functions provided by the debugger must be implemented as methods on COM objects that represent the Notification interfaces, which will be addressed later in this topic. </p>
<p>
The IRemoteDebugManager interface implements the following methods that may be called by a debugger.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Method</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>RegisterCallback</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>The debugger program calls this method to provide a callback for receiving notification when new Java processes are created. The debugger must pass an interface to its own COM object that implements IRemoteDebugManagerCallback. The Microsoft VM communicates with the debugger by calling various methods on this callback interface.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Detach</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>The debugger program calls this method to detach its callback (IRemoteDebugManagerCallback) that was attached by some previous call to RegisterCallback. Call this method before the debugger exits.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetActiveProcesses</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method is used to return an interface to an enumerator object (IJavaEnumRemoteProcess) for all the Java processes currently running in the Microsoft VM.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>RequestCreateEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method notifies the Debug Manager in the Microsoft VM that a debugger program will be debugging a specific Java class. The debugger can specify a Java class name (for an applet or an application) or request interest in debugging all Java classes. The debugger can also specify interest in Java classes run in a specific host Win32 process or any Win32 process.</td>
</tr>
</table><br>
<p>
Once an interface pointer to IRemoteDebugManager object has been obtained, the debugger program must call the RegisterCallback method on this interface. The following code illustrates registering a callback in a sample Initialize method of a Java debugger class.</p>
<pre><code><font face="Lucida Sans Typewriter, Courier New, monospace" size="2">// Initialize is passed. The interface pointer to
//    IRemoteDebugManager is called.
HRESULT JavaDebugger::Initialize(IRemoteDebugManager *pirdm)
{
    HRESULT hr;

    // Register this JavaDebugger's IRemoteDebugManagerCallback with the
    // debug manager so it can be notified when new processes are run.

    hr = pirdm-&gt;RegisterCallback(this);

    if (hr == S_OK) {
        m_pirdm = pirdm;
        m_pirdm-&gt;AddRef();    // Increment the reference count. 
    }
    return(hr);
}</font></code></pre>
<p>
Once a debugger has registered its callback interface, it can request that it be notified when new Java processes are started. The debugger calls the RequestCreateEvent method of the IRemoteDebugManager interface to request being informed when the Microsoft VM creates new Java processes. The RequestCreateEvent method takes two parameters that allow the debugger to register to receive notifications of all new processes created, or in a specific process (a particular Java class) when it is created within a particular Win32 process. There are four possible combinations of these two parameters. The debugger can pass –1 for the process ID registering to receive notifications for any Win32 process. Any other value for the dwProcessID parameter indicates a specific Win32 process. The debugger can pass a zero-length string for the process name (Java class name) registering to receive notification of any Java process that is started. Any other value for the pcszProcessName parameter indicates a specific Java class name passed as a Unicode string. </p>
<p>
The sample code below illustrates registering an interest to receive all process create events.</p>
<pre><code><font face="Lucida Sans Typewriter, Courier New, monospace" size="2">// Ask the debug manager to notify us when any Java class is run.
HRESULT hr;
DWORD dwProcessID = -1;             // For any Win32 process ID, 
                                    // use –1.
LPCOLESTR pcszProcessName = ""; // Zero-length string for all processes.

hr = m_pirdm-&gt;RequestCreateEvent(&amp;pcszProcessName, dwProcessID);</font></code></pre>
<p>
At this point, a Java applet or application that is to be debugged can be started. If the Java application or applet was previously started using the Win32 CreateProcess function was in a suspended state, it can now be resumed. When any new Java processes are started, the debugger is notified through its IRemoteDebugManagerCallback interface.</p>
<h2><a name="jsdk_vm_jdebug4a_enumerating_active_java_processes"></a>Enumerating Active Java Processes</h2>
<p>
Using the RequestCreateEvent method of the IRemoteDebugManager object, a debugger can request to be informed of new Java processes that are created. A debugger program can also keep track of active processes by the calling GetActiveProcesses method on this object to retrieve a pointer to an enumerator object (IJavaEnumRemoteProcess) for all active Java processes. Two other registration interfaces, IJavaEnumRemoteProcess and IEnumRemoteProcess, can be used to enumerate all Java processes currently running in the Microsoft VM. </p>
<p>
These interfaces implement the following methods that may be called by a debugger.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Method</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Next</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Used to retrieve IRemoteProcess objects that represent active Java processes into an array. The number of Java processes to be retrieved is passed as one of the parameters; the enumeration pointer is incremented by that amount.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Skip</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Moves the position of the enumeration forward. The number of objects to be skipped is based on a parameter passed to the method.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Reset</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Sets or resets the positions the enumerator to the beginning of the list of Java processes.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Clone</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Copies a pointer to the current position in the list to another enumerator object. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetNext</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Retrieves the next IRemoteProcess object being pointed to by the enumerator object and increments the enumeration pointer by one. Note that this method is only implemented by the IJavaEnumRemoteProcess object.</td>
</tr>
</table><br>
<h2><a name="jsdk_vm_jdebug4a_registering_with_a_remote_process"></a>Registering with a Remote Process</h2>
<p>
Once a debugger has obtained a list of active Java processes—either through enumeration or from receiving ProcessCreateEvent method calls—it can attach to and debug a specific Java process. </p>
<p>
To debug a specific process, a debugger program must first register a callback to receive notifications and information from the Microsoft VM regarding that process. The IRemoteProcess object, another registration interface, is used for this task. </p>
<p>
The IRemoteProcess interface implements the following methods that can be called by a debugger.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Methods</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>RegisterCallback</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>The debugger program calls this method to provide a callback that should receive notification and information regarding this active Java process. The debugger must pass an interface to its own COM object that implements IRemoteProcessCallback. This is the primary interface that the Microsoft VM communicates with the debugger. The VM sends information to the debugger regarding this process by calling various methods on this callback interface.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Detach</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>The debugger program calls this method to detach its callback (IRemoteProcessCallback) that was attached by some previous call to RegisterCallback.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Break</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method issues a break on all threads in this Java process, resulting in all threads being stopped. This method is asynchronous, so threads won't necessarily stop immediately.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetGlobalContainerObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method returns a pointer to an IRemoteContainerObject, representing the root of all objects in this Java process. This method is used by a debugger to collect static information on all class objects in a Java process. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FindClass</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method finds a specific Java class. If the class isn't already loaded in the Java process, it’s loaded by the Microsoft VM.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>TraceMethods</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method enables or disables TraceEvent callbacks used for notification of method calls. It is being deprecated. Developers should use the newer Java Profiler interfaces.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetThreadGroups</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method returns an enumerator object (IJavaEnumRemoteThreadGroup) for all the thread groups in the Java process. The method is used by a debugger to collect dynamic information on all threads and class objects in a Java process.</td>
</tr>
</table><br>
<h2><a name="jsdk_vm_jdebug4a_implementing_callback_notification_interfaces"></a>Implementing Callback Notification Interfaces</h2>
<p>
For the Microsoft VM to communicate with a debugger, it registers with the Java Debug Manager and passes in pointers to COM objects that implement its notification interfaces. The Java debugger must implement two COM objects for this callback mechanism. The first provides global notification of new process creation. The second interface is used for debugging a specific Java process. </p>
<p>
The notification interfaces that must be implemented by the debugger are as follows.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Notification Interfaces</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteDebugManagerCallback</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object is the initial callback through which the Microsoft VM communicates with the debugger. This callback must be registered by the debugger with the Java Debug Manager. This object has a single method that receives notification from the VM when new Java processes are created.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteProcessCallback</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object is the primary callback through which the VM communicates with the debugger and passes notifications and information requested concerning a specific Java process.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteDebugManagerCallbackEx</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This COM object is not required to be implemented. This object inherits from and is a replacement for the IRemoteDebugManagerCallback object. This interface and is only necessary if the debugger wants to support JIT debugging.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteProcessCallbackEx</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This COM object is not required to be implemented. This object is a replacement for the IRemoteProcessCallback object and is only necessary if the debugger wants to receive notification of the class for which the Microsoft VM was started.</td>
</tr>
</table><br>
<p>
A debugger will normally implement either the IRemoteDebugManager interface or the IRemoteDebugManagerEx interface, which extends the former interface by adding one new method. Under normal circumstances, JIT debugging is disabled when a Java process is being debugged. The IRemoteDebugManagerEx interface is only used when the debugger wants to receive notification of the classes for which the Microsoft VM started to support JIT debugging. </p>
<p>
When the debugger program starts execution, it must register with the Java Debug Manager in the VM passing its own callback interface pointer to IRemoteDebugManagerCallback (or IRemoteDebugManagerCallbackEx). </p>
<p>
The IRemoteDebugManagerCallback and IRemoteDebugManagerCallbackEx interfaces implement the following methods that may be called by the Microsoft VM.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Method</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ProcessCreateEvent</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger that a new Java process has been created and passes back a pointer to the IRemoteProcess object for this new Java class. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>StartClassEvent</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Only implemented by the IRemoteDebugManagerEx object. Notifies the debugger regarding the Java class it has started that the VM was started. For example, if the VM was started with JView using the command line “JView Hello,” the start class would be Hello. This method is only used for JIT debugging.</FONT></TD>
</tr>
</table><br>
<p>
When a Java process starts in the Microsoft VM, the debugger will be notified through its ProcessCreateEvent method that a new Java process has been created. If the debugger decides to, it can register to receive notifications regarding this specific Java process. The IRemoteProcessCallback (or the IRemoteProcessCallbackEx) object is the primary way the Microsoft VM communicates with the debugger about a specific Java process. This callback has a large number of methods that must be implemented by the debugger.</p>
<p>
A debugger will normally implement either the IRemoteProcessCallback or the IRemoteProcessCallbackEx interface (which extends the former interface by adding one new method). The Microsoft VM senses which interface the debugger supports by calling QueryInterface on the callback object passed to IRemoteProcess::RegisterCallback. </p>
<p>
The IRemoteProcessCallback and the IRemoteProcessCallbackEx interfaces implement the following methods that may be called by the Microsoft VM.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Method</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>DebugStringEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when the Java process being debugged outputs a string. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CodeBreakPointEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when a code breakpoint is hit by the Java process being debugged. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>DataBreakPointEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when a data breakpoint is hit by the Java process being debugged.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ExceptionEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when an exception occurs in the Java process being debugged.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>StepEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when an execution step completes in the Java process being debugged.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CanStopEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger during a range step when the Java process being debugged makes a function call.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>BreakEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when an asynchronous break occurs in response to the debugger calling IRemoteProcess:Break.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ThreadCreateEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when a thread is created.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ThreadDestroyEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when a thread is destroyed.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ThreadGroupCreateEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when a thread group is created.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ThreadGroupDestroyEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when a thread group is destroyed.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ClassLoadEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when a Java class is loaded and indicates the thread on which the class was loaded.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>LoadCompleteEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when all Java class have been loaded.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ClassUnloadEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when a Java class is unloaded.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>TraceEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger while tracing is enabled when a method is entered in a Java class. This method is being deprecated. Developers should use the newer Java Profiler interfaces.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ProcessDestroyEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Notifies the debugger when a Java process terminates. No further notifications are sent to the debugger regarding this Java process after this method is called.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>StartClassEvent</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Only implemented by the IRemoteDebugManagerEx object; notifies the debugger regarding the Java class it has started. This method is only used for JIT debugging.</td>
</tr>
</table><br>
<p>
After a debugger registers an interest in a particular Java process (IRemoteProcess), it will begin to receive a large number of calls to its LoadClassEvent method for each class that was loaded before the debugger was attached. The debugger might receive a flurry of over 100 calls for a typical Java process. These notifications to the debugger are initially made asynchronously by the Microsoft VM. After notifications are made for all the currently loaded classes, a LoadCompleteEvent is received. After this notification, any other ClassLoadEvent notifications are sent synchronously for the thread that caused the class to be loaded.</p>
<p>
If the debugger returns S_OK from a ClassLoadEvent method, this Java process is suspended and class loading by the Microsoft VM becomes synchronous. The execution of the Java process can be resumed once the debugger calls IRemoteThread::Go. If the debugger returns S_FALSE from each ClassLoadEvent call, the process of loading Java classes continues. </p>
<p>
All these callback methods implemented by the debugger use the same return values. If the debugger returns S_FALSE, execution of the Java process continues. If the debugger returns S_OK, the Java process is suspended. This process can be resumed once the debugger calls IRemoteThread::Go.</p>
<p>
The IRemoteProcess:FindClass method can be used to force a class to be loaded into the Microsoft VM if it is not already loaded. This method has side effects and the debugger will receive ClassLoadEvent method calls. The initializer for the Java class may also run and the debugger will not receive events during execution of the initializer. For example, if an exception occurs in the initializer, the debugger won't receive an exception event.</p>
<p>
Thread groups are used to group threads together. Thread groups have special meaning for security purposes. Each Java applet is given its own thread group, and the applet can only manipulate threads within that group. These thread groups may be used to differentiate threads between multiple applets.</p>
<p>
The debugger will receive notifications for a large number of events. The debugger is notified when thread groups and individual threads are created and destroyed. Threads are used extensively to get dynamic information when debugging a Java applet or application.</p>
<p>
The debugger will also receive notifications on breakpoint and step events. The debugger sets breakpoints and controls execution by calling methods on the execution control interfaces. The objects to control execution control are also based using threads. In this case, threads are used to retrieve stack frames, calling frames and program counters.</p>
<h2><a name="jsdk_vm_jdebug4a_retrieving_static_information"></a>Retrieving Static Information</h2>
<p>
Static information on a Java process is available through the IRemoteField hierarchy of interfaces. These interfaces represent fields that are members of classes. These fields can be methods, objects, inner classes, or nested class definitions. Because all the attributes of a field are constant during the lifetime of the field, this information can be cached by the debugger.</p>
<p>
Global classes (classes not defined within other classes) can be thought of as fields of a global class. Access to static information in a Java process is based on using the IRemoteClassField and thread passed on each ClassLoadEvent notification to the debugger. The IRemoteProcess:GetGlobalContainerObject method (one of the interfaces used for retrieving dynamic information) can also be used to access the root of this object hierarchy and descend down it to retrieve IRemoteClassField objects. </p>
<p>
The static information interfaces consist primarily of the IRemoteField interface and a collection of other interfaces designed for a specific Java object (primitive data types, arrays, classes, methods, and so on) that inherit from IRemoteField or from other interfaces that extend IRemoteField. The static information interfaces implemented by the Microsoft VM are as follows.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Static Information Interfaces</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Inherits From</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object represents a field in a Java process.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteDataField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object represents a field that is not a method or a class definition. This interface inherits from IRemoteField. This interface is not used except as a base interface for IRemoteArrayField.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteArrayField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteDataField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object represents arrays (special data fields). The only major difference between data and arrays (IRemoteDataField and IRemoteArrayField) is that arrays have a size. This interface inherits from IRemoteDataField. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteContainerField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>The object represents fields that contain other fields. This interface inherits from IRemoteField.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteClassField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteContainerField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object represents a class definition. This interface inherits from IRemoteContainerField.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteClassFieldEx</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteClassField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object represents a class definition. This interface inherits from IRemoteClassField and adds one new method.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteInnerClassField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteClassFieldEx</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This objects represents an inner class definition. This interface inherits from IRemoteClassFieldEx and adds several new method.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteMethodField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteContainerField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object represents a method within a class. This interface inherits from IRemoteContainerField.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object allows a debugger to enumerate fields in a Java process running in the Microsoft VM.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object extends the IEnumRemoteField interface (adds one new method) and allows a debugger to enumerate fields in a Java process running in the Microsoft VM.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumLINEINFO</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This object enumerates line number information for a method.</FONT></TD>
</tr>
</table><br>
<p>
Fields are classified and defined by the FIELDKIND enum as follows:</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>FIELDKIND enum </b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Value</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_KIND_DATA_OBJECT</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0001</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A class instance.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_KIND_DATA_PRIMITIVE</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0002</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A primitive Java data type.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_KIND_ARRAY</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0004</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>An array. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_KIND_CLASS</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0008</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A Java class.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_KIND_METHOD</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0010</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A Java class method. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_KIND_LOCAL</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x1000</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A local variable in a Java method.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_KIND_PARAM</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x2000</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A parameter passed to a Java method.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_KIND_THIS</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x4000</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A THIS pointer to an object.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_KIND_INNER_CLASS</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x8000</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>An Java inner class.</td>
</tr>
</table><br>
<p>
If a field is not FIELD_KIND_LOCAL, FIELD_KIND_PARAM, or FIELD_KIND_THIS, it may be a class field or an array element. This may be determined by getting the kind of the field’s container. For an array element, the container field is FIELD_KIND_ARRAY. For a class field, the container field is FIELD_KIND_CLASS.</p>
<p>
The following Java code sample illustrates the FIELDKINDs for a sample Java class.</p>
<pre><code><font face="Lucida Sans Typewriter, Courier New, monospace" size="2">class &lt;globals&gt;                           // FIELD_KIND_CLASS
{
    class FooClass                        // FIELD_KIND_CLASS
   {
       boolean bDone;                     // FIELD_KIND_DATA_PRIMITIVE
       class BarClass                     // FIELD_KIND_CLASS
      {
           String username[20];           // FIELD_KIND_ARRAY
      }
      BarClass mybar;                     // FIELD_KIND_DATA_OBJECT
      int BarMethod();                    // FIELD_KIND_METHOD
    };
};</font></code></pre>
<p>
Fields also have a set of modifiers contained in a flag attribute bitmask. These modifier bits are the same as those used in the access_flags field of the class file header. These bitmasks are defined in Java Virtual Machine specification published by JavaSoft.</p>
<p>
These modifier bits are defined by the FIELD_ACC enum as follows:</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>FIELDMODIFIERS enum </b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Value</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_PUBLIC</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0001</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Is public and may be accessed from outside its package (visible to everyone). This modifier can be applied to any class, interface, field, or method.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_PRIVATE</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0002</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Is private and usable only within the defining class. This modifier can be applied to a class, method, or class field.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_PROTECTED</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0004</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Is protected and may be accessed within this class and subclasses. This modifier can be applied to any class, method, or class field.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_STATIC</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0008</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A static field or method. This modifier can be applied to any class, method, or field.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_FINAL</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0010</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Is final and no further subclassing or assignment is allowed. This modifier can be applied to any class, method, or field.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_SYNCHRONIZED</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0020</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Use monitor lock when the method is invoked. This modifier can be applied to any class or method.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_VOLATILE</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0040</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>The value of this field cannot be cached. This modifier can be applied to any class field.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_TRANSIENT</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0080</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This field cannot be read or written by a persistent object manager. This modifier can be applied to any class field.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_NATIVE</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0100</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method is implemented using native code. This modifier can be applied to any class or method.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_INTERFACE</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0200</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Is an interface (used to distinguish between an interface and a class). This modifier is applied to an interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_ABSTRACT</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0400</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>An abstract class or interface that may not be instantiated. This modifier can be applied to a class, an interface, or a method.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_SUPER</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x0800</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Treat superclass methods specially in invokespecial (used for backward compatibility). This modifier can be applied to any class or interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>FIELD_ACC_SYNTHETIC</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>0x1000</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Set on fields that the compiler had to generate (used by inner classes).</FONT></TD>
</tr>
</table><br>
<p>
The IRemoteField interface and the other IRemoteXXXField interfaces that inherit from IRemoteField implement a standard set of methods used to get the name, kind, type, and modifiers of a field as well as the field representing the class that contains the field. The GetContainer method provides a way for a debugger to maneuver up the field hierarchy in a class.   </p>
<p>
The following methods of IRemoteField (and the objects that inherit from it) can be called by a debugger.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Methods</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetName</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the identifier (the class, variable, or method name) for this field.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetKind</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the kind (FIELD_KIND enum) of this field. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetType</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an IRemoteField object that represents the type of this field. The relationship between a field and its type depends on the FIELD_KIND of the field. The type will be either a class type or a Java native object type (boolean, short, integer, long, and so on). When this method is called on a global container field, the method returns S_OK and IRemoteField object returned representing the type is NULL.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetContainer</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the field representing the class that contains the field.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetModifiers</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns a bitmask of flags containing the modifiers (FIELDMODIFIERS enum) for this field. If a bit is set, the type is modified in that way.</FONT></TD>
</tr>
</table><br>
<p>
The following methods are specific to the interfaces that inherit from IRemoteField and can be called by a debugger.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Methods</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetSize</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the number of elements in an array. This method is implemented only by the IRemoteArrayField interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetFields</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an enumerator (IJavaEnumRemoteField) for the fields that are contained by this field and match given characteristics. The characteristics are determined by three parameters passed to the method that specify the name of the field, the modifiers bitmask, and the kind. A null parameter passed for the name is used to include all names. A bitmask of 0 is used to include all modifiers. A FIELD_KIND of 0 is used to include all kinds. This method is implemented only by the IRemoteContainerField, IRemoteClassField, IRemoteClassFieldEx, IRemoteInnerClassField, and the IRemoteMethodField interfaces.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetFileName</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the full name of the class if it is available (C:\classes\HelloWorld.class, for example). This method is implemented only by the IRemoteClassField, IRemoteClassFieldEx, and IRemoteInnerClassField interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetSourceFileName</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2> Returns the name of the source file attribute (SourceFile) from the class file if it is available (HelloWorld.java, for example). This method is implemented only by the IRemoteClassField, IrRemoteClassFieldEx, and IRemoteInnerClassField interfaces.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetSourceFileDir</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the name of the source file directory attribute (SourceDir) from the class file if it is available. This method is implemented only by the IRemoteClassFieldEx and the IRemoteInnerClassField interfaces.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetSuperclass</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the class (an IRemoteClassField) from which this class is derived. For Java.Lang.Object, the top of the hierarchy, this method returns NULL. This method is implemented only by the IRemoteClassField interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetInterfaces</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an enumerator (IJavaEnumRemoteField) for the interfaces that this class implements. If the class has no interfaces, an enumerator is returned that enumerates nothing. This method is implemented only by the IRemoteClassField, IRemoteClassFieldEx, and IRemoteInnerClassField interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetConstantPoolItem</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the raw contents for the constant pool and is used for disassembly. Any indices contained within the CP item are converted from big endian order to platform byte order. This method is implemented only by the IRemoteClassField, IRemoteClassFieldEx, and IRemoteInnerClassField interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetIndexedField</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Obtains a local variable or parameters field from a method by local variable index and byte offset.</FONT></TD>
</tr>
</table><br>
<p>
The constant pool items are defined by an initial tag byte that indicates the format of the item stored followed the specific information for that constant entry. The constant pool tag bytes are defined as follows:</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>enum </b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Value</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_UTF8</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>1</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A UCS Transformation Format (UTF-8) string used to represent constant string values encoded in a structure with a 2-byte length preceding the string. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_UNICODE</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>2</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A Unicode string with a two-byte length preceding the string.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_INTEGER</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>3</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A 32-bit integer constant.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_FLOAT</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>4</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A 32-bit single-precision floating point constant.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_LONG</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>5</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A 64-bit long constant. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_DOUBLE</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>6</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A 64-bit double precision floating-point constant.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_CLASS</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>7</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A 16-bit index to a UTF-8 constant name.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_STRING</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>8</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A 16-bit index to a UTF-8 constant string.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_FIELDREF</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>9</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A 16-bit index to a class followed by a 16-bit index to a name_and_type.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_METHODREF</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>10</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A 16-bit index to a class followed by a 16-bit index to a name_and_type.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_
<BR>
INTERFACEMETHODREF</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>11</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>A 16-bit index to a class followed by a 16-bit index to a name_and_type.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_CONSTANT_NAMETYPE</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>12</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>One 16-bit index to a name (UTF-8 constant) followed by a 16-bit index to a field or method descriptor (a UTF-8 constant) representing the type of a class or instance variable. The field or method descriptor is a series of characters defined in the Java Virtual Machine specification published by Sun Microsystems. </FONT></TD>
</tr>
</table><br>
<p>
The following methods are specific to the IRemoteInnerClassField and can be called by a debugger.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Methods</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetInnerClassName</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the real class name, not the mangled class name from the Java compiler. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetInnerClassModifiers</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the real field modifiers for the inner class.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetOuterClass</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an IRemoteClassField representing the outer class.</FONT></TD>
</tr>
</table><br>
<p>
The IRemoteMethodField, which inherits from the IRemoteContainerField, represents a method within a class. This interface implements a number of methods that can be used by a debugger to set and clear breakpoints, get line number info, return Java bytecodes, and other information. </p>
<p>
The following methods are specific to the IRemoteMethodField and can be called by a debugger.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Methods</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>SetBreakpoint</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Sets a code breakpoint at a given byte offset from the start of a method. The VM will not validate the given location of the breakpoint; a breakpoint may be set at any offset within the method’s bytecodes. Breakpoints are reference counted and may be set multiple times at the same byte offset.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ClearBreakpoint</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Clears a code breakpoint at a given byte offset from the start of a method. This method will only clear breakpoints set by SetBreakpoint. If a breakpoint is set multiple times, it must be cleared the same number of times to eliminate it completely.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetLineInfo</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an enumerator of LINEINFO structures (IJavaEnumLINEINFO objects) describing the mapping between source lines and byte offset within the Java bytecodes representing the method. This mapping is in order of increasing offsets. The last element in the list is a “dummy” node with a line number field set to the last line of the method + 1 and the offset field set to the last offset in the method +1. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetBytes</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an interface (ILockBytes) that can be used to access the Java bytecode of the method. This method can be used by a debugger to display a disassembly of the bytecode. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetScope</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the range of byte offsets (within which the object is in scope) that can be used by a debugger to obtain the value of some field within this method. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetIndexedField</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Obtains a local variable or parameters field from a method by local variable index and byte offset. </td>
</tr>
</table><br>
<h2><a name="jsdk_vm_jdebug4a_enumerating_static_fields"></a>Enumerating Static Fields</h2>
<p>
Several of the interfaces that inherit from the IRemoteField object (IRemoteContainerField, IRemoteClassField, and IRemoteMethodField) implement a GetFields method that returns an enumerator for the fields contained by this field. Two other static information interfaces, IJavaEnumRemoteField and IEnumRemoteField, can be used to enumerate all these fields contained within a class, method, or container. The IJavaEnumRemoteField object inherits from IEnumRemoteField, extending this interface with one additional method.</p>
<p>
These interfaces implement the following methods that may be called by a debugger.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Method</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Next</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Used to retrieve IRemoteField objects that represent fields. The number of fields to be retrieved is passed as one of the parameters; the enumeration pointer is incremented by that amount.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Skip</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Moves the position of the enumeration forward. The number of objects to be skipped is based on a parameter passed to the method.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Reset</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Sets or resets the positions the enumerator to the beginning of the list of fields.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Clone</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Copies a pointer to the current position in the list to another enumerator object. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetCount</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the number of fields being pointed to by the enumerator object. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetNext</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Retrieves the next IRemoteField object being pointed to by the enumerator object and increments the enumeration pointer by one. Note that this method is only implemented by the IJavaEnumRemoteField object.</td>
</tr>
</table><br>
<h2><a name="jsdk_vm_jdebug4a_enumerating_line_number_information"></a>Enumerating Line Number Information</h2>
<p>
Line number information represents the mapping between Java source code line numbers and byte offsets in the method. This information is represented as an array of LINEINFO structures maintained for each method. The IEnumLINEINFO interface provides access to this information.</p>
<p>
The IEnumLINEINFO interface implements the following methods that may be called by a debugger.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Method</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Next</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Used to retrieve LINEINFO structures that represent the mapping between Java source code line numbers and byte offset in the method. The number of LINEINFO structures to be retrieved is passed as one of the parameters; the enumeration pointer is incremented by that amount.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Skip</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Moves the position of the enumeration forward. The number of LINEINFO structures to be skipped is based on a parameter passed to the method.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Reset</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Sets or resets the positions the enumerator to the beginning of the list of LINEINFO structures.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Clone</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Copies a pointer to the current position in the list to another enumerator object. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetNext</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Retrieves the next LINEINFO structure being pointed to by the enumerator object and increments the enumeration pointer by one. Note that this method is only implemented by the IJavaEnumLINEINFO object.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetCount</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the number of fields being pointed to by the enumerator object. Note that this method is only implemented by the IJavaEnumLINEINFO object.</td>
</tr>
</table><br>
<h2><a name="jsdk_vm_jdebug4a_retrieving_dynamic_information"></a>Retrieving Dynamic Information</h2>
<p>
Dynamic information on a Java process is available through the IRemoteObject hierarchy of interfaces. These interfaces provide bound access to objects of different types. An object does not necessarily refer to an instance of a class, but represents an instance of any type. The information obtained from an IRemoteObject is only valid during the lifetime of the actual object that it represents. Consequently, dynamic information cannot be cached by the debugger.</p>
<p>
Access to dynamic information in a Java process is based on using the IRemoteThreadGroup and IRemoteThread passed on each ThreadGroupCreateEvent and ThreadCreateEvent notification to the debugger. The IRemoteProcess:GetGlobalContainerObject method can also be used to access the root of this object hierarchy and descend down it to retrieve IRemoteClassField objects. </p>
<p>
The dynamic information interfaces consist primarily of the IRemoteObject, IEnumRemoteObject, and the IEnumRemoteValue interfaces and a collection of other interfaces designed for a specific Java object (primitive data types, arrays, or classes) that inherit from IRemoteObject or IEnumRemoteValue. The dynamic information interfaces implemented by the Microsoft VM are as follows.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Dynamic Information Interfaces</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Inherits From</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Represents bound access to objects of different types in a Java process.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteBooleanObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides run-time access to the value of a boolean variable. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteByteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides run-time access to the value of a byte variable. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteCharObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides run-time access to the value of a char variable. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteContainerObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides run-time access to container objects. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteClassObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteContainerObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides run-time access to class objects. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteDoubleObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides run-time access to the value of a double variable. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteFloatObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides run-time access to the value of a float variable. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteIntObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides run-time access to the value of an int variable. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteLongObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides run-time access to the value of a long variable. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteShortObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides run-time access to the value of a short variable. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteArrayObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides run-time access to array objects. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteObject</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Allows a debugger to enumerate objects in a Java process running in the Microsoft VM.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Allows a debugger to enumerate the value of a variable in a Java process running in the Microsoft VM.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteBooleanValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates boolean values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteByteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates byte values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteCharValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates char values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteDoubleValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates double values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteFloatValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates float values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteIntValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates int values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteLongValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates long values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteShortValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates short values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Allows a debugger to enumerate the value of a variable in a Java process running in the Microsoft VM.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteBooleanValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates boolean values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteByteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates byte values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteCharValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates char values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteDoubleValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates double values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteFloatValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates float values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteIntValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates int values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteLongValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates long values.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteShortValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Enumerates short values.</td>
</tr>
</table><br>
<p>
Java uses a number of built-in types that can be represented by a Win32 debugger written in C and C++ as a series of typedefs as follows:
<pre><font face="Lucida Sans Typewriter, Courier New, monospace" size="2">// JAVA built-in types
    typedef BYTE JAVA_BOOLEAN;
    typedef signed char JAVA_BYTE;
    typedef USHORT JAVA_CHAR;
    typedef double JAVA_DOUBLE;
    typedef float JAVA_FLOAT;
    typedef LONG JAVA_INT;
    typedef LONGLONG JAVA_LONG;
    typedef SHORT JAVA_SHORT;
    typedef LPOLESTR JAVA_STRING;
</font></pre>
<p>
The IRemoteObject interface and the other IRemoteXXXObject interfaces that inherit from IRemoteObject implement a standard set of methods used to get the type of an object, and set or clear data breakpoints on the object. The breakpoint will fire when the value of the object changes. For classes, a data breakpoint will fire when the object references a different instance of that class. For arrays, a data breakpoint will fire when the object references a different instance of the array (when one array is assigned or copied to another). The GetFieldObject method of the IRemoteContainerObject interface provides a way for a debugger to access fields in a container (class). </p>
<p>
The following methods of IRemoteObject (and the objects that inherit from it) can be called by a debugger.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Methods</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetType</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the type of the object (an IRemoteField object). A debugger would normally then call the GetKind method of the IRemoteField interface to determine the FIELD_KIND of the object. The type will be either a class type or a Java native object type (boolean, short, integer, long, and so on.). </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>SetBreakpoint</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Sets a data breakpoint on the object. The breakpoint fires when the value of the object changes. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ClearBreakpoint</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Clears a data breakpoint on the object previously set with the SetBreakpoint method. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Gets the value of a primitive Java type. This method is implemented by the IRemotexxxObject interfaces that inherit from IRemoteObject, where xxx represents one of the primitive Java data types.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>SetValue</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Sets the value of a primitive Java type. This method is implemented by the IRemotexxxObject interfaces that inherit from IRemoteObject, where xxx represents one of the primitive Java data types.</td>
</tr>
</table><br>
<p>
The following methods are unique to the IRemoteObjectEx and can be called by a debugger.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Methods</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IsSameObject</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Indicates whether two objects are the same object.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetContainer</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an IRemoteObject that represents the container for the current object. This methods allows a debugger to navigate back up the hierarchy of objects.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetIdentity</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns a new IRemoteObjectEx that is detached from its containers. This method is used for data breakpoints and allows a debugger to hang onto an object across execution.</FONT></TD>
</tr>
</table><br>
<p>
The following method is unique to the IRemoteContainerObject (and the IRemoteClassObject that inherit from it) and can be called by a debugger.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Methods</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetFieldObject</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an IRemoteObject that represents the object contained in the field of this object. The IRemoteField object that is returned is not bound to the instance of the object and can be used to extract the value of that field from many different IRemoteContainerObject in the same Java process. This method allows a debugger to navigate down the hierarchy of objects.</FONT></TD>
</tr>
</table><br>
<p>
The following method is unique to the IRemoteClassObject and can be called by a debugger.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Methods</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetDerivedMostType</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an IRremoteClassField that represents the object's derived-most type. An example of a derived-most type would be a MyException class derived from the java.io.IOException class.</FONT></TD>
</tr>
</table><br>
<h2><a name="jsdk_vm_jdebug4a_enumerating_dynamic_fields"></a>Enumerating Dynamic Information</h2>
<p>
Several of the interfaces that inherit from the IRemoteObject object (IRemoteContainerObject and IRemoteClassObject) implement a GetFieldObject method that returns an object representing a specific field. </p>
<p>
Several other dynamic information interfaces, IEnumRemoteObject, IEnumRemoteValue, and IJavaENumRemoteValue, can be used to enumerate objects and enumerate values. The IJavaEnumRemoteValue object inherits from IEnumRemoteValue, extending this interface with one additional method.</p>
<p>
These interfaces implement the following methods that may be called by a debugger.</p>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Method</b></td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Next</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Used to retrieve objects (IRemoteObject). The number of objects to be retrieved is passed as one of the parameters; the enumeration pointer is incremented by that amount.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Skip</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Moves the position of the enumeration forward. The number of objects to be skipped is based on a parameter passed to the method.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Reset</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Sets or resets the positions the enumerator to the beginning of the list of fields.</td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Clone</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Copies a pointer to the current position in the list to another enumerator object. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetCount</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the number of objects being pointed to by the enumerator object. </td>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetNext</td>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Retrieves the next LINEINFO structure being pointed to by the enumerator object and increments the enumeration pointer by one. Note that this method is only implemented by the IJavaEnumRemoteValue object and the interfaces that inherit from it.</td>
</tr>
</table><br>
<h2><a name="#jsdk_vm_jdebug4a_controlling_execution">Controlling Execution</a></h2>
<p>
Controlling execution of a Java process is available through the IRemoteThread and IRemoteStackFrame interfaces. These interfaces provide access to call stacks within the threads of the Java process being debugged. Each stack frame represents the state of execution within a method. Consequently, execution control information cannot be cached by the debugger.</p>
<p>
Access to execution control information in a Java process is based on using the IRemoteThreadGroup and IRemoteThread passed on each ThreadGroupCreateEvent and ThreadCreateEvent notification to the debugger. The IRemoteProcess:GetGlobalContainerObject method can also be used to access the root of this object hierarchy and descend down it to retrieve IRemoteThreadGroup and IRemoteThread objects. These IRemoteThread objects can then be used to access the IRemoteStackFrame objects </p>
<p>
The execution control interfaces consist primarily of the IRemoteStackFrame, IRemoteThread, and the IRemoteThreadGroup interfaces and a collection of other interfaces used for enumerating threads and thread groups. The execution control interfaces implemented by the Microsoft VM are as follows.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Execution Control Interfaces</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Inherits From</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteStackFrame</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides access to call stacks within the threads of the Java process being debugged. Each stack frame represents the state of execution within a method.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteStackFrameEx</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteStackFrame</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides access to call stacks within the threads of the Java process being debugged. Each stack frame represents the state of execution within a method. This interface inherits from IRemoteStackFrame and adds two new methods.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteThreadGroup</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides access to thread groups.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteThreadGroupEx</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteThreadGroup</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides access to thread groups. This interface inherits from IRemoteThreadGroup and adds one new method.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteThread</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides access to threads.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteThreadEx</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IRemoteThread</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Provides access to threads. This interface inherits from IRemoteThread and adds several new methods.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteStackFrames</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Allows a debugger to enumerate stack frames in a Java process running in the Microsoft VM.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteThreadGroup</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Allows a debugger to enumerate thread groups in a Java process running in the Microsoft VM.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteThreadGroup</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteThreadGroup</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Allows a debugger to enumerate thread&nbsp; groups in a Java process running in the Microsoft VM. This interface inherits from IEnumRemoteThreadGroup and adds one new method.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteThread</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IUnknown</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Allows a debugger to enumerate threads in a Java process running in the Microsoft VM.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IJavaEnumRemoteThread</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IEnumRemoteThread</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Allows a debugger to enumerate threads in a Java process running in the Microsoft VM. This interface inherits from IEnumRemoteThread and adds one new method.</FONT></TD>
</tr>
</table><br>
<p>
The IRemoteThreadGroup and the IRemoteThreadGroupEx interfaces implement a set of methods used to get the name of a thread group and enumerate the other thread groups and threads in a thread group.</p>
<p>
The following methods of IRemoteThreadGroup (and the IRemoteThreadGroupEx objects that inherit from it) can be called by a debugger.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Methods</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetName</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the name of this thread group. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetThreads</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an enumerator for the threads in this thread group. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetThreadGroups</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an enumerator for the thread groups in this thread group. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetParent</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the parent thread group of this thread group. This method is implemented by the IRemoteThreadGroupEx interface that inherits from IRemoteThreadGroup.</FONT></TD>
</tr>
</table><br>
<h2><a name="jsdk_vm_jdebug4a_enumerating_thread_groups_threads_and_stack_frames">Enumerating Thread Groups, Threads, and Stack Frames</a></h2>
<p>
Two execution control interfaces, IJavaEnumRemoteThreadGroup and IEnumRemoteThreadGroup, can be used to enumerate all these thread groups contained in a Java process. The IJavaEnumRemoteThreadGroup object inherits from IEnumRemoteThreadGroup, extending this interface with one additional method.</p>
<p>
The IRemoteThreadGroup interface implements a GetThreads method that returns an enumerator for the threads in this thread group. Two other execution control interfaces, IJavaEnumRemoteThread and IEnumRemoteThread, can be used to enumerate all the threads contained within a thread group. The IJavaEnumRemoteThread object inherits from IEnumRemoteThread, extending this interface with one additional method.</p>
<p>
These interfaces implement the following methods that may be called by a debugger.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Method</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Next</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Used to retrieve IRemoteThread&nbsp; or IRemoteThreadGroup objects that represent thread groups or threads in a Java process. The number of objects to be retrieved is passed as one of the parameters; the enumeration pointer is incremented by that amount.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Skip</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Moves the position of the enumeration forward. The number of objects to be skipped is based on a parameter passed to the method.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Reset</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Sets or resets the positions the enumerator to the beginning of the list of fields.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Clone</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Copies a pointer to the current position in the list to another enumerator object. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetNext</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Retrieves the next IRemoteThreadGroup or IRemoteThread object being pointed to by the enumerator object and increments the enumeration pointer by one. Note that this method is only implemented by the IJavaEnumRemoteThreadGroup and IJavaEnumRemoteThread object.</FONT></TD>
</tr>
</table><br>
<h2><a name="#jsdk_vm_jdebug4a_controlling_execution_with_remote_threads">Controlling Execution with Remote Thread Objects</a></h2>
<p>
Execution of a Java process is controlled through methods implemented by the IRemoteThread and IRemoteThreadEx interfaces. Methods on these objects allow a debugger to suspend or resume execution of a thread, step through or over a method, and get the current stack frame on this thread. Other methods return the name of the thread and the thread group containing this thread, which allow a debugger to move up the hierarchy of thread objects.</p>
<p>
For notification, many of these methods generate a StepEvent call to the debugger on its IRemoteCallBack or IRemoteCallbackEx interface. If StepEvent returns S_FALSE, execution continues. If StepEvent returns S_OK, execution of this thread is suspended until the Go or Resume method is called.</p>
<p>
The following methods of IRemoteThread (and the IRemoteThreadEx object that inherits from it) can be called by a debugger.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Methods</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetName</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the name of this thread. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetCurrentStackFrame</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the currently executing stack frame on this thread.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetThreadGroup</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the thread group (traverse up the hierarchy) that contains this thread.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Go</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Continues (resumes) execution of this thread. This method clears the execution state and returns immediately.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Step</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Steps a single instruction of bytecode. This method steps over method calls in a Java class. The StepEvent method exported by the debugger on the IRemoteCallback interface is called when execution is complete.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>StepIn</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Steps over a single bytecode instruction. The StepIn method steps into method calls in a Java class. This method return immediately. The StepEvent method exported by the debugger on the IRemoteCallback interface is called when execution is complete.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>StepOut</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Continues execution until the end of the current method. The next instruction to be executed is the first instruction after the call in the calling method. This method returns immediately. The StepEvent method exported by the debugger on the IRemoteCallback interface is called when execution is complete.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>RangeStep</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Continues execution until the PC is outside the given range. The RangeStep method steps over method calls in a Java class. The StepEvent method (exported by the debugger on the IRemoteCallback interface) is called when execution is complete. If the flow of execution enters another method, the debugger receives a CanStopEvent method call on its IRemoteCallback interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>RangeStepIn</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Continues execution until the PC is outside the given range. The RangeStep method steps into method calls in a Java class. The StepEvent method exported by the debugger on the IRemoteCallback interface is called at the first instruction of the stepped into method. If the debugger returns S_FALSE from StepEvent, the Microsoft VM continues executing to the end of this method, and continues executing within the given range. when execution is complete. If the flow of execution enters another method, the debugger receives a CanStopEvent method call on its IRemoteCallback interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Destroy</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Destroys a thread. The ThreadDestroy method exported by the debugger on the IRemoteCallback interface is called when the operation is complete.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Suspend</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Suspends execution of this thread.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Resume</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Resumes execution of this thread.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetSuspendCount</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns a count of how many times the debugger called Suspend.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetThreadID</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the actual Win32 thread ID for the thread. This method is implemented by the IRemoteThreadEx interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetStackFrames</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an enumerator for all of the stack frames in this thread. This method is implemented by the IRemoteThreadEx interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>IsStartBlock</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Indicates if a given stack frame is at the top of the thread (the current stack frame). This method is implemented by the IRemoteThreadEx interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>WatchForStep</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method is used for cross-language engine support (JavaScript and Microsoft® Visual Basic® Scripting Edition, for example) to watch for stepping above or below a given stack pointer. This method is implemented by the IRemoteThreadEx interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Continue</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Continues (resumes) execution of this thread similar to the Go method, but leaves the Java process in step mode. This call returns immediately. This method is implemented by the IRemoteThreadEx interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>AllowExecution</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method is used to control whether execution of this thread should be enabled or disabled. This method is used for function evaluation. This method is implemented by the IRemoteThreadEx interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>PassExceptionToDebuggee</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method is used to control how exceptions are handled during an ExceptionEvent. If this method is called with FALSE as the parameter, the Microsoft VM “swallows” any exceptions that occur, ignores the exception that just occurred, and continues execution. If this method is called with TRUE as the parameter, exception handling occurs normally. If an exception is not caught by the Java process, the exception is passed to the Microsoft VM and the Java process is aborted and the thread is terminated. This method is implemented by the IRemoteThreadEx interface and may only be called during an ExceptionEvent.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>ClearExecutionState</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>This method clears the execution state and returns immediately. Executing a Go method is the equivalent of a ClearExecution method call followed by a Continue call. This method is implemented by the IRemoteThreadEx interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2></FONT></TD>
</tr>
</table>
<br>
<h2><a name="#jsdk_vm_jdebug4a_accessing_call_stacks">Accessing Call Stacks</a></h2>
<p>
Call stacks are accessed through methods implemented by the IRemoteThread and IRemoteStackFrame and the IRemoteStackFrameEx interfaces. Stack frames can be enumerated by calling the GetStackFrames method of the IRemoteThreadEx interface. The current stack frame can be returned by calling the GetCurrentStackFrame method of the IRemoteThread or the IRemoteThreadEx interfaces.</p>
<p>
Methods on these objects allow a debugger to view and change bytecodes that are about to be executed. Other methods return the calling frame and the method object, which allow a debugger to navigate up the hierarchy of objects.</p>
<p>
The following methods of IRemoteStackFrame (and the IRemoteStackFrameEx object that inherits from it) can be called by a debugger.</p>
<P><TABLE WIDTH="87%" BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Methods</b></FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><b>Description</b></FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetCallingFrame</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the stack frame representing the caller of this method. </FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetMethodObject</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns an IRemoteContainer object representing the instance of the method object.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetPC</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the byte offset from the start of this method of the next instruction to be executed. In non-topmost stack frames, this returns the byte offset of the invoke instruction that is being executed.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>SetPC</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Sets the byte offset from the start of this method of the next instruction to be executed.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetKind</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the FRAMEKIND of this frame stack.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetStackRange</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2> Returns the real Win32 pointers top the upper and lower bounds to a stack frame. This method is used for mixed language debugging, so the debugger can order the call stack. This method is implemented by the IRemoteStackFrameEx interface.</FONT></TD>
</tr>
<tr valign=top>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>GetRealPC</FONT></TD>
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>Returns the return address for the stack frame (real PC byte offset from the start of this method) of where execution will resume. This method is implemented by the IRemoteStackFrameEx interface.</FONT></TD>
</tr>
</table><br>
</FONT></TD></TABLE>
<P>
</FONT>
</TD>
</TR>
</TABLE>
<CENTER>
<TD><TR><TD HEIGHT=1 BGCOLOR="RED"></TD></TR></TABLE>
<TABLE WIDTH="100%"><TR>
<TD ALIGN="left"><A HREF="#top"><IMG SRC="art/upnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Top"></A></TD>
<TD ALIGN="right">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><A HREF="cpyright.htm" TARGET="_top">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A></FONT></TD></TR></TABLE>
</CENTER></BODY>
</HTML>
