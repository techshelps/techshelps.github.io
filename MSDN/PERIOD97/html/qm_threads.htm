<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Unraveling Threads: Using This Built-In Java Feature for Fun and Profit </title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<Font face="verdana,arial,helvetica" size="2">
<h1><a name="unravelingthreads"></a>Unraveling Threads: Using This Built-In Java Feature for Fun and Profit </h1>
<p class=indent>
By Qusay H. Mahmoud</p>
<p>
Threads are not a new idea; they’ve been around for quite some time. However, only a few programmers have used them. Fortunately, Java has incorporated threads as part of the language. It’s not only made their use easy, but also effective and productive.</p>
<h3>The Benefits of Threads</h3>
<p>
Threads give your program the ability to perform multiple tasks simultaneously, and to take advantage of multiple CPUs. That is, they present the illusion that two or more events are occurring at the same time; however, your computer (if equipped with one CPU) can execute only one thread at any given time. This illusion of simultaneous execution is the result of rapid switching from one thread to another. Each executes for a short time, then passes control to the next. (In multiprocessor machines, however, multiple threads <i>can</i> execute concurrently.)</p>
<p>
As an example, suppose we want a program to read a line of text from the user, via the keyboard. An exceedingly simple program will block execution of other programs until a line of text is entered. This is all right if the program has nothing else to do. But if the program could be doing background work such as drawing or animating images, then we are wasting CPU time. The background work could be accomplished with threads while the program waits for user input. </p>
<p>
Other benefits include increased application throughput and responsiveness, and the ability to use system resources more efficiently.</p>
<h3>Thread Basics</h3>
<p>
A program with a single flow of control is called <i>sequential</i>. At any time in such a program, the computer is executing at a single point. On the other hand, a program with alternating (or multiple) points of execution — i.e. threads — is called <i>concurrent</i>. </p>
<p>
The term <i>thread</i> derives from the phrase “thread of execution” in operating systems. At any instant, a single point of execution exists within a single thread. Threads can create and kill other threads. Newly created threads will run in the same address space, allowing them to share data.</p>
<p>
Figure 1 depicts a sequential program. Such a program has four parts: Source Code, Global Data, Heap, and Stack. The Source Code is the statements and expressions of the program, translated into machine language. The Global Data holds the <i>static</i> variables of the program, which are usually declared at the top level. The Heap is the storage used by the <i>new</i> operator when allocating new objects. The Stack is the storage that holds all local variables, method arguments, and other information.</p>
<p>
<b>Figure 1: A sequential program.</b></p>
<p>
Figure 2 shows a program with two threads. As you can see, the structure is the same except that each thread has its own stack — because each thread could call a different set of methods in a totally different order. However, all threads share the same Source Code, Global Data, and Heap storage. Thus, if a thread makes a change to a local variable, other threads will not be affected — because those variables are on the thread’s own stack.</p>
<p>
<b>Figure 2: A program with two threads.</b></p>
<p>
The simple example in Figure 3 creates and starts two threads. (Don’t worry about the details for now; we’ll cover them next.) One thread reads from a network socket, while the other reads from a keyboard. Both run in parallel. If you compile and run the program, you’ll get output like this:</p>
<pre><code>ReadingFromSocket:0
ReadingFromKeyboard:0
ReadingFromSocket:1
ReadingFromKeyboard:1
ReadingFromSocket:2
ReadingFromKeyboard:2</code></pre>
<p>
Don’t be surprised if your output looks a bit different. Threads are machine-dependent; their run order can’t be guaranteed, though their scheduling and priorities can be manipulated, as you’ll see.</p>
<pre><code>class MyThread extends Thread {
  
  public MyThread(String name) {
    super(name);
  }

  public void run() {
    for (int i=0; i&lt;3; i++) {
      System.out.println(getName() + ":" + i);
      try {
        sleep(500);
      }
      catch(InterruptedException e) {
        e.printStackTrace();
      }
    }
  }

  public static void main(String argv[]) {
    MyThread t1 = new MyThread("ReadFromSocket");
    MyThread t2 = new MyThread("ReadFromKeyboard");
      t1.start();
    t2.start();
  }
}</code></pre>
<p>
<b>Figure 3: Creating and starting two threads.</b></p>
<h3>Creating and Starting a Thread</h3>
<p>
There are two ways to create a thread in Java. The first way is to create an object from a custom class (e.g. <i>MyThread</i>) that extends the <i>Thread</i> class. The<i> MyThread</i> class must override the <i>run</i> method of the <i>Thread</i> class by providing an implementation for it, as Figure 3 depicted.</p>
<p>
Instantiating the class <i>MyThread</i>:</p>
<pre><code>MyThread t1 = new MyThread("read");
</code></pre>
<p>
will not make the <i>t1</i> object start executing as a thread. We must call <i>Thread</i>’s <i>start</i> method to start the thread’s execution. Once called, this method will in turn call the <i>run</i> method; that’s where all the actions to be performed by the thread should be placed.</p>
<p>
This technique has a drawback, because we must extend the <i>Thread</i> class. Java doesn’t support multiple inheritance, so we can’t write the multithreaded applet we need to extend both the <i>Applet</i> and <i>Thread</i> classes. For this very reason, Java supports another way of creating a thread — through an interface.</p>
<p>
The <i>Runnable</i> interface is used for creating threads, and is defined as follows:</p>
<pre><code>package java.lang;

public interface Runnable {
  public abstract void run();
}</code></pre>
<p>
The only method this interface defines is <i>run</i>, which is declared as <i>abstract</i>, meaning the implementor of this interface must provide an implementation for <i>run</i>. Using this interface, we can implement our earlier example (see Figure 4).</p>
<pre><code>class MyThread implements Runnable {

  public void run() {
    for (int i=0; i&lt;3; i++) {
      System.out.println(Thread.currentThread().getName() +
                         ":" + i);
      try {
        Thread.sleep(500);
      }
      catch(InterruptedException e) {
        e.printStackTrace();
      }
    }
  }

  public static void main(String argv[]) {
    MyThread t1 = new MyThread();
    MyThread t2 = new MyThread();
    Thread ReadFromSocket = new Thread(t1);
    Thread ReadFromKeyboard = new Thread(t2);
    ReadFromSocket.start();
    ReadFromKeyboard.start();
  }
}</code></pre>
<p>
<b>Figure 4: An alternate technique for multithreading.</b></p>
<p>
The main difference between the two ways is that the class implementing the <i>Runnable</i> interface has access to the <i>run</i> method only, and not to all the nice, handy methods provided by the <i>Thread</i> class. But as mentioned previously, the <i>Runnable</i> interface earns its keep because Java doesn’t directly support multiple inheritance.</p>
<p>
When using the <i>Runnable</i> interface to create a thread, we must refer to the class that implements the <i>Runnable</i> interface — in this case, <i>MyThread</i>. Now a thread can be created by calling the <i>Thread</i> class, or a subclass of it, with a <i>Runnable</i> object as target:</p>
<pre><code>MyThread x = new MyThread();
Thread t1 = new Thread(x, "ReadFromSocket");
t1.start();</code></pre>
<p>
When the thread starts executing, it will call the <i>run</i> method in the corresponding class that implements the <i>Runnable</i> interface.</p>
<h3>Putting a Thread to Sleep</h3>
<p>
If you have a drawing method that runs in a separate thread, you may want to control, for example, how fast the thread draws an object. This can be done by briefly suspending the thread each time it’s about to draw an object. You may pause a thread for a specific time by using the <i>sleep</i> method. The argument to <i>sleep</i> specifies the milliseconds of duration. <i>sleep</i> can throw an exception — <i>InterruptedException</i> — that you should catch. The code segment in Figure 5, for example, puts a thread to sleep for one second.</p>
<pre><code>// More code goes here.
public void run() {
  // More code goes here.
  try {
    sleep(1000);
  }
  catch(InterruptedException e) {
    e.printStackTrace();
  }
  // More code goes here.
}
// Mode code goes here.</code></pre>
<p>
<b>Figure 5: Making a thread take a short nap.</b></p>
<p>
I’ve found <i>sleep</i> to be invaluable — not just for use with threads, but in other applications requiring a brief pause before calling another method. Make sure you call it as: </p>
<pre><code>Thread.sleep(amount);</code></pre>
<h3>Controlling Threads </h3>
<p>
As we’ve already seen, the <i>start</i> method is used to bring a newly created thread to life. Three other methods are part of the <i>Thread</i> class, and allow you to control execution: <i>stop</i>, <i>suspend</i>, and <i>resume</i>. They operate on the current thread object, and thus take no arguments. As the name suggests, the <i>stop</i> method is used to stop and destroy a thread. The <i>suspend</i> and <i>resume</i> methods are used to arbitrarily pause and restart execution. Applying these methods is easy. To suspend a thread, use:</p>
<pre><code>MyThread.suspend()</code></pre>
<p>
Later, resume the execution of the thread by calling the <i>resume</i> method: </p>
<pre><code>MyThread.resume(); </code></pre>
<h3>Changing Thread Priority</h3>
<p>
Threads will normally compete for processor time. To give one thread an advantage over others, you may want to change its priority. Priorities range from 1 to 10, where 1 is a low priority and 10 is a high priority. The <i>Thread</i> class defines three constants used to select a common priority. These are: MIN_PRIORITY (equal to 1), NORM_PRIORITY (equal to 5), and MAX_PRIORITY (equal to 10). When a thread is first created, it inherits a priority from its parent thread — usually NORM_PRIORITY.</p>
<p>
You can obtain a <i>Thread</i> priority by using the <i>getPriority</i> method; you can change a priority by calling the <i>setPriority</i> method, which takes an integer argument that must be greater than 0 and less than or equal to 10. If you pass an argument less than 1 or greater than 10, an <i>IllegalArgumentException</i> will be thrown at run time.</p>
<p>
Here’s an example of why you may want to prioritize threads: a client with two threads — a reader and a writer. The reader reads from the server and writes to the console, while the writer reads from the console and writes to the server. In such a case, there might be a shared-access problem at the console. To prevent this, you must give the reader a higher priority than the writer.</p>
<p>
If a thread has a high priority, it may not allow other threads to receive processor time. Such a thread is called “selfish.” A nicer thread would sleep for a while, or yield so that other threads can run. This can be accomplished with the <i>yield</i> method, which gives other threads the opportunity to run.</p>
<h3>Synchronization</h3>
<p>
One pitfall of threads is data sharing. If two or more threads have shared access (read and write) to a variable, then care must be taken to coordinate and synchronize data access. As an example, suppose Alice and Bob (threads personified) are sharing a checkbook. If they’re not careful, their checks might exceed the balance. This code segment demonstrates:</p>
<pre><code>int balance;

boolean withdraw(int amt) {
  if (balance - amt &gt;= 0) {
    balance = balance - amt;
    return true;
  }
  return false;
}</code></pre>
<p>
Figure 6 shows what might happen if Alice and Bob execute this code simultaneously: The balance could become negative. The (hypothetical) <i>withdraw</i> method needs to be synchronized such that only one thread at a time can execute the code. Providing mutual exclusion — that is, preventing simultaneous access to a shared resource — can be accomplished with the <i>synchronized</i> modifier:</p>
<pre><code>int balance;

synchronized boolean withdraw(int amt) {
  if (balance - amt &gt;= 0) {
    balance = balance - amt;
    return true;
  }
  return false;
}</code></pre>
<p>
This code can be executed by only one thread at a time. Also, <i>synchronized</i> does not affect objects; it simply coordinates the sharing of data. This code sample would have the same effect as the previous one:</p>
<pre><code>int balance;

boolean withdraw(int amt) {
  synchronized(this) {
    if (balance - amount &gt;= 0) {
      balance = balance - amt;
      return true;
    }
    return false;
  }
}</code></pre>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=blue width=158><b>Alice</b></td>
<td class=blue width=150><b>Bob</b></td>
<td class=blue width=78><b>Balance</b></td>
</tr>
<tr valign=top>
<td width=158>if (80 - 50) &gt;= 0)</td>
<td width=150></td>
<td width=78>80</td>
</tr>
<tr valign=top>
<td width=158></td>
<td width=150>if (80 - 50 &gt;= 0)</td>
<td width=78>80</td>
</tr>
<tr valign=top>
<td width=158>balance = balance - 50;</td>
<td width=150> </td>
<td width=78>30</td>
</tr>
<tr valign=top>
<td width=158></td>
<td width=150>balance = balance - 50;</td>
<td width=78>-20</td>
</tr>
</table><br>
<p>
<b>Figure 6: The trouble with Alice and Bob.</b></p>
<h3>Conclusion </h3>
<p>
Java incorporates threads as part of the language, making their use easy and effective. Using threads may increase your applications’ performance, in terms of throughput and responsiveness. Just remember to watch for a few pitfalls in coordinating access to shared data and in keeping threads nice, not selfish.</p>
<p>
<i>The files referenced in this article are available for download from the Informant Web site at </i>http://www.informant.com/ji/jinewupl.htm. <i>File name: JI9712QM<b>.</b>ZIP.</i></p>
<p>
Qusay H. Mahmoud is a Senior Software Engineer in the School of Computer Science at Carleton University, Ottawa, Canada. Before joining Carleton University, he worked as a Software Designer at Newbridge Networks. Qusay holds a B.Sc. in Data Analysis and a Masters degree in Computer Science, both from the University of New Brunswick. You can reach him at dejavu@acm.org</p>
</font></BODY>
</HTML>
