<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The ABCs of Requirements Management for Access </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<font face="verdana,arial,helvetica" size="2"><form name=x><object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object></form>
<h1>The ABCs of Requirements Management for Access</h1>
<p>
<i>Mike Gunderloy</i></p>
<p>
Let me start with a true story from my own consulting history. I won't tell you who the client was (my lawyer would frown on that, since he had to get involved in extricating us from the situation), but this was well after I was established in the Access field as a trainer, writer, and developer. Along with a couple of other coders, I signed on to do a major job for a mid-sized (about 100 employees) manufacturing company. What they wanted seemed fairly simple: a bill of materials database, with links back to their accounting system, to let them track the custom work they were doing for various clients of their own. The company's vice president was pretty savvy about PCs himself and had decided that Access was the language of choice for this project.</p>
<p>
We started early one Monday morning with some simple entity-relationship analysis, talked to enough people to make sure we understood the structure of their bills of materials, and started writing code. Not wanting to spend much time in their small town, we did the bulk of our work off-site, issuing periodic, upbeat progress reports by phone and e-mail. After a month, we went back with what we thought was a finished application and a large invoice.</p>
<p>
That was when the trouble started. "I was promised it would do inventory forecasting," said one person in the accounting department. "Where's my daily report?" was the question of someone high up in production. In short order, we realized that what we built had nothing to do with what they needed, wanted, or expected. Worse yet (from our point of view), our contract called for building software to the client's satisfaction. We clearly hadn't ascertained what would satisfy them, and things quickly turned ugly over the issue of a large invoice for a product that they didn't think was relevant to their needs.</p>
<p>
In retrospect, what we left out of the picture was requirements management. "Build a bill of materials database" isn't a requirement. "Generate a report on expected inventory levels for the next three weeks, for all base-level items, on a daily basis" is a requirement: It's clear enough to build a bit of software from. Had we taken the time to collect requirements, we could have avoided the nasty end result of a canceled project and a dissatisfied customer.</p>
<h2>What is a requirement?</h2>
<p>
Let's start with the basics. Before you can make good use of requirements, you need to understand what a requirement is. The definition I use is that a requirement is a specification that tells you what should be implement-ed in an application. Some typical requirements you might see for an Access database could include:
<ul>
<li>
A user-level facility: "The user must be able to specify how many weeks the aging report covers."<br><br></li>
<li>
A general system property: "All employee data must be encrypted so it's not available to an external program."<br><br></li>
<li>
A development constraint: "All code must use the Reddick VBA naming convention."<br><br></li>
<li>
It's just as important to understand what a requirement is <i>not</i>. Requirements <i>don't</i> include:<br><br></li>
<li>
A completely abstract description of the system: "Build an accounting program."<br><br></li>
<li>
Database language: "The employees table must have a many-to-one relationship to the departments table."</li>
</ul>
<p>
In the first case, the demand for an accounting system isn't detailed enough to be considered a requirement. Think of this in terms of testability: What test would determine if you had built an accounting system? If you can't think of a way to prove that a requirement was met by the final software, then it's probably too abstract to be a good requirement. When that happens, you must break the requirement down into smaller requirements. For example, one requirement for an accounting system might be: "The system should store supplier and payment information on all invoices received." </p>
<p>
The second case fails because requirements should always be written in the language of users (the problem domain), not in the language of developers (the computer domain). Leave the computer talk for the design phase of your project. The second requirement should probably be rewritten as: "Each employee should be a member of precisely one department."</p>
<p>
The fact that requirements should be in "user language" means that developers are usually the worst possible people to come up with the requirements for a project. There's no substitute for talking to the actual users of the system. Asking over and over again: "What else do you want the program to do?" is a vital part of the process. If you're not thoroughly versed in your user's business, you'd better alternate that question with, "Can you explain to me what that means?" Some developers dislike this sort of interaction, thinking it somehow lowers their prestige. I suspect they're the least likely developers to deliver useful systems.</p>
<h2>Requirements as contract</h2>
<p>
A thorough set of requirements represents a contract between the client and the developer. On one side, it says, "I expect you to build software that does these things." On the other, it says, "I understand that this is what you need the software to do." The mistake many developers make is to consider the requirements as an <i>immutable</i> contract. This is simply unrealistic. For one thing, no matter how patient you are in eliciting requirements from users, you're not likely to get everything in a few meetings. For another, the business changes even while you're building the software.</p>
<p>
I was recently involved in a project to build a utility with a graphical "Wizard" interface. After the Wizard asked some questions, it would build a text file that was used by another program. The written specification for this program ran five pages, and when it was done both the client and I were satisfied that the requirements described the software. When I was about 75 percent done, the lead developer for the other program came to me with an additional requirement: For some scenarios, they needed to be able to launch the utility I was writing from a command line, supplying all the necessary arguments and suppressing the user interface entirely.</p>
<p>
I could have reacted as many developers would, by simply saying, "That's not in the spec!" Instead, I took the time to sit with the other developer and the manager involved and write some additional concrete requirements so that we both understood the work involved. Then I worked up an estimate for the additional work. The manager approved the estimate, we amended the requirements document (and kept both the old and new versions so we could track the changes), and the additional work proceeded. The result was a satisfied customer and more billable hours for me.</p>
<p>
According to research reported by Capers Jones in <i>Assessment and Control of Software Risks</i> (Yourdon Press, 1994), "Creeping requirements changes average about 1% per month." For a project of any magnitude, you simply must plan ahead for this. On a year-long contract, the expected requirements changes will amount to an extra month of work. Clients who aren't expecting this will be unhappy with the additional cost. If you're not expecting this, you won't finish the job. Make sure that all parties understand up front that the requirements document is subject to change, and that major changes will incur additional costs. As Steve McConnell says in <i>Code Complete</i> (Microsoft Press, 1993), "A plan to follow the requirements rigidly is actually a plan not to respond to your customer."</p>
<p>
What do you do with a customer who won't understand this point or, worse yet, won't budget any money for requirements analysis at all? Walk away and find another customer. If this simply isn't feasible, make sure your contract is strictly time and materials, and have your lawyer check that you won't incur any penalties when the project is canceled without being finished. Anything else is a huge gamble. (For more on which projects to walk away from, see Ed Yourdon's book, <i>Death March</i> [Prentice Hall PTR, 1997].)</p>
<h2>Requirements and iterative prototyping</h2>
<p>
Fortunately, those of us working in Access have a powerful tool for helping elicit the requirements that users didn't think of during the first set of interviews: iterative prototyping, or "false-front" development. The idea is pretty simple. Armed with the requirements, go back to your cubicle and slap together the user interface for the application. Don't get hung up on the final data model, report design, menus, or anything else. Forms with buttons leading to other forms with textboxes are plenty. Hardwire the text in the textboxes to reasonable values-that is, when you open the customer form, it should show a customer, but it doesn't have to be coming from a customer table. Write the minimum code, or even macros, necessary to make the demonstration application flow when you push buttons, select values from combo boxes, or whatever.</p>
<p>
Then, take the demonstration version of the application back to the users and run through it. Show which buttons lead where, how you've grouped functionality together, and what input controls exist. Talk through the application, relying on paper when necessary ("When you push this button, we'll print a report that looks sort of like this sketch"). All the while, of course, take notes on where the users see problems with the demonstration.</p>
<p>
On one recent project, the requirement was to allow selection of a customer service agent and display a list of the orders handled by that agent. When I got to that point in the demonstration, I showed the customer how to select an agent from a combo box and see the orders in an associated listbox. "How do I sort the orders so I see the oldest ones first?" was the response, and I knew immediately that we'd missed a requirement. I assured the user that they'd be able to do that in the final version and added that to my list of requirements for the day. No, I didn't insist that the manager sign off on a new estimate for something that minor. Your initial estimate should be realistic enough to handle this sort of minor change without having to quote a new price to the customer. </p>
<h2>Other requirements management techniques</h2>
<p>
There are whole books out there on requirements engineering (the discipline that analyzes the software requirements process) that explore techniques ranging from simply standardizing on a template for your requirements documents to using a formal, mathematical language for specifications. Without trying to cover the field, let me suggest a few techniques from my own experience:
<ol type=1>
<li>
Don't assume that you know everything, even after talking to the users. Any software project of substantial size will affect multiple stakeholders: end users, managers, technical support people, customers, and more. Make sure you collect requirements from every group of stakeholders that you can identify. It's up to your client to decide on the requirements that are actually important enough to be implemented, but you should try for a complete wish list.<br><br></li>
<li>
Plan for a requirements review. This should be a formal meeting between the developers and the client after the requirements document has been compiled. Often, you can convince the client to schedule this meeting by simply insisting that you can't refine your cost estimate until they sign off on a set of requirements.<br><br></li>
<li>
Plan for conflict resolution. In an ideal world, this wouldn't be the job of the software developer. In the real world, you'll often be the one who discovers that two groups of users have contradictory requirements for the software. Make sure you understand who holds the political power in the organization, so you know who can settle these disputes. Try to limit your participation to collecting information and suggesting the relative costs of different implementations of the software.<br><br></li>
<li>
Do everything you can to make the requirements document easy to read. Don't use technical terms if you can avoid it, especially computer technical terms. If you must use technical terms, define them. If the document is long, include a table of contents and possibly an index. When you print the document, leave margins wide enough to scribble in. It's in your best interest to have this document widely reviewed in the client's organization. Encourage people to submit their comments before the requirements review so that they can be incorporated.<br><br></li>
<li>
Spell out who is responsible for what in your requirements document. I usually include a section labeled "Ownership" that, at the minimum, lists who has the responsibility for funding the project, maintaining the requirements document, writing the code, testing the code, and signing off on the final product.<br><br></li>
<li>
Either keep all versions of the requirements document that you circulate or put the requirements document into your source code control system. Using change bars and annotation marks in your document also helps. Keep track of when changes are made, why they're made, and who authorized them. Toward the end of the development process, you might find that you need to be able to justify additional time spent. It's much better to say "Tom in accounting needed this, and your project manager approved it in our June 3rd meeting" than "I think someone in accounting asked for that feature."</li>
</ol>
<h1>Conclusion</h1>
<p>
How do you justify all this concentration on requirements to clients who might not understand the software development process as well as you do? One way is to cite some figures from <i>Code Complete</i>, based on studies done at IBM, TRW, and GTE. Suppose that one of the requirements for a project is erroneous and that it would take an hour of your time-$100-to correct by doing a more rigorous requirements analysis. Without that requirements analysis, that same defect would cost:
<ul>
<li>
$500 to correct during design.<br><br></li>
<li>
$1,000 to correct during coding.<br><br></li>
<li>
$2,000 to correct during unit test.<br><br></li>
<li>
$5,000 to correct during system test.<br><br></li>
<li>
$10,000 to correct during maintenance.</li>
</ul>
<p>
All but the most devil-may-care customer will understand this argument and be willing to spend the extra time up front to avoid spending a lot more time (and money) down the road. In fact, it's a general principle of software construction that errors detected closest to the point at which they happen are cheapest to correct. Had I understood this basic point, the debacle I described at the beginning of this article would never have happened. With no requirements, 100 percent of the requirements must be wrong, and the cost of correcting this problem during the system test is simply prohibitive.</p>
<p>
Fortunately, the problem is relatively simple to correct. Even the simple act of sitting down with the customer and the users for a few meetings to generate a Word document listing requirements is a powerful tool for making sure that you're building the software the client wants. If you do this much, you'll generally be ahead of the majority of developers in Access, VBA, and Visual Basic. Once you're at that point, you can investigate using a more formal process. In a future <i>Smart Access</i> article, I'll review a product, Requisite Pro, that will help you set up such a formal requirements management process. s</p>
<p>
<b><i>Mike Gunderloy, MCSD, MCSE, MCT, a contributing editor to Smart Access, is a senior consultant for MCW Technologies, a Microsoft Solution Provider. He's a co-author of Access and SQL Server Developer's Handbook (Sybex). He's currently traveling around the country and programming in Access and Visual Basic. MikeG1@mcwtech.com. </i></b></p>
</font></BODY>
</HTML>
