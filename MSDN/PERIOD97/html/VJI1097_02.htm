<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Java Controls: Converting Java Classes to OLE Automation Servers </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>


<h1>Java Controls: Converting Java Classes to OLE Automation Servers </h1>
<p>
<i>By Trevor Harmon</i></p>
<p>
Java is the be-all and end-all of human existence - at least, that's what the hype surrounding this ever-popular computer language would have us believe. Most source code, however, will remain in its original language, simply because of the expense of translation. This presents a developer's dilemma: All programs must be rewritten in Java before they can take advantage of the features in a Java class.</p>
<p>
Visual J++ can help you overcome this problem. With a few source code modifications and some quality time at the command prompt, you can convert your Java class to an OLE automation server. Your code is then available to C++, Visual Basic, and any other language that supports OLE automation. </p>
<h3>What Are Java Controls?</h3>
<p>
You won't find the term "Java control" anywhere in the Visual J++ documentation. It's a phrase I use throughout this article to replace the more accurate (and lengthier) description, "a COM class written in Java and exposed as an OLE automation server." The Visual J++ documentation shortens this phrase to "COM class," but I prefer my version - not just because it's less cryptic, but because it reflects the similarity of automation servers to ActiveX controls. </p>
<p><img src="th_fig01.gif">
</p>
<p>
<b>Figure 1: Java controls are not true ActiveX controls, but rather OLE automation servers.</b></p>
<h3>Java Controls vs. ActiveX Controls</h3>
<p>
Microsoft has changed the specification of ActiveX controls; it now has two different meanings. An ActiveX control can mean, as it has meant in the past, a miniature program that sits inside another program. But it can also mean simply an OLE automation server with no user interface or event handling.</p>
<p>
Don't be fooled by Microsoft's press releases and FAQs on Visual J++: They say Visual J++ can transform a Java class into an ActiveX control, but they actually mean that it can transform a Java class into an OLE automation server. (The new definition of ActiveX controls keeps everything nice and legal.) Java controls support neither encapsulation nor event handling, unlike traditional ActiveX controls. They merely expose their functions and variables through OLE automation (see Figure 1).</p>
<p>
Still, Java controls are similar to true ActiveX controls. Both have methods and properties accessible to all OLE automation controllers in the system; both can expose their features without exposing their source code; and both can produce a visual user interface (although Java controls cannot display their interface inside another program).</p>
<h3>Limitations of Java Controls</h3>
<p>
A Java control is neither a true ActiveX control nor a true OLE automation server, but rather a Java class rigged up to look like an automation server. As a result, it carries two significant restrictions:</p>
<p>
<i>Limited to the Java language</i>. Java controls are written in Java, of course, so they can do only what the Java language allows them to do. However, because they are installed on your system locally - not through Web-like applets - they can access files, connect to remote servers, and call native code.</p>
<p>
<i>One-way communication</i>. Normal OLE automation servers can call other OLE automation servers. Java controls, because they are limited to Java, know nothing about how to use OLE. They can only expose their functions and properties, and sit idly until an automation controller accesses them.</p>
<p>
To get around these restrictions, you must rewrite your Java class in another language that supports OLE automation, such as Visual Basic, Visual C++, or Delphi.</p>
<h3>How Is Integration Possible?</h3>
<p>
Because Java was never designed for OLE, and OLE was never designed for Java, you might wonder how integration of the two is possible. The secret is MSJAVA.DLL, a component of Internet Explorer that implements a Java virtual machine in Windows. When an OLE automation controller attempts to access a Java control, the MSJAVA component is automatically loaded by the OLE subsystem. It acts as a shell around the control, passing OLE function calls directly to the Java code.</p>
<p>
The MSJAVA.DLL file must be present for any Java control to execute. If you distribute a control, you must either require users to install Internet Explorer or obtain redistribution rights to MSJAVA.DLL, and install it along with your control.</p>
<h3>Creating Java Controls</h3>
<p>
Creating a Java control is rather tedious, and requires many careful steps. </p>
<h3>Step 1: Write the Java Source Code</h3>
<p>
You can't convert any old Java class to a Java control. It must meet a strict guideline set by Visual J++:</p>
<p>
Applets not allowed. Just as OLE automation servers cannot reside inside a Web browser, neither can Java controls. Deriving your class from an applet will cause it to fail. Hence, you shouldn't use the Visual J++ Applet Wizard to create a new project. Just open a new Project Workspace and enter the class definition yourself.</p>
<p>
Public classes not allowed. For some mysterious reason, Visual J++ doesn't allow the class of a Java control to be declared public. Adding this modifier will break the entire class.</p>
<p>
<b>Exposing functions and variables. </b>Once your class meets this guideline, you can begin defining functions and variables that you want to expose to users of your Java control. The process for creating these functions is the same as for standard Java class functions. Simply declare a public function, and insert its code between two curly braces. The function can take parameters and return a value (as usual).</p>
<p>
For variables, the process is a little different. Simply declaring a variable as public will not expose it. You must instead wrap the variable, which should be declared private, with <i>get/put</i> functions. For example, a class that exposes a variable called <i>MyProperty</i> would look like this:</p>
<pre><code>class CMyJavaControl {

  private boolean m_bMyProperty = false;

  public boolean getMyProperty() {
    return m_bMyProperty;
  }

  public void putMyProperty(boolean bMyProperty) {
    m_bMyProperty = bMyProperty;
  }
}</code></pre>
<p>
Because the <i>get </i>and<i> put</i> functions provide automation controllers with indirect access to the property, you can easily validate its value (for instance, making sure an integer stays within a certain range) simply by inserting validation code within the <i>put</i> function.</p>
<p>
<b>Data type restrictions. </b>Not all data types can be exposed from Java. Only the primitive types (integers, rationals, char, and Boolean), the <i>String</i> class, and the <i>com.ms.com.Variant</i> class are allowed. This restriction applies to all exposed variables and to the parameters and return values of all exposed functions.</p>
<p>
<b>Handling Errors. </b>In Java, errors are handled by throwing exceptions or returning error codes. In OLE, error codes are universal. The OLE architecture provides a standard error-code data type called HRESULT. By default, every Java function that you expose returns an HRESULT of 0 - indicating success - no matter what your function actually returns. (You'll find out how this is possible in the next section, "Step 2: Create the Object Description.")</p>
<p>
To indicate failure, your function must throw the <i>com.ms.com.ComFailException</i> exception. Figure 2 provides an example of  how to throw an HRESULT value called E_FAIL, indicating a general failure, defined as 0x80004005. </p>
<p>
<b>Debugging Java controls. </b>Visual J++ cannot debug Java controls. It can, however, debug stand-alone applications. To convert your control to a stand-alone application, simply add a <i>main</i> function to the class, and call an exposed function or two (see Figure 3).</p>
<p>
<b>Displaying a user interface.</b> Because Java controls are not applets, they can't appear inside a Web browser, play sounds, or perform other applet feats. They can, however, reveal a user interface as a stand-alone window, which can hold graphics, text, and any <i>Component</i> class (see Figure 4). This window can't appear when the control loads; it can display itself only when an exposed function is called. As shown in Figure 5, the trick is simply to create an instance of the <i>Frame</i> class.</p>
<pre><code>import com.ms.com.*;

class CMyJavaControl {

  public int MyExposedFunction() throws ComFailException {

    ...

    if ( ErrorDetected ) {
      // An error was detected, so throw an instance
      // of ComFailException. This will return the
      // corresponding HRESULT error code to the calling
      // program.

      throw new ComFailException(0x80004005, // E_FAIL
                                 "An error was detected.");

      // The calling program, if written correctly, detects
      // the HRESULT error code and ignores the actual
      // return value. Therefore, just return a dummy value
      // of zero.
      return 0;
    }
    else {
      return SomeMeaningfulValue;
    }
  }
}</code></pre>
<p>
<b>Figure 2:</b> Returning an error in a Java control's exposed function.</p>
<pre><code>private static CMyJavaControl ctrl;

public static void main(String args[]) {
  ctrl = new CMyJavaControl();
  ctrl.MyExposedFunction();
}</code></pre>
<p>
<b>Figure 3: </b>Converting your control to a stand-alone application.</p>
<p><img src="th_fig04.gif">
</p>
<p>
<b>Figure 4: </b>Java controls can display Frame windows that hold a user interface.</p>
<pre><code>import java.awt.*;

class CMyJavaControl {

  public void MyExposedFunction() {

    ...

    // Display a window for the user interface...
    new MyFrame();

    ...
  }
}

class MyFrame extends Frame {

  public MyFrame() {

    super("My Frame");

    setLayout( new FlowLayout() );
    resize(225, 220);
    setBackground(Color.lightGray);

    TextArea textStuff = new TextArea(12, 30);
    textStuff.setText("I was in a boxing match once. " +
                      "I came in second.");

    add(textStuff);
      
    show();
  }

  public boolean handleEvent(Event evt) {

    switch (evt.id) {

      // If the user clicks the close box,
      // shut down the window.
      case Event.WINDOW_DESTROY:
        dispose();
        return true;
    }
       
    return super.handleEvent(evt);
  }
}</code></pre>
<p>
<b>Figure 5: Displaying a user interface in a Java control.</b></p>
<table border=1 cols=2 frame=box rules=all>
<tr valign=top>
<td width=80><b>Section</b></td>
<td width=464><b>Description</b></td>
</tr>
<tr valign=top>
<td width=80>Library</td>
<td width=464>The library section is simply a container for the interface and coclass sections. By convention, library names begin with the letter L.</td>
</tr>
<tr valign=top>
<td width=80>Interface</td>
<td width=464>The interface section is the guts of the ODL file. It declares your Java class' functions and variables that you want to convert to methods and properties of your Java control. By convention, interface names begin with the letter I.</td>
</tr>
<tr valign=top>
<td width=80>Coclass</td>
<td width=464>The coclass section, which stands for "component object class," declares the sets of interfaces in the library. (You can use this section to declare multiple sets of interfaces, but for simplicity I'll pretend ODL files contain only one set.) The name of the coclass should match the name of your Java class. By convention, coclass names begin with the letter C.</td>
</tr>
</table><br>
<p>
<b>Figure 6: The three sections of ODL files.</b></p>
<h3>Step 2: Create the Object Description</h3>
<p>
Once you've got functions exposed, <i>get/put</i> functions installed, and everything debugged, you're ready to convert your Java class to a Java control. The next step is to create an Object Description Language (ODL) file, which defines how your Java class exposes its functions and variables. ODL files are pure text files with three sections (see Figure 6).</p>
<p>
<b>Defining the interfaces. </b>The library and coclass sections are quite simple. You can learn how to create them by looking at the sample ODL file at the end of this section. The interface section, on the other hand, requires some explanation. It lists exposed functions and variables in a special format. For example, if your Java class contains a function defined as:</p>
<pre><code>public void MyExposedFunction() {}</code></pre>
<p>
then you would list it in the interface section like this:</p>
<pre><code>HRESULT MyExposedFunction();</code></pre>
<p>
Notice that even though the Java function is void, its ODL equivalent returns an HRESULT. The HRESULT allows the function to return an error code. ODL interfaces are pretty easy if your Java function takes no parameters. Once you start to add parameters, however, things get weird. For example, an unassuming Java function such as:</p>
<pre><code>public void MyExposedFunction(int nVar1,
                              String strVar2,
                              boolean bVar3) {}</code></pre>
<p>
would translate to ODL as:</p>
<pre><code>HRESULT MyExposedFunction([in] int nVar1,
                          [in] BSTR strVar2,
                          [in] boolean bVar3);</code></pre>
<p>
Notice the unusual <i>[in]</i>? It indicates that the parameter's value is coming in to the function. If the parameter were a single-element array, such as <i>int[]</i>, you would use <i>[in, out]</i> instead, because any changes to the array would remain when the function exits (hence, the values would go out).</p>
<p>
Also notice that the String parameter was changed to a BSTR in the ODL. This is because the OLE automation equivalent of a Java String is a BSTR, a 32-bit length-prefixed character pointer. See Figure 7 for a list of the most common conversions of Java data types to ODL data types.</p>
<p>
If your Java function returns a value, your ODL interface gets even weirder. Return values go out of the function, so you must specify them with <i>[out]</i>. Return values are a special type of <i>out</i>, though, so you must also declare them with <i>retval</i>. Furthermore, you must append * to the data type as you would for an ODL array. For example:</p>
<pre><code>public boolean MyExposedFunction(char ch,
                                 double[] DoubleArray) {}</code></pre>
<p>
would convert to this:</p>
<pre><code>HRESULT MyExposedFunction([in] char ch,
                          [in, out] double* DoubleArray,
                          [out, retval] boolean* retval);</code></pre>
<p>
You can have only one <i>retval</i> parameter per ODL interface, and it must be listed last.</p>
<p>
Inserting property declarations into an ODL file is much like inserting methods. The only difference is that you must declare them twice: once for the <i>get</i> function and once for the <i>put</i> function. For example, a variable declared as:</p>
<pre><code>private byte m_byMyProperty = 0;

public byte getMyProperty() {
  return m_byMyProperty;
}

public void putMyProperty(byte byMyProperty) {
  m_byMyProperty = byMyProperty;
}</code></pre>
<p>
would look like this in the ODL file:</p>
<pre><code>[propget]
HRESULT MyProperty([out, retval] unsigned char* retval);

[propput]
HRESULT MyProperty([in] unsigned char byMyProperty);</code></pre>
<p>
The <i>[propget]</i> and <i>[propput]</i> keys declare each line of ODL code as either a <i>get</i> function or <i>put</i> function, respectively.</p>
<table border=1 cols=2 frame=box rules=all>
<tr valign=top>
<td width=152><b>Java Type</b></td>
<td width=138><b>ODL Equivalent</b></td>
</tr>
<tr valign=top>
<td width=152>boolean</td>
<td width=138>boolean</td>
</tr>
<tr valign=top>
<td width=152>char</td>
<td width=138>char</td>
</tr>
<tr valign=top>
<td width=152>byte</td>
<td width=138>unsigned char</td>
</tr>
<tr valign=top>
<td width=152>short</td>
<td width=138>short</td>
</tr>
<tr valign=top>
<td width=152>int</td>
<td width=138>int</td>
</tr>
<tr valign=top>
<td width=152>long</td>
<td width=138>int64</td>
</tr>
<tr valign=top>
<td width=152>float</td>
<td width=138>float</td>
</tr>
<tr valign=top>
<td width=152>double</td>
<td width=138>double</td>
</tr>
<tr valign=top>
<td width=152>String</td>
<td width=138>BSTR</td>
</tr>
<tr valign=top>
<td width=152>com.ms.com.Variant</td>
<td width=138>VARIANT</td>
</tr>
<tr valign=top>
<td width=152>class java.lang.Object</td>
<td width=138>IDispatch*</td>
</tr>
<tr valign=top>
<td width=152>array of <i>typename</i> </td>
<td width=138></td>
</tr>
<tr valign=top>
<td width=152>(i.e. String[])</td>
<td width=138><i>typename</i>* </td>
</tr>
<tr valign=top>
<td width=152>(i.e. BSTR*)</td>
<td width=138></td>
</tr>
</table><br>
<p>
<b>Figure 7: ODL equivalents of Java data types.</b></p>
<p><img src="th_fig08.gif">
</p>
<p>
<b>Figure 8: The Create GUID program generates unique identifiers for your ODL file.</b></p>
<p>
<b>Generating the UUIDs. </b>Each section in an ODL file - library, interface, and coclass - requires a special identifier called a universally unique identifier (UUID). A UUID, also known as a GUID (globally unique identifier), is a 128-bit value guaranteed to be unique. Each one is generated by a special algorithm that ensures no two values match, even if two people run the algorithm at the exact same moment.</p>
<p>
UUIDs are ideal for OLE automation. By tagging every library, class, and interface with a UUID, the OLE subsystem can always tell them apart. You never have to worry about giving your interfaces unique names.</p>
<p>
To generate a trio of UUIDs for your ODL file, select Tools | Create GUID in Visual J++. This displays the  dialog box shown in Figure 8.</p>
<p>
First, click the fourth radio button to specify that you want the UUID in Registry Format. (ODL files also use this format.) Next, click the Copy button, which will copy the UUID to the Windows Clipboard. Finally, open your ODL file, and paste the UUID into the appropriate section, as shown in the following sample. (Note: After pasting, you must remove the curly braces that the Create GUID program placed around the text.)</p>
<p>
<b>A sample ODL file. </b>This section presents a sample that should complete your education in writing ODL files. From this code, you will see how the library, interface, and coclass sections relate to each other, as well as where to place the UUIDs. You will also notice a <i>helpstring</i> parameter in each section. This parameter is merely a description of the library, interface, or class. (Note that the <i>helpstring</i> in the library section is the most important, because it appears in OLE automation browsers, such as the Java Type Library Wizard and the References dialog box in Visual Basic.)</p>
<p>
Figure 9 shows the Java class declaration for the sample, and Listing Two beginning on page XX shows its ODL representation.</p>
<p>
<b>Instant ODL. </b>For quick access to an ODL file, insert it into your Visual J++ project by selecting Insert | Files Into Project. You can then double-click the file from the FileView to load it into the Visual J++ Text Editor.</p>
<p>
import java.lang.*;</p>
<pre><code>class CMyJavaControl {

  private String m_Var1 = "1";
  private int m_Var2 = 2;
  private float m_Var3 = 3;

  public getVar1() { return m_Var1; }
  public putVar1(String Var1) { m_Var1 = Var1; }

  public getVar2() { return m_Var2; }
  public putVar2(int Var1) { m_Var2 = Var2; }

  public getVar3() { return m_Var3; }
  public putVar3(float Var3) { m_Var3 = Var3; }

  public void func1(int param1) {}
  public void func2(String param1, long param2) {}
  public int func3(int[] param1) {}
  public boolean func4(byte param1, short param2) {}
}</code></pre>
<p>
<b>Figure 9: A sample Java class declaration.</b></p>
<h3>Step 3: Build the Type Library</h3>
<p>
After you have created an ODL file, you must convert it from its original text form to binary. The binary form of an ODL file is known as a type library, or TLB. TLBs are easier for programs to read, and the conversion process checks your ODL file for errors.</p>
<p>
<b>The MkTypLib utility. </b>Visual J++ includes a utility called MkTypLib for converting ODL files to TLBs. It's located in the bin directory. To run this program, simply enter its name on the command line, specifying your ODL file as a parameter. (Note: If Visual C++ is not installed, you must also specify the /nocpp parameter.) For instance, at the command line you might enter:</p>
<pre><code>"c:\Visual J++\bin\mktyplib" MyJavaControl.odl /nocpp</code></pre>
<p>
which would produce:</p>
<pre><code>Microsoft (R) Type Library Generator  Version 2.03.3027
Copyright (c) Microsoft Corp. 1993-1995.  All rights ...

Successfully generated type library 'MyJavaControl.tlb'.</code></pre>
<p>
<b>Fatal distractions. </b>While developing a Java control, you may occasionally receive the following error from MkTypLib:</p>
<pre><code>MyJavaControl.odl : fatal error M0003: Error creating type
  library while processing item 'LMyJavaControl':
  Access denied.</code></pre>
<p>
This error indicates that a running program, most likely Visual Basic, has a stranglehold on the existing TLB file. Find the program, shut it down, then restart MkTypLib.</p>
<p>
<b>The JavaTLB utility. </b>Now you can run the JavaTLB utility on the type library you just created. JavaTLB, which is the command-line version of the Java Type Library Wizard, generates class files from the library description you provide. These files are not the implementation of your Java control, which you will create in Step 4, but rather entry points to the implementation. It places all files in a directory descending from \Windows\Java\TrustLib, so MSJAVA.DLL can find them.</p>
<p>
A session with JavaTLB might look like this:</p>
<pre><code>C:\My Java Control&gt;"c:\Visual J++\bin" MyJavaControl.tlb
Microsoft (R) Visual J++ Java Typelib Conversion Utility
Copyright (C) Microsoft Corp 1996. All rights reserved.

import myjavacontrol.*;

</code></pre>
<table border=1 cols=2 frame=box rules=all>
<tr valign=top>
<td width=116><b>Parameter</b></td>
<td width=428><b>Description</b></td>
</tr>
<tr valign=top>
<td width=116>/register</td>
<td width=428>Always include this parameter when registering a Java class. (To unregister a class, use the /unregister parameter.)</td>
</tr>
<tr valign=top>
<td width=116>/class</td>
<td width=428>This parameter specifies the name of the primary class in your Java control. Separate the parameter name from the class name with a colon.</td>
</tr>
<tr valign=top>
<td width=116>/clsid</td>
<td width=428>JavaReg requires the UUID from your ODL's coclass section. Use this parameter to specify the UUID, separating the two with a colon. Be sure to place curly braces around the ID. (Hint: Instead of typing out the number, paste it from the Clipboard using the DOS prompt's system menu.)</td>
</tr>
</table><br>
<p>
<b>Figure 10: The three parameters of the JavaReg utility.</b></p>
<h3>Step 4: Rebuild the Java Class</h3>
<p>
Take note of JavaTLB's output. It's what you need to create the implementation of your Java control. In the earlier sample session, JavaTLB printed:</p>
<pre><code>import myjavacontrol.*</code></pre>
<p>
This indicates that the myjavacontrol library must be imported into your Java class. Once you have added the <i>import</i> statement, you must also implement the interface defined in your ODL file. For example, if you named your interface <i>IMyJavaControl</i>, your Java class would look like this:</p>
<pre><code>import myjavacontrol.*;

class CMyJavaControl implements IMyJavaControl {
  // Class definition
}</code></pre>
<p>
After importing the library and implementing the interface, rebuild your source code.</p>
<h3>Step 5: Register the Java Class</h3>
<p>
Creating your Java control requires one final step: You must register it with the Windows registry. Once registered, OLE automation controllers will know how to call your Java control (a.k.a. your OLE automation server).</p>
<p>
To register a control, run the JavaReg utility (located in the Visual J++ bin directory) from the command line. This program takes three parameters (see Figure 10).</p>
<p><img src="th_fig11.gif">
</p>
<p>
<b>Figure 11: JavaReg displays this message box if it registers your classes successfully.</b></p>
<p><img src="th_fig12.gif">
</p>
<p>
<b>Figure 12: The Visual Basic References dialog box defines variables for OLE automation.</b></p>
<p>
For example, if your Java control was built from a class called <i>CMyJavaControl</i> and was given a UUID of 98A34D60-2100-11d0-8512-0020AFC746E8, you might type the following at the command line:</p>
<pre><code>"c:\Visual J++\bin\javareg" /register /class:CMyJavaControl
   /clsid:{98A34D60-2100-11d0-8512-0020AFC746E8}</code></pre>
<p>
Executing this command loads JavaReg, registers the Java control, and displays the message box shown in Figure 11. You should then be able to find your class in the Object List pane of the OLE/COM Object Viewer utility (located under the Visual J++ Tools menu).</p>
<p>
Note that if your Java control's implementation - the class files you built in Step 4 - are not already in a directory on the CLASSPATH (see the sidebar "What's the CLASSPATH?" on page X), you must move them to the CLASSPATH so the MSJAVA component can find them. Also, note that if you distribute a Java control, your installation program must register it and place its implementation somewhere in the CLASSPATH.</p>
<h3>Driving Java Controls</h3>
<p>
By themselves, Java controls are useless. They can only wait in the background until some other program - known as an OLE controller or Java control driver - calls on them. Drivers can be written in any language that supports OLE automation; the two popular languages are Visual Basic and C++. This section demonstrates how to write a Java control driver in either language.</p>
<h3>Driving from Visual Basic</h3>
<p>
Driving Java controls from Visual Basic is wonderfully simple. You need to write no more than three lines of code. Before calling the control, however, you must create a reference to it.</p>
<p>
<b>Creating a reference. </b>To create a Visual Basic reference to a Java control, follow these steps:</p>
<p>
Select Tools | References. This will bring up the dialog box shown in Figure 12.</p>
<p>
Find your Java control in the list, and place a checkmark next to its name.</p>
<p>
Select your project's main form from the Project window, and click the View Code button.</p>
<p>
From the Object list, select (General), and from the Proc list, select (declarations).</p>
<p>
Define a variable for your Java control's interface using the <i>Dim</i> keyword. For example, if your Java control was named MyJavaControl, you would type:</p>
<pre><code>Dim MyJavaControl As IMyJavaControl</code></pre>
<p>
From the Object list, select Form, and from the Proc list, select Load.</p>
<p>
Allocate memory for the interface variable using the <i>New</i> keyword. Be sure to allocate it as a class, not an interface. For example:</p>
<pre><code>Set MyJavaControl = New CMyJavaControl</code></pre>
<p>
<b>Calling methods and accessing properties. </b>After you have created a reference to the Java control, you can call its methods and access its properties as you would for any other Visual Basic object. For example, to call a function defined as:</p>
<pre><code>public void MyExposedFunction() {}</code></pre>
<p>
you would enter:</p>
<pre><code>Call MyJavaControl.MyExposedFunction</code></pre>
<p>
Similarly, to call a function defined as:</p>
<pre><code>public void AnotherExposedFunction(int param1,
                                   String param2)</code></pre>
<p>
you would enter:</p>
<pre><code>Call MyJavaControl.AnotherExposedFunction(
  37, "See? I told you VB was simple.")</code></pre>
<p>
Accessing a Java control's properties is no more difficult. It works the same as standard Visual Basic properties. A Java variable named <i>MyProperty</i> of type Boolean would be accessed as:</p>
<pre><code>MyJavaControl.MyProperty = True</code></pre>
<table border=1 cols=2 frame=box rules=all>
<tr valign=top>
<td width=188><b>Parameter</b></td>
<td width=356><b>Description</b></td>
</tr>
<tr valign=top>
<td width=188>REFCLSID rclsid</td>
<td width=356>Class identifier. This has already been defined for you in MkTypLib's header file (example: CLSID_CMy JavaControl).</td>
</tr>
<tr valign=top>
<td width=188>LPUNKNOWN pUnkOuter</td>
<td width=356>A pointer for aggregate mapping. Specify NULL for Java controls.</td>
</tr>
<tr valign=top>
<td width=188>DWORD dwClsContext</td>
<td width=356>Context for running executable code. Specify CLSCTX_INPROC_SERVER for Java controls.</td>
</tr>
<tr valign=top>
<td width=188>REFIID riid</td>
<td width=356>Interface identifier. This has already been defined for you in MkTypLib's header file (example: IID_IMy JavaControl).</td>
</tr>
<tr valign=top>
<td width=188>LPVOID* ppv</td>
<td width=356>Pointer to storage of interface identifier (see the following example).</td>
</tr>
</table><br>
<p>
<b>Figure 13: CoCreateInstance's five parameters.</b></p>
<h3>Driving from C++</h3>
<p>
Driving a Java control is more difficult from C++ than from Visual Basic. You must concern yourself with such tedious issues as building a header file, releasing interface handles, and checking for null pointers. I've already worked through these tricky details, however, and can help you avoid the pitfalls. Just follow the steps in this section and you'll be okay.</p>
<p>
<b>Building the header file.</b> Before you can write any C++ code that calls a Java control, you must build a header file so the compiler knows what you're talking about. The MkTypLib utility, discussed in Step 3 of the previous section, can build this header for you when you specify the /h parameter. For example:</p>
<pre><code>"c:\Visual C++\bin" MyJavaControl.tlb /h MyJavaControl.h</code></pre>
<p>
This command will generate a header file similar to the one shown in Listing Three beginning on page XX. You must <i>#include</i> this file, as well as the initguid.h header file that came with your C++ compiler, in your source code.</p>
<p>
<b>Creating a reference. </b>Your next step is to create a reference to your Java control by calling <i>CoCreateInstance</i>. This function obtains a pointer to the Java control, which you can use to call methods and access properties. It takes five parameters (see Figure 13).</p>
<p>
Here's an example of how you would create an instance of the Java control from Listing Three:</p>
<pre><code>IMyJavaControl* iMyCtrl = NULL;
   
CoCreateInstance(CLSID_CMyJavaControl, NULL,
                 CLSCTX_INPROC_SERVER, IID_IMyJavaControl,
                 (void**)&amp;iMyCtrl);

if (iMyCtrl == NULL) {
  MessageBox(0, "Unable to create instance", "Error", 0);
}
else {
  // Use iMyCtrl to call methods and access properties.
  // See the following section for an example.
  iMyCtrl-&gt;Release();
}</code></pre>
<p>
Notice that the <i>iMyCtrl</i> interface is released when it's no longer needed. This is because OLE keeps track of memory by using reference counting. The <i>Release</i> function decrements the release count on the control. If you forget to call <i>Release</i>, your program will leak memory, and could eventually crash the system. (Makes you appreciate Java's garbage collecting, doesn't it?)</p>
<p>
<b>Saving interface pointers. </b>Instead of calling <i>CoCreateInstance</i> every time you want to use a Java control, you can save a copy of the interface pointer in a global (or member) variable. Saving pointers reduces both execution time and the time you spend coding. Just be sure to release the interface pointer when you're done with it.</p>
<p>
<b>Calling methods. </b>Once you have created an interface, you can use it to call the methods and access the properties of the Java control. Calling methods works just like calling the functions of a C++ class pointer. For example, a Java function defined as:</p>
<pre><code>public void MyExposedFunction(char param1, float param2) {}</code></pre>
<p>
would be called in C++ as:</p>
<pre><code>iMyCtrl-&gt;MyExposedFunction('t', 1.234);</code></pre>
<p>
Although this syntax is what you're probably used to, note that return values are handled differently. All Java control methods, when called from C++, return an HRESULT to indicate success or some type of failure. To get the actual return value, you must specify a pointer as the last parameter, as indicated in MkTypLib's header file. For example, a Java function defined as:</p>
<pre><code>public String MyExposedFunction(boolean param1) {}</code></pre>
<p>
would be called in C++ like this:</p>
<pre><code>int nRetVal;
iMyCtrl-&gt;MyExposedFunction(TRUE, &amp;nRetVal);</code></pre>
<p>
Always remember to pass a valid pointer as the return-value reference. If you try to cut corners and pass NULL, your program will crash.</p>
<p>
<b>Managing BSTRs in C++. </b>As indicated in Figure 7, the ODL equivalent of a Java String is a BSTR, the string data type used by OLE. Because OLE is based heavily on C++, the C++ equivalent of a Java String is also a BSTR. As you might expect, managing a BSTR variable takes more effort than its Java counterpart. You can't use standard C++ string functions; you must use special OLE-defined functions that handle BSTRs. The three most important of these functions are listed in Figure 14.</p>
<p>
See the OLE SDK documentation for a complete list of BSTR functions. Also, if you're creating a C++ driver with the Microsoft Foundation Classes (MFC), see the documentation of CString to learn about its built-in support for BSTRs.</p>
<p>
<b>Accessing properties. </b>Accessing a Java control's properties from C++ isn't as easy as it could be. The MkTypLib header file wraps each property with <i>get/put</i> functions, and you must call these functions every time you access a property value. To illustrate, a control property called <i>MyProperty</i> would be accessed in this way:</p>
<pre><code>// Get the integer property value...
int i;
iMyCtrl-&gt;get_MyProperty(&amp;i)
i++;
// Set it back...
iMyCtrl-&gt;put_MyProperty(i);</code></pre>
<table border=1 cols=2 frame=box rules=all>
<tr valign=top>
<td width=194><b>Function</b></td>
<td width=350><b>Description</b></td>
</tr>
<tr valign=top>
<td width=194>SysAllocString(OLECHAR*)</td>
<td width=350>Allocates a BSTR from an OLECHAR string. (Hint: You can convert a standard C++ string to OLECHAR using the T2OLE macro.)</td>
</tr>
<tr valign=top>
<td width=194>SysStringLen(BSTR)</td>
<td width=350>Determines the length of a BSTR.</td>
</tr>
<tr valign=top>
<td width=194>SysFreeString(BSTR)</td>
<td width=350>Frees a previously allocated BSTR. Don't forget to call this function when you're finished with the string.</td>
</tr>
</table><br>
<p>
<b>Figure 14: Three important OLE-defined functions.</b></p>
<h3>Putting It All Together</h3>
<p>
As an example, I've combined all the topics of this article into a single Java control called the LingoMaker. It can translate English text into any of three "lingos": pig latin, Elmer Fudd talk, or Morse code. (LingoMaker source code and compiled class files are available for download.)</p>
<p>
<i>This article was adapted from </i>Web Developer's Guide to Visual J++ &amp; ActiveX <i> by Trevor Harmon </i>[Coriolis Group Books, 1996]<i>, ISBN: 1-57610062-6. For more information, call (602) 483-0192 or visit </i>http://www.coriolis.com<i>.</i></p>
<p>
<i>The files referenced in this article are available for download from the Informant Web site at </i>http://www.informant.com/ji/jinewupl.htm<i>. File name: JI9710TH.ZIP.</i></p>
<p>
Trevor Harmon is the author of <i>Web Developer's Guide to Visual J++ &amp; ActiveX </i>[Coriolis Group Books, 1996]. He recently produced "<i>The Coffee Grinder</i>", an online resource for JavaBeans developers, available at http://TrevorHarmon.com/coffeegrinder. He currently lives in Germany, and works for Jenoptik Systemhaus, makers of administration software for hospitals. Trevor can be reached at coffeegrinder@TrevorHarmon.com. </p>
<h3>Begin Listing Two - The ODL representation</h3>
<pre><code>// MyJavaControl.odl

[
  uuid (A1ED37A1-208D-11d0-8512-0020AFC746E8),
  version (1.0),
  helpstring("My Java control")
]

library LMyJavaControl {

  importlib("stdole32.tlb");  // Required for IDispatch

  [ 
    odl,
    uuid(A1ED37A2-208D-11d0-8512-0020AFC746E8),
    helpstring("IMyJavaControl interfaces"),
    oleautomation,
    dual
  ]

  interface IMyJavaControl : IDispatch {
    // PROPERTY: String Var1
    [propget]
    HRESULT Var1([out, retval] BSTR* retval);
    [propput]
    HRESULT Var1([in] BSTR Var1);

    // PROPERTY: int Var2
    [propget]
    HRESULT Var2([out, retval] int* retval);
    [propput]
    HRESULT Var2([in] int Var2);

    // PROPERTY: float Var3
    [propget]
    HRESULT Var3([out, retval] float* retval);
    [propput]
    HRESULT Var3([in] float Var3);

    // METHOD: void func1(int param1)
    HRESULT func1([in] int param1);

    // METHOD: void func2(String param1, long param2)
    HRESULT func2([in] BSTR param1, [in] int64 param2);

    // METHOD: int func3(int[] param1)
    HRESULT func3([in, out] int* param1,
                  [out, retval] int* retval);

    // METHOD: boolean func4(byte param1, short param2)
    HRESULT func4([in] unsigned char param1,
                  [in] short param2,
                  [out, retval] boolean retval);
  }
   
  [
    uuid(A1ED37A3-208D-11d0-8512-0020AFC746E8),
    helpstring("CMyJavaControl class"),
    appobject
  ]
  coclass CMyJavaControl {
    interface IMyJavaControl;
  }
}</code></pre>
<h1>End Listing Two</h1>
<h1></h1>
<h1>Begin Listing Three - The header file</h1>
<pre><code>/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: LMyJavaControl */

#ifndef _LMyJavaControl_H_
#define _LMyJavaControl_H_

DEFINE_GUID(LIBID_LMyJavaControl, 0x710CA5E1L, 0x1F0B,
            0x11D0, 0x85, 0x12, 0x00, 0x20, 0xAF, 0xC7,
            0x46, 0xE8);

DEFINE_GUID(IID_IMyJavaControl, 0x710CA5E2L, 0x1F0B,
            0x11D0, 0x85, 0x12, 0x00, 0x20, 0xAF, 0xC7,
            0x46, 0xE8);

/* Definition of interface: IMyJavaControl */
#undef INTERFACE
#define INTERFACE IMyJavaControl

DECLARE_INTERFACE_(IMyJavaControl, IDispatch) {
#ifndef NO_BASEINTERFACE_FUNCS

  /* IUnknown methods */
  STDMETHOD(QueryInterface)(THIS_ REFIID riid,
                            LPVOID FAR* ppvObj) PURE;
  STDMETHOD_(ULONG, AddRef)(THIS) PURE;
  STDMETHOD_(ULONG, Release)(THIS) PURE;

  /* IDispatch methods */
  STDMETHOD(GetTypeInfoCount)
    (THIS_ UINT FAR* pctinfo) PURE;

  STDMETHOD(GetTypeInfo)(
    THIS_
    UINT itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo) PURE;

  STDMETHOD(GetIDsOfNames)(
    THIS_
    REFIID riid,
    OLECHAR FAR* FAR* rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID FAR* rgdispid) PURE;

  STDMETHOD(Invoke)(
    THIS_
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr) PURE;
#endif

  /* IMyJavaControl methods */
  STDMETHOD(get_MyProp)(THIS_ long FAR* retval) PURE;
  STDMETHOD(put_Prop)(THIS_ long MyProp) PURE;
  STDMETHOD(MyExposedMethod)(THIS) PURE;
  STDMETHOD(AnotherExposedMethod)
    (THIS_ BSTR str, VARIANT_BOOL bShowResults,
     BSTR FAR* retval) PURE;
};

DEFINE_GUID(CLSID_CMyJavaControl, 0x710CA5E3L, 0x1F0B,
            0x11D0, 0x85, 0x12, 0x00, 0x20, 0xAF, 0xC7, 
            0x46,0xE8);

#ifdef __cplusplus
class CMyJavaControl;
#endif

#endif</code></pre>
<h1>End Listing Three</h1>
<h1></h1>
<h1>What's the CLASSPATH?</h1>
<p>
The CLASSPATH is a list of four directories that the MSJAVA component searches when executing a Java class. If a class doesn't reside in one of these directories, it cannot execute. By default, all directories in the CLASSPATH descend from \Windows\Java.</p>
<p>
Each of the four directories is stored in the Windows System Registry under the key HKEY_LOCAL_MACHINE\Software\Microsoft\Java VM. The subkeys, listed in the order in which they are searched, are:</p>
<p>
<b>Classpath. </b>Classes available to all applets, including untrusted applets.</p>
<p>
<b>LibsDirectory. </b>Libraries available to all applets, including untrusted applets.</p>
<p>
<b>TrustedClassPath. </b>Classes available only to trusted applets.</p>
<p>
<b>TrustedLibsDirectory. </b>Libraries available only to trusted applets.</p>
<p>
By editing these subkeys, you can change how the MSJAVA component searches for your Java control.</p>
<p>
<i>- Trevor Harmon</i></p>
</font></BODY>
</HTML>
