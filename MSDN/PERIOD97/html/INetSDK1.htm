<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Boning Up on the Internet Client SDK Part I:  Web Browsing Objects</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<font face="verdana,arial,helvetica" size="2">
<h1>Boning Up on the Internet Client SDK Part I:  Web Browsing Objects</h1>
<p>
In just a short time, the Internet has become an integral tool for connecting computers <br>
and transferring information. As a result, developers are under increasing pressure to integrate their applications with the Internet. Microsoft® Office 97 is a perfect example of how Microsoft has added Internet functionality into its word processor and other business applications. Now, with the preview release of Internet Explorer (IE) 4.0, Microsoft takes this technology one step further and makes Internet access part of the Windows desktop. </p>
<p>
Microsoft has released a new and improved Internet Client SDK. The Internet Client SDK, which evolved from the ActiveX™ SDK, contains overviews, reference materials, and examples of how to use the new technology available in IE 4.0. After you start integrating the new technology with your applications, the Internet Client SDK will become a valuable addition to your development library.</p>
<p>
The Internet Client SDK contains a staggering amount of information, but this article will focus on one small section: Web browsing objects. First, I'll give you a brief overview of the Internet Client SDK structure and what it contains. Second, I'll show you how to create a simple MFC application (using Visual C++® 5.0) that embeds the WebBrowser control in a dialog class. In particular, I'll discuss WebBrowser navigation, fonts, printing, and events. Finally, I'll show you how to control an instance of the InternetExplorer automation object from Visual Basic®.</p>
<h2>Getting the Internet Client SDK</h2>
<p>
If you are a Microsoft Site Builder Network member (level 1, 2, or 3) or a Microsoft Developer Network member, the new Internet Client SDK should already have been shipped to you on CD-ROM, along with the IE 4.0 Platform Preview. If you haven't received it, you can download the Internet Client SDK directly from http://www.microsoft.com/workshop/prog/inetsdk. </p>
<p>
You also need to install IE 4.0 and a subset of the latest Win32® development files (available as part of the Internet Client SDK installation and elsewhere) to build and run programs that use the Internet Client SDK. You can install IE 4.0 from the Internet Client SDK CD-ROM, or you can download it from http://www.microsoft.com/ie/ie40. Remember, the IE 4.0 Platform Preview is meant as a developer release only, which implies that some of the documented SDK functionality may still reflect work in progress, with no official support available.</p>
<h2>Overview </h2>
<p>
The Internet Client SDK was designed for all types of Internet developers. Whether you're a content provider, an ActiveX component developer, or a traditional application developer, the Internet Client SDK has a section geared to you. With this in mind, the SDK is organized into a number of categories: Authoring for the Desktop and Web, Component Development, Internet Application Development, and the Component Library. Each category is a separate, downloadable component so you can easily download only the information that interests you. Figure 1 provides a more detailed look at what each category contains.</p>
<p><img src="inetsdk1fig01.gif"></p>
<p><b>Figure 1: Internet Client SDK Overview</b></p>
<p>
The first category, Authoring for the Desktop and Web, is targeted at Internet content providers (ICPs) who are interested in learning about Dynamic HTML authoring, using ActiveX components in their designs, and implementing scripting. It contains information on how you can use the new Active Desktop™ capabilities of IE 4.0 to deliver content to the user's desktop. This section also contains complete Internet Explorer, Dynamic HTML, VBScript, and JScript™ documentation. </p>
<p>
The&nbsp;second&nbsp;category,&nbsp;Component Development, is a valuable reference for the serious ActiveX developer. Not only does it contain the latest ActiveX standards and references, it also has a great introduction to COM for ActiveX newbies. It also covers ActiveX control containers, Active&nbsp;documents,&nbsp;ActiveX&nbsp;scripting engines, services, and even the SDK for Java™.</p>
<p>
The third category, Internet Application Development, is for developers working with&nbsp;Visual&nbsp;Basic&nbsp;or&nbsp;Visual&nbsp;C++.&nbsp;It contains detailed information on the Internet Explorer Web browsing objects, the Windows® Internet API (WinInet API), the Windows Shell API, the Common Controls API, the NetMeeting™ API, and many other technologies that will add value to Windows-based applications.</p>
<p>
The final category, the Component Library, is for anyone looking for the <br>
latest and greatest Internet ActiveX controls to use in their development. It contains references to the Microsoft Chat control, the ActiveMovie™ control, NetShow™, the Tabular Data control, the Advanced Data Connector, and the Microsoft Dynamic HTML multimedia controls.</p>
<p>
Although the Internet Client SDK contains a plethora of information, it is organized in a straightforward manner, so you should be able to quickly find what you're looking for. If you're new to Internet-based development and not sure where to get started with the SDK, I recommend browsing through the categories that interest you most; I'm sure something will spark your interest. For the rest of this article, I'll concentrate on the Web browsing objects covered in the Internet Application Development category.</p>
<h2>Web Browsing Objects</h2>
<p>
There are two Web browsing objects that can be used in your Visual C++ and Visual Basic-based applications: WebBrowser and InternetExplorer. The WebBrowser object gives you the power to embed Web browsing capabilities into your custom application windows. The InternetExplorer object, on the other hand, allows you to control a remote instance of the Internet Explorer application. Although WebBrowser and InternetExplorer share the same interface (IWebBrowser2), only some of the properties, methods, and events apply to each object (see Figure 2). (The WebBrowser control isn't actually installed from the SDK; it's part of Internet Explorer that's documented in the SDK.)</p>
<p><img src="inetsdk1fig02.gif"></p>
<p><b>Figure 2: WebBrowser and InternetExplorer Properties, Methods, and Events</b></p>
<p>
Both IE 3.0 and IE 4.0 use the WebBrowser control to implement Web browsing functionality. The main difference between these two versions of Internet Explorer is the design of the control container. Like most controls, the WebBrowser component is an in-process server, so it must be hosted by another process. IE 3.0 hosts the control within its own process space as a standalone application. IE 4.0, on the other hand, allows the control to be hosted by the Windows shell. This important design change allowed Microsoft to integrate its Internet technologies with the Windows shell, and this shell integration represents the core new technology in IE 4.0 and a feature of Windows 98.</p>
<h2>WebBrowser Sample Application</h2>
<p>
Using Visual C++ 5.0, I'll walk you through the creation of a simple MFC program (MyBrowser) that illustrates how to use the WebBrowser control in a dialog class. To begin, create a new project and select MFC AppWizard (exe) from the list of project types. Choose a location for the project and give it a name (MyBrowser). To keep things simple, choose Dialog-based for the application type. Finally, make sure the ActiveX Controls checkbox is checked so the project can contain controls; MyBrowser has to be a control container in order to host the WebBrowser control. If you forget to check ActiveX Controls, you can manually make your program a control container by adding a call to AfxEnableControlContainer in the application object's InitInstance method. Once you finish with the wizard, you'll have a simple framework that's capable of hosting the WebBrowser control.</p>
<h2>Adding WebBrowser to Your Project</h2>
<p>
The most efficient way to insert an ActiveX control into a Visual C++ 5.0-based project is through the Components and Controls Gallery. You can open the Components and Controls Gallery by selecting Project | Add to Project | Components and Controls from the menu. When you open the Components and Controls Gallery, it quickly parses through the Windows registry and generates a database containing all registered components and controls. Assuming you've installed IE 4.0, the WebBrowser control should already be registered with Windows and, therefore, available in the Components and Controls Gallery. To find the WebBrowser control, open the Registered ActiveX Controls folder and scroll until you find the control labeled Microsoft Web Browser (see Figure 3).</p>
<p><img src="inetsdk1fig03.gif"></p>
<p><b>Figure 3: Finding the WebBrowser control</b></p>
<p>
To insert the WebBrowser control into your project, <br>
select Microsoft Web Browser and click Insert. The WebBrowser control generates&nbsp;a&nbsp;single&nbsp;class&nbsp;called CWebBrowser2 (named after the IWebBrowser2 interface). Verify the file names (the defaults are fine) and click OK. Now, if you go to the Developer Studio class view, you'll find the newly generated CWebBrowser2&nbsp;class.&nbsp;You'll&nbsp;use an instance of this class for each WebBrowser object in your program.</p>
<h2>The WebBrowser Dialog</h2>
<p>
Now I'm ready to create an instance of the WebBrowser control in the application dialog class. Since I created a dialog-based application, there is already a wizard-generated dialog class in the project called CMyBrowserDlg. The dialog template associated with CMyBrowserDlg, IDD_ MYBROWSER_DIALOG, is where I'll embed the WebBrowser control. </p>
<p>
If your common controls toolbar is visible, notice that the WebBrowser control icon is now available in the palette (see Figure 4). Any control that is inserted into a project via the Components and Controls Gallery will be available in that project's common controls toolbar.</p>
<p><img src="inetsdk1fig04.gif"></p>
<p><b>Figure 4: Palette</b></p>
<p>
To embed the WebBrowser control in the dialog, click on the WebBrowser icon in the common controls toolbar and then size it within the template. To modify the control's properties, right-click on the control in the dialog template and select Properties. For the WebBrowser control, four properties can be set in the property sheet: Offline, RegisterAsBrowser, RegisterAsDropTarget, and Silent. The rest of the WebBrowser properties must be set at runtime. Give the WebBrowser control a resource ID or use the default value IDC_EXPLORER1.</p>
<p>
Instead of getting a pointer to the control each time you need one, let's create a CWebBrowser2 member variable in CMyBrowserDlg. Open Class Wizard and go to the Member Variables tab. Map the control ID (IDC_EXPLORER1) to a CWebBrowser2 member variable (m_WebBrowser). Class Wizard will then add a few lines of code to MyBrowserDlg.h and MyBrowserDlg.cpp. </p>
<p>
With the WebBrowser member variable in place, you're ready to start using its properties and methods. Let's start by making the control navigate to the Microsoft homepage when the dialog initializes. Add the following line of code to the dialog's InitInstance method:</p>
<p>
&lt;·05pt line space&gt;</p>
<pre><code>m_WebBrowser.Navigate("http://www.microsoft.com", NULL, NULL, NULL, NULL);</code></pre>
<p>
&lt;·05pt line space&gt;</p>
<p>
Compile and run the program. If you're connected to the Internet, the dialog should appear with the WebBrowser control opened to the Microsoft homepage (see Figure 5).</p>
<p><img src="inetsdk1fig05.gif"></p>
<p><b>Figure 5: WebBrowser Automatic Navigation</b></p>
<h2>WebBrowser Navigation</h2>
<p>
The WebBrowser control exposes a set of navigational methods that represent the main functionality of Internet Explorer. The methods, described in Figure 6, let you navigate to any location on the Internet, your company intranet, or even your local hard drive. </p>
<p><img src="inetsdk1fig06.gif"></p>
<p><b>Figure 6: WebBowser Navigation Methods</b></p>
<p>
To show you just how easy it is to use these methods, let's add several buttons to the dialog template and their associated message handlers to the CMyBrowserDlg message map. I labeled them Back, Forward, Home, Search, Refresh, and Stop. The code for each of the message handlers is as simple as calling the appropriate WebBrowser control method (see Figure 7). For example, to make the WebBrowser control go to the previous page in the file history list, you would use the following line of code:</p>
<p>
&lt;·05pt line space&gt;</p>
<pre><code>m_WebBrowser.GoBack() </code></pre>
<p>
&lt;·05pt line space&gt;</p>
<p>
It can't get much easier than that!</p>
<p><b>Figure 7: MyBrowserDlg.cpp</b></p>
<p><pre><font size=2>// MyBrowserDlg.cpp : implementation file
//

/////////////////////////////////////////////////////////////////////////////
// CMyBrowserDlg dialog

CMyBrowserDlg::CMyBrowserDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CMyBrowserDlg::IDD, pParent)
{
    m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);
}

void CMyBrowserDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMyBrowserDlg)
    DDX_Control(pDX, IDC_COMBO_FONTS, m_Fonts);
    DDX_Control(pDX, IDC_ANIMATE1, m_Animate);
    DDX_Control(pDX, IDC_EXPLORER1, m_WebBrowser);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMyBrowserDlg, CDialog)
    //{{AFX_MSG_MAP(CMyBrowserDlg)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDBACK, OnBack)
    ON_BN_CLICKED(IDFORWARD, OnForward)
    ON_BN_CLICKED(IDHOME, OnHome)
    ON_BN_CLICKED(IDOPEN, OnOpen)
    ON_BN_CLICKED(IDREFRESH, OnRefresh)
    ON_BN_CLICKED(IDSEARCH, OnSearch)
    ON_BN_CLICKED(IDSTOP, OnStop)
    ON_BN_CLICKED(IDPRINT, OnPrint)
    ON_CBN_SELCHANGE(IDC_COMBO_FONTS, OnSelchangeComboFonts)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMyBrowserDlg message handlers

BOOL CMyBrowserDlg::OnInitDialog()
{
    //wizard generated initialization omitted...
    
    m_WebBrowser.Navigate(&quot;http://www.microsoft.com&quot;, NULL, NULL, NULL, NULL);
    m_Fonts.SetCurSel(2);
    if (!m_Animate.Open(&quot;findcomp.avi&quot;))
        AfxMessageBox(&quot;Error opening findcomp.avi&quot;);
    return TRUE;  // focus not set to a control
}


BEGIN_EVENTSINK_MAP(CMyBrowserDlg, CDialog)
         //{{AFX_EVENTSINK_MAP(CMyBrowserDlg)
    ON_EVENT(CMyBrowserDlg, IDC_EXPLORER1, 106 /* DownloadBegin */, 
        OnDownloadBeginExplorer1, VTS_NONE)
    ON_EVENT(CMyBrowserDlg, IDC_EXPLORER1, 104 /* DownloadComplete */, 
        OnDownloadCompleteExplorer1, VTS_NONE)
    ON_EVENT(CMyBrowserDlg, IDC_EXPLORER1, 102 /* StatusTextChange */, 
        OnStatusTextChangeExplorer1, VTS_BSTR)
    //}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void CMyBrowserDlg::OnBack() 
{
    m_WebBrowser.GoBack();    
}

void CMyBrowserDlg::OnForward() 
{
    m_WebBrowser.GoForward();
}

void CMyBrowserDlg::OnHome() 
{
    m_WebBrowser.GoHome();
}

void CMyBrowserDlg::OnSearch() 
{
    m_WebBrowser.GoSearch();
}

void CMyBrowserDlg::OnOpen() 
{
    COpenURLDlg dlg;

    if (IDOK == dlg.DoModal())
    {
        COleVariant vaURL(dlg.m_strURL);
        m_WebBrowser.Navigate2(vaURL, NULL, NULL, NULL, NULL);
    }
}

void CMyBrowserDlg::OnRefresh() 
{
    m_WebBrowser.Refresh();
}


void CMyBrowserDlg::OnStop() 
{
    m_WebBrowser.Stop();
}

void CMyBrowserDlg::OnPrint() 
{
    m_WebBrowser.ExecWB(OLECMDID_PRINT, 0, NULL,NULL);
}

void CMyBrowserDlg::OnSelchangeComboFonts() 
{
    COleVariant vaFontScale((long)m_Fonts.GetCurSel());
    m_WebBrowser.ExecWB(OLECMDID_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER, &amp;vaFontScale, 	        NULL);
}

void CMyBrowserDlg::OnDownloadBeginExplorer1() 
{
    m_Animate.Play(0,-1,-1);
}

void CMyBrowserDlg::OnDownloadCompleteExplorer1() 
{
    m_Animate.Stop();
    m_Animate.Seek(0);
}

void CMyBrowserDlg::OnStatusTextChangeExplorer1(LPCTSTR Text) 
{
    if (GetSafeHwnd())
    {
        CWnd *pWnd = GetDlgItem(IDC_STATUS_TEXT);
        if (pWnd)
            pWnd-&gt;SetWindowText(Text);
    }
}
</font></pre>
<p>
Now let's take a closer look at how some of these navigational methods behave. It's obvious that GoBack and GoForward iterate through the file history list and that Stop cancels any download activity. But what's the difference between Refresh and Refresh2? Refresh simply reloads the current page and gives you no control over how the reload will take place. Refresh2, on the other hand, allows you to pass in a refresh level specifying whether the control should do a lightweight or complete reload of the current page. </p>
<p>
Another not so obvious issue deals with the GoHome and GoSearch behavior. How do I know where these methods will take me? The answer is found in the registry. The WebBrowser control reads the SearchPage and StartPage locations from the registry and navigates to them when GoSearch and GoHome are called. IE 4.0 allows you to customize these locations by going to View | Options and clicking on the Navigation tab. If you modify these settings in the Navigation tab, they'll be written to the registry in the following location:</p>
<p>
&lt;·03pt line space&gt;</p>
<pre><code>HKEY_CURRENT_USERS\Software\Microsoft\Internet Explorer\Main
    SearchPage="http://www.yahoo.com"
    StartPage="http://www.enol.com/~skonnard"</code></pre>
<p>
Using regedit.exe (or regedt32.exe), change the StartPage registry&nbsp;value&nbsp;to&nbsp;a&nbsp;different&nbsp;location&nbsp;while&nbsp;you&nbsp;have&nbsp;IE&nbsp;4.0&nbsp;running, then click Home on the toolbar. The new location you saved in the registry will be loaded. Now, run the sample application again and press the Home button. It will also load the new location in the registry. </p>
<p>
Since this functionality is built into the WebBrowser <br>
control, your application will have to share the SearchPage and StartPage preference information with IE 4.0 unless <br>
you want to implement your own GoSearch and GoHome methods. The following code segment illustrates how this could be accomplished:</p>
<p>
&lt;·05pt line space&gt;</p>
<pre><code>void CMyBrowserDlg::OnHome() 
{
    CString strHomeURL = GetMyHomeRegistryEntry();
    m_WebBrowser.Navigate(strHomeURL, NULL, NULL, NULL, NULL);
}

void CMyBrowserDlg::OnSearch() 
{
    CString strSearchURL = GetMySearchRegistryEntry();
    m_WebBrowser.Navigate(strSearchURL, NULL, NULL, NULL, NULL);
}</code></pre>
<p>
&lt;·05pt line space&gt;</p>
<p>
The GetMyHomeRegistryEntry and GetMySearchRegistryEntry methods would read your application-specific registry entries from wherever you decide to store them. Then, instead of calling GoSearch or GoHome, you call Navigate or Navigate2.</p>
<h2>Navigate vs. Navigate2</h2>
<p>
While there is a subtle difference between Navigate and Navigate2, both methods allow you to open any given URL. First, let's look at the function declaration for Navigate:</p>
<pre><code>HRESULT IWebBrowser2::Navigate( 
    BSTR URL,                            // URL to navigate to 
    VARIANT FAR* Flags,                  // address of option flags 
    VARIANT FAR* TargetFrameName,        // address of frame name for resource 
    VARIANT FAR* PostData,               // address of HTTP POST data 
    VARIANT FAR* Headers,                // address of HTTP headers
    );</code></pre>
<p>
The Flags parameter allows you to specify how you want the browser to behave with the given URL. The possible values are defined in the BrowserNavConstants enumeration:</p>
<pre><code>typedef enum BrowserNavConstants {
    navOpenInNewWindow = 1,
    navNoHistory = 2,
    navNoReadFromCache = 4,
    navNoWriteToCache = 8
} BrowserNavConstants;</code></pre>
<p>
These values can be OR'd together to specify if the URL should be opened in a new window, prevented from entering the history list, read from the cache, or written to the cache. The TargetFrameName parameter allows you to specify the frame in which to display the file. The PostData parameter allows you to send data associated with an HTTP POST request. For example, if you wanted to emulate an HTML form, you could do so by setting PostData with the information gathered from a dialog box and sending it to the appropriate form handler. The final parameter, Headers, allows you to add your own HTTP headers to the request (Content-type, for example). </p>
<p>
The function declaration for Navigate2 is identical to Navigate, with the exception of the first parameter:</p>
<p>
&lt;·07pt line space&gt;</p>
<pre><code>HRESULT IWebBrowser2::Navigate2( 
    VARIANT * URL,                          // PIDL to navigate to 
    VARIANT * Flags,                        // address of option flags 
    VARIANT * TargetFrameName,              // address of frame name for 
    VARIANT * PostData,                     // address of HTTP POST data 
    VARIANT * Headers,                      // address of HTTP headers
    );</code></pre>
<p>
&lt;·07pt line space&gt;</p>
<p>
Navigate2 uses a VARIANT* instead of a BSTR for the type of URL. This change occurred because Navigate2 is capable of navigating to locations that cannot be expressed as URLs, such as a pointer to an item identifier list (PIDL) for an entity in the Windows shell namespace.</p>
<p>
With this understanding of how Navigate and Navigate2 work, let's add another button to the dialog class and label it Open. You'll also need to create a new dialog (COpenURLDlg) to query the user for the new location. It simply needs an edit box and an associated member variable (m_strURL) to hold the location string. OnOpen will navigate to any URL or local file the user specifies:</p>
<p>
&lt;·07pt line space&gt;</p>
<pre><code>void CMyBrowserDlg::OnOpen() 
{
    COpenURLDlg dlg;
    if (IDOK == dlg.DoModal())
    {
        COleVariant vaURL(dlg.m_strURL);
        m_WebBrowser.Navigate2(vaURL, NULL, NULL, NULL, NULL);
    }
}</code></pre>
<p>
&lt;·07pt line space&gt;</p>
<p>
Since the WebBrowser control is also an ActiveX document host, it can be used as a container for objects like Microsoft Excel or Word documents. Run the sample application and click the Open button. Type in the path to a Microsoft Word document located on your system. Amazingly enough, the file is loaded, and even allows editing (see Figure 8). Next type in the path to any folder on your system. The contents of the folder are enumerated and displayed (see Figure 9). </p>
<p><img src="inetsdk1fig08.gif"></p>
<p><b>Figure 8: Editing a Word document in MyBrowser</b></p>
<p><img src="inetsdk1fig09.gif"></p>
<p><b>Figure 9: Viewing folder contents in MyBrowser</b></p>
<h2>Changing Fonts and Printing</h2>
<p>
The WebBrowser control does not support a method that allows the user to change the font size. IE 4.0, however, allows you to choose from a five-level font scale: Largest, Larger, Medium, Smaller, and Smallest. This scale allows you to change the relative size of the font being displayed by the WebBrowser control. How does IE 4.0 provide this functionality? Through the IOleCommandTarget interface. </p>
<p>
In the previous version of the WebBrowser control, this process was a bit complicated. First you had to get the IDispatch pointer to the WebBrowser document object. Then you had to call QueryInterface on the IDispatch pointer looking for IOleCommandTarget. Finally, once you had the IOleCommandTarget interface pointer, you could call IOleCommandTarget::Exec, passing in OLECMDID_ZOOM along with the desired font scale (0-4). To illustrate this, I added a combo box to CMyBrowserDlg and filled it with values of Largest, Larger, Medium, Smaller, and Smallest. OnComboFontSelChange gets called each time the combo box selection changes (see Figure 10).</p>
<P>
<b>Figure 10: Changing Font Scaling</b></p><P>
<pre><font size=2>void CMyBrowserDlg::OnComboFontsSelChange() 
{
    COleVariant vaFontScale((long)m_Fonts.GetCurSel());
    LPDISPATCH pDispatch = NULL;
    LPOLECOMMANDTARGET pCommandTarget = NULL;

    pDispatch = m_WebBrowser.getDocument();
    ASSERT(pDispatch);

    pDispatch-&gt;QueryInterface(IID_IOleCommandTarget, (LPVOID*)&amp;pCommandTarget);
    ASSERT(pCommandTarget);

    pCommandTarget-&gt;Exec(NULL,
        OLECMDID_ZOOM,
        OLECMDEXECOPT_DONTPROMPTUSER,
        &amp;vaFontScale,
        NULL);
    if (pCommandTarget)
        pCommandTarget-&gt;Release(); 
    if (pDispatch)
        pCommandTarget-&gt;Release(); 
}
</font></pre>
<p>
The new version of the WebBrowser control simplifies this process by adding the IWebBrowser2::ExecWB method, which encapsulates the process of getting the interface pointers and releasing them when finished:</p>
<p>
&lt;·08pt line space&gt;</p>
<pre><code>HRESULT IWebBrowser2::ExecWB(
    long cmdID, 
    long cmdexecopt, 
    VARIANT * pvaIn, 
    VARIANT * pvaOut
    );</code></pre>
<p>
&lt;·08pt line space&gt;</p>
<p>
This is how OnComboFontsSelChange is implemented using the IWebBrowser2::ExecWB method:</p>
<pre><code>void CMyBrowserDlg::OnComboFontsSelChange() 
{
    COleVariant vaFontScale((long)m_Fonts.GetCurSel());
    m_WebBrowser.ExecWB(OLECMDID_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER, 
                        &amp;vaFontScale, NULL);
}</code></pre>
<p>
I love that kind of simplification! You can also implement printing with IWebBrowser2::ExecWB. The OnPrint method is even simpler-just one line of code:</p>
<pre><code>void CMyBrowserDlg::OnPrint() 
{
    m_WebBrowser.ExecWB(OLECMDID_PRINT, 0,  
        NULL,NULL);
}</code></pre>
<h1>WebBrowser Events</h1>
<p>
The WebBrowser control fires a variety of events in response to user commands, navigation status, and property changes. For example, when a download operation is beginning, the control fires a DownloadBegin event. Then, as the progress of the download operation changes, the control fires ProgressChange events. Finally, when the download operation is complete, the control fires a final DownloadComplete event. These events can be very useful for displaying feedback to the user of the application. Figure 11 describes the events supported by the WebBrowser control.</p>
<p><img src="inetsdk1fig11.gif"></p>
<p><b>Figure 11: WebBrowser Events</b></p>
<p>
In order to use these events in MyBrowser, I need to implement an event sink. Visual C++ 5.0 has greatly simplified this task. To begin, right-click the WebBrowser control in the dialog template and choose Events. A dialog appears containing a list of all messages and events available for the WebBrowser control (see Figure 12). Select the StatusTextChange event and click Add Handler. After you name the handler and click OK, repeat the process for the DownloadBegin and DownloadComplete events. When you close the events dialog, the event sink and event handlers will be magically added to the CMyBrowserDlg class.</p>
<p>
Understanding what the wizard is doing behind the scenes is always helpful. To implement an event sink manually, <br>
begin by adding the following macro to MyBrowserDlg.h immediately after the DECLARE_MESSAGE_MAP macro:</p>
<pre><code>DECLARE_EVENTSINK_MAP()</code></pre>
<p>
Second, add the following lines of code to MyBrowser.cpp:</p>
<pre><code>BEGIN_EVENTSINK_MAP(CWebBrowserDlg, CDialog)
    ON_EVENT(CWebBrowserDlg, IDC_EXPLORER1, DISPID_STATUSTEXTCHANGE, 
        OnStatusTextChange,  VTS_BSTR)
    ON_EVENT(CWebBrowserDlg, IDC_EXPLORER1, DISPID_DOWNLOADBEGIN, 
        OnDownloadBegin, NULL)
    ON_EVENT(CWebBrowserDlg, IDC_EXPLORER1, DISPID_DOWNLOADCOMPLETE, 
        OnDownloadComplete, NULL)
END_EVENTSINK_MAP()</code></pre>
<p>
You'll need one ON_EVENT macro for each message you want to handle. Finally, add the following event handler declarations to the CMyBrowserDlg class definition:</p>
<pre><code>afx_msg void OnDownloadComplete();
afx_msg void OnDownloadBegin();
afx_msg void OnStatusTextChange(BSTR strText);</code></pre>
<p>
Whether you have to add the event sink manually or get the pleasure of working with Visual C++ 5.0, both methods work. With the event sink in place, you're ready to write the event handler routines to improve user feedback. </p>
<p>
Let's add an animation control to the dialog box and have it open a simple AVI file (findcomp.avi). In the OnDownloadBegin handler, the animation control begins to play, and in OnDownloadComplete it stops and resets itself:</p>
<p>
&lt;·03pt line space&gt;</p>
<pre><code>void CMyBrowserDlg::OnDownloadComplete()
{
    m_Animate.Stop();
    m_Animate.Seek(0); 
}

void CMyBrowserDlg::OnDownloadBegin()
{
    m_Animate.Play(0,-1,-1); //play repeatedly
}</code></pre>
<p>
&lt;·03pt line space&gt;</p>
<p>
&lt;Manuscript&gt;Another way to show the user what's going on is through<br>
 a status bar. The StatusTextChange event will notify the dialog when the status text has changed. To implement a status bar within CMyBrowserDlg, I added a static text control whose value will be changed every time OnStatusTextChange gets called:</p>
<p>
&lt;·03pt line space&gt;</p>
<pre><code>void CWebBrowserDlg::OnStatusTextChange(BSTR strText)
{
    CWnd *pWnd = GetDlgItem(IDC_STATUS_TEXT);
    if (pWnd)
    pWnd-&gt;SetWindowText((LPCTSTR)strText);
}</code></pre>
<p>
&lt;·03pt line space&gt;</p>
<p>
Now when you run MyBrowser.exe and open a URL, the AVI file starts playing while the status bar informs the user of the download progress. Also, as you run the cursor over hyperlinks, the linked URL is displayed in the status bar (see Figure 13). As you can see, using WebBrowser events helps create a more user-friendly application shell around the WebBrowser control.</p>
<h2>InternetExplorer Object</h2>
<p>
So far I've shown you how to embed the WebBrowser <br>
control within a dialog class. This approach allows you to create a frame window for the control that fits your needs exactly. This can be useful in many situations. For example, I'm currently developing an Internet-based product ordering system in which server-side errors are passed back to <br>
the application in the form of HTML. The WebBrowser control is a perfect solution for displaying the errors and integrating them with the online help system. Visual C++ 5.0 is another example; it now uses the WebBrowser control to view help media. </p>
<p>
While embedding the control within a custom frame can improve the quality of your applications tremendously, it requires more work and time to develop the frame window. Another approach is to use the InternetExplorer object, which allows you to control an instance of IE 4.0 via Automation.</p>
<p>
As I mentioned previously, the InternetExplorer object uses the same interface (IWebBrowser2) as the WebBrowser object. In other words, you can control the InternetExplorer object by using the same techniques I described previously for WebBrowser controls. Although the solution is not as flexible as creating your own frame window, using the InternetExplorer object exposes a wider range of properties, methods, and events than the WebBrowser object (see Figure 2). This allows for greater customization of the IE 4.0 frame window. In particular, you can set properties like Toolbar, StatusBar, FullScreen, Visibility, and so on. </p>
<p>
Let's take a quick look at some Visual Basic code that creates and controls an instance of the InternetExplorer object (see Figure 14). To create an instance of InternetExplorer, you need to call CreateObject and pass in InternetExplorer.Application for the program ID. Then, in order for the IE 4.0 window to appear, you must also set the Visible property to True.</p>
<p>
Once the object is created, you're able to customize its appearance and functionality through its properties and methods. To give you a simple example, I created a form that launches IE 4.0 and controls some of its UI and behavior. Figure 15 shows the form and the instance of IE 4.0 it controls. Notice the hidden toolbar, status bar, and menu resulting from the properties set in LaunchIE_Click. While this example is very basic, it illustrates how the InternetExplorer object allows you to control IE 4.0 from your own app.</p>
<h2>Conclusion</h2>
<p>
The new Internet Client SDK has a tremendous amount of information to offer all developers of Internet-based applications. While the Internet Client SDK is organized effectively, the sheer amount of information can be overwhelming. </p>
<p>
The Web browsing objects WebBrowser and InternetExplorer both provide simple solutions to previously complex problems. WebBrowser gives you more control over the appearance and handling of your custom browser windows. The InternetExplorer object allows you to easily build on the IE 4.0 application window. Whether you decide to use an <br>
embedded WebBrowser control or an InternetExplorer Automation interface, Web browsing objects will add value to your applications.                                                                                               </p>
</font></BODY>
</HTML>
