<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Understanding finalize()</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<h1>Understanding finalize()</h1>
<p>
<i>by Tim Gooch</i></p>
<p>
In many ways, Java is like C++. Java's syntax is very similar to C++; Java has classes, methods, and data members; Java classes have constructors; Java has exception handling. </p>
<p>
However, Java is also missing some features that you're probably familiar with if you've used C++. One of those missing features is destructors. Instead of using destructors, Java supports the finalize() method.</p>
<p>
In this article, we'll describe how finalize() differs from C++ destructors. In addition, we'll create a simple applet that demonstrates how finalize() works.</p>
<h2>The final frontier</h2>
<p>
Unlike Java, C++ supports local objects (stack-based) as well as global objects (heap-based). Because of this dual support, C++ also provides automatic construction and destruction, which results in constructor and destructor calls, and (for heap objects) memory allocation and deallocation.</p>
<p>
In Java, all objects reside in heap memory, solocal objects aren't possible. As a result, Java's designers didn't feel that destruction (as C++ implements it, anyway) was necessary.</p>
<p>
Instead, Java defines a special method named finalize(), which provides some of the behavior of C++ destructors. However, finalize() doesn't perform exactly like a C++ destructor, and assuming that it does can lead to serious problems. A key element of the finalize() method's behavior is the Java garbage collector.</p>
<h2>The garbage collector</h2>
<p>
In C/C++, Pascal, and several other general-purpose programming languages, the developer is responsible for playing an active role in memory management. For example, if you allocate memory for an object or data structure, you have to release that memory when you've finished using it.</p>
<p>
In Java, when you create an object, the Java Virtual Machine (JVM) allocates space for the object, calls the constructor, and then begins tracking your use of the object. When you stop using an object (that is, when there aren't any valid references to that object), the JVM marks that object for release by the garbage collector. </p>
<p>
As the garbage collector is about to release an object's memory, it calls the object's finalize() method (if it defines one). The garbage collector runs in a separate, low-priority thread and only releases the memory for an object when other pending needs for that memory are present. (Actually, you can call the System.gc() method to force the garbage collector to attempt to release the memory for these objects.)</p>
<p>
There are a couple of important things to note about the above description. First, finalize() executes only when the garbage collector releases memory for an object. If the garbage collector doesn't release memory before the applet or application exits, the garbage collector won't call finalize().</p>
<p>
Second, unless the garbage collector determines that your applet/application needs additional memory, it may not attempt to release the memory for unused objects. In other words, it's entirely possible that an applet could allocate a small number of objects, not make serious memory requests, and exit without the garbage collector ever having released the memory for those objects. </p>
<p>
Obviously, if you've defined a finalize() method for the objects in question, the JVM won't call it, because the garbage collector never reclaims the memory for those objects. Calling System.gc() doesn't help here either, because it's only a suggestion to the JVM--not a demand.</p>
<h2>What's finalize() good for?</h2>
<p>
Now, if finalize() isn't a destructor, and the JVM doesn't always call it, you might wonder whether it's good for anything at all. In fact, it's not good for much in Java 1.0.</p>
<p>
According to the Java documentation, finalize() is a method you should use to perform deallocation of non-Java resources. However, given the potential for the JVM not to call finalize() for an object, it's hard to justify using this method to release resources.</p>
<p>
Java 1.1 partially addresses this issue by providing a System.runFinalizersOnExit() method. (Don't confuse this method with the System.runFinalizations() method that's available in Java 1.0.) Unlike the System.gc() method, System.runFinalizersOnExit() doesn't attempt to perform garbage collection right away. Instead, it calls finalize() for every object as the application or applet exits.</p>
<p>
As you might guess, forcing the garbage collector to clean up all outstanding objects by calling System.runFinalizersOnExit() can cause significant delays as the cleanup code executes. Now let's build a simple applet that demonstrates how the Java garbage collector and the finalize() method interact.</p>
<h2>Collect this garbage</h2>
<p>
Begin by creating a new applet using the Java Applet Wizard. When prompted to do so, enter <i>final_things</i> as the applet name, and choose not to generate source-file comments.</p>
<p>
Next, proceed to step three in the Java Applet Wizard, and choose the <i>No</i> option for multi-threading. Advance to the fifth step, and modify the applet description if necessary. </p>
<p>
When you click Finish, the Applet Wizard will generate a new workspace, and create the default Java file for the project. Enter the appropriate code from Listing A (we've highlighted the code you'll need to enter).</p>
<p>
When you've finished entering the code, configure Internet Explorer to write System.out messages to the Javalog.txt file. (Select Enable Java Logging in the Advanced page of the IE Options dialog box.) </p>
<p>
Build and run the applet. Then, wait for the applet to run (you'll see the Applet Started message in the status bar), exit the browser, and open the Javalog.txt file. You'll find something similar to the following lines:</p>
<pre>1000 things constructed
<code>0 things finalized</code></pre>
<p>
As you can see, building 1,000 thing objects doesn't force the garbage collector to begin reclaiming space, even though none of the objects are in use at the time the applet exits.</p>
<p>
Now, remove the comment tokens in the first line of the stop() method to enable the call to the System.gc() method. Build and run the applet again, wait for the applet to finish running, and exit the browser. When you open the Javalog.txt file again, you'll see the lines</p>
<pre>1000 things constructed
<code>963 things finalized</code></pre>
<p>
This time, the garbage collector determined that most of the thing objects weren't in use, and it reclaimed the space for most of them. In turn, as the garbage collector began releasing the memory for those objects, the JVM called their finalize() methods.</p>
<h2>Inherited finalize()?</h2>
<p>
By the way, if you define finalize() in a class, it won't call the base-class version automatically. After our discussion of how finalize() differs from C++ destructors, this result shouldn't be surprising, because the custom cleanup code for one class may not be necessary for another. </p>
<p>
If you decide that you want to invoke a base class's version of finalize() from a derived class's finalize() method, you do so like you would any other inherited method, as in</p>
<pre>protected void finalize()
<code>{</code>
<code>  super.finalize();</code>
<code>  // other finalization code...</code>
<code>}</code></pre>
<p>
In addition to granting you control over whether or not the cleanup will occur, this technique gives you control over when it will happen within the current class's finalize() method. </p>
<h2>Conclusion</h2>
<p>
While helpful, Java's automatic garbage collection is not without its trade-offs. In exchange for convenience, you give up some control over how system resources are released. Unlike destructors in C++, a Java applet won't automatically execute the finalize() method for your classes. In fact, if you're using Java 1.0, there's no guarantee that it will call finalize(), even if you try to force it to do so. </p>
<p>
Therefore, you shouldn't depend on finalize() to perform resource cleanup for your applets and applications. Instead, you should explicitly clean up those resources or create a try...finally block (or some similar mechanism) to do so. </p>
<p>
<b>Listing A: final_things.java</b></p>
<pre><code>import java.applet.*;
import java.awt.*;

class thing
{
  public static int thingcount = 0;
  public static int thingfinal = 0;

  public thing()
  {
    ++thingcount;
  }


  protected void finalize()
  {
    ++thingfinal;
  }
}

public class final_things extends Applet
{

  public final_things()
  {
  }

  public String getAppletInfo()
  {
    return "Name: final_thing\r\n" +
           "Author: Tim Gooch\r\n" +
           "Created with Microsoft " +
           "Visual J++ Version 1.1";
  }


  public void init()
  {
      resize(320, 240);

  }

  public void destroy()
  {
  }

  public void paint(Graphics g)
  {
    g.drawString("Created with Microsoft" + 
      "Visual J++ Version 1.1", 10, 20);
  }

  public void start()
  {
    while(thing.thingfinal &lt; 1)
    {
      new thing();
    }
  }
  
  public void stop()
  {
    // System.gc();
    System.out.println(thing.thingcount + 
      " things constructed");
    System.out.println(thing.thingfinal + 
      " things finalized");
  }

}
</code></pre>
</font></BODY>
</HTML>
