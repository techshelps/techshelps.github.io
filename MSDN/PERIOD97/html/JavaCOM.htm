<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Understanding the JAVA/COM Integration Model</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<font face="verdana,arial,helvetica" size="2"><form name=x><object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object></form>
<h1>Understanding the JAVA/COM Integration Model</h1>
<p>
Corporate intranets that rely upon machine-independent Java™ programs are increasingly popular. But what about all those Component Object Model (COM) objects you built before the switch? Can you still use them? The answer for Windows® users is yes-if you're using Microsoft's Java Virtual Machine (VM). The tools for integrating Java and COM are found in Microsoft's Java development environment, Visual J++™.</p>
<p>
As you probably know, one of the major goals of COM is language-independence. What you may not realize is that COM was also designed to be platform-independent. Windows was the first platform for which COM was made available, but nothing in COM is tied to features specific to Windows. In fact, Distributed COM (DCOM) is currently available in beta form on Solaris. For now, however, Java programs that use COM objects will run only under Windows.</p>
<p>
In this article we will examine both sides of the Java/COM integration model: how Java programs use COM objects and how to create COM objects in Java. First we'll show you how to incorporate COM objects built in Visual C++® and Visual Basic® into your Java programs. Then we'll show you how to build COM objects in Java and access them using Visual C++, Visual Basic, and Visual J++.</p>
<h2>The Java VM and Visual J++</h2>
<p>
Microsoft was able to integrate Java and COM without adding any keywords or constructs to the Java language. The COM support resides in the Java VM, which Microsoft® Internet Explorer uses to run Java applets and JView uses to run standalone Java programs. The Java VM currently ships as part of Internet Explorer 3.0 (IE 3.0), but future versions of Windows will probably ship with a Java VM in the box.</p>
<p>
The Java/COM integration model is based on type libraries-a mechanism defined by COM to store type information. Each type library contains complete type information about one or more COM entities, including classes, interfaces, dispinterfaces, and others.  A Java program can call any COM object for which type library information is available. This type library information may be available as a TLB file or as a resource within the component. The OLE Object View utility that comes with Visual J++ is good for exploring type libraries, either as TLB files or embedded within components.</p>
<p>
Visual J++ includes special tools for integrating COM objects with Java programs: a Java Type Library Wizard and two command-line tools, JavaTLB and JavaReg. The JavaTLB utility converts type library information into Java .class files; JavaReg lets you register Java classes. The Java Type Library Wizard (see Figure 1) automates the creation of Java class wrappers.</p>
<p><img src="javacomfig01.gif"></p>
<p><b>Figure 1: The Java Type Library Wizard</b></p>
<p>
To obtain the list of COM objects, the Java Type Library Wizard hunts through the HKEY_CLASSES_ROOT\TypeLib keys in the registry looking for all COM objects with valid type library information. It then displays those entries with the user-friendly name found in the version number key for the type library settings. This is usually the helpstring parameter for the library found in the ODL file. </p>
<p>
Check the COM components you want to use and click OK. The Java Type Library Wizard then automatically invokes the JavaTLB utility to convert the type library information into Java .class files. If you stop to think about it, JavaTLB is a rather amazing utility; it takes the type library information contained in a TLB, OLB, OCX, DLL, or EXE file and spits out Java .class files, one for each of the classes and interfaces described by the type library. By default, these .class files are placed in a new subdirectory, normally beneath C:\Windows\Java\Trustlib, with the same name as the type library. The actual trusted library directory is defined by the HKEY_LOCAL_MACHINE\Software\Microsoft\Java VM\TrustedLibsDirectory key in the registry. (We'll discuss trusted and untrusted applets later.)</p>
<p>
You might wonder how a program crosses the bridge from Java bytecode to a COM object. Well, each .class file generated by JavaTLB contains a special attribute identifying it as a wrapper for a COM class. When the Java VM (msjava.dll) sees this attribute on a class, it translates all Java method invocations on the class into COM function calls on the COM class. </p>
<h2>Preparing a Visual C++ COM Object for Visual J++</h2>
<p>
Before diving into the details of how to use a Visual C++ COM object in a Java program, let's briefly review how to create a COM object in Visual C++. As you may know, COM programming in C++ is not for the faint of heart. That's why we need tomes like Kraig Brockschmidt's <i>Inside OLE</i> (Microsoft Press, 1995) to explain it to us mere mortals. Most people who actually do COM programming use Visual <br>
C++, its wizards, and MFC. While this makes COM programming significantly easier, it also means you have to wade through thousands of lines of code you didn't write and don't understand. </p>
<p>
Be that as it may, here are the steps for creating a COM object in Visual C++:
<p>1. Open Visual C++.<br><br></p>
<p>2. Click File | New. Select Project Workspace and click OK.<br><br></p>
<p>3. Select MFC AppWizard (dll) and enter the name VCWidget. Click Create.<br><br></p>
<p>4. Check the box to add OLE Automation support to your DLL.<br><br></p>
<p>5. Click Finish, then click OK.<br><br></p>
<p>6. Click View | ClassWizard and select the OLE Automation tab.<br><br></p>
<p>7. Click Add Class and select New.<br><br></p>
<p>8. Enter the name DooHickey. Set the base class to CCmdTarget.<br><br></p>
<p>9. Select the OLE Automation option Createable by type ID and click Create.<br><br></p>
<p>10. Click Add Method. Enter the external name Greet and set the return type to void.<br><br></p>
<p>11. In the Parameter list, add a message parameter of type LPCTSTR. Click OK.<br><br></p>
<p>12. Click Add Method. Enter the external name Sum and set the return type to long.<br><br></p>
<p>13. In the Parameter list add X and Y parameters, both of type long. Click OK.<br><br></p>
<p>14. Click Edit Code, then modify the code as follows:</p><pre><code>////////////////////////////////////////////////////////////////////////
// DooHickey message handlers

void DooHickey::Greet(LPCTSTR Message)
{
        AfxMessageBox(Message);
}

long DooHickey::Sum(long X, long Y)
{
        return X + Y;
}</code></pre>
<p>15. Edit the code in the DooHickey.cpp file as shown in <b>Figure 2</b>.<br><br></p>
<p><img src="javacomfig02.gif"></p>

<p>16. Click File | Save All.<br><br></p>
<p>17. Click Build | Build VCWidget.dll.<br><br></p>
<p>18. Click Tools | Register Control. Click OK.<br><br></p>
<p>19. Close Visual C++.</p>

<p>
To use the COM class you created in Visual C++ from Java, you must first use the JavaTLB utility to generate the Java-callable wrappers-the .class files. Visual C++ does not automatically register the type library when you build a COM component, so you can't use the Java Type Library Wizard to import it. We used the following the command line to import the COM component created in Visual C++:</p>
<pre><code>javatlb /U:T vcwidget.tlb</code></pre>
<p>
The command-line option /U:T creates a text file (summary.txt) with class signature information. The output looks something like this:</p>
<pre><code>Microsoft (R) Visual J++ Java Typelib Conversion Utility Version 1.00.6235
Copyright (C) Microsoft Corp 1996. All rights reserved.</code></pre>
<pre><code>import vcwidget.*;
C:\WINDOWS\java\trustlib\vcwidget\summary.txt(1): Class summary information created</code></pre>
<p>
JavaTLB places the summary.txt and class files in %windir%\<br>
java\trustlib\<i>type_library_name</i>, where %windir% is the Windows installation directory. The summary.txt file contained the following explanation:</p>
<pre><code>public class vcwidget/DOOHICKEY extends java.lang.Object
{
}
public interface vcwidget/IDooHickey extends com.ms.com.IUnknown
{
    public abstract int Sum(int, int);
    public abstract void Greet(java.lang.String);
}</code></pre>
<p>
There are several things worth noting about the summary.txt file. In the declaration of the class or interface, the packagename/classname format strictly provides information about which package the class or interface belongs to. An identifier like vcwidget/IDooHickey is not legal in Java. Also notice that only interfaces have methods; classes do not. When using the Java-callable wrappers for COM objects, you must always call methods through an interface, not through the class itself. This limitation is built into the Java VM to parallel the COM model of access through interfaces. </p>
<h2>Preparing a Visual Basic COM Object for Visual J++</h2>
<p>
Visual Basic can also be used for COM programming by virtue of its ability to create OLE Automation servers, although most developers don't consider Visual Basic a serious contender in the COM programming arena. Instead, Visual Basic is usually employed to combine components created in lower-level languages like C++. Still it's possible; here's how you do it.</p>
<p>
1.Open Visual Basic.</p>
<p>
2.Click File | Remove File to remove the form and start a new project.</p>
<p>
3.Click Insert | Class Module. A code window for Class1 will appear.</p>
<p>
4.In the Object box, select Class.</p>
<p>
5.Enter the following code:</p>
<pre><code>Private Sub Class_Initialize()
    MsgBox "Initialize, from Visual Basic"
End Sub</code></pre>
<p>
6.In the Proc box, select Terminate.</p>
<p>
7.Enter the following code:</p>
<pre><code>Private Sub Class_Terminate()
    MsgBox "Terminate, from Visual Basic"
End Sub</code></pre>
<p>
8.Click Insert | Procedure.</p>
<p>
9.In the Name box, type Greet. Click OK.</p>
<p>
10.Enter the following code:</p>
<pre><code>Public Sub Greet(Message As String)
    MsgBox Message
End Sub</code></pre>
<p>
11.Click Insert | Procedure.</p>
<p>
12.In the Name box, type Sum and select the Function option. Click OK.</p>
<p>
13.Enter the following code:</p>
<pre><code>Public Function Sum(ByVal X As Long, ByVal Y As Long) As Long
    Sum = X + Y
End Function</code></pre>
<p>
14.Click View | Properties.</p>
<p>
15.Set the properties as shown below:</p>
<table border=1 cols=2 frame=box rules=all>
<tr valign=top>
<td width=134><b>Property</b></td>
<td width=198><b>Value</b></td>
</tr>
<tr valign=top>
<td width=134>Instancing</td>
<td width=198>2-Creatable MultiUse</td>
</tr>
<tr valign=top>
<td width=134>Name</td>
<td width=198>DooHickey</td>
</tr>
<tr valign=top>
<td width=134>Public</td>
<td width=198>True</td>
</tr>
</table><br>
<p>
16.Click Tools | Options. Select the Project tab.</p>
<p>
17.Set the project name to VBWidget and StartMode to OLE Server.</p>
<p>
18.Set the application description to VBWidget and click OK.</p>
<p>
19.Click Insert | Module.</p>
<p>
20.Click Insert | Procedure and type Main in the Name box. Click OK.</p>
<p>
21.Click File | Save Project and accept all the default file names.</p>
<p>
22.Click File | Make OLE DLL File. Enter the name VBWidget.dll and Click OK.</p>
<p>
23.Close Visual Basic.</p>
<p>
Since Visual Basic automatically registers the type library when you build a COM component, you can use the Java Type Library Wizard to import the component. Simply open Visual J++ and click Tools Java Type Library Wizard. Then select the VBWidget component and click OK. This will create a vbwidget directory containing the files DooHickey.class, _DooHickey.class, and summary.txt beneath %windir%\<br>
java\trustlib. Summary.txt contains the following data:</p>
<pre><code>public class vbwidget/DooHickey extends java.lang.Object
{
}
public interface vbwidget/_DooHickey extends com.ms.com.IUnknown
{
    public abstract int Sum(int, int);
    public abstract void Greet(java.lang.String[]);
}</code></pre>
<p>
Note that the interface created by Visual Basic has the name _DooHickey, whereas the interface created by Visual C++ has the name IDooHickey. </p>
<h2>Calling a COM Object from Visual J++</h2>
<p>
Once the Java .class files have been generated, you can create a Java applet or application that calls COM objects created in Visual C++ or Visual Basic. Here are the steps:</p>
<p>
1.Open Visual J++.</p>
<p>
2.Click File | New.</p>
<p>
3.Select Project Workspace and click OK.</p>
<p>
4.Select Java Applet Wizard and enter the name ComTest. Click Create.</p>
<p>
5. In Step 3 of the Java Applet Wizard, select "No, thank you" for the multithreading option.</p>
<p>
6.Check the mouseDown() and mouseUp() event handlers.</p>
<p>
7.Click Finish, and then click OK.</p>
<p>
8.To call the Visual C++ COM object, edit the ComTest.java file as shown in Figure 3.</p>
<p><img src="javacomfig03.gif"></p>
<p>
To call the Visual Basic COM object, edit the ComTest.java file as shown in Figure 4. Then run the Java applet inside of Internet Explorer and enjoy the show.</p>
<p><img src="javacomfig04.gif"></p>
<h2>A Look Behind the Scenes</h2>
<p>
The Java code that instantiates the COM class uses the "new" operator:</p>
<pre><code>IDooHickey VCCom = (IDooHickey)new DOOHICKEY();</code></pre>
<p>
Behind the scenes, this code actually performs a call to CoCreateInstance. Equivalent C++ code might look like this:</p>
<pre><code>IDooHickey *pDooHickey;
CoCreateInstance(CLSID_DOOHICKEY, NULL, CLCTX_SERVER, IID_IDooHickey, 
                 (void**)&amp;pDooHickey);</code></pre>
<p>
Also hidden from view is the call to the IUnknown::<br>
QueryInterface function that allows clients to choose among an object's supported interfaces. The simple typecast from the DOOHICKEY class to the IDooHickey interface is an implicit call to the object's QueryInterface function. If an object supports multiple interfaces (a standard capability in COM), simply casting the object to the appropriate interface will yield correct results. If the object does not implement the requested interface and QueryInterface fails, an exception of type ClassCastException is thrown when you attempt the cast. To determine whether an object implements the desired interface before casting, the instanceof operator may be used:</p>
<pre><code>DooHickey myObject = new DooHickey();
if(myObject instanceof IDooHickey)
{
// Now we know that myObject implements IDooHickey
// It is safe to cast (IDooHickey)myObject
}</code></pre>
<p>
Reference counting, another painful COM chore, is handled automatically in Java. There is no need to call IUnknown::AddRef when creating a new reference to an object, nor do you need to call IUnknown::Release when you're finished using a reference to an object. The reference counting is done automatically.</p>
<p>
Note that the import vcwidget.*; statement in Figure 3 and the import vbwidget.*; statement in Figure 4 are not strictly necessary. In Java, any class can be referenced using its fully qualified name (for example, java.awt.Component) as long the class can be found in the class path. The import statement simply allows you to refer to the class using its short name (for example, Component). The same is true for COM classes. So, in Figure 4, the import statement could have been omitted in favor of using the COM object's fully qualified name (vbwidget.DooHickey).</p>
<h2>Handling COM Exceptions in Visual J++</h2>
<p>
In old fashioned procedural programming languages such as C, programmers handled errors primarily through code numbers returned by function calls. It was the programmer's job to test the value returned from a function to determine whether an error had occurred. If so, the programmer would then write code to respond to the error in a logical fashion, as dictated by the context. This style of error handling has the disadvantage of requiring errorhandling code throughout the program, and so rigorous error checking was often neglected. </p>
<p>
Exception handling is a new method of handling errors supported by modern programming languages such as C++ and Java. If an error (called an exception) occurs, execution control is immediately transferred to a special block of error-handling code. In Java, as in C++, exception handling is implemented with the language keywords try, catch, finally, and throw. Code in the try block executes normally until an exception occurs. At that point control is transferred to the catch block, where the error-handling code determines the nature of the error and decides how to respond.</p>
<p>
As a language-independent standard for interoperable binary objects, COM is in a delicate position when it comes to exception handling. Exceptions thrown in one object must be catchable in another, regardless of the language used to create each object. This is the functionality provided by the COM exception-handling mechanism. </p>
<p>
To support COM exception handling in Java, Microsoft's Java VM defines a class called com.ms.com.ComException that derives from the java.lang.RuntimeException class. ComException is the Java class that wraps an HRESULT, the return type for most COM methods. Two subclasses are derived from ComException: ComFailException and ComSuccessException. When calling COM methods from Java, ComFailException is the one you typically catch to handle error conditions. Note that ComException is derived from RuntimeException, so the compiler does not check to see if any vGthods throw ComException objects. If you choose not to handle a ComException exception with a try-catch block, the error is simply ignored. Figure 5 shows what a COM exception handler looks like in Java. Simply make the appropriate changes to the code shown in color.</p>
<p><img src="javacomfig05.gif"></p>
<p>
The following code is an update to the VCWidget component implemented in Visual C++. It raises an exception using the AfxThrowOleDispatchException function the third time the Greet method is called. The Java code shown in Figure 5 will trap this exception and display an error message.</p>
<pre><code>void DooHickey::Greet(LPCTSTR Message) 
{
<b>    static int counter;</b>
<b>    char newMessage[255];</b>
<b>    </b>
<b>    counter++;</b>
<b>    sprintf(newMessage, "%s\nStrike %d", Message, counter);</b>
<b>    AfxMessageBox(newMessage);</b>
<b>    if(counter == 3)</b>
<b>    {</b>
<b>        counter = 0;</b>
<b>        AfxThrowOleDispatchException(1000, "You're out!");</b>
<b>    }</b>
}</code></pre>
<p>
The code shown below is an update to the VBWidget component implemented in Visual Basic. </p>
<pre><code>Public Sub Greet(Message As String)
<b>    Static Counter As Integer</b>
<b>    Counter = Counter + 1</b>
<b>    MsgBox Message &amp; Chr$(13) &amp; "Strike" &amp; Counter</b>
<b>    If Counter = 3 Then</b>
<b>        Counter = 0</b>
<b>        Err.Raise 1000, "You're out!"</b>
<b>    End If</b>
End Sub</code></pre>
<p>
It raises an exception using the Err.Raise method the third time the Greet method is called, and is functionally equivalent to the C++ code shown earlier. Modifying the Java applet to trap this exception from Visual Basic is left as an exercise to the reader. A little hint: you will need to rerun the Java Type Library Wizard after rebuilding your Visual Basic component. The reason? Although the interface hasn't changed, Visual Basic generates a new GUID every time you rebuild a component unless you set a Compatible OLE Server in the Project tab of the Options dialog box.</p>
<p>
When implementing COM classes in Java, you throw ComException objects to signal error conditions. Since ComException is an abstract class, you cannot construct a ComException object directly. Instead, you must construct either a ComFailException or a ComSuccessException object.</p>
<h2>COM Inheritance</h2>
<p>
Just as a Java class can singly inherit the implementation of another Java class using the extends keyword, any Java class can inherit the implementation of any COM object. The syntax for specifying this is exactly as though the superclass were a Java class. Thus COM supports binary inheritance when used from within Java.</p>
<pre><code>import vbwidget.*;

class MySubClass extends DooHickey
{
    public int Sum(int x, int y)
    {
        int z = super.Sum(x, y);
        return -z;
    }
}</code></pre>
<h1>Creating COM Objects in Visual J++</h1>
<p>
Up to this point we've examined how to call COM objects built in various languages from within Java. It is also possible to use Java to implement COM objects. These components can be called from languages such as Visual C++ and Visual Basic, as well as Visual J++. </p>
<p>
Like the rest of the Java/COM integration model, this functionality has been cleanly implemented. In fact, all Java classes are automatically exposed as COM objects. Let's assume you wanted to implement the DooHickey object as a COM class in Java. Figure 6 is the basic Java class. Notice that the class and its methods (except the constructor) are declared as public so they will be accessible from outside the package. </p>
<p><img src="javacomfig06.gif"></p>
<p>
Here are the basic steps for making this class accessible via COM:</p>
<p>
1.Create an ODL file describing the class interface. </p>
<p>
2.Compile the ODL file into a TLB file using the MkTypLib utility. </p>
<p>
3.Set the output directory to %windir%\java\lib, and generate COM class wrappers based on the TLB file using the JavaTLB utility. </p>
<p>
4.Modify your Java code to implement the interfaces defined in the COM class wrappers. </p>
<p>
5.Register the Java class using the JavaReg utility.</p>
<p>
The VJWidget.odl file that describes the Java class shown in Figure 6 would look like Figure 7. Notice that the parameter types used for the methods in the ODL file do not exactly match those used in the Java code. Since COM provides a language-independent binary standard, it needs to play referee between all the different data types used in various languages. Figure 8 shows the type mappings between native Java types and ODL types.</p>
<p><img src="javacomfig07.gif"></p>
<p><img src="javacomfig08.gif"></p>
<p>
Now, build the ODL file with a command like this:</p>
<pre><code>mktyplib /nocpp vjwidget.odl</code></pre>
<p>
The MkTypLib utility produces a VJWidget.tlb type library file for the COM component. If you prefer, you can name the file VJWidget.idl instead of VJWidget.odl, and then build the type library using a recent version of the Microsoft MIDL compiler that comes with Visual C++. The results will be identical. You must create a type library for each set of exposed objects. Because VTBL references are bound at compile time, exposed objects that support VTBL binding must be described in a type library. </p>
<p>
Now run the JavaTLB utility using this command:</p>
<pre><code>javatlb /U:T vjwidget.tlb</code></pre>
<p>
JavaTLB will automatically create a subdirectory called vjwidget beneath %windir%\java\trustlib containing the three files DooHickey.class, IDooHickey.class, and summary.txt. The DooHickey.class and IDooHickey.class files are COM class wrappers for your Java code. In addition to generating these .class files, JavaTLB quietly registers the type library with the registry entries under HKEY_<br>
CLASSES_ROOT as shown in Figure 9. The summary.txt file should contain the following information:</p>
<p><img src="javacomfig09.gif"></p>
<p>
public class vjwidget/DooHickey extends java.lang.Object</p>
<p>
{</p>
<p>
}</p>
<p>
public interface vjwidget/IDooHickey extends com.ms.com.IUnknown</p>
<p>
{</p>
<p>
public abstract int Sum(int, int);</p>
<p>
public abstract void Greet(java.lang.String);</p>
<p>
}</p>
<p>
Now you need to modify the Java code to implement the interfaces described in the COM class wrapper generated by JavaTLB. The finished version of the DooHickey.java code, along with a silly MessageBox class that we built, is shown in Figure 10.</p>
<p><img src="javacomfig10.gif"></p>
<p>
Lastly you need to add the appropriate registry entries so that other programs will be able to find your COM component. While this can be done by hand, the JavaReg utility makes it much easier. A command line like this should do the trick:</p>
<pre><code>javareg /register /class:DooHickey /progid:VJWidget.DooHickey /clsid:{A59DDDB3-
    1472-11d0-AD2F-10005A74E96B}</code></pre>
<p>
Carefully note which UUID from the ODL file is used to register your Java component. You should use the one defined for the coclass. JavaReg will then add the entries shown in Figure 11 into the registry under HKEY_CLASSES_ROOT.</p>
<p><img src="javacomfig11.gif"></p>
<p>
Notice that the in-process server for the VJWidget.DooHickey component is listed as MSJAVA.DLL-Microsoft's Java VM! Since Java code is compiled into bytecode, it can't be called directly from a language like Visual C++. Instead, the Java VM provides the COM support for your Java programs. COM clients think they are working with MSJAVA.DLL, but MSJAVA.DLL is actually running your code. </p>
<p>
Every Java class automatically implements IUnknown and IDispatch via the support in the Java VM. At runtime, the Microsoft Java VM will automatically provide type information for the IDispatch implementation via IDispatch::<br>
GetTypeInfo so that clients can avoid the overhead of using IDispatch::GetIDsOfNames to do late binding. Incidentally, the just-in-time (JIT) compiler is also implemented in MSJAVA.DLL. Some developers seem to be under the mistaken impression that it is part of Visual J++! </p>
<p>
At this point you're almost finished. You just need to make sure that the .class files are in the classpath. An easy way to ensure this is to copy them to the %windir%\java\trustlib directory, as shown here:</p>
<pre><code>copy DooHickey.class c:\windows\java\trustlib
copy MessageBox.class c:\windows\java\trustlib</code></pre>
<p>
To test the component you've built in Java, you can use Visual Basic, Visual C++, or Visual J++. The following examples show how to call the COM object from Visual Basic and Visual C++.</p>
<h2>Calling COM Objects from Visual C++</h2>
<p>
1.Open Visual C++.</p>
<p>
2.Click File | New. Select Project Workspace and click OK.</p>
<p>
3.Select MFC AppWizard (exe) and enter the name ComTestVC. Click Create.</p>
<p>
4.In Step 1 of the MFC AppWizard, select a Single document application.</p>
<p>
5.In Step 3 of the MFC AppWizard, select OLE Automation support.</p>
<p>
6.Click Finish, then click OK.</p>
<p>
7.Click View | ClassWizard.</p>
<p>
8.Click Add Class and select From an OLE TypeLib.</p>
<p>
9.In the Import from OLE TypeLib box, locate the VJWidget.tlb file created previously.</p>
<p>
10.Click Open, then click OK.</p>
<p>
11.In the Messages list box, select WM_LBUTTONDOWN.</p>
<p>
12.Click Add Function, then click Edit Code.</p>
<p>
13.Make the changes shown in Figure 12.</p>
<p><img src="javacomfig12.gif"></p>
<p>
14.Click Build | Execute ComTestVC.exe.</p>
<h2>Calling COM Objects from Visual Basic</h2>
<p>
1.Open Visual Basic.</p>
<p>
2.Click Tools | References.</p>
<p>
3.Check the VJWidget component.</p>
<p>
4.Click OK.</p>
<p>
5.Click View | Properties.</p>
<p>
6.Set the AutoRedraw property to True.</p>
<p>
7.Click View | Code.</p>
<p>
8.In the Object box, select General.</p>
<p>
9.Enter the following code:</p>
<pre><code>Option Explicit
<b>Dim VJCom As VJWidget.IDooHickey</b></code></pre>
<p>
10. In the Object box, select Form.</p>
<p>
11. Enter the following code:</p>
<pre><code>Private Sub Form_Load()
<b>Set VJCom = New DooHickey</b>
End Sub</code></pre>
<p>
12. In the Proc box, select Click.</p>
<p>
13. Enter the following code:</p>
<pre><code>Private Sub Form_Click()
On Error GoTo OhBoy
Print "3 + 4 = " &amp; VJCom.Sum(3, 4)
VJCom.Greet "Hi there, Visual J++, this is Visual Basic here!"
Exit Sub
OhBoy:
Print "On Error handler: " &amp; Err.Number
Print Err.Description
End Sub</code></pre>
<p>
14. Click | Run Start.</p>
<h2>Trusted versus Untrusted Applets</h2>
<p>
Since Java applets can be automatically downloaded over the Internet as a user browses the World Wide Web, security is a big concern. To prevent Java applets from potentially damaging a user's system, applets typically run in a sandbox-a carefully delimited execution environment that prevents applets from posing a security threat. Local file access, for example, is off limits, as are COM services. Note that the sandbox restriction applies only to applets; standard Java applications do not run in the sandbox and therefore may use COM services. </p>
<p>
Microsoft's Java VM categorizes applets as either trusted or untrusted. Untrusted applets run within the sandbox; trusted applets run outside the sandbox and can therefore read and write files and use COM services. All .class files that aren't loaded from the class path-including those downloaded off the Internet-are considered untrusted. Trusted .class files are those that are either loaded from the class path or extracted from a CAB (cabinet) file that has a digital signature. This last caveat enables Java applets to be downloaded over the Internet and still be trusted.</p>
<p>
There are four path-related registry keys that are relevant to the security of Java applets. They are stored in HKEY_<br>
LOCAL_MACHINE\Software\Microsoft\Java VM. Here are the typical values for these keys:</p>
<pre><code>Classpath = C:\WINDOWS\java\classes\classes.zip;C:\WINDOWS\java\classes;
LibsDirectory = C:\WINDOWS\java\lib
TrustedClasspath = C:\WINDOWS\java\trustlib\tclasses.zip
TrustedLibsDirectory = C:\WINDOWS\java\trustlib</code></pre>
<p>
During development with Visual J++, the .class files generated by the active project are considered trusted so you don't have to worry about security issues. If you want to distribute a Java applet that uses COM services, you will need to ensure that your applet runs outside of the sandbox on the user's machine. To do so, you can create digitally signed CAB files for your Java classes using the cabinet and code-signing tools provided in the Cab&amp;Sign directory on the Visual J++ CD. Besides enabling applets to run outside the sandbox, using CAB files for your classes speeds up downloading and makes installation more secure.</p>
<h2>What's ActiveX Got to Do with It?</h2>
<p>
Since COM is the protocol underlying ActiveX™ and OLE, and you can use COM services from Java, then it also must be possible to access ActiveX services, right? Well, in theory this is correct, but it's not easy to do. Using the methods shown in this article, you can call or implement any COM-based interfaces that can be defined in a type library, including ActiveX controls, documents, scripting engines, hyperlinking, and URL monikers. But with no wizards to automate the process and no sample code to guide you, implementing one of these complex objects is a daunting job. In a future release of Visual J++, Microsoft will provide a set of classes with the functionality of the COM library API, but packaged and defined for easier use by Java programmers.</p>
<p>
It's fairly simple, however, to use ActiveX scripting languages such as VBScript and JavaScript to access Java applets that run in Internet Explorer. Figure 13 shows a simple, scribble-style Java applet. With scripting code in an HTML document, we can create a form that calls the Java applet. The buttons are created with an HTML form. When clicked, they call VBScript or JavaScript code embedded in the Web page. This, in turn, talks to the Java applet via the Java/COM integration model using ActiveX Scripting interfaces (see Figure 14). The result is shown in Figure 15.</p>
<p><img src="javacomfig13.gif"></p>
<p><img src="javacomfig14.gif"></p>
<p><img src="javacomfig15.gif"></p>
<p><b>Figure 15: The Scribble applet</b></p>
<p>
Java and COM can be a powerful combination, though currently the integration works only under Windows. Your Java programs can use COM objects created in Visual C++, Visual Basic, or Visual J++, and you can also create COM objects in Java for use in any of these environments. In a future release of Visual J++, a new class library will ease integration with ActiveX services.                                                          </p>
</font></BODY>
</HTML>
