<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Active Streaming Format with Microsoft NetShow</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<font face="verdana,arial,helvetica" size="2"><form name=x><object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object></form>
<h1>Active Streaming Format with Microsoft NetShow</h1>
<p>
The Active Streaming Format (ASF) is a long-overdue addition to network technology that improves manageability and adds application-level bandwidth reservation to any data stream. Consider how Web page data is sent from an HTTP server to a Web browser: HTML code is transferred to the browser first, which reads the code to determine if there are any embedded objects such as pictures or ActiveX™ controls that need to be retrieved. The browser then makes a separate HTTP connection to the server for each embedded object. Sometimes the connections occur all at once and each embedded object competes with the other objects for bandwidth, causing all of the objects to transfer slowly; other times the objects are retrieved one at a time, in serial. This can lead to chaotic, unpredictable, and unmanageable delivery of Web page content to the browser.</p>
<p>
Under these conditions, the Web is like an orchestra without a conductor-with no one to coordinate the timing and intensity of the instruments, the listener is quickly overwhelmed by noise. The conductor keeps time and brings order from chaos; composers are able to write complex pieces of music that could not be performed without the help of a conductor. The same is true for the Internet. As content becomes more complex and timing becomes a more critical factor in its presentation, the presence of a conductor becomes a necessity.</p>
<p>
Now Microsoft® NetShow™ server and the Active Streaming Format give multimedia content developers the assurance of a conductor. The delivery and playback of complex multimedia content, built with many different tools and viewed in a wide variety of computing environments, can now be managed, directed, and optimized for each performance.</p>
<p>
The old approach to delivering multimedia content suffers several serious flaws. For example, the entire media file has to be downloaded prior to being viewed. After waiting for the media file to download, the user still can't view the content if the right helper application isn't already installed on their computer. The correct decoding algorithm (called a codec) needs to be installed for the helper application to properly decode the content. Because no single media format provides features that meet the needs of every content developer in every situation, these first three problems don't have a trivial solution such as installing a single standard codec and its associated player on every computer in the world. Further, there is no way to combine, synchronize, and prioritize media object transmission and playback. Finally, thanks to the insurmountable, arbitrary, and in most cases pointless barriers erected by Internet firewalls that filter data based on TCP/IP port number, many users are unable to receive the media in the first place if it's delivered by anything other than a Web server.</p>
<p>
When all of these flaws are added to the flaws inherent in the Web itself (such as incompatibilities between browsers), the result is a multimedia technology that seems always half-broken and is difficult to take seriously. This article will show you how to overcome these problems using ActiveX, Microsoft NetShow, and the Active Streaming Format. The ASF specification defines the structure of complex, synchronized object data streams. Any object can be placed into an ASF data stream, including audio and video data objects, scripts, ActiveX controls, and HTML documents. ASF data can be stored in a file or created in real-time using audio and video capture hardware. Either way, ASF data is optimized for use in situations where bits-per-second (bps) throughput is limited, such as on a digital network.</p>
<p>
Every digital network, including digital television (http://www.atsc.org) and the Internet, moves information by encapsulating it in packets. A packet is a way to package data for digital transmission. Packets often include delivery information, such as address or content labeling, along with the actual data. ASF data streams are made up of data packets that can be transmitted over any digital network by inserting them one at a time into the data field of network packets. Each ASF packet contains a proportional mix of data from the objects within the stream. Figure 1 demonstrates how data from certain objects receives priority placement within ASF packets, and therefore will transmit faster and consume a greater proportion of the available bandwidth. Other objects transmit more slowly and consume a smaller proportion of bandwidth to accommodate the demands of the higher-priority objects.</p>
<p><img src="netshowfig01.gif"></p>
<p><b>Figure 1: ASF Editor</b></p>
<p>
ASF version 2 is still under development and you are invited to participate in the specification process. Learn how by visiting http://www.microsoft.com/netshow/. Any program can implement support for ASF, and Microsoft provides several ActiveX controls that are built into the NetShow product that you can use in your own applications. The usefulness of ASF isn't limited to networked environments, either. Any application that needs to provide multimedia playback, such as from a CD-ROM or DVD, benefits from the use of Active Streaming Format. Due to its advanced features, ASF is slated to replace both the AVI and WAV multimedia file formats under Microsoft Windows®. ASF also promises to play an important role in allowing content vendors and users of digital television to determine, on a per-instance basis, how much of the available digital television bandwidth to consume.</p>
<p>
ASF-compatible software is required to create, deliver, and view ASF data streams. A variety of software is provided with Microsoft NetShow that enables ASF streams to be captured in real time, stored to file, converted from existing audio or video formats, created by combining audio with pictures and scripts, and delivered over the network to a client program or viewer. The NetShow client, called NetShow Player, comes as both a standalone helper application (for compatibility with the old Web publishing approach) and as an ActiveX control that can be embedded in Web pages with the HTML &lt;OBJECT&gt; tag or hosted by any ActiveX control container. NetShow also includes a special server program called NetShow Server that takes advantage of the features of ASF to deliver reliable, packetized object streams. In addition to the client, server, and ASF capture, conversion, and creation software provided as part of NetShow, you need software to create and edit digital audio, video, and graphics prior to including these objects into an ASF stream. We will cover how to create ASF content later. First, because ASF data stream creation depends so heavily on the way in which it will be delivered, we'll go over exactly what's involved in distributing ASF data streams on the Internet.</p>
<p>
ASF data streams are usually viewed progressively in real time, as the ASF data arrives at the client computer, rather than being viewed after the entire stream is downloaded. This eliminates the long download times that users must put up with when traditional multimedia content is added to Web pages. Any technology that enables real-time viewing of content as it transmits over the network is called streaming. When multimedia content is streamed over a network, playback of the content becomes very sensitive to delay. If data doesn't arrive reliably or if transmission speed falls below an acceptable minimum, playback of the content cannot continue. Smooth-streaming playback at the client computer requires a different number of bits per second (also known as bit-rate) for each multimedia production depending on the size and quality of the video and audio. The highest-quality audio and video specified for digital television broadcasts requires about 19Mbps of reliable real-time data transmission in order for the content to be viewed by the receiver. Most Internet users today are lucky to experience 28.8Kbps rates reliably, especially during <br>
heavy network congestion. The bit-rate for which a particular ASF data stream is optimized is therefore of paramount importance to its successful playback when streamed over the Internet.</p>
<p>
A regular Web server can be used to deliver ASF data streams, but there are a couple of good reasons to use the NetShow Server instead. The packets within an ASF data stream must be delivered sequentially, one per network packet, for the full benefit of data streaming to be realized. Only an ASF-compatible server such as NetShow Server can transmit ASF packets one at a time, encapsulated neatly within individual network packets. The error correction, streaming playback, and bit-rate optimization inherent to ASF depend on the client and server not having to figure out on-the-fly where ASF data packets begin and end. A Web server doesn't have this ability because it doesn't recognize the significance of ASF packets; it just shoves data to the client as quickly as possible by filling each network packet with an arbitrary amount of data. Additionally, several features of NetShow, such as the ability to fast-forward or rewind ASF data streams, are not available on a regular Web server.</p>
<p>
If you do decide to deliver ASF data streams through a regular Web server, you'll need to verify that your Web server's MIME type and file extension map is correctly configured. The MIME type setting for NetShow files is set automatically in Internet Information Server (IIS). For Web servers other than IIS, you must add the following MIME type mapping for .asf and .asx file extensions:</p>
<pre><code>video/x-ms-asf</code></pre>
<p>
Once ASF data packets are placed inside network packets, the routing technology of the digital network takes care of delivering the network packets to the receiver. There are two primary means of routing network packets, unicasting and multicasting. Unicasting is the one-to-one delivery of packets exemplified by the HTTP interaction between Web servers and browsers. Unicast packets are addressed to only one host so that network routers simply relay the packets until they reach their destination. </p>
<p>
Multicasting is a one-to-many means of routing packets to multiple computers that simultaneously receive the same content. Multicast routing is an efficient means of delivering network content to a large audience, but it requires new software and modifications to network routers so the routers properly relay multicast packets to many destinations. There is an initiative underway for the widespread rollout of multicast technology on the Internet called the IP Multicast Initiative (http://www.ipmulticast.com). It's safe to assume that multicasting will develop into a standard and ubiquitous means of delivering content to a large network audience. There is already a large Internet-based multicast backbone called the MBone, which relies primarily on software routers and unicast-style "tunnels" to move multicast packets between networks that don't have hardware multicast routers. (See Vinay Kumar's "Real-time Multimedia Broadcasts with the Internet Multicast Backbone" in the February 1997 <i>MIND</i>.)</p>
<p>
NetShow Server and Player include a special feature known as intelligent<i> </i>rollover that enables NetShow broadcasts to switch automatically from multicast to unicast when necessary. Not all clients can take advantage of multicast routing, and therefore must make use of unicast. A variety of network and application protocols are used by NetShow, including UDP, TCP, RTP, IP Multicast, and HTTP, allowing NetShow to choose the best unicast or multicast delivery approach. The NetShow Server can even be configured to serve ASF data streams through HTTP on port 80 so that firewalls treat NetShow data as though it were being sent from a Web server and allow it to pass without filtering. This ensures that users who are forced to access the Internet from behind firewalls can still receive NetShow broadcasts.</p>
<h2>Internet Broadcasting of Data Streams</h2>
<p>
When networks are small, it is possible to broadcast packets to every computer on the network. These special packets are known as broadcast packets. Because not all network routers support the relay of broadcast packets, it's impossible for broadcast packets to reach every computer on the Internet. It's unlikely that broadcast routing will ever be supported on the Internet because the scale is too big and there is no compelling reason to send the same packets to every computer. Internet broadcasting, therefore, doesn't have a technical meaning but is used anyway when talking about the user experience of receiving multimedia content. People have come to associate broadcasting with simple and effortless reception of multimedia content. You don't have to configure anything to watch a particular television show or listen to a radio station, and this colors users' expectations of broadcasting technology. People don't need to install a different TV plug-in for each show they want to watch, nor do they need to periodically upgrade their television sets to keep up with new special effects technology used by movie producers (HDTV not withstanding). Television users just locate the content they want to see and tune in to it. The technology is simple and easy to use; it requires no special training or skill to watch television broadcasts. Data streaming with NetShow can make it just as easy for users to receive Internet broadcasts.</p>
<p>
The key to making your NetShow production easily viewable to any user is to deliver the NetShow Player ActiveX control along with the ASF data stream. One of the distinct advantages of delivering content digitally over the Internet is the ability to send program code and scripts along with your content. NetShow uses ActiveX component download to install the code necessary to view ASF data streams. All that you need to do is embed the NetShow Player ActiveX control in a Web <br>
page by using the &lt;OBJECT&gt; tag. Microsoft FrontPage® or any other ActiveX-compatible Web authoring tool will construct the &lt;OBJECT&gt; tag syntax for you. Figure 2 shows the ActiveX Control Properties dialog used in FrontPage to insert the Microsoft NetShow control. Type the following URL in the Code Source field to tell the ActiveX-compatible Web browser where to download the ActiveX control if it isn't already present on the user's computer:</p>
<pre><code>http://www.microsoft.com/netshow/download/en/nsasfinf.cab#Version=2,0,0,912</code></pre>
<p><img src="netshowfig02.gif"></p>
<p><b>Figure 2: NetShow control properties</b></p>
<p>
You also need to specify which ASF data stream the control should retrieve upon activation. To do so, click on the Properties button to open the dialog shown in Figure 3. Locate the FileName property and type the URL of your ASF data stream, then click Apply. You can now save the page to your Web server and open it in a browser to view the NetShow content. The mms:// URL prefix stands for Microsoft Media Server (MMS); this is the default protocol used in both the NetShow Server and the Player. Users who access the Internet from behind a firewall may not be able to use the MMS protocol unless their firewall is reconfigured to allow the MMS protocol to pass through unfiltered. To overcome this problem, the NetShow Server can be configured to emulate a Web server by using port 80 for its transmissions. If your NetShow Server is configured to use port 80 or if you use a standard Web server to deliver ASF data, then you can type a standard http:// URL in the FileName property instead of one that begins with mms://.</p>
<p><img src="netshowfig03.gif"></p>
<p><b>Figure 3: Specifying an ASF dream</b></p>
<p>
Automatic rollover can be enabled to retrieve your ASF data stream by creating a standard text file that contains multiple references to the same ASF data using different URLs. Type the following using a text editor:</p>
<pre><code>[Reference]
Ref1 = mms://<i>server</i>/<i>stream.asf</i>
Ref2 = http://<i>server</i>/<i>stream.asf</i></code></pre>
<p>
Replace <i>server</i> with the IP address or the fully qualified domain name of the computer on which your NetShow Server lives. Replace <i>stream.asf </i>with the name of the ASF data stream file that your NetShow Server is ready to serve. Save the text file with an extension of .asx and place it on your Web server. </p>
<p>
Files that have the .asx extension are called Active Stream Redirectors. The NetShow Player helper application and ActiveX control use the URL listed as Ref1 first; if that URL fails they use the URL listed as Ref2. Active Stream Redirectors can also contain a single URL like the following:</p>
<pre><code>ASF mms://<i>server/stream.asf</i></code></pre>
<p>
When you insert the NetShow Player ActiveX control in a Web page, the class ID of the control is supplied as part of the &lt;OBJECT&gt; tag. The following HTML source shows what a typical &lt;OBJECT&gt; tag looks like for the NetShow Player ActiveX control:</p>
<pre><code>&lt;object id="netshowsample1" name="netshowsample1"
    classid="clsid:2179C5D3-EBFF-11CF-B6FD-00AA00B4E220"
    codebase="http://www.microsoft.com/netshow/download/en/
          nsasfinf.cab#Version=2,0,0,912" border="0"
    width="160" height="120"&gt;&lt;param name="_ExtentX" value="4233"&gt;&lt;param
    name="_ExtentY" value="3175"&gt;&lt;param name="FileName"
    value="mms://titanium.science.org/test6.asf"&gt;Sample Internet Broadcast
&lt;/object&gt;</code></pre>
<p>
Using the ActiveX component download to allow a Web browser to automatically retrieve and install code for a media viewer is probably familiar to you. One aspect of NetShow that's unusual compared to other media viewers is that the NetShow Player ActiveX control does not include proprietary embedded codecs for decoding digital audio and video. Instead, NetShow supports any and all codecs by relying on the Audio Compression Manager (ACM) and Video Compression Manager (VCM) in Windows (which we'll discuss in more detail later). As a result, in order for a user to view your NetShow ASF content with the ActiveX control, the correct codecs must also be installed on the user's computer. A number of codecs come preinstalled with Windows and any user who downloads and installs the NetShow Player helper application is given several more during installation, but you can't assume every user will have the codec they need to decode your ASF content. Strange things happen in the world of computers; codec files can become corrupted, be removed manually by a good-natured yet misinformed company guru, get clobbered by antisocial software, or otherwise die a gruesome and unclean death. It is essential that you arrange for the codecs that are used to encode your digital content to be delivered to users who don't yet have them.</p>
<p>
A long-term, platform-independent solution to the problem of automated codec installation is under development by the Microsoft NetShow product team, but we thought it would be nice to look at a workaround solution that's available today. You can easily create a new ActiveX control that will automatically retrieve and install the codec files required for viewing your ASF content. The codec installation control can be embedded at the top of the HTML page that contains the embedded NetShow Player ActiveX control. Any user who doesn't yet have the codecs required to view your ASF data will automatically receive the codec files, and you can be certain that every visitor to your site can decode your content.</p>
<p>
A codec installation control must do two basic things. First, it must download the codec DLL files and place them in the system directory. Second, it must update the system registry and, under Windows 95, also update the system.ini file. Figure 4 shows the source code for one such control that will download and install the Cinepak codec on both Windows 95 and Windows NT®. The full Visual Studio™ 97 project for this codec installation control is available on the Microsoft Interactive Developer Web site (http://www.microsoft.com/mind/).</p>
<p><b>Figure 4: CodecinstallCtl.cpp</b></p>
<pre><font size=2>// CodecinstallCtl.cpp : Implementation of the CCodecinstallCtrl ActiveX Control /// class.

#include &quot;stdafx.h&quot;
#include &quot;codecinstall.h&quot;
#include &quot;CodecinstallCtl.h&quot;
#include &quot;CodecinstallPpg.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCodecinstallCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCodecinstallCtrl, COleControl)
    //{{AFX_MSG_MAP(CCodecinstallCtrl)
    // NOTE - ClassWizard will add and remove message map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCodecinstallCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CCodecinstallCtrl)
    // NOTE - ClassWizard will add and remove dispatch map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCodecinstallCtrl, COleControl)
    //{{AFX_EVENT_MAP(CCodecinstallCtrl)
    // NOTE - ClassWizard will add and remove event map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CCodecinstallCtrl, 1)
    PROPPAGEID(CCodecinstallPropPage::guid)
END_PROPPAGEIDS(CCodecinstallCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCodecinstallCtrl, &quot;CODECINSTALL.CodecinstallCtrl.1&quot;,
    0xff54cafc, 0xe9c7, 0x11d0, 0x9b, 0x84, 0, 0x60, 0x8c, 0xb8, 0x4b, 0x63)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCodecinstallCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCodecinstall =
        { 0xff54cafa, 0xe9c7, 0x11d0, { 0x9b, 0x84, 0, 0x60, 0x8c, 0xb8, 0x4b,  
          0x63 } };
const IID BASED_CODE IID_DCodecinstallEvents =
        { 0xff54cafb, 0xe9c7, 0x11d0, { 0x9b, 0x84, 0, 0x60, 0x8c, 0xb8, 0x4b, 
          0x63 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCodecinstallOleMisc =
    OLEMISC_INVISIBLEATRUNTIME |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCodecinstallCtrl, IDS_CODECINSTALL, _dwCodecinstallOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CCodecinstallCtrl::CCodecinstallCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCodecinstallCtrl

BOOL CCodecinstallCtrl::CCodecinstallCtrlFactory::UpdateRegistry(BOOL bRegister)
{
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_CODECINSTALL,
            IDB_CODECINSTALL,
            afxRegApartmentThreading,
            _dwCodecinstallOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CCodecinstallCtrl::CCodecinstallCtrl - Constructor

CCodecinstallCtrl::CCodecinstallCtrl()
{
    InitializeIIDs(&amp;IID_DCodecinstall, &amp;IID_DCodecinstallEvents);

    // TODO: Initialize your control's instance data here.
    HRESULT hRet;
    long lRet;
    HKEY hkResult;
    LPUNKNOWN pCaller;
    LPCTSTR szURL, szFileName;
    DWORD dwResv = 0;
    lpfnCB = NULL;
    OSVERSIONINFO osVers;
    char sBuffer[50];
    BOOL bInstallCodec = FALSE;

    osVers.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(GetVersionEx(&amp;osVers))
    {
        dwPlatform = osVers.dwPlatformId;
        switch(dwPlatform)
        {
        case VER_PLATFORM_WIN32_WINDOWS:

        GetPrivateProfileString(&quot;drivers32&quot;,&quot;vidc.CVID&quot;,&quot;NULL&quot;,
                                sBuffer, 50, &quot;system.ini&quot;);

        if(strcmp(&quot;NULL&quot;,sBuffer) == 0)
        {    // Cinepak Codec needs to be installed on client
            bInstallCodec = TRUE;
        }
        break;

        case VER_PLATFORM_WIN32_NT:
            lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
&quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32&quot;,
0,KEY_READ,&amp;hkResult);

            if(ERROR_SUCCESS == lRet)
            {
                DWORD dwType, dwData;
                BYTE byteData;
                lRet = RegQueryValueEx(hkResult,&quot;vidc.cvid&quot;,0,
                    &amp;dwType,&amp;byteData,&amp;dwData);
                if(ERROR_SUCCESS != lRet)
                    bInstallCodec = TRUE;
                RegCloseKey(hkResult);
            }
        break;
        }

        HANDLE hExistingFile;
        hExistingFile = CreateFile((LPCTSTR)sFile,GENERIC_READ,
                                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                                   NULL,OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,NULL);
        if(hExistingFile == INVALID_HANDLE_VALUE)
            bInstallCodec = TRUE;

        CloseHandle(hExistingFile);

        if(bInstallCodec)
        {
        /* URL of the codec DLL file to download and install */
        sURL = CString(&quot;http://www.science.org/iccvid.dll&quot;);
        GetSystemDirectory(cSysDir,MAX_PATH);
        sFile = CString(cSysDir) + CString(&quot;\\iccvid.dll&quot;);

        szFileName = (LPCTSTR)sFile;
        szURL = (LPCTSTR)sURL;
        pCaller = NULL;
        objImpCallback.setCodecInstallControlPointer(this);

        lpfnCB = (IBindStatusCallback *)&amp;objImpCallback;

        hRet = URLDownloadToFile(pCaller,szURL,szFileName,dwResv,lpfnCB);
        }
    }
}

void CCodecinstallCtrl::InstallCodec()
{
    HKEY hkResult;
    DWORD dwDisposition;
    long lRet;
    CString sDesc;
    CString sDriver;

    switch(dwPlatform)
    {
    case VER_PLATFORM_WIN32_WINDOWS:

        WritePrivateProfileString(&quot;drivers32&quot;,&quot;vidc.CVID&quot;,
                                  &quot;iccvid.dll&quot;, &quot;system.ini&quot;);

        lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
&quot;SYSTEM\\CurrentControlSet\\Control\\MediaResources\\icm\\vidc.CVID&quot;,
0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&amp;hkResult,
&amp;dwDisposition);
        if(ERROR_SUCCESS == lRet)
        {
        sDesc = CString(&quot;Cinepak Codec by Radius, Inc.&quot;);
        sDriver = CString(&quot;iccvid.dll&quot;);

        RegSetValueEx(hkResult,&quot;Description&quot;,0,
        REG_SZ,(unsigned char *)(LPCTSTR)sDesc,sDesc.GetLength());

        RegSetValueEx(hkResult,&quot;Driver&quot;,0,
        REG_SZ,(unsigned char *)(LPCTSTR)sDriver,sDriver.GetLength());

        RegCloseKey(hkResult);
        }

    break;

    case VER_PLATFORM_WIN32_NT:
        lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
&quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc&quot;,
0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&amp;hkResult,
&amp;dwDisposition);
        if(ERROR_SUCCESS == lRet)
        {
        sDesc = CString(&quot;Cinepak Codec by Radius, Inc.&quot;);
        sDriver = CString(&quot;iccvid.dll&quot;);

        RegSetValueEx(hkResult,&quot;iccvid.dll&quot;,0,
        REG_SZ,(unsigned char *)(LPCTSTR)sDesc,sDesc.GetLength());
        RegCloseKey(hkResult);

        lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
&quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32&quot;,
0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&amp;hkResult,
&amp;dwDisposition);
        if(ERROR_SUCCESS == lRet)
            {
            RegSetValueEx(hkResult,&quot;vidc.cvid&quot;,0,
                          REG_SZ,(unsigned char 
                          *)(LPCTSTR)sDriver,sDriver.GetLength());
            }
        }

    break;
    }
}


/////////////////////////////////////////////////////////////////////////////
// CCodecinstallCtrl::~CCodecinstallCtrl - Destructor

CCodecinstallCtrl::~CCodecinstallCtrl()
{
    // TODO: Cleanup your control's instance data here.
    if(lpfnCB) lpfnCB-&gt;Release();
}


/////////////////////////////////////////////////////////////////////////////
// CCodecinstallCtrl::OnDraw - Drawing function

void CCodecinstallCtrl::OnDraw(
            CDC* pdc, const CRect&amp; rcBounds, const CRect&amp; rcInvalid)
{
    // TODO: Replace the following code with your own drawing code.
    pdc-&gt;FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
    pdc-&gt;Ellipse(rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CCodecinstallCtrl::DoPropExchange - Persistence support

void CCodecinstallCtrl::DoPropExchange(CPropExchange* pPX)
{
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);

    // TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CCodecinstallCtrl::GetControlFlags -
// Flags to customize MFC's implementation of ActiveX controls.
//
// For information on using these flags, please see MFC technical note
// #nnn, &quot;Optimizing an ActiveX Control&quot;.
DWORD CCodecinstallCtrl::GetControlFlags()
{
    DWORD dwFlags = COleControl::GetControlFlags();


    // The control can activate without creating a window.
    // TODO: when writing the control's message handlers, avoid using
    //        the m_hWnd member variable without first checking that its
    //        value is non-NULL.
    dwFlags |= windowlessActivate;
    return dwFlags;
}


/////////////////////////////////////////////////////////////////////////////
// CCodecinstallCtrl::OnResetState - Reset control to default state

void CCodecinstallCtrl::OnResetState()
{
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange

    // TODO: Reset any other control state here.
}


•••
</font></pre>
<p>
The codec installation control's constructor determines whether the platform is Windows 95 or Windows NT and uses an appropriate mechanism to check for the presence of the Cinepak codec. If the codec is already installed, the control does nothing. Otherwise, the ActiveX SDK function URLDownloadToFile is used to retrieve the Cinepak codec DLL (iccvid.dll) using an http:// URL and store the DLL in the standard system directory (this will be system32 under Windows NT). The InstallCodec method is called when the download completes so that the appropriate registry values can be set. Under Windows 95 the system.ini file also needs to be updated.</p>
<p>
Figure 5 shows the header file for the codec installation control. Note that the control class declares another class named cImpMonikerCallback that implements the IBindStatusCallback interface. This interface is required by URLDownloadToFile to enable the control to receive notification as the file is downloaded. Final notification is sent to the OnStopBinding method when the download is complete so that InstallCodec can be called to complete the codec installation.</p>
<P><B>Figure 5: CodecinstallCtl.h</b></p>
<pre><font size=2>#if !defined(AFX_CODECINSTALLCTL_H__FF54CB09_E9C7_11D0_9B84_00608CB84B63__INCLUDED_)
#define AFX_CODECINSTALLCTL_H__FF54CB09_E9C7_11D0_9B84_00608CB84B63__INCLUDED_

#if _MSC_VER &gt;= 1000
#pragma once
#endif // _MSC_VER &gt;= 1000

// CodecinstallCtl.h : Declaration of the CCodecinstallCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CCodecinstallCtrl : See CodecinstallCtl.cpp for implementation.

class CCodecinstallCtrl : public COleControl
{
class cImpMonikerCallback :
 public IBindStatusCallback
{
    DWORD           m_cRef;
    IBinding*       m_pbinding;
    CCodecinstallCtrl *pCodecInstallControl;
public:
    cImpMonikerCallback()
    {
        m_cRef = 1;
        m_pbinding = NULL;
    };
    ~cImpMonikerCallback()
    {
        if (m_pbinding)
        m_pbinding-&gt;Release();
    };

    // IUnknown methods
    STDMETHODIMP    QueryInterface(REFIID riid,void ** ppv)
    { 
    *ppv = NULL;
    
    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback)
        {
        *ppv = this;
        AddRef();
        return S_OK;
        }
    return E_NOINTERFACE;
    };
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo)
        {return(NOERROR);};
    STDMETHODIMP    OnStartBinding(DWORD grfBSCOption, IBinding* pbinding)
        {return(NOERROR);};
    STDMETHODIMP    GetPriority(LONG* pnPriority)
        {return(NOERROR);};
    STDMETHODIMP OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                            ULONG ulStatusCode, LPCWSTR szStatusText)
            {return(NOERROR);};
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                                    STGMEDIUM* pstgmed)
        {return(NOERROR);};
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk)
        {return(NOERROR);};
    STDMETHODIMP    OnLowResource(DWORD dwReserved)
        {return(NOERROR);};
    STDMETHODIMP    OnStopBinding(HRESULT hrStatus, LPCWSTR szText)
        {if(!hrStatus) pCodecInstallControl-&gt;InstallCodec();
    return(NOERROR);};

    void setCodecInstallControlPointer(CCodecinstallCtrl *p)
    {pCodecInstallControl = p;};

};

    DECLARE_DYNCREATE(CCodecinstallCtrl)
    LPBINDSTATUSCALLBACK lpfnCB;
    cImpMonikerCallback objImpCallback;
    CString sURL;
    CString sFile;
    char cSysDir[MAX_PATH];
    DWORD dwPlatform;

// Constructor
public:
    CCodecinstallCtrl();
    void InstallCodec();
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCodecinstallCtrl)
    public:
    virtual void OnDraw(CDC* pdc, const CRect&amp; rcBounds, const CRect&amp; rcInvalid);
    virtual void DoPropExchange(CPropExchange* pPX);
    virtual void OnResetState();
    virtual DWORD GetControlFlags();
    //}}AFX_VIRTUAL

// Implementation
protected:
    ~CCodecinstallCtrl();

    DECLARE_OLECREATE_EX(CCodecinstallCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CCodecinstallCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CCodecinstallCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CCodecinstallCtrl)      // Type name and misc status

// Message maps
    //{{AFX_MSG(CCodecinstallCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CCodecinstallCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

// Event maps
    //{{AFX_EVENT(CCodecinstallCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CCodecinstallCtrl)
        // NOTE: ClassWizard will add and remove enumeration elements here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DISP_ID
    };

};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CODECINSTALLCTL_H__FF54CB09_E9C7_11D0_9B84_00608CB84B63__INCLUDED)
</font></pre>

<p>
Standard Authenticode™ code-signing should be applied to the codec installation control using your software publisher's digital ID. Visit the Verisign Inc. digital ID center to get your Authenticode-compatible ID (http://digitalid.<br>
verisign.com). You always need to build and deploy your own codec installation control unless the codec manufacturer or Microsoft provides one for you. An alternative to coding an ActiveX control is to write a setup information (INF) text file and package it along with the codec DLL files into a cabinet (CAB) file. ActiveX Component Download has the ability to read and extract the contents of CAB files and process setup INF files to accomplish the same installation steps that a codec installation control would. CAB files can even be signed using Authenticode. You can find out more about writing your own INF file by visiting http://computers.science.<br>
org/digitalmedia/netshow/.</p>
<p>
Microsoft provides CAB files and setup INF files for a number of codecs that ship with NetShow. You can include a URL in your Web page inside a floating frame (&lt;IFRAME&gt;) that will cause the user's Web browser to download and install the correct codec installation CAB file from the Microsoft site. The following shows one example; a full list of URLs for Microsoft codec installation pages can be obtained from the NetShow documentation:</p>
<pre><code>&lt;iframe src="http://www.microsoft.com/netshow/download/codecs/installmetasnd.htm" name="MetaSound" width="1" height="1" frameborder=0 marginheight=0 marginwidth=0 scrolling=auto&gt;
&lt;!- IE users will get the codec automatically downloaded if they need it. Non IE 32bit users see this next bit -&gt;
If you do not have the Voxware MetaSound audio codec installed, you can install the &lt;a href="http://www.microsoft.com/netshow/download/player.htm "&gt;Full NetShow client install&lt;/a&gt; in order to obtain it.
&lt;/iframe&gt;</code></pre>
<p>
When ActiveX is released on platforms other than Win32®, such as the Macintosh or UNIX, you will be able to use a standard CAB file to deliver the right ActiveX controls, setup INF files, and codecs for the operating system your user is running. This provides advantages not just for site builders, but also for multimedia authors whose work is distributed via DVD or CD-ROM for multiple computing platforms. By enabling the automatic delivery and installation of platform-specific code and codecs required to view your Active Streams, the ActiveX architecture provides the kind of flexibility and openness required to broadcast multimedia content in a public data network. It also provides the simplicity required for successful deployment of multimedia content on a corporate intranet.</p>
<p>
NetShow can be used in a number of different configurations depending on your preferences. If you don't care about Internet broadcasting and instead just want to link to an ASF data stream from a Web page using the standard Web publishing technique, there are two things that you must do differently. First, create an Active Stream Redirector (.asx) file that contains the URL of an ASF data stream and put the .asx file on your Web site. Hyperlink to the .asx file in a Web page so a user can download the file. When the user's browser downloads the .asx file, the NetShow Player helper application will be activated. </p>
<p>
Second, create a Web page that includes a hyperlink to the Active Stream Redirector and add the standard technical caveat that explains to your users that they won't be able to view your site's multimedia content unless they first learn how to download and install software on their computer. </p>
<p>
Publishing data streams on the Web is subject to the same shortcomings encountered with any other Web technology. What it lacks in elegance and simplicity for the user is sometimes compensated for by the browser-independence it provides when components aren't used. Conventional Web publishing of multimedia streams may be an important way to distribute content on the Internet today, but anyone who has spent countless hours helping novice computer users try to install helper applications knows that the future of Internet multimedia is bleak without better broadcasting technology.</p>
<p>
Internet broadcasting is as much about delivering content as it is about delivering code to view the content. It is the automated installation of code such as ActiveX controls and codecs that differentiates Internet broadcasting from conventional multimedia Web publishing or digital broadcasting through digital television. Think of Internet broadcasting as being object-oriented digital multicasting, where data and the code to manipulate it are delivered together to a wide network audience. It is far better to standardize on an object-oriented computing platform and use it as the network content viewer than to create a standard content format and use a single-purpose viewer that imposes narrow limitations on interactive media. </p>
<p>
Now that you understand the issues that affect the delivery of ASF data streams over the network and the requirements for the user to successfully view them, it's time to create your own ASF-compatible content.</p>
<h2>Creating Active Streams</h2>
<p>
Multimedia content leaves very little to the imagination; it must meet the discerning standards of human eyes and ears. Because it's easy to tell the difference between an audio recording captured on a handheld cassette recorder and one produced in a professional recording studio, the hardware and software you use to record or capture audio and video are your most important assets in creating data streams. Luckily, quality equipment that was once available only to professional media producers with large budgets can now be purchased at an affordable price from your local consumer electronics store. Almost any audio or video recording device can be made to interface easily with a personal computer. Video capture cards capture and digitize full-motion video from a video source such as a VCR or video camera. Sound-cards process audio inputs from microphones, mixers, CD players, and stereos. Digital cameras, video frame grabbers, and scanners allow you to acquire digital pictures from any medium. Acquiring or creating audio, video, and digital pictures is the first step in creating Active Streams that are compatible with NetShow.</p>
<p>
When audio and video is recorded or transmitted using analog or digital technology, several pieces of electronic equipment must agree on the way in which the signal is encoded. The recording equipment must use an encoding technology that is compatible with that used in the editing equipment. Editing equipment must be able to encode a final production that is compatible with the technology used to play back the audio and video. For example, conventional television is encoded using one of three standards: National Television System Committee (NTSC), Phase Alternating Line (PAL), or Sequential Color and Memory (SECAM). These standards essentially define mechanisms that can be used to encode or decode analog audio and video broadcasts or tape recordings. Each region of the world uses one of these three standards (American sets use NTSC) and they're all incompatible with each other. The term codec refers to a specification for a way to encode and decode analog or digital audio or video and its associated algorithm or implementation.</p>
<p>
Contrary to popular belief-and contrary to much computer-oriented documentation-codec is an abbreviation of coder/decoder, not compressor/decompressor. While many codecs involve compression, many others do not. The term codec originated in the field of analog communications long before the first bit was ever transmitted digitally. NTSC, PAL, and SECAM are examples of analog codecs used in television. Other analog codecs are used for audio or video in a number of technologies including satellite communications and land or wireless telephony. The point is, without codecs it would be impossible to record and play back audio and video signals.</p>
<p>
Under Microsoft Windows, codecs are usually implemented as ACM- or VCM-compatible. The ACM and VCM enable new codecs to be written and installed in <br>
such a way that they can be used immediately by ACM- and VCM-compatible software. Figure 6 lists the ACM- <br>
and VCM-compatible codecs installed by default with Windows 95.</p>
<p><img src="netshowfig06.gif"></p>
<p><b>Figure 6: ACM- and VCM-Compatible Codecs in Windows 95</b></p>
<p>
The NetShow Player helper application comes with several additional codecs, but they aren't installed when the NetShow Player ActiveX control is downloaded. To find out which codecs are installed on your computer, open the Control Panel and double-click on Multimedia. Click the Advanced tab to view the installed multimedia drivers. Continue by expanding either the Video Compression Codecs or Audio Compression Codecs items within the list box displayed. Figure 7 shows an audio codec listing within the Multimedia Properties applet.</p>
<p><img src="netshowfig07.gif"></p>
<p><b>Figure 7: Installed codecs</b></p>
<p>
NetShow uses the ASF format, which enables multimedia developers to encode their content with any audio or video codec. Inside ASF files or data streams are instructions to the player telling it which codecs were used to encode each audio or video object. Under Windows, the NetShow Player reads those instructions and uses the appropriate codec from the ACM or VCM so that the content can be decoded for playback. If a codec used inside an ASF file is not available in the ACM or VCM when the NetShow Player needs it, the media clip cannot be decoded for playback. Video clips will appear entirely black for their duration and audio clips will not produce any sound. If your NetShow production doesn't play back correctly, you can choose Properties from the Player's File menu, or right-click on the ActiveX control and choose Properties to access the dialog shown in Figure 8. Under the Codecs tab you will see a list of the codecs used by the objects within the ASF data and whether the codecs are installed on your computer.</p>
<p><img src="netshowfig08.gif"></p>
<p><b>Figure 8: Time to install a codec</b></p>
<p>
Multimedia file formats such as AVI, MOV, and WAV are often confused with codecs, but file format and codec are not the same thing. Video data inside an AVI or MOV file can be encoded using any digital video codec. Digital video files are like videotapes. There are many types of videotape, such as 8mm, VHS, and Betacam, all of which can hold analog video that is encoded using the PAL, NTSC, or SECAM standards. Even though a VHS-videotape will fit in an NTSC-VCR, if the tape contains PAL- or SECAM-encoded video you won't be able to view the content without converting it to NTSC first. Digital video file formats are simply containers for encoded digital video, similar to the way videotapes hold analog video.</p>
<p>
The easiest way to create an ASF file is to use the tools included with NetShow Server that will convert WAV, AVI, and MOV file formats to the Active Streaming Format. The WavToASF program converts WAV audio files and the VidToASF program converts AVI and MOV file formats to ASF. Just digitize your audio or video with a capture card and capture software, then save the digitized media to a .WAV, .AVI, or .MOV file. Next, run the command-line program WavToASF or VidToASF to convert the file to ASF format. The resulting ASF file will contain audio or video data encoded with the same codec that you specified in your capture software when you digitized the media. Copy the ASF file to your NetShow Server's ASFRoot directory to make it available over the network.</p>
<p>
Depending on the codec used and the video size, color depth, and audio sample rate, your digitized media will require a different minimum bit-rate to play back properly. Some codecs such as Cinepak (on a Macintosh) allow you to specify your target bit-rate when you encode (see Figure 9). The ASF conversion utilities do not convert between codecs, just between file formats, so you're stuck with the bit-rate and codec requirement of your original media file. Encoding your media at an appropriate bit-rate for the speed at which you expect it to stream over the network during playback is critical to the successful delivery of a NetShow production.</p>
<p><img src="netshowfig09.gif"></p>
<p><b>Figure 9: Setting the bit-rate</b></p>
<p>
There is an alternative to sacrificing the quality of your audio and video. You can instruct the NetShow Player to buffer a larger portion of your ASF data stream prior to beginning playback. You do this with the VidToASF and WavToASF utilities by increasing leadtime. When you run VidToASF or WavToASF, specify the parameter leadtime, followed by the number of milliseconds to delay playback while ASF data is buffered. A large leadtime reduces the bandwidth required during streaming playback. The default leadtime is 1,000 milliseconds.</p>
<p>
After digital audio and video clips are captured, you almost always need to edit them or piece the clips together, or touch up the presentation with voice-over audio or special effects. This is usually the final step before converting your media to ASF format. One of the most popular full-<br>
featured digital video editing suites is called the Media 100 (http://www.media100.com). Figure 10 shows a typical Media 100 editing station. Although lots of disk space and RAM are required to use an advanced digital editing product like <br>
the Media 100, it's very difficult to prepare long and complicated digital videos without such a tool.</p>
<p><img src="netshowfig10.gif"></p>
<p><b>Figure 10: Media 100</b></p>
<p>
Some of the most common digital effects you might add to finish off your production are transitions between segments-wiping the new segment on to the screen or fading to black at the end of a section, for instance. Figure 11 shows one of the Media 100 screens (on a Macintosh) that is used to synchronize playback of audio and video tracks within a production and link clips together. One of the biggest advantages of using a product like the Media 100 is that your original content is stored and manipulated at its highest resolution or sample quality. When your production is finished, it is exported to file, videotape, or DVD and can undergo codec conversion and size or resolution reduction at that time, depending on your needs. This means you can use a single set of tools and work with a single media database to produce content for everything from broadcast television to 14.4Kbps Internet streams.</p>
<p><img src="netshowfig11.gif"></p>
<p><b>Figure 11: Synchronizing audio and video</b></p>
<p>
Often, you simply want to digitize a video clip and edit only its audio track. For example, you might record using a video camera in a noisy environment and later replace the noise with music. An excellent software product from Sonic Foundry (http://www.sonicfoundry.com) called Sound Forge is available for digital audio editing. With Sound Forge, you can edit audio files only or edit the audio within AVI or other multimedia files. Figure 12 shows Sound Forge being used to edit the audio within an AVI file. The newest version of Sound Forge even allows you to save to ASF format.</p>
<p><img src="netshowfig12.gif"></p>
<p><b>Figure 12: Sound Forge</b></p>
<p>
In addition to products like the Media 100 and Sound Forge, there are several Microsoft tools that help you prepare ASF content. The PublishToASF program converts PowerPoint presentations to ASF format. This allows you to take advantage of the simplicity of PowerPoint® to create presentations and use the streaming capabilities of NetShow for delivery. ASFChop is an ASF file editing tool used to cut data from the start or end of an ASF file. The ASF Editor (which you got a glimpse of in Figure 1) is used to develop a special type of multimedia content called illustrated audio, where<i> </i>a stream of static images are synchronized with sound and program script. As the images change, they can create simple animations that give the appearance of motion without the high-bandwidth requirements of full video.</p>
<p>
The ASF Editor helps you manage bandwidth and synchronize objects within your ASF data stream by displaying a timeline along which each object is placed. The time it takes each object to download, given a specified target bit-rate, is displayed along the timeline. In the sample shown in Figure 1, a long rectangle in the timeline represents the sound object that acts as the sound track for the production. The block segments represent static JPEG images. This shows you the bandwidth requirements of each object, allowing you to act as bandwidth manager. You can be certain that each of the objects you want to place in the stream has enough time to download before you ask the viewer to use the object. The small vertical arrows along the top of the timeline tell the player when to use the object during playback.</p>
<p>
To give users of your illustrated audio presentation more playback control, the ASF Editor allows you to add markers that identify areas of your presentation by name. The user can jump right to any marker in your ASF data stream by selecting it from a menu in the NetShow control, or using the slide bar in the NetShow Player. Choose Markers from the Edit menu in the ASF Editor to add, edit, and delete markers in your illustrated audio. Markers show up as thick, vertical gray lines along the top and bottom of the ASF Editor timeline. When adding a marker, you specify a marker name and the time at which the marker should be placed within the <br>
ASF data.</p>
<p>
Another feature of NetShow is the ability to include automatic navigation to URL addresses during playback. Known as URL flips, the URL that the user's Web browser will display at a certain time during playback of your illustrated audio presentation is embedded as a script command within the ASF data. You add URL flips by selecting Edit | Script Commands. The Script Commands dialog, shown in Figure 13, makes it easy to add URL flips by specifying the time and URL address. When you type only a URL, the NetShow Player knows to send a URL navigation instruction to the default Web browser. This can cause a problem if you're using the NetShow control embedded in a Web page because the browser will change locations. In doing so, the browser unloads the control and stops playback. To avoid this problem, you must lay out your Web page using frames and supply a parameter immediately following the URL. The following example instructs the Web browser to navigate to the address http://www.science.org and display the site in the frame named framemain:</p>
<pre><code>http://www.science.org/ &amp;&amp;framemain</code></pre>
<p><img src="netshowfig13.gif"></p>
<p><b>Figure 13: Script Commands Dialog</b></p>
<p>
More advanced features of NetShow are available if you know VBScript and want to learn how to script the NetShow Player's client SDK. Text captions can be added at any point in the ASF data stream to provide additional information or instructions to the user. Clickable hotspots can turn images or video clips into hyperlinks or script locations. And regular VBScript or JScript scripts can be delivered along with your audio, video, and image content to execute in any Active Scripting container, including Internet Explorer. See the NetShow documentation for more on these advanced features.</p>
<p>
VidToASF and WavToASF also allow markers, captions, hotspots, URL flips, and scripts to be included in ASF data. A separate text file that contains these items must be created prior to running VidToASF or WavToASF so that the instructions can be parsed during conversion and included in the ASF output. See the documentation that accompanies NetShow for this script parameter when running one of the conversion utilities.</p>
<p>
The<i> </i>ASF Real-Time Encoder is a NetShow utility that turns any live source, such as output from a sound card or video capture card, into an ASF stream, ASF file, or both. This application can also be used to convert an existing AVI or WAV file to an ASF stream or file. The Real-Time Encoder, affectionately known as Rex, delivers encoded audio and video data over the network to the NetShow Server. Because of the large CPU demands of real-time digital encoding, it is not advisable to run Rex in a production environment on the same computer that runs the NetShow Server. To get data from Rex over the network and deliver it through your NetShow Server, you must first add a new Publish Point to your server configuration for each instance of Rex (see Figure 14). Note the use of the msbd:// URL syntax to refer to the remote Rex application. Rex can be configured to communicate with the NetShow Server using any TCP/IP port number so pick one-like 3134 shown in the example-and remember it. You'll need to configure Rex to use the same port number that you enter in your Publish Point URL.</p>
<p><img src="netshowfig14.jpg"></p>
<p><b>Figure 14: Adding a Publish Point</b></p>
<p>
Now, start Rex (see Figure 15) and choose "Live source" as the audio or video source. Pick the correct input device for each source and check the Include Script Commands box if you intend to supply real-time script input through the Rex automation interface. Click on the Next button and choose a target network bandwidth for the real-time stream. Click on Next again and choose the audio and video codecs you would like to use in encoding the stream. Click Next again and decide whether you would like to send data from Rex to the NetShow Server or save ASF data to a local file, or both.</p>
<p><img src="netshowfig15.gif"></p>
<p><b>Figure 15: Rex</b></p>
<p>
Click on Next again and select a TCP/IP port number (if you chose to send data over the network to the server) for Rex to use. You can click on the Query button to have an unused port number filled in for you automatically, but remember that the port number you assign to Rex must match the port number that you enter as part of the msbd:// URL in your server's Publish Point. You may wish to configure Rex and use the Query button to select a port number prior to adding the Publish Point to the server. Finally, click Next and supply a description of the real-time stream, then click Finish. The Rex window shown in Figure 16 appears, allowing you to start and stop real-time encoding as well as monitor Rex's progress and settings.</p>
<p><img src="netshowfig16.gif"></p>
<p><b>Figure 16: Starting and stopping encoding</b></p>
<p>
If you're going to be doing a lot of real-time encoding, you should plan on dedicating fast computers to this single task. It is also a good idea to dedicate at least one computer to running the NetShow Server on port 80 using HTTP, so that users who are on the other side of firewalls can receive your ASF data. Employees from your own company might need external access to intranet-based NetShow content when they work from home or travel, so setting up a dedicated NetShow Server computer is useful even if you won't be broadcasting to Internet visitors. </p>
<h2>Future Digital Streaming and<br>
Active Broadcasting</h2>
<p>
NetShow is a good example of the type of technology that will be needed when large broadcast audiences have the ability to tune into a variety of high-speed digital transmissions using hybrid PC/TV boxes. Regardless of what happens with digital broadcasting and the Internet, intranets will certainly benefit in the long term from the integration of digital media and network technology. Creating and deploying multimedia applications and digital <br>
media productions with NetShow represents a wealth of untapped <br>
potential for corporate information technology and improved business communications.                                   </p>
</font></BODY>
</HTML>
