<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Shared Object Models: Part I: Files and Shapes</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<font face="verdana,arial,helvetica" size="2"><form name=x><object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object></form>

<h1>Shared Object Models: Part I: Files and Shapes</h1>
<p>
By Rick Dobson</p>
<p>
Office 97 shared object models complement the "native" object models of individual applications, such as Word 97 and Excel 97. There are four shared object models. They cover file searching, drawing, Office Assistants, menus, and toolbars; and you can use them in any Office 97 application without invoking automation.</p>
<p>
This article is the first of a three-article series on shared object models. It will briefly introduce the topic before moving on to in-depth discussions of file searching and drawing. You will learn about key objects, properties, and methods for each topic. Sample procedures will illustrate how to put this background to use for achieving practical results.</p>
<h2>Shared Object Model Overview</h2>
<p>
FIGURE 1 presents four shared object models, along with a brief synopsis of their functions. To use any of these object models, your application must add a reference to the Office 8 Object Library from the Visual Basic Editor. FIGURE 2 shows this selection being made in a Word 97 application.</p>
<p>
Office 97 integrates the functionality of menus and toolbars with its CommandBars object model. You can build custom solutions with a single object model for both toolbars and menus. Use the CommandBars object model when your custom systems require custom menus and toolbars that replace or complement an application's built-in menus and toolbars.</p>
<p>
The Office Assistant is one of the defining characteristics of the Office 97 user interface. Many end-users learn to rely on the Assistant for tips, step-by-step instructions, and as a front-end to the online Help system. The Assistant object model lets custom applications provide information, prompt for information, or display error messages. Office 97 users will feel right at home with custom applications that incorporate the Assistant object model.</p>
<p>
The FileSearch object model enables developers to build their own front-end to the File | Open command. With this command, your application can search for individual files and file types. By using the <b>PropertyTests</b> collection within the FileSearch object model, you can specify advanced search criteria, such as a date range for when files were last modified.</p>
<p>
The Drawing object model provides custom solutions programmatic access to the capabilities of the Office 97 Drawing toolbar. This includes the addition of custom shapes and WordArt. Through the application of methods, users can animate shape and WordArt objects in an application. This isn't possible except by using the Drawing object model.</p>
<h2>FileSearch Properties and Methods</h2>
<p>
The FileSearch object model represents the File | Open command. Its properties and methods give developers programmatic control over the command; use the properties to set criteria for a returned set of files. Invoke a search with the <b>Execute</b> method. Use the <b>NewSearch</b> method to change the criteria from a previous search.</p>
<p>
The <b>FoundFiles</b> collection contains the return set satisfying the search criteria. Its items are file names and paths. <b>FileSearch</b> is the parent object for this collection. The <b>Count</b> property for <b>FoundFiles</b> indicates how many files match the criteria. If no files satisfy the criteria, the <b>Count</b> property is 0. Whenever an application invokes the <b>Execute</b> method, it refreshes the <b>FoundFiles</b> collection.</p>
<p>
Launch the <b>Execute</b> method after setting your search criteria. The FileSearch object model has a <b>LookIn</b> property that functions much like the LookIn box in the Open dialog box. Developers have read/write access to this property. Other properties correspond to the remaining four input boxes in the Open dialog box. As with the Open dialog box, your code can specify with the <b>FileName</b> property both the filename and file type.</p>
<p>
The <b>FileType</b> property can set or return the file type to any of the following values: <b>msoFileTypeAllFiles</b>, <b>msoFileTypeBinders</b>, <b>msoFileTypeDatabases</b>, <b>msoFileTypeExcelWorkbooks</b>, <b>msoFileTypeOfficeFiles</b>, <b>msoFileTypePowerPointPresentations</b>, <b>msoFileTypeTemplates</b>, or <b>msoFileTypeWordDocuments</b>. (An example of how to use these constants is shown in FIGURE 10.) If you need a file type that is not in this set, use *.<i>extension</i> as the value for the <b>FileName</b> property. The <b>TextOrProperty</b> property searches for files that contain a text string in a file or its properties. You can use the ? and * wildcard operators in the normal ways.</p>
<p>
The <b>LastModified</b> property lets an application specify whether files qualify for the return set based on the date of their last modification. When using a basic file search, you must pick from a specific list of named options, such as <b>msoLastModifiedToday</b>. These options match those in the Last Modified drop-down box in the Open dialog box. If your application needs to designate starting and ending dates for the <b>LastModified</b> property, use the <b>PropertyTests</b> collection.</p>
<p>
The <b>PropertyTests</b> collection contains all criteria associated with a FileSearch object model. If you need to specify advanced criteria, such as those in the Advanced Find dialog box, you must use the <b>PropertyTests</b> collection to designate your criteria. <b>PropertyTest</b> objects contain different criteria. Any single advanced search can have multiple criteria. <b>PropertyTest</b> object properties correspond to the input boxes in the Advanced Find dialog box. The <b>Add</b> and <b>Remove</b> methods permit a developer to manage the criteria for a search. Because the FileSearch object model is the parent for the <b>PropertyTests</b> collection, the <b>NewSearch</b> method can also flush all previously set criteria. Also, you run the file search for a <b>PropertyTests</b> collection with the same method that you use for the basic searches - <b>Execute</b>.</p>
<table border=1 cols=2 frame=box rules=all>
<tr valign=top>
<td width=98><b>Model Name</b></td>
<td width=216><b>Functionality</b></td>
</tr>
<tr valign=top>
<td width=98>Assistant</td>
<td width=216>Provides programmatic control over the Office Assistant</td>
</tr>
<tr valign=top>
<td width=98>CommandBars</td>
<td width=216>Allows the creation and modification of custom menus and toolbars</td>
</tr>
<tr valign=top>
<td width=98>Drawing</td>
<td width=216>Provides programmatic control for Shapes and WordArt Effects</td>
</tr>
<tr valign=top>
<td width=98>FileSearch</td>
<td width=216>Provides programmatic control for the File | Open command</td>
</tr>
</table><br>
<p>
<b>FIGURE 1: Selected shared object models.</b></p>
<h2>FileSearch Code Examples</h2>
<p>
A series of sample applications confirm that the FileSearch object model is, in fact, shared. These examples show the FileSearch model working in Word, Excel, and Access. (It also functions in PowerPoint.) I describe at least one slight variation in how to use the object model in Access versus the other applications; in particular, Access does not support the FileSearch data type.</p>
<p>
FIGURE 3 shows a typical file search. The <b>LookIn</b> property designates that the search will take place in the Office subfolder of the Microsoft Office subfolder of the Program Files folder. By setting the <b>SearchSubFolders</b> property to <i>False</i>, the procedure limits the search to the one specific subfolder designated as the value for the <b>LookIn</b> property. The <b>FileName</b> property designates that the search will look for any file with a "dot" extension.</p>
<p><img src="rd_fig02.gif">
</p>
<p>
<b>FIGURE 2: You must make a reference to the Office 8 Object Library before attempting to use any of the four shared object models discussed in this article..</b></p>
<p>
The <b>Execute</b> command launches the search. It also returns the number of files found after the search completes. If <b>Execute</b> is not greater than 0, then no files match the criteria. The procedure processes this outcome in the <b>Else</b> clause of its <b>If</b> statement. If <b>Execute</b> discovers at least one file that matches the criteria, then the code prints out the number of matches on the current document before printing the names of and paths to the individual files in the <b>FoundFiles</b> collection. Recall that this collection contains an entry for each file matching the criteria.</p>
<p>
The routine in FIGURE 4 is similar, except it's designed to work in Excel instead of Word. This time the code searches for "xls" instead of "dot" file types, and it looks in subfolders of the folder designated in the <b>LookIn</b> property. The structure of the procedure is identical in all other respects, except for how the return set integrates with the application.</p>
<p>
FIGURE 4 differs from FIGURE 3 primarily in the Excel-specific code needed to enter the number of files found and the list of their names into a spreadsheet. Cells A2 and A3 contain labels of "File Count:" and "Files:", respectively. The code writes the count of files found into cell B2, and it writes the list of file names and paths into column B, starting in cell B3. The <b>Offset</b> method moves the <b>ActiveCell</b> progressively down column B. At the conclusion, two formatting steps improve the appearance of the final output. First, the routine left-justifies the file count in cell B2. This brings the number close to the "File Count:" label. Second, the routine expands column B's width so that it accommodates its longest entry.</p>
<p>
FIGURE 5 presents an approach to the same basic problem tackled in the first two examples, but this time the code does it from Access. Although this code works in Access, the syntax for the FileSearch properties and methods correspond to those used for the Word and Excel examples. This simple case merely sends the file count and file names to a message box for viewing by the user. Developers can use recordset navigation and updating methods to enter file names into a table for subsequent review.</p>
<p>
FIGURE 6 presents an example that uses the <b>PropertyTests</b> collection. Recall that this method is necessary for setting advanced file search criteria, such as those that appear in the Advanced Find dialog box. I used the <b>Add</b> method of the <b>PropertyTests</b> collection to create two <b>PropertyTest</b> objects. The first object designates a search for Access database files. The second object restricts the search to files last modified sometime in 1996. The <b>Connector</b> property specifies how the criteria work together. The arrangement of <b>Connector</b> property settings in FIGURE 6 requires that files be of a database type and that they be last modified sometime in 1996.</p>
<p>
The return set for this search will depend on how you install and use the sample files that ship with Access. If you don't modify these files (and you installed all three sample applications), the search will return three files in the <b>FoundFiles</b> collection. Because I regularly modify the Northwind database, its last modified date falls outside the range designated by the second <b>PropertyTest</b> object. Therefore, the procedure in FIGURE 6 returned two files when I ran it.</p>
<pre><code>Public Sub FirstSearch()

Dim strFile As String

  With Application.FileSearch
    .LookIn = "C:\Program Files\Microsoft " &amp; _
                "Office\Office"
    .SearchSubFolders = False
    .FileName = "*.dot"
    If .Execute() &gt; 0 Then
      Selection.TypeText "There were " &amp; _
        .FoundFiles.Count &amp; " file(s) found."
      Selection.TypeParagraph
      For i = 1 To .FoundFiles.Count
        strFile = .FoundFiles(i)
        Selection.TypeText Text:=strFile
        Selection.TypeParagraph
      Next i
    Else
      MsgBox "There were no files found."
    End If
  End With

End Sub</code></pre>
<p>
<b>FIGURE 3: A simple file search in Word.</b></p>
<pre><code>Public Sub SecondSearch()

  With Application.FileSearch
    .LookIn = "C:\Program Files\" &amp; _
      "Microsoft Office\Office"
    .SearchSubFolders = True
    .FileName = "*.xls"
    If .Execute() &gt; 0 Then
      Sheets("Sheet1").Select
      Range("B2").Select
      ActiveCell.Value = .FoundFiles.Count
      For i = 1 To .FoundFiles.Count
        ActiveCell.Offset(1, 0).Activate
        ActiveCell.Value = .FoundFiles(i)
      Next i
      Range("B2").HorizontalAlignment = xlLeft
      ActiveSheet.Columns("B").AutoFit
    Else
      MsgBox "There were no files found."
    End If
  End With

End Sub</code></pre>
<p>
<b>FIGURE 4: A simple file search in Excel.</b></p>
<pre><code>Public Sub ThirdSearch()

Dim i As Integer

  With Application.FileSearch
    .LookIn = "C:\Program Files\" &amp; _
      "Microsoft Office\Office"
    .SearchSubFolders = True
    .FileName = "*.mdb"
    If .Execute() &gt; 0 Then
      MsgBox "There were " &amp; .FoundFiles.Count &amp; _
        " file(s) found."
      For i = 1 To .FoundFiles.Count
        MsgBox .FoundFiles(i)
      Next i
    Else
      MsgBox "There were no files found."
    End If
  End With

End Sub</code></pre>
<p>
<b>FIGURE 5: A simple file search in Access.</b></p>
<pre><code>Public Sub FourthSearch()
Dim fs As FileSearch

  Set fs = Application.FileSearch
  fs.NewSearch
  With fs.PropertyTests
    .Add Name:="Files of Type", _
      Condition:=msoConditionFileTypeDatabases, _
      Connector:=msoConnectorOr
    .Add Name:="Last Modified", _
      Condition:=msoConditionAnytimeBetween, _
      Value:="1/1/96", SecondValue:="12/31/96", _
      Connector:=msoConnectorAnd
  End With

  With fs
    .LookIn = "C:\Program Files\" &amp; _
      "Microsoft Office\Office"
    .SearchSubFolders = True
    If .Execute() &gt; 0 Then
      Sheets("Sheet1").Select
      Range("B2").Select
      ActiveCell.Value = .FoundFiles.Count
      For i = 1 To .FoundFiles.Count
        ActiveCell.Offset(1, 0).Activate
        ActiveCell.Value = .FoundFiles(i)
      Next i
      Range("B2").HorizontalAlignment = xlLeft
      ActiveSheet.Columns("B").AutoFit
    Else
      MsgBox "There were no files found."
    End If
  End With

End Sub</code></pre>
<p>
<b>FIGURE 6: An advanced file search in Excel.</b></p>
<h2>Drawing Objects</h2>
<p>
The <b>Shapes</b> and <b>ShapeRange</b> collections, along with the <b>Shape</b> object, provide programmatic entrée to the drawing layer that sits above the document layer in Excel 97, Word 97, and PowerPoint 97. The properties and methods for the two collections and object enable developers to programmatically manage images and WordArt in Office 97 documents.</p>
<p>
The <b>Shapes</b> collection is the aggregate of all images, including AutoShapes, freeform, OLE objects, and pictures, on the drawing layer of an Office 97 document. Through variations of its <b>AddShape</b> method, the <b>Shapes</b> collection permits a developer to add new shapes to a document. The <b>Shapes</b> collection permits a developer to concurrently manipulate all the images on a document. Developers can designate a specific shape on a document by an index reference. The index can be a name, such as Shapes("StarTwo"), or a number, such as Shapes(2). Use an array to concurrently designate two or more shapes in a collection. For example:</p>
<pre><code>Shapes.Range(Array("StarOne", "StarTwo"))
</code></pre>
<p>
designates two shapes from the <b>Shapes</b> collection with the names <i>StarOne</i> and <i>StarTwo</i>.</p>
<p>
A <b>ShapeRange</b> collection is a subset of the shapes on a document. It can contain one, some, or all the shapes in a document. When a <b>ShapeRange</b> includes all the shapes in a document, it's equivalent to the <b>Shapes</b> collection. When a <b>ShapeRange</b> contains just one shape, it is equivalent to the corresponding <b>Shape</b> object. Use the <b>Group</b> method to assemble several individual shapes into a <b>ShapeRange</b>. Designate individual shapes by a name or number index, as with the <b>Shapes</b> collection. Select a subset of shapes with the <i>Array</i> argument.</p>
<p>
There are two ways to manipulate the properties of shapes within a <b>ShapeRange</b> collection. First, apply the property setting to the collection as a whole. If all objects in a group do not accept that property setting, this approach can generate an error. Second, loop through the items in a <b>ShapeRange</b> collection and check shape types to verify whether they qualify for the property setting adjustment. Only two-dimensional AutoShapes have text frames. Therefore, if you try to assign text to the text frame of a line, your code will generate an error. Looping through the elements within a <b>ShapeRange</b> collection permits a developer to assess the shape type and avoid invalid property settings.</p>
<h2>Drawing Properties and Methods</h2>
<p>
Use the <b>AddShape</b> method to add AutoShapes. There are well over 100 AutoShapes you can reference by names such as <b>msoShape16pointStar</b>, <b>msoShapeCurvedLeftArrow</b>, and <b>msoShapeIsoscelesTriangle</b>. The <b>AddShape</b> method also takes four other numeric arguments that specify the size and location of the shape on the drawing layer. The numeric values for top, left, width, and height are in points (1/72 of an inch). By adjusting a shape's top and left properties, a developer can animate a shape within the drawing layer. Varying a shape's width and height permit an application to change the size of a shape. Applications can also change the color of shapes by altering their RGB property settings.</p>
<p>
Other options offer additional opportunities to populate a document's drawing layer. Developers can create new OLE objects in a document with the <b>AddOLEObject</b> method. Use the <b>AddPicture</b> method to create a picture based on a graphic image file. Specify a particular graphic image file with the <i>FileName</i> argument for the method and indicate whether to link or embed the graphic image into the document with the <i>LinkToFile</i> argument. A wide collection of other <b>Add...</b> methods ease the process of adding more special-purpose shapes to a document. The method names suggest the scope of the options: <b>AddCurve</b>, <b>AddLabel</b>, <b>AddLine</b>, <b>AddTextEffect</b>, and <b>BuildFreeForm</b>. The <b>AddTextEffect</b> permits WordArt effects.</p>
<p>
After adding shapes to a document, developers can code their properties. Because a shape can instantly reflect a change in its property settings, developers can dynamically change the appearance of a shape on a document. Because of the huge scope of properties available for shapes, developers have the latitude to achieve stunning effects. One way to begin learning about the options available and how to manage them is by using the Drawing toolbar to add and manipulate shapes while you record your actions in a macro. Then you can examine the macro to determine which property settings to change to achieve desired effects programmatically. Online Help lists names for AutoShapes, as well as constant names for values that methods can assume.</p>
<p><img src="rd_fig07.gif">
</p>
<p>
<b>FIGURE 7. A succession shape transitions programmed with the shared Drawing object model and VBA.</b></p>
<h2>Drawing Code Examples</h2>
<p>
A pair of sample applications hint at some of what is possible with the Drawing shared object model. My first example successively manipulates the position, size, and color of a shape at the beginning of three discrete one-second intervals. The second example highlights different techniques for manipulating sets of shapes on the drawing layer.</p>
<p>
FIGURE 7 shows the first drawing application in action. It illustrates the kind of advanced dynamic effects that are easy to generate with the Drawing object model. For the first second, it shows a small oval in a dark shade of green. During the second interval, the shape moves down and to the right edge of the window. At the same time, it grows more like a circle and turns a lighter shade of green. At the beginning of the third second, the shape moves farther down the screen and to the right. It also completes its metamorphosis from an oval to a circle. Finally, the shape turns a bright shade of green.</p>
<p>
FIGURE 8 presents the two short procedures that generate the dynamic effects displayed in FIGURE 7. One of these procedures, <b>WaitSeconds</b>, does nothing more than time durations. The argument passed to the procedure determines the duration that it pauses before returning control to the calling routine. These pauses are critical to the effect because they allow enough time to elapse between transitions for the viewer to see them.</p>
<p>
The <b>MakeCircle</b> procedure initially generates the oval, then transforms its position, size, and color. It calls the <b>WaitSeconds</b> routine after preparing a revised shape so the application pauses long enough for the viewer to see the effect.</p>
<p>
The <b>MakeCircle</b> procedure begins by declaring two variables. The <i>shpShape</i> variable stores the property settings for the shape as it transitions from its initial form to its final image in the lower right corner of FIGURE 7. The <i>wksDocument</i> variable is the Worksheet document that acts as the host for the drawing layer. The <b>AddShape</b> method draws the initial version of the oval on the drawing layer. Its top, left, width, and height settings are not immediately relevant because the following line sets the oval's <b>Visible</b> property to <i>False</i>. This suppresses its image on the drawing layer until the program is ready to reveal the manipulation of its property settings.</p>
<p>
A simple <b>For…Next </b>statement manages the transitions. The<i> i </i>index for the <b>For</b> loop starts with a value of 85 and progresses in two steps to 255. On the first pass through the loop, the shape's <b>Visible</b> property changes to <i>True</i>. This allows viewers to see the shape change its location, size, and color with each pass through the loop.</p>
<p>
Four transition effects occur during each pass through the loop. First, the color is set to the green value that matches the value of <i>i</i>. Second, the left edge of the shape is set to 1/3, 2/3, or 3/3 of an inch (85 divides evenly into 255 three times, and 72 points equals one inch). Third and fourth, the height and top of the shape also adjust in 1/3 inch increments to one inch. As the top grows larger, the shape gets pushed farther down the screen. Similarly, as the left setting increases, the shape pushes away from the left window edge and toward the right boundary. Because the initial width for the oval is 72 points, the oval transforms into a circle when its height also grows to 72 points on the third pass through the <b>For</b> loop.</p>
<p>
FIGURE 9 displays basic <b>ShapeRange</b> development techniques. It performs two rounds of adjustments to the elements of a <b>ShapeRange</b>. In the first round, all the stars get a vertical, desert gradient fill effect. In the second round, only the second star in the <b>ShapeRange</b> has its fill effect altered to a horizontal gradient fill effect. The routine controlling these effects reinforces how to use the <b>AddShape</b> method, and it illustrates basic <b>ShapeRange</b> techniques.</p>
<p>
FIGURE 10 shows the short and simple routine that generates the effect in FIGURE 9. It starts by adding three five-pointed stars to the drawing layer. Next, it constructs a <b>ShapeRange</b> with the <b>Range</b> property of the <b>Shapes</b> collection. After the <b>ShapeRange</b> gets constructed as the composite of all three stars, the code sets their fill effect as it appears on the first and third stars in FIGURE 9. A second manipulation uses an index to reference only the second star. This star has its fill property setting changed from a vertical gradient effect to a horizontal one.</p>
<pre><code>Public Sub MakeCircle()

Dim shpShape As Shape, wksDocument As Worksheet

  Set wksDocument = Worksheets(1)
  Set shpShape = wksDocument.Shapes.AddShape _
                   (msoShapeOval, 72, 72, 72, 36)
  shpShape.Visible = False

  For i = 85 To 255 Step 85
    shpShape.Fill.ForeColor.RGB = RGB(0, i, 0)
    shpShape.Left = (i / 255) * 72
    shpShape.Height = (i / 255) * 72
    shpShape.Top = (i / 255) * 72
    shpShape.Visible = True
    WaitSeconds 1
  Next i

End Sub

Public Sub WaitSeconds(intSeconds)

Dim intHour As Integer, intMinute As Integer
Dim intSecond As Integer, varTime As Variant

  intHour = Hour(Now())
  intMinute = Minute(Now())
  intSecond = Second(Now()) + intSeconds
  varTime = TimeSerial(intHour, intMinute, intSecond)
  Application.Wait varTime

End Sub</code></pre>
<p>
<b>FIGURE 8. A pair of procedures to generate the dynamic shapes in FIGURE 7.</b></p>
<p><img src="rd_fig09.gif">
</p>
<p>
<b>FIGURE 9. The outcome of two ShapeRange manipulations (see FIGURE 10 for the details).</b></p>
<pre><code>Public Sub GroupShapes()

Dim wksMyDoc As Worksheet

  Set wksMyDoc = Worksheets(1)

  With wksMyDoc.Shapes
    .AddShape(msoShape5pointStar, _
      6, 12, 36, 36).Name = "StarOne"
    .AddShape(msoShape5pointStar, _
      54, 12, 36, 36).Name = "StarTwo"
    .AddShape(msoShape5pointStar, _
      102, 12, 36, 36).Name = "StarThree"

    With .Range(Array("StarOne", "StarTwo", _
      "StarThree")).Group
      .Fill.PresetGradient msoGradientVertical, _
        1, msoGradientDesert
      .GroupItems(2).Fill.PresetGradient _
        msoGradientHorizontal, 1, msoGradientDesert
    End With

  End With

End Sub</code></pre>
<p>
<b>FIGURE 10: A procedure demonstrating ShapeRange manipulation techniques shown in FIGURE 9. </b></p>
<h2>Conclusion</h2>
<p>
The Office 97 shared object models offer a collection of tools common to three or more Office 97 applications. This article introduces four basic shared object models and presents the basics of the FileSearch and Drawing object models. The second and third installments in this series will illustrate how to work with the Assistant and CommandBars object models.</p>
<p>
<i>The files referenced in this article are available for download from the Informant Web site at http://www.informant.com/mod/modnewupl.htm. File name: MOD9711RD.ZIP.</i></p>
<p>
<i>Rick Dobson, Ph.D. heads his own database and Web development consultancy. His byline appears in several leading publications, including Byte, and he is a Contributing Editor to Microsoft Interactive Developer, a Microsoft publication. In addition, Rick is an MCT who is certified to teach Mastering Microsoft Office 97 Development. You can reach him at RickD@cabinc.win.net.</i></p>
</font></BODY>
</HTML>
