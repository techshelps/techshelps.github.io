<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Designing ActiveX Components Part II:  Implementing Internet Communications with WinInet</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<font face="verdana,arial,helvetica" size="2">
<form name=x>
<object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object>
</form>
<h1>Designing ActiveX Components Part II:  Implementing Internet Communications with WinInet</h1>
<p>
In last month's issue of <i>MIND</i>, I explained how to use MFC's document/view architecture to add a sophisticated user interface to your ActiveX™ controls. As an example, I created an ActiveX control version of the well-known Scribble sample application (introduced in the Visual C++® tutorials). In this month's follow-up article, I'll make good on my promise to enhance the control so that, instead of storing its data on the user's hard drive, the control sends the information to a Web server that makes the data available to all other running instances of the control. In other words, I'll convert the control into a real-time World Wide Web whiteboard. Before I do that, let me give you a little background.</p>
<p>
With the emergence of low-cost PC hardware and the fierce competition among Internet service providers (ISP), access to the Internet has become available to nearly everyone. Unfortunately, most Internet newbies think that the World Wide Web and the Internet are one and the same. This is not the case, of course. For well over a decade, computer enthusiasts around the world have used the Internet to communicate with each other. Technologies such as email, MUD servers, Internet Relay Chat, USENET Newsgroups-even Internet Chess servers-were used to share ideas long before the emergence of the Web. Although the Web is an unprecedented platform for publishing information, I believe the real value of the Internet will continue to be its ability to provide near-real-time communication between two or more users. As a result, the path to the future is cobbled with technologies such as the ActiveX Platform that let developers combine the live elements of traditional Internet applications with the power of the Web.</p>
<h2>Along Comes ActiveX</h2>
<p>
Let's say you're developing software that lets users send information to each other over the Internet. Traditionally, you would have created a full-featured application using WinSock (or an even lower level vendor-specific protocol). Today, with the ActiveX Platform, you can place a few ActiveX controls on a Web page to accomplish the same task. There are several advantages of this approach over a standalone application:
<ul>
<li>
You can download or buy a large number of third-party ActiveX controls, thus minimizing the code you have to write from scratch.
</li>
<li>
The code that you do write can be packaged into ActiveX controls so that common objects can be reused more effectively.
</li>
<li>
You can take advantage of the look-and-feel consistency and existing functionality of the user interface provided by the Web browser.
</li>
<li>
You don't need to worry about how you will deploy and update your software because the Web browser will do it for you using the Component Download Service provided by the ActiveX Platform.
</li>
<li>
You don't have to write a complicated setup program that configures the Internet access on each user's machine-you simply piggyback the configuration that the Web browser stores in the registry.
</li>
</ul>
<p>
The ActiveX approach to development is advantageous to the user as well. Instead of working with several different Internet applications, each with its own look and feel, the user can complete the same tasks from within a single application: the Web browser. A few examples of ActiveX control components that could take the place of full-blown Internet applications are a chat control, a stock ticker control, and a shared whiteboard control.</p>
<p>
I should point out that not all ActiveX controls need the ability to communicate with other controls (or applications) over the Internet. In many cases, the intercommunication provided by the Web browser is sufficient. For example, a simple ActiveX push button (like the Microsoft Forms 2.0 Command Button control that ships with Internet Explorer 3.01) doesn't need to send information back to the Web server because the logic that surrounds the control (a combination of ActiveX Scripting and the HTML &lt;FORM&gt; tag) takes care of that for you.</p>
<h2>Internet Communication Between ActiveX Controls</h2>
<p>
While developing the sample code for this article, I came up with two general strategies for getting ActiveX controls to talk to each other over the Internet. The first method uses the WinSock API, and the second uses the WinInet API.</p>
<p>
Using the WinSock API With WinSock as the communication layer, you can design an ActiveX control with the ability to act as either a client or a server. When the user accesses the control (from a Web page, for example), he or she must tell it which role to play. If the control is acting as a client, the user must give it the IP address and port number of the socket created by the control acting as the server. The server control maintains a connection with all of the client controls and broadcasts the information it receives from one client to all of the other clients, as shown in Figure 1. This is how you would implement a typical chat control.</p>
<p><img src="scribble_01.gif"></p>
<p><b>Figure 1: ActiveX Intercommunication using WinSock</b></p>
<p>
The advantage of using WinSock is that you don't have to write code to continuously poll the server control. Instead, you implement a callback function in the client code that is automatically called by WinSock when the server sends it information. In addition, since the control can act as both a server and a client, a special server application is not required.</p>
<p>
The drawback of the WinSock approach is that the client control must know the IP address and port number of the server socket in order to connect to it. Unfortunately, users who access the Internet using a modem are often given a different IP address each time they connect to their ISP. You can't simply hard-wire the port number in the client code because the port you choose might already be in use by another application. Furthermore, unless you write and install a proxy, your control's WinSock requests will not be allowed to cross a firewall boundary.</p>
<p>
Using the WinInet API First, you create an ISAPI extension .dll or CGI application running on a Web server that acts as a data repository for the information collected by each ActiveX control. Then, using the HTTP protocol provided by the WinInet API, you write a control that sends its data to the server extension (using the POST command) and asks for the data sent by the other controls (using the GET command), as shown in Figure 2. This is the approach I used for the Scribble control.</p>
<p><img src="scribble_02.gif"></p>
<p><b>Figure 2: ActiveX Intercommunication using a server</b></p>
<p>
Compared to the WinSock method, using the WinInet routine is a breeze-the details of the connection between the Web server and your control are handled for you. Assuming your ActiveX control is used from within a Web page, you can use ActiveX Scripting to tell the control the location of your server extension so the control doesn't have to ask the user. Because most proxy servers support HTTP, crossing a firewall is not a problem.</p>
<p>
However, you must write a server extension .dll or CGI script (and find a Web server on which to use it) to store the data sent by each of the ActiveX control clients. Using the HTTP protocol, the connection between the client (the ActiveX control, in this case) and the server is brief and one-sided. An HTTP server cannot initiate a connection with its clients-it must wait for them to issue a POST or a GET request. After the data is sent, the connection is terminated. As a result, the control must poll the Web server when it wants the data sent by other controls.</p>
<h2>Improving the Active Scribble Example</h2>
<p>
In the past, some of my unenlightened UNIX-loving buddies have poked fun at my enthusiasm for Microsoft development technologies. After they read this article, I'm sure there will be no end to the wisecracks about my ActiveX evangelism. I've decided that my only chance to get the last laugh is to present some sample code that blows them away. I've come up with an improved version of the ActiveX control that I presented last month. To refresh your memory, I'll summarize what I presented in the April issue.</p>
<p>
First, I introduced two general-purpose helper classes, CActiveXDocTemplate and CActiveXDocControl, that allow you to use the document/view architecture within an ActiveX control. Using these two classes, you can add toolbars, "splitter" windows, scrolling, distinct data views, and object serialization to your ActiveX controls with little effort. I then created an ActiveX control, based on the Scribble sample application that appears in the Visual C++ tutorials, that lets you draw a series of marker strokes on a virtual whiteboard. I also created two classes specific to the control, CScribbleDoc and CScribbleView, that do the work of storing the marker strokes and displaying them on the screen.</p>
<p>
Using the WinInet communication method, the new version of the control sends the marker strokes to a Web server instead of storing them on the hard drive. To get the marker strokes drawn by other Scribble control users, each control polls the server in a background thread. I used the Internet Server API (ISAPI) to implement the server extension .dll, which I'll describe later on. If I access a Web page containing the Scribble control from my computer in Utah while a friend in Connecticut is viewing the page, we see each other's marker strokes appear on our screens, as shown in Figure 3.</p>
<p><img src="scribble_03.gif"></p>
<p><b>Figure 3: Sharing marker strokes between controls</b></p>
<h2>HTTP Basics</h2>
<p>
Since the Scribble control uses the HTTP protocol provided by the WinInet API, the requests it sends to the server extension look something like the cryptic URLs you get when you perform an Internet search from your Web browser. For example, when I did a Yahoo search on the words "Microsoft Interactive Developer Magazine," my Web browser displayed the following URL in the Location box:</p>
<pre><code>http://search.yahoo.com/bin/search?p=Microsoft+Interactive+Developer+Magazine
&amp;hc=0&amp;hs=0</code></pre>
<p>
While a complete explanation of URLs and HTTP requests like the one shown above is beyond the scope of this article, let me point out a few basics. I'm simplifying things a bit, but making an HTTP request to a server is essentially the same as giving your Web browser a URL that takes the following general form:</p>
<pre><code>&lt;address of server extension&gt;?&lt;first parameter&gt;&amp;&lt;second parameter&gt;&amp; ...
 &amp;&lt;last parameter&gt;</code></pre>
<p>
Since spaces and NULL characters are not allowed by the HTTP protocol, characters like ?, +, and &amp; are used to separate the various parts of the request. In the example above, the address of the server extension that performs Yahoo searches is http://search.yahoo.com/bin/search. The text after the question mark represents the parameters that are passed to the extension.</p>
<p>
In general, a server extension is either a .dll or an application located on the server that gets executed whenever it's referenced by a Web browser. When the Web browser makes the HTTP request, the server parses the URL to determine the name and location of the extension to execute and the parameters to pass into it. In the example, the server extension is most likely a CGI application located on the Yahoo server. When the search application is executed, it compares the parameters that were passed into it with the information in its database and outputs the search results in the form of the HTML that is sent back to the browser. Because the HTML is generated by a running application instead of being read from a file, a Web page is created "on the fly" for each search. Without the ability to create Web pages dynamically, the server would not be able to perform operations like search requests that have many different possible results.</p>
<h2>The CGatewayInterface Helper Class</h2>
<p>
To encapsulate and simplify the use of the WinInet API within the Scribble control, I created a helper class, CGatewayInterface, that handles the requests to the server extension. As a result, I won't spend any time discussing the nuances of the WinInet API itself. Hopefully, you can just use the CGatewayInterface class in your code and not worry about it. The constructor for CGatewayInterface takes two parameters: the URL of the server extension and the handle of the window that will be notified if there are HTTP errors (see Figure 4). In my sample code, the Scribble server stores the marker strokes that have been drawn on the whiteboard. However, the CGatewayInterface is generalized so you can use it to transfer data to and from any server extension.</p>

<p><b>Figure 4: Gateway.h</b></p>
<pre><code>#if !defined(_WININET_)
typedef LPVOID HINTERNET;
typedef HINTERNET* LPHINTERNET;
#endif

class CGatewayInterface
{
    #define SEPARATOR_CHAR '@'
    
    HINTERNET m_hSession;
    HINTERNET m_hConnect;
    CString m_strURL, m_strModule;
    HWND m_hWndNotify;

public:
    CGatewayInterface(CString module_url, HWND hWndNotify = NULL);
    ~CGatewayInterface();

    void SendErrorMsgOnFalse(BOOL bCondition, CString strMessage);

    CString MakeRequest(const char* lpstrAction,
        CString& strParams = CString(""),
        const char* lpstrMethod = "GET");

    // Convenience functions

    static void MakeParamFromObject(CObject* pObject, CString& strAscii);
    static CObject* MakeObjectFromParam(CRuntimeClass* pObjType,
                                        CString& strAscii);
};
</code></pre>
<p>
When an error occurs, the CGatewayInterface class posts a WM_HTTPERROR message along with the text that describes the error. I chose to post a notification message to a window rather than simply returning an error code because you may want to make the HTTP requests in a worker thread, and only notify the user interface thread when there's an error. This parameter is optional, so if your control doesn't need to be notified of errors, you can ignore it.</p>
<p>
In the sample Web page that I've provided, I use ActiveX Scripting to pass the URL of the server extension into the control at runtime, but if you were to hard-code the URL, it might look something like this:</p>
<pre><code>CGatewayInterface extInterface("http://myserver/scripts/myext.dll", hMyWnd);</code></pre>
<p>
The CGatewayInterface constructor parses the URL and calls the WinInet InternetOpen and InternetSession functions. You should refer to the WinInet API documentation for an in-depth explanation of the two functions, but basically they create "Internet handles" that are used when making requests to the Web server. After creating a CGatewayInterface object, you make server requests using that object's MakeRequest method. The MakeRequest function takes three parameters:</p>
<p>
The name of the action being performed If the server extension is implemented as an ISAPI .dll, this name represents the name of the function within the .dll that will be called by the Web server. If you want to call the .dll's default function, or if the extension is implemented as a CGI application, this value should be NULL.</p>
<p>
The parameter list This is the context information that is passed to the server extension, with each parameter separated by an ampersand (&amp;). In the Yahoo example described earlier, the parameter list is "p=Microsoft+Interactive+<br>
Developer+Magazine&amp;hc=0&amp;hs=0." As I mentioned before, this string cannot contain any spaces or NULL characters because HTTP doesn't allow them.</p>
<p>
The command type CGatewayInterface supports the HTTP POST and GET commands. Although you should again consult the WinInet documentation or the HTTP protocol specification for more information on these commands, you basically use POST to send information to the server and GET to receive information from the server. In general, any information submitted to the Web browser using a button labeled Submit is a POST request. In the Scribble sample, I use POST to send a marker stroke from the control to the server and GET to receive strokes created by other controls.</p>
<h2>Converting a Binary Object Into a Parameter</h2>
<p>
In the ActiveX Scribble control, the CStroke class encapsulates the data for a single marker stroke. CStroke contains information about the size and color of the marker used to draw the stroke, the stroke's bounding rectangle, and the <br>
array of points that make up the stroke. When the user <br>
draws a stroke, the control sends it to the server extension. Using the CGatewayInterface class, that HTTP request might look something like this:</p>
<pre><code>CGatewayInterface extScribble("http://zimsoft/scripts/scribsrv.dll");
extScribble.MakeRequest("SendStroke", pStroke, "POST");</code></pre>
<p>
Of course, this code won't compile because the second parameter of the MakeRequest function does not take a CStroke pointer-it takes an LPSTR. If you're like me, you're probably thinking that you could just cast the CStroke pointer to an LPSTR in the call to the MakeRequest function. Unfortunately, that won't work either. Since a CStroke object is comprised of mostly integers, it will almost certainly contain several zeros if it's treated as an array of characters. As soon as the MakeRequest function gets to the first zero, it'll think it has reached the end of the parameter string. As a result, sending a binary object to a Web server using HTTP is a bit tricky. </p>
<p>
To solve this problem, I added two public methods to the CGatewayInterface class: MakeParamFromObject and MakeObjectFromParam (see Figure 5). MakeParamFromObject converts a CObject-derived class into a text string that can be passed into the MakeRequest function. MakeObjectFromParam creates an instance of a CObject-derived class using a text string created by MakeParamFromObject. With the help of MakeParamFromObject, the code snippet can be modified with little effort so that it 
works correctly:</p>
<pre><code>CGatewayInterface extScribble("http://zimsoft/scripts/scribsrv.dll");
CString strParam;
extScribble.MakeParamFromObject(pStroke, strParam);
extScribble.MakeRequest("SendStroke", strParam, "POST");</code></pre>
<p>
Since the MakeParamFromObject and MakeObjectFromParam functions call the Serialize method of the CObject-derived class, you can develop your objects without having to worry about whether they'll be stored on disk or on a remote server. In fact, if you look carefully at the CStroke code in the Scribble control (see Figure 6), you'll see that it remains unchanged from last month's example.</p>

<p><b>Figure 5: Gateway.cpp</b></p>
<pre><code>#include "stdafx.h"
#include &lt;wininet.h&gt;
#include "Gateway.h"

CGatewayInterface::CGatewayInterface(CString module_url, HWND hWndNotify)
: m_hWndNotify(hWndNotify),
  m_strURL(module_url)
{
    // Separate the URL path into the server path and
    // the module to be called (such as an ISAPI DLL or
    // CGI script).

    const char* HTTP_URL = "HTTP://";
    if (strnicmp(module_url, HTTP_URL, strlen(HTTP_URL)) == 0)
        module_url = module_url.Mid(strlen(HTTP_URL));

    int index = module_url.Find("/");
    CString server = (index != -1) ? module_url.Left(index) : module_url;
    m_strModule = module_url.Mid(index);

    // Open an Internet Session and connect to the server

    m_hSession = InternetOpen(AfxGetAppName(),
                              PRE_CONFIG_INTERNET_ACCESS, NULL, NULL, 0);

    m_hConnect = InternetConnect(m_hSession, server,
                                 INTERNET_INVALID_PORT_NUMBER, NULL, NULL,
                                 INTERNET_SERVICE_HTTP, 0, 0);

    SendErrorMsgOnFalse(m_hSession && m_hConnect,
                        CString("Could not connect to ") + server);
}

CGatewayInterface::~CGatewayInterface()
{
    InternetCloseHandle(m_hConnect);
    InternetCloseHandle(m_hSession);
}

void CGatewayInterface::SendErrorMsgOnFalse( BOOL bCondition,
                                             CString strMessage)
{
    if (!bCondition && ::IsWindow(m_hWndNotify))
    {
        SendMessage(m_hWndNotify, WM_HTTPERROR, 0, 
                    (LPARAM)strMessage.LockBuffer());
        strMessage.UnlockBuffer();
    }
}

CString CGatewayInterface::MakeRequest(const char* lpstrAction,
                                       CString& strParams, const char* lpstrMethod)
{
    ASSERT(lpstrAction);
    ASSERT(!strcmp(lpstrMethod, "GET") || !strcmp(lpstrMethod, "POST"));
    
    CString strAction;
    if (lpstrAction && strlen(lpstrAction) != 0)
    {
        strAction += "?";
        strAction += lpstrAction;
    }

    if (strcmp(lpstrMethod, "GET") == 0 && !strParams.IsEmpty())
    {
        strAction += "&";
        strAction += strParams;
        strParams.Empty();
    }

    HINTERNET hHttpFile;

    hHttpFile = HttpOpenRequest(m_hConnect, lpstrMethod, m_strModule + strAction,
                                HTTP_VERSION, NULL, 0, INTERNET_FLAG_DONT_CACHE, 0);

    SendErrorMsgOnFalse(hHttpFile != NULL,
                        CString("Error opening: ") + m_strURL);

    CString strResponse;
    if (hHttpFile)
    {
        BOOL bSendRequest = HttpSendRequest(hHttpFile, NULL, 0,
                                            (LPVOID) strParams.LockBuffer(),
                                            strParams.GetLength());
        strParams.UnlockBuffer();
        SendErrorMsgOnFalse(bSendRequest,
                            CString("Error sending request: ") + m_strURL);
  
        if (bSendRequest)
        {
            const UINT BUFFSIZE = 1024;
            char sBuffer[BUFFSIZE];
            DWORD dwBytesRead;

            while (InternetReadFile(hHttpFile, sBuffer,
                                    BUFFSIZE, &dwBytesRead) && dwBytesRead > 0)
            {
                strResponse += CString(sBuffer, (int)dwBytesRead);
            }
        } 

        InternetCloseHandle(hHttpFile); 
    }

    return strResponse;
}

//////////////////////////////////////////////////////////////////////
// Helper functions //////////////////////////////////////////////////
void CGatewayInterface::MakeParamFromObject(CObject* pObject, CString& strAscii)
{
    ASSERT(pObject);

    CMemFile memFile;
    CArchive archive(&memFile, CArchive::store);
    pObject->Serialize(archive);
    archive.Close();

    char sTemp[20];
    UINT nLength = memFile.GetLength();
    UCHAR* pBuffer = memFile.Detach();
    long* pArray = (long*) pBuffer;

    strAscii = itoa(nLength, sTemp, 10);
    for (UINT nLoop = 0; nLoop &lt; nLength / sizeof(long); nLoop++)
    {
        strAscii += SEPARATOR_CHAR;
        strAscii += ultoa(pArray[nLoop], sTemp, 16);
    }

    delete [] pBuffer;
}

CObject* CGatewayInterface::MakeObjectFromParam(CRuntimeClass* pObjType,
                                                CString& strAscii)
{
    char* pNextNum = strAscii.LockBuffer();

    UINT nLength = (UINT) strtoul(pNextNum, &pNextNum, 10) / sizeof(long) + 1;
    ULONG* pArray = new ULONG[nLength];

    for (UINT nCount = 0; nCount &lt; nLength; nCount++)
        pArray[nCount] = strtoul(++pNextNum, &pNextNum, 16);

    strAscii.UnlockBuffer();

    CMemFile memFile((BYTE*) pArray, nLength * sizeof(long));
    CArchive archive(&memFile, CArchive::load);
    CObject* pObject = pObjType->CreateObject();
    pObject->Serialize(archive);
    archive.Close();

    delete [] pArray;
    return pObject;
}

</code></pre>
<h2>CScribServDoc</h2>
<p>
Rather than changing the code in last month's CScribbleDoc class to integrate the calls to CGatewayInterface, I decided instead to create a new class, CScribServDoc, that inherits from CScribbleDoc and overrides only the functions that need to be changed (see Figure 7). When the Web browser sets the DocumentName property of the Scribble control (using ActiveX Scripting), the control calls CScribServDoc::OnOpenDocument. The DocumentName property represents the URL of the Scribble server extension. CScribServDoc::OnOpenDocument then creates a CGatewayInterface object and starts up a background thread that repeatedly polls the server for the marker strokes submitted by other instances of the control. When the user releases the mouse button at the end of a marker stroke, the CScribServDoc::FinishStroke function sends that stroke to the server. When the eraser button is clicked, the CScribServDoc::OnEraser function makes a server request that calls the server extension .dll's RemoveStrokes function.</p>

<p><b>Figure 6: ScribDoc.cpp</b></p>
<pre><code>// ScribDoc.cpp : implementation of the CScribbleDoc class

#include "stdafx.h"
#include "resource.h"
#include "ScribDoc.h"

•••

/////////////////////////////////////////////////////////////////////////////
// CStroke

IMPLEMENT_SERIAL(CStroke, CObject, 1)

CStroke::CStroke(UINT nPenWidth, COLORREF lPenColor)
{
    m_rectBounding.SetRectEmpty();
    m_nPenWidth = nPenWidth;
    m_penColor = lPenColor;
}

void CStroke::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        ar << m_rectBounding;
        ar << m_nPenWidth;
        ar << m_penColor;
    }
    else
    {
        ar >> m_rectBounding;
        ar >> m_nPenWidth;
        ar >> m_penColor;
    }

    m_pointArray.Serialize(ar);
}

void CStroke::AddPoint(CPoint& point)
{
    m_pointArray.Add(point);
}

void CStroke::DrawStroke(CDC* pDC)
{
    CPen penStroke(PS_SOLID, m_nPenWidth, m_penColor);
    CPen* pOldPen = pDC-&gt;SelectObject(&penStroke);

    pDC->MoveTo(m_pointArray[0]);
    for (int i=1; i &lt; m_pointArray.GetSize(); i++)
        pDC->LineTo(m_pointArray[i]);

    pDC->SelectObject(pOldPen);
}

void CStroke::FinishStroke()
{
    if (m_pointArray.GetSize() == 0)
    {
        m_rectBounding.SetRectEmpty();
        return;
    }

    CPoint pt = m_pointArray[0];
    m_rectBounding = CRect(pt.x, pt.y, pt.x, pt.y);

    for (int i=1; i &lt; m_pointArray.GetSize(); i++)
    {
        pt = m_pointArray[i];
        m_rectBounding.left     = min(m_rectBounding.left, pt.x);
        m_rectBounding.right    = max(m_rectBounding.right, pt.x);
        m_rectBounding.top      = min(m_rectBounding.top, pt.y);
        m_rectBounding.bottom   = max(m_rectBounding.bottom, pt.y);
    }

    m_rectBounding.InflateRect(CSize(m_nPenWidth, m_nPenWidth));
}
</code></pre>
<p><b>Figure 7: Server.cpp</b></p>
<pre><code>// Server.cpp : implementation of the CScribServDoc and
//  CScribServView classes

#include "stdafx.h"
#include "resource.h"
#include "Gateway.h"
#include "ScribDoc.h"
#include "ScribVw.h"
#include "Server.h"

/////////////////////////////////////////////////////////////////////////////
// CScribServDoc

IMPLEMENT_DYNCREATE(CScribServDoc, CScribbleDoc)

BEGIN_MESSAGE_MAP(CScribServDoc, CScribbleDoc)
    //{{AFX_MSG_MAP(CScribServDoc)
    ON_COMMAND(IDB_ERASER, OnEraser)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CScribServDoc::CScribServDoc()
{
    m_pGateway = NULL;
}

void CScribServDoc::OnEraser()
{
    // We need to tell the server extension that the
    // strokes should be removed.
    
    if (m_pGateway)
        m_pGateway->MakeRequest("RemoveStrokes");
    else
        CScribbleDoc::OnEraser();
}

void CScribServDoc::FinishStroke(CView* pView, CStroke* pStroke)
{
    CScribbleDoc::FinishStroke(pView, pStroke);

    if (m_pGateway)
    {
        // Send the finished stroke to the server
        
        CString strParam;
        m_pGateway->MakeParamFromObject(pStroke, strParam);
        CString strResult = m_pGateway->MakeRequest( "PostStroke",
                                                     strParam, "POST");

        // The server returns the index number for
        // the stroke we just sent.

        pStroke-&gt;Index() = atoi(strResult);
    }
}

UINT CScribServDoc::RequestThread(CScribServDoc* document)
{
    document-&gt;RequestServerStrokes();
    return 0;
}

void CScribServDoc::RequestServerStrokes()
{
    // This thread continuously polls the server extension
    // for new strokes. Before we ask for a given stroke,
    // however, we check to see if we already have it.
    
    UINT nStrokeIndex = 0;

    while (WaitForSingleObject(m_eventQuit, 0) != WAIT_OBJECT_0)
    {
        POSITION pos = m_strokeList.GetHeadPosition();
        while (pos != NULL)
        {
            CStroke* pStroke = m_strokeList.GetNext(pos);
            if (nStrokeIndex == pStroke-&gt;Index())
                nStrokeIndex++;
        }

        // We didn't find the stroke in our local list, so we
        // ask the server extension for it.

        char sTemp[10];
        CString strStrokeNum = itoa(nStrokeIndex, sTemp, 10);
        CString strResult = m_pGateway-&gt;MakeRequest( "GetStroke",
                                                     strStrokeNum);

        // The server returns one of three results: 1) a valid
        // stroke (which we recognize because it has numeric
        // data); 2) "EMPTY" which means that we should empty
        // our stroke list; and 3) "CURRENT" which means that
        // our stroke list is up to date.

        if (atoi(strResult) != 0)    // Valid Stroke
        {
            CStroke* pNewStroke = (CStroke*) m_pGateway->MakeObjectFromParam(
                                                 RUNTIME_CLASS(CStroke), strResult);

            pNewStroke->Index() = nStrokeIndex++;
            m_strokeList.AddTail(pNewStroke);

            // Since this code is executing in a worker thread,
            // we cannot just call UpdateAllViews. Instead, we
            // post a special message to each view telling it
            // to update itself.

            pos = GetFirstViewPosition();
            while (pos != NULL)
            {
                CView* pView = GetNextView(pos);
                pView-&gt;PostMessage(WM_UPDATEVIEW, 0, (LPARAM)pNewStroke);
            }

            continue;
        }

        if (strResult == "EMPTY" && nStrokeIndex != 0)
        {
            nStrokeIndex = 0;
            OnNewDocument();
            pos = GetFirstViewPosition();
            while (pos != NULL)
            {
                CView* pView = GetNextView(pos);
                pView->PostMessage(WM_UPDATEVIEW, 0, NULL);
            }
        }

        CString strServerError("&lt;body&gt;");
        m_pGateway->SendErrorMsgOnFalse(
            strnicmp(strResult, strServerError,
            strServerError.GetLength()), strResult);

        // Since the server has no strokes for us, we sleep
        // a while. You could make this number bigger or smaller,
        // depending on how "real-time" the updates need to be.

        Sleep(500);
    }

    m_eventRequestDone.SetEvent();
}
    
BOOL CScribServDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
    POSITION pos = GetFirstViewPosition();
    ASSERT (pos != NULL);
    
    CWnd* pFrameWnd = GetNextView(pos)->GetParent();
    ASSERT_KINDOF(CFrameWnd, pFrameWnd);
    HWND hWndNotify = pFrameWnd->GetParent()->GetSafeHwnd();

    m_pGateway = new CGatewayInterface(lpszPathName, hWndNotify);    

    // Start the thread that continuously polls the
    // server extension, looking for new strokes.

    m_eventQuit.ResetEvent();
    AfxBeginThread((AFX_THREADPROC) RequestThread, this);
    return TRUE;
}

BOOL CScribServDoc::OnSaveDocument(LPCTSTR) 
{
    if (m_pGateway)
    {
        m_eventQuit.SetEvent();
        WaitForSingleObject(m_eventRequestDone, INFINITE);
        delete m_pGateway;
        m_pGateway = NULL;
    }

    SetModifiedFlag(FALSE);
    return TRUE;
}
</code></pre>
<h2>The Scribble Server</h2>
<p>
A full explanation of Microsoft's Internet Server API is beyond the scope of this article, but I have provided a simple Scribble server as an example (see Figure 8). Even though I used MFC to create an ISAPI .dll, I could have implemented the server extension as a CGI app. The server extension has three functions of interest, which are shown in Figure 9.</p>

<p><b>Figure 8: ScribSrv.cpp</b></p>
<pre><code>// ScribSrv.cpp - Implementation file for Scribble Server Extension
// 

#include &lt;afx.h&gt;
#include &lt;afxwin.h&gt;
#include &lt;afxisapi.h&gt;
#include &lt;afxcoll.h&gt;
#include &lt;afxmt.h&gt;
#include "ScribSrv.h"

BEGIN_PARSE_MAP(CScribbleSE, CHttpServer)
    ON_PARSE_COMMAND(PostStroke, CScribbleSE, ITS_PSTR)
    ON_PARSE_COMMAND(GetStroke, CScribbleSE, ITS_I2)
    ON_PARSE_COMMAND(RemoveStrokes, CScribbleSE, ITS_EMPTY)
END_PARSE_MAP(CScribbleSE)

CScribbleSE theExtension;

DWORD CScribbleSE::HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pECB )

{
    return CHttpServer::HttpExtensionProc(pECB);
}

BOOL CScribbleSE::GetExtensionVersion(HSE_VERSION_INFO* pVer)

{
    CHttpServer::GetExtensionVersion(pVer);
    _tcscpy(pVer->lpszExtensionDesc, "Scribble Server Extension");
    return TRUE;
}

void CScribbleSE::GetStroke(CHttpServerContext* pCtxt, short index)

{
    CSingleLock lock(&m_critSection, TRUE);

    if (m_strokeArray.GetSize() == 0)
        *pCtxt &lt;&lt; "EMPTY";
    else if (m_strokeArray.GetSize() &lt;= index)
        *pCtxt &lt;&lt; "CURRENT";
    else
        *pCtxt &lt;&lt; m_strokeArray.GetAt(index);
}

void CScribbleSE::PostStroke(CHttpServerContext* pCtxt, LPCTSTR new_stroke)

{
    CSingleLock lock(&m_critSection, TRUE);
    *pCtxt << (short) m_strokeArray.Add(new_stroke);

    // Since the server extension could potentially become
    // a memory hog, we limit the number of strokes. A more
    // robust extension would cache the strokes instead.

    if (m_strokeArray.GetSize() > MAX_STROKES)
        m_strokeArray.RemoveAll();
}

void CScribbleSE::RemoveStrokes(CHttpServerContext* pCtxt)

{
    CSingleLock lock(&m_critSection, TRUE);
    m_strokeArray.RemoveAll();
    *pCtxt &lt;&lt; "Strokes Emptied!";
}
</code></pre>

<p><b>Figure 9: Server Extension Functions</b></p>
<table border=1 cellpadding=2 cols=2>
<tr>
<td><b>PostStroke</b></td>	
<td>Called by the ActiveX control to submit a stroke for storage on the server. This function adds the CStroke object (its textual representation, anyway) to a CStringArray.</td>
</tr>
<tr>
<td><b>GetStroke</b></td>	
<td>Called by the ActiveX control to get a stroke created by another control. This function returns the text representing the desired stroke. The control calls MakeObjectFromParam to convert the text back into a CStroke object.</td>
</tr>
<tr>
<td><b>RemoveStrokes</b></td>
<td>Called in response to an eraser button click. This function flushes all of the strokes stored on the server.</td>
</tr>
</table>
<p>
To keep the extension .dll simple, I did not write the code required to store the Scribble strokes to a file when the .dll is removed from memory. Thus, if the server needs to unload the extension .dll due to memory constraints (or a server shutdown), all of the strokes stored on the server are lost. However, under normal circumstances you'll find that the .dll will most likely stay in memory until the server is shut down, so the code I've provided should be enough to give you the idea.</p>
<h2>Conclusion</h2>
<p>
The complete source code and project files for the ActiveX Scribble control and the extension .dll can be downloaded from the <i>MIND</i> Website (http://www.microsoft.com/mind) along with the HTML for a simple Web page that wires them together (see Figure 10). The SCRIBBLE.OCX and SCRIBSRV.DLL files that I've included with the source code were compiled using Visual C++ 4.2 and, in fact, will not work correctly if compiled with Visual C++ 4.1 or earlier. You should also be aware that for reasons of brevity I haven't signed the ActiveX control or added the OLE interfaces necessary to mark it as safe for scripting. Thus, if your Internet Explorer safety-level preferences are set to high or medium (as they probably should be), you will be warned each time you try to open a Web page that uses the control. For a complete explanation of code signing and safe scripting, stay tuned to this magazine.                                                                            </p>

<p><b>Figure 10: Default.htm</b></p>
<p><img src="scribble_10.gif"></p>
</font></BODY>
</HTML>
