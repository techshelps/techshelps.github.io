<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Collection Classes: Safety Wrappers for VBA Collection Objects</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<font face="verdana,arial,helvetica" size="2">

<h1>Collection Classes: Safety Wrappers for VBA Collection Objects</h1>
<p>
<i>By Ken Getz and Mike Gilbert</i></p>
<p>
Sooner or later you'll need to manage a group of custom objects created with VBA class modules, and the VBA <b>Collection</b> object is the perfect vehicle for doing this. We introduced <b>Collection</b>s in the Premiere issue of this magazine, and demonstrated how to use the <b>Collection</b><i> </i>object to store other objects. And while this technique is useful, it does have some limitations. In this article, we'll discuss those limitations, and show you how to overcome them by using - you guessed it - class modules.</p>
<h2>The Trouble with Collections</h2>
<p>
So, what's the problem with the <b>Collection</b> object? It seems to store objects very well. In fact, it works a bit too well. The biggest problem with the <b>Collection</b> object is that it can store references to any data type, e.g. <b>Integer</b>, <b>String</b>, <b>Long</b>, <b>Variant</b>, etc. (see FIGURE 1). </p>
<p>
Of course, it is much simpler to manipulate objects in a <b>Collection</b> if you can count on each object being of the same type and having the same properties and methods. For example, as part of this month's sample Excel VBA project, we created a custom <b>File</b> class to represent a disk file. The <b>File</b> class has several properties, including <b>Path</b>, <b>Size</b>, and <b>ShortName</b>. If you created a <b>Collection</b> of <b>File</b> objects, you would expect every object in the <b>Collection</b> to have those properties. And you could use code like this with no fear of adverse consequences:</p>
<pre><code>' Print the size of the first file in the Collection.
Debug.Print colFiles.Item(1).Size</code></pre>
<p>
But what happens if the first object in the <i>colFiles</i> <b>Collection</b> isn't a <b>File</b>? What if it's a <b>Form</b> or <b>Control</b> object? What if it isn't an object at all? What if it's an Integer? VBA will, of course, generate a run-time error when it attempts to execute the code. </p>
<p><img src="mg_fig01.gif"></p>
<p>
<b>FIGURE 1 <i>(on the left)</i>: The VBA </b>Collection<b> object can accommodate any type of object.</b></p>
<p>
<b>FIGURE 2 <i>(on the right)</i>: Creating a Collection class guards against unwanted objects in the collection.</b></p>
<h2>Enter the Collection Class </h2>
<p>
A <i>Collection class </i>acts as a filter for the <b>Collection</b> object, restricting the type of object you can store in it (see FIGURE 2). By interacting with the Collection class in your application, rather than the <b>Collection</b> object itself, you guard against objects that don't fit your expectations. Creating and using Collection classes allows you to extend the properties and methods of the <b>Collection</b> object. (We'll demonstrate an example of this later.)</p>
<p>
To illustrate a Collection class, as well as how to create one, we'll use an Excel 97 project with a collection of files created by scanning a disk directory. FIGURE 3 shows a form that populates the list box with file information stored in a custom Collection class after you select a path.</p>
<p>
The form uses a Collection class called <b>Files</b> to populate the list box. When creating a Collection class, begin by adding a new class module to your VBA project, then declare a <b>Private</b> <b>Collection</b> object in the new module's declaration section. Here's the declaration from the <b>Files</b> class module:</p>
<pre><code>' Collection of files.
Private pcolFiles As New Collection</code></pre>
<p>
You must declare the <b>Collection</b> object as <b>Private</b> to "insulate" it from the outside world and prevent the rest of your program from filling it with garbage.</p>
<h2>Replicate the Required Methods</h2>
<p>
Of course, once you've declared the <b>Collection</b> object as <b>Private</b>, there's no way for <i>any </i>process to add or remove items from it. Therefore, the next step is to replicate the standard methods of the <b>Collection</b> object. While this might sound like a lot of extra work, it's also where the "filtering" we mentioned earlier comes in.</p>
<p>
Remember the built-in <b>Collection</b> object has an <b>Add</b> method that accepts an object reference and a unique, alphanumeric identifier. If your application was using a <b>Collection</b> object directly, it would likely create a new instance of an object and add it to the <b>Collection</b> itself:</p>
<pre><code>' Create a new instance of an object.
Dim objFile As New File
objFile.Path = "C:\AUTOEXEC.BAT"

' Add to a Collection object.
colFiles.Add objFile, objFile.ShortName</code></pre>
<p>
With a Collection class, the application calls the <b>Add</b> method of the class, passing any required information. Contrast the previous code with the <b>Add</b> method of the <b>Files</b> class:</p>
<pre><code>Public Function Add(Path As String) As File

Dim objFile As File

  ' Create the new File object.
  Set objFile = New File
  objFile.Path = Path

  ' Add it to the Private collection.
  pcolFiles.Add objFile, objFile.ShortName

  ' Return a pointer to the new object.
  Set Add = objFile

End Function</code></pre>
<p>
In this example, the object creation and addition to the <b>Collection</b> takes place <i>inside </i>the<i> </i><b>Add</b><i> </i>method; and the class retains complete control. Any required information, such as the file's path, is supplied as an argument to the method. The code called by the application to add a file to the <b>Collection</b> can then be simplified to:</p>
<pre><code>' Add a file to the collection.
colFiles.Add "C:\AUTOEXEC.BAT"</code></pre>
<p>
In addition to the <b>Add</b> method, the Collection class should also implement the <b>Item</b> and <b>Remove</b> methods, as well as a <b>Count</b> property:</p>
<pre><code>Public Function Item(Key As Variant) As File
  ' Return an item in the collection.
  Set Item = pcolFiles.Item(Key)
End Function

Public Sub Remove(Key As Variant)
  ' Remove an item from the collection.
  pcolFiles.Remove Key
End Sub

Property Get Count() As Long
  ' Return the number of items.
  Count = pcolFiles.Count
End Property</code></pre>
<p>
Note that we've omitted error handling in these methods - something you should <i>never</i> do! Always include an error handler that, at a minimum, passes errors to the calling procedure by using the <b>Raise</b> method of the <b>Err</b> object.</p>
<p><img src="mg_fig03.gif">
</p>
<p>
<b>FIGURE 3: This form illustrates a Collection class by displaying file information.</b></p>
<pre><code>' Private variable to store path.
Private pstrPath As String

Property Get Path() As String
  ' Return stored path value.
  Path = pstrPath
End Property

Property Let Path(strPath As String)

Dim strFile As String
  
  ' Clear the collection.
  Set pcolFiles = New Collection

  ' Make sure there's a backslash.
  If Right(strPath, 1) &lt;&gt; "\" Then
    strPath = strPath &amp; "\"
  End If

  ' Get the first file.
  strFile = Dir(strPath &amp; "*.*", _
    vbReadOnly Or vbHidden Or vbArchive Or vbSystem)
  Do Until Len(strFile) = 0
    ' Add it to the collection.
    Call Add(strPath &amp; strFile)  
    ' Get the next file.
    strFile = Dir()
  Loop
  
  ' Save the path.
  pstrPath = strPath

End Property</code></pre>
<p>
<b>FIGURE 4: A </b>Path<b> property is added to the Collection class. Set this property and the class scans the directory and adds each file it finds to the private </b>Collection<b> object. </b></p>
<h2>Extending Collection Classes</h2>
<p>
At this point, you could now use the <b>Files</b> class by declaring an instance of it and repeatedly calling its <b>Add</b> method, once for each file found by the <b>Dir</b> function. But that's not what our example does. Why not? One of the advantages of using a Collection class is that you can extend its functionality by adding more properties and methods; you're not limited to <b>Add</b>, <b>Remove</b>, <b>Item</b>, and <b>Count</b>.</p>
<p>
In the case of our <b>Files</b> class, doesn't it make more sense to put the code that scans a directory inside the class itself, rather than in each application that uses the class? That's one of the guiding principles of object-oriented design: put the code closest to where it's needed.</p>
<p>
To illustrate this concept, we added a <b>Path</b> property to the Collection class. When you set this property, the class scans the directory and adds each file it finds to the private <b>Collection</b> object (see FIGURE 4).</p>
<p>
The <b>Property</b> <b>Let</b> procedure is triggered when a process changes the <b>Path</b> property of the class. In our example, this happens after you select a path from the browse dialog box. Here's the simple code that accomplishes the task of filling the <b>Collection</b> with a list of files:</p>
<pre><code>' Reinitialize the collection.
Set mobjFiles = New Files

' Set the path property.
mobjFiles.Path = strPath</code></pre>
<p>
That's all there is to it! Once the <b>Path</b> property is set, the <b>Files</b> class populates its own <b>Collection</b> and makes it available to the application. This is yet another example where the "guts" of the process lies within the class itself. (You could argue that the class no longer needs its <b>Add</b> and <b>Remove</b> methods. In some applications this could well be true, but we've chosen to leave them as part of the class for illustrative purposes.)</p>
<h2>Some Drawbacks</h2>
<p>
Life with VBA Collection classes isn't all wine and roses. There are two things that you give up when using a Collection class instead of the <b>Collection</b> object. The first is the <b>Collection</b> object's default method, <b>Item</b>. A default method allows you to omit the word "Item" from your code. For example, the following two statements are identical, assuming <i>colFiles</i> refers to a <b>Collection</b> object:</p>
<pre><code>Debug.Print colFiles.Item(1).Size
Debug.Print colFiles(1).Size</code></pre>
<p>
Unless you're using Visual Basic 5.0, there is no way to designate a method as the default method for a class. Therefore, you must always call the <b>Item</b> method explicitly.</p>
<p>
The second major drawback to Collection classes is that you cannot create an <b>enumeration</b><i> </i>function. An <b>enumeration</b> class is what makes <b>For Each </b>loops work. If you want to iterate through every item in the <b>Collection</b> you must do it the old fashioned way, using the <b>Count</b> property and a <b>For Next </b>loop. For example, this code populates the list box:</p>
<pre><code>' Fill the list box with info.
lstFiles.Clear
For lngCount = 1 To mobjFiles.Count
  With mobjFiles.Item(lngCount)
    lstFiles.AddItem .ShortName &amp; _
      Space(12 - Len(.ShortName)) &amp; _
      vbTab &amp; .AttributeString &amp; _
      vbTab &amp; .Size
  End With
Next</code></pre>
<p>
Note how the procedure uses the counter variable, <i>lngCount</i>, to loop from 1 to the number of items in the <b>Collection</b>. The <b>With</b> statement uses the <b>Item</b> method to reference each object in the <b>Collection</b>.</p>
<p>
Note that Visual Basic 5.0 users can overcome this limitation by creating an <b>enumeration</b> function. Search for the keyword "enumeration" in Visual Basic Books Online for more information.</p>
<h2>This <i>Will</i> Be on the Exam</h2>
<p>
Collection classes are extremely versatile. Not only do they protect your delicate <b>Collection</b>s (especially important when they'll be used by others), but by adding additional properties and methods you can create extremely functional classes. In future issues, we'll show you more examples of using Collection classes. Stay tuned!</p>
<p>
The files referenced in this article are available for download from the Informant Web site at http://www.informant.com/mod/modnewupl.htm. <i>File name: MOD9711MG.ZIP.</i></p>
<p>
<i>Ken Getz and Mike Gilbert are Senior Consultants with MCW Technologies, a Microsoft Solution Provider focusing on Visual Basic and the Office and BackOffice suites. They've recently completed VBA Developer's Handbook and Access 97 Developer's Handbook (co-authored with Paul Litwin), both for SYBEX.</i></p>
</font></BODY>
</HTML>
