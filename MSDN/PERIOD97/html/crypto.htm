<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Supporting CryptoAPI in Real-World Applications</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<font face="verdana,arial,helvetica" size="2"><form name=x><object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object></form>
<h1>Supporting CryptoAPI in Real-World Applications</h1>
<p>
The increasing volume of Internet traffic moving valuable messages, documents, and payments over potentially insecure media creates a need for an efficient protection mechanism. When talking about security in networking environments, you're addressing a couple of nontrivial topics: encryption and authentication. If you want to keep your data far from ill-intentioned eyes, you have to scramble and camouflage it using special two-way techniques that allow you to encrypt and decrypt with reasonable overhead and a high level of protection. If you want to exchange messages, you need verifiable authentication certificates that guarantee someone's identity.</p>
<p>
The techniques that let you add privacy, integrity, and authentication to your code and data are globally known as cryptography. In the Windows® environment there is a set of functions translating this theoretical model into concrete programming calls: CryptoAPI.</p>
<p>
Microsoft has released version 1.01 of the CryptoAPI -SDK, while a newer version that exposes COM interfaces is available in beta test. In this article, I'll show you how to use cryptography in real-world applications. First, I'll explain the CryptoAPI architecture and its programming model, then I'll take a close look at the API itself. The final goal will be the construction of a new MFC document base class from which you can derive your own classes with the built-in and transparent capability of encrypting and decrypting data. The resulting application will be an enhanced version of Notepad that demonstrates how you can also implement CryptoAPI in desktop and standalone applications.</p>
<h3>The CryptoAPI Theoretical Model</h3>
<p>
Regardless of the technique you use to scramble the bytes of your files, what you want to save or send remains the same. The encryption engine is a separate, algorithm-independent module that plugs into your program and places itself between the data and the storage media. This engine encrypts the data before saving it and decrypts the data before returning it to the requester. Data is authenticated by digital signatures that are just a handful of bytes added to the data or message. Consequently, cryptography is the way to achieve privacy and certification at the same time, without losing <br>
data integrity. </p>
<p>
Figure 1 shows a how an application may take advantage of cryptography to protect and sign its own documents. Any encryption mechanism is formed by a set of rules for changing the value of data in such a way that it will be easy to recover the original content later. These rules transform the source with respect to a digital ID called an encryption key. To decode any previously encoded file you need a decryption key. Privacy relies on the ability to keep the keys secret. </p>
<p><img src="cryptofig01.gif"></p>
<h3>The CryptoAPI Architecture</h3>
<p>
Figure 2 presents a simplified view of the CryptoAPI system architecture. The abstract engine in Figure 1 is implemented by the functions defined in the header file wincrypt.h and exported by advapi32.dll. These functions allow you to encrypt and decrypt files as well as store and verify digital certificates from documents. (The functions for verifying certificates and creating/parsing messages live in crypt32.dll.) The good news is that your application doesn't need to worry about encryption algorithms, private or public keys, and other low-level details. Encrypting a file is not much harder than drawing a bitmap inside a window. </p>
<p><img src="cryptofig02.gif"></p>
<p>
CryptoAPI provides an abstraction layer that isolates you from the algorithm used to protect the data. An application will refer to contexts and keys and make calls to special functions that act as drivers for the encryption servers installed on the machine. These servers are called Cryptographic Service Providers (CSP) and are the modules that do the dirty work of encoding and decoding data.</p>
<p>
Figure 3 offers a more complex and complete perspective of the three-tiered CryptoAPI programming model. An <br>
application makes calls to simplified cryptographic functions or certificate store routines that delegate to base services. Neither the application nor the simplified functions should directly access any available CSPs. </p>
<p><img src="cryptofig03.gif"></p>
<p>
The CryptoAPI interface to the application is composed of three classes of functionality: simplified cryptographic functions, certificate functions, and low-level services. Understanding the simplified cryptographic functions is the first step towards becoming familiar with the API. They include high-level functions for creating and using keys and for encrypting and decrypting information. The certificate functions provide the means to extract, store, and verify the certificates enclosed with documents and to enumerate the ones saved to the machine. </p>
<p>
At a lower programming level, there <br>
are other functions whose arguments require a specific CSP. Unless it is critical to your application, you should not access CSPs directly, and you should also avoid using features that are particular to a given <br>
provider. There may be applications that need their own CSP for one of a number of reasons, one of which might be special security concerns.</p>
<h3>The Crypto Service Providers</h3>
<p>
A typical CSP is composed of a DLL and a signature file that CryptoAPI uses to periodically verify the integrity and identity of the provider itself. Sometimes a CSP may implement some of its functionalities in hardware to prevent tampering or to improve performance. Put another way, a CSP is a server able to perform a standard set of tasks invoked by the system via CryptoAPI functions. An application should not make assumptions about CSP capabilities that exceed the known standard. A CSP is just a removable plug-in module. The role played by a CSP makes it very similar to Windows drivers implementing print or graphic functions. Once you have registered the CSP, you may start using it without changing anything at the application level.</p>
<p>
To ensure privacy, all the data a CSP manipulates (especially keys) is returned to the caller as opaque handles and remains inaccessible at the application level. Moreover, programs cannot affect the way the data is actually encoded. A program must limit itself to passing in the data and specifying the type of the encryption required. A provider can always return a type that explains what and how it is able to do. Different providers may use the same algorithms but adopt different logic for padding and different key sizes.</p>
<p>
Figure 4 shows the list of defined provider types with the algorithms they use for encryption and authentication. Bundled with the CryptoAPI SDK is a default CSP, called Microsoft RSA Base Provider, implemented in rsabase.dll. It's a PROV_RSA_FULL type provider supporting the RSA public-key algorithm <br>
for both key exchange and signatures. (The key is 512 bits long.) It also uses RC2 and RC4 cipher algorithms for encryption with a 40-bit key. Applications should not rely on these lengths for a particular implementation because CSPs <br>
can be swapped in without the application's knowledge.</p>
<p><img src="cryptofig04.gif"></p>
<p>
Each CSP is associated with a database of key containers that stores all the private and public keys for the users accessing that computer (see Figure 5). Each container has a unique name that is the key to the CryptoAPI programming world. If this database doesn't exist, <br>
all CryptoAPI functions will fail. It's common to have a default key container with the logon name of each user. <br>
An application, however, may create a custom key container and key pairs during installation, assigning them its own name. Since the type of the provider affects the behavior of the cryptographic functions, two connected applications should use the same CSP, or at least CSPs with a common subset of functions.</p>
<p><img src="cryptofig05.gif"></p>
<h3>The CryptoAPI Programming Model</h3>
<p>
However, before adding cryptography to real-world applications, you must become familiar with terms such as context, session keys, exchange keys, and signature keys. A context represents a session that's been established between CryptoAPI and the client application. To begin, you need to acquire a context. In doing so, you pass in the name of the key container you need and the name of the provider to which you want to connect. The handle you obtain must be used in all subsequent calls to the CryptoAPI routines.</p>
<p>
A session key comes into play when it's time to encrypt or decrypt data. Session keys are volatile objects whose actual bytes never leave the CSP for reasons of privacy and security. The session key determines how a file is encrypted and must be inserted in a ciphered file to allow decryption. If you need to bring a session key out of the CSP for exchange or storage purposes, you need key blobs. A key blob is a binary chunk of data and may be considered an encrypted and exportable version of the key itself.</p>
<p>
The safekeeping mechanism is completed with exchange keys. They are key pairs (one public and one private) that take care of encrypting the session keys inside the key blobs and handling the digital signatures. A session key is created dynamically from the information stored in the user's key container (see Figure 5). Once you have a session key, you <br>
are ready to make the calls that will scramble the bytes of <br>
the file. </p>
<p>
Supporting cryptography in your applications doesn't require you to be familiar with details of RSA or DES algorithm, or subtle concepts such as public and private keys.</p>
<h2>Getting Started with CryptoAPI</h2>
<p>
At the moment, the CryptoAPI functions are supported only in Windows NT® 4.0 and the OSR 2 release of Windows 95. However, chances are you can also use them under a previous copy of Windows 95. (If you've never upgraded either to Windows NT 4.0 or the most recent Windows 95 service packs, installing Internet Explorer 3.0 puts the CryptoAPI-enabled version of advapi32.dll on your machine.)</p>
<p>
Once you have the engine, you still need the means for exploiting its power. Releases of Microsoft Visual C++® starting with version 4.2 come with updated versions of the files that let you access CryptoAPI successfully. These files are advapi32.lib, wincrypt.h, and winerror.h. But this isn't enough because the wincrypt.h contains a preprocessor directive </p>
<pre><code>#if( _WIN32_WINNT &gt;= 0x0400 )</code></pre>
<p>
that keeps all the definitions from inclusion into your compiled code if your machine isn't running Windows NT 4.0. You have two options: remove the directive from wincrypt.h or install Windows NT 4.0. I also tried to compile using <br>
Visual C++ 4.1-if you replace the three files listed above, you'll hit the target and get your first CryptoAPI program compiled.</p>
<p>
The work of making your system ready for CryptoAPI doesn't end here. If you download all the samples from the security directory on the Microsoft Site Builder Network (http://www.microsoft.com/intdev/security), you'll notice that before running any of them you should launch InitUser.exe. This program creates and initializes a <br>
key database like the one in Figure 5. InitUser.exe attempts to get a handle to the default container. If such a container doesn't exist, then the program creates it. The new container will include a single user, which is assigned the name of the current user. The next step consists of creating and storing a signature key and an exchange key.</p>
<p>
When all of this has been done, you are finally ready to execute a significant CryptoAPI application. InitUser.exe is just a way to initialize your cryptographic system. Any application can achieve the same result by including the proper code, although this practice is discouraged.</p>
<h2>An Overview of the Functions</h2>
<p>
CryptoAPI is divided into three functional categories: simplified cryptographic functions, certificate functions, and base services. The simplified routines, most of which are listed in Figure 6, encapsulate things such as contexts and session keys behind a higher-level interface. It's not surprising that the simple CryptoAPI functions are eclectic and not very flexible; <br>
they do exactly what their names suggest and do it in a <br>
default way. </p>
<p><img src="cryptofig06.gif"></p>
<p>
The basic routines (see Figure 7) cover four main areas: CSP, keys, hash objects, and signatures. Let's start with CSP. The first function you call in a typical CryptoAPI application is CryptAcquireContext, which provides a handle to the specified provider as a returned argument.</p>
<pre><code>BOOL CryptAcquireContext( 
HCRYPTPROV *phProv,
    LPCTSTR pszContainer,
    LPCTSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags );</code></pre>
<p><img src="cryptofig07.gif"></p>
<p>
The returned HCRYPTPROV handle is proof that a working session was established between the application and the CSP. You may specify a particular CSP to which you want to connect, as well as the key container you want to access. You do this through the pszProvider and pszContainer arguments. You may restrict your query by indicating what type the provider should be. Feasible values for dwProvType are listed in Figure 4. The function first attempts to locate a provider with the given name and characteristics. If it's successful, the function will then search for a pszContainer key container in that CSP. The dwFlags parameter allows you to create a new key container or delete an existing one. The handle obtained should be released via CryptReleaseContext.</p>
<p>
Here's how to call CryptAcquireContext:</p>
<pre><code>HCRYPTPROV hProv=NULL;
CryptAcquireContext( &amp;hProv, NULL, 
    NULL, PROV_RSA_FULL, 0 );</code></pre>
<p>
This call, where both pszContainer and pszProvider are set to NULL, will connect your application to the default provider and the default key container. The function CryptSetProvider allows you to change this default, but it's considered a bad programming strategy.</p>
<p>
None of the functions dealing with CSP (except for CryptAcquireContext) should be used at the application level; they must be called only from within system-level and administrative tools. CryptAcquireContext gives you a handle to an encryption provider. You can use this handle to create or derive keys.</p>
<p>
There are two methods for generating session keys: using a random seed through CryptGenKey or using a hash method via CryptDeriveKey. CryptGenKey requires four parameters as shown below:</p>
<pre><code>BOOL CryptGenKey( 
HCRYPTPROV hProv,
    ALG_ID algid,
    DWORD dwFlags,
    HCRYPTKEY* phKey );</code></pre>
<p>
The first is a handle to the selected CSP, while the last is a buffer that will contain a valid key handle. The algid argument specifies a value identifying the algorithm to be used for creating the key. The algorithms available depend upon the provider's capabilities. The Microsoft RSA Base Provider offers two possible choices: CALG_RC4 and CALG_RC2. The key may or may not be exportable. </p>
<p>
As I mentioned earlier, a session key is a volatile object unless you assign it the CRYPT_EXPORTABLE attribute. This flag allows the key to originate a key blob-nothing more than a nonvolatile and encrypted version of the key. Often a key blob is attached to a message or file.</p>
<p>
Exporting a key is a two-step process that involves another special object, the exchange key. The first step consists of asking the CSP for the user's public key viaCryptGetUserKey. Once you've got an exchange key handle, you are ready to get a key blob. The following does just that:</p>
<pre><code>HCRYPTKEY hXKey=NULL;
LPBYTE pBuf=NULL;
CryptGetUserKey( hProv, AT_KEYEXCHANGE, &amp;hXKey );
CryptExportKey( hKey, hXKey, SIMPLEBLOB, 0, NULL, &amp;dwSize);
pBuf = (LPBYTE) malloc(dwSize)
CryptExportKey( hKey, hXKey, SIMPLEBLOB, 0, pBuf, &amp;dwSize);</code></pre>
<p>
The function CryptExportKey returns the key blob, which is stored in the pBuf buffer. When the pBuf argument is NULL, the same function will instead return the amount of required memory. To decode a key blob and finally decipher the document, the destination user calls CreateImportKey, passing in the key blob and receiving an HCRYPTKEY handle.</p>
<p>
A session key may also be generated through hashing. You just need to provide a stream of data to work on, and you get back a previously initialized hash object. The functions involved are CryptCreateHash (whose purpose is creating a hash object), CryptHashData (which hashes in the given data), and CryptDeriveKey (which generates an HCRYPTKEY handle from the hash object).</p>
<pre><code>CryptCreateHash( hProv, CALG_MD5, 0, 0, &amp;hHash );
CryptHashData( hHash, szData, lstrlen(szData) );
CryptDeriveKey( hProv, CALG_RC4, hHash, 0, &amp;hKey );</code></pre>
<p>
The szData parameter represents the string whose content is hashed using an MD5 hash algorithm. Typically, szData will be a password. All the objects created have destructors that must be called when finished.</p>
<p>
Up to this point, I've talked mostly about encryption and disregarded the signature topic. If you want to add a digital signature to your document, then take into account the CryptoAPI hash functions. To sign and verify documents, you should create a hash object, hash the content (exactly as described previously for passwords), and call CryptSignHash.</p>
<pre><code>CryptCreateHash( hProv, CALG_MD5, 0, 0, &amp;hHash );
CryptHashData( hHash, szDocContent, sizeOfDoc );
CryptSignHash( hHash, AT_SIGNATURE, szDesc, 0, NULL, &amp;dwSize );
pBuf = (LPBYTE) malloc( dwSize )
CryptSignHash( hHash, AT_SIGNATURE, szDesc, 0, pBuf, &amp;dwSize );</code></pre>
<p>
In this example, pBuf contains the signature information that will typically end up in a separate file, while szDesc is a description string. Both concur with the authentication process governed by CryptVerifySignature. In addition, this function requires a hashed version of the source file and the public signature key used to sign the file. This key is returned by CryptGetUserKey with the AT_SIGNATURE flag.</p>
<h2>Putting it All Together</h2>
<p>
You can download some useful code from the Microsoft Site Builder Network Web site (http://www.microsoft.com/sitebuilder). You'll find clear samples of how to encrypt, decrypt, sign, and verify a single file. Cryptography can be used to protect any kind of data, and you can use CryptoAPI in any kind of desktop application. In other words, a simple MFC-based text editor, totally unaware of the Internet, can still exploit CryptoAPI to save its documents. Figure 8 shows a sample program called Crypto NotePad in action. The MFC AppWizard generated the skeleton, which I modified just to adopt a specialized CEditView view and a thinner font.</p>
<p><img src="cryptofig08.gif"></p>
<p>
The core of Crypto NotePad is inside its new CCryptoDoc document class. CCryptoDoc is derived from CDocument and overrides two methods: OnOpenDocument and&nbsp;<br>
OnSaveDocument. Consequently, the document class used by Crypto NotePad is derived from CCryptoDoc instead <br>
of CDocument.</p>
<p>
I started by creating a simple text editor, loading and saving ASCII files with a .ctx extension. I had to implement a customized version of both Serialize and DeleteContents methods. CEditView (as well as its sister class, CRichEditView) is an anomalous view class that wraps an edit control, actually becoming both view and document class. This means that to read or save a document you must call archive methods from within a view object instead of a document.</p>
<p>
When my text editor was working perfectly, I tried to enhance it by adding encryption. The idea was to encrypt the data before storing, and decrypt after loading. A document-based class uses serialization to load or save its data, but serialization is a procedure that must reside in the application document class because of its strict relation to the inner structure of the data. I wanted to keep encryption as transparent as possible for all the CCryptoDoc-derived classes. At the same time, I didn't want to change prototypes or force the application to use specific serialization schemas. My slogan was, derive from CCryptoDoc and have your program support CryptoAPI.Thus, the first step is compulsory: derive a CTextEditDoc class from a new CCryptoDoc class. </p>
<p>
The new class must work under the MFC document base class. CDocument implements two methods (OnOpenDocument and OnSaveDocument) that are invoked after a user chooses a file to open or to save. Figure 9 shows how the CCryptoDoc class modifies the standard behavior. Clicking on the Open button in the application's toolbar and selecting an existing file name results in a call to OnOpenDocument with the specified file name as an argument (the same happens for Save and Save As commands).</p>
<p><img src="cryptofig09.gif"></p>
<p>
The selected .ctx file is encrypted, so you must first decipher it for standard serialization. I chose to implement this by creating a temporary file somewhere on the machine (Crypto NotePad does it on the root directory of the C drive, but this is just one possible technique). The temp file is then passed to CDocument::OnOpenDocument to complete the operation.</p>
<p>
The same strategy is behind the storing procedure. Once you select a file name for the saved file, the class flushes the archive to disk using a temporary file name. The actual encryption is performed in a successive step, which will create a valid .ctx file. Figure 10 shows a dump of a .ctx file in the background, while Crypto NotePad shows the deciphered content in the foreground. </p>
<p><img src="cryptofig10.gif"></p>
<p>
The temporary file, used internally to encrypt and decrypt the data, was my first approach to the problem. I chose this method because it appeared much simpler (therefore, I could reuse some of the sample code). Once I knew Crypto NotePad worked, I started investigating alternate solutions. My conclusion is that if you want the high-level interface to the MFC applications to remain, you can't choose a different approach, primarily because of the file-based nature of the MFC serialization. CArchive and CFile appear to be good starting points for new attempts.</p>
<h3>Details of CCryptoDoc</h3>
<p>
Aside from the OnOpenDocument and OnSaveDocument mentioned previously,&nbsp;the CCryptoDoc class exports a third public method called OnSaveDocumentWithPswd. And there are three other protected members: DecryptFile, EncryptFile, and GetPassword. </p>
<p>
The Crypto NotePad program offers the expected menu items plus a Save With Password command and an Options menu with a checked item called Encryption. This lets you enable or disable the cryptographic power of your application simply by calling CCryptoDoc::EnableEncryption. If this functionality is not active, then the overriden methods just pass the control down to the base class.</p>
<p>
Conceptually, the EncryptFile function is similar to <br>
the one available from the ENCDEC sample on the Microsoft Web site. It takes the source file, the target file, and an optional password. If a password is specified, it is used to generate the encryption key-otherwise the key is given by CryptGenKey. </p>
<p>
Of course, an encrypted file must be decryptable, so you need to save the key somewhere. This is where the concept of a key blob finally comes into play. Once you determine the key, you make it exportable and store the key blob and its size at the beginning of the target file. With the Microsoft RSA Base Provider, the length of a key blob is 76 bytes. To make things easier, I decided to add a small header to .ctx files to denote whether they are encrypted with a password. The first four bytes are just a file ID (a LONG value) with magic values. Figure 11 explains the binary format of the .ctx file.</p>
<p><img src="cryptofig11.gif"></p>
<p>
If you save with a password, EncryptFile will create a hash object, encrypt the data, and then flush it to disk. While <br>
it's necessary to make a random key persistent, in theory there is no need to store the password with the file data. A password is just a word-though it might be a cryptic word-and can be transmitted or remembered. A key, on the other hand, is just a sequence of bits, which is much more difficult to keep in mind! For simplicity in the file format I chose, <br>
the password is encrypted via a trivial NOT operator rather than CryptoAPI.</p>
<p>
The member function GetPassword just examines the given file, returning the password, if any. DecryptFile loads the data from the source file with respect to the layouts shown in Figure 11. If a .ctx file is password-encrypted, then you need to check the password before decryption occurs. If you try to decipher with the wrong hash data, you'll simply obtain a pile of meaningless characters.</p>
<h2>Extending Existing Applications</h2>
<p>
Crypto NotePad demonstrates the power of the CCryptoDoc class, which encapsulates the capability of encrypting and decrypting data and makes it available to all derived classes.&nbsp;The cryptographic&nbsp;engine&nbsp;is implemented&nbsp;in CryptoDoc.cpp, PswdDlg.cpp, and their respective headers. In addition, the resource file contains a dialog template <br>
and some error strings for the user interface. When I built CCryptoDoc, I tried <br>
to make its new functionality transparent so existing applications could easily use it instead of CDocument.</p>
<p>
Figure 12 shows a well-known MFC application (Scribble, step 2) that uses cryptography. The window in the background shows the binary contents of the file scribb1.scb; in the foreground you have a view of the decrypted data. Figure 13 is a snapshot of Developer Studio with the updated Scribble project and some of the changes to the original code. I used a simplified version of CCryptoDoc class, without password support and user interface (these files are called CryptDoc.* instead of CryptoDoc.*).</p>
<p><img src="cryptofig12.gif"></p>
<p><img src="cryptofig13.gif"></p>
<p>
If you have an MFC application based on CDocument, you can add cryptography by doing the following:</p>
<p>
1. Add CryptDoc.cpp to your project.</p>
<p>
2. #include CryptDoc.h to your document class header.</p>
<p>
3. Derive your document class from CCryptoDoc instead of CDocument.</p>
<p>
4. Replace (with a grain of salt) all occurrences of CDocument in your sources.</p>
<p>
5. Rebuild the project.</p>
<p>
If you have an MFC application that uses documents <br>
from a specialized document class such as CRichEditDoc or COleServerDoc, then you should create a CCryptoOleDoc class and make it inherit from COleDocument. </p>
<h2>Summary</h2>
<p>
All the code shown in this article will <br>
fail under conditions different from those discussed earlier. Be sure you have the updated DLLs, and initialize your CryptoAPI engine with InitUser.exe. The specs recommend that you perform this kind of task offline; this is the reason I didn't implement it in my code. All this code is based on CryptoAPI 1.<i>x</i>. This version supports only encryption and digital signatures; for more sophisticated applications such as certificates-as well as COM interfaces you'll have to wait for an upcoming release.                          </p>
</font></BODY>
</HTML>
