<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Keyboard Class: From Windows API Chaos to VBA Class Module Calm </title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<Font face="verdana,arial,helvetica" size="2">


<h1><a name="keyboardclass"></a>Keyboard Class: From Windows API Chaos to VBA Class Module Calm</h1>
<p class=indent>
By Ken Getz</p>
<p>
Working with VBA, you grow accustomed to working with objects, and their inherent properties and methods. In fact, it becomes difficult — even painful — to program any other way. Unfortunately, there’s still plenty of functionality that’s available only the old-fashioned, non-object-oriented way. An outstanding example is that great sea of function calls, the Windows API. One of the appealing features of working with class modules is that you can wrap up such bodies of functionality into manageable objects with a set of public interfaces. That is, you can hide the details of an interrelated set of information, and present it as an object.</p>
<p>
For example, imagine you find the need, in some of your VBA projects, to interact with the user’s keyboard. You might want to speed up or slow down the cursor blink rate; find out how many function keys the user has; modify the keyboard repeat speed and the delay time before repeating; or perhaps retrieve and set the state of the toggle keys, i.e. n, c, and o. To do this requires working with the Windows API, and <i>that</i> requires declarations, external function calls, working with user-defined types and API-defined constants — all sorts of unpleasantness.</p>
<p>
Wouldn’t it be nice if you had a simple <b>Keyboard</b> object that supplied properties to perform all the work for you? Of course it would! And, as you’ve probably figured out, that’s where this article is headed. The Windows API provides a lot of information about the keyboard, but retrieving it requires calling a number of functions, so you have to know which functions to call, how to call them, what information they return, and more. This article presents a VBA <b>Keyboard</b> class, with the properties described in FIGURE 1. (One of the more inviting reasons to use class modules and the objects they create is that you can instantiate multiple objects from the same class. Although you’ll never create multiple instances of the <b>Keyboard</b> class in a single application, that’s no reason not to use a class module.)</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=blue width=104><b>Property</b></td>
<td class=blue width=168><b>Description</b></td>
<td class=blue width=108><b>Allowable Values</b></td>
<td class=blue width=78><b>Read/Write</b></td>
</tr>
<tr valign=top>
<td class=blue width=104>KeyboardType</td>
<td width=168>Determines the type (number of keys) of the keyboard.</td>
<td width=108>N/A</td>
<td width=78>R</td>
</tr>
<tr valign=top>
<td class=blue width=104>FunctionKeys</td>
<td width=168>Determines the number of function keys.</td>
<td width=108>N/A</td>
<td width=78>R</td>
</tr>
<tr valign=top>
<td class=blue width=104>CapsLock</td>
<td width=168>Retrieves or sets the state of the c toggle.</td>
<td width=108>True/False</td>
<td width=78>R/W</td>
</tr>
<tr valign=top>
<td class=blue width=104>NumLock</td>
<td width=168>Retrieves or sets the state of the n toggle.</td>
<td width=108>True/False</td>
<td width=78>R/W</td>
</tr>
<tr valign=top>
<td class=blue width=104>ScrollLock</td>
<td width=168>Retrieves or sets the state of the o toggle.</td>
<td width=108>True/False</td>
<td width=78>R/W</td>
</tr>
<tr valign=top>
<td class=blue width=104>Delay</td>
<td width=168>Retrieves or sets the keyboard repeat-delay setting.</td>
<td width=108>0-3</td>
<td width=78>R/W</td>
</tr>
<tr valign=top>
<td class=blue width=104>Speed</td>
<td width=168>Retrieves or sets the keyboard repeat speed.</td>
<td width=108>0-31</td>
<td width=78>R/W</td>
</tr>
<tr valign=top>
<td class=blue width=104>CaretBlinkTime</td>
<td width=168>Retrieves or sets the number of milliseconds between blinks of the insertion caret.</td>
<td width=108>200-1200 (generally in increments of 100)</td>
<td width=78>R/W</td>
</tr>
</table><br>
<p>
<b>FIGURE 1: Properties provided by the </b>Keyboard<b> class.</b></p>
<p>
To try out Keyboard.cls (you’ll find the code later in this article, and it’s available for download — see the end of the article for details), you’ll need to first create a class module named <b>Keyboard</b>, then get the code into your project. Once you’ve got the <b>Keyboard</b> class module in your project, you can use it like any other class. For example, to use the <b>Keyboard</b> class, create a new instance of the class, then set or retrieve its available properties. To retrieve and set the current keyboard delay setting, for example, you could use code like this:</p>
<pre><code>Dim okb As Keyboard

Set okb = New Keyboard
If okb.Delay &lt; 3 Then
  okb.Delay = okb.Delay + 1
End If</code></pre>
<p>
Certainly a lot easier than calling a bunch of Windows API functions directly!</p>
<h3>Doing It the Hard Way</h3>
<p>
To do its work, the <b>Keyboard</b> class makes calls to the Windows API. This section of the article delves into the specific API calls. If you’re not interested, just skip to the next section, “Don’t Sweat the Details,” which describes how to use the class.</p>
<p>
<b>Keyboard type. </b>Retrieving the type of keyboard and the number of function keys is simple. Call the <b>GetKeyboardType</b> API function, passing it a value of 0 to obtain the keyboard type, or 2 to get the number of function keys. The function returns keyboard types as shown in FIGURE 2, and the number of function keys as shown in FIGURE 3.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=68><b>Value</b></td>
<td class=blue width=192><b>Keyboard Type</b></td>
</tr>
<tr valign=top>
<td width=68>1</td>
<td width=192>IBM PC/XT or compatible (83-key) </td>
</tr>
<tr valign=top>
<td width=68>2</td>
<td width=192>Olivetti “ICO” (102-key) </td>
</tr>
<tr valign=top>
<td width=68>3</td>
<td width=192>IBM PC/AT (84-key) or similar </td>
</tr>
<tr valign=top>
<td width=68>4</td>
<td width=192>IBM enhanced (101- or 102-key) </td>
</tr>
<tr valign=top>
<td width=68>5</td>
<td width=192>Nokia 1050 and similar </td>
</tr>
<tr valign=top>
<td width=68>6</td>
<td width=192>Nokia 9140 and similar </td>
</tr>
<tr valign=top>
<td width=68>7</td>
<td width=192>Japanese </td>
</tr>
</table><br>
<p>
<b>FIGURE 2: Keyboard type return values for </b>GetKeyboardType<b>.</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=62><b>Value</b></td>
<td class=blue width=210><b>Number of Function Keys</b></td>
</tr>
<tr valign=top>
<td width=62>1</td>
<td width=210>10</td>
</tr>
<tr valign=top>
<td width=62>2</td>
<td width=210>12 (sometimes 18)</td>
</tr>
<tr valign=top>
<td width=62>3</td>
<td width=210>10</td>
</tr>
<tr valign=top>
<td width=62>4</td>
<td width=210>12</td>
</tr>
<tr valign=top>
<td width=62>5</td>
<td width=210>10</td>
</tr>
<tr valign=top>
<td width=62>6</td>
<td width=210>24</td>
</tr>
<tr valign=top>
<td width=62>7</td>
<td width=210>Hardware dependent; specified by the OEM</td>
</tr>
</table><br>
<p>
<b>FIGURE 3. Function key return values for </b>GetKeyboardType<b>.</b></p>
<p>
Of course, to use these functions, the class module requires the API function’s declaration, so it must include the following line of code in its Declarations section:</p>
<pre><code>Private Declare Function GetKeyboardType Lib "User32" _
  (ByVal lngTypeFlag As Long) As Long</code></pre>
<p>
To retrieve the keyboard type, or number of function keys (as just described), the <b>Keyboard</b> class module contains the following procedures:</p>
<pre><code>Property Get KeyboardType() As Long
  KeyboardType = GetKeyboardType(0)
End Property

Property Get FunctionKeys() As Long
  FunctionKeys = GetKeyboardType(2)
End Property</code></pre>
<p>
Keyboard toggles. To set a keyboard toggle, you must use the GetKeyboardState and SetKeyboardState API functions. To retrieve the current state of a toggle key, use the GetKeyState API function. These require the following declarations:</p>
<pre><code>Private Declare Function GetKeyState Lib "User32" _
  (ByVal lngVirtKey As Long) As Integer
Private Declare Function GetKeyboardState Lib "User32" _
  (bytKeyState As Byte) As Long
Private Declare Function SetKeyboardState Lib "User32" _</code></pre>
<p>
&nbsp;&nbsp;(bytKeyState As Byte) As Long</p>
<p>
To retrieve the state of a key, call <b>GetKeyState</b>, passing in the Windows virtual key code for the keyboard key. Luckily, VBA provides constants for n and c (<b>vbKeyNumlock</b> and <b>vbKeyCapital</b>). However, not all implementations of VBA provide a similar key constant for o, so you may need to define the constant yourself:</p>
<pre><code>Private Const vbKeyScrollLock = 145</code></pre>
<p>
The <b>GetKeyState</b> function returns an integer containing information about the key you’ve sent it, but the only piece of that information you need is the lowest bit. To retrieve only the lowest bit, use the <b>And</b> operator and the value 1 to strip off all the information except the lowest bit.</p>
<p>
(For the bit-confused: In binary, the value 1 consists of a bunch of 0’s followed by a lonely 1. Each of these digits is called a “bit.” The <b>And</b> operator takes each bit of its two operands, and unless the bits in the same position from both operands are 1, the result is a 0 bit. If they were both 1, the result is a 1 bit. That way, by using <b>And</b> 1 with the return value, all the bits except the least significant bit are guaranteed to be 0 in the output. The final bit will either be 1 or 0 in the output, depending on its value in the return value from <b>GetKeyState</b>. That didn’t help? It’s OK — you can get by for a long time in VBA not digging too deep into bitwise arithmetic. You can also find plenty of help by searching on “And operator” in the online help in the VBA IDE. Or, search using “Logical Operators” to learn about the entire family of logical operators.)</p>
<p>
To find out whether the o toggle is set, the <b>Keyboard</b> class module uses the following property procedure:</p>
<pre><code>Property Get ScrollLock() As Boolean
  ' Return the ScrollLock toggle.
  ScrollLock = CBool(GetKeyState(vbKeyScrollLock) And 1)
End Property</code></pre>
<p>
You’ll find similar procedures to retrieve the state of the n and c toggles.</p>
<p>
Setting the state of the toggle requires a bit more effort; you must follow these steps:</p>
<p>
Call an API function (<b>GetKeyboardState</b>) to retrieve the current state of the entire keyboard as a series of bytes (one byte per key).</p>
<p>
Change the state of the key (or keys) that interests you within the array of bytes.</p>
<p>
Call an API function (<b>SetKeyboardState</b>), sending the modified array of bytes. This sets the state of the entire keyboard.</p>
<p>
For each of the <b>GetKeyboardState</b> or <b>SetKeyboardState</b> functions, pass the first element of an array of 256 bytes to the API function. The function either fills the 256 elements of the array with information about the keyboard, or uses the bytes to set the state of the keyboard. The <b>Keyboard</b> class includes the following private procedure, which does all the work:</p>
<pre><code>Private Sub SetKeyState(intKey As Integer, _
                        fTurnOn As Boolean)
  ' Retrieve the keyboard state, set the particular key in
  ' which you're interested; then set the entire keyboard
  ' state back the way it was, with the one key altered.
  Dim abytBuffer(0 To 255) As Byte

  Call GetKeyboardState(abytBuffer(0))
  abytBuffer(intKey) = CByte(Abs(fTurnOn))
  Call SetKeyboardState(abytBuffer(0))
End Sub</code></pre>
<p>
Code within the class module calls this procedure (passing key constants for n, c, and o). The <b>SetKeyState</b> procedure follows the steps listed previously to do its work. For example, the <b>Property Let </b>procedure, <b>ScrollLock</b>, looks like this:</p>
<pre><code>Property Let ScrollLock(Value As Boolean)
  ' Set the ScrollLock toggle.
  Call SetKeyState(vbKeyScrollLock, Value)
End Property</code></pre>
<p>
Repeat delay and speed. Setting the keyboard repeat speed, and the number of milliseconds the keyboard waits before starting to repeat keys, is not terribly difficult. These tasks require calling the SystemParametersInfo function, requesting the necessary information, or setting the values. SystemParametersInfo is a “grab bag” function; it can do many things, and you indicate what you want it to do by passing it a constant. For example, to set the keyboard delay to 3, you could make the following call to SystemParametersInfo:</p>
<pre><code>Call SystemParametersInfo(SPI_SETKEYBOARDDELAY, _
                          3, 0, SPIF_TELLALL)</code></pre>
<p>
In this case, the third parameter isn’t used, so leave it as 0. The fourth parameter is a constant defined in the class module, telling <b>SystemParametersInfo</b> to update both the appropriate .ini file and the Windows registry. The constants also instruct <b>SystemParametersInfo</b> to send a message to all the running Windows applications, telling them you’ve changed a setting. Setting the repeat speed is the same, except a different constant is used.</p>
<p>
To use <b>SystemParametersInfo</b>, you must declare it, as well as any constants you’ll be using. The <b>Keyboard</b> class module includes these declarations:</p>
<pre><code>Private Const SPI_GETKEYBOARDDELAY = 22
Private Const SPI_SETKEYBOARDDELAY = 23
Private Const SPI_GETKEYBOARDSPEED = 10
Private Const SPI_SETKEYBOARDSPEED = 11

' SystemParametersInfo flags
Private Const SPIF_UPDATEINIFILE = &amp;H1
Private Const SPIF_SENDWININICHANGE = &amp;H2

Private Declare Function SystemParametersInfo _
  Lib "User32" Alias "SystemParametersInfoA" ( _
  ByVal uAction As Long, ByVal uParam As Long, _
  lpvParam As Any, ByVal fuWinIni As Long) As Long

' This is a made-up constant.
Private Const SPIF_TELLALL = SPIF_UPDATEINIFILE Or _
                             SPIF_SENDWININICHANGE</code></pre>
<p>
Retrieving values using <b>SystemParametersInfo</b> requires a bit more effort. To retrieve values, you must pass a variable as the third parameter, and (normally) 0 as the fourth parameter. <b>SystemParametersInfo</b> fills the variable with the requested value, like this fragment from the <b>Keyboard</b> class module:</p>
<pre><code>Property Get Speed() As Long
  ' Get the keyboard repeat-speed setting.
  Dim lngValue As Long

  Call SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, _
                            lngValue, 0)
  Speed = lngValue
End Property</code></pre>
<p>
Working with the caret. You can also set and retrieve the number of milliseconds between blinks of the text insertion caret using Windows API calls. The GetCaretBlinkTime function retrieves information about the caret, and the SetCaretBlinkTime sets the blink time. To use these functions, you must first declare them:</p>
<pre><code>Private Declare Function GetCaretBlinkTime _
  Lib "User32" () As Long
Private Declare Function SetCaretBlinkTime _
  Lib "User32" (ByVal wMSeconds As Long) As Long</code></pre>
<p>
Once you’ve declared these functions, they’re simple to use. For example, to set the caret so that it blinks every 50 milliseconds (not a very good idea, by the way), you’d write code like this:</p>
<pre><code>Call SetCaretBlinkTime(50)</code></pre>
<p>
Be careful! The caret is a global resource, so if you change the blink time for your application, it changes in all applications.</p>
<h3>Don’t Sweat the Details</h3>
<p>
Of course, once you’ve got all the API calls under your belt, you’ve done most of the work required to create the class module. Given that you want to expose the properties listed in FIGURE 1, it’s only a matter of writing the appropriate <b>Property Let</b> and <b>Property Get </b>procedures. Listing One on page XX includes all the property procedures, neatly wrapping up the mess of Windows API calls.</p>
<p>
To use the <b>Keyboard</b> class module, treat it like any other class (except, as noted earlier, that you’ll never create more than one instance of the class). For example, to set the caret blink time to 100 milliseconds and to turn on the c and n toggles (preserving the original states of all the settings), you could write code as shown in FIGURE 4.</p>
<pre><code>Dim fCapsLock As Boolean
Dim fNumLock As Boolean
Dim intBlinkTime As Integer

Dim okb As Keyboard

Set okb = New Keyboard
intBlinkTime = okb.CaretBlinkTime
fCapsLock = okb.Capslock
fNumLock = okb.Numlock
okb.CaretBlinkTime = 100
okb.Capslock = True
okb.Numlock = True

' Later, to reset the states:
okb.CaretBlinkTime = intBlinkTime
okb.Capslock = fCapsLock
okb.Numlock = fNumLock</code></pre>
<p>
<b>FIGURE 4: Using the </b>Keyboard<b> class to set the caret blink rate and c and n toggles.</b></p>
<p>
Certainly, no one could disagree that using properties of a simple object, such as this one, is far easier than calling the Windows API directly. Once you’ve got this class module completed (and that should be easy: Simply copy and paste the code from the sample file — see the end of the article for download details), you can use it in any VBA application. What’s more, because of IntelliSense, you don’t even need to remember the names of the properties. (I admit, when I find myself required to revert to previous versions of Office or VB, I usually write the code in the current version, taking advantage of IntelliSense, then copy and paste the code into the older version when I’m done. Talk about lazy!) </p>
<p>
<b>Give It a Try</b></p>
<p>
Take the <b>Keyboard</b> class, add it to a project, and use it. You’ll see that it couldn’t be easier. And you don’t need to know or remember how those pesky API calls work. As this column progresses, I’m sure we’ll present several more API wrapper classes. Mike Gilbert and I have written a number of these for various projects, and they’re incredibly rewarding to use in production code. Imagine being able to pull out a class that wraps up some complex API work, and use it without digging into obscure function calls and tons of constants. You shouldn’t need to sweat the details more than once, and that’s where class modules come in handy.</p>
<p>
<b>Begin Listing One </b></p>
<pre><code>Property Get KeyboardType() As Long
  ' Determine the type of keyboard on the system.
  ' 1  IBM PC/XT or compatible (83-key) keyboard
  ' 2  Olivetti "ICO" (102-key) keyboard
  ' 3  IBM PC/AT (84-key) or similar keyboard
  ' 4  IBM enhanced (101- or 102-key) keyboard
  ' 5  Nokia 1050 and similar keyboards
  ' 6  Nokia 9140 and similar keyboards
  ' 7  Japanese keyboard
  KeyboardType = GetKeyboardType(0)
End Property

Property Get FunctionKeys() As Long
  ' Determine the number of function keys on the keyboard.
  ' 1  10
  ' 2  12 (sometimes 18)
  ' 3  10
  ' 4  12
  ' 5  10
  ' 6  24
  ' 7  Hardware dependent and specified by the OEM
  FunctionKeys = GetKeyboardType(2)
End Property

Property Get Capslock() As Boolean
  ' Return the Capslock toggle.
  Capslock = CBool(GetKeyState(vbKeyCapital) And 1)
End Property

Property Get Numlock() As Boolean
  ' Return the Numlock toggle.
  Numlock = CBool(GetKeyState(vbKeyNumlock) And 1)
End Property

Property Get ScrollLock() As Boolean
  ' Return the ScrollLock toggle.
  ' ScrollLock = CBool(GetKeyState(vbKeyScrollLock) And 1)
End Property

Property Let Capslock(Value As Boolean)
  ' Set the Capslock toggle.
  Call SetKeyState(vbKeyCapital, Value)
End Property

Property Let Numlock(Value As Boolean)
  ' Set the Numlock toggle.
  Call SetKeyState(vbKeyNumlock, Value)
End Property

Property Let ScrollLock(Value As Boolean)
  ' Set the ScrollLock toggle.
  Call SetKeyState(vbKeyScrollLock, Value)
End Property

Private Sub SetKeyState(intKey As Integer, _
                        fTurnOn As Boolean)
  ' Retrieve the keyboard state, set the particular
  ' key in which you're interested, and then set
  ' the entire keyboard state back the way it
  ' was, with the one key altered.
  Dim abytBuffer(0 To 255) As Byte

  Call GetKeyboardState(abytBuffer(0))
  abytBuffer(intKey) = CByte(Abs(fTurnOn))
  Call SetKeyboardState(abytBuffer(0))
End Sub

Property Let Delay(Value As Long)
  ' Sets the keyboard repeat-delay setting.
  ' Only values 0 through 3 are acceptable. Others will be
  ' set back to 0.
  Call SystemParametersInfo(SPI_SETKEYBOARDDELAY, Value, _
                            0, SPIF_TELLALL)
End Property

Property Get Delay() As Long
  Dim lngValue As Long

  Call SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, _
                            lngValue, 0)
  Delay = lngValue
End Property

Property Let Speed(Value As Long)
  ' Sets the keyboard repeat-speed setting.
  ' Only values 0 through 31 are acceptable. Others will
  ' be set back to 0.
  Call SystemParametersInfo(SPI_SETKEYBOARDSPEED, Value, _
                            0, SPIF_TELLALL)
End Property

Property Get Speed() As Long
  ' Get the keyboard repeat-speed setting.
  Dim lngValue As Long

  Call SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, _
                            lngValue, 0)
  Speed = lngValue
End Property

Property Get CaretBlinkTime() As Long
  ' Retrieve the number of milliseconds
  ' between blinks of the caret.
  ' SYSTEM RESOURCE. Change this with care.
  CaretBlinkTime = GetCaretBlinkTime()
End Property

Property Let CaretBlinkTime(Value As Long)
  ' Set the number of milliseconds
  ' between blinks of the caret.
  ' SYSTEM RESOURCE. Change this with care.
  ' Allowable values: 200 to 1200 (multiples of 100)
  Call SetCaretBlinkTime(Value)
End Property</code></pre>
<p>
<b>End Listing One</b></p>
<p>
<i>The files referenced in this article are available for download from the Informant Web site at </i>http://www.informant.com/mod/modnewupl.htm<i>. File name: MOD9712KG.ZIP.</i></p>
<p>
<i>Ken Getz and Mike Gilbert are Senior Consultants with MCW Technologies, a Microsoft Solution Provider focusing on Visual Basic and the Office and BackOffice suites. They’ve recently completed VBA Developer’s Handbook and Access 97 Developer’s Handbook (co-authored with Paul Litwin), both for SYBEX.</i></p>
</font></BODY>
</HTML>
