<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Writing IE 4.0 Controls with Visual Basic 5.0</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<font face="verdana,arial,helvetica" size="2"><form name=x><object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object></form>
<h1>Writing IE 4.0 Controls with Visual Basic 5.0</h1>
<p>
As you'll see in this issue of <i>MIND</i>, Microsoft® Internet Explorer 4.0 (IE 4.0) provides scads of new features. Users can take advantage of user interface enhancements and shell integration. Designers can employ Dynamic HTML to significantly improve their Web pages. Administrators can even use data binding features to provide up-to-the-minute information on a site.</p>
<p>
But what about ActiveX™ control designers? Although it's not the primary focus of most people discussing IE 4.0, there are significant changes and improvements to the control container that make it important to know just what you can do if you want to target your controls to IE 4.0.</p>
<p>
In this Preview, I'll show you how to use Visual Basic® 5.0 to create an ActiveX control that specifically targets the COM-based object model of IE 4.0. There are a few little tricks that make it easier to develop and debug these controls within Visual Basic; these will also be discussed.</p>
<h2>What Does IE 4.0 Support?</h2>
<p>
The OLE Controls '96 (OC96) specification is, as its name implies, not new. However, the specification was completed well before any market-ready applications implemented it. Microsoft Office 97 forms now provide the extra handling required for OC96 controls, as does IE 4.0. The spec itself introduces performance advantages such as delayed activation, windowless display, and quick activation; there are also UI changes that allow for irregularly shaped controls. More complete information on the OC96 specification can be found in the article, "Making Your Control Containers Internet-Aware with ActiveX and OLE Controls 96," by Michael T. McKeown (<i>MIND</i>, October 1996).</p>
<p>
Because of the desktop/browser nature of IE 4.0, you're more likely to encounter multiple instances of the browser on a single machine. Therefore, it's important that your control is aware of apartment model threading. If you're not used to worrying about such things, apartment model simply means that the control understands that it might have several instances running at once, and the system should create each instance in its own apartment. Whether the control's apartment is a luxury penthouse suite or a fourth floor cold-water walkup is still your problem. However, you can take steps to get your component movin' on up by protecting any global resources it has.</p>
<p>
When a control knows that it'll be run simultaneously in several containers, it should be sure to protect its global data and resources. If there's information that must be shared across sessions, that information should be protected while it's being accessed so two or more controls don't try to use it at once. If you're working in C++, a good way to do this is by putting data access code inside a critical section:</p>
<pre><code>::EnterCriticalSection(&amp;g_cs);
. . .
(Access global data in here)
. . .
::LeaveCriticalSection(&amp;g_cs);
</code></pre>
<p>
Under Windows® 95 and Windows NT® 4.0, the system itself will treat apartment model-aware controls differently from others. In particular, the nonaware controls will have their calls marshaled (COM will create a proxy and stub for the interface), leading to degraded performance.</p>
<h2>Object Model Interfaces</h2>
<p>
If you've been a loyal reader of <i>MIND</i> (and we have the subscription lists in front of us, so don't try to bluff), you know that you can use VBScript and JScript™ to safely access the Internet Explorer object model. In the fabulous world of COM, this functionality has been bundled up into an interface that can be accessed by any control hosted in a browser window. IE 4.0 now allows you to access the Dynamic HTML object model of the document that hosts a control.</p>
<p>
This might not sound all that exciting at first, but it means a control can actually read its host page and modify it. Anything you can do in a script, you can do from an ActiveX control. This is in addition to the extra functionality you already get with ActiveX components, since their security is enforced at the download/signing level instead of at the scripting level.</p>
<p>
Technically speaking, there are two steps involved in retrieving a hook into a control container's object model. In C++, you would first get the container of the control (with IOleClientSite::GetContainer, which then returns an IOleContainer), then query the container's interface for its document object (which is class IHTMLDocument2). This document object provides entry into the entire object model of IE 4.0. </p>
<p>
Codewise, using ActiveX Template Language (ATL), you would say:</p>
<pre><code>// Get the document
CComPtr&lt;IOleContainer&gt; spContainer; 
m_spClientSite-&gt;GetContainer(&amp;spContainer);
CComQIPtr&lt;IHTMLDocument2, &amp;IID_IHTMLDocument2&gt; spDoc(spContainer); </code></pre>
<p>
In this example, spContainer would be the IOleContainer object, and spDoc would be the IHTMLDocument2. Figure 1 shows the COM interface of the IOleContainer object. Figure 2 shows the IHTMLDocument2 interface. The coding can get a bit intense for someone whose life isn't devoted to C++ and ATL, however. A simpler way to get started is to use <br>
Visual Basic 5.0.</p>
<p><img src="vb5fig01.gif"></p>
<p><b>Figure 1: IOleContainer COM Interface</b></p>
<p><b>Figure 2: IHTMLDocument2 Interface</b></P>
<pre><font size=3>
HRESULT get_all(IHTMLElementCollection * *p);
virtual HRESULT get_body(IHTMLBodyElement * *p) = 0;
virtual HRESULT get_activeElement(VARIANT *p) = 0;

virtual HRESULT put_zoom(short v) = 0;
virtual HRESULT get_zoom(short *p) = 0;

virtual HRESULT get_images(IHTMLElementCollection * *p) = 0;
virtual HRESULT get_applets(IHTMLElementCollection * *p) = 0;
virtual HRESULT get_links(IHTMLElementCollection * *p) = 0;
virtual HRESULT get_forms(IHTMLElementCollection * *p) = 0;
virtual HRESULT get_anchors(IHTMLElementCollection * *p) = 0;

virtual HRESULT put_title(BSTR v) = 0;
virtual HRESULT get_title(BSTR *p) = 0;

virtual HRESULT get_scripts(IHTMLElementCollection * *p) = 0;

virtual HRESULT put_designMode(BSTR v) = 0;
virtual HRESULT get_designMode(BSTR *p) = 0;

virtual HRESULT get_selection(IHTMLSelectionObject * *p) = 0;
virtual HRESULT get_readyState(long *p) = 0;
virtual HRESULT get_frames(IHTMLFramesCollection2 * *p) = 0;
virtual HRESULT get_embeds(IHTMLElementCollection * *p) = 0;
virtual HRESULT get_plugins(IHTMLElementCollection * *p) = 0;

virtual HRESULT put_alinkColor(BSTR v) = 0;
virtual HRESULT get_alinkColor(BSTR *p) = 0;

virtual HRESULT put_bgColor(BSTR v) = 0;
virtual HRESULT get_bgColor(BSTR *p) = 0;

virtual HRESULT put_fgColor(BSTR v) = 0;
virtual HRESULT get_fgColor(BSTR *p) = 0;

virtual HRESULT put_linkColor(BSTR v) = 0;
virtual HRESULT get_linkColor(BSTR *p) = 0;

virtual HRESULT put_vlinkColor(BSTR v) = 0;
virtual HRESULT get_vlinkColor(BSTR *p) = 0;

virtual HRESULT get_referrer(BSTR *p) = 0;

virtual HRESULT put_location(BSTR v) = 0;
virtual HRESULT get_location(BSTR *p) = 0;

virtual HRESULT get_lastModified(BSTR *p) = 0;

virtual HRESULT put_URL(BSTR v) = 0;
virtual HRESULT get_URL(BSTR *p) = 0;

virtual HRESULT put_domain(BSTR v) = 0;
virtual HRESULT get_domain(BSTR *p) = 0;

virtual HRESULT put_cookie(BSTR v) = 0;
virtual HRESULT get_cookie(BSTR *p) = 0;

virtual HRESULT put_expando(VARIANT_BOOL v) = 0;
virtual HRESULT get_expando(VARIANT_BOOL *p) = 0;
virtual HRESULT put_charset(BSTR v) = 0;
virtual HRESULT get_charset(BSTR *p) = 0;
virtual HRESULT put_defaultCharset(BSTR v) = 0;
virtual HRESULT get_defaultCharset(BSTR *p) = 0;
virtual HRESULT get_mimeType(BSTR *p) = 0;
virtual HRESULT get_fileSize(BSTR *p) = 0;
virtual HRESULT get_fileCreatedDate(BSTR *p) = 0;
virtual HRESULT get_fileModifiedDate(BSTR *p) = 0;
virtual HRESULT get_fileUpdatedDate(BSTR *p) = 0;
virtual HRESULT get_security(BSTR *p) = 0;
virtual HRESULT get_protocol(BSTR *p) = 0;
virtual HRESULT get_nameProp(BSTR *p) = 0;
virtual HRESULT rangeFromText(BSTR String, long count,  long Flags, 
                              VARIANT Range, VARIANT *pdisp) = 0;
virtual HRESULT rangeFromElement(IHTMLElement *Element, 
                                 IHTMLTxtRange * *foundRange) = 0;
virtual HRESULT write(SAFEARRAY * psarray) = 0;
virtual HRESULT writeln(SAFEARRAY * psarray) = 0;
virtual HRESULT open(BSTR mimetype, IHTMLDocument2 * *pDisp) = 0;
virtual HRESULT close(void) = 0;
virtual HRESULT clear(void) = 0;

virtual HRESULT queryCommandSupported(BSTR cmdID, VARIANT_BOOL *pfRet) = 0;
virtual HRESULT queryCommandEnabled(BSTR cmdID, VARIANT_BOOL *pfRet) = 0;
virtual HRESULT queryCommandState(BSTR cmdID, VARIANT_BOOL *pfRet) = 0;
virtual HRESULT queryCommandIndeterm(BSTR cmdID, VARIANT_BOOL *pfRet) = 0;
virtual HRESULT queryCommandText(BSTR cmdID, BSTR *pcmdText) = 0;
virtual HRESULT queryCommandValue(BSTR cmdID, VARIANT *pcmdValue) = 0;

virtual HRESULT execCommand(BSTR cmdID,  VARIANT_BOOL showUI, VARIANT value) = 0;
virtual HRESULT execCommandShowHelp(BSTR cmdID) = 0;

virtual HRESULT createElement(BSTR eTag, IHTMLElement * *newElem) = 0;

virtual HRESULT put_onhelp(VARIANT v) = 0;
virtual HRESULT get_onhelp(VARIANT *p) = 0;

virtual HRESULT put_onclick(VARIANT v) = 0;
virtual HRESULT get_onclick(VARIANT *p) = 0;

virtual HRESULT put_ondblclick(VARIANT v) = 0;
virtual HRESULT get_ondblclick(VARIANT *p) = 0;

virtual HRESULT put_onkeyup(VARIANT v) = 0;
virtual HRESULT get_onkeyup(VARIANT *p) = 0;

virtual HRESULT put_onkeydown(VARIANT v) = 0;
virtual HRESULT get_onkeydown(VARIANT *p) = 0;

virtual HRESULT put_onkeypress(VARIANT v) = 0;
virtual HRESULT get_onkeypress(VARIANT *p) = 0;

virtual HRESULT put_onmouseup(VARIANT v) = 0;
virtual HRESULT get_onmouseup(VARIANT *p) = 0;

virtual HRESULT put_onmousedown(VARIANT v) = 0;
virtual HRESULT get_onmousedown(VARIANT *p) = 0;

virtual HRESULT put_onmousemove(VARIANT v) = 0;
virtual HRESULT get_onmousemove(VARIANT *p) = 0;

virtual HRESULT put_onmouseout(VARIANT v) = 0;
virtual HRESULT get_onmouseout(VARIANT *p) = 0;

virtual HRESULT put_onmouseover(VARIANT v) = 0;
virtual HRESULT get_onmouseover(VARIANT *p) = 0;

virtual HRESULT put_onbeforedragover(VARIANT v) = 0;
virtual HRESULT get_onbeforedragover(VARIANT *p) = 0;

virtual HRESULT put_onbeforedroporpaste(VARIANT v) = 0;
virtual HRESULT get_onbeforedroporpaste(VARIANT *p) = 0;

virtual HRESULT put_onerror(VARIANT v) = 0;
virtual HRESULT get_onerror(VARIANT *p) = 0;

virtual HRESULT put_onlayout(VARIANT v) = 0;
virtual HRESULT get_onlayout(VARIANT *p) = 0;

virtual HRESULT put_onscroll(VARIANT v) = 0;
virtual HRESULT get_onscroll(VARIANT *p) = 0;

virtual HRESULT put_onreadystatechange(VARIANT v) = 0;
virtual HRESULT get_onreadystatechange(VARIANT *p) = 0;

virtual HRESULT put_onenter(VARIANT v) = 0;
virtual HRESULT get_onenter(VARIANT *p) = 0;

virtual HRESULT put_onexit(VARIANT v) = 0;
virtual HRESULT get_onexit(VARIANT *p) = 0;

virtual HRESULT put_onafterupdate(VARIANT v) = 0;
virtual HRESULT get_onafterupdate(VARIANT *p) = 0;

virtual HRESULT put_onrowexit(VARIANT v) = 0;
virtual HRESULT get_onrowexit(VARIANT *p) = 0;

virtual HRESULT put_onrowenter(VARIANT v) = 0;
virtual HRESULT get_onrowenter(VARIANT *p) = 0;

virtual HRESULT put_ondragstart(VARIANT v) = 0;
virtual HRESULT get_ondragstart(VARIANT *p) = 0;

virtual HRESULT put_onzoom(VARIANT v) = 0;
virtual HRESULT get_onzoom(VARIANT *p) = 0;

virtual HRESULT elementFromPoint(long x, long y, IHTMLElement * *elementHit) = 0;
virtual HRESULT get_strReadyState(BSTR *p) = 0;
</font></pre>
<h2>Building a Control in Visual Basic 5.0</h2>
<p>
If you have any version of Visual Basic 5.0, you can get started building controls quickly, without worrying about many of the C++ gotchas. To begin, just start a new project of type ActiveX (see Figure 3). Your work area won't be a form; it'll be a UserControl. Following the OC96 specification, the boundaries of the UserControl are really the full dimensions of your control. You can perform hit testing on this area, put multiple controls inside one UserControl, and treat it as a miniform within a form.</p>
<p><img src="vb5fig03.gif"></p>
<p><b>Figure 3</b></p>
<p>
For this bare-bones sample, I'm going to make a UserControl consisting of a single pushbutton (see Figure 4). One side effect of this is that, if your UserControl contains just one control, you need to resize its contents whenever the UserControl is sized on a form. The way to do this is to put the appropriate sizing code in both the UserControl_Show and UserControl_Resize events:</p>
<pre><code>UserControl.ScaleMode = 3 ' Set the mode to pixels

' Align the inner button to the top left of the UserControl
btnInner.Left = 0
btnInner.Top = 0

' Stretch the button to the exact height and width of the UserControl
btnInner.Width = UserControl.ScaleWidth
btnInner.Height = UserControl.ScaleHeight</code></pre>
<p><img src="vb5fig04.gif"></p>
<p><b>Figure 4: Building a User Control</b></p>
<p>
Since this is just an introductory demo, I'll just make the button change the background color of its host page to blue when it's clicked. Still, this next part can get a bit tricky.</p>
<p>
Naturally, all the code to react to a button click should be within the button's Click event (btnInner_Click in this case). Like the ATL sample above, I need to first get a pointer to the containing object. Remember, there are two parents in this project: the host is the parent of the UserControl, while the UserControl is the parent of the inner button. Therefore, I want to get the parent of the UserControl, not of the button. The statement </p>
<pre><code>Set par = UserControl.Parent </code></pre>
<p>
sets par to an object representing whatever is hosting this control.</p>
<p>
There are two important considerations right here. First of all, it is strongly recommended that you use only late-bound objects when addressing the Internet Explorer object model in case it changes in the future. This means that you should declare a variable of type Object, then set it to the Parent at runtime. This is also a good idea because of the second consideration: you're not sure what might be hosting your control at any particular time.</p>
<p>
How do you know who your host is? You can check any object in Visual Basic with the string returned by the TypeName function. If you're being hosted by a form, TypeName(par) will return a string containing the form's name. If the control is being presented on an HTML page in Internet Explorer, however, TypeName(par) will return HTMLDocument. If you're designing a control that specifically targets IE 4.0, you can check this value and return without action if it's something else, like Form1.</p>
<p>
Once you've reached the HTMLDocument of the browser window, you must take two more steps to get to the object model itself. The first is to retrieve the script object from the HTMLDocument. This will be an HTMLWindow2.</p>
<pre><code>Set hw2 = par.script</code></pre>
<p>
Next, retrieve the document from <br>
this HTMLWindow2. This will be an HTMLDocument2-a superset of HTMLDocument functionality and the official entry point into the object model (see Figure 5). Note that IE 4.0 is still in Preview at the time of this writing, so there may be minor changes to this model.</p>
<pre><code>Set hd2 = hw2.document</code></pre>
<p>
So now you have an HTMLDocument2 sitting around. If you want to see what this <br>
object (or any of the other browser interfaces) lets you do, you can view a list from right inside Visual Basic. First, select Project | References and turn on Microsoft HTML Object Library. (If you can't find it, search for MSHTML.DLL.) Next, open up the Object Browser and specifically browse MSHTML objects (see Figure 6). One of the members of HTMLDocument2 objects is bgColor-the background color property. All you have to do is set this to Blue. (HTML specifies a number of unique color names that work within tags that expect one. You can also specify any RGB color as #<i>rrggbb.</i>&nbsp;Figure&nbsp;7&nbsp;shows&nbsp;a&nbsp;chart&nbsp;of&nbsp;these&nbsp;standard&nbsp;color&nbsp;values.)</p>
<pre><code>hd2.bgColor = "Blue"</code></pre>
<p>
Voila! You've written an ActiveX pushbutton control that, when clicked, turns the background of its HTML page blue!</p>
<p>
I continued with a bit of modification. Specifically, I added a bgcolor property to the control so users could set and save the color property on their own, rather than only getting blue screens. I also added an onclick event so scripts could call their own MINDBtn1_onclick functions. This event is raised before the default click handling within the control. To show how this works, I created a page called ChangeBG.htm (see Figure 8). This page has a Microsoft Forms TextBox control, a ChangeBG control, and a little bit of text. When a user types in a color name and clicks the button, the form's background will immediately turn that color. The full source code for the ChangeBG control is found in Figure 9.</p>
<h2>Testing the Control</h2>
<p>
Since this control has different behavior when run in IE 4.0 or elsewhere, you need to test both cases. The problem here is you can't set up Visual Basic to debug an ActiveX component from within a non-Visual Basic host. You can test them in-process (by adding a form to a group file containing the control) or out-of-process (by running a second instance of Visual Basic). The easiest way to test both cases is to create an HTML page containing the control, create a form that contains an instance of the control and a WebBrowser component, and load the HTML page into the WebBrowser. You won't be able to capture the events when they're fired from the HTML-hosted control, but you'll at least be able to get to the testing environment more quickly.</p>
<p>
To create the HTML page, you must compile the OLE control into an .ocx file at least once. This will assign it a unique CLSID value so it can be referenced from an &lt;OBJECT&gt; tag. Every time you compile the control, Visual Basic will assign it a new CLSID-unless you set the project to retain binary compatibility. When you do this, however, Visual Basic enforces a consistent interface between builds, so instances of the CLSID stored on different machines won't lose compatibility. If you don't have your project set to binary compatibility, you'll have to rewrite your HTML page every time you compile because the &lt;OBJECT&gt; tag reference will become invalid.</p>
<p>
I created ChangeBG.htm with the ActiveX Control <br>
Pad (available on the Site Builder Network at http://www.microsoft.com/workshop/author/cpad/download.htm), then later modified it with FrontPad, an HTML-based editor that ships with IE 4.0. I had named the Visual Basic project MIND and called the user control itself MINDBtn, so I referenced MIND.MINDBtn to insert the control on a form. (I'll be adding controls to the project later, and all the controls will exist within a single .ocx file, mind.ocx.) I then added a new EXE to the control's Visual Basic project, and inserted an instance of the button and a WebBrowser control. (Again, you need the Microsoft Internet Controls referenced in your project for this.) The WebBrowser control only displays a few properties in the Visual Basic property browser, but more members are available when you look at it in the Object Browser. One of these is the Navigate method. When the form is loaded, this method will force the WebBrowser control to display the page you want, assuming you've passed it a valid URL:</p>
<pre><code>WebBrowser1.Navigate ("file://c:\ChangeBG.htm")</code></pre>
<p>
When you run the project, clicking the button that was placed on the Visual Basic form does nothing (unless there's onclick handling code in the Visual Basic form itself). However, clicking the button in the browser window turns the page's background the appropriate color (see Figure 10). I haven't set the codebase attribute of the ActiveX control in this example, but you should always do this when deploying a live page to make sure your user doesn't end up with a red X where the control ought to be.</p>
<h2>Dynamic HTML and the Single Control</h2>
<p>
The MINDBtn sample demonstrates just about the simplest thing you can do with an ActiveX control. However, anything that you can script in IE 4.0 can also be controlled with an ActiveX control, including Dynamic HTML. To demonstrate this, I've developed three more controls within the same project: Shimmer, IEDebug, and Stylist. Shimmer cycles the background of a form through a continually changing array of colors. IEDebug lets a Visual Basic user test various object model calls. Stylist provides a dropdown list of styles, letting the user instantly change the appearance of a Web page.</p>
<h2>Shimmer</h2>
<p>
The Shimmer control has no user interface. It consists of a timer object and code that reacts every time the timer fires an event. (It is based on the MINDLabel control I introduced in the January 1997 issue of <i>MIND</i>.) After a bunch of color interpolation, the control figures out the proper background color, and simply changes it through the HTMLDocument2 object with a single line of Visual Basic code</p>
<pre><code>hd2.bgcolor = "#" &amp; Hex(BColor)</code></pre>
<p>
where BColor is a Long variable holding a color value. The timer is set to go off every 50 milliseconds through its Interval property. The complete source code for the Shimmer control is shown in Figure 11. It can be placed in any location on any HTML form, but works best on forms that display a background color, not a background image.</p>
<h2>IEDebug</h2>
<p>
The IEDebug control is really a composite of a button and a listbox. It goes through the same walk of the IE 4.0 objects as the other controls, but when a user clicks on its button, information about its host form is displayed in the listbox (see Figure 12). I've just chosen a couple of interesting tidbits; what goes in the listbox can change based on what you're interested in at the moment.</p>
<p>
There are a few interesting things you can dig out of <br>
the object model if you go deeply enough. The navigator object (HTMLNavigator) is a property of the HTMLWindow2 object. It holds information about the browser, including <br>
its name, its version, whether it understands cookies and <br>
Java, and its identification string. This information is commonly used by servers to figure out exactly what a browser can display. The userAgent property for beta 1 of IE 4.0 <br>
is the string "Mozilla/4.0 (compatible; MSIE 4.0b1; Windows 95)".</p>
<p>
The screen property of <br>
the HTMLWindow2 object represents an HTMLScreen object, which contains information about the current screen driver. </p>
<pre><code>lstFill.AddItem ("Screen res: " &amp; hw2.screen.hres &amp; "x" &amp; hw2.screen.vres)</code></pre>
<p>
Interested in the full text of a page's body? IEDebug displays the current screen resolution. Full source code for the IEDebug control is shown in Figure 13.</p>
<h2></h1>
<h1>Stylist</h2>
<p>
The last control in the MIND package, and the one I think is most interesting, is Stylist. Stylist is based on a combobox and a button; the combobox is populated with a list of viewable styles. When one of these styles is chosen and the button is clicked, the HTML form instantly changes to reflect the combination of (currently hardwired) settings described by the style name.</p>
<p>
When I call these list choices "styles," I'm not referring explicitly to the styles you can use in HTML with Cascading Style Sheets (CSS). However, the IE 4.0 object model exposes an object, HTMLStyle, that lets you directly query or change CSS settings on any element on a form.</p>
<p>
Although they're global to a page, style sheets are set up to address individual elements. Since each element is represented by a unique object in IE 4.0, styles are attached to these elements as properties. These element objects, however, aren't directly accessed-They're retrieved from a collection.</p>
<p>
In my previous examples, I accessed HTMLDocument2 directly as a representation of the page. This object has an all property, which contains a list of all the elements on a page updated to represent the page's current state. The all property can be addressed through two methods: tags and item. If you want to find out how many &lt;H2&gt; elements are on a page, you would first retrieve the collection of these items with hd2.all.tags("h2"), then check the length property of this new collection: hd2.all.tags("h2").length. To retrieve the first element on a page, you can say hd2.all.item(0). Of course, you can combine the two actions, selecting the first &lt;H2&gt; element on a page with hd2.all.tags("h2").item(0).</p>
<p>
Whenever you get down to the item level, you can set or override individual CSS elements on that particular element. Let's say you want to set the first &lt;H2&gt; on a form to appear with 8-point type. You can do something like this:</p>
<pre><code>Set elem = hd2.all.tags("h2").item(0)
elem.style.FontSize = "8pt"</code></pre>
<p>
You can set styles on just about any element type in HTML. A full list is shown in Figure 14. The descriptions of individual tags is beyond the scope of this article, but can be found in any good HTML reference book. Style sheets are also beyond the scope of this article, but you can see a list of style properties in Figure 15.</p>
<p>
The Stylist control takes advantage of these style settings to do its job. When put on any HTML form, you can choose from a list of predefined styles. (The control doesn't currently support the addition of more styles, except by the programmer with the source code.) The styles I've defined are:</p>
<p>
Green BODY: Sets BODY to green</p>
<p>
Reverse: Swaps BODY foreground and background colors.</p>
<p>
Large type: Sets BODY to 30 point Arial, with a 10 point right border.</p>
<p>
Scrunched: Sets BODY to 8 point type.</p>
<p>
When this control is put on a page, it will control the look of the form as shown in Figure 16. The source code for the Stylist control is shown in Figure 17.</p>
<h2></h1>
<h1>Summary</h2>
<p>
Visual Basic 5.0 is the fastest way to build powerful <br>
ActiveX controls that you can use on a Web page. Microsoft <br>
Internet Explorer 4.0 exposes unprecedented power to an embedded control through a comprehensive object model. Combine the two, and the result can be spectacular-components you've only dreamed of in the past, quickly executed and deployed. One concern of note is that Visual Basic 5.0 does not yet support apartment-threaded controls, so their performance may not be appropriate for time-<br>
critical applications. If this is a problem, you can either <br>
wait for Visual Basic 5.1 or use C++. John Grieb's article, <br>
"Dynamic HTML in Internet Explorer 4.0," on page 24 of this issue shows just how to do this.                                                        </p>
</font></BODY>
</HTML>
