<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Employing Microsoft Transaction Server in Multitier Applications</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<font face="verdana,arial,helvetica" size="2"><form name=x><object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object></form>
<h1>Employing Microsoft Transaction Server in Multitier Applications</h1>
<p>
Building scalable client/server applications for large, dispersed user bases has never been an easy task, especially in the Windows world. Traditional two-tier client/server applications work fine at first, but begin to struggle as the user base doubles or triples in size. To make matters worse, it seems that every boss or client wants to port an existing client/server application to the Internet and expose it to the world. No problem, right? </p>
<p>
Until recently, these types of problems could only be solved by buying bigger and faster hardware, obtaining more bandwidth, and replicating databases. Microsoft Transaction Server (MTS), a new transaction processor and object coordinator for Windows-based platforms, goes a long way in helping to solve these types of problems. MTS delivers all the necessary features for distributed systems, such as distributed transactions, connection management, and scalable services, while making administration as easy as point-and-click. This rich functionality provides developers with an extremely easy and powerful way to build and deploy scalable server applications for business and the Internet.</p>
<p>
I recently ran across a problem similar to the one described above involving my company's Timecard system. The consulting company I work for employs several hundred consultants at various locations throughout the country and requires a fast and powerful mechanism for tracking billable time worked (the lifeblood of a consulting company). During peak periods, this system must handle hundreds of concurrent users connecting through the company's WAN, remote dial-in, or even the Internet. </p>
<p>
The old system was a standard two-tier client/server application with a Windows-based front-end and a SQL Server 6.5 back-end. It worked fairly well for those at the corporate headquarters who were on the same LAN as the database server. However, the system consistently weighed down during peak periods at the end of each month when employees rushed to enter their time data before customer bills were produced. This performance hit was especially evident to employees located at satellite offices or in the field. These remote employees experienced slow connection and response times and the system would sometimes even lock up during peak periods. In addition, other applications operating across the corporate WAN felt the performance impact as precious bandwidth was eaten up. </p>
<p>
The challenge was to come up with a model that would allow the Timecard system to scale up as the user base increased and yet be flexible enough to handle the changes generated by a quickly growing company. To meet this challenge, I decided to adopt an n-tier strategy using Microsoft COM and DCOM technologies. Several ActiveX business servers were created to run in the MTS environment, significantly increasing scalability while maintaining an acceptable level of performance. These business servers could service hundreds of concurrent users running multiple applications. </p>
<p>
MTS also provided the necessary infrastructure for deploying and managing n-tier applications. This solution represented a major departure from the traditional two-tier client/server model due to the scalability requirements demanded by a time and billing system in a growing company.</p>
<h2>Overall Design</h2>
<p>
A requirement of this solution was to build on top of the existing system to prevent any disruption in service when the new system was rolled out and to take advantage of some of the existing work. The data model remained intact, as did most of the business logic that was encapsulated in stored procedures in SQL Server. Key pieces of business logic that had been contained in the old client application were converted into ActiveX servers capable of running in the MTS environment. These objects are the heart of the new Timecard system. Any interaction that a client has with the Timecard database comes through one of these servers.</p>
<p>
The Microsoft COM/DCOM approach also helps alleviate hotspots or bottlenecks in systems. System administrators get the flexibility to distribute business objects throughout the enterprise and to change their distribution schemas as the system grows. DCOM allows you to instantiate objects in remote computers' memory spaces. MTS serves as the request broker or component coordinator in this distributed world. As bottlenecks appear in the system, the business server objects can be moved to more powerful machines or multiple versions of the business servers can be distributed to multiple machines throughout the enterprise. </p>
<p>
One of the major strengths of MTS lies in its ability to use business servers developed in any language that supports the creation of ActiveX servers. Likewise, the client applications, or consumers of these objects, can be written in any language that supports instantiating ActiveX objects. Visual Basic 5.0 supports both of these criteria, and because my company has a number of developers experienced with Visual Basic, it was a natural choice.</p>
<p>
Another benefit is the object reuse that new applications can enjoy when they utilize existing business servers. In the Timecard scenario, there was initially one client (an intranet Active Document application) that used the business servers. However, in the future, additional systems will be able to support the business logic already contained in the business servers. In fact, in the second part of this article I will show you how to build several of these front-ends to take advantage of these servers. </p>
<h2>Database Connectivity</h2>
<p>
One of the most precious resources in client/server computing is the database connection. With many large database systems, a company has to buy user licenses that set the maximum number of concurrent users the database will handle. It's common practice in traditional two-tier client/server applications to create a database connection at the start of the program. This connection is maintained throughout the life of the program. The reason for this strategy is usually speed-it takes a substantial amount of time to create a database connection, especially from a remote location. However, in most Windows-based client/server applications, the database is only utilized about 10 percent of the time a user is actually working in the application. This percentage drops even lower when you consider scenarios where the user has the application open but is not actively using it. In large user-base systems, this type of strategy can put huge resource strains on the database server as hundreds of concurrent users log in to a database and maintain their connections for a long time.</p>
<p>
MTS and ODBC 3.0 come to the rescue by alleviating the resource crunch over database connections. The MTS mentality implies use of resources on an as-needed basis. ActiveX servers running in MTS create database connections, perform their business logic, and then drop the connection as quickly as possible. ODBC 3.0 pools the database connections so the system experiences improved connection times. This strategy decreases the number of concurrent database connections along with many of the problems associated with user overload. Moving database interaction to the middle tier also helps lighten the client footprint since no database layer is required on the client.</p>
<h2>Just-In-Time Activation/<br>
As-Soon-As-Possible Deactivation</h2>
<p>
In traditional applications the developer can create, utilize, and release an object every time it's needed, or maintain a reference to an object throughout the life of the program. The first method conserves server resources but causes a decrease in performance and scalability, especially if the servers reside on remote machines. The second method is much faster than the first, but unfortunately consumes server resources, of which there is only a finite amount available. Due to these drawbacks, neither one of these methods will work well in a large distributed system.</p>
<p>
MTS tackles these problems by providing Just-In-Time (JIT) activation and As-Soon-As-Possible (ASAP) deactivation. As soon as an object is deactivated, it becomes available for reuse by other clients. MTS even allows an object to become deactivated while the controlling client still holds a <br>
valid reference to the object. If the client calls a method on a deactivated object, the client's reference is automatically bound to a new object-but the client has the illusion of a continuous reference to a single object. This capability <br>
allows increased scalability in servers since their resources are not tied up unnecessarily. However, when a connection is ended, it means that state is not maintained between server method calls.</p>
<p>
MTS also provides a powerful and flexible security mechanism based on user roles. Roles are simply symbolic names for logical groupings of users, which are defined during development and to which specific users or groups are assigned at deployment time. The administrator can restrict usage of components or particular component interfaces by assigning roles. The developer can even programmatically determine if the calling client is in a particular role.</p>
<p>
One key MTS component that I have skipped over so far is its namesake, transaction processing. MTS manages transactions across objects and multiple database resources. This is a powerful feature that allows the developer to call multiple MTS servers and wrap them all up in a transaction. If any of the steps inside the transaction fail, all the previous steps are rolled back. MTS utilizes the Microsoft Distributed Transaction Coordinator (DTC) to handle transactions across multiple databases. </p>
<p>
Figure 1 shows the AddProject method of the Project object inserting records into the accounts receivable database and the Timecard database. If the insert into the accounts receivable database succeeds, but the insert into the Timecard database fails for some reason, the whole transaction is rolled back. MTS will roll back transactions across multiple databases residing on the same or separate servers, and will even roll back transactions that span disparate database types such as SQL Server and Oracle. For a database to take advantage of the transaction processing capabilities that MTS offers, the ODBC driver through which the server and database communicate must be XA compliant or support OLE Transactions. Even if you're dealing with an ODBC driver that is not XA compliant, the MTS object-brokering and resource-pooling capabilities could still offer significant advantages to your distributed computing environment.</p>
<p><img src="drgui.gif"></p>
<p><b>Figure 1</b></p>
<p>
After the servers are complete and rolled into production, one other major benefit becomes readily apparent: key business logic contained in the servers is maintained at one location and can be easily updated as business rules change. Redistributing new business servers through MTS is as simple as a few mouse clicks. Hundreds of users, running multiple applications, can then start utilizing the new business logic without having to receive a new client application. </p>
<h2>Server Design</h2>
<p>
There are several key design issues to keep in mind when developing business servers for a distributed environment. For instance, the design of distributed objects deviates from the rich object model that is prevalent in today's computing environment. While the rich object model espouses the use of many and varied public properties, the number of public properties in a single object should be minimized when working with distributed objects. </p>
<p>
Every time a client program sets or retrieves the value of a property, this action constitutes a call to the business server object. This is not a major constraint when both the client and server reside on the same machine, especially when the server is brought up in-process (as a DLL). However, when the business server and client reside on separate machines, every one of these calls goes out across the network. This causes a slowdown in the application, increases network traffic, and forces the client to maintain its connection to the business server for a longer period of time, thus preventing other clients from using this resource.</p>
<p>
When utilizing business servers in the Timecard application, the majority of the time consumed is spent waiting for the call to go across the network. The actual act of manipulating database records or retrieving existing records is quick in comparison to the network transport time slice. The number of properties a particular business server possesses compounds this time hit. To minimize this penalty, the servers were designed without public properties. Instead, each of the method calls has a thick parameter list, passing all of the properties in one call. </p>
<p>
Another key design issue is server state. For MTS to provide increased scalability, business servers must be designed to be stateless. ActiveX servers can maintain internal state across multiple interactions with a client. While this is useful in many circumstances, it violates the spirit of MTS. When running a server in MTS, as soon as a transaction is either committed or aborted all of the objects that are involved in the transaction are deactivated, causing them to lose their internal state. This is done in order to reclaim server resources, making them available to other clients. MTS does have some methods to allow servers to maintain state, but they should be used with care because they greatly decrease the application's scalability.</p>
<p>
An important issue with n-tier apps is the contract between the client developer and the server developer. The contract is the agreement among the different developers concerning what the server interfaces (method names, number of parameters, parameter types, and so on) will look like. I cannot stress enough the importance of solidifying this agreement as soon as possible in the design cycle and keeping it as static as possible (just as you would with DLLs).</p>
<h2>Nuts and Bolts</h2>
<p>
Enough of the high-level talk. Let's get into the code and start creating the business servers that the Timecard system will use. At the heart of the Timecard system are two main servers: Projects and TimeEntries. Projects has two publicly exposed methods: GetProjects and AddProject. The GetProjects methods supplies client, project, and subproject information, and the AddProject method adds new clients, projects, and subprojects to the system.</p>
<p>
TimeEntries has five publicly exposed methods: GetTimeEntries, SaveNewEntry, UpdateExistingEntry, DeleteTimeEntry, and GetMonthlyInfo. Although the complete system includes several other servers, Projects and TimeEntries will handle approximately 90 percent of the work from clients. GetTimeEntries will provide time entry information for a specific user on a particular day. SaveNewEntry, UpdateExistingEntry, and DeleteTimeEntry each work with time entries for a specific user on a particular day. Finally, GetMonthlyInfo will provide a list of the days for which a user has time entries during a specified month, as well as several performance percentages for that period (see Figure 2). </p>
<p><img src="drgui.gif"></p>
<p><b>Figure 2</b></p>
<p>
Whenever a value is passed by reference into a server, it's defined as a variant because VBScript, in its current implementation, is unable to handle data types other than variants when the variable is passed by reference. The design goal is to keep the servers as flexible as possible. In a future implementation, the Timecard servers might be hit by Active Server Pages, which would use VBScript to access the servers.</p>
<p>
All of the servers' methods provide an integer as the return value. If a server returns a value of one, then the server executed successfully. If the server experiences an unexpected error, it returns a zero. Finally, if a server experiences an expected error, it will return a negative error code. The list of error codes was decided early in the development cycle of the server, along with the contract over the method interface. </p>
<p>
In some cases, such as in GetTimeEntries with the DailyData parameter, arrays of data are returned to the client. There are several benefits to transporting data in this manner. First, it helps keep the number of parameters being passed in the method calls more manageable, thus simplifying life for client developers who are interacting with the servers. Second, it serves as a mechanism to return multiple records in one call. As shown in Figure 3, a stored procedure returns all the time entry information for an employee on a particular day. The server code iterates through the resultset and populates the returned data into an array. This array is sent back to the client application in the form of a variant; the client application then pulls the data from the array and populates a listview control. True to the MTS spirit of stateless servers, it performs the business logic in one quick blast. In a more traditional object model, the client application would iterate through a collection to retrieve a dataset. However, in the distributed world this would constitute a large number of network hits, causing the business server to be held in memory and consuming valuable resources for far too long.</p>
<p><img src="drgui.gif"></p>
<p><b>Figure 3</b></p>
<p>
One last benefit of passing data in arrays is that the server method interfaces can remain static when changes are <br>
made to pass additional information to and from the client. Currently, the GetTimeEntries server returns client code, project code, subproject code, actual hours worked, <br>
billable hours worked, a description, and a unique ID for <br>
each time entry. In the future, the server could be enhanced to track time entry information one layer lower in the client/project/subproject hierarchy by adding on a task category. By passing data back in an array, the server interface would remain the same. </p>
<p>
The server developer can simply increase the dimensions of the array by one and add the task code into this new slot. The server would be recompiled, and the existing server that is deployed through MTS would be replaced. All of the existing client applications would continue to run, unaffected by the changes because the server would still return all the required information. Client applications that utilize the new functionality of the server could then be released. Developing servers in this manner is helpful in environments where multiple versions of applications will be running at the same time or in situations where deployment of new client applications is not instantaneous.</p>
<p>
Other than the design issues noted previously, there are very few differences between developing a regular ActiveX server and an MTS server. The first step is to include a reference to the MTS 1.0 Type Library (mtxas.dll) in the Visual Basic project. Next, you obtain a reference to an object's context through the following code:</p>
<pre><code>Dim ctxObject As ObjectContext
Set ctxObject = GetObjectContext()
&lt;If logic completes successfully then&gt;
ctxObject.SetComplete
&lt;else&gt;
ctxObject.SetAbort</code></pre>
<p>
The context object contains state information that is implicitly associated with the MTS server. This includes information about the object's execution environment and any transactions that the object might be involved in. MTS automatically creates a context for each object as soon as it is created and manages this context for each object running within its environment. The context also allows the developer to affect how the object participates in a transaction. When the business server has completed its work and is ready to release the context, the developer can call either SetComplete or SetAbort. Each of these methods declare that the current object has completed its work and should be deactivated when its currently executing method returns to the client. Calling SetComplete causes any transaction the object is contained in to continue or to be committed. Calling SetAbort causes any transaction the object is contained in to abort.</p>
<p>
As stated earlier, MTS provides security roles (like Manager) that can be used to restrict usage of components or particular component interfaces as defined by the administrator. You can use the execution context of an object to determine whether the caller of the object lives in a particular MTS security role, as follows:</p>
<pre><code>Dim ctxObject As ObjectContext
Set ctxObject = GetObjectContext()
If Not ctxObject.IsCallerInRole("Manager") Then
<i>    &lt;Code that stops user from proceeding&gt;</i>
Else
<i>    &lt;Proceed with logic of server&gt;</i>
End If</code></pre>
<p>
The program checks to see if the caller is in the role of Manager; if so, the code will continue. However, if the caller isn't a Manager, the server returns an error code to the calling program stating that the caller doesn't have the appropriate rights to access this method.</p>
<h2>Testing/Debugging MTS Components</h2>
<p>
Although Part II of this article will cover client creation, it's important to show how easily you can use a business server running in MTS. The server developer will probably have to write a dummy application to test and debug the server; the only assumption the client developer has to consider is the fact that the MTS server application will be registered on the client machine and the server interface will remain static. Depending upon where the ActiveX server resides, COM (if local) or DCOM (if distributed) will handle the call to the server from the client.</p>
<p>
The code to call MTS components is identical to the code for calling regular ActiveX components. The client developer simply initializes a reference to the MTS component, calls its methods, and then releases the reference.</p>
<pre><code>Dim objTimeEntries As Object
Dim arTimeEntries As Variant

 Set objTimeEntries= _
     CreateObject("TimeEntries.clsTimeEntries")
 If objTimeEntries.GetTimeEntries(CurDate,                arTimeEntries, EmpID) Then
     &lt;Perform business logic&gt;
Else
     &lt;Handle error&gt;
End If  
Set objTimeEntries = Nothing</code></pre>
<p>
Debugging and testing the components can be a little tricky since they have to run inside of the MTS environment. It usually helps to create the server without any of the MTS components first, and then test it thoroughly. After you're satisfied that the server functions correctly, add the lines of MTS code and retest. When testing the servers, it also helps to create several dummy applications that remove any of the complexities and bugs of the client program. The server should be integrated with the client only after you are confident that the server is working properly. </p>
<h2>Deployment and Management</h2>
<p>
There are a number of options available when deciding how to effectively distribute the business servers. In the Timecard example, employees in corporate headquarters are on the same LAN as the database server and regional offices are connected to this database via the corporate WAN. Based on this network topology, an MTS server is installed on the same LAN as the database server for those users who are located at corporate headquarters. Each of the regional offices also has an <br>
MTS server set up on its LAN (see Figure 4). </p>
<p><img src="drgui.gif"></p>
<p><b>Figure 4</b></p>
<p>
The business components are deployed on each of these MTS servers. This distributes the load across the corporation and reduces some of the risks of downtime. If for some reason one of the MTS servers were to go down, it would only affect one office, not the whole company. If <br>
the database server goes down, the whole system comes to a screeching halt, but this is an acceptable risk <br>
for this particular system. It is possible to lessen the risk even further by replicating the database to each regional office.</p>
<p>
Setting up the MTS servers and deploying the business servers is relatively painless. Installing MTS on Windows NT® Server took less than five minutes, and it took an additional fifteen minutes to completely set up the business servers.</p>
<p>
All the distribution and management tasks associated with MTS are handled through the Transaction Server Explorer. The Transaction Server Explorer provides point-and-click wizards to help configure and administer packages, components, transactions, and security. </p>
<p>
The first step in setting up a group of business servers in MTS is creating a package. A package is a set of components that perform related application functions; all components in a package run together in the same MTS process. Additionally, a package is a trust boundary that defines when security credentials are verified, and serves as a deployment mechanism for a set of components. Figure 5 shows a package called Timecard. After the package is created, the administrator will register two components within the package: Projects and TimeEntries (see Figure 6). </p>
<p><img src="drgui.gif"></p>
<p><b>Figure 5</b></p>
<p><img src="drgui.gif"></p>
<p><b>Figure 6</b></p>
<p>
Beneath the Timecard package, each of the components is set up to include the Employee and Manager roles in its Role Membership, since these objects should be accessible by all groups within the company (see Figure 7). Then, the system administrator must add each of the system users to the appropriate roles through the standard Windows NT User/Group dialog (as shown in Figure 8).</p>
<p><img src="drgui.gif"></p>
<p><b>Figure 7</b></p>
<p><img src="drgui.gif"></p>
<p><b>Figure 8</b></p>
<p>
The last step is to set the Transaction Support property for each  component. As shown in Figure 9, the programmer has four transaction options for each server. These are discussed in Figure 10. The administrator can assign the appropriate transaction support by pulling up the properties for each of the servers. The Timecard servers are all set to Requires a transaction. This causes the servers to always run inside a transaction, creating a new one if none exist.</p>
<p><img src="drgui.gif"></p>
<p><b>Figure 9</b></p>
<p><img src="drgui.gif"></p>
<p><b>Figure 10</b></p>
<p>
After following these steps for setting up the MTS components, the servers are basically ready to go. The client developers of the Timecard system could begin to hit these servers and test their applications.</p>
<h2>Conclusion</h2>
<p>
Building solutions with MTS offers an alternative to the traditional two-tier client/server system. MTS serves as an object broker in the Microsoft DCOM world, providing fast and easy access to distributed business objects on a variety of platforms. ActiveX™ servers enjoy better performance and scalability when combined with MTS, due to MTS's JIT activation and ASAP deactivation. They also see improvements in database connection times due to ODBC 3.0. Microsoft DTC even allows MTS to distribute transactions across multiple databases with-out worrying about their types and locations.</p>
<p>
The programming model used to develop in the Microsoft n-tier DCOM world is powerful, yet flexible and fairly easy to implement. Both the clients and the business servers can be written in a variety of languages, allowing programmers to use the tools they have the most experience with. Once business objects have been created, they can be utilized by other client applications throughout the enterprise, thus decreasing development time and support costs. Microsoft COM and DCOM combined with MTS and new development tools provides a fast, flexible, and scalable model with which to build tomorrow's systems.                         </p>
</font></BODY>
</HTML>
