<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Cool Stuff in Visual C++ 5.0</title>
<BODY bgcolor=white>

<font face="Verdana">
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<form name=x><object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object></form>
<p><font size=5><b><a name="msdn_coolstuf"></a>Cool Stuff in Visual C++ 5.0</b></font></p>
<p>
Robert Coleridge<BR>MSDN Content Development Group</p>
<p><font size=4><b>Compiler Support for COM</b></font></p>
<p>
With the release of Microsoft&reg; Visual C++&reg; 5.0, Component Object Model (COM) programming just got easier. The compiler now has built-in support for many COM features. A few of the new COM features are discussed below.</p>
<p><b>#import Keyword</b></p>
<p>
Imagine being able to invoke methods on a third-party COM object as easily as you would any class you wrote yourself! This is the power that the #import keyword gives you. By specifying the name of a COM object, whether a DLL, .exe, or typelib, the compiler generates a header file and source for inline functions for accessing the COM object directly. The code generated is based on _com_ptr_t and throws _com_error exceptions even if the actual DLL or .exe does not. The days of wading through a type library just to write the interface signature declarations are over!</p>
<p><b>New COM Classes</b></p>
<p>
Along with some other fancy enhancements to the compiler come four new classes and templates that either enhance the #import keyword or simply make COM programming easier.</p>
<p>
<b>_com_ptr_t</b></p>
<p>
The _com_ptr_t class is a very powerful wrapper template for smart interface pointers. If you've done COM programming in the past, then you know how important it is to keep reference counts straight. Keeping reference counts straight is one of the most tedious problems to debug in COM. You no longer have this headache when you use _com_ptr_t. This simple template greatly simplifies all of the reference counting work for you. AddRef and Release are handled safely behind the scenes.</p>
<p>
<b>_com_error</b></p>
<p>
There is now a standard package to use when throwing COM exceptions: the _com_error package. This class encapsulates any HRESULT coming back from a COM function and any associated <b>IErrorInfo</b>. The _com_error package provides several COM methods for extracting requested information, such as the HRESULT, a text description of the error, and the fields from the <b>IErrorInfo</b> structure.</p>
<p>
<b>_variant_t and _bstr_t</b></p>
<p>
The COM specification defines the various data types that are <i>standard</i> to COM programming. If you need to pass a string, use a BSTR data type, and if you need to pass objects or <i>unknown</i> data use a VARIANT. Although these types are fundamental to COM programming, there has not been much support for them until now. These two data types are now easier to use with the new release of Visual C++, which uses the C++ classes _variant_t and _bstr_t.</p>
<p><font size=4><b>New Keywords</b></font></p>
<p><b>bool/true/false</b></p>
<p>
With the introduction of an integral Boolean data type (bool), the application size and, potentially, the size of your data get smaller. Boolean data types of the older type, BOOL, were defined as an unsigned short. BOOL was either 2- or 4-bytes long! What this meant was that any stored data records containing BOOLs took up extra space with leading zeros. If you did not write special code to trim the size of this data type that was stored out to disk, your data files suffered from excessive <i>empty</i> space. Now with the <i>bool</i> data type this <i>empty</i> space is minimized since a bool is only 1-byte long. With the introduction of the bool data type come its associated values: true and false. Note that these values are <i>not</i> the old values of TRUE and FALSE; however, at the present time they equate to the same value.</p>
<p><b>mutable</b></p>
<p>
The new storage class specifier, mutable, allows you to declare class member data as &quot;modifiable even in a const object.&quot; This allows you to distinguish between &quot;abstract const&quot; (const to the user) and &quot;concrete const&quot; (const to the implementation). </p>
<dl>
<dt>
This attribute has a number of possible uses. Here is a simple example of one: </dt>
<dd>
<pre><font face="new courier" size="4">class Object
{
public:
&#09;void x();
&#09;void y() const;
private:
&#09;int&#09;&#09;m1;
&#09;mutable int&#09;m2;
};
void Object::x()&#09;// Can always modify object.
{
&#09;m1 = 0;
&#09;m2 = 1;
}
void Object::y() const&#09;// Object is const.
{
&#09;// cannot modify m1
&#09;m2 = 2;&#09;&#09;// Can modify m2 because it is mutable.
}</font></pre>
</dd>
</dl>
<p><font size=4><b>MFC and the WinINet API</b></font></p>
<p>
With this release of Visual C++, the Microsoft Foundation Class (MFC) library encapsulates the WinINet application programming interface (API). What used to take a significant amount of coding and testing time now takes only a few minutes. In addition, you can reduce the number of WinINet API function calls to a single class invocation. There are currently a total of 13 new WinINet API classes in the MFC. Programming for the Web has never been easier.</p>
<p><font size=4><b>ATL 2.1 Compiler Optimization</b></font></p>
<p>
Be aware that ActiveX™ Template Library (ATL) 2.1 has been optimized for the Visual C++ 5.0 compiler. In particular, you should be aware that many ATL classes are declared with the <b>ATL_NO_VTABLE</b> macro. This has the effect of creating objects <i>without</i> vtables. For further information see the article in the ATL documentation titled &quot;Compiler Optimizations.&quot; Note that with this new release of ATL there are 39 new classes that facilitate control creation, seven renamed classes, and seven classes that have been dropped entirely.</p>
<p><font size=5><b>Tips and Tricks</b></font></p>
<p><font size=4><b>The New bool Data Type: When to Use It</b></font></p>
<p>
The introduction of internal support for Boolean data types in the newest release of Visual C++ prompts an interesting question: When should we use it? This arises from the discrepancy in size between the older BOOL type, which is 4 bytes long, and the new bool type, which is 1 byte long. If BOOL data has been stored to disk, then you need to retrieve it as a BOOL or convert the data. If BOOL data is being passed via pointer to another application or DLL, then receive the data as a BOOL.</p>
<p>
If the new application has no interaction with older BOOLs, then use the new bool type, since it is now integral to the compiler and can be optimized for.</p>
<p><font size=4><b>When is True Not True? When Doing Inter-Language Programming</b></font></p>
<p>
The difficulty here lies in inter-language support. In both Visual C++ and Visual Basic&reg; the value for false is zero, but the value for true is <i>not</i> the same in both languages! Visual C++ uses a positive one (1) and Visual Basic uses a negative one (–1)!</p>
<dl>
<dt>
This discrepancy can cause some conditional statements to fail when they should not. For example, suppose we have a COM object written in Visual C++, called &quot;Foo.&quot; It has one interface, called &quot;Bar,&quot; which returns a Boolean result. The problem can be easily seen with the following code:</dt>
<dd>
<pre><font face="new courier" size="4">dim bResult as Boolean

// This code will NOT work since Visual C++ and Visual Basic have differing 
// 'true' values.
bResult = Foo.Bar();
if bResult = True then
&#09;DoSomeThing();</font></pre>
<br>
</dd>
<dt>
This problem is identical when Visual C++ calls Visual Basic. However, there is a simple fix to this problem. Simply change the conditional to look like the following:</dt>
<dd>
<pre><font face="new courier" size="4">dim bResult as Boolean
// This code WILL work since both know that true does not equal 0.
bResult = Foo.Bar();
<b>if bResult then
&#09;DoSomeThing();</b></font></pre>
</dd>
</dl>
<p>
By making this small change in coding you can ensure that any code you write that deals with Boolean conditionals will have interlanguage operability.</p>
<p><font size=4><b>How to Make True = True</b></font></p>
<p>
Under Visual C++ version 4.2 and earlier, the data type BOOL was used to define Boolean data types and return codes. If an application that uses this data type is recompiled under Visual C++ 5.0, it will still function as expected but you may receive a warning that you did not receive before. You will definitely get this warning if you begin to mix and match the older BOOL with the newer built-in bool data type. The compiler is simply warning you that the optimization techniques it has for bool data types cannot be used, since the two data types are internally different.</p>
<dl>
<dt>
You can disable the warning with the following pragma:</dt>
<dd>
<pre><font face="new courier" size="4">#pragma warning (disable : 4800)&#09;// Turns off bool warning.</font></pre>
</dd>
</dl>
<p>
You should only disable the warning as a temporary solution, however. It would be better to change your BOOLs to bool, or not to mix and match the two.</p>
<p><font size=4><b>How to Use a Structure to Execute Code Before and After Your Main Code</b></font></p>
<p>
When using smart interface pointers from a template, it is often necessary to have certain code execute before and after the main program executes. For example, let's assume that you needed to have OLE initialized before your program started and have OLE uninitialize after your program is finished. The technique below demonstrates how to do this.</p>
<dl>
<dt>
Define a global structure that looks like the following:</dt>
<dd>
<pre><font face="new courier" size="4">struct OleInit
{
&#09;OleInit()&#09;
&#09;{
&#09;&#09; OleInitialize(NULL);
&#09;}
&#09;~OleInit()
&#09;{
&#09;&#09; OleUninitialize();
&#09;}
} Init_Ole;</font></pre>
</dd>
</dl>
<p>
Place the above code segment in your code <i>outside</i> of any function, for example above your main routine. Since this code is outside of any function, the constructor gets called <i>prior</i> to the main routine. Calling the constructor, in effect, calls the <b>OleInitialize</b> routine. At the end of the program's life the destructor is called, thus calling the <b>OleUninitialize</b> routine. This technique could be applied to any code that <i>must</i> be started prior to the main routine starting and any code that <i>must</i> run after the program is finished.</p>
</font></body>
</HTML>
