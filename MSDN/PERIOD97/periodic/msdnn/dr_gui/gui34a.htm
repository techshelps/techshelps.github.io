<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Throwing the good doctor for a loop...</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF" text="#000000">


<p><a name="msdn_gui34a"><font size="5" face="verdana"></font></a><font
size="5" face="verdana">Throwing the good doctor for a loop&#133;</font></p>

<h2><font size="2" face="verdana">Dear Dr. GUI,</font></h2>

<p><font size="2" face="verdana">Is it possible to drop into an
endless loop yet keep the Windows message loop pumping? I&#146;ve
always been told that this isn&#146;t possible, but hey,
you&#146;re Dr. GUI&#133; perhaps by making appropriate (API or
MFC) function calls from within the loop it is possible.</font></p>

<p><font size="2" face="verdana">Let&#146;s assume I have a good
reason (which I don&#146;t!) for wanting to do this. I realize
that normally a timer loop (calling <b>OnTimer())</b> would be
used instead of the endless loop.</font></p>

<p><font size="2" face="verdana"><i>Steven D. Lacy</i></font></p>

<h2><font size="2" face="verdana">Dr. GUI replies:</font></h2>

<p><font size="2" face="verdana">Kind of a loopy question, no?
Note that this is actually a common problem: any operation, such
as background printing, file I/O, or network I/O, that you&#146;d
like to run in the background will need to keep the message pump
going.</font></p>

<p><font size="2" face="verdana">Well, there are a couple of ways
to do this. Under Win32, the best way is to just spawn a new
thread so that your &#147;infinite loop&#148; is run in a
separate thread from the thread running the message pump. This
thread should probably be a worker thread&#151;it shouldn&#146;t
create any UI elements. And don&#146;t set the priority of this
background thread too high or you&#146;ll starve the system,
okay? Multithreaded programming brings up a lot of tough
issues&#151;read about them in the Win32 SDK documentation. Note
also that MFC supports multithreaded programming. Finally, note
that the thread will be killed when your process exits.</font></p>

<p><font size="2" face="verdana">Windows® 3.1<i>x</i>
doesn&#146;t support multiple threads, so you can&#146;t spawn
another thread to solve the problem. Therefore, you mustn&#146;t
go into an infinite loop, or you&#146;ll lock up the whole
system. However, you can do background processing by writing a
loop that, in addition to your background processing, frequently
calls <b>PeekMessage </b>to check for messages that are waiting.
When it gets messages, it must dispatch them. This non-preemptive
multitasking will result in jerky, slow performance, but it will
work. You can do this under Win32 as well, but I don&#146;t
recommend it unless it&#146;s just extraordinarily difficult to
make your code safe for multiple threads.</font></p>

<p><font size="2" face="verdana">And, in keeping with our Java
theme: if you&#146;re programming in Java,
rejoice&#151;multithreaded support is built into the Java
language. You still have to deal with the tough issues of more
than one thread modifying data at the same time, but you at least
get some solid support in both the language and run-time library
for doing it right.</font></p>
</font></body>
</html>
