<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Wicked Code</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF>

<font face="verdana,arial,helvetica" size="2">
<h1>Wicked Code</h1>
<p>Jeff Prosise</p>
<p>Jeff Prosise is  the author of Programming Windows 95 with MFC (Microsoft Press, 1996). He also teaches Visual C++/MFC programming seminars. For more information, visit <BR>http://www.solsem.com.</p>
<p></p>
<p>There’s an old axiom in the software industry that <BR>&#09;programmers won’t switch tools unless there’s a <BR>&#09;compelling reason for them to do so. Lately, more and more Windows&reg; SDK programmers are migrating to Visual C++&reg; and MFC for one reason and one reason only: MFC vastly simplifies the process of writing COM, OLE, and ActiveX™ applications. Writing COM, OLE, and ActiveX code without a good class library is about as much fun as a root canal. Maybe you enjoy having holes carved in your jawbone, but me, I’ll take the easy way out every time. I’d no sooner tackle ActiveX without MFC than say no when my dentist offers me the loopy gas.</p>
<p>MFC isn’t the best tool available for writing simple COM servers and clients, but it really shines when it comes to writing OLE and ActiveX document servers, Automation servers, and other applications that rely on the myriad protocols built on top of COM. MFC also makes it relatively easy to write applications that exchange data through the OLE clipboard and OLE drag and drop. Building a modern user interface means supporting drag and drop whenever and wherever possible. Even novice users find grabbing an object with the mouse and dragging it across the screen to be a clean, easy-to-execute, and for the most part intuitive operation.</p>
<p>This month, I’d like to share a fun little programming technique that will help you write better drag and drop code. The sample application I’ll present uses MFC, but the technique isn’t specific to MFC; it’s applicable to any language or development environment.</p>
<p>You’ve all seen drag and drop implementations that tack a little rectangle onto the cursor to represent whatever it is that’s being dragged. That’s good—for wimps. A really cool application draws an outline of the object (or objects) being dragged and moves the outline with the cursor. A good example of this behavior can be seen in the Microsoft Windows&reg; 95 and Windows NT&reg; 4.0 shells. Open a Windows Explorer window, group-select a bunch of files, and then drag the files to another folder. The shell paints a clear picture of what’s being dragged with a wireframe drag image silhouetting the files you selected (see Figure 1).</p>
<p><img src="wicked1.gif" border=0></p>
<p>Figure 1  Dragging files in Windows 95</p>
<p>I’ve received a number of email messages in recent months asking how the shell draws the drag image. Common sense says that there’s more to it than simply changing the cursor image because a cursor image is limited to 32&nbsp;¥&nbsp;32 pixels. I can’t tell you exactly how the shell does it because I haven’t seen the source code, but I can tell you how I’ve achieved a similar effect in my own applications. The secret is to let the drop target (not the drop source, which is where most people assume the image originates) draw the drag image.&nbsp;How? By including information de&shy;scribing how to draw the image in the OLE data object that links the drop source to the drop target. This information can take any form you’d like: a series of <i>x-y</i> coordinates describing the endpoints of lines, a list of private meta&shy;commands, or even a handle to an enhanced metafile. When the drop target’s IDropTarget::OnDragEnter function is called, the drop target can extract the information from the data object and use it to draw a drag image.</p>
<p>In the sample application presented in the next section, the drop target draws a drag image by creating a temporary object just like the one that’s being dragged and passing a CDC pointer (MFC’s equivalent of a device context handle) to the object’s DrawDragImage function. In other words, the object draws its own drag image. It makes sense when you think about it, because who knows what the object looks like better than the object itself?</p>
<h2>The WIDGET Application</h2>
<p>WIDGET is an SDI doc/view application that lets you create widgets of various shapes and colors (see Figure 2). Widgets are created with commands in the application’s Insert menu. Once created, they can be moved and copied using drag and drop. When a widget is dragged, WIDGET draws a drag image depicting the widget’s shape, which could be a circle, a triangle, or a square. You can drop a widget inside the application that created it or in another instance of WIDGET. To demonstrate, start two copies of WIDGET and insert a widget or two in instance A. Then grab a widget in instance A and release it over instance B. As if by magic, the widget will disappear from A and appear in B. (To copy a widget, repeat this procedure with the Ctrl key held down.) One of the strengths of OLE’s Uniform Data Transfer (UDT) model is that it is not limited by process boundaries. OLE drag and drop is a subset of UDT.</p>
<p><img src="wicked2.gif" border=0></p>
<p>Figure 2  Dragging a Widget</p>
<p>The code that makes all this work will seem pretty straight&shy;forward if you’re at all familiar with OLE drag and drop as implemented by MFC. WIDGET is both an OLE drop source and an OLE drop target. When a widget is clicked with the left mouse button, the view’s OnLButton&shy;Down handler initializes a global memory block (HGLOBAL) with data describing the widget. Then it creates a COle&shy;DataSource object, transfers the HGLOBAL to the data source by calling COleDataSource::Cache&shy;GlobalData, and calls COleDataSource::DoDragDrop to initiate a drag and drop data transfer. If DoDragDrop returns DROPEFFECT_<BR>MOVE, indicating the widget was moved rather than copied, WIDGET deletes the widget from the document.</p>
<p>On the flip side of the data transfer, WIDGET’s view registers itself as a drop target by creating a COleDrop&shy;Target object and calling COleDropTarget::Register. Calls to the drop target’s IDropTarget functions generate calls to the view’s OnDragEnter, OnDragOver, OnDragLeave, and OnDrop functions. WIDGET’s CWidgetView class implements OnDrop by calling COleDataObject::GetGlobalData to retrieve the HGLOBAL created by the drop source and calling the document’s AddWidget function to create a new widget from the data in the HGLOBAL.</p>
<p>When an object is transferred through OLE drag and drop, its type is identified with a clipboard format code. WIDGET uses ::RegisterClipboardFormat to register a private clipboard format for widgets. The format’s integer ID is stored in a public member variable named m_nFormat in the application object, and retrieved through the pointer returned by AfxGetApp.</p>
<p>You can see how all this is implemented by browsing the source code for WIDGET’s view class, which is reproduced along with other pertinent parts of the application’s source code in Figure 3. (The full source code and Visual C++ 5.0 project files may be downloaded from <i>MSJ</i>’s Web site at http://www.microsoft.com/msj and from the other sources listed on page 5.) However, what’s more interesting is how WIDGET draws drag images. As you drag a widget over a WIDGET window, notice that an outline of the widget travels with the cursor. The code responsible for drawing the drag image lies partly in the view class and partly in the classes that implement the widgets themselves. </p>
<p>Figure 3  WIDGET</p>
<h4>WidgView.h</h4>
<p>
// WidgView.h : interface of the CWidgetView class</p>
<p>
//</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
#if !defined(AFX_WIDGVIEW_H__877329C1_C22E_11D0_B2D8_444553540000__INCLUDED_)</p>
<p>
#define AFX_WIDGVIEW_H__877329C1_C22E_11D0_B2D8_444553540000__INCLUDED_</p>
<p>
#if _MSC_VER &gt;= 1000</p>
<p>
#pragma once</p>
<p>
#endif // _MSC_VER &gt;= 1000</p>
<p>
typedef struct tagWIDGETDATA {</p>
<p>
    int nType;      // Widget type (0=Circle, 1=Triangle, 2=Square)</p>
<p>
    RECT rcItem;    // Widget rectangle (logical coordinates)</p>
<p>
    POINT ptDrag;   // Drag point (logical coordinates)</p>
<p>
} WIDGETDATA;</p>
<p>
class CWidgetView : public CScrollView</p>
<p>
{</p>
<p>
protected: // create from serialization only</p>
<p>
    CWidgetView();</p>
<p>
    DECLARE_DYNCREATE(CWidgetView)</p>
<p>
// Attributes</p>
<p>
public:</p>
<p>
    CWidgetDoc* GetDocument();</p>
<p>
// Operations</p>
<p>
public:</p>
<p>
// Overrides</p>
<p>
    // ClassWizard generated virtual function overrides</p>
<p>
    //{{AFX_VIRTUAL(CWidgetView)</p>
<p>
    public:</p>
<p>
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view</p>
<p>
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);</p>
<p>
    virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, </p>
<p>
                                   CPoint point);</p>
<p>
    virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, </p>
<p>
                                  CPoint point);</p>
<p>
    virtual void OnDragLeave();</p>
<p>
    virtual BOOL OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect, </p>
<p>
                        CPoint point);</p>
<p>
    protected:</p>
<p>
    virtual void OnInitialUpdate(); // called first time after construct</p>
<p>
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);</p>
<p>
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);</p>
<p>
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);</p>
<p>
    //}}AFX_VIRTUAL</p>
<p>
// Implementation</p>
<p>
public:</p>
<p>
    virtual ~CWidgetView();</p>
<p>
#ifdef _DEBUG</p>
<p>
    virtual void AssertValid() const;</p>
<p>
    virtual void Dump(CDumpContext&amp; dc) const;</p>
<p>
#endif</p>
<p>
protected:</p>
<p>
// Generated message map functions</p>
<p>
protected:</p>
<p>
    int m_nWidget;</p>
<p>
    COleDropTarget m_oleDropTarget;</p>
<p>
    CPoint m_ptPrevPos;</p>
<p>
    CPoint m_ptOldImage;</p>
<p>
    CSize m_sizeDelta;</p>
<p>
    CWidget* m_pWidget;</p>
<p>
    //{{AFX_MSG(CWidgetView)</p>
<p>
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);</p>
<p>
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);</p>
<p>
    //}}AFX_MSG</p>
<p>
    DECLARE_MESSAGE_MAP()</p>
<p>
};</p>
<p>
#ifndef _DEBUG  // debug version in WidgView.cpp</p>
<p>
inline CWidgetDoc* CWidgetView::GetDocument()</p>
<p>
   { return (CWidgetDoc*)m_pDocument; }</p>
<p>
#endif</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
//{{AFX_INSERT_LOCATION}}</p>
<p>
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.</p>
<p>
#endif // !defined(AFX_WIDGVIEW_H__877329C1_C22E_11D0_B2D8_444553540000__INCLUDED_)</p>
<h4>WidgView.cpp</h4>
<p>
// WidgView.cpp : implementation of the CWidgetView class</p>
<p>
//</p>
<p>
#include &quot;stdafx.h&quot;</p>
<p>
#include &quot;Widget.h&quot;</p>
<p>
#include &quot;WidgBase.h&quot;</p>
<p>
#include &quot;Circle.h&quot;</p>
<p>
#include &quot;Triangle.h&quot;</p>
<p>
#include &quot;Square.h&quot;</p>
<p>
#include &quot;WidgDoc.h&quot;</p>
<p>
#include &quot;WidgView.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidgetView</p>
<p>
IMPLEMENT_DYNCREATE(CWidgetView, CScrollView)</p>
<p>
BEGIN_MESSAGE_MAP(CWidgetView, CScrollView)</p>
<p>
    //{{AFX_MSG_MAP(CWidgetView)</p>
<p>
    ON_WM_LBUTTONDOWN()</p>
<p>
    ON_WM_CREATE()</p>
<p>
    //}}AFX_MSG_MAP</p>
<p>
    // Standard printing commands</p>
<p>
    ON_COMMAND(ID_FILE_PRINT, CScrollView::OnFilePrint)</p>
<p>
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CScrollView::OnFilePrint)</p>
<p>
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CScrollView::OnFilePrintPreview)</p>
<p>
END_MESSAGE_MAP()</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidgetView construction/destruction</p>
<p>
CWidgetView::CWidgetView()</p>
<p>
{</p>
<p>
}</p>
<p>
CWidgetView::~CWidgetView()</p>
<p>
{</p>
<p>
}</p>
<p>
BOOL CWidgetView::PreCreateWindow(CREATESTRUCT&amp; cs)</p>
<p>
{</p>
<p>
    // TODO: Modify the Window class or styles here by modifying</p>
<p>
    //  the CREATESTRUCT cs</p>
<p>
    return CScrollView::PreCreateWindow(cs);</p>
<p>
}</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidgetView drawing</p>
<p>
void CWidgetView::OnDraw(CDC* pDC)</p>
<p>
{</p>
<p>
    CWidgetDoc* pDoc = GetDocument();</p>
<p>
    ASSERT_VALID(pDoc);</p>
<p>
    int nCount = pDoc-&gt;GetWidgetCount ();</p>
<p>
    if (nCount) {</p>
<p>
        for (int i=0; i&lt;nCount; i++)</p>
<p>
            pDoc-&gt;GetWidget (i)-&gt;Draw (pDC);</p>
<p>
    }</p>
<p>
}</p>
<p>
void CWidgetView::OnInitialUpdate()</p>
<p>
{</p>
<p>
    CScrollView::OnInitialUpdate();</p>
<p>
    CSize sizeTotal;</p>
<p>
    sizeTotal.cx = sizeTotal.cy = 1024;</p>
<p>
    SetScrollSizes(MM_TEXT, sizeTotal);</p>
<p>
    m_nWidget = -1;     // Index of the widget that's being dragged</p>
<p>
    m_pWidget = NULL;   // Pointer to temporary widget used in drag imaging</p>
<p>
}</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidgetView printing</p>
<p>
BOOL CWidgetView::OnPreparePrinting(CPrintInfo* pInfo)</p>
<p>
{</p>
<p>
    // default preparation</p>
<p>
    return DoPreparePrinting(pInfo);</p>
<p>
}</p>
<p>
void CWidgetView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)</p>
<p>
{</p>
<p>
    // TODO: add extra initialization before printing</p>
<p>
}</p>
<p>
void CWidgetView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)</p>
<p>
{</p>
<p>
    // TODO: add cleanup after printing</p>
<p>
}</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidgetView diagnostics</p>
<p>
#ifdef _DEBUG</p>
<p>
void CWidgetView::AssertValid() const</p>
<p>
{</p>
<p>
    CScrollView::AssertValid();</p>
<p>
}</p>
<p>
void CWidgetView::Dump(CDumpContext&amp; dc) const</p>
<p>
{</p>
<p>
    CScrollView::Dump(dc);</p>
<p>
}</p>
<p>
CWidgetDoc* CWidgetView::GetDocument() // non-debug version is inline</p>
<p>
{</p>
<p>
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CWidgetDoc)));</p>
<p>
    return (CWidgetDoc*)m_pDocument;</p>
<p>
}</p>
<p>
#endif //_DEBUG</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidgetView message handlers</p>
<p>
void CWidgetView::OnLButtonDown(UINT nFlags, CPoint point) </p>
<p>
{</p>
<p>
    CWidgetDoc* pDoc = GetDocument ();</p>
<p>
    int nCount = pDoc-&gt;GetWidgetCount ();</p>
<p>
    if (nCount) {</p>
<p>
        //</p>
<p>
        // Convert the click point to logical coordinates.</p>
<p>
        //</p>
<p>
        CClientDC dc (this);</p>
<p>
        OnPrepareDC (&amp;dc);</p>
<p>
        dc.DPtoLP (&amp;point);</p>
<p>
        //</p>
<p>
        // Find out whether a widget was clicked.</p>
<p>
        //</p>
<p>
        int i;</p>
<p>
        BOOL bHit = FALSE;</p>
<p>
        for (i=nCount - 1; i&gt;=0 &amp;&amp; !bHit; i--) {</p>
<p>
            CWidget* pWidget = pDoc-&gt;GetWidget (i);</p>
<p>
            if (pWidget-&gt;PtInWidget (point)) {</p>
<p>
                bHit = TRUE;</p>
<p>
            }</p>
<p>
        }</p>
<p>
        //</p>
<p>
        // If a widget was clicked, initiate a drag-drop operation.</p>
<p>
        //</p>
<p>
        if (bHit) {</p>
<p>
            m_nWidget = ++i;</p>
<p>
            HANDLE hData =</p>
<p>
                ::GlobalAlloc (GMEM_MOVEABLE | GMEM_SHARE, sizeof (WIDGETDATA));</p>
<p>
            WIDGETDATA* pWidgetData = (WIDGETDATA*) ::GlobalLock (hData);</p>
<p>
            CWidget* pWidget = pDoc-&gt;GetWidget (m_nWidget);</p>
<p>
            pWidgetData-&gt;nType = pWidget-&gt;GetType ();</p>
<p>
            pWidget-&gt;GetItemRect (&amp;pWidgetData-&gt;rcItem);</p>
<p>
            pWidgetData-&gt;ptDrag = point;</p>
<p>
            ::GlobalUnlock (hData);</p>
<p>
            COleDataSource ods;</p>
<p>
            UINT nFormat = ((CWidgetApp*) AfxGetApp ())-&gt;m_nFormat;</p>
<p>
            ods.CacheGlobalData (nFormat, hData);</p>
<p>
            DROPEFFECT de = ods.DoDragDrop (DROPEFFECT_COPY | DROPEFFECT_MOVE);</p>
<p>
            if (de == DROPEFFECT_MOVE) {</p>
<p>
                pDoc-&gt;RemoveWidget (m_nWidget);</p>
<p>
                pDoc-&gt;UpdateAllViews (NULL);</p>
<p>
            }</p>
<p>
            m_nWidget = -1;</p>
<p>
        }</p>
<p>
    }</p>
<p>
    CScrollView::OnLButtonDown(nFlags, point);</p>
<p>
}</p>
<p>
DROPEFFECT CWidgetView::OnDragEnter(COleDataObject* pDataObject,</p>
<p>
                                    DWORD dwKeyState, CPoint point) </p>
<p>
{</p>
<p>
    CScrollView::OnDragEnter(pDataObject, dwKeyState, point);</p>
<p>
    //</p>
<p>
    // Return now if the object being dragged is not a widget.</p>
<p>
    //</p>
<p>
    UINT nFormat = ((CWidgetApp*) AfxGetApp ())-&gt;m_nFormat;</p>
<p>
    if (!pDataObject-&gt;IsDataAvailable (nFormat))</p>
<p>
        return DROPEFFECT_NONE;</p>
<p>
    //</p>
<p>
    // Create a temporary widget for drag imaging.</p>
<p>
    //</p>
<p>
    HGLOBAL hData = pDataObject-&gt;GetGlobalData (nFormat);</p>
<p>
    WIDGETDATA* pWidgetData = (WIDGETDATA*) ::GlobalLock (hData);</p>
<p>
    int nType = pWidgetData-&gt;nType;</p>
<p>
    CRect rect = pWidgetData-&gt;rcItem;</p>
<p>
    CPoint pt = pWidgetData-&gt;ptDrag;</p>
<p>
    ::GlobalUnlock (hData);</p>
<p>
    switch (nType) {</p>
<p>
    case 0: // Circle</p>
<p>
        m_pWidget = new CCircle (rect);</p>
<p>
        break;</p>
<p>
    case 1: // Triangle</p>
<p>
        m_pWidget = new CTriangle (rect);</p>
<p>
        break;</p>
<p>
    case 2: // Square</p>
<p>
        m_pWidget = new CSquare (rect);</p>
<p>
        break;</p>
<p>
    default: // Just in case</p>
<p>
        return DROPEFFECT_NONE;</p>
<p>
    }</p>
<p>
    //</p>
<p>
    // Begin dragging.</p>
<p>
    //</p>
<p>
    CClientDC dc (this);</p>
<p>
    OnPrepareDC (&amp;dc);</p>
<p>
    dc.DPtoLP (&amp;point);</p>
<p>
    m_sizeDelta.cx = pt.x - rect.left;</p>
<p>
    m_sizeDelta.cy = pt.y - rect.top;</p>
<p>
    CPoint ptDrag (point.x - m_sizeDelta.cx, point.y - m_sizeDelta.cy);</p>
<p>
    m_ptOldImage.x = m_ptOldImage.y = -32000;</p>
<p>
    m_ptPrevPos = point;</p>
<p>
    return (dwKeyState &amp; MK_CONTROL) ? DROPEFFECT_COPY : DROPEFFECT_MOVE;</p>
<p>
}</p>
<p>
DROPEFFECT CWidgetView::OnDragOver(COleDataObject* pDataObject,</p>
<p>
                                   DWORD dwKeyState, CPoint point) </p>
<p>
{</p>
<p>
    CScrollView::OnDragOver(pDataObject, dwKeyState, point);</p>
<p>
    //</p>
<p>
    // Return now if the object being dragged is not a widget.</p>
<p>
    //</p>
<p>
    if (m_pWidget == NULL)</p>
<p>
        return DROPEFFECT_NONE;</p>
<p>
    //</p>
<p>
    // Erase the old drag image and draw a new one if the cursor has moved.</p>
<p>
    //</p>
<p>
    CClientDC dc (this);</p>
<p>
    OnPrepareDC (&amp;dc);</p>
<p>
    dc.DPtoLP (&amp;point);</p>
<p>
    if (point != m_ptPrevPos) {</p>
<p>
        m_pWidget-&gt;DrawDragImage (&amp;dc, m_ptOldImage);</p>
<p>
        CPoint ptDrag (point.x - m_sizeDelta.cx, point.y - m_sizeDelta.cy);</p>
<p>
        m_pWidget-&gt;DrawDragImage (&amp;dc, ptDrag);</p>
<p>
        m_ptOldImage = ptDrag;</p>
<p>
        m_ptPrevPos = point;</p>
<p>
    }</p>
<p>
    return (dwKeyState &amp; MK_CONTROL) ? DROPEFFECT_COPY : DROPEFFECT_MOVE;</p>
<p>
}</p>
<p>
void CWidgetView::OnDragLeave() </p>
<p>
{</p>
<p>
    CScrollView::OnDragLeave();</p>
<p>
    //</p>
<p>
    // Erase the old drag image and delete the temporary widget.</p>
<p>
    //</p>
<p>
    if (m_pWidget != NULL) {</p>
<p>
        CClientDC dc (this);</p>
<p>
        OnPrepareDC (&amp;dc);</p>
<p>
        m_pWidget-&gt;DrawDragImage (&amp;dc, m_ptOldImage);</p>
<p>
        delete m_pWidget;</p>
<p>
        m_pWidget = NULL;</p>
<p>
    }</p>
<p>
}</p>
<p>
BOOL CWidgetView::OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect,</p>
<p>
                         CPoint point) </p>
<p>
{</p>
<p>
    CScrollView::OnDrop(pDataObject, dropEffect, point);</p>
<p>
    //</p>
<p>
    // Convert point to logical coordinates.</p>
<p>
    //</p>
<p>
    CClientDC dc (this);</p>
<p>
    OnPrepareDC (&amp;dc);</p>
<p>
    dc.DPtoLP (&amp;point);</p>
<p>
    //</p>
<p>
    // Erase the old drag image and delete the temporary widget.</p>
<p>
    //</p>
<p>
    if (m_pWidget != NULL) {</p>
<p>
        m_pWidget-&gt;DrawDragImage (&amp;dc, m_ptOldImage);</p>
<p>
        delete m_pWidget;</p>
<p>
        m_pWidget = NULL;</p>
<p>
    }</p>
<p>
    //</p>
<p>
    // Retrieve the HGLOBAL from the data object.</p>
<p>
    //</p>
<p>
    UINT nFormat = ((CWidgetApp*) AfxGetApp ())-&gt;m_nFormat;</p>
<p>
    HGLOBAL hData = pDataObject-&gt;GetGlobalData (nFormat);</p>
<p>
    if (hData == NULL)</p>
<p>
        return FALSE;</p>
<p>
    //</p>
<p>
    // Create a widget from the data in the HGLOBAL.</p>
<p>
    //</p>
<p>
    WIDGETDATA* pWidgetData = (WIDGETDATA*) ::GlobalLock (hData);</p>
<p>
    int nType = pWidgetData-&gt;nType;</p>
<p>
    CRect rect = pWidgetData-&gt;rcItem;</p>
<p>
    ::GlobalUnlock (hData);</p>
<p>
    CRect rcItem;</p>
<p>
    rcItem.left = point.x - m_sizeDelta.cx;</p>
<p>
    rcItem.top = point.y - m_sizeDelta.cy;</p>
<p>
    rcItem.right = rcItem.left + rect.Width ();</p>
<p>
    rcItem.bottom = rcItem.top + rect.Height ();</p>
<p>
    CWidgetDoc* pDoc = GetDocument ();</p>
<p>
    pDoc-&gt;AddWidget (nType, &amp;rcItem);</p>
<p>
    pDoc-&gt;UpdateAllViews (NULL);</p>
<p>
    return TRUE;</p>
<p>
}</p>
<p>
int CWidgetView::OnCreate(LPCREATESTRUCT lpCreateStruct) </p>
<p>
{</p>
<p>
    if (CScrollView::OnCreate(lpCreateStruct) == -1)</p>
<p>
        return -1;</p>
<p>
    </p>
<p>
    m_oleDropTarget.Register (this);</p>
<p>
    return 0;</p>
<p>
}</p>
<h4>WidgDoc.h</h4>
<p>
// WidgDoc.h : interface of the CWidgetDoc class</p>
<p>
//</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
#if !defined(AFX_WIDGDOC_H__877329BF_C22E_11D0_B2D8_444553540000__INCLUDED_)</p>
<p>
#define AFX_WIDGDOC_H__877329BF_C22E_11D0_B2D8_444553540000__INCLUDED_</p>
<p>
#if _MSC_VER &gt;= 1000</p>
<p>
#pragma once</p>
<p>
#endif // _MSC_VER &gt;= 1000</p>
<p>
class CWidgetDoc : public CDocument</p>
<p>
{</p>
<p>
protected: // create from serialization only</p>
<p>
    CWidgetDoc();</p>
<p>
    DECLARE_DYNCREATE(CWidgetDoc)</p>
<p>
// Attributes</p>
<p>
public:</p>
<p>
// Operations</p>
<p>
public:</p>
<p>
// Overrides</p>
<p>
    // ClassWizard generated virtual function overrides</p>
<p>
    //{{AFX_VIRTUAL(CWidgetDoc)</p>
<p>
    public:</p>
<p>
    virtual BOOL OnNewDocument();</p>
<p>
    virtual void Serialize(CArchive&amp; ar);</p>
<p>
    virtual void DeleteContents();</p>
<p>
    //}}AFX_VIRTUAL</p>
<p>
// Implementation</p>
<p>
public:</p>
<p>
    BOOL RemoveWidget (int nIndex);</p>
<p>
    int AddWidget (int nType, LPCRECT pRect);</p>
<p>
    CWidget* GetWidget (int nIndex);</p>
<p>
    int GetWidgetCount ();</p>
<p>
    virtual ~CWidgetDoc();</p>
<p>
#ifdef _DEBUG</p>
<p>
    virtual void AssertValid() const;</p>
<p>
    virtual void Dump(CDumpContext&amp; dc) const;</p>
<p>
#endif</p>
<p>
protected:</p>
<p>
// Generated message map functions</p>
<p>
protected:</p>
<p>
    CObArray m_aWidgets;</p>
<p>
    //{{AFX_MSG(CWidgetDoc)</p>
<p>
    afx_msg void OnInsertTriangle();</p>
<p>
    afx_msg void OnInsertCircle();</p>
<p>
    afx_msg void OnInsertSquare();</p>
<p>
    //}}AFX_MSG</p>
<p>
    DECLARE_MESSAGE_MAP()</p>
<p>
};</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
//{{AFX_INSERT_LOCATION}}</p>
<p>
// Microsoft Developer Studio will insert additional declarations immediately </p>
<p>
// before the previous line.</p>
<p>
#endif // !defined(AFX_WIDGDOC_H__877329BF_C22E_11D0_B2D8_444553540000__INCLUDED_)</p>
<h4>WidgDoc.cpp</h4>
<p>
// WidgDoc.cpp : implementation of the CWidgetDoc class</p>
<p>
//</p>
<p>
#include &quot;stdafx.h&quot;</p>
<p>
#include &quot;Widget.h&quot;</p>
<p>
#include &quot;WidgBase.h&quot;</p>
<p>
#include &quot;Circle.h&quot;</p>
<p>
#include &quot;Triangle.h&quot;</p>
<p>
#include &quot;Square.h&quot;</p>
<p>
#include &quot;WidgDoc.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidgetDoc</p>
<p>
IMPLEMENT_DYNCREATE(CWidgetDoc, CDocument)</p>
<p>
BEGIN_MESSAGE_MAP(CWidgetDoc, CDocument)</p>
<p>
    //{{AFX_MSG_MAP(CWidgetDoc)</p>
<p>
    ON_COMMAND(ID_INSERT_TRIANGLE, OnInsertTriangle)</p>
<p>
    ON_COMMAND(ID_INSERT_CIRCLE, OnInsertCircle)</p>
<p>
    ON_COMMAND(ID_INSERT_SQUARE, OnInsertSquare)</p>
<p>
    //}}AFX_MSG_MAP</p>
<p>
END_MESSAGE_MAP()</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidgetDoc construction/destruction</p>
<p>
CWidgetDoc::CWidgetDoc()</p>
<p>
{</p>
<p>
    // TODO: add one-time construction code here</p>
<p>
}</p>
<p>
CWidgetDoc::~CWidgetDoc()</p>
<p>
{</p>
<p>
}</p>
<p>
BOOL CWidgetDoc::OnNewDocument()</p>
<p>
{</p>
<p>
    if (!CDocument::OnNewDocument())</p>
<p>
        return FALSE;</p>
<p>
    m_aWidgets.SetSize (0, 16);</p>
<p>
    return TRUE;</p>
<p>
}</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidgetDoc serialization</p>
<p>
void CWidgetDoc::Serialize(CArchive&amp; ar)</p>
<p>
{</p>
<p>
    m_aWidgets.Serialize (ar);</p>
<p>
}</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidgetDoc diagnostics</p>
<p>
#ifdef _DEBUG</p>
<p>
void CWidgetDoc::AssertValid() const</p>
<p>
{</p>
<p>
    CDocument::AssertValid();</p>
<p>
}</p>
<p>
void CWidgetDoc::Dump(CDumpContext&amp; dc) const</p>
<p>
{</p>
<p>
    CDocument::Dump(dc);</p>
<p>
}</p>
<p>
#endif //_DEBUG</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidgetDoc commands</p>
<p>
void CWidgetDoc::OnInsertCircle() </p>
<p>
{</p>
<p>
    AddWidget (0, CRect (10, 10, 100, 100));</p>
<p>
    UpdateAllViews (NULL);</p>
<p>
}</p>
<p>
void CWidgetDoc::OnInsertTriangle() </p>
<p>
{</p>
<p>
    AddWidget (1, CRect (10, 10, 100, 100));</p>
<p>
    UpdateAllViews (NULL);</p>
<p>
}</p>
<p>
void CWidgetDoc::OnInsertSquare() </p>
<p>
{</p>
<p>
    AddWidget (2, CRect (10, 10, 100, 100));</p>
<p>
    UpdateAllViews (NULL);</p>
<p>
}</p>
<p>
void CWidgetDoc::DeleteContents() </p>
<p>
{</p>
<p>
    int nCount = m_aWidgets.GetSize ();</p>
<p>
    while (nCount--)</p>
<p>
        delete m_aWidgets[nCount];</p>
<p>
    m_aWidgets.RemoveAll ();</p>
<p>
    </p>
<p>
    CDocument::DeleteContents();</p>
<p>
}</p>
<p>
int CWidgetDoc::GetWidgetCount()</p>
<p>
{</p>
<p>
    return m_aWidgets.GetSize ();</p>
<p>
}</p>
<p>
CWidget* CWidgetDoc::GetWidget(int nIndex)</p>
<p>
{</p>
<p>
    if (nIndex &gt; (m_aWidgets.GetSize () - 1))</p>
<p>
        return NULL;</p>
<p>
    return (CWidget*) m_aWidgets[nIndex];</p>
<p>
}</p>
<p>
int CWidgetDoc::AddWidget(int nType, LPCRECT pRect)</p>
<p>
{</p>
<p>
    int nIndex;</p>
<p>
    CWidget* pWidget;</p>
<p>
    try {</p>
<p>
        switch (nType) {</p>
<p>
        case 0: // Circle widget</p>
<p>
            pWidget = new CCircle (pRect);</p>
<p>
            break;</p>
<p>
        case 1: // Triangle widget</p>
<p>
            pWidget = new CTriangle (pRect);</p>
<p>
            break;</p>
<p>
        case 2: // Square widget</p>
<p>
            pWidget = new CSquare (pRect);</p>
<p>
            break;</p>
<p>
        }</p>
<p>
        nIndex = m_aWidgets.Add (pWidget);  </p>
<p>
    }</p>
<p>
    catch (CMemoryException* e) {</p>
<p>
        AfxMessageBox (&quot;Out of memory&quot;);</p>
<p>
        if (pWidget != NULL)</p>
<p>
            delete pWidget;</p>
<p>
        e-&gt;Delete ();</p>
<p>
        return -1;</p>
<p>
    }</p>
<p>
    SetModifiedFlag ();</p>
<p>
    return nIndex;</p>
<p>
}</p>
<p>
BOOL CWidgetDoc::RemoveWidget(int nIndex)</p>
<p>
{</p>
<p>
    if (nIndex &gt;= m_aWidgets.GetSize ())</p>
<p>
        return FALSE;</p>
<p>
    delete m_aWidgets[nIndex];</p>
<p>
    m_aWidgets.RemoveAt (nIndex);</p>
<p>
    return TRUE;</p>
<p>
}</p>
<h4>Circle.h</h4>
<p>
#if !defined(AFX_CIRCLE_H__877329CB_C22E_11D0_B2D8_444553540001__INCLUDED_)</p>
<p>
#define AFX_CIRCLE_H__877329CB_C22E_11D0_B2D8_444553540001__INCLUDED_</p>
<p>
#if _MSC_VER &gt;= 1000</p>
<p>
#pragma once</p>
<p>
#endif // _MSC_VER &gt;= 1000</p>
<p>
// Circle.h : header file</p>
<p>
//</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CCircle</p>
<p>
class CCircle : public CWidget</p>
<p>
{</p>
<p>
    DECLARE_SERIAL(CCircle)</p>
<p>
    CCircle();           // protected constructor used by dynamic creation</p>
<p>
// Attributes</p>
<p>
public:</p>
<p>
// Operations</p>
<p>
public:</p>
<p>
    virtual ~CCircle();</p>
<p>
    virtual int GetType ();</p>
<p>
    CCircle (LPCRECT pRect);</p>
<p>
    CCircle (int left, int top, int right, int bottom);</p>
<p>
    virtual BOOL PtInWidget (POINT point);</p>
<p>
    virtual void DrawDragImage (CDC* pDC, POINT point);</p>
<p>
    virtual void Draw (CDC* pDC);</p>
<p>
// Overrides</p>
<p>
    // ClassWizard generated virtual function overrides</p>
<p>
    //{{AFX_VIRTUAL(CCircle)</p>
<p>
    //}}AFX_VIRTUAL</p>
<p>
    virtual void Serialize (CArchive&amp; ar);</p>
<p>
// Implementation</p>
<p>
protected:</p>
<p>
    // Generated message map functions</p>
<p>
    //{{AFX_MSG(CCircle)</p>
<p>
        // NOTE - the ClassWizard will add and remove member functions here.</p>
<p>
    //}}AFX_MSG</p>
<p>
    DECLARE_MESSAGE_MAP()</p>
<p>
};</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
//{{AFX_INSERT_LOCATION}}</p>
<p>
// Microsoft Developer Studio will insert additional declarations immediately </p>
<p>
// before the previous line.</p>
<p>
#endif // !defined(AFX_CIRCLE_H__877329CB_C22E_11D0_B2D8_444553540001__INCLUDED_)</p>
<h4>Circle.cpp</h4>
<p>
// Circle.cpp : implementation file</p>
<p>
//</p>
<p>
#include &quot;stdafx.h&quot;</p>
<p>
#include &quot;Widget.h&quot;</p>
<p>
#include &quot;WidgBase.h&quot;</p>
<p>
#include &quot;Circle.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CCircle</p>
<p>
IMPLEMENT_SERIAL(CCircle, CWidget, 1)</p>
<p>
CCircle::CCircle()</p>
<p>
{</p>
<p>
}</p>
<p>
CCircle::CCircle (LPCRECT pRect)</p>
<p>
{</p>
<p>
    m_rect = *pRect;</p>
<p>
}</p>
<p>
CCircle::CCircle (int left, int top, int right, int bottom)</p>
<p>
{</p>
<p>
    m_rect.SetRect (left, top, right, bottom);</p>
<p>
}</p>
<p>
CCircle::~CCircle()</p>
<p>
{</p>
<p>
}</p>
<p>
BEGIN_MESSAGE_MAP(CCircle, CWidget)</p>
<p>
    //{{AFX_MSG_MAP(CCircle)</p>
<p>
        // NOTE - the ClassWizard will add and remove mapping macros here.</p>
<p>
    //}}AFX_MSG_MAP</p>
<p>
END_MESSAGE_MAP()</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CCircle message handlers</p>
<p>
void CCircle::Draw(CDC * pDC)</p>
<p>
{</p>
<p>
    CBrush brush (RGB (255, 255, 0)); // Yellow</p>
<p>
    CBrush* pOldBrush = pDC-&gt;SelectObject (&amp;brush);</p>
<p>
    pDC-&gt;Ellipse (m_rect);</p>
<p>
    pDC-&gt;SelectObject (pOldBrush);</p>
<p>
}</p>
<p>
void CCircle::DrawDragImage(CDC * pDC, POINT point)</p>
<p>
{</p>
<p>
    int nOldMode = pDC-&gt;SetROP2 (R2_NOT);</p>
<p>
    CBrush* pOldBrush = (CBrush*) pDC-&gt;SelectStockObject (NULL_BRUSH);</p>
<p>
    pDC-&gt;Ellipse (point.x, point.y,</p>
<p>
                  point.x + m_rect.Width (),</p>
<p>
                  point.y + m_rect.Height ());</p>
<p>
    pDC-&gt;SelectObject (pOldBrush);</p>
<p>
    pDC-&gt;SetROP2 (nOldMode);</p>
<p>
}</p>
<p>
BOOL CCircle::PtInWidget(POINT point)</p>
<p>
{</p>
<p>
    if (!m_rect.PtInRect (point))</p>
<p>
        return FALSE;</p>
<p>
    CPoint ptCenter;</p>
<p>
    ptCenter.x = m_rect.left + (m_rect.Width () / 2);</p>
<p>
    ptCenter.y = m_rect.top + (m_rect.Height () / 2);</p>
<p>
    int cx = point.x - ptCenter.x;</p>
<p>
    int cy = point.y - ptCenter.y;</p>
<p>
    if ((cx * cx) + (cy * cy) &lt;</p>
<p>
        (m_rect.Width () / 2) * (m_rect.Width () / 2))</p>
<p>
        return TRUE;</p>
<p>
    return FALSE;</p>
<p>
}</p>
<p>
int CCircle::GetType()</p>
<p>
{</p>
<p>
    return 0; // Circle</p>
<p>
}</p>
<p>
void CCircle::Serialize (CArchive&amp; ar)</p>
<p>
{</p>
<p>
    CWidget::Serialize (ar);</p>
<p>
    if (ar.IsStoring ())</p>
<p>
        ar &lt;&lt; m_rect;</p>
<p>
    else</p>
<p>
        ar &gt;&gt; m_rect;</p>
<p>
}</p>
<h4>Triangle.h</h4>
<p>
#if !defined(AFX_TRIANGLE_H__877329CB_C22E_11D0_B2D8_444553540000__INCLUDED_)</p>
<p>
#define AFX_TRIANGLE_H__877329CB_C22E_11D0_B2D8_444553540000__INCLUDED_</p>
<p>
#if _MSC_VER &gt;= 1000</p>
<p>
#pragma once</p>
<p>
#endif // _MSC_VER &gt;= 1000</p>
<p>
// Triangle.h : header file</p>
<p>
//</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CTriangle</p>
<p>
class CTriangle : public CWidget</p>
<p>
{</p>
<p>
    DECLARE_SERIAL(CTriangle)</p>
<p>
    CTriangle();           // protected constructor used by dynamic creation</p>
<p>
// Attributes</p>
<p>
public:</p>
<p>
// Operations</p>
<p>
public:</p>
<p>
    virtual ~CTriangle();</p>
<p>
    virtual int GetType ();</p>
<p>
    CTriangle (LPCRECT pRect);</p>
<p>
    CTriangle (int left, int top, int right, int bottom);</p>
<p>
    virtual BOOL PtInWidget (POINT point);</p>
<p>
    virtual void DrawDragImage (CDC* pDC, POINT point);</p>
<p>
    virtual void Draw (CDC* pDC);</p>
<p>
// Overrides</p>
<p>
    // ClassWizard generated virtual function overrides</p>
<p>
    //{{AFX_VIRTUAL(CTriangle)</p>
<p>
    //}}AFX_VIRTUAL</p>
<p>
    virtual void Serialize (CArchive&amp; ar);</p>
<p>
// Implementation</p>
<p>
protected:</p>
<p>
    // Generated message map functions</p>
<p>
    //{{AFX_MSG(CTriangle)</p>
<p>
        // NOTE - the ClassWizard will add and remove member functions here.</p>
<p>
    //}}AFX_MSG</p>
<p>
    DECLARE_MESSAGE_MAP()</p>
<p>
};</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
//{{AFX_INSERT_LOCATION}}</p>
<p>
// Microsoft Developer Studio will insert additional declarations immediately </p>
<p>
// before the previous line.</p>
<p>
#endif // !defined(AFX_TRIANGLE_H__877329CB_C22E_11D0_B2D8_444553540000__INCLUDED_)</p>
<h4>Triangle.cpp</h4>
<p>
// Triangle.cpp : implementation file</p>
<p>
//</p>
<p>
#include &quot;stdafx.h&quot;</p>
<p>
#include &quot;Widget.h&quot;</p>
<p>
#include &quot;WidgBase.h&quot;</p>
<p>
#include &quot;Triangle.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CTriangle</p>
<p>
IMPLEMENT_SERIAL(CTriangle, CWidget, 1)</p>
<p>
CTriangle::CTriangle()</p>
<p>
{</p>
<p>
}</p>
<p>
CTriangle::CTriangle (LPCRECT pRect)</p>
<p>
{</p>
<p>
    m_rect = *pRect;</p>
<p>
}</p>
<p>
CTriangle::CTriangle (int left, int top, int right, int bottom)</p>
<p>
{</p>
<p>
    m_rect.SetRect (left, top, right, bottom);</p>
<p>
}</p>
<p>
CTriangle::~CTriangle()</p>
<p>
{</p>
<p>
}</p>
<p>
BEGIN_MESSAGE_MAP(CTriangle, CWidget)</p>
<p>
    //{{AFX_MSG_MAP(CTriangle)</p>
<p>
        // NOTE - the ClassWizard will add and remove mapping macros here.</p>
<p>
    //}}AFX_MSG_MAP</p>
<p>
END_MESSAGE_MAP()</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CTriangle message handlers</p>
<p>
void CTriangle::Draw(CDC * pDC)</p>
<p>
{</p>
<p>
    CBrush brush (RGB (0, 0, 255)); // Blue</p>
<p>
    CBrush* pOldBrush = pDC-&gt;SelectObject (&amp;brush);</p>
<p>
    CPoint points[3];</p>
<p>
    points[0].x = m_rect.left;</p>
<p>
    points[0].y = m_rect.bottom;</p>
<p>
    points[1].x = m_rect.left + ((m_rect.right - m_rect.left) / 2);</p>
<p>
    points[1].y = m_rect.top;</p>
<p>
    points[2].x = m_rect.right;</p>
<p>
    points[2].y = m_rect.bottom;</p>
<p>
    pDC-&gt;Polygon (points, 3);</p>
<p>
    pDC-&gt;SelectObject (pOldBrush);</p>
<p>
}</p>
<p>
void CTriangle::DrawDragImage(CDC * pDC, POINT point)</p>
<p>
{</p>
<p>
    int nOldMode = pDC-&gt;SetROP2 (R2_NOT);</p>
<p>
    CBrush* pOldBrush = (CBrush*) pDC-&gt;SelectStockObject (NULL_BRUSH);</p>
<p>
    CPoint points[3];</p>
<p>
    points[0].x = point.x;</p>
<p>
    points[0].y = point.y + m_rect.Height ();</p>
<p>
    points[1].x = point.x + (m_rect.Width () / 2);</p>
<p>
    points[1].y = point.y;</p>
<p>
    points[2].x = point.x + m_rect.Width ();</p>
<p>
    points[2].y = point.y + m_rect.Height ();</p>
<p>
    pDC-&gt;Polygon (points, 3);</p>
<p>
    pDC-&gt;SelectObject (pOldBrush);</p>
<p>
    pDC-&gt;SetROP2 (nOldMode);</p>
<p>
}</p>
<p>
BOOL CTriangle::PtInWidget(POINT point)</p>
<p>
{</p>
<p>
    if (!m_rect.PtInRect (point))</p>
<p>
        return FALSE;</p>
<p>
    int cx = min (point.x - m_rect.left, m_rect.right - point.x);</p>
<p>
    return ((m_rect.bottom - point.y) &lt;= (2 * cx));</p>
<p>
}</p>
<p>
int CTriangle::GetType()</p>
<p>
{</p>
<p>
    return 1; // Triangle</p>
<p>
}</p>
<p>
void CTriangle::Serialize (CArchive&amp; ar)</p>
<p>
{</p>
<p>
    CWidget::Serialize (ar);</p>
<p>
    if (ar.IsStoring ())</p>
<p>
        ar &lt;&lt; m_rect;</p>
<p>
    else</p>
<p>
        ar &gt;&gt; m_rect;</p>
<p>
}</p>
<h4>Square.h</h4>
<p>
#if !defined(AFX_SQUARE_H__877329CB_C22E_11D0_B2D8_444553540002__INCLUDED_)</p>
<p>
#define AFX_SQUARE_H__877329CB_C22E_11D0_B2D8_444553540002__INCLUDED_</p>
<p>
#if _MSC_VER &gt;= 1000</p>
<p>
#pragma once</p>
<p>
#endif // _MSC_VER &gt;= 1000</p>
<p>
// Square.h : header file</p>
<p>
//</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CSquare</p>
<p>
class CSquare : public CWidget</p>
<p>
{</p>
<p>
    DECLARE_SERIAL(CSquare)</p>
<p>
    CSquare();           // protected constructor used by dynamic creation</p>
<p>
// Attributes</p>
<p>
public:</p>
<p>
// Operations</p>
<p>
public:</p>
<p>
    virtual ~CSquare();</p>
<p>
    virtual int GetType ();</p>
<p>
    CSquare (LPCRECT pRect);</p>
<p>
    CSquare (int left, int top, int right, int bottom);</p>
<p>
    virtual BOOL PtInWidget (POINT point);</p>
<p>
    virtual void DrawDragImage (CDC* pDC, POINT point);</p>
<p>
    virtual void Draw (CDC* pDC);</p>
<p>
// Overrides</p>
<p>
    // ClassWizard generated virtual function overrides</p>
<p>
    //{{AFX_VIRTUAL(CSquare)</p>
<p>
    //}}AFX_VIRTUAL</p>
<p>
    virtual void Serialize (CArchive&amp; ar);</p>
<p>
// Implementation</p>
<p>
protected:</p>
<p>
    // Generated message map functions</p>
<p>
    //{{AFX_MSG(CSquare)</p>
<p>
        // NOTE - the ClassWizard will add and remove member functions here.</p>
<p>
    //}}AFX_MSG</p>
<p>
    DECLARE_MESSAGE_MAP()</p>
<p>
};</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
//{{AFX_INSERT_LOCATION}}</p>
<p>
// Microsoft Developer Studio will insert additional declarations immediately </p>
<p>
// before the previous line.</p>
<p>
#endif // !defined(AFX_SQUARE_H__877329CB_C22E_11D0_B2D8_444553540002__INCLUDED_)</p>
<h4>Square.cpp</h4>
<p>
// Square.cpp : implementation file</p>
<p>
//</p>
<p>
#include &quot;stdafx.h&quot;</p>
<p>
#include &quot;Widget.h&quot;</p>
<p>
#include &quot;WidgBase.h&quot;</p>
<p>
#include &quot;Square.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CSquare</p>
<p>
IMPLEMENT_SERIAL(CSquare, CWidget, 1)</p>
<p>
CSquare::CSquare()</p>
<p>
{</p>
<p>
}</p>
<p>
CSquare::CSquare (LPCRECT pRect)</p>
<p>
{</p>
<p>
    m_rect = *pRect;</p>
<p>
}</p>
<p>
CSquare::CSquare (int left, int top, int right, int bottom)</p>
<p>
{</p>
<p>
    m_rect.SetRect (left, top, right, bottom);</p>
<p>
}</p>
<p>
CSquare::~CSquare()</p>
<p>
{</p>
<p>
}</p>
<p>
BEGIN_MESSAGE_MAP(CSquare, CWidget)</p>
<p>
    //{{AFX_MSG_MAP(CSquare)</p>
<p>
        // NOTE - the ClassWizard will add and remove mapping macros here.</p>
<p>
    //}}AFX_MSG_MAP</p>
<p>
END_MESSAGE_MAP()</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CSquare message handlers</p>
<p>
void CSquare::Draw(CDC * pDC)</p>
<p>
{</p>
<p>
    CBrush brush (RGB (255, 0, 0)); // Red</p>
<p>
    CBrush* pOldBrush = pDC-&gt;SelectObject (&amp;brush);</p>
<p>
    pDC-&gt;Rectangle (m_rect);</p>
<p>
    pDC-&gt;SelectObject (pOldBrush);</p>
<p>
}</p>
<p>
void CSquare::DrawDragImage(CDC * pDC, POINT point)</p>
<p>
{</p>
<p>
    int nOldMode = pDC-&gt;SetROP2 (R2_NOT);</p>
<p>
    CBrush* pOldBrush = (CBrush*) pDC-&gt;SelectStockObject (NULL_BRUSH);</p>
<p>
    pDC-&gt;Rectangle (point.x, point.y,</p>
<p>
                    point.x + m_rect.Width (),</p>
<p>
                    point.y + m_rect.Height ());</p>
<p>
    pDC-&gt;SelectObject (pOldBrush);</p>
<p>
    pDC-&gt;SetROP2 (nOldMode);</p>
<p>
}</p>
<p>
BOOL CSquare::PtInWidget(POINT point)</p>
<p>
{</p>
<p>
    return m_rect.PtInRect (point);</p>
<p>
}</p>
<p>
int CSquare::GetType()</p>
<p>
{</p>
<p>
    return 2; // Square</p>
<p>
}</p>
<p>
void CSquare::Serialize (CArchive&amp; ar)</p>
<p>
{</p>
<p>
    CWidget::Serialize (ar);</p>
<p>
    if (ar.IsStoring ())</p>
<p>
        ar &lt;&lt; m_rect;</p>
<p>
    else</p>
<p>
        ar &gt;&gt; m_rect;</p>
<p>
}</p>
<h4>WidgBase.h</h4>
<p>
#if !defined(AFX_WIDGBASE_H__877329CA_C22E_11D0_B2D8_444553540000__INCLUDED_)</p>
<p>
#define AFX_WIDGBASE_H__877329CA_C22E_11D0_B2D8_444553540000__INCLUDED_</p>
<p>
#if _MSC_VER &gt;= 1000</p>
<p>
#pragma once</p>
<p>
#endif // _MSC_VER &gt;= 1000</p>
<p>
// WidgBase.h : header file</p>
<p>
//</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidget command target</p>
<p>
class CWidget : public CCmdTarget</p>
<p>
{</p>
<p>
    DECLARE_DYNCREATE(CWidget)</p>
<p>
    CWidget();           // protected constructor used by dynamic creation</p>
<p>
// Attributes</p>
<p>
public:</p>
<p>
// Operations</p>
<p>
public:</p>
<p>
    virtual void GetItemRect (LPRECT pRect);</p>
<p>
    virtual ~CWidget();</p>
<p>
    virtual int GetType ();</p>
<p>
    virtual BOOL PtInWidget (POINT point);</p>
<p>
    virtual void DrawDragImage (CDC* pDC, POINT point);</p>
<p>
    virtual void Draw (CDC* pDC);</p>
<p>
// Overrides</p>
<p>
    // ClassWizard generated virtual function overrides</p>
<p>
    //{{AFX_VIRTUAL(CWidget)</p>
<p>
    //}}AFX_VIRTUAL</p>
<p>
// Implementation</p>
<p>
protected:</p>
<p>
    CRect m_rect;</p>
<p>
    // Generated message map functions</p>
<p>
    //{{AFX_MSG(CWidget)</p>
<p>
        // NOTE - the ClassWizard will add and remove member functions here.</p>
<p>
    //}}AFX_MSG</p>
<p>
    DECLARE_MESSAGE_MAP()</p>
<p>
};</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
//{{AFX_INSERT_LOCATION}}</p>
<p>
// Microsoft Developer Studio will insert additional declarations immediately </p>
<p>
// before the previous line.</p>
<p>
#endif // !defined(AFX_WIDGBASE_H__877329CA_C22E_11D0_B2D8_444553540000__INCLUDED_)</p>
<h4>WidgBase.cpp</h4>
<p>
// WidgBase.cpp : implementation file</p>
<p>
//</p>
<p>
#include &quot;stdafx.h&quot;</p>
<p>
#include &quot;Widget.h&quot;</p>
<p>
#include &quot;WidgBase.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidget</p>
<p>
IMPLEMENT_DYNCREATE(CWidget, CCmdTarget)</p>
<p>
CWidget::CWidget()</p>
<p>
{</p>
<p>
}</p>
<p>
CWidget::~CWidget()</p>
<p>
{</p>
<p>
}</p>
<p>
BEGIN_MESSAGE_MAP(CWidget, CCmdTarget)</p>
<p>
    //{{AFX_MSG_MAP(CWidget)</p>
<p>
        // NOTE - the ClassWizard will add and remove mapping macros here.</p>
<p>
    //}}AFX_MSG_MAP</p>
<p>
END_MESSAGE_MAP()</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CWidget message handlers</p>
<p>
void CWidget::Draw(CDC * pDC)</p>
<p>
{</p>
<p>
    ASSERT (FALSE); // Override this function in a derived class</p>
<p>
}</p>
<p>
void CWidget::DrawDragImage(CDC * pDC, POINT point)</p>
<p>
{</p>
<p>
    ASSERT (FALSE); // Override this function in a derived class</p>
<p>
}</p>
<p>
BOOL CWidget::PtInWidget(POINT point)</p>
<p>
{</p>
<p>
    ASSERT (FALSE); // Override this function in a derived class</p>
<p>
    return FALSE;</p>
<p>
}</p>
<p>
int CWidget::GetType()</p>
<p>
{</p>
<p>
    ASSERT (FALSE); // Override this function in a derived class</p>
<p>
    return -1;</p>
<p>
}</p>
<p>
void CWidget::GetItemRect(LPRECT pRect)</p>
<p>
{</p>
<p>
    *pRect = m_rect;</p>
<p>
}</p>
<p>A good place to begin examining the code is with the data structure WIDGET uses to describe a widget object:</p>
<p>
typedef struct tagWIDGETDATA {</p>
<p>
    int nType;</p>
<p>
    RECT rcItem;</p>
<p>
    POINT ptDrag;</p>
<p>
} WIDGETDATA;</p>
<p>The type field holds 0, 1, or 2, identifying the widget as a circle, triangle, or square. rcItem holds the coordinates of the&nbsp;widget’s&nbsp;bounding rectangle, and ptDrag holds the coor&shy;dinates of the drag point—the point at which the widget is grabbed to begin a drag and drop operation. The difference between the drag point and the upper-left corner of the bounding rectangle is used as an offset from the current cursor location whenever WIDGET draws a drag image.</p>
<p>When a widget is clicked, the OnLButtonDown code in the view allocates a global memory block and fills it with a WIDGETDATA structure describing the widget. When a drop occurs, the view’s OnDrop handler uses the infor&shy;mation in the structure to create a new widget. However, before the drop occurs, the view’s OnDragEnter function, which is called when the cursor enters the window during a drag operation, uses the information in the WIDGETDATA structure to create a temporary widget. The temporary widget’s address is tucked away in the view’s m_pWidget data member, as shown in Figure 4.</p>
<p>Figure 4  Saving a Widget's Address</p>
<p>
HGLOBAL hData = pDataObject-&gt;GetGlobalData (nFormat);</p>
<p>
WIDGETDATA* pWidgetData = (WIDGETDATA*) ::GlobalLock (hData);</p>
<p>
int nType =  pWidgetData-&gt;nType;</p>
<p>
CRect rect = pWidgetData-&gt;rcItem;</p>
<p>
CPoint pt =  pWidgetData-&gt;ptDrag;</p>
<p>
::GlobalUnlock (hData);</p>
<p>
switch (nType) {</p>
<p>
case 0: // Circle</p>
<p>
    m_pWidget = new CCircle (rect);</p>
<p>
    break;</p>
<p>
case 1: // Triangle</p>
<p>
    m_pWidget = new CTriangle (rect);</p>
<p>
    break;</p>
<p>
case 2: // Square</p>
<p>
    m_pWidget = new CSquare (rect);</p>
<p>
    break;</p>
<p>
default: // Just in case</p>
<p>
    return DROPEFFECT_NONE;</p>
<p>
}</p>
<p>Why create a temporary widget when the cursor enters the window? Because widget objects have DrawDragImage functions that draw widget outlines by inverting pixels on the screen. As the cursor is moved over the view during a drag and drop operation, the view’s OnDragOver function is called repeatedly. OnDragOver calls the temporary widget’s DrawDragImage function twice—once to erase the previous drag image and once to draw the image in the new location. Thus, the drag image follows the cursor around the window, and it’s the widget itself—a copy of it, anyway—that does the actual drawing. Calls to Draw&shy;DragImage, of course, go through the pointer stored in m_p&shy;Widget. The temporary widget is deleted when the view’s OnDragLeave function is called, indicating that the cursor left the window.</p>
<p>That’s really all there is to it. The key (again) is that the drop target, not the drop source, does the drag imaging. Since the drop target gets called each time the cursor moves over its window, it’s a simple matter for it to grab a screen DC and update a drag image. All it needs to know is what to draw and, as WIDGET demonstrates, that information can be provided either directly or indirectly by the drop source. I suspect that, if you could peel the cover off the Microsoft Windows 95 and Windows NT 4.0 shell and look at the source code, you’d find that it does something very similar to what I’ve done here.</p>
<h2>Your Needs, Your Ideas</h2>
<p>Are there tough Win32-based programming questions you’d like to see answered in this column? If so, mail them to me at the address listed below. I regret that time doesn’t permit me to respond individually to all questions, but rest assured that I’ll read each and every one and consider all for inclusion in a future installment of Wicked Code.             u</p>
<h5>To obtain complete source code listings, see page 5.</h5>
<p>Have a tricky issue dealing with Windows? Send your questions via email to Jeff Prosise: 72241.44@compuserve.com</p>
</font></font></body>
</HTML>
