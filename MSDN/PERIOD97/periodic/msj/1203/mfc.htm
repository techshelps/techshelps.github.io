<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Adobe application">
<meta name="Template" content="C:\MSOffice\Templates\MSJ.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>More Fun With MFC: DIBs, Palettes, Subclassing and a Gamut of Goodies, Part II</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<p><font color="#000000" size="6" face="verdana,arial,helvetica">More
Fun With MFC: DIBs, Palettes, Subclassing and a Gamut of Goodies,
Part II</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica">Paul DiLascia</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Paul DiLascia is a freelance
software consultant specializing in training and software
development in C++ and Windows. He is the author of Windows++:
Writing Reusable Code in C++ </b></font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>(Addison-Wesley, 1992).</b></font></p>

<blockquote>
    <p><font color="#000080" size="7"
    face="verdana,arial,helvetica">A</font><font color="#000000"
    size="4" face="verdana,arial,helvetica">fter January&#146;s </font><font
    color="#000000" size="2" face="verdana,arial,helvetica">article,
    I had to leave in a hurry. I raced over to Acme World
    Headquarters where I was scheduled to present my DIBVIEW
    program to Acme&#146;s Maximum Leader and beg for a deadline
    extension for writing Acme&#146;s XYZ file viewer. (He
    granted me two more days.) In case you&#146;ve forgotten, I
    wrote an app called DIBVIEW that lets you look at DIBs
    (device-independent bitmaps). I implemented a class, CDib,
    that loads and draws bitmaps using some new Win32® functions
    and the DrawDib API from Video for Windows</font><font
    color="#000000" size="1" face="verdana,arial,helvetica">®</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">.
    Then I added a whole bunch of code to handle palette
    messages&#151;WM_QUERYNEWPALETTE and WM_ONPALETTECHANGED. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If your memory is a little
    fuzzy, now is a good time to go back and skim Part I
    (&quot;More Fun with MFC: Dibs, Palettes, Subclassing, and a
    Gamut of Reusable Goodies,&quot; <i>MSJ</i> January 1996),
    since that&#146;s all the refresher you&#146;ll get.
    I&#146;ve got a lot to cover, so I want to jump right in
    where I left off. This is where things start to get really
    interesting.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Probing
the Pattern in Palettes</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">All that palette stuff is
    pretty boring when you get right down to it. You read the
    manuals and the articles on MSDN, maybe copy some code from a
    sample program. Programmers have been doing palettes ever
    since Windows 3.0; just imagine how many programs are out
    there with palette-handling code similar to what&#146;s in
    DIBVIEW. With all that code, you&#146;d think by now someone
    would&#146;ve written a function to Just Do It. No such luck.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">That&#146;s because most
    programmers follow the copy-and-paste school of software
    reusability: the way you reuse the code is to copy from one
    source file and paste into another. This is indeed a form of
    reusability, though it&#146;s more the sort of thing cavemen
    would think of than sophisticated programmers. Which is to
    say, primitive. Nevertheless, the copy-and-paste style of
    programming is so ingrained that most programmers don&#146;t
    think twice about it. Copy-and-paste even lives on in code
    generators, programs like AppWizard that are really no more
    than sophisticated copy-and-paste machines. If the behavior
    is so generic that you can write a program to write a program
    to implement it, why not just put it in a class or subroutine
    any app can call?</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Wouldn&#146;t it be nice if,
    instead of copying all that palette code from app to app,
    there was some way to genuinely reuse it? What you need is
    some way to encapsulate that palette code in a class you
    could instantiate in your app to just do palettes. Every app
    is slightly different of course, but there is a basic pattern
    to palettes. A view realizes its palette in the foreground
    when it gets focus or its main frame gets WM_QUERYNEWPALETTE,
    and in the background when its main frame gets
    WM_PALETTECHANGED. The only thing that differs from app to
    app is the palette itself. There should be some way to
    capture the &quot;palette pattern&quot; in a reusable class.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In C++/MFC (or any other
    framework), the obvious thing to do is derive a new class,
    CViewThatHandlesPalettes, that apps can derive from. This
    class would have OnQueryNewPalette, OnPaletteChanged,
    OnSetFocus, and OnInitialUpdate handlers like the ones for
    CDIBView. But that won&#146;t work because you&#146;d need a
    CScrollViewThatHandlesPalettes and a
    CFrameWndThatHandlesPalettes, one for CMDIFrameWnd and CWnd,
    and practically every window class there is in MFC. Even if
    you were willing to write all that code (perhaps using
    templates), it still wouldn&#146;t be enough. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Suppose some programmer is
    using a third-party library?</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CWnd // MFC</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CView // MFC</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CBetterView // Zippy Tools
    CMyView // app</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Where are you, as a tool
    developer, going to insert CViewThatHandlesPalettes?
    Nowhere&#151;there&#146;s no place to put it. The hierarchy
    is already cast in concrete and the code already written.
    This problem is endemic to MFC and any system with
    single-inheritance class hierarchies. You want the view to be
    a CBetterView <i>and</i> a CViewThatHandlesPalettes. The only
    solution is multiple inheritance.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">class CMyView : public
    CBetterView, </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">public
    CViewThatHandlesPalettes {</font></p>
    <blockquote>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">};</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Unfortunately, MFC
    doesn&#146;t support multiple inheritance in this way. I
    don&#146;t know any framework that does. Most Windows-based
    C++ application frameworks are alike in this respect. They
    all use a single-inheritance model that makes it difficult to
    write reusable library extensions. So if Zippy Tools makes a
    CBetterView and Dippy Tools makes a CViewThatHandlesPalettes,
    you can&#146;t use both&#151;you have to choose one or the
    other. It&#146;s not just an issue for tool vendors, because
    good application programmers write tools too, like I did for
    DIBVIEW.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">This problem doesn&#146;t
    exist in C. In C, you could do something like the following:
    write a special window proc, PaletteMsgProc, that handles
    WM_QUERYNEWPALETTE, WM_PALETTECHANGED, and WM_SETFOCUS as
    described previously. When it comes time to actually realize
    the palette, PaletteMsgProc sends a new message, called
    PALWM_REALIZE, with the HDC in WPARAM and the
    foreground/background flag in LPARAM. Any app that wants to
    use palettes would just have to install this window proc
    ahead of its own&#151;in other words, subclass its
    windows&#151;and realize its palette when it gets
    PALWM_REALIZE. That would work perfectly. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As a tool developer, you could
    even supply the convenient functions
    InstallPaletteHandler(HWND) and RemovePaletteHandler(HWND) to
    do the subclassing and unsubclassing, so the application
    programmer doesn&#146;t even know about PaletteMsgProc. Then
    all the application programmer has to do is call the install
    function and handle PALWM_REALIZE. In fact, even that is
    unnecessary if the install function accepts an HPALETTE. Just
    install the palette handler and forget about it. If Zippy
    Tools and Dippy Tools each produce something like this, you
    can use them both because, with Windows and C, you can
    subclass a window any number of times in any order. The class
    hierarchy (in the Windows sense) needn&#146;t be specified in
    advance. Each library just inserts its window proc in front
    of whatever is there before it. (I&#146;m assuming that the
    Zippy and Dippy window procs provide unrelated
    functionality&#151;one handles palette messages while the
    other does, say, 3D controls.)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">So the real problem is that
    MFC doesn&#146;t let you subclass a window in the Windows
    sense. In MFC, every window is subclassed with the generic
    AfxWndProc. MFC (and every other C++/Windows framework I
    know) maps the Windows notion of subclassing to the C++
    concept of derived classes. The way you modify the behavior
    of an existing window in C++ is to derive a new class and
    override one or more message handlers. It&#146;s a great
    model in many respects, but it ties you to a rigid class
    hierarchy that&#146;s hardwired into the source code.
    There&#146;s no way in C++ to say, &quot;derive my new
    extension class from the &#145;most derived&#146;
    class,&quot; which is exactly what Windows subclassing does
    and what you need to build some sort of reusable palette
    message handler. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The long and short of it is
    this: to reuse my now-perfect palette code from Part I,
    adding a window class is out; what you need is a way to
    subclass MFC windows.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>CMsgHook:
Windows Subclassing in MFC</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Just because MFC doesn&#146;t
    let you subclass its windows doesn&#146;t mean you can&#146;t
    do it anyway. After all, C++ <i>is</i> C (and don&#146;t ever
    forget it). All MFC does is make life complicated and force
    you to be more sneaky. For STEP4 of DIBVIEW, I implemented a
    new general-purpose class, CMsgHook, that hooks a CWnd object
    by subclassing it in the Windows sense&#151;that is, by
    inserting its own window proc ahead of whatever proc is there
    currently, usually AfxWndProc. I thought of calling this new
    goodie CSubclassWnd since that&#146;s what it really
    does&#151;subclass a window&#151;but &quot;subclass&quot; is
    too fraught with misconception. CMsgHook emphasizes the fact
    that my new class really just hooks messages. Also, CMsgHook
    is not derived from CWnd, though it does resemble CWnd in
    many respects. For example, it has WindowProc and Default
    functions just like CWnd.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The best way to understand how
    CMsgHook works is to look at how you&#146;d use it in a
    program. The first thing you do is install the hook by
    calling CMsgHook::HookWindow.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CWnd* pMyWnd; // some window</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CMsgHook hook // message hook</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">hook.HookWindow(pMyWnd); //
    now it's &quot;hooked&quot;</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CMsgHook::HookWindow
    subclasses the window in the normal Windows sense.</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// (simplified)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL
    CMsgHook::HookWindow(CWnd* pWnd)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">m_pWndHooked = pWnd;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">m_pOldWndProc =
    SetWindowLong(pWnd-&gt;m_hWnd,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">GWL_WNDPROC, HookWndProc);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return TRUE;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CMsgHook stores the pointer to
    the window in a data member, m_pWndHooked, then subclasses
    the window by installing its own HookWndProc, saving whatever
    was there before. Now all WM_ messages for pMyWnd go to
    HookWndProc instead of AfxWndProc.</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// (simplified)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">LRESULT CALLBACK<br>
    HookWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CMsgHook* pHook =
    GetMsgHookForThisHWND(hwnd);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return
    pHook-&gt;WindowProc(msg, wp, lp);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">When HookWndProc gets a
    message, the first thing it does is find the CMsgHook object
    attached to the HWND. I&#146;ll describe how it does that in
    just a moment; for now take my word that it can. Once
    HookWndProc has the right CMsgHook object, it calls that
    hook&#146;s WindowProc function.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// it's virtual!</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">LRESULT </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CMsgHook::WindowProc(UINT msg,
    WPARAM wp, LPARAM lp)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return
    ::CallWindowProc(m_pOldWndProc,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">m_pWndHooked-&gt;m_hWnd, msg,
    wp, lp);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As you can see, WindowProc
    doesn&#146;t do much. It passes the message back to the
    original window proc. The overall result
    is&nbsp;...&nbsp;nothing. But that&#146;s OK. CMsgHook
    isn&#146;t supposed to do anything; its only job is to handle
    the mechanics of hooking (subclassing) a window. To actually
    do something, you have to derive a new class from CMsgHook
    and override CMsgHook::WindowProc.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">LRESULT </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CMyMsgHook::WindowProc(UINT
    msg, WPARAM wp, LPARAM lp)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (msg==WM_QUERYNEWPALETTE) {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// handle it</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return 0;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return
    CMsgHook::WindowProc(msg, wp, lp);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If the specialized hook
    handles the message, it can return a value; otherwise it must
    pass the message to CMsgHook::WindowProc, which sends it back
    to the original window proc. In effect, all CMsgHook does is
    convert the C-style window proc into a C++-style virtual
    function, CMsgHook::WindowProc. This is exactly the same
    thing CWnd does.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The only part I left out of my
    explanation is how HookWndProc gets the CMsgHook associated
    with a window handle (HWND). This is where I followed my KISS
    (keep it simple stupid, not &quot;I wanna rock and roll all
    night&quot;) philosophy of software development, which
    dictates that I always start small, then enhance. In my first
    implementation, I stored the hook as a global variable,
    theHook, which I accessed from HookWndProc. This meant I
    could have only one hook for the entire app. Not very useful!
    </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As soon as I got CMsgHook
    working with one hook in a test program, I went back and
    added a more sophisticated mechanism. For lack of inspiration
    I imitated what MFC does for CWnd, which is to store the
    HWND/CWnd association in a lookup table. So I derived another
    class, CMsgHookMap, from CMapPtrToPtr and wrote functions to
    Add, Remove, and Lookup the hooks (see MsgHook.cpp in <b>Figure
    1</b>). Pretty straightforward. So far everything is just
    like CWnd&#151;with one extremely significant improvement.
    MFC lets you associate or &quot;Attach&quot; one HWND with
    only one CWnd object, which is why you can&#146;t subclass in
    MFC. In CMsgHook, however, I added a data member, m_pNext,
    that can point to another message hook for the same window.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">class CMsgHook : public
    CObject {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">protected:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CMsgHook* m_pNext; // next in
    chain this window</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">};</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To make multiple hooks work, I
    modified CMsgHook::HookWindow so the first time a particular
    CWnd is hooked, it adds the hook to the global map. After
    that it merely appends the hook to the list of hooks for that
    window. HookWindow thus creates the data structure
    illustrated in <b>Figure 2</b>. Of course, I also had to
    modify CMsgHook::WindowProc to call the next hook in the
    chain.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">LRESULT<br>
    CMsgHook::WindowProc(UINT msg, WPARAM wp, LPARAM lp)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return m_pNext ? </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">m_pNext-&gt;WindowProc(msg,
    wp, lp) :</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">::CallWindowProc(m_pOldWndProc,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">m_pWndHooked-&gt;m_hWnd,msg,wp,lp);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Each CMsgHook::WindowProc
    calls the next hook&#146;s WindowProc until control flows to
    the last hook, which then calls the original window proc,
    m_pOldWndProc. This way, a single CWnd object can have any
    number of hooks attached to it. Pretty cool.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
1&nbsp; HOOK</b></font></p>

<p><font color="#000000" size="1" face="Courier New">Hook.h</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;resource.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">class
CApp : public CWinApp {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">public:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CApp();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">virtual
BOOL InitInstance();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">afx_msg
void OnAppAbout();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DECLARE_MESSAGE_MAP()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">Hook.cpp</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;StdAfx.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;Hook.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;MainFrm.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;TraceWin.h&quot;</font></p>

<blockquote>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
CApp::InitInstance()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Create main frame window (don't use doc/view stuff)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMainFrame*
pMainFrame = new CMainFrame;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pMainFrame-&gt;ShowWindow(m_nCmdShow);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pMainFrame-&gt;UpdateWindow();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pMainWnd
= pMainFrame;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">MainFrm.h</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;MsgHook.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Msg hook to spy on mouse messages</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">class
CKbdMsgHook : public CMsgHook {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DECLARE_DYNAMIC(CKbdMsgHook);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">virtual
LRESULT WindowProc(UINT msg, WPARAM wp, LPARAM lp); </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Standard main frame</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">class
CMainFrame : public CFrameWnd {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">public:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMouseMsgHook
m_mouseMsgHook; // mouse message hook</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CKbdMsgHook
m_kbdMsgHook; // keyboard message hook</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CAllMsgHook
m_allMsgHook; // all message hook</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMainFrame();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">virtual
~CMainFrame();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">protected:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DECLARE_DYNAMIC(CMainFrame)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CStatusBar
m_wndStatusBar;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CToolBar
m_wndToolBar;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DECLARE_MESSAGE_MAP()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">afx_msg
int OnCreate(LPCREATESTRUCT lpCreateStruct);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">afx_msg
void OnHookKbd();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">afx_msg
void OnUpdateHookKbd(CCmdUI* pCmdUI);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">...</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">MainFrm.cpp</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Note: edited to show only KBD hook</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;StdAfx.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;Hook.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;MainFrm.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;Debug.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">IMPLEMENT_DYNAMIC(CMainFrame,
CFrameWnd)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BEGIN_MESSAGE_MAP(CMainFrame,
CFrameWnd)</font></p>

<blockquote>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">&#149;</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">&#149;</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">&#149;</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ON_COMMAND(ID_HOOK_KBD,
OnHookKbd)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ON_UPDATE_COMMAND_UI(ID_HOOK_KBD,
OnUpdateHookKbd)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">END_MESSAGE_MAP()</font></p>

<blockquote>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">&#149;</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">&#149;</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">&#149;</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////////////////////////////////////////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Command and UI handlers for hook/unhook commands</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
CMainFrame::OnHookKbd() </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_kbdMsgHook.HookWindow(m_kbdMsgHook.IsHooked()
? NULL : this);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
CMainFrame::OnUpdateHookKbd(CCmdUI* pCmdUI) </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pCmdUI-&gt;SetCheck(m_kbdMsgHook.IsHooked());</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
CKbdMsgHook spies on keyboard messages,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LRESULT
CKbdMsgHook::WindowProc(UINT msg, WPARAM wp, LPARAM lp)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(WM_KEYFIRST &lt;= msg &amp;&amp; msg &lt;= WM_KEYLAST) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">TRACE(&quot;CKbdMsgHook::%s\n&quot;,
DbgName(msg));</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
CMsgHook::WindowProc(msg, wp, lp); // Important!!</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">IMPLEMENT_DYNAMIC(CKbdMsgHook,
CMsgHook);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<blockquote>
    <p><font color="#000000" size="1" face="Courier New">MsgHook.cpp</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////////////////////////////////////////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
1997 Microsoft Systems Journal. </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
CMsgHook is a generic class for hooking another window's
messages.</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;StdAfx.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;MsgHook.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;Debug.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
The message hook map is derived from CMapPtrToPtr, which
associates</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
a pointer with another pointer. It maps an HWND to a CMsgHook,
like</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
the way MFC's internal maps map HWND's to CWnd's. The first hook</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
attached to a window is stored in the map; all other hooks for
that</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
window are then chained via CMsgHook::m_pNext.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">class
CMsgHookMap : private CMapPtrToPtr {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">public:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMsgHookMap();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">~CMsgHookMap();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">static
CMsgHookMap&amp; GetHookMap();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
Add(HWND hwnd, CMsgHook* pMsgHook);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
Remove(CMsgHook* pMsgHook);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
RemoveAll(HWND hwnd);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMsgHook*
Lookup(HWND hwnd);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
This trick is used so the hook map isn't</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
instantiated until someone actually requests it.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
theHookMap (CMsgHookMap::GetHookMap())</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">IMPLEMENT_DYNAMIC(CMsgHook,
CWnd);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMsgHook::CMsgHook()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pNext
= NULL;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pOldWndProc
= NULL; </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pWndHooked
= NULL;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMsgHook::~CMsgHook()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ASSERT(m_pWndHooked==NULL);
// can't destroy while still hooked!</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ASSERT(m_pOldWndProc==NULL);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Hook a window.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
This installs a new window proc that directs messages to the
CMsgHook.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
pWnd=NULL to remove.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><img
src="mfc2.jpg"></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><strong>Figure
2 CMsgHook Data Structures</strong></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To test it all out, I wrote a
    program called HOOK that implements three different kind of
    hooks: CMouseMsgHook, CKbdMsgHook, and CAllMsgHook (see <b>Figure
    1</b>). These record all mouse, keyboard, or WM_ events in
    the TRACE output. Each hook is derived from CMsgHook, with a
    WindowProc function that uses DbgName(UINT), described in
    Part I, to TRACE the WM_ messages. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">HOOK&#146;s main frame window
    contains an instance of each hook as a data member.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">class CMainFrame : public
    CFrameWnd {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CMouseMsgHook m_mouseMsgHook;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CKbdMsgHook m_kbdMsgHook;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CAllMsgHook m_allMsgHook;</font></p>
    <blockquote>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">};</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Initially, these hooks are all
    unhooked. When the user invokes a menu command to turn one of
    the hooks on, MFC calls my command handler in CMainFrame:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">void CMainFrame::OnHookKbd() </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">m_kbdMsgHook.HookWindow(</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">m_kbdMsgHook.IsHooked() ? NULL
    : this);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">OnHookKbd toggles the state of
    the keyboard hook; likewise for the other hooks. The user can
    turn each hook on or off independently of the others, proving
    that multiple hooks work. <b>Figure 3</b> shows HOOK running,
    and <b>Figure 4</b> shows the TRACE output generated with the
    All hook turned on. Indenting works courtesy of TRACEFN from
    Part I.</font></p>
    <p><img src="mfc3.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
3 The HOOK program</b></font></p>

<blockquote>
    <p><img src="mfc4.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
4 TRACE output for All</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">There are a few implementation
    details that I skipped in my explanation of CMsgHook. For one
    thing, HookWndProc automatically unhooks a hook when the
    window gets WM_NCDESTROY, in case you forgot. It also stores
    the current MSG information (HWND, WPARAM, and LPARAM) in
    AfxGetThreadState()-&gt;m_lastSentMsg, just like AfxWndProc
    does.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">MSG&amp; curMsg =
    AfxGetThreadState()-&gt;m_lastSentMsg;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">MSG oldMsg = curMsg; // save
    for nesting</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">curMsg.hwnd = hwnd;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">curMsg.message = msg;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">curMsg.wParam = wp;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">curMsg.lParam = lp;</font></p>
    <blockquote>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">curMsg = oldMsg; // restore</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">MFC always saves the current
    message in the thread&#146;s global state, so I do the same
    thing in case any function that gets called while processing
    the message needs it. In particular, CMsgHook::Default uses
    AfxGetThread-State()-&gt;m_lastSentMsg to do the default
    thing&#151;pass whatever the current message is to the
    original window proc. Just like CWnd::Default,
    CMsgHook::Default is useful when you want to break your
    WindowProc override into separate handlers instead of a
    single giant switch statement, but you don&#146;t want to
    pass msg, wParam, and lParam everywhere. Note that it&#146;s
    crucial to save/restore the old MSG information in oldMsg,
    because control is likely to reenter HookWndProc any number
    of times down the call stack as one message begets another in
    typical Windows fashion.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Another absolutely crucial
    detail for DLLs is that you must initialize MFC&#146;s state
    when control enters your hook proc.</font></p>
    <blockquote>
        <blockquote>
            <blockquote>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">LRESULT CALLBACK</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">HookWndProc(HWND
                hwnd, UINT msg, <br>
                WPARAM wp, LPARAM lp)</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">{</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">#ifdef _USRDLL</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">// If this is a
                DLL, set up MFC state</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">AFX_MANAGE_STATE(AfxGetStaticModuleState());</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">#endif</font></p>
                <p><font color="#000000" size="1"
                face="verdana,arial,helvetica">&#149;</font></p>
                <p><font color="#000000" size="1"
                face="verdana,arial,helvetica">&#149;</font></p>
                <p><font color="#000000" size="1"
                face="verdana,arial,helvetica">&#149;</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">}</font></p>
                <blockquote>
                    <blockquote>
                        <p><font color="#000000"
                        face="verdana,arial,helvetica"></font>&nbsp;</p>
                        <p><font color="#000000"
                        face="verdana,arial,helvetica"></font>&nbsp;</p>
                    </blockquote>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I discovered this one the hard
    way when I converted DIBVIEW to a Quick View file viewer
    (which is a DLL). You must use AFX_MANAGE_STATE at the top of
    any function&#151;callback or C++ member&#151;that can
    receive control from the outside. AFX_MANAGE_STATE is what
    initializes the module or thread&#146;s global state
    information. I&#146;ll have a lot more to say about MFC
    states in a future article; for now, I&#146;ll just note this
    important detail and move on.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>CMsgHook
versus CWnd</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As I was writing CMsgHook, I
    had to chuckle to myself because I was essentially
    reinventing the wheel. CMsgHook does almost exactly the same
    thing as CWnd, with a couple of important twists. Number one,
    since CMsgHook is not derived from CWnd, CMsgHooks don&#146;t
    have message maps. This means you have to override WindowProc
    to handle messages; you don&#146;t get them served on a
    platter the way CWnd-derived objects are. Number two&#151;and
    this is the whole point&#151;CMsgHook lets you hook the same
    window any number of times with any number of different kinds
    of hooks.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The similarity to CWnd is so
    close I actually tried deriving CMsgHook from CWnd so it
    would really &quot;be&quot; a window. Then you could use
    message maps and CCmdTarget and everything else. But I
    couldn&#146;t make it fly. There are just too many places
    where MFC assumes&#151;or ASSERTS&#151;that there&#146;s only
    one CWnd object attached to an HWND. The AssertValid function
    for CWnd checks this, and there are countless places where
    MFC does ASSERT_VALID on a CWnd pointer.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I considered Detaching the
    original CWnd and Attaching each hook as it came into scope,
    but this seemed untenable since the context swap would have
    to occur whenever control flowed from one hook to another and
    to the CWnd. For example, if CMyMsgHook calls
    m_pWndHooked-&gt;AnyFunction, I&#146;d have to Detach the
    hook and Attach the CWnd. This could be done by exposing
    m_pWndHooked through a Get function GetHookedWnd that did the
    context swap before returning m_pWndHooked. But then how do
    you re-Attach the hook whenever a CMsgHook or
    CMsgHook-derived member function gets control? You&#146;d
    need some kind of HOOK_PROLOGUE macro to Detach the CWnd and
    re-Attach the hook. This would get pretty unwieldy, if it
    would even work at all&#151;not to mention how it would
    affect performance. All the Attaching and Detaching would
    occur on every WM_ <i>xxx </i>message. Forget it! (If
    you&#146;re totally lost, don&#146;t worry, just keep
    reading.)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">It&#146;s a shame MFC
    doesn&#146;t support multiple subclassing. In principle,
    there&#146;s no reason MFC couldn&#146;t do subclass-ing
    using a daisy-chain approach like in <b>Figure 2</b>.
    Allowing true Windows-style subclassing would give
    programmers an elegant way to build some really neat MFC
    extensions, and would let you use multiple extensions in the
    same window object. </font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Total
Palette Bliss: CPalMsgHandler</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Just in case you don&#146;t
    fully appreciate the significance of CMsgHook, it&#146;s time
    to return to palettes. I know, I know&#151;you hate palettes
    by now. But CMsgHook ought to cure your palette ills forever.
    After this, you&#146;ll never again have to worry about
    palette messages, I promise!</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">After freezing DIBVIEW yet
    again as STEP3, to begin work on STEP4 (this is the last
    version, really), the first thing I did was derive a new
    message hook, CPalMsgHandler, to implement the palette
    pattern described earlier. CPalMsgHandler::WindowProc has a
    switch statement that routes WM_QUERYNEWPALETTE,
    WM_PALETTECHANGED, and WM_SETFOCUS to specific message
    handler functions OnQueryNewPalette, OnPaletteChanged, and so
    on, which implement the pattern. The implementation is
    straightforward, mostly just a matter of copying the CView
    and CMainFrame code from STEP3 to CPalMsgHandler, changing
    all invocations through an implicit this pointer to
    invocations through m_pWndHooked.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Naturally, there were a few
    wrinkles. The biggest problem has to do with
    WM_INITIALUPDATE. If you remember, I had to call
    DoRealizePalette from CDIBView::OnInitialUpdate because, for
    SDI apps, MFC doesn&#146;t load the document until after you
    get WM_QUERYNEWPALETTE, which is too late. In converting from
    CDIBView to CPalMsgHandler, this meant handling
    WM_INITIALUPDATE, which is a private MFC message defined in
    &lt;afxpriv.h&gt;. No big deal, just include the file. But
    when I ran the code, it didn&#146;t work; my palette hook
    never got WM_INITIALUPDATE. I set a break point and ran my
    code in the debugger to see if maybe MFC was calling
    OnInitialUpdate directly instead of sending it as a
    WM_INITIALUPDATE message. What I discovered was even worse:
    MFC doesn&#146;t call OnInitialUpdate directly, it calls
    SendMessageToDescendants to broadcast the message from the
    frame to all its views. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">SendMessageToDescendants
    contains the following lines:</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (bOnlyPerm) {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">AfxCallWndProc(pWnd,
    pWnd-&gt;m_hWnd, msg, wp, lp);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">} else {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">::SendMessage(hWndChild, msg,
    wp, lp);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I&#146;ve omitted everything
    else to highlight the heinous crime: if bOnlyPerm is TRUE
    (send to permanent windows only&#151;ones with CWnds
    attached), CWnd calls AfxCallWndProc.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">LRESULT </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">AfxCallWndProc(CWnd* pWnd,
    HWND hWnd,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">UINT nMsg, WPARAM wp, LPARAM
    lp)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <blockquote>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">lResult=pWnd-&gt;WindowProc(nMsg,
    wp, lp);</font></p>
    <blockquote>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">AfxCallWndProc calls
    CWnd::WindowProc directly! Can you believe it? Instead of
    going through Windows&#151;and instead of calling
    SendMessage&#151;MFC just short-circuits the whole show.
    Arrghhh! This sort of kludge makes me want to pull my hair
    out. Be warned: do not use SendMessageToDescendants with
    bOnlyPerm=TRUE if you install a new window proc, because the
    message is not really sent at all&#151;MFC calls
    CWnd::WindowProc directly. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Unfortunately, while you are
    free to avoid SendMessageToDescendants, you can&#146;t
    control what MFC does, and CFrameWnd uses
    SendMessageToDescendants to broadcast WM_INITIALUPDATE. There
    are other places where this happens, too. For example, MFC
    uses SendMessageToDescendants to send WM_IDLEUPDATECMDUI.
    This means you can&#146;t write a CMsgHook that taps into
    idle processing, and that&#146;s a shame.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Now, in defense of the
    Friendly Redmondtonians, I know what they&#146;re trying to
    do. They&#146;re trying to squeeze every last microdram of
    performance out of MFC, but the tiny bit of performance
    gained from a few extra cycles to go through SendMessage does
    not justify violating the integrity of the whole Windows
    system, which demands that every, and I mean every, message
    go through normal channels&#151;that is, through whatever
    window proc is currently installed in the window. If MFC
    wants to be a little faster, it can use
    ::CallWindowProc(GetWindowLong(GWL_WNDPROC)).</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">What can I do to make
    CPalMsgHandler work? How can I hook WM_INITIALUPDATE when MFC
    sends it through secret channels? Frankly, there&#146;s
    nothing I can do. I looked around for some other message that
    gets sent around the same time, something to hook after a new
    doc is opened in an SDI app, but there isn&#146;t one. So to
    use CPalMsgHandler, you just have to remember to call
    DoRealizePalette(TRUE) from your OnInitialUpdate.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Aside from that, all you have
    to do is instantiate CPalMsgHandler objects in your frame and
    view classes, and then hook them up by calling
    CPalMsgHandler::Install from your OnCreate or OnInitialUpdate
    handler (see View.cpp and MainFrm.cpp in <b>Figure 5</b>).</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
5&nbsp; DIBVIEW</b></font></p>

<p><font color="#000000" size="1" face="Courier New">DibView.cpp</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;StdAfx.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;DibView.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;MainFrm.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;Doc.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;View.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;TraceWin.h&quot;</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
CApp::InitInstance()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifdef
_MDI</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">AddDocTemplate(new
CMultiDocTemplate(IDR_MYDOCTYPE,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RUNTIME_CLASS(CDIBDoc),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RUNTIME_CLASS(CMDIChildWnd),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RUNTIME_CLASS(CDIBView)));</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">AddDocTemplate(new
CSingleDocTemplate(IDR_MAINFRAME,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RUNTIME_CLASS(CDIBDoc),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RUNTIME_CLASS(CMainFrame),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RUNTIME_CLASS(CDIBView)));</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CCommandLineInfo
cmdInfo;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ParseCommandLine(cmdInfo);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifdef
_MDI</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
create main MDI Frame window</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMainFrame*
pMainFrame = new CMainFrame;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pMainWnd
= pMainFrame;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Parse command line. Since this is a read-only viewer,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
don't allow FileNew</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(cmdInfo.m_nShellCommand!=CCommandLineInfo::FileNew &amp;&amp; </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">!ProcessShellCommand(cmdInfo))</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
The main window has been initialized, so show and update it.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pMainFrame-&gt;ShowWindow(m_nCmdShow);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pMainFrame-&gt;UpdateWindow();</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#else
// SDI app</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!ProcessShellCommand(cmdInfo))</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">MainFrm.h</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;PalHook.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifdef
_MDI</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
CBaseFrameWnd CMDIFrameWnd</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
CBaseFrameWnd CFrameWnd</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Palette-handling main frame window</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">class
CMainFrame : public CBaseFrameWnd {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">public:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMainFrame();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">virtual
~CMainFrame();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">protected:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DECLARE_DYNCREATE(CMainFrame)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CPalMsgHandler
m_palMsgHandler; // handles palette messages</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CStatusBar
m_wndStatusBar; // status bar</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CToolBar
m_wndToolBar; // tool (button) bar</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DECLARE_MESSAGE_MAP()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">afx_msg
int OnCreate(LPCREATESTRUCT lpCreateStruct);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<blockquote>
    <p><font color="#000000" size="1" face="Courier New">MainFrm.cpp</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////////////////////////////////////////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
1997 Microsoft Systems Journal. </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If this program works, it was written by Paul DiLascia.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If not, I don't know who wrote it.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;StdAfx.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;DibView.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;MainFrm.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149;</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DragAcceptFiles(TRUE);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Install palette handler.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Mainframe doesn't draw, only views--so palette is NULL.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_palMsgHandler.Install(this,
NULL);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="1" face="Courier New">Doc.h</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;dib.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Document class just holds a DIB</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">class
CDIBDoc : public CDocument {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">protected:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DECLARE_DYNCREATE(CDIBDoc)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDIBDoc();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDib
m_dib; // the DIB</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DECLARE_MESSAGE_MAP()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">public:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">virtual
~CDIBDoc();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">virtual
BOOL OnOpenDocument(LPCTSTR lpszPathName);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">virtual
void DeleteContents();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDib*
GetDIB() { return &amp;m_dib; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<blockquote>
    <p><font color="#000000" size="1" face="Courier New">Doc.cpp</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////////////////////////////////////////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
1997 Microsoft Systems Journal. </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If this program works, it was written by Paul DiLascia.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If not, I don't know who wrote it.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;StdAfx.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;DibView.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;Doc.h&quot;</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
CDIBDoc::OnOpenDocument(LPCTSTR lpszPathName)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DeleteContents();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
m_dib.Load(lpszPathName);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
CDIBDoc::DeleteContents()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_dib.DeleteObject();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<blockquote>
    <p><font color="#000000" size="1" face="Courier New">View.h</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;PalHook.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
DIB view class. A scroll view that draws DIBs and realizes
palettes.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The second problem I
    encountered implementing CPalMsgHandler is that it needs to
    handle messages a little differently depending on whether the
    window hooked is a frame window or a child view. If you
    remember, CMainFrame::OnQueryNewPalette broadcasts the
    message to its children, whereas CDIBView::OnQueryNewPalette
    realizes its palette. Rather than implement two classes,
    CMainFramePalMsgHandler and CViewPalMsgHandler, I decided to
    test inside CPalMsgHandler whether the hooked window is a
    top-level frame or a child window. This approach is a little
    less object-oriented from a purist&#146;s perspective, but it
    makes CPalMsgHandler easier to use and more foolproof since
    there&#146;s only one class to deal with.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Finally, so that
    CPalMsgHandler works in apps that don&#146;t use doc/view,
    where the frame draws directly in its client area, I modified
    the logic slightly. CPalMsgHandler gives the frame window
    first crack at realizing the palette by calling
    DoRealizePalette first, in OnQueryNewPalette and
    OnPaletteChanged. In vanilla doc/view apps like DIBVIEW,
    you&#146;ll Install your main frame with a NULL palette, in
    which case DoRealizePalette does nothing and CPalMsgHandler
    passes the messages on to the frame&#146;s children. Main
    frames that draw can Install their CPalMsgHandlers with a
    non-NULL palette.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CPalMsgHandler works like a
    charm. More important, it&#146;s reusable. If I ever write
    another app that does palettes&#151;maybe a video editor or
    paint program&#151;I can just plop my palette handler in and
    give it a palette. That&#146;s a lot easier and more reliable
    than copying and pasting code from some other app and then
    changing the variable names (and probably making a mistake in
    the process). While the chances are pretty good that
    CPalMsgHandler will work straight out of the box in my new
    app, what if it doesn&#146;t? Maybe CPalMsgHandler isn&#146;t
    quite general enough. Maybe I&#146;ll have to modify it
    slightly, perhaps adding another virtual function. Or maybe
    I&#146;ll have to do something that makes it faster. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In fact, this actually
    happened in real life. When I converted DIBVIEW to a DLL
    running with apartment model threading, I had to add a line
    in OnSetFocus to call SetForegroundWindow to get the palette
    realization to work right. What&#146;s my point? That&#146;s
    how you improve your code&#151;by stressing it in different
    situations. But now when I do improve CPalMsgHandler, DIBVIEW
    and all the other apps that use it get the improvement free,
    just by recompiling with the new version. If I had copied the
    code from program to program and replicated source files like
    a human Xerox machine, it&#146;s unlikely I&#146;d bother to
    back-port my improvements to all those apps. But when the
    code lives in only one place, it&#146;s easy.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Of course, it took me a little
    extra time and effort to encapsulate my palette-handling code
    in a reusable class, and time is precious when you have
    Acme&#146;s Maximum Leader breathing down your back. It also
    took some extra time to write CMsgHook. But look what I
    gained: CMsgHook is a totally general mechanism whose
    usefulness extends way beyond palettes. You can use it to
    encapsulate window behavior into little objects you plop in
    your window objects to do various things. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Windows is full of patterns
    like the palette. For example, when you want to draw your own
    title bar, there are several messages you have to handle:
    WM_NCPAINT, WM_SETTEXT, and WM_NCACTIVATE. The overall
    pattern of message handling is the same every time. The only
    thing that&#146;s different is what you do when it comes time
    to actually paint the caption. You could use CMsgHook to
    implement a CCaptionPainter class that handles all the
    mechanics of these messages and calls one virtual function,
    OnPaintCaption, to actually paint the caption. The
    possibilities are endless. You could use CMsgHook to
    implement a CDragMove class that handles WM_LBUTTONDOWN,
    WM_LBUTTONUP, and WM_MOUSEMOVE to support moving a window by
    dragging its client area. ISVs could use CMsgHook to develop
    extension classes that send private messages to themselves,
    without forcing application developers to derive from new
    classes. All the application programmer has to do is hook up
    the hooks and compile. As a tool supplier, you don&#146;t
    have to know which C++ class your hook will end up in (CView
    or CBetterView). As a tool consumer, you can use as many
    kinds of hooks as you need in your window object. And as I
    hope I&#146;ve shown you, the supplier/consumer distinction
    is conceptual, not physical; any time you write an app, you
    can be both a supplier and a consumer of your own tools.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Final
Feature Fun</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">OK, now that you&#146;ve
    learned how to load and draw DIBs, built a cool MFC
    subclassing extension, solved the palette problem, and saw
    what it means for software to be truly reusable, it&#146;s
    time to put the icing on the cake! I&#146;m talking about
    features, of course. That&#146;s what makes software
    fun&#151;doing neat things. In addition to displaying the
    image itself, the Acme spec also calls for displaying the
    information from the BITMAPINFOHEADER in the user&#146;s
    choice of font. And it&#146;s gotta do printing, too. In the
    hopes of impressing Maximum Leader and getting another
    deadline extension, I decided to add a zoom feature that
    magnifies or shrinks the image.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Printing is, for some reason,
    always the orphan child when it comes to application
    development, probably because the printer is black-and-white
    and down the hall, while the screen has lots of pretty colors
    and sits right in front of you. In any case, printing is one
    place MFC really shines. The framework has built-in command
    handlers and functions to run the proper dialogs. The default
    OnPrint function for CView calls your view&#146;s OnDraw
    function to draw on the printer instead of the screen. In
    other words, MFC makes printing work without you having to
    write even a single line of code!</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Well, almost. </font><font
    color="#000000" size="1" face="verdana,arial,helvetica">Figure
    6</font><font color="#000000" size="2"
    face="verdana,arial,helvetica"> shows what happened (actual
    size) the first time I tried printing one of my bitmaps.
    Great for printing postage stamps, but not for viewing
    hardcopy DIBs. The problem is that CDIBView uses MM_TEXT as
    the default drawing mode, which means all my dimensions
    (width and height) are measured in pixels, which have no
    intrinsic metric. If my screen has 75 dots per inch and my
    bitmap is 300 pixels wide, that&#146;s four inches. On the
    printer, where I have 300 dots per inch, that&#146;s only one
    inch&#151;a bit hard to see without a magnifying glass. Alas,
    printing is never as simple as just drawing to the printer
    instead of the screen. </font></p>
    <p><img src="mfc6.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;6&nbsp;Too&nbsp;small</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Fortunately, the pixel problem
    isn&#146;t hard to fix. Just override OnPrint and convert all
    units to something meaningful, like inches. To make printing
    WYSIWYG, I used the formula</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">xPrinter = xScreen *
    (PrinterPPI / ScreenPPI)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">That is, to convert a
    dimension from screen to printer units, multiply by the ratio
    (PrinterPPI&nbsp;/&nbsp;ScreenPPI), where PrinterPPI is the
    number of pixels per inch for the printer and ScreenPPI is
    the number of pixels per inch for the screen. You can get the
    number of pixels per inch for any device by calling
    GetDeviceCaps(LOGPIXELSX). Since the aspect ratio is not
    necessarily one, there&#146;s also LOGPIXELSY for the <i>y</i>
    direction. I&#146;ll spare you the details; take a look at
    CDIBView::OnPrint in View.cpp in <b>Figure 5</b>.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Once I modified OnPrint,
    printing worked fine, but I should point out that there are
    other ways to handle metrics. If you use some other mapping
    mode like MM_LOMETRIC or MM_HIENGLISH, where units are in
    millimeters or inches, then the same OnDraw function will
    work for drawing on the screen or printer&#151;but you have
    to convert your bitmap dimensions to millimeters or inches
    first, because the bitmap info is always in pixels.
    There&#146;s no way to avoid a conversion somewhere. For
    DIBs, the BITMAPINFOHEADER has two fields, biXPelsPerMeter
    and biYPelsPerMeter, that specify the number of pixels per
    meter in <i>x</i> and <i>y</i> for the device on which the
    image was originally captured. This information is there to
    tell you how big the image is in real life. Unfortunately,
    these fields are often zero because capture programs
    don&#146;t bother to fill them in or some editing tool throws
    them away. Nevertheless, good imaging tools do use them, so a
    commercial DIB program should look at biXPelsPerMeter and
    biYPelsPerMeter to calculate the display/print dimensions. I
    was lazy so I punted (I have to save something for Release
    2).</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you remember from January,
    CDib uses DrawDib to do dithering. Printing is where DrawDib
    really shows its colors&#151;even in black and white! <b>Figure
    7</b> shows printing without dithering; <b>Figure 8</b> shows
    printing with it. Quite a difference!</font></p>
    <p><img src="mfc7.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
7 Pre-DrawDib output</b></font></p>

<blockquote>
    <p><img src="mfc8.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
8 Printout with DrawDib</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Next on my feature list was
    displaying the information in the BITMAPINFOHEADER. This one
    is trivial. CDIBView::DrawBITMAPINFOHEADER formats all the
    information into a string using printf&#151;er, I mean
    CString::Format. It then calls DrawTextEx (which for some
    reason has no CDC wrapper) with DT_EXPANDTABS and DT_TABSTOP,
    to set a tab stop so the text lines up nicely whether the
    user chooses a monospaced or variable-width font.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>CFontUI:
A Quick Font Goodie</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Speaking of fonts, the spec
    calls for letting the user select the font: Arial,
    Copperplate, Dingbats, whatever. Also, since the UI
    guidelines for Quick View file viewers suggest using buttons
    to increment/decrement the font point size, and since my
    ultimate goal is to convert DIBVIEW into a file viewer, I
    decided now would be a good time to add the buttons. So I
    encapsulated all this font functionality into a single class,
    CFontUI, with one multipurpose function, OnChangeFont, that
    handles all three cases (see FontUI.h and FontUI.cpp in<b>
    Figure 5</b>).</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CFont font; // some font</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CFontUI fui; // Font UI</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">fui.OnChangeFont(font,
    opcode);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If opcode is negative,
    OnChangeFont shrinks the font; if opcode is positive,
    OnChangeFont makes the font bigger; if it&#146;s zero,
    OnChangeFont runs the common dialog CFontDialog. The details
    are just a lot of font mechanics: converting point sizes to
    pixel heights, calling CreateFontIndirect, running
    CFontDialog::DoModal, and so on. When CFontUI shrinks or
    grows the font, it uses an algorithm that adjusts the
    increment depending on how big the font currently is. For
    example, if the font is 10 points, CFontUI
    increments/decrements by one point; if the font is 32 points,
    CFontUI increments/decrements by four points, to 28 or 36
    points. I got this idea from a sample text-file viewer on
    MSDN. Naturally, the function that implements the algorithm
    is virtual, so you can override it.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CFontUI also has
    Get/SetFontPointSize functions that do the standard
    points-to-logical-device-units conversion. As an added bonus,
    I threw in a couple of functions to load and save the font
    spec to the application profile (the .INI file or registry).
    If you have a font, all it takes to save it is a single line
    of code:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CFontUI().WriteProfileFont(&quot;Settings&quot;,&quot;Font&quot;,font);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">My syntax may be unfamiliar to
    non-C++ gurus. I&#146;ve used the ultra-terse trick of
    invoking the constructor to create a nameless CFontUI object
    on the stack, then call one of its member functions. The
    above line is equivalent to this:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CFontUI fui;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">fui.WriteProfileFont(&quot;Settings&quot;,
    &quot;Font&quot;,font);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">WriteProfileFont writes the
    information to the registry in the format shown in </font><font
    color="#000000" size="1" face="verdana,arial,helvetica">Figure
    9</font><font color="#000000" size="2"
    face="verdana,arial,helvetica">; ReadProfileFont reads this
    format. I have to emphasize once more that by encapsulating
    all the font code in a little class, you don&#146;t just get
    a feature for DIBVIEW, you get a reusable software component.
    I&#146;d long thought of modifying my TRACEWIN program to let
    users select different fonts, but never bothered because the
    feature would be useless without saving the font across
    sessions, and I was too lazy to do it. But once I had
    CFontUI, it took five minutes to update TRACEWIN with the new
    feature.</font></p>
    <p><img src="mfc9.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
9 WriteProfileFont registry entry</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">One final trick before I leave
    fonts for good. When I first implemented the choice-of-fonts
    feature, I made the current font a data member of my view
    class.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">class CDIBView : public
    CScrollView {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CFont m_font; // current font</font></p>
    <blockquote>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
        <p><font color="#000000" size="3" face="Courier New">&#149;</font></p>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Then I called all my nifty
    CFontUI functions with m_font as the CFont argument. This
    worked fine in the SDI version of DIBVIEW, but when I
    compiled it for MDI, I quickly realized I didn&#146;t want
    each view to have its own font; I wanted the whole app to
    have a single font. If the user changes the font, it should
    affect all views, not just the active one. At first I figured
    I&#146;d have to move m_font to CApp or CMainFrame, but an
    even simpler solution came to me: make the font
    static&#151;that is, a class global for CDIBView (I changed
    the name to g_font to remind you).</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">This worked fine, except the
    new problem was how to get all the views to recompute their
    scroll sizes and redisplay themselves when the user changes
    the font. UpdateAllViews is no good because it only updates
    the views for one document. I wanted to update all the views
    for all the documents. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The simplest solution proved
    to be broadcasting WM_INITIALUPDATE from the top-level frame
    to all children.</font></p>
    <blockquote>
        <blockquote>
            <blockquote>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">void
                CDIBView::OnFontChange(UINT nID)</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">{</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">CFontUI fui;</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">if
                (fui.OnChangeFont(...)) {</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">GetTopLevelFrame()-&gt;</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">SendMessageToDescendants(WM_INITIALUPDATE);</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">}</font></p>
                <p><font color="#000000" size="2"
                face="verdana,arial,helvetica">}</font></p>
            </blockquote>
        </blockquote>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">(Notice I didn&#146;t call
    with bOnlyPerm=TRUE!) Now all the views get reinitialized.
    Since OnInitialUpdate is where I compute scroll sizes, this
    is just what I needed.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">You needn&#146;t worry that
    WM_INITIALUPDATE is undocumented; it isn&#146;t going
    anywhere. Just remember to #include &lt;afxpriv.h&gt;. One
    thing you do have to worry about is whether your
    OnInitialUpdate handler expects to get called again when
    it&#146;s not really first-time initialization, but ongoing
    reinitialization. For example, as a bonus feature to impress
    you-know-who, I modified OnInitialUpdate to call
    CScrollView::SizeToFit so the window (MDI child or SDI frame)
    starts out the perfect size to accommodate its DIB with no
    scroll bars. Well, this is good the first time you run
    DIBVIEW, but I don&#146;t want the window changing its size
    every time the user changes the font! So I added a flag to
    confine this part of initialization to first-time-init only.
    Just something to be aware of.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">My final feature is the
    magnify/zoom feature, which is really easy. I added a View
    Zoom command with popups for 1/4</font><font color="#000000"
    size="2" face="Symbol">´</font><font color="#000000"
    size="2" face="verdana,arial,helvetica">, 1/2</font><font
    color="#000000" size="2" face="Symbol">´</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">, 1</font><font
    color="#000000" size="2" face="Symbol">´</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">, 2</font><font
    color="#000000" size="2" face="Symbol">´</font><font
    color="#000000" size="2" face="verdana,arial,helvetica"> and
    4</font><font color="#000000" size="2" face="Symbol">´</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">
    magnification, and I also added mouse double-click handlers,
    so DIBVIEW doubles the zoom factor if the user double-clicks
    the mouse on the bitmap image. If the user double-clicks with
    the right button, DIBVIEW halves the zoom factor. (If the
    user double-clicks on the text, DIBVIEW runs the font
    dialog.) To implement zooming, all I had to do was add a
    scale factor, m_iZoom (this time I want each view to have its
    own), that ranges from&nbsp;&#150;2 to +2, and a rectangle,
    m_rcDIB, that represents the client-area destination
    rectangle for drawing the DIB. I compute this rectangle in
    OnInitialUpdate by left or right-shifting the true DIB
    rectangle by my zoom factor.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><b>Figure 10</b> shows the
    final SDI version of DIBVIEW, and<b> Figure 11</b> shows the
    MDI version in all its glory, with font buttons, bitmap info
    displayed, generic palette handler class (you can&#146;t see
    that), and several images of different sizes and color
    resolutions open at once. All the images show their true
    colors because I took the screen capture while running in
    32-bit color mode. </font></p>
    <p><img src="mfc10.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;10&nbsp;SDI&nbsp;DIBVIEW</b></font></p>

<blockquote>
    <p><img src="mfc11.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
11 MDI DIBVIEW</b></font></p>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>To
Be Continued...</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I&#146;ve shown you how to
    build several reusable classes that extend MFC and make
    writing apps easier.<b> Figure 12</b> lists them. I used
    these goodies to grow DIBVIEW from a baby bitmap viewer that
    didn&#146;t even get palettes right into a full-fledged app
    with printing, the user&#146;s choice of font,
    BITMAPINFOHEADER, and SDI and MDI versions. Each time I added
    some new feature, I took a little extra time to encapsulate
    it in a general-purpose, reusable class. If you take my lead
    and do things this way, you win on two counts. First, you get
    reusable objects that make the next app even easier to write.
    Second, even if you write only one app, its internal
    structure will be more coherent and hence bug-free when
    independent behavior is isolated in independent components.
    The alternative to this is called spaghetti code. </font></p>
    <p><img src="mfc12.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;12&nbsp;MFC
Goodies Described in the Article</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Despite Hurculean efforts to
    beat the clock, by the time I finished DIBVIEW I&#146;d
    busted my schedule by at least seven hours. Needless to say,
    Mr. Maximum Leader was not thrilled. Fortunately, after I
    gave him a demo of DIBVIEW using some images I scanned off
    recent covers of <i>Cosmopolitan</i> magazine, his mood
    softened.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&quot;OK, I&#146;ll give ya
    another two days.&quot;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Two days?! To convert DIBVIEW
    to a Quick View file viewer? Yikes! Stay-tuned to see if I
    make it.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>To
obtain complete source code listings, see</b></font><a
href="ednote.htm"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b> Editor's page</b></font></a><font
color="#000000" size="2" face="verdana,arial,helvetica"><b>.</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><i>This article is reproduced
    from Microsoft Systems Journal. Copyright © 1997 by Miller
    Freeman, Inc. All rights are reserved. No part of this
    article may be reproduced in any fashion (except in brief
    quotations used in critical articles and reviews) without the
    prior consent of Miller Freeman.</i></font></p>
    <p><font color="#000000" size="2"><i>To contact Miller
    Freeman regarding subscription information, call (800)
    666-1084 in the U.S. and Canada, or (303) 678-0439 in all
    other countries. For other inquiries, call (415) 905-2200.</i></font></p>
</blockquote>
</font></body>
</html>
