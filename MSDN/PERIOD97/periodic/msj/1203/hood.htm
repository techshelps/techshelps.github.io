<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Adobe application">
<meta name="Template" content="C:\MSOffice\Templates\MSJ.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Under the Hood</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<p><font color="#000000" size="6" face="verdana,arial,helvetica">Under
the Hood</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica">by Matt Pietrek</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Matt Pietrek is the author of
Windows 95 System Programming Secrets (IDG Books, 1995). He works
at NuMega Technologies Inc., and can be reached at
mpietrek@sprynet.com.</b></font></p>

<blockquote>
    <p><font color="#000080" size="7"
    face="B New Century Schlbk Bold">C</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">ertain
    Windows® programming topics are timeless. Questions about
    them keep coming up, despite the ever growing list of
    knowledge bases and publications. One such topic is timers
    and DispatchMessage. I&#146;ve seen this particular subject
    trip up even grizzled Windows veterans because they first
    encountered timers in those prehistoric days when 16-bit
    Windows programs roamed the land. Improvements and extensions
    to the Win32® architecture have made DispatchMessage and
    timers behave differently (or at least appear that way). With
    this in mind, a fresh 32-bit expedition into the subject is
    in order. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Since you&#146;re probably not
    reading this column while sitting in front of the Win32
    documentation, I&#146;ll do a quick review of the SetTimer
    function. The SetTimer function is the traditional method of
    initiating a timer in Windows (both 16 and 32-bit). As
    parameters, it takes an HWND, a timer interval, a timer ID
    (which you supply), and the address of a callback function.
    The callback function is of type TIMERPROC.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you pass a non-null HWND
    after the specified interval has passed, a WM_TIMER message
    is posted to the window and the TIMERPROC parameter is
    ignored. The other option is passing a null HWND and a valid
    TIMERPROC address. In this case, after the specified time has
    elapsed, the HWND is ignored and the system calls your
    TIMERPROC function. In either case, you shouldn&#146;t rely
    on the timer to be extremely accurate, as you&#146;re subject
    to the unpredictability of Win32 thread scheduling.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">With this quick review out of
    the way, consider a ques-tion I&#146;ve heard several times
    recently: &quot;I&#146;ve called SetTimer in a program that
    doesn&#146;t have any windows. Therefore, I set the timer to
    call a function, rather than post a message to a window.
    However, my timer callback (see <b>Figure 1</b>) is never
    called.&quot;</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;1&nbsp;CONSOLE_WM_TIMER.CPP</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Matt Pietrek</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, March 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: CONSOLE_WM_TIMER.CPP</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
To build: &quot;CL CONSOLE_WM_TIMER.CPP USER32.LIB&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
WIN32_LEAN_AND_MEAN</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;windows.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;stdio.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;conio.h&gt;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
A do-nothing TIMERPROC. Simply prints out the parameters</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">VOID
CALLBACK MyTimerProc( HWND hwnd, UINT uMsg, UINT idEvent, DWORD
dwTime );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
main()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Set up a 50 millisecond timer which calls MyTimerProc</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">SetTimer(
0, 0, 0x50, (TIMERPROC)MyTimerProc );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;A timer proc has been set up. Press any key to
exit.\n&quot;);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">getch();
// Wait for user response. This gives enough time for at</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
least one timer cycle to have elapsed</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">VOID
CALLBACK MyTimerProc( HWND hwnd, UINT uMsg, UINT idEvent, DWORD
dwTime )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;In MyTimerProc: hwnd:%X uMsg:%X idEvent:%X
dwTime:%X\n&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">hwnd,
uMsg, idEvent, dwTime );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">My immediate response is to
    ask if their program has a DispatchMessage loop. They&#146;ll
    reply that they shouldn&#146;t need one. After all, they told
    SetTimer to call their TIMERPROC rather than post a message.
    The problem is that calling DispatchMessage isn&#146;t
    optional if you&#146;re using timers. As you&#146;ll see
    later, DispatchMessage is needed for both varieties of timer
    notifications (that is, window messages and callback
    functions).</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To prove that DispatchMessage
    really is necessary, run the code in <strong>Figure 1</strong>.
    The program sits at a prompt, and you&#146;ll never see the
    message that&#146;s printed inside the MyTimerProc function.
    Next, run CONSOLE_WM_TIMER2 (see <b>Figure 2</b>). The code
    is identical to the first program, except that it adds a call
    to GetMessage followed by a call to DispatchMessage. Yes, it
    may seem a little strange for a console program to retrieve
    and dispatch window messages, but hey, it works, and the
    TIMERPROC function gets called.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;2&nbsp;CONSOLE_WM_TIMER2.CPP</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Matt Pietrek</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, March 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: CONSOLE_WM_TIMER2.CPP</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
To build: &quot;CL CONSOLE_WM_TIMER2.CPP USER32.LIB&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
WIN32_LEAN_AND_MEAN</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;windows.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;stdio.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;conio.h&gt;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
A do-nothing TIMERPROC. Simply prints out the parameters</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">VOID
CALLBACK MyTimerProc( HWND hwnd, UINT uMsg, UINT idEvent, DWORD
dwTime );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
main()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Set up a 50 millisecond timer which calls MyTimerProc</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">SetTimer(
0, 0, 0x50, (TIMERPROC)MyTimerProc );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;A timer proc has been set up. Press any key to call &quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;GetMessage/DispatchMessage\n&quot;
);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">getch();
// Wait for user response. This gives enough time for at</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
least one timer cycle to have elapsed</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MSG
msg = { 0, 0, 0, 0 };</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get the message, and dispatch it. This causes MyTimerProc to be</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
invoked.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( GetMessage(&amp;msg, 0, 0, 0) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DispatchMessage(
&amp;msg );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">VOID
CALLBACK MyTimerProc( HWND hwnd, UINT uMsg, UINT idEvent, DWORD
dwTime )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;In MyTimerProc: hwnd:%X uMsg:%X idEvent:%X
dwTime:%X\n&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">hwnd,
uMsg, idEvent, dwTime );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">How is this behavior different
    between 16 and 32-bit programs? It isn&#146;t really, but
    remembering to call DispatchMessage usually isn&#146;t an
    issue for 16-bit programs. Strange as it might seem now,
    16-bit Windows doesn&#146;t support console applications.
    Therefore, nearly every 16-bit Windows program creates
    windows, and hence, has a message loop. The message loop
    might be explicit or hidden. As an example of a hidden
    message loop, think about a DialogBox-based program. The
    DialogBox API spends most of its time in a message loop
    inside USER.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Because 16-bit programs have
    message loops, the 16-bit Windows documentation doesn&#146;t
    bother to tell you that DispatchMessage is a necessary
    complement to timers. In reading the Remarks section of the
    32-bit SetTimer documentation, you&#146;ll come across this: <i>&quot;When
    you specify a TimerProc callback function, the
    DispatchMessage function simply calls the callback function
    instead of the window procedure. Therefore, you need to
    dispatch messages in the calling thread, even when you use
    TimerProc instead of processing WM_TIMER.&quot;</i></font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If there&#146;s a lesson here,
    that lesson is that it&#146;s a good idea to occasionally
    review the API documentation. A lot of what you learned in
    the days of 16-bit Windows may be incomplete or inaccurate.
    I&#146;m certainly guilty of skimming the Win32 documentation
    because the prototype of the API at the top looks familiar.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">While the easy answer here is
    to process window messages, it may not be practical. There
    are other ways to get periodic callbacks under Win32. If your
    needs are simple and you want to keep things light, consider
    this option: start a second thread to act as a timer thread.
    The second thread enters into a loop, first calling the Sleep
    API for the desired interval, and then calling your callback
    function. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">There&#146;re two potential
    pitfalls with this that you should be aware of. First, the
    true period of the callbacks will be (at a minimum) the time
    spent in the Sleep function as well as the time spent in the
    callback function. You can theoretically prevent some of the
    vagaries of scheduling by making the timer thread a higher
    priority thread than normal. However, there&#146;s still no
    guarantee about scheduling, and some people will argue that
    high-priority threads, if used excessively, can degrade
    overall system performance and scheduling smoothness.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The other problem with
    creating a second timer thread with a Sleep loop is that the
    callback function will be called from a different thread than
    your primary thread. If you&#146;re not relying on anything
    that&#146;s thread-sensitive (such as global data), this
    shouldn&#146;t be a problem. If you&#146;re using
    thread-sensitive resources, your code needs to use the
    appropriate synchronization mechanisms. A regular
    SetTimer-style timer doesn&#146;t have this problem, as the
    callback function is invoked in the same thread that called
    SetTimer.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Beyond this simple homegrown
    approach, there are a couple of other solutions to consider.
    First, there are the multimedia timers. I won&#146;t rehash
    the SDK documentation on them here. The key thing is
    they&#146;re not dependent on DispatchMessage to invoke the
    callback function. Like the homegrown solution, they also run
    in a separate thread. To learn more about them, see the
    timeSetEvent API function (and friends).</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The second timer solution is
    the Waitable Timer objects, which are new in Windows NT¨
    4.0. While they&#146;re oriented toward threads that need to
    block for a specified period of time, they also support a
    completion function that&#146;s called after the specified
    time elapses. In the Win32 documentation, see the
    CreateWaitableTimer and SetWaitableTimer APIs. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Here&#146;s another question
    that highlights a difference between 16 and 32-bit Windows
    timers: &quot;I&#146;ve recently been rewriting a 16-bit
    Windows application to run under Windows NT. The original
    program uses the PostMessage(WM_TIMER) trick to force code in
    my task to execute in the context of another task. This trick
    doesn&#146;t seem to work under Windows NT (or Windows 95 for
    that matter).&quot;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">When I saw this question, it
    made me smile because it momentarily transported me back to
    the days when gross system-level hacks were often relatively
    easy to pull off. This was due to the fact that 16-bit
    Windows was relatively unsecure and didn&#146;t do much to
    prevent devious or malicious programs from doing things that
    most other operating systems won&#146;t allow. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you&#146;re not familiar
    with the trick, it&#146;s pretty simple. Let&#146;s say you
    wanted some code you wrote to execute in the context of
    another application. By posting a particular WM_TIMER message
    to a window owned by the desired task, you could coerce
    Windows into executing your code in that task&#146;s context.
    The trick was to create and post a WM_TIMER message with the
    LPARAM holding a pointer to a TIMERPROC function of your own
    devising. When the other task retrieved and dispatched this
    WM_TIMER message, your TIMERPROC would be called in that
    task&#146;s context. Clever, eh? </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The unspoken assumption that
    lets this hack-o-rama succeed is that your TIMERPROC code is
    visible within the context of the desired task. This
    isn&#146;t an issue in 16-bit Windows because there is just
    one address space shared by all tasks. Any task can see all
    the memory of any other task. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In contrast to this brazen
    cohabitation, Windows NT and Windows 95 have separate address
    spaces for each process. Therefore, the odds are reasonably
    high that your code isn&#146;t loaded in the address space of
    some other process that you&#146;d like to execute in the
    context of. Sure, you can still post a WM_TIMER message with
    an LPARAM containing a pointer to your code. What will
    Windows NT and Windows 95 do when they try to dispatch a
    WM_TIMER message with an LPARAM pointing to code that&#146;s
    not loaded in the receiving process&#146;s address space?
    This question provides a good segue into an examination of
    the DispatchMessage code.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>What
Does DispatchMessage Do?</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In my book, <i>Windows
    Internals (Addison-Wesley, 1993)</i>, I created pseudocode
    for the DispatchMessage function as implemented in Windows
    3.1. Since then, I haven&#146;t paid much attention to this
    API. While researching this column, I decided it was time to
    examine how DispatchMessage has evolved to handle the much
    more complex environment of Windows NT 4.0. The result of my
    work is the pseudocode for Windows NT 4.0 DispatchMessage,
    which is given in <b>Figure 3</b>.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
3&nbsp; Ring 3 DispatchMessage Pseudocode</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//=================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Matt Pietrek</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, March 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Pseudocode for ring 3 portion of DispatchMessage</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//=================================================</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LONG
DispatchMessageA( CONST MSG *lpmsg )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
DispatchMessageWorker( lpmsg, 1 ); // 0 == UNICODE, 1 = ANSI</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LONG
DispatchMessageWorker( CONST MSG *lpmsg, BOOL fAnsi )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( lpmsg-&gt;message == 0xFFFE0000 )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_UserSetLastError(
ERROR_INVALID_PARAMETER );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0; </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If we have a non-null HWND, convert it to a pointer to the user
mode</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
WND structure. We'll use this ptr extensively.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( lpmsg-&gt;hwnd )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pWnd
= @ValidateHwnd( lpmsg-&gt;hwnd );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !pWnd )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pWnd
= 0;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( (lpmsg-&gt;message != WM_TIMER) &amp;&amp; (lpmsg-&gt;message
!= WM_SYSTIMER) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">begin_normal_message:</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pWnd == 0 ) // Sanity check. We'd better have a valid window!</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
save_wParam = lpmsg-&gt;wParam;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( (lpmsg-&gt;message != WM_PAINT) &amp;&amp;
!(pWnd-&gt;someFlags9E &amp; 4) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( IsWindowUnicode( lpmsg-&gt;hwnd ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( fAnsi )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlMBMessageWParamCharToWCS(
lpmsg-&gt;message, save_wParam );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlWCSMessageWParamCharToMB(
lpmsg-&gt;message, save_wParam );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Is the high bit in the wndproc address set? If so, this is a</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
16 bit window, and pfnWndProc is a 16:16 far address. To get</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
the real address, turn off the high bit (0x80000000)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( 0 == (pWnd-&gt;pfnWndProc &amp; 0x80000000) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pWnd-&gt;pfnWndProc(
lpmsg-&gt;hwnd, lpmsg-&gt;message,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">lpmsg-&gt;wParam,
lpmsg-&gt;lParam );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pfnWowWndProcEx(
lpmsg-&gt;hwnd, lpmsg-&gt;message, save_wParam,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">lpmsg-&gt;lParam,
lpmsg-&gt;message, pWnd-&gt;0x90 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
// WM_PAINT, or something else...</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( fAnsi )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_RtlMBMessageWParamCharToWCS(
lpmsg-&gt;message, save_wParam ); </font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_NtUserDispatchMessage(
lpmsg ); </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">lpmsg-&gt;wParam
= save_wParam;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
// WM_TIMER &amp;&amp; WM_SYSTIMER</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">TIMERPROC
pfnTimerCallback = lpmsg-&gt;lParam;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pfnTimerCallback == 0 )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">goto
begin_normal_message;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( lpmsg-&gt;message == WM_SYSTIMER )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
_NtUserDispatchMessage( lpmsg );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pfnTimerCallback( lpmsg-&gt;hwnd,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">lpmsg-&gt;message,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">lpmsg-&gt;wParam,
// wTimerId</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">GetTickCount()
); // actually, an inline</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
version of the code</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
in KERNEL32.DLL</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">You can see that the
    DispatchMessageA function is just a wrapper around an
    internal USER32 function called DispatchMessageWorker.
    Besides a pointer to the message to dispatch,
    DispatchMessageWorker takes a parameter that specifies
    whether it was called in its ANSI flavor (DispatchMessageA)
    or Unicode (DispatchMessageW). DispatchMessageWorker needs to
    know this so that it can convert characters passed in the
    WPARAM to the ANSI or Unicode form that the target window
    expects.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The first significant thing
    DispatchMessageWorker does is extract the HWND from the MSG
    structure and pass it to the @ValidateHwnd function. This
    serves two purposes. Obviously, it ensures that the message
    will be dispatched to a valid window. More interestingly,
    @ValidateHwnd returns a pointer to an internal data structure
    that represents a window (which I&#146;ve called a WND
    structure in the pseudocode). </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The fact that @ValidateHwnd
    returns a WND pointer surprised me at first. The window data
    structure contains very sensitive internal system
    information. Normally, ring 3 code (including ring 3 system
    DLLs like USER32.DLL) isn&#146;t supposed to have access to
    this privileged information. Further investigation lead to an
    interesting discovery. In Windows NT, WND data structures are
    kept in memory above 2GB, which is owned by WIN32K.SYS (the
    Windows NT 4.0 ring 0 portion of USER32). As you may know,
    addresses above 2GB in Windows NT are off-limits to ring 3
    code. Specifically, these addresses have the supervisor
    attribute (in the Intel architecture), and ring 3 code will
    fault if it tries to access these addresses. So how does the
    ring 3 USER32 get a pointer to a WND structure? It turns out
    that Windows NT uses the processor&#146;s page tables to
    create a read-only range of addresses below 2GB that map to
    the same physical memory as the ring 0 WND structures above
    2GB. Thus, the ring 3 USER32.DLL can read, but not write, the
    WND structures maintained by WIN32K.SYS.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Returning to the ring 3
    DispatchMessageWorker code, the remainder of the function
    splits into two major parts. The latter part executes if the
    messages is a WM_TIMER or WM_SYSTIMER message. The former
    part is for handling all other messages. This is further
    evidence that timer messages are handled specially by the
    system. Incidentally, WM_SYSTIMER is a well-known yet still
    undocumented message. Windows uses WM_SYSTIMER for internal
    actions like scrolling.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In the timer section of the
    DispatchMessageWorker function, if the timer was set up to
    post a window message, the code simply jumps to where normal
    messages are dispatched. In other words, if you receive your
    timer notifications via a WM_TIMER message,
    DispatchMessageWorker treats the timer message like any other
    message. Special processing is only required if the timer is
    set up to call a TIMERPROC function. In the case of the
    WM_TIMER message, DispatchMessageWorker extracts the
    TIMERPROC address from the message&#146;s LPARAM and just
    calls it. If the timer is a WM_SYSTIMER type,
    DispatchMessageWorker lets another internal function,
    NtUserDispatchMessage, handle it.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">What does
    DispatchMessageWorker do with regular, non-timer window
    messages? The dispatching of these messages depends on what
    type of window (16 or 32-bit) the dispatchee window is, as
    well as whether the message is a WM_PAINT message. In the
    simplest case, DispatchMessageWorker simply reaches into the
    WND procedure, grabs out the WNDPROC address, and calls it
    with the appropriate parameters. Since some messages contain
    character values in their WPARAM, DispatchMessageWorker makes
    the appropriate conversions between ANSI and Unicode
    characters as necessary.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If the message being
    dispatched is for a 16-bit window, a special function,
    pfnWowWndProcEx, handles the message. Why would a 32-bit app
    be retrieving and dispatching messages for a 16-bit window?
    The answer is WOW (yep, that horrible acronym for Windows on
    Windows). In Windows NT, the NTVDM process is a 32-bit
    process that encapsulates and runs 16-bit Windows-based
    applications within the otherwise entirely 32-bit system.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If the message isn&#146;t
    handled via one of the simple scenarios that I&#146;ve just
    described, DispatchMessageWorker pushes the message off to
    the ring 0 NtUserDispatchMessage I alluded to earlier. When
    this happens the message is usually a WM_PAINT. Like the
    timer messages, WM_PAINT has extra significance to the
    windowing system. It&#146;s best to let the ring 0 USER
    component, where the real brains lie, do the work. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To summarize,
    DispatchMessageWorker handles the simple messages that
    don&#146;t need much system knowledge and that can be
    dispatched with a minimum of fuss. Anything more complicated
    gets shuttled off to the NtUserDispatchMessage function in
    WIN32K.SYS at ring 0. While writing this column, I did look
    into the NtUserDispatchMessage function and found it rather
    tricky and complicated, so I won&#146;t attempt to describe
    it in this limited space.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Now let&#146;s return to what
    happens if you use the &quot;posting a phony WM_TIMER
    message&quot; trick that I described earlier. Looking at the
    pseudocode for DispatchMessageWorker and mentally executing
    the code, you&#146;ll see that execution very quickly gets to
    the else clause that handles WM_TIMER messages. Since the
    LPARAM is nonzero when using this trick, execution quickly
    gets to the line that calls through pfnTimerCallback, where
    pfnTimerCallback is whatever value is in the LPARAM.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">What&#146;s really interesting
    here is not what the code does, but what it doesn&#146;t do.
    DispatchMessageWorker makes no attempt to validate the LPARAM
    of the WM_TIMER message to see if it&#146;s a valid code
    address. Instead, DispatchMessageWorker blindly assumes that
    the LPARAM is OK and calls it. You might be tempted to think
    that the system should be smart and load in the appropriate
    code that the LPARAM points to. The problem is, how?
    There&#146;s nothing in the MSG structure that indicates
    which EXE or DLL the LPARAM code address refers to.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I personally find it very
    surprising that DispatchMessage doesn&#146;t do better
    checking on the LPARAM for WM_TIMER messages. If there&#146;s
    truly no validity checking, you could post a lethal WM_TIMER
    message with a bogus LPARAM to any window in the system and
    kill the process that owns the window. To test this out, I
    wrote a small program that kills Windows Explorer. The
    program is called WM_TIMER_TOAST, and is shown in <b>Figure 4</b>.
    The code simply locates the taskbar window on Windows NT 4.0
    or Windows 95 and posts a WM_TIMER message with a bogus
    LPARAM value to it. Luckily, the Windows Explorer process
    automatically restarts if a fault occurs in it, so you can
    run WM_TIMER_TOAST without having to reboot your system
    afterwards. It goes without saying that a malicious program
    could pick some other window besides the Explorer and wreak
    potential havoc.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;4&nbsp;WM_TIMER_TOAST.CPP</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Matt Pietrek</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, March 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: WM_TIMER_TOAST.CPP</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
To build: &quot;CL WM_TIMER_TOAST.CPP USER32.LIB&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
WIN32_LEAN_AND_MEAN</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;windows.h&gt;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
main()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get the HWND of the tray, which is owned by the Explorer process</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">HWND
hWndToToast = FindWindow( &quot;Shell_TrayWnd&quot;, 0 );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( hWndToToast )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Post the deadly WM_TIMER message.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PostMessage(
hWndToToast, WM_TIMER, 123, 0x87654321 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">What could be done to prevent
    this WM_TIMER loophole from being exploited? While digging
    around in WIN32K.SYS, I found that it uses a neat trick for
    WM_SYSTIMER messages. When Windows creates a new system
    timer, it remembers the callback address. Before dispatching
    a WM_SYSTIMER message, the system checks the LPARAM address
    against the list of registered timer callback functions. If
    there&#146;s no match, the message is tossed. This same
    technique could probably be applied to WM_TIMER message in
    the ring 3 DispatchMessage code, although it would add
    overhead to WM_TIMER dispatching.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If I were to apply a moral to
    all this, it would have to be that once again there&#146;s
    really no substitute for understanding what goes on under the
    hood of the system. In this case, the Win32¨ documentation
    doesn&#146;t really let on that timers are special in the
    eyes of DispatchMessage and the messaging system. In both of
    the questions I addressed, a rote knowledge of how to do
    things and how things work in 16-bit Windows proved to be
    insufficient in 32-bit Windows.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>To
obtain complete source code listings, see</b></font><a
href="ednote.htm"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b> Editor's page</b></font></a><font
color="#000000" size="2" face="verdana,arial,helvetica"><b>.</b></font></p>

<p><font color="#000080" size="1" face="B Franklin Gothic Demi">Have
a question about programming in Windows? Send it to Matt at </font><a
href="mailto:mpietrek@sprynet.com"><font color="#000080" size="1"
face="B Franklin Gothic Demi">mpietrek@sprynet.com</font></a><font
color="#000080" size="1" face="B Franklin Gothic Demi">.</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><i>This article is reproduced
    from Microsoft Systems Journal. Copyright © 1997 by Miller
    Freeman, Inc. All rights are reserved. No part of this
    article may be reproduced in any fashion (except in brief
    quotations used in critical articles and reviews) without the
    prior consent of Miller Freeman.</i></font></p>
    <p><font color="#000000" size="2"><i>To contact Miller
    Freeman regarding subscription information, call (800)
    666-1084 in the U.S. and Canada, or (303) 678-0439 in all
    other countries. For other inquiries, call (415) 905-2200.</i></font></p>
</blockquote>
</font></body>
</html>
