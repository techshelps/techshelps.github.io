<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Adobe application">
<meta name="Template" content="C:\MSOffice\Templates\MSJ.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Visual Programmer</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<p><font color="#000000" size="6" face="verdana,arial,helvetica">The
Visual Programmer</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica">by George Shepherd and Scot Wingo</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>George Shepherd develops
mapping software for Orbital Software and delivers training
courses for DevelopMentor. Scott Wingo is cofounder of Stingray
Software, producing MFC Extension class libraries. George and
Scot wrote MFC Internals (Addison Wesley, 1996). </b></font></p>

<blockquote>
    <p><font color="#000080" size="7"
    face="B New Century Schlbk Bold">I</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">t
    isn&#146;t enough any more to simply expose your objects
    using either COM interfaces or dispatch interfaces. Dual
    interfaces are now <i>de riguer</i>! Microsoft recommends
    using dual interfaces wherever possible so your clients have
    more flexibility in talking to your COM objects. Dual
    interfaces are fairly straightforward if you develop your COM
    objects using raw C++ or the ActiveX&trade; Template Library.
    Writing dual interfaces is more complicated if you&#146;re
    creating a COM object with MFC. For example, MFC remains the
    easiest and most efficient way of producing ActiveX controls:
    AppWizard generates one for you in a matter of seconds. Yet,
    by default, MFC-based ActiveX controls implement only a
    plain-vanilla IDispatch (the one you build up using
    ClassWizard&#146;s Automation tab). </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">What if you want to expose
    that IDispatch interface as a dual interface for clients that
    understand dual interfaces? All it takes is a bit of
    exploring MFC, learning about Object Description Language
    (ODL), and your ability to exercise the TextWizard. Some of
    this information is covered in MFC Tech Note 65, though there
    are some pieces missing (which we&#146;ll fill in here, of
    course).</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Dual
Interfaces Aplenty</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">COM supports three types of
    interfaces: pure COM, dispatch, and dual. Pure COM interfaces
    are similar to C++ vtbls. In fact, pure COM interfaces are
    defined in C++ as pure abstract base classes. Clients of COM
    objects that expose COM interfaces understand how to talk to
    the object because the COM interface is specified in a header
    file. The COM client sees the header file and is immediately
    aware of the function signatures and the order in which the
    functions appear in the table. Clients access a pure COM
    interface with the same syntax they use for a plain-vanilla
    C++ class.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">For example, given the
    following interface definition</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// ICOOL.H</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">struct ICoolInterface : public
    IUnknown {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">virtual HRESULT Function1() =
    0;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">virtual HRESULT Function2() =
    0;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">};</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">//
    {49BA7C02-40D4-11d0-8A90-E1C000C3FC20}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DEFINE_GUID(IID_ICoolInterface,
    </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">0x49ba7c02, 0x40d4, 0x11d0,
    0x8a, 0x90, </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">0xe1, 0xc0, 0x0, 0xc3, 0xfc,
    0x20);</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">a COM client can exercise the
    interface using the following code:</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">//USECOOL.CPP</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#include &quot;icool.h&quot;</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ICoolInterface* pCool;</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">void UseCoolInterface() {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if(SUCCEEDED(CoCreateInstance(CLSID_CoCoolClass,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">NULL,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CLSCTX_ALL,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">IID_ICoolInterface,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">(void**)pCool)) {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">pCool-&gt;Function1();</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">pCool-&gt;Function2();</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Notice that the COM interface
    approach involves pointers. The COM client acquires a pointer
    to an interface (not the object itself) and uses the
    interface definition to call the functions in the interface.
    While this is a great way for C++ clients to access
    functionality, it&#146;s a big problem for environments like
    Visual Basic¨, which don&#146;t support pointers in the same
    manner. The way to get Visual Basic programmers into the game
    is to introduce a single well-known interface that provides a
    way to get the same functionality. COM provides such an
    interface and it&#146;s called IDispatch. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">interface IDispatch : public
    IUnknown {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">virtual&nbsp;HRESULT&nbsp;GetTypeInfoCount(UINT&nbsp;FAR*&nbsp;pctinfo)&nbsp;=&nbsp;0;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">virtual HRESULT GetTypeInfo
    (UINT itinfo, LCID lcid,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ITypeInfo FAR* FAR*</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">pptinfo) = 0;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">virtual HRESULT
    GetIDsOfNames(REFIID riid, </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">char FAR* FAR* rgszNames,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">UINT cNames,&nbsp;LCID lcid,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DISPID FAR* rgdispid) = 0;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">virtual HRESULT Invoke(DISPID
    dispidMember,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">REFIID riid, LCID lcid,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">WORD wFlags, </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DISPPARAMS FAR* pdispparams,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">VARIANT FAR* pvarResult,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">EXCEPINFO FAR* pexcepinfo,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">UINT FAR* puArgErr) = 0;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">};</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">IDispatch involves a tokenized
    lookup mechanism instead of a pointer-based mechanism. Once
    automation clients acquire the IDispatch interface, they can
    use IDispatch::Invoke to carry out their bidding. Notice
    Invoke&#146;s first parameter, a DISPID. DISPIDs are simply
    tokens (32-bit numbers) defined by the automation object that
    the client uses to invoke the object&#146;s functions and
    properties. For example, if a client discovers that an
    automation object implements a function called DoSomething,
    the client can find the token representing DoSomething by
    either calling IDispatch::GetIDsOfNames or by consulting the
    object&#146;s TypeInfo. Once the client acquires the token,
    the client uses the token to call IDispatch::Invoke, avoiding
    the need to understand function signatures and function table
    layout information.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As you can imagine, getting to
    an object through IDispatch isn&#146;t the most efficient
    proposition. Clients need to set up IDispatch::Invoke by
    packing up arguments into variant structures and setting up
    the flag to indicate the kind of call (setting a property,
    getting a property, or calling a method). Once the client
    makes the call, the object has to decipher all the
    parameters, unpack the variants, and perform the actual
    operation. Then the client has to pack up the result in a
    variant and return it. Finally, the client needs to unpack
    the returned variant and check out any errors or exceptions.
    All this takes time. If you&#146;re writing a C++ program and
    you want to use a COM object, you&#146;d get better
    performance if you went straight for the COM interface. In
    addition, COM interfaces are much easier to use in C++. If a
    COM object supports only IDispatch, the client is stuck with
    a performance hit. If you want to improve performance for
    your COM interface clients, you need to implement a
    completely separate interface.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Enter dual interfaces. The
    best of both worlds, they&#146;re COM interfaces and dispatch
    interfaces rolled into one. Here&#146;s a great way to think
    about dual interfaces: you know that every COM object starts
    with IUnknown (that is, QueryInterface, AddRef, and
    Release)&#151;that way clients can count on certain
    functionality always being available. The object provides a
    way of maintaining a reference count and the client has a way
    to try to get more interfaces when it needs to. Like COM
    interfaces, dual interfaces always start off with an
    established set of functions, like QueryInterface, AddRef,
    and Release, and continue with the IDispatch functions
    (GetTypeInfoCount, GetTypeInfo, GetIDsOfNames, and Invoke),
    finishing with the functions that make that interface unique.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To COM clients, a dual
    interface looks like any other COM interface. Clients of dual
    interfaces that understand COM interfaces can focus on the
    first three functions (IUnknown) and the functions following
    IDispatch, completely ignoring the IDispatch functions. For
    clients that don&#146;t understand pure COM interfaces, the
    dual interface looks like just another implementation of
    IDispatch, and a client can use the interface that way. <b>Figure
    1</b> illustrates how this works.</font></p>
    <p><img src="vprog1.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
1&nbsp; ICoolInterface Exposed as a Dual Interface</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Dispatch interfaces are at the
    heart of ActiveX controls. Although MFC remains the easiest
    way to write ActiveX controls, adding dual interfaces to
    MFC-based ActiveX controls is a somewhat roundabout process.
    You have to understand how MFC implements COM and how to work
    with ODL.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The way to COM using MFC
    involves macros to assemble the interfaces. You implement COM
    classes in MFC using a variation on the class-composition
    approach. Two sets of macros are needed: one to define and
    implement the nested classes for implementing the COM
    interfaces, and another to declare and implement MFC&#146;s
    version of QueryInterface. This is what&#146;s happening
    under the sheets to implement IDispatch (it&#146;s just
    another COM interface, you know). </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Giving substance to a
    particular instance of IDispatch involves the ClassWizard.
    With ClassWizard, you can whip up in minutes an
    implementation of IDispatch that might take a C++ developer
    hours to implement by hand. It&#146;s almost exactly the same
    as using ClassWizard to trap messages in your app. Simply
    press the Property button in the Automation tab to add a
    property to your IDispatch interface and press the Method
    button to add a function to your IDispatch implementation. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Another thing ClassWizard does
    for you is maintain the ODL file. Doing any serious work with
    automation requires you become familiar with ODL. ODL is an
    entirely declarative language that describes type libraries,
    COM interfaces, dispatch interfaces, COM classes, and dual
    interfaces. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Turning on the automation
    check box causes AppWizard to pump out an ODL file for your
    project. ActiveX controls get ODL files automatically, which
    will have the same name as your project with an ODL
    extension.<b> Figure 2</b> describes an ActiveX control in
    ODL with three properties (AProperty, PlainVanillaProperty,
    and NotificationProperty) and two methods (AFunction and
    AboutBox).</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;2&nbsp;AppWizard-generated
ODL</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
DualCtl.odl : type library source for OLE Control project.</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;olectl.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;idispids.h&gt;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[
uuid(6E281361-40AF-11D0-8A90-E1C000C3FC20), </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">version(1.0),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">helpstring(&quot;DualCtl
OLE Control module&quot;), </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">control
]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">library
DUALCTLLib</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">importlib(STDOLE_TLB);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">importlib(STDTYPE_TLB);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Primary dispatch interface for CDualCtlCtrl</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[
uuid(6E281362-40AF-11D0-8A90-E1C000C3FC20),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">helpstring(&quot;Dispatch
interface for DualCtl Control&quot;),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">hidden
]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dispinterface
_DDualCtl {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">properties:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
ClassWizard Voodoo warnings</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[id(3)]
long AProperty;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[id(2)]
float NotificationProperty;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[id(1)]
double PlainVanillaProperty;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">methods:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[id(4)]
short AFunction(short Param1);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[id(DISPID_ABOUTBOX)]
void AboutBox();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Event dispatch interface for CDualCtlCtrl</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[uuid(6E281363-40AF-11D0-8A90-E1C000C3FC20),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">helpstring(&quot;Event
interface for DualCtl Control&quot;) ]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dispinterface
_DDualCtlEvents</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">properties:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Event interface has no properties</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">methods:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Class information for CDualCtlCtrl</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[uuid(6E281364-40AF-11D0-8A90-E1C000C3FC20),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">helpstring(&quot;DualCtl
Control&quot;), </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">control
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">coclass
DualCtl {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[default]
dispinterface _DDualCtl;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[default,
source] dispinterface _DDualCtlEvents;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">This ODL file describes a
    collection of attributes (whatever&#146;s inside square
    brackets) and &quot;things&quot; in this module (which
    happens to be an ActiveX control). ODL always follows an
    &quot;attribute-thing&quot; format. Attributes appear in the
    square brackets before the things. This type library consists
    of two dispatch interface descriptions (_DDualCtl and
    _DDualCtlEvents) and the description of a COM class
    (DualCtl). The control implements _DDualCtl and control
    containers implement _DDualCtlEvents. Implementing dual
    interfaces in MFC requires modifying the ODL file, so
    you&#146;ll have a chance to become intimately familiar with
    the syntax. </font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Doing
the Dual</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Adding a dual interface to
    your MFC-based ActiveX control requires five steps:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Create your control
    skeleton using AppWizard.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Add your properties and
    methods to the control.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Modify the
    control&#146;s ODL file to describe the dual interface you
    want to support.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Add the corresponding
    interface to your control.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Add type library
    registration support to your control.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Let&#146;s implement a dual
    interface for the ActiveX control called DualCtl whose ODL
    appears in <b>Figure 2</b>. It&#146;s a regular ActiveX
    control, except that it&#146;ll expose its properties and
    methods through a dual interface. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Let&#146;s start off by
    creating the control. Select File New, select the options you
    want for your control, and let AppWizard do its thing! In
    seconds you&#146;ve got a full-blown MFC-based ActiveX
    control waiting to do your bidding. Next, use ClassWizard to
    add the properties and methods that make your control unique.
    Once the control is finished, you need to add properties and
    methods to the control.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ClassWizard makes this step
    easy, too. The only caveat here is that you should think hard
    about the properties and methods you want to expose. If you
    mess something up here, changing the code later becomes more
    difficult because you have to modify a lot more of it (no
    more just selecting Delete from the ClassWizard&#146;s
    Automation tab). Anyway, once you settle on your incoming
    IDispatch interface (that is, your control&#146;s methods and
    properties), it&#146;s time to move on to the ODL file.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To add a dual interface to the
    control, you&#146;ve got to get in and modify the ODL file
    (despite the scary warnings amid the ClassWizard comments).
    The first thing to do is add another interface
    description&#151;one for the dual interface. Given the ODL
    from <b>Figure 2</b>, you need to add the lines shown in <b>Figure
    3</b></font><font color="#000000" size="1"
    face="verdana,arial,helvetica"> </font><font color="#000000"
    size="2" face="verdana,arial,helvetica">to the ODL code.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;3&nbsp;The
Dual Interface Described in ODL</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[uuid(49BA7C01-40D4-11d0-8A90-E1C000C3FC20),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">helpstring(&quot;Dual
interface for DualCtl Control&quot;), </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dual,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">oleautomationp
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">interface
_DIDualCtl : IDispatch {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[propput,
id(3)] HRESULT AProperty([in] long l);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[propget,
id(3)] HRESULT AProperty([retval, out] long* pl);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[propput,
id(1)] HRESULT PlainVanillaProperty([in] double d);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[propget,
id(1)] HRESULT PlainVanillaProperty([retval, </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">out]
double* pd);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[propput,
id(2)] HRESULT NotificationProperty([in]float f);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[propget,
id(2)] HRESULT NotificationProperty([retval, </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">out]
float* pf);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[id(4)]
HRESULT AFunction([in] short Param1, [out, retval] short *s);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[id(DISPID_ABOUTBOX)]
HRESULT AboutBox();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">There are several things going
    on that might strike you as odd. Why do you need to add
    another interface definition? If you go back and change the
    AppWizard-generated ODL file to add the new keywords,
    there&#146;s a good chance you&#146;ll break ClassWizard.
    Adding a completely separate interface avoids this problem. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">What&#146;s all this propput
    and propget stuff in<b> Figure 3</b>? The original
    AppWizard-generated ODL uses the keywords
    &quot;properties&quot; and &quot;methods&quot; to delineate
    the object&#146;s properties and methods. This is legal ODL
    syntax (albeit a bit outdated now). To define this interface
    as a dual interface, you need to define each property into
    separate get<i>xxx</i> and put<i>xxx</i> functions. Applying
    the keywords propput and propget to the property attributes
    does the job. Because the COM interface can define only
    functions, each property has to be represented by separate
    get<i>xxx</i> and set<i>xxx</i> functions.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Remember that ODL always takes
    an attributes-thing form. This interface (_DIDualCtl) has a
    name identified by the uuid statement in the attributes
    section. In addition to a comment describing the interface,
    there are two new keywords: dual and interface. The dual
    keyword tells the type library compiler the interface is a
    combination of IDispatch and some other functions (that is,
    the first seven entries in the interface are IDispatch and
    the next entries are something else). The interface keyword
    tells the type library compiler the interface is a regular
    COM interface. ODL is very precise&#151;each function must
    specify the direction of its parameters (notice the in and
    out attributes for the parameters). Also notice that the
    interface has a new globally unique ID (GUID). Because
    it&#146;s a new unique interface, the rules of COM stipulate
    that it gets a new name.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The final modification to the
    ODL file is to add the dual interface to the coclass section
    of the ODL. The default attributes makes the dual interface
    the primary incoming interface. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">[
    uuid(6E281364-40AF-11D0-8A90-E1C000C3FC20),</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">helpstring(&quot;DualCtl
    Control&quot;), control ]</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">coclass DualCtl {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">[default] interface
    _DIDualCtl;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">[default, source]
    dispinterface _DDualCtlEvents;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">dispinterface _DDualCtl;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">};</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Once the ODL file defines the
    new interface, the next step is to graft the new interface to
    your control using MFC&#146;s nested class and interface map
    mechanisms. </font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Implementing
the Dual Interface</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The first step to adding the
    dual interface to the control is to add the
    DECLARE_INTERFACE_MAP macro to the control&#146;s header
    file. DECLARE_INTERFACE_MAP sets up MFC&#146;s QueryInterface
    machinery to work with the control. Then you need to add a
    nested class that implements the dual interface. In the ODL
    example above, the interface is already fully described. The
    trick is to turn that interface description into something
    you can use in this C++ code. Fortunately, the type library
    compiler is smart enough to read the interface description in
    the ODL file and turn it into a C++ header file. Here are the
    steps necessary to do that:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Select Build Settings
    from the menu.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Go to the OLE Types
    tab.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Expand the tree in the
    settings list and highlight the control&#146;s ODL file.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Type the name of your
    header file in the &quot;Output header file name&quot; field.
    (Call it something other than your control&#146;s header
    file. In the example above, the control is named
    &quot;DualCtl.&quot; The interface is defined in a file
    called IDUALCTL.H.)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Load the ODL file in
    the environment compile it. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Given the ODL file in <b>Figure
    2</b> with the modification above, <b>Figure 4</b> shows the
    header file spit out by the type library compiler. This
    rather scary looking C++ code is exactly what your control
    needs to implement the dual interface. In addition to the
    code emitted from the type library compiler, you&#146;ll need
    a macro that comes with the MFC samples. The file, MFCDUAL.H,
    is in \MSDEV\SAMPLES\MFC\OLE\ACDUAL\SERVER. This header file
    contains the macros for defining the nested classes.
    MFC&#146;s normal BEGIN_INTERFACEPART/END_INTERFACE_PART
    macros work too, but you have to prototype the four IDispatch
    functions yourself.
    BEGIN_DUAL_INTERFACE_PART/END_DUAL_INTERFACE_PART already do
    that for you. </font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;4&nbsp;MKTYPLIB
Emits this Header File</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DEFINE_GUID(IID__DIDualCtl,0x49BA7C01L,0x40D4,0x11D0,0x8A,0x90,0xE1,0xC0,0x00,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">0xC3,0xFC,0x20);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">/*
Definition of interface: _DIDualCtl */</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#undef
INTERFACE</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
INTERFACE _DIDualCtl</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DECLARE_INTERFACE_(_DIDualCtl,
IDispatch)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifndef
NO_BASEINTERFACE_FUNCS</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">/*
IUnknown methods */</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(QueryInterface)(THIS_
REFIID riid, LPVOID FAR* ppvObj) PURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD_(ULONG,
AddRef)(THIS) PURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD_(ULONG,
Release)(THIS) PURE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">/*
IDispatch methods */</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(GetTypeInfoCount)(THIS_
UINT FAR* pctinfo) PURE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(GetTypeInfo)(</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">THIS_</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">UINT
itinfo,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LCID
lcid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ITypeInfo
FAR* FAR* pptinfo) PURE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(GetIDsOfNames)(</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">THIS_</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">REFIID
riid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OLECHAR
FAR* FAR* rgszNames,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">UINT
cNames,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LCID
lcid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DISPID
FAR* rgdispid) PURE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(Invoke)(</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">THIS_</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DISPID
dispidMember,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">REFIID
riid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LCID
lcid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WORD
wFlags,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DISPPARAMS
FAR* pdispparams,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">VARIANT
FAR* pvarResult,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXCEPINFO
FAR* pexcepinfo,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">UINT
FAR* puArgErr) PURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">/*
_DIDualCtl methods */</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(put_AProperty)(THIS_
long l) PURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(get_AProperty)(THIS_
long FAR* pl) PURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(put_PlainVanillaProperty)(THIS_
double d) PURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(get_PlainVanillaProperty)(THIS_
double FAR* pd) PURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(put_NotificationProperty)(THIS_
float f) PURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(get_NotificationProperty)(THIS_
float FAR* pf) PURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(AFunction)(THIS_
short Param1, short FAR* s) PURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(AboutBox)(THIS)
PURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To add the nested class for
    implementing the dual interface, simply use the macros as
    shown in <b>Figure 5</b>. You can more or less steal the code
    from the header file emitted by MKTYPLIB. Make sure to get
    rid of the PURE symbol following each function. This gives
    the control a nested class that implements the dual
    interface. The control here, DualCtl, is implemented in a
    class called CDualCtlCtrl. The macros generate a nested class
    called X_DIDualCtlObj within CDualCtlCtrl that implements the
    _DIDualCtl interface. _DIDualCtl is declared in the header
    file generated by the type library compiler.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The next step is to implement
    the new interface. This is pretty much like implementing a
    new COM interface to a control except that you need to
    implement the IDispatch functions as well as the IUnknown
    functions. <b>Figure 6</b> shows implementing the IUnknown
    and the IDispatch functions.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Implementing the IUnknown
    functions is a matter of using the METHOD_PROLOGUE macro to
    get a pointer back to the control and delegating to
    CCmdTarget&#146;s IUnknown functions. Implementing IDispatch
    is a matter of getting MFC&#146;s implementation of IDispatch
    (available through CCmdTarget::GetIDispatch) and delegating
    to MFC&#146;s implementation.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Next comes mapping the dual
    interface functions to the implementations provided by
    ClassWizard. Doing this involves getting a pointer back to
    the control and delegating to those ClassWizard functions.
    The dual interface methods are also forwarded to the
    ClassWizard-generated functions, as shown in <b>Figure 7</b>.
    The thing to watch out for here is that all the dual
    interface functions return HRESULTs and that results are
    passed back through out parameters. <b>Figure 7</b> shows how
    to implement get_AProperty, set_AProperty, and AFunction.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The next step is to fill in
    the interface map so that the framework knows where to find
    your new interface when a client calls QueryInterface. Simply
    add the entries to the control&#146;s interface map as shown
    below. There are three entries: one for plain old IDispatch,
    one for a version of IDispatch that&#146;s named in the ODL
    file, and the new custom interface. MFC uses this table to
    match interface IDs to interface pointers when clients call
    QueryInterface.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BEGIN_INTERFACE_MAP(CDualCtlCtrl,
    COleControl)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// Plain vanilla IDispatch</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">INTERFACE_PART(CDualCtlCtrl,&nbsp;IID_IDispatch,&nbsp;Dispatch)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// Control's IDispatch</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">INTERFACE_PART(CDualCtlCtrl,
    DIID__DDualCtl,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Dispatch)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// Control's Dual interface</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">INTERFACE_PART(CDualCtlCtrl,
    IID__DIDualCtl,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">_DIDualCtlObj)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">END_INTERFACE_MAP()</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Because type information is
    such an important part of ActiveX controls, the code
    generated by AppWizard already includes the code necessary to
    register type information in the registry. Here&#146;s the
    code that appears in DUALCTL.H: </font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">STDAPI DllRegisterServer(void)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">AFX_MANAGE_STATE(_afxModuleAddrThis);</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if
    (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(),</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">_tlid))</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return
    ResultFromScode(SELFREG_E_TYPELIB);</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if
    (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return
    ResultFromScode(SELFREG_E_CLASS);</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return NOERROR;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">There are two final caveats.
    First, you need to include initguid.h in your control&#146;s
    CPP file to give the GUIDs declared in the DEFINE_GUID macro
    some substance. Second, be sure to include the ODL-generated
    header file in your control&#146;s main source file so the
    compiler understands the new dual interface (that is, include
    IDUALCTL.H in DUALCTLCTRL.CPP in this example).</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;5&nbsp;Declaring
the Nested Class</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Inside the control's header file-- the control's declaration</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">class
CDualCtlCtrl : public COleCtontrol {</font></p>

<blockquote>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BEGIN_DUAL_INTERFACE_PART(_DIDualCtlObj,
_DIDualCtl)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(put_AProperty)(long
l);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(get_AProperty)(long
FAR* pl);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(put_PlainVanillaProperty)(double
d);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(get_PlainVanillaProperty)(double
FAR* pd);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(put_NotificationProperty)(float
f);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(get_NotificationProperty)(float
FAR* pf);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(AFunction)(short
Param1, short FAR* s);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHOD(AboutBox)();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">END_DUAL_INTERFACE_PART(_DIDualCtlObj)</font></p>

<blockquote>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;6&nbsp;Implementing
IUnknown and IDispatch</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHODIMP
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDualCtlCtrl::X_DIDualCtlObj::QueryInterface(REFIID
riid, </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LPVOID
FAR* ppvObj) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">METHOD_PROLOGUE(CDualCtlCtrl,
_DIDualCtlObj)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pThis-&gt;ExternalQueryInterface(&amp;riid, ppvObj);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHODIMP_(ULONG)
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDualCtlCtrl::X_DIDualCtlObj::AddRef()
{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">METHOD_PROLOGUE(CDualCtlCtrl,
_DIDualCtlObj)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pThis-&gt;ExternalAddRef();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHODIMP_(ULONG)
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDualCtlCtrl::X_DIDualCtlObj::Release()
{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">METHOD_PROLOGUE(CDualCtlCtrl,
_DIDualCtlObj)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pThis-&gt;ExternalRelease();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHODIMP
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDualCtlCtrl::X_DIDualCtlObj::GetTypeInfoCount(UINT
FAR* pctinfo) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">METHOD_PROLOGUE(CDualCtlCtrl,
_DIDualCtlObj)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LPDISPATCH
pDisp = pThis-&gt;GetIDispatch(FALSE);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ASSERT(pDisp
!= NULL);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pDisp-&gt;GetTypeInfoCount(pctinfo);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHODIMP
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDualCtlCtrl::X_DIDualCtlObj::GetTypeInfo(UINT
itinfo,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LCID
lcid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ITypeInfo
FAR* FAR* pptinfo) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">METHOD_PROLOGUE(CDualCtlCtrl,
_DIDualCtlObj)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LPDISPATCH
pDisp = pThis-&gt;GetIDispatch(FALSE);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ASSERT(pDisp
!= NULL);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pDisp-&gt;GetTypeInfo(itinfo, lcid, pptinfo);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHODIMP
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDualCtlCtrl::X_DIDualCtlObj::GetIDsOfNames(REFIID
riid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OLECHAR
FAR* FAR* rgszNames,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">UINT
cNames,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LCID
lcid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DISPID
FAR* rgdispid) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">METHOD_PROLOGUE(CDualCtlCtrl,
_DIDualCtlObj)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LPDISPATCH
pDisp = pThis-&gt;GetIDispatch(FALSE);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ASSERT(pDisp
!= NULL);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pDisp-&gt;GetIDsOfNames(riid, rgszNames,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">cNames,lcid,
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rgdispid);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHODIMP
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDualCtlCtrl::X_DIDualCtlObj::Invoke(DISPID
dispidMember,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">REFIID
riid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LCID
lcid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WORD
wFlags,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DISPPARAMS
FAR* pdispparams,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">VARIANT
FAR* pvarResult,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXCEPINFO
FAR* pexcepinfo,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">UINT
FAR* puArgErr) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">METHOD_PROLOGUE(CDualCtlCtrl,
_DIDualCtlObj)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LPDISPATCH
pDisp = pThis-&gt;GetIDispatch(FALSE);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ASSERT(pDisp
!= NULL);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pDisp-&gt;Invoke(dispidMember,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">riid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">lcid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">wFlags,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pdispparams,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pvarResult,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pexcepinfo,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">puArgErr);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;7&nbsp;Implementing
the Rest of the Function and Property Accessors</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHODIMP
CDualCtlCtrl::X_DIDualCtlObj::put_AProperty(long l) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">METHOD_PROLOGUE(CDualCtlCtrl,
_DIDualCtlObj)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pThis-&gt;SetAProperty(l);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
NOERROR;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHODIMP
CDualCtlCtrl::X_DIDualCtlObj::get_AProperty(long FAR* pl) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">METHOD_PROLOGUE(CDualCtlCtrl,
_DIDualCtlObj)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">*pl
= pThis-&gt;GetAProperty();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
NOERROR;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STDMETHODIMP
CDualCtlCtrl::X_DIDualCtlObj::AFunction(short Param1, </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">short
FAR* s) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">METHOD_PROLOGUE(CDualCtlCtrl,
_DIDualCtlObj)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">*s
= pThis-&gt;AFunction(Param1);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
NOERROR;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Conclusion</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Now you know how to add a dual
    interface to an ActiveX control. This example shows the
    importance of understanding COM at the visceral level.
    Knowing how IDispatch works and how to take advantage of
    MFC&#146;s nested class macros is key to getting a dual
    interface (or any other COM interface) grafted onto your
    control. While for now adding a dual interface to an
    MFC-based ActiveX control isn&#146;t the easiest thing to do,
    it&#146;s not impossible. And you can use this technique to
    add a dual interface to any CCmdTarget-derived class. </font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>To
obtain complete source code listings, see </b></font><a
href="ednote.htm"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Editor's page</b></font></a><font
color="#000000" size="2" face="verdana,arial,helvetica"><b>.</b></font></p>

<p><font color="#000080" size="1" face="B Franklin Gothic Demi">Have
a question about programming in Visual Basic, Visual FoxProª,
Microsoft¨ Access, Office or stuff like that? Send your
questions via email to Dave Edson: </font><a
href="mailto:davee@microsoft.com"><font color="#000080" size="1"
face="B Franklin Gothic Demi">davee@microsoft.com</font></a><font
color="#000000" size="2" face="verdana,arial,helvetica">. </font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><i>This article is reproduced
    from Microsoft Systems Journal. Copyright © 1997 by Miller
    Freeman, Inc. All rights are reserved. No part of this
    article may be reproduced in any fashion (except in brief
    quotations used in critical articles and reviews) without the
    prior consent of Miller Freeman.</i></font></p>
    <p><font color="#000000" size="2"><i>To contact Miller
    Freeman regarding subscription information, call (800)
    666-1084 in the U.S. and Canada, or (303) 678-0439 in all
    other countries. For other inquiries, call (415) 905-2200.</i></font></p>
</blockquote>
</font></body>
</html>
