<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Adobe application">
<meta name="Template" content="C:\MSOffice\Templates\MSJ.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Under the Hood</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<p><font color="#000000" size="6" face="verdana,arial,helvetica">Under
the Hood</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica">by Matt Pietrek</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Matt Pietrek is the author of
Windows 95 System Programming Secrets (IDG Books, 1995). He works
at NuMega Technologies Inc., and can be reached at
71774.362@compuserve.com.</b></font></p>

<blockquote>
    <p><font color="#000080" size="7"
    face="B New Century Schlbk Bold">I</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">n my
    October 1996 Liposuction article, I created a set of classes
    for accessing information in executable files. The article
    also used a class I called a MODULE_DEPENDENCY_LIST, which
    attempted to find all DLLs that were imported (either
    directly or indirectly) by a Win32</font><font
    color="#000000" face="verdana,arial,helvetica">®</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">
    portable executable (PE). To keep that article on track with
    the subject matter, I didn&#146;t do full justice in
    describing these classes and their capabilities. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">This month, I&#146;ll revisit
    these classes (which I&#146;ve spiffed up), and create a new
    utility from them. I must confess to having an ulterior
    motive in doing this work. I&#146;ve recently been bitten by
    several problems relating to DLLs and versioning. One problem
    involves multiple versions of a DLL in different directories.
    This inevitably leads to the wrong DLL being used, which can
    be a hair-pulling experience when trying to figure out why
    your program doesn&#146;t work. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Another problem occurs when
    the system complains that a DLL can&#146;t be found, and I
    can&#146;t determine who referenced it. <b>Figure 1</b> shows
    the enormously helpful message you receive from Windows NT¨
    4.0 when a DLL isn&#146;t found. It sure would be nice to
    know who needs &quot;ONION32.DLL.&quot; </font></p>
    <p><img src="hood1.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
1 Windows NT can&#146;t find a DLL</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Yet a third problem is that a
    coworker of mine needs to know exactly when the executables
    in a particular beta build were actually created. It&#146;s
    common practice to mark all the executables with the same
    time and date when a product is released. This makes it
    difficult to determine which version of a file was actually
    shipped. It turns out that, in Win32 executables, you can
    (usually) determine exactly when the file was linked. This
    isn&#146;t a trivial task, however, and by the time I had
    finished writing my program, I knew more about dates and
    times in Win32 than I ever cared to know. Would you believe
    that there are four different ways that dates and times are
    expressed in various parts of Win32?</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>The
DEPENDS Program</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The program that I put
    together to help solve these problems is called DEPENDS
    (insert your own joke here). I wrote DEPENDS as a
    console-mode application so it&#146;s easy to collect the
    results into a file, and it&#146;s also easy to use it in
    automatic build processes. The syntax for using DEPENDS can
    be gleaned by running it without any arguments:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DEPENDS - Matt Pietrek, 1997,
    for MSJ</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Syntax: DEPENDS [args]
    &lt;executable filename&gt;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">/v show version information</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">/t show time &amp; date
    information</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">/p show full path</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">/l show link time &amp; date
    information</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you run DEPENDS with just
    the name of an executable file, you&#146;ll get a list of all
    DLLs used by the executable, along with the EXE&#146;s name.
    For example, running DEPENDS on MSDEV.EXE from Visual C++¨
    gives the output shown in <b>Figure 2</b>. Of the 19
    executables that are required to run MSDEV.EXE (18 DLLs and
    one EXE), only four of the DLLs are referenced directly:
    MSVCSHL.DLL, MFC40.DLL, MSVCRT40.DLL, and KERNEL32.DLL. The
    remaining DLLs are indirectly imported; that is, they&#146;re
    imported by one of the four DLLs used by MSDEV.
    Alternatively, the DLLs may be another level away and are
    imported by one of the DLLs imported by MSDEV&#146;s four
    DLLs. The DEPENDS program uses recursion to show you all of
    an executable&#146;s dependencies, much like the Win32 loader
    does when it loads the program. I &#146;ll have more to say
    on this later.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;2&nbsp;DEPENDS
Output for MSDEV.EXE</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LZ32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">VERSION.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">comdlg32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">COMCTL32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">SHELL32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WINMM.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ole32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RPCRT4.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ADVAPI32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">USER32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">GDI32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MFC40.DLL
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MSVCIRT.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ntdll.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">KERNEL32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MSVCRT.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MSVCRT40.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MSVCSHL.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MSDEV.EXE
</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The four command-line switches
    to DEPENDS let you tailor the output to your liking. You can
    use either &#150; or / as the switch character, and the
    options are not case-sensitive (/V is equivalent to &#150;v).</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The /v switch causes DEPENDS
    to emit any version information that it finds in an
    executable file. <b>Figure 3</b> shows an example of the /v
    switch used on CLOCK.EXE. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The /p switch tells the
    program to append the complete path to each EXE or DLL in the
    dependency list. For example, this command line</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DEPENDS /p
    c:\WINNT\SYSTEM32\CLOCK.EXE</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">generates this:</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">COMCTL32.dll
    (c:\WINNT\system32\COMCTL32.dll)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">SHELL32.dll
    (c:\WINNT\system32\SHELL32.dll)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">RPCRT4.dll
    (c:\WINNT\system32\RPCRT4.dll)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ADVAPI32.dll
    (c:\WINNT\system32\ADVAPI32.dll)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">GDI32.dll
    (c:\WINNT\system32\GDI32.dll)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">USER32.dll
    (c:\WINNT\system32\USER32.dll)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">KERNEL32.dll
    (c:\WINNT\system32\KERNEL32.dll)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ntdll.dll
    (c:\WINNT\system32\ntdll.dll)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">comdlg32.dll
    (c:\WINNT\system32\comdlg32.dll)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">clock.exe
    (c:\WINNT\system32\clock.exe)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">This capability lets you see
    exactly which DLLs are being used by a program. If you
    suspect a DLL mismatch (for instance, a DLL in multiple
    directories in the path), the /p switch can be helpful in
    tracking down the problem.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
3&nbsp; CLOCK.EXE Version Information</b></font></p>

<p><font color="#000000" size="1" face="Courier New">COMCTL32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CompanyName
Microsoft Corporation</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileDescription
Custom Controls Library</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileVersion
4.70</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">InternalName
COMMCTRL</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LegalCopyright
Copyright (C) Microsoft Corp. 1981-1996</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OriginalFilename
COMMCTRL.DLL</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductName
Microsoft(R) Windows NT(TM) Operating System</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductVersion
4.70</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">SHELL32.dll </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CompanyName
Microsoft Corporation</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileDescription
Windows Shell Common Dll</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileVersion
4.00</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">InternalName
SHELL32</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LegalCopyright
Copyright (C) Microsoft Corp. 1981-1996</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OriginalFilename
SHELL32.DLL</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductName
Microsoft(R) Windows NT(TM) Operating System</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductVersion
4.00</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">RPCRT4.dll </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CompanyName
Microsoft Corporation</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileDescription
Remote Procedure Call Runtime</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileVersion
4.00</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">InternalName
rpcrt4.dll</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LegalCopyright
Copyright (C) Microsoft Corp. 1981-1996</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OriginalFilename
rpcrt4.dll</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductName
Microsoft(R) Windows NT(TM) Operating System</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductVersion
4.00</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">ADVAPI32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CompanyName
Microsoft Corporation</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileDescription
Advanced Windows 32 Base API</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileVersion
4.00</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">InternalName
advapi32.dll</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LegalCopyright
Copyright (C) Microsoft Corp. 1981-1996</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OriginalFilename
advapi32.dll</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductName
Microsoft(R) Windows NT(TM) Operating System</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductVersion
4.00</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">GDI32.dll </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CompanyName
Microsoft Corporation</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileDescription
GDI Client DLL</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileVersion
4.00</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">InternalName
gdi32</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LegalCopyright
Copyright (C) Microsoft Corp. 1981-1996</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OriginalFilename
gdi32</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductName
Microsoft(R) Windows NT(TM) Operating System</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductVersion
4.00</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">USER32.dll </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CompanyName
Microsoft Corporation</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileDescription
Windows NT USER API Client DLL</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileVersion
4.00</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">InternalName
user32</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LegalCopyright
Copyright (C) Microsoft Corp. 1981-1996</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OriginalFilename
user32</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductName
Microsoft(R) Windows NT(TM) Operating System</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductVersion
4.00</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">KERNEL32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CompanyName
Microsoft Corporation</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileDescription
Windows NT BASE API Client DLL</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileVersion
4.00</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">InternalName
kernel32</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LegalCopyright
Copyright (C) Microsoft Corp. 1981-1996</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OriginalFilename
kernel32</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductName
Microsoft(R) Windows NT(TM) Operating System</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductVersion
4.00</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">ntdll.dll </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CompanyName
Microsoft Corporation</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileDescription
NT Layer DLL</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileVersion
4.00</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">InternalName
ntdll.dll</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LegalCopyright
Copyright (C) Microsoft Corp. 1981-1996</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OriginalFilename
ntdll.dll</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductName
Microsoft(R) Windows NT(TM) Operating System</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductVersion
4.00</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">comdlg32.dll
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CompanyName
Microsoft Corporation</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileDescription
Common Dialogs DLL</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileVersion
4.00</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">InternalName
comdlg32</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LegalCopyright
Copyright (C) Microsoft Corp. 1981-1996</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OriginalFilename
comdlg32.dll</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductName
Microsoft(R) Windows NT(TM) Operating System</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductVersion
4.00</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">clock.exe </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CompanyName
Microsoft Corporation</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileDescription
Clock Applet</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FileVersion
4.00</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">InternalName
clock</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LegalCopyright
Copyright (C) Microsoft Corp. 1981-1996</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">OriginalFilename
CLOCK.EXE</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductName
Microsoft(R) Windows NT(TM) Operating System</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProductVersion
4.00</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The remaining two command-line
    switches emit the time and date of each EXE or DLL in the
    dependency list. Using /t forces DEPENDS to emit the date and
    time of the file as recorded by the file system. This time
    and date information is what you&#146;ll see in the Explorer
    or by doing a DIR from the command line.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The other date and time
    information that DEPENDS can show is when the executable was
    created. This information is stored in the PE header and
    doesn&#146;t change even if you explicitly modify the
    traditional date and time by using tools like TOUCH. To see
    this information, use DEPENDS with the /l switch. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">How I obtained this
    information is an interesting programming story, which
    I&#146;ll come back to later. As a side note, I was quite
    surprised when I ran DEPENDS on some Windows NT 4.0
    executables. It seems that USER32.DLL, KERNEL32.DLL, and
    NTDLL.DLL were all created on different days, and those dates
    were about two weeks before the formal release date of
    08/09/96 that the Windows Explorer shows. Give it a try and
    see for yourself!</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>The
MODULE_DEPENDENCY_LIST Class</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The heart of the DEPENDS code
    is the MODULE_DEPENDENCY_LIST class, implemented in
    DependencyList.h and DependencyList.cpp (see <b>Figure 4</b>).
    The constructor for this class takes one argument, the name
    of the executable to be searched for dependencies. When the
    constructor returns, the dependency list has been generated.
    There are querying methods to retrieve information from the
    list.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;4&nbsp;MODULE_DEPENDENCY_LIST
Class</b></font></p>

<p><font color="#000000" size="1" face="Courier New">DependencyList.h</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Matt Pietrek</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, Feb 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: DependencyList.h</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifndef
__DEPLIST_H__</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
__DEPLIST_H__</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifndef
__MODULEFILEINFO_H__</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;modulefileinfo.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">enum
errModuleDependencyList { errMDL_NO_ERROR,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">errMDL_FILE_NOT_FOUND,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">errMDL_NOT_PE_FILE,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">errMDL_GENERAL_FAILURE
};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
The MODULE_DEPENDENCY_LIST class creates a linked list of
MODULE_FILE_INFO</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
structures. In theory, this list will represent every executable
file</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
loaded by the Win32 loader when the executable is loaded. The
class creates</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
the list by starting with the file passed to the constructor, and
recursing</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
through all the import tables.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">class
MODULE_DEPENDENCY_LIST</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">public:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MODULE_DEPENDENCY_LIST(
PSTR pszFileName );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">~MODULE_DEPENDENCY_LIST(
);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
IsValid( void ){ return (BOOL)(m_errorType =&nbsp;=
errMDL_NO_ERROR); }</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">errModuleDependencyList
GetErrorType( void ){ return m_errorType; }</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
GetErrorString( void );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PMODULE_FILE_INFO
GetNextModule( PMODULE_FILE_INFO p );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PMODULE_FILE_INFO
LookupModule( PSTR pszFileName, BOOL fFullName );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">unsigned
GetNumberOfModules( void ){ return m_cModules; }</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">protected:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">unsigned
m_cModules; // Number of modules in list</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PMODULE_FILE_INFO
m_pList; // Pointer to head of linked list</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Recursively adds modules to the list </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">errModuleDependencyList
AddModule( PSTR pszFullName );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">errModuleDependencyList
m_errorType; // Error type</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<blockquote>
    <p><font color="#000000" size="1" face="Courier New">DependencyList.cpp</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Matt Pietrek</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, Feb 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: DependencyList.cpp</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;windows.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;malloc.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#pragma
hdrstop</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;peexe.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;dependencylist.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MODULE_DEPENDENCY_LIST::MODULE_DEPENDENCY_LIST(
PSTR pszFileName )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_errorType
= errMDL_GENERAL_FAILURE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_cModules
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pList
= 0;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Make a copy of the path that we can modify to get just the path
portion</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
pszJustPath = strdup( pszFileName );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !pszJustPath )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
fHasPath = FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
pszEnd = strrchr( pszJustPath, '\\' );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pszEnd )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">*pszEnd
= 0; /// Strip off the filename</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">fHasPath
= TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If a path was part of the input filename, save the current
directory,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
then switch to the new directory.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szOriginalPath[MAX_PATH];</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( fHasPath )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
This doesn't take into account &quot;App_Paths&quot;!</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">GetCurrentDirectory(MAX_PATH,
szOriginalPath); // Save original dir</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">SetCurrentDirectory(
pszJustPath ); // Switch to app's dir</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
recursively build the module list</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_errorType
= AddModule( pszFileName );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( fHasPath ) // Set things back to the way they were</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">SetCurrentDirectory(
szOriginalPath );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">free(
pszJustPath ); // Free the copy of the path that we allocated</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MODULE_DEPENDENCY_LIST::~MODULE_DEPENDENCY_LIST(
)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PMODULE_FILE_INFO
pTemp;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Delete each MODULE_FILE_INFO structures in the regular linked
list</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pTemp
= m_pList;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">while
( pTemp )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pTemp
= m_pList-&gt;m_pNext;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Before we delete the module, delete each MODULE_FILE_INFO</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
structures in the not found list</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PMODULE_FILE_INFO
pNotFound = m_pList-&gt;m_pNotFoundNext;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">while
( pNotFound )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pNotFound
= m_pList-&gt;m_pNotFoundNext-&gt;m_pNotFoundNext;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">delete
m_pList-&gt;m_pNotFoundNext;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pList-&gt;m_pNotFoundNext
= pNotFound;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Now it's OK to delete the module</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">delete
m_pList;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pList
= pTemp;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_cModules--;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pList
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PMODULE_FILE_INFO
MODULE_DEPENDENCY_LIST::GetNextModule( PMODULE_FILE_INFO p )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Returns the next module in the linked list of MODULE_FILE_INFO's</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
p ? p-&gt;m_pNext : m_pList;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Given the name of a file, find the MODULE_FILE_INFO structure
that</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
represents it. The fFullName parameter specifies whether the full
path</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
names or just the base file names will be compared.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PMODULE_FILE_INFO
MODULE_DEPENDENCY_LIST::LookupModule( PSTR pszFileName,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
fFullName )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PMODULE_FILE_INFO
p = m_pList; // Start at the list head</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">while
( p ) // While there's still entries in the list...</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
pszCompName = fFullName ? p-&gt;m_szFullName :
p-&gt;m_szBaseName;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( 0 =&nbsp;= lstrcmpi( pszFileName, pszCompName ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
p;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">p
= p-&gt;m_pNext;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
MODULE_DEPENDENCY_LIST::GetErrorString( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">switch
( m_errorType )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
errMDL_NO_ERROR: return &quot;No error&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
errMDL_FILE_NOT_FOUND: return &quot;File not found&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
errMDL_NOT_PE_FILE: return &quot;Not a PE file&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
errMDL_GENERAL_FAILURE:return &quot;General failure&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">default:
return &quot;&lt;Error ???&gt;&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Adds a modules to the MODULE_FILE_INFO list. If the module
imports other</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
modules, this routine recurses to add them, and check their
imports.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">errModuleDependencyList</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MODULE_DEPENDENCY_LIST::AddModule(
PSTR pszFileName )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PE_EXE
peFile( pszFileName ); // Get easy access to the executable</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( FALSE =&nbsp;= peFile.IsValid() ) // A valid PE file???</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
(errModuleDependencyList)peFile.GetErrorType();</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PMODULE_FILE_INFO
pNew = new MODULE_FILE_INFO( pszFileName );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !pNew )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
errMDL_GENERAL_FAILURE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pNew-&gt;m_pNext
= m_pList;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pList
= pNew;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_cModules++;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Now see if this module imports any other modules. If so, we need</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
to recurse and add them as well.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(0 =&nbsp;= peFile.GetDataDirectoryEntrySize(
IMAGE_DIRECTORY_ENTRY_IMPORT ))</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
errMDL_NO_ERROR;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Make a pointer to the imports table</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PIMAGE_IMPORT_DESCRIPTOR
pImportDir;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pImportDir
= (PIMAGE_IMPORT_DESCRIPTOR)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">peFile.GetDataDirectoryEntryPointer(IMAGE_DIRECTORY_ENTRY_IMPORT);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !pImportDir )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
errMDL_NO_ERROR;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
While there are still non-null IMAGE_IMPORT_DESCRIPTORs...</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">while
( pImportDir-&gt;Name )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get a pointer to the imported module's base name</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
pszBaseName;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pszBaseName
= (PSTR)peFile.GetReadablePointerFromRVA(pImportDir-&gt;Name);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !pszBaseName )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">break;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Check to see if it's already in our list. Don't add again if so.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( 0 =&nbsp;= LookupModule( pszBaseName, FALSE ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Search path supposedly has the same searching algorithm as</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
the the Win32 loader...</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szPath[MAX_PATH];</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
pszDontCare;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( SearchPath(0, pszBaseName, 0, MAX_PATH, szPath,
&amp;pszDontCare))</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">AddModule(
szPath );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pNew-&gt;AddNotFoundModule(
pszBaseName );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pImportDir++;
// Advance to next imported module</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
errMDL_NO_ERROR;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">What if there&#146;s an error
    and a dependency list isn&#146;t generated? For instance,
    what if a nonexistent file name is passed to the constructor?
    The IsValid method returns a BOOL indicating if a dependency
    list was successfully created. If there was a problem, you
    can ascertain the reason via the GetErrorType method, which
    returns an enum indicating the cause of the problem. The
    possible problems are a file that doesn&#146;t exist, a file
    that&#146;s not a Win32 PE file, and &quot;general.&quot; The
    last is a catchall for problems such as memory allocation
    failures. You can also get a descriptive string for the
    problem by calling the GetErrorString method.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If the dependency list was
    created successfully, there are two methods for finding out
    about a particular module in the list. The LookupModule
    method takes either the base file name or the full path to a
    module and returns information about the module, if found.
    The GetNextModule method is for iterating through each module
    in succession. To start the enumeration, pass in zero as the
    parameter. All subsequent calls should pass a pointer to the
    information returned by the previous call to GetNextModule.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The most interesting code in
    MODULE_DEPENDENCY_LIST occurs during the constructor call.
    This code takes the file name parameter and prepares to add
    it as the first entry in the dependency list. Next, the
    constructor saves the current directory away and switches to
    the directory where the file is located. This mimics the
    behavior of the operating system, which treats the
    executable&#146;s directory as implicitly part of the search
    path. After creating the entire dependency list, the
    constructor switches the current directory back to its
    original value. If you decide to use the
    MODULE_DEPENDENCY_LIST code in your own programs, be aware
    that this directory switching makes the class thread-unsafe.
    Remember, the current working directory is effectively global
    data for a program.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The workhorse of the
    MODULE_DEPENDENCY_LIST class is the private AddModule method,
    invoked from the class&#146;s constructor. AddModule takes a
    file name as a parameter and adds the file&#146;s information
    to the dependency list. AddModule next scans through the
    file&#146;s import table and looks for other files that
    aren&#146;t already in the dependency list. If AddModule
    finds such a module, it calls itself again, this time with
    the name of the imported module. This recursiveness is
    similar to what the Win32 loader does when it verifies that
    all required modules are present before starting a process.
    By the time the first call to AddModule returns, the entire
    dependency tree has been recursively searched and built.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Another way that the AddModule
    method imitates the system&#146;s behavior is in how it finds
    the complete path to imported DLLs. In the import table of a
    module, only the base name of the imported DLL appears (for
    example, &quot;ONION32.DLL&quot;). The system takes that base
    file name and searches the path for a file with that name. I
    didn&#146;t want to write my own path-searching code and,
    luckily, I didn&#146;t have to; the Win32 SearchPath API does
    exactly what I need. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">With the AddModule method
    behind me, let&#146;s now return to the subject of extracting
    information about the dependency list. Both the LookupModule
    and GetNextModule methods of the MODULE_DEPENDENCY_LIST class
    return a pointer to a class known as MODULE_FILE_INFO. A
    MODULE_FILE_INFO class describes exactly one module in the
    dependency list, and is implemented in ModuleFileInfo.H and
    ModuleFileInfo.CPP. The primary public methods are
    GetBaseName and GetFullName, which return the base file name
    and full path to the module, respectively.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">One slick new addition to the
    MODULE_DEPENDENCY_LIST code (relative to the version of this
    code from my Liposuction article) is the &quot;not
    found&quot; list. Each MODULE_FILE_INFO class contains a list
    of imported modules that the
    MODULE_DEPENDENCY_LIST::AddModule method was unable to
    locate. To enumerate this list, use the GetNextNotFoundModule
    method, which returns a pointer to a MODULE_FILE_INFO
    describing the unlocatable module. To start enumerating the
    unfound modules, pass in a NULL pointer. In subsequent calls,
    pass the previously returned MODULE_FILE_INFO pointer.
    I&#146;ll demonstrate this method later on. </font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>The
PE_EXE Class</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">While much of the action of
    DEPENDS occurs in MODULE_DEPENDENCY_LIST, this class relies
    heavily on the underlying PE_EXE class shown in <b>Figure 5</b>.
    The PE_EXE class is itself derived from the EXE_FILE class
    (see <b>Figure 6</b>), which is derived from the
    MEMORY_MAPPED_FILE class. <b>Figure 7</b> shows the
    hierarchy. Let&#146;s start at the lowest level, and look at
    each successive class briefly.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;5&nbsp;PE_EXE
Class</b></font></p>

<p><font color="#000000" size="1" face="Courier New">PeExe.h</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Matt Pietrek</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, Feb 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: PeExe.h</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifndef
__PEEXE_H__</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
__PEEXE_H__</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifndef
__EXEFILE_H__</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;exefile.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">class
PE_EXE : public EXE_FILE</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">public:</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PE_EXE(
PSTR pszFileName );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">~PE_EXE(
){ }</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">IsValid()
{ return m_pNtHdr ? TRUE : FALSE; }</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
For those who want at the data directly</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PIMAGE_NT_HEADERS
GetIMAGE_NT_HEADERS( void ) { return m_pNtHdr; }</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
IMAGE_FILE_HEADER fields</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WORD
GetMachine( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;FileHeader.Machine; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WORD
GetNumberOfSections( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;FileHeader.NumberOfSections; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetTimeDateStamp(void)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;FileHeader.TimeDateStamp; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetCharacteristics( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;FileHeader.Characteristics; }</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
IMAGE_OPTIONAL_HEADER fields</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetSizeOfCode( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.SizeOfCode; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetSizeOfInitializedData( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.SizeOfInitializedData; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetSizeOfUninitializedData( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.SizeOfUninitializedData; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetAddressOfEntryPoint( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.AddressOfEntryPoint; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetBaseOfCode( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.BaseOfCode; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetBaseOfData( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.BaseOfData; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetImageBase( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.ImageBase; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetSectionAlignment( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.SectionAlignment; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetFileAlignment( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.FileAlignment; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WORD
GetMajorOperatingSystemVersion( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.MajorOperatingSystemVersion; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WORD
GetMinorOperatingSystemVersion( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.MinorOperatingSystemVersion; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WORD
GetMajorImageVersion( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.MajorImageVersion; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WORD
GetMinorImageVersion( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.MinorImageVersion; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WORD
GetMajorSubsystemVersion( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.MajorSubsystemVersion; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WORD
GetMinorSubsystemVersion( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.MinorSubsystemVersion; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
DWORD GetWin32VersionValue( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
{ return m_pNtHdr-&gt;OptionalHeader.Win32VersionValue; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetSizeOfImage( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.SizeOfImage; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetSizeOfHeaders( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.SizeOfHeaders; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WORD
GetSubsystem( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.Subsystem; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetSizeOfStackReserve( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.SizeOfStackReserve; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetSizeOfStackCommit( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.SizeOfStackCommit; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetSizeOfHeapReserve( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.SizeOfHeapReserve; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetSizeOfHeapCommit( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
return m_pNtHdr-&gt;OptionalHeader.SizeOfHeapCommit; }</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetDataDirectoryEntryRVA( DWORD id );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PVOID
GetDataDirectoryEntryPointer( DWORD id );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetDataDirectoryEntrySize( DWORD id );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PVOID
GetReadablePointerFromRVA( DWORD rva );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">protected:</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
RVAToFileOffset( DWORD rva );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PIMAGE_NT_HEADERS
m_pNtHdr;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">PeExe.cpp</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Matt Pietrek</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, Feb 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: PeExe.cpp</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;windows.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;stdlib.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#pragma
hdrstop</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;peexe.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PE_EXE::PE_EXE(
PSTR pszFileName ) : EXE_FILE( pszFileName )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pNtHdr
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( FALSE =&nbsp;= EXE_FILE::IsValid() )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
It's an EXE, but is it a *PE* file??? If not, set code and bail</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( GetExeType() != exeType_PE )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_errorType
= errEXE_FILE_INVALID_FORMAT;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pNtHdr
=
MakePtr(PIMAGE_NT_HEADERS,GetBase(),GetSecondaryHeaderOffset());</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
PE_EXE::GetDataDirectoryEntryRVA( DWORD id )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Given a IMAGE_DIRECTORY_ENTRY_XXX value (see WINNT.H), retrive
the</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
RVA stored in the corresponding slot</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( id &gt;= IMAGE_NUMBEROF_DIRECTORY_ENTRIES )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
(DWORD)-1;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
m_pNtHdr-&gt;OptionalHeader.DataDirectory[id].VirtualAddress;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PVOID
PE_EXE::GetDataDirectoryEntryPointer( DWORD id )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Given a IMAGE_DIRECTORY_ENTRY_XXX value (see WINNT.H), return a
pointer</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
to memory that corresponds to the RVA in the specified slot.</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( id &gt;= IMAGE_NUMBEROF_DIRECTORY_ENTRIES )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
(PVOID)-1;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
va =
m_pNtHdr-&gt;OptionalHeader.DataDirectory[id].VirtualAddress;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !va ) // Return 0 if the RVA is 0</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
GetReadablePointerFromRVA( va );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
PE_EXE::GetDataDirectoryEntrySize( DWORD id )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Given a IMAGE_DIRECTORY_ENTRY_XXX value (see WINNT.H), retrive
the</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
size value stored in the corresponding slot</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( id &gt;= IMAGE_NUMBEROF_DIRECTORY_ENTRIES )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
(DWORD)-1;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
m_pNtHdr-&gt;OptionalHeader.DataDirectory[id].Size;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PVOID
PE_EXE::GetReadablePointerFromRVA( DWORD rva )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Given an RVA, translate it into a pointer within our linear
memory</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
mapping for the executable.</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
fileOffset = RVAToFileOffset( rva );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( (DWORD)-1 =&nbsp;= fileOffset )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
MakePtr( PVOID, GetBase(), fileOffset );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
PE_EXE::RVAToFileOffset( DWORD rva )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Given an RVA, figure out which section encompasses it. Next,
using</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
the PointerToRawData field for the found section, return an
actual</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
file offset that corresponds to the RVA</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PIMAGE_SECTION_HEADER
pSectHdr = IMAGE_FIRST_SECTION( m_pNtHdr );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">for
( unsigned i = 0; i &lt; GetNumberOfSections(); i++, pSectHdr++ )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
cbMaxOnDisk</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">=
min( pSectHdr-&gt;Misc.VirtualSize, pSectHdr-&gt;SizeOfRawData );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
startSectRVA = pSectHdr-&gt;VirtualAddress;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
endSectRVA = startSectRVA + cbMaxOnDisk;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( (rva &gt;= startSectRVA) &amp;&amp; (rva &lt; endSectRVA) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pSectHdr-&gt;PointerToRawData + (rva - startSectRVA);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
(DWORD)-1; // RVA not found in the section table... Ooops!</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
6&nbsp; EXE_FILE Class</b></font></p>

<p><font color="#000000" size="1" face="Courier New">ExeFile.h</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Matt Pietrek</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, Feb 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: ExeFile.h</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifndef
__EXEFILE_H__</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
__EXEFILE_H__</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifndef
__MEMMAPFL_H__</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;memorymappedfile.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
MakePtr is a macro that allows you to easily add to values
(including</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
pointers) together without dealing with C&#146;s pointer
arithmetic. It</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
essentially treats the last two parameters as DWORDs. The first</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
parameter is used to typecast the result to the appropriate
pointer type.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
MakePtr( cast, ptr, addValue ) (cast)( (DWORD)(ptr) +
(DWORD)(addValue))</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">enum
EXE_TYPE { exeType_Invalid, exeType_DOS, exeType_NE, exeType_VXD,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">exeType_LX,
exeType_PE };</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">enum
errEXE_FILE { errEXE_FILE_NO_ERROR,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">errEXE_FILE_FILE_NOT_FOUND,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">errEXE_FILE_INVALID_FORMAT
};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">class
EXE_FILE : public MEMORY_MAPPED_FILE</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">public:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXE_FILE(
PSTR pszFileName );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">~EXE_FILE(
){ ; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
IsValid( void ){ return errMMF_NoError == m_errorType; }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">errEXE_FILE
GetErrorType( void ){ return m_errorType; }</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetSecondaryHeaderOffset( void ){ return m_secondaryHeaderOffset;
}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXE_TYPE
GetExeType( void ){ return m_exeType; }</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
GetFileTypeDescription( void );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">protected:</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">errEXE_FILE
m_errorType;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">private:</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LONG
m_secondaryHeaderOffset;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXE_TYPE
m_exeType;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="Courier New">ExeFile.cpp</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Matt Pietrek</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, Feb 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: ExeFile.cpp</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;windows.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#pragma
hdrstop</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;ExeFile.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXE_FILE::EXE_FILE(
PSTR pszFileName ) : MEMORY_MAPPED_FILE( pszFileName )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_errorType
= errEXE_FILE_FILE_NOT_FOUND;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_secondaryHeaderOffset
= -1; // A bogus value to catch bugs</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_exeType
= exeType_Invalid;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( FALSE == MEMORY_MAPPED_FILE::IsValid() )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;
// m_errorType already set to errEXE_FILE_FILE_NOT_FOUND</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If we get here, the file exists, and was mapped. We&#146;re still
not</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
sure that it&#146;s a valid EXE though</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_errorType
= errEXE_FILE_INVALID_FORMAT;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( GetFileSize() &lt; sizeof(IMAGE_DOS_HEADER) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PIMAGE_DOS_HEADER
pDosHdr = (PIMAGE_DOS_HEADER)GetBase();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( IMAGE_DOS_SIGNATURE != pDosHdr-&gt;e_magic )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If we get here, it&#146;s at least a DOS &#145;MZ&#146; file</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_errorType
= errEXE_FILE_NO_ERROR;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pDosHdr-&gt;e_lfarlc &lt; 0x40 ) // Theoretically, this field
must be &gt;=</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
// 0x40 for it to be a non-DOS executable</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_exeType
= exeType_DOS;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Sanity check. Make sure the &quot;new header&quot; offset
isn&#146;t past the end</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
of the file</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pDosHdr-&gt;e_lfanew &gt; (LONG)GetFileSize() )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Make a pointer to the secondary header </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_secondaryHeaderOffset
= pDosHdr-&gt;e_lfanew;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PWORD
pSecondHdr = MakePtr( PWORD, GetBase(), m_secondaryHeaderOffset
);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Decide what type of EXE, based on the start of the secondary
header</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">switch
( *pSecondHdr )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
IMAGE_OS2_SIGNATURE: m_exeType = exeType_NE; break;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
IMAGE_VXD_SIGNATURE: m_exeType = exeType_VXD; break;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
0x4558: m_exeType = exeType_LX; break; // OS/2 2.X</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( *(PDWORD)pSecondHdr == IMAGE_NT_SIGNATURE )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_exeType
= exeType_PE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
EXE_FILE::GetFileTypeDescription( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Returns a static string that describes what type this file is</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">switch
( m_exeType )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
exeType_DOS: return &quot;DOS&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
exeType_NE: return &quot;NE&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
exeType_VXD: return &quot;VXD&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
exeType_LX: return &quot;LX&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">case
exeType_PE: return &quot;PE&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">default:
return &quot;Invalid&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The base class for the
    hierarchy is the MEMORY_MAPPED_FILE class. It simply provides
    a wrapper around the APIs necessary to use memory-mapped
    files: CreateFile, CreateFileMapping, and MapViewOfView. The
    destructor for the class automatically undoes everything to
    clean up properly.</font></p>
    <p><img src="hood7.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
7&nbsp; Class Hierarchy</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">After the MEMORY_MAPPED_FILE
    constructor returns, you can check that everything went OK by
    calling the IsValid method. For more detailed information in
    the event of an error, call the GetErrorType method. If
    everything succeeded, the GetBase method returns a pointer to
    the beginning of the mapped region.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Up a level in the hierarchy is
    the EXE_FILE class, which is derived from the
    MEMORY_MAPPED_FILE class. This is because an EXE_FILE is just
    a special case of a regular file. The EXE_FILE constructor
    also takes a file name as its only parameter, and passes the
    file name on to the MEMORY_MAPPED_FILE constructor. The guts
    of the EXE_FILE constructor check to make sure that the file
    is (at a minimum) an MS-DOS¨ MZ executable. Code using the
    EXE_FILE class can use the IsValid function to ensure that
    the specified file really is an executable.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If the file begins with an
    MS-DOS MZ executable, the executable may be just an MS-DOS
    stub for a newer type of executable. The file might really be
    a 16-bit Windows executable (NE), a Win32 executable (PE), an
    OS/2 executable (LX), or a VxD (LE). The EXE_FILE constructor
    examines the file and tries to determine what type of
    executable it is. The EXE_FILE::GetExeType method returns an
    enum indicating the kind of executable it is. All of the more
    modern executables contain a secondary header, so the
    EXE_FILE class also has the GetSecondaryHeaderOffset method,
    which does just what its name implies.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Finally, the PE_EXE class
    derives from the EXE_FILE class. The PE_EXE constructor also
    takes a file name as the only parameter, and passes it down
    the chain to the EXE_FILE constructor. The PE_EXE class has
    specific knowledge about the IMAGE_NT_HEADERS and related
    structures defined in WINNT.H. After creating the class, call
    the IsValid method to make sure that everything went OK
    before using the other methods. PE_EXE doesn&#146;t define
    its own GetErrorType method. Rather, the same error codes
    returned by the base class EXE_FILE::GetErrorType method
    apply.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Once a valid PE_EXE exists,
    there are several different ways of accessing the data in the
    file. The GetIMAGE_NT_HEADERS method returns a pointer to the
    IMAGE_NT_HEADERS structure in the memory-mapped file, and
    you&#146;re free to pick through it however you want. For
    simpler access to the data, the PE_EXE class provides wrapper
    methods that return the values of individual fields in the PE
    header (for example, the GetAddressOfEntryPoint method). The
    class also provides easy access to information in the PE
    file&#146;s DataDirectory via the GetDataDirectoryEntry<i>XXX</i>
    methods. Finally, the GetReadablePointerFromRVA method takes
    a Relative Virtual Address (RVA) as input, and returns a
    pointer to the corresponding location in the underlying
    memory-mapped file.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In my Liposuction code, I went
    a step further and derived a PE_EXE2 class from the PE_EXE
    class. I don&#146;t need anything so fancy here. The PE_EXE
    class provides quick and easy access to information in a PE
    file with a minimum of overhead. I suspect that I&#146;ll be
    using the PE_EXE class in future projects because it&#146;s
    so handy.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Who&#146;s
Got the Time?</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">My initial goals for DEPENDS
    were to just spit out the dependency list and then elaborate
    it with the ability to print out the full path to the module.
    Next on the list was to add date and time information.
    That&#146;s when I ran into trouble with Win32. As I
    mentioned earlier, there are at least four different ways
    that a time can be stored under Win32, and I ended up working
    with all four.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The first type of time that I
    encountered was FILETIME, which is a 64-bit structure
    returned by the GetFileTime function. Looking up the FILETIME
    structure in the SDK documentation, you&#146;ll come across
    this definition: &quot;The FILETIME structure is a 64-bit
    value representing the number of 100-nanosecond intervals
    since January 1, 1601.&quot; I don&#146;t know about you, but
    I find that friends and relatives get testy when I specify
    the time in 100-nanosecond intervals. Luckily, the second
    Win32 time format comes to the rescue. This time format is a
    structure known as a SYSTEMTIME that has fields for the year,
    month, day, hour, second, and millisecond. There&#146;s even
    a Win32 API, FileTimeToSystemTime, that does the conversion
    for you. Of course, if you&#146;re big into the whole Julian,
    Gregorian, leap year, leap century thing, you could do the
    conversion yourself.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Once I had coded up my calls
    to GetFileTime and FileTimeToSystemTime, I fired up the
    program and promptly discovered that all the times were off
    by several hours. Ooops! Remember when you installed Windows
    NT or Windows® 95 and you had to tell it where you live?
    There&#146;s a reason for that. It turns out that, under
    Win32, file times are specified in Coordinated Universal Time
    (UTC). Using UTC allows for the operating system to account
    for the fact that while it&#146;s 7PM in Greenwich, England,
    it&#146;s only 2PM in Nashua, New Hampshire.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Making every programmer
    responsible for checking time zones and compensating
    accordingly would be a bad thing. That&#146;s why Win32 has
    the FileTimeToLocalTime API. To make my file dates and times
    appear correct, I had to first call FileTimeToLocalFileTime
    before calling FileTimeToSystemTime.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The third format for
    representing times in Win32 is the old MS-DOS way. In this
    format, the date and time are stored in separate WORDs.
    Because there are only 16 bits to play with, the year is
    stored relative to 1980. Likewise, the lowest time resolution
    is two seconds. If you choose to work in this time format,
    the FileTimeToDosDateTime API will be of interest. Why bring
    up this archaic time format? Silly me; when I started work on
    DEPENDS, I didn&#146;t immediately realize that the
    SYSTEMTIME format was what I should be using. The early
    versions of DEPENDS converted FILETIMEs to MS-DOS dates and
    times until I realized the error of my ways.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The fourth time format under
    Win32 is one you won&#146;t see in any of the API
    documentation. In Win32 executables, there&#146;s a DWORD in
    the IMAGE_FILE_HEADER portion of the PE header. This DWORD is
    called the TimeDateStamp, and represents the number of
    seconds since midnight on January 1, 1970, in Greenwich,
    England. The TimeDateStamp is set by the linker, and is
    actually used in other parts of a PE file.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">At this point, I need to
    confess a small boo-boo. In my article, &quot;Peering Inside
    the PE: A Tour of the Win32 Portable Executable File
    Format,&quot; (<i>MSJ</i> March 1994), as well as in my book,
    <i>Windows 95 System Programming Secrets</i>, I described the
    TimeDateStamp field as being the number of seconds since 4PM
    on December 31, 1969. I obtained this particular time by
    setting the TimeDateStamp on a file to the value zero and
    then running DUMPBIN on the file. What I didn&#146;t take
    into account was that DUMPBIN was adjusted for my time zone
    (which pretty obviously wasn&#146;t Greenwich Mean Time). So
    here&#146;s another one for all you errata collectors out
    there.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">This TimeDateStamp field can
    be quite useful. For example, while you can change the
    file&#146;s date and time in the file system, the
    TimeDateStamp remains unaffected. Therefore, if you really
    want to know when an executable was created, the
    TimeDateStamp field is more accurate (assuming the linker set
    it properly). The only tricky part is fig- uring out how to
    get the number of seconds since 1970 into a format that the
    general population cares to work with.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">After pondering this problem
    for a while, I came across the following trick. Both FILETIME
    and TimeDateStamp are values relative to some point in time.
    If I can somehow express a TimeDateStamp in terms of a
    FILETIME, I can then use the various Win32 time APIs to do
    whatever I desire. To start with, I need to know how January
    1, 1970, is expressed as a 64-bit FILETIME. Next, I need to
    convert the TimeDateStamp (expressed in seconds) into
    100-nanosecond units. Finally, add the two values together to
    make a FILETIME containing the desired time.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To convert January 1, 1970,
    into a FILETIME, I work backwards. First, I create a
    SYSTEMTIME structure and fill in the fields corresponding to
    January 1, 1970. Next, I pass this structure to the
    SystemTimeToFileTime API and print out the resulting 64-bit
    FILETIME value. You can see this value (0x0x019DB1DED53E8000)
    in use in the DEPENDS code. Converting seconds to
    100-nanosecond units is easy. Just multiply by 10 million. Of
    course, the result could overflow a 32-bit DWORD, so I made
    sure to cast one of the multiplicands to a 64-bit integer (an
    __int64 in Visual C++). Of course, if you want to take the
    easy way out, you could just use the ctime function from the
    C runtime library.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>The
DEPENDS Code</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The main code for Depends.exe
    is in Depends.cpp (see <b>Figure 8</b>). The main function
    first invokes the ProcessCommandLine function to parse the
    command-line arguments, including the name of the file to
    process. Next, function main declares a
    MODULE_DEPENDENCY_LIST class instance. The rest of function
    main is a while loop that iterates through every
    MODULE_FILE_INFO class in the dependency list. Each
    MODULE_FILE_INFO instance is passed to the
    DisplayFileInformation function, which emits the requested
    information about the file. Before continuing on to the next
    module, the while loop also uses the
    MODULE_FILE_INFO::GetNextNotFoundModule method to print out
    any imported modules that weren&#146;t located. By doing
    this, DEPENDS makes it easy to track down exactly who&#146;s
    referencing some DLL that the system isn&#146;t finding.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;8&nbsp;Depends.cpp</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Matt Pietrek</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, Feb 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: Depends.cpp</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==========================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;windows.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;stdio.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;DependencyList.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;PeExe.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==============================
Variables ===============================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
g_szHelpSyntax[] =</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;DEPENDS
- Matt Pietrek, 1997, for MSJ\n&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;Syntax:
DEPENDS [args] &lt;executable filename&gt;\n&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;
/v show version information\n&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;
/t show time &amp; date information\n&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;
/p show full path\n&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;
/l show link time &amp; date information\n\n&quot;;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
* g_pszPrimaryFile = 0;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
g_fShowDateTime = FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
g_fShowLinkDateTime = FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
g_fShowVersion = FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
g_fShowFullPath = FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==============================
Prototypes ===============================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
DisplayFileInformation( PMODULE_FILE_INFO pModInfo );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
ShowVersionInfo( PSTR pszFileName );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
TimeDateStampToFileTime( DWORD timeDateStamp, LPFILETIME
pFileTime );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
GetFileDateAsString( LPFILETIME pFt, char * pszDate, unsigned
cbIn );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
GetFileTimeAsString( LPFILETIME pFt, char * pszTime, unsigned
cbIn,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
fSeconds );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//===================================
Code ================================</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
ProcessCommandLine( int argc, char * argv[] )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
fSawFileName = FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( argc &lt; 2 )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">for
( int i = 1; i &lt; argc; i++ )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
pArg = argv[i];</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( (*pArg =&nbsp;= '/') || (*pArg =&nbsp;= '-') ) // Is it a
switch char?</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pArg++;
// Point past switch char</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( 0 =&nbsp;= lstrcmpi( pArg, &quot;v&quot; ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">g_fShowVersion
= TRUE; </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
if ( 0 =&nbsp;= lstrcmpi( pArg, &quot;t&quot; ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">g_fShowDateTime
= TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
if ( 0 =&nbsp;= lstrcmpi( pArg, &quot;l&quot; ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">g_fShowLinkDateTime
= TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
if ( 0 =&nbsp;= lstrcmpi( pArg, &quot;p&quot; ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">g_fShowFullPath
= TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;Unrecognized option: \&quot;%s\&quot;\n&quot;, pArg );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( fSawFileName )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">g_pszPrimaryFile
= pArg;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">fSawFileName
= TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
fSawFileName;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
main( int argc, char * argv[] )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !ProcessCommandLine( argc, argv ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
g_szHelpSyntax );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
1;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MODULE_DEPENDENCY_LIST
depends( g_pszPrimaryFile );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !depends.IsValid() )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;Error: %s %s\n&quot;, g_pszPrimaryFile,
depends.GetErrorString() );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
1;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PMODULE_FILE_INFO
pModInfo = 0;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">while
( pModInfo = depends.GetNextModule( pModInfo ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DisplayFileInformation(
pModInfo );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PMODULE_FILE_INFO
pNotFound = 0;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">while
( pNotFound = pModInfo-&gt;GetNextNotFoundModule(pNotFound) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot; Not found: %s\n&quot;, pNotFound-&gt;GetBaseName() );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
DisplayFileInformation( PMODULE_FILE_INFO pModInfo )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;%-14s&quot;, pModInfo-&gt;GetBaseName() );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
pszFullName = pModInfo-&gt;GetFullName();</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( g_fShowDateTime )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">HFILE
hFile = _lopen( pszFullName, OF_READ );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( HFILE_ERROR != hFile )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FILETIME
ft;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( GetFileTime( (HANDLE)hFile, 0, 0, &amp;ft ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szFileDate[32] = { 0 };</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szFileTime[32] = { 0 };</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">GetFileDateAsString(&amp;ft,
szFileDate, sizeof(szFileDate) );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">GetFileTimeAsString(&amp;ft,
szFileTime, sizeof(szFileTime),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">TRUE);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;%s %s &quot;, szFileDate, szFileTime );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_lclose(
hFile );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( g_fShowLinkDateTime )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FILETIME
ft;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szFileDate[32] = { 0 };</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szFileTime[32] = { 0 };</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PE_EXE
exe( pszFullName );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">TimeDateStampToFileTime(
exe.GetTimeDateStamp(), &amp;ft );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">GetFileDateAsString(&amp;ft,
szFileDate, sizeof(szFileDate) );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">GetFileTimeAsString(&amp;ft,
szFileTime, sizeof(szFileTime),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">TRUE);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;%s %s &quot;, szFileDate, szFileTime );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( g_fShowFullPath )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;(%s)&quot;, pszFullName );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;\n&quot; );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( g_fShowVersion )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ShowVersionInfo(
pszFullName );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
ShowVersionInfo( PSTR pszFileName )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
cbVerInfo, dummy;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
How big is the version info?</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">cbVerInfo
= GetFileVersionInfoSize( pszFileName, &amp;dummy );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !cbVerInfo )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Allocate space to hold the info</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PBYTE
pVerInfo = new BYTE[cbVerInfo];</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !pVerInfo )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_try</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !GetFileVersionInfo(pszFileName, 0, cbVerInfo, pVerInfo) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_leave;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
* predefResStrings[] = </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;CompanyName&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;FileDescription&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;FileVersion&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;InternalName&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;LegalCopyright&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;OriginalFilename&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;ProductName&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;ProductVersion&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">0</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">for
( unsigned i=0; predefResStrings[i]; i++ )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szQueryStr[ 0x100 ];</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szQueryStr2[0x100 ];</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Format the string with the 1200 codepage (Unicode)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">wsprintf(
szQueryStr, &quot;\\StringFileInfo\\%04X%04X\\%s&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">GetUserDefaultLangID(),
1200,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">predefResStrings[i]
);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Format the string with the 1252 codepage (Windows Multilingual)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">wsprintf(
szQueryStr2, &quot;\\StringFileInfo\\%04X%04X\\%s&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">GetUserDefaultLangID(),
1252,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">predefResStrings[i]
);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
We may want to format a string with the &quot;0000&quot; codepage</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSTR
pszVerRetVal;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">UINT
cbReturn;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
fFound;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Try first with the 1252 codepage</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">fFound
= VerQueryValue( pVerInfo, szQueryStr,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">(LPVOID
*)&amp;pszVerRetVal, &amp;cbReturn );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !fFound )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Hmm... 1252 wasn't found. Try the 1200 codepage</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">fFound
= VerQueryValue( pVerInfo, szQueryStr2,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">(LPVOID
*)&amp;pszVerRetVal, &amp;cbReturn );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( fFound )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot; %s %s\n&quot;, predefResStrings[i], pszVerRetVal );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_finally</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">delete
[]pVerInfo;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Convert a TimeDateStamp (i.e., # of seconds since 1/1/1970) into
a FILETIME</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
TimeDateStampToFileTime( DWORD timeDateStamp, LPFILETIME
pFileTime )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__int64
t1970 = 0x019DB1DED53E8000; // Magic... GMT... Don't ask....</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__int64
timeStampIn100nsIncr = (__int64)timeDateStamp * 10000000;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__int64
finalValue = t1970 + timeStampIn100nsIncr;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">memcpy(
pFileTime, &amp;finalValue, sizeof( finalValue ) );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
GetFileDateAsString( LPFILETIME pFt, char * pszDate, unsigned
cbIn )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FILETIME
ftLocal;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">SYSTEMTIME
st;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !FileTimeToLocalFileTime( pFt, &amp;ftLocal ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !FileTimeToSystemTime( &amp;ftLocal, &amp;st ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szTemp[12];</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">wsprintf(
szTemp, &quot;%02u/%02u/%04u&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">st.wMonth,
st.wDay, st.wYear );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">lstrcpyn(
pszDate, szTemp, cbIn );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
GetFileTimeAsString( LPFILETIME pFt, char * pszTime, unsigned
cbIn,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
fSeconds )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FILETIME
ftLocal;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">SYSTEMTIME
st;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !FileTimeToLocalFileTime( pFt, &amp;ftLocal ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !FileTimeToSystemTime( &amp;ftLocal, &amp;st ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szTemp[12];</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( fSeconds ) // Want seconds???</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">wsprintf(
szTemp, &quot;%02u:%02u:%02u&quot;, st.wHour, st.wMinute, </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">st.wSecond
);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
// No thanks.. Just hours and minutes</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">wsprintf(
szTemp, &quot;%02u:%02u&quot;, st.wHour, st.wMinute );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">lstrcpyn(
pszTime, szTemp, cbIn );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The DisplayFileInformation
    function, at a minimum, displays the base file name from the
    MODULE_FILE_INFO passed to it. The remainder of the
    function&#146;s output depends on the command-line switches.
    If /t is specified, the function uses GetFileTime and a pair
    of helper functions to display the file system&#146;s date
    and time for the file. Next, if /l is specified, the function
    creates a temporary instance of the PE_EXE class in order to
    retrieve the TimeDateStamp. The TimeDateStamp is then passed
    to a helper function, TimeDateStampToFileTime, and the
    returned FILETIME information is displayed</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The last bit of code in the
    DisplayFileInformation function is for the /v switch. If set,
    the file name is passed to the ShowVersionInfo function.
    ShowVersionInfo uses several of the version APIs:
    GetFileVersionInfoSize, GetFileVersionInfo, and
    VerQueryValue. After allocating space for the version
    information for a file and reading it in, the code uses
    VerQueryValue to look for the Win32 predefined version
    strings such as &quot;CompanyName,&quot;
    &quot;FileDescription,&quot; and so on. In writing this code,
    I found that even Microsoft is inconsistent in their use of a
    code page for the version strings. Most version resources use
    code page 1252 (Unicode), but a few use code page 1200
    (Windows Multilingual). My code checks for both. In testing,
    I found that some executables used even other code pages. If
    you&#146;re looking to improve the DEPENDS code, this
    function is fertile ground.</font></p>
</blockquote>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">When
I was all done, I figured that it was a perfect candidate for
TINYCRT, which appeared in my October 1996 column. TINYCRT is a
minimal replacement runtime library for the standard C++ RTL.
Using TINYCRT (the Visual C++ version is called LIBCTINY.LIB) is
as simple as including it in the linker&#146;s list of libraries.
By using LIBCTINY.LIB, I was able to cut Depends.exe from 25KB
down to 9KB. I&#146;ve included LIBCTINY.LIB in the downloadable
sources so that you can rebuild DEPENDS if necessary. </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>To
obtain complete source code listings, see </b></font><a
href="ednote.htm"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Editor's page</b></font></a><font
color="#000000" size="2" face="verdana,arial,helvetica"><b>.</b></font></p>

<p><font color="#000080" size="1" face="B Franklin Gothic Demi">Have
a question about programming in Windows? Send it to Matt at </font><a
href="mailto:71774.362@compuserve.com"><font color="#000080"
size="1" face="B Franklin Gothic Demi">71774.362@compuserve.com</font></a><font
color="#000080" size="1" face="B Franklin Gothic Demi">.</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><i>This article is reproduced
    from Microsoft Systems Journal. Copyright © 1997 by Miller
    Freeman, Inc. All rights are reserved. No part of this
    article may be reproduced in any fashion (except in brief
    quotations used in critical articles and reviews) without the
    prior consent of Miller Freeman.</i></font></p>
    <p><font color="#000000" size="2"><i>To contact Miller
    Freeman regarding subscription information, call (800)
    666-1084 in the U.S. and Canada, or (303) 678-0439 in all
    other countries. For other inquiries, call (415) 905-2200.</i></font></p>
</blockquote>
</font></body>
</html>
