<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Adobe application">
<meta name="Template" content="C:\MSOffice\Templates\MSJ.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>More Fun with MFC: DIBs, Palettes, Subclassing, and a Gamut of Reusable Goodies</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<p><font color="#000000" size="6" face="verdana,arial,helvetica">More
Fun with MFC: DIBs, Palettes, Subclassing, and a Gamut of
Reusable Goodies</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica">Paul DiLascia</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Paul DiLascia is a freelance
software consultant specializing in training and software
development in C++ and Windows. His the author of </b><b><i>Windows++:
Writing Reusable Code in C++</i></b><b> (Addison-Wesley, 1992)</b></font></p>

<blockquote>
    <p><font color="#000080" size="7"
    face="verdana,arial,helvetica">I</font><font color="#000000"
    size="2" face="verdana,arial,helvetica"> started writing this
    article as a how-to piece about writing a Quick View file
    viewer in MFC. In the process of building my viewer, I had to
    confront a number of real-world Windows programming
    problems&#151;drawing device-independent bitmaps, handling
    palette messages, dealing with fonts and so on. Nothing to do
    with writing file viewers per se, just everyday Windows¨
    fare, the sort of stuff you&#146;d expect to be trivial but
    that, because of the vagaries of Windows and MFC, are more
    likely to make you pull your hair out. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As I solved each problem, I
    didn&#146;t just fill my viewer with more and more lines of
    open code, like the incredible expanding blob; instead, I
    encapsulated my solutions in reusable C++
    classes&#151;classes I can use over and over again, as is, in
    any app. In other words, I didn&#146;t just solve each
    problem specifically, I solved it generally. By the time I
    was finished, I&#146;d accumulated a handy grab-bag of
    reusable components useful for any application. So I decided
    to share the goodies with the rest of the world. Even more
    important, I hope to illustrate a particular style of
    software development, one that emphasizes creating reusable
    components as you build your app. Not that this is going to
    be some sort of academic OOP sermon&#151;on the contrary,
    this will be a true-life case history, an exercise in
    real-world programming, where surprise lurks behind every
    function call and nothing ever goes the way you hope or want.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>The
Master Plan</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">When my client, the Maximum
    Leader of Acme Corporation, a multi-quadrillion-dollar
    conglomerate with offices across the solar system, asked me
    to develop a file viewer for their XYZ documents, I said,
    &quot;Sure thing, Max. No problem. When do you want it?&quot;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&quot;Three hours,&quot; he
    said, in a tone not to be trifled with.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Gulp. How do you write a file
    viewer in three hours? Well, whenever you&#146;re confronted
    with a daunting project in life or programming, the best
    thing to do is break it up into manageable tasks. <strong>Figure
    1</strong></font><font color="#000000" size="1"
    face="FranklinGothic"><b> </b></font><font color="#000000"
    size="2" face="verdana,arial,helvetica">shows my Master Plan
    of Attack. In this article, the first of two parts, I&#146;ll
    focus on step one of The Plan, writing the XYZ viewer.
    I&#146;ll show you all the goodies I developed along the way.
    In a later article, I&#146;ll show how I converted my XYZ
    viewer into a Quick View file viewer.</font></p>
    <p><img src="mfc1.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
1&nbsp; Master Plan of Attack</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Since the format of Acme
    Corporation&#146;s XYZ documents is super top secret, known
    only to five people, I&#146;ll use DIBs (device-independent
    bitmaps) as my file format. I chose DIBs because the real XYZ
    documents contain them, because DIBs are fun (all those
    pretty pictures to look at), and because dealing with DIBs is
    a real pain in the tush. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The problem is that while DIBs
    are common on disk&#151;almost any .BMP or .DIB file
    you&#146;re likely to run across uses the modern DIB
    format&#151;internally, Windows still prefers the older DDBs
    (device-dependent bitmaps). To draw a DIB, you have to
    convert it to a DDB (HBITMAP) using CreateDIBitmap, or else
    draw it directly using the special functions
    SetDIBitsToDevice or StretchDIBits. MFC&#146;s CBitmap class
    does nothing to make any of this easier; it&#146;s just the
    C++ equivalent of HBITMAP.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As my main project for this
    article, I&#146;ll show you how to write a program called
    DIBVIEW that displays DIBs. Since I&#146;m a firm believer
    that the easiest way to write complex programs is to first
    write simple ones and then extend them, I wrote DIBVIEW in a
    series of steps (see </font><font color="#000000" size="1"
    face="verdana,arial,helvetica">Figure 2</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">).
    Each step builds on the previous one, just like the infamous
    SCRIBBLE tutorial. That way it&#146;s easier for me to write
    the code and for you to understand it. Unfortunately, I
    can&#146;t show you all the steps because, if I did, this
    issue of <i>MSJ </i>would be thicker than an issue of <i>Modern
    Bride</i>. Only step three is printed here; next month
    I&#146;ll show you step four, the final one.</font></p>
</blockquote>

<blockquote>
    <blockquote>
        <blockquote>
            <p><font color="#000000" size="1"
            face="verdana,arial,helvetica">step one Baby Bitmap
            Viewer. CDib is implemented using the Video for
            Windows DrawDib API. Draws bitmaps correctly but
            doesn't handle palette messages. If you open one
            bitmap, then another, the first bitmap looks
            psychedelic.</font></p>
            <p><font color="#000000" size="1"
            face="verdana,arial,helvetica">step two CDib
            implemented as a CBitmap using standard Win32 API
            calls instead of DrawDib. Option to dither using
            DrawDib. DIBVIEW still doesn't handle palette
            messages.</font></p>
            <p><font color="#000000" size="1"
            face="verdana,arial,helvetica">step&nbsp;three Adds
            support for both MDI and SDI versions through a
            single compile-time #define variable, _MDI. Adds
            palette message handlers to do correct
            foreground/background palette realization. Now when
            you activate one window&#151;either one of multiple
            instances of DIBVIEW, or one of multiple child
            windows in the MDI version&#151;the other windows
            realize their palettes in the background.</font></p>
            <p><font color="#000000" size="1"
            face="verdana,arial,helvetica">step four Same as step
            three, but now the palette-handling functionality is
            encapsulated in a new class, CPalMsgHandler, that
            uses CMsgHook to handle palette messages in totally
            generic fashion. You can use CPalMsgHandler in any
            app that does palettes. CMsgHook is a generic
            subclassing mechanism for MFC windows. Step four also
            adds a slew of features: printing, zooming,
            BITMAPINFOHEADER displayed in user&#146;s choice of
            font, and font bigger/smaller buttons. (This step
            will be discussed in Part II.)</font></p>
        </blockquote>
    </blockquote>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>CDib
and The Baby Bitmap Viewer</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">OK, let&#146;s start writing
    DIBVIEW. Not a Quick View file viewer, but just an ordinary
    old standalone app. There&#146;s already a DIB viewer in the
    MFC SAMPLES directory, but using DIBLOOK would be cheating.
    Besides, that code is so old and grungy even Rip Van Winkle
    wouldn&#146;t recognize it, not to mention the fact that it
    doesn&#146;t even display hi-color bitmaps! All the
    Redmondtonians did for DIBLOOK was copy the code from an even
    older C SDK sample&#151;called coincidentally
    DIBVIEW&#151;and make it look marginally like C++. Our
    DIBVIEW uses all the latest APIs and it&#146;s
    object-oriented to the core. Plus, you can use the basic DIB
    class in any app.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Since the ultimate aim is to
    build a Quick View file viewer, and file viewers view only
    one doc at a time, I implemented DIBVIEW as an SDI app. Just
    select &quot;Single Document&quot; in AppWizard and press the
    GO button to get an instant vanilla app. The only thing left
    to do is fill in the blanks. Aside from all the fancy
    features, this basically means: write some code to load the
    bitmap and display it. So, where to begin? </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">When in doubt, define a class.
    Preferably with a suggestive name like CDib, and some equally
    suggestive functions like Load and Draw.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// Device Independent Bitmap</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">class CDib : public CObject {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">public:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL Load(LPCTSTR szPathName);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL Draw(CDC* pDC);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">};</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CDib is the first of several
    goodies you&#146;ll meet in this article. I built it for
    DIBVIEW, but you can use it in any app that uses DIBs.
    I&#146;ll show you two different implementations of CDib, one
    quick-and-dirty and the other more thorough. That&#146;s how
    I did it in real life and I want to emphasize how, if you
    encapsulate your code properly, you can change the
    implementation of a class without affecting the rest of the
    app much, if at all.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">For my first implementation, I
    was in a hurry (only three hours to write the whole thing). I
    didn&#146;t want to mess with CreateDIBitmap or palettes or
    whatever. I just wanted my DIB on the screen. This is where
    my experience with Video for Windows (VFW) came in handy. VFW
    has a really great API called DrawDib made just for drawing
    DIBs. VFW uses DrawDib to draw the frames in a video
    sequence, but you can use it to draw individual DIBs too.
    DrawDib is fast, and even does decompression. Most important,
    it&#146;s easy to use. There&#146;s a single function,
    DrawDibDraw, that draws the DIB. But before you can call it,
    you have to load the DIB into memory.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To load a DIB, you have to
    know its format, which is well documented in the Windows
    manuals. A bitmap comprises three parts: a BITMAPINFOHEADER,
    a color table or &quot;palette,&quot; and the image bits
    themselves (see <b>Figure 3</b>). For DIBs on disk,
    there&#146;s also a BITMAPFILEHEADER to precede all this. If
    the bitmap has a color table, the image bits are single-byte
    indexes into the color table. Bitmaps with more than 256
    colors don&#146;t have a color table, they just use RGB
    values for each pixel. They take more space, but the color is
    better. You can find out if a bitmap has a color table by
    looking at information in the BITMAPINFOHEADER (more on this
    later.)</font></p>
    <p><img src="mfc3.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
3&nbsp; Anatomy of a DIB</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><b>Figure 4</b> shows my first
    cut at CDib, including the Load function. Actually, there are
    two Load functions: CDib::Load(LPCTSTR) opens a CFile on the
    given path name, then calls CDib::Load(CFile&amp;) to do the
    work. I broke it up this way in case I ever wanted to load a
    DIB directly from a CFile. Either way, the first step in
    loading is to read the BITMAPFILEHEADER.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BITMAPFILEHEADER hdr;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD len =
    file.Read(&amp;hdr, sizeof(hdr));</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if ((len!=sizeof(hdr)) || </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">(hdr.bfType!=BITMAP_TYPE)) {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACE0(&quot;***CDib: bad
    BITMAPFILEHEADER\n&quot;);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return FALSE;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
4&nbsp; Dib1.cpp</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////////////////////////////////////////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
1996 Microsoft Systems Journal. </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If this program works, it was written by Paul DiLascia.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If not, I don't know who wrote it.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
CDib - Device Independent Bitmap.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
This implementation uses the Video for Windows DrawDib API to
draw.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;StdAfx.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;Dib.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">IMPLEMENT_DYNAMIC(CDib,
CObject)</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDib::CDib()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pbmih
= NULL;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_hdd
= NULL;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDib::~CDib()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DeleteObject();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Common function to delete stuff</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
CDib::DeleteObject()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(m_hdd) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DrawDibClose(m_hdd);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_hdd
= NULL;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(m_pbmih) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">delete
[] (char*)m_pbmih;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pbmih
= NULL;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get number of palette colors</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">UINT
CDib::GetNumPaletteColors()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Calculate # entries in color table:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
if biClrUsed is not specified, then use:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
(2,16,256) for (1,4,8)-bit bitmaps;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
0 for 24, 32-bit bitmaps (no color table)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">UINT
nColors=m_pbmih-&gt;biClrUsed;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(nColors==0 &amp;&amp; m_pbmih-&gt;biBitCount&lt;=8)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">nColors
= 1&lt;&lt;m_pbmih-&gt;biBitCount;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
nColors;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get ptr to actual bits.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LPBYTE
CDib::GetBits()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
(LPBYTE)m_pbmih + m_pbmih-&gt;biSize </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">+
GetNumPaletteColors()*sizeof(RGBQUAD); </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
First two bytes of bitmap file should be &quot;BM&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">const
BITMAP_TYPE = (WORD)('M' &lt;&lt; 8) | 'B';</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<blockquote>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">&#149;</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">&#149;</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">&#149;</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////////////////////////////////////////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Draw routine for a DIB on caller's DC. Like above, but</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
caller can specify source and destination rectangles.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Use Video for Windows DrawDIB API to do the work.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
CDib::Draw(CDC&amp; dc, const CRect* rcDst, const CRect* rcSrc)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!m_pbmih)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!m_hdd)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">VERIFY(m_hdd
= DrawDibOpen());</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CRect
rc;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!rcSrc) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
if no source rect, use whole bitmap</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rc.SetRect(0,
0, m_pbmih-&gt;biWidth, m_pbmih-&gt;biHeight);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcSrc=&amp;rc;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!rcDst)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
if no destination rect, use source</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcDst=rcSrc;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
This is as easy as it gets in Windows.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
DrawDibDraw(m_hdd, dc,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcDst-&gt;left,
rcDst-&gt;top, rcDst-&gt;Width(), rcDst-&gt;Height(),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pbmih,
GetBits(), </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcSrc-&gt;left,
rcSrc-&gt;top, rcSrc-&gt;Width(), rcSrc-&gt;Height(), 0);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If the information in the
    header doesn&#146;t pass a few rudimentary checks, CDib::Load
    gives up and returns FALSE. In particular, the first two
    bytes (hdr.bfType) must have the magic number BITMAP_TYPE,
    which is &quot;BM&quot; in ASCII.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Assuming the header is OK, the
    next step is easy: just read the rest of the file into a
    buffer.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">len = file.GetLength() - len;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">m_pbmih =
    (BITMAPINFOHEADER*)new char[len];</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">file.Read(m_pbmih, len);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CDib::m_pbmih points to the
    BITMAPINFOHEADER and everything else following it (color
    table and bitmap bits). Once the bitmap is loaded, drawing it
    is easy with DrawDib.</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL CDib::Draw(CDC&amp; dc,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">const CRect* rcDst, const
    CRect* rcSrc)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (!m_hdd)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">VERIFY(m_hdd = DrawDibOpen());</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return DrawDibDraw(m_hdd, dc,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">...,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">GetBits(),</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">...);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CDib::Draw calls DrawDibOpen
    to get a handle to a DrawDib context, then calls DrawDibDraw
    with this handle, the HDC, and a bunch of arguments:
    rectangle coordinates, pointer to the BITMAPINFOHEADER,
    pointer to the bits, and some flags. It&#146;s not every day
    you get to use a function that takes thirteen arguments!
    DrawDib does whatever decompression and bit-stretching are
    required to draw your DIB on the DC. The only hard part is
    getting the pointer to the actual bitmap bits in memory.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">LPBYTE CDib::GetBits()</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return (LPBYTE)m_pbmih + //
    start of bitmap +</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">m_pbmih-&gt;biSize + // size
    of header +</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">GetNumPaletteColors() // (num
    colors *</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">*sizeof(RGBQUAD); // size each
    entry)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The bits come after the
    BITMAPINFOHEADER and the color table, so getting them
    requires computing the size of the color table. Once you have
    that, just multiply by the size of each entry, which is an
    RGBQUAD. In older bitmaps (pre-Windows 3.0), the table is an
    array of RGBTRIPLE instead of RGBQUAD, but supporting old
    bitmaps was not a requirement for me, so I made Load reject
    them. (My second implementation supports old bitmaps
    too&#151;stay tuned.) To compute the number of colors, I
    wrote yet another function.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">UINT
    CDib::GetNumPaletteColors()</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">UINT
    nColors=m_pbmih-&gt;biClrUsed;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (nColors==0 &amp;&amp;
    m_pbmih-&gt;biBitCount&lt;=8)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">nColors =
    1&lt;&lt;m_pbmih-&gt;biBitCount;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return nColors;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The biClrUsed field in the
    BITMAPINFOHEADER tells how many colors are in the color
    table&#151;unless it&#146;s zero, in which case you have to
    compute the number of colors by looking at how many bits are
    used per pixel (biBitCount) and raising 2 to that power. For
    example, 4-bit color implies 16 total colors; 8-bit color
    implies 256 total colors. For more than 8-bit color,
    there&#146;s no color table at all because the image bits
    contain actual RGB values. All this stuff is boring and
    well-documented, so I won&#146;t dwell on it. The important
    thing is to observe how I started with a simple class, CDib,
    with two functions, Load and Draw, and expanded it as
    necessary to implement them.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Since most of the time I plan
    to draw my DIBs without stretching, but sometimes I&#146;ll
    want to, I added source and destination rectangles as
    arguments to my Draw function, with default NULL values,
    which tells Draw to use the default. CDib::GetSize returns
    the width and height as a CSize object.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">With CDib implemented, the
    rest of DIBVIEW is pretty brainless. I added a CDib as a data
    member in my document class, CDIBDoc, then overloaded
    CDIBDoc::OnOpenDocument to call CDib::Load.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL
    CDIBDoc::OnOpenDocument(LPCTSTR lpszPathName)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{ DeleteContents();</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return m_dib.Load(lpszPath);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To draw the bitmap, I call
    CDib::Draw from my view&#146;s OnDraw function.</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">void CDIBView::OnDraw(CDC*
    pDC)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{ </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CDib* pDIB = GetDIB();</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (pDIB)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">pDIB-&gt;Draw(*pDC);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I derived my view class from
    CScrollView to support scrolling, so there&#146;s also the
    usual business in OnInitialUpdate to set the scroll sizes to
    the width and height of the DIB, and I wrote
    CDIBDoc::DeleteContents to delete my DIB.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">void CDib::DeleteObject()</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (m_hdd) {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DrawDibClose(m_hdd);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">m_hdd = NULL;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (m_pbmih) {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">delete [] (char*)m_pbmih;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">m_pbmih = NULL;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><b>Figure 5</b></font><font
    color="#000000" size="2" face="FranklinGothic"><b> </b></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">shows
    DIBVIEW in action. Not bad for a few hours work, huh?</font></p>
    <p><img src="mfc5.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
5 DIBVIEW</b></font></p>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>CDib
Redux</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As soon as I got DIBVIEW up
    and running&#151;not a nanosecond later&#151;I raced over to
    Acme World Headquarters to present it to His Supremeness the
    Maximum Leader. He was not especially impressed, but after
    much cajoling I managed to persuade him to give me another 48
    hours to write the viewer.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Back in my programming cave, I
    decided to ignore all time pressures and reimplement CDib.
    Why? Because there was something about CDib that bothered me,
    something I knew would cause trouble down the road. Since a
    device-independent bitmap &quot;is a&quot; bitmap, CDib
    should be derived from CBitmap, not CObject.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CObject // base for all
    objects</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CBitmap //
    &quot;ordinary&quot; bitmap</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CDib // DIB</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">This isn&#146;t just a
    philosophical consideration; it has real implications. I
    should be able to use a CDib anywhere I can use a CBitmap. If
    SomeFunction takes a pointer to a CBitmap as an argument, I
    should be able to pass a CDib as well. Why not? To do this,
    CDib must be derived from CBitmap. So I froze my baby bitmap
    viewer as step one and began step two by altering the
    derivation of CDib.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">class CDib : public CBitmap {</font></p>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">};</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">What this means in practice is
    that I must somehow convert my DIB into an HBITMAP, since
    that&#146;s all CBitmap really is: a wrapper for HBITMAP. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">One way to do it is to call
    CreateDIBitmap, but Win32</font><font color="#000000"
    size="1" face="verdana,arial,helvetica">¨</font><font
    color="#000000" size="2" face="verdana,arial,helvetica"> has
    a handy new function that makes it almost trivial to load a
    DIB and create an HBITMAP handle to it.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// revised load function</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL CDib::Load(LPCTSTR
    lpszPath)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return
    Attach(::LoadImage(NULL, lpszPath,IMAGE_BITMAP,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">0, 0, LR_LOADFROMFILE |</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">LR_CREATEDIBSECTION |
    LR_DEFAULTSIZE));</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">LoadImage is a multipurpose
    Win32 API function that loads icons, cursors, and bitmaps.
    There are all sorts of different ways you can use LoadImage
    (see the Win32 documentation); for CDib, I use IMAGE_BITMAP
    to tell LoadImage to load a bitmap, not an icon or cursor,
    and LR_LOADFROMFILE to load it from a file instead of a
    resource. The width and height are zero because I&#146;m
    using LR_DEFAULTSIZE to load the bitmap in its normal size,
    and LR_CREATEDIBSECTION tells LoadImage to load the bitmap as
    a DIB. Without LR_CREATEDIBSECTION, LoadImage would map my
    bitmap&#146;s colors to match the current display device.
    That can be handy sometimes, but definitely not for CDib.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Assuming it can read the file,
    LoadImage returns a handle to the bitmap (HBITMAP). What
    could be easier? CDib::Load passes this handle to Attach
    (actually CGdiObject::Attach) the same way you can call
    CWnd::Attach to manually attach an HWND to a CWnd object.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">That&#146;s
    it&#151;that&#146;s all there is! Now my CDib is a bonafide
    CBitmap, all hooked up with a real HBITMAP and everything.
    One major benefit of using LoadImage instead of loading the
    DIB myself is that now I don&#146;t have to worry about those
    pre-Windows 3.0 bitmaps. LoadImage can handle it. Not to
    mention that my Load function has gone from about thirty
    lines of code to about one. In fact, you&#146;re probably
    wondering, &quot;Why didn&#146;t you use LoadImage in the
    first place, you dimwit?&quot; That&#146;s only because you
    haven&#146;t seen what&#146;s required to draw the DIB yet!</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">You&#146;d think that after
    all these years, with bitmaps as ubiquitous as they are in
    Windows, there&#146;d be a function somewhere to just draw a
    lousy bitmap on the screen. But no, you have to go through
    minor conniptions to do it. First, you create a memory device
    context compatible with the display, then you select the
    bitmap into the memory device context, then you call BitBlt
    to copy the bits to the target device context. In C++, it
    looks like this:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL DrawBitmap(CDC&amp; dc,
    CBitmap* pbm)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CDC mdc; // memory DC</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">mdc.CreateCompatibleDC(&amp;dc);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CBitmap* pOld =
    mdc.SelectObject(pbm);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL bRet = dc.BitBlt(...);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">mdc.SelectObject(pOld);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return bRet;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I left out the args to BitBlt
    because there&#146;s a ton of them, mostly coordinates. If
    stretching is required, you use StretchBlt instead of BitBlt.
    It&#146;s not back-breaking, but it is several lines of code.
    Even that isn&#146;t enough; DrawBitmap as I&#146;ve shown it
    works for ordinary CBitmap objects, but fails for DIBs. Why?
    Because to draw a DIB, you must first select, then realize,
    its palette. This is what makes a DIB a DIB&#151;that is,
    device independent. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">A DIB specifies true RGB
    values, either directly or through a palette. If you
    implemented your draw function as above, </font><font
    color="#000000" size="1" face="verdana,arial,helvetica">Figure
    6</font><font color="#000000" size="2"
    face="verdana,arial,helvetica"> is what you&#146;d get. Not
    the sort of thing to show Maximum Leader. With no palette,
    Windows draws the bitmap using the 20 standard system
    colors&#151;red, green, cyan, magenta, and so on. To get the
    DIB&#146;s true colors, you must select its palette.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">mfc6.bmp</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">Figure
6 Palette-free DIBVIEW</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL CDib::Draw(CDC&amp; dc)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CPalette* pPal = ?</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CPalette* pOldPal = </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">dc.SelectPalette(pPal,FALSE);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">dc.RealizePalette();</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL bRet = DrawBitmap(dc,
    this); // as before</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">dc.SelectPalette(pOldPal,
    TRUE);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return bRet;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">First you select, then
    &quot;realize,&quot; the palette before drawing the bitmap
    using the DrawBitmap function I just showed you. But this
    still isn&#146;t the end of the story because, as you may
    have noticed, I didn&#146;t tell you where to get the
    palette. In fact, this turns out to be quite a mystery.
    Nowhere in the Windows API will you find a function to get a
    bitmap&#146;s palette. It&#146;s true. You have to create the
    palette manually by copying the DIB&#146;s entire color table
    into a special LOGPALETTE (logical palette) structure, then
    calling CreatePalette with this structure. You even have to
    take into account whether the bitmap uses the older RGBTRIPLE
    (three bytes) or newer RGBQUAD (four bytes) to hold the color
    values. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Win32 has a new function,
    GetDIBColorTable, that gives you the colors, always in
    RGBQUAD format. You still have to copy them into your
    LOGPALETTE. There&#146;s just one catch. Before you can call
    GetDIBColorTable, you must have the bitmap selected in a
    device context somewhere, so once again you have to create a
    memory DC. In summary, here&#146;s what you have to do to get
    the DIB&#146;s palette.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Create memory DC</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Select bitmap into it</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Allocate array of
    RGBQUAD</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Call GetDIBColorTable
    to fill array</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Allocate LOGPALETTE
    array </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Copy each RGBQUAD entry
    to LOGPALETTE</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Call CreatePalette with
    LOGPALETTE</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Delete RGBQUAD array</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&#149; Delete LOGPALETTE
    struct</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I implemented all this in a
    new function, CDib::CreatePalette, which creates the palette
    in a new data member, m_pal. I also overrode the Attach
    function to create the palette whenever one of my Load
    functions attaches a new HBITMAP to the CDib object. Now that
    I finally have the palette, I can select it and draw the
    bitmap. Whew!</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">There&#146;s just one more
    little trick I didn&#146;t tell you about. Doing the
    RGBQUAD/LOGPALETTE schtick works fine for bitmaps that have
    color tables (palettes)&#151;but what about hi-color bitmaps
    with 24 or 32 color bits? Those DIBs don&#146;t have a color
    table. Instead, each pixel has a full RGB value,
    GetDIBColorTable returns zero as the number of entries in the
    color table, and there&#146;s no palette. So what&#146;re you
    going to do? You still need a palette&#151;you saw what
    happens without one in </font><font color="#000000" size="1"
    face="verdana,arial,helvetica">Figure 6</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">. You
    could analyze the bitmap and select the best 256 colors but,
    sheesh, that&#146;s ridiculous&#151;and I&#146;ve only got 40
    hours left! Do the folks in Redmond really expect me to write
    a zillion lines of code just to compute a palette?</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">No, you only have to write one
    line. You can create something called a halftone palette,
    which is essentially just a palette with a broad range of
    colors in it that looks good for most <br>
    hi-color DIBs. So if CDib::CreatePalette encounters a DIB
    with no palette, it creates a halftone palette. </font><font
    color="#000000" size="1" face="verdana,arial,helvetica">Figure
    7</font><font color="#000000" size="2"
    face="verdana,arial,helvetica"> shows an example of a 24-bit
    color bitmap displayed using the system palette (yech!); </font><font
    color="#000000" size="1" face="verdana,arial,helvetica">Figure
    8</font><font color="#000000" size="1" face="FranklinGothic"><b>
    </b></font><font color="#000000" size="2"
    face="verdana,arial,helvetica">shows the same image displayed
    using a halftone palette. Thanks to Jeff Prosise for this
    wicked trick.</font></p>
    <p><img src="mfc7.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
7 256 colors, no palette selected</b></font></p>

<blockquote>
    <p><img src="mfc8.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
8 256 colors, halftone palette</b></font></p>

<blockquote>
    <p><img src="mfc9.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
9 256 colors, halftone palette, dithering</b></font></p>

<blockquote>
    <p><img src="mfc10.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
10 32-bit true color</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I&#146;ve written a lot of
    code, but now CDib is general enough to be useful. It has
    Load and Draw functions that handle all kinds of DIBs, and
    since it&#146;s derived from CBitmap (and implemented as
    one), you can use a CDib object anywhere you could use a
    CBitmap. As a fringe benefit, I exposed ::DrawBitmap, the
    function that draws an ordinary CBitmap, as a global extern
    function so you can use it to draw run-of-the-mill CBitmap
    bitmaps. In an ideal world, DrawBitmap would be a member
    function, CBitmap::Draw, not a global extern
    function&#151;but alas, the world is far from ideal and
    I&#146;m not about to modify the MFC source code.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Best
of Both Worlds</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As soon as I implemented my
    new, improved CDib class, I thought it would be interesting
    to compare it with my old DrawDib implementation. When I
    opened ordinary 256-color bitmaps, there was no noticeable
    difference, except I think the improved version is a little
    faster (I&#146;m not sure I can really tell; it may be
    wishful thinking). When I opened 24-bit images, however,
    there was an obvious difference. </font><font color="#000000"
    size="1" face="verdana,arial,helvetica">Figure 8</font><font
    color="#000000" size="1" face="FranklinGothic"><b> </b></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">shows
    a 24-bit color image displayed with my new improved CDib
    class; <b>Figure 9</b></font><font color="#000000" size="1"
    face="FranklinGothic"><b> </b></font><font color="#000000"
    size="2" face="verdana,arial,helvetica">shows the same image
    displayed with the old version that uses DrawDib (both with
    my display set at 256 color mode); and <b>Figure 10</b> shows
    the image displayed with true 32-bit color turned on.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">One thing my mama taught me is
    if you show a turned on client a program, and then you show
    him version two, the second version should be better, not
    worse. What&#146;s going on? Does DrawDib know something I
    don&#146;t?</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Yup. DrawDib does dithering.
    That&#146;s a graphics technique of mixing the pixels to make
    them look better, so you don&#146;t get the abrupt color
    transitions in </font><font color="#000000" size="1"
    face="verdana,arial,helvetica">Figure 8</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">.
    Windows 95 uses dithering to turn every other pixel grey when
    you shut down. You can still see the desktop, but it looks
    darkened. Color dithering is similar, but you dither the
    pixels with their neighbors instead of a fixed color like
    grey. It&#146;s a lot of work, but DrawDib does it. So the
    problem in a nutshell is that while my new CDib class is
    better from a programming perspective (because it derives
    from CBitmap), the old version looks better with hi-color
    images (because it uses DrawDib, which does dithering).
    Isn&#146;t there some way I can have my cake and eat it too?</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
11&nbsp; DIBVIEW3</b></font></p>

<p><font color="#000000" size="1" face="Courier New">Debug.cpp</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////////////////////////////////////////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Copyright 1996 Microsoft Systems Journal. </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If this program works, it was written by Paul DiLascia.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If not, I don't know who wrote it.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
General purpose debugging utilities</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;StdAfx.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;Debug.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;afxpriv.h&gt; // for MFC WM_ messages</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifdef
_DEBUG</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
new DEBUG_NEW</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#undef
THIS_FILE</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">static
char THIS_FILE[] = __FILE__;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
CTraceFn::nIndent=-1; // current indent level</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
_countof(array) (sizeof(array)/sizeof(array[0]))</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
These functions are copied from dumpout.cpp in the MFC source,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
with my modification to do indented TRACEing</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
AFXAPI AfxDump(const CObject* pOb)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">afxDump
&lt;&lt; pOb;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
AFX_CDECL AfxTrace(LPCTSTR lpszFormat, ...)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifdef
_DEBUG // all AfxTrace output is controlled by afxTraceEnabled</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!afxTraceEnabled)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">va_list
args;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">va_start(args,
lpszFormat);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
nBuf;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">TCHAR
szBuffer[512];</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">nBuf
= _vstprintf(szBuffer, lpszFormat, args);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ASSERT(nBuf
&lt; _countof(szBuffer));</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
PD: Here are my added lines to do the indenting. Search</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
for newlines and insert prefix before each one. Yawn.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">static
BOOL bStartNewLine = TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char*
nextline;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">for
(char* start = szBuffer; *start; start=nextline+1) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(bStartNewLine) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
((afxTraceFlags &amp; traceMultiApp) &amp;&amp; (AfxGetApp() !=
NULL))</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">afxDump
&lt;&lt; AfxGetApp()-&gt;m_pszExeName &lt;&lt; &quot;: &quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">afxDump
&lt;&lt; CString(' ',CTraceFn::nIndent);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">bStartNewLine
= FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">nextline
= strchr(start, '\n');</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(nextline) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">*nextline
= 0; // terminate string at newline</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">bStartNewLine
= TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">afxDump
&lt;&lt; start;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!nextline)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">break;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">afxDump
&lt;&lt; &quot;\n&quot;; // the one I terminated</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">va_end(args);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get window name in the form classname[HWND,title]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Searches all the parents for a window with a title.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CString
sDbgName(CWnd* pWnd)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CString
sTitle;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">HWND
hwnd = pWnd-&gt;GetSafeHwnd();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(hwnd==NULL)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">sTitle
= &quot;NULL&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
if (!::IsWindow(hwnd))</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">sTitle
= &quot;[bad window]&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">sTitle
= &quot;[no title]&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">for
(CWnd* pw = pWnd; pw; pw = pw-&gt;GetParent()) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(pw-&gt;GetWindowTextLength() &gt; 0) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pw-&gt;GetWindowText(sTitle);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">break;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CString
s;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">s.Format(&quot;%s[0x%04x,\&quot;%s\&quot;]&quot;,
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pWnd
? pWnd-&gt;GetRuntimeClass()-&gt;m_lpszClassName :
&quot;NULL&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">hwnd,
(LPCTSTR)sTitle);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
s;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">struct
{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">UINT
msg;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LPCTSTR
name;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}
MsgData[] = {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
WM_CREATE,_T(&quot;WM_CREATE&quot;) },</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
WM_DESTROY,_T(&quot;WM_DESTROY&quot;) },</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
WM_MOVE,_T(&quot;WM_MOVE&quot;) },</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
WM_SIZE,_T(&quot;WM_SIZE&quot;) },</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">.
// (about 220 messages)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
WM_OCC_LOADFROMSTREAM,_T(&quot;*WM_OCC_LOADFROMSTREAM&quot;) },</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
WM_OCC_LOADFROMSTORAGE,_T(&quot;*WM_OCC_LOADFROMSTORAGE&quot;) },</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
WM_OCC_INITNEW,_T(&quot;*WM_OCC_INITNEW&quot;) },</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
WM_QUEUE_SENTINEL,_T(&quot;*WM_QUEUE_SENTINEL&quot;) },</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
0,NULL }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
This class is basically just an array of 1024 strings,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
the names of each WM_ message. Constructor initializes it.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">class
CWndMsgMap {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">static
LPCTSTR Names[]; // array of WM_ message names</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">public:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CWndMsgMap();
// constructor initializes them</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CString
GetMsgName(UINT msg); // get name of message</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LPCTSTR
CWndMsgMap::Names[WM_USER]; // name of each WM_ message</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Initialize array from sparse data</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CWndMsgMap::CWndMsgMap()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
copy sparse MsgData into table</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">memset(Names,
0, sizeof(Names));</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">for
(int i=0; MsgData[i].msg; i++) </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">Names[MsgData[i].msg]
= MsgData[i].name;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get the name of a WM_ message</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CString
CWndMsgMap::GetMsgName(UINT msg)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CString
name;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(msg&gt;=WM_USER)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">name.Format(&quot;WM_USER+%d&quot;,
msg-WM_USER);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
if (Names[msg])</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">name
= Names[msg];</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">name.Format(&quot;0x%04x&quot;,
msg);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
name;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get name of WM_ message.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CString
sDbgName(UINT uMsg)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">static
CWndMsgMap wndMsgMap; // instantiate 1st time called</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
wndMsgMap.GetMsgName(uMsg);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif
// DEBUG</font></p>

<blockquote>
    <p><font color="#000000" size="1" face="Courier New">Dib.cpp</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////////////////////////////////////////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
1996 Microsoft Systems Journal. </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If this program works, it was written by Paul DiLascia.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If not, I don't know who wrote it.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
CDib - Device Independent Bitmap.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
This implementation draws bitmaps using normal Win32 API
functions,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
not DrawDib. CDib is derived from CBitmap, so you can use it with</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
any other MFC functions that use bitmaps.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;StdAfx.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;Dib.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifdef
_DEBUG</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
new DEBUG_NEW</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#undef
THIS_FILE</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">static
char THIS_FILE[] = __FILE__;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">IMPLEMENT_DYNAMIC(CDib,
CObject)</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDib::CDib()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">memset(&amp;m_bm,
0, sizeof(m_bm));</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_hdd
= NULL;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDib::~CDib()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DeleteObject();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Delete Object. Delete DIB and palette.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
CDib::DeleteObject()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pal.DeleteObject();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(m_hdd) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DrawDibClose(m_hdd);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_hdd
= NULL;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">memset(&amp;m_bm,
0, sizeof(m_bm));</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
CBitmap::DeleteObject();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Read DIB from file.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
CDib::Load(LPCTSTR lpszPathName)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
Attach(::LoadImage(NULL, lpszPathName, IMAGE_BITMAP, 0, 0,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LR_LOADFROMFILE
| LR_CREATEDIBSECTION | LR_DEFAULTSIZE));</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Load bitmap resource. Never tested.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
CDib::Load(HINSTANCE hInst, LPCTSTR lpResourceName)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
Attach(::LoadImage(hInst, lpResourceName, IMAGE_BITMAP, 0, 0,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LR_CREATEDIBSECTION
| LR_DEFAULTSIZE));</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Attach is just like the CGdiObject version,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
except it also creates the palette</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
CDib::Attach(HGDIOBJ hbm)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(CBitmap::Attach(hbm)) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!GetBitmap(&amp;m_bm)) // load BITMAP for speed</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_pal.DeleteObject();
// in case one is already there</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
CreatePalette(m_pal); // create palette</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE; </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get size (width, height) of bitmap.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
extern fn works for ordinary CBitmap objects.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CSize
GetBitmapSize(CBitmap* pBitmap)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BITMAP
bm;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pBitmap-&gt;GetBitmap(&amp;bm) ?</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CSize(bm.bmWidth,
bm.bmHeight) : CSize(0,0);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
You can use this static function to draw ordinary</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
CBitmaps as well as CDibs</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
DrawBitmap(CDC&amp; dc, CBitmap* pBitmap,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">const
CRect* rcDst, const CRect* rcSrc)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Compute rectangles where NULL specified</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CRect
rc;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!rcSrc) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
if no source rect, use whole bitmap</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rc
= CRect(CPoint(0,0), GetBitmapSize(pBitmap));</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcSrc
= &amp;rc;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!rcDst) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
if no destination rect, use source</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcDst=rcSrc;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Create memory DC</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDC
memdc;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">memdc.CreateCompatibleDC(&amp;dc);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CBitmap*
pOldBm = memdc.SelectObject(pBitmap);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Blast bits from memory DC to target DC.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Use StretchBlt if size is different.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
bRet = FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(rcDst-&gt;Size()==rcSrc-&gt;Size()) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">bRet
= dc.BitBlt(rcDst-&gt;left, rcDst-&gt;top,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcDst-&gt;Width(),
rcDst-&gt;Height(),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;memdc,
rcSrc-&gt;left, rcSrc-&gt;top, SRCCOPY);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}
else {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dc.SetStretchBltMode(COLORONCOLOR);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">bRet
= dc.StretchBlt(rcDst-&gt;left, rcDst-&gt;top, rcDst-&gt;Width(),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcDst-&gt;Height(),
&amp;memdc, rcSrc-&gt;left, rcSrc-&gt;top, rcSrc-&gt;Width(),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcSrc-&gt;Height(),
SRCCOPY);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">memdc.SelectObject(pOldBm);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
bRet;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">////////////////////////////////////////////////////////////////</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Draw DIB on caller's DC. Does stretching from source to
destination</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
rectangles. Generally, you can let the following default to
zero/NULL:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
bDither = whether to dither (uses DrawDib), default FALSE</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
pPal = palette, default=NULL, (use DIB's palette)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
bForeground = realize in foreground (default FALSE)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If you are handling palette messages, you should use
bForeground=FALSE to</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
draw, since you will realize the foreground palette in
WM_QUERYNEWPALETTE.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
CDib::Draw(CDC&amp; dc, const CRect* rcDst, const CRect* rcSrc,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
bDither, CPalette* pPal, BOOL bForeground)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!m_hObject)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
bRet = FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Select, realize palette</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(pPal==NULL) // no palette specified:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pPal
= GetPalette(); // use default</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CPalette*
pOldPal = dc.SelectPalette(pPal, !bForeground);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dc.RealizePalette();</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Only use DrawDib to dither if more than 8-bit color</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(bDither &amp;&amp; m_bm.bmBitsPixel&gt;8) {</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Compute rectangles where NULL specified</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CRect
rc;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!rcSrc) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
if no source rect, use whole bitmap</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rc.SetRect(0,
0, m_bm.bmWidth, m_bm.bmHeight);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcSrc
= &amp;rc;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!rcDst) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
if no destination rect, use source</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcDst=rcSrc;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DIBSECTION
ds;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">VERIFY(GetObject(sizeof(ds),
&amp;ds)==sizeof(ds));</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(!m_hdd)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">VERIFY(m_hdd
= DrawDibOpen());</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">bRet
= DrawDibDraw(m_hdd, dc,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcDst-&gt;left,
rcDst-&gt;top, rcDst-&gt;Width(), rcDst-&gt;Height(),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;ds.dsBmih,
// ptr to BITMAPINFOHEADER</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">m_bm.bmBits,
// bits in memory</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">rcSrc-&gt;left,
rcSrc-&gt;top, rcSrc-&gt;Width(), rcSrc-&gt;Height(),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">bForeground
? 0 : DDF_BACKGROUNDPAL);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}
else {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
use normal draw function</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Yes. In the final version of
    CDib (files Dib.h and Dib.cpp in <b>Figure 11</b>), I added a
    bunch of extra arguments to CDib::Draw. (For example, you can
    pass a palette to use instead of the one that comes with the
    bitmap, in case you want to do weird palette effects, and you
    can tell CDib::Draw whether to draw in the foreground or
    background.) One of the new arguments is bUseDrawDib. If you
    specify TRUE (the default), CDib draws the old way, using
    DrawDib; if not, it uses BitBlt or StretchBlt. Good thing I
    saved the old code! I had to write a few lines to get the
    BITMAPINFOHEADER and color table for DrawDibDraw since the
    CBitmap implementation no longer has the DIB in memory.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DIBSECTION ds;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">GetObject(sizeof(ds),
    &amp;ds);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">char
    buf[sizeof(BITMAPINFOHEADER) + MAXPALCOLORS*sizeof(RGBQUAD)];</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BITMAPINFOHEADER&amp; bmih =
    *(BITMAPINFOHEADER*)buf;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">RGBQUAD* colors =
    (RGBQUAD*)(&amp;bmih+1); </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">memcpy(&amp;bmih,
    &amp;ds.dsBmih, sizeof(bmih));</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">GetColorTable(colors,
    MAXPALCOLORS);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The first time I wrote this, I
    allocated the combined BITMAPINFOHEADER/color table from the
    heap instead of the stack, and only the first time it was
    needed, because I thought it would slow things down to copy
    on every Draw. But when I tried it as above there was no
    perceptible performance hit, which is not that surprising
    when you think of how many bits get copied all over the place
    to draw a DIB. What&#146;s an extra kilobyte among friends?
    So I kept the stack implementation to save memory. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I made bUseDrawDib an argument
    instead of always using DrawDib because some images may look
    better without dithering and because dithering takes longer.
    Not noticeable on the screen, but definitely so for printing
    (more on this in Part II). I even propagated the bUseDrawDib
    flag up to the user interface as a new unrequested DIBVIEW
    feature: a View Dither command to let the user choose whether
    to dither or not. </font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Palette
Problems in Paradise</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">By now things were really
    rolling. The improved CDib took a couple of days, leaving me
    with only one hour to implement all the other features and
    convert the thing into a file viewer COM object. Sensing that
    was unlikely, I showed Mr. Maximum Leader my latest DIBVIEW
    with the dithering feature and told him it was a
    super-sophisticated graphics technique that would catapult
    Acme Corp far beyond the competition. He was skeptical at
    first, but agreed reluctantly to give me another couple of
    days to write the viewer.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Back in my cave, with time
    pressure removed, I took a few minutes to smell the roses.
    That is, gaze at some pretty bitmaps with my new viewer.
    Well, wouldn&#146;t you know it, just when I was feeling
    proud of myself for being so clever and productive, I
    discovered a slight problem. Well, er, OK, so it wasn&#146;t
    a slight problem, it was a major bug. <b>Figure 12</b></font><font
    color="#000000" size="1" face="FranklinGothic"><b> </b></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">shows
    what happened when I ran two instances of DIBVIEW with two
    different DIBs. Gak! Good thing Mr. Maximum Leader
    didn&#146;t see that! What&#146;s going on? Why the
    psychedelic snowsurfer?</font></p>
    <p><img src="mfc12.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
12 Two DIBVIEWs; two DIBs</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The bug has to do with
    palettes. To produce it, I set my desktop display properties
    to 8-bit color mode, which means my system has a maximum of
    256 colors it can display at any given time. Which particular
    256 colors those are, out of the total possible of 224 = 16M
    colors that can be expressed with 8-bit RGB values, is called
    the current physical palette or system palette. (Actually,
    you only get 236 colors to play with because 20 colors are
    fixed for the basic colors like black and red&#151;see </font><font
    color="#000000" size="1" face="verdana,arial,helvetica">Figure
    13</font><font color="#000000" size="1" face="FranklinGothic"><b>.</b></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">) The
    psychedelic look comes from the fact that my snowsurfer has
    one idea about which 256 colors are in the system palette,
    while the Les Paul guitar has another. Whichever window has
    the focus wins. As for the loser, well, its color indexes end
    up pointing at who knows which colors in the system palette.
    The surfer window might think, for instance, that the 134th
    color in its palette is RGB(12,34,104) when in fact the
    guitar window has changed it to something completely
    different like RGB(205,0,19). When every color in surf.dib
    gets randomly mapped this way, the result is the brain salad
    palette in <b>Figure 12</b>.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;13&nbsp;Reserved
Palette Indexes</b></font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">Static
colors unaltered by palette changes. These are guaranteed to be
there forever.</font></p>

<p><font color="#000000" size="1" face="Courier New">INDEX RED
GREEN BLUE COLOR</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">0
0 0 0 black</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">1
128 0 0 dark red</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">2
0 128 0 dark green</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">3
128 128 0 dark yellow</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">4
0 0 128 dark blue</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">5
128 0 128 dark magenta</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">6
0 128 128 dark cyan</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">7
192 192 192 light gray</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">8
192 220 192 money green</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">9
166 202 240 sky blue</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">246
255 251 240 cream</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">247
160 160 164 light gray</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">248
128 128 128 medium gray</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">249
255 0 0 red</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">250
0 255 0 green</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">251
255 255 0 yellow</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">252
0 0 255 blue</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">253
255 0 255 magenta</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">254
0 255 255 cyan</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">255
255 255 255 white</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Now, everyone knows the ideal
    way to solve this problem. Just examine the system color
    resolution when your program starts up and, if it&#146;s
    anything less than 24 bits, display a message box that says
    &quot;CHEAPSKATE!&quot; I mean, it&#146;s 1997. Anyone who
    can&#146;t afford a display card with enough memory to handle
    hi-res color doesn&#146;t deserve to look at DIBs anyway.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Well, OK, so that&#146;s not
    an option. But you should understand that this whole business
    with palettes&#151;in fact, the very existence of
    palettes&#151;is only a hack invented long ago to overcome
    feeble display cards. When you run in 24-bit or higher color
    modes, the palette problem disappears (as does the need for
    halftone palettes). Every window can have all the colors its
    little heart desires. Some day after the millennium, when the
    last 8-bit color card gets tossed into the nearest cosmic
    incinerator, the Friendly Redmondtonians will quietly pull
    the plug on palettes by turning all the palette functions in
    Windows 2000 into no-ops&#151;just like they did with all the
    memory locking functions when 16-bit pointers bit the dust.
    Until then, you have to learn to realize your palettes in the
    background.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Since this is an article about
    building reusable goodies, not palette internals, I
    won&#146;t go into all the nitty-gritties of logical and
    physical palettes, but concentrate on fixing the problem.
    (For more info, see &quot;The Palette Manager: How and
    Why&quot; on MSDN.) The gist of it is that while many windows
    can each use different logical palettes, there&#146;s only
    one physical palette for the whole system at any given time. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">You may have noticed a little
    Boolean argument I glossed over when I showed you how to
    select the palette.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">dc.SelectPalette(pMyPal,
    FALSE);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">dc.RealizePalette();</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">That FALSE tells Windows not
    to realize the palette in the background; in other words,
    realize it in the foreground. When you realize a palette in
    the foreground, Windows changes the system palette so it
    contains the colors in your logical palette. Of course, that
    throws all the other windows out of whack because now their
    logical palettes are no longer realized. To avoid the Timothy
    Leary look, inactive windows must realize their palettes in
    the background, which they do by calling RealizePalette with
    TRUE instead of FALSE. Now Windows does something totally
    different; instead of altering the system palette, Windows
    remaps the logical palette to use colors already in the
    system palette, in the best possible way. For example, if a
    pixel in surf.dib wants to be a particular shade of blue that
    doesn&#146;t exist in the system palette, Windows will find
    the closest shade of blue it can, and use that instead.
    It&#146;s not perfect, but it&#146;s a lot better than some
    random hue in the spectrum. <b>Figures 14 </b>and<b> 15</b>
    show what two DIBs each look like with their palettes
    realized in the foreground and background.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">So the basic idea is to
    realize your palette in the foreground when your window has
    focus, and in the background when it doesn&#146;t. What could
    be simpler? Alas, as with all things in Windows, the details
    may make you crave some Advil.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To give apps a chance to
    realize their palettes at the right time, Windows broadcasts
    two messages to all top-level windows. Windows sends
    WM_QUERYNEWPALETTE to your main frame window as it&#146;s
    about to activate your app. This is your big chance in life
    to realize your foreground palette. When you do (by calling
    Select/RealizePalette), Windows is likely to change some of
    the colors in the system palette. If so, Windows immediately
    broadcasts the other message, WM_PALETTECHANGED, to all
    top-level windows. This gives inactive apps a chance to
    rerealize their palettes in the background and repaint
    themselves using the new palette&#151;thus avoiding the Leary
    look. Most apps ignore WM_QUERYNEWPALETTE and
    WM_PALETTECHANGED since most apps don&#146;t use palettes.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Armed with this new
    information, I set out to fix the palette bug. Once again, I
    froze DIBVIEW, called it step two and began work on step
    three. That way if I broke anything (as I am prone to do), I
    could always go back. The first thing I did was add a couple
    of message handlers, CMainFrame::OnQueryNewPalette and
    OnPaletteChanged. To get started, I copied some lines from
    DIBLOOK (OK, I admit it) and hacked them to fit my program. </font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Debugging
Detour</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Naturally, the first time I
    ran my palette code, it failed. Sigh. To find out why, I
    needed a picture of what messages my app was getting when.
    Spy++ is too cumbersome; all I really needed was a few
    diagnostic messages. So I sprinkled my code with TRACE macros
    and ran it again. As the barrage of messages flooded my
    screen, I realized this was no good; what I really needed to
    unravel all the palette pandemonium was some way to indent
    the messages to show the call stack. This may seem obsessive,
    but proper formatting goes a long way toward making text more
    readable. Besides, I&#146;m an obsessive kind of guy.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">There are several possible
    approaches to indenting debug output, but the quickest I
    could think of was to modify the MFC function ::AfxTrace,
    which is what all the TRACE macros call. The MFC developers
    were kind enough to put AfxTrace in its own file,
    dumpout.cpp, with only one other function, AfxDump (whose
    implementation is trivial), so all I had to do was copy the
    functions into my own debug module, debug.cpp (shown in <b>Figure
    11</b>), and modify AfxTrace. My modified version formats the
    output string as before, but before it ships the string to
    the display, it scans it for newlines (\n) and inserts <i>n</i>
    spaces after each newline, where <i>n</i> is the current
    indent level, stored as a static global in a little class I
    invented.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">class CTraceFn : public CFile
    {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">private:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">static int nIndent; // current
    indent</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">friend void AfxTrace(LPCTSTR
    lpszFormat, ...);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">public:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CTraceFn() { nIndent++; }</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">~CTraceFn() { nIndent&#151;; }</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">};</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I declared AfxTrace a friend
    of CTraceFn so AfxTrace can look at nIndent, which is
    private. The CTraceFn constructor increments the indent
    level; the destructor decrements it. The idea is that you
    instantiate one of these little doodads at the top of each
    function you want to TRACE. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To make using CTraceFn really
    easy and look more familiar, I defined a macro:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#define TRACEFN CTraceFn
    __fooble; TRACE</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Now whenever I want to trace
    the action in a group of functions, all I have to do is add a
    TRACEFN statement at the top of each one.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">void SomeFunction()</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACEFN(&quot;SomeFunction\n&quot;);</font></p>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The macro expands to:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CTraceFn __fooble;
    TRACE(&quot;SomeFunction\n&quot;);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">That is, TRACEFN instantiates
    an instance of CTraceFn as an automatic variable __fooble,
    then expands whatever follows using TRACE. The constructor
    for __fooble bumps the indent level so the string
    &quot;SomeFunction&quot; appears indented in the debug
    output, as do all subsequent TRACE messages, until control
    flows out of SomeFunction and C++ calls the destructor for
    __fooble, which unbumps the indent level. If SomeFunction
    calls SomeOtherFunction that also has a TRACEFN statement,
    the output is indented twice. Pretty neat. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACEFN is simple, easy, and
    it makes diagnostic messages much more readable, as the
    before and after shots in <b>Figures 16 </b>and <b>17 </b>show.
    There&#146;s just one catch: You can&#146;t use TRACEFN in
    one-line if statements because it generates two C statements.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (bletch)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACEFN(...);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">expands to</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (bletch)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">__fooble; TRACE(...);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">which is equivalent to</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (bletch)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">__fooble;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACE(...);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">which is probably not what you
    want. The solution is to always put TRACEFN in curly
    brackets.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (bletch) {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACEFN(...);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">While I&#146;m on the subject
    of debugging, let me tell you about another debugging goodie
    I implemented: sDbgName. This function returns a friendly
    name for a CWnd object as a CString. If you write</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACE(&quot;Window is
    %s\n&quot;, (LPCTSTR)sDbgName(pMyWnd));</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">you&#146;ll get something like</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Window is
    CDIBView[0x0cc4,&quot;surf.dib&quot;]</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">sDbgName generates a string in
    the form <i>classname</i> [<i>hwnd, &quot;title&quot;</i>].
    sDbgName gets the class name from the object&#146;s runtime
    class; to get the title, it calls GetWindowText. If the
    window has no title (views typically don&#146;t), sDbgName
    looks at the parent and all other parents until it finds one
    with a title&#151;that is, one for which GetWindowText
    returns a nonempty string. To avoid casting sDbgName to
    LPCTSTR every time I use it, I wrote another macro:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#define DbgName(x)
    (LPCTSTR)sDbgName(x)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Normally, you can pass CString
    anywhere const char* is expected without casting since the
    compiler automatically calls CString&#146;s conversion
    operator for you. But printf, AfxTrace, and CString::Format
    all have the &quot;...&quot; variable-number-of-arguments
    declaration, for which the compiler does no conversions since
    it has no type information. To pass a CString to printf,
    TRACE, or CString::Format, you must explicitly cast it to
    LPCTSTR or you&#146;ll get garbage output.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Since I sometimes find it
    useful to display the names of WM_<i>XXX</i> messages, I also
    wrote an overloaded sDbgName(UINT) that does just that. So
    instead of wondering what 0x0007 means in my diagnostic
    stream, I&#146;ll see WM_SETFOCUS. sDbgName(UINT) knows about
    private MFC messages like WM_IDLEUPDATECMDUI and
    WM_INITIALUPDATE, and displays them with an asterisk as in
    *WM_INITIALUPDATE. It displays messages beyond WM_USER in the
    form WM_USER+n. The HOOK program described later uses
    sDbgName(UINT) to spy on itself. Note that by using the same
    overloaded name (sDbgName) instead of using different names
    like DbgNameWnd and DbgNameMsg, my DbgName macro still works.</font></p>
    <p><img src="mfc14.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
14 Virgil&#146;s palette realized in background</b></font></p>

<blockquote>
    <p><img src="mfc15.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
15 Surfer&#146;s palette realized in background</b></font></p>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>To
MDI or Not to MDI?</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Before getting back to
    palettes, I have to tell you about another little problem I
    ran into in step three. I mentioned earlier that I
    implemented DIBVIEW as an SDI app because my ultimate aim was
    to write a file viewer and file viewers are SDI apps. But I
    figured it would be nice to have a standalone viewer that
    supported MDI. I know from experience that palette handling
    is slightly more complex in an MDI app and I wanted to solve
    the palette problem generally, in a way that would work for
    MDI as well as SDI apps. So the next thing I did in step
    three was expand DIBVIEW to a MDI app. In order to preserve
    the SDI version and still have a single code base, I used
    #ifdef statements with a #define symbol, _MDI, to control the
    compilation. This worked well since there are surprisingly
    few places where differences between SDI and MDI apps show up
    in the source. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#ifdef _MDI</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#define CBaseFrameWnd
    CMDIFrameWnd</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#else</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#define CBaseFrameWnd
    CFrameWnd</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#endif</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">class CMainFrame : public
    CBaseFrameWnd {</font></p>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Also, the document templates
    are different and the startup code in CApp::InitInstance is
    slightly different too. No big deal, #ifdef took care of it. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Things were a little more
    troublesome when I got to the resource file. I tried to use
    the same _MDI symbol with conditional #ifdefs to build
    different menus, strings, and other resources for
    IDR_MAINFRAME. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">IDR_MAINFRAMEMDI MENU PRELOAD
    DISCARDABLE </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BEGIN</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#ifdef _MDI</font></p>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#else</font></p>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#endif</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">END</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">This worked fine as far as the
    resource compiler was concerned, but when I edited my
    resources with App Studio, Visual C++¨ stripped all my
    #ifdefs&#151;without even telling me! Whichever block in the
    #ifdef clause was not active when I opened the RC file got
    totally trashed! App Studio just threw it away as if it never
    existed! Boy, that&#146;s what I call unfriendly. So consider
    this a warning: be careful using #ifdef in resource files
    edited with Developer/App Studio! Lucky for me, I had backups
    (I don&#146;t trust anybody).</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To work around Visual C++, I
    put all the versions of all the resources in my resource file
    using two different IDs, IDR_MAINFRAMESDI and
    IDR_MAINFRAMEMDI.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">IDR_MAINFRAMEMDI MENU PRELOAD
    DISCARDABLE </font></p>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">END</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">IDR_MAINFRAMESDI MENU PRELOAD
    DISCARDABLE </font></p>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">END</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I did the same for all the
    other resources so that my resource file has no conditional
    compile flags. Then, in DibView.h, I select which one to use
    as follows:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#ifdef _MDI</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#define IDR_MAINFRAME
    IDR_MAINFRAMEMDI</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#else</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#define IDR_MAINFRAME
    IDR_MAINFRAMESDI</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">#endif</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The only drawback is this
    wastes space since each version of DIBVIEW&#151;SDI and
    MDI&#151;contains all the other version&#146;s resources as
    well as its own. </font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Back
to Regularly Scheduled Palette Programming</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Armed with debugging tools and
    a dual-GUI app, let&#146;s return to the palette problem.
    While you were reading about TRACEFN, DbgName, and MDI, I was
    busy hacking DIBVIEW. I added OnQueryNewPalette and
    OnPaletteChanged handlers with TRACEFN macros to show
    what&#146;s going on (see MainFrm.cpp in </font><font
    color="#000000" size="1" face="verdana,arial,helvetica">Figure
    11</font><font color="#000000" size="2"
    face="verdana,arial,helvetica">). I&#146;ll step you through
    the code in two different scenarios. If you consider yourself
    a palette guru, feel free to skip right along to the next
    section.</font></p>
    <p><img src="mfc16.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
16 TRACE output without indenting</b></font></p>

<blockquote>
    <p><img src="mfc17.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
17 TRACE output with indenting</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In the first scenario, DIBVIEW
    is running in an inactive state with two documents open when
    I click the mouse to activate it. The TRACE output in <b>Figure
    18</b></font><font color="#000000" size="1"
    face="FranklinGothic"><b> </b></font><font color="#000000"
    size="2" face="verdana,arial,helvetica">records the action,
    which begins when I click on the DIBVIEW main window. Windows
    sends my app WM_QUERYNEWPALETTE, which MFC routes to my
    CMainFrame handler.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL
    CMainFrame::OnQueryNewPalette() </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACEFN(&quot;CMainFrame::OnQueryNewPalette\n&quot;);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CView* pView = </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">GetActiveFrame()-&gt;GetActiveView();</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (pView)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">pView-&gt;SendMessage(WM_QUERYNEWPALETTE);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return FALSE;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Since the main frame itself
    doesn&#146;t draw anything&#151;only the views do the
    drawing&#151;CMainFrame delegates the message to the active
    view. Windows sends WM_QUERYNEWPALETTE to top-level windows
    only, but there&#146;s no reason you can&#146;t pass it along
    to your children. Note that CMDIFrameWnd::GetActiveFrame
    returns the active MDI child app, whereas
    CFrameWnd::GetActiveFrame returns &quot;this&quot;&#151;that
    is, the CFrameWnd itself&#151;so the above code works whether
    CMainFrame is derived from CMDIFrameWnd or CFrameWnd, whether
    my app is compiled for SDI or MDI. Either way, CMainFrame
    sends WM_QUERYNEWPALETTE to the active view. In this case,
    it&#146;s surf.dib. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Here&#146;s my CDIBView
    handler.</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL
    CDIBView::OnQueryNewPalette() </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACEFN(...);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return DoRealizePalette(TRUE);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">OnQueryNewPalette passes the
    buck to a helper function, DoRealizePalette, that does the
    work.</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">int
    CDIBView::DoRealizePalette(BOOL bForeground)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CClientDC dc = this;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CPalette* pPal =
    pDIB-&gt;GetPalette();</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CPalette* pOldPal =
    dc.SelectPalette(pPal, !bForeground);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">int nColorsChanged =
    dc.RealizePalette();</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (nColorsChanged &gt; 0)
    Invalidate(FALSE); // repaint</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">dc.SelectPalette(pOldPal,
    TRUE);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">return nColorsChanged;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DoRealizePalette gets the
    palette from the DIB and selects it in the foreground or
    background, depending on bForeground. In this case,
    bForeground is TRUE, so DoRealizePalette passes FALSE as the
    bForceBackground argument to SelectPalette. (It seems more
    natural to think of foreground as TRUE and background as
    FALSE, so I changed the sense of this flag.) </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">When DoRealizePalette calls
    dc.RealizePalette to finally realize the palette, Windows
    changes the system palette to match surf.dib&#146;s palette.
    As it turns out, Windows changes 235 colors in the system
    palette. But I don&#146;t know that yet because as soon as it
    does&#151;before returning from ::RealizePalette&#151;Windows
    immediately broadcasts WM_PALETTECHANGED to all top-level
    windows. Do not pass Go, do not collect $200. You can see
    this happening in <strong>Figure 18</strong><b>,</b> where
    control jumps from DoRealizePalette to
    CMainFrame::OnPaletteChanged, before DoRealizePalette returns
    or even gets a chance to record how many colors changed.
    (This is where the TRACEFN indenting helps reveal what&#146;s
    going on.) </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As usual, MFC routes the
    WM_PALETTECHANGED to my handler.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">void
    CMainFrame::OnPaletteChanged(CWnd* pFocusWnd)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACEFN(&quot;CMainFrame::OnPaletteChanged\n&quot;);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">const MSG&amp; msg = </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">AfxGetThreadState()-&gt;m_lastSentMsg;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">SendMessageToDescendants(WM_PALETTECHANGED,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">msg.wParam, msg.lParam);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CMainFrame broadcasts the
    message to all its children: &quot;Hey, everybody, wake up,
    the palette just changed!&quot; This time all the views get
    the message, not just the active view.</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">void
    CDIBView::OnPaletteChanged(CWnd* pFocusWnd)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACEFN(...);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (pFocusWnd!=this)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DoRealizePalette(FALSE);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">else</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACE0(&quot;[It&#146;s me,
    don&#146;t realize palette]\n&quot;);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The WPARAM argument of
    WM_PALETTECHANGED is the HWND of the window that changed the
    palette (in this case, surf.dib); MFC packages it as
    pFocusWnd. If the view is the same view that triggered the
    palette change in the first place (pFocusWnd == this), it
    ignores the message. After all, it&#146;s already realizing
    its palette in the foreground. In fact, right now it&#146;s
    in the middle of a call to ::RealizePalette, which is what
    triggered WM_PALETTECHANGED. Otherwise, if the view is not
    the view that changed the palette, it realizes its palette in
    the background by calling RealizePalette with FALSE. You can
    see all this happening in <b>Figure 18</b>: surf.dib reports
    &quot;It&#146;s me, don&#146;t realize palette,&quot; whereas
    virgil.dib realizes its palette in the background, which
    results in 220 colors being remapped. Not 220 colors changed
    in the system palette, but 220 colors in virgil.dib&#146;s
    palette remapped to close-but-not-perfect colors in
    surf.dib&#146;s palette. As a result, the virgil.dib view
    invalidates itself so Windows will repaint it. If there were
    more views, they too would realize their palettes in the
    background and invalidate themselves if colors were remapped.
    If the WM_PALETTECHANGED had come as a result of the user
    activating some other completely different app like DOOM,
    then all the views, including surf.dib (even though it&#146;s
    the active view within DIBVIEW), would realize their palettes
    in the background.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Once all the views have
    handled WM_PALETTECHANGED, control returns to
    CMainFrame::OnPaletteChanged and back through Windows, back
    to ::RealizePalette and CDIBView::DoRealizePalette, where
    surf.dib realized its palette in the foreground in response
    to the original WM_QUERYNEWPALETTE. The result of surf.dib
    realizing its palette in the foreground is that 235 colors
    changed in the system palette. The surf.dib view invalidates
    itself and returns control back to
    CMainFrame::OnQueryNewPalette. The end. Well, actually the
    end doesn&#146;t come until Windows gets around to painting
    all the invalidated windows, but it will.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The second scenario is
    simpler. Here, DIBVIEW is already active, with surf.dib as
    the active view, when I click on virgil.dib to activate it.
    Now all the action takes place completely inside DIBVIEW, so
    Windows never sends a WM_QUERYNEWPALETTE message. (This is
    why I said MDI apps are a little more complex as far as
    palettes are concerned.) It&#146;s up to you to handle the
    palettes in this situation. Fortunately, it&#146;s easy. All
    you have to do is realize the new view&#146;s palette in the
    foreground. The most convenient time to do it is when the
    view gets focus.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">void
    CDIBView::OnSetFocus(CWnd* pOldWnd) </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">TRACEFN(&quot;%s::OnSetFocus\n&quot;,
    DbgName(this));</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CView::OnSetFocus(pOldWnd);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DoRealizePalette(TRUE);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Now when virgil.dib&#151;or
    any other child frame in the MDI version of DIBVIEW&#151;gets
    focus, it realizes its palette in the foreground, just as if
    the main window had received WM_QUERYNEWPALETTE.
    DoRealizePalette calls RealizePalette, Windows changes the
    palette and, assuming colors have changed, once again
    broadcasts WM_PALETTECHANGED. CMainFrame::OnPaletteChanged
    broadcasts the message to all the views, just as in scenario
    one. This time virgil.dib is the one to ignore it and
    surf.dib is the one to realize its palette in the background.
    surf.dib has 236 colors remapped as a result of virgil.dib
    changing 238 colors in the system palette (see <strong>Figure
    18</strong>).</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><strong>Figure
18</strong> <strong>Tracing DIBVIEW</strong></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Palette scenario 1: I activated DIBVIEW from another app</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMainFrame::OnQueryNewPalette</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDIBView[0x0ab8,&quot;surf.dib&quot;]::OnQueryNewPalette</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDIBView[0x0ab8,&quot;surf.dib&quot;]::DoRealizePalette(foreground)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMainFrame::OnPaletteChanged</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDIBView[0x0ab8,&quot;surf.dib&quot;]::OnPaletteChanged
(from CDIBView[0x0ab8,&quot;surf.dib&quot;])</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[It's
me, don't realize palette]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDIBView[0x0c9c,&quot;virgil.dib&quot;]::OnPaletteChanged
(from CDIBView[0x0ab8,&quot;surf.dib&quot;])</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDIBView[0x0c9c,&quot;virgil.dib&quot;]::DoRealizePalette(background)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">220
colors changed</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">235
colors changed</font></p>

<blockquote>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="2"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Palete scenario 2: I changed focus within DIBVIEW from surf.dib
to virgil.dib </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDIBView[0x0900,&quot;virgil.dib&quot;]::OnSetFocus</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDIBView[0x0900,&quot;virgil.dib&quot;]::DoRealizePalette(foreground)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CMainFrame::OnPaletteChanged</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDIBView[0x0900,&quot;virgil.dib&quot;]::OnPaletteChanged
(from CDIBView[0x0900,&quot;virgil.dib&quot;])</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">[It's
me, don't realize palette]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDIBView[0x079c,&quot;surf.dib&quot;]::OnPaletteChanged
(from CDIBView[0x0900,&quot;virgil.dib&quot;])</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CDIBView[0x079c,&quot;surf.dib&quot;]::DoRealizePalette(background)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">236
colors changed</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">238
colors changed</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you&#146;re totally
    confused, the best thing to do is download the code yourself
    and run it, or if you&#146;re on an airplane and the smelly
    guy next to you is hogging the phone, study the TRACE output
    in <b>Figure 18</b> and compare it with the code in <b>Figure
    11</b></font><font color="#000000" size="1"
    face="FranklinGothic"><b>.</b></font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In the course of testing my
    palette code, I ran into a really nasty problem. Everything
    worked fine for the MDI version, which is what I primarily
    used to test with, because I just assumed MDI is harder. If
    it worked in MDI, it would naturally work in SDI. Wrong. For
    some reason, my palette code didn&#146;t work when opening a
    new file in the SDI version of DIBVIEW. A couple more TRACE
    statements revealed it was a bootstrapping problem. When you
    open a new file in SDI, MFC displays the File Open dialog.
    You select the file you want and press Open. As Windows
    destroys the dialog and activates DIBVIEW, it sends DIBVIEW a
    WM_QUERYNEWPALETTE message. But MFC hasn&#146;t loaded the
    new document yet, so you don&#146;t know what the palette is.
    The WM_QUERYNEWPALETTE message, your one chance in life to
    realize the palette, comes and goes before you even know what
    palette to realize. The fix was simple: just realize the
    palette in the foreground in OnInitalUpdate, after the
    document is opened.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">void
    CDIBView::OnInitialUpdate()</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">.</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DoRealizePalette(TRUE);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I realize that&#146;s a lot of
    palette-babble to digest in one sitting, especially if
    you&#146;ve never seen palettes before. Sorry. But now
    DIBVIEW is something to be proud of. (Better than MFC&#146;s
    DIBLOOK, which takes 40 percent more source lines and
    can&#146;t even display 24-bit DIBs!) DIBVIEW displays all
    kinds of bitmaps, old and new, low and hi-color, and handles
    palette messages perfectly, a feat even some commercial apps
    don&#146;t get right. I tested DIBVIEW in several situations,
    with multiple instances running, overlapping windows, SDI and
    MDI, several DIBs open at once, 8- and 24-bit DIBs. In all
    cases DIBVIEW remained true to its, er, colors. </font></p>
    <p><font color="#000000" size="1"
    face="verdana,arial,helvetica">Figure 11</font><font
    color="#000000" size="1" face="FranklinGothic"><b> </b></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">shows
    the full source code for step three of DIBVIEW. Don&#146;t
    forget to #include &lt;vfw.h&gt; in StdAfx.h for faster
    compiling, and don&#146;t forget to link with vfw.lib. VFW is
    a standard component of Windows 95 and the Visual C++
    development tools.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Wrap
Up</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Uh-oh&#151;I&#146;m running
    out of space and time! Mr. Maximum Leader has already left
    three messages on my voice mail system, wanting to know when
    he can have the viewer. So excuse me while I run over to Acme
    World Headquarters to beg for yet another extension.
    Meanwhile, don&#146;t touch that dial! In Part II, I&#146;ll
    show you how to encapsulate all that hairy palette code in a
    totally reusable class, and I&#146;ll put the final touches
    on DIBVIEW by adding some neat features and more reusable
    goodies. </font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>To
obtain complete source code listings, see </b></font><a
href="ednote.htm"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Editor's page</b></font></a><font
color="#000000" size="2" face="verdana,arial,helvetica"><b>.</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><i>This article is reproduced
    from Microsoft Systems Journal. Copyright © 1997 by Miller
    Freeman, Inc. All rights are reserved. No part of this
    article may be reproduced in any fashion (except in brief
    quotations used in critical articles and reviews) without the
    prior consent of Miller Freeman.</i></font></p>
    <p><font color="#000000" size="2"><i>To contact Miller
    Freeman regarding subscription information, call (800)
    666-1084 in the U.S. and Canada, or (303) 678-0439 in all
    other countries. For other inquiries, call (415) 905-2200.</i></font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
</blockquote>
</font></body>
</html>
