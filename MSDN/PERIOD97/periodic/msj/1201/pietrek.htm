<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Adobe application">
<meta name="Template" content="C:\MSOffice\Templates\MSJ.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A Crash Course on the Depths of Win32 Structured Exception Handling</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<p><font color="#000000" size="6" face="verdana,arial,helvetica">A
Crash Course on the Depths of Win32 Structured Exception Handling</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica">by Matt Pietrek</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Matt Pietrek is the author of
Windows 95 System Programming Secrets (IDG Books, 1995). He works
at NuMega Technologies Inc., and can be reached at
71774.362@compuserve.com.</b></font></p>

<blockquote>
    <p><font color="#000080" size="7"
    face="verdana,arial,helvetica">O</font><font color="#000000"
    size="2" face="verdana,arial,helvetica">f all the facilities
    provided by Win32¨</font><font color="#000000" size="1"
    face="verdana,arial,helvetica"> </font><font color="#000000"
    size="2" face="verdana,arial,helvetica">operating systems,
    perhaps the most widely used but underdocumented is
    structured exception handling (SEH). When you think of Win32
    structured exception handling, you probably think of terms
    like _try, _finally, and _except. You can find good
    descriptions of SEH in just about any competent Win32 book
    (even the remedial ones). Even the Win32 SDK has a fairly
    complete overview of using structured exception handling with
    _try, _finally, and _except.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">With all this documentation,
    where do I get off saying that SEH is underdocumented? At its
    heart, Win32 structured exception handling is an operating
    system-provided service. All the documentation you&#146;re
    likely to find about SEH describes one particular
    compiler&#146;s runtime library wrapping around the operating
    system implementation. There&#146;s nothing magical about the
    keywords _try, _finally, or _except. Microsoft&#146;s OS and
    compiler groups defined these keywords and what they do.
    Other C++ compiler vendors have simply gone along with their
    semantics. While the compiler SEH layer tames the nastiness
    of raw operating system SEH, it&#146;s had the effect of
    keeping the raw operating system SEH details from public
    view.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I&#146;ve received numerous
    email messages from people who have needed to implement
    compiler-level SEH and couldn&#146;t find much in the way of
    documentation for the operating system facilities. In a
    rational world, I&#146;d be able to point to the runtime
    library sources for Visual C++ or Borland C++ and be done
    with it. Alas, for some unknown reason, compiler-level SEH
    seems to be a big secret. Neither Microsoft nor Borland
    provide the source code for the innermost layer of their SEH
    support.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In this article, I&#146;ll
    strip structured exception handling down to its most
    fundamental concepts. In doing so, I&#146;ll separate what
    the OS provides from what compilers provide via code
    generation and runtime library support. When I dive into the
    code for key operating system routines, I&#146;ll use the
    Intel version of Windows NT¨ 4.0 as my base. Most of what
    I&#146;ll describe is equally applicable on other processors,
    however.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I&#146;m going to avoid the
    issue of true C++ exception handling, which uses catch()
    instead of _except. Under the hood, true C++ exception
    handling is implemented very similarly to what I&#146;ll
    describe here. However, true C++ exception handling has some
    additional complexities that would just cloud the concepts I
    want to cover.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In digging through obscure .H
    and .INC files to piece together what constitutes Win32 SEH,
    one of the best sources of information turned out to be the
    IBM OS/2 header files (particularly BSEXCPT.H). This
    shouldn&#146;t be too surprising if you&#146;ve been in this
    business for a while. The SEH mechanisms described here were
    defined back when Microsoft was still working on OS/2. For
    this reason, you&#146;ll find SEH under Win32 and OS/2 to be
    remarkably similar.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>SEH
in the Buff</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Since the details of SEH can
    be overwhelming if taken all at once, I&#146;ll start out
    small and work my way up through the layers. If you&#146;ve
    never worked with structured exception handling before,
    you&#146;re in good shape; you have no preconceived notions.
    If you&#146;ve used SEH before, try to clear your head of
    words like _try, GetExceptionCode, and
    EXCEPTION_EXECUTE_HANDLER. Pretend that this is all new to
    you. Take a deep breath. Are you ready? Good.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Imagine I told you that when a
    thread faults, the operating system gives you an opportunity
    to be informed of the fault. More specifically, when a thread
    faults, the operating system calls a user-defined callback
    function. This callback function can do pretty much whatever
    it wants. For instance, it might fix whatever caused the
    fault, or it might play a Beavis and Butt-head .WAV file.
    Regardless of what the callback function does, its last act
    is to return a value that tells the system what to do next.
    (This isn&#146;t strictly true, but it&#146;s close enough
    for now.)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Given that the system calls
    you back when your code makes a mess, what should the
    callback function look like? In other words, what sort of
    information would you want to know about the exception? It
    really doesn&#146;t matter because Win32 has made up your
    mind for you. An exception callback function looks like this:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">EXCEPTION_DISPOSITION</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">__cdecl _except_handler(</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">struct _EXCEPTION_RECORD
    *ExceptionRecord,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">void * EstablisherFrame,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">struct _CONTEXT
    *ContextRecord,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">void * DispatcherContext</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">This prototype, which comes
    from the standard Win32 header file EXCPT.H, looks a little
    overwhelming at first. If you take it slowly, it&#146;s
    really not so bad. For starters, ignore the return type
    (EXCEPTION_DISPOSITION). What you basically have is a
    function called _except_handler that takes four parameters.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The first parameter to an
    _except_handler callback is a pointer to an EXCEPTION_RECORD.
    This structure is defined in WINNT.H, shown below:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">typedef struct
    _EXCEPTION_RECORD {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD ExceptionCode;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD ExceptionFlags;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">struct _EXCEPTION_RECORD
    *ExceptionRecord;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">PVOID ExceptionAddress;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD NumberParameters;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD
    ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">} EXCEPTION_RECORD;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The ExceptionCode parameter is
    the number that the operating system assigned to the
    exception. You can see a list of various exception codes in
    WINNT.H by searching for #defines that start with
    &quot;STATUS_&quot;. For example, the code for the
    all-too-familiar STATUS_ACCESS_VIOLATION is 0xC0000005. A
    more complete set of exception codes can be found in
    NTSTATUS.H from the Windows NT DDK. The fourth element in the
    EXCEPTION_RECORD structure is the address where the exception
    occurred. The remaining EXCEPTION_RECORD fields can be
    ignored for the moment.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The second parameter to the
    _except_handler function is a pointer to an establisher frame
    structure. This is a vital parameter in SEH, but for now you
    can ignore it. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The third parameter to the
    _except_handler callback is a pointer to a CONTEXT structure.
    The CONTEXT structure is defined in WINNT.H and represents
    the register values of a particular thread. <b>Figure 1</b></font><font
    color="#000000" size="1" face="verdana,arial,helvetica"> </font><font
    color="#000000" size="2" face="verdana,arial,helvetica">shows
    the fields of a CONTEXT structure. When used for SEH, the
    CONTEXT structure represents the register values at the time
    of the exception. Incidentally, this CONTEXT structure is the
    same structure used with the GetThreadContext and
    SetThreadContext APIs.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;1&nbsp;CONTEXT
Structure</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">typedef
struct _CONTEXT</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
ContextFlags;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Dr0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Dr1;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Dr2;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Dr3;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Dr6;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Dr7;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FLOATING_SAVE_AREA
FloatSave;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
SegGs;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
SegFs;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
SegEs;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
SegDs;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Edi;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Esi;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Ebx;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Edx;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Ecx;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Eax;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Ebp;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Eip;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
SegCs;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
EFlags;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
Esp;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
SegSs;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}
CONTEXT;</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The fourth and final parameter
    to the _except_handler callback is called the
    DispatcherContext. It also can be ignored for the moment. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To briefly recap thus far, you
    have a callback function that&#146;s called when an exception
    occurs. The callback takes four parameters, three of which
    are pointers to structures. Within these structures, some
    fields are important, others not so important. The key point
    is that the _except_handler callback function receives a
    wealth of information, such as what type of exception
    occurred and where it occurred. Using this information, the
    exception callback needs to decide what to do.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">While it&#146;s tempting for
    me to throw together a quickie sample program that shows the
    _except_handler callback in action, there&#146;s still
    something missing. In particular, how does the operating
    system know where to call when a fault occurs? The answer is
    yet another structure called an EXCEPTION_REGISTRATION.
    You&#146;ll see this structure throughout this article, so
    don&#146;t skim past this part. The only place I could find a
    formal definition of an EXCEPTION_REGISTRATION was in the
    EXSUP.INC file from the Visual C++ runtime library sources:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">_EXCEPTION_REGISTRATION struc</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">prev dd ?</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">handler dd ?</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">_EXCEPTION_REGISTRATION ends</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">You&#146;ll also see this
    structure referred to as an _EXCEPTION_REGISTRATION_RECORD in
    the definition of the NT_TIB structure from WINNT.H. Alas,
    nowhere is an _EXCEPTION_REGISTRATION_RECORD defined, so all
    I have to work from is the assembly language struc definition
    in EXSUP.INC. This is just one example of what I meant
    earlier when I said that SEH was underdocumented.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In any event, let&#146;s
    return to the question at hand. How does the OS know where to
    call when an exception occurs? The EXCEPTION_REGISTRATION
    structure consists of two fields, the first of which you can
    ignore for now. The second field, handler, contains a pointer
    to an _except_<br>
    handler callback function. This gets you a little closer, but
    now the question becomes, where does the OS look to find the
    EXCEPTION_REGISTRATION structure?</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To answer this question,
    it&#146;s helpful to remember that structured exception
    handling works on a per-thread basis. That is, each thread
    has its own exception handler callback function. In my May
    1996 column, I described a key Win32 data structure, the
    thread information block (aka the TEB or TIB). Certain fields
    of this data structure are the same between Windows NT,
    Windows</font><font color="#000000" size="1"
    face="verdana,arial,helvetica">¨</font><font color="#000000"
    size="2" face="verdana,arial,helvetica"> 95, Win32s, and
    OS/2. The first DWORD in a TIB is a pointer to the
    thread&#146;s EXCEPTION_REGISTRATION structure. On the Intel
    Win32 platform, the FS register always points to the current
    TIB. Thus, at FS:[0] you can find a pointer to an
    EXCEPTION_REGISTRATION structure.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Now I&#146;m getting
    somewhere! When an exception occurs, the system looks at the
    TIB of the faulting thread and retrieves a pointer to an
    EXCEPTION_REGISTRATION structure. In this structure is a
    pointer to an _except_handler callback function. The
    operating system now knows enough to call the _except_handler
    function, as shown in <b>Figure 2</b>.</font></p>
    <p><img src="pietrek2.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
2 _except_handler_function</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">With the minimal pieces
    finally put together, I wrote a small program to demonstrate
    this very simple description of OS-level structured exception
    handling.<b> Figure 3</b></font><font color="#000000"
    size="1" face="FranklinGothic"><b> </b></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">shows
    MYSEH.CPP, which has only two functions. Function main uses
    three inline ASM blocks. The first block builds an
    EXCEPTION_REGISTRATION structure on the stack via two PUSH
    instructions (&quot;PUSH handler&quot; and &quot;PUSH
    FS:[0]&quot;). The PUSH FS:[0] saves the previous value of
    FS:[0] as part of the structure, but that&#146;s not
    important at the moment. The significant thing is that
    there&#146;s an 8-byte EXCEPTION_REGISTRATION structure on
    the stack. The very next instruction (MOV FS:[0],ESP) makes
    the first DWORD in the thread information block point at the
    new EXCEPTION_REGISTRATION structure.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;3&nbsp;MYSEH.CPP</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
MYSEH - Matt Pietrek 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, January 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: MYSEH.CPP</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
To compile: CL MYSEH.CPP</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
WIN32_LEAN_AND_MEAN</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;windows.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;stdio.h&gt;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
scratch;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXCEPTION_DISPOSITION</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__cdecl</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_except_handler(</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">struct
_EXCEPTION_RECORD *ExceptionRecord,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
* EstablisherFrame,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">struct
_CONTEXT *ContextRecord,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
* DispatcherContext )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">unsigned
i;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Indicate that we made it to our exception handler</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;Hello from an exception handler\n&quot; );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Change EAX in the context record so that it points to someplace</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
where we can successfully write</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ContextRecord-&gt;Eax
= (DWORD)&amp;scratch;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Tell the OS to restart the faulting instruction</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
ExceptionContinueExecution;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
main()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
handler = (DWORD)_except_handler;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__asm</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
// Build EXCEPTION_REGISTRATION record:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">push
handler // Address of handler function</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">push
FS:[0] // Address of previous handler</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">mov
FS:[0],ESP // Install new EXECEPTION_REGISTRATION</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__asm</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">mov
eax,0 // Zero out EAX</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">mov
[eax], 1 // Write to EAX to deliberately cause a fault</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;After writing!\n&quot; );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__asm</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
// Remove our EXECEPTION_REGISTRATION record</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">mov
eax,[ESP] // Get pointer to previous record</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">mov
FS:[0], EAX // Install previous record</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">add
esp, 8 // Clean our EXECEPTION_REGISTRATION off stack</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you&#146;re wondering why I
    built the EXCEPTION_REGISTRATION structure on the stack
    rather than using a global variable, there&#146;s a good
    reason. When you use a compiler&#146;s _try/_except syntax,
    the compiler also builds the EXCEPTION_REGISTRATION struct on
    the stack. I&#146;m simply showing you a simplified version
    of what a compiler would do if you used _try/_except.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Back to function main, the
    next __asm block intentionally causes a fault by zeroing out
    the EAX register (MOV EAX,0), and then uses the
    register&#146;s value as a memory address, which the next
    instruction writes to (MOV [EAX],1). The final __asm block
    removes this simple exception handler: first it restores the
    previous contents of FS:[0], and then it pops the
    EXCEPTION_REGISTRATION record off the stack (ADD ESP,8).</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Now, pretend that you&#146;re
    running MYSEH.EXE and you&#146;ll see what happens. When the
    MOV [EAX],1 instruction executes, it causes an access
    violation. The system looks at the FS:[0] in the TIB and
    finds a pointer to the EXCEPTION_REGISTRATION structure. In
    the structure is a pointer to the _except_handler function in
    MYSEH.CPP. The system then pushes the four required
    parameters (which I described earlier) onto the stack and
    calls the _except_handler function.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Once inside _except_handler,
    the code first indicates &quot;Yo! I made it here!&quot; via
    a printf statement. Next, _except_handler fixes the problem
    that caused the fault. That is, the EAX register points to a
    memory address that can&#146;t be written to (address 0). The
    fix is to change the EAX value in the CONTEXT structure so
    that it points to a location where writing is allowed. In
    this simple program, a DWORD variable (scratch) has been
    designated for just this purpose. The last act of the
    _except_handler function is to return the value
    ExceptionContinueExecution, which is defined in the standard
    EXCPT.H file.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">When the operating system sees
    that ExceptionContinueExecution was returned, it interprets
    this to mean that you&#146;ve fixed the problem and the
    faulting instruction should be restarted. Since my
    _except_handler function tweaked the EAX register to point to
    valid memory, the MOV EAX,1 instruction works the second time
    and function main continues normally. See, that wasn&#146;t
    so complicated, was it?</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Moving
In a Little Deeper</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">With this simplest of
    scenarios behind us, let&#146;s go back and fill in some of
    the blanks. While this exception callback is great, it&#146;s
    not a perfect solution. In an application of any size, it
    would be exceedingly messy to write a single function to
    handle exceptions that could occur anywhere in your
    application. A much more workable scenario would be to have
    multiple exception handling routines, each one customized to
    a particular section of your application. Wouldn&#146;t you
    know it, the operating system provides just this
    functionality.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Remember the
    EXCEPTION_REGISTRATION structure that the system uses to find
    the exception callback function? The first member of this
    structure, which I ignored earlier, is called prev. It&#146;s
    really a pointer to another EXCEPTION_REGISTRATION structure.
    This second EXCEPTION_REGISTRATION structure can have a
    completely different handler function. What&#146;s more, its
    prev field can point to a third EXCEPTION_REGISTRATION
    structure, and so on. Simply put, there&#146;s a linked list
    of EXCEPTION_REGISTRATION structures. The head of the list is
    always pointed to by the first DWORD in the thread
    information block (FS:[0] on Intel-based machines).</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">What does the operating system
    do with this linked list of EXCEPTION_REGISTRATION
    structures? When an exception occurs, the system walks the
    list of structures and looks for an EXCEPTION_REGISTRATION
    whose handler callback agrees to handle the exception. In the
    case of MYSEH.CPP, the handler callback agreed to handle the
    exception by returning the value ExceptionContinueExecution.
    The exception callback can also decline to handle the
    exception. In this case, the system moves on to the next
    EXCEPTION_REGISTRATION structure in the list and asks its
    exception callback if it wants to handle the exception.<b>
    Figure 4</b></font><font color="#000000" size="1"
    face="FranklinGothic"><b> </b></font><font color="#000000"
    size="2" face="verdana,arial,helvetica">shows this process.
    Once the system finds a callback that handles the exception,
    it stops walking the linked list of EXCEPTION_REGISTRATIONs.</font></p>
    <p><img src="pietrek4.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
4&nbsp; Finding a Structure to Handle the Exception</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To show an example of an
    exception callback that doesn&#146;t handle an exception,
    check out MYSEH2.CPP in <b>Figure 5</b>. To keep the code
    simple, I cheated a bit and used a little compiler-level
    exception handling. Function main just sets up a _try/_except
    block. Inside the _try block is a call to the HomeGrownFrame
    function. This function is very similar to the code in the
    earlier MYSEH program. It creates an EXCEPTION_REGISTRATION
    record on the stack and points FS:[0] at it. After
    establishing the new handler, the function intentionally
    causes a fault by writing to a NULL pointer:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">*(PDWORD)0 = 0;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The exception callback
    function, again called _except_handler, is quite different
    than the earlier version. The code first prints out the
    exception code and flags from the ExceptionRecord structure
    that the function received as a pointer parameter. The reason
    for printing out the exception flags will become clear later.
    Since this _except_handler function has no intention of
    fixing the offending code, the function returns
    ExceptionContinueSearch. This causes the operating system to
    continue its search at the next EXCEPTION_REGISTRATION record
    in the linked list. For now, take my word for it; the next
    installed exception callback is for the _try/_except code in
    function main. The _except block simply prints out
    &quot;Caught the exception in main()&quot;. In this case,
    handling the exception is as simple as ignoring that it
    happened.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
5&nbsp; MYSEH2.CPP</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
MYSEH2 - Matt Pietrek 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, January 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: MYSEH2.CPP</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
To compile: CL MYSEH2.CPP</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
WIN32_LEAN_AND_MEAN</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;windows.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;stdio.h&gt;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXCEPTION_DISPOSITION</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__cdecl</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_except_handler(</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">struct
_EXCEPTION_RECORD *ExceptionRecord,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
* EstablisherFrame,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">struct
_CONTEXT *ContextRecord,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
* DispatcherContext )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;Home Grown handler: Exception Code: %08X Exception Flags
%X&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ExceptionRecord-&gt;ExceptionCode,
ExceptionRecord-&gt;ExceptionFlags );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( ExceptionRecord-&gt;ExceptionFlags &amp; 1 )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot; EH_NONCONTINUABLE&quot; );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( ExceptionRecord-&gt;ExceptionFlags &amp; 2 )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot; EH_UNWINDING&quot; );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( ExceptionRecord-&gt;ExceptionFlags &amp; 4 )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot; EH_EXIT_UNWIND&quot; );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( ExceptionRecord-&gt;ExceptionFlags &amp; 8 )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot; EH_STACK_INVALID&quot; );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( ExceptionRecord-&gt;ExceptionFlags &amp; 0x10 )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot; EH_NESTED_CALL&quot; );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;\n&quot; );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Punt... We don&#146;t want to handle this... Let somebody else
handle it</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
ExceptionContinueSearch;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
HomeGrownFrame( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
handler = (DWORD)_except_handler;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__asm</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
// Build EXCEPTION_REGISTRATION record:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">push
handler // Address of handler function</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">push
FS:[0] // Address of previous handler</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">mov
FS:[0],ESP // Install new EXECEPTION_REGISTRATION</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">*(PDWORD)0
= 0; // Write to address 0 to cause a fault</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;I should never get here!\n&quot; );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__asm</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
// Remove our EXECEPTION_REGISTRATION record</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">mov
eax,[ESP] // Get pointer to previous record</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">mov
FS:[0], EAX // Install previous record</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">add
esp, 8 // Clean our EXECEPTION_REGISTRATION off stack</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
main()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_try</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">HomeGrownFrame();
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_except(
EXCEPTION_EXECUTE_HANDLER )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;Caught the exception in main()\n&quot; );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">A key point to bring up here
    is execution control. When a handler declines to handle an
    exception, it effectively declines to decide where control
    will eventually resume. The handler that accepts the
    exception is the one that decides where control will continue
    after all the exception handling code is finished. This has
    an important implication that&#146;s not immediately obvious.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">When using structured
    exception handling, a function may exit in an abnormal manner
    if it has an exception handler that doesn&#146;t handle the
    exception. For instance, in MYSEH2 the minimal handler in the
    HomeGrownFrame function didn&#146;t handle the exception.
    Since somebody later in the chain handled the exception
    (function main), the printf after the faulting instruction
    never executes. In some ways, using structured exception
    handling is similar to using the setjmp and longjmp runtime
    library functions.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you run MYSEH2, you&#146;ll
    find something surprising in the output. It seems that
    there&#146;s two calls to the _except_handler function. The
    first call is certainly understandable, given what you know
    so far. But why the second?</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Home Grown handler: Exception
    Code: C0000005 Exception Flags 0</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Home Grown handler: Exception
    Code: C0000027 Exception Flags 2</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">EH_UNWINDING</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Caught the Exception in main()</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">There&#146;s obviously a
    difference: compare the two lines that start with &quot;Home
    Grown Handler.&quot; In particular, the exception flags are
    zero the first time though, and 2 the second time. This
    brings me to the subject of unwinding. To jump ahead a bit,
    when an exception callback declines to handle an exception,
    it gets called a second time. This callback doesn&#146;t
    happen immediately, though. It&#146;s a bit more complicated
    then that. I&#146;ll need to refine the exception scenario
    one final time.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">When an exception occurs, the
    system walks the list of EXCEPTION_REGISTRATION structures
    until it finds a handler for the exception. Once a handler is
    found, the system walks the list again, up to the node that
    will handle the exception. During this second traversal, the
    system calls each handler function a second time. The key
    distinction is that in the second call, the value 2 is set in
    the exception flags. This value corresponds to EH_UNWINDING.
    (The definition for EH_UNWINDING is in EXCEPT.INC, which is
    in the Visual C++ runtime library sources, but nothing
    equivalent appears in the Win32 SDK.)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">What does EH_UNWINDING mean?
    When an exception callback is invoked a second time (with the
    EH_UNWINDING flag), the operating system is giving the
    handler function an opportunity to do any cleanup it needs to
    do. What sort of cleanup? A perfect example is that of a C++
    class destructor. When a function&#146;s exception handler
    declines to handle an exception, control typically
    doesn&#146;t exit from that function in a normal manner. Now,
    consider a function with a C++ class declared as a local
    variable. The C++ specification says that the destructor must
    be called. The second exception handler callback with the
    EH_UNWINDING flag is the opportunity for the function to do
    cleanup work such as invoking destructors and _finally
    blocks.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">After an exception is handled
    and all the previous exception frames have been called to
    unwind, execution continues wherever the handling callback
    decides. Remember though that it&#146;s just not enough to
    set the instruction pointer to the desired code address and
    plunge ahead. The code where execution resumes expects that
    the stack and frame pointer (the ESP and EBP registers on
    Intel CPUs) are set to their values within the stack frame
    that handled the exception. Therefore, the handler that
    accepts a particular exception is responsible for setting the
    stack and frame pointers to values that they had in the stack
    frame that contains the SEH code that handled the exception.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In more general terms, the act
    of unwinding from an exception causes all things on the stack
    below the handling frame&#146;s stack region to be removed.
    It&#146;s almost as if those functions were never called.
    Another effect of unwinding is that all
    EXCEPTION_REGISTRATIONs in the list prior to the one that
    handled the exception are removed from the list. This makes
    sense, as these EXCEPTION_REGISTRATIONs are typically built
    on the stack. After the exception has been handled, the stack
    and frame pointers will be higher in memory than the
    EXCEPTION_REGISTRATIONs that were removed from the list. <b>Figure
    6</b></font><font color="#000000" size="1"
    face="FranklinGothic"><b> </b></font><font color="#000000"
    size="2" face="verdana,arial,helvetica">shows what I&#146;m
    talking about. </font></p>
    <p><img src="pietrek6.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
6&nbsp; Unwinding from an Exception</b></font></p>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Help!
Nobody Handled It!</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">So far, I&#146;ve implicitly
    assumed that the operating system always finds a handler
    somewhere in the linked list of EXCEPTION_REGISTRATIONs. What
    happens if nobody steps up to the plate? As it turns out,
    this almost never happens. The reason is that the operating
    system sneaks in a default exception handler for each and
    every thread. The default handler is always the last node in
    the linked list, and it always chooses to handle the
    exception. Its actions are somewhat different than a normal
    exception callback routine, as I&#146;ll show later.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Let&#146;s look at where the
    system inserts the default, last resort exception handler.
    This obviously needs to occur very early in the thread&#146;s
    execution, before any user code executes. <b>Figure 7</b></font><font
    color="#000000" size="1" face="FranklinGothic"><b> </b></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">shows
    some pseudocode I wrote for BaseProcessStart, an internal
    routine in the Windows NT KERNEL32.DLL. BaseProcessStart
    takes one parameter, the address of the thread&#146;s entry
    point. BaseProcessStart runs in the context of the new
    process and calls the entry point to kick off execution of
    the first thread in the process.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;7&nbsp;BaseProcessStart
Pseudocode</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BaseProcessStart(
PVOID lpfnEntryPoint )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
retValue</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
currentESP;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
exceptionCode;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">currentESP
= ESP;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_try</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">NtSetInformationThread(
GetCurrentThread(),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ThreadQuerySetWin32StartAddress,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;lpfnEntryPoint,
sizeof(lpfnEntryPoint) );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= lpfnEntryPoint();</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ExitThread(
retValue );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_except(//
filter-expression code</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">exceptionCode
= GetExceptionInformation(),</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">UnhandledExceptionFilter(
GetExceptionInformation() ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ESP
= currentESP;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !_BaseRunningInServerProcess ) // Regular process</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ExitProcess(
exceptionCode );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
// Service</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ExitThread(
exceptionCode );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In the pseudocode, notice that
    the call to lpfnEntryPoint is wrapped within an _try and
    _except construct. This _try block is what installs the
    default, last resort exception handler in the linked list of
    handlers. All subsequent registered exception handlers will
    be inserted ahead of this handler in the list. If the
    lpfnEntryPoint function returns, the thread ran to completion
    without causing an exception. When this happens,
    BaseProcessStart calls ExitThread to terminate the tread.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">On the other hand, what if the
    thread faults and no other exception handlers handle it? In
    this case, control goes to the code inside the parens after
    the _except keyword. In BaseProcessStart, this code calls the
    UnhandledExceptionFilter API, which I&#146;ll come back to
    later. For now, the key point is that the
    UnhandledExceptionFilter API contains the meat of the default
    exception handler.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If UnhandledExceptionFilter
    returns EXCEPTION_EXECUTE_HANDLER, the _except block in
    BaseProcessStart executes. All the _except block code does is
    terminate the current process by calling ExitProcess.
    Thinking about it for a second, this makes sense; it&#146;s
    common knowledge that if a program causes a fault and nobody
    handles the fault, the system terminates the process. What
    you&#146;re seeing in the pseudocode is exactly where and how
    this happens.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">There&#146;s one final
    addition to what I&#146;ve just described. If the thread that
    faulted is running as a service and is for a thread-based
    service, the _except block code doesn&#146;t call
    ExitProcess&#151;it calls ExitThread instead. You
    wouldn&#146;t want to terminate the entire service process
    just because one service went bad.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">So what does the default
    exception handler code in UnhandledExceptionFilter do? When I
    ask this question at seminars, very few people can guess what
    the default behavior of the operating system is when an
    unhandled exception occurs. With a very simple demonstration
    of the default handler&#146;s behavior, things usually click
    and people understand. I simply run a program that
    intentionally causes a fault, and point out the results (see</font><font
    size="2"><strong> Figure 8</strong></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">).</font></p>
    <p><img src="pietrek8.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
8 Unhandled Exception Dialog</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">At a high level,
    UnhandledExceptionFilter displays a dialog telling you that a
    fault occurred. At that point, you&#146;re given the
    opportunity to either terminate or debug the faulting
    process. Much more happens behind the scenes, and I&#146;ll
    describe these things towards the end of the article.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As I&#146;ve shown, when an
    exception occurs, user-written code can (and often does) get
    executed. Likewise, during an unwind operation, user-written
    code can execute. This user-written code may have bugs and
    could cause another exception. For this reason, there are two
    other values that an exception callback can return:
    ExceptionNestedException and ExceptionCollidedUnwind. While
    obviously important, this is pretty advanced stuff and
    I&#146;m not going to dwell on it here. It&#146;s difficult
    enough to understand the basic facts.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Compiler-level
SEH</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">While I&#146;ve made
    occasional reference to _try and _except, just about
    everything I&#146;ve written about so far is implemented by
    the operating system. However, in looking at the contortions
    of my two small programs that used raw system SEH, a compiler
    wrapper around this functionality is definitely in order.
    Let&#146;s now see how Visual C++ builds its structured
    exception handling support on top of the system-level SEH
    facilities.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Before moving on, it&#146;s
    important to remember that another compiler could do
    something completely different with the raw system-level SEH
    facilities. Nothing says that a compiler must implement the
    _try/_except model that the Win32 SDK documentation
    describes. For example, the upcoming Visual Basic¨ 5.0 uses
    structured exception handling in its runtime code, but the
    data structures and algorithms are completely different from
    what I&#146;ll describe here.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you read through the Win32
    SDK documentation on structured exception handling,
    you&#146;ll come across the following syntax for a so called
    &quot;frame-based&quot; exception handler:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">try { </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// guarded body of code </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">} </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">except (filter-expression) { </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// exception-handler block </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To be a bit simplistic, all of
    the code within a try block in a function is protected by an
    EXCEPTION_REGISTRATION that&#146;s built on the
    function&#146;s stack frame. On function entry, the new
    EXCEPTION_REGISTRATION is put at the head of the linked list
    of exception handlers. After the end of the _try block, its
    EXCEPTION_REGISTRATION is removed from the head of the list.
    As I mentioned earlier, the head of the exception handler
    chain is kept at FS:[0]. Thus, if you&#146;re stepping
    through assembly language in a debugger and you see
    instructions such as</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">MOV DWORD PTR
    FS:[00000000],ESP</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">or </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">MOV DWORD PTR
    FS:[00000000],ECX</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">you can be pretty sure that
    the code is setting up or tearing down a _try/_except block.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Now that you know that a _try
    block corresponds to an EXCEPTION_REGISTRATION structure on
    the stack, what about the callback function within the
    EXCEPTION_REGISTRATION? Using Win32 terminology, the
    exception callback function corresponds to the
    filter-expression code. To refresh your memory, the
    filter-expression is the code in parens after the _except
    keyword. It&#146;s this filter-expression code that decides
    whether the code in the subsequent {} block will execute. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Since you write the
    filter-expression code, you get to decide if a particular
    exception will be handled at this particular point in your
    code. Your filter-expression code might be as simple as
    saying &quot;EXCEPTION_EXECUTE_HANDLER.&quot; Alternatively,
    the filter-expression might invoke a function that calculates
    </font><font color="#000000" size="2" face="Symbol">p</font><font
    color="#000000" size="2" face="verdana,arial,helvetica"> to
    20 million places before returning a code telling the system
    what to do next. It&#146;s your choice. The key point: your
    filter-expression code is effectively the exception callback
    that I described earlier.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">What I&#146;ve just described,
    while reasonably simple, is nonetheless a
    rose-colored-glasses view of the world. The ugly reality is
    that things are more complicated. For starters, your
    filter-expression code isn&#146;t called directly by the
    operating system. Rather, the exception handler field in
    every EXCEPTION_REGISTRATION points to the same function.
    This function is in the Visual C++ runtime library and is
    called __except_handler3. It&#146;s __except_handler3 that
    calls your filter-expression code, and I&#146;ll come back to
    it a bit later.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Another twist to the
    simplistic view that I described earlier is that
    EXCEPTION_REGISTRATIONs aren&#146;t built and torn down every
    time a _try block is entered or exits. Instead, there&#146;s
    just one EXCEPTION_REGISTRATION created in any function that
    uses SEH. In other words, you can have multiple _try/_except
    constructs in a function, yet only one EXCEPTION_REGISTRATION
    is created on the stack. Likewise, you might have a _try
    block nested within another _try block in a function. Still,
    Visual C++ creates only one EXCEPTION_REGISTRATION.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If a single exception handler
    (that is, __except_handler3) suffices for the whole EXE or
    DLL, and if a single EXCEPTION_REGISTRATION handles multiple
    _try blocks, there&#146;s obviously more going on here than
    meets the eye. This magic is accomplished through data in
    tables that you don&#146;t normally see. However, since the
    whole purpose of this article is to dissect structured
    exception handling, let&#146;s take a look at these data
    structures.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>The
Extended Exception Handling Frame</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The Visual C++ SEH
    implementation doesn&#146;t use the raw
    EXCEPTION_REGISTRATION structure. Instead, it adds additional
    data fields to the end of the structure. This additional data
    is critical to allowing a single function (__except_handler3)
    to handle all exceptions and route control to the appropriate
    filter-expressions and _except blocks throughout the code. A
    hint to the format of the Visual C++ extended
    EXCEPTION_REGISTRATION structure is found in the EXSUP.INC
    file from the Visual C++ runtime library sources. In this
    file, you&#146;ll find the following (commented out)
    definition:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">;struct
    _EXCEPTION_REGISTRATION{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">; struct
    _EXCEPTION_REGISTRATION *prev;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">; void
    (*handler)(PEXCEPTION_RECORD,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">; PEXCEPTION_REGISTRATION,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">; PCONTEXT,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">; PEXCEPTION_RECORD);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">; struct scopetable_entry
    *scopetable;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">; int trylevel;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">; int _ebp;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">; PEXCEPTION_POINTERS
    xpointers;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">;};</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">You&#146;ve seen the first two
    fields, prev and handler, before. They make up the basic
    EXCEPTION_REGISTRATION structure. What&#146;s new are the
    last three fields: scopetable, trylevel, and _ebp. The
    scopetable field points to an array of structures of type
    scopetable_entries, while the trylevel field is essentially
    an index into this array. The last field, _ebp, is the value
    of the stack frame pointer (EBP) before the
    EXCEPTION_REGISTRATION was created.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">It&#146;s not coincidental
    that the _ebp field becomes part of the extended
    EXCEPTION_REGISTRATION structure. It&#146;s included in the
    structure via the PUSH EBP instruction that most functions
    begin with. This has the effect of making all of the other
    EXCEPTION_REGISTRATION fields accessible as negative
    displacements from the frame pointer. For example, the
    trylevel field is at [EBP-04], the scopetable pointer is at
    [EBP-08], and so on. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Immediately below its extended
    EXCEPTION_REGISTRATION structure, Visual C++ pushes two
    additional values. In the DWORD immediately below, it
    reserves space for a pointer to an EXCEPTION_POINTERS
    structure (a standard Win32 structure). This is the pointer
    returned when you call the GetExceptionInformation API. While
    the SDK documentation implies that GetExceptionInformation is
    a standard Win32 API, the truth is that
    GetExceptionInformation is a compiler-intrinsic function.
    When you call the function, Visual C++ generates the
    following:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">MOV EAX,DWORD PTR [EBP-14]</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Just as
    GetExceptionInformation is a compiler intrinsic function, so
    is the related function GetExceptionCode. GetExceptionCode
    just reaches in and returns the value of a field from one of
    the data structures that GetExceptionInformation returns.
    I&#146;ll leave it as an exercise for the reader to figure
    out exactly what&#146;s going on when Visual C++ generates
    the following instructions for GetExceptionCode:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">MOV EAX,DWORD PTR [EBP-14]</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">MOV EAX,DWORD PTR [EAX]</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">MOV EAX,DWORD PTR [EAX]</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Returning to the extended
    EXCEPTION_REGISTRATION structure, 8 bytes before the start of
    the structure, Visual C++ reserves a DWORD to hold the final
    stack pointer (ESP) after all the prologue code has executed.
    This DWORD is the normal value of the ESP register as the
    function executes (except of course when parameters are being
    pushed in preparation for calling another function). </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If it seems like I&#146;ve
    dumped a ton of information onto you, I have. Before moving
    on, let&#146;s pause for just a moment and review the
    standard exception frame that Visual C++ generates for a
    function that uses structured exception handling:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">EBP-00 _ebp</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">EBP-04 trylevel</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">EBP-08 scopetable pointer</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">EBP-0C handler function
    address</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">EBP-10 previous
    EXCEPTION_REGISTRATION</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">EBP-14 GetExceptionPointers</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">EBP-18 Standard ESP in frame</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">From the operating
    system&#146;s point of view, the only fields that exist are
    the two fields that make up a raw EXCEPTION_REGISTRATION: the
    prev pointer at [EBP-10] and the handler function pointer at
    [EBP-0Ch]. Everything else in the frame is specific to the
    Visual C++ implementation. With this in mind, let&#146;s look
    at the Visual C++ runtime library routine that embodies
    compiler level SEH, __except_handler3. </font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>__except_handler3
and the scopetable</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">While I&#146;d dearly love to
    point you to the Visual C++ runtime library sources and have
    you check out the __except_handler3 function yourself, I
    can&#146;t. It&#146;s conspicuously absent. In its place,
    you&#146;ll have to make due with some pseudocode for
    __except_handler3 that I cobbled together (see <b>Figure 9</b>).</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
9&nbsp; __except_handler3 Pseudocode</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
__except_handler3(</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">struct
_EXCEPTION_RECORD * pExceptionRecord,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">struct
EXCEPTION_REGISTRATION * pRegistrationFrame,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">struct
_CONTEXT *pContextRecord,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
* pDispatcherContext )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LONG
filterFuncRet</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LONG
trylevel</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXCEPTION_POINTERS
exceptPtrs</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PSCOPETABLE
pScopeTable</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CLD
// Clear the direction flag (make no assumptions!)</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
if neither the EXCEPTION_UNWINDING nor EXCEPTION_EXIT_UNWIND bit</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
is set... This is true the first time through the handler (the</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
non-unwinding case)</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( ! (pExceptionRecord-&gt;ExceptionFlags</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;
(EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Build the EXCEPTION_POINTERS structure on the stack</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">exceptPtrs.ExceptionRecord
= pExceptionRecord;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">exceptPtrs.ContextRecord
= pContextRecord;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Put the pointer to the EXCEPTION_POINTERS 4 bytes below the</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
establisher frame. See ASM code for GetExceptionInformation</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">*(PDWORD)((PBYTE)pRegistrationFrame
- 4) = &amp;exceptPtrs;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get initial &quot;trylevel&quot; value</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">trylevel
= pRegistrationFrame-&gt;trylevel </font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get a pointer to the scopetable array</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">scopeTable
= pRegistrationFrame-&gt;scopetable;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">search_for_handler:
</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pRegistrationFrame-&gt;trylevel != TRYLEVEL_NONE )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pRegistrationFrame-&gt;scopetable[trylevel].lpfnFilter )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PUSH
EBP // Save this frame EBP</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
!!!Very Important!!! Switch to original EBP. This is</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
what allows all locals in the frame to have the same</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
value as before the exception occurred.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EBP
= &amp;pRegistrationFrame-&gt;_ebp </font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Call the filter function</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">filterFuncRet
= scopetable[trylevel].lpfnFilter();</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">POP
EBP // Restore handler frame EBP</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( filterFuncRet != EXCEPTION_CONTINUE_SEARCH )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( filterFuncRet &lt; 0 ) // EXCEPTION_CONTINUE_EXECUTION</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
ExceptionContinueExecution;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If we get here, EXCEPTION_EXECUTE_HANDLER was specified</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">scopetable
== pRegistrationFrame-&gt;scopetable</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Does the actual OS cleanup of registration frames</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Causes this function to recurse</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__global_unwind2(
pRegistrationFrame );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Once we get here, everything is all cleaned up, except</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
for the last frame, where we'll continue execution</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EBP
= &amp;pRegistrationFrame-&gt;_ebp</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__local_unwind2(
pRegistrationFrame, trylevel );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
NLG == &quot;non-local-goto&quot; (setjmp/longjmp stuff)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__NLG_Notify(
1 ); // EAX == scopetable-&gt;lpfnHandler</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Set the current trylevel to whatever SCOPETABLE entry</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
was being used when a handler was found</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pRegistrationFrame-&gt;trylevel
= scopetable-&gt;previousTryLevel;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Call the _except {} block. Never returns.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pRegistrationFrame-&gt;scopetable[trylevel].lpfnHandler();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">scopeTable
= pRegistrationFrame-&gt;scopetable;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">trylevel
= scopeTable-&gt;previousTryLevel</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">goto
search_for_handler;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
// trylevel == TRYLEVEL_NONE</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retvalue
== DISPOSITION_CONTINUE_SEARCH;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
// EXCEPTION_UNWINDING or EXCEPTION_EXIT_UNWIND flags are set</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PUSH
EBP // Save EBP</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EBP
= pRegistrationFrame-&gt;_ebp // Set EBP for __local_unwind2</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__local_unwind2(
pRegistrationFrame, TRYLEVEL_NONE )</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">POP
EBP // Restore EBP</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retvalue
== DISPOSITION_CONTINUE_SEARCH;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">While __except_handler3 looks
    like a lot of code, remember that it&#146;s just an exception
    callback like I described at the beginning of this article.
    It takes the identical four parameters as my homegrown
    exception callbacks in MYSEH.EXE and MYSEH2.EXE. At the
    topmost level, __except_handler3 is split into two parts by
    an if statement. This is because the function can be called
    twice, once normally and once during the unwind phase. The
    larger portion of the function is devoted to the
    non-unwinding callback.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The beginning of this code
    first creates an EXCEPTION_POINTERS structure on the stack,
    initializing it with two of the __except_handler3 parameters.
    The address of this structure, which I&#146;ve called
    exceptPtrs in the pseudocode, is placed at [EBP-14]. This
    initializes the pointer that the GetExceptionInformation and
    GetExceptionCode functions use.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Next, __except_handler3
    retrieves the current trylevel from the
    EXCEPTION_REGISTRATION frame (at [EBP-04]). The trylevel
    variable acts as an index into the scopetable array, which
    allows a single EXCEPTION_REGISTRATION to be used for
    multiple _try blocks within a function, as well as nested
    _try blocks. Each scopetable entry looks like this:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">typedef struct _SCOPETABLE</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD previousTryLevel;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD lpfnFilter</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD lpfnHandler</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">} SCOPETABLE, *PSCOPETABLE;</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The second and third
    parameters in a SCOPETABLE are easy to understand.
    They&#146;re the addresses of your filter-expression and the
    corresponding _except block code. The previous tryLevel field
    is bit trickier. In a nutshell, it&#146;s for nested try
    blocks. The important point here is that there&#146;s one
    SCOPETABLE entry for each _try block in a function.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As I mentioned earlier, the
    current trylevel specifies the scopetable array entry to be
    used. This, in turn, specifies the filter-expression and
    _except block addresses. Now, consider a scenario with a _try
    block nested within another _try block. If the inner _try
    block&#146;s filter-expression doesn&#146;t handle the
    exception, the outer _try block&#146;s filter-expression must
    get a crack at it. How does __except_handler3 know which
    SCOPETABLE entry corresponds to the outer _try block? Its
    index is given by the previousTryLevel field in a SCOPETABLE
    entry. Using this scheme, you can create arbitrarily nested
    _try blocks. The previousTryLevel field acts as a node in a
    linked list of possible exception handlers within the
    function. The end of the list is indicated by a trylevel of
    0xFFFFFFFF.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Returning to the
    __except_handler3 code, after it retrieves the current
    trylevel the code points to the corresponding SCOPETABLE
    entry and calls the filter- expression code. If the
    filter-expression returns EXCEPTION_CONTINUE_SEARCH,
    __except_handler3 moves on to the next SCOPETABLE entry,
    which is specified in the previousTryLevel field. If no
    handler is found by traversing the list, __except_handler3
    returns DISPOSITION_CONTINUE_SEARCH, which causes the system
    to move on to the next EXCEPTION_REGISTRATION frame. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If the filter-expression
    returns EXCEPTION_EXECUTE_HANDLER, it means that the
    exception should be handled by the corresponding _except
    block code. This means that any previous
    EXCEPTION_REGISTRATION frames have to be removed from the
    list and the _except block needs to be executed. The first of
    these chores is handled by calling __global_unwind2, which
    I&#146;ll describe later on. After some other intervening
    cleanup code that I&#146;ll ignore for the moment, execution
    leaves __except_handler3 and goes to the _except block.
    What&#146;s strange is that control never returns from the
    _except block, even though __except_handler3 makes a CALL to
    it. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">How is the current trylevel
    set? This is handled implicitly by the compiler, which
    performs on-the-fly modifications of the trylevel field in
    the extended EXCEPTION_REGISTRATION structure. If you examine
    the assembler code generated for a function that uses SEH,
    you&#146;ll see code that modifies the current trylevel at
    [EBP-04] at different points in the function&#146;s code. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">How does __except_handler3
    make a CALL to the _except block code, yet control never
    returns? Since a CALL instruction pushes a return address
    onto the stack, you&#146;d think this would mess up the
    stack. If you examine the generated code for an _except
    block, you&#146;ll find that the <br>
    first thing it does is load the ESP register from the <br>
    DWORD that&#146;s 8 bytes below the EXCEPTION_REGISTRATION
    structure. As part of its prologue code, the function saves
    the ESP value away so that an _except block can retrieve it
    later.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>The
ShowSEHFrames Program </b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you&#146;re feeling a bit
    overwhelmed at this point by things like
    EXCEPTION_REGISTRATIONs, scopetables, trylevels,
    filter-expressions, and unwinding, so was I at first. The
    subject of compiler-level structured exception handling does
    not lend itself to learning incrementally. Much of it
    doesn&#146;t make sense unless you understand the whole ball
    of wax. When confronted with a lot of theory, my natural
    inclination is to write code that applies the concepts
    I&#146;m learning. If the program works, I know that my
    understanding is (usually) correct.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>Figure 10</strong> is
    the source code for ShowSEHFrames.EXE. It uses _try/_except
    blocks to set up a list of several Visual C++ SEH frames.
    Afterwards, it displays information about each frame, as well
    as the scopetables that Visual C++ builds for each frame. The
    program doesn&#146;t generate or expect any exceptions.
    Rather, I included all the _try blocks to force Visual C++ to
    generate multiple EXCEPTION_REGISTRATION frames, with
    multiple scopetable entries per frame.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
10&nbsp; ShowSEHFrames.CPP</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
ShowSEHFrames - Matt Pietrek 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, February 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: ShowSEHFrames.CPP</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
To compile: CL ShowSehFrames.CPP</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#define
WIN32_LEAN_AND_MEAN</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;windows.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;stdio.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#pragma
hdrstop</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//----------------------------------------------------------------------------</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
!!! WARNING !!! This program only works with Visual C++, as the
data</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
structures being shown are specific to Visual C++.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//----------------------------------------------------------------------------</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#ifndef
_MSC_VER</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#error
Visual C++ Required (Visual C++ specific information is
displayed)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#endif</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//----------------------------------------------------------------------------</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Structure Definitions</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//----------------------------------------------------------------------------</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
The basic, OS defined exception frame</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">struct
EXCEPTION_REGISTRATION</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXCEPTION_REGISTRATION*
prev;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FARPROC
handler;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Data structure(s) pointed to by Visual C++ extended exception
frame</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">struct
scopetable_entry</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
previousTryLevel;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FARPROC
lpfnFilter;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FARPROC
lpfnHandler;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
The extended exception frame used by Visual C++</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">struct
VC_EXCEPTION_REGISTRATION : EXCEPTION_REGISTRATION</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">scopetable_entry
* scopetable;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
trylevel;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
_ebp;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">};</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//----------------------------------------------------------------------------</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Prototypes</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//----------------------------------------------------------------------------</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
__except_handler3 is a Visual C++ RTL function. We want to refer
to</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
it in order to print it's address. However, we need to prototype
it since</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
it doesn't appear in any header file.</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">extern
&quot;C&quot; int _except_handler3(PEXCEPTION_RECORD,
EXCEPTION_REGISTRATION *,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PCONTEXT,
PEXCEPTION_RECORD);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//----------------------------------------------------------------------------</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Code</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//----------------------------------------------------------------------------</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Display the information in one exception frame, along with its
scopetable</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
ShowSEHFrame( VC_EXCEPTION_REGISTRATION * pVCExcRec )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;Frame: %08X Handler: %08X Prev: %08X Scopetable:
%08X\n&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pVCExcRec,
pVCExcRec-&gt;handler, pVCExcRec-&gt;prev,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pVCExcRec-&gt;scopetable
);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">scopetable_entry
* pScopeTableEntry = pVCExcRec-&gt;scopetable;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">for
( unsigned i = 0; i &lt;= pVCExcRec-&gt;trylevel; i++ )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot; scopetable[%u] PrevTryLevel: %08X &quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;filter:
%08X __except: %08X\n&quot;, i,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pScopeTableEntry-&gt;previousTryLevel,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pScopeTableEntry-&gt;lpfnFilter,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pScopeTableEntry-&gt;lpfnHandler
);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pScopeTableEntry++;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;\n&quot; );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}
</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Walk the linked list of frames, displaying each in turn</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
WalkSEHFrames( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">VC_EXCEPTION_REGISTRATION
* pVCExcRec;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Print out the location of the __except_handler3 function</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;_except_handler3 is at address: %08X\n&quot;,
_except_handler3 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;\n&quot; );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get a pointer to the head of the chain at FS:[0]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__asm
mov eax, FS:[0]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__asm
mov [pVCExcRec], EAX</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Walk the linked list of frames. 0xFFFFFFFF indicates the end of
list</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">while
( 0xFFFFFFFF != (unsigned)pVCExcRec )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ShowSEHFrame(
pVCExcRec );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pVCExcRec
= (VC_EXCEPTION_REGISTRATION *)(pVCExcRec-&gt;prev);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
Function1( void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Set up 3 nested _try levels (thereby forcing 3 scopetable
entries)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_try</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_try</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_try</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">WalkSEHFrames();
// Now show all the exception frames</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_except(
EXCEPTION_CONTINUE_SEARCH )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_except(
EXCEPTION_CONTINUE_SEARCH )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_except(
EXCEPTION_CONTINUE_SEARCH )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
main()</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
i;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Use two (non-nested) _try blocks. This causes two scopetable
entries</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
to be generated for the function.</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_try</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">i
= 0x1234; // Do nothing in particular</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_except(
EXCEPTION_CONTINUE_SEARCH )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">i
= 0x4321; // Do nothing (in reverse)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_try</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">Function1();
// Call a function that sets up more exception frames</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_except(
EXCEPTION_EXECUTE_HANDLER )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Should never get here, since we aren't expecting an exception</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">printf(
&quot;Caught Exception in main\n&quot; );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The important functions in
    ShowSEHFrames are WalkSEHFrames and ShowSEHFrame.
    WalkSEHFrames first prints out the address of
    __except_handler3, the reason for which will be clear in a
    moment. Next, the function obtains a pointer to the head of
    the exception list from FS:[0] and walks each node in the
    list. Each node is of type VC_EXCEPTION_REGISTRATION, which
    is a structure that I defined to describe a Visual C++
    exception handling frame. For each node in the list,
    WalkSEHFrames passes a pointer to the node to the
    ShowSEHFrame function.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ShowSEHFrame starts by
    printing the address of the exception frame, the handler
    callback address, the address of the previous exception
    frame, and a pointer to the scopetable. Next, for each
    scopetable entry, the code prints out the previous trylevel,
    the filter-expression address, and the _except block address.
    How do I know how many entries are in a scopetable? I
    don&#146;t really. Rather, I assume that the current trylevel
    in the VC_EXCEPTION_REGISTRATION structure is one less than
    the total number of scopetable entries.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><b>Figure 11</b></font><font
    color="#000000" size="1" face="FranklinGothic"><b> </b></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">shows
    the results of running ShowSEHFrames. First, examine every
    line that begins with &quot;Frame:&quot;. Notice how each
    successive instance shows an exception frame that&#146;s at a
    higher address on the stack. Next, on the first three Frame:
    lines, notice that the Handler value is the same (004012A8).
    Looking at the beginning of the output, you&#146;ll see that
    this 004012A8 is none other than the address of the
    __except_handler3 function in the Visual C++ runtime library.
    This proves my earlier assertion that a single entry point
    handles all exceptions.</font></p>
    <p><img src="pietrk11.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
11 Running ShowSEHFrames</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">You may be wondering why there
    are three exception frames using __except_handler3 as their
    callback since ShowSEHFrames plainly has only two functions
    that use SEH. The third frame comes from the Visual C++
    runtime library. The code in CRT0.C from the Visual C++
    runtime library sources shows that the call to main or
    WinMain is wrapped in an _try/_except block. The
    filter-expression code for this _try block is found in the
    WINXFLTR.C file. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Returning to ShowSEHFrames,
    the Handler for the last Frame: line contains a different
    address, 77F3AB6C. Poking around a bit, you&#146;ll find that
    this address is in KERNEL32.DLL. This particular frame is
    installed by KERNEL32.DLL in the BaseProcessStart function
    that I described earlier.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Unwinding</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Let&#146;s briefly recap what
    unwinding means before digging into the code that implements
    it. Earlier, I described how potential exception handlers are
    kept in a linked list, pointed to by the first DWORD of the
    thread information block (FS:[0]). Since the handler for a
    particular exception may not be at the head of the list,
    there needs to be an orderly way of removing all exception
    handlers in the list that are ahead of the handler that
    actually deals with the exception.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As you saw in the Visual C++
    __except_handler3 function, unwinding is performed by the
    __global_unwind2 RTL function. This function is just a very
    thin wrapper around the undocumented RtlUnwind API:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">__global_unwind2(void *
    pRegistFrame)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">{</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">_RtlUnwind( pRegistFrame,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">&amp;__ret_label,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">0, 0 );</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">__ret_label:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">While RtlUnwind is a critical
    API for implementing compiler-level SEH, it&#146;s not
    documented anywhere. While technically a KERNEL32 function,
    the Windows NT KERNEL32.DLL forwards the call to NTDLL.DLL,
    which also has an RtlUnwind function. I was able to piece
    together some pseudocode for it, which appears in <b>Figure
    12</b>.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
12&nbsp; RtlUnwind Pseudocode</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
_RtlUnwind( PEXCEPTION_REGISTRATION pRegistrationFrame,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PVOID
returnAddr, // Not used! (At least on i386)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PEXCEPTION_RECORD
pExcptRec,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
_eax_value ) </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
stackUserBase;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
stackUserTop;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PEXCEPTION_RECORD
pExcptRec;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXCEPTION_RECORD
exceptRec; </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CONTEXT
context;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get stack boundaries from FS:[4] and FS:[8]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlpGetStackLimits(
&amp;stackUserBase, &amp;stackUserTop );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( 0 == pExcptRec ) // The normal case</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec
= &amp;excptRec;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionFlags
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionCode
= STATUS_UNWIND;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionRecord
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get return address off the stack</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionAddress
= RtlpGetReturnAddress();</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionInformation[0]
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pRegistrationFrame )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionFlags
|= EXCEPTION_UNWINDING;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionFlags|=(EXCEPTION_UNWINDING|EXCEPTION_EXIT_UNWIND);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">context.ContextFlags
=</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">(CONTEXT_i486
| CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlpCaptureContext(
&amp;context );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">context.Esp
+= 0x10;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">context.Eax
= _eax_value;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PEXCEPTION_REGISTRATION
pExcptRegHead;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRegHead
= RtlpGetRegistrationHead(); // Retrieve FS:[0]</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Begin traversing the list of EXCEPTION_REGISTRATION</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">while
( -1 != pExcptRegHead )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXCEPTION_RECORD
excptRec2;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pExcptRegHead == pRegistrationFrame )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_NtContinue(
&amp;context, 0 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If there's an exception frame, but it's lower on the stack</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
then the head of the exception list, something's wrong!</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pRegistrationFrame &amp;&amp; (pRegistrationFrame &lt;=
pExcptRegHead) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Generate an exception to bail out</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionRecord
= pExcptRec;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.NumberParameters
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionCode
= STATUS_INVALID_UNWIND_TARGET;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionFlags
= EXCEPTION_NONCONTINUABLE; </font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_RtlRaiseException(
&amp;exceptRec2 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PVOID
pStack = pExcptRegHead + 8; // 8==sizeof(EXCEPTION_REGISTRATION)</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( (stackUserBase &lt;= pExcptRegHead ) // Make sure that</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;&amp;
(stackUserTop &gt;= pStack ) // pExcptRegHead is in</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;&amp;
(0 == (pExcptRegHead &amp; 3)) ) // range, and a multiple</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
// of 4 (i.e., sane)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
pNewRegistHead;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
retValue;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= RtlpExecutehandlerForUnwind(</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec,
pExcptRegHead, &amp;context,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;pNewRegistHead,
pExceptRegHead-&gt;handler );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( retValue != DISPOSITION_CONTINUE_SEARCH )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( retValue != DISPOSITION_COLLIDED_UNWIND )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionRecord
= pExcptRec;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.NumberParameters
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionCode
= STATUS_INVALID_DISPOSITION;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionFlags
= EXCEPTION_NONCONTINUABLE; </font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlRaiseException(
&amp;excptRec2 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRegHead
= pNewRegistHead;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PEXCEPTION_REGISTRATION
pCurrExcptReg = pExcptRegHead;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRegHead
= pExcptRegHead-&gt;prev;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlpUnlinkHandler(
pCurrExcptReg );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
// The stack looks goofy! Raise an exception to bail out</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionRecord
= pExcptRec;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.NumberParameters
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionCode
= STATUS_BAD_STACK;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionFlags
= EXCEPTION_NONCONTINUABLE; </font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlRaiseException(
&amp;excptRec2 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If we get here, we reached the end of the EXCEPTION_REGISTRATION
list.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
This shouldn't happen normally.</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( -1 == pRegistrationFrame )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">NtContinue(
&amp;context, 0 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">NtRaiseException(
pExcptRec, &amp;context, 0 );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PEXCEPTION_REGISTRATION</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlpGetRegistrationHead(
void )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FS:[0];</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_RtlpUnlinkHandler(
PEXCEPTION_REGISTRATION pRegistrationFrame )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FS:[0]
= pRegistrationFrame-&gt;prev;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
_RtlpCaptureContext( CONTEXT * pContext )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;Eax
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;Ecx
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;Edx
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;Ebx
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;Esi
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;Edi
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;SegCs
= CS;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;SegDs
= DS;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;SegEs
= ES;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;SegFs
= FS;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;SegGs
= GS;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;SegSs
= SS;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;EFlags
= flags; // __asm{ PUSHFD / pop [xxxxxxxx] }</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;Eip
= return address of the caller of the caller of this function</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;Ebp
= EBP of the caller of the caller of this function </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext-&gt;Esp
= Context.Ebp + 8</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">While RtlUnwind looks
    imposing, it&#146;s not hard to understand if you
    methodically break it down. The API begins by retrieving the
    current top and bottom of the thread&#146;s stack from FS:[4]
    and FS:[8]. These values are important later as sanity checks
    to ensure that all of the exception frames being unwound fall
    within the stack region.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">RtlUnwind next builds a dummy
    EXCEPTION_RECORD on the stack and sets the ExceptionCode
    field to STATUS_UNWIND. Also, the EXCEPTION_UNWINDING flag is
    set in the ExceptionFlags field of the EXCEPTION_RECORD. A
    pointer to this structure will later be passed as a parameter
    to each exception callback. Afterwards, the code calls the
    _RtlpCaptureContext function to create a dummy CONTEXT
    structure that also becomes a parameter for the unwind call
    of the exception callback.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The remainder of RtlUnwind
    traverses the linked list of EXCEPTION_REGISTRATION
    structures. For each frame, the code calls the
    RtlpExecuteHandlerForUnwind function, which I&#146;ll cover
    later. It&#146;s this function that calls the exception
    callback with the EXCEPTION_UNWINDING flag set. After each
    callback, the corresponding exception frame is removed by
    calling RtlpUnlinkHandler.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">RtlUnwind stops unwinding
    frames when it gets to the frame with the address that was
    passed in as the first parameter. Interspersed with the code
    I&#146;ve described is sanity-checking code to ensure that
    everything looks okay. If some sort of problem crops up,
    RtlUnwind raises an exception to indicate what the problem
    was, and this exception has the EXCEPTION_NONCONTINUABLE flag
    set. A process isn&#146;t allowed to continue execution when
    this flag is set, so it must terminate. </font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Unhandled
Exceptions</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Earlier in the article, I put
    off a full description of the UnhandledExceptionFilter API.
    You normally don&#146;t call this API directly (although you
    can). Most of the time, it&#146;s invoked by the
    filter-expression code for KERNEL32&#146;s default exception
    callback. I showed this earlier in the pseudocode for
    BaseProcessStart.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>Figure 13</strong>
    shows my pseudocode for UnhandledExceptionFilter. The API
    starts out a bit strangely (at least in my opinion). If the
    fault is an EXCEPTION_ACCESS_VIOLATION, the code calls
    _BasepCheckForReadOnlyResource. While I haven&#146;t provided
    pseudocode for this function, I can summarize it. If the
    exception occurred because a resource section (.rsrc) of an
    EXE or DLL was written to, _BasepCurrentTopLevelFilter
    changes the faulting page&#146;s attributes from its normal
    read-only state, thereby allowing the write to occur. If this
    particular scenario occurs, UnhandledExceptionFilter returns
    EXCEPTION_CONTINUE_EXECUTION and execution restarts at the
    faulting instruction.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
13&nbsp; UnHandledExceptionFilter Pseudocode</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">UnhandledExceptionFilter(
STRUCT _EXCEPTION_POINTERS *pExceptionPtrs )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PEXCEPTION_RECORD
pExcptRec;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
currentESP;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
retValue;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
DEBUGPORT;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
dwTemp2;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
dwUseJustInTimeDebugger;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CHAR
szDbgCmdFmt[256]; // Template string retrieved from AeDebug key</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CHAR
szDbgCmdLine[256]; // Actual debugger string after filling in</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STARTUPINFO
startupinfo;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PROCESS_INFORMATION
pi;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">HARDERR_STRUCT
harderr; // ???</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
fAeDebugAuto;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">TIB
* pTib; // Thread information block</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec
= pExceptionPtrs-&gt;ExceptionRecord;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( (pExcptRec-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;&amp;
(pExcptRec-&gt;ExceptionInformation[0]) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_BasepCheckForReadOnlyResource(pExcptRec-&gt;ExceptionInformation[1]);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( EXCEPTION_CONTINUE_EXECUTION == retValue )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
EXCEPTION_CONTINUE_EXECUTION;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
See if this process is being run under a debugger...</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= NtQueryInformationProcess(GetCurrentProcess(),
ProcessDebugPort,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;debugPort,
sizeof(debugPort), 0 );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( (retValue &gt;= 0) &amp;&amp; debugPort ) // Let debugger have
it</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
EXCEPTION_CONTINUE_SEARCH;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Did the user call SetUnhandledExceptionFilter? If so, call their</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
installed proc now.</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( _BasepCurrentTopLevelFilter )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= _BasepCurrentTopLevelFilter( pExceptionPtrs );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( EXCEPTION_EXECUTE_HANDLER == retValue )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
EXCEPTION_EXECUTE_HANDLER;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( EXCEPTION_CONTINUE_EXECUTION == retValue )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
EXCEPTION_CONTINUE_EXECUTION;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Only EXCEPTION_CONTINUE_SEARCH goes on from here</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Has SetErrorMode(SEM_NOGPFAULTERRORBOX) been called?</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( 0 == (GetErrorMode() &amp; SEM_NOGPFAULTERRORBOX) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">harderr.elem0
= pExcptRec-&gt;ExceptionCode;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">harderr.elem1
= pExcptRec-&gt;ExceptionAddress;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( EXCEPTION_IN_PAGE_ERROR == pExcptRec-&gt;ExceptionCode )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">harderr.elem2
= pExcptRec-&gt;ExceptionInformation[2];</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">harderr.elem2
= pExcptRec-&gt;ExceptionInformation[0];</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dwTemp2
= 1;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">fAeDebugAuto
= FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">harderr.elem3
= pExcptRec-&gt;ExceptionInformation[1];</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pTib
= FS:[18h];</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
someVal = pTib-&gt;pProcess-&gt;0xC;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pTib-&gt;threadID != someVal )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__try</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szDbgCmdFmt[256]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= _GetProfileStringA( &quot;AeDebug&quot;, &quot;Debugger&quot;,
0,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">szDbgCmdFmt,
sizeof(szDbgCmdFmt)-1 );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( retValue )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dwTemp2
= 2;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szAuto[8]</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= GetProfileStringA( &quot;AeDebug&quot;, &quot;Auto&quot;,
&quot;0&quot;,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">szAuto,
sizeof(szAuto)-1 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( retValue )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( 0 == strcmp( szAuto, &quot;1&quot; ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( 2 == dwTemp2 )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">fAeDebugAuto
= TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">__except(
EXCEPTION_EXECUTE_HANDLER )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ESP
= currentESP;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dwTemp2
= 1</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">fAeDebugAuto
= FALSE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( FALSE == fAeDebugAuto )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= NtRaiseHardError(</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">STATUS_UNHANDLED_EXCEPTION
| 0x10000000,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">4,
0, &amp;harderr,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_BasepAlreadyHadHardError
? 1 : dwTemp2,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;dwUseJustInTimeDebugger
);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dwUseJustInTimeDebugger
= 3;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= 0;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( retValue &gt;= 0 </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;&amp;
( dwUseJustInTimeDebugger == 3)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;&amp;
( !_BasepAlreadyHadHardError )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;&amp;
( !_BaseRunningInServerProcess ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_BasepAlreadyHadHardError
= 1;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">SECURITY_ATTRIBUTES
secAttr = { sizeof(secAttr), 0, TRUE };</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">HANDLE
hEvent = CreateEventA( &amp;secAttr, TRUE, 0, 0 );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">memset(
&amp;startupinfo, 0, sizeof(startupinfo) );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">sprintf(szDbgCmdLine,
szDbgCmdFmt, GetCurrentProcessId(), hEvent);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">startupinfo.cb
= sizeof(startupinfo);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">startupinfo.lpDesktop
= &quot;Winsta0\Default&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CsrIdentifyAlertableThread();
// ???</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= CreateProcessA(</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">0,
// lpApplicationName</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">szDbgCmdLine,
// Command line</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">0,
0, // process, thread security attrs</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">1,
// bInheritHandles</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">0,
0, // creation flags, environment</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">0,
// current directory.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;statupinfo,
// STARTUPINFO</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&amp;pi
); // PROCESS_INFORMATION</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( retValue &amp;&amp; hEvent )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">NtWaitForSingleObject(
hEvent, 1, 0 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
EXCEPTION_CONTINUE_SEARCH;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( _BasepAlreadyHadHardError )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">NtTerminateProcess(GetCurrentProcess(),
pExcptRec-&gt;ExceptionCode);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
EXCEPTION_EXECUTE_HANDLER;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LPTOP_LEVEL_EXCEPTION_FILTER</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">SetUnhandledExceptionFilter(</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LPTOP_LEVEL_EXCEPTION_FILTER
lpTopLevelExceptionFilter ); </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{
</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
_BasepCurrentTopLevelFilter is a KERNEL32.DLL global var</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">LPTOP_LEVEL_EXCEPTION_FILTER
previous= _BasepCurrentTopLevelFilter;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Set the new value</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_BasepCurrentTopLevelFilter
= lpTopLevelExceptionFilter;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
previous; // return the old value</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The next task of
    UnhandledExceptionFilter is to determine if the process is
    being run under a Win32 debugger. That is, the process was
    created with the DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS
    flag. UnhandledExceptionFilter uses the
    NtQueryInformationProcess Function that I describe in this
    month&#146;s Under the Hood column to tell if the process is
    being debugged. If so, the API returns
    EXCEPTION_CONTINUE_SEARCH, which tells some other part of the
    system to wake up the debugger process and tell it that an
    exception occurred in the debuggee. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Next on
    UnhandledExceptionFilter&#146;s plate is a call to the
    user-installed unhandled exception filter, if present.
    Normally, there isn&#146;t a user-installed callback, but one
    can be installed via the SetUnhandledExceptionFilter API.
    I&#146;ve also provided pseudocode for this API. The API
    simply bashes a global variable with the new user callback
    address, and returns the value of the old callback. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">With the preliminaries out of
    the way, UnhandledExceptionFilter can get down to its primary
    job: informing you of your ignominious programming blunder
    with the ever- stylish Application Error dialog. There are
    two ways that this dialog can be avoided. The first is if the
    process has called SetErrorMode and specified the
    SEM_NOGPFAULTERRORBOX flag. The other method is to have the
    Auto value under the AeDebug registry key set to 1. In this
    case, UnhandledExceptionFilter skips the Application Error
    dialog and automatically fires up whatever debugger is
    specified in the Debugger value of the AeDebug key. If
    you&#146;re familiar with &quot;just in time debugging,&quot;
    this is where the operating system supports it. More on this
    later.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In most cases, neither of
    these dialog avoidance conditions are true and
    UnhandledExceptionFilter calls the NtRaiseHardError function
    in NTDLL.DLL. It&#146;s this function that brings up the
    Application Error dialog. This dialog waits for you to hit
    the OK button to terminate the process, or Cancel to debug
    it. (Maybe it&#146;s just me, but hitting Cancel to launch a
    debugger seems a little backward.)</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you hit OK in the
    Application Error dialog box, UnhandledExceptionFilter
    returns EXCEPTION_EXECUTE_HANDLER. The code that called
    UnhandledExceptionFilter usually responds by terminating
    itself (as you saw in the BaseProcessStart code). This brings
    up an interesting point. Most people assume that the system
    terminates a process with an unhandled exception. It&#146;s
    actually more correct to say that the system sets up things
    so that an unhandled exception causes the process to
    terminate itself.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The truly interesting code in
    UnhandledExceptionFilter executes if you select Cancel in the
    Application Error dialog, thereby bringing up a debugger on
    the faulting process. The code first calls CreateEvent to
    make an event that the debugger will signal after it has
    attached to the faulting process. This event handle, along
    with the current process ID, is passed to sprintf, which
    formats the command line used to start the debugger. Once
    everything is prepared, UnhandledExceptionFilter calls
    CreateProcess to start the debugger. If CreateProcess
    succeeds, the code calls NtWaitForSingleObject on the event
    created earlier. This call blocks until the debugger process
    signals the event, indicating that it has attached to the
    faulting process successfully. There are other little bits
    and pieces to the UnhandledExceptionFilter code, but
    I&#146;ve covered the important highlights here.</font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Into
the Inferno</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you&#146;ve made it this
    far, it wouldn&#146;t be fair to finish without completing
    the entire circuit. I&#146;ve shown how the operating system
    calls a user-defined function when an exception occurs.
    I&#146;ve shown what typically goes on inside of those
    callbacks, and how compilers use them to implement _try and
    _catch. I&#146;ve even shown what happens when nobody handles
    the exception and the system has to do the mopping up. All
    that remains is to show where the exception callbacks
    originate from in the first place. Yes, let&#146;s plunge
    into the bowels of the system and see the beginning stages of
    the structured exception handling sequence.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><b>Figure 14</b> shows some
    pseudocode I whipped up for KiUserExceptionDispatcher and
    some related functions. KiUserExceptionDispatcher is in
    NTDLL.DLL and is where execution begins after an exception
    occurs. To be 100 percent accurate, what I just said
    isn&#146;t exactly true. For instance, in the Intel
    architecture an exception causes control to vector to a ring
    0 (kernel mode) handler. The handler is defined by the
    interrupt descriptor table entry that corresponds to an
    exception. I&#146;m going to skip all that kernel mode code
    and pretend that the CPU goes straight to
    KiUserExceptionDispatcher upon an exception</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
14&nbsp; KiUserExceptionDispatcher Pseudocode</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">KiUserExceptionDispatcher(
PEXCEPTION_RECORD pExcptRec, CONTEXT * pContext )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
retValue;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Note: If the exception is handled, RtlDispatchException() never
returns</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( RtlDispatchException( pExceptRec, pContext ) )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= NtContinue( pContext, 0 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= NtRaiseException( pExceptRec, pContext, 0 );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXCEPTION_RECORD
excptRec2;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionCode
= retValue;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionFlags
= EXCEPTION_NONCONTINUABLE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionRecord
= pExcptRec;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.NumberParameters
= 0;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlRaiseException(
&amp;excptRec2 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
RtlDispatchException( PEXCEPTION_RECORD pExcptRec, CONTEXT *
pContext )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
stackUserBase;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
stackUserTop;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PEXCEPTION_REGISTRATION
pRegistrationFrame;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
hLog;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get stack boundaries from FS:[4] and FS:[8]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlpGetStackLimits(
&amp;stackUserBase, &amp;stackUserTop );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pRegistrationFrame
= RtlpGetRegistrationHead();</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">while
( -1 != pRegistrationFrame )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PVOID
justPastRegistrationFrame = &amp;pRegistrationFrame + 8;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( stackUserBase &gt; justPastRegistrationFrame )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionFlags
|= EH_STACK_INVALID;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
DISPOSITION_DISMISS; // 0</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( stackUsertop &lt; justPastRegistrationFrame )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionFlags
|= EH_STACK_INVALID;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
DISPOSITION_DISMISS; // 0</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pRegistrationFrame &amp; 3 ) // Make sure stack is DWORD
aligned</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionFlags
|= EH_STACK_INVALID;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
DISPOSITION_DISMISS; // 0</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( someProcessFlag )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Doesn't seem to do a whole heck of a lot.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">hLog
= RtlpLogExceptionHandler( pExcptRec, pContext, 0,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pRegistrationFrame,
0x10 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
retValue, dispatcherContext;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue=
RtlpExecuteHandlerForException(pExcptRec, pRegistrationFrame,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pContext,
&amp;dispatcherContext,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pRegistrationFrame-&gt;handler
);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Doesn't seem to do a whole heck of a lot.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( someProcessFlag )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlpLogLastExceptionDisposition(
hLog, retValue );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( 0 == pRegistrationFrame )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionFlags
&amp;= ~EH_NESTED_CALL; // Turn off flag</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EXCEPTION_RECORD
excptRec2;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
yetAnotherValue = 0;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( DISPOSITION_DISMISS == retValue )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( pExcptRec-&gt;ExceptionFlags &amp; EH_NONCONTINUABLE )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionRecord
= pExcptRec;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionNumber
= STATUS_NONCONTINUABLE_EXCEPTION;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionFlags
= EH_NONCONTINUABLE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.NumberParameters
= 0</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlRaiseException(
&amp;excptRec2 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
DISPOSITION_CONTINUE_SEARCH;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
if ( DISPOSITION_CONTINUE_SEARCH == retValue )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
if ( DISPOSITION_NESTED_EXCEPTION == retValue )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pExcptRec-&gt;ExceptionFlags
|= EH_EXIT_UNWIND;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( dispatcherContext &gt; yetAnotherValue )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">yetAnotherValue
= dispatcherContext;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">else
// DISPOSITION_COLLIDED_UNWIND</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionRecord
= pExcptRec;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionNumber
= STATUS_INVALID_DISPOSITION;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.ExceptionFlags
= EH_NONCONTINUABLE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">excptRec2.NumberParameters
= 0</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlRaiseException(
&amp;excptRec2 );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pRegistrationFrame
= pRegistrationFrame-&gt;prev; // Go to previous frame</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
DISPOSITION_DISMISS;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">_RtlpExecuteHandlerForException:
// Handles exception (first time through)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MOV
EDX,XXXXXXXX</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">JMP
ExecuteHandler</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">RtlpExecutehandlerForUnwind:
// Handles unwind (second time through)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MOV
EDX,XXXXXXXX</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
ExecuteHandler( PEXCEPTION_RECORD pExcptRec</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PEXCEPTION_REGISTRATION
pExcptReg</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CONTEXT
* pContext</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PVOID
pDispatcherContext,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">FARPROC
handler ) // Really a ptr to an _except_handler()</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Set up an EXCEPTION_REGISTRATION, where EDX points to the</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
appropriate handler code shown below</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PUSH
EDX</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PUSH
FS:[0]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MOV
FS:[0],ESP</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Invoke the exception callback function</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">EAX
= handler( pExcptRec, pExcptReg, pContext, pDispatcherContext );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Remove the minimal EXCEPTION_REGISTRATION frame </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MOV
ESP,DWORD PTR FS:[00000000]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">POP
DWORD PTR FS:[00000000]</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
EAX;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">Exception
handler used for _RtlpExecuteHandlerForException:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If unwind flag set, return DISPOSITION_CONTINUE_SEARCH, else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
assign pDispatcher context and return
DISPOSITION_NESTED_EXCEPTION</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pExcptRec-&gt;ExceptionFlags &amp; EXCEPTION_UNWIND_CONTEXT</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">?
DISPOSITION_CONTINUE_SEARCH </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">:
*pDispatcherContext = pRegistrationFrame-&gt;scopetable,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DISPOSITION_NESTED_EXCEPTION;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">Exception
handler used for _RtlpExecuteHandlerForUnwind:</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If unwind flag set, return DISPOSITION_CONTINUE_SEARCH, else</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
assign pDispatcher context and return DISPOSITION_COLLIDED_UNWIND</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
pExcptRec-&gt;ExceptionFlags &amp; EXCEPTION_UNWIND_CONTEXT</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">?
DISPOSITION_CONTINUE_SEARCH </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">:
*pDispatcherContext = pRegistrationFrame-&gt;scopetable,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DISPOSITION_COLLIDED_UNWIND;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The heart of
    KiUserExceptionDispatcher is its call to
    RtlDispatchException. This kicks off the search for any
    registered exception handlers. If a handler handles the
    exception and continues execution, the call to
    RtlDispatchException never returns. If RtlDispatchException
    returns, there are two possible paths: either NtContinue is
    called, which lets the process continues, or another
    exception is raised. This time, the exception isn&#146;t
    continuable, and the process must terminate.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Moving on to the
    RtlDispatchExceptionCode, this is where you&#146;ll find the
    exception frame walking code that I&#146;ve referred to
    throughout this article. The function grabs a pointer to the
    linked list of EXCEPTION_REGISTRATIONs and iterates over
    every node, looking for a handler. Because of the possibility
    of stack corruption, the routine is very paranoid. Before
    calling the handler specified in each EXCEPTION_REGISTRATION,
    the code ensures that the EXCEPTION_REGISTRATION is
    DWORD-aligned, within the thread&#146;s stack, and higher on
    the stack than the previous EXCEPTION_REGISTRATION. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">RtlDispatchException
    doesn&#146;t directly call the address specified in the
    EXCEPTION_REGISTRATION structure. Instead, it calls
    RtlpExecuteHandlerForException to do the dirty work.
    Depending on what happens inside
    RtlpExecuteHandlerForException, RtlDispatchException either
    continues walking the exception frames or raises another
    exception. This secondary exception indicates that something
    went wrong inside the exception callback and that execution
    can&#146;t continue.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The code for
    RtlpExecuteHandlerForException is closely related to another
    function, RtlpExecutehandlerForUnwind. You may recall that I
    mentioned this function earlier when I described unwinding.
    Both of these &quot;functions&quot; simply load the EDX
    register with different values before sending control to the
    ExecuteHandler function. Put another way,
    RtlpExecuteHandlerForException and
    RtlpExecutehandlerForUnwind are separate front ends to a
    common function, ExecuteHandler.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ExecuteHandler is where the
    handler field from the EXCEPTION_REGISTRATION is extracted
    and called. Strange as it may seem, the call to the exception
    callback is itself wrapped by a structured exception handler.
    Using SEH within itself seems a bit funky but it makes sense
    if you ponder it for a moment. If an exception callback
    causes another exception, the operating system needs to know
    about it. Depending on whether the exception occurred during
    the initial callback or during the unwind callback,
    ExecuteHandler returns either DISPOSITION_NESTED_EXCEPTION or
    DISPOSITION_COLLIDED_UNWIND. Both are basically &quot;Red
    Alert! Shut everything down now!&quot; kind of codes.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you&#146;re like me,
    it&#146;s hard to keep all of the functions associated with
    SEH straight. Likewise, it&#146;s hard to remember who calls
    who. To help myself, I came up with the diagram shown in <b>Figure
    15</b>.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Now, what&#146;s the deal with
    setting EDX before getting to the ExecuteHandler code?
    It&#146;s simple, really. ExecuteHandler uses whatever&#146;s
    in EDX as the raw exception handler if something goes wrong
    while calling the user-installed handler. It pushes the EDX
    register onto the stack as the handler field for a minimal
    EXCEPTION_REGISTRATION structure. In essence, ExecuteHandler
    uses raw structured exception handling like I showed in the
    MYSEH and MYSEH2 programs.</font></p>
    <p><img src="pietrk15.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
15 Who Calls Who in SEH</b></font></p>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Conclusion</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Structured exception handling
    is a wonderful Win32 feature. Thanks to the supporting layers
    that compilers like Visual C++ put on top of it, the average
    programmer can benefit from SEH with a relatively small
    investment in learning. However, at the operating system
    level, things are more complicated than the Win32
    documentation would lead you to believe.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Unfortunately, not much has
    been written about system-level SEH to date because almost
    everyone considers it an extremely difficult subject. The
    lack of documentation on the system-level details hasn&#146;t
    helped. In this article, I&#146;ve shown that system-level
    SEH revolves around a relatively simple callback. If you
    understand the nature of the callback, and then build
    additional layers of understanding on top of that,
    system-level structured exception handling really isn&#146;t
    so hard to grasp</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>To
obtain complete source code listings, see </b></font><a
href="ednote.htm"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Editor's page</b></font></a><font
color="#000000" size="2" face="verdana,arial,helvetica"><b>.</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><i>This article is reproduced
    from Microsoft Systems Journal. Copyright © 1997 by Miller
    Freeman, Inc. All rights are reserved. No part of this
    article may be reproduced in any fashion (except in brief
    quotations used in critical articles and reviews) without the
    prior consent of Miller Freeman.</i></font></p>
    <p><font color="#000000" size="2"><i>To contact Miller
    Freeman regarding subscription information, call (800)
    666-1084 in the U.S. and Canada, or (303) 678-0439 in all
    other countries. For other inquiries, call (415) 905-2200.</i></font></p>
</blockquote>
</font></body>
</html>
