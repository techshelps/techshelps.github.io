<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Adobe application">
<meta name="Template" content="C:\MSOffice\Templates\MSJ.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Win32 Q &amp; A</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<p><font color="#000000" size="6" face="verdana,arial,helvetica">Win32
Q &amp; A</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica">Jeffery Richter</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Jeffrey Richter wrote Advanced
Windows (Microsoft Press, 1995) and Windows 95: A
Developer&#146;s Guide (M&amp;T Books, 1995). Jeff is a
consultant and teaches Win32-based programming seminars. He can
be reached at v-jeffrr@microsoft.com.</b></font></p>

<blockquote>
    <p><font color="#000080" size="6"
    face="verdana,arial,helvetica">L</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">et me
    start this column with a bug fix for my program that
    demonstrated how to delete an executable while it was running
    (<i>MSJ </i>January 1996)<i>. </i>Reader Gord Umphrey pointed
    out this bug to me and also sent in the correction for it. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In my source code file,
    RFOR.C, search for the if statement on the first line shown
    below and insert the lines in italics.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if (pszWinInit != NULL) {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><i>// Make sure a
    zero-character terminates the string.</i></font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><i>pszWinInit[dwFileSize] =
    '\0';</i> </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// Search for the [Rename]
    section in the file.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">LPSTR pszRenameSecInFile =
    strstr(pszWinInit, szRenameSec);</font></p>
    <blockquote>
        <blockquote>
            <blockquote>
                <blockquote>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">&#149;</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">&#149;</font></p>
                    <p><font color="#000000" size="1"
                    face="verdana,arial,helvetica">&#149;</font></p>
                </blockquote>
            </blockquote>
        </blockquote>
    </blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">This additional line fixes a
    problem that could cause access violations when strstr is
    called. The problem is that the memory-mapped string may not
    be terminated with a zero character, and therefore strstr
    doesn&#146;t know when it has reached the end of the string.
    The solution is to force a terminating zero character at the
    end of the string.</font></p>
    <p><font color="#000080" size="6"
    face="verdana,arial,helvetica">Q</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">I
    need to solve a complex thread synchronization problem.
    I&#146;m aware that the WaitForMultipleObjects API allows my
    thread to wait for either a single object or for all of the
    specified objects to be signaled. WaitForMultipleObjects
    almost fills my needs, but what I really want is a function
    that allows me to express a richer waiting criteria.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">For example, let&#146;s say
    that I have three kernel objects: a mutex, a semaphore, and
    an event. I want my thread to sleep until either the mutex
    and the semaphore are both signaled or until the mutex and
    the event are both signaled. As far as I can tell,
    WaitForMultipleObjects won&#146;t let me accomplish this. How
    can I get this behavior?</font></p>
    <p align="right"><font color="#000000" size="2"
    face="verdana,arial,helvetica"><i>Lauren Calia<br>
    Columbia, MD</i></font></p>
    <p><font color="#000080" size="6"
    face="verdana,arial,helvetica">A</font><font color="#000000"
    size="2" face="verdana,arial,helvetica">You are correct:
    Win32 does not offer an API that allows you to wait on
    multiple Boolean expressions. But with a little creative use
    of the existing Win32 APIs, you can create your own
    WaitForMultipleExpressions function that does what you want.
    I created my own WaitForMultipleExpressions function that
    works on Windows¨ 95 and Windows NT¨ 4.0 or later. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">My WaitForMultipleExpressions
    function has the following prototype:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD WINAPI
    WaitForMultipleExpressions(DWORD cExpObjects, </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CONST HANDLE* pchExpObjects,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD dwTimeOut);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To call this function, you
    must first allocate an array of HANDLEs and initialize all of
    the array entries. The cExpObjects parameter indicates the
    number of entries in the array pointed to by the
    pchExpObjects parameter. This array contains multiple sets of
    kernel object handles, with each set separated by a NULL
    handle entry. WaitForMultipleExpressions treats objects
    within a single set as being ANDed together and treats the
    individual sets as being ORed together. So a call to
    WaitForMultipleExpressions suspends the calling thread until
    all the objects within a single set are signaled at the same
    time. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Here&#146;s an example.
    Suppose that we are working with four kernel objects:</font></p>
</blockquote>

<p><font color="#000000" size="1" face="B Franklin Gothic Demi">Object
Handle Value</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">Mutex
0x1111</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">Semaphore
0x2222</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">Event
0x3333</font></p>

<p><font color="#000000" size="1" face="verdana,arial,helvetica">Process
0x4444</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">Initializing
the array of handles as they appear in<b> Figure 1</b></font><font
color="#000000" size="1" face="FranklinGothic"><b> </b></font><font
color="#000000" size="2" face="verdana,arial,helvetica">instructs
WaitForMultipleExpressions to suspend the calling thread until
either the mutex AND the process are signaled, OR the semaphore
AND the event AND the process are signaled, OR the mutex and the
semaphore are signaled. You may recall that
WaitForMultipleObjects does not allow you to indicate a kernel
object more than once when you call it. When calling
WaitForMultipleExpressions you may not indicate a single kernel
object more than once within a single set, but different sets may
refer to a single kernel object. Also, WaitForMultipleObjects
does not allow you to pass an array of handles that exceeds 64
(MAXIMUM_ WAIT_OBJECTS) entries. With WaitForMultipleExpressions,
the handle array may be much larger than 64 entries; however, you
must not have more than 64 sets, and each set can contain no more
than 63 handles.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;1&nbsp;Suspending
Threads with WaitForMultipleObjects</b></font></p>

<blockquote>
    <p><font color="#000000" size="1" face="Courier New">Index
    Handle Value Set</font></p>
    <p><font color="#000000" size="1"
    face="verdana,arial,helvetica">0 0x1111 (mutex) 0</font></p>
    <p><font color="#000000" size="1"
    face="verdana,arial,helvetica">1 0x2222 (semaphore) </font></p>
    <p><font color="#000000" size="1"
    face="verdana,arial,helvetica">2 0x0000 (OR) </font></p>
    <p><font color="#000000" size="1"
    face="verdana,arial,helvetica">3 0x2222 (semaphore) 1</font></p>
    <p><font color="#000000" size="1"
    face="verdana,arial,helvetica">4 0x3333 (event) </font></p>
    <p><font color="#000000" size="1"
    face="verdana,arial,helvetica">5 0x4444 (process) </font></p>
    <p><font color="#000000" size="1"
    face="verdana,arial,helvetica">6 0x0000 (OR) </font></p>
    <p><font color="#000000" size="1"
    face="verdana,arial,helvetica">7 0x1111 (mutex) 2</font></p>
    <p><font color="#000000" size="1"
    face="verdana,arial,helvetica">8 0x4444 (process) </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><b>Figure 2</b></font><font
    color="#000000" size="1" face="FranklinGothic"><b> </b></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">shows
    WaitForMultipleExpressions&#146; possible return values. If
    an expression does become true, WaitForMultipleExpressions
    returns the WAIT_OBJECT_0-based index of that expression.
    Using the example above, if the mutex and the process object
    become signaled, WaitForMultipleExpressions returns an index
    of 2.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;2&nbsp;WaitForMultipleExpressions
Return Values</b></font></p>

<blockquote>
    <p align="left"><font color="#000000" size="1"
    face="Courier New">Return Value Description</font></p>
    <p align="left"><font color="#000000" size="1"
    face="verdana,arial,helvetica">WAIT_OBJECT_0 to
    (WAIT_OBJECT_0 +# of expressions - 1) Indicates which
    expression came true</font></p>
    <p align="left"><font color="#000000" size="1"
    face="verdana,arial,helvetica">WAIT_TIMEOUT No expression
    came true within the specified time</font></p>
    <p align="left"><font color="#000000" size="1"
    face="verdana,arial,helvetica">WAIT_FAILED An error occurred.
    Call GetLastError for more information. An <br>
    error of ERROR_TOO_MANY_SECRETS means you specified more than
    64 expressions. An error of ERROR_SECRET_TOO_LONG means that
    at least one expression had more than 63 objects specified.
    Other error codes may be returned. (I just couldn&#146;t
    resist using these two error codes for my own purposes.)</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">That&#146;s
all there is to using WaitForMultipleExpressions. To test my
function, I wrote the program, TWFME, which can be downloaded
from www.msj.com. When you run it, the dialog box in <b>Figure 3</b></font><font
color="#000000" size="1" face="FranklinGothic"><b> </b></font><font
color="#000000" size="2" face="verdana,arial,helvetica">is
displayed.</font></p>

<p><img src="winqa3.jpg"></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
3 WaitForMultipleExpressions </b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you don&#146;t change any
    of the settings and press the Wait For Multiple Expressions
    button, the application creates three event kernel objects
    that are all initially not signaled, and places one entry in
    the multicolumn, multiselection listbox for each kernel
    object. Then the test application parses the expression field
    and constructs the array of handles. I&#146;ve chosen four
    kernel objects and an expression that coincides with my
    earlier examples.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Since I&#146;ve specified a
    timeout of 30000 milliseconds, you now have 30 seconds to
    signal and unsignal the event objects by toggling entries in
    the listbox on and off. As soon as you toggle enough entries
    to satisfy one of the expressions, WaitForMultipleExpressions
    returns and indicates which expression was satisfied at the
    bottom of the dialog box. If no expressions are satisfied
    within the 30 seconds, the word &quot;Timeout&quot; appears.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Now I&#146;ll discuss how I
    implemented WaitForMultipleExpressions. This was not an easy
    function to implement, and there are definitely some overhead
    issues to be concerned with when you&#146;re using it. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">As you know, Win32 offers the
    WaitForMultipleObjects API that allows a thread to wait on a
    single AND expression:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD
    WaitForMultipleObjects(DWORD cObjects, </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">CONST HANDLE* pchObjects, </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">BOOL fWaitAll, DWORD
    dwTimeout);</font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To extend this functionality
    to include OR expressions, I must spawn multiple threads: one
    thread for each ORed expression. Each of these individual
    threads waits on a single AND expression using
    WaitForMultipleObjectsEx. (I use WaitForMultipleObjectsEx
    instead of the more common WaitForMultipleObjects for reasons
    that I&#146;ll discuss later). When one of the expressions
    comes true, one of the spawned threads wakes up and
    terminates.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The thread that called
    WaitForMultipleExpressions (which is the same thread that
    spawned all the OR threads) needs to wait until one of the OR
    expressions comes true. It does this by calling the Win32
    WaitForMultipleObjects API. The number of threads spawned (OR
    expressions) is passed for the cObjects parameter, and the
    phObjects parameter points to an array containing the list of
    spawned thread handles. For the fWaitAll parameter, FALSE is
    passed so that the main thread will wake up as soon as any of
    the expressions come true. Finally, the dwTimeout value
    passed to WaitForMultipleExpressions is passed to
    WaitForMultipleObjects.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If none of the expressions
    comes true in the specified time, WAIT_TIMEOUT is returned
    from WaitForMultipleObjects, and WAIT_TIMEOUT will be
    returned from WaitForMultipleExpressions as well. If an
    expression does come true, WaitForMultipleObjects returns the
    index that indicates which thread terminated. Since each
    thread is a separate expression, this index also indicates
    which expression came true. The same index will be returned
    from WaitForMultipleExpressions.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">That&#146;s the executive
    summary explaining how WaitForMultipleExpressions works.
    However, there are three small details that need to be
    addressed.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">First, I don&#146;t want it to
    be possible for multiple OR threads to wake up from their
    call to WaitForMultipleObjects simultaneously, because
    successfully waiting on some kernel objects causes the object
    to alter its state. For example, waiting on a semaphore
    causes its count to decrement by one.
    WaitForMultipleExpressions waits for just one expression to
    come true, so I must prevent an object from altering its
    state more than once.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The solution to this problem
    is actually quite simple. Before I spawn the OR threads, I
    create a semaphore object of my own with an initial count of
    1. Then each OR thread&#146;s call to WaitForMultipleObjects
    includes the handle to this semaphore, along with the other
    handles in the expression. This explains why each set can
    specify no more than 63 handles. For an OR thread to wake up,
    all the objects that it&#146;s waiting on must be
    signaled&#151;this includes my special semaphore. Since I
    gave my semaphore an initial count of 1, I&#146;m guaranteed
    that no more than one OR thread will ever wake up; therefore,
    no other objects will accidentally have their states altered.
    </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The second detail that needs
    to be addressed is how to force a waiting thread to stop
    waiting in order to clean up properly. Adding the semaphore
    guarantees that no more than one thread wakes up, but after I
    know which expression came true, I need to force the
    remaining threads to wake up so that they can terminate
    cleanly, freeing their stack. Calling TerminateThread should
    always be avoided, so another mechanism is required.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">After thinking a while, I
    remembered that waiting threads are forced to wake up if they
    are in an altertable state when an entry enters their
    Asynchronous Procedure Call (APC) queue. I&#146;m aware that
    most programmers aren&#146;t familiar with the APC queue, so
    I&#146;ll give some background information here.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Whenever a thread is created,
    the system also creates a queue and associates it with the
    thread. This queue is called the APC queue. The thread&#146;s
    APC queue works similarly to the window message queue.
    However, the APC queue is implemented by the low-level guts
    of the kernel, whereas the window message queue is
    implemented at a much higher level&#151;the user-interface
    components of the system. Because the APC queue is
    implemented by the kernel, it&#146;s more efficient and
    operations involving it execute much quicker.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">When performing asynchronous
    I/O, it&#146;s possible to have completed I/O notifications
    queue to the issuing thread&#146;s APC queue (for more
    information about this, see my book, <i>Advanced Windows</i>,
    Third Ed., Microsoft Press¨, 1996). Each queued notification
    includes the address of a callback routine that will be
    called to get the complete I/O notification. As I/O requests
    complete, they are simply queued to your thread&#146;s APC
    queue&#151;the callback routine is not immediately called
    because your thread may be busy doing something else and
    cannot be interrupted. To process entries in your
    thread&#146;s APC queue, the thread must put itself in an
    alertable state. This means that your thread has reached a
    position in its execution where it can handle being
    interrupted. There are five Win32 APIs (see <b>Figure 4</b>)
    that place a thread into an alertable state.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The last argument to the first
    four APIs is a Boolean value indicating whether the calling
    thread should place itself into an alertable state or not.
    For MsgWaitForMultipleObjectEx, you must use the
    MWMO_ALERTABLE flag to have the thread enter an alertable
    state. If you&#146;re familiar with the Sleep,
    WaitForSingleObject, and WaitForMultipleObjects APIs, you
    know that, internally, these non-Ex APIs call their Ex
    counterparts, always passing FALSE for the fAlertable
    parameter.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;4&nbsp;Win32
APIs that Place Threads in an Alterable State</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
SleepEx(DWORD dwTimeout, BOOL fAlertable);<br>
DWORD WaitForSingleObjectEx(HANDLE hObject, DWORD dwTimeout, BOOL
fAlertable);<br>
DWORD WaitForMultipleObjectsEx(DWORD cObjects, LPHANDLE
lphObjects, BOOL </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">fWaitAll,
DWORD dwTimeout, BOOL fAlertable);<br>
BOOL SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE
hObjectToWaitOn, DWORD </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dwMilliseconds,
BOOL fAlertable);<br>
DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, LPHANDLE
pHandles, DWORD </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dwMilliseconds,
DWORD dwWakeMask, DWORD dwFlags);</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">When you call one of the five
    APIs above and place your thread in an alertable state, the
    system first checks your thread&#146;s APC queue. If there is
    at least one entry in the queue, the system does not put your
    thread to sleep; instead, the system pulls the entry from the
    APC queue and your thread calls the callback routine. When
    the callback routine returns to the system, the system checks
    for more entries in the APC queue. If more entries exist,
    they are processed. If no more entries exist, your call to
    the alertable API returns. If there are any entries in your
    thread&#146;s APC queue when you call any of these APIs, your
    thread never sleeps!</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The only time that these APIs
    suspend your thread is if there are no entries in your
    thread&#146;s APC queue at the time when you call the API.
    Now, while your thread is suspended, it will wake up if the
    kernel objects that you&#146;re waiting on become signaled or
    if an APC entry appears in your thread&#146;s queue. Since
    your thread is in an alertable state, the system wakes your
    thread as soon as an APC entry appears. The system empties
    the queue (by calling the callback routines), and the APIs
    immediately return to the caller&#151;your thread does not go
    back to sleep waiting for kernel objects to become signaled.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The return value from these
    five APIs indicates why they have returned. If the return
    value is WAIT_IO_COMPLETION, you know that the thread is
    continuing to execute because at least one entry was
    processed from the thread&#146;s APC queue. If the return
    value is anything else, it indicates that the thread woke up
    because the sleep period expired, the specified kernel
    objects became signaled, or a mutex was abandoned.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Windows 95 and Windows NT 4.0
    introduce a new API that allows you to manually queue an
    entry to a thread&#146;s APC queue:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">DWORD QueueUserAPC(PAPCFUNC
    pfnAPC, HANDLE hThread, DWORD dwData);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The first parameter is a
    pointer to an APC function and must have the following
    prototype:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">VOID WINAP APCFunc(DWORD
    dwParam);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The second parameter is the
    handle of the thread that you wish to queue the entry for.
    Note that this can be any thread in the system. If hThread
    identifies a thread in a different process&#146;s address
    space, then pfnAPC must specify the memory address of a
    function that is in the address space of the target thread.
    The last parameter to QueueUserAPC, dwData, is a 32-bit value
    that simply gets passed to the callback function.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Even though QueueUserAPC is
    prototyped as returning a DWORD, it actually returns a BOOL
    indicating success or failure. By the way, QueueUserAPC is
    undocumented in Windows 95, but it does exist and is exported
    from Kernel32.DLL. Although it is not in the Windows 95
    documentation, it is in the Windows NT 4.0 documentation, and
    I have found it to work fine under Windows 95.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">My implementation of
    WaitForMultipleExpressions uses QueueUserAPC to force waiting
    threads to wake up. After my main thread&#146;s call to
    WaitForMultipleObjects returns, I queue an APC event to each
    of the still-waiting OR threads:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// Break all the waiting
    expression threads out of </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// their wait state so that
    they can terminate cleanly.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">for (dwExpNum = 0; dwExpNum
    &lt; dwNumExps; dwExpNum++) {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">if ((WAIT_TIMEOUT ==
    dwWaitRet) || </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">(dwExpNum != (dwWaitRet -
    WAIT_OBJECT_0))) {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">QueueUserAPC(WFME_ExpressionAPC,
    </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ahThreads[dwExpNum], 0);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Because I really don&#146;t
    have anything to do and I just want the thread to stop
    waiting, the callback function, WFME_ExpressionAPC, looks
    like this:</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// This is the APC callback
    routine function</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">VOID WINAPI WFME_ExpressionAPC
    (DWORD dwData) {</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">// This function intentionally
    left blank</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">}</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The third and last detail has
    to do with handling timeouts correctly. If none of the
    expressions comes true while waiting, the main thread&#146;s
    call to WaitForMultipleObjects returns with a value of
    WAIT_TIMEOUT. If this happens, I want to prevent any of the
    expressions from coming true and potentially causing objects
    to alter their state. The code in <strong>Figure 5</strong></font><font
    color="#000000" size="1" face="FranklinGothic"><b> </b></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">shows
    how I accomplish this.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;5&nbsp;Handling
Timeouts</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Wait for an expressions to come TRUE or for a timeout</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dwWaitRet
= WaitForMultipleObjects(dwExpNum, </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ahThreads,
FALSE, dwTimeOut);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(WAIT_TIMEOUT == dwWaitRet) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If we timed-out, we need to check to see if any </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
expressions were satisfied by checking the state </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
of the hsemOnlyOne semaphore.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dwWaitRet
= WaitForSingleObject(hsemOnlyOne, 0);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
(WAIT_TIMEOUT == dwWaitRet) {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
If the semaphore was not signalled, some thread </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
expressions was satisfied and we need to </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
determine which expression was satisfied.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dwWaitRet
= WaitForMultipleObjects(dwExpNum, </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ahThreads,
FALSE, INFINITE);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}
else {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
No expression was satisfied and the call to </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
WaitForSingleObject gave us the semaphore so we</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
know that no expression will ever be satisfied</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
now -- waiting for an expression has timed-out.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">dwWaitRet
= WAIT_TIMEOUT;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">I prevent the other
    expressions from coming true by waiting on the semaphore.
    This will decrement the semaphore&#146;s count to zero and
    none of the OR threads will be able to wake up. But it&#146;s
    possible that an expression came true somewhere after the
    main thread&#146;s call to WaitForMultipleObjects and its
    call to WaitForSingleObject. This is why I check the return
    value of calling WaitForSingleObject. If it returns
    WAIT_OBJECT_0, the main thread got the semaphore and none of
    the expressions can come true. If WAIT_TIMEOUT is returned,
    then an expression did come true before the main thread got
    the semaphore. To determine which expression came true, the
    main thread calls WaitForMultipleObjects again with a timeout
    of INFINITE, which is OK because I know that an OR thread got
    the semaphore and is about to terminate.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">At this point, I must force
    the OR threads to wake up so that they exit cleanly. The loop
    that calls QueueUserAPC (in the code fragment on the previous
    page) does this.</font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>To
obtain complete source code listings, see </b></font><a
href="ednote.htm"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Editor's page</b></font></a><font
color="#000000" size="2" face="verdana,arial,helvetica"><b>.</b></font></p>

<p><font color="#000080" size="1" face="B Franklin Gothic Demi">Have
a question about programming in Win32? Send your questions via
e-mail to Jeffrey Richter: </font><a
href="mailto:v-jeffrr@microsoft.com"><font color="#000080"
size="1" face="B Franklin Gothic Demi">v-jeffrr@microsoft.com</font></a></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><i>This article is reproduced
    from Microsoft Systems Journal. Copyright © 1997 by Miller
    Freeman, Inc. All rights are reserved. No part of this
    article may be reproduced in any fashion (except in brief
    quotations used in critical articles and reviews) without the
    prior consent of Miller Freeman.</i></font></p>
    <p><font color="#000000" size="2"><i>To contact Miller
    Freeman regarding subscription information, call (800)
    666-1084 in the U.S. and Canada, or (303) 678-0439 in all
    other countries. For other inquiries, call (415) 905-2200.</i></font></p>
</blockquote>
</font></body>
</html>
