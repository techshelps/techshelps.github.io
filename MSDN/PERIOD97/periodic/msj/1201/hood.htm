<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Adobe application">
<meta name="Template" content="C:\MSOffice\Templates\MSJ.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Under The Hood</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<p><font color="#000000" size="6" face="verdana,arial,helvetica">Under
The Hood</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica">by Matt Pietrek</font></p>

<p align="center"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Matt Pietrek is the author of
Windows 95 System Programming Secrets (IDG Books, 1995). He works
at NuMega Technologies Inc., and can be reached at
71774.362@compuserve.com.</b></font></p>

<blockquote>
    <p><font color="#000080" size="7"
    face="B New Century Schlbk Bold">I</font><font
    color="#000000" size="2" face="verdana,arial,helvetica">have
    a confession to make. For a long time, I resisted moving to
    Windows NT¨ as my primary operating system. I preferred
    Windows¨ 95 because I was more familiar with its
    architecture and knew how to extract much more in the way of
    system-level information from it. For instance, the Windows
    95 TOOLHELP32 APIs, which let you easily obtain information
    on all processes, threads, and modules in the system,
    don&#146;t appear (on the surface) to have any equivalent
    under Windows NT and the Win32 API. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you dig a little deeper,
    though, Windows NT reveals a wealth of information. You just
    have to know where to look. In previous columns, I showed two
    methods for accessing system-level information in Windows NT.
    The first method, using the performance data from the Windows
    NT registry, was described in my April 1996 column. My August
    and November 1996 columns covered PSAPI.DLL, a
    redistributable DLL from the Windows NT 4.0 Win32 SDK. This
    month, I&#146;ll dig a little deeper and examine a third way
    of accessing system-level information.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If you&#146;re a curious type
    like me, somewhere in your Win32 travels you may have
    stumbled across a group of APIs exported from NTDLL.DLL that
    have names beginning with &quot;NtQueryInformation,&quot;
    like NtQueryInformationFile and NtQueryInformationProcess.
    These APIs certainly sound like they could be useful. Alas,
    the Win32 SDK doesn&#146;t mention these APIs. What&#146;s
    up? First, looking in the SDK is barking up the wrong tree.
    And, when you do find mention of these APIs, there&#146;s no
    formal documentation. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">With no online help for these
    APIs, it&#146;s up to you to piece together how to call these
    NtQueryInformation APIs. This month, I&#146;ll show how to
    use one of them, NtQueryInformationProcess. Before I proceed,
    I&#146;m obligated to point out that
    NtQueryInformationProcess isn&#146;t part of the Win32 API.
    Microsoft could change or remove this API in the future.
    Likewise, this API isn&#146;t available on Windows 95, so be
    aware of what you&#146;re getting into if you want to use it.
    On the other hand, even if you don&#146;t use
    NtQueryInformationProcess in your own code, it&#146;s still
    interesting to know what it does, and who uses it. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To use
    NtQueryInformationProcess, you&#146;ll need to put the Win32
    SDK aside and turn to the Windows NT DDK. The DDK has many
    header files in an include directory that offer up
    information about the design and implementation of Windows
    NT. Among the most important of these files is NTDDK.H.
    There, you&#146;ll find the following: </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">NTSYSAPI</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">NTSTATUS</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">NTAPI</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">NtQueryInformationProcess(</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">IN HANDLE ProcessHandle,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">IN PROCESSINFOCLASS
    ProcessInformationClass,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">OUT PVOID ProcessInformation,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">IN ULONG
    ProcessInformationLength,</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">OUT PULONG ReturnLength
    OPTIONAL</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">);</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">This API doesn&#146;t appear
    to be described anywhere in the DDK documentation either. But
    since Win32 APIs are usually called in a consistent manner,
    you can figure out what the parameters mean and how to
    correctly call the API. A few are fairly obvious. The first
    parameter should obviously be a process handle like
    you&#146;d get back from CreateProcess or OpenProcess. The
    third parameter is a pointer to a buffer that the API fills
    in, and the fourth parameter tells the API how big the buffer
    is. The fifth parameter, ReturnLength, is a pointer to an
    unsigned long, but is labeled OPTIONAL. You can infer that
    this parameter will be filled with the length of the buffer
    needed to hold the information returned by the API.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The only tricky parameter to
    NtQueryInformationProcess is the second,
    ProcessInformationClass, which is of type PROCESSINFOCLASS.
    Luckily, elsewhere in NTDDK.H you&#146;ll find that
    PROCESSINFOCLASS is just an enum. </font><font size="2"><strong>Figure
    1</strong></font><font color="#000000" size="2"
    face="verdana,arial,helvetica"> shows the enumeration values
    from NTDDK.H that NtQueryInformationProcess accepts.
    I&#146;ll defer a description of what the enumerations mean
    until later. </font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;1&nbsp;PROCESSINFOCLASS
Enums</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">typedef
enum _PROCESSINFOCLASS {</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessBasicInformation,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessQuotaLimits,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessIoCounters,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessVmCounters,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessTimes,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessBasePriority,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessRaisePriority,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessDebugPort,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessExceptionPort,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessAccessToken,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessLdtInformation,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessLdtSize,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessDefaultHardErrorMode,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessIoPortHandlers,
// Note: this is kernel mode only</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessPooledUsageAndLimits,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessWorkingSetWatch,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessUserModeIOPL,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessEnableAlignmentFaultFixup,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessPriorityClass,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessWx86Information,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessHandleCount,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessAffinityMask,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">ProcessPriorityBoost,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">MaxProcessInfoClass</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}
PROCESSINFOCLASS;</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">With all the parameters
    accounted for, it&#146;s pretty easy to see what
    NtQueryInformationProcess does: the API fills in a buffer
    with the requested type of information for a specified
    process. Pretty simple, eh? </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">If everything I&#146;ve
    described so far is correct, it should be relatively easy to
    construct a very small sample program that calls
    NtQueryInformationProcess and spits out the results of a
    query. Having been there and done that, I can tell you of
    some pitfalls that you&#146;d encounter along the way. The
    first of these stumbling blocks is that NTDDK.H and WINDOWS.H
    do not get along. If you try to #include both WINDOWS.H and
    NTDDK.H in the same source file, you&#146;ll get numerous
    compiler errors. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The reason for the compiler
    errors is that many of the include files in the DDK overlap
    with files in the Win32 SDK (and by implication, the Visual
    C++¨ version of those files). These overlapping files
    (WINNT.H, for instance) aren&#146;t identical to their SDK
    counterparts. I tried for quite some time to get some
    combination of DDK files and SDK files to work together, but
    finally gave up. Instead, I extracted just enough of NTDDK.H
    to get the necessary definitions and created the
    NTQUERYINFORMATIONPROCESS.H file. The demo program that
    I&#146;ll describe later on uses NTQUERYINFORMATIONPROCESS.H
    rather than NTDDK.H. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Once you successfully compile
    a call to NtQueryInformationProcess, the second pitfall comes
    at the link stage. You see, NtQueryInformationProcess is
    exported by NTDLL.DLL. Neither Visual C++ nor the Win32 SDK
    comes with an import library for NTDLL.DLL. One way to bypass
    this problem is to not call NtQueryInformationProcess
    directly, and instead use GetProcAddress. A simpler solution
    is to find an import library for NTDLL.DLL. Where can you
    find one? In the Windows NT DDK, of course! It&#146;s in the
    \LIB\<i>processor </i>directory (for instance, \LIB\I386). </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Having gotten past the twin
    hurdles of compiling and linking a call to
    NtQueryInformationProcess, you should be styling. But there
    are still a few flies in the ointment; not all of the
    possible values for the PROCESSINFOCLASS enum will work with
    the API. This is hinted at in the comment next to the line
    for ProcessIoPortHandlers, which reads &quot;// Note: this is
    kernel mode only.&quot; So which PROCESSINFOCLASS values will
    NtQueryInformationProcess succeed with? Through rigorous
    tests involving cheese and hula hoops, the <i>MSJ</i> labs
    have determined that the following PROCESSINFOCLASS enums are
    worthwhile to send to NtQueryInformationProcess: </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ProcessBasicInformation</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ProcessQuotaLimits</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ProcessVmCounters</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ProcessTimes</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ProcessDebugPort</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ProcessLdtInformation</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ProcessDefaultHardErrorMode</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ProcessPooledUsageAndLimits</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ProcessWorkingSetWatch</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ProcessHandleCount</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">ProcessPriorityBoost</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">In general, when calling
    NtQueryInformationProcess, the buffer size (parameter 4) must
    exactly match the length of the information to be returned.
    Let&#146;s go through the usable PROCESSINFOCLASSes and see
    what information they return, and hence, what the buffer size
    needs to be. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>ProcessBasicInformation</strong></font><font
    color="#000000" size="2" face="FranklinGothic"><strong> </strong></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">NtQueryInformationProcess
    fills in a PROCESS_BASIC_INFORMATION structure, which is
    defined in NTDDK.H. The ProcessInformationLength parameter to
    NtQueryInformationProcess should be set to the size of this
    structure. A particularly interesting field in this structure
    is the InheritedFromUniqueProcessId DWORD. This DWORD is the
    parent process ID that created the process being queried.
    Other useful fields include the exit status and base priority
    level for the process. The GetExitCodeProcess and
    GetProcessAffinityMask APIs use NtQueryInformationProcess and
    this enum. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>ProcessQuotaLimits</strong></font><font
    color="#000000" size="2" face="FranklinGothic"> </font><font
    color="#000000" size="2" face="verdana,arial,helvetica">NtQueryInformationProcess
    fills in a QUOTA_LIMITS structure, which is defined in
    NTDDK.H. The ProcessInformationLength parameter to
    NtQueryInformationProcess should be set to the size of this
    structure. The fields of this structure define the upper
    boundaries of various system resources that the process is
    allowed to consume. In this case, resources means memory from
    the kernel mode, paged and nonpaged pools, the process
    working set, the pagefile, and the amount of processor time
    used. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>ProcessVmCounters</strong></font><font
    color="#000000" size="2" face="FranklinGothic"> </font><font
    color="#000000" size="2" face="verdana,arial,helvetica">NtQueryInformationProcess
    fills in a VM_COUNTERS structure, defined in NTDDK.H. The
    ProcessInformationLength parameter to
    NtQueryInformationProcess should be set to the size of this
    structure. Most of the fields in the VM_COUNTERS structure
    are closely related to the fields in the QUOTA_LIMITS
    structure. The key difference is that the VM_COUNTERS
    information shows what the process has actually used, rather
    than how much it would be allowed to use. There are also a
    few unrelated fields that may be of interest, such as the
    page fault count. The GetProcessWorkingSetSize API is based
    on this enum. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>ProcessTimes</strong></font><font
    color="#000000" size="2" face="FranklinGothic"> </font><font
    color="#000000" size="2" face="verdana,arial,helvetica">NtQueryInformationProcess
    fills in a KERNEL_USER_TIMES structure, also defined in
    NTDDK.H. The ProcessInformationLength parameter to
    NtQueryInformationProcess should be set to the size of this
    structure. This structure&#146;s fields tell you the start
    and exit times of a particular process, as well as how much
    time has been spent in user mode and kernel mode. Since most
    processes in the system are alive, the ExitTime member is
    usually zero. The GetProcessTimes API is really just a
    wrapper around a call to NtQueryInformationProcess with this
    enum. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>ProcessDebugPort</strong></font><font
    color="#000000" size="2" face="FranklinGothic"> </font><font
    color="#000000" size="2" face="verdana,arial,helvetica">NtQueryInformationProcess
    fills in a DWORD with the port number of the debugger for the
    process being queried. The ProcessInformationLength parameter
    to NtQueryInformationProcess should be set to sizeof(DWORD).
    The debug port is a value that&#146;s useless to ring 3 code.
    However, you can infer that a nonzero debug port means that
    the process is being run under the control of a ring 3
    debugger such as the Visual C++ IDE or Turbo Debugger. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>ProcessLdtInformation</strong></font><font
    color="#000000" size="2" face="FranklinGothic"> </font><font
    color="#000000" size="2" face="verdana,arial,helvetica">Based
    on the name, this enum should cause NtQueryInformationProcess
    to return information about LDT entries for the specified
    process. Since most Win32 processes don&#146;t use the LDT,
    this enum is of limited use. In my testing, I was unable to
    get the API to return any LDT-related information for any
    process (even NTVDM). </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>ProcessDefaultHardErrorMode</strong></font><font
    color="#000000" size="2" face="FranklinGothic"> </font><font
    color="#000000" size="2" face="verdana,arial,helvetica">NtQueryInformationProcess
    fills in a DWORD with the error mode of the process being
    queried. The ProcessInformationLength parameter to
    NtQueryInformationProcess should be set to sizeof(DWORD).
    &quot;Error mode&quot; in this case means the flags defined
    by the GetErrorMode API, and GetErrorMode is really just a
    wrapper around a call to NtQueryInformationProcess with this
    enum. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>ProcessPooledUsageAndLimits</strong></font><font
    color="#000000" size="2" face="FranklinGothic"> </font><font
    color="#000000" size="2" face="verdana,arial,helvetica">NtQueryInformationProcess
    fills in a POOLED_USAGE_AND_LIMITS structure, defined in
    NTDDK.H. The ProcessInformationLength parameter to
    NtQueryInformationProcess should be set to the size of this
    structure. Many of the fields in this structure are related
    to information returned via the ProcessQuotaLimits enum and
    the QUOTA_LIMITS structure. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>ProcessWorkingSetWatch</strong></font><font
    color="#000000" size="2" face="FranklinGothic"><strong> </strong></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">NtQueryInformationProcess
    fills in a PROCESS_WS_WATCH_INFORMATION structure, defined as
    usual in NTDDK.H. The ProcessInformationLength parameter to
    NtQueryInformationProcess should be set to the size of this
    structure. The fields in this structure describe the address
    of each page fault that brought a new page into memory and
    the address of the instruction that caused the fault. The
    GetWsChanges API in PSAPI.DLL is really just a wrapper around
    a call to NtQueryInformationProcess with this enum. I
    described the GetWsChanges function in my November 1996
    column, so I&#146;ll omit a more complete description here.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>ProcessHandleCount</strong></font><font
    color="#000000" size="2" face="FranklinGothic"> </font><font
    color="#000000" size="2" face="verdana,arial,helvetica">NtQueryInformationProcess
    fills in a DWORD with the number of open handles in use by
    the process being queried. The ProcessInformationLength
    parameter to NtQueryInformationProcess should be set to
    sizeof(DWORD). </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><strong>ProcessPriorityBoost</strong></font><font
    color="#000000" size="2" face="FranklinGothic"> </font><font
    color="#000000" size="2" face="verdana,arial,helvetica">NtQueryInformationProcess
    fills in a DWORD with the priority boost of the process being
    queried. The ProcessInformationLength parameter to
    NtQueryInformationProcess should be set to sizeof(DWORD). The
    GetProcessPriorityBoost API is really just a wrapper around a
    call to NtQueryInformationProcess with this enum. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Most of the information
    available through NtQueryInformationProcess is obtainable
    through more formally documented means. Between the
    documented Win32 APIs (such as GetProcessTimes), the Windows
    NT registry performance data, and the PSAPI.DLL APIs, you can
    get at most of the information I&#146;ve described above. If
    possible, try to use these other techniques. On the other
    hand, there&#146;s something to be said for
    NtQueryInformationProcess. It&#146;s simple to use (unlike
    the registry performance data), and doesn&#146;t require
    redistributing a supporting DLL (PSAPI.DLL). </font></p>
</blockquote>

<p><font color="#000000" size="3" face="verdana,arial,helvetica"><b>Putting
NtQueryInformationProcess to Work</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">To show off the capabilities
    of NtQueryInformationProcess, I&#146;ve written the
    NTQUERYINFORMATIONPROCESSDEMO program, winner of this
    year&#146;s &quot;Longest Sample App Name&quot; award and
    shown in <b>Figure 2</b>. The listbox in the upper left
    contains a list of all running processes and their IDs. The
    process list doesn&#146;t automatically update as processes
    start up and exit, so you might find the Refresh Processes
    button handy. </font></p>
    <p><img src="hood2.jpg"></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure
2 NTQUERYINFORMATIONPROCESSDEMO</b></font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">Upon clicking on a process in
    the process list, all of the other listboxes fill up with the
    information specific to that process, which is obtained via a
    call to NtQueryInformationProcess. The headers at the top of
    each listbox correspond to the particular PROCESSINFOCLASS
    enum that the information was retrieved by. The one exception
    is the Miscellaneous list, where I lumped all items that are
    only a single DWORD (for example, ProcessHandleCount). The
    only PROCESSINFOCLASS enum that&#146;s supported, but which
    the program doesn&#146;t report, is ProcessWorkingSetWatch.
    The information returned requires too much interpretation for
    a small sample, and I&#146;ve already covered the working set
    information in my November 1996 column. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The code for
    NTQUERYINFORMATIONPROCESSDEMO is all found within
    NTQUERYINFORMATIONPROCESSDEMO.CPP in <b>Figure 3</b>.</font><font
    color="#000000" size="1" face="FranklinGothic"><b> </b></font><font
    color="#000000" size="2" face="verdana,arial,helvetica">The
    essential function is QueryProcessInformation, a nice wrapper
    around the NtQueryInformationProcess API. My wrapper function
    takes a process ID as one of its parameters rather than a
    process handle. This spares the rest of the code from being
    littered with calls to OpenProcess and CloseHandle. My
    QueryProcessInformation wrapper function also zeros out the
    input buffer before calling NtQueryInformationProcess, and
    checks the return value from NtQueryInformationProcess. Thus,
    my QueryProcessInformation can return a simple BOOL
    indicating the success or failure of
    NtQueryInformationProcess. </font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>Figure&nbsp;3&nbsp;NTQUERYINFORMATIONPROCESSDEMO</b></font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
NTQUERYINFORMATIONPROCESSDEMO - Matt Pietrek 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Microsoft Systems Journal, January 1997</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
FILE: NTQUERYINFORMATIONPROCESSDEMO.CPP</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//==================================================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;windows.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&lt;stdio.h&gt;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#pragma
hdrstop</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;psapi.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;ntqueryinformationprocess.h&quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">#include
&quot;ntqueryinformationprocessdemo.h&quot;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Helper function prototypes</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
Handle_WM_COMMAND(HWND hDlg, WPARAM wParam, LPARAM lParam);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
Handle_WM_INITDIALOG(HWND hDlg);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
Handle_WM_CLOSE( HWND hDlg );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
CALLBACK
NtQueryInformationProcessDemoDlgProc(HWND,UINT,WPARAM,LPARAM);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
lbprintf(HWND hWnd, char * format, ...);</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
StrFromLONGLONG( LONGLONG val , PSTR szOut );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
GetDlgSelectedItemData( HWND hDlg, int ctlID );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
FakeFirstLbItemSelection( HWND hDlg, int listboxID );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
GetSetPositionInfoFromRegistry( BOOL fSave, POINT *lppt );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
======================= String literals
===============================</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
gszRegistryKey[]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">=
&quot;Software\\WheatyProductions\\NtQueryInformationProcessDemo&quot;;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
g_AboutMsgTxt[] =</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;NtQueryInformationProcessDemo
shows processes information obtained &quot;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">&quot;from
the NtQueryInformationProcess function&quot;;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
g_AboutTitleTxt[]</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">=
&quot;NtQueryInformationProcessDemo - Matt Pietrek 1997, for
MSJ&quot;;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
======================= Start of code
===============================</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Wrapper function around NtQueryInformationProcess. Lets you pass</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
in a PID, and takes care of creating and closing a process
handle.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Also takes care of other housecleaning work.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">BOOL
QueryProcessInformation( DWORD pid,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">PROCESSINFOCLASS
infoEnum,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
* pBuffer,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">unsigned
cbBuffer )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">HANDLE
hProcess = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, pid );</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !hProcess )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Zero the input buffer that NtQueryInformationProcess sees</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">memset(
pBuffer, 0, cbBuffer );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
retLen;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">int
retValue;</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">retValue
= NtQueryInformationProcess( hProcess, infoEnum,</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">pBuffer,
cbBuffer, &amp;retLen );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">CloseHandle(
hProcess );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( retValue &lt; 0 ) // NtQueryInformationProcess returns a
negative</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
FALSE; // value if it fails</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return
TRUE;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">}</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Using functions from PSAPI.DLL, update the listbox in the upper
left</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
corner, and store the associated PID with each entry.</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">void
UpdateProcessList( HWND hDlg )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get the treeview's HWND, then clear it</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">HWND
hWnd = GetDlgItem( hDlg,IDC_LB_PROCESSES );</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Get the list of process IDs</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
aProcesses[1024], cbNeeded;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">if
( !EnumProcesses( aProcesses, sizeof(aProcesses), &amp;cbNeeded )
)</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">return;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Calculate how many process IDs were returned</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
cProcesses = cbNeeded / sizeof(DWORD);</font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">//
Spit out the information for each ID</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">for
( unsigned i = 0; i &lt; cProcesses; i++ )</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">{</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">char
szProcessName[MAX_PATH] = &quot;unknown&quot;;</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">DWORD
pid = aProcesses[i];</font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">HANDLE
hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">The remainder of the
    NTQUERYINFORMATIONPROCESSDEMO code is boilerplate dialog box
    management. If you want to get a handle on where the hardcore
    code starts, check out the UpdateProcessInfoFields function.
    This function takes a process ID and is invoked whenever the
    user selects a new process in the process list. When called,
    the function in turn calls half a dozen other functions to
    fill in the various listboxes with process-specific
    information. </font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">For example, the first thing
    UpdateProcessInfoFields does is call
    UpdateProcessBasicInformation, passing it the process ID.
    UpdateProcessBasicInformation declares a variable of type
    PROCESS_BASIC_INFORMATION, and passes a pointer to that
    structure, along with the process ID, to the
    QueryProcessInformation wrapper function. As described
    earlier, QueryProcessInformation is a wrapper around
    NtQueryInformationProcess. Assuming the call to
    NtQueryInformationProcess goes well, the
    UpdateProcessBasicInformation function formats and adds <br>
    information about each member of the PROCESS__INFORMATION
    structure to the relevant listbox.</font></p>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica">While
    NtQueryInformationProcess isn&#146;t a full-fledged Win32
    API, enough of the information needed to use it can be
    gleaned from the NTDDK.H file. Some of the information it
    returns isn&#146;t available in any other way (at least not
    from user-mode code). On the other hand, much of the system
    information it retrieves can be obtained via other means.
    While you may not ever need to use NtQueryInformationProcess,
    it&#146;s comforting to know that it&#146;s there if needed.
    Likewise, realizing that higher-level functions like
    GetProcessTimes are built atop it leads to an overall better
    understanding of the Windows NT architecture. </font></p>
</blockquote>

<p><font color="#000000" size="2" face="verdana,arial,helvetica"><b>To
obtain complete source code listings, see </b></font><a
href="ednote.htm"><font color="#000000" size="2"
face="verdana,arial,helvetica"><b>Editor's page</b></font></a><font
color="#000000" size="2" face="verdana,arial,helvetica"><b>.</b></font></p>

<p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>

<p><font color="#000080" size="1" face="B Franklin Gothic Demi">Have
a question about programming in Windows? Send it to Matt at c</font><a
href="mailto:71774.362@compuserve.com"><font color="#000080"
size="1" face="B Franklin Gothic Demi">mailto:71774.362@compuserve.com</font></a><font
color="#000080" size="1" face="B Franklin Gothic Demi">.</font></p>

<blockquote>
    <p><font color="#000000" size="2"
    face="verdana,arial,helvetica"><i>This article is reproduced
    from Microsoft Systems Journal. Copyright © 1997 by Miller
    Freeman, Inc. All rights are reserved. No part of this
    article may be reproduced in any fashion (except in brief
    quotations used in critical articles and reviews) without the
    prior consent of Miller Freeman.</i></font></p>
    <p><font color="#000000" size="2"><i>To contact Miller
    Freeman regarding subscription information, call (800)
    666-1084 in the U.S. and Canada, or (303) 678-0439 in all
    other countries. For other inquiries, call (415) 905-2200.</i></font></p>
    <p><font color="#000000" size="3" face="Courier New"></font>&nbsp;</p>
</blockquote>
</font></body>
</html>
