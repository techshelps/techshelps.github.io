<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft Transaction Server Helps You Write Scalable, Distributed Internet Apps</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF>

<font face="verdana,arial,helvetica" size="2">
<h1>Microsoft Transaction Server Helps You Write Scalable, Distributed Internet Apps</h1>
<p>Dave Reed, Tracey Trewin, Mai-lan Tomsen</p>
<p>Dave Reed (product unit manager), Tracey Trewin (program manager), and Mai-lan Tomsen (programming writer) are part of the MTS product team at Microsoft.</p>
<p>
Talk&nbsp;to&nbsp;anyone build&shy;ing a multiuser enterprise server application and they will tell you about all sorts of interesting problems they solved that had nothing to do with the actual business logic. Complex problems relating to thread management, security authorization, and transaction support across multiple databases might come up. This article explains how Microsoft&reg; Transaction Server (MTS) 1.0 eliminates the need to work on low-level programming when building server applications, allowing developers to focus primarily on the server business logic. To illustrate MTS design and implementation decisions, we’ve built a sample Customer Maintenance program that exhibits the fundamental MTS development and deployment tasks. As we walk through the client and server code, we will point out requirements and suggestions for building your applications according to the MTS programming model. We’ve provided a glossary of MTS terminology in the sidebar “An MTS Glossary” for your general reference.</p>
<h2>What is MTS?</h2>
<p>
MTS is a component-based programming model and runtime environment for developing, deploying, and managing high-performance, scalable, and robust enterprise Internet and intranet server applications. MTS 1.0, which was released in December 1996, combines the power, flexibility, and low cost of desktop applications with the mission-critical transaction processing features previously found on high-end mainframes. MTS requires Microsoft Windows NT&reg; 4.0 and accommodates both Windows NT and Windows&reg; 95-based clients (with DCOM support). </p>
<h2>MTS Components</h2>
<p>
Because MTS uses a component-based application <BR>development model with a transaction processing run&shy;time infrastructure, you break down your business logic into ActiveX™ components that can be updated and managed easily. You use your favorite development tool—Visual Basic&reg;, Visual C++&reg;, Visual J++, COBOL, Powerbuilder, Optima++, or Vision Builder—to build ActiveX single-user components as in-process DLLs. The DLLs are then installed into the MTS runtime environment for execution. You can create your application from components you build yourself, components you share with other applications, or components you buy from a third party.</p>
<h2>MTS Explorer</h2>
<p>
The MTS Explorer helps you package, deploy, and administer your applications. MTS applications consist of one or more packages—a set of components that perform related application functions that are organized into one deployment unit. You can use the MTS Explorer’s graphical user interface to perform development, deployment, and administration tasks on your package files. The MTS Explorer hierarchy depicts how the items in the runtime environment are organized so that you can manipulate your applications on the package, component, interface, and method levels. The MTS Explorer interface lets you perform tasks ranging from creating a new package to providing a brief description of a method on an interface for administrators to reference. </p>
<h2>MTS Application Clients</h2>
<p>
With MTS, you have a choice of clients. MTS supports HTML browser clients and Win32&reg; clients built using any of the development tools mentioned previously. Figure 1 shows how the two client types communicate with MTS components. A Win32 client communicates over DCOM with an MTS component running in the MTS runtime environment. A browser client communicates with Microsoft Internet Information Server (IIS) or any other Internet server capable of invoking ActiveX components. For example, you can write Active Server Pages (ASP) scripts to invoke ActiveX components running in MTS. </p>
<p>
<img src="mts1.gif" border=0></p>
<p>
Figure 1  Three-tier Architecture with MTS</p>
<h2>MTS Runtime Environment</h2>
<p>
Components in an MTS application execute in the MTS runtime environment. This runtime infrastructure:
<ul>
<li>
Manages system resources, including processes, threads, and database connections so that your server application can scale to many simultaneous users.<br><br></li>
<li>
Manages server component creation, execution, and deletion.<br><br></li>
<li>
Automatically initiates and controls transactions to make your application reliable.<br><br></li>
<li>
Implements security so that unauthorized users cannot access your application.<br><br></li>
<li>
Provides tools for configuration, management, and deployment.</li>
</ul>
<p>
MTS components can access data using ODBC. Anything layered above ODBC may also be used to access data, in&shy;cluding ActiveX Data Objects (ADO), OLE DB provider for ODBC, and Remote Data Objects (RDO). Since ODBC 3.0 Driver Manager is an MTS resource dispenser, data accessed via ODBC is automatically protected by your object’s transaction. In order for this to work, an ODBC-compliant database must have a thread-safe driver that operates without thread affinity.</p>
<p>
If ODBC is used from within a transactional component, then the ODBC driver must also support the SQL_ATTR_<BR>ENLIST_IN_DTC connection attribute. This is how the ODBC Driver Manager asks the ODBC driver to enlist a connection on a transaction. You can make your component transactional by setting the transaction property for your component in the MTS Explorer.</p>
<p>
Currently, SQL Server™ 6.5 is the only database with an ODBC driver that satisfies both criteria. Many databases support the first criteria and are working on providing support for the second. If you are working with a database that does not have a resource dispenser that can recognize MTS transactions, contact your database vendor to obtain the required support. </p>
<p>
Other MTS resource dispensers include the Microsoft beta products codenamed “Cedar” and “Falcon.” Cedar is used to access CICS and IMS transaction monitor mainframes (see http://www.microsoft.com/transaction/ for details). Falcon (Microsoft MSMQ) is a message queuing system (see http://www.microsoft.com/msmq/). Since Cedar and MSMQ are resource dispensers, any work done is guaranteed to be protected by the object’s transaction when used by an MTS component. The MTS Beta SDK can be used to build additional resource dispensers. </p>
<h2>MTS Transaction Coordinator</h2>
<p>
MTS uses the services of Microsoft Distributed Transaction Coordinator (DTC) for transaction coordination. DTC is a system service that coordinates transactions that span multiple resource managers. Work can be committed as a single transaction even if it spans multiple resource managers, potentially on separate machines. DTC was first released as part of Microsoft SQL Server 6.5 and is included as part of MTS. It implements a two-phase commit protocol that ensures the transaction outcome (either commit or abort) is consistent across all resource managers involved in a transaction. DTC supports resource managers that implement OLE transactions, X/Open XA protocols, and LU 6.2 Sync Level 2.</p>
<h2>Customer Maintenance Sample </h2>
<p>
To illustrate the process of building applications to the MTS programming model, we wrote a simple, three-tier sample application called Customer Maintenance that updates customer information in a database. We built Customer Maintenance using Visual Basic 5.0 Enterprise Edition, ADO, and SQL Server 6.5 for the database. Figure 2 illustrates the architecture of the sample application.</p>
<p>
<img src="mts2.gif" border=0></p>
<p>
Figure 2  Customer Maintenance Architecture</p>
<p>
The user interface of the Customer Maintenance client consists of two forms for data entry. Figure 3 shows the update form to add or modify customer infor&shy;mation stored in the customer table of the database. The customer form contains the subroutines shown in Figure 4. If the user selects Search, a second form is displayed to provide search capability across the database. Users can enter any part of a customer name to display a list of customers, and then select the&nbsp;customer&nbsp;name&nbsp;for&nbsp;modification.&nbsp;Figure&nbsp;5&nbsp;shows&nbsp;the user interface for searching customer records, and Figure 6 lists the subroutines contained in the form.</p>
<p>
</p>
<p>
Figure 3  Update Form</p>
<p>
Figure 4  frmCustomer Subroutines</p>
<p>
Subroutine Name&#09;Description</p>
<p>
cmdFind_Click&#09;Find a single customer record from the database calling the LookupCustomer&shy;ByEmail method on the Customer object.</p>
<p>
cmdSearch_Click&#09;Open the frmCustomerSearch to allow user to select a customer from a list box.</p>
<p>
cmdClear_Click&#09;Clear all fields on a form.</p>
<p>
cmdAdd_Click&#09;Add a new customer to the database using the Add method on the Customer object.</p>
<p>
cmdSave_Click&#09;Save an existing customer using the Update method on the Customer object.</p>
<p>
cmdExit_Click&#09;Exit and end application</p>
<p>
FillFields&#09;Fill the fields on the form with the data from the recordset returned by the Find method.</p>
<p>
ClearFields&#09;Clear all the fields on the form.</p>
<p>
FindCustomer&#09;Find a customer in the database using the Find method on the Customer object.</p>
<p>
Form_KeyDown&#09;Executes code that implements the shortcut keys for the command buttons on the form. The KeyPreview property on the form is set to True causing the shortcuts (Alt-I) to be processed in this method. We did this because we used graphics on our command buttons without captions.</p>
<p>
<img src="mts5.gif" border=0></p>
<p>
Figure 5  Searching Customer Records</p>
<p>
Figure 6  frmCustomerSearch Subroutines</p>
<p>
cmdSearch_Click&#09;Search the customer database finding all last names matching the selection entered by using the LookupCustomerByLastName method on the Customer object.</p>
<p>
CmdSelect_Click&#09;Select a customer record from the list box and fill the customer form with the customer record by using the Find method on the Customer object.</p>
<p>
cmdExit_Click&#09;Hide the frmCustomerSearch form</p>
<p>
Form_KeyDown&#09;Executes code that implements the shortcut keys for the command buttons on the form. The KeyPreview property on the form is set to True causing the shortcuts (Alt-I) to be processed in this method. We did this because we used graphics on our command buttons without captions.</p>
<p>
Note that in the client code (see Figure 7), the ERROR_NUMBER constant is used for setting the error number in the application. The ERROR_<BR>NUMBER’s value is set to a value higher than the standard Visual Basic error numbers to avoid any conflicts, and can be used to generate application errors. The client code also contains a constant, strDSN, that points to the location of the DSN file used for this application. The DSN file is a text file that contains information about the database to be used for this application.</p>
<p>
Figure 7  Customer Maintenance Client</p>
<p>
CustomerMod.bas</p>
<p>
' we always return the same error number</p>
<p>
Public Const ERROR_NUMBER = vbObjectError + 0 </p>
<p>
Public Const strDSN = &quot;Classified.dsn&quot;</p>
<p>
Public g_strEmail as String</p>
<p>
frmCustomer.frm</p>
<p>
Option Explicit</p>
<p>
Dim objCustomer As MTS_Customers.Customers</p>
<p>
Private Sub Form_Load()</p>
<p>
   </p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    </p>
<p>
    Set objCustomer = CreateObject(&quot;MTS_Customers.Customers&quot;)</p>
<p>
    </p>
<p>
    Exit Sub</p>
<p>
ErrorHandler:</p>
<p>
    cmdExit_Click</p>
<p>
    MsgBox &quot;An error occurred in creating the Customer Component.&quot;</p>
<p>
End Sub</p>
<p>
Private Sub Form_KeyDown(KeyCode As Integer, Shift As Integer)</p>
<p>
    If Shift &lt;&gt; vbAltMask Then</p>
<p>
        Exit Sub</p>
<p>
    Else</p>
<p>
        Select Case KeyCode</p>
<p>
            Case vbKeyI</p>
<p>
                cmdFind_click</p>
<p>
            Case vbKeyR</p>
<p>
                cmdSearch_Click</p>
<p>
            Case vbKeyC</p>
<p>
                cmdClear_Click</p>
<p>
            Case vbKeyA</p>
<p>
                cmdAdd_Click</p>
<p>
            Case vbKeyS</p>
<p>
                cmdSave_Click</p>
<p>
            Case vbKeyX</p>
<p>
                cmdExit_Click</p>
<p>
        End Select</p>
<p>
    End If</p>
<p>
    </p>
<p>
End Sub</p>
<p>
Private Sub cmdSearch_Click()</p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    </p>
<p>
    frmCustomerSearch.Show vbModal, Me</p>
<p>
    </p>
<p>
    Exit Sub</p>
<p>
    </p>
<p>
ErrorHandler:</p>
<p>
    MsgBox &quot;An error occurred loading the customer search form.&quot;</p>
<p>
    </p>
<p>
End Sub</p>
<p>
Private Sub cmdFind_click()</p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    If txtEmail.Text = &quot;&quot; Then</p>
<p>
        MsgBox &quot;ERROR: Email is required to lookup customer.&quot;, , Me.Caption</p>
<p>
        txtEmail.SetFocus</p>
<p>
    Else</p>
<p>
        FindCustomer</p>
<p>
        txtEmail.SetFocus</p>
<p>
    End If</p>
<p>
    </p>
<p>
    Exit Sub</p>
<p>
    </p>
<p>
ErrorHandler:</p>
<p>
    </p>
<p>
    MsgBox &quot;An error occurred in finding the customer.&quot;</p>
<p>
    </p>
<p>
End Sub</p>
<p>
Private Sub cmdClear_Click()</p>
<p>
    ClearFields</p>
<p>
End Sub</p>
<p>
Private Sub cmdAdd_Click()</p>
<p>
    </p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    </p>
<p>
    objCustomer.Add strDSN, txtEmail, txtLastName, </p>
<p>
                    txtFirstName, txtAddress, txtCity, </p>
<p>
                    txtState, txtPostalCode, txtPhoneNumber</p>
<p>
    txtEmail.SetFocus</p>
<p>
    MsgBox &quot;Customer record has been added.&quot;, , Me.Caption</p>
<p>
    </p>
<p>
    Exit Sub</p>
<p>
ErrorHandler:</p>
<p>
    MsgBox &quot;ERROR: Your record was not added. This customer may already exist.&quot;,</p>
<p>
            , Me.Caption</p>
<p>
    txtEmail.SetFocus</p>
<p>
End Sub</p>
<p>
Private Sub cmdSave_Click()</p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    </p>
<p>
    If txtEmail &lt;&gt; &quot;&quot; Then</p>
<p>
        objCustomer.Update strDSN, txtEmail, txtLastName, </p>
<p>
                           txtFirstName, txtAddress, txtCity, </p>
<p>
                           txtState, txtPostalCode, txtPhoneNumber</p>
<p>
        txtEmail.SetFocus</p>
<p>
        MsgBox &quot;Customer record has been updated.&quot;, , Me.Caption</p>
<p>
    Else</p>
<p>
        Err.Raise ERROR_NUMBER, &quot;Email is required.&quot;</p>
<p>
    End If</p>
<p>
    </p>
<p>
    Exit Sub</p>
<p>
ErrorHandler:</p>
<p>
    </p>
<p>
    MsgBox &quot;ERROR: &quot; &amp; Err.Description &amp; &quot;. Customer record was not updated.&quot;, </p>
<p>
           , Me.Caption</p>
<p>
    txtEmail.SetFocus</p>
<p>
End Sub</p>
<p>
Private Sub cmdExit_Click()</p>
<p>
    End</p>
<p>
End Sub</p>
<p>
Public Sub FillFields(rsCustomer As ADODB.Recordset)</p>
<p>
    txtEmail.Text = rsCustomer!Email</p>
<p>
    txtLastName.Text = rsCustomer!LastName</p>
<p>
    txtFirstName.Text = rsCustomer!FirstName</p>
<p>
    txtAddress.Text = rsCustomer!Address</p>
<p>
    txtCity.Text = rsCustomer!City</p>
<p>
    txtState.Text = rsCustomer!State</p>
<p>
    txtPostalCode.Text = rsCustomer!PostalCode</p>
<p>
    txtPhoneNumber.Text = rsCustomer!PhoneNumber</p>
<p>
End Sub</p>
<p>
Private Sub ClearFields()</p>
<p>
    txtEmail.Text = &quot;&quot;</p>
<p>
    txtLastName.Text = &quot;&quot;</p>
<p>
    txtFirstName.Text = &quot;&quot;</p>
<p>
    txtAddress.Text = &quot;&quot;</p>
<p>
    txtCity.Text = &quot;&quot;</p>
<p>
    txtState.Text = &quot;&quot;</p>
<p>
    txtPostalCode.Text = &quot;&quot;</p>
<p>
    txtPhoneNumber.Text = &quot;&quot;</p>
<p>
End Sub</p>
<p>
Public Sub FindCustomer()</p>
<p>
    </p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    </p>
<p>
    Dim rsCustomer As ADODB.Recordset</p>
<p>
    Set rsCustomer = </p>
<p>
       objCustomer.LookupCustomerByEMail(strDSN, txtEmail.Text)</p>
<p>
    If rsCustomer.EOF = True And rsCustomer.BOF = True Then</p>
<p>
        MsgBox &quot;ERROR: No record was found.&quot;, , Me.Caption</p>
<p>
        Dim strEmail As String</p>
<p>
        strEmail = txtEmail.Text</p>
<p>
        ClearFields</p>
<p>
        txtEmail.Text = strEmail</p>
<p>
    Else</p>
<p>
        FillFields rsCustomer</p>
<p>
    End If</p>
<p>
    </p>
<p>
    Exit Sub</p>
<p>
ErrorHandler:</p>
<p>
    MsgBox &quot;Error in finding customer.&quot;</p>
<p>
    </p>
<p>
End Sub</p>
<p>
FrmCustomerSearch.frm</p>
<p>
Option Explicit</p>
<p>
Dim arrCustomerEmail() As String</p>
<p>
Dim objCustomer As MTS_Customers.Customers</p>
<p>
Private Sub cmdSelect_Click()</p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    If lstCustomers.ListIndex &lt; 0 Then</p>
<p>
        MsgBox &quot;No customer has been selected.&quot;</p>
<p>
        txtSearch.SetFocus</p>
<p>
        Exit Sub</p>
<p>
    End If</p>
<p>
    </p>
<p>
    g_strEmail = arrCustomerEmail(lstCustomers.ListIndex)</p>
<p>
    Me.Hide</p>
<p>
    frmCustomers.Show</p>
<p>
    frmCustomers.txtEmail.SetFocus</p>
<p>
    </p>
<p>
    Exit Sub</p>
<p>
    </p>
<p>
ErrorHandler:</p>
<p>
    </p>
<p>
    MsgBox &quot;An error occurred in selecting the customer record&quot;</p>
<p>
End Sub</p>
<p>
Private Sub Form_KeyDown(KeyCode As Integer, Shift As Integer)</p>
<p>
    </p>
<p>
    If Shift &lt;&gt; vbAltMask Then</p>
<p>
        Exit Sub</p>
<p>
    Else</p>
<p>
        Select Case KeyCode</p>
<p>
            Case vbKeyR</p>
<p>
                cmdSearch_Click</p>
<p>
            Case vbKeyX</p>
<p>
                cmdExit_Click</p>
<p>
        End Select</p>
<p>
    End If</p>
<p>
    </p>
<p>
End Sub</p>
<p>
Private Sub cmdExit_Click()</p>
<p>
    Me.Hide</p>
<p>
End Sub</p>
<p>
Private Sub cmdSearch_Click()</p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    </p>
<p>
    Dim strListData As String</p>
<p>
    Dim rsCustomer As ADODB.Recordset</p>
<p>
    </p>
<p>
        lstCustomers.Clear</p>
<p>
        Set rsCustomer = </p>
<p>
           objCustomer.LookupCustomerByLastName</p>
<p>
             (strDSN, txtSearch.Text)</p>
<p>
        </p>
<p>
        Dim i  As Integer</p>
<p>
        i = 0</p>
<p>
        Do Until rsCustomer.EOF</p>
<p>
            lstCustomers.AddItem rsCustomer!LastName &amp; &quot;, </p>
<p>
                   &quot; &amp; rsCustomer!FirstName</p>
<p>
            ReDim Preserve arrCustomerEmail(i)</p>
<p>
            arrCustomerEmail(i) = rsCustomer!Email</p>
<p>
            i = i + 1</p>
<p>
            rsCustomer.MoveNext</p>
<p>
        Loop</p>
<p>
        </p>
<p>
        Exit Sub</p>
<p>
        </p>
<p>
ErrorHandler:</p>
<p>
    </p>
<p>
        MsgBox &quot;An error occurred in search for customer.&quot;</p>
<p>
        </p>
<p>
End Sub</p>
<p>
Private Sub Form_Load()</p>
<p>
    </p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    </p>
<p>
    Set objCustomer = CreateObject(&quot;MTS_Customers.Customers&quot;)</p>
<p>
    </p>
<p>
    Exit Sub</p>
<p>
ErrorHandler:</p>
<p>
    cmdExit_Click</p>
<p>
    MsgBox &quot;An error occurred in creating the Customer Component.&quot;</p>
<p>
End Sub</p>
<p>
So, what else do you need to do to make MTS work with a Win32 client? This is the best part: there is nothing specific about a client communicating directly with an MTS middle-tier server other than meeting the standard ActiveX client programming requirements.</p>
<h2>Customer Server Component</h2>
<p>
On the server, the sample application contains a single component,&nbsp;MTS_Custo&shy;mers.Customers,&nbsp;that&nbsp;handles access and update requests from the client. The server Customer component is a middle-tier object that uses methods for finding, adding, and updating customer information in a database. The Customer component uses the “Requires a transaction” setting (we’ll tell you how to set this property in the MTS Explorer later), which means that all work done in the component will be protected by a transaction. The component can run in a transaction all by itself or may also be called as part of a larger transaction. The component itself only needs to care about its own work.</p>
<p>
The component will essentially place its “vote” on the outcome of the transaction based on the success or failure of its own work. If the component is happy with the outcome, it will execute an MTS method to commit the transaction. Otherwise, the component will execute an MTS method to abort the transaction. The important point here is that the component does not ever need to know about what the other components are doing or the outcome of their work. Figure 8 shows the methods used in the Customer object. (See the “MTS Transactions” sidebar for a more detailed discussion.)</p>
<p>
Figure 8  Customer Object Methods</p>
<p>
Method Name&#09;Description</p>
<p>
LookupCustomerByLastName&#09;Given all or part of a customer last name, return a customer recordset containing all matching records found.</p>
<p>
LookupCustomerByEMail&#09;Given a customer email address, return a customer recordset containing one customer.</p>
<p>
Add&#09;Add a customer record.</p>
<p>
Update&#09;Update a customer record.</p>
<p>
The first part of the server component sets the return value of the method Lookup&shy;CustomerByLastName to ADODB.Recordset because we are going to remote a record&shy;set back to the client. Note that we pass in the file&shy;DSN for&nbsp;the database. By using the fileDSN, you can avoid hard&shy;coding system DSN information into your program. </p>
<p>
Option Explicit</p>
<p>
Public Const ERROR_NUMBER= </p>
<p>
  vbObjectError + 0 </p>
<p>
' we always return the </p>
<p>
' same error number</p>
<p>
Option Explicit</p>
<p>
Public Function   </p>
<p>
  LookupCustomerByLastName</p>
<p>
  (ByVal fileDSN As String, </p>
<p>
   ByVal vLastName) As ADODB.Recordset</p>
<p>
First, we need to get a reference to an object context for our server component. The object context is an intrinsic MTS runtime component that stores data specific to a component instance (including security and transaction information). ObjectContext also exposes methods that make up the MTS programming model. </p>
<p>
   Dim objContext As </p>
<p>
      ObjectContext</p>
<p>
   Set objContext = </p>
<p>
      GetObjectContext</p>
<dl>
<dt>
    </dt>
<dd>
   On Error GoTo <p>
      ErrorHandler</p>
</dd>
</dl>
<p>
We set the cursor location property on the customer recordset to the value adUse&shy;ClientBatch so the recordset can be remoted back to the client. We then use a standard SQL query on the database to pull records of customers with the specified last name. </p>
<p>
We use SetComplete on objContext to indicate to MTS that we are finished with this piece of work and no longer need the state in this component. This means a component can be returned to its initial state for future method invocations. Note that we have not written any explicit code supporting transactions. The MTS runtime environment handles transaction support if you specify (in the MTS Explorer) that your components require transactions. We’ll show you how to assign transactional settings when we deploy the Customer Maintenance package.</p>
<p>
SetComplete also tells the MTS runtime that any resource manager changes can be committed. SetAbort tells the MTS runtime that the component is done with its work, but that any resource manager changes should be rolled back (aborted). If this component was part of a larger transaction, then the changes would be committed when <BR>all the components had completed their work successfully (see Figure 9).</p>
<dl>
<dt>
Figure 9  LookupCustomerByLastName Method</dt>
<dd>
Public Function LookupCustomerByLastName<p>
  (ByVal fileDSN As String, ByVal vLastName) As Variant   </p>
<p>
    Dim m_objContext As ObjectContext</p>
<p>
    Set m_objContext = GetObjectContext</p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
' Get customer information</p>
<p>
    Dim rsCustomer As New ADODB.Recordset</p>
<p>
    Dim strSQL As String</p>
<p>
    strSQL = &quot;SELECT FULLNAME = (RTrim(LastName) + ', </p>
<p>
             ' + RTrim(FirstName)),LastName, FirstName, </p>
<p>
             Address, City, State, PostalCode, PhoneNumber, </p>
<p>
             EMail FROM Customers Where LastName Like '&quot; &amp; </p>
<p>
             vLastName &amp; &quot;%' ORDER BY FULLNAME For Browse&quot;</p>
<p>
    rsCustomer.CursorLocation = adUseClientBatch</p>
<p>
    rsCustomer.Open strSQL, &quot;FILEDSN=&quot; &amp; fileDSN</p>
<p>
    ' Cleanup object on the way out</p>
<p>
    objContext.SetComplete</p>
<p>
    </p>
<p>
    Set LookupCustomerByLastName = rsCustomer   </p>
<p>
    Exit Function</p>
<p>
    </p>
<p>
ErrorHandler:   </p>
<p>
    ' Cleanup object on the way out</p>
<p>
    objContext.SetAbort</p>
<p>
    Err.Raise Number:=ERROR_NUMBER, </p>
<p>
      Source:=&quot;MTS_Customers.Customers.LookupCustomerByLastName&quot;, </p>
<p>
      Description:=Err.Description</p>
<p>
        </p>
<p>
End Function</p>
</dd>
</dl>
<p>
Next, we implement the LookupCustomerByEMail method (see Figure 10), which checks the database for a specified email string and returns a recordset to the client. To add a customer to the database, we use the Add method, which takes a number of parameters. To avoid expensive network round-trips, we recommend that you pass parameters instead of setting properties on the object.</p>
<dl>
<dt>
Figure 10  LookupCustomerByEMail Method</dt>
<dd>
Public Function LookupCustomerByEMail<p>
  (ByVal fileDSN As String, ByVal vEmail) As ADODB.Recordset</p>
<p>
    </p>
<p>
    </p>
<p>
    Dim objContext As ObjectContext</p>
<p>
    Set objContext = GetObjectContext</p>
<p>
    </p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    </p>
<p>
    ' Get customer information</p>
<p>
    Dim rsCustomer As New ADODB.Recordset</p>
<p>
    Dim strSQL As String</p>
<p>
    </p>
<p>
    strSQL = &quot;Select * from Customers where Email ='&quot; &amp; vEmail &amp; &quot;'&quot;</p>
<p>
    rsCustomer.CursorLocation = adUseClientBatch</p>
<p>
    rsCustomer.Open strSQL, &quot;FILEDSN=&quot; &amp; fileDSN</p>
<p>
    </p>
<p>
    ' Cleanup object on the way out</p>
<p>
    objContext.SetComplete</p>
<p>
    </p>
<p>
    ' all went well -- return the customer</p>
<p>
    Set LookupCustomerByEMail = rsCustomer</p>
<p>
    </p>
<p>
    Exit Function</p>
<p>
    </p>
<p>
ErrorHandler:</p>
<p>
    </p>
<p>
    ' Cleanup object on the way out</p>
<p>
    objContext.SetAbort</p>
<p>
    Err.Raise Number:=ERROR_NUMBER, </p>
<p>
              Source:=&quot;MTS_Customers.Customers.LookupCustomerByEMail&quot;, </p>
<p>
              Description:=Err.Description</p>
<p>
    </p>
<p>
End Function</p>
</dd>
</dl>
<p>
We use a Connection component because we are not going to be returning a recordset to the client (see Figure 11). The Update method is very similar to the Add method. Again, we use the Connection component (see Figure 12). </p>
<dl>
<dt>
Figure 11  Adding a Customer</dt>
<dd>
Public Sub Add(ByVal fileDSN, ByVal strEMail As String, <p>
               ByVal strLastName As String, </p>
<p>
               ByVal strFirstName As String, </p>
<p>
               ByVal strAddress As String, </p>
<p>
               ByVal strCity As String, ByVal strState As String, </p>
<p>
               ByVal strPostalCode As String, ByVal strPhone As String)</p>
<p>
    </p>
<p>
    Dim objContext As ObjectContext</p>
<p>
    Set objContext = GetObjectContext</p>
<p>
    </p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    Dim strSQL As String</p>
<p>
    Dim Conn As New ADODB.Connection</p>
<p>
    strSQL = &quot;INSERT Customers(Email, LastName, FirstName, </p>
<p>
             'Address, City, State, PostalCode, PhoneNumber) </p>
<p>
             VALUES ('&quot; &amp; strEMail &amp; &quot;', '&quot; &amp; strLastName &amp; &quot;', </p>
<p>
             '&quot; &amp; strFirstName &amp; &quot;', '&quot; &amp; strAddress &amp; &quot;', </p>
<p>
             '&quot; &amp; strCity &amp; &quot;', '&quot; &amp; strState &amp; &quot;', </p>
<p>
             '&quot; &amp; strPostalCode &amp; &quot;', '&quot; &amp; strPhone &amp; &quot;')&quot;</p>
<p>
    Conn.Open &quot;FILEDSN=&quot; &amp; fileDSN, &quot;&quot;, &quot;&quot;</p>
<p>
    Conn.Execute strSQL</p>
<p>
    </p>
<p>
    objContext.SetComplete</p>
<p>
    </p>
<p>
    Exit Sub</p>
<p>
ErrorHandler:</p>
<p>
    </p>
<p>
    ' Cleanup object on the way out</p>
<p>
    objContext.SetAbort</p>
<p>
    Err.Raise Number:=ERROR_NUMBER, </p>
<p>
              Source:=&quot;MTS_Customers.Customers.Customers.Add&quot;, </p>
<p>
              Description:=Err.Description</p>
<p>
End Sub</p>
<br>
</dd>
<dt>
Figure 12  Update Method</dt>
<dd>
Public Sub Update(ByVal fileDSN, ByVal strEMail As String, <p>
                  ByVal strLastName As String, </p>
<p>
                  ByVal strFirstName As String, </p>
<p>
                  ByVal strAddress As String, </p>
<p>
                  ByVal strCity As String, </p>
<p>
                  ByVal strState As String, </p>
<p>
                  ByVal strPostalCode As String, </p>
<p>
                  ByVal strPhone As String)</p>
<p>
    </p>
<p>
    Dim objContext As ObjectContext</p>
<p>
    Set objContext = GetObjectContext</p>
<p>
    </p>
<p>
    On Error GoTo ErrorHandler</p>
<p>
    Dim strSQL As String</p>
<p>
    Dim Conn As New ADODB.Connection</p>
<p>
    strSQL = &quot;Update Customers Set &quot; &amp; &quot;LastName = '&quot; &amp;</p>
<p>
             strLastName &amp; &quot;', &quot; &amp; &quot;FirstName = '&quot; &amp; </p>
<p>
             strFirstName &amp; &quot;', &quot; &amp; &quot;Address = '&quot; &amp; </p>
<p>
             strAddress &amp; &quot;', &quot; &amp; &quot;City = '&quot; &amp; strCity &amp; </p>
<p>
             &quot;', &quot; &amp; &quot;State = '&quot; &amp; strState &amp; &quot;', &quot; &amp; </p>
<p>
             &quot;PostalCode = '&quot; &amp; strPostalCode &amp; &quot;', &quot; &amp; </p>
<p>
             &quot;PhoneNumber = '&quot; &amp; strPhone &amp; &quot;' &quot; &amp; </p>
<p>
             &quot;Where Email = '&quot; &amp; strEMail &amp; &quot;'&quot;</p>
<p>
    Conn.Open &quot;FILEDSN=&quot; &amp; fileDSN, &quot;&quot;, &quot;&quot;</p>
<p>
    Conn.Execute strSQL</p>
<p>
    </p>
<p>
    objContext.SetComplete</p>
<p>
    </p>
<p>
    Exit Sub</p>
<p>
ErrorHandler:</p>
<p>
    </p>
<p>
    ' Cleanup object on the way out</p>
<p>
    objContext.SetAbort</p>
<p>
    Err.Raise Number:=ERROR_NUMBER, </p>
<p>
              Source:=&quot;MTS_Customers.Customers.Customers.Update&quot;, </p>
<p>
              Description:=Err.Description</p>
<p>
End Sub</p>
<br>
</dd>
<dt>
You’ve probably noticed a general pattern in the implementation of each of the methods in the Customer server component—each method shares the following infrastructure in the code:</dt>
<dd>
Public Sub DoWork()<br>
</dd>
<dt>
    </dt>
<dd>
    Dim objContext As ObjectContext<p>
    Set objContext = GetObjectContext</p>
<br>
</dd>
<dt>
    </dt>
<dd>
    ' Do work.<br>
</dd>
<dt>
    </dt>
<dd>
    ' Everything okay.<br>
</dd>
<dt>
    </dt>
<dd>
    objContext.SetComplete<br>
</dd>
<dt>
    </dt>
<dd>
    Exit Sub<p>
ErrorHandler:</p>
<p>
    ' Cleanup object on the way out</p>
<p>
    objContext.SetAbort</p>
<p>
    ' Report Error information</p>
<p>
End Sub</p>
</dd>
</dl>
<p>
In general, the majority of MTS application methods can be written for MTS components by following these steps: 
<ol>
<li>
Get the MTS ObjectContext.<br><br></li>
<li>
Do work.<br><br></li>
<li>
If there is no error, tell MTS you are done and consistent using ObjectContext.SetComplete.<br><br></li>
<li>
Otherwise&nbsp;(Error),&nbsp;tell MTS you are done and are incon&shy;sistent using ObjectContext.SetAbort.</li>
</ol>
<p>
The Customer component is a simple but complete representation of a typical MTS component. We did not include the methods associated with creating subcomponents or programmatic security in this sample. (A discussion of Just-In-Time activation appears in the “Just-In-Time Activation” sidebar.)</p>
<h2>Preparing for Deployment</h2>
<p>
When building your application, think about development and deployment as two separate stages. Applications are partitioned into package files and then deployed and administered by the MTS Explorer. A package is an abstraction-representing component associated by security and fault isolation as well as a physical file format. The package file contains component and application information. The package file and corresponding component DLLs represent the deploy&shy;able unit, which is distributed to one or more middle-tier server machines. Note that an MTS application can consist of one or more packages, just as a package can contain one or more components.</p>
<p>
When creating an MTS application, you should carefully consider the design and deployment implications for package topology, partitioning of components across packages, package security configuration, and property configuration per component (such as transactions or security).  The “Package Design” sidebar gives you a few pointers for designing your package application topology.</p>
<p>
Opening the MTS Explorer, we selected the Packages Installed folder in the MTS Explorer&nbsp;hierarchy&nbsp;and started the Package Wizard by selecting File|New. Figure 13 illustrates how you can either create a new package or install a prebuilt package (such as a package provided by a third-party developer).</p>
<p>
<img src="mts13.gif" border=0></p>
<p>
Figure 13  Package Wizard</p>
<p>
After we created and named the new package, we installed&nbsp;the&nbsp;MTS_Custo&shy;mer.DLL file into the package as a component. The MTS Explorer has an Install Component Wizard that walks you through the installation of a component (see Figure 14). You can also drag and drop your DLL into the component pane of the MTS Explorer to add a component to a package (see Figure 15). </p>
<p>
<img src="mts14.gif" border=0></p>
<p>
Figure 14  Component Wizard</p>
<p>
</p>
<p>
Figure 15  Adding a component to a package</p>
<p>
After we set up our package, we right-clicked on the new component in the package to bring up the Properties page, which allows you to define transaction support, security, and activation. We set the transactions setting to “Requires a transaction” so that our component will automatically start a new transaction if one doesn’t already exist (see Figure 16). Note here that selecting a single radio button on a property page enables transactions in your component. You don’t have to write any code to define the scope of a transaction, such as Begin Transaction or End Transaction, because that functionality is built into MTS, just like declarative security and a number of other features. </p>
<p>
<img src="mts16.gif" border=0></p>
<p>
Figure 16  Component Property Page</p>
<p>
Once we set up our package, we used the export function in the MTS Explorer to export that package to a local directory. This generates a subdirectory called clients that contains a client install executable (see Figure 17). You can distribute that client executable through a share, a Web page, or email. </p>
<p>
<img src="mts17.gif" border=0></p>
<p>
Figure 17  The Client Subdirectory</p>
<h2>Deploying the  Application</h2>
<p>
The Customer Maintenance sample application consists of five files (not including database configuration). On the client side, both Customer&shy;Maint.exe and Customers.exe are deployed to a set of client machines. MTS handles the configuration of client applications for server packages, while the distributor is responsible for delivering the client executable to users. When the user runs Cus&shy;tomers.exe, the client install file will configure the client machine to activate the Customer component on a remote server.</p>
<p>
Note that the current implementation of client install configures the remote server as the server machine that created the package. Alternatively, you can use the DCOM configuration utility (DCOMCNFG.EXE) to modify the remote server to which the client connects. </p>
<p>
The other two files, MTS_Customer.dll and Custo&shy;mers.pak, are deployed to <BR>one or more server machines. You can distribute these server components across multiple servers and statically bind specific client machines to specific servers. Balancing the load across several server machines increases app&shy;lication performance and scalability.</p>
<p>
Once Customers.pak and MTS_Customer.dll are physically on or accessible from the server machine, the MTS Explorer can be used to install the Customers package in-to MTS. The MTS Explorer provides remote administration, so packages can be deployed across several servers from a single instance of MTS Explorer.</p>
<p>
If you used declarative security on your application, the next step in setting up the MTS server is to configure each security role defined in the Customer package with specific Windows NT users and groups. Package developers are encouraged to provide documentation for those deploying MTS applications (specifically, detailed information on security roles and call authorization between components and component interfaces). If a package does not contain documentation about security roles, you can use the MTS Explorer to browse role information.</p>
<h4> </h4>
<h2>Monitoring the Application</h2>
<p>
You can also use the MTS Explorer to monitor your applications. After you have deployed the Customer Maintenance application across a set of clients and servers, you can review activity on one or more servers. The component status view provides information per component:</p>
<p>
<b>Objects</b> The total number of objects that have been allocated within the server process.</p>
<p>
<b>Activated</b> The total number of objects being used by clients.</p>
<p>
<b>In&nbsp;Call&nbsp;</b>The<b>&nbsp;</b>total<b>&nbsp;</b>number<b>&nbsp;</b>of<b>&nbsp;</b>ob&shy;jects<b>&nbsp;</b>that<b>&nbsp;</b>are<b>&nbsp;</b>currently<b>&nbsp;</b>executing a client call.</p>
<p>
In addition to component status, you can monitor transaction status using the Transaction Statistics view (see Figure 18). Statistics include current active transactions, total&nbsp;&nbsp;committed&nbsp;transactions,&nbsp;and&nbsp;total&nbsp;aborted&nbsp;transactions.</p>
<p>
<img src="mts18.gif" border=0></p>
<p>
Figure 18  Transaction Statistics</p>
<h2>Conclusion</h2>
<p>
We just stepped through the implementation, packaging, and deployment of a simple three-tier MTS application. To really learn what MTS is all about, what problems it solves, and what issues it raises, you must build an MTS application on your own. Start out with an application that is not critical-path for your business, but performs a specific business function. We recommend starting a “3-2-1”effort, meaning that you identify a business application that can be implemented using a three-tier architecture, using two people, in one month. This will get you comfortable with MTS and by the end of the project you will have assembled a working enterprise application.</p>
<p>
If&nbsp;you&nbsp;don’t&nbsp;already&nbsp;have&nbsp;MTS&nbsp;1.0,&nbsp;you&nbsp;can&nbsp;download&nbsp;an&nbsp;eval&shy;uation&nbsp;copy&nbsp;from http://www.microsoft.com/transaction/. Try it for yourself and see what the developer community is beginning to realize: if you’re not using MTS, you’re coding more than you should for server applications.                  u</p>
<p>
An MTS Glossary</p>
<p>
<b>ActiveX </b>A set of technologies that enables software components to interact with one another in a networked environment, regardless of the language in which they were created. ActiveX is built on the Component Object Model (COM).</p>
<p>
<b>Administrator </b>One who uses the Microsoft Transaction Server (MTS) Explorer to install, configure, and manage MTS components and packages. </p>
<p>
<b>Business rule </b>The combination of validation edits, logon verifications, database lookups, policies, and algorithmic transformations that constitute an enterprise’s way of doing business. Also known as business logic.</p>
<p>
<b>Catalog </b>The MTS data store that maintains configuration information for components, packages, and roles. The catalog is administered by using the MTS Explorer. </p>
<p>
<b>Client </b>An application or process that requests a service from some process or component.</p>
<p>
<b>COM (Component Object Model)</b> An open architecture for cross-platform development of client/server applications based on object-oriented technology. Clients have access to an object through interfaces implemented on the object. COM is language-neutral, so any language that produces ActiveX components can also produce COM applications. </p>
<p>
<b>Component </b>A discrete unit of code built on ActiveX technologies that delivers a well-specified set of services through well-specified interfaces. Components provide the objects that clients request at runtime.</p>
<p>
<b>Concurrency </b>The appearance of simultaneous execution of processes or transactions by interleaving the execution of multiple pieces of work.</p>
<p>
<b>Context </b>The state that is implicitly associated with a given MTS object. The context contains information about the object’s execution environment, such as the identity of the object’s creator and, optionally, the transaction encompassing the work of the object. An object’s context is similar in concept to the process context that an operating system maintains for an executing program. The MTS runtime environment manages a context for each object.</p>
<p>
<b>Declarative security </b>The security that is configured with the MTS Explorer. Access to packages, components, and interfaces is controlled by defining roles. Roles determine which users are allowed to invoke interfaces in a component. See also programmatic security.</p>
<p>
<b>Distributed COM (DCOM) </b>DCOM is an object protocol that enables ActiveX components to communicate directly with each other across a network. DCOM is language-neutral, so any language that produces ActiveX components can also produce DCOM applications.</p>
<p>
<b>Data source name (DSN) </b>The name that applications use to request a connection to an ODBC data source.</p>
<p>
<b>Dynamic-link library (DLL) </b>A file that contains one or more functions that are compiled, linked, and stored separately from the processes that use them. The operating system maps the DLLs into the address space of the calling process when the process is starting or while it’s running. </p>
<p>
<b>Identity </b>A package property that specifies the user accounts that are allowed to access the package. It can be a specific user account or a group of users within a Windows NT domain.</p>
<p>
<b>In-doubt transaction </b>A transaction that has been prepared but hasn’t received a decision to commit or abort because the server coordinating the transaction is unavailable.</p>
<p>
<b>In-process component </b>A component that runs in a client’s process space. This is typically a DLL.</p>
<p>
<b>Just-In-Time activation </b>The ability for an MTS object to be activated only as needed for executing requests from its client. Objects can be deactivated even while clients hold references to them, allowing otherwise idle server resources to be used more productively.</p>
<p>
<b>Interface </b>A group of logically related operations or methods that provides access to a component object.</p>
<p>
<b>MTS component </b>A COM component that executes in the MTS runtime environment. An MTS component must be a DLL, implement a class factory to create objects, and describe all of the component’s interfaces in a type library for standard marshaling.</p>
<p>
<b>Microsoft Distributed Transaction Coordinator (DTC) </b>A transaction manager that coordinates transactions that span multiple resource managers. Work can be committed as an atomic transaction even if it spans multiple resource managers, potentially on separate computers. </p>
<p>
<b>MTS Explorer</b> A graphical user interface used to configure and manage MTS components within a distributed computer network.</p>
<p>
<b>MTS object</b> A COM object that executes in the MTS runtime environment and follows the MTS programming and deployment model. </p>
<p>
<b>ODBC resource dispenser</b> A resource dispenser that manages pools of database connections for MTS components that use the standard ODBC programming interfaces. </p>
<p>
<b>Out-of-process component </b>A component that runs in a separate process space from its client. MTS enables components implemented as DLLs to be used out-of-process from the client by loading the components into surrogate server processes. </p>
<p>
<b>Package </b>A set of components that perform related application functions. All components in a package run together in the same MTS server process. A package is a trust boundary that defines when security credentials are verified. It’s also a deployment unit for a set of components. The MTS Explorer can create packages.</p>
<p>
<b>Package file </b>A file that contains information about the components and roles of a package. A package file is created using the package export function of the MTS Explorer. When a package is created, the associated component files (DLLs, type libraries, and proxy-stub DLLs, if implemented) are copied to the same directory where the package file was created.</p>
<p>
<b>Pooling </b>A performance optimization based on using collections of pre-allocated resources, such as objects or database connections. Pooling results in more efficient resource allocation.</p>
<p>
<b>Programmatic security </b>The procedural logic provided by a component to determine if a client is authorized to perform the requested operation. See also declarative security.</p>
<p>
<b>Resource dispenser </b>A service that provides the synchronization and management of nondurable resources within a process, providing for simple and efficient sharing by MTS objects. For example, the ODBC resource dispenser manages pools of database connections.</p>
<p>
<b>Resource Dispenser Manager</b> A DLL that coordinates work among a collection of resource dispensers.</p>
<p>
<b>Resource manager </b>A system service that manages durable data. Server applications use resource managers<i> </i>to maintain the durable state of the application, such as the record of inventory on hand, pending orders, and accounts receivable. The resource managers work in cooperation with the transaction manager to provide the application with a guarantee of atomicity<i> </i>and<i> </i>isolation (using the two-phase commit protocol). Microsoft SQL Server is an example of a resource manager. </p>
<p>
<b>Role </b>A symbolic name that defines a class of users for a set of components. Each role defines which users are allowed to invoke interfaces on a component.</p>
<p>
<b>Remote component </b>A component used by a client on a different computer.</p>
<p>
<b>Server process </b>A process that hosts MTS components. An MTS component can be loaded into a surrogate server process, either on the client’s computer (local) or on another computer (remote). It can also be loaded into a client application process (in-process).</p>
<p>
<b>Shared property </b>A variable that is available to all objects in the same server process via the Shared Property Manager. The value of the property can be any type that can be represented by a variant. </p>
<p>
<b>Stateful object </b>An object that holds private state accumulated from the execution of one or more client calls.</p>
<p>
<b>Stateless object </b>An object that doesn’t hold private state accumulated from the execution of one or more client calls.</p>
<p>
<b>Transaction </b>A unit of work that is done as an atomic operation—that is, the operation succeeds or fails as a whole. </p>
<p>
<b>Transaction context </b>An object used to allow a client to dynamically include one or more objects in one transaction.</p>
<p>
<b>Transaction manager </b>A system service responsible for coordinating the outcome of transactions in order to achieve atomicity. The transaction manager ensures that the resource managers reach a consistent decision on whether the transaction should commit or abort. </p>
<p>
<b>Two-phase commit </b>A protocol ensuring that transactions applying to more than one server are completed on all servers or none at all. Two-phase commit is coordinated by the transaction manager and supported by resource managers. </p>
<dl>
<dt>
MTS Transactions</dt>
<dd>
Microsoft&nbsp;Transaction&nbsp;Server&nbsp;simplifies&nbsp;the&nbsp;task&nbsp;of&nbsp;devel&shy;op&shy;ing&nbsp;application components by letting you perform work with transactions. This protects applications from anomalies caused by concurrent updates or system failures.<p>
Transactions maintain the following properties, together known as ACID:
<ul>
<li>
Atomicity ensures that all the updates completed under a specific transaction are committed (and made durable) or that they get aborted and rolled back to their previous state.<br><br></li>
<li>
Consistency means that a transaction is a correct trans&shy;formation&nbsp;of the&nbsp;system state,&nbsp;preserving&nbsp;the&nbsp;state invariants.<br><br></li>
<li>
Isolation protects concurrent transactions from seeing each other’s partial and uncommitted results, which might create inconsistencies in the application state. Resource managers use transaction-based synchronization protocols to isolate the uncommitted work of active transactions.<br><br></li>
<li>
Durability means that committed updates to managed resources (such as a database record) survive failures, including communication failures, process failures, and server system failures.</li>
</ul>
<p>
Transactional logging even allows you to recover the durable state after disk media failures. The intermediate states of a transaction aren’t visible outside the transaction, and either all of the work happens or none of it does. This allows you to develop application components as if each transaction executes sequentially and without regard to concurrency. This is a tremendous simplification for application developers.</p>
<p>
If you declare that a component is transactional, MTS associates transactions with the component’s objects. When an object’s method is executed, the services that resource managers and resource dispensers perform on its behalf execute under a transaction. This can also include work that it performs for other MTS objects. Work from multiple objects can be composed into a single atomic transaction. In our Customer Maintenance sample application our component is transactional.</p>
</dd>
</dl>
<p>Transaction Attributes</p>
<p>
Every MTS component has a transaction attribute that is recorded in the MTS catalog. MTS uses this attribute during object creation to determine whether a new transaction should be created for the object, whether the object should use the object creator’s transaction, or whether the object should run without a transaction. Components that access transactional resources (for example, database records) can ensure that their objects are always created within a transaction. If the object is created from a context that has a transaction, the new context inherits that transaction; otherwise, the system automatically initiates a transaction.</p>
<p>
You can set components that perform non-database work (such as calculations) to support, but not require, transactions. If this component is called and a transaction has already been started, then the work of the component can participate in the transaction. If the non-database work of the component fails, the transaction would fail and any other database work that other components had done would be rolled back.</p>
<p>
Resource dispensers can use the context object to provide transaction-based services to the MTS object. For example, when an object executing within a transaction allocates a database connection by using the ODBC resource dispenser, the connection is automatically enlisted on the transaction. All database updates using this connection become part of the transaction, and are either atomically committed or aborted.</p>
<p>How Objects Can Participate</p>
<p>
The IObjectContext interface has methods that enable an MTS object to participate in determining a transaction’s outcome. The SetComplete, SetAbort, DisableCommit, and EnableCommit methods work in conjunction with the component’s transaction attribute to allow one or more objects&nbsp;to&nbsp;be&nbsp;simply&nbsp;and&nbsp;safely&nbsp;composed&nbsp;within&nbsp;transactions.
<ul>
<li>
SetComplete indicates that the object has successfully completed its work for the transaction. The object is deactivated upon return from the method that first entered the context.<br><br></li>
<li>
SetAbort indicates that the object’s work can never be committed. The object is deactivated upon return from the method that first entered the context.<br><br></li>
<li>
EnableCommit indicates that the object’s work isn’t necessarily done, but that its transactional updates can be committed in their current form.<br><br></li>
<li>
DisableCommit indicates that the object’s transactional updates can’t be committed in their current form.</li>
</ul>
<p>
Both SetComplete and SetAbort deactivate the object on return from the method. The object is reactivated on the next call that requires object execution.</p>
<p>
Objects that need to retain state across multiple calls from a client can protect themselves from having their work committed prematurely by the client. By calling DisableCommit before returning control to the client, the object can guarantee that its transaction cannot be successfully committed without the object doing its remaining work and calling EnableCommit.</p>
<dl>
<dt>
Just-In-Time Activation</dt>
<dd>
Traditionally, when you design applications, you have two options for how to handle your object. The first option is for a client to create, use, and release an object. The next time it needs the object, it creates it again. This kind of object maintains state only across method invocation. The second option is for a client to create an object and hold onto it until the client no longer needs it. These objects maintain state for the object’s lifetime.<p>
When you use stateless components, you conserve server resources. However, as your application scales to more users, the performance of your application may decline. If the object is on a remote computer, there must be a network round-trip each time an object is created, which degrades performance. Objects that maintain state boost performance for an application with a small number of users, but are extremely expensive in terms of server resources in a large-scale application. While either of these approaches might be adequate for a small-scale application, as your application scales up, they’re both inefficient. With MTS, Just-In-Time activation provides the best of both approaches while avoiding the disadvantages of each.</p>
<p>
For example, in the Customer Maintenance sample application, the Customer client controls the Customer server object’s life cycle. Clients hold onto server resources even when they are idle. As more clients are added, there will be a proportional increase in the number of allocated objects and database connections. A Customer object doesn’t need to maintain any private state to correctly process new requests from its client, nor does it need to maintain its database connection between calls. The main problem in this scenario is that the MTS runtime environment can’t reclaim the object’s resources until the client explicitly releases the object. If you have to depend on your clients to manage your object’s resources, you can’t build a scalable component.</p>
<p>
We implemented Just-In-Time activation in the Customer server component by adding a few lines of code. When the Customer object calls SetComplete, the component notifies the MTS runtime environment that it should be deactivated as soon as it returns control to the client. This allows the MTS runtime environment to release the object’s resources, including any database connection it holds prior to the object’s release. The Customer client continues to hold a reference to the deactivated Customer object. Just-In-Time activation allows you to conserve system resources while allowing your application to scale to multiple users.</p>
<br>
</dd>
<dt>
Package Design</dt>
<dd>
MTS introduces packages as an application file unit, and it may not be immediately obvious how to partition your application across MTS packages. Here are a few points to consider when designing your package application topology.<p>
Fault Isolation By default, components sharing the same package will share the same server process. (A server process is a system process that hosts application component execution.) Note that there are exceptions <BR>to this, depending on your activation settings. Fault isolation can be achieved by placing components in different packages, since each package runs in a separate server process. For example, you may be hosting an online sports score Web site with components written for each major sport (basketball, soccer, and so on). When you bring a new sport online (such as telemark extreme skiing), isolate your telemark component in its own package. If the telemark component causes an access violation, the failure will not affect the other sporting event components that are running in one or more different server processes.</p>
<p>
Activation Currently, activation settings exist at the component level:</p>
<p>
Ý In the creator’s process</p>
<p>
Ý In a server process on this computer</p>
<p>
Ý In a server process on a remote computer</p>
<p>
We recommend that developers avoid using remote as a setting because MTS provides a simpler way of setting up remote components using the Remote Computer and Remote Component folders in the MTS Explorer hierarchy. For more information about pulling or pushing components between computers, refer to the Administrator’s Guide in the MTS 1.0 Help documentation. </p>
<p>
Activation by default runs components in a server process on the local computer (in-process). When building a library of utility components (such as tax or zipcode components) with components used across a variety of packages, create a utility package specifying all components to run in the creator’s process. Note that in-process components do not support declarative security or offer the benefits of process isolation. However, the efficiency gained from calling in-process utility components may outweigh process isolation or security concerns.</p>
<p>
Security Isolation MTS defines a rich declarative security model using security roles that can be defined during deployment in the MTS Explorer. Security roles represent a logical group of users that are mapped to Windows NT domain users and groups during the deployment of the package. You can define declarative authorization checking by applying roles to components and component interfaces using the MTS Explorer. Applying a security role to a component specifies that anyone who is a member of the security role is allowed to call the component.</p>
<p>
Security authorization is checked when a method call crosses a package boundary, such as when a client calls into a package or two packages call each other. No security checking is performed when two components that are running in the same server process call one another. In other words, components that share packages should trust one another.</p>
<br>
</dd>
<dt>
Learning More About Microsoft Transaction Server</dt>
<dd>
Microsoft Transaction Server Evaluation Kit 2 The MTS Evaluation Kit includes a 120-day evaluation version of MTS, white papers and NetShow presentations by the MTS architects, and sample MTS applications, including a Visual Basic-based application and a comprehensive Web-based application. You can order the evaluation kit from the MTS Web page at http://www.microsoft.com/transaction/.<p>
Microsoft Transaction Server 1.0 Online Help Online help is installed by MTS setup. To view the help files after installing MTS, from the Start menu click Programs| Microsoft Transaction Server|Help.</p>
<p>
Microsoft Transaction Server Readme The readme is installed by MTS setup. To view the readme after installing MTS, from the Start menu click Programs|Microsoft Transaction Server|Readme.</p>
<p>
Microsoft Transaction Server Software Development Kit For advanced developers, MTS provides a beta SDK that lets you build resource managers or resource dispensers that work with your MTS application. The SDK also contains documentation and examples for programming support for XA-compliant resource managers and viewing MTS events. You can also utilize the SDK to facilitate deployment and administration of a package. The administrative objects in the SDK can be used to program MTS Explorer tasks such as updating a package property. <BR>You can download the MTS Beta SDK from the MTS <BR>Web page.</p>
<p>
Web sites, FTP sites, public newsgroups, and FAQs The MTS Web page can be found at http://www.microsoft.com/transaction/. The MTS public FTP site can be found at ftp.microsoft.com. You can use anonymous FTP to access the site by entering “anonymous” as your user name, and your email id as your password. After you have logged in, enter “cd bussys/viper” to gain access to the MTS directories and files. The Microsoft Transaction Server public newsgroups and FAQs can be found through the MTS Support Web page.</p>
</dd>
</dl>
<p>
To obtain complete source code listings, see page 5.</p>
</font></font></body>
</HTML>
