<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ActiveX/COM Q &amp; A</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>

<font face="verdana,arial,helvetica" size="2">
<h1>ActiveX/COM Q &amp; A</h1>

<p>Don Box</p>

<p>Don Box is
cofounder of DevelopMentor, a training firm for COM and Windows
NT-based development. He also wrote the upcoming book Creating
Components Using DCOM and C++ for Addison-Wesley. Don can be
reached at dbox@develop.com.</p>

<p><font size="6">Q</font>I have a C++ class that simply cannot have a
default constructor and requires explicit constructor parameters
to initialize properly. How do I provide my clients using Visual
Basic ® and C++ with a mechanism for creating my objects
correctly?</p>


<p><font size="6">A</font>CoCreateInstance is one of the first API functions
that COM programmers learn. The routine is easy to understand,
but too often programmers try to shoehorn their entire world into
this one fairly limited function. One of the primary limitations
of CoCreateInstance is its complete lack of flexibility in terms
of initialization parameters. If your C++ programs consist of
lots of calls to the new operator using default constructors,
then CoCreateInstance is great. If your constructors require
arguments to properly initialize new objects, then you are out of
luck.</p>

<p>Consider the following extremely
simple C++ class:</p>



<dir>
    <li><pre><code> class Color {</code></pre>
        <pre><code> short m_red; short m_green; short m_blue;</code></pre>
        <pre><code> public:</code></pre>
        <pre><code> Color(short r, short g, short b) </code></pre>
        <pre><code> : m_red(r), m_green(g), m_blue(b) {}</code></pre>
        <pre><code> short Red(void) const { return m_red; }</code></pre>
        <pre><code> short Green(void) const { return m_green; }</code></pre>
        <pre><code> short Blue(void) const { return m_blue; }</code></pre>
        <pre><code> };</code></pre>
    </li>
</dir>

<p>Assume that it is illegal to use
the object unless the client has explicitly initialized its data
members. The fact that the C++ class does not have a default
constructor enforces this at compile time. In COM, explicit steps
must be taken to make the same guarantees.</p>

<p>One standard approach for
supporting object initialization is to export an explicit
initialization method that takes the same parameters as the
object&#146;s constructor:</p>

<dir>
    <li><pre><code> interface IColor : IUnknown {</code></pre>
        <pre><code> HRESULT Init([in] short r, [in] short g,</code></pre>
        <pre><code> [in] short b);</code></pre>
        <pre><code> [propget] HRESULT Red([out, retval] short *p);</code></pre>
        <pre><code> [propget] HRESULT Green([out,retval] short *p);</code></pre>
        <pre><code> [propget] HRESULT Blue([out, retval] short *p);</code></pre>
        <pre><code> }</code></pre>
        <pre><code> coclass Color {</code></pre>
        <pre><code> interface IColor;</code></pre>
        <pre><code> }</code></pre>
    </li>
</dir>

<p>This implies that Visual Basic
clients would write the code shown below,</p>


<dir>
    <li><pre><code> Function GetPink() as Long</code></pre>
        <pre><code> Dim pink as IColor</code></pre>
        <pre><code> Set pink = new Color</code></pre>
        <pre><code> pink.Init 255, 100, 100</code></pre>
        <pre><code> GetPink = RGB(pink.Red, pink.Green, pink.Blue)</code></pre>
        <pre><code> End Function</code></pre>
    </li>
</dir>

<p>which translates to the following C++ code:</p>


<dir>
    <li><pre><code> COLORREF GetPink(void) {</code></pre>
        <pre><code> IColor *pink = 0; short r, g, b;</code></pre>
        <pre><code> HRESULT hr = CoCreateInstance(CLSID_Color, 0,</code></pre>
        <pre><code> CLSCTX_ALL, IID_IColor,</code></pre>
        <pre><code> (void**)&amp;pink);</code></pre>
        <pre><code> if (SUCCEEDED(hr)) {</code></pre>
        <pre><code> pink-&gt;Init(255, 100, 100);</code></pre>
        <pre><code> pink-&gt;get_Red(&amp;r); pink-&gt;get_Green(&amp;g); </code></pre>
        <pre><code> pink-&gt;get_Blue(&amp;b);</code></pre>
        <pre><code> pink-&gt;Release(); </code></pre>
        <pre><code> }</code></pre>
        <pre><code> return RGB(r,g,b);</code></pre>
        <pre><code> }</code></pre>
    </li>
</dir>

<p>To support this client-side
code, the object needs to have a default constructor and to
postpone initialization until the Init method is called. The
underlying C++ class must now have a default constructor,
although this constructor will only be called internally by the
server. This requirement might render the technique useless in
some domains (such as classes that make extensive use of C++
references as data members), but there are many C++ classes where
this technique could be applied without excessive reengineering.</p>

<p>The approach shown above is
based on a two-phase construction, which has several drawbacks.
First, it is possible that the client will neglect to invoke the
second phase:</p>


<dir>
    <li><pre><code> Function GetPink() as Long</code></pre>
        <pre><code> Dim pink as IColor</code></pre>
        <pre><code> Set pink = new Color</code></pre>
        <pre><code> ' danger: using uninitialized object </code></pre>
        <pre><code> GetPink = RGB(pink.Red, pink.Green, pink.Blue)</code></pre>
        <pre><code> End Function</code></pre>
    </li>
</dir>

<p>For the Color class,
this may not be fatal. For many real-world classes, however,
using uninitialized objects could cause serious faults in a
program that can be very difficult to track down.</p>

<p>To make diagnosing such
errors simpler, the object could add a data member that keeps
track of whether the object has been initialized and returns an
error if the object is used before proper initialization has been
performed:</p>



<dir>
    <li><pre><code> class Color : public IColor {</code></pre>
        <pre><code> short m_red; short m_green; short m_blue;</code></pre>
        <pre><code> bool m_bIsInited;</code></pre>
        <pre><code> public:</code></pre>
        <pre><code> Color(void) : m_bIsInited(false) {}</code></pre>
        <pre><code> STDMETHODIMP Init(short r, short g, short b){</code></pre>
        <pre><code> m_bIsInited=true; m_red=r; m_green=g; m_blue=b; </code></pre>
        <pre><code> return S_OK;</code></pre>
        <pre><code> }</code></pre>
        <pre><code> STDMETHODIMP get_Red(short *ps) {</code></pre>
        <pre><code> if (!m_bIsInited) return E_UNEXPECTED;</code></pre>
        <pre><code> *ps = m_red; return S_OK;</code></pre>
        <pre><code> }</code></pre>
        <pre><code> : : :</code></pre>
        <pre><code> };</code></pre>
    </li>
</dir>

<p>Performing this
bookkeeping requires additional per-object memory and per-method
processing that was not necessary in the original C++ class.</p>

<p>Another potential cause
of errors would be for the client to call the initialization
method more than once:</p>


<dir>
    <li><pre><code> Function GetPink() as Long</code></pre>
        <pre><code> Dim pink as IColor</code></pre>
        <pre><code> Set pink = new Color</code></pre>
        <pre><code> pink.Init 0, 0, 0</code></pre>
        <pre><code> ' danger: reinitializing object </code></pre>
        <pre><code> pink.Init 255, 100, 100</code></pre>
        <pre><code> GetPink = RGB(pink.Red, pink.Green, pink.Blue)</code></pre>
        <pre><code> End Function</code></pre>
    </li>
</dir>

<p>For the Color class,
this error is not fatal, but for many classes reinitialization
could be disastrous. The Init method could be extended to catch
this error at runtime:</p>



<dir>
    <li><pre><code> STDMETHODIMP Color::Init(short r,short g,short b){</code></pre>
        <pre><code> if (m_bIsInited) </code></pre>
        <pre><code> return E_UNEXPECTED;</code></pre>
        <pre><code> m_bIsInited=true; m_red=r; m_green=g; m_blue=b; </code></pre>
        <pre><code> return S_OK;</code></pre>
        <pre><code> }</code></pre>
    </li>
</dir>

<p>Again, this bookkeeping
was not necessary in the original C++ class.</p>

<p>A solution that does
not require the object implementor to worry about uninitialized
objects is to expose a custom activation interface from the class
object. Often, COM class objects are viewed simply as the
necessary glue that allows COM to create instances of a class. It
turns out that class objects are fairly powerful programming
abstractions for representing the instanceless operations of your
COM class. Class objects can expose any custom interface they
choose, and the methods of these interfaces act as the COM
version of C++ static methods. Clients can bind any type of
pointer to a class object using the low-level API function
CoGetClassObject:</p>



<dir>
    <li><pre><code> HRESULT CoGetClassObject(REFCLSID rclsid,</code></pre>
        <pre><code> DWORD dwClsCtx,</code></pre>
        <pre><code> COSERVERINFO *pcsi,</code></pre>
        <pre><code> REFIID riid,</code></pre>
        <pre><code> void **ppv);</code></pre>
    </li>
</dir>

<p>Note that the
server-side registration function, CoRegisterClassObject, does
not require the class object to export <br>
any interface other than IUnknown.</p>


<dir>
    <li><pre><code> HRESULT CoRegisterClassObject(REFCLSID rclsid,</code></pre>
        <pre><code> IUnknown *pUnk,</code></pre>
        <pre><code> DWORD dwClsCtx,</code></pre>
        <pre><code> DWORD dwRegCls,</code></pre>
        <pre><code> DWORD *pdwReg);</code></pre>
    </li>
</dir>

<p>Armed with an
understanding of class objects, it is now possible to enforce the
explicit initialization of objects by, instead of exporting
IClassFactory, exporting a custom activation interface that
requires the client to explicitly pass the necessary
initialization parameters:</p>


<dir>
    <li><pre><code> interface IColorClass : IUnknown {</code></pre>
        <pre><code> HRESULT CreateColor([in] short r, [in] short g,</code></pre>
        <pre><code> [in] short b, </code></pre>
        <pre><code> [out, retval] IColor **ppc);</code></pre>
        <pre><code> }</code></pre>
    </li>
</dir>

<p>This interface would be
exposed from a distinct C++ class that would be used to create
the initial class object. The implementation of this class would
create new initialized instances of the class Color in its
CreateColor method:</p>

<dir>
    <li><pre><code> class ColorClass : public IColorClass {</code></pre>
        <pre><code> STDMETHODIMP CreateColor(short r, short g, </code></pre>
        <pre><code> short b, IColor **ppc){</code></pre>
        <pre><code> if ((*ppc = new Color(r, g, b)) == 0)</code></pre>
        <pre><code> return E_OUTOFMEMORY;</code></pre>
        <pre><code> (*ppc)-&gt;AddRef();</code></pre>
        <pre><code> return S_OK;</code></pre>
        <pre><code> }</code></pre>
        <pre><code> };</code></pre>
    </li>
</dir>

<p>Since the class object
does not expose the IClassFactory interface, the CreateColor
method is the only way clients can create Color objects. This
means that the object implementor does not need to worry about
uninitialized instances since CreateColor properly initializes
every object. This also means that the C++ class does not need to
provide a default constructor.</p>

<p>To use the custom
activation interface shown above, clients need to call
CoGetClassObject instead of CoCreateInstance (see Figure 1).
Beyond the semantic benefits of preventing uninitialized objects,
this approach also yields a big performance win if more than one
object is needed. Using the two-phase construction approach, if
four objects are needed, four calls to CoCreateInstance and four
calls to the Init method would be required, resulting in a total
of eight logical client-server round-trips:</p>

<dir>
    <li><pre><code> CoCreateInstance(CLSID_Color,...,&amp;c1);</code></pre>
        <pre><code> c1-&gt;Init(...);</code></pre>
        <pre><code> CoCreateInstance(CLSID_Color,...,&amp;c2);</code></pre>
        <pre><code> c2-&gt;Init(...);</code></pre>
        <pre><code> CoCreateInstance(CLSID_Color,...,&amp;c3);</code></pre>
        <pre><code> c3-&gt;Init(...);</code></pre>
        <pre><code> CoCreateInstance(CLSID_Color,...,&amp;c4);</code></pre>
        <pre><code> c4-&gt;Init(...);</code></pre>
    </li>
</dir>
<p><img src="actx1.gif"></p>
<p><b>Figure 1 Using
CoGetClassObject</b></p>

<pre><code> COLORREF GetPink(void) {</code></pre>

<pre><code> IColorClass *pcc = 0; short r, g, b;</code></pre>

<pre><code> HRESULT hr = CoGetClassObject(CLSID_Color, CLSCTX_ALL, 0,</code></pre>

<pre><code> IID_IColorClass,(void**)&amp;pcc);</code></pre>

<pre><code> if (SUCCEEDED(hr)) {</code></pre>

<pre><code> IColor *pink = 0; </code></pre>

<pre><code> hr = pcc-&gt;CreateColor(255, 100, 100, &amp;pink);</code></pre>

<pre><code> if (SUCCEEDED(hr)) {</code></pre>

<pre><code> pink-&gt;get_Red(&amp;r); pink-&gt;get_Green(&amp;g); </code></pre>

<pre><code> pink-&gt;get_Blue(&amp;b);</code></pre>

<pre><code> pink-&gt;Release(); </code></pre>

<pre><code> }</code></pre>

<pre><code> pcc-&gt;Release();</code></pre>

<pre><code> }</code></pre>

<pre><code> return RGB(r,g,b);</code></pre>

<pre><code> }</code></pre>


<p>Using the custom
activation interface IColorClass, only one call to
CoGetClassObject is needed, followed by four calls to the
CreateColor method, resulting in just six client-server
round-trips:</p>


<dir>
    <li><pre><code> CoGetClassObject(CLSID_Color,..., &amp;cco);</code></pre>
        <pre><code> cco-&gt;CreateColor(..., &amp;c1);</code></pre>
        <pre><code> cco-&gt;CreateColor(..., &amp;c2);</code></pre>
        <pre><code> cco-&gt;CreateColor(..., &amp;c3);</code></pre>
        <pre><code> cco-&gt;CreateColor(..., &amp;c4);</code></pre>
        <pre><code> cco-&gt;Release();</code></pre>
    </li>
</dir>

<p>In addition to
requiring fewer logical round-trips, the CreateColor method calls
will be more efficient than the calls to CoCreateInstance simply
because they do not have to pass through the client or
server-side SCMs.</p>

<p>Using a custom
activation interface from C++ is fairly straightforward.
Accessing a custom activation interface from Visual Basic
presents more of a challenge. Visual Basic allows programmers to
call CoCreateInstance using the New keyword. Unfortunately,
Visual Basic does not offer a similar keyword for calling
CoGetClassObject. This is not a major obstacle, as Visual Basic
does offer access to
a&nbsp;far&nbsp;more&nbsp;powerful&nbsp;activation&nbsp;API&nbsp;that&nbsp;ultimately&nbsp;is&nbsp;a&nbsp;superset
of CoGetClassObject. This activation API is
MkParseDisplayName/BindToObject,&nbsp;and&nbsp;it&nbsp;is&nbsp;exposed&nbsp;to&nbsp;Visual
Basic programmers via the GetObject intrinsic function. </p>

<p>MkParseDisplayName is
one of the least-appreciated API functions in all of COM.
MkParseDisplayName is a generic, extensible API function that
translates arbitrary text strings into monikers that can be used
to locate, find, or create the objects that they name. The Visual
Basic function GetObject calls MkParseDisplayName internally to
convert a string into a moniker. GetObject then calls the
resultant moniker&#146;s BindToObject method to dereference the
moniker and locate the object named by the moniker. The code
shown in Figure 2 emulates the behavior of Visual
Basic&#146;s GetObject. The actual GetObject function from Visual
Basic takes an optional second parameter that is not relevant to
the discussion at hand.</p>
<p><img src="actx2.gif"></p>
<p><b>Figure 2 Emulating
Visual Basic GetObject</b></p>

<pre><code> IUnknown *GetObject(LPCOLESTR wszObjectName) {</code></pre>

<pre><code> IUnknown *pUnk = 0;</code></pre>

<pre><code> IBindCtx *pbc = 0;</code></pre>

<pre><code> HRESULT hr = CreateBindCtx(&amp;pbc, 0);</code></pre>

<pre><code> if (SUCCEEDED(hr)) {</code></pre>

<pre><code> ULONG cch;</code></pre>

<pre><code> IMoniker *pmk = 0;</code></pre>

<pre><code> hr = MkParseDisplayName(pbc, wszObjectName,</code></pre>

<pre><code> &amp;cch, &amp;pmk);</code></pre>

<pre><code> if (SUCCEEDED(hr)) {</code></pre>

<pre><code> hr = pmk-&gt;BindToObject(pbc, 0, IID_IUnknown,</code></pre>

<pre><code> (void**)&amp;pUnk);</code></pre>

<pre><code> pmk-&gt;Release();</code></pre>

<pre><code> }</code></pre>

<pre><code> pbc-&gt;Release();</code></pre>

<pre><code> }</code></pre>

<pre><code> return pUnk;</code></pre>

<pre><code> }</code></pre>


<p>MkParseDisplayName acts
as the main entry point into the namespace of COM. All object
activation can be performed via MkParseDisplayName and
IMoniker::BindToObject. This namespace is extensible and allows
developers to integrate new object activation algorithms or
policies simply by implementing a custom moniker.
MkParseDisplayName determines the type of moniker to create based
on the prefix of the presented string. If the string begins with
a valid ProgID followed by a colon</p>


<dir>
    <li><pre><code> foo:ObjectName</code></pre>
    </li>
</dir>

<p>MkParseDisplayName
calls CLSIDFromProgID to map the ProgID (foo) onto the CLSID of
the moniker. (Remember, monikers are dynamically created COM
objects with CLSIDs stored in the registry, just like any other
COM class.) MkParseDisplayName then uses the IParseDisplayName
interface of the moniker&#146;s class object to create a new
moniker. The moniker&#146;s class object simply creates a new
moniker object based on the presented string. How this new
moniker uses the string to implement BindToObject is completely
under the control of the moniker implementor. The techniques used
by an implementation of BindToObject
are&nbsp;of&nbsp;no&nbsp;concern to the client. The client simply
calls BindToObject and uses the resultant interface pointer. This
separation of interface from implementation allows clients to use
a single uniform mechanism for activation that
dynamically&nbsp;selects the activation policy based on the
content of the string.</p>

<p>One very important
moniker that is preinstalled as part of COM (as of Windows NT
4.0) is the class moniker. Class monikers keep a CLSID as their
state and use the clsid prefix:</p>



<dir>
    <li><pre><code> clsid:12345678-1234-1234-1234-123412341234</code></pre>
    </li>
</dir>

<p>If this string is
passed to MkParseDisplayName, the clsid prefix is parsed as a
ProgID (which confusingly happens to map to the registry key
HKEY_CLASSES_ROOT\CLSID). The GUID that is found at the
corresponding CLSID subkey
is&nbsp;used&nbsp;to&nbsp;create&nbsp;the&nbsp;moniker.&nbsp;The&nbsp;GUID&nbsp;at&nbsp;HKEY_<br>
CLASSES_ROOT\CLSID\CLSID corresponds to the system-provided class
moniker. The class moniker&#146;s implementation of BindToObject
simply calls CoGetClassObject as shown in the following
pseudocode:</p>



<dir>
    <li><pre><code> HRESULT </code></pre>
        <pre><code> CStdClassMoniker::BindToObject(IBindCtx *pbc,</code></pre>
        <pre><code> IMoniker *pmkToLeft, </code></pre>
        <pre><code> REFIID riid, void**ppv){</code></pre>
        <pre><code> BIND_OPTS2 bo; bo.cbStruct = sizeof(bo);</code></pre>
        <pre><code> pbc-&gt;GetBindOptions(&amp;bo);</code></pre>
        <pre><code> if (pmkToLeft == 0) {</code></pre>
        <pre><code> // m_clsid is the guid parsed at init time</code></pre>
        <pre><code> return CoGetClassObject(m_clsid, bo.dwClassContext,</code></pre>
        <pre><code> 0, riid, ppv);</code></pre>
        <pre><code> }</code></pre>
        <pre><code> // else deal with moniker to left</code></pre>
        <pre><code> }</code></pre>
    </li>
</dir>

<p>At the time of this
writing (Windows NT® 4.0 Service Pack 2), the class
moniker does not use the COSERVERINFO that may be present in the
bind options. </p>

<p>While there is no way
to get the current implementation of the class moniker to
redirect the activation request to another host machine through a
COSERVERINFO, the class moniker does support composition to its
left. If the class moniker is composed to the right of another
moniker, the class moniker expects the object named by the
moniker to its left to export the IClassActivator interface.</p>



<dir>
    <li><pre><code> interface IClassActivator : IUnknown {</code></pre>
        <pre><code> HRESULT GetClassObject(</code></pre>
        <pre><code> [in] REFCLSID rclsid,</code></pre>
        <pre><code> [in] DWORD dwClassContext,</code></pre>
        <pre><code> [in] LCID locale,</code></pre>
        <pre><code> [in] REFIID riid,</code></pre>
        <pre><code> [out, iid_is(riid)] void **ppv);</code></pre>
        <pre><code> }</code></pre>
    </li>
</dir>

<p>When composed to the
left of another moniker, the class moniker uses the
IClassActivator::GetClassObject method to find the class object
instead of calling the API function CoGetClassObject directly
(see Figure 3). This extensibility allows arbitrary
machine selection algorithms to be composed to the left of the
class moniker.</p>

<p><b>Figure 3 Class Moniker
BindToObject Pseudocode</b></p>

<pre><code> HRESULT </code></pre>

<pre><code> CStdClassMoniker::BindToObject(IBindCtx *pbc, IMoniker *pmkToLeft, </code></pre>

<pre><code> REFIID riid, void**ppv){</code></pre>

<pre><code> BIND_OPTS2 bo; bo.cbStruct = sizeof(bo);</code></pre>

<pre><code> pbc-&gt;GetBindOptions(&amp;bo);</code></pre>



<pre><code> if (pmkToLeft != 0) { // we are being composed</code></pre>

<pre><code> IClassActivator *pca = 0;</code></pre>

<pre><code> // bind the activation context to our left</code></pre>

<pre><code> hr = pmkToLeft-&gt;BindToObject(pbc, 0, IID_IClassActivator,</code></pre>

<pre><code> (void**)&amp;pca):</code></pre>

<pre><code> if (SUCCEEDED(hr)) {</code></pre>

<pre><code> // ask the activator for a class object</code></pre>

<pre><code> hr = pca-&gt;GetClassObject(m_clsid, bo.dwClassContext,</code></pre>

<pre><code> bo.locale, riid, ppv);</code></pre>

<pre><code> pca-&gt;Release();</code></pre>

<pre><code> }</code></pre>

<pre><code> return hr;</code></pre>

<pre><code> }</code></pre>

<pre><code> else return CoGetClassObject(m_clsid, bo.dwClassContext,</code></pre>

<pre><code> 0, riid, ppv);</code></pre>

<pre><code> }</code></pre>



<p>Consider a custom
moniker that names an object that can perform load balancing
between a collection of host machines. If this moniker uses the
prefix/ProgID &quot;lb,&quot; the following display name
describes a composite moniker that would activate a class object
using the load-balancing moniker to give the class moniker an
activation context:</p>



<dir>
    <li><pre><code> lb:any!clsid:12341234-1234-1234-1234-123412341234</code></pre>
    </li>
</dir>

<p>The runtime model of
this composite moniker is shown in Figure 4. If the client program were to
load the string from the registry instead of hardcoding it into
the source code, system administrators could inject a new
host-selection policy simply by changing the prefix of the
display name to use a different moniker type.</p>

<p>&nbsp;</p>

<p><b>Figure 4 Composite
Monikers</b></p>

<p>With an understanding
of the class moniker in place, using the custom activation
interface IColorClass is simple:</p>



<dir>
    <li><pre><code> Function GetColor() As Long</code></pre>
        <pre><code> Dim cc as IColorClass</code></pre>
        <pre><code> Dim pink as IColor</code></pre>
        <pre><code> Dim sz as String</code></pre>
        <pre><code> sz =&quot;clsid:12341234-1234-1234-1234-123412341234&quot;</code></pre>
        <pre><code> ' bind to the class object for Color</code></pre>
        <pre><code> Set cc = GetObject(sz)</code></pre>
        <pre><code> ' use class object to create a new instance</code></pre>
        <pre><code> Set pink = cc.CreateColor(255, 100, 100)</code></pre>
        <pre><code> GetColor = RGB(pink.Red, pink.Green, pink.Blue)</code></pre>
        <pre><code> End Function</code></pre>
    </li>
</dir>

<p>Using the class
moniker, Visual Basic can access any interface that a class
object exposes provided the interface uses only
VARIANT-compatible parameter types. Ironically, this means that
the IClassFactory interface is off-limits to programmers using
Visual Basic.</p>

<p>One aspect of exporting
custom interfaces like IColorClass from class objects is that, if
you are building an out-of-process server, you must implement
IExternalConnection if you elect to not implement IClassFactory.
This is because of the strange relationship between class object
reference counting and server lifetime. Your class object&#146;s
implementation of IExternalConnection::AddConnection should
perform the equivalent of IClassFactory::LockServer(TRUE), and
your implementation of IExternalConnection::Re-<br>
leaseConnection should perform the equivalent of
IClassFactory::LockServer(FALSE). This prevents your server from
terminating while there are outstanding proxies to your class
objects.</p>

<p>Implementing a custom
class object in raw C++ is very straightforward since you are in
complete control at all times. Some frameworks, such as MFC, make
it extremely difficult to export a class object that is anything
other than the standard implementation of IClassFactory or
perhaps IClassFactory2. Fortunately, the Active Template Library
(ATL) makes custom class objects trivial. The
DECLARE_CLASSFACTORY_EX macro allows you to provide your own
custom C++ class to use for your class object. Figure 5
shows the complete implementation of the Color class and class
object in ATL. Ironically, while ATL makes it easy to use custom
class objects, you cannot use ATL&#146;s CComObject family of
classes if you don&#146;t provide a default constructor. As Figure 5 illustrates, this is only an inconvenience and not an
insurmountable problem.</p>

<p><b>Figure 5 ColorClass ATL
Implementation</b></p>

<pre><code> ////////////////////////////////////////////</code></pre>

<pre><code> //</code></pre>

<pre><code> // ATLColor.h - 1997, Don Box</code></pre>

<pre><code> //</code></pre>

<pre><code> // An ATL-based inplementation of IColor/IColorClass</code></pre>

<pre><code> //</code></pre>



<pre><code> #ifndef __COLOR_H_</code></pre>

<pre><code> #define __COLOR_H_</code></pre>



<pre><code> #include &quot;resource.h&quot; // main symbols</code></pre>



<pre><code> /////////////////////////////////////////////////////////////////////////////</code></pre>

<pre><code> // Color</code></pre>

<pre><code> class Color : </code></pre>

<pre><code> public CComObjectRootEx&lt;CComMultiThreadModelNoCS&gt;,</code></pre>

<pre><code> public IColor</code></pre>

<pre><code> {</code></pre>

<pre><code> BEGIN_COM_MAP(Color)</code></pre>

<pre><code> COM_INTERFACE_ENTRY(IColor)</code></pre>

<pre><code> END_COM_MAP()</code></pre>

<pre><code> short m_red; short m_green; short m_blue;</code></pre>

<pre><code> public:</code></pre>

<pre><code> // we need to explicitly lock/unlock module because CComObject&lt;&gt;</code></pre>

<pre><code> // will not work with classes that do not have default constructors</code></pre>



<pre><code> Color(short r, short g, short b)</code></pre>

<pre><code> : m_red(r), m_green(g), m_blue(b)</code></pre>

<pre><code> {</code></pre>

<pre><code> _Module.Lock();</code></pre>

<pre><code> }</code></pre>



<pre><code> ~Color(void)</code></pre>

<pre><code> {</code></pre>

<pre><code> _Module.Unlock();</code></pre>

<pre><code> }</code></pre>



<pre><code> // IUnknown methods (needed due to CComObject-incompatibility)</code></pre>

<pre><code> STDMETHODIMP QueryInterface(REFIID iid, void ** ppvObject)</code></pre>

<pre><code> {return _InternalQueryInterface(iid, ppvObject);}</code></pre>

<pre><code> STDMETHODIMP_(ULONG) AddRef(void) </code></pre>

<pre><code> {return InternalAddRef();}</code></pre>

<pre><code> STDMETHODIMP_(ULONG) Release(void){</code></pre>

<pre><code> ULONG l = InternalRelease();</code></pre>

<pre><code> if (l == 0)</code></pre>

<pre><code> delete this;</code></pre>

<pre><code> return l;</code></pre>

<pre><code> }</code></pre>



<pre><code> // IColor methods</code></pre>

<pre><code> STDMETHODIMP get_Red(/*[out, retval]*/ short *pval)</code></pre>

<pre><code> { *pval = m_red; return S_OK; }</code></pre>

<pre><code> STDMETHODIMP get_Green(/*[out, retval]*/ short *pval)</code></pre>

<pre><code> { *pval = m_green; return S_OK; }</code></pre>

<pre><code> STDMETHODIMP get_Blue(/*[out, retval]*/ short *pval)</code></pre>

<pre><code> { *pval = m_blue; return S_OK; }</code></pre>

<pre><code> // ColorClass will act as the class object for our class</code></pre>

<pre><code> class ColorClass : </code></pre>

<pre><code> public CComObjectRootEx&lt;CComMultiThreadModelNoCS&gt;,</code></pre>

<pre><code> public IColorClass,</code></pre>

<pre><code> public IExternalConnection</code></pre>

<pre><code> {</code></pre>

<pre><code> BEGIN_COM_MAP(ColorClass)</code></pre>

<pre><code> COM_INTERFACE_ENTRY(IColorClass)</code></pre>

<pre><code> COM_INTERFACE_ENTRY(IExternalConnection)</code></pre>

<pre><code> END_COM_MAP()</code></pre>

<pre><code> // IColorClass methods</code></pre>

<pre><code> STDMETHODIMP CreateColor(short r, short g, short b,</code></pre>

<pre><code> IColor **ppc) {</code></pre>

<pre><code> if ((*ppc = new Color(r, g, b)) == 0)</code></pre>

<pre><code> return E_OUTOFMEMORY;</code></pre>

<pre><code> (*ppc)-&gt;AddRef();</code></pre>

<pre><code> return S_OK;</code></pre>

<pre><code> }</code></pre>



<pre><code> // IExternalConnection methods</code></pre>

<pre><code> STDMETHODIMP_(DWORD) AddConnection(DWORD extconn, DWORD) {</code></pre>

<pre><code> if (extconn&amp;EXTCONN_STRONG) _Module.Lock();</code></pre>

<pre><code> return 2;</code></pre>

<pre><code> }</code></pre>

<pre><code> STDMETHODIMP_(DWORD) ReleaseConnection(DWORD extconn, DWORD, BOOL) {</code></pre>

<pre><code> if (extconn&amp;EXTCONN_STRONG) _Module.Unlock();</code></pre>

<pre><code> return 1;</code></pre>

<pre><code> }</code></pre>

<pre><code> };</code></pre>

<pre><code> // make ColorClass our class object C++ class</code></pre>

<pre><code> DECLARE_CLASSFACTORY_EX(ColorClass)</code></pre>



<pre><code> DECLARE_REGISTRY_RESOURCEID(IDR_COLOR)</code></pre>

<pre><code> static const CLSID&amp; WINAPI GetObjectCLSID() {return CLSID_Color;}</code></pre>

<pre><code> static LPCTSTR WINAPI GetObjectDescription() {return NULL;}</code></pre>

<pre><code> typedef CComFailCreator&lt;E_FAIL&gt; _CreatorClass;</code></pre>

<pre><code> };</code></pre>



<pre><code> #endif //__COLOR_H_</code></pre>

<p><font size="4"></font>&nbsp;</p>



<p><font size="2"></font>&nbsp;</p>



<p><b>Q</b> I want to implement a singleton object in
COM. How should I do it? </p>



<p><b>A</b> Singletons are typically used to limit
the number of instances of a class to one. Singletons are useful
for modeling generic services (such as time of day or scheduling)
or any functionality that does not require a distinct state to be
maintained for each client. Classic RPC is great for modeling
such services, but most programmers prefer using COM due to its
better tool and language integration and its potential for
in-process execution. While COM does not have any explicit API
support for singletons, there are several ways to go about
implementing this common programming idiom. </p>

<p>To grasp the concept of
singletons, it helps to start with a concrete example. Consider
an object that supports getting the current time of day. Such an
object would export an interface similar to the following:</p>



<dir>
    <li><pre><code> interface ITimeOfDay : IUnknown {</code></pre>
        <pre><code> HRESULT GetCurrentTimeOfDay([out, retval] DATE *p);</code></pre>
        <pre><code> }</code></pre>
    </li>
</dir>

<p>While it would not
cause any semantic errors to export this interface from a normal
multi-instance COM class, having each client call
CoCreateInstance to create a new COM object would consume
considerably more resources than having the same number of
clients simply connect to one singleton object. The increased
resource consumption is due to the fact that COM needs to manage
the internal state for each unique COM identity that is exported
(marshaled) from a process. Since this interface relies solely on
temporal information and requires no per-object state to operate
correctly, it&#146;s a prime candidate for deployment as a
singleton. This is semantically more appropriate and will also
scale to thousands of clients better than an instance-based
server, especially if most of the operations on the object are
read-only and don&#146;t require locks.</p>

<p><font size="2" face="NewCenturyPerhaps&nbsp;the&nbsp;most&nbsp;direct&nbsp;technique&nbsp;for&nbsp;implementing&nbsp;singletons
is to simply use the class object as the singleton. As I
mentioned earlier, class objects can expose arbitrary COM
interfaces&nbsp;and&nbsp;can&nbsp;be accessed from any language
that
supports&nbsp;either&nbsp;CoGetClassObject&nbsp;or&nbsp;MkParseDisplayName.
Figure 6 shows a simple C++ class that implements
the&nbsp;ITimeOfDay and IExternalConnection interfaces. Given
this class, writing a singleton server is fairly straightforward:</p>



<dir>
    <li><pre>void main(void) {</code></pre>
        <pre>CoInitializeEx(0, COINIT_MULTITHREADED);</code></pre>
        <pre>TimeOfDay tod;</code></pre>
        <pre>DWORD dwReg;</code></pre>
        <pre>CoRegisterClassObject(CLSID_TimeOfDay,</code></pre>
        <pre>(ITimeOfDay*)&amp;tod,</code></pre>
        <pre>CLSCTX_LOCAL_SERVER,</code></pre>
        <pre>REGCLS_MULTIPLEUSE,</code></pre>
        <pre>&amp;dwReg);</code></pre>
        <pre>WaitForSingleObject(g_heventDone, INFINITE);</code></pre>
        <pre>CoRevokeClassObject(dwReg);</code></pre>
        <pre>CoUninitialize();</code></pre>
        <pre>}</code></pre>
    </li>
</dir>

<p>Clients can use this
server simply by using its CLSID to bind to the class object:</p>



<dir>
    <li><pre><code> Dim sz as String</code></pre>
        <pre><code> Dim tod as ITimeOfDay</code></pre>
        <pre><code> sz = &quot;clsid:56785678-5678-5678-5678-567856785678&quot;</code></pre>
        <pre><code> ' use class moniker to call CoGetClassObject</code></pre>
        <pre><code> Set tod = GetObject(sz)</code></pre>
        <pre><code> MsgBox tod.GetCurrentTime()</code></pre>
    </li>
</dir>

<p>Because this client
uses moniker activation via MkParseDisplayName, it is possible to
load arbitrary <br>
display names/monikers for the singleton at runtime. <br>
This allows users or administrators to redirect where the time of
day is read from simply by composing the class moniker with a
moniker that identifies a machine or group of machines.</p>

<p><b>Figure 6 TimeOfDay</b></p>

<pre><code>//</code></pre>

<pre><code>// TimeOfDay.h - 1997, Don Box</code></pre>

<pre><code>//</code></pre>

<pre><code>// A singleton implementation of ITimeOfDay</code></pre>

<pre><code>//</code></pre>



<pre><code>#ifndef __TOD_H_</code></pre>

<pre><code>#define __TOD_H_</code></pre>



<pre><code>class TimeOfDay : </code></pre>

<pre><code>public ITimeOfDay,</code></pre>

<pre><code>public IExternalConnection</code></pre>

<pre><code>{</code></pre>

<pre><code>public:</code></pre>

<pre><code>double m_offset;</code></pre>



<pre><code>// IUnknown methods </code></pre>

<pre><code>STDMETHODIMP QueryInterface(REFIID riid, void **ppv)</code></pre>

<pre><code>{</code></pre>

<pre><code>if (riid == IID_IUnknown || riid == IID_ITimeOfDay)</code></pre>

<pre><code>*ppv = static_cast&lt;ITimeOfDay*&gt;(this);</code></pre>

<pre><code>else if (riid == IID_IExternalConnection)</code></pre>

<pre><code>*ppv = static_cast&lt;IExternalConnection*&gt;(this);</code></pre>

<pre><code>else</code></pre>

<pre><code>return (*ppv = 0), E_NOINTERFACE;</code></pre>

<pre><code>((IUnknown*)*ppv)-&gt;AddRef();</code></pre>

<pre><code>return S_OK;</code></pre>

<pre><code>}</code></pre>

<pre><code>STDMETHODIMP_(ULONG) AddRef(void) </code></pre>

<pre><code>{ return 2;}</code></pre>

<pre><code>STDMETHODIMP_(ULONG) Release(void)</code></pre>

<pre><code>{ return 1; }</code></pre>



<pre><code>// ITimeOfDay methods</code></pre>

<pre><code>STDMETHODIMP GetCurrentTimeOfDay(DATE *pval)</code></pre>

<pre><code>{ </code></pre>

<pre><code>SYSTEMTIME st;</code></pre>

<pre><code>// convert system time to a date</code></pre>

<pre><code>GetLocalTime(&amp;st);</code></pre>

<pre><code>SystemTimeToVariantTime(&amp;st, pval);</code></pre>

<pre><code>// factor in timezone offsets</code></pre>

<pre><code>*pval += m_offset;</code></pre>

<pre><code>return S_OK;</code></pre>

<pre><code>}</code></pre>



<pre><code>// IExternalConnection methods</code></pre>

<pre><code>STDMETHODIMP_(DWORD) AddConnection(DWORD extconn, DWORD) {</code></pre>

<pre><code>extern void LockModule();// some module locking routine</code></pre>

<pre><code>if (extconn&amp;EXTCONN_STRONG) </code></pre>

<pre><code>LockModule(); </code></pre>

<pre><code>return 2;</code></pre>

<pre><code>}</code></pre>

<pre><code>STDMETHODIMP_(DWORD) ReleaseConnection(DWORD extconn, DWORD, BOOL) {</code></pre>

<pre><code>extern void UnlockModule();// some module unlocking routine</code></pre>

<pre><code>if (extconn&amp;EXTCONN_STRONG) </code></pre>

<pre><code>UnlockModule();</code></pre>

<pre><code>return 1;</code></pre>

<pre><code>}</code></pre>

<pre><code>};</code></pre>



<pre><code>#endif </code></pre>



<p>Another popular
technique for implementing singletons is to use the class
object&#146;s IClassFactory::CreateInstance method to return a
pointer to a single global object in the server. Given the
TimeOfDay class shown in </font>Figure 6, this technique would require
the following class factory method</p>



<dir>
    <li><pre><code> STDMETHODIMP </code></pre>
        <pre><code> CTODClassFactory::CreateInstance(IUnknown * puo,</code></pre>
        <pre><code> REFIID riid,</code></pre>
        <pre><code> void **ppv) {</code></pre>
        <pre><code> *ppv = 0;</code></pre>
        <pre><code> if (puo) return CLASS_E_NOAGGREGATION;</code></pre>
        <pre><code> static TimeOfDay s_tod; // declare a singleton</code></pre>
        <pre><code> return s_tod.QueryInterface(riid, ppv);</code></pre>
        <pre><code> }</code></pre>
    </li>
</dir>

<p>assuming the following
client code:</p>



<dir>
    <li><pre><code> Dim tod as ITimeOfDay</code></pre>
        <pre><code> Set tod = new TimeOfDay</code></pre>
        <pre><code> MsgBox tod.GetCurrentTime()</code></pre>
    </li>
</dir>

<p>This technique, while
commonly deployed in the field, has several deficiencies when
compared to using the class object directly. </p>

<p>The first deficiency is
that it seems semantically wrong for a method called
CreateInstance to get an object instead of create an object.
Second, because CoCreateInstance is a generic API function, it is
impossible for the supporting COM runtime to provide any
optimizations based on prior calls to CoCreateInstance on the
same CLSID. Since the semantics of the
IClassFactory::CreateInstance method assume that a new instance
will be returned on each call, CoCreateInstance must return to
the server for each activation request. In contrast, the
semantics of CoGetClassObject default to that of a singleton.
This means that the results of the first CoGetClassObject request
are valid for any subsequent CoGetClassObject requests, which
implies that future runtime environments could cache commonly
used class objects to avoid excessive round-trips to the server
without compromising the semantic integrity of the programming
model. Also, client programs can safely do their own explicit
caching of class object pointers based on their own usage
patterns. </p>

<p>Another disadvantage to
using CoCreateInstance explicitly to bind to singleton objects is
that it is not possible to change the binding policy simply by
replacing a single text string as was possible when the class
moniker was used via GetObject or MkParseDisplayName. Beyond the
load-balancing and remote activation possibilities mentioned
previously, another advantage of monikers is that they allow
activation of named objects.</p>

<p>To grasp why named
objects are useful, consider the ITimeOfDay interface described
previously. At any given moment, there is only one time of day at
any given location. However, in various regions of the planet,
the time of day is different due to the fact that most of the
world refuses to recognize Pacific Standard Time as the official
planet-wide time of day. While this temporal diversity makes
communicating with most of the world somewhat inconvenient for
people who live near the epicenter of the universe (Redondo
Beach, Ca.), it does allow most of the world&#146;s programmers
to sleep when it is light and program when it is dark, thus
keeping the wheels of progress properly lubricated.</p>

<p>Suppose that I want to
extend my time of day server to support multiple time zones
without requiring source code changes in my client programs. Had
I exposed my object to the client via CoCreateInstance, there
would be no way for me to discern what time zone the client
wishes to query. One solution to this problem would be to add an
explicit method to my instances that allows the client to set the
desired time zone. However, since this time zone would need to be
stored in the object as a data member, I would no longer be able
to use a singleton. This means that my server would need to have
thousands of extant objects in order to serve thousands of
clients simultaneously. Besides the scalability limitations this
type of solution poses, it also requires modifications to the
client source code, which may not be possible in many situations.
</p>

<p>The key to finding a
palatable solution is to examine the problem domain. There are a
finite number of time zones on Earth. There are even fewer in the
United States (actually four, if you consider only the 48
contiguous states and ignore the fact that the state of Arizona
and a handful of renegade Indianans choose to ignore daylight
savings time). Assuming that my server needs to serve clients
only in the United States, the server could export four singleton
instances, one per time zone. This would keep the per-object
overhead fairly low. All that is needed is a mechanism for the
client to bind to the correct time zone.</p>

<p>Assuming that the
original singleton solution was deployed as a class object and
that clients bind using GetObject/MkParseDisplayName, this
problem can be solved using Item monikers. Item monikers are
simply text strings that name some subcomponent of a containing
object. If I model my class object as such, I can use the item
moniker to name the individual time zones as follows:</p>



<dir>
    <li><pre><code> clsid:12341234-1234-1234-1234-123412341234:!Eastern</code></pre>
    </li>
</dir>

<p>This display name maps
to a composite moniker with a class moniker as the left component
and the item moniker Eastern as the right component. When parsed,
MkParseDisplayName will first parse the class moniker, then bind
the class moniker (which starts the server) and ask the class
object for the IParseDisplayName interface. My class
object&#146;s IParseDisplayName::ParseDisplayName method then
gets the remainder of the string (&quot;!Eastern&quot; in this
example) to convert into the right component of the composite.
Since my implementation will use Item monikers to name the time
zone objects, the implementation of ParseDisplayName is as
follows:</p>



<dir>
    <li><pre><code> STDMETHODIMP </code></pre>
        <pre><code> TODClass::ParseDisplayName(IBindCtx *pbc,</code></pre>
        <pre><code> LPOLESTR pszDisplayName,</code></pre>
        <pre><code> ULONG *pchEaten,</code></pre>
        <pre><code> IMoniker **ppmkOut)</code></pre>
        <pre><code> {</code></pre>
        <pre><code> *pchEaten = wcslen(pszDisplayName);</code></pre>
        <pre><code> return CreateItemMoniker(OLESTR(&quot;!&quot;), </code></pre>
        <pre><code> pszDisplayName, </code></pre>
        <pre><code> ppmkOut);</code></pre>
        <pre><code> }</code></pre>
    </li>
</dir>

<p>At bind time, the
composite moniker will first try to bind the item moniker. The
item moniker binds itself by first binding the moniker to its
left (which is the class moniker in this case), requesting the
IOleItemContainer interface from my class object. In my class
object&#146;s IOleItemContainer::<br>
GetObject method, I am presented with the string Eastern and must
map this name onto an instance. Assuming that my class object
maintains an array of four singleton objects, one per time zone,
this method could be implemented as follows:</p>



<dir>
    <li><pre><code> STDMETHODIMP </code></pre>
        <pre><code> TODClass::GetObject(LPOLESTR pszItem,</code></pre>
        <pre><code> DWORD dwSpeedNeeded, IBindCtx *pbc,</code></pre>
        <pre><code> REFIID riid, void **ppv) </code></pre>
        <pre><code> {</code></pre>
        <pre><code> if (!_wcsicmp(pszItem, OLESTR(&quot;pacific&quot;)))</code></pre>
        <pre><code> return m_rgTimes[0].QueryInterface(riid, ppv);</code></pre>
        <pre><code> else if (!_wcsicmp(pszItem, OLESTR(&quot;mountain&quot;)))</code></pre>
        <pre><code> return m_rgTimes[1].QueryInterface(riid, ppv);</code></pre>
        <pre><code> else if (!_wcsicmp(pszItem, OLESTR(&quot;central&quot;)))</code></pre>
        <pre><code> return m_rgTimes[2].QueryInterface(riid, ppv);</code></pre>
        <pre><code> else if (_wcsicmp(pszItem, OLESTR(&quot;eastern&quot;)))</code></pre>
        <pre><code> return m_rgTimes[3].QueryInterface(riid, ppv);</code></pre>
        <pre><code> *ppv = 0;</code></pre>
        <pre><code> return MK_E_NOOBJECT;</code></pre>
        <pre><code> }</code></pre>
    </li>
</dir>

<p>Figures 7 and 8 show the complete
implementation of this server. Figures 9 and 10 show a Visual Basic-based
client application that displays the time in each available time
zone.</p>

<p><img src="actx7.gif"></p>
<p><b>Figure 7 Singleton
TimeOfDay Server</b></p>

<p><b>Figure 8 Per-Time Zone
TimeOfDay Singleton</b></p>

<pre><code>TOD.idl</code></pre>

<pre><code> ////////////////////////////////////////////</code></pre>

<pre><code> //</code></pre>

<pre><code> // TOD.idl - 1997, Don Box</code></pre>

<pre><code> //</code></pre>

<pre><code> // Interface definitions for TimeOfDay</code></pre>

<pre><code> //</code></pre>

<pre><code> [</code></pre>

<pre><code> uuid(8C54EFA0-B85F-11d0-8C3E-0080C73925BA),</code></pre>

<pre><code> object,</code></pre>

<pre><code> oleautomation</code></pre>

<pre><code> ]</code></pre>

<pre><code> interface ITimeOfDay : IUnknown</code></pre>

<pre><code> {</code></pre>

<pre><code> import &quot;oaidl.idl&quot;;</code></pre>

<pre><code> HRESULT GetCurrentTimeOfDay([out, retval] DATE *pval);</code></pre>

<pre><code> }</code></pre>


<pre><code> [</code></pre>

<pre><code> uuid(8C54EFA1-B85F-11d0-8C3E-0080C73925BA),</code></pre>

<pre><code> helpstring(&quot;Time Of Day Interfaces&quot;),</code></pre>

<pre><code> lcid(0),</code></pre>

<pre><code> version(1.0)</code></pre>

<pre><code> ]</code></pre>

<pre><code> library TimeOfDayLib</code></pre>

<pre><code> {</code></pre>

<pre><code> [</code></pre>

<pre><code> uuid(8C54EFA2-B85F-11d0-8C3E-0080C73925BA)</code></pre>

<pre><code> ]</code></pre>

<pre><code> coclass TimeOfDay</code></pre>

<pre><code> {</code></pre>

<pre><code> interface ITimeOfDay;</code></pre>

<pre><code> }</code></pre>

<pre><code> }</code></pre>

<pre><code>TZ.cpp</code></pre>

<pre><code> ////////////////////////////////////////////</code></pre>

<pre><code> //</code></pre>

<pre><code> // TZ.cpp - 1997, Don Box</code></pre>

<pre><code> //</code></pre>

<pre><code> // A multi-singleton implementation of ITimeOfDay</code></pre>

<pre><code> // that supports multiple time zones using composite </code></pre>

<pre><code> // monikers.</code></pre>

<pre><code> //</code></pre>

<pre><code> // Usage: </code></pre>

<pre><code> // Dim tod as ITimeOfDay</code></pre>

<pre><code> // Set tod = GetObject(&quot;clsid:8C54EFA2-B85F-11d0-8C3E-0080C73925BA:!Eastern&quot;)</code></pre>

<pre><code> // MsgBox tod.GetCurrentTimeOfDay()</code></pre>

<pre><code> //</code></pre>

<pre><code> #define _WIN32_WINNT 0x402</code></pre>

<pre><code> #include &lt;windows.h&gt;</code></pre>

<pre><code> #include &quot;TOD.h&quot;</code></pre>

<pre><code> #include &quot;TOD_i.c&quot;</code></pre>

<pre><code> #include &quot;TimeOfDay.h&quot;</code></pre>


<pre><code> class TODClass : </code></pre>

<pre><code> public IOleItemContainer,</code></pre>

<pre><code> public IExternalConnection,</code></pre>

<pre><code> public ITimeOfDay</code></pre>

<pre><code> {</code></pre>

<pre><code> // this object supports four time zones</code></pre>

<pre><code> TimeOfDay m_rgTimes[4];</code></pre>

<pre><code> public:</code></pre>

<pre><code> TODClass(void) </code></pre>

<pre><code> {</code></pre>

<pre><code> // initialize the offsets to adjust for timezone shifts</code></pre>

<pre><code> m_rgTimes[0].m_offset = 0;</code></pre>

<pre><code> m_rgTimes[1].m_offset = 1/24.0;</code></pre>

<pre><code> m_rgTimes[2].m_offset = 2/24.0;</code></pre>

<pre><code> m_rgTimes[3].m_offset = 3/24.0;</code></pre>

<pre><code> }</code></pre>

<pre><code> // IUnknown methods </code></pre>

<pre><code> STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)</code></pre>

<pre><code> {</code></pre>

<pre><code> if (riid == IID_IUnknown || riid == IID_ITimeOfDay)</code></pre>

<pre><code> *ppv = static_cast&lt;ITimeOfDay*&gt;(this);</code></pre>

<pre><code> else if (riid == IID_IExternalConnection)</code></pre>

<pre><code> *ppv = static_cast&lt;IExternalConnection*&gt;(this);</code></pre>

<pre><code> else if (riid == IID_IParseDisplayName)</code></pre>

<pre><code> *ppv = static_cast&lt;IParseDisplayName*&gt;(this);</code></pre>

<pre><code> else if (riid == IID_IOleContainer)</code></pre>

<pre><code> *ppv = static_cast&lt;IOleContainer*&gt;(this);</code></pre>

<pre><code> else if (riid == IID_IOleItemContainer)</code></pre>

<pre><code> *ppv = static_cast&lt;IOleItemContainer*&gt;(this);</code></pre>

<pre><code> else</code></pre>

<pre><code> return (*ppv = 0), E_NOINTERFACE;</code></pre>

<pre><code> ((IUnknown*)*ppv)-&gt;AddRef();</code></pre>

<pre><code> return S_OK;</code></pre>

<pre><code> }</code></pre>

<pre><code> STDMETHODIMP_(ULONG) AddRef(void) </code></pre>

<pre><code> { return 2;}</code></pre>

<pre><code> STDMETHODIMP_(ULONG) Release(void)</code></pre>

<pre><code> { return 1; }</code></pre>

<pre><code> // ITimeOfDay methods</code></pre>

<pre><code> STDMETHODIMP GetCurrentTimeOfDay(DATE *pval)</code></pre>

<pre><code> { </code></pre>

<pre><code> // class object also implements ITimeOfDay (maps to </code></pre>

<pre><code> // pacific time)</code></pre>

<pre><code> return m_rgTimes[0].GetCurrentTimeOfDay(pval);</code></pre>

<pre><code> }</code></pre>

<pre><code> // IExternalConnection methods</code></pre>

<pre><code> STDMETHODIMP_(DWORD) AddConnection(DWORD extconn, DWORD) {</code></pre>

<pre><code> extern void LockModule();// some module locking routine</code></pre>

<pre><code> if (extconn&amp;EXTCONN_STRONG) </code></pre>

<pre><code> LockModule(); </code></pre>

<pre><code> return 2;</code></pre>

<pre><code> }</code></pre>

<pre><code> STDMETHODIMP_(DWORD) ReleaseConnection(DWORD extconn, DWORD, BOOL) {</code></pre>

<pre><code> extern void UnlockModule();// some module unlocking routine</code></pre>

<pre><code> if (extconn&amp;EXTCONN_STRONG) </code></pre>

<pre><code> UnlockModule();</code></pre>

<pre><code> return 1;</code></pre>

<pre><code> }</code></pre>

<pre><code> // IParseDisplayName methods</code></pre>

<pre><code> STDMETHODIMP </code></pre>

<pre><code> ParseDisplayName( IBindCtx *pbc,</code></pre>

<pre><code> LPOLESTR pszDisplayName,</code></pre>

<pre><code> ULONG *pchEaten,</code></pre>

<pre><code> IMoniker **ppmkOut)</code></pre>

<pre><code> {</code></pre>

<pre><code> // parse string as an item moniker, stripping off the leading &quot;!&quot;</code></pre>

<pre><code> *pchEaten = wcslen(pszDisplayName);</code></pre>

<pre><code> return CreateItemMoniker(OLESTR(&quot;!&quot;), pszDisplayName + 1, ppmkOut);</code></pre>

<pre><code> }</code></pre>


<pre><code> // IOleContainer methods</code></pre>

<pre><code> STDMETHODIMP </code></pre>

<pre><code> EnumObjects(DWORD grfFlags, IEnumUnknown **ppenum)</code></pre>

<pre><code> {</code></pre>

<pre><code> *ppenum = 0;</code></pre>

<pre><code> return E_NOTIMPL;</code></pre>

<pre><code> }</code></pre>

<pre><code> STDMETHODIMP </code></pre>

<pre><code> LockContainer(BOOL fLock)</code></pre>

<pre><code> {</code></pre>

<pre><code> return E_NOTIMPL;</code></pre>

<pre><code> }</code></pre>





<pre><code> // IOleContainer methods</code></pre>

<pre><code> STDMETHODIMP </code></pre>

<pre><code> GetObject(LPOLESTR pszItem, DWORD dwSpeedNeeded,</code></pre>

<pre><code> IBindCtx *pbc, REFIID riid, void **ppv)</code></pre>

<pre><code> {</code></pre>


<pre><code> if (_wcsicmp(pszItem, OLESTR(&quot;pacific&quot;)) == 0)</code></pre>

<pre><code> return m_rgTimes[0].QueryInterface(riid, ppv);</code></pre>

<pre><code> else if (_wcsicmp(pszItem, OLESTR(&quot;mountain&quot;)) == 0)</code></pre>

<pre><code> return m_rgTimes[1].QueryInterface(riid, ppv);</code></pre>

<pre><code> else if (_wcsicmp(pszItem, OLESTR(&quot;central&quot;)) == 0)</code></pre>

<pre><code> return m_rgTimes[2].QueryInterface(riid, ppv);</code></pre>

<pre><code> else if (_wcsicmp(pszItem, OLESTR(&quot;eastern&quot;)) == 0)</code></pre>

<pre><code> return m_rgTimes[3].QueryInterface(riid, ppv);</code></pre>

<pre><code> *ppv = 0;</code></pre>

<pre><code> return MK_E_NOOBJECT;</code></pre>

<pre><code> }</code></pre>

<pre><code> STDMETHODIMP </code></pre>

<pre><code> GetObjectStorage(LPOLESTR pszItem, IBindCtx *pbc, REFIID riid, void **ppv)</code></pre>

<pre><code> {</code></pre>

<pre><code> *ppv = 0;</code></pre>

<pre><code> return MK_E_NOSTORAGE;</code></pre>

<pre><code> }</code></pre>


<pre><code> STDMETHODIMP </code></pre>

<pre><code> IsRunning(LPOLESTR pszItem)</code></pre>

<pre><code> {</code></pre>

<pre><code> return E_NOTIMPL;</code></pre>

<pre><code> }</code></pre>



<pre><code> };</code></pre>



<pre><code> HANDLE g_heventDone = CreateEvent(0, TRUE, FALSE, 0);</code></pre>

<pre><code> void LockModule()</code></pre>

<pre><code> {</code></pre>

<pre><code> CoAddRefServerProcess();</code></pre>

<pre><code> }</code></pre>



<pre><code> void UnlockModule()</code></pre>

<pre><code> {</code></pre>

<pre><code> if (CoReleaseServerProcess() == 0)</code></pre>

<pre><code> SetEvent(g_heventDone);</code></pre>

<pre><code> }</code></pre>



<pre><code> int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR szCmdParam, int)</code></pre>

<pre><code> {</code></pre>

<pre><code> HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);</code></pre>

<pre><code> if (FAILED(hr))</code></pre>

<pre><code> return hr;</code></pre>

<pre><code> if (strstr(szCmdParam, &quot;/RegServer&quot;) == 0)</code></pre>

<pre><code> {</code></pre>

<pre><code> DWORD dwReg;</code></pre>

<pre><code> TODClass todClassObject;</code></pre>

<pre><code> hr = CoRegisterClassObject(CLSID_TimeOfDay,</code></pre>

<pre><code> (IExternalConnection*)&amp;todClassObject,</code></pre>

<pre><code> CLSCTX_LOCAL_SERVER,</code></pre>

<pre><code> REGCLS_MULTIPLEUSE,</code></pre>

<pre><code> &amp;dwReg);</code></pre>

<pre><code> if (SUCCEEDED(hr))</code></pre>

<pre><code> {</code></pre>

<pre><code> WaitForSingleObject(g_heventDone, INFINITE);</code></pre>

<pre><code> CoRevokeClassObject(dwReg);</code></pre>

<pre><code> }</code></pre>

<pre><code> }</code></pre>

<pre><code> else</code></pre>

<pre><code> {</code></pre>

<pre><code> // self-registration code</code></pre>

<pre><code> char szFileName[MAX_PATH];</code></pre>

<pre><code> GetModuleFileNameA(0, szFileName, MAX_PATH);</code></pre>

<pre><code> OLECHAR wszFileName[MAX_PATH];</code></pre>

<pre><code> mbstowcs(wszFileName, szFileName, MAX_PATH);</code></pre>

<pre><code> ITypeLib *ptl = 0;</code></pre>

<pre><code> hr = LoadTypeLib(wszFileName, &amp;ptl);</code></pre>

<pre><code> if (SUCCEEDED(hr))</code></pre>

<pre><code> {</code></pre>

<pre><code> hr = RegisterTypeLib(ptl, wszFileName, 0);</code></pre>

<pre><code> ptl-&gt;Release();</code></pre>

<pre><code> }</code></pre>

<pre><code> RegSetValueA(HKEY_CLASSES_ROOT, &quot;CLSID\\{8C54EFA2-B85F-11d0-8C3E-0080C73925BA}&quot;, REG_SZ, &quot;TimeOfDay Object&quot;, 23);</code></pre>

<pre><code> RegSetValueA(HKEY_CLASSES_ROOT, &quot;CLSID\\{8C54EFA2-B85F-11d0-8C3E-0080C73925BA}\\LocalServer32&quot;, REG_SZ, szFileName, lstrlenA(szFileName));</code></pre>

<pre><code> }</code></pre>

<pre><code> CoUninitialize();</code></pre>

<pre><code> return hr;</code></pre>

<pre><code> }</code></pre>

<p><font size="4"></font>&nbsp;</p>

<p>&nbsp;</p>

<p><b>Figure 9 Visual Basic
Time Zone Client</b></p>
<p><img src="actx9.gif"></p>
<p><b>Figure 10 Multi-Time
Zone TimeOfDay Using Monikers</b></p>

<pre><code>Form1.FRM</code></pre>

<pre><code>VERSION 5.00</code></pre>

<pre><code>Begin VB.Form Form1 </code></pre>

<pre><code>Caption = &quot;It's Moniker Time!&quot;</code></pre>

<pre><code>ClientHeight = 2475</code></pre>

<pre><code>ClientLeft = 240</code></pre>

<pre><code>ClientTop = 1545</code></pre>

<pre><code>ClientWidth = 4275</code></pre>

<pre><code>LinkTopic = &quot;Form1&quot;</code></pre>

<pre><code>ScaleHeight = 2475</code></pre>

<pre><code>ScaleWidth = 4275</code></pre>

<pre><code>Begin VB.Timer Timer1 </code></pre>

<pre><code>Interval = 1000</code></pre>

<pre><code>Left = 3480</code></pre>

<pre><code>Top = 360</code></pre>

<pre><code>End</code></pre>

<pre><code>Begin VB.Label Label5 </code></pre>

<pre><code>Caption = &quot;Label1&quot;</code></pre>

<pre><code>BeginProperty Font </code></pre>

<pre><code>Name = &quot;Arial&quot;</code></pre>

<pre><code>Size = 12</code></pre>

<pre><code>Charset = 0</code></pre>

<pre><code>Weight = 700</code></pre>

<pre><code>Underline = 0 'False</code></pre>

<pre><code>Italic = 0 'False</code></pre>

<pre><code>Strikethrough = 0 'False</code></pre>

<pre><code>EndProperty</code></pre>

<pre><code>Height = 375</code></pre>

<pre><code>Left = 120</code></pre>

<pre><code>TabIndex = 4</code></pre>

<pre><code>Top = 2040</code></pre>

<pre><code>Width = 4000</code></pre>

<pre><code>End</code></pre>

<pre><code>Begin VB.Label Label4 </code></pre>

<pre><code>Caption = &quot;Label1&quot;</code></pre>

<pre><code>BeginProperty Font </code></pre>

<pre><code>Name = &quot;Arial&quot;</code></pre>

<pre><code>Size = 12</code></pre>

<pre><code>Charset = 0</code></pre>

<pre><code>Weight = 700</code></pre>

<pre><code>Underline = 0 'False</code></pre>

<pre><code>Italic = 0 'False</code></pre>

<pre><code>Strikethrough = 0 'False</code></pre>

<pre><code>EndProperty</code></pre>

<pre><code>Height = 375</code></pre>

<pre><code>Left = 120</code></pre>

<pre><code>TabIndex = 3</code></pre>

<pre><code>Top = 1560</code></pre>

<pre><code>Width = 4000</code></pre>

<pre><code>End</code></pre>

<pre><code>Begin VB.Label Label3 </code></pre>

<pre><code>Caption = &quot;Label1&quot;</code></pre>

<pre><code>BeginProperty Font </code></pre>

<pre><code>Name = &quot;Arial&quot;</code></pre>

<pre><code>Size = 12</code></pre>

<pre><code>Charset = 0</code></pre>

<pre><code>Weight = 700</code></pre>

<pre><code>Underline = 0 'False</code></pre>

<pre><code>Italic = 0 'False</code></pre>

<pre><code>Strikethrough = 0 'False</code></pre>

<pre><code>EndProperty</code></pre>

<pre><code>Height = 375</code></pre>

<pre><code>Left = 120</code></pre>

<pre><code>TabIndex = 2</code></pre>

<pre><code>Top = 1080</code></pre>

<pre><code>Width = 4000</code></pre>

<pre><code>End</code></pre>

<pre><code>Begin VB.Label Label2 </code></pre>

<pre><code>Caption = &quot;Label1&quot;</code></pre>

<pre><code>BeginProperty Font </code></pre>

<pre><code>Name = &quot;Arial&quot;</code></pre>

<pre><code>Size = 12</code></pre>

<pre><code>Charset = 0</code></pre>

<pre><code>Weight = 700</code></pre>

<pre><code>Underline = 0 'False</code></pre>

<pre><code>Italic = 0 'False</code></pre>

<pre><code>Strikethrough = 0 'False</code></pre>

<pre><code>EndProperty</code></pre>

<pre><code>Height = 375</code></pre>

<pre><code>Left = 120</code></pre>

<pre><code>TabIndex = 1</code></pre>

<pre><code>Top = 600</code></pre>

<pre><code>Width = 4000</code></pre>

<pre><code>End</code></pre>

<pre><code>Begin VB.Label Label1 </code></pre>

<pre><code>Caption = &quot;Label1&quot;</code></pre>

<pre><code>BeginProperty Font </code></pre>

<pre><code>Name = &quot;Arial&quot;</code></pre>

<pre><code>Size = 12</code></pre>

<pre><code>Charset = 0</code></pre>

<pre><code>Weight = 700</code></pre>

<pre><code>Underline = 0 'False</code></pre>

<pre><code>Italic = 0 'False</code></pre>

<pre><code>Strikethrough = 0 'False</code></pre>

<pre><code>EndProperty</code></pre>

<pre><code>Height = 375</code></pre>

<pre><code>Left = 120</code></pre>

<pre><code>TabIndex = 0</code></pre>

<pre><code>Top = 120</code></pre>

<pre><code>Width = 4000</code></pre>

<pre><code>End</code></pre>

<pre><code>End</code></pre>

<pre><code>Attribute VB_Name = &quot;Form1&quot;</code></pre>

<pre><code>Attribute VB_GlobalNameSpace = False</code></pre>

<pre><code>Attribute VB_Creatable = False</code></pre>

<pre><code>Attribute VB_PredeclaredId = True</code></pre>

<pre><code>Attribute VB_Exposed = False</code></pre>

<pre><code>Dim defaultTime As ITimeOfDay</code></pre>

<pre><code>Dim pacificTime As ITimeOfDay</code></pre>

<pre><code>Dim mountainTime As ITimeOfDay</code></pre>

<pre><code>Dim centralTime As ITimeOfDay</code></pre>

<pre><code>Dim easternTime As ITimeOfDay</code></pre>



<pre><code>Private Sub Form_Load()</code></pre>

<pre><code>Set defaultTime = GetObject(&quot;clsid:8C54EFA2-B85F-11d0-8C3E-0080C73925BA&quot;)</code></pre>

<pre><code>Set pacificTime = GetObject(&quot;clsid:8C54EFA2-B85F-11d0-8C3E-0080C73925BA:!pacific&quot;)</code></pre>

<pre><code>Set mountainTime = GetObject(&quot;clsid:8C54EFA2-B85F-11d0-8C3E-0080C73925BA:!mountain&quot;)</code></pre>

<pre><code>Set centralTime = GetObject(&quot;clsid:8C54EFA2-B85F-11d0-8C3E-0080C73925BA:!central&quot;)</code></pre>

<pre><code>Set easternTime = GetObject(&quot;clsid:8C54EFA2-B85F-11d0-8C3E-0080C73925BA:!eastern&quot;)</code></pre>

<pre><code>End Sub</code></pre>



<pre><code>Private Sub Timer1_Timer()</code></pre>

<pre><code>Label1.Caption = &quot;Default Time: &quot; &amp; defaultTime.GetCurrentTimeOfDay &amp; Chr(13)</code></pre>

<pre><code>Label2.Caption = &quot;Pacific Time: &quot; &amp; pacificTime.GetCurrentTimeOfDay &amp; Chr(13)</code></pre>

<pre><code>Label3.Caption = &quot;Mountain Time: &quot; &amp; mountainTime.GetCurrentTimeOfDay &amp; Chr(13)</code></pre>

<pre><code>Label4.Caption = &quot;Central Time: &quot; &amp; centralTime.GetCurrentTimeOfDay &amp; Chr(13)</code></pre>

<pre><code>Label5.Caption = &quot;Eastern Time: &quot; &amp; easternTime.GetCurrentTimeOfDay &amp; Chr(13)</code></pre>

<pre><code>End Sub</code></pre>



<p>No discussion of singletons
would be complete without addressing in-process servers. Mixing
singletons and in-process servers is generally a bad idea for
several reasons. First, it is impossible to have one instance per
machine, as each client will load the server DLL independently
and will have its own unique instance of the singleton, which
ultimately results in a per-process singleton.
Second,&nbsp;unless&nbsp;the CLSID for the singleton is
marked&nbsp;TheadingModel=Free (which means its objects run in
the MTA of the process) or has no threading model at all (which
means its objects run in the first STA of the process), COM will
allow direct access to the class object (and any singletons it
exports) from more than one apartment. This generally breaks the
identity model used by COM&#146;s remoting layer.</p>

<p>Multi-apartment&nbsp;access
is&nbsp;especially&nbsp;bad&nbsp;news&nbsp;if
your&nbsp;singletons&nbsp;have&nbsp;data members that are
interface pointers.&nbsp;In&nbsp;ThreadingModel=Both or
ThreadingModel=Apartment-based singletons, interface pointer data
members belong to the apartment of the thread that initializes
them. If a thread from another apartment calls a method that in
turn invokes methods through these interface pointers, the
results are undefined. Undefined behavior in programs went out of
fashion with Windows® 3.1 and is now considered socially
unacceptable programming style. While cross-thread marshaling
could help in this situation&nbsp;somewhat, the complexity that
this would add to the design of the object probably warrants just
deploying singletons using ThreadingModel=Free or as
out-of-process servers. It is likely that future versions of COM
will provide better support for cross-apartment access to
pointers. Check future installments of this column for more
coverage of this topic as details become available.</p>

<p>Finally, if you are implementing
a singleton object as an out-of-process server, be aware that if
you don&#146;t explicitly configure your server to run as a
distinguished login account, it will run using the login account
of the activator. If more than one user tries to access your
singleton on a given machine, the SCM will start multiple copies
of your server process, resulting in a per-user singleton instead
of a per-machine singleton. This severely limits the number of
clients that can access your server, as spawning a process (and
probably a window station) per object is extremely expensive. 
Figure 11 shows how to use DCOMCNFG to change the
activating identity to that of a distinguished user account,
ensuring that only one copy of the server process will be
started.</p>


<p><strong>Figure 11 Using
DCOMCNFG</strong></p>

<p>In this column I addressed using
monikers as a generic, extensible object activation mechanism.
The examples I used leveraged the concept of class objects to
provide custom activation interfaces as well as to implement
singletons. One moniker-related topic that I didn&#146;t address
was the Running Object Table (ROT). The ROT is a facility
provided by the SCM that allows instances to be associated with
monikers. While the ROT is an integral part of the file moniker
protocol and of some custom monikers, I was able to achieve the
same effect by using the SCM&#146;s Class Table and the class
moniker. If you are interested in more information on monikers,
surf over to http://www.develop.com/dbox/com/mk and download the
source code. </p>


<p><font color="#000080" size="2" face="Verdana">Have a question
about programming with ActiveX or COM? Send it to Don Box at
dbox@develop.com or http://www.develop.com/dbox.</p>
</font></body>
</html>
