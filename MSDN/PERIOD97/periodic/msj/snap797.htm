<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Create Apps That Are Easily Extensible with Our Smart &quot;Snap-Ins&quot; Methodology</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF>

<font face="verdana,arial,helvetica" size="2">
<h1>Create Apps That Are Easily Extensible with Our Smart &quot;Snap-Ins&quot; Methodology</h1>
<p>Steve Zimmerman</p>
<p>Steve Zimmerman is a senior software engineer and an adjunct professor at the University of Phoenix. He can be reached at zimsoft@aros.net.</p>
<p>
If you’re doing serious commercial software development, it’s likely you are writing an application that must be easily extensible. Perhaps you plan to eventually incorporate features that will be developed by other product teams in your company. Maybe the application will be packaged as several products with varying levels of functionality—named the Standard, Professional, and Enterprise Editions, of course—meaning that you must be able to conditionally enable certain components when the product is installed. You might even have plans to publish an API that allows third-party developers to write extension components that integrate seamlessly into your application.</p>
<p>
For example, let’s say you’ve just written a simple word processor like the WordPad application that ships with Windows&reg; 95 and Windows NT&reg; 4.0. Now you want to <BR>create a Professional Edition that provides some of the tools found in other commercial word processors, such as autocorrection, spellchecking, document statistics, and duplicate word removal. In addition, you want to let other vendors provide tools that snap into the application, such <BR>as syntax highlighting, grammar checking, or document <BR>revision management.</p>
<p>
While none of these extension components, which I’ll <BR>call snap-ins, are part of the standard product, you want them added to the application’s menu bar and toolbar <BR>once they are installed so they are visually integrated. For now, let me merely define a snap-in as a simple in-pro&shy;cess&nbsp;COM server that can be hosted by a client app&shy;licationæsimilar to the way that an ActiveX™ control is hosted by an ActiveX control container. A little later on, <BR>I’ll fill you in on the details of a snap-in implementation <BR>I have developed that uses an interface called, appropriately, ISnapIn.</p>
<p>
In this article, I’ll show you how to write an application that supports snap-ins. In the spirit of the example given above, I’ll convert the MFC WordPad sample into an extensible snap-in client. I’ll also provide you with three extension components that snap into it: a snap-in that counts and displays the number of the words in the document; a snap-in that removes all duplicate entries of a word (it fixes the “to to” mistake in “I went to to the store”); and a snap-in that automatically corrects common spelling errors.</p>
<p>
Before going any further, I want to make it clear that <BR>I’m not attempting to come up with a replacement for <BR>full-featured ActiveX controls. Therefore, if your goal is <BR>to create general-purpose controls such as the Microsoft Calendar Control that support the umpteen control <BR>interfaces expected by a well-rounded ActiveX control container, you’ll have to read elsewhere. Furthermore, I’m <BR>not going to show you how to write a container applica-<BR>tion that is anywhere near as robust as Visual Basic&reg; <BR>or Microsoft Excel. What I am going to do is show you <BR>how to give your application a basic level of extensibility without going to all the effort required to be a full-blown control container.</p>
<p>
I should also point out that since the sample code I’ve written uses the Active Template Library (ATL) and takes advantage of new interfaces provided by the ActiveX SDK, I’ve developed it using Visual C++&reg; 5.0. If you’re still using Visual C++  4.2b, you’ll be able to compile the code, but you’ll need to download the latest version of ATL and create your own makefiles (Visual C++ 5.0 project files are not backwards-compatible).</p>
<h2>The Ideal Snap-In</h2>
<p>
Before I get to my specific snap-in implementation, let’s talk about the general case. While it has obvious advantages, writing an extensible application is tricky. When designing the application, you can’t make any assumptions about what snap-ins will be available at runtime or you’ll end up releasing a new version of the product every time a new snap-in is created. Similarly, your snap-ins can’t rely too much on the implementation details of the host application or they’ll need to be rewritten every time the application is modified. In short, the less your application and its snap-ins know about each other, the better. With that goal in mind, I’ve come up with the following guidelines.</p>
<p>
A snap-in should be self-registering. When a new snap-in is installed, the user should not have to perform any special action from within the host application to enable it. Once registered, the snap-in should appear in the application’s toolbar and menu bar automatically. Similarly, when a snap-in is removed, it should require no action from within the application and should leave no trace.</p>
<p>
If appropriate, a snap-in should be able to work with more than one host. While a snap-in must expect specific interfaces to be made available by its clients, the snap-in should work with any application that exposes the interfaces it recognizes. In other words, it should be possible to add a spellchecker snap-in to any application that provides it with an interface method—called something like GetDocumentBuffer—that exposes an LPSTR.</p>
<p>
A snap-in should be context sensitive. Depending upon the state of the host application, a snap-in should be able to perform different functions. For example, if a WordPad user selects a block of text with the mouse, a word-count snap-in would display the number of currently selected words. If no text is selected, the snap-in would instead display the total number of words in the document.</p>
<p>
A snap-in should receive notification messages from its container when the user clicks the toolbar button or menu item associated with the snap-in, or whenever the internal state of the application changes in a way that affects the snap-in. </p>
<p>
While a snap-in could be implemented in a number of ways, it is an ideal candidate for COM due to the nature of the communication between the snap-in and its container. Specifically, a snap-in exposes a well-defined set of functions that allows it to be fully integrated with the host application. In turn, the host exposes one or more interfaces that are recognized by the snap-in. While this model is similar to the traditional ActiveX control container approach, its implementation is likely to be much simpler because a snap-in and its host each need to expose only a single interface (in addition to IUnknown, of course). However, according to the latest ActiveX specification, an ActiveX control is simply a self-registering COM object that supports IUnknown. Thus, in a very real sense, snap-ins are a specialized form of ActiveX controls and a snap-in host is an ActiveX control container!</p>
<h2>The ISnapIn Interface</h2>
<p>
It is unlikely that my implementation of a snap-in interface—which I named simply ISnapIn for lack of a better name—will meet the needs of every application, but what I’ve come up with will hopefully help you get headed in the right direction. An explanation of each of the ISnapIn methods is shown in Figure 1. You’ll notice that the ISnapIn interface gives the snap-in the flexibility to provide its container with one or more of the following visual elements: menu item text, status bar text, tooltip text, and various sizes of toolbar buttons. However, the snap-in can run silently without any visual interface at all.</p>
<p>
Figure 1  ISnapIn Interface Methods</p>
<p>
<b>Method&#09;Description</b></p>
<p>
HINSTANCE GetResourceInstance(void)&#09;Returns a handle to the module that contains the string and bitmap resources used to add the snap-in to the menu bar and toolbar. You can return NULL if the snap-in won’t appear as a menu item.</p>
<p>
int GetMenuTextID(void)&#09;Returns the resource ID of the menu item text for the snap-in. If you don’t want the snap-in to appear as a menu item, you should return –1.</p>
<p>
int GetMessageTextID(void)&#09;Returns the resource ID of the status bar text. To provide a tooltip, place that text <BR>at the end of the status bar text, separated by \n. If you don’t want text to appear <BR>in the status bar, you should return –1. This method is only called if the snap-in appears as a menu item.</p>
<p>
int GetBitmapID(nSize)&#09;Returns the resource ID of the bitmap to be displayed in the application toolbar. Since the application may support various toolbar sizes, the button size is passed <BR>as a parameter. If you don’t want the snap-in to appear in the toolbar, or if you don’t support a particular bitmap size, you should return –1. This method is only called if the snap-in appears as a menu item. </p>
<p>
BOOL SupportsInterface(IUnknown* lpUnk)&#09;Although an application should only load snap-ins that are marked in the registry as supporting a compatible interface, this method provides an extra safeguard. The application passes this method its context interface immediately after the snap-in is loaded. If the snap-in cannot successfully query an interface that it recognizes, it returns FALSE.</p>
<p>
void OnStateChange(IUnknown* lpUnk)&#09;Called whenever the state of an application changes in a way that affects the snap-in. The application passes this method a pointer to its context interface.</p>
<p>
void IsEnabled(IUnknown* lpUnk)&#09;Called by the application to determine whether or not the snap-in menu item should be enabled. In an MFC application, this method is called in response to an ON_UPDATE_<BR>COMMAND_UI message. Thus, depending upon application context, a snap-in may be unavailable to the user.</p>
<p>
void OnCommand(IUnknown* lpUnk)&#09;Called when the user selects the snap-in from the menu bar or toolbar. The application passes this method a pointer to its context interface.</p>
<p>
The ISnapIn interface methods are divided into two functional categories: methods such as GetMenuTextID that provide user-interface integration and methods that respond to user actions. While the user-interface functions are required for menu-merging and toolbar support, the functions that do the real work are the action functions. Specifically, OnStateChange is called whenever the state of the host application changes, and OnCommand is called when the user selects the snap-in from the toolbar, menu, or other user interface mechanism. Obviously, the action performed by these two interface methods depends entirely upon the functionality of the snap-in. In the case of my souped-up version of WordPad, the application calls each snap-in’s OnStateChange method whenever the user changes the text of the document. The word-count snap-in, for example, counts each word in the document and displays the result in the application’s status bar, as shown at the bottom of Figure 2.</p>
<p>
<img src="snapin2.gif" border=0></p>
<p>
Figure 2  The Improved WordPad Application</p>
<h2>See No Evil</h2>
<p>
Obviously, a host application must share information with its snap-ins for them to do anything useful. The WordPad sample, for example, exposes the window handle of the rich edit control containing the user’s document. However, it wouldn’t make sense to implement an ISnapIn interface that always expected its container to pass it a rich edit control—or any other application-specific data, for that matter—because you’d have to come up with a new interface every time you wrote an application that exposed something different. Instead, I’ve implemented ISnapIn so that the only context information passed to the snap-in by its container is a pointer to IUnknown. Of course, IUnknown by itself isn’t very useful, but a snap-in can use it to check for the existence of other interfaces it recognizes by using the QueryInterface method.</p>
<p>
The sample snap-ins I wrote look for IRichDocContext—an essentially brain-dead interface I invented that has only two methods: GetRichEditControl and SetStatusText. My new version of WordPad implements IRichDocContext, of course, but the snap-ins it hosts don’t know that they’re integrated with WordPad—they just know that they’re talking to an application that supports IRichDocContext. In your own application, you can expose whatever interfaces you want, but since the entry-point to those interfaces is IUnknown, your snap-ins can implement the exact same ISnapIn interface as the ones I’ve provided.</p>
<h2>Component Registration</h2>
<p>
One of the most important design considerations when writing an extension component is to determine how it will make its existence known to host applications. In other words, if you deploy your application tomorrow and a compatible snap-in is installed on the computer a year from now, how will your application know about it? One method would be for the snap-in to place information about itself in a predefined section of your application’s registry settings. Following this logic, a WordPad-compatible snap-in would place information about itself in the HKEY_CUR&shy;RENT_USER\Software\Microsoft\Windows\CurrentVersion\<BR>Applets\WordPad\SnapIns registry section. Each time it was executed, WordPad would check the registry to see if a new snap-in had been added.</p>
<p>
While this approach would probably be adequate for snap-ins that are only designed to work with a single application, it suffers from scalability problems. Using this technique, whenever a new snap-in was installed, it would have to determine what compatible applications were already on the machine and place information about itself in the registry section of each application. As a result, a snap-in would have to know an unhealthy amount of information about each of its containers. Furthermore, every time you installed a new application, you’d have to reinstall each of its snap-ins or the application wouldn’t know they existed.</p>
<p>
The widely accepted method for solving this problem <BR>has been to place one or more specially-named empty registry keys beneath the CLSID entry of the component as a way of indicating that the component supports a certain category of interfaces. To find its compatible components, an application scans through the list of components found in the registry, looking for CLSID entries marked with <BR>the keys that correspond to the interfaces it requires. <BR>For example, Figure 3 shows the CSLID registry entry <BR>for the Microsoft Calendar Control. You’ll notice that <BR>it contains two empty keys: Control and Programmable. <BR>Because these keys exist, an ActiveX control container <BR>like Visual Basic 4.<i>x</i> knows it can host that control.</p>
<p>
<img src="snapin3.gif" border=0></p>
<p>
Figure 3  The Microsoft Calendar Control Registry Entry</p>
<p>
This approach is clearly a much better solution than the one I described earlier because it does not require a control to know anything about its containers. But while this approach has worked fairly well for traditional ActiveX controls, it still has a serious flaw when applied to snap-ins. Suppose you added a special key—named SnapIn, of course—to the CLSID entry for your snap-in, indicating that it supports the ISnapIn interface. This information alone would be insufficient because a host application must also know which snap-ins handle the specific interfaces it exposes. As a result, you’d also have to assign special registry keys for each type of exposed application interface. For example, since WordPad exposes an interface named IRichDocContext, it would have to look for all components marked with two keys: one named SnapIn and the other named something like SupportsRichDocument. If this categorization method were widely used, there would eventually be name collisions in the snap-in category descriptions. Perhaps a software developer in New Jersey would develop an application with an interface called IAmARichDoctor, but also name its corresponding registry key Supports&shy;RichDocument. Or even worse, some guy in Vernal, Utah, would tweak the ISnapIn interface but still use the word SnapIn as its registry keyword. Pretty soon you’d end up with a real mess.</p>
<p>
Fortunately, with the release of the ActiveX Platform SDK, there’s a new specification—component categories—that solves these problems. Similar to the special keys used to classify traditional ActiveX controls, component categories are registry entries that describe the type of functionality an ActiveX component supports. However, there are several improvements over the old model.</p>
<p>
Instead of using human-readable names, component categories are defined using globally unique identifiers called category identifiers, or CATIDs. For example, the CATIDs registered on my machine are shown in Figure 4. Because a CATID is guaranteed to be unique, there’s no fear of name collisions between different categories. Each CATID has one or more locale-specific text descriptions associated with it, stored in a well-known location in the registry. This makes it easier for control containers to support multiple languages.</p>
<p>
<img src="snapin4.gif" border=0></p>
<p>
Figure 4  Component Categories</p>
<p>
In addition to describing the categories it implements, an ActiveX control can also describe the categories it requires from its container. This extra information will help solve a problem that has frustrated ActiveX control developers in the&nbsp;past.&nbsp;Previously,&nbsp;even&nbsp;when&nbsp;a&nbsp;developer&nbsp;created&nbsp;a&nbsp;control that provided all of the required interfaces, he or she might get varied—and often undesired—results due to the different way each control container (Visual Basic 4.<i>x</i> or 5.0, Microsoft&nbsp;Excel,&nbsp;Internet&nbsp;Explorer&nbsp;3.0, Visual C++ Test <BR>Con&shy;tainer, and so on) interacts with the control. Since a developer can now define the exact set of interfaces that <BR>the ActiveX&nbsp;control&nbsp;requires&nbsp;its&nbsp;container&nbsp;to&nbsp;implement, these inconsistencies should eventually disappear. Unfortunately, backward com&shy;pat&shy;ibility with old containers will still be a  problem.</p>
<p>
There is a system-provided COM object called the Component Category Manager that gives you two interfaces—ICatRegister and ICatInformation—that you can use to store and retrieve category information from the registry. No more parsing the registry by hand to find the controls that implement a certain category! While you’ll need to refer to the online help for specific information on how to use those interfaces, here’s how easy it is to create instances of them:</p>
<p>
ICatInformation* lpCatInfo;</p>
<p>
HRESULT hr = CoCreateInstance(</p>
<p>
    CLSID_StdComponentCategoriesMgr, NULL,</p>
<p>
    CLSCTX_INPROC_SERVER, IID_ICatInformation,</p>
<p>
    (LPVOID*) &amp;lpCatInfo);</p>
<p>
ICatRegister* lpCatReg;</p>
<p>
hr = CoCreateInstance(</p>
<p>
    CLSID_StdComponentCategoriesMgr, NULL,</p>
<p>
    CLSCTX_INPROC_SERVER, IID_ICatRegister,</p>
<p>
    (LPVOID*) &amp;lpCatReg);</p>
<h2>Snap-In Component Categories</h2>
<p>
As I mentioned earlier, I came up with a simple interface called ISnapIn that provides just enough information to allow you to integrate a COM object with an application. Naturally, I defined a component category called CATID_<BR>ISnapIn that classifies an ActiveX component as a snap-in. While most component categories indicate support for <BR>several interfaces, registering your component as a member of the CATID_ISnapIn category simply means you guarantee that your object implements ISnapIn. In fact, I’ll confess that&nbsp;the GUID I used to identify the CATID_ISnapIn category is the same one that identifies the ISnapIn interface, as you can see in Figure 5. For the WordPad sample, I also defined a category named CATID_IRichDocContext that applies only to containers supporting my IRich&shy;DocContext interface.</p>
<dl>
<dt>
Figure 5  CATID_ISnapIn and ISnapIn Declarations</dt>
<dd>
// Copyright (c) 1997, Microsoft Systems Journal<p>
// Author: Steve Zimmerman</p>
<p>
//</p>
<p>
// ISnapIn Interface Definition:</p>
<p>
// {6AE74760-83C6-11D0-A2A7-000000000000}</p>
<p>
DEFINE_GUID(IID_ISnapIn,</p>
<p>
    0x6ae74760, 0x83c6, 0x11d0, 0xa2, 0xa7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);</p>
<p>
#define CATID_ISnapIn IID_ISnapIn</p>
<p>
DECLARE_INTERFACE_(ISnapIn, IUnknown)</p>
<p>
{</p>
<p>
    STDMETHOD_(BOOL, SupportsInterface)(THIS_ IUnknown* lpUnk) PURE;</p>
<p>
    STDMETHOD_(HINSTANCE, GetResourceInstance) (THIS_) PURE;</p>
<p>
    STDMETHOD_(int, GetMenuTextID)(THIS_) PURE;</p>
<p>
    STDMETHOD_(int, GetMessageTextID)(THIS_) PURE;</p>
<p>
    STDMETHOD_(int, GetBitmapID)(THIS_ UINT nSize) PURE;</p>
<p>
    STDMETHOD_(BOOL, IsEnabled)(THIS_ IUnknown* lpUnk) PURE;</p>
<p>
    STDMETHOD_(void, OnStateChange)(THIS_ IUnknown* lpUnk) PURE;</p>
<p>
    STDMETHOD_(void, OnCommand)(THIS_ IUnknown* lpUnk) PURE;</p>
<p>
};</p>
</dd>
</dl>
<p>
In production-quality code, you should not use the same GUID to identify both the CATID and its associated interfaces. However, since the code I’ve provided is just a sample, what I’ve done is probably OK. Furthermore, even though the number of possible component categories is infinite, you should avoid defining a new component category if there is an existing category that can be used instead. This suggestion is consistent with the idea that controls and containers should be designed with optimum interoperability in mind. As with regular ActiveX controls, if you are writing production-quality snap-ins or snap-in containers, you should collaborate with other vendors when defining new component categories to ensure that they meet the common requirements of your market. Microsoft has said it plans <BR>to provide an up-to-date list of the component categories developed by itself and Microsoft vendor partners at <BR>http://www.microsoft.com. At press time the exact URL had not been defined, but I expect it will be in the near future. In the meantime, a search of the site for “component categories” may be helpful.</p>
<h2>Come On Up to My Pad</h2>
<p>
Before I delve into the details of my sample snap-ins, let me explain the enhancements I made to WordPad so that it supports them. When making these changes, I had two goals in mind. First, I wanted to change as few routines as possible. In the spirit of information hiding—a key concept in object-oriented design—I wanted the application to know as little about snap-ins as possible. I’ll also admit that I didn’t want to have to take the time to learn about the inner-workings of WordPad—I just wanted to sneak into the code, add the snap-in logic, and get out! My secondary goal was to encapsulate the snap-in code so that it would be easily reusable. If I’ve done my job well, you’ll be able to take the code I added to WordPad and slip it into your own application with little effort.</p>
<p>
What I ended up with was two classes, CSnapInFrame and CSnapIn, that implement the functionality required <BR>to be a snap-in container. An overview of those classes appears in Figure 6. Adding them to the WordPad code that ships with Visual C++ was fairly easy.  Since the Word&shy;Pad project contains many files, I created a SnapIn subdirectory beneath Pro&shy;ject Root in which I placed all of the reusable code. Then, I added those files to the project.</p>
<p>
Figure 6  CSnapInFrame and CSnapIn Classes</p>
<p>
<b>Class&#09;Explanation</b></p>
<p>
CSnapInFrame&#09;Derived from CFrameWnd, this class looks up the compatible snap-ins in the registry (using the ICatInformation interface), creates a snap-in toolbar, routes command messages to the snap-in, and performs special handling required to enable the snap-in status bar messages and tooltips.</p>
<p>
CSnapIn&#09;Creates an instance of the specified snap-in class and provides a light wrapper around the ISnapIn interface. Adds the snap-in menu item and toolbar button to the application’s menu bar and toolbar.</p>
<p>
I replaced all references to CFrameWnd in mainfrm.h and mainfrm.cpp so that CMainFrame was derived from CSnapInFrame. I created a simple interface, IRichDocCon&shy;text, that WordPad uses to make its context information available to the snap-ins. The header file for that interface is shown in Figure 7. I added the header file to the project <BR>and added the following code to the CMainFrame class definition:</p>
<p>
DECLARE_INTERFACE_MAP()</p>
<p>
BEGIN_INTERFACE_PART(ContextObj, IRichDocContext)</p>
<p>
    STDMETHOD_(HWND, GetRichEditCtrl)();</p>
<p>
    STDMETHOD_(void, SetStatusText)(LPCTSTR);</p>
<p>
END_INTERFACE_PART(ContextObj)</p>
<dl>
<dt>
Figure 7  Header File for IRichDocContext</dt>
<dd>
// Copyright (c) 1997, Microsoft Systems Journal<p>
// Author: Steve Zimmerman</p>
<p>
//</p>
<p>
// IRichDocContext Interface Definition:</p>
<p>
// {305BB760-8993-11D0-A2C4-000000000000}</p>
<p>
DEFINE_GUID(IID_IRichDocContext, </p>
<p>
    0x305bb760, 0x8993, 0x11d0, 0xa2, 0xc4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);</p>
<p>
#define CATID_IRichDocContext IID_IRichDocContext</p>
<p>
DECLARE_INTERFACE_(IRichDocContext, IUnknown)</p>
<p>
{</p>
<p>
    STDMETHOD_(HWND, GetRichEditCtrl)() PURE;</p>
<p>
    STDMETHOD_(void, SetStatusText)(LPCTSTR) PURE;</p>
<p>
};</p>
</dd>
</dl>
<p>
If you’ve used OLE with MFC, you’ll immediately recognize this as the way to expose a COM interface. I don’t have the space to explain what these macros do and how they work, so if you’ve never done this type of thing before, I recommend you read (and reread) the MFC help topic entitled “TN038: MFC/OLE IUnknown Implementation.” It is sufficient to say that those macros create an embedded class within CMainFrame—called XContextObj, incidentally—that implements the IRichDocContext interface. They also create a member variable named m_xContextObj that represents an instance of the interface. Thus, somewhere in the source code for CMainFrame, I had to implement the GetRichEditCtrl and SetStatusText methods (see Figure 8). As expected, my GetRichEditCtrl interface method returns the window handle of the rich edit control used to display the WordPad document:</p>
<p>
HWND FAR EXPORT CMainFrame::XContextObj::GetRichEditCtrl()</p>
<p>
{</p>
<p>
    METHOD_PROLOGUE(CMainFrame, ContextObj)</p>
<p>
    CRichEditView* pView =</p>
<p>
        DYNAMIC_DOWNCAST(CRichEditView,</p>
<p>
                         pThis-&gt;GetActiveView());</p>
<p>
    ASSERT(pView);</p>
<p>
    return pView-&gt;GetRichEditCtrl().GetSafeHwnd();</p>
<p>
}</p>
<p>
Your applications probably won’t use IRichDocContext—at least I sure hope not, because it is admittedly a kludge—but you can still follow this model.</p>
<dl>
<dt>
Figure 8  Functions Added to CMainFrame</dt>
<dd>
// Changes to the CMainFrame class<p>
//</p>
<p>
IUnknown* CMainFrame::GetSnapInContext(int nMsg)</p>
<p>
{</p>
<p>
    // This function is called whenever we need to expose</p>
<p>
    // an interface to the snap-in. If this application</p>
<p>
    // has just called OnStateChange, which results in a</p>
<p>
    // call to this function, nMsg will be an application</p>
<p>
    // defined value that gives us added flexibility.</p>
<p>
    // Otherwise, nMsg is zero. In the case of WordPad, we</p>
<p>
    // always return the IRichDocContext interface pointer.</p>
<p>
    </p>
<p>
    return &amp;m_xContextObj;</p>
<p>
}</p>
<p>
int CMainFrame::GetSupportedCategories(GUID** ppCatIDs)</p>
<p>
{</p>
<p>
    // CMainFrame supports</p>
<p>
        </p>
<p>
    static CATID CatIDs[1];</p>
<p>
    CatIDs[0] = CATID_IRichDocContext;</p>
<p>
    *ppCatIDs = CatIDs;</p>
<p>
    return 1;</p>
<p>
}</p>
<p>
BEGIN_INTERFACE_MAP(CMainFrame, CSnapInFrame)</p>
<p>
    INTERFACE_PART(CMainFrame, IID_IRichDocContext, ContextObj)</p>
<p>
END_INTERFACE_MAP()</p>
<p>
  </p>
<p>
HWND FAR EXPORT CMainFrame::XContextObj::GetRichEditCtrl()</p>
<p>
{</p>
<p>
    METHOD_PROLOGUE(CMainFrame, ContextObj)</p>
<p>
    CRichEditView* pView =</p>
<p>
        DYNAMIC_DOWNCAST(CRichEditView, pThis-&gt;GetActiveView());</p>
<p>
    ASSERT(pView);</p>
<p>
    return pView-&gt;GetRichEditCtrl().GetSafeHwnd();</p>
<p>
}</p>
<p>
void FAR EXPORT CMainFrame::XContextObj::SetStatusText(LPCTSTR lpText)</p>
<p>
{</p>
<p>
    METHOD_PROLOGUE(CMainFrame, ContextObj)</p>
<p>
    pThis-&gt;SetMessageText(lpText);</p>
<p>
}</p>
<p>
ULONG FAR EXPORT CMainFrame::XContextObj::AddRef()</p>
<p>
{</p>
<p>
    METHOD_PROLOGUE(CMainFrame, ContextObj)</p>
<p>
    return pThis-&gt;ExternalAddRef();</p>
<p>
}</p>
<p>
ULONG FAR EXPORT CMainFrame::XContextObj::Release()</p>
<p>
{</p>
<p>
    METHOD_PROLOGUE(CMainFrame, ContextObj)</p>
<p>
    return pThis-&gt;ExternalRelease();</p>
<p>
}</p>
<p>
HRESULT FAR EXPORT CMainFrame::XContextObj::QueryInterface(</p>
<p>
    REFIID iid, void FAR* FAR* ppvObj)</p>
<p>
{</p>
<p>
    METHOD_PROLOGUE(CMainFrame, ContextObj)</p>
<p>
    return (HRESULT)pThis-&gt;ExternalQueryInterface(&amp;iid, ppvObj);</p>
<p>
}</p>
</dd>
</dl>
<p>
Since I wrote CSnapInFrame to be reusable, it knows nothing about the IRichDocContext interface. As a result, it has two pure virtual functions—GetSnapInContext and GetSupportedCategories—that I had to implement in CMainFrame:</p>
<p>
IUnknown* CMainFrame::GetSnapInContext(int nMsg)</p>
<p>
{</p>
<p>
     return &amp;m_xContextObj;</p>
<p>
}</p>
<p>
int CMainFrame::GetSupportedCategories(GUID** ppCatIDs)</p>
<p>
{</p>
<p>
    static CATID CatIDs[1];</p>
<p>
    CatIDs[0] = CATID_IRichDocContext;</p>
<p>
    *ppCatIDs = CatIDs;</p>
<p>
    return 1;</p>
<p>
}</p>
<p>
In the GetSnapInContext function, although the code actually returns the address of m_xContextObj—an IRich&shy;DocContext pointer, in other words—the return value is cast into a pointer to IUn&shy;known. This way, the CSnap&shy;InFrame class can pass the host interface along to the snap-in without getting its hands dirty. Thanks to COM, when a snap-in gets the IUnknown pointer, it can simply call QueryInterface to get back the pointer to IRichDocContext. Thus, your application can return a pointer to IDontKnow or IDontCare, but you won’t have to change CSnapInFrame.</p>
<p>
The GetSupportedCategories virtual function is the <BR>way an application specifies which container categories it implements. Again, since CSnapInFrame is not application-specific, this function has no default implementation; it must be implemented by any class derived from CSnap&shy;In&shy;Frame. WordPad only implements one snap-in container category, CATID_IRichDocContext, but your application may expose several. In that case, you’d point ppCatIDs <BR>(see the previous code) to an array containing the CATIDs you implement and return the number of elements in that array.</p>
<p>
To notify each snap-in whenever the user changes the WordPad document, I added the following code to CWord&shy;PadView::OnEditChange:</p>
<p>
CMainFrame* pFrame = DYNAMIC_DOWNCAST(CMainFrame,</p>
<p>
                                      AfxGetMainWnd());</p>
<p>
if (pFrame)</p>
<p>
    pFrame-&gt;OnStateChange(EN_CHANGE);</p>
<p>
As you can see, when the user changes the text in the rich edit control, the application routes that message to the frame window. In turn, CSnapInFrame calls the OnState&shy;Change interface method of each snap-in. The frequency of communication between WordPad and its snap-ins makes it possible for the word count snap-in to keep an accurate count of the number of words in the document, which it displays at the bottom of the screen. Incidentally, you should be aware that if you call OnState&shy;Change too often (especially if your snap-ins perform a large number of calculations each time they are called), your application’s responsiveness will suffer.</p>
<p>
To avoid interfering with the registry settings of the real WordPad—it is, after all, an application that ships with Windows 95 and Windows NT 4.0—I changed the enhanced version’s relative registry path from Microsoft\Windows\<BR>CurrentVersion\Applets\WordPad to Microsoft\Microsoft Systems Journal\WordPad. This was more than a matter of politeness, incidentally. As it turns out, WordPad uses MFC’s CDockState class to store and retrieve the position and state of its toolbars. Since my version of WordPad has an additional toolbar, it adds more information to the registry than the original Word&shy;Pad can handle.</p>
<p>
Finally, I changed the project settings so that the output directory for all build configurations is set to a single subfolder. I did this because the data files Word&shy;Pad uses to convert between document types—namely, Word 6 and rich text format—must be located in the same directory as the application. Rather than place duplicate versions of those files in several different directories (Debug, DebugU, Release, and ReleaseU), I have the linker place the output files in a single directory regardless of the configuration. Since those files are quite large, this change will make a significant difference in the size of the file you have to download to get the sample code!</p>
<p>
While it took several steps to wire things up, I was able to add snap-in functionality to WordPad with minimal <BR>code changes. In fact, except for the two snippets of code I described above, all of the changes were specific to C&shy;MainFrame. Figure 8 shows the new functions I added to that class.</p>
<h2>How CSnapInFrame Works</h2>
<p>
While I’ll let you sort through the nitty gritty implementation details of CSnapInFrame at your leisure (see Figure 9), here’s a high-level overview of what it does.</p>
<p>
Figure 9  the CSnapInFrame Class</p>
<p>
SnapFrm.h</p>
<p>
// Copyright (c) 1997, Microsoft Systems Journal</p>
<p>
// Author: Steve Zimmerman</p>
<p>
//</p>
<p>
// SnapFrm.h : header file</p>
<p>
//</p>
<p>
class CSnapIn;</p>
<p>
class CSnapInManager;</p>
<p>
interface ICatInformation;</p>
<p>
interface IEnumCLSID;</p>
<p>
class CSnapInFrame : public CFrameWnd</p>
<p>
{</p>
<p>
protected:</p>
<p>
    DECLARE_DYNAMIC(CSnapInFrame);</p>
<p>
    CTypedPtrArray&lt;CPtrArray, CSnapIn*&gt; m_snapIn;</p>
<p>
    CToolBar m_snapInBar;</p>
<p>
    void HideSnapInBar();</p>
<p>
    virtual ~CSnapInFrame();</p>
<p>
    virtual int CreateSnapInBar();</p>
<p>
    virtual int AddMenuEntries();</p>
<p>
    virtual BOOL GetNextSnapInClsID(ICatInformation** ppCatInfo,</p>
<p>
        IEnumCLSID** ppEnum, CLSID* pClsID);</p>
<p>
    virtual IUnknown* GetSnapInContext(int nMsg) = 0;</p>
<p>
    virtual int GetSupportedCategories(GUID** ppCatIDs) = 0;</p>
<p>
    //{{AFX_MSG(CSnapInFrame)</p>
<p>
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);</p>
<p>
    //}}AFX_MSG</p>
<p>
    DECLARE_MESSAGE_MAP()</p>
<p>
    afx_msg void OnUpdateViewSnapInBar(CCmdUI* pCmdUI);</p>
<p>
    afx_msg BOOL OnViewSnapInBarCheck(UINT nID);</p>
<p>
    afx_msg void OnUpdateSnapIn(CCmdUI* pCmdUI);</p>
<p>
    afx_msg void OnSnapIn(UINT nID);</p>
<p>
    afx_msg BOOL OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT* pResult);</p>
<p>
public:</p>
<p>
    void OnStateChange(int nMsg);</p>
<p>
    //{{AFX_VIRTUAL(CSnapInFrame)</p>
<p>
    public:</p>
<p>
    virtual void ActivateFrame(int nCmdShow = -1);</p>
<p>
    //}}AFX_VIRTUAL</p>
<p>
    virtual void GetMessageString(UINT nID, CString&amp; rMessage) const;</p>
<p>
};</p>
<p>
// These must be defined in order for CSnapInFrame to</p>
<p>
// compile correctly. However, you may define them as</p>
<p>
// you wish in resource.h if these values conflict</p>
<p>
// with yours.</p>
<p>
#ifndef ID_VIEW_SNAPINBAR</p>
<p>
#define ID_VIEW_SNAPINBAR               59999</p>
<p>
#define ID_TOOLS_START                  60000</p>
<p>
#define ID_TOOLS_END                    60100</p>
<p>
#endif</p>
<p>
SnapFrm.cpp</p>
<p>
// Copyright (c) 1997, Microsoft Systems Journal</p>
<p>
// Author: Steve Zimmerman</p>
<p>
//</p>
<p>
// SnapFrm.cpp : implementation file</p>
<p>
//</p>
<p>
#include &quot;stdafx.h&quot;</p>
<p>
#include &quot;..\resource.h&quot;</p>
<p>
#include &lt;comcat.h&gt;</p>
<p>
#include &lt;afxtempl.h&gt;</p>
<p>
#include &quot;ISnapIn.h&quot;</p>
<p>
#include &quot;SnapFrm.h&quot;</p>
<p>
#include &quot;SnapIn.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CSnapInFrame</p>
<p>
IMPLEMENT_DYNAMIC(CSnapInFrame, CFrameWnd)</p>
<p>
CSnapInFrame::~CSnapInFrame()</p>
<p>
{</p>
<p>
    for (int nLoop = 0; nLoop &lt; m_snapIn.GetSize(); nLoop++)</p>
<p>
        delete m_snapIn[nLoop];</p>
<p>
}</p>
<p>
int CSnapInFrame::CreateSnapInBar()</p>
<p>
{</p>
<p>
    EnableDocking(CBRS_ALIGN_ANY);</p>
<p>
    m_snapInBar.Create(this, WS_CHILD|WS_VISIBLE|CBRS_TOP,</p>
<p>
        ID_VIEW_SNAPINBAR);</p>
<p>
    HDC screenDC = ::GetDC(NULL);</p>
<p>
    BOOL bLargeIcons = GetDeviceCaps(screenDC, LOGPIXELSX) &gt;= 120;</p>
<p>
    ::ReleaseDC(NULL, screenDC);</p>
<p>
    if (bLargeIcons)</p>
<p>
        m_snapInBar.SetSizes(CSize(31,30), CSize(24,24));</p>
<p>
    else</p>
<p>
        m_snapInBar.SetSizes(CSize(23,22), CSize(16,16));</p>
<p>
    m_snapInBar.SetBarStyle(m_snapInBar.GetBarStyle() |</p>
<p>
        CBRS_TOOLTIPS |    CBRS_FLYBY | CBRS_SIZE_DYNAMIC);</p>
<p>
    m_snapInBar.EnableDocking(CBRS_ALIGN_ANY);</p>
<p>
    DockControlBar(&amp;m_snapInBar);</p>
<p>
    return bLargeIcons ? 24 : 16;</p>
<p>
}</p>
<p>
#define VIEW_MENU_POSITION        2</p>
<p>
#define TOOLS_MENU_POSITION       5</p>
<p>
int CSnapInFrame::AddMenuEntries()</p>
<p>
{</p>
<p>
    CMenu* pSubMenu = GetMenu()-&gt;GetSubMenu(VIEW_MENU_POSITION);</p>
<p>
    ASSERT(pSubMenu);</p>
<p>
    pSubMenu-&gt;InsertMenu(0, MF_BYPOSITION|MF_STRING|MF_CHECKED,</p>
<p>
        ID_VIEW_SNAPINBAR, _T(&quot;Snap-&amp;In Bar&quot;));</p>
<p>
    HMENU hMenu = ::CreateMenu();</p>
<p>
    GetMenu()-&gt;InsertMenu(TOOLS_MENU_POSITION, MF_BYPOSITION|MF_POPUP,</p>
<p>
        (UINT) hMenu, _T(&quot;&amp;Tools&quot;));</p>
<p>
    return TOOLS_MENU_POSITION;</p>
<p>
}    </p>
<p>
void CSnapInFrame::HideSnapInBar()</p>
<p>
{</p>
<p>
    CControlBar* pBar = GetControlBar(ID_VIEW_SNAPINBAR);</p>
<p>
    if (pBar != NULL)</p>
<p>
        ShowControlBar(pBar, FALSE, FALSE);</p>
<p>
}</p>
<p>
void CSnapInFrame::OnStateChange(int nMsg)</p>
<p>
{</p>
<p>
    for (int nLoop = 0; nLoop &lt; m_snapIn.GetSize(); nLoop++)</p>
<p>
    {</p>
<p>
        ISnapIn* pInt = m_snapIn[nLoop]-&gt;Interface();</p>
<p>
        pInt-&gt;OnStateChange(GetSnapInContext(nMsg));</p>
<p>
    }</p>
<p>
}</p>
<p>
BOOL CSnapInFrame::GetNextSnapInClsID(ICatInformation** ppCatInfo,</p>
<p>
    IEnumCLSID** ppEnum, CLSID* pClsID)</p>
<p>
{</p>
<p>
    ASSERT(ppCatInfo &amp;&amp; ppEnum);</p>
<p>
    </p>
<p>
    // We get a pointer to ICatInformation so that we can find all</p>
<p>
    // of the compatible SnapIns in the registry.</p>
<p>
    </p>
<p>
    if (*ppCatInfo == NULL)</p>
<p>
    {</p>
<p>
        HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,</p>
<p>
            CLSCTX_INPROC_SERVER, IID_ICatInformation, (LPVOID*) ppCatInfo);</p>
<p>
        if (hr != S_OK)</p>
<p>
            return FALSE;</p>
<p>
    }</p>
<p>
    // We only enumerate the SnapIns that support CATID_ISnapIn</p>
<p>
    // and are compatible with this application.</p>
<p>
    if (*ppEnum == NULL)</p>
<p>
    {</p>
<p>
        CATID* pCatIDs;</p>
<p>
        int reqCatIDs = GetSupportedCategories(&amp;pCatIDs);</p>
<p>
        CATID snapInCatID = CATID_ISnapIn;</p>
<p>
        HRESULT hr = (*ppCatInfo)-&gt;EnumClassesOfCategories(1, &amp;snapInCatID,</p>
<p>
            reqCatIDs, pCatIDs, ppEnum);</p>
<p>
        if (hr != S_OK)</p>
<p>
        {</p>
<p>
            (*ppCatInfo)-&gt;Release();</p>
<p>
            return FALSE;</p>
<p>
        }</p>
<p>
        (*ppEnum)-&gt;Reset();</p>
<p>
    }</p>
<p>
    ULONG lFetched;</p>
<p>
    if ((*ppEnum)-&gt;Next(1, pClsID, &amp;lFetched) != S_OK)</p>
<p>
    {</p>
<p>
        (*ppEnum)-&gt;Release();</p>
<p>
        (*ppCatInfo)-&gt;Release();</p>
<p>
        return FALSE;</p>
<p>
    }</p>
<p>
    return TRUE;</p>
<p>
}</p>
<p>
BEGIN_MESSAGE_MAP(CSnapInFrame, CFrameWnd)</p>
<p>
    //{{AFX_MSG_MAP(CSnapInFrame)</p>
<p>
    ON_WM_CREATE()</p>
<p>
    //}}AFX_MSG_MAP</p>
<p>
    ON_UPDATE_COMMAND_UI(ID_VIEW_SNAPINBAR, OnUpdateViewSnapInBar)</p>
<p>
    ON_COMMAND_EX(ID_VIEW_SNAPINBAR, OnViewSnapInBarCheck)</p>
<p>
    ON_UPDATE_COMMAND_UI_RANGE(ID_TOOLS_START, ID_TOOLS_END, OnUpdateSnapIn)</p>
<p>
    ON_COMMAND_RANGE(ID_TOOLS_START, ID_TOOLS_END, OnSnapIn)</p>
<p>
    ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0, 0xFFFF, OnToolTipText)</p>
<p>
    ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0, 0xFFFF, OnToolTipText)</p>
<p>
END_MESSAGE_MAP()</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CSnapInFrame message handlers</p>
<p>
int CSnapInFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) </p>
<p>
{</p>
<p>
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)</p>
<p>
        return -1;</p>
<p>
    int nBmpSize = CreateSnapInBar();</p>
<p>
    CLSID clsID;</p>
<p>
    IEnumCLSID* pEnum = NULL;</p>
<p>
    ICatInformation* pCatInfo = NULL;</p>
<p>
    int nSubMenu;</p>
<p>
    int nIndex = 0;</p>
<p>
    while (GetNextSnapInClsID(&amp;pCatInfo, &amp;pEnum, &amp;clsID))</p>
<p>
    {</p>
<p>
        CSnapIn* pSnapIn = new CSnapIn(clsID, nIndex + ID_TOOLS_START);</p>
<p>
        if (!pSnapIn-&gt;Interface() ||</p>
<p>
            !pSnapIn-&gt;Interface()-&gt;SupportsInterface(GetSnapInContext(0)))</p>
<p>
        {</p>
<p>
            delete pSnapIn;</p>
<p>
            continue;</p>
<p>
        }</p>
<p>
        if (m_snapIn.GetSize() == 0)</p>
<p>
            nSubMenu = AddMenuEntries();</p>
<p>
        ASSERT(GetMenu()-&gt;GetSubMenu(nSubMenu));</p>
<p>
        if (pSnapIn-&gt;AddMenuItem(GetMenu()-&gt;GetSubMenu(nSubMenu)))</p>
<p>
            pSnapIn-&gt;AddToolbarButton(m_snapInBar, nBmpSize);</p>
<p>
        m_snapIn.Add(pSnapIn);</p>
<p>
        nIndex++;</p>
<p>
    }</p>
<p>
    return 0;</p>
<p>
}</p>
<p>
void CSnapInFrame::ActivateFrame(int nCmdShow) </p>
<p>
{</p>
<p>
    if (m_snapIn.GetSize() == 0)</p>
<p>
        HideSnapInBar();</p>
<p>
    </p>
<p>
    CFrameWnd::ActivateFrame(nCmdShow);</p>
<p>
}</p>
<p>
void CSnapInFrame::GetMessageString(UINT nID, CString&amp; rMessage) const</p>
<p>
{</p>
<p>
    if (nID &lt; ID_TOOLS_START || nID &gt; ID_TOOLS_END)</p>
<p>
    {</p>
<p>
        CFrameWnd::GetMessageString (nID, rMessage);</p>
<p>
        return;</p>
<p>
    }</p>
<p>
    CSnapIn* pSnapIn = m_snapIn[nID - ID_TOOLS_START];</p>
<p>
    HINSTANCE myInst = AfxGetResourceHandle();</p>
<p>
    AfxSetResourceHandle(pSnapIn-&gt;Interface()-&gt;GetResourceInstance());</p>
<p>
    nID = pSnapIn-&gt;Interface()-&gt;GetMessageTextID();</p>
<p>
    CFrameWnd::GetMessageString(nID, rMessage);</p>
<p>
    AfxSetResourceHandle(myInst);</p>
<p>
}</p>
<p>
void CSnapInFrame::OnUpdateViewSnapInBar(CCmdUI* pCmdUI)</p>
<p>
{</p>
<p>
    CControlBar* pBar = GetControlBar(ID_VIEW_SNAPINBAR);</p>
<p>
    if (pBar != NULL)</p>
<p>
    {</p>
<p>
        pCmdUI-&gt;SetCheck((pBar-&gt;GetStyle() &amp; WS_VISIBLE) != 0);</p>
<p>
        return;</p>
<p>
    }</p>
<p>
    pCmdUI-&gt;ContinueRouting();</p>
<p>
}</p>
<p>
BOOL CSnapInFrame::OnViewSnapInBarCheck(UINT nID)</p>
<p>
{</p>
<p>
    CControlBar* pBar = GetControlBar(ID_VIEW_SNAPINBAR);</p>
<p>
    if (pBar != NULL)</p>
<p>
    {</p>
<p>
        ShowControlBar(pBar, (pBar-&gt;GetStyle() &amp; WS_VISIBLE) == 0, FALSE);</p>
<p>
        return TRUE;</p>
<p>
    }</p>
<p>
    return FALSE;</p>
<p>
}</p>
<p>
void CSnapInFrame::OnUpdateSnapIn(CCmdUI* pCmdUI)</p>
<p>
{</p>
<p>
    CSnapIn* pSnapIn = m_snapIn[pCmdUI-&gt;m_nID - ID_TOOLS_START];</p>
<p>
    pCmdUI-&gt;Enable(pSnapIn-&gt;Interface()-&gt;</p>
<p>
        IsEnabled(GetSnapInContext(0)));</p>
<p>
}</p>
<p>
void CSnapInFrame::OnSnapIn(UINT nID)</p>
<p>
{</p>
<p>
    CSnapIn* pSnapIn = m_snapIn[nID - ID_TOOLS_START];</p>
<p>
    pSnapIn-&gt;Interface()-&gt;OnCommand(GetSnapInContext(0));</p>
<p>
}</p>
<p>
BOOL CSnapInFrame::OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult)</p>
<p>
{</p>
<p>
    if (pNMHDR-&gt;idFrom &lt; ID_TOOLS_START || pNMHDR-&gt;idFrom &gt; ID_TOOLS_END)</p>
<p>
        return CFrameWnd::OnToolTipText(nID, pNMHDR, pResult);</p>
<p>
    CSnapIn* pSnapIn = m_snapIn[pNMHDR-&gt;idFrom - ID_TOOLS_START];</p>
<p>
    HINSTANCE myInst = AfxGetResourceHandle();</p>
<p>
    AfxSetResourceHandle(pSnapIn-&gt;Interface()-&gt;GetResourceInstance());</p>
<p>
    pNMHDR-&gt;idFrom = pSnapIn-&gt;Interface()-&gt;GetMessageTextID();</p>
<p>
    BOOL bResult = CFrameWnd::OnToolTipText(nID, pNMHDR, pResult);</p>
<p>
    AfxSetResourceHandle(myInst);</p>
<p>
    </p>
<p>
    return bResult;</p>
<p>
}</p>
<p>
At create time, CSnapInFrame always creates a snap-in toolbar, regardless of whether or not it finds any compatible snap-ins. If it finds none, the empty toolbar is hidden from view when the frame window is activated. I had to do this because CDockState does not respond gracefully to a missing toolbar. Consider this perilous scenario: the user installs a snap-in and then runs the host application. When the application terminates, it stores the state of the snap-in toolbar in the registry using CDockState. Later, the user uninstalls the snap-in. The next time the application is executed, CSnapInFrame does not create a snap-in toolbar because there are no snap-ins to display. Consequently, CDockState crashes the application while trying to restore the state of a toolbar that has not been created!</p>
<p>
Immediately after creating the snap-in toolbar, CSnap&shy;InFrame builds an array of CSnapIn objects used to keep track of each snap-in. It does this by traversing the list of compatible snap-ins using the ICatInformation interface. Incidentally, each snap-in is actually loaded into memory by the CSnapIn constructor using a call to CoCreateInstance. The CSnapIn class stores the pointer to ISnapIn so that it can be used in later communication with that component.</p>
<p>
If any snap-ins exist, CSnapInFrame calls its AddMenu&shy;Entries function, which adds a command to the View menu that lets the user toggle the visibility of the snap-in toolbar. It also creates a Tools menu, where the menu command for each snap-in is placed. Since Add&shy;MenuEntries is a virtual function, you can easily override it if you want your menu to behave differently. Each CSnapIn object adds its snap-in’s toolbar button and menu item to the application window. As I’ve mentioned previously, a hidden snap-in may not provide that information, so CSnapIn is written to handle that case as well.</p>
<p>
Because the tool-tip text and status bar message for each snap-in do not reside in the resource module for the application, CSnapInFrame has to perform some sleight-of-hand to display them properly. This is because MFC expects to find those resources in the same module as all of the other resources used by the application. To get around this, CSnapInFrame overrides the GetMessageString and OnToolTipText functions and twiddles the application’s global resource handle (using a call to AfxSetResource&shy;Handle) before and after calling the base-class implementation of those functions. This approach works fine, but it’s not thread-safe. If your application calls AfxGetResource&shy;Handle from simultaneous threads, you’ll need to add thread synchronization to your code to make sure that other threads are properly blocked while the primary thread is processing GetMessageString or OnToolTipText.</p>
<p>
CSnapInFrame has three functions—OnSnapIn, OnUpdateSnapInUI, and OnStateChanged—that make calls to the ISnapIn interface functions OnCommand, IsEnabled, and OnStateChanged, respectively. Refer to Figure 9 for details.</p>
<h2>My Three Snap-Ins</h2>
<p>
As I mentioned at the outset, I wrote three simple snap-ins—a word counter, a duplicate word remover, and an autocorrect tool—but don’t expect to see them for sale anytime soon! I’ve provided them just to give you an idea of the kinds of snap-ins you can build yourself. Unfortunately, unlike the CSnapInFrame and CSnapIn classes, most of the sample snap-in code is specific to its integration with an IRichDocContext host application. Thus, you won’t be able to copy and paste large chunks of the code into your own snap-in projects. </p>
<p>
I wrote the snap-ins using a combination of ATL and MFC. Before beginning this project, I often wondered why anyone would want to mix those two frameworks. Now I have an answer: ATL makes working with COM interfaces a painless experience, but it really can’t compare with MFC when it comes to developing dialog boxes. So, I used ATL for everything but the autocorrect preferences dialog box (see Figure 10).</p>
<p>
<img src="snapin10.gif" border=0></p>
<p>
Figure 10  Autocorrect Preferences</p>
<p>
Each snap-in exposes an implementation of the ISnapIn interface, which has three methods that get called by the host application in response to user action: OnState&shy;Changed, IsEnabled, and OnCommand (refer to Figure 1). Each snap-in handles those functions differently. The word-count snap-in counts the number of words in the document every time its OnStateChanged method is called. It has no menu item or toolbar button, so its OnCommand and IsEn&shy;abled methods are never called. The duplicate word snap-in scans the document for repeated words whenever the user selects it from the menu, but its OnStateChanged method does nothing; its IsEnabled function returns false when the WordPad document is empty. The autocorrect snap-in replaces spelling errors <BR>in the document in its OnStateChanged method and displays a settings dialog box whenever its OnCommand method is called.</p>
<p>
It seems to me that the ideal way to register the snap-in component categories would be to derive my own class from CComModule and override its RegisterClassHelper and UnregisterClassHelper functions. However, I was disappointed to find that neither of those functions is virtual—at least, they weren’t at the time of this writing. Of course, I’ll probably get email from you COM experts out there telling me that the best way to do it is with registry scripting. Since I haven’t figured out how to do that yet, my approach was to write three helper functions—RegisterComponent&shy;Category, RegisterClassReqCategory, and RegisterClass&shy;ImplCategory (see Figure 11)—that you may find useful in your own code. They act as general-purpose wrappers around the calls to the interface methods of ICatRegister. With the help of those functions, adding component category registration to the DllRegisterServer function was <BR>a snap:</p>
<p>
STDAPI DllRegisterServer(void)</p>
<p>
{</p>
<p>
    RegisterComponentCategory(CATID_ISnapIn,</p>
<p>
                             _T(&quot;Snap-Ins&quot;));</p>
<p>
    RegisterComponentCategory(CATID_IRichDocContext,</p>
<p>
                        T(&quot;Snap-Ins that support the</p>
<p>
                        IRichDocContext interface&quot;));</p>
<p>
    _ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;</p>
<p>
    while (pEntry-&gt;pclsid != NULL)</p>
<p>
    {</p>
<p>
        RegisterClassImplCategory(pEntry-&gt;pclsid,</p>
<p>
                                  CATID_ISnapIn);</p>
<p>
        RegisterClassReqCategory(pEntry-&gt;pclsid,</p>
<p>
                                 CATID_IRichDocContext);</p>
<p>
        pEntry++;</p>
<p>
    }</p>
<p>
    return _Module.RegisterServer(FALSE) // No typelib</p>
<p>
} </p>
<dl>
<dt>
Figure 11  Component Category Helper Functions</dt>
<dd>
// Copyright (c) 1997, Microsoft Systems Journal<p>
// Author: Steve Zimmerman</p>
<p>
//</p>
<p>
// SnapIns.cpp : Implementation of DLL Exports.</p>
<p>
// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this </p>
<p>
// project.  This is because you will need MIDL 3.00.15 or higher and new</p>
<p>
// headers and libs.  If you have VC 4.2 installed, then everything should</p>
<p>
// already be configured correctly.</p>
<p>
// Note: Proxy/Stub Information</p>
<p>
//        To build a separate proxy/stub DLL, </p>
<p>
//        run nmake -f SnapInsps.mak in the project directory.</p>
<p>
#include &quot;stdafx.h&quot;</p>
<p>
#include &quot;resource.h&quot;</p>
<p>
#include &quot;initguid.h&quot;</p>
<p>
#include &quot;comcat.h&quot;</p>
<p>
#include &quot;ISnapIn.h&quot;</p>
<p>
#include &quot;IRichDoc.h&quot;</p>
<p>
#include &quot;RichDoc.h&quot;</p>
<p>
#include &quot;WordCount.h&quot;</p>
<p>
#include &quot;RemoveDup.h&quot;</p>
<p>
#include &quot;Correct.h&quot;</p>
<p>
HRESULT RegisterComponentCategory(CATID catid, TCHAR* catDescription,</p>
<p>
    BOOL bRegister = TRUE);</p>
<p>
HRESULT RegisterClassReqCategory(const CLSID* rclsid, CATID rgcatid,</p>
<p>
    BOOL bRegister = TRUE);</p>
<p>
HRESULT RegisterClassImplCategory(const CLSID* rclsid, CATID rgcatid,</p>
<p>
    BOOL bRegister = TRUE);</p>
<p>
#define IID_DEFINED</p>
<p>
CComModule _Module;</p>
<p>
BEGIN_OBJECT_MAP(ObjectMap)</p>
<p>
    OBJECT_ENTRY(CLSID_CWordCount, CWordCount)</p>
<p>
    OBJECT_ENTRY(CLSID_CRemoveDup, CRemoveDup)</p>
<p>
    OBJECT_ENTRY(CLSID_CAutoCorrect, CAutoCorrect)    </p>
<p>
END_OBJECT_MAP()</p>
<p>
class CMyApp : public CWinApp</p>
<p>
{</p>
<p>
public:</p>
<p>
    virtual BOOL InitInstance();</p>
<p>
    virtual int ExitInstance();</p>
<p>
};</p>
<p>
CMyApp theApp;</p>
<p>
BOOL CMyApp::InitInstance()</p>
<p>
{</p>
<p>
    _Module.Init(ObjectMap, m_hInstance);</p>
<p>
    return CWinApp::InitInstance();</p>
<p>
}</p>
<p>
int CMyApp::ExitInstance()</p>
<p>
{</p>
<p>
    _Module.Term();</p>
<p>
    return CWinApp::ExitInstance();</p>
<p>
}</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// Used to determine whether the DLL can be unloaded by OLE</p>
<p>
STDAPI DllCanUnloadNow(void)</p>
<p>
{</p>
<p>
    AFX_MANAGE_STATE(AfxGetStaticModuleState());</p>
<p>
    return (AfxDllCanUnloadNow()==S_OK &amp;&amp; _Module.GetLockCount()==0) ? S_OK : S_FALSE;</p>
<p>
}</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// Returns a class factory to create an object of the requested type</p>
<p>
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)</p>
<p>
{</p>
<p>
    return _Module.GetClassObject(rclsid, riid, ppv);</p>
<p>
}</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// DllRegisterServer - Adds entries to the system registry</p>
<p>
STDAPI DllRegisterServer(void)</p>
<p>
{</p>
<p>
    // First we register the ISnapIn and IRichDocContext</p>
<p>
    // interfaces as special categories. For simplicity,</p>
<p>
    // I just use the CLSIDs as the CATIDs. In your code,</p>
<p>
    // you should register ISnapIn (and IRichDocContext if</p>
<p>
    // you happen to use it) using the same text description</p>
<p>
    // given here. We can't unregister these categories</p>
<p>
    // since another module might require them.</p>
<p>
    RegisterComponentCategory(CATID_ISnapIn, _T(&quot;Snap-Ins&quot;));</p>
<p>
    RegisterComponentCategory(CATID_IRichDocContext,</p>
<p>
        _T(&quot;Snap-Ins that support the IRichDocContext interface&quot;));</p>
<p>
    // Now we register each control as implementing ISnapIn</p>
<p>
    // and requiring that its container support IRichDocContext</p>
<p>
    _ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;</p>
<p>
    while (pEntry-&gt;pclsid != NULL)</p>
<p>
    {</p>
<p>
        RegisterClassImplCategory(pEntry-&gt;pclsid, CATID_ISnapIn);</p>
<p>
        RegisterClassReqCategory(pEntry-&gt;pclsid, CATID_IRichDocContext);</p>
<p>
        pEntry++;</p>
<p>
    }</p>
<p>
    // register all the other stuff</p>
<p>
    </p>
<p>
    return _Module.RegisterServer(FALSE);    // No typelib</p>
<p>
}</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// DllUnregisterServer - Removes entries from the system registry</p>
<p>
STDAPI DllUnregisterServer(void)</p>
<p>
{</p>
<p>
    _Module.UnregisterServer();</p>
<p>
    return S_OK;</p>
<p>
}</p>
<p>
HRESULT RegisterComponentCategory(CATID catid,</p>
<p>
    TCHAR* catDescription, BOOL bRegister)</p>
<p>
{</p>
<p>
    ICatRegister* pcr = NULL;</p>
<p>
    HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, </p>
<p>
        NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&amp;pcr);</p>
<p>
    if (FAILED(hr))</p>
<p>
        return hr;</p>
<p>
    // Make sure the HKCR\Component Categories\{..catid...}</p>
<p>
    // key is registered</p>
<p>
    CATEGORYINFO catinfo;</p>
<p>
    catinfo.catid = catid;</p>
<p>
    catinfo.lcid = 0x0409; // English is all for now</p>
<p>
    // Make sure the provided description is not too long.</p>
<p>
    // Only copy the first 127 characters if it is</p>
<p>
    USES_CONVERSION;</p>
<p>
    int len = min(_tcslen(catDescription), 127);</p>
<p>
    wcsncpy(catinfo.szDescription, T2W(catDescription), len);</p>
<p>
    catinfo.szDescription[len] = 0;</p>
<p>
    if (bRegister)</p>
<p>
        hr = pcr-&gt;RegisterCategories(1, &amp;catinfo);</p>
<p>
    else </p>
<p>
        hr = pcr-&gt;UnRegisterCategories(1, &amp;catid);</p>
<p>
    pcr-&gt;Release();</p>
<p>
    return hr;</p>
<p>
}</p>
<p>
HRESULT RegisterClassReqCategory(const CLSID* pclsid,</p>
<p>
    CATID rgcatid, BOOL bRegister)</p>
<p>
{</p>
<p>
    _ASSERTE(pclsid);</p>
<p>
    </p>
<p>
    ICatRegister* pcr = NULL;</p>
<p>
    HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, </p>
<p>
        NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&amp;pcr);</p>
<p>
    if (FAILED(hr))</p>
<p>
        return hr;</p>
<p>
    return bRegister ? pcr-&gt;RegisterClassReqCategories(*pclsid, 1, &amp;rgcatid)</p>
<p>
        : pcr-&gt;UnRegisterClassReqCategories(*pclsid, 1, &amp;rgcatid);</p>
<p>
}</p>
<p>
HRESULT RegisterClassImplCategory(const CLSID* pclsid,</p>
<p>
    CATID rgcatid, BOOL bRegister)</p>
<p>
{</p>
<p>
    _ASSERTE(pclsid);</p>
<p>
    ICatRegister* pcr = NULL;</p>
<p>
    HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, </p>
<p>
        NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&amp;pcr);</p>
<p>
    if (FAILED(hr))</p>
<p>
        return hr;</p>
<p>
    return bRegister ? pcr-&gt;RegisterClassImplCategories(*pclsid, 1, &amp;rgcatid)</p>
<p>
        : pcr-&gt;UnRegisterClassImplCategories(*pclsid, 1, &amp;rgcatid);</p>
<p>
}</p>
</dd>
</dl>
<p>
The autocorrect snap-in allows users to maintain a persistent list of commonly misspelled words (and their replacements, of course) by storing that information in a file. However, I had trouble deciding whether the file should be specific to each host application or shared among all of them. I finally decided to associate a wordlist with its host so each application using the autocorrect snap-in has its own file. I probably should have developed an additional interface that the application uses to tell the snap-in where to store the file, but I simply use the same path name as the host application and change its file extension, like so:</p>
<p>
TCHAR sFileName[_MAX_PATH];</p>
<p>
GetModuleFileName(AfxGetInstanceHandle(), sFileName,</p>
<p>
                  _MAX_PATH);</p>
<p>
TCHAR* pFileExt = _tcschr(sFileName, _T('.'));</p>
<p>
_tcscpy(pFileExt, _T(&quot;.acf&quot;)); // auto-correct file</p>
<h2>Conclusion</h2>
<p>
I’ve shown you how to use simple COM objects, called snap-ins, to extend the functionality of your application. I’ve discussed some of the features of an ideal snap-in and I showed you an implementation that uses my homegrown ISnapIn interface. Feel free to modify and improve that interface to meet your needs. Just remember to use a different CLSID in case someone else does the same thing. Hopefully, I’ve given you several ideas—and some nifty sample code—that will help you along the way. Incidentally, if you happen to develop a super-duper WordPad-compatible snap-in, I’d love to hear about it.                       u</p>
<p>
To obtain complete source code listings, see page 5.</p>
</font></font></body>
</HTML>
