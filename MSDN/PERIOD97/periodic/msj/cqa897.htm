<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C++ Q &amp; A</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF>

<font face="verdana,arial,helvetica" size="2">
<h1>C++ Q &amp; A</h1>
<p>Paul DiLascia</p>
<p>Paul DiLascia is a freelance software consultant specializing in training and software development in C++ and Windows. He is <BR>the author of Windows ++: Writing Reusable Code in C++ <BR>(Addison-Wesley, 1992).</p>
<p>
QI’m building a Web app and want to implement the flat-style buttons in my toolbar like the buttons in Internet Explorer. I read about the Internet Explorer 4.0 (IE 4.0) common controls in the November 1996 issue of <i>MSJ</i>, but I’m using MFC and I can’t figure out how to get the flat style with CToolBar.</p>
<h2><i>From numerous readers</i></h2>
<p>
AOne of the hallmarks of a true hacker is being the first to give your app the new look—whether it’s shaded caption bars, 3D windows (as opposed to the old, flat Windows&reg; 3.1 look), or the latest UI fashion: flat-style toolbars and coolbars. (See the next question for details on coolbars.) As soon as Microsoft—or anyone else—comes out with a new look, everyone races to jump on the bandwagon lest their app seem <i>declassé</i>. Prediction: a few years from now, the old Windows 3.1 look will make a retro comeback, along with saddle shoes and bobbysocks. You heard it here first.</p>
<p>
Now, to answer the question. Microsoft recently introduced several new and enhanced common controls (see “Previewing the New and Improved Common Controls DLL for Microsoft&reg; IE 4.0” by Strohm Armstrong, in the October and November 1996 issues of <i>MSJ</i>). Although the new controls were designed for IE 4.0, they reside in a separate DLL, COM&shy;&shy;CTL32.DLL, that any app can call. Visual C++&reg; 5.0 comes with an updated commctrl.h #include file that has all the definitions you need to use the new controls. </p>
<p>
Believe it or not, to get the flat-style toolbar you see in Figure 1, all you have to do is add one line to your code. That’s right, one line.</p>
<p>
m_wndToolBar.ModifyStyle(0, TBSTYLE_FLAT);</p>
<p>
The place to put it is in CMainFrame::OnCreate, after creating your toolbar. TBSTYLE_FLAT is a new toolbar style that produces the look in Figure 1. Note that you must use CWnd::ModifyStyle to modify the style; you can’t specify TBSTYLE_FLAT when creating the toolbar.</p>
<p>
// This fails</p>
<p>
m_wndToolBar.Create(this, WS_CHILD|WS_VISIBLE|</p>
<p>
                    CBRS_TOP|TBSTYLE_FLAT);</p>
<p>
<img src="cqa1.gif" border=0></p>
<p>
Figure 1  Toolbar with TBSTYLE_FLAT</p>
<p>
If you try passing TBSTYLE_FLAT to CToolBar::Create, it won’t work because MFC clobbers your TBSTYLE_FLAT flag. The hex value for TBSTYLE_FLAT (and other new toolbar style flags) conflicts with special CBRS_<i>xxx</i> control bar styles MFC uses for its own purposes. For example, MFC lets you specify CBRS_TOP for a top-aligned toolbar, or CBRS_BORDER_BOTTOM to get a border along the bottom of your toolbar. But CBRS_BORDER_BOTTOM and TBSTYLE_FLAT have the same value, 0x0800. In gen- eral, MFC uses the low-order word (16 bits) of the style for the CBRS_ flags, which conflict with the TBSTYLE_ flags. </p>
<p>
The folks in Redmond wrote CControlBar long before ToolbarWindow32 and TBSTYLE_FLAT were even a glint in Bill’s eye, but they must’ve had some idea about possible future conflicts because CToolBar::Create contains the line</p>
<p>
dwStyle &amp;= ~CBRS_ALL;</p>
<p>
just before MFC passes dwStyle to CWnd::Create. That is, MFC turns off the low-order 16 style bits before creating the ToolbarWindow32. Personally, I find this quite amusing. The MFC programmers did just what Microsoft says you’re never supposed to do—use unused style bits for your own purposes. In any case, the upshot is TBSTYLE_FLAT gets clobbered if you pass it to CTool&shy;Bar::Create. This is why the only way to set the new style is to call CWnd::ModifyStyle after you’ve created the toolbar. On the bright side, anything that lets you get a whole new UI look with just one line of code can’t be too bad. </p>
<p>
There’s just one little problem (there’s always “one little problem”). If your toolbar has the docking <BR>feature, the order of the universe spins slightly out of whack. If you implement the one-liner as I have indicated, and if you also call the MFC EnableDocking functions to create a docking toolbar, you will discover—to your great dismay—that the toolbar doesn’t repaint itself properly when you drag it around to do the docking thing. Figure 2 shows what I mean. Yech! The problem is that Toolbar&shy;Window32 achieves its flat look by drawing the button bitmaps transparently, which MFC doesn’t expect. MFC expects the toolbar to paint the gray background as well as the buttons. So now when the user moves the docking toolbar to a new location, it leaves a shadow of itself in the old location, as you see in Figure 2.</p>
<p>
<img src="cqa2.gif" border=0></p>
<p>
Figure 2  Parlez-vous display bug?</p>
<p>
A “correct” solution is difficult to achieve because it requires overriding several MFC functions, and ideally you’d have to modify the MFC source code. A full explanation is pointless and would only put you to sleep. (Besides, I can’t figure out what those kids were thinking about half the time.) Fortunately, there is a simple fix: derive a new toolbar class that handles WM_WINDOW–POS&shy;CHANGING by repainting the appropriate areas whenever the user moves the toolbar. This is admittedly a bit of a kludge, but it works like a charm—and it’s impossible to program Windows or MFC without kludges.</p>
<p>
Figure 3 shows a CFlatToolBar class I wrote that does flat toolbars correctly. To use it, all you have to do is change CToolBar to CFlatToolBar in your MainFrm.h. Of course, you have to #include FlatBar.h and add FlatBar.cpp to your project, too. </p>
<p>
Figure 3  CFlatToolBar</p>
<p>
FlatBar.h</p>
<p>
////////////////////////////////////////////////////////////////</p>
<p>
// CFlatToolBar 1997 Microsoft Systems Journal. </p>
<p>
// If this code works, it was written by Paul DiLascia.</p>
<p>
// If not, I don't know who wrote it.</p>
<p>
// This code compiles with Visual C++ 5.0 on Windows 95</p>
<p>
//</p>
<p>
#ifndef TBSTYLE_FLAT</p>
<p>
#define TBSTYLE_FLAT 0x0800   // (in case you don't have the new commctrl.h)</p>
<p>
#endif</p>
<p>
//////////////////</p>
<p>
// &quot;Flat&quot; style tool bar. Use instead of CToolBar in your CMainFrame</p>
<p>
// or other window to create a tool bar with the flat look.</p>
<p>
//</p>
<p>
// CFlatToolBar fixes the display bug described in the article. It also has</p>
<p>
// overridden load functions that modify the style to TBSTYLE_FLAT. If you</p>
<p>
// don't create your toolbar by loading it from a resource, you should call</p>
<p>
// ModifyStyle(0, TBSTYLE_FLAT) yourself.</p>
<p>
//</p>
<p>
class CFlatToolBar : public CToolBar {</p>
<p>
public:</p>
<p>
   BOOL LoadToolBar(LPCTSTR lpszResourceName);</p>
<p>
   BOOL LoadToolBar(UINT nIDResource)</p>
<p>
      { return LoadToolBar(MAKEINTRESOURCE(nIDResource)); }</p>
<p>
protected:</p>
<p>
   DECLARE_DYNAMIC(CFlatToolBar)</p>
<p>
   DECLARE_MESSAGE_MAP()</p>
<p>
   afx_msg void OnWindowPosChanging(LPWINDOWPOS lpWndPos);</p>
<p>
};</p>
<p>
FlatBar.cpp</p>
<p>
////////////////////////////////////////////////////////////////</p>
<p>
// CFlatToolBar 1997 Microsoft Systems Journal. </p>
<p>
// If this code works, it was written by Paul DiLascia.</p>
<p>
// If not, I don't know who wrote it.</p>
<p>
//</p>
<p>
#include &quot;StdAfx.h&quot;</p>
<p>
#include &quot;FlatBar.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
////////////////////////////////////////////////////////////////</p>
<p>
// CFlatToolBar--does flat tool bar in MFC.</p>
<p>
//</p>
<p>
IMPLEMENT_DYNAMIC(CFlatToolBar, CToolBar)</p>
<p>
BEGIN_MESSAGE_MAP(CFlatToolBar, CToolBar)</p>
<p>
   ON_WM_WINDOWPOSCHANGING()</p>
<p>
END_MESSAGE_MAP()</p>
<p>
////////////////</p>
<p>
// Load override modifies the style after loading toolbar.</p>
<p>
//</p>
<p>
BOOL CFlatToolBar::LoadToolBar(LPCTSTR lpszResourceName)</p>
<p>
{</p>
<p>
   if (!CToolBar::LoadToolBar(lpszResourceName))</p>
<p>
      return FALSE;</p>
<p>
   ModifyStyle(0, TBSTYLE_FLAT); // make it flat</p>
<p>
   return TRUE;</p>
<p>
}</p>
<p>
//////////////////</p>
<p>
// MFC doesn't handle moving a TBSTYLE_FLAT toolbar correctly.</p>
<p>
// The simplest way to fix it is to repaint the old rectangle and</p>
<p>
// toolbar itself whenever the toolbar moves.</p>
<p>
// </p>
<p>
void CFlatToolBar::OnWindowPosChanging(LPWINDOWPOS lpwp)</p>
<p>
{</p>
<p>
   CToolBar::OnWindowPosChanging(lpwp);</p>
<p>
//#define ILLUSTRATE_DISPLAY_BUG        //  remove comment to see the bug</p>
<p>
#ifndef ILLUSTRATE_DISPLAY_BUG</p>
<p>
   if (!(lpwp-&gt;flags &amp; SWP_NOMOVE)) {   //  if moved:</p>
<p>
      CRect rc;                         //  Fill rectangle with..</p>
<p>
      GetWindowRect(&amp;rc);               //  ..my (toolbar) rectangle.</p>
<p>
      CWnd* pParent = GetParent();      //  get parent (dock bar/frame) win..</p>
<p>
      pParent-&gt;ScreenToClient(&amp;rc);     //  .. and convert to parent coords</p>
<p>
      // Ask parent window to paint the area beneath my old location.</p>
<p>
      // Typically, this is just solid grey.</p>
<p>
      //</p>
<p>
      pParent-&gt;InvalidateRect(&amp;rc);     //  paint old rectangle</p>
<p>
      // Now paint my non-client area at the new location.</p>
<p>
      // This is the extra bit of border space surrounding the buttons.</p>
<p>
      // Without this, you will still have a partial display bug (try it!)</p>
<p>
      //</p>
<p>
      PostMessage(WM_NCPAINT);</p>
<p>
   }</p>
<p>
#endif</p>
<p>
}</p>
<p>
There is one minor design glitch in CFlatToolBar: I wanted to make the Create function modify the style, but I discovered that this won’t work because the style must be modified after loading the toolbar, or else the buttons will come out aligned to the very top edge of the toolbar. Go figure. (I guess Microsoft is still working out the bugs on this one.) So instead of writing CFlat&shy;ToolBar::Create, I overloaded the LoadToolBar functions to modify the style after calling the base class load function. Be advised: if you don’t call LoadToolBar, you must call ModifyStyle yourself to modify the style to TBSTYLE_FLAT. Sorry.</p>
<p>
Just in case you think this question was selected as a slimy promotional gimmick to make you go out and buy Visual C++ 5.0 to get spiffy new toolbars, I should point out that, in theory, you don’t need Visual C++ 5.0. All you need to make flat toolbars work are the new COMCTL32.DLL, which you can download free from Microsoft, and the definition of TBSTYLE_FLAT, which you can write yourself.</p>
<p>
#ifndef TBSTYLE_FLAT</p>
<p>
#define TBSTYLE_FLAT 0x0800</p>
<p>
#endif</p>
<p>
Since I’m such a friendly guy, I added these lines to FlatBar.h. So if you haven’t yet taken the 5.0 plunge (go ahead, it’s fun), all you need is the new COMCTL32.DLL. Like I said, this is theoretical because I didn’t personally test it. Figure 3 shows only the CFlatTool&shy;Bar class, not the FlatBar program that uses it. You can download the full FlatBar app from http://www.microsoft.com/msj.</p>
<p>
Before closing the case on flat toolbars, I must mention one important restriction that we at <i>MSJ </i>unfortunately neglected to mention in Strohm’s article. The new common controls in COMCTL32.DLL are not, repeat not, freely distributable in an end user application. I would bet my booty that COMCTL32.DLL, or some version of it, becomes distributable in the near future, but that’s just my own personal opinion, not an official Microsoft pronouncement. Meanwhile, if you use CFlatToolbar, it won’t work on machines that don’t already have IE 3.0 or IE 4.0 installed. You could, however, add some code to check for COM&shy;CTL32.DLL, and use the flat look only if the DLL is present. You can also encourage your users to install IE 3.0 or IE 4.0 if they want the flat look. Finally, Microsoft has provided the IEAK, a distribution kit for applications wanting to ship a branded Microsoft Internet Explorer on their Web site. With this kit you can distribute COMCTL32.DLL, along with the rest of Internet Explorer. Because this isn’t exactly small in size, this may not be another option.</p>
<p>
QI am attempting to write a simple program with Visual C++ 5.0 and I want to give my toolbars and menus that new 3D look with the sliding bands that Microsoft introduced with Office 97 and Visual Studio™ 97. Can you give me some insight into how this is done? I’m using Visual C++ 5.0 and MFC.</p>
<h2><i>Ken Perkins and numerous other readers</i></h2>
<p>
AUh oh, here we go again. More UI fashion envy. The toolbars in Office 97 and Visual Developer are proprietary Microsoft window classes not available for general consumption yet; however, the COMCTL32.DLL mentioned in the previous question has something called a coolbar that has many similar features and is what IE 3.0 uses. So now that I showed you how to implement flat toolbars in MFC, the next logical step is to go full hog and implement coolbars. Unfortunately, this is much more difficult and definitely not something for the faint of heart. Lucky for you, I figured it all out myself and wrote some classes that make coolbars a snap, as I will now describe. Hold on to your programming caps.</p>
<p>
Coolbars are those toolbars with the skinny handles at the left end that you can use to size or drag the different bands inside the toolbar (see Figures 4 and 5). Coolbars can also display a bitmap background instead of boring gray. Unlike flat toolbars, which are merely a new style for an old class (Toolbar&shy;Window32), coolbars are an entirely new window class, ReBarWindow32. That’s <i>Resizable toolBar</i>. Read Strohm Armstrong’s series for a full discussion of coolbars; I will stay focused on <BR>MFC issues.</p>
<p>
<img src="cqa4.gif" border=0></p>
<p>
Figure 4  Coolbar with side-by-side bands</p>
<p>
<img src="cqa5.gif" border=0></p>
<p>
Figure 5  Same coolbar with stacked bands</p>
<p>
The CoolBar program you see in Figures 4 and 5 uses a new class I wrote, CCoolBar, with related classes CRebarInfo, CRebarBandInfo, and CCoolToolBar. CRebarInfo and CRe&shy;&shy;barBandInfo are programmer-friendly C++ versions of the C structs REBARINFO and REBARBANDINFO, with constructors that initialize the objects to all zeroes before setting the cbSize member appropriately. CCoolBar is an MFC-style wrapper for ReBarWindow32, and CCoolToolBar is a specialized CToolBar to use inside a CCoolBar. See Figure 6 for the executive summary.</p>
<p>
Figure 6  Classes in CoolBar.h and CoolBar.cpp</p>
<p>
CCoolBar&#09;An MFC wrapper for ReBarWindow32. It has wrapper functions like GetBarInfo and GetBandCount to wrap coolbar messages like RB_GETBANDINFO and RB_GETBAND&shy;COUNT. You must derive from this and override OnCreateBands to add bands to your coolbar. It contains code to work around MFC display bugs.</p>
<p>
CRebarInfo&#09;A C++ version of REBARINFO. Constructor initializes itself to zero and sets cbSize properly. </p>
<p>
CRebarBandInfo&#09;A C++ version of REBARBANDINFO. Constructor initializes itself to zero and sets cbSize properly. </p>
<p>
CCoolToolBar&#09;A specialization of CToolBar you should use inside a rebar/coolbar. Overrides CToolBar functions to work around MFC display bugs.</p>
<p>
Before I take you inside CCoolBar and CCoolToolBar, let me show you how to use them in your app. Figure 7 shows the CMain&shy;Frame class from my CoolBar sample app, which is the only class affected. The first thing you’ll notice is yet another class, CMyCool&shy;Bar, derived from CCoolBar. You can’t use CCoolBar directly; you must derive your own class from it and implement the pure virtual function OnCreate&shy;Bands. Why did I design CCoolBar this way? Because it makes no sense to have a coolbar with no bands, and I have no way of knowing what kinds of bands you want! So I left this part open by making it a pure virtual function. CCoolBar calls OnCreateBands at the right time (when the coolbar is created), so all you have to do is write it.</p>
<p>
Figure 7  How to Use CCoolBar</p>
<p>
MainFrm.h</p>
<p>
////////////////////////////////////////////////////////////////</p>
<p>
// 1997 Microsoft Systems Journal. </p>
<p>
// If this code works, it was written by Paul DiLascia.</p>
<p>
// If not, I don't know who wrote it. See MainFrm.cpp</p>
<p>
//</p>
<p>
#include &quot;CoolBar.h&quot;</p>
<p>
////////////////</p>
<p>
// Special combo box handles drop down event</p>
<p>
//</p>
<p>
class CMyComboBox : public CComboBox {</p>
<p>
protected:</p>
<p>
    DECLARE_DYNAMIC(CMyComboBox)</p>
<p>
    DECLARE_MESSAGE_MAP()</p>
<p>
    afx_msg void OnDropDown();</p>
<p>
};</p>
<p>
/////////////////</p>
<p>
// My Cool bar: specialized CCoolBar creates bands.</p>
<p>
//</p>
<p>
class CMyCoolBar : public CCoolBar {</p>
<p>
protected:</p>
<p>
    DECLARE_DYNAMIC(CMyCoolBar)</p>
<p>
    CCoolToolBar    m_wndToolBar;           // toolbar</p>
<p>
    CMyComboBox     m_wndCombo;             // combo box</p>
<p>
    CBitmap         m_bmBackground;         // background bitmap</p>
<p>
    virtual BOOL    OnCreateBands();</p>
<p>
};</p>
<p>
/////////////////</p>
<p>
// Main frame window has cool bar and status bar</p>
<p>
//</p>
<p>
class CMainFrame : public CFrameWnd {</p>
<p>
protected:</p>
<p>
    DECLARE_DYNCREATE(CMainFrame)</p>
<p>
    CStatusBar  m_wndStatusBar;</p>
<p>
    CMyCoolBar  m_wndCoolBar;                 // here's the coolbar</p>
<p>
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);</p>
<p>
    DECLARE_MESSAGE_MAP()</p>
<p>
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);</p>
<p>
    afx_msg void OnUpdateFileOpen(CCmdUI* pCmdUI);</p>
<p>
};</p>
<p>
MainFrm.cpp</p>
<p>
////////////////////////////////////////////////////////////////</p>
<p>
// COOLBAR 1997 Microsoft Systems Journal. </p>
<p>
// If this program works, it was written by Paul DiLascia.</p>
<p>
// If not, I don't know who wrote it.</p>
<p>
// Shows how to use my CCoolBar class to implement a coolbar in MFC.</p>
<p>
// Compiles with Visual C++ 5.0 on Windows 95</p>
<p>
#include &quot;StdAfx.h&quot;</p>
<p>
#include &quot;MainFrm.h&quot;</p>
<p>
#include &quot;resource.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
////////////////////////////////////////////////////////////////</p>
<p>
// CMainFrame</p>
<p>
//</p>
<p>
IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)</p>
<p>
BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)</p>
<p>
   ON_WM_CREATE()</p>
<p>
END_MESSAGE_MAP()</p>
<p>
static UINT indicators[] = {</p>
<p>
   ID_SEPARATOR,           // status line indicator</p>
<p>
   ID_INDICATOR_CAPS,</p>
<p>
   ID_INDICATOR_NUM,</p>
<p>
   ID_INDICATOR_SCRL,</p>
<p>
};</p>
<p>
//////////////////</p>
<p>
// Create handler creates control bars</p>
<p>
//</p>
<p>
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)</p>
<p>
{</p>
<p>
   if (CFrameWnd::OnCreate(lpCreateStruct) == -1)</p>
<p>
      return -1;</p>
<p>
   </p>
<p>
   // Create cool bar</p>
<p>
   if (!m_wndCoolBar.Create(this, WS_CHILD|WS_VISIBLE|WS_BORDER|</p>
<p>
                            WS_CLIPSIBLINGS|WS_CLIPCHILDREN|</p>
<p>
                            RBS_TOOLTIPS|RBS_BANDBORDERS|RBS_VARHEIGHT)) {</p>
<p>
      TRACE0(&quot;Failed to create cool bar\n&quot;);</p>
<p>
      return -1;      // fail to create</p>
<p>
   }</p>
<p>
   // Create status bar</p>
<p>
   if (!m_wndStatusBar.Create(this) ||</p>
<p>
      !m_wndStatusBar.SetIndicators(indicators,</p>
<p>
                                    sizeof(indicators)/sizeof(UINT))) {</p>
<p>
      TRACE0(&quot;Failed to create status bar\n&quot;);</p>
<p>
      return -1;      // fail to create</p>
<p>
   }</p>
<p>
   return 0;</p>
<p>
}</p>
<p>
////////////////</p>
<p>
// Override for flicker-free drawing with no CS_VREDRAW and CS_HREDRAW.</p>
<p>
// This has nothing to do with coolbars, but I threw it in because it's</p>
<p>
// a good thing to do.</p>
<p>
//</p>
<p>
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)</p>
<p>
{</p>
<p>
   cs.lpszClass = AfxRegisterWndClass(</p>
<p>
      CS_DBLCLKS,                       // if you need double-clicks</p>
<p>
      NULL,                             // no cursor (use default)</p>
<p>
      NULL,                             // no background brush</p>
<p>
      AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME)); // app icon</p>
<p>
   ASSERT(cs.lpszClass);</p>
<p>
   return CFrameWnd::PreCreateWindow(cs);</p>
<p>
}</p>
<p>
////////////////////////////////////////////////////////////////</p>
<p>
// CMyCoolBar</p>
<p>
//</p>
<p>
IMPLEMENT_DYNAMIC(CMyCoolBar, CCoolBar)</p>
<p>
const CSize COMBO_MINSIZE(150,25);</p>
<p>
////////////////</p>
<p>
// This is the virtual function you have to override to add bands</p>
<p>
//</p>
<p>
BOOL CMyCoolBar::OnCreateBands()</p>
<p>
{</p>
<p>
   // Create tool bar</p>
<p>
   CCoolToolBar&amp; tb = m_wndToolBar;</p>
<p>
   if (!tb.Create(this,</p>
<p>
                  WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|</p>
<p>
                  CBRS_TOOLTIPS|CBRS_SIZE_DYNAMIC) ||</p>
<p>
       !tb.LoadToolBar(IDR_MAINFRAME)) {</p>
<p>
      TRACE0(&quot;Failed to create toolbar\n&quot;);</p>
<p>
      return FALSE; // failed to create</p>
<p>
   }</p>
<p>
   tb.ModifyStyle(0, TBSTYLE_FLAT);</p>
<p>
   // Create combo box</p>
<p>
   CRect rc(0,0,0,0);</p>
<p>
   m_wndCombo.Create(WS_VISIBLE|WS_CHILD|WS_VSCROLL|CBS_DROPDOWNLIST|</p>
<p>
                     WS_CLIPCHILDREN|WS_CLIPSIBLINGS, rc, this, 1001);</p>
<p>
// Following is not needed since I'm not using an image list</p>
<p>
// CRebarInfo rbi;</p>
<p>
// ... set stuff in rbi...</p>
<p>
// SetBarInfo(&amp;rbi);</p>
<p>
   // Get minimum size of bands</p>
<p>
   CSize szHorz = tb.CalcDynamicLayout(-1, 0);        // get min horz size</p>
<p>
   CSize szVert = tb.CalcDynamicLayout(-1, LM_HORZ);  // get min vert size</p>
<p>
   VERIFY(m_bmBackground.LoadBitmap(IDB_BITMAP1));    // load background bmp</p>
<p>
   // Band 1: Add toolbar band</p>
<p>
   CRebarBandInfo rbbi;</p>
<p>
   rbbi.fMask = RBBIM_STYLE|RBBIM_CHILD|RBBIM_CHILDSIZE|</p>
<p>
                RBBIM_BACKGROUND|RBBIM_COLORS;</p>
<p>
   rbbi.fStyle = RBBS_FIXEDBMP;</p>
<p>
   rbbi.hwndChild = m_wndToolBar;</p>
<p>
   rbbi.cxMinChild = szHorz.cx;</p>
<p>
   rbbi.cyMinChild = szVert.cy;</p>
<p>
   rbbi.hbmBack = m_bmBackground;</p>
<p>
   rbbi.clrFore = GetSysColor(COLOR_BTNTEXT);</p>
<p>
   rbbi.clrBack = GetSysColor(COLOR_BTNFACE);</p>
<p>
   if (!InsertBand(-1, &amp;rbbi))</p>
<p>
      return FALSE;</p>
<p>
   // Band 2: Add combo box band. Most settings in rbbi same from tool bar</p>
<p>
   rbbi.fMask |= RBBIM_TEXT;</p>
<p>
   rbbi.lpText = _T(&quot;Address:&quot;);</p>
<p>
   rbbi.cxMinChild = COMBO_MINSIZE.cx;</p>
<p>
   rbbi.cyMinChild = COMBO_MINSIZE.cy;</p>
<p>
   rbbi.hwndChild = m_wndCombo;</p>
<p>
   if (!InsertBand(-1, &amp;rbbi))</p>
<p>
      return FALSE;</p>
<p>
   return 0; // OK</p>
<p>
}</p>
<p>
////////////////////////////////////////////////////////////////</p>
<p>
// CMyComboBox</p>
<p>
//</p>
<p>
IMPLEMENT_DYNAMIC(CMyComboBox, CComboBox)</p>
<p>
BEGIN_MESSAGE_MAP(CMyComboBox, CComboBox)</p>
<p>
   ON_CONTROL_REFLECT(CBN_DROPDOWN, OnDropDown)</p>
<p>
END_MESSAGE_MAP()</p>
<p>
//////////////////</p>
<p>
// Note that I have to resize the window when I get CBN_DROPDOWN</p>
<p>
//    </p>
<p>
void CMyComboBox::OnDropDown()</p>
<p>
{</p>
<p>
   CRect rc;</p>
<p>
   GetWindowRect(&amp;rc);</p>
<p>
   SetWindowPos(NULL,0,0,rc.Width(),200,      // use same width but taller height</p>
<p>
                SWP_NOMOVE|SWP_NOACTIVATE);</p>
<p>
   ResetContent();</p>
<p>
   for (int i=1; i&lt;=20; i++) {</p>
<p>
      CString s;</p>
<p>
      s.Format(&quot;http://www.msj%d.com&quot;, i);</p>
<p>
      AddString(s);</p>
<p>
   }</p>
<p>
}</p>
<p>
For the sample CoolBar program, CMyCoolBar::On&shy;Create&shy;Bands creates two bands: one for the toolbar and one for the combo box in Figure 4. First, OnCreate&shy;Bands creates the windows. The combo box is a special class, CMyCombo&shy;Box, with an OnDropDown handler that generates a list of phony-looking URLs. The toolbar is a CCoolToolBar, not an ordinary CToolBar. I’ll discuss CCoolToolBar in a moment; right now you’re still looking at OnCreateBands. </p>
<p>
After creating the windows that make up the bands, CMyCoolBar::OnCreateBands creates the bands themselves. This is a matter of uttering the proper coolbar voodoo, as described in Strohm’s series. You have to fill out a CRebarBandInfo/REBARBANDINFO struct and call CCoolBar::InsertBand. Most of it is pretty straightforward. I load a bitmap into a data member, m_bmBackground, and use the RBBS_FIXEDBMP style to tell the coolbar to paint the bitmap continuously across all bands instead of starting at origin (0,0) again for each band. For the minimum size of the combo box band, I use a hardwired constant; for the toolbar band, I call CToolBar::CalcDynamicLayout. MFC uses CalcDynamicLayout to determine how small it can shrink a dynamic toolbar vertically or horizontally. I use it to get the minimum height and width of the toolbar, which is for all practical purposes the height and width of one button. Once CMyCoolBar::OnCreateBands creates the two bands, it returns zero to indicate success. Whew. </p>
<p>
The only thing left to do is create the coolbar. This is done in CMainFrame::OnCreate, which calls m_wndCool&shy;Bar.Create. It’s just like creating an ordinary CToolBar, except I call it with a zillion—or at least eight—style flags, including RBS_VARHEIGHT, to make my bands movable vertically within my coolbar.</p>
<p>
Here’s a quick summary of what you have to do to use CCoolBar:
<ul>
<li>
Derive CYourOwnCoolBar from CCoolBar and imple&shy;ment OnCreateBands to create the bands you want. <br><br></li>
<li>
If you want a toolbar inside your coolbar (likely), use CCoolToolBar instead of CToolBar.<br><br></li>
<li>
Create the coolbar in your main frame’s OnCreate function, as usual.</li>
</ul>
<p>
Pretty easy, huh? For those of you who aren’t content to play with your new toys, but have to take them apart to see what’s inside, let me now take you quickly through my implementation of CCoolBar. I derived CCoolBar from MFC’s CControlBar—the base class for toolbars, status bars, and dialog bars—in order to inherit CControlBar’s many useful features like message routing and functions that CFrameWnd uses to calculate its layout. CCoolBar has all the wrapper functions you’d expect—tiny inline functions that convert Windows-style message-speak into C++-style object-speak. </p>
<p>
inline BOOL CCoolBar::GetBarInfo(LPREBARINFO lp)</p>
<p>
{&#09;</p>
<p>
&#09;ASSERT(::IsWindow(m_hWnd));</p>
<p>
&#09;return SendMessage(RB_GETBARINFO, 0, </p>
<p>
                         (LPARAM)lp); </p>
<p>
}</p>
<p>
CCoolBar also has a Create function that makes a one-time call to InitCommonControlsEx with the ICC_COOL_<BR>CLASSES flag to initialize coolbars and an OnCreate handler that calls the previously described virtual function CCoolBar::OnCreateBands so the derived class can create its bands. CCoolBar also overrides two functions inherited from CControlBar, CalcFixedLayout and CalcDynamic&shy;Layout, to calculate the size of the coolbar as if it were fixed. I decided to punt on dynamic-sizing coolbars. If you want docking coolbars, you’re on your own.</p>
<p>
Now we get to the ugly part. The biggest problem I had implementing CCoolBar was crashing into MFC’s CControl&shy;Bar and CToolBar, which have all sorts of hairy code, mostly to do things like docking and dynamic sizing. And you thought the display bug with flat toolbars was bad! I don’t have the space or time to describe each problem in detail, so here are the highlights.</p>
<p>
CCoolBar::OnPaint calls CWnd::Default to bypass all the bizarre painting in CControlBar::OnPaint. CCoolBar::On&shy;Erase&shy;Bkgnd bypasses CControlBar::On&shy;EraseBkgnd for a similar reason. If the user sizes a window containing a coolbar, the coolbar will try to maintain the minimum height and width you specified for each band. If the user shrinks the window horizontally, the coolbar may move one band below another to make it fit. The coolbar undoes this action if the user makes the window bigger. Either way, the coolbar’s height changes, which affects the layout of the frame; but CFrameWnd has no way of knowing the coolbar changed its height and fails to adjust itself properly, resulting in display bugs. Fortunately, the coolbar sends a RBN_HEIGHTCHANGE message whenever its height changes. CCoolBar handles this message by posting WM_SIZE to the parent frame window, which forces it to recalculate its layout. Problem solved.</p>
<p>
All the preceding fixes are for CCoolBar—that is, the coolbar itself. Now I’ll turn to the toolbar inside the coolbar. Remember, a coolbar is just a container window that manages sizeable rectangles called bands, which can contain other windows as children. To get buttons inside a coolbar, you must add your toolbar window as a band. But if you use the vanilla MFC CToolBar, you’ll run into more display bugs. That’s what CCoolToolBar is for—to work around the bugs in CToolBar. There are three overrides, and they all fall into the “bypass the base class” category; CCoolToolBar::OnNc&shy;Paint, OnPaint, and OnNcCalcSize all bypass the CToolBar/CControlBar implementations by calling CWnd::Default. The CToolBar/CControlBar implementations of these functions cause display bugs when used inside coolbars.</p>
<p>
In my humble opinion, the toolbar code is one of a few major problem areas in MFC. It’s contorted, fragile, and almost impossible to modify. Fundamentally, the problem is that the implementation is too tightly knitted into the base classes and spread across umpteen functions, each of which expects the others to behave in just the right way. Change one behavior slightly and the whole thing breaks. No insult intended, but will someone over there in MFC-land please fix this code? </p>
<p>
So there you have it. A CoolBar class for MFC. Figure 8 shows the complete CCoolBar and related classes. The sample CoolBar program is available from the sources listed on page 5. </p>
<p>
Figure 8  CCoolBar</p>
<p>
CoolBar.h</p>
<p>
////////////////////////////////////////////////////////////////</p>
<p>
// CCoolBar 1997 Microsoft Systems Journal. </p>
<p>
// If this program works, it was written by Paul DiLascia.</p>
<p>
// If not, I don't know who wrote it.</p>
<p>
// Compiles with Visual C++ 5.0 on Windows 95</p>
<p>
//////////////////</p>
<p>
// CCoolBar encapsulates IE 4.0 common coolbar for MFC.</p>
<p>
//</p>
<p>
class CCoolBar : public CControlBar {</p>
<p>
protected:</p>
<p>
   DECLARE_DYNAMIC(CCoolBar)</p>
<p>
public:</p>
<p>
   CCoolBar();</p>
<p>
   virtual ~CCoolBar();</p>
<p>
   BOOL Create(CWnd* pParentWnd, DWORD dwStyle,</p>
<p>
      DWORD dwAfxBarStyle = CBRS_ALIGN_TOP,</p>
<p>
      UINT nID = AFX_IDW_TOOLBAR);</p>
<p>
   // Message wrappers</p>
<p>
   BOOL GetBarInfo(LPREBARINFO lp)</p>
<p>
      { ASSERT(::IsWindow(m_hWnd));</p>
<p>
        return (BOOL)SendMessage(RB_GETBARINFO, 0, (LPARAM)lp); }</p>
<p>
   BOOL SetBarInfo(LPREBARINFO lp)</p>
<p>
      { ASSERT(::IsWindow(m_hWnd));</p>
<p>
        return (BOOL)SendMessage(RB_SETBARINFO, 0, (LPARAM)lp); }</p>
<p>
   BOOL GetBandInfo(int iBand, LPREBARBANDINFO lp)</p>
<p>
      { ASSERT(::IsWindow(m_hWnd));</p>
<p>
        return (BOOL)SendMessage(RB_GETBANDINFO, iBand, (LPARAM)lp); }</p>
<p>
   BOOL SetBandInfo(int iBand, LPREBARBANDINFO lp)</p>
<p>
      { ASSERT(::IsWindow(m_hWnd));</p>
<p>
        return (BOOL)SendMessage(RB_SETBANDINFO, iBand, (LPARAM)lp); }</p>
<p>
   BOOL InsertBand(int iWhere, LPREBARBANDINFO lp)</p>
<p>
      { ASSERT(::IsWindow(m_hWnd));</p>
<p>
        return (BOOL)SendMessage(RB_INSERTBAND, (WPARAM)iWhere, (LPARAM)lp); }</p>
<p>
   BOOL DeleteBand(int nWhich)</p>
<p>
      { ASSERT(::IsWindow(m_hWnd));</p>
<p>
        return (BOOL)SendMessage(RB_INSERTBAND, (WPARAM)nWhich); }</p>
<p>
   int GetBandCount()</p>
<p>
      { ASSERT(::IsWindow(m_hWnd));</p>
<p>
        return (int)SendMessage(RB_GETBANDCOUNT); }</p>
<p>
   int GetRowCount()</p>
<p>
      { ASSERT(::IsWindow(m_hWnd));</p>
<p>
        return (int)SendMessage(RB_GETROWCOUNT); }</p>
<p>
   int GetRowHeight(int nWhich)</p>
<p>
      { ASSERT(::IsWindow(m_hWnd));</p>
<p>
        return (int)SendMessage(RB_GETROWHEIGHT, (WPARAM)nWhich); }</p>
<p>
protected:</p>
<p>
   // new virtual functions you must/can override</p>
<p>
   virtual BOOL OnCreateBands() = 0; // return -1 if failed</p>
<p>
   virtual void OnHeightChange(const CRect&amp; rcNew);</p>
<p>
   // CControlBar Overrides</p>
<p>
   virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);</p>
<p>
   virtual CSize CalcDynamicLayout(int nLength, DWORD nMode);</p>
<p>
   virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);</p>
<p>
   // message handlers</p>
<p>
   DECLARE_MESSAGE_MAP()</p>
<p>
   afx_msg int  OnCreate(LPCREATESTRUCT lpcs);</p>
<p>
   afx_msg void OnPaint();</p>
<p>
   afx_msg void OnHeigtChange(NMHDR* pNMHDR, LRESULT* pRes);</p>
<p>
   afx_msg BOOL OnEraseBkgnd(CDC* pDC);</p>
<p>
};</p>
<p>
//////////////////</p>
<p>
// Specialized CToolBar fixes display problems in MFC.</p>
<p>
//</p>
<p>
class CCoolToolBar : public CToolBar {</p>
<p>
public:</p>
<p>
   CCoolToolBar();</p>
<p>
   virtual ~CCoolToolBar();</p>
<p>
protected:</p>
<p>
   DECLARE_DYNAMIC(CCoolToolBar)</p>
<p>
   DECLARE_MESSAGE_MAP()</p>
<p>
   afx_msg void OnNcPaint();</p>
<p>
   afx_msg void OnPaint();</p>
<p>
   afx_msg void OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*);</p>
<p>
};</p>
<p>
//////////////////</p>
<p>
// Programmer-friendly REBARINFO initializes itself</p>
<p>
//</p>
<p>
class CRebarInfo : public REBARINFO {</p>
<p>
public:</p>
<p>
   CRebarInfo() {</p>
<p>
      memset(this, 0, sizeof(REBARINFO));</p>
<p>
      cbSize = sizeof(REBARINFO);</p>
<p>
   }</p>
<p>
};</p>
<p>
//////////////////</p>
<p>
// Programmer-friendly REBARBANDINFO initializes itself</p>
<p>
//</p>
<p>
class CRebarBandInfo : public REBARBANDINFO {</p>
<p>
public:</p>
<p>
   CRebarBandInfo() {</p>
<p>
      memset(this, 0, sizeof(REBARBANDINFO));</p>
<p>
      cbSize = sizeof(REBARBANDINFO);</p>
<p>
   }</p>
<p>
};</p>
<p>
CoolBar.cpp</p>
<p>
////////////////////////////////////////////////////////////////</p>
<p>
// CCoolBar 1997 Microsoft Systems Journal. </p>
<p>
// If this program works, it was written by Paul DiLascia.</p>
<p>
// If not, I don't know who wrote it.</p>
<p>
// CCoolBar implements coolbars for MFC.</p>
<p>
//</p>
<p>
#include &quot;StdAfx.h&quot;</p>
<p>
#include &quot;CoolBar.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
IMPLEMENT_DYNAMIC(CCoolBar, CControlBar)</p>
<p>
BEGIN_MESSAGE_MAP(CCoolBar, CControlBar)</p>
<p>
   //{{AFX_MSG_MAP(CCoolBar)</p>
<p>
   ON_WM_CREATE()</p>
<p>
   ON_WM_PAINT()</p>
<p>
   ON_WM_ERASEBKGND()</p>
<p>
   ON_NOTIFY_REFLECT(RBN_HEIGHTCHANGE, OnHeigtChange)</p>
<p>
   //}}AFX_MSG_MAP</p>
<p>
END_MESSAGE_MAP()</p>
<p>
CCoolBar::CCoolBar()</p>
<p>
{</p>
<p>
}</p>
<p>
CCoolBar::~CCoolBar()</p>
<p>
{</p>
<p>
}</p>
<p>
//////////////////</p>
<p>
// Create coolbar</p>
<p>
//</p>
<p>
BOOL CCoolBar::Create(CWnd* pParentWnd, DWORD dwStyle,</p>
<p>
                      DWORD dwAfxBarStyle, UINT nID)</p>
<p>
{</p>
<p>
   ASSERT_VALID(pParentWnd);   // must have a parent</p>
<p>
   // dynamic coolbar not supported</p>
<p>
   dwStyle &amp;= ~CBRS_SIZE_DYNAMIC;</p>
<p>
   // save the style (this code copied from MFC--probably unnecessary)</p>
<p>
   m_dwStyle = dwAfxBarStyle;</p>
<p>
   if (nID == AFX_IDW_TOOLBAR)</p>
<p>
      m_dwStyle |= CBRS_HIDE_INPLACE;</p>
<p>
   // MFC requires these:</p>
<p>
   dwStyle |= CCS_NODIVIDER|CCS_NOPARENTALIGN;</p>
<p>
   // Initialize cool common controls</p>
<p>
   static BOOL bInit = FALSE;</p>
<p>
   if (!bInit) {</p>
<p>
      INITCOMMONCONTROLSEX sex;</p>
<p>
      sex.dwSize = sizeof(INITCOMMONCONTROLSEX);</p>
<p>
      sex.dwICC = ICC_COOL_CLASSES;</p>
<p>
      InitCommonControlsEx(&amp;sex);</p>
<p>
      bInit = TRUE;</p>
<p>
   }</p>
<p>
   // Create the cool bar using style and parent.</p>
<p>
   CRect rc;</p>
<p>
   rc.SetRectEmpty();</p>
<p>
   return CWnd::CreateEx(WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL,</p>
<p>
                         dwStyle, rc, pParentWnd, nID);</p>
<p>
}</p>
<p>
//////////////////</p>
<p>
// Handle WM_CREATE. Call virtual fn so derived class can create bands.</p>
<p>
//</p>
<p>
int CCoolBar::OnCreate(LPCREATESTRUCT lpcs)</p>
<p>
{</p>
<p>
   return CControlBar::OnCreate(lpcs) == -1 ? -1</p>
<p>
      : OnCreateBands();   // call pure virtual fn to create bands</p>
<p>
}</p>
<p>
//////////////////</p>
<p>
// Standard UI handler updates any controls in the coolbar.</p>
<p>
//</p>
<p>
void CCoolBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)</p>
<p>
{</p>
<p>
   UpdateDialogControls(pTarget, bDisableIfNoHndler);</p>
<p>
}</p>
<p>
/////////////////</p>
<p>
// These two functions are called by MFC to calculate the layout of</p>
<p>
// the main frame. Since CCoolBar is not designed to be dynamic, the</p>
<p>
// size is always fixed, and the same as the window size. </p>
<p>
//</p>
<p>
CSize CCoolBar::CalcDynamicLayout(int nLength, DWORD dwMode)</p>
<p>
{</p>
<p>
   return CalcFixedLayout(dwMode &amp; LM_STRETCH, dwMode &amp; LM_HORZ);</p>
<p>
}</p>
<p>
CSize CCoolBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)</p>
<p>
{</p>
<p>
   CRect rc;</p>
<p>
   GetWindowRect(&amp;rc);</p>
<p>
   CSize sz(bHorz &amp;&amp; bStretch ? 0x7FFF : rc.Width(),</p>
<p>
            !bHorz &amp;&amp; bStretch ? 0x7FFF : rc.Height());</p>
<p>
   return sz;</p>
<p>
}</p>
<p>
//////////////////</p>
<p>
// Low-level height-changed handler just passes to virtual fn w/nicer args.</p>
<p>
//</p>
<p>
void CCoolBar::OnHeigtChange(NMHDR* pNMHDR, LRESULT* pRes)</p>
<p>
{</p>
<p>
   CRect rc;</p>
<p>
   GetWindowRect(&amp;rc);</p>
<p>
   OnHeightChange(rc);</p>
<p>
   *pRes = 0; // why not?</p>
<p>
}</p>
<p>
//////////////////</p>
<p>
// Height changed:</p>
<p>
// Notify the parent frame by posting a WM_SIZE message. This will cause the</p>
<p>
// frame to do RecalcLayout. The message must be posted, not sent, because</p>
<p>
// the coolbar could send RBN_HEIGHTCHANGE while the user is sizing, which</p>
<p>
// would be in the middle of a CFrame::RecalcLayout, and RecalcLayout doesn't</p>
<p>
// let you re-enter it. Posting guarantees that CFrameWnd can finish any recalc</p>
<p>
// it may be in the middle of before handling my posted WM_SIZE. Very confusing.</p>
<p>
//</p>
<p>
void CCoolBar::OnHeightChange(const CRect&amp; rcNew)</p>
<p>
{</p>
<p>
   CWnd* pParent = GetParent();</p>
<p>
   CRect rc;</p>
<p>
   pParent-&gt;GetWindowRect(&amp;rc);</p>
<p>
   pParent-&gt;PostMessage(WM_SIZE, 0, MAKELONG(rc.Width(),rc.Height()));</p>
<p>
}</p>
<p>
void CCoolBar::OnPaint()</p>
<p>
{</p>
<p>
   Default();  // bypass CControlBar</p>
<p>
}</p>
<p>
BOOL CCoolBar::OnEraseBkgnd(CDC* pDC)</p>
<p>
{</p>
<p>
   return (BOOL)Default();  // bypass CControlBar</p>
<p>
}</p>
<p>
////////////////////////////////////////////////////////////////</p>
<p>
// Special tool bar to use in cool bars.</p>
<p>
// Mainly, it overides yukky stuff in CToolBar.</p>
<p>
//</p>
<p>
IMPLEMENT_DYNAMIC(CCoolToolBar, CToolBar)</p>
<p>
BEGIN_MESSAGE_MAP(CCoolToolBar, CToolBar)</p>
<p>
   ON_WM_NCPAINT()</p>
<p>
   ON_WM_PAINT()</p>
<p>
   ON_WM_NCCALCSIZE()</p>
<p>
END_MESSAGE_MAP()</p>
<p>
CCoolToolBar::CCoolToolBar()</p>
<p>
{</p>
<p>
}</p>
<p>
CCoolToolBar::~CCoolToolBar()</p>
<p>
{</p>
<p>
}</p>
<p>
void CCoolToolBar::OnNcPaint()</p>
<p>
{</p>
<p>
   Default();  // bypass CToolBar/CControlBar</p>
<p>
}</p>
<p>
void CCoolToolBar::OnPaint()</p>
<p>
{</p>
<p>
   Default();  // bypass CToolBar/CControlBar</p>
<p>
}</p>
<p>
void CCoolToolBar::OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*)</p>
<p>
{</p>
<p>
   Default();  // bypass CToolBar/CControlBar</p>
<p>
}</p>
<p>
If you decide to use CCoolBar, keep in mind that the same COMCTL32.DLL restriction I mentioned in the previous question applies here: you can’t distribute COMCTL32.DLL freely with you app; coolbars will only work on machines that have the latest COMCTL32.DLL. So you must write your app to use old-style toolbars if it doesn’t detect the latest COMCTL32.DLL.</p>
<p>
I’m sure by the time MFC 6.0 comes out it will have its own CCoolBar class. In the meantime, my homegrown version should be all you need to cure your UI fashion envy, at least until the next fad comes along. (Already, I hear someone asking, “How do I get the button icons to appear in my menus?”) As an extra bonus, I even grabbed the background bitmap from IE 3.0—you know, the one with the wavy gray swirls. Gee, I hope they don’t sue me.                                   u</p>
<p>
To obtain complete source code listings, see page 5.</p>
<p>
Have a question about programming in C or C++? Send it to Paul DiLascia at askpd@pobox.com.</p>
</font></font></body>
</HTML>
