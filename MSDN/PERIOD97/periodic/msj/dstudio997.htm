<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Extend Developer Studio 97 With Your Own Add-ins, Macros, and Wizards</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF>

<font face="verdana,arial,helvetica" size="2">
<h1>Extend Developer Studio 97 With Your Own Add-ins, Macros, and Wizards</h1>
<p>Steve Zimmerman</p>
<p></p>
<p>Steve Zimmerman is a senior software engineer and an adjunct professor at the University of Phoenix. He can be reached at zimsoft@aros.net.</p>
<p>
In a previous issue of <i>MSJ</i>, I presented a way to develop easily extensible applications using components called snap-ins (“Create Apps That Are Easily Extensible with Our Smart “Snap-Ins” Methodology,” July 1997). Similar functionality exists in many commercial applications: Microsoft&reg; Excel has add-ins, Netscape Navigator and Microsoft Internet Explorer support plug-ins, Visual InterDev™ hosts design-time controls, and Microsoft FrontPage™ 97 uses something called a WebBot&reg;. While these components all provide a way to enhance and customize the host application, each is implemented differently. In fact, someone could probably write a hefty tome about how to develop each called <i>The Big Book of Extension Components</i>. </p>
<p>
I’d like to concentrate on something a little less complicated: the new extensibility features found in Microsoft Developer Studio™ 97—add-ins, macros, and improved custom wizards. Incidentally, since an article has already appeared in <i>MSJ</i> that explains how to write your own wizards (“Pay No Attention to the Man Behind the Curtain! Write Your Own C++ AppWizards,” by Walter Oney, March 1997), I’ll simply show you what improvements have been made; I’ll assume you already know how they work.</p>
<h2>Developer Studio Automation</h2>
<p>
Developer Studio has always had a rudimentary level of customizability. In version 4.2, for example, you could record and play memorized keystrokes, change the editor settings, manipulate the toolbars, and adjust the font sizes and colors of various elements of the text display. Unfortunately, except for the ability to create your own wizards, the customizations you could make before the release of Developer Studio 97 were almost entirely cosmetic. Now, there are two powerful new ways to programmatically tailor Developer Studio to your needs: macros and add-ins. You can use either of these techniques to perform customized tasks using automation (formerly known as OLE automation). Here’s how it works: Developer Studio exposes a number of automation objects—such as Application, Document, and Debug&shy;ger—which you can manipulate by accessing each object’s methods and properties. Furthermore, you can write handler functions that will be called whenever certain&nbsp;Developer Studio events occur, such as BuildFinish, New&shy;Document, or BreakpointHit.</p>
<p>
What’s so great about macros and add-ins in Developer Studio? You can automate routine tasks, significantly reducing the time required to perform rote operations. And automating tasks helps prevent errors. You can also extend the functionality of Developer Studio to meet the specific needs of your projects and applications. For example, using the built-in Documents object, you could write a macro to automate the creation of a new C++ source file:</p>
<p>
Sub CreateCPPFile</p>
<p>
    Set NewDoc = Documents.Add(&quot;Text&quot;)</p>
<p>
    NewDoc.Language = dsCPP</p>
<p>
End Sub</p>
<p>
While I won’t explain each method, property, and event for every object in the Developer Studio object model, I will present sample code that shows those objects in action. </p>
<h2>Creating a Macro</h2>
<p>
While macros existed in Developer Studio 4.2, they were not very powerful, in my opinion. All they could do was record and play back a set of memorized keystrokes. While macros were certainly helpful under some circumstances, their usefulness was limited—a glorified copy-and-paste. Aside from the fact that you didn’t have access to an object model, you had no way to program the macro to make decisions based on runtime conditions. For example, you couldn’t tell the macro to search the active document for the occurrence of a particular class name:</p>
<p>
Sub ReplaceClassName()</p>
<p>
    If ActiveDocument.Type = &quot;Text&quot; Then</p>
<p>
        If    </p>
<p>
            ActiveDocument.Selection.FindText( _</p>
<p>
            &quot;CMyDialog&quot;, _</p>
<p>
            dsMatchFromStart + dsMatchCase) Then</p>
<p>
                ActiveDocument.Selection = _</p>
<p>
                &quot;CYourDialog&quot;</p>
<p>
        End If</p>
<p>
    End If</p>
<p>
End Sub</p>
<p>
The combination of a new Developer Studio object model and support for Visual Basic&reg; Scripting Edition means that macros are no longer limited to simple record-and-play keystroke memorization. They have now become full-fledged miniprograms—very powerful and useful. Fortunately, macros are still quite easy to create. Simply click File | New to bring up the New dialog box, then click the Files tab and choose Macro File from the list of file types. When you click OK, you’ll see a dialog box like the one in Figure 1. If you wish, you may provide a brief text description that will appear in a comment at the top of the file created for you. The file can contain several macros, each nestled between the Sub and End Sub declarations that Visual Basic programmers have grown to love. </p>
<p>
<img src="dstud1.gif" border=0></p>
<p>
Figure 1  The Macros registry information</p>
<p>
Obviously, to write the macros themselves you’ll need to have at least a cursory understanding of VBScript. If you don’t, you’ll find helpful documentation, tutorials, and samples on the Microsoft Developer Network CD or at the VBScript Web site (http://www.microsoft.com/vbscript). As an aside, you might also be interested in learning how to host VBScript in your own code so that your application supports automation scripts similar to Developer Studio macros. If so, check out the Extreme C++ column in the August 1997 issue of <i>MSJ</i>’s sister publication, <i>Microsoft Interactive Developer</i> (available at better newsstands everywhere, or see http://www.microsoft.com/mind for subscription information).</p>
<h2>Registering Macros</h2>
<p>
Once you’ve created a macro file, you must register it. While you can save the file in any directory with whatever file extension you want, Developer Studio will only find your macros automatically if you place the file in the DevStudio\SharedIDE\ Macros directory and give <BR>it a DSM extension. Otherwise, you’ll have to specifically tell Developer Studio where it resides. </p>
<p>
Either way, when you first save the file, the macros it contains are not yet available to run. To enable them, click Tools | Customize to display the Customize dialog box, then click the Add-ins and Macro Files tab <BR>(see Figure 2) to display the list of registered add-ins <BR>and macro files. Don’t worry about add-ins for the time being—I’ll discuss them in detail later on. If you give your macro file a DSM file extension and store it in the shared macro directory, it will automatically appear in the dialog box and you can enable it by clicking its check box. Otherwise, you’ll first need to search for the file by clicking the Browse button. Incidentally, the list of registered macros and add-ins is stored in the registry beneath the HKEY_CUR&shy;RENT_USER\Software\Microsoft\<BR>DevStudio\5.0 key (see Figure 3). I mention this because, if you have macros and add-ins stored in various and sundry directories, it’s nice to know where they reside in case you ever want to uninstall them.</p>
<p>
<img src="dstud2.gif" border=0></p>
<p>
Figure 2  Registered add-ins and macros</p>
<p>
<img src="dstud3.gif" border=0></p>
<p>
Figure 3  The Macros registry information</p>
<p>
After your macro is registered, you are ready to run it. The obvious way is to click Tools&nbsp;|&nbsp;Macro to display the Macro dialog box and then select the desired macro from the list. That method is not very efficient—it’s a real pain to have to search the entire macro list each time you want to run one. A much better solution is to assign a macro to a keystroke or a toolbar button. You can assign buttons to your favorite macros and position them at the right of the Developer Studio menu bar (see Figure 4). To do that, simply drag the macros from the Customize dialog box (see Figure 5) to the position on the toolbar or menu bar where you <BR>want them to appear. When you drop the macro on a tool-bar, you are asked to choose the icon used to represent it from a built-in set of icons provided by Developer Studio, as shown in Figure 6. </p>
<p>
<img src="dstud4.gif" border=0></p>
<p>
Figure 4  Macro buttons</p>
<p>
<img src="dstud5.gif" border=0></p>
<p>
Figure 5  Drag macros from the Customize dialog</p>
<p>
<img src="dstud6.gif" border=0></p>
<p>
Figure 6  Select a button icon</p>
<p>
Even though there are nearly 40 stock icons to choose from, sometimes you’ll want to use your own icon. While not as easy as I’d like, there is a way to do it. First, drag your macro to the toolbar and select one of the stock icons. Next, using the resource editor or any other application that lets you design bitmaps, create a 16&nbsp;¥&nbsp;16 image and copy it to the clipboard. If necessary, switch back to Developer Studio and click Tools | Customize to display the Customize dialog box. Finally, right-click the toolbar button whose image you want to replace and click Paste Button Image from the context menu. Developer Studio will replace the stock image on the toolbar with the one you’ve provided.</p>
<h2>Care for a Free Sample?</h2>
<p>
When I’m debugging an MFC application, I often find myself stepping into the MFC source code. Sometimes I do it because I want to see what is happening behind the scene, but most often it is simply a side effect of inadvertently debugging into the constructor of a temporary MFC object. For example, suppose I have a function that takes a CString as an argument. If somewhere in my code I pass that function an LPCSTR instead of a CString, the compiler must first create a temporary CString before entering the function. Thus, when debugging a line of code that calls my function, I end up stepping through the code for the CString constructor. </p>
<p>
After a lengthy debug session, it’s not unusual to end up with 20 or more open source files! Since I like to avoid clutter when coding, I usually close all of the source windows when I’m finished debugging. What I really want to do is close the superfluous files, but leave open the file I’m working with. As it turns out, one of the sample macros that ship with Developer Studio does exactly that. That macro, aptly named Close&shy;ExceptActive, closes every open file except the active one. Thus, with a single click of the mouse I can clear up source file clutter. If only there were a similar macro I could use to clean my office!</p>
<p>
The code for the CloseExceptActive macro, along with the code for two more of my favorite factory-ready macros—CommentOut and OneTimeInclude—is shown in Figure 7. These three macros are part of the SAMPLE.DSM macro file that ships with Developer Studio. As you can see, the code for the CloseExceptActive macro is almost unbelievably simple. It merely uses a VBScript Do...While loop in conjunction with the Developer Studio Windows object to iterate through the list of open windows, closing all but the one on top. Admittedly, while this macro comes in handy, it isn’t exactly earth-shattering. But in earlier versions of Developer Studio, macros could not perform even that simple task because there was no way to repeat an operation until a certain condition was met. As simple as the CloseExceptActive macro is, without the combination of VBScript and the Developer Studio object model, it wouldn’t be possible.</p>
<dl>
<dt>
Figure 7  Sample Macros</dt>
<dd>
Sub CloseExceptActive () <p>
'DESCRIPTION: Closes all editor windows except the current one.</p>
<p>
   'Windows.Item(1) is always the currently active window. So to close all</p>
<p>
   ' the windows except the active one, keep looping until there is no </p>
<p>
   ' longer a Windows.Item(2).</p>
<p>
   do while Windows.Count &gt; 1</p>
<p>
      Windows.Item(2).Close(dsSaveChangesPrompt)</p>
<p>
   Loop</p>
<p>
End Sub</p>
<p>
Sub CommentOut ()</p>
<p>
'DESCRIPTION: Comments out a selected block of text.</p>
<p>
   Dim win</p>
<p>
   set win = ActiveWindow</p>
<p>
   if win.type &lt;&gt; &quot;Text&quot; Then</p>
<p>
     MsgBox &quot;This macro can only be run when a text editor window is active.&quot;</p>
<p>
   else</p>
<p>
      TypeOfFile = FileType(ActiveDocument)  </p>
<p>
      If TypeOfFile &gt; 0 And TypeOfFile &lt; 5 Then    'C &amp; Java use the same </p>
<p>
                                                   'style of comments.</p>
<p>
         ActiveDocument.Selection = &quot;/*&quot; + ActiveDocument.Selection + &quot;*/&quot;</p>
<p>
         ElseIf TypeOfFile = 5 Then</p>
<p>
            ActiveDocument.Selection = “&lt;!— “ + ActiveDocument.Selection + &quot; —&gt;&quot;</p>
<p>
         ElseIf TypeOfFile = 6 Or TypeOfFile = 7 Then</p>
<p>
         'There is no group comment like there is in the other file types, </p>
<p>
         'so we need to iterate through each line, and prepend a ' to the line.</p>
<p>
         'Also, because VBS/DEF does not have a 'end the comment at this </p>
<p>
         'particular column' delimiter, entire lines of code must be </p>
<p>
         'commented out, not sections.</p>
<p>
            If TypeOfFile = 6 Then </p>
<p>
               CommentType = &quot; ‘ &quot;</p>
<p>
            Else</p>
<p>
               CommentType = &quot; ; &quot;</p>
<p>
            End If</p>
<p>
     </p>
<p>
            StartLine = ActiveDocument.Selection.TopLine</p>
<p>
            EndLine = ActiveDocument.Selection.BottomLine</p>
<p>
            If EndLine &lt; StartLine Then</p>
<p>
               Temp = StartLine</p>
<p>
               StartLine = EndLine</p>
<p>
               EndLine = Temp</p>
<p>
            End If</p>
<p>
            If EndLine = StartLine Then</p>
<p>
               ActiveDocument.Selection = CommentType + ActiveDocument.Selection</p>
<p>
            Else </p>
<p>
               For i = StartLine To EndLine</p>
<p>
                  ActiveDocument.Selection.GoToLine i</p>
<p>
                  ActiveDocument.Selection.SelectLine</p>
<p>
                  ActiveDocument.Selection = CommentType + _</p>
<p>
                     ActiveDocument.Selection</p>
<p>
               Next</p>
<p>
            End If</p>
<p>
         Else</p>
<p>
            MsgBox(&quot;Unable to comment out the highlighted text&quot; + vbLf + _</p>
<p>
                   &quot;because the file type was unrecognized.&quot; + vbLf + _</p>
<p>
                   &quot;If the file has not yet been saved, &quot; + vbLf + _</p>
<p>
                   &quot;please save it and try again.&quot;)</p>
<p>
      End If</p>
<p>
   End If</p>
<p>
End Sub</p>
<p>
'Allows the user to make sure the current header file is included only once. </p>
<p>
' There are two ways to do this, using the #pragma once directive or </p>
<p>
' surrounding the entire file in a #ifndef/#endif structure. The first way</p>
<p>
' is much cleaner, but it is Visual C++ specific, and therefore not portable. If </p>
<p>
' you plan on compiling your code with other compilers, use the </p>
<p>
' #ifndef/#endif method, otherwise, the #pragma once option is preferable.</p>
<p>
Sub OneTimeInclude ()</p>
<p>
'DESCRIPTION: Adds code to the current header file so it is included only once </p>
<p>
' per c/cpp file.</p>
<p>
      </p>
<p>
   ext = ActiveDocument.Name</p>
<p>
   If ext = &quot;&quot; Then</p>
<p>
      If MsgBox(&quot;The file you are working with does not have a file extension.&quot; +_</p>
<p>
         vbLF + &quot;Are you sure this is a C/C++ header file?&quot;, 4) = vbCancel Then</p>
<p>
            Exit Sub</p>
<p>
      End If</p>
<p>
      ext = &quot;nofilenamegiven.h&quot;</p>
<p>
   End If</p>
<p>
   DocName = UCase(ext)</p>
<p>
   pos = Instr(ext, &quot;.&quot;)</p>
<p>
   Do While pos &lt;&gt; 1</p>
<p>
      ext = Mid(ext, pos, (Len(ext) - pos + 1))</p>
<p>
      pos = Instr(ext, &quot;.&quot;)</p>
<p>
   Loop</p>
<p>
   ext = LCase(ext)</p>
<p>
   pos = Instr(DocName, &quot;.&quot;)</p>
<p>
   If ext = “.h” Or ext = &quot;.hpp&quot; Then</p>
<p>
      'Warn user that this will not work with a compiler other than Visual C++.</p>
<p>
      If MsgBox(&quot;This macro uses the Visual C++ dependant #pragma once&quot; + _</p>
<p>
                vbLf + &quot;Is the source to be portable across compilers?&quot;, 4) _</p>
<p>
                = 6 Then</p>
<p>
         ActiveDocument.Selection.StartOfDocument (False)</p>
<p>
         Examp = &quot;__&quot; + Left(DocName, pos - 1) + &quot;_&quot; + _</p>
<p>
                 UCase(Right(ext, len(ext) - 1)) + &quot;__&quot;</p>
<p>
         ControlVarName = InputBox(&quot;What should the control variable be?&quot; _</p>
<p>
                          + vbLf + vbLf + &quot;Example: #ifdef &quot; + _</p>
<p>
                          Examp, &quot;One time header include protection&quot;, Examp)</p>
<p>
         If ValidId (ControlVarName) = True Then</p>
<p>
            ActiveDocument.Selection = &quot;#ifndef &quot; + ControlVarName + _</p>
<p>
                                       vbLf + &quot;#define &quot; + ControlVarName + vbLf</p>
<p>
            ActiveDocument.Selection.EndOfDocument(False)</p>
<p>
            ActiveDocument.Selection = vbLf + &quot;#endif //&quot; + _ </p>
<p>
                                       ControlVarName</p>
<p>
         Else</p>
<p>
            MsgBox(ControlVarName + &quot; is not a valid c identifier.&quot; + _</p>
<p>
                   vbLf + &quot;please re-run the macro with a valid C identifier&quot;)</p>
<p>
         End If</p>
<p>
      Else</p>
<p>
         ActiveDocument.Selection.StartOfDocument(False)</p>
<p>
         ActiveDocument.Selection = &quot;#pragma once&quot; + vbLf + vbLf</p>
<p>
      End If</p>
<p>
   Else</p>
<p>
      MsgBox(&quot;This macro can only be run on .h or .hpp files&quot;)</p>
<p>
   End If</p>
<p>
End Sub</p>
</dd>
</dl>
<p>
When you’re trying to isolate a bug in your code, another macro you’ll find handy is CommentOut (also shown in Figure 7). It lets you comment out the currently selected text using a single keystroke. While this macro might seem to be a no-brainer at first glance, consider that Developer Studio is more than a workspace for C++ source files. For many people, it is also the editor of choice for DEF files, HTML files, and (of course!) VBScript macro files. Since C-style comments are not compatible with any of those languages, the CommentOut macro must be intelligent enough to handle those files correctly. In other words, the tokens used to comment out a block of text depend on the file type of the active document. Furthermore, if the active document is not a text file—perhaps it’s a bitmap or a dialog box—the macro must simply display a warning message or do nothing at all. Because of these varying conditions, the CommentOut macro makes liberal use of the VBScript If…Then and ElseIf…Then clauses and the ActiveDocu&shy;ment.Selection object.</p>
<p>
The last sample macro shown in Figure 7 is OneTime&shy;Include. It lets you make sure that a C++ header file is included only once. Of course, this has traditionally been accomplished by placing the following #define around the text in the header file:</p>
<p>
#ifdef __MYHEADER_H__</p>
<dl>
<dt>
#define __MYHEADER_H__</dt>
<dd>
•<p>
•</p>
<p>
•</p>
</dd>
</dl>
<p>
#endif</p>
<p>
If you’re not planning to port your code to another platform (or to a previous version of the Visual C++&reg; compiler), it’s much easier to use the #pragma once directive. As a result, the OneTimeInclude macro lets you decide which approach to take, the traditional #ifdef method or the more efficient (but Visual C++-specific) #pragma method. If you choose the latter, the macro simply inserts a single line at the top of the header file. If you use the #ifdef method, the OneTime&shy;Include macro parses the file name to create a default #define token, such as __MYHEADER_H__, and then gives you the option to modify that token (see Figure 8). The OneTimeInclude macro shows how to use several of the VBScript string manipulation functions (UCase, Instr, Mid, Len, LCase, Left, and Right) and user-interface subroutines (MsgBox and InputBox), as well as how to manipulate the ActiveDocument.Selection object.</p>
<p>
<img src="dstud8.gif" border=0></p>
<p>
Figure 8  Modifying a #define token</p>
<p>
While VBScript macros are an effective way to enhance the performance and functionality of Developer Studio, they do have limitations. There’s no way to display <BR>your own dialog box using VBScript. While you can display notification messages and collect simple input using the MsgBox and InputBox subroutines, neither of those commands is flexible enough to meet every need. Furthermore, VBScript does not have access to the Win32&reg; API, nor does it allow you to create your own objects—you can only manipulate the objects exposed by Developer Studio.</p>
<h2>Add-Ins</h2>
<p>
Suppose you wanted to seamlessly integrate a set of sophisticated features with Developer Studio, similar to the integration provided by development tools like Microsoft Visual&nbsp;SourceSafe™&nbsp;or&nbsp;NuMega&nbsp;BoundsChecker.&nbsp;With&nbsp;VBScript it’s just not possible. Fortunately, there’s an alternative: Devel&shy;oper Studio 97 supports a specialized type of ActiveX™ component called add-ins that allows you to add custom commands to the toolbar and handle Developer Studio events similar to the way you use macros. </p>
<p>
While it is generally easier to develop a VBScript macro than it is to develop an add-in, add-ins give you a much greater level of versatility. You can use any language you’d like when creating an add-in, as long as it supports COM. I’ll discuss developing add-ins using Visual C++. If you consider yourself more of a Visual Basic person, you’ll find sample add-ins created using Visual Basic outlined in the MSDN Library topic entitled “Using the Sample Add-ins.” At any rate, since add-ins are in-process COM server DLLs rather than simple scripts, you have access to the resources of the entire operating system, as well as the&nbsp;objects&nbsp;exposed by Developer Studio.</p>
<p>
The easiest way to create an add-in is to use the DevStudio Add-in Wizard (see Figure 9). The wizard generates all of the necessary code to add one command to the toolbar and, optionally, to handle Developer Studio events. Using the wizard code as a starting point, I’ve developed two sample add-ins that I think you’ll find useful, not only as examples from which you can borrow code, but as bona-fide extensions to Developer Studio. Before I get to the specifics, let’s look at the inner workings of the DevStudio Add-in Wizard.</p>
<p>
<img src="dstud9.gif" border=0></p>
<p>
Figure 9  DevStudio Add-in Wizard</p>
<p>
The wizard code is comprised of three classes—CCommands, CDSAddIn, and CProjectNameApp (where ProjectName is the name of the project)—each of which is described in Figure 10. In addition, the add-in implements two key interfaces, IDSAddIn and ICommands. IDSAddIn is a custom interface that allows Developer Studio to communicate with the add-in; the ICommands interface—inherited from IDispatch—is the means by which the add-in exposes one or more commands. Incidentally, the wizard code uses both Active Template Library (ATL) and MFC. ATL is used to implement the COM classes and interfaces efficiently, while MFC gives you the power to create a sophisticated add-in user interface.</p>
<p>
Figure 10  Wizard-generated Add-in Classes</p>
<p>
Class Name&#09;Description</p>
<p>
CCommands&#09;Implements one or more commands that are made available to Developer Studio by exposing an IDispatch-derived interface named ICommands.</p>
<p>
CDSAddIn&#09;Implements the IDSAddIn custom interface declared in header files provided with Developer Studio. This interface exposes two methods that Developer Studio uses to communicate with the add-in: OnConnection and OnDisconnection.</p>
<p>
CProjectNameApp&#09;This CWinApp-derived class provides initialization and registration code for the add-in.</p>
<h2>IDSAddIn Implementation</h2>
<p>
Since the DevStudio Add-in Wizard provides fully functional implementations of the IDSAddIn and ICommands interfaces, it is possible to develop add-ins without knowing how they work—you can simply change the command-handler code in the CCommands class. Since it’s helpful to understand what happens when an add-in is loaded and unloaded, I’ll give you a quick overview. So that you can follow along at home, I’ve included the wizard-generated code for the CDSAddIn and CCommands classes in Figures 11 and 12.</p>
<dl>
<dt>
Figure 11  CDSAddIn</dt>
<dd>
// AddInMod.cpp : implementation file<p>
//</p>
<p>
#include &quot;stdafx.h&quot;</p>
<p>
#include &quot;Replace.h&quot;</p>
<p>
#include &quot;DSAddIn.h&quot;</p>
<p>
#include &quot;Commands.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
// This is called when the user first loads the add-in, and on start-up</p>
<p>
//  of each subsequent Developer Studio session</p>
<p>
STDMETHODIMP CDSAddIn::OnConnection(IApplication* pApp, VARIANT_BOOL bFirstTime,</p>
<p>
                                    long dwCookie, VARIANT_BOOL* OnConnection)</p>
<p>
{</p>
<p>
      AFX_MANAGE_STATE(AfxGetStaticModuleState());</p>
<p>
      </p>
<p>
      // Store info passed to us</p>
<p>
      IApplication* pApplication = NULL;</p>
<p>
      if (FAILED(pApp-&gt;QueryInterface(IID_IApplication, (void**) &amp;pApplication))</p>
<p>
            || pApplication == NULL)</p>
<p>
      {</p>
<p>
            *OnConnection = VARIANT_FALSE;</p>
<p>
            return S_OK;</p>
<p>
      }</p>
<p>
      m_dwCookie = dwCookie;</p>
<p>
      // Create command dispatch, send info back to DevStudio</p>
<p>
      CCommandsObj::CreateInstance(&amp;m_pCommands);</p>
<p>
      m_pCommands-&gt;AddRef();</p>
<p>
      // The QueryInterface above AddRef'd the Application object.  It will</p>
<p>
      //  be Release'd in CCommand's destructor.</p>
<p>
      m_pCommands-&gt;SetApplicationObject(pApplication);</p>
<p>
      // (see stdafx.h for the definition of VERIFY_OK)</p>
<p>
      VERIFY_OK(pApplication-&gt;SetAddInInfo((long) AfxGetInstanceHandle(),</p>
<p>
                                    (LPDISPATCH) m_pCommands, IDR_TOOLBAR_MEDIUM, </p>
<p>
                                    IDR_TOOLBAR_LARGE, m_dwCookie));</p>
<p>
      // Inform DevStudio of the commands we implement</p>
<p>
      // TODO: Replace the AddCommand call below with a series of calls,</p>
<p>
      //  one for each command your add-in will add.</p>
<p>
      // The command name should not be localized to other languages.  The </p>
<p>
      //  tooltip, command description, and other strings related to this</p>
<p>
      //  command are stored in the string table (IDS_CMD_STRING) and should</p>
<p>
      //  be localized.</p>
<p>
      LPCTSTR szCommand = _T(&quot;ReplaceCommand&quot;);</p>
<p>
      VARIANT_BOOL bRet;</p>
<p>
      CString strCmdString;</p>
<p>
      strCmdString.LoadString(IDS_CMD_STRING);</p>
<p>
      strCmdString = szCommand + strCmdString;</p>
<p>
      CComBSTR bszCmdString(strCmdString);</p>
<p>
      CComBSTR bszMethod(_T(&quot;ReplaceCommandMethod&quot;));</p>
<p>
      CComBSTR bszCmdName(szCommand);</p>
<p>
      VERIFY_OK(pApplication-&gt;AddCommand(bszCmdString, bszMethod, 0, m_dwCookie,  </p>
<p>
                                         &amp;bRet));</p>
<p>
      if (bRet == VARIANT_FALSE)</p>
<p>
      {</p>
<p>
            // AddCommand failed because a command with this name already</p>
<p>
            //  exists.  You may try adding your command under a different name.</p>
<p>
            //  Or, you can fail to load as we will do here.</p>
<p>
            *OnConnection = VARIANT_FALSE;</p>
<p>
            return S_OK;</p>
<p>
      }</p>
<p>
      // Add toolbar buttons only if this is the first time the add-in</p>
<p>
      //  is being loaded.  Toolbar buttons are automatically remembered</p>
<p>
      //  by Developer Studio from session to session, so we should only</p>
<p>
      //  add the toolbar buttons once.</p>
<p>
      if (bFirstTime == VARIANT_TRUE)</p>
<p>
      {</p>
<p>
            VERIFY_OK(pApplication-&gt;AddCommandBarButton(dsGlyph, bszCmdName,</p>
<p>
                                                        m_dwCookie));</p>
<p>
      }</p>
<p>
      *OnConnection = VARIANT_TRUE;</p>
<p>
      return S_OK;</p>
<p>
}</p>
<p>
// This is called on shut-down, and also when the user unloads the add-in</p>
<p>
STDMETHODIMP CDSAddIn::OnDisconnection(VARIANT_BOOL bLastTime)</p>
<p>
{</p>
<p>
      AFX_MANAGE_STATE(AfxGetStaticModuleState());</p>
<p>
      m_pCommands-&gt;Release();</p>
<p>
      m_pCommands = NULL;</p>
<p>
      // TODO: Perform any cleanup work here</p>
<p>
      return S_OK;</p>
<p>
}</p>
<br>
</dd>
<dt>
Figure 12  CCommands</dt>
<dd>
// Commands.cpp : implementation file<p>
#include &quot;stdafx.h&quot;</p>
<p>
#include &quot;Replace.h&quot;</p>
<p>
#include &quot;Commands.h&quot;</p>
<p>
#include &quot;ReplaceDlg.h&quot;</p>
<p>
#ifdef _DEBUG</p>
<p>
#define new DEBUG_NEW</p>
<p>
#undef THIS_FILE</p>
<p>
static char THIS_FILE[] = __FILE__;</p>
<p>
#endif</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CCommands</p>
<p>
CCommands::CCommands()</p>
<p>
{</p>
<p>
      m_pApplication == NULL;</p>
<p>
}</p>
<p>
CCommands::~CCommands()</p>
<p>
{</p>
<p>
      ASSERT (m_pApplication != NULL);</p>
<p>
      m_pApplication-&gt;Release();</p>
<p>
}</p>
<p>
void CCommands::SetApplicationObject(IApplication* pApplication)</p>
<p>
{</p>
<p>
      // This function assumes pApplication has already been AddRef’d</p>
<p>
      //  for us, which CDSAddIn did in its QueryInterface call</p>
<p>
      //  just before it called us.</p>
<p>
      m_pApplication = pApplication;</p>
<p>
}</p>
<p>
/////////////////////////////////////////////////////////////////////////////</p>
<p>
// CCommands methods</p>
<p>
STDMETHODIMP CCommands::ReplaceCommandMethod() </p>
<p>
{</p>
<p>
      AFX_MANAGE_STATE(AfxGetStaticModuleState());</p>
<p>
      VERIFY_OK(m_pApplication-&gt;EnableModeless(VARIANT_FALSE));</p>
<p>
      CReplaceDlg dlg(m_pApplication);</p>
<p>
      dlg.DoModal();</p>
<p>
      VERIFY_OK(m_pApplication-&gt;EnableModeless(VARIANT_TRUE));</p>
<p>
      return S_OK;</p>
<p>
}</p>
</dd>
</dl>
<p>
To keep things simple, when I ran the DevStudio Add-in Wizard, I chose not to handle Developer Studio events—I’ll talk about those a bit later. As shown in Figure 11, the CDSAddIn class implements the two IDSAddIn interface methods required to integrate with Developer Studio: OnConnection and OnDisconnection. These functions are called when the add-in is being loaded and unloaded. Their prototypes are shown below:</p>
<p>
VARIANT_BOOL OnConnection(IApplication* pApp, </p>
<p>
                          VARIANT_BOOL bFirstTime, </p>
<p>
                          long dwCookie, VARIANT_BOOL*       </p>
<p>
                          pbResult);</p>
<p>
STDMETHODIMP OnDisconnection(VARIANT_BOOL bLastTime);</p>
<p>
As you can see, Developer Studio exposes its object model to the add-in by passing a pointer to the IApplication interface in the call to OnConnection. If you hadn’t guessed, IApp&shy;lication is the dual interface that represents the Application object, the topmost object in the hierarchy. The add-in uses that interface to get at other objects, such as Active&shy;Document, Application, and Debugger.</p>
<p>
Here’s what happens when Developer Studio calls the OnConnection function.
<ol>
<li>
The add-in verifies the validity of the IApplication pointer by calling QueryInterface. While this step is probably not required, it ensures that the Developer Studio objects are properly loaded. If for some reason the call to QueryInterface fails, the OnConnection method sets the status variable passed into the function to VARIANT_FALSE and returns.<br><br></li>
<li>
The add-in stores its cookie—the unique identifier assigned to it by Developer Studio—so that it can identify itself in subsequent calls. For example, the add-in uses the cookie in calls to IApplication::Set&shy;Add&shy;Info and IApplication::Add&shy;Command (described later).<br><br></li>
<li>
The add-in creates an instance of the CCommands class and passes it a copy of the IApplication pointer. This ensures that the add-in will still have access to Developer Studio objects when its commands are executed.<br><br></li>
<li>
The add-in calls IApplication::SetAddInInfo to furnish information about itself to Developer Studio. Specifically, the add-in provides the IDispatch pointer exposed by the CCommands object. It also passes its instance handle and toolbar resource identifiers (for both large and medium-size toolbars) so that its buttons can be visually integrated. Incidentally, if your add-in will not use a toolbar, you can return –1 in place of the two resource identifiers.<br><br></li>
<li>
For each command, the add-in calls IApplication::Add&shy;Command with a command string (which I’ll describe shortly) and the name of the CCommands class method associated with the command. The command string is a list of four substrings separated by newline characters: the command name, the toolbar text for the command, the status bar text, and the ToolTip text. Since the command name (the first item in the command string) is not viewed by the user, it need not be localized. The other three strings should be, so the wizard code places them in a string resource.<br><br></li>
<li>
If the add-in is being loaded for the first time—which it knows by checking the state variable passed into the OnConnection method—it calls IApplication::AddCom&shy;mand&shy;BarButton to associate each command with a toolbar button.</li>
</ol>
<p>
As it turns out, the OnDisconnection function—which is called whenever Developer Studio exits or the user unloads the add-in—is much less complicated than OnConnection. It simply releases the CCommand object, and Developer Studio takes care of the rest.</p>
<p>
As I mentioned before, if I had chosen to handle Developer Studio events such as BeforeBuildStart or BreakpointHit, the code for the CCommand object would have been significantly more complex. As it is now, there’s really not much to it (see Figure 12). When the user clicks the toolbar button for a particular add-in command, Developer Studio calls the associated CCommand function.</p>
<p>
Once you’ve created an add-in, you need to register it with Developer Studio, a process similar to the way you register a macro. From the Customize dialog box (refer to Figure 5), use the browse button to tell Developer Studio where the add-in resides.</p>
<h2>Multiple File Replace</h2>
<p>
Perhaps it shows a lack of forethought, but when I’m writing code I often want to change the name of a class midway through its development cycle. For example, I might name a class CSnickerView when I first create it using the ClassWizard, but decide sometime later on that it would be more appropriately named something else, like CDoodleView. Unfortunately, when this happens, the changes required to rename the class are rarely restricted to a single file. More often than not, I end up having to search-and-replace across several source modules. What makes this difficult is that the Developer Studio Replace dialog only lets me replace text in the active document. It would be nice if there were an enhanced version of that dialog that would let me quickly change the class name in all of the open documents, not just the active one.</p>
<p>
I created a sample add-in to provide that functionality. When you click the toolbar button for the add-in, it displays a dialog box similar to the built-in Replace dialog, as shown in Figure 13. Since you can download the code and examine it at your leisure (see page 5 for download instructions), I won’t give you a line-by-line explanation. I’ll simply mention that there are two key Developer Studio objects that make the Multiple File Replace add-in work: Documents and TextSelection. As you might expect, the Documents object allows you to iterate through the list of open documents. The TextSelection object has two methods, FindText and ReplaceText, which allow you to find and replace specific strings.</p>
<p>
<img src="dstud13.gif" border=0></p>
<p>
Figure 13  Multiple File Replace</p>
<h2>Tracepoints</h2>
<p>
When I’m debugging, I often want to see what happens to the value of a variable as the execution of my program progresses. While the Developer Studio debugger is great, I sometimes find that setting a breakpoint is tedious, especially if I’m working on a section of code that might get executed several hundred times. I end up reverting back to the mindset of <BR>my days as a college student (OK, OK, so it hasn’t been <BR>that long ago) when my idea of robust debugging was to liberally sprinkle printf statements throughout my code. Don’t laugh, you did it too. </p>
<p>
Of course, now that I’m a professional Windows developer I <BR>use TRACE, but the goal is the same—I just want to see what’s happening to the variable without inter&shy;rupting execution. The <BR>problem with printf or TRACE is that I have to recompile my program once when I add those statements, and again when I remove them. It’s a big pain. It would be nice if there were a way to dump the contents of a variable at specific intervals without having to muck&nbsp;with&nbsp;the&nbsp;code.&nbsp;Well,&nbsp;surprise, surprise! I created an add-in that lets you set what I’ve named a “trace&shy;point” instead of a break&shy;point. In other words, you can dump the contents of a variable to the output window at specific points throughout your code without having to interrupt program flow or change the code itself.</p>
<p>
To make it work, you must first set a breakpoint at the desired location and then bring up the Tracepoint dialog box (see Figure 14) by clicking the toolbar button for that add-in. The dialog box lets you convert one or more breakpoints into tracepoints and specify the regular expressions you want to send to the output window (instead of stopping) whenever program execution reaches those points.</p>
<p>
<img src="dstud14.gif" border=0></p>
<p>
Figure 14  Tracepoint</p>
<p>
As you’d expect, I created the Tracepoint add-in using the DevStudio Add-in Wizard. Unlike the Multiple File Replace add-in described above, I had to handle Developer Studio events. The Tracepoint add-in responds to the BreakpointHit event, as shown in Figure 15.</p>
<dl>
<dt>
Figure 15  BreakpointHit Event Handler</dt>
<dd>
HRESULT CCommands::XDebuggerEvents::BreakpointHit(IDispatch* pBP)<p>
{</p>
<p>
      AFX_MANAGE_STATE(AfxGetStaticModuleState());</p>
<p>
      CComQIPtr&lt;IBreakpoint, &amp;IID_IBreakpoint&gt; pBreakpoint = pBP;</p>
<p>
      // We only care about line# breakpoints.  We can tell whether this</p>
<p>
      //  is a line# breakpoint by seeing whether its Location property</p>
<p>
      //  begins with a period (e.g., &quot;.253&quot;)</p>
<p>
      CComBSTR bstrLocation;</p>
<p>
      pBreakpoint-&gt;get_Location(&amp;bstrLocation);</p>
<p>
      if (bstrLocation.Length() == 0 || *(BSTR)bstrLocation != '.')</p>
<p>
            return S_OK;</p>
<p>
      // Is it enabled as a tracepoint?</p>
<p>
      CComBSTR bstrFile;</p>
<p>
      pBreakpoint-&gt;get_File(&amp;bstrFile);</p>
<p>
      CString strFullInfo = (BSTR) bstrFile;</p>
<p>
      strFullInfo += (BSTR) bstrLocation;</p>
<p>
      BOOL* pEnable = NULL;</p>
<p>
      m_pCommands-&gt;m_mapEnable.Lookup(strFullInfo, (void*&amp;)pEnable);</p>
<p>
      if (pEnable == NULL || *pEnable == FALSE)</p>
<p>
            return S_OK;</p>
<p>
      // Yes, it's a tracepoint.  Let's output the expressions.</p>
<p>
      CStringArray* pExprArray = NULL;</p>
<p>
      m_pCommands-&gt;m_mapExpr.Lookup(strFullInfo, (void*&amp;)pExprArray);</p>
<p>
      ASSERT(pExprArray);</p>
<p>
      IDebugger* pDebugger = m_pCommands-&gt;GetDebuggerObject();</p>
<p>
      IApplication* pApplication = m_pCommands-&gt;GetApplicationObject();</p>
<p>
      for (int nLoop = 0; nLoop &lt; pExprArray-&gt;GetSize(); nLoop++)</p>
<p>
      {</p>
<p>
            CComBSTR bstrValue(_T(&quot;&lt;Expression could not be evaluated&gt;&quot;));</p>
<p>
            pDebugger-&gt;Evaluate(CComBSTR(pExprArray-&gt;GetAt(nLoop)),</p>
<p>
                                &amp;bstrValue);</p>
<p>
            CComBSTR bstrOut(pExprArray-&gt;GetAt(nLoop));</p>
<p>
            bstrOut += CComBSTR(_T(&quot; = &quot;));</p>
<p>
            bstrOut += bstrValue;</p>
<p>
            pApplication-&gt;PrintToOutputWindow(bstrOut);</p>
<p>
      }</p>
<p>
      pDebugger-&gt;Go();</p>
<p>
      return S_OK;</p>
<p>
}</p>
</dd>
</dl>
<p>
I think you’ll find the code for the Tracepoint add-in straightforward. In the code for the dialog box—written using run-of-the-mill MFC—I keep track of each tracepoint and its associated array of output expressions. During program execution, when a breakpoint is reached, Developer Studio calls the BreakpointHit event handler and passes it a pointer to a Breakpoint object—again, part of the totally cool Developer Studio object model. At that point, my code simply looks up the breakpoint in the list of enabled tracepoints. If there’s a match, the code does two things. First, it calls IApplication::PrintToOutputWindow for each expression, which displays the results in the Macros tab of the output window. (Depending on your Developer Studio configuration, the Macros tab might not be visible by default—you may have to click on the right arrow at the bottom of the output window a few times before it comes into view.) Second, the code calls IDebugger::Go, which tells the debugger not to stop at the breakpoint.</p>
<p>
While the Tracepoint code works like a charm, there is a minor annoyance that I need to point out. By the time Developer Studio calls the BreakpointHit event handler, it has become the active window. Thus, even though program execution doesn’t stop when it reaches a tracepoint, the focus momentarily switches to Developer Studio. If the tracepoint is hit multiple times, the result is a bothersome flicker between Developer Studio and the topmost window of the application being debugged. I’ve decided that it’s a small price to pay. Of course, if you find a workaround to the problem, I’d love to hear about it!</p>
<h2>Improved Custom Wizards</h2>
<p>
As I mentioned at the beginning, the latest version of Developer Studio has improved the functionality of custom wizards, giving you more power and flexibility than ever before. If you’re not familiar with how wizards work, you should consult the online documentation and read the excellent article that appeared in <i>MSJ</i> several months ago.</p>
<p>
In a nutshell, a wizard is an MFC dynamic-link library (with an AWX file extension) that allows you to extend the functionality of Developer Studio by providing a starting point for new projects. For example, the built-in MFC AppWizard walks you through the steps of creating an MFC document/view application. The ATL COM AppWizard helps you create one or more COM objects using ATL. As it turns out, there is also a built-in wizard (called the Custom AppWizard) that allows you to create your own wizards! The key difference between a typical MFC-based DLL and a custom wizard DLL is that, rather than defining a CWinApp-derived class like you normally do, you define a CCustomAppWiz-derived class instead. In the project’s DllMain, you register that class as a Developer Studio extension DLL by calling SetCustomAppWizClass.</p>
<p>
Unfortunately, there were two significant problems with the custom wizards you could create with earlier editions of Developer Studio. First, wizards created with Visual C++ 4.2 did not work correctly under some circumstances due to runtime conflicts between Developer Studio and the MFC DLLs. As a result, to ensure correct functionality of your wizard under Visual C++ 4.2, you had to create it using Visual C++ 4.1! </p>
<p>
Second, there was no way to control the build settings for the new project created by your wizard DLL—you just got the vanilla MAK file created by CCustomAppWiz. For simple wizards it wasn’t a big deal, but if you wanted to change the compiler options, add a library module to the linker settings, or add a custom build step, you were simply out of luck! For example, suppose you wanted to create a customized ActiveX ControlWizard, slightly different than the built-in ActiveX ControlWizard that ships with Developer Studio. If you created your custom wizard using Visual C++ 4.2, the project file generated for the control had two problems: the output file name for the control would be given a DLL extension instead of OCX, and the project lacked a custom build step to register the control. Since you had no control over those settings, you would have had to instruct users of your wizard to make those changes by hand after the project was created.</p>
<p>
Fortunately, these limitations have been overcome with the latest version of Developer Studio. First, wizards created using DevStudio 97 work just fine under it, just as you’d expect. Unfortunately, they are not backward-compatible. They do not work with previous versions of the compiler, such as Visual C++ 4.2—but that’s probably not a big deal. More impressive is the fact that the CCustom&shy;AppWiz class now includes a CustomizeProject virtual method that allows you to alter the project settings. Immediately after generating the source files and creating the project, the AppWizard engine calls the Customize&shy;Project function and passes it a pointer to the BuildProject automation object (via the IBuildProject interface). Thus, by overriding that function, you can alter the project settings to your heart’s content.</p>
<h2>Altering the Project Settings</h2>
<p>
As it turns out, you can’t get at the compile and link options directly using the BuildProject object. Instead, that object simply gives you access to the Configurations object, which exposes the list of the project’s configurations. Using VBScript, it is quite easy to manipulate those configurations. In fact, it only took me a few seconds to write a macro that displays the name of each configuration in the active project, as shown below. To refresh your memory, a configuration is a collection of project settings, such as “Win32 Debug” or “Win32 Release MinSize.”</p>
<p>
Sub GetBuildProjectInfo()</p>
<p>
    Set activeProject = Application.ActiveProject</p>
<p>
    If activeProject.type = &quot;Build&quot; Then</p>
<p>
        For Each configuration in  </p>
<p>
                activeProject.Configurations</p>
<p>
            MsgBox configuration.Name</p>
<p>
        Next</p>
<p>
    End If</p>
<p>
End Sub</p>
<p>
Unfortunately, manipulating the Developer Studio objects in C++ is a bit more tricky than it is with VBScript. Once you get a pointer to each Configuration object, you can make changes to its settings by calling its AddToolSettings, RemoveToolSettings, and AddCustomBuildStep functions. The AddToolSettings and RemoveToolsSettings functions let you alter the compiler and linker settings for a given configuration. For example, you might want to add a preprocessor definition (such as _MBCS or _DEBUG) or <BR>dis&shy;&shy;able Runtime Type Information (RTTI). The Add&shy;&shy;&shy;&shy;&shy;&shy;&shy;Cus&shy;tom&shy;&shy;&shy;Build&shy;Step function allows you to designate one or more shell commands to execute after the specified configuration is built. </p>
<p>
Incidentally, the custom build step applies to the entire configuration, not just to a single file. The most commonly used custom build step is the one used to register a COM object. For example, when you create a project using the ATL COM AppWizard or the MFC ActiveX ControlWizard, those wizards add the custom steps shown in Figure 16.</p>
<p>
<img src="dstud16.gif" border=0></p>
<p>
Figure 16  Custom build step</p>
<h2>Project File Basics</h2>
<p>
Before I show you an example of the AddToolSettings, RemoveToolSettings, and AddCustomBuildStep functions in action, let’s take a quick look at what you might call the “anatomy and evolution” of a Developer Studio 97 project file. As you may recall, previous versions of the Developer Studio stored the project settings in two files: an MDP file containing user-specific workspace settings, and a MAK file containing just about everything else—the build configurations, the list of files included in the project, the file dependencies, and the compiler and linker settings. In principle, a single MAK file could be shared among developers working on the same project (using source code control software). Furthermore, the MAK file could be used for both interactive builds within Developer Studio and command-line builds using NMAKE. This was an elegant and admirable approach, but in practice the implementation of the MAK file had a few glitches when shared among several developers. For details, refer to the Knowledge Base articles entitled “Using Relative Paths in Visual C++ 32-bit Edition MAK Files” and “Absolute Pathnames for Source Files Placed in Makefile.”</p>
<p>
The solution to the MAK file limitations was to create two new file types that represent workspaces and projects—DSW (Developer Studio Workspace) files and DSP (Developer Studio Project) files . The new approach not only solves the “shared makefile” bug, but also gives Developer Studio the ability to host several different project types (Visual InterDev, Visual C++, and Visual J++™) using a single, consistent file structure. Of course, if you need to build your projects using NMAKE, you can still export a MAK file, but it is not guaranteed to be portable across machines.</p>
<p>
The compiler and linker settings that used to be stored in a MAK file are now stored in the DSP file. For example, Figure 17 shows a sampling of the information found in a project file for a typical ActiveX control. Admittedly, if you haven’t spent much time browsing project files, little of what you see in the figure will make sense, especially at first glance. If you look closely, you should be able to pick out a few things. The ADD BASE CPP and ADD CPP lines con&shy;&shy;tain the settings specified in the C/C++ tab of the Project Settings dialog box. The ADD BASE LINK32 and ADD LINK32 lines represent the settings found in the Link tab of that same dialog box. Finally, notice that the DSP file con&shy;tains a Custom Build step that registers the ActiveX control.</p>
<dl>
<dt>
Figure 17  A Developer Studio Project File</dt>
<dd>
// Partial sample DSP file<p>
!IF  “$(CFG)” == “Signature - Win32 Release”</p>
<p>
# PROP BASE Use_MFC 2</p>
<p>
# PROP BASE Use_Debug_Libraries 0</p>
<p>
# PROP BASE Output_Dir &quot;Release&quot;</p>
<p>
# PROP BASE Intermediate_Dir &quot;Release&quot;</p>
<p>
# PROP BASE Target_Dir &quot;&quot;</p>
<p>
# PROP Use_MFC 2</p>
<p>
# PROP Use_Debug_Libraries 0</p>
<p>
# PROP Output_Dir &quot;Release&quot;</p>
<p>
# PROP Intermediate_Dir &quot;Release&quot;</p>
<p>
# PROP Target_Dir &quot;&quot;</p>
<p>
# ADD BASE CPP /nologo /MD /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_WINDLL&quot; /D &quot;_AFXDLL&quot; /Yu&quot;stdafx.h&quot; /FD /c</p>
<p>
# ADD CPP /nologo /MD /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_WINDLL&quot; /D &quot;_AFXDLL&quot; /D &quot;_USRDLL&quot; /Yu&quot;stdafx.h&quot; /FD /c</p>
<p>
# ADD BASE MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /o NUL /win32</p>
<p>
# ADD MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /o NUL /win32</p>
<p>
# ADD BASE RSC /l 0x409 /d &quot;NDEBUG&quot; /d &quot;_AFXDLL&quot;</p>
<p>
# ADD RSC /l 0x409 /d &quot;NDEBUG&quot; /d &quot;_AFXDLL&quot;</p>
<p>
BSC32=bscmake.exe</p>
<p>
# ADD BASE BSC32 /nologo</p>
<p>
# ADD BSC32 /nologo</p>
<p>
LINK32=link.exe</p>
<p>
# ADD BASE LINK32 /nologo /subsystem:windows /dll /machine:I386</p>
<p>
# ADD LINK32 /nologo /subsystem:windows /dll /machine:I386 /out:&quot;Release\Signature.ocx&quot;</p>
<p>
# Begin Custom Build - Registering ActiveX Control...</p>
<p>
OutDir=.\Release</p>
<p>
TargetPath=.\Release\Signature.ocx</p>
<p>
InputPath=.\Release\Signature.ocx</p>
<p>
SOURCE=$(InputPath)</p>
<p>
&quot;$(OutDir)\regsvr32.trg&quot; : $(SOURCE) &quot;$(INTDIR)&quot; &quot;$(OUTDIR)&quot;</p>
<p>
      regsvr32 /s /c &quot;$(TargetPath)&quot; </p>
<p>
      echo regsvr32 exec. time &gt; &quot;$(OutDir)\regsvr32.trg&quot; </p>
<p>
      </p>
<p>
# End Custom Build</p>
</dd>
</dl>
<h2>Changing the Project Settings</h2>
<p>
As I mentioned earlier, the default project file generated by a custom wizard might not contain the settings you want. To show you how to change the project settings from within your wizard code, I’ve included the source for a custom wizard—the MFC Design-Time ActiveX Control&shy;Wizard. Incidentally, I created this code for an article that appeared several months ago in <i>Microsoft Interactive Developer</i> (“Design-Time ActiveX Controls Made Easy with Visual C++ 5.0,” June 1997). Of course, an explanation of design-time ActiveX controls is beyond the scope of this article, but a look at the wizard’s Customize&shy;Project function (see Figure 18) might give you some ideas that will help you with your own custom wizards.</p>
<dl>
<dt>
Figure 18  CustomizeProject</dt>
<dd>
void CWebDCAppWiz::CustomizeProject(IBuildProject* pProject)<p>
{</p>
<p>
   IConfigurations* pConfigs = NULL;</p>
<p>
   pProject-&gt;get_Configurations(&amp;pConfigs);</p>
<p>
   ASSERT(pConfigs);</p>
<p>
   CComPtr&lt;IUnknown&gt; pUnk;</p>
<p>
   CComQIPtr&lt;IEnumVARIANT, &amp;IID_IEnumVARIANT&gt; pNewEnum;</p>
<p>
   if (SUCCEEDED(pConfigs-&gt;get__NewEnum(&amp;pUnk)) &amp;&amp; pUnk != NULL)</p>
<p>
   {</p>
<p>
      pNewEnum = pUnk;</p>
<p>
      VARIANT varConfig;</p>
<p>
      CComQIPtr&lt;IConfiguration, &amp;IID_IConfiguration&gt; pConfig;</p>
<p>
         while (pNewEnum-&gt;Next(1, &amp;varConfig, NULL) == S_OK)</p>
<p>
      {</p>
<p>
         ASSERT (varConfig.vt == VT_DISPATCH);</p>
<p>
         pConfig = varConfig.pdispVal;</p>
<p>
         VariantClear(&amp;varConfig);</p>
<p>
            // Add Control registration custom build step</p>
<p>
            VARIANT reserved;</p>
<p>
            CComBSTR bstrCommand(</p>
<p>
               &quot;regsvr32 /s /c \&quot;$(TargetPath)\&quot;\n&quot;</p>
<p>
               &quot;echo regsvr32 exec. time &gt; \&quot;$(OutDir)\\regsvr32.trg\&quot;&quot;);</p>
<p>
            CComBSTR bstrOutput(&quot;$(OutDir)\\regsvr32.trg&quot;);</p>
<p>
            CComBSTR bstrDescription(&quot;Registering ActiveX Control...&quot;);</p>
<p>
            pConfig-&gt;AddCustomBuildStep(bstrCommand, bstrOutput,</p>
<p>
                                        bstrDescription, reserved);</p>
<p>
                  </p>
<p>
            // Remove old output name (DLL)</p>
<p>
                  </p>
<p>
            CComBSTR bstrTool = &quot;link.exe&quot;;</p>
<p>
            CComBSTR bstrOption = &quot;/out:&quot;;</p>
<p>
            pConfig-&gt;RemoveToolSettings(bstrTool, bstrOption, reserved);</p>
<p>
            // Change output name to OCX</p>
<p>
            USES_CONVERSION;</p>
<p>
         CComBSTR bstrName;</p>
<p>
         pConfig-&gt;get_Name(&amp;bstrName);</p>
<p>
            BOOL bDebug = (BOOL) _tcsstr(OLE2T(bstrName), _T(&quot;Debug&quot;));</p>
<p>
            bstrOption = bDebug ? &quot;/out:Debug\\&quot; : &quot;/out:Release\\&quot;;</p>
<p>
            bstrOption += m_Dictionary[_T(&quot;safe_root&quot;)].AllocSysString();</p>
<p>
            bstrOption += &quot;.ocx&quot;;</p>
<p>
            pConfig-&gt;AddToolSettings(bstrTool, bstrOption, reserved);</p>
<p>
      }</p>
<p>
   }</p>
<p>
}</p>
</dd>
</dl>
<h2>Wrap-up</h2>
<p>
Well, there you have it! I’ve discussed three ways to extend Developer Studio 97: macros, add-ins, and custom wizards. These features, along with the new object model, make it possible to customize and enhance Developer Studio like never before. While I’ve touched on several different topics, I’ve only described a few of the automation objects made available by Developer Studio—you’ll have to discover the rest of them on your own.                                  u</p>
<p>
To obtain complete source code listings, see page 5.</p>
</font></font></body>
</HTML>
