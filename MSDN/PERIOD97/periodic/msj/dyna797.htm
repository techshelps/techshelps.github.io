<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Dynamic Runtime Objects:  Building Applications Your Users Can Modify at Runtime</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF>

<font face="verdana,arial,helvetica" size="2">
<h1>Dynamic Runtime Objects:  Building Applications Your Users Can Modify at Runtime</h1>
<p>Ed Smetak and Jean Caputo</p>
<p>Ed Smetak is vice president of Engineering Software Consulting at NanoSoft Corporation. Jean Caputo is a project management specialist at NanoSoft Corporation. They can be reached at http://www.nanocorp.com.</p>
<p>
Managing the development of large software applications can be a big headache. Often, the headache comes from inappropriate object dependencies that creep in as the result of a poor global design framework. If the application needs to be extensible enough to allow customization by users, things get worse as awkward object dependencies mount.</p>
<p>
We have found that the concept of dynamic runtime objects can go a long way toward keeping big projects under control by isolating object dependencies. This concept forces developers to segregate code in such a way that the tendency toward inappropriate object dependencies is greatly reduced, while appropriate dependencies are handled in a uniform, understandable, and manageable fashion. The result is an application that is well organized and easy to extend—even by users, and even at runtime.</p>
<p>
In this article, we will show you how to solve common problems of complicated application architectures by structuring classes to your utmost advantageæimplementing generic behavior high up in the inheritance chain and pushing context-specific behavior down to the most <BR>derived classes. With the concept of dynamic objects, you can take this strategy for structuring classes to the limit and allow new object classes to be introduced to the application at runtime.</p>
<p>
Rather than focusing on an isolated technology area, this article takes a stab at the big picture using an application of arbitrary complexity. We are providing a large amount of example code to show you how it can all fit together. All of the concepts will be demonstrated through a series of dynamic runtime objects and views that live in separate MFC Extension DLLs. The objects are hosted by a generic container application called ObjectView. (You can get the complete source code, as well as the ObjectView container app, from the sources listed on page 5.) We hope that the ideas and components presented here will be a useful addition to your box of development tools.</p>
<p>
We’ll start by showing you how easy it is to build a DLL that houses a simple dynamic runtime object and an associated view. Then we’ll look at three key components that make it work—a class broker, a view broker, and an object broker. Of particular interest is the object broker, which uses ActiveX™ structured storages and whisks objects in and out of memory as needed, minimizing your application’s overhead.</p>
<p>
 We’ll move on to introduce an extensible Dynamic <BR>Object design pattern that you can use to structure classes and manage object dependencies in your most complex application. The pattern is extensible to situations that require multiple views on complex objects with intricate interdependencies. We’ll use the pattern to create three different dynamic objects that live in MFC Extension DLLs. Each DLL houses a dynamic object class and associated graphical user interface (GUI) classes. The first DLL <BR>demonstrates how a view should interact with a dynamic ob&shy;ject and how to handle persistent data for dynamic objects. The second DLL demonstrates how to handle object <BR>interde&shy;pendencies—a common source of&nbsp;problems in many applications. The third DLL demonstrates the concept of inter&shy;&shy;&shy;changeable classes, which is useful to provide hooks for customizing apps at runtime. We’ll finish up with a few words about how the dynamic object con&shy;&shy;cepts presented here compare with COM, ActiveX, and OLE technologies.</p>
<p>
We’ll be using class diagrams and interaction diagrams to illustrate our design concepts. The class diagrams, based on the Object Modeling Technique (OMT), depict classes, their structures, and the static relationships between them (Figure 1 shows the key to the OMT diagrams.) The interaction diagrams, taken from the Booch method, depict the order in which requests between objects get executed.</p>
<p>
</p>
<p>
Figure 1  OMT Notation Key</p>
<h2>Building a Simple Dynamic Object and View</h2>
<p>
Let’s jump right in with a simple example to demonstrate how easy it is to use dynamic objects. We’ll build an MFC Extension DLL called Simple.dll that will be incorporated into our host application at runtime—without recompiling—thanks to the services of our class, view, and object brokers. Simple.dll will house a dynamic object class called CSimple&shy;Object and an associated view class called CSimpleView (see Figure 2).</p>
<p>
<img src="dynam2.gif" border=0></p>
<p>
Figure 2  CSimpleObject and CSimpleView</p>
<p>
Go to Visual C++&reg;, open a new project workspace, and choose the MFC DLL AppWizard. Make sure to specify an MFC Extension DLL using MFC as a shared DLL. CSimpleObject is derived from a base class called CDynamicObject that we’ll discuss later. For this example, all we’ll include is a constructor, a destructor, and a Serialize function. All three of these functions will be just empty shells. We’ll look at more interesting examples later. Make sure to use the DECLARE_<BR>SERIAL macro in your class definition and the IMPLEMENT_SERIAL macro in your implementation file to allow the object to be dynamically created and serialized:</p>
<p>
IMPLEMENT_SERIAL(CSimpleObject,<BR>                 CDynamicObject,1)</p>
<p>
CSimpleObject::CSimpleObject() </p>
<p>
{</p>
<p>
  // nothing required for this </p>
<p>
  // simple example</p>
<p>
}</p>
<p>
CSimpleObject::~CSimpleObject()</p>
<p>
{</p>
<p>
  // nothing required for this </p>
<p>
  // simple example</p>
<p>
}</p>
<p>
void CSimpleObject::Serialize(CArchive&amp; </p>
<p>
                         archive)</p>
<p>
{</p>
<p>
  // remember to call the base class</p>
<p>
  CDynamicObject::Serialize(archive);</p>
<p>
}</p>
<p>
Next, add some code for the CSimple&shy;View class. Use the MFC ClassWizard to create a class derived from a CForm&shy;View. ClassWizard automatically <BR>adds the DECLARE_DYN&shy;CREATE macro to the class definition and the <BR>IMPLEMENT_ DYNCREATE macro to the implementation file. Note that we’ve changed the base class from CForm&shy;View to CNSFlexFormView. CNSFlexFormView is from the NSViews C++ library. This library gives all the views in our sample code some distinctive resizing behavior:</p>
<p>
IMPLEMENT_DYNCREATE(CSimpleView, CNSFlexFormView)</p>
<p>
CSimpleView::CSimpleView() : CNSFlexFormView(CSimpleView::IDD)</p>
<p>
{</p>
<p>
  // nothing required for this simple example</p>
<p>
}</p>
<p>
A basic rule for good architectures is to keep user interface object classes separate from functional object classes. In our case, CSimpleView is our user interface class and CSimple&shy;Object is our functional class. It’s OK for CSimple&shy;View to hold a reference to CSimpleObject, but CSimple&shy;Object should have no knowledge of CSimpleView. How does CSimpleView get hold of the associated CSimpleObject? Here’s where the view broker and object broker come in. The view broker will send a WM_OBJECT&shy;INFO custom message that includes a unique key associated with the dy&shy;namic object we need. Given the key, we can get hold of our dynamic object from the object broker. A pointer to the object broker is also passed with the message. CSimpleView::<BR>OnObjectInfo (see Figure 3) shows how to handle the WM_OBJECTINFO message.</p>
<p>
Figure 3  Simple Dynamic Object and View</p>
<p>
OnObjectInfo Method of CSimpleView</p>
<p>
BEGIN_MESSAGE_MAP(CSimpleView, CNSFlexFormView)</p>
<p>
    //{{AFX_MSG_MAP(CSimpleView)</p>
<p>
        // NOTE - the ClassWizard will add and remove </p>
<p>
        //        mapping macros here.</p>
<p>
    //}}AFX_MSG_MAP</p>
<p>
    ON_MESSAGE(WM_OBJECTINFO,OnObjectInfo)</p>
<p>
END_MESSAGE_MAP()</p>
<p>
LRESULT CSimpleView::OnObjectInfo(WPARAM wParam, LPARAM lParam)</p>
<p>
{</p>
<p>
    ObjectInfoMessage* pObjectInfoMessage =</p>
<p>
        (ObjectInfoMessage*)(lParam);</p>
<p>
    CObjectBroker* pObjectBroker = pObjectInfoMessage-&gt;pObjectBroker;</p>
<p>
    CObjectInfo* pObjectInfo = </p>
<p>
        pObjectBroker-&gt;GetObjectInfoByKey(pObjectInfoMessage-&gt;</p>
<p>
                                          pszObjectKey);</p>
<p>
    ASSERT(pObjectInfo);</p>
<p>
    m_pSimpleObject = (CSimpleObject*)pObjectInfo-&gt;GetObject();</p>
<p>
    ASSERT(m_pSimpleObject);</p>
<p>
    ASSERT(m_pSimpleObject-&gt;IsKindOf(RUNTIME_CLASS(CSimpleObject)));</p>
<p>
    return 1;</p>
<p>
}</p>
<p>
DllMain Function for Simple.dll</p>
<p>
extern &quot;C&quot; int APIENTRY</p>
<p>
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)</p>
<p>
{</p>
<p>
    if (dwReason == DLL_PROCESS_ATTACH)</p>
<p>
    {</p>
<p>
        TRACE0(&quot;SIMPLE.DLL Initializing!\n&quot;);</p>
<p>
        </p>
<p>
        // Extension DLL one-time initialization</p>
<p>
        AfxInitExtensionModule(SimpleDLL, hInstance);</p>
<p>
        // Insert this DLL into the resource chain</p>
<p>
        new CDynLinkLibrary(SimpleDLL);</p>
<p>
    }</p>
<p>
    else if (dwReason == DLL_PROCESS_DETACH)</p>
<p>
    {</p>
<p>
        TRACE0(&quot;SIMPLE.DLL Terminating!\n&quot;);</p>
<p>
        AfxTermExtensionModule(SimpleDLL);</p>
<p>
    }</p>
<p>
    return 1;   // ok</p>
<p>
}</p>
<p>
ClassInfo Function Exported from Simple.dll</p>
<p>
extern &quot;C&quot; void WINAPI ClassInfo(CLSID&amp; clsidClassID, </p>
<p>
                                 CLSID&amp; clsidClassCategory, </p>
<p>
                                 CString&amp; csDescription,</p>
<p>
                                 CRuntimeClass*&amp; pObjectClass, </p>
<p>
                                 CRuntimeClass*&amp; pFrameClass,</p>
<p>
                                 CRuntimeClass*&amp; pViewClass)</p>
<p>
{</p>
<p>
    // ID: {34E338C1-86E1-11d0-8984-00008609452B}</p>
<p>
    CLSID clsidID = { 0x34e338c1, 0x86e1, 0x11d0, </p>
<p>
        { 0x89, 0x84, 0x0, 0x0, 0x86, 0x9, 0x45, 0x2b } };</p>
<p>
    // CATEGORY: {8CEDC521-90AF-11d0-A263-2AC81B000000}</p>
<p>
    CLSID clsidCategory = { 0x8cedc521, 0x90af, 0x11d0,</p>
<p>
        { 0xa2, 0x63, 0x2a, 0xc8, 0x1b, 0x0, 0x0, 0x0 } };</p>
<p>
    clsidClassID = clsidID;</p>
<p>
    clsidClassCategory = clsidCategory;</p>
<p>
    csDescription = &quot;Simple Object&quot;;</p>
<p>
    pObjectClass = RUNTIME_CLASS(CSimpleObject);</p>
<p>
    pFrameClass = RUNTIME_CLASS(CFlexibleChildFrame);</p>
<p>
    pViewClass = RUNTIME_CLASS(CSimpleView);</p>
<p>
}</p>
<p>
When we’re done with the dynamic object, we need to call CDynamicObject::Release. A convenient place to do that is in the destructor for our view:</p>
<p>
CSimpleView::~CSimpleView()</p>
<p>
{</p>
<p>
  m_pSimpleObject-&gt;Release();</p>
<p>
}</p>
<p>
The object broker will load and unload DLLs as dynamic objects are created and deleted. The code for DllMain that AppWizard created for us didn’t include a call to AfxTerm&shy;ExtensionModule—it’s unusual for DLLs to be unloaded as we do here. But, if you’re going to unload MFC Extension DLLs, you need to be sure to call AfxTermEx&shy;tensionModule (see Figure 3). Some very mysterious (and bad) things will happen if you forget this detail.</p>
<p>
The last thing we have to do is tell the class broker that our DLL houses a dynamic object and associated view. The class broker will load our DLL and search for an exported function called ClassInfo (see Figure 3). ClassInfo must return a class ID, a class category, and a short description for our dynamic object. In addition, ClassInfo must return the runtime classes of our dynamic object, frame, and view. The class ID and class category are easily generated using the Guidgen.exe program that ships with Visual C++. The class ID for each runtime DLL must be globally unique. Later we’ll see that it is useful to identify classes that are interchangeable. The class category is used for this purpose and must be globally unique for each category of interchangeable classes.</p>
<h2>Using Dynamic Objects</h2>
<p>
Now that we’ve built a DLL that contains a dynamic object, let’s run it by using ObjectView, a generic container for dynamic objects. The behavior of the dynamic object and view can be as simple or as complicated as required. What’s important is that we define all that behavior in the DLL. The main application doesn’t know a thing about either of the classes—except that the dynamic object is derived from CDynamicObject. The main application doesn’t even need to include any headers for the classes defined and implemented in the DLL. If you run ObjectView without any DLLs containing dynamic objects in ObjectView’s&nbsp;directory,&nbsp;it’s&nbsp;rather boringæ<BR>just an empty shell (see Figure 4). But copy Simple.dll into ObjectView’s directory and suddenly ObjectView is hosting both the CSimpleObject object and the CSimpleView view (see Figure 5).</p>
<p>
<img src="dynam4.gif" border=0></p>
<p>
Figure 4  ObjectView, no DLLs</p>
<p>
<img src="dynam5.gif" border=0></p>
<p>
Figure 5  Hosting Dynamic Object and View</p>
<p>
CSimpleObject and CSimpleView don’t really do much more than display a bitmap that was included in the dialog resource associated with the CForm&shy;View. However, all the hooks are in place for more sophisticated behaviors. Later, in our more complicated examples, we’ll let our imagination go a little further and create some spinning rotors that use threads and persist&nbsp;their state through CDynamic&shy;Object::&shy;Serialize. You’ll be surprised how easy it is, and the objects can be as big and complicated as you want. The dynamic objects can even have complex interdependencies. </p>
<p>
The three key components that support this extensibility aren’t that complicated. The class broker registers classes for dynamic objects. The view broker manages views on dynamic objects. The object broker dispenses dynamic objects as needed. We’ll take a look at each of them in detail. But first, we need to introduce one more concept that will be a recurring theme in almost every ingredient of our dynamic object architecture.</p>
<h2>Observer Design Pattern</h2>
<p>
The well-known Observer design pattern provides a useful context for managing object interdependencies. The Observer pattern recognizes that applications are replete with interdependent objects, and a generic method of communicating changes between objects is essential. Communication between subject and observer is best accomplished when the subject object does not need to know anything specific about the observer object except that the observer must be notified of any change. MFC’s document view architecture is a form of the Observer pattern.</p>
<p>
Our implementation of the Observer pattern centers on two classes, CSubject and CObserver, which allow interested observers to register with and be notified about changes to interesting subjects (see Figure 6). CSubject::NotifyObservers broadcasts change notifications to all registered COb&shy;servers. CSubject::AttachTo&shy;Subject and CSubject::DetachFromSubject register and unregister CObservers. CObser&shy;ver::Subject&shy;Changed is a virtual function that must be overridden to receive change notifications from CSubjects.</p>
<p>
<img src="dynam6.gif" border=0></p>
<p>
Figure 6  CSubject and CObserver</p>
<p>
These classes are a snap to use and can make complex communication among objects manageable and bug-free. For example, the view broker is an observer, the object broker is a subject, and dynamic objects may be either or both. The Observer design pattern is a cornerstone for the Dynamic Object pattern, which we will use to support complicated cases where an object needs to observe multiple subjects as well as be observed by multiple observers.</p>
<h2>Class Broker</h2>
<p>
We need a vehicle to whisk code for object classes into and out of the application’s address space at runtime. CClassBroker and CClassInfo provide this service (see Figure 7). CClassBro&shy;ker::&shy;LoadDLLModules (see Figure 8) is called as part of the application’s initialization. LoadDLLModules searches the application’s directory, loads each DLL residing there via a call to ::Afx&shy;LoadLibrary, and inquires—via a call to ::GetProc&shy;Address—whether a function called ClassInfo is exported from the DLL. If GetProc&shy;Address locates ClassInfo, Class&shy;Info is called to obtain six pieces of information:
<ul>
<li>
class ID associated with the object in the DLL (must be unique)<br><br></li>
<li>
class category of the object (unique for each category of interchangeable classes)<br><br></li>
<li>
short text description of the object<br><br></li>
<li>
runtime class of the object<br><br></li>
<li>
runtime class of the frame for the object’s view<br><br></li>
<li>
runtime class of the object’s view</li>
</ul>
<p>
<img src="dynam7.gif" border=0></p>
<p>
Figure 7  CClassBroker and CClassInfo</p>
<dl>
<dt>
Figure 8  LoadDllModules Method of CClassBroker</dt>
<dd>
void CClassBroker::LoadDLLModules()<p>
{</p>
<p>
    char szBuffer[MAX_PATH], szDrive[3], szPath[MAX_PATH];</p>
<p>
    GetModuleFileName(AfxGetInstanceHandle(),szBuffer,MAX_PATH);</p>
<p>
    _splitpath(szBuffer,szDrive,szPath,NULL,NULL);</p>
<p>
    CString csPath = szDrive;</p>
<p>
    csPath += szPath;</p>
<p>
    CString csDLLSearch = csPath + &quot;*.dll&quot;;</p>
<p>
    WIN32_FIND_DATA FileData;</p>
<p>
    HANDLE hFind;</p>
<p>
    for (BOOL bOK = ((hFind = FindFirstFile(csDLLSearch,&amp;FileData))</p>
<p>
        != INVALID_HANDLE_VALUE); bOK;</p>
<p>
        bOK = FindNextFile(hFind,&amp;FileData))</p>
<p>
    {</p>
<p>
        CString csDLL = csPath;</p>
<p>
        csDLL += FileData.cFileName;</p>
<p>
        HMODULE hModule = AfxLoadLibrary(csDLL);</p>
<p>
        ASSERT(hModule);</p>
<p>
        typedef void (WINAPI* CLASSINFO)(CLSID&amp;,CLSID&amp;,CString&amp;, </p>
<p>
                      CRuntimeClass*&amp;,CRuntimeClass*&amp;,CRuntimeClass*&amp;);</p>
<p>
        CLASSINFO pClassInfo =</p>
<p>
            (CLASSINFO)GetProcAddress(hModule,&quot;ClassInfo&quot;);</p>
<p>
        if (pClassInfo)</p>
<p>
        {</p>
<p>
            CLSID clsidClassID;</p>
<p>
            CLSID clsidClassCategory;</p>
<p>
            CString csDescription;</p>
<p>
            CRuntimeClass* pObjectClass;</p>
<p>
            CRuntimeClass* pFrameClass;</p>
<p>
            CRuntimeClass* pViewClass;</p>
<p>
            (*pClassInfo)(clsidClassID,clsidClassCategory,</p>
<p>
                          csDescription,pObjectClass,pFrameClass,</p>
<p>
                          pViewClass);</p>
<p>
            if (GetClassInfo(clsidClassID))</p>
<p>
                AfxMessageBox(</p>
<p>
                &quot;CClassBroker::LoadDLLModules - Duplicate class ID&quot;);</p>
<p>
            else</p>
<p>
                AddClassInfo(clsidClassID,clsidClassCategory,</p>
<p>
                             csDescription,pObjectClass,pFrameClass,</p>
<p>
                             pViewClass,csDLL);</p>
<p>
        }</p>
<p>
        AfxFreeLibrary(hModule);</p>
<p>
    }</p>
<p>
}</p>
</dd>
</dl>
<p>
You’ve already seen a typical implementation of ClassInfo in the Simple.dll example. The information returned from ClassInfo, along with the full path to the associated DLL, is passed to CClassBroker::AddClassInfo. AddClassInfo instantiates a CClassInfo object and adds it to a static list of available CClassInfo objects.</p>
<p>
Each DLL is then unloaded via a call to ::AfxFreeLibrary. A DLL only needs to stay loaded if objects defined in the DLL are actually instantiated by the application. CClassIn&shy;fo::&shy;LoadLibrary and CClassInfo::FreeLibrary provide the mechanism to load and unload a DLL as required. It’s important to note that each time a DLL is loaded, the addresses of the runtime classes in the DLL may change. Therefore, LoadLibrary will always need to call ClassInfo to get the current addresses. We’ll see how LoadLibrary is called to do its work when we look at the object broker.</p>
<h2>View Broker</h2>
<p>
MFC’s AppWizard generates code that creates a single CMultiDocTemplate as part of the application object’s InitInstance function. CMultiDocTemplate ties together the document, frame window, and view. But we know nothing about the type of view or frame our runtime object will need until the DLL is loaded at runtime. CViewBroker, CViewInfo, and CMultiDocTemplateEx provide a mechanism that will let us open a view, or even multiple views, on our dynamic object (see Figure 9). In order to use these classes, the code that AppWizard generates for us needs to be altered to create a CMultiDocTemplateEx instead of a CMultiDocTemplate:</p>
<p>
CMultiDocTemplateEx* pDocTemplate = new CMultiDocTemplateEx(</p>
<p>
  IDR_OBVIEWTYPE,</p>
<p>
  RUNTIME_CLASS(CObjectViewDoc),</p>
<p>
  RUNTIME_CLASS(CFlexibleChildFrame), </p>
<p>
  RUNTIME_CLASS(CObjectBrokerView));</p>
<p>
AddDocTemplate(pDocTemplate);</p>
<p>
<img src="dynam9.gif" border=0></p>
<p>
Figure 9  CMultiDocTemplateEx, CViewBroker, and CViewInfo</p>
<p>
Here’s the CMultiDocTemplateEx constructor. It saves the runtime classes of the frame and view for later use:</p>
<p>
CMultiDocTemplateEx::CMultiDocTemplateEx(UINT&nbsp;nIDResource,</p>
<p>
                           CRuntimeClass* pDocClass,</p>
<p>
                           CRuntimeClass* pFrameClass,</p>
<p>
                           CRuntimeClass* pViewClass) : </p>
<p>
CMultiDocTemplate(nIDResource,   </p>
<p>
                  pDocClass,pFrameClass,pViewClass)</p>
<p>
{</p>
<p>
  m_pDefaultFrameClass = pFrameClass;</p>
<p>
  m_pDefaultViewClass = pViewClass;</p>
<p>
}</p>
<p>
To open a view on one of our dynamic objects,&nbsp;call CView&shy;Broker::OpenView (see Figure 10) with the key to the object. If a view is already open on the object, OpenView activates it. Otherwise, OpenView calls CViewBroker::Open&shy;Dupli&shy;cate&shy;&shy;View (see Figure 10) to create a new view.</p>
<p>
Figure 10  View Broker Code</p>
<p>
OpenView Method of CViewBroker</p>
<p>
void CViewBroker::OpenView(LPCTSTR pszObjectKey)</p>
<p>
{</p>
<p>
    CViewInfo* pViewInfo;</p>
<p>
    if (m_mapViewInfo.Lookup(pszObjectKey,(void*&amp;)pViewInfo))</p>
<p>
    {</p>
<p>
        CView* pView = (CView*)pViewInfo-&gt;m_listViews.GetHead();</p>
<p>
        CMDIChildWnd* pFrameWindow =</p>
<p>
            (CMDIChildWnd*)pView-&gt;GetParent();</p>
<p>
        if (pFrameWindow-&gt;IsIconic())</p>
<p>
            pFrameWindow-&gt;MDIRestore();</p>
<p>
        pFrameWindow-&gt;MDIActivate();</p>
<p>
        return;</p>
<p>
    }</p>
<p>
    pViewInfo = new CViewInfo();</p>
<p>
    m_mapViewInfo.SetAt(pszObjectKey,pViewInfo);</p>
<p>
    OpenDuplicateView(pszObjectKey);</p>
<p>
}</p>
<p>
OpenDuplicateView Method of CViewBroker</p>
<p>
void CViewBroker::OpenDuplicateView(LPCTSTR pszObjectKey)</p>
<p>
{</p>
<p>
    CObjectInfo* pObjectInfo = m_pObjectBroker-&gt;</p>
<p>
        GetObjectInfoByKey(pszObjectKey);</p>
<p>
    CClassInfo* pClassInfo = </p>
<p>
        CClassBroker::GetClassInfo(pObjectInfo-&gt;GetClassID());</p>
<p>
    CMultiDocTemplateEx* pDocTemplate = </p>
<p>
        (CMultiDocTemplateEx*)m_pObjectDoc-&gt;GetDocTemplate();</p>
<p>
    CFrameWnd* pFrameWnd = pDocTemplate-&gt;CreateNewFrame(</p>
<p>
        m_pObjectDoc,pClassInfo-&gt;GetFrameClass(),</p>
<p>
        pClassInfo-&gt;GetViewClass());</p>
<p>
    CView* pView =</p>
<p>
        (CView*)pFrameWnd-&gt;</p>
<p>
            GetDescendantWindow(AFX_IDW_PANE_FIRST,TRUE);</p>
<p>
    ASSERT(pView-&gt;IsKindOf(pClassInfo-&gt;GetViewClass()));</p>
<p>
    CViewInfo* pViewInfo = NULL;</p>
<p>
    m_mapViewInfo.Lookup(pszObjectKey,(void*&amp;)pViewInfo);</p>
<p>
    ASSERT(pViewInfo);</p>
<p>
    pViewInfo-&gt;m_listViews.AddTail(pView);</p>
<p>
    ObjectInfoMessage structObjectInfoMessage;</p>
<p>
    structObjectInfoMessage.pObjectBroker = m_pObjectBroker;</p>
<p>
    structObjectInfoMessage.pszObjectKey = pszObjectKey;</p>
<p>
    VERIFY(pView-&gt;SendMessage(WM_OBJECTINFO,0,</p>
<p>
        (LPARAM)&amp;structObjectInfoMessage));</p>
<p>
    SetWindowTitles();</p>
<p>
    pDocTemplate-&gt;InitialUpdateFrame(pFrameWnd,m_pObjectDoc);</p>
<p>
}</p>
<p>
CreateNewFrame Method of CMultiDocTemplateEx</p>
<p>
CFrameWnd* CMultiDocTemplateEx::CreateNewFrame(CDocument* pDoc, </p>
<p>
    CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass)</p>
<p>
{</p>
<p>
    if (pFrameClass)</p>
<p>
        m_pFrameClass = pFrameClass;</p>
<p>
    else</p>
<p>
        m_pFrameClass = m_pDefaultFrameClass;</p>
<p>
    if (pViewClass)</p>
<p>
        m_pViewClass = pViewClass;</p>
<p>
    else</p>
<p>
        m_pViewClass = m_pDefaultViewClass;</p>
<p>
    return CMultiDocTemplate::CreateNewFrame(pDoc,NULL);</p>
<p>
}</p>
<p>
CViewBroker::OpenDuplicateView asks the CClass&shy;Broker for the associated CClassInfo for the requested key. Now we can call CMultiDocTemplateEx::CreateNewFrame with the runtime classes of the frame and view we get from CClassInfo. After the view is created, we send it a WM_<BR>OBJECTINFO custom message that includes the key for the object and a pointer to the object broker.</p>
<p>
CMultiDocTemplateEx::CreateNewFrame (see Figure 10) performs some slight of hand to trick CMultiDocTem&shy;plate::CreateNewFrame into using the specified MDI frame and view.</p>
<h2>Object Broker</h2>
<p>
The object broker conserves memory resources by keeping objects in memory only as long as they are needed. This also makes saving files almost instantaneous since there are fewer objects living in memory. In addition, the object broker allows you to store and serialize references to dependent objects as simple keys. The object broker is implemented using three classes: CObjectBroker, CObjectInfo, and CDynamicObject (see Figure 11).</p>
<p>
<img src="dynam11.gif" border=0></p>
<p>
Figure 11  CObjectBroker, CObjectInfo, and CDynamicObject</p>
<p>
CDynamicObject provides a base class for our dynamic objects. Each dynamic object derived from CDynamicObject is added to a CObjectBroker container object along with an associated CObjectInfo object. When the CDynamicObject object is created, it actually goes into an ActiveX structured storage living in the application’s compound file. Each CDynamicObject object resides in the structured storage on disk until you need it. At that time, get hold of the associated CObjectInfo object and then ask it to bring your dynamic object from the structured storage into memory. Everything happens transparently, so it’s easy to use. Let’s see what makes it work.</p>
<p>
A dynamic object derived from CDynamicObject is created and inserted into a CObjectBroker object along with an associated CObjectInfo object, using CObjectBroker::Add (see Figures 12 and 13). Add takes one of the class IDs registered with CClassBroker and returns a unique key for the new dynamic object. First, Add generates a unique key, a unique default object name, and a unique ActiveX structured storage stream name. Then, Add instantiates a new CObject&shy;Info, assigns the key, object name, and stream name, and then calls CObjectInfo::Set&shy;ClassID (see <BR>Figure 13).</p>
<p>
<img src="dynam12.gif" border=0></p>
<p>
Figure 12  Adding a Dynamic Object to CObjectBroker</p>
<p>
Figure 13  Object Broker Code</p>
<p>
Add Method of CObjectBroker</p>
<p>
BOOL CObjectBroker::Add(REFCLSID rclsid, CString&amp; rcsKey)</p>
<p>
{</p>
<p>
    CString csName, csStream;</p>
<p>
    GenerateUniqueKey(rcsKey);</p>
<p>
    GenerateUniqueName(csName);</p>
<p>
    GenerateUniqueStream(csStream);</p>
<p>
    </p>
<p>
    CObjectInfo* pObjectInfo = new CObjectInfo;</p>
<p>
    pObjectInfo-&gt;SetKey(rcsKey);</p>
<p>
    pObjectInfo-&gt;SetName(csName);</p>
<p>
    pObjectInfo-&gt;SetStream(csStream);</p>
<p>
    pObjectInfo-&gt;SetObjectBroker(this);</p>
<p>
    if(!pObjectInfo-&gt;SetClassID(rclsid))</p>
<p>
    {</p>
<p>
        delete pObjectInfo;</p>
<p>
        return FALSE;</p>
<p>
    }</p>
<p>
    m_mapObjectsByKey.SetAt(rcsKey,pObjectInfo);</p>
<p>
    m_mapObjectsByName.SetAt(csName,pObjectInfo);</p>
<p>
    m_mapObjectsByStream.SetAt(csStream,pObjectInfo);</p>
<p>
    NotifyObservers(OBJECT_BROKER_ADDED_OBJECT,&amp;rcsKey);</p>
<p>
    return TRUE;</p>
<p>
}</p>
<p>
SetClassID Method of CObjectInfo</p>
<p>
BOOL CObjectInfo::SetClassID(REFCLSID rclsid)</p>
<p>
{</p>
<p>
    ASSERT(m_pDynamicObject == NULL);</p>
<p>
    m_clsid = rclsid;</p>
<p>
    CClassInfo* pClassInfo = GetClassInfo();</p>
<p>
    if (pClassInfo == NULL)</p>
<p>
        return FALSE;</p>
<p>
    pClassInfo-&gt;LoadLibrary();</p>
<p>
    CRuntimeClass* pObjectClass = pClassInfo-&gt;GetObjectClass();</p>
<p>
    ASSERT(pObjectClass);</p>
<p>
    if (!pObjectClass-&gt;IsDerivedFrom(RUNTIME_CLASS(CDynamicObject)))</p>
<p>
        return FALSE;</p>
<p>
    </p>
<p>
    m_pDynamicObject = </p>
<p>
        (CDynamicObject*)pObjectClass-&gt;CreateObject();</p>
<p>
    ASSERT(m_pDynamicObject);</p>
<p>
    ASSERT(m_pDynamicObject-&gt;IsKindOf(RUNTIME_CLASS(CDynamicObject)));</p>
<p>
    m_pDynamicObject-&gt;SetObjectInfo(this);</p>
<p>
    m_pDynamicObject-&gt;OnCreatedNewObject();</p>
<p>
    StoreObject(TRUE);</p>
<p>
    return TRUE;</p>
<p>
}</p>
<p>
StoreObject Method of CObjectInfo</p>
<p>
void CObjectInfo::StoreObject(BOOL bFreeMemory)</p>
<p>
{</p>
<p>
    LPSTORAGE pObjectStorage = GetObjectBroker()-&gt;GetObjectStorage();</p>
<p>
    COleStreamFile StreamFile;</p>
<p>
    if (StreamFile.OpenStream(pObjectStorage,GetStream())== FALSE)</p>
<p>
        VERIFY(StreamFile.CreateStream(pObjectStorage,GetStream()));</p>
<p>
    CArchive Archive(&amp;StreamFile,</p>
<p>
        CArchive::store|CArchive::bNoFlushOnDelete);</p>
<p>
    Archive.m_bForceFlat = FALSE;</p>
<p>
    Archive &lt;&lt; m_pDynamicObject;</p>
<p>
    Archive.Close();</p>
<p>
    StreamFile.Close();</p>
<p>
    pObjectStorage-&gt;Commit(STGC_DEFAULT);</p>
<p>
    pObjectStorage-&gt;Release();</p>
<p>
    if (bFreeMemory)</p>
<p>
    {</p>
<p>
        delete m_pDynamicObject;</p>
<p>
        m_pDynamicObject = NULL;</p>
<p>
    }</p>
<p>
}</p>
<p>
GetObject Method of CObjectInfo</p>
<p>
CDynamicObject* CObjectInfo::GetObject()</p>
<p>
{</p>
<p>
    if (m_pDynamicObject)</p>
<p>
    {</p>
<p>
        m_pDynamicObject-&gt;AddRef();</p>
<p>
        return m_pDynamicObject;</p>
<p>
    }</p>
<p>
    LPSTORAGE pObjectStorage = GetObjectBroker()-&gt;GetObjectStorage();</p>
<p>
    COleStreamFile StreamFile;</p>
<p>
    VERIFY(StreamFile.OpenStream(pObjectStorage,GetStream()));</p>
<p>
    CArchive Archive(&amp;StreamFile,</p>
<p>
        CArchive::load|CArchive::bNoFlushOnDelete);</p>
<p>
    Archive.m_bForceFlat = FALSE;</p>
<p>
    Archive &gt;&gt; m_pDynamicObject;</p>
<p>
    Archive.Close();</p>
<p>
    StreamFile.Close();</p>
<p>
    pObjectStorage-&gt;Release();</p>
<p>
    </p>
<p>
    ASSERT(m_pDynamicObject);</p>
<p>
    ASSERT(m_pDynamicObject-&gt;IsKindOf(RUNTIME_CLASS(CDynamicObject)));</p>
<p>
    m_pDynamicObject-&gt;SetObjectInfo(this);</p>
<p>
    m_pDynamicObject-&gt;AddRef();</p>
<p>
    m_pDynamicObject-&gt;OnSerializedObjectFromArchive();</p>
<p>
    return m_pDynamicObject;</p>
<p>
}</p>
<p>
GetObjectStorage Method of CObjectBroker</p>
<p>
LPSTORAGE CObjectBroker::GetObjectStorage()</p>
<p>
{</p>
<p>
    BSTR bstrObjectStorage = m_csObjectStorageName.AllocSysString();</p>
<p>
    LPSTORAGE pObjectStorage = NULL;</p>
<p>
    HRESULT hr = m_pRootStorage-&gt;OpenStorage(bstrObjectStorage,  </p>
<p>
                          NULL,STGM_SHARE_EXCLUSIVE|STGM_READWRITE|STGM_TRANSACTED,</p>
<p>
                          NULL,0,&amp;pObjectStorage);</p>
<p>
    ASSERT(SUCCEEDED(hr));</p>
<p>
    SysFreeString(bstrObjectStorage);</p>
<p>
    return pObjectStorage;</p>
<p>
}</p>
<p>
SetRootStorage Method of CObjectBroker</p>
<p>
void CObjectBroker::SetRootStorage(LPSTORAGE pRootStorage)</p>
<p>
{</p>
<p>
    if (m_pRootStorage == pRootStorage)</p>
<p>
        return;</p>
<p>
    BSTR bstrObjectStorage = m_csObjectStorageName.AllocSysString();</p>
<p>
    if (m_pRootStorage == NULL)</p>
<p>
    {</p>
<p>
        LPSTORAGE pObjectStorage = NULL;</p>
<p>
        m_pRootStorage = pRootStorage;</p>
<p>
        if (FAILED(m_pRootStorage-&gt;OpenStorage(bstrObjectStorage,</p>
<p>
            NULL,STGM_SHARE_EXCLUSIVE|STGM_READWRITE,</p>
<p>
            NULL,0,&amp;pObjectStorage)))</p>
<p>
            m_pRootStorage-&gt;CreateStorage(bstrObjectStorage,</p>
<p>
                STGM_SHARE_EXCLUSIVE|STGM_READWRITE,</p>
<p>
                0,0,&amp;pObjectStorage);</p>
<p>
                    </p>
<p>
        pObjectStorage-&gt;Release();</p>
<p>
    }</p>
<p>
    else</p>
<p>
    {</p>
<p>
        m_pRootStorage-&gt;MoveElementTo(bstrObjectStorage,</p>
<p>
            pRootStorage,bstrObjectStorage,STGMOVE_COPY);</p>
<p>
        m_pRootStorage = pRootStorage;</p>
<p>
    }</p>
<p>
    SysFreeString(bstrObjectStorage);</p>
<p>
}</p>
<p>
OnNewDocument Method and Serialize Method of CObjectDoc</p>
<p>
BOOL CObjectDoc::OnNewDocument()</p>
<p>
{</p>
<p>
    if (!COleDocument::OnNewDocument())</p>
<p>
        return FALSE;</p>
<p>
    m_pObjectBroker-&gt;SetRootStorage(m_lpRootStg);</p>
<p>
    return TRUE;</p>
<p>
}</p>
<p>
void CObjectDoc::Serialize(CArchive&amp; ar)</p>
<p>
{</p>
<p>
    COleDocument::Serialize(ar);</p>
<p>
    m_pObjectBroker-&gt;SetRootStorage(m_lpRootStg);</p>
<p>
    m_pObjectBroker-&gt;Serialize(ar);</p>
<p>
}</p>
<p>
One of the first things that CObjectInfo::SetClassID does is to call CClassInfo::LoadLibrary to insure the DLL containing the code for the dynamic object is loaded. Then, SetClassID calls CClass&shy;Info::&shy;GetObjectClass to obtain the runtime class of the dynamic object to be created. Next, MFC’s dynamic object creation facility is used to breathe life into the dynamic object via a call to CRun&shy;timeClass::CreateObject. After the object is dynamically created, SetClassID gives you a hook to do whatever processing may be appropriate at this time via a call to the&nbsp;virtual&nbsp;function&nbsp;CDynamic&shy;Object::OnCreatedNewObject (which you can override). Finally, we send the object out of memory to the ActiveX structured storage with a call to CObjectInfo::StoreObject (see <BR>Figure 13).</p>
<p>
Here’s how CObjectInfo::StoreObject works. A pointer to the IStorage COM interface on a storage is obtained through a call to CObjectBroker::GetObjectStorage. With the IStorage interface in hand, we open or create a COleStream&shy;File named with the unique stream name obtained from CObjectInfo::GetStream. We create a CArchive on the COleStreamFile and dump the CDynamicObject into the archive. Finally, we clean up and free the memory where the CDynamicObject was living.</p>
<p>
There’s another thing to notice about CObjectBroker. It uses multiple inheritance to inherit from both CObject and CSubject. Since CObjectBroker contains all of our dynamic objects, CObjectBroker itself will be an interesting subject to many observers. As dynamic objects enter and leave the object broker, CObject&shy;Broker uses CSubject::&shy;&shy;Notify&shy;Observers to let registered observers know about completed additions, pending removals, completed removals, and renamed objects.</p>
<p>
We’ll see how to handle notifications from the object broker a little later. The important thing to recognize now is that, just by inheriting from CSubject, CObject&shy;Broker is able to broadcast notifications in a very generic way. It can do this without having to know anything about whom the observers will be, other than that they are derived from CObserver. This means you write the object broker code once, compile it, and forget it. The Observer pattern leads to the creation of an object broker that is independent of any implementation details associated with objects to which it must send change notifications. Undesirable object dependencies are eliminated. To create an object that needs to know about the object broker, inherit from CObserver, register with the object broker as an observer, and it all just works.</p>
<p>
So far, so good. But how do you get to an existing dynamic object from CObjectBroker? The process is summarized in Figure 14. CObjectBroker::GetObjectInfoByKey, along with the key returned from CObjectBroker::Add, returns a pointer to the CObjectInfo associated with our dynamic object. Call CObjectInfo::Get&shy;Object (see Figure 13) to get a pointer to a CDynamicObject, the base class for the dynamic object. If the object is already alive, GetObject simply increments a reference count and returns the pointer to the living object. Otherwise, we again use MFC’s dynamic object creation facility to create the object, this time through serialization from a temporary CArchive object created using a COleStreamFile in our structured storage. We again give you a hook to do whatever processing may be appropriate via a call to the virtual function CDynamicObject::OnSerializedObjectFrom&shy;Archive, which you can override.</p>
<p>
<img src="dynam14.gif" border=0></p>
<p>
Figure 14  Getting a Dynamic Object from CObjectBroker</p>
<p>
CObjectBroker::GetObjectStorage gets a pointer to the IStorage COM interface for a storage in our application’s compound file. Now here’s the million dollar question: how does m_pRootStorage in CObjectBroker get set? The simple answer is that the document object, in our case CObjectDoc, needs to set it through a call to CObjectBroker::SetRoot&shy;Storage (see Figure 13), but it’s a little more complicated than that. CObjectDoc is derived from the MFC COle&shy;Document. If you go snooping around the MFC header file for COleDocument, you will find a protected member variable called m_lpRootStg. If you call COleDocu&shy;ment::Enable&shy;CompoundFile in the constructor for your document, your app’s file will be a compound file and m_lpRootStg will point to a valid IStorage interface for the root storage. Seems simple enough, but there’s a fly in the ointment. When a new document is opened, m_lpRootStg gets set to a temporary storage. The first time you save the document, MFC suddenly changes m_lpRootStg to a permanent storage in the actual file. To get around this issue, COb&shy;ject&shy;Bro&shy;ker::<BR>SetRoot&shy;Storage needs to be called from both COb&shy;ject&shy;&shy;&shy;&shy;Doc::<BR>OnNewDocument and CObjectDoc::Serialize (see Figure 13).</p>
<p>
CObjectBroker::SetRootStorage checks to see if the incoming pointer pRootStorage is the same as the stored pointer m_pRootStorage. If it is, everything is cool and we just return. If m_pRootStorage is NULL, we need to create a storage for our dynamic objects and then set m_pRoot&shy;Storage accordingly. Pretty straightforward. The weird and somewhat confusing condition occurs if m_pRootStorage has already been set and pRootStorage is different. This is the clue that we are doing an initial save of the document and both pointers point to valid storagesæthe temporary one and the permanent one. For this weird case, we need to move the storage we’re using for our dynamic objects from the temporary one to the permanent one.</p>
<p>
Now let’s turn our attention to CDynamicObject, the base class for our dynamic objects. As with ActiveX COM objects, there’s one rule you must always abide by when using CDynamicObjects. When you are done with the CDynamic&shy;Object, you must call CDynamicObject::Release. Release decrements the object’s reference count. If the reference count goes to zero, Release calls CObject&shy;Info::StoreObject, which we discussed earlier. We need to be really careful. StoreObject will delete the CDynamic&shy;Object. This has the same effect as deleting this pointer. Just be careful not to access any of the object’s memory after the call to StoreObject—which is something that is easy to overlook. This is why we return zero rather than m_nRefCount:</p>
<p>
ULONG CDynamicObject::Release()</p>
<p>
{</p>
<p>
  if (--m_nRefCount &gt; 0)</p>
<p>
    return m_nRefCount;</p>
<p>
  else</p>
<p>
  {</p>
<p>
    m_pObjectInfo-&gt;StoreObject(TRUE);</p>
<p>
    return 0;  </p>
<p>
  }</p>
<p>
}</p>
<h2>Dynamic Object Pattern</h2>
<p>
Let’s move on to the Dynamic Object design pattern, which provides a generic, cookbook approach to structuring classes and using dynamic objects in any application. The pattern coordinates the actions of eight participants (see Figure 15):
<ul>
<li>
CViewBroker (or some other class responsible for managing views)<br><br></li>
<li>
CMultiDocTemplateEx<br><br></li>
<li>
MFC Framework<br><br></li>
<li>
KindOfCViewAndCObserver (a class inheriting from CView and CObserver)<br><br></li>
<li>
CObjectBroker<br><br></li>
<li>
CObjectInfo<br><br></li>
<li>
KindOfCDynamicObjectAndCSubject (a class inheriting from CDynamicObject and CSubject)<br><br></li>
<li>
KindOfCDocument (a class inheriting from CDocument)</li>
</ul>
<p>
<img src="dynam15.gif" border=0></p>
<p>
Figure 15  Dynamic Object Pattern</p>
<p>
Keep in mind that while the pattern is described using the&nbsp;CViewBroker&nbsp;class,&nbsp;the&nbsp;pattern&nbsp;can&nbsp;be&nbsp;used&nbsp;in&nbsp;other&nbsp;con&shy;texts as long&nbsp;as&nbsp;some&nbsp;class&nbsp;that&nbsp;is&nbsp;responsible&nbsp;for&nbsp;view management performs the CViewBroker duties described here.</p>
<p>
The first part of the pattern handles the actions required to open a view on a dynamic object. This is a significant task since the application has no knowledge of either the view or the dynamic object that will be created. The pattern begins when CViewBroker calls CMultiDocTemplateEx::Create&shy;New&shy;Frame. CreateNewFrame instantiates a new KindOfC&shy;&shy;ViewAndCObserver. Following the call to CreateNewFrame, CViewBroker calls CWnd::SendMessage to send a WM_<BR>OBJECTINFO custom message to the newly created KindOf&shy;C&shy;ViewAndCObserver. A pointer to an ObjectInfoMessage structure is passed along with the message. This structure contains the unique key for the dynamic object associated with the view being opened, along with a pointer to the object broker. The call to SendMessage triggers a call to KindOfCViewAndCObserver::On&shy;ObjectInfo.&nbsp;Since&nbsp;a <BR>pointer to the object broker was passed with the message, OnObject&shy;Info can call CObjectBroker::&shy;Get&shy;Object&shy;InfoByKey and then CObjectInfo::GetObject to obtain a pointer to the dynamic object.</p>
<p>
Recall that the call to GetObject will cause the dynamic object to move from the application’s compound file into active memory if it isn’t already there. Also, remember that a call to GetObject carries with it an obligation to call CDynamicObject::Release when we are finished with the dynamic object. With the pointer to the dynamic object in hand, OnObjectInfo can call CSubject::AttachToSubject to register KindOfCViewAndCObserver as an observer of Kind&shy;OfCDynamicObjectAndCSubject. Finally, CView&shy;Broker calls CMultiDocTemplate::InitialUpdate&shy;Frame, which will result in a call to KindOfCViewAndC&shy;Obser&shy;ver::OnInitialUpdate and KindOfCViewAndC&shy;Observer::&shy;OnUpdate. These functions need to do whatever is necessary to refresh the view for the first time as indicated in the pattern by the call to KindOfCViewAndCObser&shy;ver::RefreshViewAsRequired. RefreshViewAsRequired is a generic function name that you will probably change to fit your own context.</p>
<p>
The second part of the pattern handles the actions required for KindOfCViewAndCObserver to handle graphical user interface (GUI) events. The MFC framework will trigger a call to KindOfCViewAndCObserver::OnGUIEvent as a result of a GUI event such as pressing a button, changing a selection in a list box, or handling a mouse click. OnGUIEvent is another generic function name that will change depending on the context of the particular GUI event. OnGUIEvent calls KindOfCDynamicObject&shy;AndCSubject::ChangeState (another generic function name) to change the state of the dynamic object as required by the GUI event. Then OnGUIEvent calls CDocument::Set&shy;ModifiedFlag to mark the document as dirty and CDocu&shy;ment::UpdateAllViews to tell all views to update themselves as required.</p>
<p>
Now, let’s back up and look again at KindOfCDyna&shy;micObjectAndCSubject::ChangeState. Note that, after ChangeState performs its designated function, it calls CSubject::NotifyObservers to broadcast a change notification to all registered observers of KindOfCDynamic&shy;ObjectAndCSubject. There could be a very long list of objects and views registered as observers, and the result could be a very complex cascade of events. Don’t worry about all of thatætrust the pattern and everything will work. The call to NotifyObservers will cause the CObserver::SubjectChanged function to be called for each registered observer. KindOfCViewAndCObserver::&shy;Subject&shy;Changed calls KeepTrackOfChanges (another generic function name) which should keep track of the changes required to refresh the CView during the next CView::OnUpdate call, which results from the call to CDocument::Update&shy;AllViews discussed previously. KindOfCViewAndCOb&shy;server::&shy;OnUpdate calls KindOf&shy;CView&shy;And&shy;C&shy;&shy;Observer::&shy;&shy;<BR>Re&shy;fresh&shy;View&shy;AsRequired to accomplish the necessary changes to the view.</p>
<p>
The final part of the pattern concerns the actions required when our KindOfCViewAndCObserver is destructed. We need to call CSubject::DetachFromSubject to unregister the KindOfCViewAndCObserver as an observer of CDyna&shy;mic&shy;ObjectAndSubject. Finally we must call CDynamic&shy;Object::Release, which decrements the reference count on the dynamic object and dismisses the object from memory back to the compound file if the count reaches zero.</p>
<p>
You may be wondering why we decided to send the WM_OBJECTINFO message to the view rather than providing a base class for the view and putting a member function in the base class that communicates the dynamic object information to the view. Since we don’t know what kind of view will be used, we didn’t want to provide several different base classesæone for each view class in MFC. This approach would require using runtime type information to get the class type and then making a call to the appropriate class, which is a very messy way to do things. So we picked the lesser evil of sending a custom message.</p>
<p>
The Dynamic Object pattern probably seems a bit complicated at first glance, but handling multiple views on interdependent objects is not trivial. If you plug into the cookbook design of the Dynamic Object pattern, everything will work. This will become more evident as we move on and look at our three example DLLs. The pattern will be rigorously applied to each one. You will see how extensible the pattern is and how using the pattern becomes a mechanical process that really isn’t all that complicatedæconsidering what it accomplishes.</p>
<h2>Dynamic Objects and Views</h2>
<p>
Our first example DLL,&nbsp;OVRotor.dll, demo&shy;nstrates how a view should interact with a dynamic object and how to handle persistent&nbsp;data&nbsp;for&nbsp;<BR>dyna&shy;mic&nbsp;objects. OVRo&shy;tor.dll houses a dynamic object class called CRotor, a base class for the dynamic object called CGeneric&shy;Rotor, and an associated view class called CRotorView (see Figures 16 and 17). CRotor knows how to draw several different rotors on a device context. The user’s rotor selection is persistent data.</p>
<p>
<img src="dynam16.gif" border=0></p>
<p>
Figure 16  ObjectView Hosting a CRotor Dynamic Object</p>
<p>
<img src="dynam17.gif" border=0></p>
<p>
Figure 17  CRotor, CGenericRotor, and CRotorView</p>
<p>
Recall that a function called ClassInfo must be exported by each DLL housing a dynamic object. ClassInfo for OV&shy;Ro&shy;tor.dll looks a lot like Class&shy;Info did for Simple.dll (see Figure 18). Of course, the class ID, class category, and run&shy;time classes are different.</p>
<p>
Figure 18  OVRotor.dll</p>
<p>
ClassInfo Function Exported from OVRotor.dll</p>
<p>
extern &quot;C&quot; void WINAPI ClassInfo(CLSID&amp; clsidClassID, </p>
<p>
    CLSID&amp; clsidClassCategory, CString&amp; csDescription,</p>
<p>
    CRuntimeClass*&amp; pObjectClass, CRuntimeClass*&amp; pFrameClass,</p>
<p>
    CRuntimeClass*&amp; pViewClass)</p>
<p>
{</p>
<p>
    // ID: {4423E281-664E-11d0-8945-2AFFD5000000}</p>
<p>
    CLSID clsidID = { 0x4423e281, 0x664e, 0x11d0, </p>
<p>
        { 0x89, 0x45, 0x2a, 0xff, 0xd5, 0x0, 0x0, 0x0 } };</p>
<p>
    // CATEGORY: {A8D09C01-90C4-11d0-A264-0040052E01FC}</p>
<p>
    CLSID clsidCategory = { 0xa8d09c01, 0x90c4, 0x11d0, </p>
<p>
        { 0xa2, 0x64, 0x0, 0x40, 0x5, 0x2e, 0x1, 0xfc } };</p>
<p>
    clsidClassID = clsidID;</p>
<p>
    clsidClassCategory = clsidCategory;</p>
<p>
    csDescription = &quot;Rotor&quot;;</p>
<p>
    pObjectClass = RUNTIME_CLASS(CRotor);</p>
<p>
    pFrameClass = RUNTIME_CLASS(CFlexibleChildFrame);</p>
<p>
    pViewClass = RUNTIME_CLASS(CRotorView);</p>
<p>
}</p>
<p>
Constructor for CRotorView</p>
<p>
CRotorView::CRotorView()</p>
<p>
    : CNSFlexFormView(CRotorView::IDD)</p>
<p>
{</p>
<p>
    //{{AFX_DATA_INIT(CRotorView)</p>
<p>
        // NOTE: the ClassWizard will add member initialization here</p>
<p>
    //}}AFX_DATA_INIT</p>
<p>
    m_pRotor = NULL;</p>
<p>
    AddFlexConstraint(IDC_ROTORS,        </p>
<p>
        NSFlexHorizontallyFixed,NSFlexExpandDown);</p>
<p>
    AddFlexConstraint(IDC_LOCATOR,         </p>
<p>
        NSFlexExpandRight,NSFlexExpandDown); </p>
<p>
}</p>
<p>
OnObjectInfo Method of CRotorView</p>
<p>
LRESULT CRotorView::OnObjectInfo(WPARAM wParam, LPARAM lParam)</p>
<p>
{</p>
<p>
    ObjectInfoMessage* pObjectInfoMessage = </p>
<p>
        (ObjectInfoMessage*)(lParam);</p>
<p>
    CObjectBroker* pObjectBroker = pObjectInfoMessage-&gt;pObjectBroker;</p>
<p>
    CObjectInfo* pObjectInfo = </p>
<p>
        pObjectBroker-&gt;GetObjectInfoByKey(pObjectInfoMessage-&gt;</p>
<p>
        pszObjectKey);</p>
<p>
    ASSERT(pObjectInfo);</p>
<p>
    m_pRotor = (CRotor*)pObjectInfo-&gt;GetObject();</p>
<p>
    ASSERT(m_pRotor);</p>
<p>
    ASSERT(m_pRotor-&gt;IsKindOf(RUNTIME_CLASS(CRotor)));</p>
<p>
    m_pRotor-&gt;AttachToSubject(this);</p>
<p>
    return 1;</p>
<p>
}</p>
<p>
Serialize Method of CRotor</p>
<p>
void CRotor::Serialize(CArchive&amp; archive)</p>
<p>
{</p>
<p>
    CDynamicObject::Serialize(archive);</p>
<p>
    if (archive.IsStoring())</p>
<p>
    {</p>
<p>
        archive &lt;&lt; m_nSelectedRotor;</p>
<p>
    }</p>
<p>
    else</p>
<p>
    {</p>
<p>
        archive &gt;&gt; m_nSelectedRotor;</p>
<p>
    }</p>
<p>
}</p>
<p>
OnUpdate Method of CRotorView</p>
<p>
void CRotorView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)</p>
<p>
{</p>
<p>
    if (!m_bNeedUpdate)</p>
<p>
        return;</p>
<p>
    CListBox* pRotorsList = (CListBox*)GetDlgItem(IDC_ROTORS);</p>
<p>
    for (int ii = 0; ii &lt; m_pRotor-&gt;GetNumRotors(); ii++)</p>
<p>
    {</p>
<p>
        if ((int)pRotorsList-&gt;GetItemData(ii) == </p>
<p>
            m_pRotor-&gt;GetSelectedRotor())</p>
<p>
        {</p>
<p>
            pRotorsList-&gt;SetCurSel(ii);</p>
<p>
            break;</p>
<p>
        }</p>
<p>
    }</p>
<p>
    Invalidate();</p>
<p>
    m_bNeedUpdate = FALSE;</p>
<p>
}</p>
<p>
OnSelchangeRotors Method of CRotorView</p>
<p>
void CRotorView::OnSelchangeRotors() </p>
<p>
{</p>
<p>
    CListBox* pRotorsList = (CListBox*)GetDlgItem(IDC_ROTORS);</p>
<p>
    int nRotor = pRotorsList-&gt;GetItemData(pRotorsList-&gt;GetCurSel());</p>
<p>
    m_pRotor-&gt;SelectRotor(nRotor);</p>
<p>
    GetDocument()-&gt;SetModifiedFlag();</p>
<p>
    GetDocument()-&gt;UpdateAllViews(NULL);</p>
<p>
}</p>
<p>
SelectRotor Method of CRotor</p>
<p>
void CRotor::SelectRotor(int nIndex)</p>
<p>
{</p>
<p>
    ASSERT(nIndex &gt;= 0 &amp;&amp; nIndex &lt;= NUM_ROTORS);</p>
<p>
    m_nSelectedRotor = nIndex;</p>
<p>
    NotifyObservers(ROTOR_CHANGED,NULL);</p>
<p>
}</p>
<p>
SubjectChanged Method of CRotorView</p>
<p>
void CRotorView::SubjectChanged(CSubject* pSubject, </p>
<p>
    LPARAM lHint, void* pHint)</p>
<p>
{</p>
<p>
    ASSERT(pSubject == m_pRotor);</p>
<p>
    switch(lHint)</p>
<p>
    {</p>
<p>
        case ROTOR_CHANGED:</p>
<p>
            m_bNeedUpdate = TRUE;</p>
<p>
            break;</p>
<p>
        default:</p>
<p>
            ASSERT(FALSE);</p>
<p>
    }</p>
<p>
}</p>
<p>
Destructor for CRotorView</p>
<p>
CRotorView::~CRotorView()</p>
<p>
{</p>
<p>
    m_pRotor-&gt;DetachFromSubject(this);</p>
<p>
    m_pRotor-&gt;Release();</p>
<p>
}</p>
<p>
Now, let’s begin stepping through our Dynamic Object pattern and looking at the implementation of each step. We’ll begin when CView&shy;Broker calls CMultiDocTemplate&shy;Ex::CreateNewFrame resulting with the instantiation of a new CRotorView. All that happens in the constructor for CRotorView is the addition of constraints for the flexible view behavior in the CNSFlexFormView base class (see Figure 18). Note how easy it is to add the resizing behavior. Well-designed, extensible architectures can let you add a lot of functionality by inserting new classes in the inheritance chain.</p>
<p>
Next, CViewBroker will send the WM_OBJECTINFO message with information about the CRotor dynamic object that our view references. Again, the code looks the same <BR>as for Simple.dll (see Figure 18). The key difference this time is that CRotorView uses multiple inheritance to inherit from both CNSFlexFormView and CObserver. Inheriting from CObserver will allow us to be informed about changes to the CRotor dynamic object. After we get hold of the CRotor dynamic object through a call to CObjectInfo::<BR>GetObject, we call CSubject::AttachToSubject to register as an observer.</p>
<p>
If this is the first view being opened on the CRotor dynamic object, the dynamic object will not be in memory, so GetObject will instantiate a new CRotor and then call CRotor::Serialize to bring in the persistent data (see Figure 18). The Serialize function is the one you are familiar with, but recall that the object broker is in the background, silently making the compound file look like a CArchive.</p>
<p>
The last thing CViewBroker does in opening a view on a CRotor is to call CMultiDocTemplate::InitialUpdateFrame. This results in a call to CRotorView::OnInitialUpdate, which results in a call to CRotorView::OnUpdate (see Figure 18). All we do is make sure the rotor selection in the list box is set properly and then call Invalidate to force the selected rotor to be redrawn. The details of drawing the rotor are not important here, but you can check out the source code if you are interested in how it’s done.</p>
<p>
Now we have a CRotor dynamic object and an associated CRotorView. Next, we want to see what happens on a GUI event. There’s a list box on CRotorView that allows the user to select the type of rotor graphic. When the user changes the selection in the list box (see Figure 18), CRotorView::<BR>OnSelchangeRotors gets called by the MFC framework. We follow the pattern exactly. First we call CRotor::SelectRotor (analogous to the ChangeState function name in the pattern) to change the state of our dynamic object. Then we call CDocument::SetModi&shy;fiedFlag and CDocument::<BR>Update&shy;AllViews.</p>
<p>
CRotor::SelectRotor also follows the pattern exactly (see Figure 18). We change a member variable to indicate the current rotor selection, and then broadcast information about the change to registered observers through a call to CSubject::NotifyObservers.</p>
<p>
CRotorView, a registered observer of the CRotor, will receive notification of the rotor change through CObserver::<BR>SubjectChanged (see Figure 18). The pattern says we need to keep track of changes required to our view. For this simple case, it’s just a matter of setting the m_bNeedUpdate flag.</p>
<p>
Recall that CRotorView::OnSelchangeRotors made a call to CDocument::UpdateAllViews. UpdateAllViews generates a call to CRotorView::OnUpdate. We’ve already looked at CRotorView::OnUpdate since it was called as part of CRotorView::OnInitialUpdate. We complete the pattern with the destructor for CRotorView (see Figure 18). Again, we follow the pattern exactly.</p>
<p>
Now is a good time to go and play with the ObjectView code again (see Figure 16). Click the Add button on the Object Broker window to create an instance of a CRotor object. Click the View button to open a CRotorView on the CRotor object. With a CRotorView window activated, click on the Window | New Window command or hit the toolbar button and open another view on the object. Notice how all windows get updated as you change the selected graphic. Resize a CRotorView window and notice how the controls are intelligently repositioned as a result of using the CNSFlexFormView. If you click the Remove button on the Object Broker window while the Rotor window is open, all the Rotor windows close and the dynamic object is permanently removed. Remember, all of this behavior was added without touching the ObjectView application. Also keep in mind that the CRotor objects are silently shuffling between memory and the application’s compound file as required, and persistent object data is getting saved appropriately. The user and developer never notice any of this. In fact, the only thing the user will ever notice is that memory usage is low and saving files is quick—even when working with numerous large objects.</p>
<h2>Interdependencies</h2>
<p>
Our second example DLL, OVRotorDri&shy;ver.dll, demonstrates how to handle object interdependencies—a common source of problems in many applications. We’re going to create a new object that tells the rotor object from the first example to draw itself at timed intervals and specific orientations. In other words, we’re going to spin the rotor. OVRotor&shy;Driver.dll houses a dynamic object class called CRotorDriver, an associated view class called CRotorDriver&shy;View, and a popup dialog called CProp&shy;ertiesDlg (see Figures 19 and 20). CRotorDriver knows how to reference a CGenericRotor and make it spin on a thread of execution. The references to CGenericRotor and several other parameters are persistent data.</p>
<p>
<img src="dynam19.gif" border=0></p>
<p>
Figure 19  ObjectView Hosting a CRotor Driver Dynamic Object</p>
<p>
<img src="dynam20.gif" border=0></p>
<p>
Figure 20  CRotorDriver and CRotorDriverView</p>
<p>
Again, the Dynamic Object pattern makes handling object interdependencies simple and mechanical. CRotorDriver and CRotorDriverView are very similar to CRotor and CRotorView from our first example. The added twist is the reference to CGenericRotor, which makes a CRotorDriver dependent on an instance of a CGenericRotor.</p>
<p>
Recall that CObjectInfo::GetObject generates a call to CDynamicObject::Serialize to load persistent data into the object. The interesting thing to note about CRotor&shy;Driver::Serialize is the ser&shy;ialization of m_csRotorKey, the key for the referenced CGenericRotor object (see <BR>Figure 21).</p>
<p>
Figure 21  OVRotorDriver.dll</p>
<p>
Serialize Method of CRotorDriver</p>
<p>
void CRotorDriver::Serialize(CArchive&amp; archive)</p>
<p>
{</p>
<p>
    if (archive.IsStoring())</p>
<p>
    {</p>
<p>
        archive &lt;&lt; m_bRotorIsGoing;</p>
<p>
        archive &lt;&lt; m_nRotationIncrement;</p>
<p>
        archive &lt;&lt; m_nUpdateInterval;</p>
<p>
        archive &lt;&lt; m_nRotorPosition;</p>
<p>
        archive &lt;&lt; m_bRotateClockwise;</p>
<p>
        archive &lt;&lt; m_csRotorKey;</p>
<p>
    }</p>
<p>
    else</p>
<p>
    {</p>
<p>
        archive &gt;&gt; m_bRotorIsGoing;</p>
<p>
        archive &gt;&gt; m_nRotationIncrement;</p>
<p>
        archive &gt;&gt; m_nUpdateInterval;</p>
<p>
        archive &gt;&gt; m_nRotorPosition;</p>
<p>
        archive &gt;&gt; m_bRotateClockwise;</p>
<p>
        archive &gt;&gt; m_csRotorKey;</p>
<p>
    }</p>
<p>
}</p>
<p>
OnSerializedObjectFromArchive Method of CRotorDriver</p>
<p>
void CRotorDriver::OnSerializedObjectFromArchive()</p>
<p>
{</p>
<p>
    AttachToObjectBroker();</p>
<p>
    AttachToRotor();</p>
<p>
    m_pTriggerThreadInfo-&gt;m_nUpdateInterval = m_nUpdateInterval;</p>
<p>
    m_pTriggerThread =</p>
<p>
    AfxBeginThread(TriggerThreadProc,m_pTriggerThreadInfo);</p>
<p>
    ASSERT(m_pTriggerThread);</p>
<p>
    if (m_bRotorIsGoing)</p>
<p>
        SetEvent(m_pTriggerThreadInfo-&gt;m_hEventStartInterval);</p>
<p>
}</p>
<p>
AttachToObjectBroker Method of CRotorDriver</p>
<p>
void CRotorDriver::AttachToObjectBroker()</p>
<p>
{</p>
<p>
    GetObjectBroker()-&gt;AttachToSubject(this);</p>
<p>
}</p>
<p>
AttachToRotor Method of CRotorDriver</p>
<p>
void CRotorDriver::AttachToRotor()</p>
<p>
{</p>
<p>
    DetachFromRotor();</p>
<p>
    CObjectInfo* pObjectInfo = </p>
<p>
        GetObjectBroker()-&gt;GetObjectInfoByKey(m_csRotorKey);</p>
<p>
    if (pObjectInfo)</p>
<p>
    {</p>
<p>
        m_pRotor = (CGenericRotor*)pObjectInfo-&gt;GetObject();</p>
<p>
        m_pRotor-&gt;AttachToSubject(this);</p>
<p>
    }</p>
<p>
    else</p>
<p>
    {</p>
<p>
        m_csRotorKey.Empty();</p>
<p>
    }</p>
<p>
}</p>
<p>
DetachFromRotor Method of CRotorDriver</p>
<p>
void CRotorDriver::DetachFromRotor()</p>
<p>
{</p>
<p>
    if (m_pRotor)</p>
<p>
    {</p>
<p>
        m_pRotor-&gt;DetachFromSubject(this);</p>
<p>
        m_pRotor-&gt;Release();</p>
<p>
        m_pRotor = NULL;</p>
<p>
    }</p>
<p>
}</p>
<p>
SubjectChanged Method of CRotorDriver</p>
<p>
void CRotorDriver::SubjectChanged(CSubject* pSubject, </p>
<p>
                                  LPARAM lHint, void* pHint)</p>
<p>
{</p>
<p>
    if (pSubject == m_pRotor)</p>
<p>
    {</p>
<p>
        switch(lHint)</p>
<p>
        {</p>
<p>
            case ROTOR_CHANGED:</p>
<p>
                NotifyObservers(ROTOR_DRIVER_ROTOR_CHANGED,NULL);</p>
<p>
                return;</p>
<p>
        }</p>
<p>
        ASSERT(FALSE);</p>
<p>
    }</p>
<p>
    if (pSubject == GetObjectBroker())</p>
<p>
    {</p>
<p>
        switch(lHint)</p>
<p>
        {</p>
<p>
            case OBJECT_BROKER_ABOUT_TO_REMOVE_OBJECT:</p>
<p>
                if (m_csRotorKey == *((CString*)pHint))</p>
<p>
                    SetRotorKey(&quot;&quot;);</p>
<p>
                return;</p>
<p>
            </p>
<p>
            case OBJECT_BROKER_ADDED_OBJECT:</p>
<p>
            case OBJECT_BROKER_REMOVED_OBJECT:</p>
<p>
            case OBJECT_BROKER_RENAMED_OBJECT:</p>
<p>
                return;</p>
<p>
        }</p>
<p>
        ASSERT(FALSE);</p>
<p>
    }</p>
<p>
    ASSERT(FALSE);</p>
<p>
}</p>
<p>
SetRotorKey Method of CRotorDriver</p>
<p>
void CRotorDriver::SetRotorKey(LPCSTR pszRotorKey)</p>
<p>
{</p>
<p>
    m_csRotorKey = pszRotorKey;</p>
<p>
    AttachToRotor();</p>
<p>
    NotifyObservers(ROTOR_DRIVER_SELECTED_ROTOR_CHANGED,NULL);</p>
<p>
}</p>
<p>
Destructor for CRotorDriver</p>
<p>
CRotorDriver::~CRotorDriver()</p>
<p>
{</p>
<p>
    DWORD dwExitCode;</p>
<p>
    if (GetExitCodeThread(m_pTriggerThread-&gt;m_hThread, &amp;dwExitCode) &amp;&amp;</p>
<p>
        dwExitCode == STILL_ACTIVE)</p>
<p>
    {</p>
<p>
        SetEvent(m_pTriggerThreadInfo-&gt;m_hEventKillTriggerThread);</p>
<p>
        SetEvent(m_pTriggerThreadInfo-&gt;m_hEventStartInterval);</p>
<p>
        WaitForSingleObject(</p>
<p>
            m_pTriggerThreadInfo-&gt;m_hEventTriggerThreadKilled,</p>
<p>
            INFINITE);</p>
<p>
    }</p>
<p>
    delete m_pTriggerThreadInfo-&gt;m_pThreadMessageWnd;</p>
<p>
    delete m_pTriggerThreadInfo;</p>
<p>
    DetachFromRotor();</p>
<p>
    DetachFromObjectBroker();</p>
<p>
}</p>
<p>
DetachFromObjectBroker Method of CRotorDriver</p>
<p>
void CRotorDriver::DetachFromObjectBroker()</p>
<p>
{</p>
<p>
    GetObjectBroker()-&gt;DetachFromSubject(this);</p>
<p>
}</p>
<p>
After calling CDyna&shy;mic&shy;Object::Serialize,&nbsp;COb&shy;ject&shy;Info::Get&shy;&shy;Object&nbsp;calls<BR>CDyna&shy;mic&shy;Object::OnSerial&shy;ized&shy;Object&shy;From&shy;Archive, which is overridden in CRo&shy;torDriver (see Figure 21). Note that CRotorDriver::On&shy;SerializedObject&shy;From&shy;Archive makes calls to CRotorDriver::<BR>Attach&shy;To&shy;ObjectBroker and CRotorDriver::Attach&shy;ToRotor. This is also where we launch a new thread of execution to make the rotor spin. We decided to throw threads into the example just for fun. Threads are not important to the main ideas here, so we won’t dive into that subject. But you can look at the code that accompanies the article if you are interested in seeing the details.</p>
<p>
CRotorDriver::Attach&shy;To&shy;ObjectBroker simply calls CSubject::AttachToSubject to register as an observer of CObjectBroker (see Figure 21). CRotorDriver::AttachToRotor does the real work of turning m_csRotorKey, the key to the referenced object, into m_pRo&shy;tor, a pointer to a living, breathing CGenericRotor object (see Figure 21). First, AttachToRotor calls CRotor&shy;Driver::DetachFromRotor to make sure we unregister as an observer of CGenericRotor and release any CGeneric&shy;Rotor object to which we may have already been attached. We call CObjectBroker::<BR>GetObjectInfoByKey to get the&nbsp;CObjectInfo&nbsp;associated with m_csRotorKey, and then call CObjectInfo::&shy;GetObject to get a pointer to the CGen&shy;eric&shy;Rotor object. Finally, we call CSubject::AttachToSub&shy;ject to register as an observer of the CGenericRotor object. It’s really that simple to handle each object interdependency. It doesn’t matter how numerous or complicated they get. Just be careful and do each one the same way.</p>
<p>
CRotorDriver::SubjectChanged is also a little more interesting than before (see Figure 21). One of the nice things about the implementation of SubjectChanged is that it passes us a pointer to the CSubject that has changed. CRotorDriver is watching two subjects: the CGenericRotor object and the CObjectBroker object. Since we’re holding a reference to another object, we need to know if a higher authority—the user—wants it deleted. If so, we have to release our reference. We check to see if pSubject is the CObjectBroker; if it is, we check for the OBJECT_BROKER_<BR>ABOUT_TO_REMOVE_OBJECT hint and call CRotor&shy;Driver::SetRotor&shy;Key with a null string. CRotorDriver::<BR>Set&shy;RotorKey sets the value of m_csRotorKey, calls CRotor&shy;Driver::AttachToRotor, and notifies any of its observers through a call to CSubject::NotifyObservers (see Figure 21).</p>
<p>
In the destructor for CRotorDriver, we need to detach from the CGenericRotor object and CObjectBroker object. This is accomplished through calls to CRotorDriver::<BR>DetachFromRotor and CRotorDriver::DetachFrom&shy;Object&shy;Broker (see Figure 21).</p>
<p>
Run ObjectView again (see Figure 19). Click the Add button on the Object Broker window to create a rotor. Click the Add button again to create a rotor driver. Click the View button to open a view on the rotor driver. Now click the Properties button on the rotor driver and select the rotor from the dropdown list. Finally, hit the Start button and you will see it spinning. To change the appearance of the spinning rotor, open a view on the rotor and select a different rotor type. The Dynamic Object pattern makes everything work. Changes to rotors are smoothly propagated to rotor driversæand the main application never had to know anything about either one.</p>
<h2>Interchangeable Classes</h2>
<p>
Our last example DLL, OVUserRotor.dll, demonstrates the useful concept of interchangeable classes. Interchangeable classes are a very extensible way to provide hooks for customizing applications at runtime. OVUserRotor.dll houses a dynamic object class called CUserRotor that can be used interchangeably with the CRotor class introduced in the first example (see Figure 22).</p>
<p>
<img src="dynam22.gif" border=0></p>
<p>
Figure 22  CRotorDriver Referencing CUserRotor</p>
<p>
Let’s drop back to the OVRotor.dll example for a moment. CGenericRotor, a base class for CRotor, contains a single virtual function called DrawRotoræa hook for an interchangeable class. The popup dialog in the OVRotorDriver.dll example, CPropertiesDlg, includes a list of CGenericRotor objects. The list gets loaded by enumerating all the objects contained in the CObjectBroker object and loading only those objects that belong to the class category for CGeneric&shy;Rotor&nbsp;objects (see Figure 23). The CUserRotor dynamic object class in our new DLL is interchangeable with a CRotor class because it inherits from CGenericRotor and its class category matches the CGenericRotor class category.</p>
<p>
Figure 23  OVUserRotor.dll</p>
<p>
OnInitDialog Method of CPropertiesDlg</p>
<p>
BOOL CPropertiesDlg::OnInitDialog() </p>
<p>
{</p>
<p>
    // ROTOR CLASS CATEGORY: {A8D09C01-90C4-11d0-A264-0040052E01FC}</p>
<p>
    CLSID clsidRotorClassCategory = { 0xa8d09c01, 0x90c4, 0x11d0, </p>
<p>
        { 0xa2, 0x64, 0x0, 0x40, 0x5, 0x2e, 0x1, 0xfc } };</p>
<p>
    CComboBox* pRotors = (CComboBox*)GetDlgItem(IDC_ROTORS);</p>
<p>
    </p>
<p>
    CObjectBroker* pObjectBroker = m_pRotorDriver-&gt;GetObjectBroker();</p>
<p>
    for (POSITION pos = pObjectBroker-&gt;GetStartPosition(); pos; )</p>
<p>
    {</p>
<p>
        CString csKey;</p>
<p>
        CObjectInfo* pObjectInfo;</p>
<p>
        pObjectBroker-&gt;GetNextAssoc(pos,csKey,pObjectInfo);</p>
<p>
        CClassInfo* pClassInfo = CClassBroker::GetClassInfo(</p>
<p>
            pObjectInfo-&gt;GetClassID());</p>
<p>
        if (pClassInfo-&gt;GetClassCategory() == clsidRotorClassCategory)</p>
<p>
        {</p>
<p>
            int nIndex = pRotors-&gt;AddString(pObjectInfo-&gt;GetName());</p>
<p>
            pRotors-&gt;SetItemDataPtr(nIndex,pObjectInfo);</p>
<p>
            if (m_pRotorDriver-&gt;GetRotorKey() == pObjectInfo-&gt;GetKey())</p>
<p>
            {</p>
<p>
                pRotors-&gt;SetCurSel(nIndex);</p>
<p>
                m_csRotorKey = pObjectInfo-&gt;GetKey();</p>
<p>
            }</p>
<p>
        }</p>
<p>
    }</p>
<p>
    pRotors-&gt;InsertString(0,&quot;&lt;None&gt;&quot;);</p>
<p>
    if (pRotors-&gt;GetCurSel() == CB_ERR)</p>
<p>
        pRotors-&gt;SetCurSel(0);</p>
<p>
    CDialog::OnInitDialog();</p>
<p>
    </p>
<p>
    return TRUE;  // return TRUE unless you set the focus to a control</p>
<p>
                  // EXCEPTION: OCX Property Pages should return FALSE</p>
<p>
}</p>
<p>
ClassInfo Function Exported from OVUserRotor.dll</p>
<p>
extern &quot;C&quot; void WINAPI ClassInfo(CLSID&amp; clsidClassID, </p>
<p>
                     CLSID&amp; clsidClassCategory, CString&amp; csDescription,</p>
<p>
                     CRuntimeClass*&amp; pObjectClass, CRuntimeClass*&amp; pFrameClass,</p>
<p>
    CRuntimeClass*&amp; pViewClass)</p>
<p>
{</p>
<p>
    // ID: {08EA0501-90EF-11d0-A264-0040052E01FC}</p>
<p>
    CLSID clsidID = { 0x8ea0501, 0x90ef, 0x11d0, </p>
<p>
        { 0xa2, 0x64, 0x0, 0x40, 0x5, 0x2e, 0x1, 0xfc } };</p>
<p>
    // CATEGORY: {A8D09C01-90C4-11d0-A264-0040052E01FC}</p>
<p>
    CLSID clsidCategory = { 0xa8d09c01, 0x90c4, 0x11d0, </p>
<p>
        { 0xa2, 0x64, 0x0, 0x40, 0x5, 0x2e, 0x1, 0xfc } };</p>
<p>
    clsidClassID = clsidID;</p>
<p>
    clsidClassCategory = clsidCategory;</p>
<p>
    csDescription = &quot;User Rotor&quot;;</p>
<p>
    pObjectClass = RUNTIME_CLASS(CUserRotor);</p>
<p>
    pFrameClass = RUNTIME_CLASS(CFlexibleChildFrame);</p>
<p>
    pViewClass = RUNTIME_CLASS(CUserRotorView);</p>
<p>
}</p>
<p>
Generic dynamic object base classes provide hooks for interchanging classes at runtime. Users can create runtime classes to do virtually anything as long as they abide by whatever contracts you set up in the form of virtual functions in your base class. The new classes can have their own views or dialogs, can use the services of other objects in your application, and can serialize their data in the application’s compound file.</p>
<h2>What About COM, ActiveX, and OLE?</h2>
<p>
Some of the design concepts we presented resemble COM, ActiveX, and OLE techniques. However, there are two things that separate our approach from other alternatives: the ability to add dynamic objects at runtime that can use the services of other objects living in the application, whether they are COM objects or C++ objects; and the ability to add dynamic views at runtime that are indistinguishable from other views in the application, from either a user or programming perspective.</p>
<p>
COM objects like to communicate with other COM objects. A COM object added at runtime will have a tough time using the services of a C++ object living in the application. Dynamic objects allow that to happen. An interesting idea might be to wrap COM objects inside dynamic objects to get the best of both worlds.</p>
<p>
ActiveX controls and OLE compound documents with in-place activation allow objects to interact with users, but the mechanism is quite different from a normal MFC CView. This may or may not make sense for your application. Dynamic object views allow interaction with the user without imposing any new user interface constraints and without a lot of additional code.</p>
<h2>Conclusion</h2>
<p>
Good architectures break your code neatly into hierarchical layers that manage interdependence seamlesslyæan important consideration for large projects with multiple development teams. You’ve seen that pushing our concepts to the limit can produce code that lets you compile and link your base application without ever including header files or libraries for any dynamic objects your application will host at runtime.</p>
<p>
The concept of dynamic runtime objects and interchangeable classes can reap huge benefits for applications that need to support user extensions. Consider, for example, an economic forecasting application. A user could code a DLL for her own economic model and drop it in at runtime. There are unlimited possibilities for scientific and engineering applications where users want to twiddle with everything.</p>
<p>
The code we’re providing is just an example of how you can implement the ideas that we have introduced in this article. The various components we’ve presented can be customized, used alone, or used collectively. The CSubject and CObserver classes can be used by themselves to solve many types of object update problems. The CClassBroker and CObjectBroker can be used by themselves to reduce memory requirements and handle serializing object references. The CViewBroker class can be used as is or modified to fit into your application. And remember that, although we are letting the CClassBroker scan for runtime DLLs, you may choose to load classes into the CClassBroker manually. Mix and match our components to meet your own needs. You can download all of the code for ObjectView and the example runtime DLLs from <i>MSJ</i>’s Web site at http://www.microsoft.com/msj.                                                     u</p>
<p>
To obtain complete source code listings, see page 5.</p>
</font></font></body>
</HTML>
