<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Ingenious Ways to Implement Multiple Threads in Visual Basic 5.0, Part I</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF>

<font face="verdana,arial,helvetica" size="2">
<h1>Ingenious Ways to Implement Multiple Threads in Visual Basic 5.0, Part I</h1>
<p>John Robbins</p>
<p>John Robbins is a software engineer at Numega Technologies, Inc. who specializes in debuggers. He can be reached at john@jprobbins.com.</p>
<p>
Visual Basic&reg; 5.0 brought with it a slew of new features and capabilities. One feature really stands out and moves Visual Basic into the big leagues of software development: the AddressOf operator. With Visual Basic 5.0 and AddressOf, you can pass pointers to functions—callbacks in the Win32&reg; vernacular—to APIs that were off-limits to previous versions. Developers using Visual Basic 5.0 can apply the en&shy;tire Win32 API to their advantage. I don’t know about you, but when I saw that Visual Basic could handle callbacks, I immediately wondered if real multithreading was possible. After all, a callback is the same thing that gets passed <BR>to the lpStartAddress parameter of CreateThread—and <BR>a callback is a callback no matter what language you are developing in. I figured the possibility was worth exploring. </p>
<p>
As it turns out, the news is good. You can multithread <BR>all you want! Building a multithreaded application with Visual Basic 5.0 is pretty straightforward, but there are <BR>a few issues that can trip you up. Visual Basic Books Online does a pretty good job of describing the new support <BR>for windows subclassing and enumeration callbacks, but that is where the callback discussion stops. In this article, I will start out with simple samples that are easy to understand and build up to a multithreaded application that you might not expect to see written completely in Visual Basic: a Win32 debugger! When I mentioned earlier that Visual Basic lets you take full advantage of the Win32 API, I wasn’t kidding. You’ll also find that all of the code works on both Intel and DEC Alpha CPUs, including the de&shy;bugger code. </p>
<h2>What is AddressOf?</h2>
<p>
As the name implies, AddressOf is used to return the address of a Visual Basic procedure. The intent of this unary operator is to pass&nbsp;the address of a Visual Basic pro&shy;cedure&nbsp;to&nbsp;an&nbsp;API&nbsp;call out of a DLL such as Enum&shy;Windows. AddressOf has a couple of restrictions.&nbsp;Visual&nbsp;Basic&nbsp;won’t let you take the address returned by Address&shy;Of and call through it as you could with a pointer to a function in C. In addition, AddressOf can only be used in the arguments list for a function and cannot be used to just assign a variable. However, AddressOf is very powerful and relatively simple to use.</p>
<p>
I&nbsp;wrote a simple program, EnumWnds, that demonstrates AddressOf. EnumWnds enumerates all the top-level windows using the API function EnumWindows with a callback function. When the Enumerate Windows button is pressed, the EnumWindows API function is called with the callback function WndEnumProc, and the listbox control is passed for the application-defined data. If the window has a title, EnumWynds inserts the title into the main form’s listbox. Figure 1 lists the form code and code module that holds the callback function.</p>
<p>
Dim bRet As Long</p>
<p>
bRet = EnumWindows(AddressOf WndEnumProc, lstOutput)</p>
<p>
Figure 1  EnumWnds</p>
<p>
FrmMain.frm</p>
<p>
VERSION 5.00</p>
<p>
Begin VB.Form frmMain </p>
<p>
   BorderStyle     =   1  'Fixed Single</p>
<p>
   Caption         =   &quot;AddressOf Example - Enumerate Windows&quot;</p>
<p>
   ClientHeight    =   4695</p>
<p>
   ClientLeft      =   45</p>
<p>
   ClientTop       =   330</p>
<p>
   ClientWidth     =   5160</p>
<p>
   LinkTopic       =   &quot;Form1&quot;</p>
<p>
   MaxButton       =   0   'False</p>
<p>
   ScaleHeight     =   4695</p>
<p>
   ScaleWidth      =   5160</p>
<p>
   StartUpPosition =   2  'CenterScreen</p>
<p>
   Begin VB.CommandButton btnEnd </p>
<p>
      Caption         =   &quot;E&amp;nd&quot;</p>
<p>
      Height          =   495</p>
<p>
      Left            =   2640</p>
<p>
      TabIndex        =   2</p>
<p>
      Top             =   3960</p>
<p>
      Width           =   2295</p>
<p>
   End</p>
<p>
   Begin VB.CommandButton btnEnumThem </p>
<p>
      Caption         =   &quot;&amp;Enumerate Windows&quot;</p>
<p>
      Height          =   495</p>
<p>
      Left            =   120</p>
<p>
      TabIndex        =   1</p>
<p>
      Top             =   3960</p>
<p>
      Width           =   2415</p>
<p>
   End</p>
<p>
   Begin VB.ListBox lstOutput </p>
<p>
      BeginProperty Font </p>
<p>
         Name            =   &quot;Courier New&quot;</p>
<p>
         Size            =   9.75</p>
<p>
         Charset         =   0</p>
<p>
         Weight          =   400</p>
<p>
         Underline       =   0   'False</p>
<p>
         Italic          =   0   'False</p>
<p>
         Strikethrough   =   0   'False</p>
<p>
      EndProperty</p>
<p>
      Height          =   3420</p>
<p>
      Left            =   120</p>
<p>
      TabIndex        =   0</p>
<p>
      Top             =   120</p>
<p>
      Width           =   4815</p>
<p>
   End</p>
<p>
End</p>
<p>
Attribute VB_Name = &quot;frmMain&quot;</p>
<p>
Attribute VB_GlobalNameSpace = False</p>
<p>
Attribute VB_Creatable = False</p>
<p>
Attribute VB_PredeclaredId = True</p>
<p>
Attribute VB_Exposed = False</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' John Robbins, Microsoft Systems Journal - August 1997</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
Option Explicit</p>
<p>
Private Sub btnEnd_Click()</p>
<p>
   End</p>
<p>
End Sub</p>
<p>
Private Sub btnEnumThem_Click()</p>
<p>
   lstOutput.Clear</p>
<p>
   </p>
<p>
   Dim bRet As Long</p>
<p>
   bRet = EnumWindows(AddressOf WndEnumProc, lstOutput)</p>
<p>
      </p>
<p>
End Sub</p>
<p>
EnumWnds.bas</p>
<p>
Attribute VB_Name = &quot;mod_EnumWnds&quot;</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' John Robbins, Microsoft Systems Journal - August 1997</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
Option Explicit</p>
<p>
' Declare the API functions.</p>
<p>
Declare Function EnumWindows Lib &quot;User32&quot; _</p>
<p>
            (ByVal lpEnumFunc As Any, ByVal lParam As Any) As Long</p>
<p>
Declare Function GetWindowText Lib &quot;User32&quot; _</p>
<p>
            Alias &quot;GetWindowTextA&quot; _</p>
<p>
            (ByVal hwnd As Long, _</p>
<p>
             ByVal lpString As String, _</p>
<p>
             ByVal cch As Long) As Long</p>
<p>
Function WndEnumProc(ByVal hwnd As Long, _</p>
<p>
                     ByVal lParam As ListBox) As Long</p>
<p>
   Dim szTitle As String</p>
<p>
   Dim bRet As Long</p>
<p>
   szTitle = String(512, 0)</p>
<p>
   bRet = GetWindowText(hwnd, szTitle, 512)</p>
<p>
   ' Only show those that have titles.</p>
<p>
   If (0 &lt;&gt; bRet) Then</p>
<p>
      lParam.AddItem szTitle</p>
<p>
   End If</p>
<p>
   WndEnumProc = 1</p>
<p>
End Function</p>
<p>
Keep in mind that the procedure after the AddressOf can be either a function or a subroutine. It just depends on what the individual API requires. With EnumWindows, the window enumeration callback routine must continue to return 1 (TRUE in C/C++ terms) to continue to be called. If the callback returns zero (FALSE), then Windows will cease the enumeration.</p>
<p>
The window enumeration callback is relatively simple in this example as well. It calls the Windows&reg; API Get&shy;WindowText to retrieve the text from the passed-in window handle and displays the title if there is one. With the callback functions, it’s a good idea to explicitly declare the ByVal and ByRef declarations so that you keep everything straight. In the EnumWnds example, if you leave off the ByVal declarations on WndEnumProc your program will crash, and will crash the IDE bugger as well because parameters will be treated as pointers instead of values.</p>
<p>
Besides providing callback functions for enumeration APIs, AddressOf can be used to subclass window procedures. Subclassing a window means inserting your own window procedure in place of the original one so you can perform additional processing on the message stream. For example, subclassing is used to intercept the messages passed to an edit control so that the edit control can receive all the keyboard input when the edit control has focus. Microsoft Word subclasses the edit control where the user can type in the return address in the envelope dialog. By trapping the Enter key, the subclassing forces it to break the lines when the user is typing in a return address, just as the user would expect. If the return address edit control in the envelope dialog was not subclassed, the user would have to remember some strange keyboard combination for breaking the lines—as well as almost always dismissing the dialog with the Enter key. </p>
<h2>Multithreading 101</h2>
<p>
Now that you have an understanding of AddressOf, I will begin discussing some of the issues associated with multi&shy;threading. First, let’s take a look at what multithreading cannot do: it cannot make your application instantly faster, it cannot solve bad programming practices, and it cannot cure world hunger. In fact, writing multithreaded applications is extremely difficult and nearly impossible to get right without careful planning and more testing than you ever dreamed of.</p>
<p>
At the same time, when you need multithreading, you really need it. Many times, having a background thread handle an operation can make the difference between a decent application and a great one. And since 85 percent of all Visual Basic-based apps are written to access a database, opportunities to use multithreading are numerous.</p>
<p>
For example, you can use multithreading to save data for printing into a temporary file and then print the file as a background thread. If you are writing a data analysis-intensive front end with huge server-driven SQL queries, you could use multithreading to keep the queries cranking in the background while allowing the user interface to remain responsive. If you are writing a field sales application that runs on a salesperson’s laptop computer and uses RAS to connect to a central database, you could create a thread to run in the background that reserves a place in the queue for a new order. That way, when the salesperson is typing the final sales agreement, she can report to the customer when the order is expected to ship based on the most up-to-date information. Finally, being able to multithread makes it possible to create things like debuggers in Visual Basic. Since writing debuggers is what I do for a living, it gives me a quick prototyping tool that I have never had before.</p>
<p>
There are a few rules to keep in mind when multithreading. First, only multithread if you have chunks of work in your application that can be done at the same time as other work. Second, do not multithread if you will end up disabling the entire user interface because it’s waiting on the background thread. Remember, the point of multithreading is to let the user continue using your application for other things while the background thread is running. Third, you should double, maybe even triple, the expected development and testing time because there will be many subtle timing and synchronization problems. Fourth, run your multithreaded applications on as many machines as possible, including very fast machines and multiprocessor machines. When writing VBDebug, my Win32 debugger example, a nasty synchronization problem showed up only when I ran it on a 400Mhz DEC Alpha, even though I ran it successfully on a 200Mhz Pentium Pro. I also had nasty synchronization problems on a multiprocessor system. Finally, always assume that all the threads are running at exactly the same time—if there is an infinitesimal chance that they will deadlock, they will.</p>
<p>
I can give you some basic guidelines about using multi&shy;threading, but I recommend learning more to really understand how multi&shy;threading works. Perhaps the best place <BR>to start is <i>Advanced Windows, Third Edition</i> by <BR>Jeffrey Richter (Microsoft Press, 1997). It has the most lucid explanation of multi&shy;threading for Win32 I have found. Also, it discusses multi&shy;threading and synchronization at the SDK API level, which is how it has to be used in Visual Basic. Another great resource is the Microsoft Developer Network CD.</p>
<h2>Debugging and Native Code Generation</h2>
<p>
Before I can show you a simple Visual Basic-based program that does multithreading, there are three things that you must know about developing these types of applications. First, you cannot use the Visual Basic IDE to run or debug your application. If you try to run the programs I wrote for this article inside the IDE, it will crash. The Visual Basic Books Online mentions several times that the IDE cannot debug multithreaded applications, even single-threaded Visual Basic executables that use multithreaded ActiveX™ controls written in C++. To debug your app, you will need to set your projects to generate unoptimized native code and turn on symbolic debug information.</p>
<p>
The fact that the Visual Basic IDE cannot handle multithreaded programs is not a design flaw. Remember, writing a multithreaded Visual Basic-based application that isn’t a simple, non-UI ActiveX control is way beyond what Microsoft designed Visual Basic to do. As long as you can debug these applications once they are compiled to native EXEs, which you can, it’s not really a big deal. Although this should take most of the sting out of not being able to use the Visual Basic debugger, the Visual Basic runtime is, from everything I can tell, pretty much thread-safe. If it wasn’t, then you couldn’t do multithreading at all without crashing every time. </p>
<p>
The second issue that makes Visual Basic native EXE debugging difficult is that there seems to be a bug in the symbol table generation; sometimes the source line numbers do not align with the code being executed. If you can deal with your code being off a line or two in the debugger, this should not be too big a problem.</p>
<p>
The last issue you should be aware of is that the sym-<BR>bols generated for Visual Basic native executables are not always very descriptive. For the most part, there are no symbols for global variables, though most, but not all, of the local variables have proper symbols. To see the values of globals and those locals without symbols, I generally sprinkle calls to Output&shy;DebugString liberally around the application. Keep in mind that the new Visual Basic 5.0 Debug object does not get compiled into your native applications, so you have to use conditional compilation for asserts and prints. Also, there are many temporary variables generated in Visual Basic code and they all get the same name: unnamed_var1. You can pretty much figure out which one applies to what section of the code by watching them change as you step through in the debugger.</p>
<h2>Let’s Start Simple</h2>
<p>
Now that you know what to watch out for when developing and debugging native code in Visual Basic, I can show you some multi&shy;threaded code. Figure 2 lists the code for MT.EXE, which is about as simple a Visual Basic-based program as you will find. It is simply a Sub Main that creates two threads that each show a message box (see Figure 3). Despite its simplicity, this sample demonstrates many of the issues associated with multithreading in Visual Basic.</p>
<dl>
<dt>
Figure 2  MT.bas</dt>
<dd>
Attribute VB_Name = &quot;MultiThreaded_Main&quot;<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' John Robbins, Microsoft Systems Journal - August 1997</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' ** NOTE ** NOTE ** NOTE ** NOTE ** NOTE ** NOTE ** NOTE ** NOTE **</p>
<p>
' NEVER RUN THIS PROGRAM IN THE VB IDE!</p>
<p>
' ** NOTE ** NOTE ** NOTE ** NOTE ** NOTE ** NOTE ** NOTE ** NOTE **</p>
<p>
Option Explicit</p>
<p>
' Note:  This declaration of CreateThread does not allow you to pass</p>
<p>
'  thread attributes.  This is the CreateThread that should be used most</p>
<p>
'  often because the parameter for the thread function is passed by</p>
<p>
'  reference.</p>
<p>
Public Declare Function CreateThread Lib &quot;kernel32&quot; _</p>
<p>
         (ByVal lpThreadAttributes As Long, _</p>
<p>
          ByVal dwStackSize As Long, _</p>
<p>
          ByVal lpStartAddress As Any, _</p>
<p>
          ByRef lpParameter As Any, _</p>
<p>
          ByVal dwCreationFlags As Long, _</p>
<p>
          ByRef lpThreadId As Long) As Long</p>
<p>
' If you only are passing a single variable type like an integer or</p>
<p>
'  string as the thread parameter, use this version of CreateThread.</p>
<p>
' Note that I set the lpParameter type to long.</p>
<p>
Public Declare Function CreateThread_ByValParam Lib &quot;kernel32&quot; _</p>
<p>
         Alias &quot;CreateThread&quot; _</p>
<p>
         (ByVal lpThreadAttributes As Long, _</p>
<p>
          ByVal dwStackSize As Long, _</p>
<p>
          ByVal lpStartAddress As Any, _</p>
<p>
          ByVal lpParameter As Long, _</p>
<p>
          ByVal dwCreationFlags As Long, _</p>
<p>
          ByRef lpThreadId As Long) As Long</p>
<p>
' So you can determine which thread the code is executing in.</p>
<p>
Public Declare Function GetCurrentThreadId Lib &quot;kernel32&quot; () As Long</p>
<p>
' This is the type that is passed to DaThreadFunc so you can do the by</p>
<p>
'  reference demonstration.</p>
<p>
Type PARAM_TYPE</p>
<p>
   lValue As Long</p>
<p>
End Type</p>
<p>
' The function used to show a pass by reference.</p>
<p>
Function DaThreadFunc(ByRef lpParam As PARAM_TYPE) As Long</p>
<p>
   Dim szStr As String</p>
<p>
   szStr = &quot;From DaThreadFunc - Parameter = &quot; &amp; _</p>
<p>
           CStr(lpParam.lValue) &amp; vbNewLine &amp; _</p>
<p>
           &quot;Thread ID: &quot; &amp; CStr(GetCurrentThreadId)</p>
<p>
   MsgBox szStr, , &quot;Function Cool!&quot;</p>
<p>
   ' Just to make the return value different, I return -2.</p>
<p>
   DaThreadFunc = -2</p>
<p>
End Function</p>
<p>
' The subroutine to show pass by value.</p>
<p>
' By the way, I noticed that subs always return 0.</p>
<p>
Sub DaThreadSub(ByVal lpVoid As Long)</p>
<p>
   Dim szStr As String</p>
<p>
   szStr = &quot;From DaThreadSub - Parameter = &quot; &amp; _</p>
<p>
           CStr(lpVoid) &amp; vbNewLine &amp; _</p>
<p>
           &quot;Thread ID: &quot; &amp; CStr(GetCurrentThreadId)</p>
<p>
   MsgBox szStr, , &quot;Sub Cool!&quot;</p>
<p>
End Sub</p>
<p>
Sub Main()</p>
<p>
   Dim lRet As Long</p>
<p>
   Dim lThreadID As Long</p>
<p>
   Dim stParam As PARAM_TYPE</p>
<p>
   Dim szStr As String</p>
<p>
   lThreadID = 0</p>
<p>
   ' Do the call to CreateThread with a by reference parameter.</p>
<p>
   stParam.lValue = -1</p>
<p>
   lRet = CreateThread(0, _</p>
<p>
                       0, _</p>
<p>
                       AddressOf DaThreadFunc, _</p>
<p>
                       stParam, _</p>
<p>
                       0, _</p>
<p>
                       lThreadID)</p>
<p>
   ' Do the call to CreateThread with a by value parameter.</p>
<p>
   lRet = CreateThread_ByValParam(0, _</p>
<p>
                                  0, _</p>
<p>
                                  AddressOf DaThreadSub, _</p>
<p>
                                  -2, _</p>
<p>
                                  0, _</p>
<p>
                                  lThreadID)</p>
<p>
   szStr = &quot;From Da Main Thread&quot; &amp; vbNewLine &amp; _</p>
<p>
           &quot;Thread ID: &quot; &amp; CStr(GetCurrentThreadId)</p>
<p>
   MsgBox szStr</p>
<p>
End Sub</p>
</dd>
</dl>
<p>
<img src="threads3.gif" border=0></p>
<p>
Figure 3 Message Boxes</p>
<p>
The best way to see how MT.EXE works is to compile and run it. When you do, you will see the three message boxes pop up that indi&shy;cate which thread the message box came from: two message boxes come from threads created in the code, and the other is the application main thread. To prove that each message box is from a different thread, each message box shows the thread identification for the thread in which it is called. If you really want to make sure that MT.EXE is creating threads, use the SDK program PVIEW.EXE to see what it reports.</p>
<p>
If you run MT.EXE a couple of times and try different shutdown scenarios, you will notice that shutting down the main thread message box first and leaving the other threads running causes all of them to end at once. While this may seem odd, it isn’t when you know that the main thread eventually calls Exit&shy;Process when it is shutting down. ExitProcess automatically kills any outstanding threads that the process still has running. Keep this in mind when developing your multithreaded programs—make sure to end your threads before the main thread exits or you could cause large resource leaks or, worse yet, database locks when TerminateThread is called on your threads.</p>
<p>
In C/C++ development, there is no difference between functions or subroutines since creative casting can turn one thing into something else. However, with the extra-strict declarations of Visual Basic, I originally thought that only true Visual Basic functions could be used because there might be a difference internally between a function and a subroutine. As I discovered in MT.BAS, the AddressOf operator can pass both functions and subroutines to CreateThread or any other API.</p>
<p>
Even though you can pass Visual Basic subroutines <BR>and functions to CreateThread, keep in mind that one of <BR>the main ways to tell that another thread finished properly is to check the thread exit code with GetExitCodeThread. <BR>If you pass a Visual Basic subroutine to CreateThread, <BR>the thread exit code will always be zero. If you pass a Visual Basic function to CreateThread, the return value of <BR>the function will be the exit code of the thread. So, if you need to know the exit code, your thread routine needs to be a function.</p>
<p>
If you look at MT.BAS, you’ll see that I set up two ways of calling CreateThread. When creating the thread for the DaThreadFunc function, I use the straight CreateThread declaration to show how to pass the thread parameter by reference because I am passing a user-defined type to DaThreadFunc. For the most part, you will almost always be passing some sort of user-defined type by reference to the thread function to have it work on unique data. To make passing the thread parameter easy, lpThreadParameter is declared of type Any. As for DaThreadSub, it only needs a value, not a reference, so I used the CreateThread_<BR>By&shy;ValParam declaration of CreateThread. While Visual Basic is extremely type-safe when doing Basic code, it fortunately allows you to coerce the different values to external DLL functions.</p>
<h2>But Wait! There’s More</h2>
<p>
Now that you have seen MT.EXE in action, you are probably salivating at the thought of making your Visual Basic application multithreaded. Before you end up with a 37-thread monster, there are still a few more things that you want to keep in mind when creating multithreaded Visual Basic-based applications. None of these minor issues are showstoppers, but they affect how you will utilize threads and classes in your application’s design.</p>
<p>
The first issue is a limitation of the AddressOf operator. AddressOf will only accept functions and routines that are part of a standard module, or code module. Simply put, your thread function must reside in a BAS file. This is not a big limitation, but it means you cannot have a helper function in a CLS module, for example, be the thread function. While you might want to do this so the thread function can access items in the class, it simply will not work and results in a compilation error.</p>
<p>
As an alternative to having the thread function come out of a class module, you may have thought about using a class method as the threaded function. AddressOf will not allow this either. Since Visual Basic classes are COM objects, they conform to the COM binary standard. This means that the COM object is a pointer to a vtable so the address of a COM method is not valid. The same restrictions apply in C++: COM methods, or C++ methods for that matter, cannot be used as parameters to CreateThread.</p>
<p>
It is perfectly legal to pass user-defined types or a specific type as the thread parameter. You have to be careful passing items as the thread parameter because some items cannot be used. For example, if you try to pass a Label control to a normal Visual Basic routine, you will get a warn&shy;ing at compile time. Since CreateThread uses As Any as the type for lpParameter, if you try passing a Label control, your app compiles but will crash when you run it.</p>
<p>
What if you need to pass a Label control to a thread? Just wrap the Label control in a class—Visual Basic classes work great as the thread parameter. Just keep in mind that you need to define the lpParameter variable to CreateThread as “ByRef lpParameter as Any” so you can pass any type of class into your thread function. If you design your application with care, you can even have an abstract class as the type your thread function takes. This lets you pass in polymorphic classes to do different levels of work. Before you can pass the class into CreateThread, however, you must create the class by using the New keyword. As you will see later, I use this heavily to do some extensible multi&shy;threading. Once the thread function starts, it can then call methods off of the class variable to do whatever you need to do in the thread.</p>
<p>
As&nbsp;well as Visual Basic classes work as the thread para&shy;meter in multithreaded applications, they do not work at all if the class is declared WithEvents, one of the cool, new Visual Basic 5.0 features. While you cannot use events in your classes, you can use a workaround to get the same effect. I will show you how later.</p>
<p>
In normal Visual Basic 5.0-based applications, you can implement components such as business rules with classes so that the user of the class can provide the user interface instead of having the component drag it around. Events make this possible by allowing the item that instantiates the class to declare it with the WithEvents keyword and by handling the various events inside the module that declares the class. If this is done in a form, then the form can provide the event handlers for the class and display the class’s&nbsp;data.&nbsp;The&nbsp;Visual&nbsp;Basic&nbsp;Books&nbsp;Online&nbsp;has&nbsp;an&nbsp;excellent example of this where the class has a PercentDone event that it calls when the class is doing a lengthy operation.</p>
<p>
Unfortunately, because the Visual Basic class that is declared through WithEvents does not seem to be a true COM object, you cannot pass a WithEvents-declared class as a thread parameter. I originally questioned the COM-ness of a WithEvents-declared class because there is no way to do events in straight C++ OLE development—and it did not&nbsp;work&nbsp;when&nbsp;I&nbsp;tested&nbsp;it.&nbsp;EVENTPROBLEM.EXE,&nbsp;included with the source code for this article, shows what happens when a WithEvents-declared class is called from a thread. (See page 5 for details on downloading the source code.)</p>
<p>
In EVENTPROBLEM.EXE, the WithEvents-declared class is TheClass. When the CallMeFromTheThread method is called, it displays a message box indicating that it was called and then calls RaiseEvent on the DoTheEvent event. In the main form, there are two different instances of this class declared: g_ClassWithEvents has events and g_Class&shy;NoWith does not. When the Declared WITHOUT EVENTS! button is pressed on the form, a thread is created with the function TheThread, and the thread just calls CallMeFrom&shy;TheThread on the class. Since the g_ClassNoWith variable is not declared as WithEvents, the message box in the class shows up but no event can be called. When the Declared With Events button is pressed, the g_ClassWithEvents variable is passed to another thread. When that thread tries to access the thread parameter, there is a runtime error that reports “Object variable or With block variable not set,” and no functions can be called on the class that raises events.</p>
<p>
To try getting the WithEvents-declared class in EVENT&shy;PROBLEM.EXE to work, I created a global variable of the same type and then did a Set operation to take care of <BR>the assignment of the thread parameter. I discovered, however, that Visual Basic won’t let you declare an object variable WithEvents in a standard module, even as a local variable. Just accessing the thread parameter that has a WithEvents-declared class variable in it causes an exception to be thrown. WithEvents and multithreading do not mix, so you lose one of the best benefits of the new Visual Basic capabilities.</p>
<p>
Fortunately, although not as elegant as class events, there is still a way to isolate the output for the class that is passed as the thread parameter. The idea is similar to that of events: when the class needs to show some output, it needs to tell something else to handle the output. Obviously, this something else should be capable of outputting information in many different ways.</p>
<p>
The idea is to have an abstract class as a public member of the class. This class is what you would normally handle with events. For the most part, this is where you would handle the entire user interface, and the class, instead of raising an event, would call through the abstract base class for all of its output. Classes using this abstract output class can be passed safely to CreateThread as the thread parameter. This is an acceptable solution, but you must carefully define the abstract output class so that it will meet the future needs of the main thread parameter class, just like you would have to do when designing and using events. Figure 4 shows the code for EVENTSOLN.EXE, which illustrates the implementation of an output class and its use to show the output.</p>
<p>
Figure 4  Event Solution Sample</p>
<p>
frmMain.frm</p>
<p>
VERSION 5.00</p>
<p>
Begin VB.Form fmrMain </p>
<p>
   Caption         =   &quot;Form1&quot;</p>
<p>
   ClientHeight    =   1740</p>
<p>
   ClientLeft      =   60</p>
<p>
   ClientTop       =   345</p>
<p>
   ClientWidth     =   4680</p>
<p>
   LinkTopic       =   &quot;Form1&quot;</p>
<p>
   ScaleHeight     =   1740</p>
<p>
   ScaleWidth      =   4680</p>
<p>
   StartUpPosition =   3  'Windows Default</p>
<p>
   Begin VB.CommandButton btnNoWith </p>
<p>
      Caption         =   &quot;Using the output class to fake events!&quot;</p>
<p>
      Height          =   855</p>
<p>
      Left            =   600</p>
<p>
      TabIndex        =   0</p>
<p>
      Top             =   360</p>
<p>
      Width           =   3375</p>
<p>
   End</p>
<p>
End</p>
<p>
Attribute VB_Name = &quot;fmrMain&quot;</p>
<p>
Attribute VB_GlobalNameSpace = False</p>
<p>
Attribute VB_Creatable = False</p>
<p>
Attribute VB_PredeclaredId = True</p>
<p>
Attribute VB_Exposed = False</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' John Robbins</p>
<p>
' Microsoft Systems Journal - August, 1997</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
Option Explicit</p>
<p>
Private g_ClassNoWith As TheClass</p>
<p>
Private g_Output As OutputClass</p>
<p>
Private Sub Form_Load()</p>
<p>
   Set g_ClassNoWith = New TheClass</p>
<p>
   Set g_Output = New OutputClass</p>
<p>
   ' Set the output class property of the &quot;NoWith&quot; class.</p>
<p>
   Set g_ClassNoWith.clsOutput = g_Output</p>
<p>
End Sub</p>
<p>
Private Sub btnNoWith_Click()</p>
<p>
   Dim hThread As Long</p>
<p>
   Dim lThreadID As Long</p>
<p>
   ' Create the thread.</p>
<p>
   hThread = CreateThread(0, _</p>
<p>
                          0, _</p>
<p>
                          AddressOf TheThread, _</p>
<p>
                          g_ClassNoWith, _</p>
<p>
                          0, _</p>
<p>
                          lThreadID)</p>
<p>
End Sub</p>
<p>
OutputClass.cls</p>
<p>
VERSION 1.0 CLASS</p>
<p>
BEGIN</p>
<p>
  MultiUse = -1  'True</p>
<p>
END</p>
<p>
Attribute VB_Name = &quot;OutputClass&quot;</p>
<p>
Attribute VB_GlobalNameSpace = False</p>
<p>
Attribute VB_Creatable = True</p>
<p>
Attribute VB_PredeclaredId = False</p>
<p>
Attribute VB_Exposed = False</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' John Robbins, Microsoft Systems Journal - August, 1997</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
Option Explicit</p>
<p>
Public Sub DoMe(msg As String)</p>
<p>
   Dim iRet As Integer</p>
<p>
   iRet = MsgBox(msg, Title:=&quot;OutputClass&quot;)</p>
<p>
   </p>
<p>
End Sub</p>
<p>
TheClass.cls</p>
<p>
VERSION 1.0 CLASS</p>
<p>
BEGIN</p>
<p>
  MultiUse = -1  'True</p>
<p>
END</p>
<p>
Attribute VB_Name = &quot;TheClass&quot;</p>
<p>
Attribute VB_GlobalNameSpace = False</p>
<p>
Attribute VB_Creatable = True</p>
<p>
Attribute VB_PredeclaredId = False</p>
<p>
Attribute VB_Exposed = False</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' John Robbins, Microsoft Systems Journal - August, 1997</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
Option Explicit</p>
<p>
Public clsOutput As OutputClass</p>
<p>
' The public method that will be called from the thread.</p>
<p>
Public Sub CallMeFromTheThread()</p>
<p>
   Dim iRet As Integer</p>
<p>
   iRet = MsgBox(&quot;TheClass.CallMeFromTheThread did something&quot;, _</p>
<p>
                  Title:=&quot;TheClass&quot;)</p>
<p>
End Sub</p>
<p>
Thread.bas</p>
<p>
Attribute VB_Name = &quot;Thread&quot;</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' John Robbins, Microsoft Systems Journal - August, 1997</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
Option Explicit</p>
<p>
Public Declare Function CreateThread Lib &quot;kernel32&quot; _</p>
<p>
         (ByVal lpThreadAttributes As Long, _</p>
<p>
          ByVal dwStackSize As Long, _</p>
<p>
          ByVal lpStartAddress As Any, _</p>
<p>
          ByRef lpParameter As Any, _</p>
<p>
          ByVal dwCreationFlags As Long, _</p>
<p>
          ByRef lpThreadId As Long) As Long</p>
<p>
Public Function TheThread(clsTheClass As TheClass) As Long</p>
<p>
   On Error GoTo TheThread_Error</p>
<p>
   clsTheClass.CallMeFromTheThread</p>
<p>
   </p>
<p>
   clsTheClass.clsOutput.DoMe (&quot;I'm from the thread!&quot;)</p>
<p>
   </p>
<p>
   Exit Function</p>
<p>
   </p>
<p>
TheThread_Error:</p>
<p>
   MsgBox (&quot;TheThread had an error : &quot; + Err.Description)</p>
<p>
End Function</p>
<h2>Some More Complex Code</h2>
<p>
Now that you’ve seen a simple example of a multithreaded Visual Basic application and you know what it takes to pass classes to your thread function, it’s time to look at something a little more interesting. Granted, THREAD&shy;TEST.EXE is not the most exciting program in the world, but it gives you an idea of a real-world implementation (see Figure 5). THREADTEST.EXE is a simple timer application that increments a label control every 100 milliseconds in a background thread (see Figure 6). You can start, pause, resume, or end the background thread completely through synchronization events just like you would do in your own applications. While the average programmer could whip the same program out in a couple of minutes with a timer control, using a thread is much more interesting.</p>
<p>
Figure 5  Thread Test Sample</p>
<p>
frmThreadTest.frm</p>
<p>
VERSION 5.00</p>
<p>
Begin VB.Form frmThreadTest </p>
<p>
   BorderStyle     =   1  'Fixed Single</p>
<p>
   Caption         =   &quot;Thread Tester!&quot;</p>
<p>
   ClientHeight    =   1725</p>
<p>
   ClientLeft      =   45</p>
<p>
   ClientTop       =   330</p>
<p>
   ClientWidth     =   5805</p>
<p>
   LinkTopic       =   &quot;Form1&quot;</p>
<p>
   MaxButton       =   0   'False</p>
<p>
   ScaleHeight     =   1725</p>
<p>
   ScaleWidth      =   5805</p>
<p>
   StartUpPosition =   2  'CenterScreen</p>
<p>
   Begin VB.CommandButton btnPause </p>
<p>
      Caption         =   &quot;&amp;Pause Thread&quot;</p>
<p>
      Height          =   615</p>
<p>
      Left            =   1533</p>
<p>
      TabIndex        =   3</p>
<p>
      Top             =   960</p>
<p>
      Width           =   1335</p>
<p>
   End</p>
<p>
   Begin VB.CommandButton btnStartThread </p>
<p>
      Caption         =   &quot;&amp;Start Thread&quot;</p>
<p>
      Height          =   615</p>
<p>
      Left            =   131</p>
<p>
      TabIndex        =   2</p>
<p>
      Top             =   960</p>
<p>
      Width           =   1335</p>
<p>
   End</p>
<p>
   Begin VB.CommandButton btnStopThread </p>
<p>
      Caption         =   &quot;Stop &amp;Thread&quot;</p>
<p>
      Height          =   615</p>
<p>
      Left            =   2935</p>
<p>
      TabIndex        =   4</p>
<p>
      Top             =   960</p>
<p>
      Width           =   1335</p>
<p>
   End</p>
<p>
   Begin VB.CommandButton btnEnd </p>
<p>
      Caption         =   &quot;&amp;End&quot;</p>
<p>
      Height          =   615</p>
<p>
      Left            =   4338</p>
<p>
      TabIndex        =   5</p>
<p>
      Top             =   960</p>
<p>
      Width           =   1335</p>
<p>
   End</p>
<p>
   Begin VB.Label lblSeconds </p>
<p>
      Caption         =   &quot;0.0&quot;</p>
<p>
      BeginProperty Font </p>
<p>
         Name            =   &quot;MS Sans Serif&quot;</p>
<p>
         Size            =   24</p>
<p>
         Charset         =   0</p>
<p>
         Weight          =   700</p>
<p>
         Underline       =   0   'False</p>
<p>
         Italic          =   0   'False</p>
<p>
         Strikethrough   =   0   'False</p>
<p>
      EndProperty</p>
<p>
      ForeColor       =   &amp;H000000FF&amp;</p>
<p>
      Height          =   495</p>
<p>
      Left            =   4200</p>
<p>
      TabIndex        =   1</p>
<p>
      Top             =   240</p>
<p>
      Width           =   1335</p>
<p>
   End</p>
<p>
   Begin VB.Label lblTitle </p>
<p>
      Caption         =   &quot;Look Ma!  No timers, just real threads!&quot;</p>
<p>
      BeginProperty Font </p>
<p>
         Name            =   &quot;MS Sans Serif&quot;</p>
<p>
         Size            =   9.75</p>
<p>
         Charset         =   0</p>
<p>
         Weight          =   700</p>
<p>
         Underline       =   0   'False</p>
<p>
         Italic          =   0   'False</p>
<p>
         Strikethrough   =   0   'False</p>
<p>
      EndProperty</p>
<p>
      Height          =   495</p>
<p>
      Left            =   120</p>
<p>
      TabIndex        =   0</p>
<p>
      Top             =   240</p>
<p>
      Width           =   3855</p>
<p>
   End</p>
<p>
End</p>
<p>
Attribute VB_Name = &quot;frmThreadTest&quot;</p>
<p>
Attribute VB_GlobalNameSpace = False</p>
<p>
Attribute VB_Creatable = False</p>
<p>
Attribute VB_PredeclaredId = True</p>
<p>
Attribute VB_Exposed = False</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' John Robbins, Microsoft Systems Journal - August 1997</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
Option Explicit</p>
<p>
' This is the static thread handle that will be used by this form</p>
<p>
'  to store the executing thread.  If it is 0, then the background</p>
<p>
'  thread is not executing.</p>
<p>
Private g_hThread As Long</p>
<p>
' The array of event handles that are used to coordinate the background</p>
<p>
'  thread.  There are two events here.  The first is the stop event</p>
<p>
'  that when signaled means that the background thread is supposed</p>
<p>
'  to end.  The second event is the event that is signaled when the</p>
<p>
'  background thread is supposed to be updating the label control</p>
<p>
'  with the count.  If it is nonsignaled, then the background thread</p>
<p>
'  is paused.  The second event is the paused/running event.</p>
<p>
Private g_ahSynchEvents(2) As Long</p>
<p>
' The flag that indicates the state of the thread so the UI can show the</p>
<p>
'  state.</p>
<p>
Private g_bThreadIsPaused As Boolean</p>
<p>
' The class that holds the label object that will be passed to the</p>
<p>
'  thread.  This is done because trying to pass the actual label</p>
<p>
'  as the lpParameter to CreateThread always passed zero which obviously</p>
<p>
'  will crash.</p>
<p>
Private g_clsLabel As LabelClass</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' Handles when the form is loaded.</p>
<p>
Private Sub Form_Load()</p>
<p>
   ' Set the statics to known values, I trust nothing.</p>
<p>
   g_hThread = 0</p>
<p>
   g_ahSynchEvents(0) = 0</p>
<p>
   g_ahSynchEvents(1) = 0</p>
<p>
   g_bThreadIsPaused = False</p>
<p>
   ' Instantiate the class.</p>
<p>
   Set g_clsLabel = New LabelClass</p>
<p>
   ' Initialize the label class so that you can really pass the label</p>
<p>
   '  to the thread as the parameter.</p>
<p>
   Set g_clsLabel.m_lblLabel = lblSeconds</p>
<p>
   ' Disable the stop thread and pause buttons.</p>
<p>
   btnStopThread.Enabled = False</p>
<p>
   btnPause.Enabled = False</p>
<p>
End Sub</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' Called when the form unloads.  If the background thread is running,</p>
<p>
'  then it is killed.</p>
<p>
Private Sub Form_Unload(Cancel As Integer)</p>
<p>
   ' Shut down the thread if needed.</p>
<p>
   KillTheThread</p>
<p>
   Set g_clsLabel.m_lblLabel = Nothing</p>
<p>
End Sub</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' The &quot;End&quot; button is pressed.</p>
<p>
Private Sub btnEnd_Click()</p>
<p>
   Unload frmThreadTest</p>
<p>
End Sub</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' The user wants to start the thread.</p>
<p>
Private Sub btnStartThread_Click()</p>
<p>
   ' Make sure that you only get in here if no thread is executing.</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 &lt;&gt; g_hThread) Then</p>
<p>
         MsgBox (&quot;btnStartThread_Click: g_hThread &lt;&gt; 0&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
   ' Create the synchronization objects now.</p>
<p>
   CreateSynchEvents g_ahSynchEvents</p>
<p>
   ' Holds the handle id returned by CreateThread.</p>
<p>
   Dim lThreadID As Long</p>
<p>
   ' Create the thread.</p>
<p>
   g_hThread = CreateThread(0, _</p>
<p>
                            0, _</p>
<p>
                            AddressOf TheThread.TheThreadSub, _</p>
<p>
                            g_clsLabel, _</p>
<p>
                            0, lThreadID)</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = g_hThread) Then</p>
<p>
         MsgBox (&quot;btnStartThread_Click: g_hThread &lt;&gt; 0&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
   If (0 &lt;&gt; g_hThread) Then</p>
<p>
      ' Disable the start thread button so you don't create extra</p>
<p>
      '  threads.</p>
<p>
      btnStartThread.Enabled = False</p>
<p>
      ' Enable the end thread button so you can kill it.</p>
<p>
      btnStopThread.Enabled = True</p>
<p>
      ' Enable the pause button.</p>
<p>
      btnPause.Enabled = True</p>
<p>
   Else</p>
<p>
      ' We didn't get started so kill the synch objects.</p>
<p>
      Dim bRet As Long</p>
<p>
      bRet = CloseHandle(g_ahSynchEvents(0))</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = bRet) Then</p>
<p>
         MsgBox (&quot;CloseHandle(g_ahSynchEvents(0)) failed&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
      bRet = CloseHandle(g_ahSynchEvents(1))</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = bRet) Then</p>
<p>
         MsgBox (&quot;CloseHandle(g_ahSynchEvents(1)) failed&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
   End If</p>
<p>
End Sub</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' The user wants to pause the thread.</p>
<p>
Private Sub btnPause_Click()</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = g_hThread) Then</p>
<p>
         MsgBox (&quot;btnStartThread_Click: g_hThread = 0&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
   Dim bRet As Long</p>
<p>
   ' Is the thread already paused?  If it is, then you need to set the</p>
<p>
   '  update event, the second in the array, and put the &quot;Pause Thread&quot;</p>
<p>
   '  text back on the button.</p>
<p>
   If (True = g_bThreadIsPaused) Then</p>
<p>
      ' Reset the flag.</p>
<p>
      g_bThreadIsPaused = False</p>
<p>
      ' Set the text back.</p>
<p>
      btnPause.Caption = &quot;&amp;Pause Thread&quot;</p>
<p>
      ' Set the event to signaled.</p>
<p>
      bRet = SetEvent(g_ahSynchEvents(1))</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = bRet) Then</p>
<p>
         MsgBox (&quot;SetEvent(g_ahSynchEvents(1)) failed&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
   Else</p>
<p>
      ' Set the flag.</p>
<p>
      g_bThreadIsPaused = True</p>
<p>
      ' Set the button caption.</p>
<p>
      btnPause.Caption = &quot;&amp;Resume Thread&quot;</p>
<p>
      ' Set the paused/running event to nonsignaled.</p>
<p>
      bRet = ResetEvent(g_ahSynchEvents(1))</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = bRet) Then</p>
<p>
         MsgBox (&quot;ResetEvent(g_ahSynchEvents(1)) failed&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
   End If</p>
<p>
End Sub</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' The user wants to stop the thread.</p>
<p>
Private Sub btnStopThread_Click()</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = g_hThread) Then</p>
<p>
         MsgBox (&quot;btnStopThread_Click: g_hThread = 0&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
   KillTheThread</p>
<p>
   ' If the thread is paused, then clear the flag and set the button</p>
<p>
   '  back to the proper text.</p>
<p>
   If (True = g_bThreadIsPaused) Then</p>
<p>
      ' Reset the flag.</p>
<p>
      g_bThreadIsPaused = False</p>
<p>
      ' Set the text back.</p>
<p>
      btnPause.Caption = &quot;&amp;Pause Thread&quot;</p>
<p>
   End If</p>
<p>
   ' Reset the state of the buttons.</p>
<p>
   btnStartThread.Enabled = True</p>
<p>
   btnStopThread.Enabled = False</p>
<p>
   btnPause.Enabled = False</p>
<p>
End Sub</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' A private routine to end the background thread.  This is here because</p>
<p>
'  it needs to be called from the &quot;Stop&quot; button and during the form</p>
<p>
'  unload.</p>
<p>
Private Sub KillTheThread()</p>
<p>
   If (0 &lt;&gt; g_hThread) Then</p>
<p>
      ' Just kill the thread!</p>
<p>
      Dim bRet As Long</p>
<p>
      ' It is, so signal the quit event then shut down.</p>
<p>
      bRet = SetEvent(g_ahSynchEvents(0))</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = bRet) Then</p>
<p>
         MsgBox (&quot;SetEvent(g_ahSynchEvents(0)) failed&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
      ' Wait for the thread to end.</p>
<p>
      bRet = WaitForSingleObject(g_hThread, INFINITE)</p>
<p>
      ' Close down the synchronization handles.</p>
<p>
      bRet = CloseHandle(g_ahSynchEvents(0))</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = bRet) Then</p>
<p>
         MsgBox (&quot;CloseHandle(g_ahSynchEvents(0)) failed&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
      bRet = CloseHandle(g_ahSynchEvents(1))</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = bRet) Then</p>
<p>
         MsgBox (&quot;CloseHandle(g_ahSynchEvents(1)) failed&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
      g_hThread = 0</p>
<p>
   End If</p>
<p>
End Sub</p>
<p>
Globals.bas</p>
<p>
Attribute VB_Name = &quot;Globals&quot;</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' John Robbins, Microsoft Systems Journal - August 1997</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
Option Explicit</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' The name of the synchronization object that, when signaled, is used to</p>
<p>
'  update the label.</p>
<p>
Public Const SYNCHEVENT_UPDATELABEL As String = &quot;ThreadTest_UpdateLabel&quot;</p>
<p>
' The name of the synchronization object that, when signaled, tells the</p>
<p>
'  background thread to end.</p>
<p>
Public Const SYNCHEVENT_ENDTHREAD As String = &quot;ThreadTest_EndThread&quot;</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
Public Declare Function CreateThread _</p>
<p>
        Lib &quot;kernel32&quot; (ByVal lpThreadAttributes As Long, _</p>
<p>
                        ByVal dwStackSize As Long, _</p>
<p>
                        ByVal lpStartAddress As Any, _</p>
<p>
                        ByRef lpParameter As Any, _</p>
<p>
                        ByVal dwCreationFlags As Long, _</p>
<p>
                        ByRef lpThreadId As Long) As Long</p>
<p>
Public Declare Function TerminateThread _</p>
<p>
        Lib &quot;kernel32&quot; (ByVal hThread As Long, _</p>
<p>
                        ByVal dwExitCode As Long) As Long</p>
<p>
Declare Sub Sleep Lib &quot;kernel32&quot; (ByVal dwMilliseconds As Long)</p>
<p>
Declare Function CreateEvent _</p>
<p>
         Lib &quot;kernel32&quot; _</p>
<p>
               Alias &quot;CreateEventA&quot; _</p>
<p>
         (ByVal lpEventAttributes As Long, _</p>
<p>
         ByVal bManualReset As Long, _</p>
<p>
         ByVal bInitialState As Long, _</p>
<p>
         ByVal lpName As String) As Long</p>
<p>
Declare Function CloseHandle _</p>
<p>
         Lib &quot;kernel32&quot; _</p>
<p>
         (ByVal hObject As Long) As Long</p>
<p>
Declare Function WaitForMultipleObjects _</p>
<p>
         Lib &quot;kernel32&quot; (ByVal nCount As Long, _</p>
<p>
                         ByRef lpHandles As Long, _</p>
<p>
                         ByVal bWaitAll As Long, _</p>
<p>
                         ByVal dwMilliseconds As Long) As Long</p>
<p>
Declare Function WaitForSingleObject _</p>
<p>
         Lib &quot;kernel32&quot; (ByVal hHandle As Long, _</p>
<p>
                         ByVal dwMilliseconds As Long) As Long</p>
<p>
Declare Function SetEvent _</p>
<p>
         Lib &quot;kernel32&quot; (ByVal hEvent As Long) As Long</p>
<p>
Declare Function ResetEvent _</p>
<p>
         Lib &quot;kernel32&quot; (ByVal hEvent As Long) As Long</p>
<p>
Public Const INFINITE = &amp;HFFFF</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' This is the helper function that will create the appropriate events</p>
<p>
'  for both the main thread and the background thread.</p>
<p>
Sub CreateSynchEvents(ahEvents() As Long)</p>
<p>
   ' The first event is the stop event so it is a manual-reset event</p>
<p>
   '  that is created NONSIGNALED.</p>
<p>
   ahEvents(0) = CreateEvent(0, 1, 0, SYNCHEVENT_ENDTHREAD)</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = ahEvents(0)) Then</p>
<p>
         MsgBox (&quot;CreateSynchEvents: ahEvents(0) = 0&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
   ' The second event is the paused/running event.  It is created as a</p>
<p>
   '  manual-reset event that starts out as signaled.</p>
<p>
   ahEvents(1) = CreateEvent(0, 1, 1, SYNCHEVENT_UPDATELABEL)</p>
<p>
#If DEBUGBUILD Then</p>
<p>
      If (0 = ahEvents(1)) Then</p>
<p>
         MsgBox (&quot;CreateSynchEvents: ahEvents(1) = 0&quot;)</p>
<p>
      End If</p>
<p>
#End If</p>
<p>
End Sub</p>
<p>
LabelClass.cls</p>
<p>
VERSION 1.0 CLASS</p>
<p>
BEGIN</p>
<p>
  MultiUse = -1  'True</p>
<p>
END</p>
<p>
Attribute VB_Name = &quot;LabelClass&quot;</p>
<p>
Attribute VB_GlobalNameSpace = False</p>
<p>
Attribute VB_Creatable = True</p>
<p>
Attribute VB_PredeclaredId = False</p>
<p>
Attribute VB_Exposed = False</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' John Robbins, Microsoft Systems Journal - August, 1997</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
Option Explicit</p>
<p>
Public m_lblLabel As Label</p>
<p>
TheThread.bas</p>
<p>
Attribute VB_Name = &quot;TheThread&quot;</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
' John Robbins, Microsoft Systems Journal - August 1997</p>
<p>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</p>
<p>
Option Explicit</p>
<p>
' This is the procedure that will be used as the</p>
<p>
'  background thread.</p>
<p>
Public Sub TheThreadSub(clsLabel As LabelClass)</p>
<p>
   ' The array of event handles that are used to coordinate the</p>
<p>
   '  background thread.  There are two events here.  The first is the</p>
<p>
   '  stop event that when signaled means that the background thread is</p>
<p>
   '  supposed to end.  The second event is the event that is signaled</p>
<p>
   '  when the background thread is supposed to be updating the label</p>
<p>
   '  control with the count.  If it is nonsignaled, then the</p>
<p>
   '  background thread is paused.  The second event is the</p>
<p>
   '  paused/running event.</p>
<p>
   Dim ahSynchEvents(2) As Long</p>
<p>
   ' Create the synchronization events.</p>
<p>
   CreateSynchEvents ahSynchEvents</p>
<p>
   ' The number of seconds that we have been running.</p>
<p>
   Dim lSecs As Long</p>
<p>
   lSecs = 0</p>
<p>
   ' All that is done in here is just spin around updating the label</p>
<p>
   '  text until this thread gets killed.  It's kind of boring,</p>
<p>
   '  actually.</p>
<p>
   While True</p>
<p>
      Dim bRet As Long</p>
<p>
      Dim lIndex As Long</p>
<p>
      lIndex = WaitForMultipleObjects(2, ahSynchEvents(0), 0, INFINITE)</p>
<p>
      Select Case lIndex</p>
<p>
         ' If it is the first one, then stop.</p>
<p>
         Case 0</p>
<p>
            ' Clean up after ourselves.</p>
<p>
            bRet = CloseHandle(ahSynchEvents(0))</p>
<p>
#If DEBUGBUILD Then</p>
<p>
            If (0 = bRet) Then</p>
<p>
               MsgBox (&quot;CloseHandle(ahSynchEvents(0)) failed&quot;)</p>
<p>
            End If</p>
<p>
#End If</p>
<p>
            bRet = CloseHandle(ahSynchEvents(1))</p>
<p>
#If DEBUGBUILD Then</p>
<p>
            If (0 = bRet) Then</p>
<p>
               MsgBox (&quot;CloseHandle(ahSynchEvents(1)) failed&quot;)</p>
<p>
            End If</p>
<p>
#End If</p>
<p>
            Exit Sub</p>
<p>
         Case 1</p>
<p>
            ' Show how long the thread has been running.  This does not</p>
<p>
            '  handle wrap around on the time.</p>
<p>
            clsLabel.m_lblLabel.Caption = lSecs / 100</p>
<p>
            ' Sleep for a bit.</p>
<p>
            Sleep (100)</p>
<p>
            lSecs = lSecs + 1</p>
<p>
         Case Else</p>
<p>
#If DEBUGBUILD Then</p>
<p>
            MsgBox (&quot;Case Else hit!!&quot;)</p>
<p>
#End If</p>
<p>
      End Select</p>
<p>
   Wend</p>
<p>
End Sub</p>
<p>
<img src="threads6.gif" border=0></p>
<p>
Figure 6  THREADTEST.EXE User Interface</p>
<p>
Needless to say, the user interface for THREADTEST.-EXE is pretty intuitive. Just click the four buttons on <BR>the bottom of the window to create and control the background thread, and click on the End button to close the application. To really see what THREADTEST.EXE is doing, you might want to run it under a debugger to see what is executing when. </p>
<p>
I applied some of the lessons that I learned from MT.EXE to THREAD&shy;TEST.EXE. For instance, when I start the background thread&nbsp;function,&nbsp;TheThreadSub, I pass a class of type Label&shy;Class as the thread parameter. The LabelClass has a single public property that is a Label object. If this were a real-world program, I would not use the Label object directly but would have provided wrapper functions to set and get the Caption property. The one instance of the LabelClass is instantiated in the Form_Load event for the main form.</p>
<p>
The most interesting part of THREADTEST.EXE is how the main thread controls the background thread. In this program, after the background thread is started, it just runs until the main thread tells it to pause or stop. If the background thread is paused, then the main thread tells it to either restart or stop. In both states, running or paused, it’s vital that you are able to stop running the background thread from the main thread. The pause and restart notifications are a lower-level toggle item.</p>
<p>
To make the background thread behave in this manner, you might be inclined to create two carefully controlled global variables. Since the background thread is always supposed to be running, it would need a While...Wend loop to run infinitely. Moreover, since the stop notification is so important, the top of the loop after the While would have to check the g_bStop Boolean flag to see if it was true. If g_<BR>bStop was true, then you would exit the subroutine. If g_bStop was false, then you could check the value of the g_bPaused Boolean flag. If g_bPaused was false, then you could go on and update the label control. The following pseudo code shows how the thread function might look:</p>
<p>
Public Dim g_bStop As Boolean</p>
<p>
Public Dim g_bPaused As Boolean</p>
<p>
Public Sub GlobalVarThread (clsLabel as LabelClass)</p>
<p>
    While (True)</p>
<p>
        if (True = g_bStop) then</p>
<p>
            Exit Sub</p>
<p>
        End If</p>
<p>
        if (False = g_bPaused) then</p>
<p>
            ' Do the update stuff here.</p>
<p>
        End If</p>
<p>
    Wend</p>
<p>
End Sub</p>
<p>
While the global variable approach seems to work at first glance, there are a couple of problems with it. First, the background thread sits in a tight loop, polling away at variables, which eats up a great deal of CPU time. This would become obvious if you ran the application because the TaskManager in your iconbar would jump to fully green, indicating something is sitting in a tight loop. </p>
<p>
The second problem is much more serious and not as obvious. When you start the background thread, you need to set the state of both global variables to False so you can restart the thread after you stop it. Consider what would happen in this scenario. First, you press the Stop button (which sets g_bStop to true). Second, Windows NT&reg; immediately task-switches away to service a huge network packet. Third, you are fast on the mouse and click on the Start button. Fourth, Windows NT task-switches back to your application and executes the main thread, which causes the Start button press to be handled. At this point, something really nasty would happen; a background thread would be created from pressing the Start button, your original background thread would spin around and see that g_bStop is true (remember, g_bStop is set to false by the Start button press), and you would have two background threads running when you should only have one.</p>
<p>
As you can see, polling global variables would be a mess and would cause even more problems if the application ran on a multiprocessor machine. But fortunately, there is another way to signal the background thread that some event has taken place: use Win32 event objects as your synchronization objects. This is what I did in the THREADTEST.EXE program.</p>
<p>
Events are created by calling the CreateEvent API. Each thread that needs an event must call CreateEvent because event objects cannot be passed around. Both threads must be working with the same event, so the lpName parameter to CreateEvent lets you give the event a name. Note that events are cross-process, so be very careful and use event names that are unique. A good technique is to append the process ID to the event, guaranteeing its uniqueness.</p>
<p>
Event objects have two states, signaled and nonsignaled. I liken a signaled event to a thing that has happened or is being set to true. The CreateEvent API has other parameters that let you specify the initial state and whether the event is manual-reset or autoreset. A manual-reset event means that, when you cause an event to be signaled, you must explicitly set it back to nonsignaled. With autoreset events, when you signal an event, the event is automatically set to nonsignaled when a single waiting thread has been released. To set a manual-reset event to the signaled state, call SetEvent on the event handle. To set a manual-reset event to the nonsignaled state, call ResetEvent with the event handle. </p>
<p>
Once you have created an event, you need to know when it is signaled. The API function WaitForSingleObject indicates if an object is signaled, and will also wait a specific period of time before timing out. Of course, the value INFINITE can be passed to WaitForSingleObject to have the thread block forever until an event is signaled.</p>
<p>
If you need to wait for a set of events, WaitForMultiple&shy;Objects takes an array of event handles and tells you which event was signaled or if all events&nbsp;in&nbsp;the&nbsp;array were signaled, depending on the bWait&shy;All parameter value. For both functions, if the event or events are not signaled, the time slice for the thread is released. This prevents polling from wasting CPU time. Finally,&nbsp;when&nbsp;you’re&nbsp;done&nbsp;with the event, which is a ubiqui&shy;tous Win32 handle, call CloseHandle on it to free the event.</p>
<p>
In THREADTEST.EXE, the synchronization scenario is that stop state must always happen whether the thread is paused or running, and the paused state must toggle back to the running state. Like the global variable attempt, THREADTEST.EXE has two events. As it has only two threads, there will not be many threads waiting on the events, so I created them both as manual-reset events so I could control the signaled state myself.</p>
<p>
Since the background thread will be waiting on the state of two events, I keep the events in an array two elements long. The stop event is higher priority for THREAD&shy;TEST.EXE, so it is the first element in the array and the pause/running event is the second. The WaitForMultiple&shy;Objects function treats the items in the event array parameter in decreasing priority the higher you go in the array. This means that, even though the event in the 99th index is signaled, WaitForMultipleObjects will return the lower number if any of the previous position’s events is signaled.</p>
<p>
The only thread that actually waits on the events is the background&nbsp;thread.&nbsp;Since it needs to update the label con&shy;trol&nbsp;every&nbsp;100&nbsp;milliseconds,&nbsp;the&nbsp;background&nbsp;thread &nbsp;will always be running unless it is paused. To accomplish this, the stop event is created as nonsignaled, but the pause/running event is created as signaled. By keeping the pause/running event&nbsp;in&nbsp;the&nbsp;signaled state, WaitForMultipleObjects always returns immediately so the label control can be updated.</p>
<p>
You are probably wondering why I have only two events for basically three states—stopped, running, and paused. The idea is that the paused and running states are Booleans; either the background thread is running or not. If you had three events, you would end up polling because, if the paused&nbsp;event&nbsp;was signaled, you would have to set the run&shy;ning event to nonsignaled. Since WaitForMulti&shy;ple&shy;&shy;Objects would return on the signaled pause event, you are doing glorified polling. When the background thread is paused, you want to get into an idle state so that it does not take up any CPU time until it is supposed to be running. Of course, if the paused/running event is always nonsignaled, the background thread stays in Wait&shy;ForMultipleObjects until either of the events becomes signaled, effectively pausing the thread.</p>
<p>
The main thread in THREADTEST.EXE is responsible for creating the background thread and for signaling the appropriate events based on user input. Inside the form, the main thread keeps the state of the thread because the&nbsp;Pause&nbsp;Thread&nbsp;button doubles as the Resume Thread button. When the Pause Thread button is pressed, the main thread calls ResetEvent on the paused/running event, which kicks the background thread into the WaitForMulti&shy;pleObjects call until something else is set. When the Resume Thread button is pressed, the main thread calls SetEvent on the paused/running event to get it back to the signaled state.</p>
<p>
When the main thread handles the Stop Thread button, it does more than set an event in the KillTheThread function. After setting the stop event, the main thread calls WaitForSingleObject, using the background thread handle to wait for the thread to end when the thread handle is signaled. Remember that there are many different handles that WaitForSingleObject can wait on, not just event object handles. I probably do not need to wait for the thread in THREADTEST.EXE, but in real-world applications you will need to wait to make sure the background thread shuts down before you end the application. If the background thread is doing something important (like shutting down a SQL database connection) and you let the main thread call ExitProcess, you can kill the thread in the middle of the shutdown and lose data or corrupt the database.</p>
<h2>Some&nbsp;Final&nbsp;Visual&nbsp;Basic&nbsp;Multithreading&nbsp;Issues</h2>
<p>
There are a couple of issues that I need to cover before I introduce the bigger debugger example. First, you should be certain that the Visual Basic runtime is thread-safe. As I mentioned earlier, the Visual Basic runtime is mostly thread-safe. While I did not sit down and completely disassemble MSVBVM50.DLL, the fact that Visual Basic 5.0 now supports apartment-model multithreading in ActiveX controls means that at least the nonuser interface portions are completely thread-safe. Since the programs in this article only use MSVBVM50.DLL; however, I cannot vouch for the thread-safety of the other Visual Basic runtime DLLs, such as VB5DB.DLL. If your multithreaded app&nbsp;needs to use some other Visual Basic system DLLs or a multi&shy;threaded user interface, you will need to do some prototyping to determine that everything is working correctly.</p>
<p>
If the runtime is thread-safe, the next thing to check is the p-code interpreter. The interpreter doesn’t appear to be thread-safe because a multithreaded application compiled to&nbsp;p-code&nbsp;eventually&nbsp;crashes.&nbsp;Maybe&nbsp;future&nbsp;versions&nbsp;of Visual&nbsp;Basic&nbsp;will&nbsp;allow&nbsp;multithreaded p-code&nbsp;compilations.</p>
<p>
Finally, while you might want to use multithreading in your Visual Basic AddIn, the IDE only supports a single execution thread—your AddIn cannot be multithreaded.</p>
<h2>The Next Step</h2>
<p>
So far, I’ve covered the basic elements needed to write multithreaded applications with Visual Basic 5.0. In this part, I took a close look at the AddressOf operator, and put it to use creating threads. But so far, my samples have been small. In the second part of this article, I’m going to write a real-world multithreaded application in Visual Basic: a fully functional Win32 debugger shell. While it won’t have a symbol engine or offer breakpoints, it isn’t that far from plugging them in. Stay tuned.                                           u</p>
</font></font></body>
</HTML>
