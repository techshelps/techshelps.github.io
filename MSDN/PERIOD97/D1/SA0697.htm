<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Access Answers: Closing All Open Forms and Handling Misleading Report Errors </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2">
<h1>Access Answers:</h1>
<h1>Closing All Open Forms and Handling Misleading Report Errors</h1>
<p>
Ken Getz</p>
<p>
<i>Ken recently taught an Access 97 training class, and got a few interesting questions from the experience. The two questions answered here are the direct outcome of that class. </i></p>
<p>
<i>I’m trying to find a way to close all the forms in my application except the current form. That is, I have code attached to the Click event of a button on the form, and I’d like to have that button click close all the other forms. I’ve tried a number of alternatives, but I either get runtime errors or other weird stuff happens. Can you help?</i></p>
<p>
This is a common question-it comes up almost every time I teach Access training classes for developers. There are a number of issues here, including these:</p>
<p>
How do you close all the forms that are currently open?</p>
<p>
How can you tell which form is the current one, and avoid closing it?</p>
<p>
Let’s take these two issues one at a time. This answer will attempt a number of different solutions, all based on forms in the sample database. In each case, opening one of the test forms (frmCloseAll1, frmCloseAll2, and so on) will open four subsidiary forms. Clicking the button on the test form calls code, which I’ll describe here, that attempts to close all the subsidiary forms.</p>
<h1>Closing all open forms</h1>
<p>
To simplify matters, let’s first look into closing all the open forms. That should be a simple task: Access provides a Forms collection that contains one reference for each currently open form. You should be able to loop through the collection one item at a time and close each form:</p>
<pre><font face="Courier New" size="3">' Code from frmCloseAll1
Dim intI As Integer

For intI = 0 To Forms.Count - 1
  DoCmd Close A_FORM, Forms(intI).Name
Next intI</font></pre>
<p>
(The syntax for the Access 95/97 example is a bit different, but the ideas are the same.) If you open frmCloseAll1 and click the Close All Forms button, you’ll receive a runtime error (2456: Invalid form number reference) in response. The code sure seems like it ought to work, but it doesn’t. Why not? It’s all because of the way Access treats objects in collections.</p>
<p>
All the items within a collection are numbered-that is, as you add them to the collection, they’re assigned an ordinal position within the collection. As you remove them from the collection, Access renumbers the items remaining within the collection. Figure 1 shows what happens, in memory, as you run the previous code fragment. As you can see, Access renumbers the elements of the collection as you close forms, so that by the time it attempts to close form 3, there is no form number 3, and the code fails.</p>
<p><img src="qa97061.gif"></p>
<p>
<b>Figure 1. Looping through all the forms by number causes a runtime error.</b></p>
<p>
Clearly, this technique won’t work. If you think about it for a minute, there are two reasonable alternatives: You can loop through the forms, closing form 0 on each iteration; or you can loop through the Forms collection backwards, closing the forms in reverse order. The first technique, demonstrated in frmCloseAll2, uses the following code to close the forms:</p>
<pre><font face="Courier New" size="3">' Code from frmCloseAll2
Dim intI As Integer
For intI = 0 To Forms.Count - 1
  DoCmd Close A_FORM, Forms(0).Name
Next intI</font></pre>
<p>
The second technique, from frmCloseAll3, uses the following code:</p>
<pre><font face="Courier New" size="3">' Code from frmCloseAll3
Dim intI As Integer

For intI = Forms.Count - 1 To 0 Step -1
  DoCmd Close A_FORM, Forms(intI).Name
Next intI</font></pre>
<p>
Which is better? Certainly not the first method (from the earlier frmCloseAll1)-it doesn’t work at all. Of the next two, I’d recommend the method used by frmCloseAll3. This technique, closing the forms in reverse order, doesn’t require Access to renumber the forms with each loop iteration, and therefore seems to cause less effort for Access. Of course, the difference in speed between the two methods is going to be inconsequential, at best.</p>
<p>
If you’re using Access 95 or 97, and you’ve looked into the For Each...Next control structure, it seems that this would be a perfect place to use it. That is, you’d expect the following code to do the trick:</p>
<pre><font face="Courier New" size="3">' Code from frmCloseAll3a (32-bit version only)
Dim frm As Form

For Each frm In Forms
  DoCmd.Close acForm, frm.Name
Next frm</font></pre>
<p>
You’d be wrong (as was I, when I truly expected this to work). This doesn’t cause a runtime error, but it leaves the same two forms open once it’s completed. Contrary to what you may think, the For Each loop doesn’t dynamically change its scope while the loop is executing. As you delete items from the collection (by closing them), the loop pointer keeps marching along, effectively skipping some forms along the way. No matter which version of Access you’re using, the technique used by frmCloseAll3 works best.</p>
<h1>Skipping the current form</h1>
<p>
As you’ve noticed if you run frmCloseAll3, the previous code fragments close all the forms and don’t attempt to bypass the form running the code. If your application requires you to close all but the current form, you’ll need to take an extra step. There are at least two solutions to this particular problem, which I’ll outline here.</p>
<p>
Somehow, as your code loops through all the open forms, you’ll need to find some way to bypass the current form. Because this code is running from the form’s module, you can use the form’s Me property (a reference to the current form) to refer to the form. The only issue, then, is to find something that uniquely identifies each form and compare it to the corresponding value for the current form as you loop through all the forms.</p>
<p>
The form’s Name property will do, and frmCloseAll4 uses the following code to check, in each iteration, whether it should close the particular form:</p>
<pre><font face="Courier New" size="3">' Code from frmCloseAll4
Dim intI As Integer
Dim strName As String

For intI = Forms.Count - 1 To 0 Step -1
  strName = Forms(intI).Name
  If Me.Name &lt;&gt; strName Then
    DoCmd Close A_FORM, strName
  End If
Next intI</font></pre>
<p>
If, on a particular loop iteration, the current form’s name (Me.Name) is the same as the name of the form the code is trying to close (Forms(intI).Name), then the loop skips that particular form. Otherwise, it closes all the rest.</p>
<p>
However, something’s bothering me here-there has to be a better way! All you really care about is whether Me and Forms(intI) refer to the same form. Sure, you can check the Name property of each, but that seems like extra work. Of course, there is<b> </b>a better way: the <i>Is</i> operator comes to the rescue. This seldom-discussed operator allows you to compare two object references and to find out if the references refer to the same object. Rather than comparing the Name properties of the two references, you should be able to use code like this:</p>
<pre><font face="Courier New" size="3">' Yes, this sounds grammatically bizarre, 
' but it works!
If Me Is Forms(intI) Then
  ' You know Forms(intI) refers to 
  ' the current form, Me.
End If</font></pre>
<p>
Using the Is operator, you can compare two references and see if they refer to the same object. However, in this case you want to know whether the two references point to different objects (so it’s safe to close the form). In that case, you’ll use code like this:</p>
<pre><font face="Courier New" size="3">If Not Me Is Forms(intI) Then</font></pre>
<p>
Therefore, the final version of the sample form, frmCloseAll5, uses the following code to close all but the current form:</p>
<pre><font face="Courier New" size="3">' Code from frmCloseAll5
Dim intI As Integer

For intI = Forms.Count - 1 To 0 Step -1
  If Not Me Is Forms(intI) Then
    DoCmd Close A_FORM, Forms(intI).Name
  End If
Next intI</font></pre>
<p>
Any differences in speed between the two final methods are imperceptible, of course, but using the Is operator seems so much more elegant than comparing properties of the two objects.</p>
<p>
<i>In my application, I allow users to print a report. I use DoCmd OpenReport to open the report, and things usually work fine. However, if the user cancels the print job, I get an ugly error message (2501: Action OpenReport was cancelled). How can I allow the user to cancel the report without seeing that error message?</i></p>
<p>
You can do what most people do: tell them ÒDon’t do that!Ó Just kidding. The solution is quite simple, although not what you might expect. With most macro actions (or methods of the DoCmd object, in Access 95 and 97), you can use the SetWarnings action (or method) to disable warnings like this. That is, you’d expect code such as the following to handle the problem:</p>
<pre><font face="Courier New" size="3">' Code from frmPrintReport1
DoCmd SetWarnings False
DoCmd OpenReport &quot;Catalog&quot;
DoCmd SetWarnings True</font></pre>
<p>
This still allows the error to occur. To test this out, open frmPrintReport1, click the command button, and cancel the report as soon as it starts up. The error is hard to miss!</p>
<p>
The solution, then, is to use Access’ error handling. Because canceling a report triggers a runtime error, the only way to trap the error is to engage an error trap. That is, you can either have Access disregard errors altogether, or handle the error gracefully, using your own code.</p>
<p>
It’s simple to convince Access to disregard errors totally: to do so, simply use the <i>On Error Resume Next </i>statement in your code. The sample form, frmPrintReport2, uses this technique with code as follows:</p>
<pre><font face="Courier New" size="3">' Code from frmPrintReport2
On Error Resume Next
DoCmd OpenReport &quot;Catalog&quot;</font></pre>
<p>
Try this form. If you press the Cancel button while the report is printing, your report will indeed stop printing, and you won’t see an error message. Mission accomplished, right? Well, not quite. </p>
<p>
What if you want to see some message in this case, but not the default message? In that case, you’ll need to take one more error handling step. In this final example, frmPrintReport3, I’ve used a full error handling fragment that allows the procedure to display a specific message if the user cancels the print job:</p>
<pre><font face="Courier New" size="3">' Code from frmPrintReport3
Const vbInformation = 64

On Error GoTo PrintReportErr
DoCmd OpenReport &quot;Catalog&quot;

PrintReportExit:
  Exit Sub

PrintReportErr:
  Select Case Err
    Case 2501   ' Action OpenReport was cancelled.
      MsgBox _
       &quot;You've cancelled the report. &quot; &amp; _
       &quot;Click the Print Report button &quot; &amp; _
       &quot;to start again.&quot;, _
       vbInformation, &quot;Report Cancelled&quot;
    Case Else
      MsgBox &quot;Error: &quot; &amp; Error &amp; &quot; (&quot; &amp; Err &amp; &quot;)&quot;
  End Select
  Resume PrintReportExit</font></pre>
<p>
<b>&#09;&#09;&#09;  GETZ44.EXE at www.pinpub.com/access </b></p>
<h1>About the Download Files</h1>
<p>
The 16-bit demonstration database is QA970616.MDB, and the 32-bit version is QA970632.MDB. The 32-bit database is in Access 95 format, but you can easily convert it for Access 97.</p>
<p>
<i>Ken Getz is a contributing editor to</i> Smart Access<i> and a senior consultant with MCW Technologies focusing on Microsoft Office, Visual Basic, and SQL Server applications. He’s a Microsoft Access MVP award winner and has co-written several books, including the recently published </i>Access 97 Developer’s Handbook<i> (Sybex) and </i>VBA Developer’s Handbook<i> (Sybex). Fax 310-836-4925, keng@mcwtech.com, 76137.3650@compuserve.com, http://www.mcwtech.com.</i></p>
<P align="center"><a
href="http://www.pinpub.com/access/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about Smart
Access and Pinnacle Publishing, visit their website at</strong>:</p>

<P align="center"><a
href="http://www.pinpub.com/access/"><strong>http://www.pinpub.com/access/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content.</font></p>

<P>This article is reproduced from the June 1997
issue of Smart Access. Copyright 1997, by Pinnacle Publishing,
Inc., unless otherwise noted. All rights are reserved. Smart
Access is an independently produced publication of Pinnacle
Publishing, Inc. No part of this article may be used or
reproduced in any fashion (except in brief quotations used in
critical articles and reviews) without prior consent of Pinnacle
Publishing, Inc. To contact Pinnacle Publishing, Inc., please
call (800)788-1900 or (206)251-1900.</p>
</font></BODY>
</HTML>
