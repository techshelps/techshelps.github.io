<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using DBCx to Data-Drive Your Applications </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1>Using DBCx to Data-Drive Your Applications</h1>
<p>
Whil Hentzen</p>
<p>
<i>“Been there, done that”-getting tired of this late ‘90s bromide? Nearly as tired as doing something for the 50th time, I’ll bet. While the VFP 5.0 database container has a number of improvements over previous versions, it isn’t complete. In this article, I’ll examine a number of places in your applications where data dictionary extensions are still needed, and show you how to use a publicly available data dictionary extender, DBCx, to provide that functionality.</i></p>
<p>
THE Visual FoxPro Database Container (DBC) is an excellent starting point for storing meta data for applications, but as I’ve described in previous <i>FoxTalk</i> articles (“Extending the Visual FoxPro Data Dictionary,” May 1995; “Extend the Visual FoxPro Database Container with EDC,” August 1995), it isn’t complete. Two solutions were proposed during the VFP 3.0 beta cycle-Tom Rettig’s EDC and DBCx, the result of a collaborative effort between Flash Creative Management, Micromega Systems, Neon Software, and Stonefield Systems Group.</p>
<p>
Two years later, VFP has matured and the database container has received some enhancements, but the fundamental requirements for extending the data dictionary remain. Let’s revisit what the database container does in VFP 5.0, what it still won’t do, what we would like it to do (or, at least, what we need), and how we can get that functionality from DBCx.</p>
<h2>What we can get from 5.0’s DBC</h2>
<p>
Let’s first review what we’re starting out with. The DBC has a row for every table, field, index, view, and connection (as well as a few rows for other specialized objects). Each row contains fields for a unique ID, an ID that points to the parent object of that row’s object (for example, the parent of a table is the database; the parent of a field is the table), a description of the object, an empty, unused memo field named <i>User</i>, and most importantly, not much else.</p>
<p>
Well, okay, there is a memo field called Properties that looks promising. However, upon further examination, it isn’t all that helpful. It contains data that you can enter into various controls in the Modify Structure dialog box, such as Display Format and Validation Rule. Why isn’t this helpful?</p>
<p>
Four basic types of information can be entered in the Modify Structure dialog box. Field characteristics such as size and type are stored in the header of the DBF itself. Display, Field validation, and Map field information is all stored in the Properties field, but to see why this isn’t useful, let’s examine how this information is used.</p>
<p>
Look at the Field Mappings tab in the Tools/Options dialog box (see Figure 1). At the bottom of the page, four check boxes specify what will happen when a field is dragged from the Data Environment to a form during design. If the Drag and Drop Field Caption check box is selected, the value in the Modify Structure Caption field will be used as the caption for the adjoining label created when the field is dragged from the DE to a form. </p>
<p><img src="07hentz1.gif"></p>
<p>
<b>Figure 1. Much of the information in the Modify Structure dialog box is stored in the properties field in the DBC.</b></p>
<p>
Similarly, if the Copy Field Comment, Input Mask, or Format check boxes in the Field Mappings tab are selected, the values in those controls in the Modify Structure dialog box will be placed in the respective properties for that field when the field is dragged from the DE to the form. </p>
<p>
However, try this: Make a change to the comment, and then drag the field from the DE onto the form again. The new comment will be reflected in the new field, but the first copy of the field will still have the old field comment. Maybe comments aren’t a big deal, but other properties are-such as Format and Input Mask.</p>
<p>
Next, let’s look at the Validation rules. Although they’re entered in the Modify Structure dialog box and aren’t stored in the Properties field, changes do propagate during the life of the application. The reason is that the VFP database engine actively reads from the DBC during runtime to evaluate the values in the DBC that involve validation.</p>
<p>
Finally, let’s examine the Map Field Types to Classes controls. In the Field Mapping tab of the Tools/Options dialog box (see Figure 2), you can specify which of your classes you want to use as the default class when dragging fields from a DE to a form, instead of using VFP’s base classes. Each data type can be defined differently-typically, you might specify a check box class for the logical data type and an edit box class for memo fields. </p>
<p><img src="07hentz2.gif"></p>
<p>
<b>Figure 2. The Field Mapping tab of the Tools/Options dialog box allows you to specify which class is used when dragging fields from a Data Environment to a form. </b></p>
<p>
The default mappings that you selected can be overridden on a field-by-field basis for specific needs with the Map Field Types to Classes controls in the Modify Structure dialog box. The Display Library value points to the VCX while the Display Class is the actual class itself. These settings override, for a specific field, which class will be used when dragging that field to any form. This information is also stored in the Properties field in the DBC, and, like the Display properties, is read only once when the control is first created. Changes made to the Map Field Types controls aren’t propagated through the application as changes are continually made to them.</p>
<p>
So, the bottom line is that much of the information entered into the Modify Structure dialog box and stored in the Properties field in the DBC is used only once. We’d like that information to persist through the application through its lifetime-not just upon initial application.</p>
<h2>What’s missing from the DBC?</h2>
<p>
One requirement of a complete data dictionary is that the developer be able to rebuild the data structures from the information in the data dictionary. Because structural information, such as field type and size and index tag expressions, isn’t stored in the DBC, this is impossible. This means that we can’t build a reindex routine, a rebuild routine, or other similar maintenance routines that rely solely on information in the DBC.</p>
<p>
But there’s more missing than that. It doesn’t take a lot of imagination to think of other information about the data structures that we’d like to keep around. Starting with the tables themselves, useful information might include long descriptive names, a flag for whether the table should be opened upon application startup, an alias to use during opening, and perhaps a default or specialized location.</p>
<p>
With fields, we need several types of long descriptive names. The first name would be used for a persistent caption for an associated label. The next could be used in grids and lists that use the field, and a third for report headings. Obviously, we need to store length, type, and whether nulls are allowed. Other useful things include persistent formats and input masks, as well as tool tips, help text, status bar text, and allowed data ranges.</p>
<p>
Indexes can use a long descriptive name, a flag indicating whether they’re selectable by the user, and a comment field.</p>
<p>
A few more minutes of thought might reveal a variety of other information that you might like to keep around, such as security-related settings that allow read/write access or even visibility of selected fields. Or how about combined fields for output, such as the concatenation of first, middle, and last name fields-there’s no place for this type of meta data in the DBC. </p>
<h2>How do we get there? The DBCx concept</h2>
<p>
Obviously, we need to store this additional meta data somewhere-let’s review quickly what the options are. The first choice of many developers might be that unused empty memo field in the DBC named User. Microsoft left it there for the express purpose of DBC extensions. Why not just store information in this memo field? </p>
<p>
For example, we could store the following data in the DBC record for the League Name field, cNaLeague:</p>
<pre><font face="Courier New" size="3">Caption: &#09;Name
List: &#09;Lg Name
Report1: &#09;League
Report2: &#09;Name
Format: 
Help: &#09;The League Name identifies the <BR>&#09;specific group that plays on a . . .
StatusBar: &#09;Enter the League Name</font></pre>
<p>
This approach has many problems. Two obvious issues involve performance and conflict. Parsing out data from memo fields is time-consuming compared to simple SELECTS from an optimized table. And what happens when more than one type of meta data is being stored in the User field? If you’re the only person using the User field, you’re safe, but your troubles begin the minute you decide to take advantage of a third-party tool that uses the User field to store more information. </p>
<p>
The originators of DBCx started out with the same concept as Tom Rettig did with EDC: store a single key value in the User field that points to another table. But that’s pretty much where the similarity ended. Because one requirement of DBCx was to allow multiple third-party vendors to play in the same sandbox without fighting, a single table to store additional meta data was going to become difficult to administer. </p>
<p>
Instead, they used the concept of a <i>registry</i>-anyone who wanted to share in the DBCx plan could include his or her own record without stomping on anyone else’s turf. Each of these records would point to the data dictionary extensions for that third party. Because many developers had common needs, the collaborators agreed to use Flash’s Codebook as the location for a set of basic extensions, and then each would write his or her own extensions as needed after that (see Listing 1).</p>
<p>
<b>Listing 1. The record in the registry, DBCXREG.DBF, that points to the Codebook extensions.</b></p>
<pre><font face="Courier New" size="3">DBCXREG.DBF
mDBCPath&#09;
cDBCName&#09;
cProdName&#09;&#09;Codebook
cVersion&#09;V3.2
mDBCXPath&#09;
cDBCXName&#09;&#09;CDBKMETA.DBF
cDBCXAlias&#09;&#09;CODEBOOK
mLibPath&#09;&#09;&#09;..\..\..\COMMON50
cLibName&#09;&#09;&#09;CDBKMGR.VCX
cClassName&#09;&#09;CdbkMgr
iLstID&#09;&#09;
tLastUpdt&#09;
lDefault&#09;
cObjName&#09;</font></pre>
<p>
It’s important to remember that the records in the DBCXREG.DBF registry are simply pointers to a second set of tables. This second set of tables actually contains the extensions to the data dictionary. Typically, they each take the form of a table and each field in the table represents a different extension (such as long descriptive table name, field length, index tag, or tool tip text). Each record in the table is usually mapped to a corresponding record in the DBC via the ID stored in the DBC’s User field. Each table is supplied by a different third party, such as Codebook, Micromega, Neon, or Stonefield.</p>
<p>
Thus, if the DBC record for the League Name field had a User ID value of 422, there would be a matching record in the Codebook table that had a unique ID of 422, a matching record in the Micromega table that also had a unique ID of 422, and so on. See Figure 3 for an example of the relationships between the tables.</p>
<p><img src="07hentz3.gif"></p>
<p>
<b>Figure 3. The User field in the DBC contains an ID that points to a record in one or more of the specific meta data tables. Here, ID 422 points to the record for the League table in the CDBKMETA table.</b></p>
<p>
By now, you may think that we’re done. We’ve seen how all the data hooks together, but there’s a missing piece: the set of programs that gets all of these pieces to work together. It isn’t evident that the piece is missing because there’s no corresponding piece for DBC. Well, actually, there is, but it’s invisible-it’s part of the VFP engine inside VFP.EXE. Because DBCx isn’t part of VFP, it has to be driven by a set of external programs.</p>
<p>
DBCx consists of a class library, DBCXMGR.VCX, that contains pointers to class libraries for each extension, such as CDBKMGR.VCX, SDTMGR.VCX, and so on. In order to get things going, instantiate DBCXMGR like so:</p>
<pre><font face="Courier New" size="3">set classlib to DBCXMGR additive
oMeta=createobject('MetaMgr',.f.)</font></pre>
<p>
These two lines of code create a “meta-manager” object onto which are hung additional objects for each registry entrant in DBCXREG.DBF. Each of these objects has its own custom methods and properties that allow access to its data dictionary extensions. Third-party products typically provide a set of wrappers to shield you from having to delve deeply into the DBCX internals-after all, that’s their job, right? For example, the reindex routine in the Stonefield Database Toolkit can be called like this:</p>
<pre><font face="Courier New" size="3">oMeta.oSDTMgr.lQuiet = .f.
m.llIndexWorked = oMeta.oSDTMgr.Reindex()
if m.llIndexWorked
  wait window nowait &quot;Reindex successful&quot;
else
 messagebox(&quot;Reindex was unsuccessful. ;
             Call for help.&quot;)
endif</font></pre>
<p>
Let’s look behind the scenes at what’s happening, and what you would do to manually access meta data through DBCx. There are two basic steps. First, given a particular object, such as a table, field, or index, find its User ID. Next, given that ID, find the specific value for a data dictionary extension of interest, such as a long descriptive name for an index or a tool tip for a field. </p>
<p>
For example, suppose you want to get the long descriptive name and the status bar text for a field. Here’s how you’d get the ID:</p>
<pre><font face="Courier New" size="3">m.liIDOfField = oMeta.DBGetDBCKey(dbc(), ;
               'Field', 'Database.Field')</font></pre>
<p>
In this line, “Field” is the actual literal parameter but “Database.Field” represents a string such as “Customer.Address.” Remember that m.liIDOfField is the value in the User field, such as 422 for League Name, as described earlier in this article.</p>
<p>
Now that you have the ID, you can fetch one or more properties:</p>
<pre><font face="Courier New" size="3">m.lcNaFieldLong = oMeta.DBCXGetProp('SDTmCaption', ;
                  m.liIDOfField)
m.lcToolTipText = oMeta.DBCXGetProp('CBmToolTip', ;
                  m.liIDOfField)</font></pre>
<p>
Because you’re getting these values from the DBC and the DBC extended tables on the fly, you can create data-driven applications that always use the very latest data. Let’s look at a practical implementation.</p>
<h2>How to extend through DBCx</h2>
<p>
One thing I always hate about generic “how-to” articles is that I still have to spend lots of time trying to figure out how to get the process to work with <i>my</i> stuff. In an attempt to avoid that, I’ll describe one possible real-life scenario, pointing out some of the issues you might run into as well as a possible solution.</p>
<p>
Here are the three things you have to know:</p>
<p>
What files are needed.</p>
<p>
Where they go.</p>
<p>
Where the commands that run DBCx go in your application.</p>
<p>
The files you need depend on which third-party products or tools you’re using. Let’s use Codebook as our starting point. You’ll need to put DBCXMGR.VCX and CDBKMGR.VCX in your path so that when you build your applications, they can be found. I put these in COMMON because only one copy is needed across all applications.</p>
<p>
Each of your applications needs its own copy of DBCXREG.DBF and CDBKMETA.DBF. I put these into the APPFILES directory of an application-the place where application-specific data resides. (My user file, error log, custom reports, and so on, also go here. These files aren’t data specific, but rather common across all data sets, so I don’t keep multiple sets of the same files in each data directory.) </p>
<p>
That’s it for the files!</p>
<p>
Now let’s see how this stuff actually is handled in an application. You may have a startup program in which you instantiate your classes, such as oApp, oLibrary, and so on. I do, too, but I quickly found that this isn’t where oMeta should be created, because oMeta needs to know about a database, and early in our startup process, we hadn’t handled data yet. Thus, we simply initialize oMeta in the startup so that it’s scoped properly, and then actually instantiate it in the Init() of oApp’s instantiation:</p>
<pre><font face="Courier New" size="3">* IT.PRG
* My startup program is always called IT.PRG.
*
&lt;bunches of code here&gt;

set classlib to HWAPP, HWLIB, HWCTRL, CUST addi

* Declare oMeta here even though we're going
* to instantiate it later - so it's scoped properly.
private oMeta
oMeta=.f.
wait window nowait &quot;Setting up libraries...&quot;
private oLib
oLib=createobject(&quot;LIB&quot;)
&lt;more code here&gt;

wait window nowait &quot;Initializing...&quot;
oApp.it()</font></pre>
<p>
Then, in oApp.init():</p>
<pre><font face="Courier New" size="3">&lt;bunches of code&gt;
*
* data dictionary
*
set classlib to DBCXMGR additive
* Set debugging on if we're in development mode.
if this.cMethod = &quot;DEV&quot;
 oMeta=createobject('MetaMgr',.t.)
else
 oMeta=createobject('MetaMgr',.f.)
endif
if type('oMeta') &lt;&gt; &quot;O&quot; or isnull(oMeta)
 messagebox(&quot;Unable to instantiate data dictionary. ;
   Please call your developer. Shutting down.&quot;)
 this.lWeAreDone = .t.
endif</font></pre>
<p>
(The second parameter passed to createobject is a parameter that turns debugging messages on.) </p>
<p>
Now we’re ready to use DBCx to do some data driving. Let’s use a simple form with a format and a tool tip for a text box as our first example. The database has a table named League, and the League table contains a field named cNaLeague (League Name-good thing we’re going to put a tool tip on it, eh?). </p>
<p>
In the Init of the form, we issue three commands. The first gets the ID for the League Name field, and the second and third get the format and tool tip values for that field:</p>
<pre><font face="Courier New" size="3">m.liIDOfField = oMeta.DBGetDBCKey(dbc(),'Field', ;
                'Database.Field')</font></pre>
<p>
Now that we have the ID, we can fetch one or more properties:</p>
<pre><font face="Courier New" size="3">m.lcNaFieldFormat = oMeta.DBCXGetProp( ;
           'CBmInFormat', m.liIDOfField)
m.lcToolTip = oMeta.DBCXGetProp( ;
           'CBmToolTip', m.liIDOfField)</font></pre>
<p>
Finally, we can set the properties for the field:</p>
<pre><font face="Courier New" size="3">thisform.hwTxtNaField.Format = m.lcNaFieldFormat
thisform.hwTxtNaField.ToolTip = m.lcToolTip</font></pre>
<p>
Let’s examine a different way to do this. After all, it seems like a lot of code to write for a property that, once set, may not change a lot. It might be nice to have these properties set automatically, right? You could combine both lines of code in a single expression and place it in the property sheet. The following value in the Format property would automatically update the format for the field regardless of how many times it was changed:</p>
<pre><font face="Courier New" size="3">oMeta.DBCXGetProp('CBmInFormat', ;
  oMeta.DBGetDBCKey(dbc(),'Field', 'Database.Field'))</font></pre>
<p>
In this article I’ve described the basic mechanism for using DBCx to extend the VFP 5.0 database container. Next month, I’ll look at some of those routines that ought to be data driven, and explain how DBCx can help you.  s</p>
<p>
<b>&#09;&#09;&#09;  07HENTZE.ZIP at www.pinpub.com/foxtalk</b></p>
<p>
<i>Whil Hentzen is editor of </i>FoxTalk<i>. whil@compuserve.com, whil@hentzenwerke.com.</i></p>
<P align="center"><a
href="http://www.pinpub.com/foxtalk/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about
FoxTalk and Pinnacle Publishing, visit their website at</strong> <br>
<a href="http://www.pinpub.com/foxtalk/"><strong>http://www.pinpub.com/foxtalk/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content..</font></p>

<P>This article is reproduced from the July 1997
issue of FoxTalk. Copyright 1997, by Pinnacle Publishing, Inc.,
unless otherwise noted. All rights are reserved. FoxTalk is an
independently produced publication of Pinnacle Publishing, Inc.
No part of this article may be used or reproduced in any fashion
(except in brief quotations used in critical articles and
reviews) without prior consent of Pinnacle Publishing, Inc. To
contact Pinnacle Publishing, Inc., please call (800)788-1900 or
(206)251-1900.</p>
</font></BODY>
</HTML>
