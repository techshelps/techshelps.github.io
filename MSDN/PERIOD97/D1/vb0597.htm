<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Asynchronicity </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1>Asynchronicity</h1>
<p>
Rod Stephens</p>
<p>
<i>I doubt The Police will ever cut an album with this name, but you may find asynchronicity useful. This month Rod explains how you can use asynchronous OLE servers to take advantage of the under-utilized computers in your network-and how to avoid “gotchas” such as servers never stopping or stopping too soon. </i></p>
<p>
IMAGINE spending a late night at the office crunching data while surrounded by dozens of computers that are just sitting there waiting for e-mail and twiddling their electronic thumbs. Wouldn’t it be nice if you could harness the power of those under-used machines to make your job faster? Well, guess what? Using asynchronous OLE servers, you can.</p>
<h1>To serve and protect</h1>
<p>
The idea behind OLE servers is that a <i>server </i>process provides some sort of <i>service </i>for a <i>client </i>process. The client and server can run on the same computer or on different computers.</p>
<p>
Normally, when a client calls a server, the client must wait for the server to finish before it can continue. Figure 1 shows how control flows from the client to the server and back during this kind of synchronous server call.</p>
<p><img src="rodfig02.gif"></p>
<p>
<b>Figure 1. Control flow during a synchronous server call.</b></p>
<p>
In an <i>asynchronous </i>server call, the client starts the server but doesn’t wait for it to finish. The client moves on to perform other tasks while the server does its job. When the server is finished, it sends the results to the client.</p>
<p>
If the client and server run on different computers, they can both run at full speed without waiting for each other. If the client starts several servers on different computers, they can all run at the same time. For some applications, the servers’ combined processing power can be enormous. Figure 2 shows the flow of control when a client starts three servers asynchronously.</p>
<p><img src="rodfig03.gif"></p>
<p>
<b>Figure 2. Control flow during asynchronous server calls.</b></p>
<h1>Three steps to success</h1>
<p>
In theory, creating a remote OLE server is simple using VB 4.0. In practice, there are so many little details that it’s easy to make a mistake. To keep the OLE server details and application details separate, you should build and test your servers in three distinct phases.</p>
<p>
Test the server within the same program as the client.</p>
<p>
Test the server in a separate program on the same computer as the client.</p>
<p>
Test the server remotely.</p>
<p>
During these phases server installation becomes progressively more complicated. At the same time you should be thoroughly testing your application code. By phase three, you should have worked out most of the bugs in the application so you can concentrate on the server details.</p>
<h1>Phase 1</h1>
<p>
In VB you implement an OLE server as a class that is exposed to outside programs. So, create a new class. Set its Public property to True so client applications will be able to create objects from the class when you get to phases two and three. Set the Instancing property of the class to <i>1-Creatable Single Use</i> or <i>2-Creatable MultiUse</i>. Look up Instancing in the online help to learn about the differences.</p>
<p>
Give the class whatever functions and subroutines the server will provide for clients. Declare them Public so the clients can use them.</p>
<p>
Finally, write an application around this server class and test it. The “client” part of the application should create an instance of the class and test the instance’s server functions.</p>
<h2>Phase 1 sample code</h2>
<p>
The file ASYNCSVR.ZIP, available in this month’s Subscriber Downloads at www.pinpub.com/vbd, contains separate directories for the different phases of the example application. Be sure to use the -d option when you unzip the package so the files are placed in separate directories.</p>
<p>
The Phase1 directory contains a program that uses a phase one “server” to draw Mandelbrot sets. The server-related code is in the DrawMandelbrot subroutine shown in Listing 1. This routine grabs a handle to the bitmap that will display the picture. It then creates two objects of the FractalServer class. These objects have a ServeFractal subroutine that computes Mandelbrot values for a region. DrawMandelbrot breaks the area of interest into two halves and makes each of these two server objects compute the values for one half.</p>
<p>
<b>Listing 1. During phase one, the “client” subroutine DrawMandelbrot calls the “server” class directly.</b></p>
<pre><font face="Courier New" size="3">Sub DrawMandelbrot()
        :
    ' [ Non-client/server code omitted]
        :
    ' Start &quot;server&quot; 1.
    Set svr = New FractalServer
    svr.ServeFractal Xmin, xmid, Ymin, Ymax, _
        0, 0, widmid, hgt
    ' Start &quot;server&quot; 2.
    Set svr = New FractalServer
    svr.ServeFractal xmid, Xmax, Ymin, Ymax, _
        widmid, 0, wid - widmid, hgt
    Set svr = Nothing
End Sub</font></pre>
<p>
The ServeFractal subroutine computes fractal values for a region. It passes the results back to the “client” by calling the main form’s ReturnResults subroutine. The following code fragment shows the server-related part of ServeFractal. Look in ASYNCSVR.ZIP for the full source code:</p>
<pre><font face="Courier New" size="3">Public Sub ServeFractal(...[parameters omitted]...)
        :
    ' [Calculate Mandelbrot set values for the region]
        :
    ' Send the results to the callback object.
    FractalForm.ReturnResults ...[parameters containing _ 
      the Mandelbrot data]...
End Sub</font></pre>
<p>
Back in the “client” code, ReturnResults copies the results into a byte array and uses SetBitmapBits to display the new piece of the Mandelbrot set.</p>
<p>
When you run this program, you’ll notice that it spends almost all of its time running server code. This is a good sign. After you move the servers onto different computers, the remaining client application will be very fast. With the hardest work split among several servers, the whole system should run faster. If the program is intolerably slow right now, try making the form smaller.</p>
<h1>Phase two</h1>
<p>
Before you move on to phase two, debug your application as thoroughly as possible using the phase one program. Debugging multiple processes is confusing enough without worrying about the application code.</p>
<p>
In phase two, you must break the phase one application into separate client and server programs. Put the main form and its support subroutines in the client project. Put the server class and its support routines in the server project.</p>
<h2>The server</h2>
<p>
When you run the phase one application, you’ll notice that the servers run one after the other, indicating that the calls to the servers are synchronous. It’s time to make them asynchronous.</p>
<p>
The idea is to have the initial call to the server activate a timer control and then return immediately to the client. When the timer control triggers, it starts the real server to do all the hard work.</p>
<p>
Eventually, the server will need to return results to the client. It does this with a special object provided by the client during the initial call to the server. The server uses one of this object’s public subroutines to send the results to the client. Because the object is used to call back to the client, it’s called a <i>callback </i>object. Figure 3 shows how control flows during this sequence of events.</p>
<p><img src="rodfig04.gif"></p>
<p>
<b>Figure 3. Control flow during an asynchronous server call in VB.</b></p>
<p>
Add a new form called WakerForm to the server project. Give the form a timer control named Waker. Set the timer’s Interval property to 1 and its Enabled property to False. Give the form one Public variable ServerObject declared as type Object. The server class will set ServerObject when it starts the timer.</p>
<p>
Waker’s Timer event handler is simple-but important. It unloads the WakerForm and calls ServerObject’s WakeUp subroutine to start the real data crunching. It’s critical that the server unload the form. Because VB won’t stop a program if it has a form loaded, you need to be sure the form is unloaded at some point. Otherwise, the server won’t stop, even when it’s finished. It will just “sit around” wasting resources on the server computer.</p>
<pre><font face="Courier New" size="3">Private Sub Waker_Timer()
    ' Unload this form.
    Unload Me
    ServerObject.WakeUp
End Sub</font></pre>
<p>
The server’s ServeFractal subroutine shown in Listing 2 no longer computes fractal values directly. Instead, it saves the parameters it will need later in class variables, and then enables the timer. One of the parameters is the callback object that the server will use to send results back to the client. Also, ServeFractal stores the server object in the WakerForm’s ServerObject variable so the timer control knows what object to wake up when it receives a Timer event.</p>
<p>
<b>Listing 2. The server initially saves parameters it will need later and starts the timer.</b></p>
<pre><font face="Courier New" size="3">Public TheCallback As Object
Public TheXmin As Single
Public TheXmax As Single
        :
    [other variables omitted]
        :
Sub ServeFractal(x_min As Single, x_max As Single, _
    ...[other parameters omitted]...)
Dim frm As New WakerForm
    ' Save the parameters for when we wake up.
    TheXmin = x_min
    TheXmax = x_max
        :
    Set TheCallback = cb
    ' Start Waker.
    Set frm.ServerObject = Me
    frm.Waker.Enabled = True
End Sub</font></pre>
<p>
When the timer activates, it calls the server object’s WakeUp subroutine. To keep the server class as simple as possible, WakeUp simply passes the processing request on to global subroutine ComputeFractal.</p>
<p>
ComputeFractal works almost exactly as the ServeFractal subroutine did in phase one. Instead of directly invoking FractalForm’s ReturnResults subroutine, however, ComputeFractal invokes the callback object’s ReturnResults subroutine. ReturnResults is then responsible for displaying the results:</p>
<pre><font face="Courier New" size="3">cb.ReturnResults servernum, bytes, ioff, joff, wid, hgt</font></pre>
<h2>Project options</h2>
<p>
Before you can install and run the server, you need to specify some information so the system can identify it. Select the Options command from the Tools menu in the VB development environment. Click on the dialog’s Project tab. You need to set four values on this tab.</p>
<p>
First, because you don’t want the server program to display a form when it starts, set the project’s StartMode to Sub Main. This makes VB execute the subroutine named Main when it starts the server program. Of course, you also need to create a subroutine called Main. Open a new BAS file and create one. It doesn’t need to do anything, but it must be present. The following two lines are enough:</p>
<pre><font face="Courier New" size="3">Sub Main
End Sub</font></pre>
<p>
Second, you need to set the Project Name. This name, plus the name of your server class, identifies the server for client applications. For example, if you specify “ServerProgram” as the Project Name and the server class is called ServerClass, then a client application would refer to one of these server objects as ServerProgram.ServerClass.</p>
<p>
The phase two example program (in the Phase2 subdirectory) contains four identical server classes with the catchy names Server1, Server2, Server3, and Server4. The Project Name is set to FractalServer. To create a server the client can refer to FractalServer.Server1.</p>
<p>
The third project option of interest is StartMode. Select the OLE Server option. This allows you to run the server in the VB development environment. If you don’t set this option, the server program will start, see that it has no client, and immediately stop. Finally, set the Application Description to something meaningful. In the example project this is set to “Fractal Server.” Click the OK button and you’re ready to install the server.</p>
<h2>Installing the server</h2>
<p>
To install the server, just run the server program. Because you set the project’s StartMode to OLE Server, VB will automatically register the server with the system registry.</p>
<h2>Creating server objects</h2>
<p>
Because the client and server are no longer in the same application, you must somehow tell the client where to find the server. You can take one of two approaches.</p>
<p>
First, you can select the References command from the Tools menu in the client’s VB development environment. Somewhere, probably at the bottom of the list, you’ll see the value you entered for the server’s Application Description. Find and select the server. Now you can create and use server objects in the client almost as before. For example, the following code defines and creates a fractal server object:</p>
<pre><font face="Courier New" size="3">Dim svr As New FractalServer.Server1</font></pre>
<p>
The second way you can use server objects is to create them with the CreateObject function. The following code shows how you can create a fractal server object using this method:</p>
<pre><font face="Courier New" size="3">Dim svr As Object
    Set svr = CreateObject(&quot;FractalServer.Server1&quot;)</font></pre>
<p>
When you use this method, VB can’t tell what kind of object you’re creating until it actually executes the CreateObject function. This prevents VB from performing any checks on the object until runtime. If you try to execute a server function that doesn’t exist, VB can’t tell you if a problem exists until that point.</p>
<p>
&#09;The phase two example program uses the second method. The DrawMandelbrot subroutine creates a Callback object for each server object, and then invokes the server object’s ServeFractal subroutine. The following code fragment shows how it creates a server to calculate values for the left half of the Mandelbrot set:</p>
<pre><font face="Courier New" size="3">Set cb = New Callback
Set svr = CreateObject(&quot;FractalServer.Server1&quot;)
svr.ServeFractal Xmin, xmid, Ymin, Ymax, 0, 0, _
    widmid, hgt, cb</font></pre>
<h2>Callbacks</h2>
<p>
The Callback class is quite simple. It passes on the returned data to the main form’s ReturnResults subroutine. That routine displays the results almost exactly as it did in phase one.</p>
<h2>Phase 2 sample code</h2>
<p>
The Phase2 directory in ASYNCSVR.ZIP contains separate subdirectories for the client and server applications. Load the server into the VB development environment and run it. Then load the client into another instance of the VB environment and run it as well. If all goes well, the client and server will cooperate to display the Mandelbrot set.</p>
<p>
You can set breakpoints in the client or in the server and step through the code. This is your last chance to easily debug the server application, so take advantage of it while you can.</p>
<h1>Phase two</h1>
<p>
At this point you should have working client and server applications. Now you need to install your servers across the network. The following eight sections briefly describe the necessary steps.</p>
<h2>1. Create the executable</h2>
<p>
Creating the server executable is simple. Select the <i>Make EXE File</i> command from the File menu just as you would to build any other executable.</p>
<h2>2. (Server) Install the server</h2>
<p>
Copy the executable onto the computers on which you want to run your server. If those computers don’t have VB installed, you also need to distribute VB support files. The easiest way to do this is to use the Application Setup Wizard to build an installation kit. In the Wizard’s step 6, be sure to select the check box that’s labeled “Yes, install remote OLE automation server components.”</p>
<h2>3. (Server) Allow remote access</h2>
<p>
On each server computer, start the Remote Automation Connection Manager. This program is called RACMGR32.EXE and you’ll find it in the clisvr subdirectory of your 32-bit Visual Basic installation directory.</p>
<p>
If you installed the server using a kit created by the Application Setup Wizard, the installation copied RACMGR32.EXE onto the server computer. Look in subdirectories of the Windows directory (\Windows in Windows95 or \WINNTxx in Windows NT).</p>
<p>
Once RACMGR is running, click the Client Access tab. Select the Allow All Remote Creates option and close RACMGR.</p>
<h2>4. (Server) Start the automation manager</h2>
<p>
On each server computer, run the Automation Manager, AUTMGR32.EXE. This program should be in the same place as RACMGR. AUTMGR starts network protocols needed for the client to connect to the server. Leave AUTMGR running as long as you want to use the server.</p>
<h2>5. (Server) Register the server</h2>
<p>
To register the server on the server computer, simply run the executable. The program will start and then appear to stop immediately. Before it stops, however, it places the necessary entries in the system registry so the server computer knows where the server is.</p>
<h2>6. (Client) Specify server locations</h2>
<p>
Run RACMGR on the client computer. Find the server’s name in the list of servers, select it, and click the Server Connection tab. Enter the server computer’s network address. Then select a Network Protocol that is appropriate for your network and click the Apply button.</p>
<p>
For example, to allow my client computer Beast to use a server on Beauty, I enter “Beauty” as the Network Address and “NetBIOS over NetBEUI” as the Network Protocol. If you have trouble figuring out what values to put in these fields, talk to your friendly neighborhood network administrator.</p>
<p>
Finally, press Ctrl-R or select the Remote command from the Register menu. This tells RACMGR that you want to use the remote server rather than a local copy of the server.</p>
<h2>7. (Client) Start the automation manager</h2>
<p>
Because the server uses a callback object on the client computer, the client computer needs to run AUTMGR as well. Start it and leave it running.</p>
<h2>8. (Client) Run the client</h2>
<p>
If you managed all of these steps without mistakes, you’re ready to run the client. It will use the information saved by RACMGR to contact the server computer. That computer will use the server’s registered information to locate and start the server program.</p>
<h2>Phase three sample code</h2>
<p>
You can use the same code in the Phase2 directory to test phase three. The difference is in how you install and run the programs. The sample code included with the online file accompanying this article breaks the Mandelbrot set into two pieces. On my test network I use a remote server on computer Beauty to calculate the values for one piece of the set and a local server running on the client machine Beast to calculate values for the other. If you have enough computers sitting around, you might try breaking the picture into more pieces and using a remote server on a different computer for each.</p>
<h1>Caveats</h1>
<p>
I hope this discussion and the sample programs will start you on your way to asynchronous server development. There are still a few tips you should keep in mind before you start breaking every application in sight into a client and server.</p>
<p>
First and foremost, not every application fits the asynchronous client/server mold. Good candidate applications have these properties:</p>
<p>
The application can be broken into pieces that don’t depend on each other.</p>
<p>
The pieces are time consuming.</p>
<p>
Little information needs to be passed between the client and the servers.</p>
<p>
The Mandelbrot set application fits the first two conditions perfectly, but it doesn’t fit the third as well. While the client passes the server only a few parameters, the server passes back a large array of values through the callback object. The overhead in sending so much data over the network is large and offsets some of the performance gains provided by using servers.</p>
<p>
In my tests, two asynchronous fractal servers generated the complete Mandelbrot set in about two-thirds the time needed by the phase one application. If there were no overhead in setting up the servers and passing data, and if the computers ran at the same speed, the two-server version should have taken about half as long as the phase one version.</p>
<p>
A second tip about asynchronous servers is that an object must respond promptly to requests from clients. If a computer is too busy to quickly create a server object, the client may decide that the object creation failed and give up.</p>
<p>
A more subtle problem occurs if the client starts a server and then enters into a long computation. When the server finishes, it will try to use a callback object to report its results. If the client doesn’t allow time for the callback object to do its job, the server may fail.</p>
<p>
A problem also occurs if a callback object tries to create a form while the client is displaying a modal form or dialog box. VB doesn’t allow a program to create a new form while a modal form is displayed. If the callback tries to create a new form, VB cries foul.</p>
<p>
In general, you should keep your client as small and fast as possible so it can react quickly to callbacks. Both clients and servers should avoid long computations and use DoEvents to break them into smaller pieces. s</p>
<p>
<b>&#09;&#09;&#09;   ASYNCSVR.ZIP at www.pinpub.com/vbd</b></p>
<p>
<i>Rod Stephens is president of Rocky Mountain Computer Consulting Inc., a custom software firm in Boulder, Colorado. He is the author of Visual Basic Algorithms and Visual Basic Graphics Programming, both from John Wiley &amp; Sons. 102124.33@compuserve.com.</i></p>
    <P align="center"><a
    href="http://www.pinpub.com/vbd/"><img src="Pinnacle.gif"
    border="0" width="216" height="72"></a></p>
    <P align="center"><strong>To find out more about
    Visual Basic Developer and Pinnacle Publishing, visit their
    website at</strong>: <a href="http://www.pinpub.com/vbd/"><strong>http://www.pinppub.com/vbd/</strong></a></p>
    <P align="center"><font size="1">Note: This is not
    a Microsoft Corporation website. <br>
    Microsoft is not responsible for its content.</font></p>
    <p><font size="1">This article is reproduced from the
    May 1997 issue of Visual Basic Developer. Copyright
    1997, by Pinnacle Publishing, Inc., unless otherwise noted.
    All rights are reserved. Visual Basic Developer is an
    independently produced publication of Pinnacle Publishing,
    Inc. No part of this article may be used or reproduced in any
    fashion (except in brief quotations used in critical articles
    and reviews) without prior consent of Pinnacle Publishing,
    Inc. To contact Pinnacle Publishing, Inc., please call
    (800)&nbsp;788-1900 or (206)&nbsp;251-1900.</font></p>
</font></BODY>
</HTML>
