<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Developing Active Controls for the Internet with ATL 2.0 </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1>Developing Active Controls for the Internet with ATL 2.0</h1>
<p>
Mark Davis</p>
<p>
<i>You’ve probably heard about a new template library from Microsoft that’s lean and mean compared to MFC code. While  primarily designed to help you avoid clogging your Internet bandwidth with downloaded active content, your desktop applications can also benefit from this library. This article shows you how to write small, fast, lightweight Active controls with Microsoft’s latest version of the Active Template Library (ATL 2.0).</i></p>
<p>
THE Active Template Library (ATL) is a C++ template-based library that Microsoft has created specifically for the task of creating Component Object Model (COM) objects. A base technology of OLE, COM is the binary standard that defines how applications interact with other objects. These objects can be within a single process, in other processes, or on remote machines. Using multiple inheritance and templates in ATL lends itself well to the development of small and fast COM objects.</p>
<p>
ATL 1.1 provides support for developing COM objects, aggregation, dual interfaces, connection points, enumerators, and tear-off interfaces. ATL supports packaging a COM server as a DLL, executable, or service, and supports the single, apartment, and free-threaded OLE threading models. ATL 2.0, which is in beta, will provide additional support for developing Active controls. It includes an ATL AppWizard to generate skeleton projects and an ATL Object Wizard component to help you create COM objects, Active controls, and property page objects. ATL provides default implementations for many of the Active control interfaces and a set of MFC-like classes to provide user interface elements such as windows and dialog boxes. If you’re using ATL 1.1, you may need to make a few changes to your existing code, so read the accompanying documentation. ATL 2.0 will be provided with future versions of Microsoft Visual C++, but for now, see the sidebar on ATL resources to find out where you can download the beta version, which requires Visual C++ 4.2b. </p>
<p>
It’s important to understand that ATL is designed to produce small, fast code with minimal dependencies. That doesn’t necessarily make it easy to use. For example, using C++ templates can be daunting because the syntax is unusual, but templates do provide an ideal and flexible solution. To help with the learning curve, I’d suggest that you study the documentation and the excellent samples provided with ATL. Once you’ve familiarized yourself with the important ATL classes and understand the features they provide, you’ll quickly be on your way to writing Active controls.</p>
<h2>So what’s an Active control? </h2>
<p>
An Active control, formerly known as an OLE control, is a COM object which, at a minimum, supports the IUnknown interface and self-registration. It may also provide some or all of the following functionality:</p>
<p>
Has a user interface and is visible at runtime.</p>
<p>
Provides a programmable interface by supporting methods and properties through OLE automation.</p>
<p>
Provides support for being hosted within an OLE control container.</p>
<p>
Can fire events.</p>
<p>
Provides a means of property persistence.</p>
<p>
Provides access to properties through property pages.</p>
<p>
Supports licensing through the IClassFactory2 interface.</p>
<p>
Supports dragging and dropping within a container.</p>
<p>
Many of these features extend the functionality already defined for OLE compound documents such as structured storage, object embedding, and in-place activation. They also extend features found in OLE automation such as methods and properties. The important OLE interfaces involved in providing these features are listed in Table 1.</p>
<p>
<b>Table 1. Traditional OLE control interfaces.</b></p>
<table>
<tr valign=top>
<td>
<b>Interface</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
IClassFactory2</td>
<td>
Object creation with licensing</td>
</tr>
<tr valign=top>
<td>
IOleControl</td>
<td>
Keyboard mnemonics, ambient properties, and events</td>
</tr>
<tr valign=top>
<td>
IOleObject</td>
<td>
Provides basic functionality to, and communications with, a container</td>
</tr>
<tr valign=top>
<td>
IDataObject</td>
<td>
Data transfer and notifications of changes</td>
</tr>
<tr valign=top>
<td>
IViewObject2</td>
<td>
Allows an object to display itself without passing a data object</td>
</tr>
<tr valign=top>
<td>
IOleInPlaceActiveObject</td>
<td>
Manipulates the object while it’s active</td>
</tr>
<tr valign=top>
<td>
IOleInPlaceObject</td>
<td>
Activates and deactivates the in-place object</td>
</tr>
<tr valign=top>
<td>
IProvideClassInfo[2]</td>
<td>
Provides access to an object’s type library information</td>
</tr>
<tr valign=top>
<td>
IDispatch</td>
<td>
OLE automation (scripting, methods, and properties)</td>
</tr>
<tr valign=top>
<td>
IConnectionPointContainer</td>
<td>
Outgoing interfaces (events)</td>
</tr>
<tr valign=top>
<td>
IPropertyPage</td>
<td>
A property page object</td>
</tr>
<tr valign=top>
<td>
ISpecifyPropertyPages</td>
<td>
A property sheet and at least one property page</td>
</tr>
<tr valign=top>
<td>
IPerPropertyBrowsing</td>
<td>
Browsing property information</td>
</tr>
<tr valign=top>
<td>
IPersistStorage</td>
<td>
Storage-based persistence</td>
</tr>
<tr valign=top>
<td>
IPersistStream[Init]</td>
<td>
Stream-based persistence</td>
</tr>
</table><br>
<p>
The original Microsoft OLE Controls specification required that an OLE control support a large number of interfaces if it is to be hosted by an OLE control container. These requirements have now been relaxed and the minimum requirement is to support the IUnknown interface and self-registration.</p>
<p>
The Microsoft OLE Controls 96 specification provides a number of features to allow lightweight Active controls to be developed for use over the Internet. These new features include:</p>
<p>
Quick activation.</p>
<p>
Inactive controls.</p>
<p>
Windowless controls.</p>
<p>
Drawing optimizations.</p>
<p>
Some of the new OLE Controls 96 interfaces are listed in Table 2.</p>
<p>
<b>Table 2. New OLE (Active) Control 96 interfaces.</b></p>
<table>
<tr valign=top>
<td>
<b>Interface</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
IViewObjectEx</td>
<td>
Supports enhanced, flicker-free drawing for irregular and transparent objects</td>
</tr>
<tr valign=top>
<td>
IPointerInactive</td>
<td>
Enables an inactive object to participate in mouse pointer interaction</td>
</tr>
<tr valign=top>
<td>
IQuickActivate</td>
<td>
Provides single-transaction negotiation of container and control interfaces and properties</td>
</tr>
<tr valign=top>
<td>
IOleInPlaceObjectWindowless</td>
<td>
Allows a container to dispatch user input to an in-place active windowless object and support for drag and drop</td>
</tr>
<tr valign=top>
<td>
IOleInPlaceSiteWindowless</td>
<td>
Allows a windowless object to get services from its container for drawing</td>
</tr>
<tr valign=top>
<td>
IOleInPlaceSiteEx</td>
<td>
Supports flicker-free activation/deactivation</td>
</tr>
<tr valign=top>
<td>
IObjectWithSite</td>
<td>
Provides a simple way to support communication between an object and its site in the container (lightweight IOleObject)</td>
</tr>
<tr valign=top>
<td>
IOleUndoUnit, </td>
<td>
 Supports multi-level undo and redo</td>
</tr>
<tr valign=top>
<td>
IOleParentUndoUnit,</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
IOleUndoManager</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
ICategorizeProperties</td>
<td>
Allows a container to categorize a control’s properties</td>
</tr>
<tr valign=top>
<td>
IObjectSafety</td>
<td>
Supports the ability to retrieve and set an object’s safety levels.</td>
</tr>
</table><br>
<p>
In addition to the new features described in the OLE Controls 96 specification, the ActiveX SDK defines a number of new interfaces that are specific to the Internet and are of interest to Active control developers. Some of these are listed in Table 3.</p>
<p>
<b>Table 3. New ActiveX interfaces.</b></p>
<table>
<tr valign=top>
<td>
<b>Interface</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
IPersistPropertyBag, </td>
<td>
Support for textual persistence of control</td>
</tr>
<tr valign=top>
<td>
IPropertyBag</td>
<td>
properties</td>
</tr>
</table><br>
<table>
<tr valign=top>
<td>
IAsyncMoniker, </td>
<td>
Support for asynchronous binding</td>
</tr>
<tr valign=top>
<td>
IBindHost,</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
IBinding,</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
IBindStatusCallBack</td>
<td>
</td>
</tr>
</table><br>
<table>
<tr valign=top>
<td>
ICatRegister, </td>
<td>
Support for component categorization</td>
</tr>
<tr valign=top>
<td>
ICatInformation</td>
<td>
</td>
</tr>
</table><br>
<h2>Which way to Active</h2>
<p>
One of the first things most developers ask when preparing to build their first Active control is whether or not they have to use the Active Template Library. In fact there are several solutions, one of which is ATL. The route you take depends on your development requirements. If you’re writing Active controls for the Internet, then you’re going to want to reduce the size of your code and minimize its dependency on DLLs; otherwise you’ll frustrate users with excessive download times. ATL is well suited for size efficiency because it gives you full control over how much or how little functionality you want to implement. With ATL you derive only from the interfaces you want to support. ATL also uses thin wrapper classes and Win32 functions for all your user interface needs.</p>
<p>
Before I explain how to use the Active Template Library, I’ll examine some of the other Active control solutions available to Visual C++ developers. If you use the Microsoft Foundation Classes (MFC), the quickest and easiest option is to use the Visual C++ OLE ControlWizard to create a skeleton MFC Active control. You can then easily add methods, properties, and events using the ClassWizard. It’s also easy to add property pages. If you use MFC 4.2, then additional OLE Controls 96 support is provided for you. MFC may be convenient, but any Active controls created with MFC are dependent on the MFC DLL, a file that’s almost 1M in size.</p>
<p>
For non-MFC users, the ActiveX SDK BaseCtl framework provides an intermediate solution for developing Active controls. This framework also includes support for the OLE Controls 96 specification and comes with a number of sample Active controls. The SDK requires knowledge of OLE interfaces and ODL/IDL, but some of the samples might act as a useful foundation for your own Active controls. Unfortunately, this solution still isn’t flexible and is based on unsupported sample code.</p>
<h2>ATL under the hood</h2>
<p>
Here’s a brief tour of some of the classes, functions, and macros available in the latest version of the Active Template Library. Because ATL is a large library, I haven’t listed every class, function, or macro. For example, ATL provides string conversion macros, helper functions, and many macros that I don’t have space to cover here. Please read the documentation provided with ATL 2.0 for a complete list.</p>
<h4>COM implementation classes</h4>
<p>
<b>CComObjectRoot </b>and<b> CComObjectRootEx</b>-These classes manage reference counting and provide a default implementation of IUnknown::QueryInterface using your interface map. Your class must derive from one of these classes.</p>
<p>
<b>CComObject </b>and<b> CComAggObject</b>-These classes provide an implementation of IUnknown. Your COM object is created from this class when the class factory CreateInstance() is called.</p>
<p>
<b>CComCoClass</b>-This class provides a default implementation of IClassFactory. Your class must derive from this class if your COM object is created externally, such as when you make a call to CoCreateInstance.</p>
<p>
<b>IDispatchImpl</b>-Implements the IDispatch interface to provide support for dual interfaces.</p>
<p>
<b>IConnectionPointContainerImpl</b> and <b>IConnectionPointImpl</b>-These classes implement their respective interfaces to provide support for connection points.</p>
<h4>Active control implementation classes</h4>
<p>
<b>CComControl</b>-Provides the ATL implementation of a control, including helper functions and interface pointers. This class is derived from CWindowImpl. Your class must derive from this if you are implementing an Active control. The Active control interfaces are implemented by their respective <i>Interface</i>Impl classes; for example, IOleControlImpl provides an implementation of IOleControl.</p>
<h4>User interface classes</h4>
<p>
<b>CWindow</b>-This class provides a means of accessing windows and is essentially a thin version of the MFC CWnd class.</p>
<p>
<b>CWindowImpl</b>-Allows the Active control to create and subclass windows, as well as provides a simple message map facility.</p>
<p>
<b>CDialogImpl</b>-Allows you to create modal and modeless dialog boxes.</p>
<h4>Support classes</h4>
<p>
<b>CComPtr</b> and<b> CComQIPtr</b>-These classes implement smart interface pointers, calling AddRef() or QueryInterface() on construction and Release() when the object is destroyed.</p>
<p>
<b>CComVariant</b> and <b>CComBSTR</b>-Provide wrappers for the respective OLE automation data types.</p>
<p>
<b>CRegKey</b>-Provides an easy way to access system registry keys.</p>
<h3>Map macros</h3>
<p>
<b>Object</b>-The object map is used to specify the COM objects implemented by your server and provides registration information about each one. The BEGIN_OBJECT_MAP, OBJECT_ENTRY, and END_OBJECT_MAP macros are used to build the object map. This is updated by the ATL Object Wizard.</p>
<p>
<b>Interface</b>-The interface map is used to specify the interfaces supported by each object and is used by the default implementation of QueryInterface. The BEGIN_COM_MAP, COM_INTERFACE_ENTRY, and END_COM_MAP macros are used to build the interface map.</p>
<p>
<b>Connection Point</b>-The connection point map is used to specify the connection points your object supports and is used by the IConnectionPointContainerImpl class, which your class must derive from. The BEGIN_CONNECTION_MAP, CONNECTION_POINT_ENTRY, and END_CONNECTION_MAP macros are used to build the connection point map.</p>
<p>
<b>Property</b>-The property map is used to specify which properties and property pages are implemented by your object. The BEGIN_PROPERTY_MAP, PROP_ENTRY, PROP_PAGE, and END_PROPERTY_MAP macros are used to build the property map. The IPersistStreamInitImpl and IPersistPropertyBagImpl classes use the property map when loading and saving persistent properties. The IPerPropertyBrowsingImpl and ISpecifyPropertyPagesImpl classes also use this information.</p>
<p>
<b>Message</b>-The message map is used to specify how messages sent to the object’s window are to be handled. The BEGIN_MSG_MAP, MESSAGE_HANDLER, COMMAND_HANDLER, NOTIFY_HANDLER, and END_MSG_MAP macros are used to build the message map. Other macros are used to provide additional support and to redirect messages to other message maps.</p>
<h2>Your first ATL Active control</h2>
<p>
When installed, ATL adds a custom AppWizard to your list of Visual C++ project types. From within Visual C++, select New from the File menu, then choose Project Workspace. Select the ATL AppWizard project type and enter a name for your project. When you press the Create button, you’ll be presented with the ATL COM AppWizard dialog box.</p>
<p>
You can accept the default project options for an Active control project. When you’re writing controls, you’ll implement the server as a DLL so you won’t need proxy/stub code. Choose ÒSupport MFCÓ if you want to use MFC functionality such as CString or the collection classes.</p>
<p>
At this point, the project doesn’t contain any objects-you’ll add these using the ATL Object Wizard. To do this, select Component from the Insert menu and select the ATL page. Select the ATL Object Wizard component and press the Insert button.</p>
<p>
The first step in the wizard allows you to specify the type of object to insert from among the following:</p>
<table>
<tr valign=top>
<td>
Simple Object</td>
<td>
A COM object.</td>
</tr>
<tr valign=top>
<td>
Full Control</td>
<td>
An Active control that supports the full set of container interfaces.</td>
</tr>
<tr valign=top>
<td>
Internet Explorer Control</td>
<td>
An Active control that supports the Internet Explorer interfaces.</td>
</tr>
<tr valign=top>
<td>
Property Page</td>
<td>
A property page object.</td>
</tr>
<tr valign=top>
<td>
Dialog</td>
<td>
A dialog box object.</td>
</tr>
</table><br>
<p>
Select either Full Control or Internet Explorer Control and press the Next button. </p>
<p>
In the next step, you can specify a variety of properties for the object. On the Names page, provide the object, Prog ID, and filenames for your object. On the Attributes page, specify the threading model, interface type, and, if you wish to support aggregation, ISupportErrorInfo and connection points. Select connection point support because this is required for supporting events. On the Miscellaneous page, specify various control options such as if your control will be subclassing a windows control. Finally, on the Stock Properties page, specify the stock properties you want to support.</p>
<p>
You can build the DLL at this point. To see your control, use Internet Explorer to display the HTML file created by the ATL Object Wizard. You’ll notice that the HTML OBJECT tag is used to create the object, referencing the CLSID of your COM object.</p>
<p>
The first thing you’ll notice is that the control displays a rectangle containing some text. This drawing code is provided in your control classes OnDraw member. As in MFC, this virtual function is called by the default handler for the WM_PAINT message. By overriding virtual functions such as this one and adding handlers for other windows messages, you’ll be able to add real functionality to your control.</p>
<h2>Adding methods and properties</h2>
<p>
If you currently develop Active controls using MFC, you probably use the ClassWizard to add methods and properties to your control. Unfortunately, you have to do this manually when using ATL. It involves the following steps:</p>
<p>
Add the method and property to the interface definition in your IDL file:</p>
<pre><font face="Courier New" size="3">interface IMyControl : IDispatch
{
&#09;[id(1)]HRESULT MyMethod();
&#09;[propput, id(2), helpstring(&quot;Set MyProperty&quot;)]
&#09;HRESULT MyProperty( [in]BSTR Text );
&#09;[propget, id(2), helpstring(&quot;Get MyProperty&quot;)]
&#09;HRESULT MyProperty( [out,retval]BSTR* pText );
 }</font></pre>
<p>
Add method and property declarations to the class definition:</p>
<pre><font face="Courier New" size="3">class CMyControl
&#09;...
&#09;// IMyControl
public:
&#09;STDMETHOD(MyMethod)();
&#09;STDMETHOD(put_MyProperty)(BSTR Text);
&#09;STDMETHOD(get_MyProperty)(BSTR* pText);
};</font></pre>
<p>
Implement the method and property:</p>
<pre><font face="Courier New" size="3">STDMETHODIMP CMyControl::MyMethod()
{
&#09;// Do something
&#09;return S_OK;
}

STDMETHODIMP CMyControl::put_MyProperty(BSTR Text)
{
&#09;// Do something
&#09;return S_OK;
}

STDMETHODIMP CMyControl::get_MyProperty
             (BSTR* pText)
{
&#09;// Do something
&#09;return S_OK;
}</font></pre>
<p>
Add a PROP_ENTRY to the property map:</p>
<pre><font face="Courier New" size="3">BEGIN_PROPERTY_MAP(CMyControl)
&#09;PROP_ENTRY(&quot;MyProperty&quot;,2, CLSID_MyControl)
END_PROPERTY_MAP()</font></pre>
<h2>Adding events</h2>
<p>
To fire events from your control, you’ll need to provide connection point support and an outgoing event interface for the container. The ATL Object Wizard will provide the necessary code if you specify connection point support. Given this connection support code, your class will derive from IConnectionPointContainerImpl, will contain an interface map entry for this interface, and will have an empty connection point map. Follow these steps to add an event to your control:</p>
<p>
Add the outgoing event interface to the library definition in your IDL file:</p>
<pre><font face="Courier New" size="3">library MYCTLLib
{
&#09;...
&#09;[
&#09;&#09;uuid(&lt;your new CLSID goes here&gt;),
&#09;&#09;helpstring(&quot;MyControl Event Interface&quot;)
&#09;]
&#09;dispinterface MyEvents
&#09;{
&#09;&#09;properties:
&#09;&#09;methods:
&#09;&#09;[id(1), helpstring(&quot;My Event&quot;)]
&#09;&#09;void MyEvent();
&#09;};
&#09;...
&#09;coclass MyControl
&#09;{
&#09;&#09;...
&#09;&#09;[default,source] dispinterface MyEvents;
&#09;};
};</font></pre>
<p>
Compile the IDL file and use the ProxyGen component to generate a connection point helper class from your type library. To use the ProxyGen component, select Component from the Insert menu, select the ATL page, and double-click the ProxyGen icon. Browse for your type library and select the event interface. Make sure the connection point proxy type is selected. ProxyGen reads the type library and creates an IConnectionPointImpl-derived class based on the selected interface, from which you will then derive your object. For each method in your event interface, a function will be created that you can call to fire the event. </p>
<p>
Add the proxy class to your list of inherited base classes. Deriving from this class will allow you to call the proxy methods to fire an event:</p>
<pre><font face="Courier New" size="3">class CMyControl :
&#09;...
<b>&#09;</b>public CProxyMyEvents&lt;CMyControl&gt;
{</font></pre>
<p>
Add support for IProvideClassInfo2 to expose the event interface. Containers will query this interface for the object’s type library. Internet Explorer uses this interface when interpreting any VBScript event handlers in your HTML file:</p>
<pre><font face="Courier New" size="3">#include &quot;CPMyCtl.h&quot;
...
class CMyControl :
&#09;...
&#09;public IProvideClassInfo2Impl&lt;&amp;CLSID_MyControl, 
         &amp;DIID_MyEvents, &amp;LIBID_MYCTLLib&gt;
{
...
&#09;COM_INTERFACE_ENTRY(IProvideClassInfo)
&#09;COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()</font></pre>
<p>
Add a CONNECTION_POINT_ENTRY to the empty connection point map. When Internet Explorer calls IConnectionPointContainer::FindConnectionPoint, the ATL implementation will use this map:</p>
<pre><font face="Courier New" size="3">BEGIN_CONNECTION_POINT_MAP(CMyControl)
&#09;CONNECTION_POINT_ENTRY(DIID_MyEvents)
END_CONNECTION_POINT_MAP()</font></pre>
<p>
To quickly test the event, add the following code to your OnDraw function:</p>
<pre><font face="Courier New" size="3">&#09;
&#09;...
&#09;MyEvent();
&#09;return S_OK;
}</font></pre>
<p>
Then add the following VBScript to the HTML file created by the ATL Object Wizard:</p>
<pre><font face="Courier New" size="3">...
&lt;SCRIPT LANGUAGE=&quot;VBScript&quot;&gt;
&lt;!--
Sub MyControl_MyEvent()
&#09;MsgBox(&quot;Event!&quot;)
End Sub
--&gt;
&lt;/SCRIPT&gt;
&#09;&lt;/HEAD&gt;
...</font></pre>
<p>
You should see the message box when you run Internet Explorer with the test HTML page. If not, check to make sure the Internet Explorer safety level is set to Medium.</p>
<h2>Debugging</h2>
<p>
An invaluable debugging aid is the trace output from the default implementation of QueryInterface, provided by the ATL CComObjectBaseRoot class. This will generate a debug message each time QueryInterface is invoked. To enable this facility, place the following line before the ATLCOM.H header file (such as in STDAFX.H):</p>
<pre><font face="Courier New" size="3">#define _ATL_DEBUG_QI</font></pre>
<p>
You can provide your own debug trace output by using the ATLTRACE macro.</p>
<h2>Conclusion</h2>
<p>
Although I haven’t covered everything, I hope you can see the power of the Active Template Library for creating small Active controls for use on the Internet. Not only can you start providing a new generation of active content for your Web pages, but you can also use ATL to create full controls that can be hosted in control containers such as Microsoft Visual Basic. s</p>
<p>
<b>&#09;&#09;&#09;   DAVIS03.ZIP at www.pinpub.com/vcd</b></p>
<p>
<b>ATL Resources</b></p>
<p>
If you’re new to COM there’s no need to feel overwhelmed! Kraig Brockschmidt provides an excellent introduction to COM and OLE in the first two chapters of his definitive book, Inside OLE, 2nd edition.</p>
<p>
You can also learn a lot from the ATL 2.0 documentation. It contains a complete list of classes, functions, and macros.</p>
<p>
See the ActiveX SDK help for more information on ActiveX interfaces, asynchronous monikers, safety levels, code-signing, and downloadable files.</p>
<p>
<b>Useful Web links</b>
<ul>
<li>
ATL 2.0 download site-http://www.microsoft.com/visualc/prodinfo<br><br></li>
<li>
COM Specification and other useful OLE articles-http://www.microsoft.com/oledev/articles.stm<br><br></li>
<li>
ActiveX Controls Overview-http://www.microsoft.com/intdev/controls/controls.htm<br><br></li>
<li>
ActiveX SDK-http://www.microsoft.com/intdev/sdk<br><br></li>
<li>
ActiveX Control Gallery-http://www.microsoft.com/activex/gallery</li>
</ul>
<p>
<i>Mark Davis specializes in Microsoft Visual C++, Microsoft Foundation Classes, ActiveX, OLE, and COM. This article is dedicated to everyone at Microsoft Developer Support in the U.K.</i></p>
<p>
<i>http://www.geocities.com/SiliconValley/Heights/1720.</i></p>
<P align="center"><a
    href="http://www.pinpub.com/vbd/"><img src="Pinnacle.gif"
    border="0" width="216" height="72"></a></p>
    <P align="center"><strong>To find out more about
    Visual C++ Developer and Pinnacle Publishing, visit their
    website at</strong>: <a href="http://www.pinpub.com/vbd/"><strong>http://www.pinppub.com/vcd/</strong></a></p>
    <P align="center"><font size="1">Note: This is not
    a Microsoft Corporation website. <br>
    Microsoft is not responsible for its content.</font></p>
    <p><font size="1">This article is reproduced from the
    March 1997 issue of Visual C++ Developer. Copyright
    1997, by Pinnacle Publishing, Inc., unless otherwise noted.
    All rights are reserved. Visual C++ Developer is an
    independently produced publication of Pinnacle Publishing,
    Inc. No part of this article may be used or reproduced in any
    fashion (except in brief quotations used in critical articles
    and reviews) without prior consent of Pinnacle Publishing,
    Inc. To contact Pinnacle Publishing, Inc., please call
    (800)&nbsp;788-1900 or (206)&nbsp;251-1900.</font></p>
</font></BODY>
</HTML>
