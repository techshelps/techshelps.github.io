<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Expand Your Outlook with Access 97 </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1>Expand Your Outlook with Access 97</h1>
<p>
David M. Shank</p>
<p>
<i>Microsoft Office 97 includes a new desktop information manger called Outlook. Using VBA, you can now incorporate Outlook contacts, scheduling, mail, tasks, and to-do lists into your Access 97 applications. This article presents a brief overview of the Outlook object model and demonstrates how to incorporate Outlook objects in your Access applications.</i></p>
<p>
If you’ve ever tried to build your own contact management, scheduling, task management, or e-mail functionality into an Access application, you know how difficult it can be. Even if you’ve used Schedule Plus to add similar features to an Access application, you know it still takes a lot of work to get it right. With the release of Office 97, you now have a powerful desktop information manager at your disposal that exposes a rich and coherent object model to other applications. You can use VBA code to manipulate the objects in Outlook and, in many cases with just a few lines of code, incorporate Outlook functionality into your Access 97 applications.</p>
<h2>Understanding the Outlook object model</h2>
<p>
For the purposes of this article, I’ll discuss only the Application object, the NameSpace object, and several key features of the Folders and Items collections. Figure 1 shows an overview of the Outlook object model.</p>
<p><img src="outlook.gif"></p>
<p>
<b>Figure 1. The Outlook object model contains a hierarchy of objects and collections.</b></p>
<p>
You access Outlook objects from within Access by first setting a reference to the Microsoft Outlook 8.0 Object Library using the References dialog box. (You can also “late-bind” the Outlook type library by using the CreateObject or GetObject functions to return an Outlook Application object.) You can then manipulate Outlook objects by setting a reference to the Application object. Once you have a reference to the Application object, you can create any Outlook Item object using the Application object’s CreateItem method. (Outlook exposes a top-level Application object from which all other Outlook objects are accessible.) You can create Item objects representing a mail message, an appointment, a contact, a journal entry, and others. For example, the following simple procedure accepts name, subject, and message strings and uses them to create and send a mail message using a MailItem object:</p>
<pre><font face="Courier New" size="3">Sub CreateNewMail(strRecip As String, _
 strSubject As String, strMessage As String)
    Dim OLApp as OutLook.Application
    Dim objNewMail As MailItem 

    Set OLApp = New OutLook.Application
    Set objNewMail = OLApp.CreateItem(olMailItem)
    With objNewMail
        .Recipients.Add strRecip
        .Recipients.ResolveAll
        .Subject = strSubject
        .Body = strMessage
        .Send
    End With
End Sub</font></pre>
<p>
To include multiple recipients, execute the Recipients collection Add method for each person you want included.</p>
<p>
In addition to the CreateItem method, you can use the GetNameSpace method to return the NameSpace object and use it to access existing Outlook items, default folders, and data sources owned by other users. Outlook exposes a Folders collection which, by default, contains a folder representing each major class of Outlook functionality. Each folder contains a collection of Items of the type contained by the specified folder. For example, Outlook maintains an Inbox folder that contains all the MailItem object Items in your Outlook Inbox. Outlook Item objects can represent mail messages, appointments, contacts, journal entries, notes, and more.</p>
<p>
At this time, Microsoft’s Mail Application Programming Interface (MAPI) is the only NameSpace data source supported. </p>
<h2>Overview of the sample database and code examples</h2>
<p>
The OLSAMPLE.MDB sample database, included with this month’s Subscriber Downloads, illustrates several techniques for incorporating Outlook functionality into your Access 97 applications. When you open the database the Customers form is displayed (see Figure 2). OLSAMPLE.MDB uses the Customers table and Customers form imported from the Northwind sample database that ships with Access. The Customers form ShortcutMenuBar property is set to the name of a custom commandbar object named CustomersCustomPopup. The controls on the custom pop-up commandbar execute custom procedures stored in the modOutlookCode module. One way to use the functionality illustrated here might be to browse customer records to locate a specific customer (for example, when you receive a telephone call from a contact at a specific company). You could then create an Outlook Item object to take further action based on your conversation with the customer.</p>
<p><img src="cust.gif"></p>
<p>
<b>Figure 2. The Customers form from OLSAMPLE.MDB. The code attached to this form allows you to manipulate various Outlook objects based on the information contained in the current record.</b></p>
<p>
You access various Outlook features from the form’s pop-up menu. Figure 3<b> </b>shows the options available from the pop-up menu.</p>
<p><img src="popup.gif"></p>
<p>
<b>Figure 3. The Customers form pop-up menu provides access to procedures that manipulate Outlook objects. Each command on the pop-up menu has its OnAction property set to a custom procedure stored in the modOutlookCode module.</b></p>
<p>
With the exception of the Send Quick Mail command, the examples in the sample application assume that you want to access an Outlook object and perform some action using information from the current record. Consequently, the selected Outlook object’s properties are populated with information from the current record. The following sections discuss how each command on the pop-up menu works. I begin the discussion with a Simple Case example that uses a custom procedure for accessing basic Outlook functionality.</p>
<h3>A simple case</h3>
<p>
Before I delve into the custom procedures I want to illustrate the most basic way to invoke Outlook objects from within Access. It’s a trivial exercise to open and display an empty Outlook object. For example, the following procedure accepts an argument representing an Outlook object Item type constant and uses that argument to display the specified Outlook object:</p>
<pre><font face="Courier New" size="3">Sub DisplayNewObject(intObjectType As Integer)
    Dim OLApp As Outlook.Application
    Dim objMail As MailItem
    Dim objAppt As AppointmentItem
    Dim objContact As ContactItem
    Dim objTask As TaskItem
    Dim objJournal As JournalItem
    Dim objNote As NoteItem
    Dim objPost As PostItem
    Dim strMessage As String
    
    ' Initialize the Outlook Application variable.
    Set OLApp = New Outlook.Application
    
    ' Create an object reference depending on 
    ' the value of the intObjecttype argument.
    Select Case intObjectType
        ' Create MailItem object.
        Case olMailItem
            Set objMail = _
             OLApp.CreateItem(intObjectType)
            objMail.Display
        ' Create AppointmentItem object.
        Case olAppointmentItem
            Set objAppt = _
             OLApp.CreateItem(intObjectType)
            objAppt.Display
        ' Create ContactItem object.
        Case olContactItem
            Set objContact = _
             OLApp.CreateItem(intObjectType)
            objContact.Display
        ' Create TaskItem object.
        Case olTaskItem
            Set objTask = _
             OLApp.CreateItem(intObjectType)
            objTask.Display
        ' Create JournalItem object.
        Case olJournalItem
            Set objJournal = _
             OLApp.CreateItem(intObjectType)
            objJournal.Display
        ' Create NoteItem object.
        Case olNoteItem
            Set objNote = _
             OLApp.CreateItem(intObjectType)
            objNote.Display
        ' Create PostItem object.
        Case olPostItem
            Set objPost = _
             OLApp.CreateItem(intObjectType)
            objPost.Display
        Case Else
        If intObjectType &gt; 6 Then
            strMessage = &quot;Inavlid Object Type.&quot; &amp; _
             vbCrLf
            strMessage = strMessage &amp; _
             &quot;Please use a value between 0 and 6&quot; &amp; _
             vbCrLf
            strMessage = strMessage &amp; _
             &quot;or an Outlook object type constant.&quot;
            MsgBox strMessage, vbExclamation, _
             &quot;Invalid Object Type Parameter&quot;
        End If
    End Select
End Sub</font></pre>
<h3>Creating public application and namespace object references</h3>
<p>
Rather than re-create the required Application and NameSpace object references in each procedure, I’ve dimensioned variables for these objects in the General Declarations section of the modOutlookCode module:</p>
<pre><font face="Courier New" size="3">Public gOLApp As Outlook.Application
Public gOLNameSpace As NameSpace</font></pre>
<p>
These variables are initialized in the InitializeOutlook procedure. Each custom procedure that uses these object variables first determines if the Application object already exists and, if not, calls the InitializeOutlook procedure:</p>
<pre><font face="Courier New" size="3">If gOLApp Is Nothing Then
    InitializeOutlook
End If

Function InitializeOutlook() As Boolean
    Set gOLApp = New Outlook.Application
    Set gOLNameSpace = gOLApp.GetNameSpace(&quot;MAPI&quot;)
End Function</font></pre>
<h3>Creating a new appointment</h3>
<p>
Imagine that you’re an employee of the Northwind Traders Company. In the middle of a busy day you get a telephone call from Paula Wilson, your contact at the Rattlesnake Canyon Grocery. She wants to meet with you about a large order she’s going to place with your company. After locating Paula’s record, you right-click on the Customers form and select Create New Appointment from the custom pop-up menubar, completing the information in the Outlook New Appointment dialog box. Not only is this a powerful and useful addition to your Customers form, but it’s also easily implemented with just a few lines of code. </p>
<p>
First, the OnAction property for the Create New Appointment commandbar button calls the CreateAppointment custom procedure. CreateAppointment creates a new AppointmentItem object using the Application object’s CreateItem method:</p>
<pre><font face="Courier New" size="3">Set objNewAppt = gOLApp.CreateItem(olAppointmentItem)</font></pre>
<p>
Next, the procedure uses the Add method of the AppointmentItem Recipients collection to add the contact name from the current record. It then sets the AppointmentItem’s Subject property using data from the current record’s ContactName and CompanyName fields. Finally, it displays the new AppointmentItem object for you to complete:</p>
<pre><font face="Courier New" size="3">With objNewAppt
    .Recipients.Add Forms!Customers!ContactName
    .Subject = &quot;Meet with &quot; &amp; _
      Forms!Customers!ContactName &amp; &quot; from &quot; _
        &amp; Forms!Customers!CompanyName
    .Display
End With</font></pre>
<p>
That’s all there is to it. Imagine trying to build this kind of functionality into your Access application without the benefit of the programmable Outlook object model.</p>
<h3>Taking notes on your customer contact</h3>
<p>
After you schedule the appointment with Paula Wilson, she proceeds to talk with you about specific items she wants to cover during the upcoming meeting. You want to take careful notes regarding the issues raised by your customer to make sure you gather necessary information prior to the meeting.</p>
<p>
To record notes regarding the conversation with your customer, you again right-click on the Customers form (still displaying the record for the Rattlesnake Canyon Grocery) and select the pop-up menu item for Notes: Customer Phone Call. The OnAction property for this menu item command button executes the CreateCustomerJournalEntry procedure. This procedure creates a new JournalItem object, uses the information in the current record of the Customers form to set several properties of the new object, and then displays the new JournalItem object using Outlook to let you record your notes of the telephone conversation. Figure 4<b> </b>shows an example of a new Outlook JournalItem.</p>
<p><img src="newjrnl.gif"></p>
<p>
<b>Figure 4. A new JournalItem object for Rattlesnake Canyon Grocery.</b></p>
<p>
Just as in the previous example, the CreateCustomerJournalEntry procedure first checks to see if the Outlook Application object variable has been initialized and then creates a new JournalItem object using the following code:</p>
<pre><font face="Courier New" size="3">Set objJournalItem = gOLApp.CreateItem(olJournalItem)</font></pre>
<p>
The JournalItem object variable is used in a With/End With block to set several properties of the JournalItem object. In addition, the code starts the object’s timer so you can also track the time spent on the telephone call:</p>
<pre><font face="Courier New" size="3">With objJournalItem
    .Importance = olImportanceNormal
    .ContactNames = Forms!Customers!ContactName
    .Companies = Forms!Customers!CompanyName
    .Subject = Format(Date, &quot;short date&quot;) &amp; _
      &quot; notes regarding &quot; &amp; _
      Forms!Customers!CompanyName
    .Categories = &quot;Business; Phone Calls&quot;
    .StartTimer
    .Display
End With</font></pre>
<p>
After the properties are set using information from the Customers form, the object’s display method forces Outlook to show the new JournalItem object. The procedure illustrates how to set several properties of the object, but be aware that many more properties are available to you. You can use the Object Browser and Outlook’s online help to explore the various properties and methods available for any of the Outlook object items illustrated here.</p>
<h3>Sending a mail message</h3>
<p>
In previous examples I created new objects, set properties, and then displayed the object using the object’s Display method. In this example I use another form to gather information used to create a new MailItem object and give you the option of displaying the object before sending it, or of sending it directly. It’s up to you to decide whether to display items or to manipulate them entirely from code, depending on the specific requirements of your application.</p>
<p>
As with all the examples in this article, sending a mail message starts with the current record from the Customers form. This example uses the MailMessage form (see Figure 5) to gather additional information used to create a new Outlook MailItem object. The MailMessage form lets you specify whether to display the new MailItem object or to send it directly. When Outlook objects are created and used without first being displayed by Outlook, the presence of Outlook as a component of your application is completely transparent to the user. </p>
<p><img src="message.gif"></p>
<p>
<b>Figure 5. The MailMessage form used to gather information from the user, which is then used to create a new Outlook MailItem object.</b></p>
<p>
Start this example by selecting a customer record using the Customers form. Clicking the Send Mail Message command from the form’s pop-up menu bar executes the OpenMailForm procedure. This procedure contains a single line of code that opens the MailMessage form, passing data from the current record’s ContactName and CompanyName fields via the OpenArgs parameter:</p>
<pre><font face="Courier New" size="3">Function OpenMailform()
    DoCmd.OpenForm &quot;MailMessage&quot;, acNormal, _
     , , , acDialog, Forms!Customers!ContactName &amp; _
     &quot;;&quot; &amp; Forms!Customers!CompanyName
End Function</font></pre>
<p>
The MailMessage form’s Open event procedure parses the data in the OpenArgs property to set the value of the txtTo and txtSubject Text Box controls:</p>
<pre><font face="Courier New" size="3">Private Sub Form_Open(Cancel As Integer)
    With Me
        If Len(Me.OpenArgs) &gt; 0 Then
            !txtTo = Left(Me.OpenArgs, _
             InStr(Me.OpenArgs, &quot;;&quot;) - 1)
            !txtSubject = Mid(Me.OpenArgs, _
             InStr(Me.OpenArgs, &quot;;&quot;) + 1)
            !txtCC.SetFocus
        Else
            !txtTo.SetFocus
        End If
        !ctlViewMail.Value = 1
        !ctlImportance = 1
    End With
End Sub</font></pre>
<p>
The txtTo control contains the name of the person who will receive the mail message. You can add additional recipients by inserting a semicolon-delimited list of names in the txtCC text box control. In addition, you can specify one file or a semicolon-delimited list of several files in the txtAttachments text box control. The files are added to your MailItem object as attachments. When you click the Send button, code in the button’s Click event procedure calls the SendMailToContact procedure, passing a reference to the MailMessage form as an argument:</p>
<pre><font face="Courier New" size="3">Private Sub cmdShowMessage_Click()
    SendMailToContact Me
End Sub</font></pre>
<p>
The SendMailToContact procedure first determines if the Outlook Application object variable has been initialized and then uses the Application object’s CreateItem method to create a new MailItem object. Then, using the new MailItem object variable, the code uses the Add method of the MailItem’s Recipients collection to add one or more recipients to the mail message and the Recipients collection’s ResolveAll method to check for valid recipient names:</p>
<pre><font face="Courier New" size="3">' Add recipients to MailItem object.
.Recipients.Add frm!txtTo
If Not IsNull(frm!txtCC) Then
    If InStr(frm!txtCC, &quot;;&quot;) = 0 Then
        Set objRecip = .Recipients.Add(frm!txtCC)
        objRecip.Type = olCC
    Else
        strRecipients = frm!txtCC
        ' Parse recipients and add them to objects
        ' Recipients collection.
        Do
            Set objRecip = .Recipients.Add( _
             Left(strRecipients, _
             InStr(strRecipients, &quot;;&quot;) - 1))
            objRecip.Type = olCC
            strRecipients = Trim(Mid(strRecipients, _
             InStr(strRecipients, &quot;;&quot;) + 1))
        Loop While InStr(strRecipients, &quot;;&quot;) &lt;&gt; 0
        If Len(strRecipients) &gt; 0 Then
            Set objRecip = .Recipients. _
             Add(strRecipients)
            objRecip.Type = olCC
        End If
    End If
End If

' Let Outlook check the validity of the recipients.
.Recipients.ResolveAll</font></pre>
<p>
Next, if the user has entered files to be attached to the mail message, those files are added to the MailItem object’s Attachments collection using the collection’s Add method:</p>
<pre><font face="Courier New" size="3">' Add attachments to MailItem object.
If Not IsNull(frm!txtAttachments) Then
    If InStr(frm!txtAttachments, &quot;;&quot;) = 0 Then
        .Attachments.Add frm!txtAttachments
    Else
        strAttachments = frm!txtAttachments
        ' Parse Attachments and add them to 
        ' the Attachments collection.
        Do
            .Attachments.Add Left(strAttachments, _
             InStr(strAttachments, &quot;;&quot;) - 1)
            strAttachments = _
             Trim(Mid(strAttachments, _
             InStr(strAttachments, &quot;;&quot;) + 1))
        Loop While InStr(strAttachments, &quot;;&quot;) &lt;&gt; 0
        If Len(strAttachments) &gt; 0 Then _
         .Attachments.Add strAttachments
    End If
End If</font></pre>
<p>
Then the MailItem’s Subject and Body properties are set, using data supplied by the user:</p>
<pre><font face="Courier New" size="3">' Set MailItem object's Subject and Body properties.
.Subject = Nz(frm!txtSubject, &quot;&quot;)
.Body = Nz(frm!txtMessage, &quot;&quot;)</font></pre>
<p>
Finally, the code sets the MailItem’s Importance property using the ctlImportance option group and either displays or sends the MailItem based on the value of the ctlViewMail option group:</p>
<pre><font face="Courier New" size="3">' Set MailItem object's Importance property.
Select Case frm!ctlImportance
    Case olImportanceHigh
        .Importance = olImportanceHigh
    Case olImportanceNormal
        .Importance = olImportanceNormal
    Case olImportanceLow
        .Importance = olImportanceLow
    End Select

' Send or Display MailItem based on user's choice.
If frm!ctlViewMail.Value = 1 Then
    .Display
Else
    .Send
End If</font></pre>
<p>
The Customers form pop-up shortcut menu includes the Send Quick Mail menu item which executes the QuickMail function. QuickMail() creates a new MailItem object and displays it without setting any additional MailItem object properties or using any data from the Customers form. I’ve included it here to illustrate the “quick and dirty” way to mail-enable your application. </p>
<h3>Adding a contact item to the Outlook contacts database</h3>
<p>
Outlook includes a rich set of contact management features that you may have struggled long and hard to add to your Access applications. You may be ready to ask: “Is there any way I can incorporate the Outlook Contacts functionality into my application?” The answer to this question: “Yes.” And the good news is that tying the Outlook Contacts database to your Access database is quite simple. </p>
<p>
If you were to try to duplicate the Outlook contact management features in your Access application, you’d have to do a great deal of work. On the other hand, Outlook can’t take the place of your Access application because Outlook isn’t “relational” and lacks the power and extensive features found in Access. The best solution is to link to Outlook to take full advantage of what it does well, while continuing to manage your data in Access.</p>
<p>
To see an example of managing contact information in Outlook based on data supplied by Access, right-click on the Customers form and select the “Add Contact to Contacts List” command from the shortcut menu. This command calls the AddNewContact procedure, which uses data from the current record to create a new entry in the Outlook contacts database.</p>
<p>
As with the other examples in this article, the AddNewContact procedure begins by making sure that the Outlook Application and NameSpace variables have been properly initialized. It then uses the GetDefaultfolder method of the NameSpace object to return a pointer to the Outlook Contacts folder:</p>
<pre><font face="Courier New" size="3">Set objFolder = gOLNameSpace. _
 GetDefaultFolder(olFolderContacts)</font></pre>
<p>
The procedure checks to see if the Customers form is currently on a new record and, if so, asks the user to save that record before adding the contact information. </p>
<p>
Outlook stores contact information in a “flat-file” database and will blindly allow you to add duplicate records to your heart’s content. Therefore, if you’re going to link Access contact information to Outlook, it’s up to you to make sure that you’re not duplicating records. The AddNewContact procedure accomplishes this by searching for an existing record containing the same ContactName and CustomerID as the record you’re attempting to add. If it finds that the contact record already exists, it warns you and gives you the option of not adding the duplicate record: </p>
<pre><font face="Courier New" size="3">If objFolder.Items(objForm!ContactName.Value). _
 CustomerID = objForm!CustomerID Then
    If Err = 0 Then
        If MsgBox(objForm!ContactName.Value _
         &amp; &quot; already exists in your &quot; _
         &amp; &quot;collection of contacts. Do you want &quot; _
         &amp; &quot;to add the current information &quot; _
         &amp; &quot;as an additional record?&quot;, _
         vbInformation + vbYesNo, _
         &quot;Record already exists&quot;) = vbNo Then
            GoTo AddNew_Bye
        End If
    ElseIf Err &lt;&gt; conItemNotfound Then
        GoTo AddNew_Err
    End If
End If</font></pre>
<p>
The first line of this code examines the NameSpace objects Items collection for a member object that matches the data in objform!ContactName.Value. (Although the value property is the default for the referenced text box control, Outlook seems to insist that you reference the Value property explicitly.) At this point the code assumes that one of three things will happen as a result of this examination of the Items collection. The first possibility is that an Item matching the specified contact name is found in the collection. In this case, the code presents a message box giving the user the option of canceling the operation. (It isn’t canceled automatically because at times the user may actually want the duplicate record.) The second possibility is that an Item matching the specified contact name is <i>not</i> found. For this case the code compares the Err.Number property with the predefined constant representing “Item not found in this collection” and if it matches, the code continues to execute, adding the new data to Outlook. The third possibility is that some other unknown error has occurred. In this case, control is passed to the error handler.</p>
<p>
At this point all the hard work is done and the code continues by setting various properties of the ContactItem object and then adds the object to Outlook: </p>
<pre><font face="Courier New" size="3">' Add the information in the current record 
' to the Outlook Contacts folder.
Set objNewContact = objFolder.Items.Add
With objNewContact
    .FirstName = Left(objForm!ContactName, _
     InStr(objForm!ContactName, &quot; &quot;) - 1)
    .LastName = Mid(objForm!ContactName, _
     InStr(objForm!ContactName, &quot; &quot;) + 1)
    .CompanyName = Nz(objForm!CompanyName, &quot;&quot;)
    .JobTitle = Nz(objForm!ContactTitle, &quot;&quot;)
    .BusinessAddress = Nz(objForm!Address, &quot;&quot;)
    .BusinessAddressCity = Nz(objForm!City, &quot;&quot;)
    .BusinessAddressState = Nz(objForm!Region, &quot;&quot;)
    .BusinessAddressPostalCode = _
     Nz(objForm!PostalCode, &quot;&quot;)
    .BusinessAddressCountry = Nz(objForm!Country, &quot;&quot;)
    .BusinessTelephoneNumber = Nz(objForm!Phone, &quot;&quot;)
    .BusinessFaxNumber = Nz(objForm!Fax, &quot;&quot;)
    .CustomerID = Nz(objForm!CustomerID, &quot;&quot;)
    .Save
End With</font></pre>
<p>
There are a couple of things worth mentioning about this code. First, although this example sets about a dozen properties of the ContactItem object, there are many more properties exposed by Outlook that will allow you to store and track data for any conceivable purpose. In addition, the Outlook object model exposes a UserProperties collection of custom-defined UserProperty objects that allow you to create and store any number of your own custom properties. </p>
<p>
Second, recall that when the code checks to see if the current record already exists in Outlook it looks for an Item object that matches the specified ContactName. If it finds a match, it checks to see if the CustomerID in the Outlook contact record matches the CustomerID of the current record on the Customers form. I suspect the developers of Outlook anticipated the very kind of linking between Access and Outlook illustrated in this section because they’ve conveniently provided a CustomerID property for ContactItem objects. In the example code, when a new record is inserted into Outlook, data from the Customers form’s CustomerID field is added to the Outlook ContactItem object for the purpose of detecting later attempts to enter duplicate records.</p>
<h2>Conclusion</h2>
<p>
I’ve attempted to illustrate several useful techniques for using Access and Outlook together, but I’ve only scratched the surface. As you delve into the Outlook object model and discover the powerful functionality and interesting features available to you, you’ll likely come up with many ideas for custom solutions in your own applications. Microsoft’s incorporation of Outlook into Office 97 has added yet another powerful tool to the Access developer arsenal. For more information on Outlook, view the Outlook online help, the <i>Microsoft Office 97 Programmers</i> <i>Guide,</i> or the Outlook product page on the Microsoft Web site at http://www.microsoft.com.</p>
<p>
<b>&#09;&#09;&#09;  Shank01.exe from www.pinpub.com/access</b></p>
<p>
<i>David Shank works at Microsoft as a technical writer on the Microsoft Access team. He was also the technical editor for Access 97 Developers Handbook (Sybex). davidsha@microsoft.com or 103176.3264@compuserve.com.</i></p>
<P align="center"><a
href="http://www.pinpub.com/access/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about Smart
Access and Pinnacle Publishing, visit their website at</strong>:</p>

<P align="center"><a
href="http://www.pinpub.com/access/"><strong>http://www.pinpub.com/access/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content.</font></p>

<P>This article is reproduced from the February 1997
issue of Smart Access. Copyright 1997, by Pinnacle Publishing,
Inc., unless otherwise noted. All rights are reserved. Smart
Access is an independently produced publication of Pinnacle
Publishing, Inc. No part of this article may be used or
reproduced in any fashion (except in brief quotations used in
critical articles and reviews) without prior consent of Pinnacle
Publishing, Inc. To contact Pinnacle Publishing, Inc., please
call (800)788-1900 or (206)251-1900.</p>
</font></BODY>
</HTML>
