<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Windows NT Security System Basics </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1>Windows NT Security System Basics  </h1>
<p>
Pete Bosch</p>
<p>
<i>Providing for security and access rights isn’t just a problem for network administrators. To deal with today’s client/server and network-enabled applications, you have to have a thorough understanding of complex security issues. Windows NT provides a robust security mechanism you can use to make your applications and servers secure from unauthorized access. This article introduces basic NT security principles, outlining key elements of the security model and some of the implementation pitfalls.</i></p>
<p>
WHEN Windows NT was conceived, the top three priorities of the design team were security, extensibility, and stability. Among other things, their charter was to achieve security certifiable at level C2. (I’ll explain what the C2 rating means in greater detail in a moment.) For now, the important point is that you need to meet the C2 standard to be eligible for certain government business opportunities, as well as to win the confidence of corporate customers looking for an operating platform that can run mission-critical applications. The security mechanism in NT is excellent; it provides abundant protection with fine control granularity<font face="Symbol"><span style="font-family:symbol">&#190;</span></font>more protection and better control than most popular operating systems. However, this sophistication can lead to flaws in your applications if you don’t completely understand the model and its associated security issues.</p>
<p>
In this article, I’ll describe the basic principles of the Windows NT security model including some of the mechanisms it serves. I’ll also provide information you can use to help determine what level of security your applications require and highlight a couple of issues you need to know about when implementing NT security features. The sample code accompanying this article demonstrates common manipulations of the security system (go to Subscriber Downloads at www.pinpub.com/vcd for the code).</p>
<h2>Getting to C2</h2>
<p>
From its introduction, level C2 security has been an intrinsic part of Windows NT services. For those who don’t know exactly what this level of security means, here’s a brief summary of what a C2-compliant system must be able to do:</p>
<p>
Grant or deny use of, or access to, system resources by certain users or groups of users.</p>
<p>
Guarantee that when a block of memory is freed, its contents will be explicitly overwritten before being assigned to another process.</p>
<p>
Identify all users, enable an audit trail on any and all users, and attribute all actions in that audit trail to the user who performed them.</p>
<p>
Prevent anyone but a system administrator from enabling an audit trail.</p>
<p>
Protect itself from modifications to, and tampering with, system files and components of the running system such as drivers and loaded DLLs.</p>
<h2>When do you need security?</h2>
<p>
A user-mode, single-process application running standalone without stringent security constraints generally doesn’t need special security treatment. The developer generally provides a NULL in such an application wherever the API asks for a LPSECURITY_ATTRIBUTES structure. A NULL forces the system to return a default security attributes structure. Although the default attributes can be changed through the SetTokenInformation API, default security usually means that the permissions are the same as those of the user who is running the process. A handle to this process isn’t inheritable by sibling processes. For example, ProcessA creates ProcessB and receives a handle to ProcessB. Later, ProcessA creates ProcessC and requests that ProcessC inherit handles from its parent. If ProcessB was created with a NULL security attributes structure, then ProcessC won’t inherit the handle to ProcessB. If ProcessB had been created with a non-NULL security attributes structure, ProcessC may or may not inherit the handle to ProcessB, depending on the contents of that security attributes structure.</p>
<p>
While simpler applications don’t need special security treatment, some applications such as an application running in kernel mode, a server handling requests from other users, or an application wishing to manipulate system-wide resources (such as changing the time) must consider security issues. Even if you don’t think you need to implement special security treatment, NT security can affect what you do. For example, before you can safely use shortcuts in a critical system, you have to understand completely what is being circumvented.</p>
<h2>The model</h2>
<p>
Windows NT security is implemented through the following model: Every process or thread possesses an access token and every secured entity (including processes and threads) possesses a security descriptor. Among other things, a process or thread’s access token specifies its user and owner. An object’s security descriptor specifies who is and isn’t allowed to do things to the object. </p>
<p>
When a process is first created, the kernel gives it and its primary thread an access token. Whenever a thread requests to create or use another kernel object, it specifies the activities it wishes to perform on that object. The kernel checks with the other kernel object’s security descriptor to see if the requested activities can be granted. If they can, then a handle to the other kernel object is granted, with only the permissions requested by the thread. Thereafter, if the thread attempts to perform an activity on the other kernel object, the kernel verifies through the permissions attached to the handle that the thread actually has permission to do the particular activity.</p>
<h2>Who goes there? </h2>
<p>
A security identifier (SID) is Windows NT’s way of uniquely naming a user or group. It’s a variable-length data structure assigned to a user (or group) at the time the account or group is created. The SID is indelibly persistent in that it may never be reused, even if the assigned account or group is deleted. The SID includes a field that describes the granting authority (such as a specific NT Server domain), a field that describes the revision level, and a series of fields that describe the groups to which a user referred to by the SID belongs (see Figure 1).</p>
<p><img src="bosch1.gif"></p>
<p>
<b>Figure 1.The NT security ID model.</b></p>
<h2>Access tokens</h2>
<p>
In essence, an access token is a device Windows NT uses to characterize the role of a process or thread. A logon process is created for a user during login. The kernel creates an access token for the user and attaches it to this process. This access token describes the user, the user’s primary and associate groups, the thread owner’s SID, the source of the access token, and other facts. The SID also contains impersonation information, which I’ll discuss later. Any process or thread created thereafter is, by default, assigned the access token of its parent; a thread may also assume the role of another thread and act on its behalf through impersonation.</p>
<h2>Access masks and rights</h2>
<p>
Access rights control what one kernel object can do with another. The API uses a handle to access the access rights of an object. An access mask is the vehicle for requesting access rights. It specifies requested generic, standard, and specific rights. Generic rights-read, write, and execute-can apply to any kernel object. Standard rights generally are used to access process information such as security data and synchronization; they’re also used to allow or prevent the parent kernel object from being deleted. Specific rights are unique to a given object type and are defined and enforced by the object.</p>
<h2>An ACE up your sleeve</h2>
<p>
An Access Control Entity (ACE) represents a single security statement by a kernel object-either that entity<i> X</i> is <i>allowed</i> or <i>not allowed</i> to do activity<i> Y</i>, or that an attempt by entity<i> X</i> to do activity<i> Y is</i> or <i>is not</i> to be logged in the security event logs. An ACE is typically a member of a kernel object’s Access Control List (ACL). It consists of a type (Allowed or Denied), a SID that specifies the user or group being granted or denied permission, and an access mask, which is the complete set of access rights that may be granted to an object carrying an access token from that SID. Figure 2 shows an example of the ACE model.</p>
<p><img src="bosch2.gif"></p>
<p>
<b>Figure 2. The Access Control Entity (ACE) model.</b></p>
<h2>ACL, SACL, and DACL</h2>
<p>
There are two types of ACLs: a Discretionary Access Control List (DACL) for governing permissions for kernel object activities and a System Access Control List (SACL) for governing security logging of these activities. The DACL specifies a list of users and groups and their associated rights for a particular object. For example, user <i>X</i> requests a handle with permission for read and write operations to pipe <i>Y</i>. The kernel traverses the DACL owned by pipe <i>Y</i>, one entry (ACE) at a time. It looks for any entry that says that user <i>X</i> (or any group that user <i>X</i> is a member of) may perform the requested operations on this object. If it fails to find such an entry, or encounters an entry specifying that user <i>X</i> (or any member group) may <i>not</i> perform the requested operations, it refuses to grant user X access rights and denies the handle request (see Figure 3). </p>
<p><img src="bosch3.gif"></p>
<p>
<b>Figure 3.The Access Control List (ACL) model.</b></p>
<h2>Security attributes</h2>
<p>
Every securable object owns a set of Security Attributes (SA). An SA is an entity containing an owner SID, a group SID, and a Security Descriptor, possibly containing a DACL and an SACL. A thread may manipulate an object’s SA except for the SACL, but only if it requests and is granted the standard rights necessary to read and write to that object’s DACL (READ_CONTROL and WRITE_DAC). A user must be a member of the administrator group to read and write to the SACL (see Figure 4). </p>
<p><img src="bosch4.gif"></p>
<p>
<b>Figure 4. The Security Attributes (SA) model.</b></p>
<h2>Impersonation</h2>
<p>
Suppose you’ve created a server that provides users with some sort of file access and you run this server as an NT service so it will always be available. Without impersonation, any user accessing your system through your server would have the same access rights as your server, probably those accorded to the system administrator. Clearly, this kind of access can cause trouble. Impersonation provides a means of limiting the degree of access to that of the client attempting to access the system. Thus, a thread impersonating a user is granted only the user’s access rights, provided the user has given permission for impersonation. The advantage to this approach is that when your server creates a process or thread to handle a user request, the server can command the thread to impersonate the logged-on user and thus allow NT to provide the necessary protections against unauthorized access. A thread can impersonate itself, a logged-on user, or a client connected to a named pipe or DDE channel. NT supports three levels of impersonation, specified by a client process upon attaching to a pipe or DDE channel: </p>
<p>
<b>SecurityAnonymous</b> forbids any impersonation by a server.  </p>
<p>
<b>SecurityIdentification</b> permits the server to acquire the access token of the client, but not to impersonate it. Thus, a server may find out the permissions, identity, and groups of a client, but not act as that client.</p>
<p>
<b>SecurityImpersonation</b> permits the server to assume the access token of the client, with almost all of the privileges and abilities of that client. The server can’t subsequently connect to another machine as the client, because a network connection requires knowledge of a password, information that isn’t passed to the impersonating server. The impersonating thread also can’t create a new process in the name of the client.</p>
<h2>Common security pitfalls</h2>
<p>
There are a couple of things you need to know when implementing NT security in your application. For example, a Security Descriptor (SD) may or may not contain a Discretionary Access Control List (DACL). Although an SD with an empty DACL signifies that no one is allowed access to that object, an SD with no DACL indicates that no protection is desired for that object. Thus, anyone can be granted access to the object. Be careful not to confuse these two cases. By default, the source code accompanying this article creates an SD with an empty SACL and DACL. You must explicitly delete the DACL in order to get a nonexistent DACL.</p>
<p>
Another important thing to remember is that in traversing a DACL, the system will stop looking as soon as access is explicitly granted or denied. Assume user JohnDoe is a member of the group, DoeBoys. Further, assume that JohnDoe is explicitly <i>denied</i> read access to object FroBozz, whereas DoeBoys are explicitly <i>granted</i> read access to FroBozz. If the system encounters the DoeBoys ACE first, JohnDoe, as a member of DoeBoys, will get access to FroBozz. The point is that you should generally make sure that denial ACEs appear first in the DACL. The source code accompanying this library automatically places denial ACEs at the end of the DACL, and allowance ACEs at the beginning.</p>
<h2>The source code</h2>
<p>
The security operations I’ve chosen are contained in a dialog-based application called SECURE, which you can download from the <i>Visual C++ Developer</i> home page (www.pinpub.com/vcd). On startup, the application queries for the current user’s name, domain, and Security ID. This prompt would be appropriate in your application if, for example, you kept a database of SIDs for which you provided certain services. After startup, the application will allow you to either set or get security parameters on a file of your choosing (see Figure 5). Although this example focuses on file security, you would use the same techniques to manage security parameters on a socket or named pipe. While the code is designed to demonstrate general principles, you can use some individual functions, such as GetCurrentUserSID(), directly in your own code.</p>
<p><img src="bosch5.gif"></p>
<p>
<b>Figure 5.The SECURE sample application.</b></p>
<p>
<b>&#09;&#09;&#09;  BOSCH.EXE at www.pinpub.com/vcd</b></p>
<p>
<i>Pete Bosch is a software developer and architect, currently working for General Electric Medical Systems. He has been developing for Windows since MSVC++ 1.0. pbosch@execpc.com.</i></p>
<P align="center"><a
    href="http://www.pinpub.com/vbd/"><img src="Pinnacle.gif"
    border="0" width="216" height="72"></a></p>
    <P align="center"><strong>To find out more about
    Visual C++ Developer and Pinnacle Publishing, visit their
    website at</strong>: <a href="http://www.pinpub.com/vbd/"><strong>http://www.pinppub.com/vcd/</strong></a></p>
    <P align="center"><font size="1">Note: This is not
    a Microsoft Corporation website. <br>
    Microsoft is not responsible for its content.</font></p>
    <p><font size="1">This article is reproduced from the
    January 1997 issue of Visual C++ Developer. Copyright
    1997, by Pinnacle Publishing, Inc., unless otherwise noted.
    All rights are reserved. Visual C++ Developer is an
    independently produced publication of Pinnacle Publishing,
    Inc. No part of this article may be used or reproduced in any
    fashion (except in brief quotations used in critical articles
    and reviews) without prior consent of Pinnacle Publishing,
    Inc. To contact Pinnacle Publishing, Inc., please call
    (800)&nbsp;788-1900 or (206)&nbsp;251-1900.</font></p>
</font></BODY>
</HTML>
