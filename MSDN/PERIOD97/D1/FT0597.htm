<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Call VFP Backends from Web Pages with FoxISAPI </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1>Call VFP Backends from Web Pages with FoxISAPI</h1>
<p>
Rick Strahl</p>
<p>
<i>Visual FoxPro 5.0’s new capability of creating custom OLE servers has opened up a number of new opportunities to extend VFP’s reach. Here’s a way to generate dynamic Web pages using a new tool called FoxISAPI.</i></p>
<p>
WHAT if you could use an OLE server to respond to a request placed from a Web page to handle data processing and HTML page generation?  FoxISAPI, a tool that’s provided by Microsoft with VFP, allows you to do just that. By using the OLE server mechanism to expose your classes, it’s now possible to directly access the methods inside an OLE server using custom FoxPro code from an HTML hyperlink or form button. This mechanism gives you tremendous power to quickly build applications that can be linked to a Web server and in turn provide dynamically generated content for your Web pages.</p>
<p>
To work with the examples in this article, you need to run an Internet Server API (ISAPI)-compliant Web server such as Microsoft Internet Information Server (IIS) running under Windows NT. FoxISAPI won’t work correctly under Windows 95, even under ISAPI-compliant servers such as the MS Personal Web server or Commerce Builder. The examples here all use IIS.</p>
<h1>How it works</h1>
<p>
FoxISAPI works in conjunction with an ISAPI-compliant Web server such as Microsoft Internet Information Server. As such, FoxISAPI is a server-side tool that acts as a connector between the Web server and your FoxPro OLE server. A typical scenario starts out on an HTML form where the user either clicks on a hyperlink or submits an HTML form containing input fields (see Figure 1). A typical hyperlink calling a FoxISAPI-based backend might look like this: </p>
<pre><font face="Courier New" size="3">&lt;A HREF=&quot;/scripts/foxisapi.dll/Tserver.Tclass
  .Tmethod?UserId=1111&amp;Name=Rick+Strahl&quot;&gt;</font></pre>
<p>
Or you can call FoxISAPI from an HTML form:</p>
<pre><font face="Courier New" size="3">&lt;FORM ACTION=&quot;/scripts/foxisapi.dll/Tserver
  .Tclass.Tmethod&quot; METHOD=&quot;POST&quot;&gt;
&lt;INPUT TYPE=&quot;TEXT&quot; NAME=&quot;UserId&quot;&gt;&lt;BR&gt;
&lt;INPUT TYPE=&quot;TEXT&quot; NAME=&quot;UserName&quot;&gt;&lt;BR&gt;
&lt;INPUT TYPE=&quot;SUBMIT&quot; NAME=&quot;Run Query&quot;&gt;
&lt;/FORM&gt;</font></pre>
<p><img src="05strah1.gif"></p>
<p>
<b>Figure 1. FoxISAPI makes it easy to build database applications that use Visual FoxPro as a backend.</b></p>
<p>
Rather than pointing at a static HTML page, these links point at a dynamic ISAPI extension “script”-in this case FOXISAPI.DLL-which, in the previous example, lives in the /scripts directory. ISAPI is an extension interface that gives the Web server the ability to execute an external routine to serve Web content. The Web server by itself is just a service that knows how to send content over the wire to the browser (see Figure 2). It’s essentially ignorant about databases and applications or dynamic content in general. Instead, the Web server hands off control to extension scripts that create dynamic content, which is routed back to the server.</p>
<p><img src="05strah2.gif"></p>
<p>
<b>Figure 2. FoxISAPI acts as a connector application between the Web server and Visual FoxPro. Because FoxISAPI is an ISAPI extension that runs in the Web server’s address space, and because the VFP OLE server is loaded only once and then held in memory, access speed is very fast.</b></p>
<p>
So, when the user clicks on this link for the first time, the request passes from the Web browser over the TCP/IP network connection to the Web server. The Web server receives the request and invokes the FoxISAPI DLL, which is loaded into memory. Once loaded, the DLL stays in memory and isn’t unloaded until the Web server is shut down. Keep in mind that FoxISAPI is <i>not</i> Visual FoxPro code-it’s a small DLL written in C that acts as a routing mechanism to access a method in an OLE server.</p>
<h1>FoxISAPI is an OLE client calling your VFP OLE server</h1>
<p>
What does this FoxISAPI extension actually do? It acts as a connector application that provides an interface to OLE servers. FoxISAPI’s functionality essentially instantiates a registered OLE server and then calls a method with three parameters. It provides the equivalent functionality of the following Visual FoxPro code:</p>
<pre><font face="Courier New" size="3">oServer=CREATEOBJECT(&quot;Tserver.TClass&quot;)
oServer.Tmethod(&quot;UserId=1111&amp;Name=Rick+Strahl&quot;,
  &quot;C:\TEMP\FoxXXXX.ini&quot;,@lnRelease)</font></pre>
<p>
In order for this to work, the OLE server must exist and be registered in the Windows registry so FoxISAPI can create the object from the OLE Class ID passed on the URL command line. If you look back at the URL, you’ll see that all three pieces of the server-the server, class, and method-are described with the Tserver.Tclass.Tmethod text in the link following the DLL name. The slash (the <i>physical path</i>) acts as a separator in order to allow the two commands to be described as a single string. </p>
<p>
At this point FoxISAPI.DLL has created an instance of your OLE server and has called your method in this server. FoxISAPI is smart enough to load an instance of this server and then keep the reference to this server loaded. This means that the first hit on the server will be slow as the entire VFP runtime loads into memory, but any subsequent hits are very fast as they access a server that’s already loaded in memory.</p>
<h1>Build your application code with Visual FoxPro</h1>
<p>
What happens next? Essentially you’ve received a blank check from the Web server to go wild and run Visual FoxPro through its magic paces. You can now run any queries or inserts, access remote data, or call classes and business objects-all of Visual FoxPro is available to you. </p>
<p>
Well, not all of it, actually. You can’t run any interactive code that requires user intervention. You can’t run a form or pop up a dialog box to have a user start entering data. By the time the request reaches your FoxPro code you’re essentially looking at building a one-way transaction-based request handler. The Web server is waiting for a single response from your code in the form of a complete HTML document. There’s no interactivity at this point. Your entire user interface needs to be generated as HTML that is sent back as the character return value from your OLE server method. Any attempt to call an interactive form or dialog box will cause the server to hang. It’s very important to understand this! Any prompt in your code, whether voluntary (forms, MessageBox, and so on) or involuntary (a File Open dialog or a program error), will cause your server to hang and no longer be available to serve requests!</p>
<p>
Once your code is complete, it needs to return a string back to the FoxISAPI.DLL as the return value. This string must contain HTTP-compliant output. In most cases, this output will be an HTML document, but a number of other responses, such as a redirect, request for authentication, or an error result can also be returned.</p>
<h1>Building the OLE server</h1>
<p>
Let’s examine what a FoxISAPI-compliant OLE server looks like in terms of FoxPro code. You might be surprised that a “Hello World” application with FoxISAPI takes a mere 20 lines of code! The most basic FoxISAPI-compatible OLE server that you can build looks like this:</p>
<pre><font face="Courier New" size="3">*** System Defines
#DEFINE CR CHR(13)+CHR(10)

DEFINE CLASS TFoxISAPI AS Custom OLEPUBLIC

FUNCTION Helloworld
LPARAMETER lcFormVars, lcIniFile, lnReleaseFlag
LOCAL lcOutput

*** HTTP header - REQUIRED on each request!

lcOutput=&quot;HTTP/1.0 200 OK&quot;+CR+;
         &quot;Content-type: text/html&quot;+CR+CR

lcOutput=lcOutput+;
   &quot;&lt;HTML&gt;&lt;BODY&gt;&quot;+CR+;
   &quot;&lt;H1&gt;Hello World from Visual FoxPro&lt;/H1&gt;&lt;HR&gt;&quot;+CR+;
   &quot;This page was generated by Visual FoxPro...&lt;HR&gt;&quot; ;
   +CR+
   &quot;&lt;/HTML&gt;&lt;/BODY&gt;&quot;

RETURN lcOutput

ENDDEFINE</font></pre>
<p>
If you take this code, stick it into a .PRG file, add it to a project, and compile it as an .EXE or .DLL-based OLE server, you’ll be able to call the server from your Web browser simply by typing the following into the browser’s location window:</p>
<pre><font face="Courier New" size="3">/localhost/scripts/foxisapi.dll/TFoxServer
  .TFoxIsapi.HelloWorld</font></pre>
<p>
Who said Web development has to be difficult?</p>
<p>
The previous code is pretty simple and doesn’t do anything fancy, but it demonstrates most of the key pieces that each method called from a Web link must support. First, the class must be created as OLEPUBLIC in order to be accessible as an OLE object once it’s compiled. You can use a single server that contains multiple publicly accessible classes.</p>
<p>
When FoxISAPI calls your OLE server, it passes along three parameters to each request method that is called. While you might not need to do anything with these parameters, your method <i>must</i> support them, or else an OLE Server error will be raised when the method is called. Here are explanations of each parameter. </p>
<h2>lcFormVars </h2>
<p>
The first parameter contains any form variables retrieved from an HTML form via an HTTP GET or POST, any “parameters” passed on the Query String, or any form variables retrieved from an HTML form via an HTTP GET or POST. </p>
<p>
The format of the parameter string contains a key/value pair for each of the form variables or “parameters” passed. The keys in the preceding example are <i>UID</i> and <i>Name</i>; the values are <i>1111</i> and <i>Rick Strahl</i>. These key value pairs are URL-encoded, which means they follow a specific protocol of encoding to allow passing special characters on the URL or via form variables. It works something like this:</p>
<p>
Key value pairs are separated by an ampersand (&amp;).</p>
<p>
Spaces are converted to plus signs (<b>+</b>).</p>
<p>
All “extended” characters are converted to Hex escape codes. The escape code uses a percent sign (%) plus a hex number to store the ASCII code of the characters. For example, a carriage return (ASC(13)) is encoded as <i>%0D</i><b>.</b></p>
<p>
The EMPLOYEE example in your \VFP\SAMPLES\SERVERS\FOXISAPI directory (as well as a simple starter class that I’ll list in a moment) decodes these variables. The starter class is also included with the download file that accompanies this article.</p>
<h2>LcIniFile</h2>
<p>
This parameter contains the path to an .INI file that contains all the server, browser, and system variables. This .INI file, which is created by FoxISAPI.DLL before control passes to your OLE server, is deleted after your method call returns. You can retrieve these with calls to the GetProfileString API call (or use the FoxISAPI::GetCGIVar(cVarname,cSection) from the listings that follow). You can see what’s available by looking at the following sample:</p>
<pre><font face="Courier New" size="3">[FOXISAPI]
Request Method=GET
Query String=UserId=11111&amp;UserName=Rick+Strahl
Logical Path=/wwDevcon.TFoxIsapi.TestMethod
Physical Path=c:\westwind\wwDevcon.TFoxIsapi.TestMethod
FoxISAPI Version=FoxISAPI v1.1
Request Protocol=HTTP/1.0
Referer=/cgi-win/foxisapi.dll
Server Software=Microsoft-IIS/2.0
Server Name=rasnote
Server Port=80
Remote Host=111.111.111.113
Remote Address=111.111.111.113
[ALL_HTTP]
HTTP_ACCEPT=image/gif, image/x-xbitmap, image/jpeg, 
     image/pjpeg, */*
HTTP_ACCEPT_LANGUAGE=en
HTTP_CONNECTION=Keep-Alive
HTTP_HOST=rasnote
HTTP_REFERER=http://rasnote/devcon/
HTTP_UA_PIXELS=800x600
HTTP_UA_COLOR=color8
HTTP_UA_OS=Windows NT
HTTP_UA_CPU=x86
HTTP_USER_AGENT=Mozilla/2.0 (compatible; MSIE 3.01; 
     Windows NT)
HTTP_COOKIE=WWLASTVISIT=10/20/96; 
     DENALISESSIONID=PUWFKVSKIVSVQCVG
[Accept]
image/gif=Yes
image/x-xbitmap=Yes
image/jpeg=Yes
image/pjpeg=Yes
*/*=Yes
[SYSTEM]
GMT Offset=-28800</font></pre>
<p>
Typically you’ll use only a few of the keys from the .INI file. The <i>Query String</i> is frequently read to figure out what “parameters” were passed to a form. The <i>User Agent</i> can help you to determine whether the user’s setup allows you to show browser-specific features. The <i>Referer</i> tells where the user was coming from: <i>HTTP_REFERER</i> contains the link the user clicked on to arrive at the current location. HTTP <i>Cookies</i> can be retrieved using a browser-stored ID that you can use to track a user over several requests through a site.</p>
<h2>LnReleaseFlag</h2>
<p>
This parameter concerns itself with the persistence of the OLE server. By default, FoxISAPI contains logic to create OLE server instances and keep those instances loaded in memory. By keeping instances loaded, successive accesses to the same server are quite fast because the server is already loaded in memory. In essence, each OLE server that’s called maintains only one persistent instance in memory at any time. It’s a good idea to keep the reference by leaving lnReleaseFlag at its default value of 0. This will keep a connection in order to minimize the server load time. The parameter is passed in by reference, so if you change it in your code you’ll effectively pass back the result to the FoxISAPI connector. Here are the possible values for lnReleaseFlag:</p>
<p>
0-Keep Server Reference (default)</p>
<p>
1-Release Server Reference</p>
<p>
Once your code gets control you can use VFP as you see fit to run queries or run any other kind of transaction or logic operation using FoxPro code. The result of each exit point of your method must be an HTTP-compliant string.</p>
<p>
In most cases, the output will be an HTML document, but you have to add an HTTP header to the top of it. Typical HTML output should look like this:</p>
<pre><font face="Courier New" size="3">HTTP/1.0 200 OK
Content-type: text/html

&lt;HTML&gt;
&lt;H1&gt;Hello World&lt;/H2&gt;
&lt;/HTML&gt;</font></pre>
<p>
The HTTP header and Content-type are important because not all browsers will support headerless results. Each line of the header must be separated by a CHR(13)+CHR(10) and the final header line must be followed by a blank line containing only CHR(13)+CHR(10).</p>
<p>
While you’ll almost always return an HTML document, it’s possible to generate standard HTTP header responses as well. For example, if you wanted Authentication to occur you might return the following:</p>
<pre><font face="Courier New" size="3">HTTP/1.0 401 Not Authorized
WWW-Authenticate: basic realm=west-wind.com

&lt;HTML&gt;
Get out and stay out!!!
&lt;/HTML&gt;</font></pre>
<p>
This would cause the browser to produce an authentication box (see Figure 3) unless the user accessing the link was previously authenticated. If the user isn’t authenticated, the password box pops up. If the user types an invalid password, an error message is returned; otherwise, the same link is re-executed and the now-validated user can receive the password check. You can then check the password as passed back in the <i>Authenticated Username</i> CGI variable to determine whether to allow the user in. (Actually, NT will first authenticate the user and fail if the user isn’t valid as determined by the User Manager.)</p>
<p><img src="05strah3.gif"></p>
<p>
<b>Figure 3. An authentication box that was initiated from a Web request forces authentication against the NT user/security manager.</b></p>
<p>
Here’s what this looks like in code (using some of the methods described in the next section):</p>
<pre><font face="Courier New" size="3">lcUserName=THIS.GetCGIVar(&quot;Authenticated Username&quot;)

IF EMPTY(lcUserName)   
  *** Send Password Dialog Box
  lcOutput=;
    &quot;HTTP/1.0 401 Not Authorized&quot;+CR+;
    &quot;WWW-Authenticate: basic realm=west-wind.com&quot;;
    +CR+CR+&quot;&lt;HTML&gt;&quot;+CR+;
    &quot;Get out and stay out!!! &quot;+CR+;
    &quot;&lt;/HTML&gt;&quot;+CR

    RETURN lcOutput
ENDIF

*** Go on processing - user has been authenticated.
...
RETURN lcOutput</font></pre>
<h1>A simple FoxISAPI class</h1>
<p>
Before I discuss a basic FoxISAPI starter class I want to mention that VFP 5.0 ships with an EMPLOYEE example that uses a Visual FoxPro form to handle requests that generate HTML from the form on the fly. It’s a very cool example, so check it out once you become familiar with how FoxISAPI works. </p>
<p>
In order to simplify working with the parameters passed by FoxISAPI and set up the response pages generated by your code, I’ve put together a starter FoxISAPI class that’s provided in this month’s downloadable file. It’s by no means a complete framework, but it provides the basics to handle the repetitive code that needs to be run on every request. See Table 1.</p>
<p>
<b>Table 1. The properties and methods for a basic FoxISAPI class to handle basic requests. </b></p>
<table>
<tr valign=top>
<td>
<b>cOutput</b></td>
<td>
Temporary holding property that contains all text output to be returned from the request method.</td>
</tr>
<tr valign=top>
<td>
<b>Send/SendLn()</b></td>
<td>
Sends text to the output property.</td>
</tr>
<tr valign=top>
<td>
<b>StandardPage()</b></td>
<td>
Generates a full HTML page.</td>
</tr>
<tr valign=top>
<td>
<b>ContentTypeHeader()</b></td>
<td>
Adds HTTP header.</td>
</tr>
<tr valign=top>
<td>
<b>StartRequest()</b></td>
<td>
Called to set up a request. Decodes input vars and clears the cOutput property.</td>
</tr>
<tr valign=top>
<td>
<b>GetFormVar()</b></td>
<td>
Retrieves a form variable passed in via the lcFormVar parameter with the first parameter.</td>
</tr>
<tr valign=top>
<td>
<b>GetCGIVar()</b></td>
<td>
Retrieves a server/browser variable from the .INI file.</td>
</tr>
<tr valign=top>
<td>
<b>ReleaseServer()</b></td>
<td>
Standard method that releases the OLE server.</td>
</tr>
</table><br>
<p>
All output is assembled using the Send/SendLn methods of the FoxISAPI class, including all output created by the internal methods. This way, in the future you can adapt your output easily to other output mechanisms. For example, the current code outputs to the cOutput property of the FoxISAPI class. In the future you might want to first build your output in a file (on large strings-20K and up-files are actually much faster than string concatenation!), then send the result back to the server as a string retrieved from that file. If you use a single method to handle all output you can make changes to the output medium without having to make any code changes later on. This method has served me extremely well in Web Connection where, thanks to this mechanism, you can output transparently to file, string, or a string array collection.</p>
<p>
Every request should start with a call to StartRequest, which decodes the form variables, assigns the .INI filename to a class property, and clears the output property (among other things). This is crucial for using some of the other methods such as GetFormVar() and GetCGIVar(). These two methods retrieve request information. GetFormVar() retrieves HTML form variables (typically a POST request) or parameters passed on the URL query string (typically a GET request).</p>
<p>
StandardPage() is extremely handy for building error messages and simple response pages, and even for debugging by quickly outputting state information to an HTML form. If you’re building pages from scratch, use ContentTypeHeader() to add the HTTP header to each request. This isn’t done in StartRequest() so you can send custom HTTP headers, which might not include the “standard” content type header.</p>
<p>
The class uses a #DEFINE DEBUGMODE .T. at the top to determine how errors are handled. The FoxISAPI includes an Error method, but it’s wrapped in an #IF !DEBUGMODE block that effectively allows you to remove the error method while debugging the server. This makes it much easier to capture errors on their source line rather than backtracking through the error method and line number:</p>
<pre><font face="Courier New" size="3">#IF !DEBUGMODE
******************************************************
* FoxISAPI :: Error
*********************************
***  Function: Limited error handler. 
***  Not much we can do here other
***  than exit. Displays error page.
******************************************************
FUNCTION Error
LPARAMETERS nError, cMethod, nLine

THIS.StandardPage(;
 &quot;Hold on... we've got a problem!&quot;,;
 &quot;The current request has caused an “ + ;
 “ error in Visual FoxPro.&lt;p&gt;&quot;+CR+;
 &quot;Error Number: &quot;+STR(nError)+&quot;&lt;BR&gt;&quot;+CR+;
 &quot;Error: &quot;+Message()+&quot;&lt;BR&gt;&quot;+CR+;
 &quot;Code: &quot;+Message(1)+&quot;&lt;BR&gt;&quot;+CR+;
 &quot;Running Method: &quot;+cMethod+&quot;&lt;BR&gt;&quot;+CR+;
 &quot;Current Code Line: &quot;+STR(nLine) )

*** Stop further output
THIS.lNoOutput=.T.

ENDFUNC
* Error

#ENDIF</font></pre>
<p>
The following is a method in a subclassed FoxISAPI class that uses some of the class features. Again, this isn’t terribly exciting stuff, but it shows some of the information that FoxISAPI makes available to your FoxPro code:</p>
<pre><font face="Courier New" size="3">DEFINE CLASS TFoxISAPI AS FoxISAPI OLEPUBLIC

FUNCTION TestMethod
LPARAMETER lcFormVars, lcIniFile, lnReleaseFlag
LOCAL lcOutput

*** Decode the Form Vars and assign an INI file 
*** to the class property.
THIS.StartRequest(lcFormVars,lcIniFile)

*** Don't Release the server.
* lnReleaseFlag=0       
* 0 - Don't release (default)  1 - Release 

*** Must always add a content Type Header.
THIS.HTMLContentTypeHeader()

*** Retrieve Form Variables.
lcUserId=THIS.GetFormVar(&quot;UserId&quot;)
lcName=THIS.GetFormVar(&quot;UserName&quot;)

THIS.SendLn(&quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Hello 
  from FoxISAPI&lt;/TITLE&gt;&lt;HEAD&gt;&lt;BODY&gt;&quot;)
THIS.SendLn(&quot;&lt;H1&gt;&lt;FONT=Arial COLOR=#800000&gt;
  Hello World from Visual FoxPro&lt;/FONT&gt;&lt;/H1&gt;&quot;)

THIS.SendLn(&quot;This page was generated by “ ;
  + “Visual FoxPro using FOXISAPI. &quot;)
THIS.SendLn(&quot;The current time is: &quot;+time()+&quot;&lt;p&gt;&quot;)

THIS.SendLn(&quot;&lt;b&gt;Encoded Form/URL variables:&lt;/b&gt; &quot; ;
  +lcFormVars+&quot;&lt;BR&gt;&quot;)
THIS.SendLn(&quot;&lt;b&gt;Decoded UserId:&lt;/b&gt; &quot;  ;
  + THIS.GetFormVar(&quot;UserId&quot;)+&quot;&lt;br&gt;&quot;)
THIS.SendLn(&quot;&lt;b&gt;Decoded UserName:&lt;/b&gt; &quot; ;
  +THIS.GetFormVar(&quot;UserName&quot;)+&quot;&lt;P&gt;&quot;)

*** Show the content of the FOXISAPI INI 
*** server/browser vars
IF !EMPTY(lcIniFile) AND FILE(lcIniFile)
   CREATE CURSOR TMemo (TFile M )
   APPEND BLANK
   APPEND MEMO TFile from (lcIniFile)
   THIS.SendLn(&quot;Here's the content of: &lt;i&gt;&quot; ;
     +lcIniFile+;
     &quot;&lt;/i&gt;. You can retrieve any of these with &lt;i&gt;
     “ THIS.GetCGIVar(cVarname,cSection)&lt;/i&gt;:&lt;p&gt;&quot;)
   THIS.SendLn([THIS.GetCGIVar( ;
        &quot;HTTP_USER_AGENT&quot;,&quot;ALL_HTTP&quot;): ]+;
   THIS.GetCGIVar(&quot;HTTP_USER_AGENT&quot;, ;
        &quot;ALL_HTTP&quot;))
  
   THIS.Send(&quot;&lt;PRE&gt;&quot;)
   THIS.SendLn(Tmemo.Tfile)
   THIS.SendLn(&quot;&lt;/PRE&gt;&quot;)
   USE in TMemo
ENDIF

THIS.SendLn(&quot;&lt;HR&gt;&lt;/HTML&gt;&lt;/BODY&gt;&quot;)

RETURN THIS.cOutput

*** 
FUNCTION AnotherMethod
LPARAMETER lcFormVars, lcIniFile, lnReleaseFlag
...
RETURN THIS.cOutput

ENDDEFINE</font></pre>
<p>
To hit this request you can type the following into your browser’s location box:</p>
<pre><font face="Courier New" size="3">localhost/scripts/foxisapi.dll?TDevCon.TFoxISAPI
  .TestMethod?UserName=Rick+Strahl&amp;UserId=1111</font></pre>
<p>
This request simply displays the encoded Query string (the example comes from a hypothetical form with two INPUT elements for UserName and UserId) and the individual decoded variables. Note the use of GetFormVar() to retrieve the variables.</p>
<p>
The code within the IF statement pulls the information from the .INI file into a memo field, then displays the information by sending it to output with the SendLn() method. The .INI file, of course, contains all the server variables that identify the server, the browser, and, to a degree, the user. The code also displays a couple of keys from the .INI file using the GetCGIVar() method. The previous example pulls out the User Agent, which is the name of the browser in use.</p>
<p>
Okay, here’s one more easy example. This time let’s run a query:</p>
<pre><font face="Courier New" size="3">*** Application DEFINEs - change for your application
#DEFINE SITELOCATION 1

*** Must use hardcoded data paths because the application
*** doesn't know where it's loading from. 
#IF SITELOCATION=1
   *** Location of your data. Reference all data.
   #DEFINE DATAPATH &quot;\devcon\code\data\&quot;

   *** I use this for scripted HTML pages with
   *** the Web Connection HTML Class.
   #DEFINE HTMLPAGEPATH &quot;c:\http\foxisapi\&quot;
#ENDIF   

#DEFINE DEBUGMODE .F.
#DEFINE CR CHR(13)+CHR(10)

DEFINE CLASS TFoxISAPI

******************************************************
* FoxISAPI :: Load
*********************************
***  Function: Load event
***  - should set up the environment for the
***    class: Any SET and ON commands, and so on
***    NOTE: 
***    This event occurs only when the server is loaded!
***    Because FoxISAPI keeps a reference, only the first
***    hit on the server fires the load.
******************************************************
FUNCTION Load

*** These are crucial to avoid dialogs!!!
SET SAFETY OFF
SET CPDIALOG OFF

*** If single server set ON
SET EXCLUSIVE OFF

*** You have to set a physical path as the OLE Server
*** runs in the System or scripts directory!
SET PATH TO DATAPATH

ENDPROC
******************************************************
* TDevCon :: CustomerLookup
*********************************
FUNCTION CustomerLookup
LPARAMETER lcFormVars, lcIniFile, lnReleaseFlag

lcIniFile=IIF(type(&quot;lcIniFile&quot;)=&quot;C&quot;,lcIniFile,&quot;&quot;)

*** Release the server 
#IF DEBUGMODE
   * 0 - Don't release (default)  1 - Release
   lnReleaseFlag=1       
#ELSE
   lnReleaseFlag=0
#ENDIF

*** Allow working as Denali expression as well! 
*** Allow stripping of HTTP Header
IF UPPER(lcIniFile)=&quot;NOHEADER&quot;
  THIS.lAddHeader=.F.  &amp;&amp; .T. by default
ENDIF  

*** Decode the Form Vars and 
*** assign INI file to global var
THIS.StartRequest(lcFormVars,lcIniFile)

*** Retrieve the Name and Company input variables
lcName=THIS.GetFormVar(&quot;Name&quot;)
lcCompany=THIS.GetFormVar(&quot;Company&quot;)

lcWhere=&quot;&quot;
IF !EMPTY(lcName)
   lcWhere=&quot;UPPER(Careof)='&quot;+UPPER(lcName)+&quot;'&quot;
ENDIF
IF !EMPTY(lcCompany)
   IF !EMPTY(lcWhere)
      lcWhere=lcWhere+&quot; AND &quot;
    ENDIF
    lcWhere=lcWhere+&quot;UPPER(Company)='&quot; ;
           +UPPER(lcCompany)+&quot;'&quot;
ENDIF
IF !EMPTY(lcWhere)
   lcWhere=&quot;WHERE &quot;+lcWhere
ENDIF
       
SELECT  Company, Careof, Address, Phone ;
   FROM (DATAPATH+&quot;TT_CUST&quot;) ;
   &amp;lcWhere ;
   ORDER BY COMPANY ;
   INTO Cursor TQuery

IF _Tally &lt;1
   THIS.StandardPage(; 
     &quot;No matching records found&quot;,;
     &quot;Please enter another name or use a “ ;
     “ shorter search string...&quot;)
    USE IN Tquery
    USE IN TT_Cust
    RETURN THIS.cOutput                     
ENDIF

IF THIS.lAddHeader
   THIS.ContentTypeHeader()
ENDIF


THIS.SendLn([&lt;HTML&gt;&lt;BODY&gt;])
THIS.SendLn([&lt;H1&gt;Customer Lookup&lt;/H1&gt;&lt;HR&gt;])

This.SendLn([Matching found: ]+STR(_Tally)+[&lt;p&gt;])

* THIS.SendLn(lcFormVars+&quot;!&quot;+lcName+&quot;!&quot;+lcCompany)

THIS.Send([&lt;TABLE BGCOLOR=#EEEEEE CELLPADDING ;
           =4 BORDER=1 WIDTH=100%&gt;]+CR+;
          [&lt;TR BGCOLOR=#FFFFCC&gt;&lt;TH&gt;Name&lt;/TH&gt; ;
           &lt;TH&gt;Company&lt;/TH&gt;&lt;TH&gt;Address&lt;/TH&gt;&lt;/TR&gt;]+CR)

SCAN
   THIS.Send(;
          [&lt;TR&gt;&lt;TD&gt;]+;
          TRIM(IIF(EMPTY(TQUery.Careof),&quot;&lt;BR&gt;&quot;, ;
            Tquery.CareOf))+[&lt;/TD&gt;&lt;TD&gt;]+;
          TRIM(IIF(EMPTY(Tquery.Company),&quot;&lt;BR&gt;&quot;, 
            Tquery.Company))+[Company&lt;/TD&gt;&lt;TD&gt;]+;
          TRIM(IIF(EMPTY(Tquery.Phone),&quot;&lt;BR&gt;&quot;, 
            TQuery.Phone))+[&lt;/TD&gt;&lt;/TR&gt;]+CR)
ENDSCAN          

THIS.SendLn([&lt;/TABLE&gt;&lt;HR&gt;])
THIS.SendLn([&lt;/BODY&gt;&lt;/HTML&gt;])

USE IN Tquery
USE IN TT_Cust

RETURN THIS.cOutput
* CustomerLookup

ENDDEFINE</font></pre>
<p>
Note the #DEFINEs at the top and the added Load method. The OLE server is typically loaded with the current directory, set to the SYSTEM directory, as it’s being called from the Web server that’s running as a system service. In order to point your server at the right directory you have to explicitly include the path to your data directory, or SET DEFAULT to the directory that you expect to be in. </p>
<p>
Additionally, it’s a good idea to set this datapath as a #DEFINE or global property on the FoxISAPI class to allow you to quickly switch paths between your development and live machine. Because I typically have a number of settings that vary between development and online boxes, I usually have a LOCALSITE #DEFINE and a block that sets up all the constants for that block of code. Then, between each site move you only have to recompile the code with the LOCALSITE flag set to the proper state.</p>
<p>
Included with this month’s downloadable file there’s another example in a separate class called Tregister. This class contains several related requests that implement the beginnings of a consultant register, where people can browse names and enter new entries into the register. It uses the Web Connection HTML class (it was easier to build it that way) for building the HTML pages as templates with embedded FoxPro code. Before running this sample make sure you take a look at Tregister.prg and read the header. Figure 1 shows an example of the applet running in Internet Explorer.</p>
<h1>Releasing servers</h1>
<p>
When FoxISAPI loads an OLE server, it creates a persistent reference to that server, which is reused on subsequent requests. This is great for speed but also a pain if you’re trying to build a new server; the server will be in use and you won’t be able to update it with a new .EXE or .DLL while it’s running.</p>
<p>
To release a server with FoxISAPI, you can use one of two mechanisms: lnReleaseFlag, which is passed to your OLE server method by reference, and a special RESET method, which is implemented directly inside of the FoxISAPI DLL. </p>
<p>
Using lnReleaseFlag allows you to control the release of the server from within your FoxPro code. FoxISAPI passes the lnReleaseFlag to your code by reference, which means you can change the value in your code and have the value checked when it returns to the DLL. A zero (0) means “keep the server loaded,” a one (1) means “unload the server.” When running in DEBUGMODE I tend to set the lnReleaseFlag to 1 so that the server releases on each hit. It slows down access to the server but it saves a number of steps when I need to rebuild the server or fix any problems in the code.</p>
<p>
The other mechanism is built directly into the FoxISAPI DLL. You can call a special RESET method that releases all server references at once by calling the FoxISAPI DLL directly through the browser. To release all servers you’d type the following:</p>
<pre><font face="Courier New" size="3">localhost/scripts/foxisapi.dll/RESET</font></pre>
<h1>Reading you your rights</h1>
<p>
I’ve described things a bit out of order, first covering the code before going over the crucial issues of actually installing FoxISAPI and the OLE server. Setting up for FoxISAPI is fairly tedious because of some of the security issues raised when OLE servers are called by the anonymous account (IUSR_Machinename), which is used by the Web server when serving Web requests. (The user rights issues might vary when running a Web server other than IIS. If you use another Web server such as Commerce Builder by the Internet Factory you might not have to deal with the setup issues because the server might run with a less restrictive user account.) The following information is specific to IIS, but it might apply to other ISAPI compliant servers as well, depending on your Web user account setup.</p>
<p>
You need to do three things when working with FoxISAPI:</p>
<p>
Install the FoxISAPI.DLL.</p>
<p>
Register the OLE server.</p>
<p>
Set the DCOM Access rights for the server.</p>
<p>
To install the FoxISAPI.DLL copy the DLL to a server directory that has Execute rights enabled. Use the DLL supplied in the downloadable file, rather than the one that came with VFP 5.0-it’s updated and contains a number of bug fixes and new features. By default IIS has a <i>/scripts</i> directory where ISAPI scripts can live, but you’re free to set up your own. If you set up your own make sure you map this directory from the IIS service manager and give it Execute rights.</p>
<p>
Before FoxISAPI can access a FoxPro OLE server the OLE server must be registered on the machine on which it’s running. If you’re building the server on the same machine as the Web server that’s running FoxISAPI, registration is automatic. If you’re building across the network, you have to manually register the server. If you have an EXE server, run the server from the Run box with <i>OleServer.exe /regserver. </i>If you have a DLL server, register the server with the <i>Regsvr32.exe</i> utility that’s installed in your VFP directory. You can do <i>Regsvr32 OleServer.dll </i>to register any DLL servers.</p>
<h1>Windows NT 4.0-the DCOM beast</h1>
<p>
On Windows NT 4.0, you have to use the Distributed Common Object Model (DCOM) configuration for all EXE servers launched by the Web server process. Every EXE OLE server created on your system is registered under the DCOM configuration manager and must be associated with access and launch rights even though you might never actually take advantage of the “distributed” aspect of the OLE server. DLL servers are more lenient because they qualify as system services, but they must have at least the default rights set to include the Web server user account with launch permissions.</p>
<p>
When Web requests hit your server, IIS logs the user on using a generic system account named IUSR_Machinename, where <i>Machinename</i> is the name of your particular NT machine. In order for a user to start up your OLE server, he or she needs to be given rights to access OLE servers in general. To do this you need to run a utility called DCOMCNFG.EXE, located in your \WINNT\SYSTEM32 directory. In DCOMCnfg  perform the following steps.</p>
<h2>Add IUSR_ account to default rights</h2>
<p>
The IUSER_Machine account is the user account used by IIS while running a Web request. To add this account so you can provide default launch and access rights for all OLE servers, follow these steps (see Figure 4):</p>
<p>
Start DCOMCNFG.</p>
<p>
Go to Default Security.</p>
<p>
Add IUSR_ to Default Access Permissions.</p>
<p>
Add IUSR_ to Default Launch Permissions.</p>
<p><img src="05strah4.gif"></p>
<p>
<b>Figure 4. \WINNT\SYSTEM32\DCOMCNFG.EXE is used to set default launch rights for OLE servers. The IUSR_ account must be added in order for the Web server to launch the server.</b></p>
<h2>Set user to Interactive User on the specific server</h2>
<p>
The EXE requires that the server be defined for interactive use (see Figure 5). To do this, perform the following steps:</p>
<p>
Go to the Applications tab.</p>
<p>
Select the Class (TFoxIsapi in the example).</p>
<p>
Click Properties.</p>
<p>
Go to the Identity tab.</p>
<p>
Click The Interactive User.</p>
<p>
Click Apply.</p>
<p><img src="05strah5.gif"></p>
<p>
<b>Figure 5. Each specific server must also be set up as Interactive User in order to allow the OLE server interface to be instantiated. </b></p>
<h2>Re-run whenever server is rebuilt</h2>
<p>
Repeat the previous steps whenever you rebuild the server on the local machine, which rebuilds the OLE IDs and blows away the DCOM settings. Tip: Build your OLE server across the network! Once the server is registered and configured with DCOM to allow execution, the registry settings aren’t updated; therefore, you don’t have to re-run DCOMCnfg after each build.</p>
<h1>Instancing issues</h1>
<p>
Whenever you build an OLE server, one of the important issues you need to deal with is server instancing. In Web applications, instancing is even more critical because timing-and freeing up the server so it can quickly handle requests-helps provide adequate Web performance.</p>
<p>
Visual FoxPro is a single-threaded application and, as such, can handle only one request at a time. OLE servers, even multiuse servers, are no different and are straddled by this limitation of the VFP runtime engine. If an OLE server (or standalone application) is busy, it can’t handle another request until it finishes. Furthermore, although ISAPI DLLs are multi-threaded, FoxISAPI blocks simultaneous OLE server access in its code to prevent your OLE server from taking more than one request at a time. You have several instancing options. </p>
<h2>An in process DLL server</h2>
<p>
This is the fastest implementation of an OLE server as it runs in process on the Web server. Requests to the OLE server are queued. Note: You can run only one DLL-based OLE server on a single machine! If you try to load a second DLL-based server it will fail. DLL servers can’t be shut down unless the Web server is stopped. A crash in the OLE server DLL will likely bring down the Web server. Don’t even attempt to build DLL-based servers until your server has been extensively tested as an EXE and you’re sure it’s stable-it’ll save you a few trips to the NT Quick Boot.</p>
<h2>Multi-use EXE server</h2>
<p>
This out of process OLE server creates a single, reusable instance of an OLE server that is shared among many simultaneous requests. It’s slightly slower than a DLL-based server because the server runs externally to the Web server. However, because the instance stays loaded there’s no load time penalty once it’s been loaded. Requests are queued, but you can run multiple <i>different</i> multi-use servers. </p>
<h2>Single-use EXE server</h2>
<p>
For use with FoxISAPI, single-use servers aren’t much different from multi-use servers because FoxISAPI recycles a single reference between hits. Single-use servers have additional potential, though. In the future it might be possible to load multiple instances of the same single-use server and have them served by FoxISAPI. Currently, though, FoxISAPI blocks all calls while another call is executing.</p>
<p>
For ultimate speed, you should use a DLL server. They provide the highest speed but they’re volatile-a crash in the OLE server can crash the entire Web server and will require a server shutdown. Multi-use servers probably offer the best compromise between performance and flexibility. Multi-use server speed is excellent and it’s possible to shut them down without shutting down the Web server.</p>
<h1>Limited scalability</h1>
<p>
FoxISAPI’s current inability to run more than one instance of the same server at the same time-and thus scale up under heavy load-is a major limitation. If you outgrow a single instance of your OLE server, FoxISAPI can’t easily offload requests to another server either on the same machine or across the network. FoxISAPI can handle only one OLE Automation call at a time. It’s possible to call <i>different</i> OLE servers simultaneously by making copies of FoxISAPI.DLL and using a different name to call specific multi-use OLE servers-essentially one ISAPI DLL per OLE server. But even using this workaround you can’t call the same server simultaneously; running multiple small servers can severely impact system resources because VFP OLE servers tend to be fairly memory hungry (you can check this out yourself with the new NT 4.0 task manager). Any busy site that’s getting multiple simultaneous hits can greatly benefit from having multiple sessions processing requests at the same time. While the site’s overall throughput might not improve, its responsiveness to the user can be greatly enhanced if multiple requests are serviced simultaneously. Weigh this scalability limitation carefully when starting a Web project that uses FoxISAPI! </p>
<p>
Despite this scalability limitation, FoxISAPI makes an excellent tool to build Web applications. A single FoxPro FoxISAPI-based server can go a long way-FoxPro’s lightning-fast data access allows it to process many requests in subsecond times. I’ve successfully clocked more than 80,000 hits on a single VFP session in the past-more than enough for many small to medium-sized Web apps. But it’s important to keep the limitation in mind: When you hit the fan with either total volume or extended query times timing out clients, there’s nowhere to go to upscale.</p>
<h1>More to come</h1>
<p>
This article is the first in a series that discusses some of the Web tools available to connect your FoxPro data to the Web. Next month I’ll expand on some of the concepts described here with a look at Web Connection to show you how you can take advantage of its application framework to build scalable Web apps in record time. The following month I’ll dig into Microsoft’s Active Server and its advances with building a powerful server-side scripting engine that also allows database access and connectivity to OLE servers.</p>
<p>
&#09;&#09;&#09;  <b>05STRAHL.ZIP at www.pinpub.com/foxtalk</b></p>
<p>
<i>Rick Strahl and his company, West Wind Technologies in Hood River, Oregon (Portland area) specialize in Internet and Web-based application design and implementation. He is the author of West Wind Web Connection, a toolset that provides scalable Web connectivity to Visual FoxPro. Rick recently contributed several chapters to Using Visual FoxPro 5.0 (Que) and was a speaker at the Visual FoxPro DevCon Ô96. 541-386-2087, rstrahl@west-wind.com, http://www.west-wind.com/.</i></p>
<P align="center"><a
href="http://www.pinpub.com/foxtalk/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about
FoxTalk and Pinnacle Publishing, visit their website at</strong> <br>
<a href="http://www.pinpub.com/foxtalk/"><strong>http://www.pinpub.com/foxtalk/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content..</font></p>

<P>This article is reproduced from the May 1997
issue of FoxTalk. Copyright 1997, by Pinnacle Publishing, Inc.,
unless otherwise noted. All rights are reserved. FoxTalk is an
independently produced publication of Pinnacle Publishing, Inc.
No part of this article may be used or reproduced in any fashion
(except in brief quotations used in critical articles and
reviews) without prior consent of Pinnacle Publishing, Inc. To
contact Pinnacle Publishing, Inc., please call (800)788-1900 or
(206)251-1900.</p>
</font></BODY>
</HTML>
