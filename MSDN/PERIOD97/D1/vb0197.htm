<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VB Explorations: Pop Goes the List Server </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1>VB Explorations: Pop Goes the List Server</h1>
<p>
Dan Appleman</p>
<p>
Dan, just back from five great days of instruction at the Disney Institute-he took classes in TV production (both studio and field), clay animation, radio disk jockeying, imagineering, and cooking-explains how he set up Desaware’s list server using a state machine modeling approach. </p>
<p>
I have this love-hate relationship with the Internet. Yes, I enjoy surfing the Web. Yes, I find having a Web page an incredibly effective way for my company to offer product information, and for me to offer updates and corrections on my book (www.desaware.com, for those who are interested). And, yes, I use Internet e-mail extensively (my e-mail is divided about equally between my CompuServe and Internet accounts).</p>
<p>
But like many others, I sometimes find it a challenge-to put it mildly-to keep up with the technology. <i>[In response to my message bewailing the complexity of DCOM and OLE DB, Dan recently wrote me this: “If you’re not overwhelmed by the new technology, you’re not doing it right. Everyone else is.”-Ed.]</i> And I can’t help feeling that, as exciting and important as the Internet is, it certainly can’t be as overwhelmingly important as all of the media hype would suggest. Nevertheless, I’ve put a fair amount of effort into learning the technology. For example, I set up most of Desaware’s site myself. No, I don’t mean the Web authoring-although I did author a few pages-I mean that I physically installed the system, installed the software, configured the Web server, and so on. I even learned about firewalls and router programming. Not necessarily the most efficient use of my time, but it did help me learn the material in a way that just reading about it in a book could never accomplish.</p>
<p>
But when it came time for Desaware to implement a list server, the approach definitely wasn’t obvious. List servers manage mailing lists. They must have the ability to do the following:</p>
<p>
Subscribe new users to the mailing list.</p>
<p>
Remove users from the mailing list on request.</p>
<p>
Broadcast a message to all users on the mailing list.</p>
<p>
List server features can be implemented in many different ways. For example, you may want to allow anyone to subscribe to the list, or you might want to limit list management to certain accounts or to the server program itself. Similarly, you may want to rebroadcast any message sent to the list account, or you may prefer to limit message broadcasting to specific accounts.</p>
<p>
To suit my purposes, the logical approach was to go out and buy one of the commercial-quality list servers on the market. There are probably a few shareware/freeware servers available as well. But it occurred to me that a list server is the kind of simple, well-defined program that would be interesting to write using VB. I was right about it being well-defined. As for simple-well, that’s another story.</p>
<p>
But before I go on, I don’t want you to get your hopes up. This article isn’t going to include a complete list server. The one I wrote is very specific to my needs and wasn’t intended to be distributed. But don’t be too disappointed. This is, after all, a column on programming-and the concepts and code that you’ll see here are applicable to a wide range of tasks, especially those relating to data transfer on the Internet.</p>
<h2>POP3 and the Internet Control Pack </h2>
<p>
I decided to start with Microsoft’s Internet Control Pack (ICP), which is a set of ActiveX controls for handling Internet data transfers. ICP was in beta as I wrote this, but the controls weren’t bad. I found only one major bug: The POP control would sometimes hang when reading a zero length message. However, I was able to work around this without too much trouble.</p>
<p>
ICP actually includes a sample list server program, but it didn’t have the features I was looking for. It also wasn’t terribly reliable (though keep in mind that this was the beta version), so I took a look at what would be involved in writing the program from scratch.</p>
<p>
I was primarily interested in the Simple Mail Transfer Protocol (SMTP) and Post Office Protocol (POP) controls, because they’re the most common protocols used for Internet e-mail. Your Internet server (or service provider) runs SMTP and POP<i> server </i>programs that process incoming e-mail requests. As a VB programmer, you’ll be more interested in the <i>client</i> side, which is implemented by the ICP controls. The SMTP control is used to send mail; the POP control to receive it.</p>
<p>
The first step that any list server must do is log in to the e-mail account assigned to the mailing list and read the messages that have arrived in that account. For the rest of this article, I’ll focus on the process of logging in and logging off an e-mail account. It may not sound like much, but the procedure used to accomplish this supposedly simple task is very similar to that of receiving and sending messages, reading Web pages via Hyper Text Transfer Protocol (HTTP), transferring files via File Transfer Program (FTP), and so on.</p>
<h2>The joys of asynchronous commands</h2>
<p>
Why do I describe logging into your e-mail account as a “supposedly simple task”? Consider the three methods that the POP control uses to perform this task:</p>
<p>
<b>Connect</b>-Connects to the specified server, opening a TCP/IP connection to the POP server program on your Internet server or ISP provider.</p>
<p>
<b>Authenticate</b>-Logs the control onto the server using the user account name and password specified.</p>
<p>
<b>Quit</b>-Logs off and disconnects the control.</p>
<p>
Seems straightforward enough, doesn’t it? The test program consists of a form with a label control that will be updated using the following function:</p>
<pre><font face="Courier New" size="3">Public Sub UpdateStatus(msg As String)
   Dim delay&amp;
   lblStatus = msg
   Debug.Print msg
   lblStatus.Refresh
   ' This is a delay for demonstration purposes 
   ' only. Remove it from any real code.
   For delay = 1 To 1000000
   Next
End Sub</font></pre>
<p>
The label control will help keep track of the status, and Debug.Print statements are included to produce a trace of the operation. To find out if the operations are succeeding, add another trace statement to the controls Error event:</p>
<pre><font face="Courier New" size="3">Private Sub POP1_Error(Number As Integer, _
    Description As String, Scode As Long, Source _ 
    As String, HelpFile As String, HelpContext _
    As Long, CancelDisplay As Boolean)
Debug.Print &quot;Error: &quot; &amp; Description &amp; &quot; State: &quot; _
    &amp; POP1.State &amp; &quot; ProtocolState: &quot; &amp; _
    POP1.ProtocolState
End Sub</font></pre>
<p>
Now try a simple Connect and Disconnect sequence as shown in the Start1 code for project PINPOP1.VBP provided with this month’s Subscriber Downloads (www.pinpub.com/vbd). (Be sure the constants UserID and UserPassword are set to a valid user name and password on <i>your</i> mail system. Also be sure to set the RemoteHostname constant to the domain name or IP address of <i>your</i> mail server. You won’t be able to test the program successfully if you don’t.)</p>
<pre><font face="Courier New" size="3">Private Sub cmdStart1_Click()
    POP1.UserID = UserID
    POP1.Password = UserPassword
    POP1.RemoteHost = RemoteHostname
    
    UpdateStatus &quot;Connecting&quot;
    POP1.Connect
    UpdateStatus &quot;Authenticating&quot;
    POP1.Authenticate
    UpdateStatus &quot;Disconnecting&quot;
    POP1.Quit
    UpdateStatus &quot;Disconnected&quot;
End Sub</font></pre>
<p>
When you run this program, you’ll see the following debug trace:</p>
<pre><font face="Courier New" size="3">Connecting
Authenticating
Error: Wrong protocol or connection state for the
       requested transaction or request 
       State: 1 ProtocolState: 0
Disconnecting
Error: Wrong protocol or connection state for the 
       requested transaction or request 
       State: 1 ProtocolState: 0
Error: Quit Command failed. Error while quitting. 
       State: 1 ProtocolState: 0
Disconnected</font></pre>
<p>
What’s going on? The control is reporting that the wrong protocol or connection state exists at the time the POP1.Authenticate command is issued. What are the connection and protocol states? The connection state can be determined from the POP control’s state property and can take on the following values:</p>
<table>
<tr valign=top>
<td>
1</td>
<td>
Connection in progress.</td>
</tr>
<tr valign=top>
<td>
2</td>
<td>
Resolving host (if RemoteHost property is a domain</td>
</tr>
<tr valign=top>
<td>
 </td>
<td>
name instead of an IP address)</td>
</tr>
<tr valign=top>
<td>
3</td>
<td>
Host is resolved</td>
</tr>
<tr valign=top>
<td>
4</td>
<td>
Connection Established</td>
</tr>
<tr valign=top>
<td>
5</td>
<td>
Connection is closing</td>
</tr>
<tr valign=top>
<td>
6</td>
<td>
Connection is closed.</td>
</tr>
</table><br>
<p>
The protocol state indicates whether the user is logged in to the mail server. It can be determined from the control’s ProtocolState property and can take on the following values:</p>
<table>
<tr valign=top>
<td>
0</td>
<td>
No connection exists.</td>
</tr>
<tr valign=top>
<td>
1</td>
<td>
Authorization (user login) is being performed.</td>
</tr>
<tr valign=top>
<td>
2</td>
<td>
Authorization complete. User is logged in to the</td>
</tr>
<tr valign=top>
<td>
 </td>
<td>
account.</td>
</tr>
<tr valign=top>
<td>
3</td>
<td>
Logout in progress.</td>
</tr>
</table><br>
<p>
Looking back at the debug trace, you’ll see that the State property was 1 at the time the Authenticate method was called. In other words, the control was still in the process of creating the connection.</p>
<p>
You’ve just run into one of the critical issues for using not only this control, but also for using Winsock and most other Internet programming tools. Most of them operate <i>asynchronously</i>. When you call a method, the control begins the operation you requested and returns immediately. It then triggers some sort of event when the operation is complete.</p>
<h2>Handling asynchronous operations: the brute force approach</h2>
<p>
One approach for handling asynchronous operations is to enter a DoEvents loop, waiting until the control has completed one command before starting the next. This approach is shown here:</p>
<pre><font face="Courier New" size="3">Private Sub cmdStart2_Click()
    POP1.UserID = UserID
    POP1.Password = UserPassword
    POP1.RemoteHost = RemoteHostname
    
    UpdateStatus &quot;Connecting&quot;
    POP1.Connect
    Do
        DoEvents
    Loop While POP1.State &lt;&gt; 4
    UpdateStatus &quot;Authenticating&quot;
    POP1.Authenticate
    Do
        DoEvents
    Loop While POP1.ProtocolState &lt;&gt; 2
    UpdateStatus &quot;Disconnecting&quot;
    POP1.Quit
    Do
        DoEvents
    Loop While POP1.Busy
    UpdateStatus &quot;Disconnected&quot;
End Sub</font></pre>
<p>
This code works correctly but has two problems. First, it includes no error handling. If for some reason the control can’t connect or log in, the code can get stuck in an infinite loop. This means that each of these wait loops may need to be modified to watch for errors, either by polling the control’s Error property or setting a global variable during the Error event and using it as an indication to exit the loop. Next, this code is subject to re-entrancy problems. To illustrate this, try clicking on the Start2 button while an operation is in progress. You can almost count on a runtime error. This means you need to either disable every control that might restart the operation, or set a global flag indicating that the command shouldn’t be executed.</p>
<h2>Handling asynchronous operations: <BR>the state machine approach</h2>
<p>
I’ve long claimed that the DoEvents command is evil and rarely necessary in a well-designed application. It’s just too hard to know what’s going on in your program. So it won’t surprise you that I never even considered this approach (I actually created the PINPOP1 project just to demonstrate these issues for this article).</p>
<p>
The solution I used is illustrated in the PINPOP.VBP project, which implements a finite state machine. At any given time the application may be in one of eight possible states:</p>
<table>
<tr valign=top>
<td>
<ul>
<li>
<b>0</b></li>
</ul>
</td>
<td>
Logged off</td>
</tr>
<tr valign=top>
<td>
<ul>
<li>
<b>1</b></li>
</ul>
</td>
<td>
Connecting</td>
</tr>
<tr valign=top>
<td>
<ul>
<li>
<b>2</b></li>
</ul>
</td>
<td>
Connected</td>
</tr>
<tr valign=top>
<td>
<ul>
<li>
<b>3</b></li>
</ul>
</td>
<td>
Authenticating</td>
</tr>
<tr valign=top>
<td>
<ul>
<li>
<b>4</b></li>
</ul>
</td>
<td>
Authenticated</td>
</tr>
<tr valign=top>
<td>
<ul>
<li>
<b>5</b></li>
</ul>
</td>
<td>
Ready to start quit</td>
</tr>
<tr valign=top>
<td>
<ul>
<li>
<b>6</b></li>
</ul>
</td>
<td>
Quitting in progress</td>
</tr>
<tr valign=top>
<td>
<ul>
<li>
<b>7</b></li>
</ul>
</td>
<td>
Disconnected (will switch to 0)</td>
</tr>
</table><br>
<p>
A state machine constantly watches for external events such as error events, state change events, protocol state change events, and timer events. When an event occurs, the software checks the current state of the system. Depending on the event and the current state, the machine may do nothing, perform an operation, or switch to a new state.</p>
<p>
The main state machine engine is the timer event that is triggered repeatedly once the timer is enabled by the Start button. Note the distinction between <i>machine</i> state-the current state of the state machine as indicated by the CurrentState variable-and the <i>control</i> state (or POP state), which is the value of the control’s state property:</p>
<pre><font face="Courier New" size="3">Private Sub Timer1_Timer()
    Dim theName$
    Dim alias$
    ' We're busy
    If POP1.Busy Then Exit Sub
    Debug.Print &quot;Machine State: &quot; &amp; CurrentState
    Select Case CurrentState
        Case 0  ' Time to log on
            POP1.UserID = UserID
            POP1.Password = UserPassword
            POP1.RemoteHost = RemoteHostname
            CurrentState = 1
            UpdateStatus &quot;Machine State: Connecting&quot;
            POP1.Connect
        ' Case 1   ' Connection in progress - wait
        Case 2  ' Connection made - authenticate
            UpdateStatus &quot;Machine State: Authenticating&quot;
            CurrentState = 3
            POP1.Authenticate
        ' Case 3    'Authorization in progress - wait
        Case 4  ' Authorized
            UpdateStatus &quot;Machine State: Authorized&quot;
            CurrentState = 5    ' For demo, disconnect now
        Case 5  ' Ready to quit
            CurrentState = 6
            UpdateStatus &quot;Machine State: Disconnecting&quot;
            POP1.Quit
        ' Case 6    ' quitting in progress
        Case 7  ' Quit
            UpdateStatus &quot;Machine State: Disconnected&quot;
            Timer1.Enabled = False
    End Select
End Sub</font></pre>
<p>
Regardless of the state, if the control is busy (unable to accept commands), you wait for the next timer event. The first time through, the machine will be in state zero. In this state the software initializes the connection and user parameters, switches the current state to 1 (connecting), then calls the Connect method. What happens when the timer event takes place while the machine is in this state? Nothing. So how does the machine get out of state 1? To see this, take a look at the StateChanged event code:</p>
<pre><font face="Courier New" size="3">Private Sub POP1_StateChanged(ByVal State As Integer)
    Select Case State
        Case prcConnected
            UpdateStatus &quot;POP State: Connected&quot;
            Select Case CurrentState
                Case 1
                    CurrentState = 2
            End Select
        Case prcDisconnected
            UpdateStatus &quot;POP State: Disconnected&quot;
            Select Case CurrentState
                Case 6
                    CurrentState = 7
            End Select
        Case prcConnecting
            UpdateStatus &quot;POP State: Connecting&quot;
        Case prcDisconnecting
            UpdateStatus &quot;POP State: Disconnecting&quot;
        
    End Select
End Sub</font></pre>
<p>
This event will first be triggered when you call the Connect method and the control changes its internal state to Connecting. However, this event doesn’t do anything other than update the status. Only when the control enters the Connected state will the machine state be changed to 2.</p>
<p>
Now look back at the timer code. When the timer event happens in machine state 2, the code will set the machine to state 3 and call the Authenticate command. Machine state 3 is like state 1: the timer event has no effect for this state. The next state transition can be found in the ProtocolStateChanged event shown here:</p>
<pre><font face="Courier New" size="3">Private Sub POP1_ProtocolStateChanged(ByVal _
  ProtocolState As Integer)
    Select Case ProtocolState
        Case prcAuthorization
            UpdateStatus &quot;Protocol: Authenticating&quot;
        Case prcTransaction
            UpdateStatus &quot;Protocol: Authenticated&quot;
            Select Case CurrentState
                Case 3
                    CurrentState = 4
            End Select
        Case prcUpdate
            UpdateStatus &quot;Protocol: Update&quot;
&#09;End Select
End Sub</font></pre>
<p>
The prcTransaction protocol (2) indicates that the login was successful and switches to machine state 4. The timer code in this case then switches from state 4 to state 5 on the next timer event, but in a real application you’d now be logged in and ready to perform whatever further operations were required. Until another operation is requested, the machine could just remain in state 4. What happens if an error occurs along the way? The Error event will be triggered, providing a way to handle each error based on the current state. As you can see in the following code, the machine state is set directly to state 5 if authentication fails:</p>
<pre><font face="Courier New" size="3">Private Sub POP1_Error(Number As Integer, Description _
   As String, Scode As Long, Source As String, _
   HelpFile As String, HelpContext As Long, _
   CancelDisplay As Boolean)
    Select Case CurrentState
        Case 1  ' Can't log on
            Debug.Print &quot;Log on failure: &quot; &amp; _
               Description CurrentState = 0
        Case 3  ' Can't authenticate
            Debug.Print &quot;Authentication failure: &quot; &amp; _
               Description
            CurrentState = 5
        Case 6  ' Can't quit
            CurrentState = 5    ' Try again
            Debug.Print &quot;Disconnect failure: &quot; &amp; _
               Description
        Case Else ' Other error
            Debug.Print &quot;Other error: &quot; &amp; Description
    End Select
    Debug.Print &quot;Error - POP state: &quot; &amp; POP1.State _
       &amp; &quot; Protocolstate: &quot; &amp; POP1.ProtocolState
End Sub</font></pre>
<h2>Conclusion</h2>
<p>
Why is this state machine approach better than the brute force DoEvents approach? After all, it <i>is</i> more work. The biggest advantage is that you can precisely determine the behavior of the application. With the DoEvent approach you have to carefully block any invalid operations. With a state machine, only those operations that you specifically allow will occur. You can determine exactly what will happen for each event that can impact the state machine (you’ll notice that this example doesn’t cover every possibility, but it does handle the most common situations).</p>
<p>
One more thing-try clicking the Start button while an operation is in progress. It causes no problems because the Start button just enables the timer for the state machine. While the machine is operating, the timer is on anyway.</p>
<p>
You can extend this approach for all of the controls’ asynchronous operations which include reading and deleting messages. This approach also applies to the SMTP control when sending messages, and to the other controls in the Internet Control Pack.</p>
<p>
Working with state machines can take getting used to (see my March 1995 column for another example) but once you’re accustomed to them, they can make life much easier and improve the reliability of your code. How many states do “real-world” list servers need? I used 29 states to implement the Desaware list server and it took me about two days to write. We’re using it to broadcast periodic notices relating to products, book updates, or major changes to our Web site, and you’re welcome to subscribe as well. Just send a message to listserv@desaware.com and place the word “Subscribe” in the subject or message text. s</p>
<p>
<i>Dan Appleman, author of Visual Basic Programmer’s Guide to the Windows API, Visual Basic Programmer’s Guide to the Win32 API, and How Computer Programming Works, has been developing applications for Microsoft Windows since its release in 1985. In 1991 he founded Desaware Inc., a Campbell, California-based software company focusing on component-based software and advanced tools for developers. 70303.2252@compuserve.com, dan@desaware.com.</i></p>
    <P align="center"><a
    href="http://www.pinpub.com/vbd/"><img src="Pinnacle.gif"
    border="0" width="216" height="72"></a></p>
    <P align="center"><strong>To find out more about
    Visual Basic Developer and Pinnacle Publishing, visit their
    website at</strong>: <a href="http://www.pinpub.com/vbd/"><strong>http://www.pinppub.com/vbd/</strong></a></p>
    <P align="center"><font size="1">Note: This is not
    a Microsoft Corporation website. <br>
    Microsoft is not responsible for its content.</font></p>
    <p><font size="1">This article is reproduced from the
    January 1997 issue of Visual Basic Developer. Copyright
    1997, by Pinnacle Publishing, Inc., unless otherwise noted.
    All rights are reserved. Visual Basic Developer is an
    independently produced publication of Pinnacle Publishing,
    Inc. No part of this article may be used or reproduced in any
    fashion (except in brief quotations used in critical articles
    and reviews) without prior consent of Pinnacle Publishing,
    Inc. To contact Pinnacle Publishing, Inc., please call
    (800)&nbsp;788-1900 or (206)&nbsp;251-1900.</font></p>
</font></BODY>
</HTML>
