<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Avoid Rounding Errors by Using the Decimal Data Type </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1>Avoid Rounding Errors by Using the Decimal Data Type</h1>
<p>
Andy Baron and Mary Chipman</p>
<p>
<i>Working with floating-point numbers frequently causes headaches for developers. In this article, Andy and Mary explain the new Decimal data type and how you can use it to avoid precision errors in floating-point computations.</i></p>
<p>
WE like to think of computers as being highly accurate, but eventually all Access programmers discover that performing math with floating-point numbers can produce inaccurate results. Decimal fractions often donít have exact binary equivalents, which can cause rounding errors to creep into VBA (or Access Basic) computations when Single or Double data types are used. Many programmers have elected to work around these problems by choosing the Currency data type because itís a <i>scaled integer</i>. Integer scaling relies on the fact that all decimal whole numbers have exact binary equivalents-they can be exactly represented by some combination of powers of 2. The Currency scaled integer data type uses whole numbers to store fractions by multiplying the fractional part of the number by 10,000, eliminating the need for the decimal point, and then storing it internally in binary form as an integer. The down side of using the Currency data type is that itís capable of only four digits of precision to the right of the decimal point.</p>
<p>
VBA 3.0 in Access 97 introduces the Decimal data type as a promising alternative to the limitations of the Currency and floating-point (Single and Double) data types. The Decimal data type uses 14 bytes, which allows it to store numbers that can be much larger and more precise than Currency values, which are stored using only 8 bytes. The range of values that you can store using the Decimal data type is in inverse proportion to the number of decimal places of precision you need. As more decimal places are required, the available range gets smaller. At one extreme, you can store a number with 28 decimal places, but the number would have to fall within the very narrow range between approximately -8 and 8. At the other extreme, if youíre working with whole numbers that require no decimal places, the available range is approximately +/-8 * 1028 (thatís an 8 followed by 28 zeros). Using the Decimal data type isnít straightforward. You canít declare a variable “As Decimal”-you have to declare it as a Variant and then convert it to the Decimal subtype using the CDec() function. The following procedure uses the VBA TypeName() function to identify the data type of the number and the CDec() function to convert a Double to the Decimal subtype. Floating-point errors exposed by repeatedly incrementing a fractional amount are eliminated when the fractions are converted to Decimal before being incremented: </p>
<pre><font face="Courier New" size="3">Sub TestDataTypes()
  Dim intI As Integer
  Dim dblSum As Double
  Dim varDblSum As Variant
  Dim varDecSum As Variant

  For intI = 1 To 10000
    dblSum = dblSum + 0.0001
  Next intI
  Debug.Print TypeName(dblSum) &amp; &quot;:&quot;; dblSum
  'This prints, &quot;Double: .999999999999906&quot;

  For intI = 1 To 10000
    varDblSum = varDblSum + 0.0001
  Next intI
  Debug.Print &quot;Variant &quot; &amp; TypeName(varDblSum) &amp; _
   &quot;:&quot;; varDblSum
  'This prints, &quot;Variant Double: 0.999999999999906&quot;
  
  For intI = 1 To 10000
    varDecSum = varDecSum + CDec(0.0001)
  Next intI
  Debug.Print &quot;Variant &quot; &amp; TypeName(varDecSum) &amp; _
   &quot;:&quot;; varDecSum
  'This prints,&quot;Variant Decimal: 1&quot;
End Sub</font></pre>
<p>
In the February 1997 issue of <i>Smart Access</i>, Luke Chung demonstrated the errors that VBA can cause when performing subtractions, and he presented a function that avoids those errors by rounding the result to the appropriate number of decimal places. The following function shows how the Decimal data type can also be used to avoid subtraction errors:</p>
<pre><font face="Courier New" size="3">Function SubtractFloatingPoint(dblNum1 As Double, _
  dblNum2 As Double) As Double
    
    Dim varDec1 As Variant
    Dim varDec2 As Variant
    
    ' Examine the difference between the numbers.
    Debug.Print &quot;Subtraction with Doubles: &quot;; _
     (dblNum1 - dblNum2)
 
   ' Convert to Decimal data type using CDec function.
    varDec1 = CDec(dblNum1)
    varDec2 = CDec(dblNum2)
    Debug.Print &quot;Subtraction with Decimals: &quot;; _
     (varDec1 - varDec2)
    SubtractFloatingPoint = (varDec1 - varDec2)
    
End Function</font></pre>
<p>
The following is the output from the Debug Window when the function is passed 1.001 and 1, which clearly shows the problem with subtracting floating point numbers. Youíd expect the difference between 1.001 and 1 to be 0.001, but that isnít the case:</p>
<pre><font face="Courier New" size="3">? SubtractFloatingPoint(1.001, 1)
Subtraction with Doubles:  9.9999999999989E-04 
Subtraction with Decimals:  0.001</font></pre>
<p>
Using the CDec function to convert only one side of the subtraction also works, as shown by the following:</p>
<pre><font face="Courier New" size="3">? 1.001-1
 9.9999999999989E-04 

? CDec(1.001)-1
 0.001 

? 1.001-CDec(1)
 0.001</font></pre>
<p>
Although the third result might seem surprising, hereís whatís probably happening under the covers: The number that wasnít explicitly converted using the CDec() function is converted to a decimal anyway when VBA performs the computation.</p>
<p>
Be careful to use the CDec() function on the inputs to your computation and not just on the result. Converting the result wonít eliminate errors, as shown by the following example from the Debug Window:</p>
<pre><font face="Courier New" size="3">? CDec(1.001-1)
 0.00099999999999989</font></pre>
<p>
In this case the incorrect result had already been computed before CDec() was called.</p>
<p>
Before the introduction of the Decimal data type, you had to write an algorithm to round values to the desired number of decimal points, unless the range and precision of the Currency type was adequate. The Decimal data type now can be used to avoid errors involving floating point numbers-unless youíre dealing with extremely large numbers or numbers with an extraordinary number of decimal places. </p>
<p>
The down side of scaled integer data types, such as Currency and Decimal, is that theyíre slightly less efficient in their use of memory because they need more bytes of storage, but youíll gain efficiency by not having to write special code to handle rounding. If the Decimal ever graduates from being just a Variant subtype to being a full-fledged data type of its own, you may be able to avoid ever using troublesome floating-point numbers. s</p>
<p>
<i>Andy Baron, MCP, is president of Key Data Systems Inc. He enjoys solving business problems by designing and implementing custom database applications. In 1996 and 1997 Andy was named an Access Most Valued Professional for his contributions to Microsoftís online support. Andy_Baron@msn.com.</i></p>
<p>
<i>Mary Chipman, MCP, MCT, MCSD, is a senior consultant with MCW Technologies. She is a co-author of</i> Microsoft Access and SQL Server Developerís Handbook<i> and is a regular contributor to Smart Access. She has been recognized by Microsoft as an MVP on the MSACCESS forums on CompuServe, MSN, and the Microsoft Internet newsgroups. mchip@msn.com or 71760.243@compuserve.com.</i></p>
<P align="center"><a
href="http://www.pinpub.com/access/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about Smart
Access and Pinnacle Publishing, visit their website at</strong>:</p>

<P align="center"><a
href="http://www.pinpub.com/access/"><strong>http://www.pinpub.com/access/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content.</font></p>

<P>This article is reproduced from the May 1997
issue of Smart Access. Copyright 1997, by Pinnacle Publishing,
Inc., unless otherwise noted. All rights are reserved. Smart
Access is an independently produced publication of Pinnacle
Publishing, Inc. No part of this article may be used or
reproduced in any fashion (except in brief quotations used in
critical articles and reviews) without prior consent of Pinnacle
Publishing, Inc. To contact Pinnacle Publishing, Inc., please
call (800)788-1900 or (206)251-1900.</p>
</font></BODY>
</HTML>
