<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Exchange Data Between a Java Applet and an MFC Program Over the Internet </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1>Exchange Data Between a Java Applet and an MFC Program Over the Internet</h1>
<p>
Sergey Michalev</p>
<p>
<i>Internet programming presents many challenges. One is arranging for programs written in different languages to communicate. Another is taking advantage of work that has already been done. This article shows how to use the power of ODBC to access a database, and at the same time build an easy user interface with a Java applet.</i></p>
<p>
RECENTLY I’ve been researching different ways of accessing a database over the Internet. I think this kind of work is becoming a very important potential market, especially with the arrival of new standards of Internet technology such as Java. There are many ways to reach a database over the Internet, and the challenge is to find the best one for your situation.</p>
<p>
My first solution was to connect a page of HTML to a CGI program written in Visual C++ 4.2 that used ODBC to reach an Access database on an NT server. When the user pressed the Submit button on the HTML page, the CGI program got the form values from the Web browser, performed a query using ODBC, and generated new HTML that included both the response to the user’s request and a Submit button, which allowed the user to continue accessing the database. </p>
<p>
However, this solution has a problem, at least with Microsoft’s Internet Explorer 3.0. The browser stores form entries in a small cache, so that it’s still filled out when the user goes back to a form. After a while, the browser just hangs because it has limited resources to store these entries. For example, my table has 30 edit controls and the browser hangs after about 20 submits. To prevent this, the user should use the Back button from time to time to free up the stored entries. Most users are unlikely to support this approach.</p>
<p>
Despite this flaw, I really liked the idea of running a program on the server that has native access to the database. I believe it makes the server side as efficient as possible for data access. Therefore, my second approach was to use two MFC programs, one on the server and one on the client, that talk to each other over the Internet. The client is nothing more than the user interface and the socket code. The server side is a small user interface, an ODBC interface, and socket code. If we replace our NT server with a UNIX server running another DBMS, we can create a new server-side program that has native access to data with the new DBMS. </p>
<p>
This approach works well, especially for intranets. Because both programs were developed by the same programmer, the amount of data they pass is limited, which is critical in some environments. The disadvantage is that the client must be distributed to each individual user, and there’s some work involved in writing the socket code on each side.</p>
<p>
This article will discuss the third solution that I’ve developed: running a Java applet on the client that communicates with an MFC program running on the server side. Unlike the second solution, you don’t have to preinstall the program on the client because it comes as an applet with the Web page. It will be downloaded each time the Web page is accessed, which isn’t usually a problem because applets are relatively small. I also found it interesting to “marry” Java and MFC programs so that they could communicate with each other. I’ll show you some techniques for this.</p>
<p>
The environment used for this sample included the following: On the client side, we have Windows 95, Microsoft Internet Explorer 3.0 as the browser, and a Java applet written with the Java Development Kit (JDK) 1.1. On the server side, we used Windows NT Server 4.0, Microsoft Internet Information Server 2.0 as the Web server, this sample program (written with Visual C++ 4.2), Winsock 1.1, and Access 7.0 as the database server.</p>
<h2>How does it work?</h2>
<p>
Figure 1 shows how the client and server sides share the work. First, the browser downloads the Web page and applet using the standard HTTP protocol. The applet runs, establishes a connection with the MFC program, and provides a GUI to the database through ODBC. The user interacts with the browser, which interacts with the applet, which interacts with the server-side MFC program, which interacts with ODBC, which interacts with the database. The reply from the database goes back through the chain to the user, who may make another query or request, and so on.</p>
<p><img src="jmfc01.gif"></p>
<p>
<b>Figure 1. The work is shared between client- and server-side programs.</b></p>
<p>
First, we need to address security. The MFC program can handle user names and passwords. Programmers can implement their own versions of secure complexity, so every Java applet and MFC program can have a unique login procedure. In this example, I’ve used a file called PASSWORD.TXT, which is kept on the server, that contains user names and passwords. You might choose a more complex approach.</p>
<p>
The interaction between the user, applet, and the server-side program goes like this: At first the applet is inactive, and the server program is just listening. When the applet starts, it gets the user name and password with the login dialog (see Figure 2) and sends them to the server, which opens a socket connection. The server program checks the user name and password against the password file, and if they’re valid, it returns “O” (for OK) to the applet. If they aren’t valid, it returns “P” (for password problem) and closes the socket. If the login worked, the applet displays the main interface shown in Figure 3.</p>
<p><img src="javamfc2.gif"></p>
<p>
<b>Figure 2. A simple dialog gets a user name and password for the applet to pass along.</b></p>
<p><img src="javamfc3.gif"></p>
<p>
<b>Figure 3. The applet interface displays database records, with buttons for navigation.</b></p>
<p>
The circle at the lower left of the applet interface is green if the applet is ready to send another request to the database, and red when it isn’t ready. If the user clicks the button labeled “|&lt;“, the applet sends “S” for start to the server program. If the user clicks “&lt;“, the applet sends “B” for back. Clicking “&gt;“ sends “F” for forward, and clicking “&gt;|” sends “E” for end. After any of these four communications from the applet, the server sends a string that represents a database record, and the applet displays it in the other fields of the interface. When the applet closes, it sends “END” to the server, which then closes the socket.</p>
<h2>MFC program</h2>
<p>
Let’s look briefly at the program that runs on the server, which was built with Visual C++ 4.2. The interface, shown in Figure 4, is simple: just a log of events the program handled.</p>
<p><img src="javamfc4.gif"></p>
<p>
<b>Figure 4. The server interface echoes requests and responses.</b></p>
<p>
Because this is a server program, it needs to listen for requests and then reply. A great example of the work involved in building such a server is the CHATSVR sample provided with Visual C++. This sample has essentially the same structure as CHATSVR, with some changes so that it can communicate with a Java applet rather than with another Visual C++ program.</p>
<p>
The Java applet will write to the socket using DataOutputStream::writeUTF(String str). This writes an eight-bit character string; the first two bytes give the number of bytes to follow (Big-Endian). For example, the following (in hex) means “VC++”: </p>
<pre><font face="Courier New" size="3">00 04 56 43 2B 2B </font></pre>
<p>
The server writes and reads messages to and from the applet in the Serialize method of the Msg class. That function looks like this:</p>
<pre><font face="Courier New" size="3">void CMsg::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring())
    {
        short k;
        short i;
        k = (short)strlen(m_Buffer);
        ar &lt;&lt; Swap(k);
        for (i = 0; i &lt; k; i++)
            ar &lt;&lt; m_Buffer[i];
    }
    else
    {
        short    w;
        unsigned char    ch;
        m_Buffer[0] = 0;

        ar &gt;&gt; w;
        w = Swap(w);
        if (w &gt; 1000 - 1) w = 1000 - 1;
        for (short i = 0; i &lt; w; i++)
        {
            ar &gt;&gt; ch;
            m_Buffer[i] = ch;
        }
        m_Buffer[i] = 0;

    }
    
    ar.Flush();
}</font></pre>
<p>
As you can see, this code sends out (or fills in) a single member variable called m_Buffer, which was declared in Msg.h:</p>
<pre><font face="Courier New" size="3">char m_Buffer[1000];</font></pre>
<p>
The Swap function handles the conversion from Big-Endian (used by the Java applet) to Little-Endian (used by Windows programs). Big-Endian systems write the most significant bits of a multi-byte field first, so that “4” would be written like this:</p>
<pre><font face="Courier New" size="3">00 04</font></pre>
<p>
Little-Endian systems write the least significant byte first, so “4” would be written like this:</p>
<pre><font face="Courier New" size="3">04 00</font></pre>
<p>
Msg::Swap takes a two-byte number (a short) and flips the bytes, like this:</p>
<pre><font face="Courier New" size="3">short&amp; CMsg::Swap(short n)
{
    static short res;
    unsigned char ch;
    union 
    {
        short a;
        unsigned char b[2];
    } un;

    un.a = n;
    ch = un.b[0];
    un.b[0] = un.b[1];
    un.b[1] = ch;
    res = un.a;
    return res;
}</font></pre>
<p>
The only work of significance in the MFC program is the database work, which has been described well elsewhere. The strings representing database records are created simply by gluing together the nine fields in the sample database (the Student Registration database provided with Visual C++) with @ as a delimiter. For every database transaction, I open the database, perform the transaction, and close the database.</p>
<p>
Control flows like this: a message arrives from the applet and triggers CClientSocket::OnReceive(), </p>
<p>
which calls CServerDoc::ProcessPendingRead(). This function serializes the socket into a CMsg object and then deals with the information that was sent. The following block of code handles the database requests:</p>
<pre><font face="Courier New" size="3">CString str;

m_Message = pSocket-&gt;m_User 
           + &quot; - received:   &quot; + msg.m_Buffer;
UpdateAllViews(NULL);

str = ReadDataBase(pSocket, msg.m_Buffer);
SendMsg(str, pSocket, &amp;msg);

m_Message = pSocket-&gt;m_User 
           + &quot; - send:       &quot; + str;
UpdateAllViews(NULL);</font></pre>
<p>
This echoes the request out to the server user interface, reads the database, sends a reply back through the socket to the applet, and echoes the reply to the server user interface.</p>
<p>
The CServerDoc::ReadDataBase() function (Listing 1) is quite straightforward.</p>
<p>
Throughout this function there are calls to BuildString(), which glues the database fields together into one string that is returned to ProcessPendingRead() so it can be sent to the applet. Here’s BuildString():</p>
<pre><font face="Courier New" size="3">CString&amp; CServerDoc::BuildString(CServerSet* m_pSet)
{
    static CString str;
    str.Format(&quot;%s@%d@%s@%d@%s@%s@%s@%s@%d&quot;, 
        m_pSet-&gt;m_Name,
        m_pSet-&gt;m_GradYear,
        m_pSet-&gt;m_CourseTitle,
        m_pSet-&gt;m_Hours,
        m_pSet-&gt;m_SectionNo2,
        m_pSet-&gt;m_InstructorID,
        m_pSet-&gt;m_RoomNo,
        m_pSet-&gt;m_Schedule,
        m_pSet-&gt;m_Capacity);
    return str;
}</font></pre>
<h2>The Java applet</h2>
<p>
The client is a Java applet included in a Web page. The HTML to include it looks like this: </p>
<pre><font face="Courier New" size="3">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Access Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;applet code=Access.class width=600 height=400&gt;
&lt;/applet&gt;
&lt;/body&gt;
&lt;/html&gt;</font></pre>
<p>
Let’s look at the Java applet code. There are four classes-Access, Login, Form, and Listener-which are defined in one source file. </p>
<h2>Access</h2>
<p>
Access is the most important class. It extends Applet, and all the other objects are secondary to it. Its most important functions are<b> </b>init(), paint(), and action(). </p>
<p>
init(), which is called when the applet initializes, sets up the socket and the input and output streams, starts the Listener object, and builds and shows the Login object:</p>
<pre><font face="Courier New" size="3">public void init()
{
    try
    {
        resize(600, 400);
        setLayout(null);
            
        flag_Ready = false;
        flag_Active = true;
        client = new Socket(
          this.getCodeBase().getHost(), PORT);
        InputStream  in  = new 
          BufferedInputStream(
          client.getInputStream());
        OutputStream out = new 
          BufferedOutputStream(
          client.getOutputStream());
        dIn  = new DataInputStream(in);
        dOut = new DataOutputStream(out);
        ls = new Listener(dIn, this);

        login = new Login(); 
        login.Init(this);
    }
    catch(IOException e)
    {
      this.showStatus(
        &quot;Can not set connection with server program&quot;);
    }
} </font></pre>
<p>
Notice the resize() call. Make sure your HTML uses the same size that is hard-coded here.</p>
<p>
paint() has Login and Form paint themselves, and draws the red or green circle:</p>
<pre><font face="Courier New" size="3">public void paint(Graphics g)
{
    if (login != null) 
    {
        login.Paint(g);
        if (login.f_close == true) login = null;
    }
    if (form  != null) 
    {
        form.Paint(g);
        if (form.f_close == true)  
        {
            form = null;
            System.exit(0);
        }
    }

    if (form != null)
    {
        g.setColor(new Color(0, 0, 0));
        g.drawOval(80, 310 + 30, 30, 30);
        if (flag_Ready == true)
            g.setColor(new Color(0, 255, 0));
        else
            g.setColor(new Color(255, 0, 0));
        g.fillOval(80 + 1, 310 + 30 + 1, 
                   30 - 1, 30 - 1);
    }
}</font></pre>
<p>
action() analyzes the user’s choice. The logic of the application is mostly concentrated here:</p>
<pre><font face="Courier New" size="3">public boolean action(Event event, Object obj)
{
        try
    {
        if (event.target instanceof Button)
        {
            String name = 
                ((Button)event.target).getLabel();
            if (login != null 
                &amp;&amp; name.compareTo(&quot;OK&quot;) == 0)
            {
                start_Login();
                return true;
            }
            if (name.compareTo(&quot;Exit&quot;) == 0)
            {
                client.close();
                if (login != null) login.Close(); 
                repaint();
            }
            if (name.compareTo(&quot;x&quot;) == 0)
            {
                dOut.writeUTF(&quot;END&quot;);
                dOut.flush();
                client.close();
                if (form  != null) form.Close();  
                repaint();
            }
            if (name.compareTo(&quot;|&lt;&quot;) == 0)
            {
                goRecord(&quot;S&quot;);
            }
            if (name.compareTo(&quot;&lt;&quot;) == 0)
            {
                goRecord(&quot;B&quot;);                
            }
            if (name.compareTo(&quot;&gt;&quot;) == 0)
            {
                goRecord(&quot;F&quot;);
            }    
            if (name.compareTo(&quot;&gt;|&quot;) == 0)
            {
                goRecord(&quot;E&quot;);
            }
        }
    }
    catch(IOException e)
    {
        this.showStatus(
         &quot;Communication problem with server (1)&quot;);
    }

    return false;
}</font></pre>
<p>
Notice the calls to goRecord(). It looks like this:</p>
<pre><font face="Courier New" size="3">public void goRecord(String str)
{
    try
    {
        dOut.writeUTF(str);
        dOut.flush();
        flag_Ready = false;
        repaint(80, 310 + 30, 30, 30); 
    }
    catch(IOException e)
    {
       showStatus(
         &quot;Communication problem with server (4)&quot;);
    }
}</font></pre>
<p>
There’s that call to writeUTF(), which eventually will meet the server program’s Msg::Serialize(). Other functions include handleEvent(), which supports low-level GUI behavior, such as the Tab and Enter keys; updateFields(), which pulls apart the string from the server and fills the applet interface fields; and stop(), which sends the “END” message to the server and sets the flag_Active variable to FALSE, which stops the Listener::run()loop.</p>
<h2>Login and Form</h2>
<p>
These classes provide the GUI. Controls are placed directly on them using pixel coordinates. Each class can draw itself and is controlled by the Access object. The code is bulky but easy to read, so feel free to download the Java code and check into it.</p>
<h2>Listener</h2>
<p>
This class extends Thread. It listens for responses from the server and fills out the form. I’ve implemented the “send” and “receive” processes in two separate threads, because I need to place the “not ready/ready” indication on the Applet screen.</p>
<h2>Conclusion</h2>
<p>
Using mixed software over the Internet lets you take advantage of the strengths of every component. A Java applet is easy to deliver through a Web page and can produce a workable user interface on a variety of platforms. A program written in Visual C++ using ODBC can make short work of reading an Access database, or any other ODBC-supported database. Using the right tool for each job is the key to developer success. s</p>
<p>
<b>Listing 1. The CServerDoc::ReadDataBase() function.</b></p>
<pre><font face="Courier New" size="3">CString&amp; CServerDoc::ReadDataBase(CClientSocket* pSocket, char* buffer)
{
    static CString str;

    if (m_Set.IsOpen())
        m_Set.Close();

    m_Set.m_strFilter = &quot;[Course].[CourseID] = [Section].[CourseID]&quot;;
    m_Set.m_strFilter += &quot; AND [Section].[CourseID] = [Enrollment].[CourseID]&quot;;
    m_Set.m_strFilter += &quot; AND [Section].[SectionNo] = [Enrollment].[SectionNo]&quot;;
    m_Set.m_strFilter += &quot; AND [Student].[StudentID] = [Enrollment].[StudentID]&quot;;

    m_Set.m_strSort = &quot;[Student].[StudentID], [Enrollment].[CourseID]&quot;;
    
    m_Set.Open();
    
    if (m_Set.IsEOF()) 
    {
        str = &quot;-@-@-@-@-@-@-@-@-&quot;;
        return str;
    }

    if (buffer[0] == 'S') 
    {     
        m_Set.MoveFirst();
        pSocket-&gt;m_CurrentPos = 0;
        str = BuildString(&amp;m_Set);
    }

    if (buffer[0] == 'E') 
    {     
        m_Set.MoveFirst();
        pSocket-&gt;m_CurrentPos = 0;
        while(!m_Set.IsEOF())
        {
            m_Set.MoveNext();
            pSocket-&gt;m_CurrentPos++;
        }
        pSocket-&gt;m_CurrentPos--;
        str = BuildString(&amp;m_Set);
    }
    
    if (buffer[0] == 'F') 
    {     
        m_Set.Move((long)pSocket-&gt;m_CurrentPos);
        if (!m_Set.IsEOF())
        {
            m_Set.MoveNext();
            pSocket-&gt;m_CurrentPos++;
            str =  BuildString(&amp;m_Set);
            if (m_Set.IsEOF())
                pSocket-&gt;m_CurrentPos--;
        }
    }

    if (buffer[0] == 'B') 
    {     
        if (!m_Set.IsBOF() &amp;&amp; pSocket-&gt;m_CurrentPos &gt; 0)
        {
            pSocket-&gt;m_CurrentPos--;
            m_Set.Move(pSocket-&gt;m_CurrentPos);
            str = BuildString(&amp;m_Set);
        }
    }

    return str;
}</font></pre>
<p>
<b>&#09;&#09;&#09;  JAVA_MFC.ZIP at www.pinpub.com/vcd</b></p>
<p>
<i>Sergey Michalev is a wireless connectivity specialist at a Canadian communications company. He welcomes e-mail if you have questions, suggestions, or notes related to this article. Sergey.Michalev@emc.ericsson.se.</i></p>
<P align="center"><a
    href="http://www.pinpub.com/vbd/"><img src="Pinnacle.gif"
    border="0" width="216" height="72"></a></p>
    <P align="center"><strong>To find out more about
    Visual C++ Developer and Pinnacle Publishing, visit their
    website at</strong>: <a href="http://www.pinpub.com/vbd/"><strong>http://www.pinppub.com/vcd/</strong></a></p>
    <P align="center"><font size="1">Note: This is not
    a Microsoft Corporation website. <br>
    Microsoft is not responsible for its content.</font></p>
    <p><font size="1">This article is reproduced from the
    May 1997 issue of Visual C++ Developer. Copyright
    1997, by Pinnacle Publishing, Inc., unless otherwise noted.
    All rights are reserved. Visual C++ Developer is an
    independently produced publication of Pinnacle Publishing,
    Inc. No part of this article may be used or reproduced in any
    fashion (except in brief quotations used in critical articles
    and reviews) without prior consent of Pinnacle Publishing,
    Inc. To contact Pinnacle Publishing, Inc., please call
    (800)&nbsp;788-1900 or (206)&nbsp;251-1900.</font></p>
</font></BODY>
</HTML>
