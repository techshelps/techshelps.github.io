<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Best Practices: Using the TreeView Control </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2">
<h1>Best Practices:</h1>
<h1>Using the TreeView Control</h1>
<p>
Doug Hennig</p>
<p>
<i>The new TreeView ActiveX control that comes with VFP 5.0 is a powerful, visually appealing tool youíll want to use in many applications. However, its quirks and poor documentation can make you spend many unproductive, frustrating hours figuring out how to properly use it. This article explores some helpful techniques for working with the TreeView control.</i></p>
<p>
VISUAL FoxPro 5.0 includes many new ActiveX (formerly OLE) controls that can add great new features to your applications. Many of these, including the TreeView, ListView, StatusBar, and CommonDialog controls, allow you to create a Windows 95 interface for your applications. The ActiveX controls are easy to find: just select <i>ActiveX Controls</i> from the <i>View Classes</i> menu in the Form Control toolbar, and 30 new controls appear. Simply drag a control from the toolbar to a form as you would with any native control, give it a name, set some properties, and away you go. In addition to the VFP Properties sheet, each control has a custom Properties sheet. To access it, right-click on the control and select the appropriate item from the menu that appears.</p>
<p>
To make things even better, you can take advantage of the fact that VFP is the only development environment that allows you to subclass ActiveX controls to add additional behavior. For example, you could create a wrapper class for a control to hide its complexity and simplify its use, or add custom properties and methods to further extend the controls.</p>
<h2>The TreeView control</h2>
<p>
In my opinion, the most important new control is TreeView. Youíve already used the TreeView control-itís used in the left pane of the Windows Explorer, and in the VFP Project Manager and Class Browser. This control is visually more appealing than the Outline control available in VFP 3.0, and is much easier to work with. For example, you had to add nodes to the Outline control in the order they appeared in the outline. With the TreeView control you can add nodes in any order because you can specify which node is the parent when you add a new one.</p>
<p>
You can use the TreeView control to do many things. Here are some examples:</p>
<p>
Display a bill of materials list for an inventory control system.</p>
<p>
Use drill-downs. For example, you could display a list of customers and drill down to orders and products for each order. Another example is a list of regions, which expands to the salespeople under each region, each of which expands to their customers, and so on.</p>
<p>
Improve organization charts: Divisions are expanded to branches, which are expanded to supervisors, which are expanded to employees.</p>
<p>
Create any other hierarchical display of information.</p>
<p>
The TreeView control is located in COMCTL32.OCX (in \WINDOWS\SYSTEM). If youíve installed the Visual Basic Control Creation Edition (distributed at the 1996 Microsoft FoxPro Developers Conference and available from the Microsoft Web site), an updated version of COMCTL32.OCX-which has a number of problems with VFP 5.0-was installed on your system. If your copy of COMCTL32.OCX is larger than 325K (the newer, problematic version is more than 500K), youíll want to reinstall the “good” copy from your VFP 5.0 CD-ROM (located in the \OS\SYSTEM directory on the CD).</p>
<p>
The TreeView control is documented in CTRLREF.HLP (in the VFP home directory). The help information for the TreeView control is probably the poorest of all ActiveX control help (which is generally abysmal anyway): Its organization is confusing, the information is incorrect in several places, and itís frequently as clear as mud, especially in documenting how to access some methods and properties.</p>
<p>
The TreeView control allows you to work with three different types of objects: the TreeView control itself, the Nodes collection, and Node objects. The Nodes collection is like the Controls collection of a form; it enables you to access individual node objects by an index number. However, you can also access individual node objects without going through the Nodes collection. For example, the TreeView SelectedItem property is an object reference to the selected node, and some methods-such as NodeClick and Expanded-accept an object reference to a node as a parameter.</p>
<p>
Iíll explore the properties, events, and methods of these three types of objects separately. This monthís Subscriber Downloads include a sample form (TREEVIEW.SCX) that shows many of the techniques Iíll discuss in this article.</p>
<h2>TreeView control methods and events</h2>
<p>
The TreeView control responds to some of the methods and events we often associate with other VFP controls: Click, DblClick, Drag, DragDrop, DragOver, GotFocus, KeyDown, KeyPress, KeyUp, LostFocus, MouseDown, MouseMove, MouseUp, Move, Refresh, SetFocus, ShowWhatsThis, and ZOrder. Thereís one big exception: there isnít a RightClick event. Youíll see how to handle that later.</p>
<p>
In addition to these methods and events, the TreeView control has some of its own methods and events (the help file lists Clear and Remove methods, but these really belong to the Nodes collection, not the TreeView control itself):</p>
<p>
<i>BeforeLabelEdit</i> and <i>AfterLabelEdit</i> occur before and after the label is edited by the user (as in Windows Explorer, you can click the selected node and edit its text, although you can disable this automatic editing capability as youíll see in a moment). Code in this event is usually used to save the new text somewhere, such as in a field in a table.</p>
<p>
<i>Collapse</i> and <i>Expand</i> are fired when users collapse or expand a node. They receive as a parameter an object reference to the selected node. Collapsing or expanding a node doesnít make it the active node, which is usually confusing to the user. Add the following code to the Collapse and Expand events to ensure that the node becomes active (the call to NodeClick(), a method Iíll explain later, is only necessary if you have some custom code in that method):</p>
<pre><font face="Courier New" size="3">lparameters node
Node.Selected = .T.
This.NodeClick(Node)</font></pre>
<p>
<i>GetVisibleCount</i> shows the number of complete nodes visible in the control. This number might seem to be too low by one if the control can show most of the last node.</p>
<p>
<i>HitTest</i> returns a reference to a node object if one exists at the passed X and Y coordinates, or .NULL. if there isnít a node at those coordinates. One complication: HitTest expects the X and Y coordinates in a unit known as “twips” (used in Visual Basic), while VFP uses pixels. The following code will convert pixels to twips (thanks to Chin Bae and Mark Giesen for figuring this out). The TREEVIEW sample form has this code in its Init method, and has two custom properties to store the calculated values: nTreeFactorX and nTreeFactorY.</p>
<pre><font face="Courier New" size="3">local liHWnd, ;
&#09;liHDC, ;
&#09;liPixelsPerInchX, ;
&#09;liPixelsPerInchY

* Define some constants.

#define cnLOG_PIXELS_X      88
&#09;* From WINGDI.H
#define cnLOG_PIXELS_Y      90
&#09;* From WINGDI.H
#define cnTWIPS_PER_INCH  1440
&#09;* 1440 twips per inch

* Declare some Windows API functions.

declare integer GetActiveWindow in WIN32API
declare integer GetDC           in WIN32API ;
&#09;integer iHDC
declare integer GetDeviceCaps   in WIN32API ;
&#09;integer iHDC, integer iIndex

* Get a device context for VFP.

liHWnd = GetActiveWindow()
liHDC  = GetDC(liHWnd)

* Get the pixels per inch.

liPixelsPerInchX = GetDeviceCaps(liHDC, cnLOG_PIXELS_X)
liPixelsPerInchY = GetDeviceCaps(liHDC, cnLOG_PIXELS_Y)

* Get the twips per pixel and store in properties of
* the form.

with This
&#09;.nTreeFactorX = cnTWIPS_PER_INCH/liPixelsPerInchX
&#09;.nTreeFactorY = cnTWIPS_PER_INCH/liPixelsPerInchY
endwith</font></pre>
<p>
HitTest() can help solve an issue with right-clicks of the mouse. You might want to display a pop-up menu when the user right-clicks on a node, but right-clicking on a node doesnít make it the selected node. Use the following code in the MouseDown event of the control to handle this (itís the only way you can handle right-clicks because there is no RightClick event). Again, the call to NodeClick() is necessary only if you have some code in that method:</p>
<pre><font face="Courier New" size="3">lparameters Button, Shift, X, Y
local loNode
if Button = 2

* If this is the right mouse button, get a reference
* to the node under the mouse.

&#09;loNode = This.HitTest(X * Thisform.nTreeFactorX, ;
&#09;&#09;Y * Thisform.nTreeFactorX)

* If you have a valid node, select it.

&#09;if not isnull(loNode)
&#09;&#09;loNode.Selected = .T.
&#09;&#09;This.NodeClick(loNode)
&#09;endif not isnull(loNode)
&#09;* show the right-click menu now
else
&#09;* handle any left-mouse click stuff necessary
endif Button = 2</font></pre>
<p>
<i>NodeClick</i> is fired when the user clicks on a node (before the Click event). NodeClick receives as a parameter an object reference to the selected node object. Typically, this method is used to update some things (such as the values of other controls) when a node is selected. If the code in NodeClick takes too long to execute, the selected item will be highlighted but the former item will have a dashed line around it. Moving the mouse (even without clicking the mouse button) restores the highlight to the former item. Add the following code to the NodeClick event to ensure that the clicked node becomes selected:</p>
<pre><font face="Courier New" size="3">Node.Selected = .T.</font></pre>
<p>
<i>StartLabelEdit</i> is used to manually invoke the editing of a nodeís label. This is used when the LabelEdit property is 1-Manual.</p>
<h2>TreeView control properties</h2>
<p>
As with events, TreeView controls support some of the same properties supported by other controls, including DragIcon, DragMode, Enabled, and Visible. Many of the TreeView-specific properties can be set in the TreeView Control Property sheet invoked from the right-mouse menu. These include Style, LineStyle, Indentation, PathSeparator, and HideSelection.</p>
<p>
Of the properties that can be edited in the property sheet, here are the ones youíre most likely to change from the defaults:</p>
<p>
<i>Style.</i> This property indicates what appears in the TreeView control. You can choose whether images appear, whether lines are displayed, whether the plus/minus marks are shown, and so on.</p>
<p>
<i>LineStyle.</i> This property indicates whether “root lines” are displayed. If you donít set this to 1-Root Lines, you wonít get the plus/minus mark for the top-level objects, regardless of how Style is set.</p>
<p>
<i>LabelEdit. </i>If you donít want the user to be able to edit the text for each node, set this to 1-Manual.</p>
<p>
<i>ImageList.</i> The images used by the nodes in the TreeView control arenít specified with a filename such as the Picture property of a CommandButton. Instead, the images must be loaded into an ImageList control, another of the new ActiveX controls. The ImageList control is simple to use: just drop one on a form, bring up its property sheet from the right-click menu, and add images to it by clicking the Add button and locating the desired graphic files. The ImageList property of the TreeView control is a reference to the ImageList control containing the images used by the nodes in the TreeView. The drop-down list in the TreeView property sheet shows the name of existing ImageList controls on the form.</p>
<p>
<i>Indentation.</i> This property indicates how much each child node is indented.</p>
<p>
<i>HideSelection</i>. If you donít turn this option off, the selected node doesnít stay highlighted when the TreeView control loses focus. This can be very confusing to the user.</p>
<p>
<i>Font.</i> This property shows the font name, size, and style used for the node text.</p>
<p>
The following properties arenít available from the property sheet (the help file includes a ScrollBars property, but thereís no such property):</p>
<p>
<i>DropHighlight</i>. This is supposed to be used in the DragOver event of the TreeView control so you can highlight a node as the mouse passes over it. However, no one has been able to get this to work in VFP yet; setting this property to a node object gives a “type mismatch” error. I suspect itís a documentation issue, but Iím not sure. You can get around this problem by using HitTest() to determine which node the mouse is over and setting that nodeís Selected property to .T. The TREEVIEW sample form uses this technique in its DragOver event.</p>
<p>
<i>Nodes</i>. This property references the Nodes collection in the control. </p>
<p>
<i>SelectedItem</i>. This property references the currently selected node object.</p>
<h2>Nodes collection methods</h2>
<p>
Here are the methods of the Nodes collection of the TreeView control (referenced by specifying &lt;Object&gt;.Nodes, where <i>&lt;Object&gt;</i> is the name of the TreeView control):</p>
<p>
<i>Add</i>: adds a new node and returns a reference to it. It uses the following syntax:</p>
<pre><font face="Courier New" size="3">&lt;Object&gt;.Nodes.Add(Relative, Relationship, Key, ;
&#09;Text, Image, SelectedImage)</font></pre>
<p>
<i>Relative</i> is the index or key of an existing node object. If it isnít specified, the new node is placed at the end of the top node hierarchy. </p>
<p>
<i>Relationship</i> indicates where the new node should be placed relative to the node specified in the first parameter:</p>
<p>
The node is placed after all other nodes at the same level of the relative node.</p>
<p>
The node is placed after the relative node.</p>
<p>
The node is placed before the relative node.</p>
<p>
The node becomes a child of the relative node.</p>
<dl>
<dt>
<i>Key</i> is a unique string used to identify the node. If the tree is loaded with records from a table, I use the primary key of the record (converted to a string if necessary). Otherwise, I just use a sequential number converted to a string.</dt>
<dd>
<i>Text</i> is the text displayed in the control for the node.<p>
<i>Image</i> is the index number of an image in the associated ImageList control.</p>
<p>
<i>SelectedImage</i> is the index number of an image in the associated ImageList control thatís shown when the node is selected.</p>
<p>
<i>Clear</i>: nukes all nodes.</p>
<p>
<i>Remove</i>: removes the node corresponding to the specified index.</p>
</dd>
</dl>
<h2>Nodes collection properties</h2>
<p>
Here are the properties of the Nodes collection:</p>
<p>
<i>Count</i>: the number of nodes.</p>
<p>
<i>[&lt;Index&gt;]</i>: an object reference to node number &lt;Index&gt;.</p>
<h2>Node objects methods</h2>
<p>
Here are the methods of node objects:</p>
<p>
<i>CreateDragImage</i>: canít be used in VFP because DragIcon expects a CUR file name while this method returns an image.</p>
<p>
<i>EnsureVisible</i>: ensures that the specified node is visible. This method scrolls the TreeView control if necessary and expands all parent nodes of the specified node.</p>
<h2>Node objectsí properties</h2>
<p>
Here are the properties of node objects:</p>
<p>
<i>Children</i>: .T. if the node object has any child node objects.</p>
<p>
<i>Expanded</i>: .T. if the node object is expanded.</p>
<p>
<i>FullPath</i>: the concatenation of the Text values of all parent objects leading to this one, separated by the controlís PathSeparator property. Itís very similar to the concept of a fully qualified file path and name.</p>
<p>
<i>Image</i>, <i>ExpandedImage</i>, and <i>SelectedImage</i>: the appropriate image number in the associated ImageList control.</p>
<p>
<i>Index</i>: the index of the node object in the Nodes collection.</p>
<p>
<i>Key</i>: the unique key assigned when the node was added.</p>
<p>
<i>Child</i>, <i>FirstSibling</i>, <i>LastSibling</i>, <i>Previous</i>, <i>Parent</i>, <i>Next</i>, and <i>Root</i>: point to the appropriate node object relative to the specified one.</p>
<p>
<i>Selected</i>: .T. if the node object is selected. Setting this property to .T. automatically highlights the node and sets the Selected property of the previously selected node to .F.</p>
<p>
<i>Text</i>: the text that appears in the control.</p>
<h2>Loading the TreeView control</h2>
<p>
While itís relatively simple to load the tree, it can have some interesting twists. Hereís a straightforward example. Assume that you want to load a tree with customers and orders for those customers (as in the TREEVIEW sample form). The following code will do this; the code would likely get called during form initialization (for example, in a custom method of the form called in the Init() method of the form or the Init() method of the TreeView control):</p>
<pre><font face="Courier New" size="3">with This

* Set up the CUSTOMER and ORDERS tables.

&#09;select CUSTOMER
&#09;set order to CUST_ID in ORDERS
&#09;set order to COMPANY
&#09;scan

* Add a node for the customer to the tree.

&#09;&#09;lcCustomerKey = 'C' + CUST_ID
&#09;&#09;.oTree.Nodes.Add(, 1, lcCustomerKey, ;
&#09;&#09;&#09;trim(COMPANY), 1)

* Find the first order for this customer and process
* each one.

&#09;&#09;select ORDERS
&#09;&#09;seek CUSTOMER.CUST_ID
&#09;&#09;scan while CUST_ID = CUSTOMER.CUST_ID
&#09;&#09;&#09;.oTree.Nodes.Add(lcCustomerKey, 4, ;
&#09;&#09;&#09;&#09;'O' + ORDER_ID, ;
&#09;&#09;&#09;&#09;dtoc(ORDER_DATE) + ' ' + ;
&#09;&#09;&#09;&#09;transform(ORDER_AMT, '$99,999.99'), 2)
&#09;&#09;endscan while CUST_ID = CUSTOMER.CUST_ID
&#09;&#09;select CUSTOMER
&#09;endscan
endwith</font></pre>
<p>
The key assigned to each node is the key for the record plus a prefix to indicate what table the record comes from (“C” for CUSTOMER and “O” for ORDER). The prefix avoids the problems where an order and customer have the same primary key. The combination of prefix and primary key allows you to quickly find the record matching a particular node (using the nodeís Key property, it gets the table from the first character, and the primary key to seek from the rest of the string).</p>
<p>
The only downside to this code is that it must process every order for every customer before the form can be displayed. If there are a lot of customers or orders, this can take a long time. A better approach is to load only the top-level items (customers in this case), then in the Expand() method, check whether the node about to be expanded has been loaded with child nodes. If it hasnít, load the child nodes just for the current node. This is much faster than loading the entire tree at the beginning. One tip: if you donít load any children for a node, no plus sign (+) will appear for the node. Youíll need to add at least one node, even a “dummy” one, for each top-level node. When the node is expanded for the first time, remove the dummy node and then add the “real” child nodes.</p>
<p>
The TREEVIEW sample form shows how to use this technique. It has an lLoadChildren property that determines whether all orders and products are loaded before the form is displayed. Try setting this to .F. and notice how long it takes the form to display.</p>
<p>
You might need to reload the tree at some point. For example, if other users are adding customers or orders, you might need to refresh the tree from time to time with any new customers or orders. To prevent the hassles of figuring out which records are already in the tree and which arenít, you could use the Nodes collectionís Clear() method to clear the tree, then reload it from scratch. The only problem with this approach is that some nodes may have been expanded. Clearing and reloading the tree causes all nodes to start in the default collapsed view. To overcome this, you can save the Expanded property, and either the Key or FullPath properties, of each existing node in an array or cursor, and clear and reload the tree. Then go through the array or cursor and reset the Expanded property of those previous nodes to the saved former value. The GetExpanded and SetExpanded methods of the TREEVIEW sample form do just that.</p>
<h2>Drag and drop</h2>
<p>
Based on messages Iíve seen on CompuServe, thereís a lot of confusion about whether you can drag and drop with the TreeView control. Some folks think that because VFP doesnít implement drag and drop with other applications such as Word (which is true), it canít do it with ActiveX controls (which isnít true). You can drag and drop with ActiveX controls even though theyíre non-VFP applications because when you drop an ActiveX control on a form, VFP places it inside a VFP container, which, of course, does support drag and drop. As a result, dragging and dropping with a TreeView control (either from or to the control) works no differently than it does for any other control.</p>
<p>
The TREEVIEW sample form implements drag and drop, both from and to the control. You can drag a node from the tree to the text box under the “Dragged Node” label; the text of the node will appear in the text box. You can also drag the “Drag me to tree” label and drop it on any node in the tree; a new node will be added, showing the text of the node you dropped the label on, along with the date and time.</p>
<h2>Conclusion</h2>
<p>
The TreeView ActiveX control is a wonderful addition to your VFP “toolbox.” It allows you to implement a visual control for any hierarchical structure-a control your users probably already know how to use. Once you get past some of the quirks and poor documentation of the TreeView control, youíll find a ton of uses for it. I hope this article sets you on the path to successfully implementing this control. s</p>
<p>
<b>&#09;&#09;&#09;  06DHENSC.EXE at www.pinpub.com/foxtalk</b></p>
<p>
<i>Doug Hennig is a partner with Stonefield Systems Group Inc. in Regina, Saskatchewan, Canada. He is the author of Stonefieldís add-on tools for FoxPro developers, including Stonefield Database Toolkit for Visual FoxPro and Stonefield Data Dictionary for FoxPro 2.x. He is also the author of The Visual FoxPro Data Dictionary in Pinnacle Publishingís The Pros Talk Visual FoxPro series. Doug has spoken at user groups and regional conferences all over North America. He was a Microsoft Most Valuable Professional (MVP) for 1996. 75156.2326@compuserve.com.</i></p>
<P align="center"><a
href="http://www.pinpub.com/foxtalk/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about
FoxTalk and Pinnacle Publishing, visit their website at</strong> <br>
<a href="http://www.pinpub.com/foxtalk/"><strong>http://www.pinpub.com/foxtalk/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content..</font></p>

<P>This article is reproduced from the June 1997
issue of FoxTalk. Copyright 1997, by Pinnacle Publishing, Inc.,
unless otherwise noted. All rights are reserved. FoxTalk is an
independently produced publication of Pinnacle Publishing, Inc.
No part of this article may be used or reproduced in any fashion
(except in brief quotations used in critical articles and
reviews) without prior consent of Pinnacle Publishing, Inc. To
contact Pinnacle Publishing, Inc., please call (800)788-1900 or
(206)251-1900.</p>
</font></BODY>
</HTML>
