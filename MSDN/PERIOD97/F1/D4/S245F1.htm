<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C++ Q &amp; A</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">
<H1>C++ Q &amp; A</H1><P>Paul DiLascia</P>
<P>Paul DiLascia is a freelance software consultant specializing in training and software development in C++ and Windows. He is the author of Windows++: Writing Reusable Code in C++ (Addison-Wesley, 1992).</P>
<P>Every so often, as most people do, I have a major brain lapse. Unlike most people, I have thousands of readers checking up on me all the time, ready to point out my failings. In my March 1997 "More Fun with MFC" article, after lamenting MFC's single-inheritance class model, I made the following sweeping claim: "Unfortunately, MFC doesn't support multiple inheritance&nbsp;this&nbsp;way.&nbsp;I&nbsp;don't know any framework that does. Most Windows&reg;-based C++ application frameworks are alike&nbsp;in this respect.&nbsp;They all use a single-inheritance model that makes it difficult to write reusable library extensions."</P>
<P>I've made some boo-boos over the years, but this is the worst. As intrepid reader Eddie Diener pointed out: "OWL uses multiple inheritance and you can easily derive from more than one window type to create another type of window. The OWL application framework does this in a number of situations. All the DIB stuff you did for MFC is and has been in OWL for a long time now plus added DIB functionality. That doesn't take away from the value of your work but I thought you should know. Either you are so dedicated to MFC that you know nothing about OWL or you prefer to just ignore it when you make a statement like the one above (it's not Microsoft, after all). Nonetheless I enjoyed the article, but try to open up your eyes to MFC alternatives a little more, even if you make a large part of your living via MFC and Microsoft."</P>
<P>Ouch! It would be forgivable if Eddie were calling my attention to some obscure library from Zippy Tools Corporation with shareware sales of 123 units—but OWL? I wish I could say it was the former of Eddie's suggested explanations, but unfortunately the head-in-the-sand theory is more accurate, and I have only myself to blame. All I can say is, that's what happens when you're under pressure from Acme's Maximum Leader at the same time you're trying to get a column out under deadline. I'll try to do better next time. Also, I owe an apology to Borland—sorry, Philippe! (Just kidding, I <I>do </I>know that Mr. Kahn has left Borland.)</P>
<P>Looking on the bright side, this gives me the perfect segue to explain something I am asked about often: why don't I write about other frameworks besides MFC? In particular, why don't I answer OWL questions?</P>
<P>Since the word Microsoft appears in the title of this magazine, it isn't surprising that I have some bias toward products from Redmond. But my focus on MFC honestly doesn't reflect any big-brother plan for world framework domination. In the ever-growing trend toward specialization, it's hard to be an expert in all things. And the simple fact is that more programmers use MFC. This is not to say MFC is necessarily better! MFC certainly has its problems, which I am always happy to point out. It's too bloated, for one thing. But like it or not, MFC has become the de facto standard for Windows programming in C++. Borland fans will have to look elsewhere—though I hope they'll find useful ideas here, too. Still, I'll try to take Eddie's advice to heart and pull my head out of the sand every now and then.</P>
<P>QI tried to use your custom caption-painting code from the ShadeCap program in my MDI app, but it doesn't seem to work properly with the MDI child windows. When I switch from my app to another and back the child windows don't get activated, and when I create a maximized child window the title bar flickers. Is this a bug? Is there some way I can fix it?</P>
<P><I>Jeroen Thur, Gil Rosin, and others</I></P>
<P></P>
<P>AYes, it's a bug. Although the code in ShadeCap works wonderfully for SDI apps, merrily painting its caption bar, free from the fulsome flicker, it fails miserably in MDI apps as a number of readers discovered. Well, why didn't you say you wanted it to work for MDI, too? Sheesh, do I have to do everything?</P>
<P>If you recall, ShadeCap handles WM_NCPAINT, WM_NCACTIVATE, and WM_SETTEXT to draw a shaded caption (see Figure 1). It does a lot of hairy stuff to draw the caption in&nbsp;totally&nbsp;flicker-free&nbsp;fashion.&nbsp;Flicker&nbsp;is&nbsp;an&nbsp;issue in Windows if you turn on the feature that draws the window contents dynamically while the user sizes a window (as opposed to the Windows 3.1 way of drawing just a shaded border). </P>
<P><img src="cqa1.gif"></P>
<P>Figure 1  ShadeCap draws a shaded caption</P>
<P>The problem has to do with the Windows 95 default window procedure for MDI apps. Normally, Windows uses a function called DefWindowProc as the window proc, but for MDI apps Windows uses a different function, DefFrameProc. When DefFrameProc gets WM_NCACTIVATE, it activates the active MDI child window's caption as well as the&nbsp;main&nbsp;window&nbsp;caption.&nbsp;Because&nbsp;my&nbsp;OnNcActivate&nbsp;handler in ShadeCap bypasses the installed window proc entirely (in order to work its special magic), it bypasses this important behavior in DefFrameProc in the case of an MDI app. </P>
<P>Not to worry—the fix is simple:</P>
<P></P>

<PRE>BOOL CMainFrame::OnNcActivate(BOOL bActive)
{
    CFrameWnd* pActiveFrame = GetActiveFrame();
    if (pActiveFrame!=this) {
        pActiveFrame-&gt;SendMessage(WM_NCACTIVATE,<BR>                                  bActive);
        pActiveFrame-&gt;SendMessage(WM_NCPAINT);
    }
    .
    . // handle for main frame
    .
}</PRE>
<P></P>
<P>CFrameWnd::GetActiveFrame is an MFC function that returns the active frame window. In the case of an SDI app, GetActiveFrame returns "this" (the main frame itself). In the case of a MDI app, GetActiveFrame returns the active MDI&nbsp;child&nbsp;window.&nbsp;Hence,&nbsp;the&nbsp;check&nbsp;for&nbsp;pActiveFrame==this. It's important to send WM_NCACTIVATE and WM_NCPAINT to the child frame before handling WM_NCACTIVATE in the parent. If you do it after, the child frame gets confused about its activated state and doesn't draw properly, something I discovered the hard way.</P>
<P>With the fix in place, ShadeCap activates its MDI child windows properly. But there's another problem that only shows&nbsp;up&nbsp;when the child window is maximized. When DefFrameProc gets a WM_SETTEXT message, it has the annoying habit of appending the child window's title to the main title and then painting it. So if you set the main frame title to ShadeCap and the child window is untitled, you end up with the title "ShadeCap - [untitled]." Since DefFrameProc draws the text as well (even when the window isn't visible), the result is the dreaded flicker as the faulty title appears briefly before your custom title. </P>
<P>In general, the way Windows 95 handles titles is completely messed up. The whole point of having WM_SETTEXT and WM_GETTEXT is to let you override default behavior. Ideally, you should be able to intercept WM_SETTEXT, store your custom title somewhere, and return it to anyone who calls WM_GETTEXT. That would be the "right" way to bypass DefFrameProc. But no, this doesn't work because Windows 95 doesn't use WM_GETTEXT. When it displays your window's title in the task bar or while the user is Alt-Tabbing from app to app, Windows gets the text from some internal&nbsp;character&nbsp;array&nbsp;stored&nbsp;in&nbsp;the&nbsp;WND&nbsp;structure.&nbsp;So&nbsp;you have&nbsp;to&nbsp;set&nbsp;your&nbsp;text&nbsp;there, but because there's no API function to do it you have to send WM_SETTEXT—catch-22.</P>
<P>The only way I can think of to bypass DefFrameProc when setting window text is to call DefWindowProc directly instead of calling CWnd::Default. You have to do it for the MDI child window as well because it does funky caption stuff, too. If overriding message procs to avoid system behavior seems disgusting, it is. You can always switch to Unix. To make it seem less objectionable, I wrote a function, SetInternalWindowText (see PaintCap.cpp in Figure 2), that you can use to set the internal text of any window. It turns off WS_VISIBLE, then calls DefWindowProc, then turns WS_VISIBLE back on again.</P>
<P>Figure 2  CCaptionPainter</P>
<P></P>
<P>PaintCap.h</P>

<PRE>////////////////////////////////////////////////////////////////
// 1997 Microsoft Systems Journal. 
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
#ifndef _PAINTCAP_H
#define _PAINTCAP_H

#include "Subclass.h"

//////////////////
// This struct is passed to client as LPARAM of callback message
//
struct PAINTCAP {
    CDC*    m_pDC;            // DC to draw in
    CSize    m_szCaption;     // size of caption rectangle
    BOOL    m_bActive;        // activated state
};

//////////////////
// Generic caption painter. Handles WM_NCPAINT, WM_NCACTIVATE, etc.
// to let you draw custom captions. 
//
class CCaptionPainter : public CSubclassWnd {
protected:
    CFrameWnd*&amp;    m_pFrame;          // same as CSubclassWnd::m_pWndHooked
    CBitmap        m_bmCaption[2];    // bitmaps for active/inactive captions 
    CSize          m_szCaption;       // size of caption rectangle
    BOOL           m_bActive;         // active/inactive state
    UINT           m_nPaintMsg;       // callback message to paint caption
    DECLARE_DYNAMIC(CCaptionPainter);

    // Helper
    void PaintCaption(const CRect&amp; rc);

    // These are similar to, but NOT the same as the equivalent CWnd fns. Don't
    // override unless you're a guru, and even THEN I wouldn't recommend it.
    virtual LRESULT WindowProc(UINT msg, WPARAM wp, LPARAM lp);    
    virtual void OnNcPaint(HRGN hUpdateRgn);
    virtual BOOL OnNcActivate(BOOL bActive);
    virtual void OnSetText(LPCTSTR lpText);

public:
    CCaptionPainter();
    virtual ~CCaptionPainter();

    BOOL Install(CFrameWnd* pFrameWnd, UINT nPaintMsg=0);
    int  DrawIcon(const PAINTCAP&amp; pc);
    int  DrawButtons(const PAINTCAP&amp; pc);
    void DrawNormalCaption(const PAINTCAP&amp; pc);
    void Invalidate() { m_szCaption=CSize(0,0); }
};

void WINAPI SetInternalWindowText(HWND hwnd, LPCTSTR lpText);

#endif
</PRE>
<P></P>
<P>PaintCap.cpp</P>

<PRE>////////////////////////////////////////////////////////////////
// 1997 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
#include "StdAfx.h"
#include "PaintCap.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////
// Class used to get the caption rectangle of a window in window coords.
// This is the area of the title bar inside the window frame, including
// the icon and min/max/close buttons.
// 
class CCaptionRect : public CRect {
public:
    CCaptionRect(const CFrameWnd* pFrame);
};

IMPLEMENT_DYNAMIC(CCaptionPainter, CSubclassWnd);

CCaptionPainter::CCaptionPainter() : m_pFrame((CFrameWnd*&amp;)m_pWndHooked)
{
    Invalidate();
}

CCaptionPainter::~CCaptionPainter()
{
}

//////////////////
// Install caption handler. nPaintMsg is message I will send to frame
// when its caption needs painting.
//
BOOL CCaptionPainter::Install(CFrameWnd* pFrameWnd, UINT nPaintMsg)
{
    ASSERT_KINDOF(CFrameWnd, pFrameWnd);
    m_nPaintMsg = nPaintMsg;
    return HookWindow(pFrameWnd);
}

//////////////////
// Message handler handles caption-related messages
//
LRESULT CCaptionPainter::WindowProc(UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg) {
    case WM_NCPAINT:
        OnNcPaint((HRGN)wp);
        return 0;
    case WM_NCACTIVATE:
        return OnNcActivate(wp);
    case WM_SETTEXT:
        OnSetText((LPCTSTR)lp);
        return 0;
    case WM_SYSCOLORCHANGE:
    case WM_SETTINGCHANGE:
        Invalidate();
        m_pFrame-&gt;SendMessage(m_nPaintMsg, 1, 0L);
        return 0;
    }
    // I don't handle it: pass along
    return CSubclassWnd::WindowProc(msg, wp, lp);
}

/////////////////
// Handle WM_NCPAINT for main window
//
void CCaptionPainter::OnNcPaint(HRGN hRgn)
{
    ASSERT_VALID(m_pFrame);
    CCaptionRect rcCap(m_pFrame);       // caption rectangle in window coords
    CRect rcWin;                        // window rect
    m_pFrame-&gt;GetWindowRect(&amp;rcWin);    // .. get window rect
    CRect rcCapScr =                    // convert caption rectangle...
        rcCap + rcWin.TopLeft();        // ..to screen coords

    // Don't bother painting if the caption doesn't lie within the region.
    if ((WORD)hRgn &gt; 1 &amp;&amp; !::RectInRegion(hRgn, &amp;rcCapScr)) {
        Default();                      // just do default thing
        return;                         // and quit
    }

    // Exclude caption from update region
    //
    HRGN hRgnCaption = ::CreateRectRgnIndirect(&amp;rcCapScr);
    HRGN hRgnNew     = ::CreateRectRgnIndirect(&amp;rcCapScr);
    if ((WORD)hRgn &gt; 1) {
        // wParam is a valid region: subtract caption from it
        ::CombineRgn(hRgnNew, hRgn, hRgnCaption, RGN_DIFF);
    } else {
        // wParam is not a valid region: create one that's the whole
        // window minus the caption bar
        HRGN hRgnAll = ::CreateRectRgnIndirect(&amp;rcWin);
        CombineRgn(hRgnNew, hRgnAll, hRgnCaption, RGN_DIFF);
        DeleteObject(hRgnAll);
    }

    // Call Windows to do WM_NCPAINT with altered update region
    //
    MSG&amp; msg = AfxGetThreadState()-&gt;m_lastSentMsg;
    WPARAM savewp = msg.wParam;    // save original wParam
    msg.wParam = (WPARAM)hRgnNew;  // set new region for DefWindowProc
    Default();                     // do normal WM_NCPAINT
    DeleteObject(hRgnCaption);     // clean up
    DeleteObject(hRgnNew);         // ...
    msg.wParam = savewp;           // restore original wParam

    PaintCaption(rcCap);           // Now paint my special caption
}

//////////////////
// Handle WM_NCACTIVATE for main window
//
BOOL CCaptionPainter::OnNcActivate(BOOL bActive)
{
    ASSERT_VALID(m_pFrame);

    // Mimic MFC kludge to stay active if WF_STAYACTIVE bit is on. Yuk!
    if (m_pFrame-&gt;m_nFlags &amp; WF_STAYACTIVE)
        bActive = TRUE;
    if (!m_pFrame-&gt;IsWindowEnabled())
        bActive = FALSE;
    if (bActive==m_bActive)
        return TRUE;

    // If this is a MDI app, manually activate/paint active MDI child
    // window, because Windows won't do it if parent frame is invisible.
    // Must do this BEFORE calling Default, or it will not work.
    //
    CFrameWnd* pActiveFrame = m_pFrame-&gt;GetActiveFrame();
    if (pActiveFrame!=m_pFrame) {
        pActiveFrame-&gt;SendMessage(WM_NCACTIVATE,bActive);
        pActiveFrame-&gt;SendMessage(WM_NCPAINT);
    }

    // Turn WS_VISIBLE off before calling DefWindowProc,
    // so DefWindowProc won't paint and thereby cause flicker.
    // 
    DWORD dwStyle = m_pFrame-&gt;GetStyle();
    if (dwStyle &amp; WS_VISIBLE)
        ::SetWindowLong(*m_pFrame, GWL_STYLE, (dwStyle &amp; ~ WS_VISIBLE));

    MSG&amp; msg = AfxGetThreadState()-&gt;m_lastSentMsg;
    msg.wParam = bActive;
    Default();
    if (dwStyle &amp; WS_VISIBLE)
        ::SetWindowLong(*m_pFrame, GWL_STYLE, dwStyle);

    // At this point, nothing has happened (since WS_VISIBLE was off).
    // Now it's time to paint.
    //
    m_bActive = bActive;                  // update state
    m_pFrame-&gt;SendMessage(WM_NCPAINT);    // paint non-client area (frame too)
    return TRUE;                          // done OK
}

//////////////////
// Handle WM_SETTEXT for main window
//
void CCaptionPainter::OnSetText(LPCTSTR lpText)
{
    ASSERT_VALID(m_pFrame);

    // Turn WS_VISIBLE style off before calling Windows to
    // set the text, then turn it back on again after.
    //
    SetInternalWindowText(*m_pFrame, lpText);

    Invalidate();                            // force new bitmap
    PaintCaption(CCaptionRect(m_pFrame));    // paint caption
}

//////////////////
// "API" function to set internal window text without drawing
//
void WINAPI SetInternalWindowText(HWND hwnd, LPCTSTR lpText)
{
    // Turn off WS_VISIBLE if necessary to avoid painting
    DWORD dwStyle = ::GetWindowLong(hwnd, GWL_STYLE);
    if (dwStyle &amp; WS_VISIBLE)
        ::SetWindowLong(hwnd, GWL_STYLE, dwStyle &amp; ~WS_VISIBLE);
    
    // Call DefWindowProc directly to set internal window text.
    DefWindowProc(hwnd, WM_SETTEXT, 0, (LPARAM)lpText);

    // Restore parent visible state
    if (dwStyle &amp; WS_VISIBLE)
        ::SetWindowLong(hwnd, GWL_STYLE, dwStyle);
}

//////////////////
// Paint custom caption. Flag tells whether active or not. Just blast the
// bitmap to the title bar, but not if minimized (iconic).
//
void CCaptionPainter::PaintCaption(const CRect&amp; rc)
{
    ASSERT_VALID(m_pFrame);

    if (m_pFrame-&gt;IsIconic())
        return;

    // Get caption DC and rectangle
    CWindowDC dcWin(m_pFrame);                // window DC
    CDC dc;                                   // memory DC
    dc.CreateCompatibleDC(&amp;dcWin);            // ...create it
    if (rc.Size() != m_szCaption) {           // if size changed:
        m_bmCaption[0].DeleteObject();        // invalidate bitmaps
        m_bmCaption[1].DeleteObject();        // ...
        m_szCaption = rc.Size();              // update new size
    }

    // Get active/inactive bitmap &amp; determine if needs to be regenerated
    CBitmap&amp; bm = m_bmCaption[m_bActive!=0];    // get bitmap
    BOOL bPaintIt = FALSE;                      // paint anew?
    if (!(HBITMAP)bm) {                         // no bitmap:
        bm.CreateCompatibleBitmap(&amp;dcWin, rc.Width(), rc.Height()); // create one
        bPaintIt = TRUE;                        // and paint it
    }
    CBitmap* pOldBitmap = dc.SelectObject(&amp;bm);   // select bitmap into memory DC

    // If bitmap needs painting, call client to do it.
    if (bPaintIt) {
        PAINTCAP pc;
        pc.m_pDC = &amp;dc;
        pc.m_szCaption = rc.Size();
        pc.m_bActive  = m_bActive;
        if (m_nPaintMsg)
            m_pFrame-&gt;SendMessage(m_nPaintMsg, 0, (LPARAM)&amp;pc);
        else
            // Not handled: draw normal caption
            DrawNormalCaption(pc);
    }

    // blast bits to screen
    dcWin.BitBlt(rc.left, rc.top, rc.Width(), rc.Height(), &amp;dc, 0, 0, SRCCOPY);
    dc.SelectObject(pOldBitmap); // restore DC
}

/////////////////
// Draw normal caption. If you fail to handle the callback message,
// CCaptionPainter will call this.
//
void CCaptionPainter::DrawNormalCaption(const PAINTCAP&amp; pc)
{
    UINT uFlags = DC_TEXT|DC_ICON;
    if (pc.m_bActive)
        uFlags |= DC_ACTIVE;
    CRect rc(CPoint(0,0), pc.m_szCaption);
    ::DrawCaption(*m_pFrame, *pc.m_pDC, &amp;rc, uFlags);
    DrawButtons(pc);
}

////////////////
// Draw caption icon transparently. Returns width of icon.
//
int CCaptionPainter::DrawIcon(const PAINTCAP&amp; pc)
{
    ASSERT_VALID(m_pFrame);

    // Within the basic button rectangle, Windows 95 uses a 1 or 2 pixel border
    // Icon has 2 pixel border on left, 1 pixel on top/bottom, 0 right
    //
    int cxIcon = GetSystemMetrics(SM_CXSIZE);
    CRect rc(0, 0, cxIcon, GetSystemMetrics(SM_CYSIZE));
    rc.DeflateRect(0,1);
    rc.left += 2;
    DrawIconEx(pc.m_pDC-&gt;m_hDC, rc.left, rc.top,
               (HICON)GetClassLong(*m_pFrame, GCL_HICONSM),
               rc.Width(), rc.Height(), 0, NULL, DI_NORMAL);
    return cxIcon;
}

////////////////
// Draw min, max/restore, close buttons transparently. Returns total
// width of buttons drawn. This is really yukky.
//
int CCaptionPainter::DrawButtons(const PAINTCAP&amp; pc)
{
    ASSERT_VALID(m_pFrame);
    DWORD dwStyle = m_pFrame-&gt;GetStyle();
    if (!(dwStyle &amp; WS_CAPTION))
        return 0;

    ASSERT(pc.m_pDC);
    CDC&amp; dc = *pc.m_pDC;

    int cxIcon = GetSystemMetrics(SM_CXSIZE);
    int cyIcon = GetSystemMetrics(SM_CYSIZE);

    // Draw caption buttons. These are all drawn inside a rectangle
    // of dimensions SM_CXSIZE by SM_CYSIZE
    CRect rc(0, 0, cxIcon, cyIcon);
    rc += CPoint(pc.m_szCaption.cx-cxIcon, 0);    // move right

    // Close box has a 2 pixel border on all sides but left, which is zero
    rc.DeflateRect(0,2);
    rc.right -= 2;
    dc.DrawFrameControl(&amp;rc, DFC_CAPTION, DFCS_CAPTIONCLOSE);

    // Max/restore button is like close box; just shift rectangle left
    // Also does help button, if any.
    BOOL bMaxBox = dwStyle &amp; WS_MAXIMIZEBOX;
    if (bMaxBox || (m_pFrame-&gt;GetExStyle() &amp; WS_EX_CONTEXTHELP)) {
        rc -= CPoint(cxIcon, 0);
        dc.DrawFrameControl(&amp;rc, DFC_CAPTION,
                            bMaxBox ? (m_pFrame-&gt;IsZoomed() ? 
                            DFCS_CAPTIONRESTORE : DFCS_CAPTIONMAX) : 
                            DFCS_CAPTIONHELP);
    }

    // Minimize button has 2 pixel border on all sides but right.
    if (dwStyle &amp; WS_MINIMIZEBOX) {
        rc -= CPoint(cxIcon-2,0);
        dc.DrawFrameControl(&amp;rc, DFC_CAPTION, DFCS_CAPTIONMIN);
    }
    return pc.m_szCaption.cx - rc.left - 2;
}

//////////////////
// CCaptionRect computes caption rectangle in window coords.
//
CCaptionRect::CCaptionRect(const CFrameWnd* pFrame)
{
    // Get size of frame around window
    DWORD dwStyle = pFrame-&gt;GetStyle();
    CSize szFrame = (dwStyle &amp; WS_THICKFRAME) ?
        CSize(GetSystemMetrics(SM_CXSIZEFRAME),
              GetSystemMetrics(SM_CYSIZEFRAME)) :
        CSize(GetSystemMetrics(SM_CXFIXEDFRAME),
              GetSystemMetrics(SM_CYFIXEDFRAME));

    int cxIcon = GetSystemMetrics(SM_CXSIZE); // width of caption icon/button

    // Compute rectangle
    pFrame-&gt;GetWindowRect(this);                  // window rect in screen coords
    *this -= CPoint(left, top);                   // shift origin to (0,0)
    left  += szFrame.cx;                           // frame
    right -= szFrame.cx;                           // frame
    top   += szFrame.cy;                           // top = end of frame
    bottom = top + GetSystemMetrics(SM_CYCAPTION)  // height of caption
        - GetSystemMetrics(SM_CYBORDER);           // minus gray shadow border
}</PRE>
<P></P>
<P>Once I had ShadeCap working, I thought "this code is really ugly. I don't want to ever have to look at it again." So I implemented a class, CCaptionPainter (see Figure 2), that encapsulates custom caption painting. Figure 3 shows how ShadeCap uses it. Only the relevant sections appear; you can download the full source code from http://www.microsoft.com/msj. </P>
<P>Figure 3  ShadCap Main Frame Window Class</P>
<P></P>
<P>MainFrm.h</P>

<PRE>////////////////////////////////////////////////////////////////
// 1997 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.

#include "PaintCap.h"

#ifdef _MDI
#define CBaseFrameWnd CMDIFrameWnd
#else
#define CBaseFrameWnd CFrameWnd
#endif

/////////////////
// Mainframe that draws shaded caption a la Excel 95
//
class CMainFrame : public CBaseFrameWnd {
·
·
·
    CCaptionPainter m_capp;            // caption painter
    afx_msg int         OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg LRESULT     OnPaintMyCaption(WPARAM wp, LPARAM lp);
};

#ifdef _MDI

//////////////////
// MDI child window class to install caption painter
//
class CMyChildWnd : public CMDIChildWnd {
·
·
·
    CCaptionPainter m_capp;            // caption painter
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
};

#endif
</PRE>
<P></P>
<P>MainFrm.cpp</P>

<PRE>////////////////////////////////////////////////////////////////
// 1997 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// 
#include "StdAfx.h"
#include "ShadeCap.h"
#include "MainFrm.h"
#include "PaintCap.h"

// Could also use RegisterWindowMessage
const UINT WM_PAINTMYCAPTION = WM_USER;

IMPLEMENT_DYNCREATE(CMainFrame, CBaseFrameWnd)
BEGIN_MESSAGE_MAP  (CMainFrame, CBaseFrameWnd)
    ON_WM_CREATE()
    ON_MESSAGE(WM_PAINTMYCAPTION, OnPaintMyCaption)
·
·
·
END_MESSAGE_MAP()

·
·
·
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    .
    . // Standard create stuff
    .
    // Install caption painter
    m_capp.Install(this, WM_PAINTMYCAPTION);
    return 0;
}

·
·
·

//////////////////
// Paint custom caption.
// This is the function that actually does the shading. 
//
LRESULT CMainFrame::OnPaintMyCaption(WPARAM bSettingChange, LPARAM lParam)
{
    if (bSettingChange==1) {
        // wParam = 1 means system setting change: invalidate fonts.
        m_fontCaption.DeleteObject();
        m_fontAcme.DeleteObject();
        return 0;
    }
    const PAINTCAP&amp; pc = *((PAINTCAP*)lParam);
    ASSERT(pc.m_pDC);
    CDC&amp; dc = *pc.m_pDC;

.
. // Lots of code to do shaded caption
.

    return 0;
}

#ifdef _MDI

IMPLEMENT_DYNCREATE(CMyChildWnd, CMDIChildWnd)
BEGIN_MESSAGE_MAP  (CMyChildWnd, CMDIChildWnd)
    ON_WM_CREATE()
END_MESSAGE_MAP()

·
·
·

int CMyChildWnd::OnCreate(LPCREATESTRUCT lpcs)
{
    if (CMDIChildWnd::OnCreate(lpcs) == -1)
        return -1;
    m_capp.Install(this);
    return 0;
}

#endif</PRE>
<P></P>
<P>To use CCaptionPainter, you first instantiate a CCaptionPainter object in your main window class.</P>
<P></P>

<PRE>#include "PaintCap.h"

class CMainFrame : public CMDIFrameWnd {
   CCaptionPainter m_capp;
.
.
.
};</PRE>
<P></P>
<P>Then, in your OnCreate handler, you must install the caption painter.</P>
<P></P>

<PRE>// any value you want
const UINT WM_PAINTMYCAPTION = WM_USER;

int CMainFrame::OnCreate(LPCREATESTRUCT lpcs)
{
.
. // normal OnCreate stuff
.
    m_capp.Install(this, WM_PAINTMYCAPTION);
}</PRE>
<P></P>
<P>CCaptionPainter::Install takes a pointer to your main window and an integer callback message that CCaptionPainter will send to your window when it's time to paint the caption. CCaptionPainter sends this message with wParam= activated state and lParam = a pointer to a PAINTCAP struct.</P>
<P></P>

<PRE>// (in PaintCap.h)
struct PAINTCAP {
    CDC*    m_pDC;         // DC to draw in
    CSize   m_szCaption;   // size of caption rectangle
    BOOL    m_bActive;     // activated state
};</PRE>
<P></P>
<P>PAINTCAP contains the size of the caption rectangle including icon and min/max/close buttons and a device context for you to draw in. CCaptionPainter also has handy member functions to draw the icon and buttons so you don't have to do it manually.</P>
<P></P>

<PRE>LRESULT CMainFrame::OnPaintMyCaption(WPARAM bActive, 
                                     LPARAM lParam)
{
.
. // paint caption background
.
    int cxIcon  = m_capp.DrawIcon(pc);
    int cxButns = m_capp.DrawButtons(pc);
    .
    . // paint title, etc.
    .
}
</PRE>
<P>CCaptionPainter::DrawIcon draws the app's icon and returns the width in pixels. DrawButtons does the same thing for whichever combination of min/max/close buttons your app uses. It even knows about the new WS_EX_CONTEXTHELP button. Typically, you'll paint the caption background first—for example, ShadeCap's shaded caption—then call DrawIcon and DrawButtons to draw the icon and buttons, then draw the text or whatever else you want. You don't have to worry about flicker because CCaptionPainter gives you a memory DC. When you're finished drawing, CCaptionPainter blasts the bits to the screen. CCaptionPainter even maintains bitmaps for the active/inactive captions (as ShadeCap did), so it only sends your window a paint message when the user has actually changed the size of the caption. </P>
<P>For MDI apps, you have to install a caption painter in your MDI child window class, too. That's so CCaptionPainter will bypass the Windows 95 default message proc for MDI child windows, DefMDIChildProc, when handling WM_SETTEXT. In ShadeCap, CMyMDIChildWnd installs a caption painter with zero as the callback message. If the callback message is zero, CCaptionPainter paints a normal caption. In theory, you could use the same callback message or a different one for your MDI child windows, too, so that both the frame and child windows would have custom captions—but I've never actually tried it. </P>
<P>If you want to do custom caption buttons, you'll have to handle the non-client mouse messages yourself; CCaptionPainter doesn't do mouse messages. It does tell you when the user has changed colors or fonts. When Windows sends WM_SYSCOLORCHANGE or WM_SETTINGCHANGE, CCaptionPainter passes the event to your frame window in the form of a callback message with wParam = 1. This is your cue to regenerate any fonts or brushes you may have hanging around.</P>
<P>If you're wondering how CCaptionPainter achieves all this magic, it uses the CMsgHook message-hooking class from my March 1997 "More Fun with MFC" article (with the mea culpa error in it). I have since renamed CMsgHook to CSubclassWnd since that's what it really does: it lets you subclass an MFC CWnd object multiple times. CSubclassWnd works by inserting a message proc in front of the one MFC uses. If you want the full poop read the MFC article, but close your eyes when you get to the part about multiple inheritance and other frameworks. </P>
<P>Once I had CMsgHook/CSubclassWnd, implementing CCaptionPainter was pretty simple. I just moved all the code from CMainFrame to CCaptionPainter and edited it slightly to invoke CWnd functions through CSubclassWnd::m_pWndHooked instead of the implicit this pointer. CSubclassWnd is not derived from CWnd; rather, it stores a pointer to the subclassed window in a data member, m_pWndHooked. Since CMsgHook/CSubclassWnd appeared in the article, it doesn't appear in <B>Figure 2</B>. As always, full source code is available see http://www.microsoft.com/msj.</P>
<P>CCaptionPainter reduces custom captions to the thing that really matters—actually painting the caption. You don't have to handle WM_NCPAINT, WM_NCACTIVATE, WM_SETTEXT, or any of that. Just install the object and handle your own, private paint-caption message. It's the way WM_NCPAINT should have worked if it were designed properly. Thanks to Gil and Jeroen for helping me find and fix the bugs in ShadeCap. </P>
<P>Have a question about programming in C or C++? Send it to Paul DiLascia at askpd@pobox.com</P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright &copy; 1997 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S. and Canada, or (303) 678-0439 in all other countries. For other inquiries, call (415) 905-2200.</P>
<P></P></font></body></HTML>
