<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How to Exploit Multiple Monitor Support in Memphis and Windows NT 5.0</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">
<H1>How to Exploit Multiple Monitor Support in Memphis and Windows NT 5.0</H1><P>David Campbell</P>
<P>David Campbell is a support engineer in Microsoft Developer Support who supports user interface issues for Windows, specializing in shell extensions.</P>
<P>Have&nbsp;you&nbsp;noticed how precious screen real estate has become? The monitor never seems big enough and the resolution never seems high enough. I want to see Outlook&trade;, Microsoft&reg; Internet Explorer, Microsoft Developer Studio, and the app that I'm debugging all at the same time—I just don't have enough room! </P>
<P>If you're too low on the company totem pole to requisition a 35-inch video monitor, there is an alternative: multiple monitors. Memphis (the codename for the next version in the Windows&reg; 95 family) and Windows NT&reg; 5.0 both contain a set of features that will allow you to use multiple display devices at the same time; that is, multiple video cards and monitors on the same machine, all part of the same virtual desktop, all with seamless support built right into the operating system.</P>
<P>Previous versions of Windows 95 and Windows NT had no built-in&nbsp;support&nbsp;for&nbsp;multiple monitors. Only a few custom solutions existed, many of which imposed serious restrictions on a system such as the hardware required or supported, the shape of the desktop, the color depth and resolution, and,&nbsp;most&nbsp;significantly,&nbsp;compatibility&nbsp;with&nbsp;existing&nbsp;applications. </P>
<P>In this article I'll review the theory and operation of multiple monitor support, look at the new APIs and some of the programming issues you should consider, and go over how to actually install multiple monitors, including how the user interface changes in response to multiple monitors. My information is based on beta versions of the new operating systems. As with all articles that discuss beta software, keep in mind that the information here is preliminary, and could change suddenly and drastically. Don't ship a product based on this information until you have built and tested it on release versions of the software.</P>
<P></P>
<H2><A NAME="sec0"></A>Theory and Operation of Multiple Monitors</H2><P>Although your needs obviously will dictate how you set up your system, I'll discuss three options here for using multiple monitors.</P>
<P>Large desktops The Windows desktop can now cover more than one monitor with no restrictions on size, position, resolution, or refresh rates (see Figure 1). The system can be configured to the size and relative position of each monitor. Applications can be moved seamlessly from one monitor to another, or be displayed simultaneously on more than one monitor.</P>
<P><img src="mon1.gif"></P>
<P>Figure 1  Large Desktops</P>
<P>Screen duplication/remote display Alternatively, you can use secondary monitors to display the same data as the primary monitor (see Figure 2). This would be useful for training or for presentations to a group.Screen duplication could also be used to control remote applications such as in a support situation or for telecommuting. </P>
<P>{mon2.gif}</P>
<P>Figure 2  Screen Duplication/Remote Display</P>
<P>Multiple independent displays A monitor does not need to be part of the Windows desktop for applications to have access to it. Applications can make use of an additional display even if it isn't part of the desktop. For example, if you have a large, high-resolution display for a CAD application, your application can use that monitor for output through Windows APIs, without requiring it to be part of the virtual desktop. That means you don't have to worry about accidentally dragging windows onto that screen. It's like having a display monitor you can draw on via GDI, but it isn't part of the Windows desktop so you don't have a taskbar or any other shell goodies to worry about.</P>
<P></P>
<H2><A NAME="sec1"></A>Virtual Desktop </H2><P>On single-monitor systems, the actual desktop is the same size and shape as the only monitor on the system. On a multimonitor system, each monitor is actually a view onto the underlying virtual desktop. The area that each monitor presents can be adjusted in the control panel. The primary monitor will always have compatible coordinates corresponding to 0,0 for the upper-left corner and the <I>x</I> and <I>y</I> resolution for the lower-right corner (see Figure 3). The actual coordinates that the secondary monitors view will depend on the layout of the monitors, which is also decided in the control panel and is usually modeled on the actual physical layout of the monitors on the user's desk. </P>
<P><img src="mon3.gif"></P>
<P>Figure 3  Virtual Desktop</P>
<P>You can use the control panel to change the resolution of any of the monitors, but you can only change the coordinates of the secondary monitors. The primary monitor's top-left coordinates must remain 0,0 for compatibility. In addition, all the monitors must touch each other on the virtual desktop. This restriction allows the system to maintain the illusion of a single, large desktop that you can maneuver on freely, seamlessly crossing from one monitor to another. At no point do you lose track of the mouse while travelling between monitors. </P>
<P>Since the desktop area that each monitor actually views must be adjacent to another monitor, the virtual desktop can be calculated as the bounding rectangle of all of the rectangular areas that can be seen on all of the existing monitors. Given that the coordinate system must be continuous, the coordinates for the secondary monitor simply continue from the primary. For example, if a secondary monitor is adjacent to the right edge of the primary monitor, its coordinates will start at the primary monitor's <I>x</I> resolution + 1 and continue to primary <I>x</I> resolution + secondary <I>x</I> resolution. If the primary and secondary monitors each have a resolution of 1024&nbsp;<SPAN>¥</SPAN>&nbsp;768, then a secondary monitor attached to the right of the primary monitor will have coordinates from 1024,0 to 2047,767.</P>
<P>Also, some of the virtual desktop area may actually be offscreen in the sense that there is no monitor that views that area. This may occur if the monitors are not completely lined up or if there are monitors with different resolutions. For example, say I have a 1024&nbsp;<SPAN>¥</SPAN>&nbsp;768 primary monitor and an 800&nbsp;<SPAN>¥</SPAN>&nbsp;600 secondary monitor. The primary monitor has coordinates 0,0 to 1023,767, and the secondary monitor, which is attached to the left of my primary, has coordinates –800,168 to -1,767. This results in an area with coordinates from –800,0 to -1,167 that is not displayed on any monitor. For the most part, you don't have to worry about this area since Windows will not let the user move the mouse there, but keep in mind that the area is included in the calculation of the virtual desktop. Therefore, for my system the virtual desktop has coordinates from –800,0 to 1023,767. </P>
<P></P>
<H2><A NAME="sec2"></A>What's New</H2><P>OK, you've installed multiple monitors and now you want to take it further. Maybe you want to develop a custom app that is multimonitor-aware, or maybe you want to make use of a custom display device. Maybe you just want to make sure your existing application isn't doing anything that looks odd on a multimonitor system.</P>
<P>Several new APIs have been added for determining which monitor something is displayed on and for getting the settings for each monitor that a window may be visible on. Figure 4 is a summary of some of the key APIs.</P>
<P>Figure 4  Key Multimonitor APIs</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="153pt" VALIGN="TOP"><COL WIDTH="288pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>MonitorFromPoint </B></P></TD><TD VALIGN="TOP"><P>Determines the monitor that contains a specific point.</P></TD></TR><TR><TD VALIGN="TOP"><P><B>MonitorFromRect</B></P></TD><TD VALIGN="TOP"><P>Determines the monitor that contains the largest piece of the rectangle.</P></TD></TR><TR><TD VALIGN="TOP"><P><B>MonitorFromWindow</B></P></TD><TD VALIGN="TOP"><P>Determines the monitor that a window belongs to (which monitor contains the majority of the window).</P></TD></TR><TR><TD VALIGN="TOP"><P><B>GetMonitorInfo</B></P></TD><TD VALIGN="TOP"><P>Gets metric information for a particular monitor.</P></TD></TR><TR><TD VALIGN="TOP"><P><B>ChangeDisplaySettingsEx</B></P></TD><TD VALIGN="TOP"><P>Same as ChangeDisplaySettings except that it allows the caller to specify the device.</P></TD></TR><TR><TD VALIGN="TOP"><P><B>EnumDisplayMonitors</B></P></TD><TD VALIGN="TOP"><P>Returns info about multiple video devices that an application may overlap. A monitor need not be part of the Windows virtual desktop. </P></TD></TR><TR><TD VALIGN="TOP"><P><B>EnumDisplayDevices</B></P></TD><TD VALIGN="TOP"><P>Allows you to determine the actual list of devices available on a given machine. You can enumerate the devices and get a DC for any monitor on the system that Windows supports. This allows an application to work with a dedicated display device without sharing the screen with other applications. (This is used, for example, by the Control Panel.)</P></TD></TR><TR><TD VALIGN="TOP"><P><B>SystemParametersInfo and GetSystemMetrics</B></P></TD><TD VALIGN="TOP"><P>These APIs were updated slightly to include support for multiple monitors, and CreateDC was updated to take a display name in the \\.\DisplayX, where X is a number. This can be used in conjunction with EnumDisplayDevices to get DCs for specific monitors.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>You can now develop an application that is multimonitor-aware yet still runs on existing Windows 95 and Windows NT 4.0 machines. There is a new include file (see Figure 5) that uses GetProcAddress to link these APIs to the corresponding operating system APIs, if they exist. If not, the include file provides default implementations so the same EXE will run on Windows 95, Windows NT 4.0, Memphis, and Windows NT 5.0. On a Windows 95 or Windows NT 4.0 machine, your code will get stubbed to the versions of the APIs in the header file (which return correct values for those systems to your code).  However, on an operating system that is multimonitor-aware, the code will pass through to the actual system APIs. </P>
<P>Figure 5  Multimon.h</P>

<PRE>#if !defined(_WIN32_WINNT) || (_WIN32_WINNT &lt; 0x0500)

//=============================================================================
//
// MULTIMON
// stub module that "stubs" multiple monitor APIs on pre-Memphis Win32 OSes
//
// By using this header your code will work unchanged on Win95,
// you will get back correct values from GetSystemMetrics() for new metrics
// and the new APIs will act like only one display is present.
//
// exactly one source must include this with COMPILE_MULTIMON_STUBS defined
//
//=============================================================================

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
// if we are building on Win95/NT4 headers we need to declare this stuff ourselves
//
#ifndef SM_CMONITORS

#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81

DECLARE_HANDLE(HMONITOR);

#define MONITOR_DEFAULTTONULL       0x00000000
#define MONITOR_DEFAULTTOPRIMARY    0x00000001
#define MONITOR_DEFAULTTONEAREST    0x00000002

#define MONITORINFOF_PRIMARY        0x00000001

typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;

#define CCHDEVICENAME 32

#ifdef __cplusplus
typedef struct tagMONITORINFOEX : public tagMONITORINFO
{
  TCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEX, *LPMONITORINFOEX;
#else
typedef struct
{
  MONITORINFO;
  TCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEX, *LPMONITORINFOEX;
#endif

typedef BOOL (CALLBACK* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

#endif  // SM_CMONITORS

#ifndef DISPLAY_DEVICE_ATTACHED_TO_DESKTOP

typedef struct {
    DWORD  cb;
    CHAR   DeviceName[32];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
} DISPLAY_DEVICE;

#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001
#define DISPLAY_DEVICE_MULTI_DRIVER        0x00000002
#define DISPLAY_DEVICE_PRIMARY_DEVICE      0x00000004
#define DISPLAY_DEVICE_MIRRORING_DRIVER    0x00000008

#endif
#define DISPLAY_DEVICE_VGA                 0x00000010

#ifndef ENUM_CURRENT_SETTINGS
#define ENUM_CURRENT_SETTINGS       ((DWORD)-1)
#define ENUM_REGISTRY_SETTINGS      ((DWORD)-2)
#endif

#undef GetMonitorInfo
#undef GetSystemMetrics
#undef MonitorFromWindow
#undef MonitorFromRect
#undef MonitorFromPoint
#undef EnumDisplayMonitors
#undef EnumDisplayDevices

//
// define this to compile the stubs
// otherwise you get the declarations
//
#ifdef COMPILE_MULTIMON_STUBS

    //---------------------------------------------------------------------------
    //
    // Implement the API stubs.
    //
    //---------------------------------------------------------------------------

    int      (WINAPI* g_pfnGetSystemMetrics)(int);
    HMONITOR (WINAPI* g_pfnMonitorFromWindow)(HWND, BOOL);
    HMONITOR (WINAPI* g_pfnMonitorFromRect)(LPCRECT, BOOL);
    HMONITOR (WINAPI* g_pfnMonitorFromPoint)(POINT, BOOL);
    BOOL     (WINAPI* g_pfnGetMonitorInfo)(HMONITOR, LPMONITORINFO);
    BOOL     (WINAPI* g_pfnEnumDisplayMonitors)(HDC, LPCRECT,
              MONITORENUMPROC, LPARAM);
    BOOL     (WINAPI *g_pfnEnumDisplayDevices)(LPVOID, int, 
              DISPLAY_DEVICE *,DWORD);

    BOOL InitMultipleMonitorStubs(void)
    {
        HMODULE hUser32;
        static BOOL fInitDone;

        if (fInitDone)
        {
            return g_pfnGetMonitorInfo != NULL;
        }

        if ((hUser32 = GetModuleHandle(TEXT("USER32"))) &amp;&amp;
            (*(FARPROC*)&amp;g_pfnGetSystemMetrics    = GetProcAddress(hUser32,"GetSystemMetrics")) &amp;&amp;
            (*(FARPROC*)&amp;g_pfnMonitorFromWindow   = GetProcAddress(hUser32,"MonitorFromWindow")) &amp;&amp;
            (*(FARPROC*)&amp;g_pfnMonitorFromRect     = GetProcAddress(hUser32,"MonitorFromRect")) &amp;&amp;
            (*(FARPROC*)&amp;g_pfnMonitorFromPoint    = GetProcAddress(hUser32,"MonitorFromPoint")) &amp;&amp;
            (*(FARPROC*)&amp;g_pfnEnumDisplayMonitors = GetProcAddress(hUser32,"EnumDisplayMonitors")) &amp;&amp;
    #ifdef UNICODE
            (*(FARPROC*)&amp;g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoW")) &amp;&amp;
            (*(FARPROC*)&amp;g_pfnEnumDisplayDevices  = GetProcAddress(hUser32,"EnumDisplayDevicesW")) &amp;&amp;
    #else
            (*(FARPROC*)&amp;g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoA")) &amp;&amp;
            (*(FARPROC*)&amp;g_pfnEnumDisplayDevices  = GetProcAddress(hUser32,"EnumDisplayDevicesA")) &amp;&amp;
    #endif
            (GetSystemMetrics(SM_CXVIRTUALSCREEN) &gt;= GetSystemMetrics(SM_CXSCREEN)) &amp;&amp;
            (GetSystemMetrics(SM_CYVIRTUALSCREEN) &gt;= GetSystemMetrics(SM_CYSCREEN)) )
        {
            fInitDone = TRUE;
            return TRUE;
        }
        else
        {
            g_pfnGetSystemMetrics    = NULL;
            g_pfnMonitorFromWindow   = NULL;
            g_pfnMonitorFromRect     = NULL;
            g_pfnMonitorFromPoint    = NULL;
            g_pfnGetMonitorInfo      = NULL;
            g_pfnEnumDisplayMonitors = NULL;
            g_pfnEnumDisplayDevices  = NULL;

            fInitDone = TRUE;
            return FALSE;
        }
    }

    //---------------------------------------------------------------------------
    //
    // "stubbed" implementations of Monitor APIs that work with the primary         //  display
    //
    //---------------------------------------------------------------------------

    int WINAPI
    xGetSystemMetrics(int nIndex)
    {
        if (InitMultipleMonitorStubs())
            return g_pfnGetSystemMetrics(nIndex);

        switch (nIndex)
        {
        case SM_CMONITORS:
        case SM_SAMEDISPLAYFORMAT:
            return 1;

        case SM_XVIRTUALSCREEN:
        case SM_YVIRTUALSCREEN:
            return 0;

        case SM_CXVIRTUALSCREEN:
            nIndex = SM_CXSCREEN;
            break;

        case SM_CYVIRTUALSCREEN:
            nIndex = SM_CYSCREEN;
            break;
        }

        return GetSystemMetrics(nIndex);
    }

    #define xPRIMARY_MONITOR ((HMONITOR)0x42)

    HMONITOR WINAPI
    xMonitorFromRect(LPCRECT lprcScreenCoords, UINT uFlags)
    {
        if (InitMultipleMonitorStubs())
            return g_pfnMonitorFromRect(lprcScreenCoords, uFlags);

        if ((uFlags &amp; (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
            ((lprcScreenCoords-&gt;right &gt; 0) &amp;&amp;
            (lprcScreenCoords-&gt;bottom &gt; 0) &amp;&amp;
            (lprcScreenCoords-&gt;left &lt; GetSystemMetrics(SM_CXSCREEN)) &amp;&amp;
            (lprcScreenCoords-&gt;top &lt; GetSystemMetrics(SM_CYSCREEN))))
        {
            return xPRIMARY_MONITOR;
        }

        return NULL;
    }

    HMONITOR WINAPI
    xMonitorFromWindow(HWND hWnd, UINT uFlags)
    {
        RECT rc;

        if (InitMultipleMonitorStubs())
            return g_pfnMonitorFromWindow(hWnd, uFlags);

        if (uFlags &amp; (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST))
            return xPRIMARY_MONITOR;

        if (GetWindowRect(hWnd, &amp;rc))
            return xMonitorFromRect(&amp;rc, uFlags);

        return NULL;
    }

    HMONITOR WINAPI
    xMonitorFromPoint(POINT ptScreenCoords, UINT uFlags)
    {
        if (InitMultipleMonitorStubs())
            return g_pfnMonitorFromPoint(ptScreenCoords, uFlags);

        if ((uFlags &amp; (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
            ((ptScreenCoords.x &gt;= 0) &amp;&amp;
            (ptScreenCoords.x &lt; GetSystemMetrics(SM_CXSCREEN)) &amp;&amp;
            (ptScreenCoords.y &gt;= 0) &amp;&amp;
            (ptScreenCoords.y &lt; GetSystemMetrics(SM_CYSCREEN))))
        {
            return xPRIMARY_MONITOR;
        }

        return NULL;
    }

    BOOL WINAPI
    xGetMonitorInfo(HMONITOR hMonitor, LPMONITORINFO lpMonitorInfo)
    {
        RECT rcWork;

        if (InitMultipleMonitorStubs())
            return g_pfnGetMonitorInfo(hMonitor, lpMonitorInfo);

        if ((hMonitor == xPRIMARY_MONITOR) &amp;&amp; lpMonitorInfo &amp;&amp;
            (lpMonitorInfo-&gt;cbSize &gt;= sizeof(MONITORINFO)) &amp;&amp;
            SystemParametersInfo(SPI_GETWORKAREA, 0, &amp;rcWork, 0))
        {
            lpMonitorInfo-&gt;rcMonitor.left = 0;
            lpMonitorInfo-&gt;rcMonitor.top  = 0;
            lpMonitorInfo-&gt;rcMonitor.right  = GetSystemMetrics(SM_CXSCREEN);
            lpMonitorInfo-&gt;rcMonitor.bottom = GetSystemMetrics(SM_CYSCREEN);
            lpMonitorInfo-&gt;rcWork = rcWork;
            lpMonitorInfo-&gt;dwFlags = MONITORINFOF_PRIMARY;

            if (lpMonitorInfo-&gt;cbSize &gt;= sizeof(MONITORINFOEX))
                lstrcpy(((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice,
                TEXT("DISPLAY"));

            return TRUE;
        }

        return FALSE;
    }

    BOOL WINAPI
    xEnumDisplayMonitors(
        HDC hdc,
        LPCRECT lprcIntersect, 
        MONITORENUMPROC lpfnEnumProc,
        LPARAM lData)
    {
        RECT rcCallback, rcLimit;

        if (InitMultipleMonitorStubs())
            return g_pfnEnumDisplayMonitors(hdc, lprcIntersect, lpfnEnumProc,
                                           lData);
    
        if (!lpfnEnumProc)
            return FALSE;

        rcLimit.left   = 0;
        rcLimit.top    = 0;
        rcLimit.right  = GetSystemMetrics(SM_CXSCREEN);
        rcLimit.bottom = GetSystemMetrics(SM_CYSCREEN);

        if (hdc)
        {
            RECT rcClip;
            HWND hWnd;

            if ((hWnd = WindowFromDC(hdc)) == NULL)
                return FALSE;

            switch (GetClipBox(hdc, &amp;rcClip))
            {
            default:
                MapWindowPoints(NULL, hWnd, (LPPOINT)&amp;rcLimit, 2);
                if (IntersectRect(&amp;rcCallback, &amp;rcClip, &amp;rcLimit))
                    break;
                //fall thru
            case NULLREGION:
                 return TRUE;
            case ERROR:
                 return FALSE;
            }

            rcLimit = rcCallback;
        }

        if (!lprcIntersect ||
            IntersectRect(&amp;rcCallback, lprcIntersect, &amp;rcLimit))
        {
            lpfnEnumProc(xPRIMARY_MONITOR, hdc, &amp;rcCallback, lData);
        }

        return TRUE;
    }

    BOOL WINAPI
    xEnumDisplayDevices(LPVOID lpReserved, int iDeviceNum, 
DISPLAY_DEVICE * pDisplayDevice, DWORD dwFlags)
    {
        if (InitMultipleMonitorStubs())
            return g_pfnEnumDisplayDevices(lpReserved, iDeviceNum,
                                           pDisplayDevice, dwFlags);
    
        return FALSE;
    }

    #undef xPRIMARY_MONITOR
    #undef COMPILE_MULTIMON_STUBS

#else    // COMPILE_MULTIMON_STUBS

    extern int    WINAPI xGetSystemMetrics(int);
    extern HMONITOR WINAPI xMonitorFromWindow(HWND, UINT);
    extern HMONITOR WINAPI xMonitorFromRect(LPCRECT, UINT);
    extern HMONITOR WINAPI xMonitorFromPoint(POINT, UINT);
    extern BOOL    WINAPI xGetMonitorInfo(HMONITOR, LPMONITORINFO);
    extern BOOL    WINAPI xEnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC,
                                               LPARAM);
    extern BOOL WINAPI xEnumDisplayDevices(LPVOID, int, DISPLAY_DEVICE *,DWORD);

#endif    // COMPILE_MULTIMON_STUBS

//
// build defines that replace the regular APIs with our versions
//
#define GetSystemMetrics    xGetSystemMetrics
#define MonitorFromWindow   xMonitorFromWindow
#define MonitorFromRect     xMonitorFromRect
#define MonitorFromPoint    xMonitorFromPoint
#define GetMonitorInfo      xGetMonitorInfo
#define EnumDisplayMonitors xEnumDisplayMonitors
#define EnumDisplayDevices    xEnumDisplayDevices

#ifdef __cplusplus
}
#endif    /* __cplusplus */

#endif  /* !defined(_WIN32_WINNT) || (_WIN32_WINNT &lt; 0x0500) */</PRE>
<P></P>
<P>Now let's take a detailed look at the APIs for multimonitor support. Each physical display device is represented to the application by a monitor handle called an HMONITOR. A physical device has the same HMONITOR value throughout its lifetime, even across changes to display settings, as long as it remains a part of the desktop. A valid HMONITOR is guaranteed to be non-NULL. When a WM_DISPLAYCHANGE message is broadcast, any HMONITOR may have its settings changed in some way, or it may be removed from the desktop and become invalid.</P>
<P>The MonitorFromPoint API returns the monitor that contains pt.</P>
<P></P>

<PRE>HMONITOR MonitorFromPoint(POINT pt, DWORD dwFlags);</PRE>
<P></P>
<P>If no monitor contains pt, the return value depends upon the dwFlags field, which can be MONITOR_DEFAULTTONULL to return NULL, MONITOR_DEFAULTTOPRIMARY to return the HMONITOR of the primary monitor, or MONITOR_DEFAULTTONEAREST to return the HMONITOR nearest to the point pt.</P>
<P>The MonitorFromRect API returns the monitor that intersects lprc.</P>
<P></P>

<PRE>HMONITOR WINUSERAPI MonitorFromRect(LPCRECT lprc,<BR>                                    DWORD dwFlags);</PRE>
<P></P>
<P>If no monitor intersects lprc, the return value depends upon the dwFlags field. The flags from MonitorFromPoint are used. If the rect intersects more than one monitor, this returns the monitor containing most of the rectangle.</P>
<P>The MonitorFromWindow API returns the monitor that a window belongs to.</P>
<P></P>

<PRE>HMONITOR WINUSERAPI MonitorFromWindow(HWND hwnd,<BR>                                      DWORD dwFlags);</PRE>
<P></P>
<P>If a window doesn't belong to a monitor, the return value depends upon the dwFlags field. The flags from MonitorFromPoint are used. If the window intersects more than one monitor, this returns the monitor containing the majority of the window.</P>
<P>The well-known SystemParametersInfo API now includes changes to the uiAction values SPI_GETWORKAREA and SPI_SETWORKAREA. SPI_GETWORKAREA retrieves the size of the working area, which is the portion of the screen not obscured by the taskbar. The pvParam parameter points to the RECT structure that receives the coordinates of the working area. Likewise, SPI_SETWORKAREA sets the size of the work area. The pvParam parameter points to the RECT structure that contains the coordinates of the work area. SPI_SETWORKAREA has been modified to change the work area of the monitor that pvParam belongs to. If pvParam is NULL, the work area of the primary monitor is modified. SPI_GETWORKAREA always returns the work area of the primary monitor. If an app needs the work area of a monitor other than the primary one, it should call GetMonitorInfo (which I'll describe later).</P>
<P>The GetSystemMetrics API has had changes and clarifications made to some of its nIndex values. If you use SM_CXSCREEN or SM_CYSCREEN, you still get the pixel width and height of the screen, but this is only for the primary screen. The same goes for GetDeviceCaps(hdcPrimaryMonitor, HORZRES/VERTRES). If you use SM_XVIRTUALSCREEN, SM_YVIRTUALSCREEN, SM_CXVIRTUALSCREEN, or SM_CYVIRTUALSCREEN, you get the left, top, width, and height of the virtual screen in pixels, respectively (see Figure 6). The SM_SAMEDISPLAYFORMAT returns true if all monitors have the same color format. Note that two displays can have the same bit depth but different color formats if the red, green, and blue pixels have different sizes or are located in different places in a pixel. SM_CMONITORS tells you how many monitors are on the desktop. </P>
<P><img src="mon6.gif"></P>
<P>Figure 6  New GetSystemMetrics Values</P>
<P>This piece of sample code (just pretend there really is a Print function like this)</P>
<P></P>

<PRE>Print("SM_CMONITORS         is %d", GetSystemMetrics(SM_CMONITORS));
Print("SM_SAMEDISPLAYFORMAT is %d", GetSystemMetrics(SM_SAMEDISPLAYFORMAT));
Print("SM_XVIRTUALSCREEN    is %d", GetSystemMetrics(SM_XVIRTUALSCREEN));
Print("SM_YVIRTUALSCREEN    is %d", GetSystemMetrics(SM_YVIRTUALSCREEN));
Print("SM_CXVIRTUALSCREEN   is %d", GetSystemMetrics(SM_CXVIRTUALSCREEN));
Print("SM_CYVIRTUALSCREEN   is %d", GetSystemMetrics(SM_CYVIRTUALSCREEN));</PRE>
<P></P>
<P>would produce the following output on my system:</P>
<P></P>

<PRE>SM_CMONITORS         is 2
SM_SAMEDISPLAYFORMAT is 1
SM_XVIRTUALSCREEN    is -800
SM_YVIRTUALSCREEN    is 0
SM_CXVIRTUALSCREEN   is 1824
SM_CYVIRTUALSCREEN   is 768</PRE>
<P></P>
<P>As you can see, my sample system has two monitors, both using the same pixel color depth. One of my monitors is 1024&nbsp;<SPAN>¥</SPAN>&nbsp;768 pixels and the other is 800&nbsp;<SPAN>¥</SPAN>&nbsp;600 pixels. The 800&nbsp;<SPAN>¥</SPAN>&nbsp;600 display is on the left, the 1024&nbsp;<SPAN>¥</SPAN>&nbsp;768 display is on the right, and their bottom pixels are aligned.</P>
<P>The GetMonitorInfo API returns metric information relevant to a particular monitor (see Figure 7). cbSize is the size of the MONITORINFO struct. A valid instance of a MONITORINFO struct must have this field set equal to sizeof(MONITORINFO) or sizeof(MONITORINFOEX) before a call to GetMonitorInfo is made. rcMonitor is the rectangle of the monitor in the virtual screen. rcWork is the rectangle of the work area of the monitor in the virtual screen. dwFlags provide some additional information about the monitor. The only flag currently defined is MONITORF_PRIMARY. szDevice is the name of the device, and it is only present in the MONITORINFOEX struct. Most apps will never use this field, and can pass in a MONITORINFO struct instead of a MONITORINFOEX. For example, this piece of code </P>
<P></P>

<PRE>MONITORINFOEX mi;
        mi.cbSize = sizeof(mi);
        GetMonitorInfo(hMonitor, (MONITORINFO*)&amp;mi);

Print("Monitor %08X", hMonitor);
Print("      szDevice  = '%s'", (LPSTR)mix.szDevice);
Print("      rcMonitor = [%d,%d,%d,%d]", mi.rcMonitor);
Print("      rcWork    = [%d,%d,%d,%d]", mi.rcWork);
Print("      dwFlags   = %08X", mi.dwFlags);</PRE>
<P></P>
<P>produces the output:</P>
<P></P>

<PRE>Monitor 00000FAE
      szDevice  = '\\.\Display1'
      rcMonitor = [0,0,1024,768]
      rcWork    = [0,0,1024,740]
      dwFlags   = 00000001</PRE>
<P></P>
<P>Figure 7  GetMonitorInfo</P>

<PRE>BOOL GetMonitorInfo(
        HMONITOR hmonitor, // the monitor to get the info for
        LPMONITORINFO lpmi // the location of a MONITORINFO struct to receive the info
);

typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;

typedef struct tagMONITORINFOEXA
{
    MONITORINFO;
    TCHAR        szDevice[CCHDEVICENAME];
} MONITORINFOEX, *LPMONITORINFOEX;</PRE>
<P></P>
<P>The EnumDisplayMonitors API lets you paint into a DC that spans more than one display. It calls you back for each monitor that intersects your window and gives you an HDC that is appropriate to that monitor. The capabilities and color depth information from that HDC will match those of the monitor. The app can then paint the piece of its window on that monitor into that DC. </P>
<P>To illustrate, here's how an app like PowerPoint&reg; could use this API. Assume half of a slide show window is on a 256-color monitor and the other half is on a 24-bit true color monitor. The operating system would call the app once for the 256-color monitor piece, and the app would dither the wash for the background. Then the operating system would call the app a second time for the piece on the 24-bit display. The presentation app would take advantage of all of the colors to draw a higher resolution screen. </P>
<P>Keep in mind that applications are not forced to do this; they can just continue painting, assuming the whole screen is the color depth of the primary monitor which will look as good as GDI can do by itself. But if an app wants to, it can paint optimally for the particular display using custom algorithms smarter than GDI's defaults. In the API declaration</P>
<P></P>

<PRE>BOOL WINAPI EnumDisplayMonitors(
        HDC                     hdc, 
        LPCRECT                 lprcClip,
        MONITORENUMPROC         lpfnEnum, 
        LPARAM                  dwData)</PRE>
<P></P>
<P>hdc is an HDC with a particular visible region. The hdcMonitor passed to MonitorEnumProc will have the capabilities of that monitor, with its visible region clipped to the monitor and hdc. If hdc is NULL, the hdcMonitor passed to MonitorEnumProc will be NULL. lprcClip is a rectangle for clipping the area. If hdc is non-NULL, the coordinates have the origin of hdc. If hdc is NULL, the coordinates are virtual screen coordinates. If lprcClip is NULL, no clipping is performed. </P>
<P>lpfnEnum is a pointer to the enumeration function. dwData is application-defined data that is passed through to the enumeration function</P>
<P></P>

<PRE>BOOL CALLBACK MonitorEnumProc(
        HMONITOR              hmonitor,
        HDC                   hdcMonitor,
        LPRC                  lprcMonitor,
        DWORD                 dwData)</PRE>
<P></P>
<P>where hmonitor is the monitor. The callback is called only if it intersects the visible region of hdc and is non-NULL and lprcClip is non-NULL. hdcMonitor is an HDC with capabilities specific to the monitor and clipping set to the intersection of hdc, lprcClip, and the dimensions of the monitor. If hdc is NULL, hdcMonitor will be NULL. lprcMonitor is the clipping area that intersects that monitor. If hdcMonitor is non-NULL, the coordinates have the origin of hdcMonitor. If hdcMonitor is NULL, the coordinates are virtual screen coordinates. dwData is application-defined data that is passed in EnumDisplayMonitors.</P>
<P>Here are some examples of how to use EnumDisplayMonitors. To paint in response to a WM_PAINT message using the capabilities of each monitor, an app would write the following in its window procedure:</P>
<P></P>

<PRE>case WM_PAINT:
        hdc = BeginPaint(hwnd, &amp;ps);
        EnumDisplayMonitors(hdc, NULL,<BR>                            MyPaintEnumProc, 0);
        EndPaint(hwnd, &amp;ps);</PRE>
<P></P>
<P>To paint the top half of a window using the capabilities of each monitor, an app would write the following:</P>
<P></P>

<PRE>GetClientRect(hwnd, &amp;rc);
rc.bottom = (rc.bottom - rc.top) / 2;
hdc = GetDC(hwnd);
EnumDisplayMonitors(hdc, &amp;rc, MyPaintEnumProc, 0);
ReleaseDC(hwnd, hdc);</PRE>
<P></P>
<P>To paint the entire screen using the capabilities of each monitor, the app would call:</P>
<P></P>

<PRE>hdc = GetDC(NULL);
EnumDisplayMonitors(hdc,&nbsp;NULL,&nbsp;MyPaintScreenEnumProc,&nbsp;0);
ReleaseDC(NULL, hdc);</PRE>
<P></P>
<P>To get information about all the displays on the desktop, the app would call:</P>
<P></P>

<PRE>EnumDisplayMonitors(NULL, NULL, MyInfoEnumProc, 0);</PRE>
<P></P>
<P>The EnumDisplayDevices API allows you to determine the actual list of devices available on a given machine:</P>
<P></P>

<PRE>BOOL WINAPI *EnumDisplayDevices(LPVOID lpReserved,<BR>                       int iDeviceNum,<BR>                       DISPLAY_DEVICE * pDisplayDevice,<BR>                       DWORD dwFlags);</PRE>
<P></P>
<P>lpReserved is reserved for future use and must be zero. iDeviceNum is a zero-based index on the device from which you want to retrieve information. pDisplayDevice is a pointer to a DISPLAY_DEVICE structure for the return information. dwFlags must currently be zero. The DISPLAY_DEVICE structure looks like</P>
<P></P>

<PRE>typedef struct {
    DWORD  cb;
    CHAR   DeviceName[32];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
} DISPLAY_DEVICE;</PRE>
<P></P>
<P>where the state flags are defined as</P>
<P></P>

<PRE>#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001
#define DISPLAY_DEVICE_MULTI_DRIVER        0x00000002
#define DISPLAY_DEVICE_PRIMARY_DEVICE      0x00000004
#define DISPLAY_DEVICE_MIRRORING_DRIVER    0x00000008
#define DISPLAY_DEVICE_VGA                 0x00000010</PRE>
<P></P>
<P>Here's more sample code </P>
<P></P>

<PRE>DISPLAY_DEVICE dd;
    ZeroMemory(&amp;dd, sizeof(dd));
    dd.cb = sizeof(dd);
    for(i=0; EnumDisplayDevices(NULL, i, &amp;dd, 0); i++)
    {
      Print("Device %d:", i);
      Print("    DeviceName:   '%s'", dd.DeviceName);
      Print("    DeviceString: '%s'", dd.DeviceString);
      Print("    StateFlags:   %s%s%s%s",<BR>            ((dd.StateFlags &amp;<BR>              DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) ?<BR>              "desktop " : ""),
            ((dd.StateFlags &amp;<BR>              DISPLAY_DEVICE_PRIMARY_DEVICE     ) ?<BR>              "primary " : ""),<BR>            ((dd.StateFlags &amp; DISPLAY_DEVICE_VGA) ?<BR>              "vga "     : ""),
            ((dd.StateFlags &amp;<BR>              DISPLAY_DEVICE_MULTI_DRIVER       ) ?<BR>              "multi "   : ""),<BR>            ((dd.StateFlags &amp;<BR>              DISPLAY_DEVICE_MIRRORING_DRIVER   ) ?<BR>              "mirror "  : ""));
    }</PRE>
<P></P>
<P>and the output it produces:</P>
<P></P>

<PRE>Device 0:
    DeviceName:   '\\.\Display1'
    DeviceString: 'ATI&nbsp;Graphics&nbsp;Pro&nbsp;Turbo&nbsp;PCI&nbsp;(mach64&nbsp;GX)'
    StateFlags:   desktop primary vga 
Device 1:
    DeviceName:   '\\.\Display2'
    DeviceString: 'ATI&nbsp;Graphics&nbsp;Pro&nbsp;Turbo&nbsp;PCI&nbsp;(mach64&nbsp;VT)'
    StateFlags:   desktop</PRE>
<P></P>
<H2><A NAME="sec3"></A>Programming Considerations</H2><P>Okay, maybe you don't need multimonitor support in your application, but what can you do to avoid being "multimonitor challenged"? There are some common Windows development practices that can make your application misbehave on a multimonitor system. </P>
<P>The most common problem to expect with multiple monitors is centering windows and dialogs on a monitor. In my opinion, this practice has questionable benefits to begin with. However, if you are going to do this you should center your window to the main application, not the monitor. If you must center on a monitor make sure you're using the correct one. Nothing looks cheesier than a window centered on the wrong monitor! If you are trying to center a dialog, use the DS_CENTER dialog style. This lets the operating system do the work and it will place the centered dialog on the correct monitor. Also, keep in mind that SM_CXSCREEN and SM_CYSCREEN always refer to the primary monitor, not necessarily the monitor that displays your application. </P>
<P>Using SM_<I>xx</I>VIRTUALSCREEN as a replacement or quick fix isn't a good idea either, since this results in your window being centered on the virtual desktop. There may be some cases where you can replace SM_<I>xx</I>SCREEN with SM_<I>xx</I>VIRTUALSCREEN, but if you do this, take into account what the code is doing rather than just using a global search and replace. (In particular, if you're calculating the center of a monitor for your splash screen, SM_<I>xx</I>VIRTUALSCREEN is not the right way to do it.) </P>
<P>Even without multiple monitors, centering windows and dialogs can be problematic. Let's say a user has a high-resolution monitor and the application is using only a small percentage of the screen area. If I center new windows to the monitor, they may come up in a location completely unrelated to where the application is.</P>
<P>Currently, most developers use code similar to the following to center a window or dialog:</P>
<P></P>

<PRE>void CenterWindowOld(HWND hWnd)
{
    RECT rcWnd;

    GetWindowRect(hWnd, &amp;rcWnd);

        // because assumptions were made about the 
        // origin and the screen, the equation
        // to center was simplified in many cases to:
        rcWnd.left = ((GetSystemMetrics(SM_CXSCREEN) - 
                      (rcWnd.right&nbsp;-&nbsp;rcWnd.left)) / 2);
        rcWnd.top  = ((GetSystemMetrics(SM_CYSCREEN) - 
                      (rcWnd.bottom&nbsp;-&nbsp;rcWnd.top )) / 2);

    SetWindowPos(hWnd, NULL, rcWnd.left, rcWnd.top,0,0,<BR>             SWP_NOSIZE | SWP_NOZORDER SWP_NOACTIVATE);
}</PRE>
<P></P>
<P>Assuming that you cannot use the DS_CENTER window style (which is really the best way to center a dialog), you could try something similar to the code in Figure 8.</P>
<P><B>Figure 8  CenterWindowNew Function</B></P>

<PRE>void CenterWindowNew(HWND hWnd)
{
    HMONITOR hMonitor;
    MONITORINFO mi;
    RECT rcWnd;
    RECT rcMon;

           GetWindowRect(hWnd, &amp;rcWnd);

    hMonitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTONEAREST);

    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &amp;mi);

    rcMon = mi.rcMonitor;

    // Since we could no longer assume where the origin is, and because we
            // have to calculate the monitor dimensions the equation is:
            // Note that if rcMon.left and rcMon.top were 0, this 
            // simplifies to the above.
    rcWnd.left   = rcMon.left + ((rcMon.right  - rcMon.left) - 
                                 (rcWnd.right  - rcWnd.left)) / 2;
    rcWnd.top    = rcMon.top  + ((rcMon.bottom - rcMon.top)  - 
                                 (rcWnd.bottom - rcWnd.top)) / 2;

    SetWindowPos(hWnd, NULL, rcWnd.left, rcWnd.top, 
                 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}</PRE>
<P></P>
<P>As I mentioned earlier, SM_CXSCREEN and SM_CYSCREEN are now going to return the <I>x</I> and <I>y</I> resolution of the primary monitor, and SM_XVIRTUALSCREEN, SM_YVIRTUALSCREEN, SM_CXVIRTUALSCREEN, and SM_CYVIRTUALSCREEN are provided to get the origin and extent of the virtual desktop. Keeping that in mind, you can see that the code in Figure 8 is functionally equivalent to the code above for systems with only one monitor.</P>
<P></P>
<H2><A NAME="sec4"></A>Coordinate Issues</H2><P>Another problem existing apps will face is that 0,0 is no longer guaranteed to be the most visible upper-left position. This means that negative coordinates can not only exist, but they may be visible. Applications that use negative coordinates to hide their app or assume that there are no negative coordinates may run into problems. This is also true for coordinates greater than SM_CXSCREEN and SM_CYSCREEN.</P>
<P>Similarly, you may have problems if you use 0,0 or SM_CXSCREEN or SM_CYSCREEN for maintaining visibility. Some apps assume that if their coordinates are negative or greater than SM_CXSCREEN or SM_CYSCREEN that they've somehow wandered off the screen and will move their windows or dialogs back into what they believe to be the visible region. This results in the unusual situation of an application "snapping" its windows or dialogs onto the primary monitor. These are all reasons that the primary monitor will have 0,0 as the upper-left coordinate and SM_CXSCREEN, SM_CYSCREEN as the lower right for compatibility. This will ensure that almost all applications will function as expected if they are running on the primary monitor.</P>
<P>Another potential problem area with SM_CXSCREEN and SM_CYSCREEN lies with the application desktop toolbars (also called appbars). An appbar is a window that is similar to the Microsoft Windows taskbar. The appbar is anchored to an edge of the screen and contains buttons that give the user quick access to other applications and windows. The system prevents other applications from using the desktop area occupied by an appbar. Any number of appbars can exist on the desktop at any given time.</P>
<P>Currently, most appbars can only support a single monitor because they use SM_CXSCREEN and SM_CYSCREEN in their calculations to determine the rectangle they want to occupy. For multimonitor support, you want to allow an appbar to be placed on any edge of any monitor. This requires that you handle your coordinates carefully and that you use the appropriate system metrics to calculate the edges of monitors for use by your appbar. (For more information on appbars, see the Application Desktop Toolbars section of the Win32&reg; SDK available on MSDN, as well as at http://www.microsoft.com/msdn.)</P>
<P>It is important to note that you must also carefully crack coordinates to get the proper signed values. This was less of a problem in the past because there were no negative coordinates delivered; if you mixed up signed and unsigned coordinates, it didn't matter. Now that negative coordinates are valid, you may end up with invalid results if you do not properly extract the coordinates. I've included a sample macro that you can use to properly extract coordinates and maintain the correct sign. For example, this</P>
<P></P>

<PRE>(int)LOWORD(lParam) </PRE>
<P></P>
<P>should be:</P>
<P></P>

<PRE>(int)(short)LOWORD(lParam)</PRE>
<P></P>
<P>Better still, use the new macros provided in the SDK in Windowsx.h:</P>
<P></P>

<PRE>GET_X_LPARAM(lParam) 
GET_Y_LPARAM(lParam)</PRE>
<P></P>
<P>A screen saver will only display on the primary monitor unless you link with the new Scrnsave.lib. The current ScrnSave.lib gets the Window size like this:</P>
<P></P>

<PRE>X=0; 
Y=0;  
dX=GetSystemMetrics(SM_CXSCREEN); 
dY=GetSystemMetrics(SM_CYSCREEN);  </PRE>
<P></P>
<P>As you can see, this only blanks the primary monitor. It has been updated and now does this:</P>
<P></P>

<PRE>hdc = GetDC(NULL);
GetClipBox(hdc, &amp;rc);
ReleaseDC(NULL, hdc);
X = rc.left;
Y = rc.top;
dX = rc.right  - rc.left;
dY = rc.bottom - rc.top;</PRE>
<P></P>
<P>This gets the RECT of the virtual desktop. This method will work correctly on Windows 95, Memphis, Windows NT 3.1, and Windows NT 4.0, so applications linked with the new Scrnsave.lib will also work on those systems. </P>
<P>If you want your screen saver to cover all the monitors by applying it to the virtual desktop, relinking with the new lib is all that is required. However, if you want independent images on the monitors, you'll need to use the new APIs described above and handle each screen separately. Likewise, you can use the new APIs to optimize the display of your images on the various monitors via EnumDisplayMonitors.</P>
<P>Anyone developing with DirectX&trade; is probably wondering about the impact of multiple monitors on DirectX. Any existing DirectX application should continue to work correctly. However, if your application runs in full-screen mode, it may run only on the primary monitor. Windows-based applications should work on any monitor or device that is supported by DirectX. In fact, no new APIs have been added to DirectDraw&reg; as DirectDrawEnumerate is all that is required (see Figure 9). </P>
<P><img src="mon9.gif"></P>
<P>Figure 9  Information displayed with DXView</P>
<P>Some minor changes to ShellExecute and ShellExecuteEx ensure that any spawned applications come up on the same monitor as the parent application. If you specify an hWnd when calling ShellExecute or ShellExecuteEx, the new application window will appear on the same monitor as the window referred to by the hWnd. </P>
<P>The sample program (see Figure 10) simply calls the new APIs to get information on the system configuration and dumps out that information. The code was built with the multimon.h header file so it works on single-monitor systems as well as on Windows 95 and Windows NT 4.0. </P>
<P>Figure 10  TestMM Sample Program</P>
<P></P>
<P>TestMM.c</P>

<PRE>/*---------------------------------------------------------------------------*\
|   TestMM.c : A test sample that calls new Multi monitor APIs and             |
|              displays the results in a simple window.                        |
|                                                                              |
\*---------------------------------------------------------------------------*/

#include &lt;windows.h&gt;
#include &lt;windowsx.h&gt;
#include "multimon.h"
#include "mmhelp.h"
#include "testmm.rc"

//
// normally you just include "multimon.h" (like above)
// but one C file needs to define COMPILE_MULTIMON_STUBS
// so the compatibility stubs will be defined
//
#define COMPILE_MULTIMON_STUBS
#include "multimon.h"

/*---------------------------------------------------------------------------*\
\*---------------------------------------------------------------------------*/
static  char    szAppName[]="TestMM";

static  HINSTANCE hInstApp;
static  HWND      hwndApp;

/*---------------------------------------------------------------------------*\
\*---------------------------------------------------------------------------*/

LONG CALLBACK AppWndProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam);
int  ErrMsg (LPSTR sz,...);
void AppSetText(LPSTR sz,...);
void AppPrint(LPSTR sz,...);

void GetOptimalDIBFormat(HDC hdc, BITMAPINFOHEADER *pbi);

/*---------------------------------------------------------------------------*\
\*---------------------------------------------------------------------------*/

void TestEnumDisplayDevices()
{
    DWORD i;
    DISPLAY_DEVICE dd;
    DEVMODE dm;

    AppPrint("");
    AppPrint("EnumDisplayDevices:");

    ZeroMemory(&amp;dd, sizeof(dd));
    dd.cb = sizeof(dd);

    __try
    {
        for(i=0; EnumDisplayDevices(NULL, i, &amp;dd, 0); i++)
        {
            AppPrint("Device %d:", i);
            AppPrint("    DeviceName:   '%s'", dd.DeviceName);
            AppPrint("    DeviceString: '%s'", dd.DeviceString);
            AppPrint("    StateFlags:   %s%s%s%s",
    ((dd.StateFlags &amp; DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) ? "desktop " : ""),
    ((dd.StateFlags &amp; DISPLAY_DEVICE_PRIMARY_DEVICE     ) ? "primary " : ""),
    ((dd.StateFlags &amp; DISPLAY_DEVICE_VGA                ) ? "vga "     : ""),
    ((dd.StateFlags &amp; DISPLAY_DEVICE_MULTI_DRIVER       ) ? "multi "   : ""),
    ((dd.StateFlags &amp; DISPLAY_DEVICE_MIRRORING_DRIVER   ) ? "mirror "  : "") );

            ZeroMemory(&amp;dm, sizeof(dm));
            dm.dmSize = sizeof(dm);

            EnumDisplaySettings(dd.DeviceName, ENUM_CURRENT_SETTINGS, &amp;dm);
            AppPrint("    Current Settings %dx%dx%d", dm.dmPelsWidth, 
                     dm.dmPelsHeight,dm.dmBitsPerPel);

            EnumDisplaySettings(dd.DeviceName, ENUM_REGISTRY_SETTINGS, &amp;dm);
            AppPrint("    Registry Settings %dx%dx%d",dm.dmPelsWidth, 
                     dm.dmPelsHeight,dm.dmBitsPerPel);
        }
    }
    __except(1)
    {
        AppPrint("EnumDisplayDevices faulted!");
    }
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
BOOL CALLBACK CallbackNull(HMONITOR hMonitor,HDC hdc, LPRECT prc, LPARAM lParam)
{
    return TRUE;
}

BOOL CALLBACK CallbackWindow(HMONITOR hMonitor,HDC hdc, LPRECT prc, 
                             LPARAM lParam)
{
    return TRUE;
}

BOOL CALLBACK CallbackRect(HMONITOR hMonitor,HDC hdc, LPRECT prc, LPARAM lParam)
{
    return TRUE;
}

BOOL CALLBACK CallbackScreen(HMONITOR hMonitor,HDC hdc,LPRECT prc,LPARAM lParam)
{
    MONITORINFOEX mix;
    MONITORINFO mi;

    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &amp;mi);

    mix.cbSize = sizeof(mix);
    GetMonitorInfo(hMonitor, (MONITORINFO*)&amp;mix);

    AppPrint("Monitor %08X", hMonitor);
    AppPrint("      szDevice  = '%s'", (LPSTR)mix.szDevice);
    AppPrint("      rcMonitor = [%d,%d,%d,%d]", mi.rcMonitor);
    AppPrint("      rcWork    = [%d,%d,%d,%d]", mi.rcWork);
    AppPrint("      dwFlags   = %08X", mi.dwFlags);

    if (hdc)
    {
        struct {
            BITMAPINFOHEADER bi;
            DWORD            ct[256];
        }   dib;

        GetOptimalDIBFormat(hdc, &amp;dib.bi);

        AppPrint(" VREFRESH        = %d", GetDeviceCaps(hdc, VREFRESH       ));
        AppPrint(" DESKTOPVERTRES  = %d", GetDeviceCaps(hdc, DESKTOPVERTRES ));
        AppPrint(" DESKTOPHORZRES  = %d", GetDeviceCaps(hdc, DESKTOPHORZRES ));
        AppPrint(" BLTALIGNMENT    = %d", GetDeviceCaps(hdc, BLTALIGNMENT   ));

        AppPrint(" HORZRES         = %d", GetDeviceCaps(hdc, HORZRES   ));
        AppPrint(" VERTRES         = %d", GetDeviceCaps(hdc, VERTRES   ));
        AppPrint(" PALETTE         = %s", 
                 (GetDeviceCaps(hdc, RASTERCAPS) &amp; RC_PALETTE) ? "Yes" : "No");
        AppPrint(" BITSPIXEL       = %d", 
                 GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES));

        if (dib.bi.biCompression == BI_BITFIELDS)
        {
            if (dib.ct[0] == 0xF800 &amp;&amp;
                dib.ct[1] == 0x07E0 &amp;&amp;
                dib.ct[2] == 0x001F )
            {
                AppPrint("      FORMAT          = 565");
            }

            if (dib.ct[0] == 0x7C00 &amp;&amp;
                dib.ct[1] == 0x03E0 &amp;&amp;
                dib.ct[2] == 0x001F )
            {
                AppPrint("      FORMAT          = 555");
            }

            if (dib.ct[0] == 0xFF0000 &amp;&amp;
                dib.ct[1] == 0x00FF00 &amp;&amp;
                dib.ct[2] == 0x0000FF )
            {
                AppPrint("      FORMAT          = BGR");
            }

            if (dib.ct[0] == 0x0000FF &amp;&amp;
                dib.ct[1] == 0x00FF00 &amp;&amp;
                dib.ct[2] == 0xFF0000 )
            {
                AppPrint("      FORMAT          = RGB");
            }
        }
    }

    return TRUE;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
void TestEnumDisplayMonitors()
{
    HDC hdc;
    RECT rc;

    AppPrint("");
    AppPrint("EnumDisplayMonitors");

    EnumDisplayMonitors(NULL, NULL, CallbackNull, 42);

    hdc = GetDC(NULL);
    EnumDisplayMonitors(hdc, NULL, CallbackScreen, 42);
    ReleaseDC(NULL,hdc);

    hdc = GetDC(hwndApp);
    EnumDisplayMonitors(hdc, NULL, CallbackWindow, 42);
    ReleaseDC(hwndApp,hdc);

    GetWindowRect(hwndApp, &amp;rc);
    EnumDisplayMonitors(NULL, &amp;rc, CallbackRect, 42);
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

void DoTestMM(HWND hwnd, LPARAM lParam)
{
    HDC hdc;
    RECT rc;
    static HMONITOR hMonitorMe;
    HMONITOR hMonitor;
    hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONULL);

    if (hMonitorMe == hMonitor &amp;&amp; lParam)
        return;

    hMonitorMe = hMonitor;

    AppPrint(NULL);

    if (hMonitor)
    {
        MONITORINFOEX mi;
        mi.cbSize = sizeof(mi);
        GetMonitorInfo(hMonitor, (MONITORINFO*)&amp;mi);

        AppSetText(mi.szDevice);
        AppPrint("My Window is on hMonitor %08X",hMonitor);
    }
    else
    {
        AppSetText(NULL);
        AppPrint("My Window is not visible");
    }

    AppPrint("");
    AppPrint("SM_CMONITORS         is %d", GetSystemMetrics(SM_CMONITORS));
    AppPrint("SM_SAMEDISPLAYFORMAT is %d",
             GetSystemMetrics(SM_SAMEDISPLAYFORMAT));
    AppPrint("SM_XVIRTUALSCREEN    is %d", GetSystemMetrics(SM_XVIRTUALSCREEN));
    AppPrint("SM_YVIRTUALSCREEN    is %d", GetSystemMetrics(SM_YVIRTUALSCREEN));
    AppPrint("SM_CXVIRTUALSCREEN   is %d", GetSystemMetrics(SM_CXVIRTUALSCREEN));
    AppPrint("SM_CYVIRTUALSCREEN   is %d", GetSystemMetrics(SM_CYVIRTUALSCREEN));

    hdc = GetDC(NULL);
    GetClipBox(hdc, &amp;rc);
    AppPrint("GetClipBox of GetDC(NULL)    = [%d,%d,%d,%d]", rc);
    ReleaseDC(NULL, hdc);

    hdc = GetDC(GetDesktopWindow());
    GetClipBox(hdc, &amp;rc);
    AppPrint("GetClipBox of GetDC(desktop) = [%d,%d,%d,%d]", rc);
    ReleaseDC(GetDesktopWindow(), hdc);

    GetWindowRect(GetDesktopWindow(), &amp;rc);
    AppPrint("GetWindowRect of desktop     = [%d,%d,%d,%d]", rc);

    TestEnumDisplayMonitors();
    TestEnumDisplayDevices();
}

/*----------------------------------------------------------------------------*\
|   AppInit( hInst, hPrev)                                                     |
\*----------------------------------------------------------------------------*/
BOOL AppInit(HINSTANCE hInst,HINSTANCE hPrev,int sw,LPSTR szCmdLine)
{
    WNDCLASS cls;
    int      dx,dy;

    /* Save instance handle for DialogBoxs */
    hInstApp = hInst;

    if (!hPrev)
    {
        /*
         *  Register a class for the main application window
         */
        cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon          = LoadIcon(hInst,"AppIcon");
        cls.lpszMenuName   = "AppMenu";
        cls.lpszClassName  = szAppName;
        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance      = hInst;
        cls.style   = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
        cls.lpfnWndProc    = (WNDPROC)AppWndProc;
        cls.cbWndExtra     = 0;
        cls.cbClsExtra     = 0;

        if (!RegisterClass(&amp;cls))
            return FALSE;
    }

    dx = GetSystemMetrics (SM_CXSCREEN) / 2;
    dy = GetSystemMetrics (SM_CYSCREEN) / 2;

    hwndApp = CreateWindow (szAppName,              // Class name
                            szAppName,              // Caption
                            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                            CW_USEDEFAULT, 0,
                            dx,dy,                  // Size
                            (HWND)NULL,             // Parent window (no parent)
                            (HMENU)NULL,            // use class menu
                            hInst,                  // handle to window instance
                            (LPSTR)NULL             // no params to pass on
                           );
     
    ShowWindow(hwndApp,sw);

    return TRUE;
}

/*----------------------------------------------------------------------------*\
|   AppWndProc( hwnd, uiMessage, wParam, lParam )                              |
|                                                                              |
|   Description:                                                               |
|       The window proc for the app's main (tiled) window.  This processes all |
|       of the parent window's messages.                                       |
|                                                                              |
\*----------------------------------------------------------------------------*/
LONG FAR PASCAL AppWndProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
    HWND hwndC;

    switch (msg)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case ID_TEST_CENTERTOMONITOR:   
            CenterWindowToMonitor(hwnd, hwnd, FALSE); 
            break;
                case ID_TEST_CENTERTOWORKAREA:  
            CenterWindowToMonitor(hwnd, hwnd, TRUE); 
            break;
                case ID_TEST_CLIPTOMONITOR:     
            ClipWindowToMonitor(hwnd, hwnd, FALSE); 
            break;
                case ID_TEST_CLIPTOWORKAREA:    
            ClipWindowToMonitor(hwnd, hwnd, TRUE); 
            break;
                case ID_TEST_RUNNOTEPAD:
            ShellExecute(hwnd,"open","notepad.exe",NULL,NULL,SW_SHOWNORMAL );
            break;
            }
            break;

        case WM_KEYUP:
            if (wParam == VK_F5)
                DoTestMM(hwnd, 0);
            break;

        case WM_WINDOWPOSCHANGED:
            DoTestMM(hwnd, 1);
            break;

        case WM_SETTINGCHANGE:
        case WM_DISPLAYCHANGE:
            DoTestMM(hwnd, 0);
            break;

    case WM_SIZE:
        if (hwndC = GetWindow(hwnd, GW_CHILD))
                MoveWindow(hwndC, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
        break;

    case WM_DESTROY:
            PostQuitMessage(0);
        break;
    }
    return DefWindowProc(hwnd,msg,wParam,lParam);
}

/*----------------------------------------------------------------------------*\
|   ErrMsg - Opens a Message box with a error message in it.  The user can     |
|            select the OK button to continue                                  |
\*----------------------------------------------------------------------------*/
int ErrMsg (LPSTR sz,...)
{
    char ach[128];

    wvsprintf (ach,sz,(LPSTR)(&amp;sz+1));   /* Format the string */
    MessageBox(hwndApp,ach,szAppName,MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL);
    return FALSE;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
void AppSetText(LPSTR sz,...)
{
    char ach[128];

    lstrcpy(ach, szAppName);

    if (sz != NULL &amp;&amp; *sz != 0)
    {
        lstrcat(ach, " - ");
        wvsprintf (ach+lstrlen(ach),sz,(LPSTR)(&amp;sz+1));   /* Format the string */
    }
    SetWindowText(hwndApp, ach);
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
void AppPrint(LPSTR sz,...)
{
    HWND hwndE = GetWindow(hwndApp, GW_CHILD);
    char ach[128];

    if (hwndE == NULL) 
    {
        RECT rc;
        GetClientRect(hwndApp, &amp;rc);
        hwndE = CreateWindow ("Edit", "", WS_VISIBLE | WS_CHILD | ES_MULTILINE | 
                              ES_READONLY | WS_VSCROLL | ES_AUTOVSCROLL,
                              0, 0, rc.right, rc.bottom, hwndApp, (HMENU)-1,
                              hInstApp, NULL);

        SetWindowFont(hwndE, GetStockObject(ANSI_FIXED_FONT), TRUE);
    }

    if (sz == NULL)
    {
        Edit_SetSel(hwndE, 0, (UINT)-1);
        Edit_ReplaceSel(hwndE, "");
    }
    else
    {
        wvsprintf (ach,sz,(LPSTR)(&amp;sz+1));   /* Format the string */
        lstrcat(ach, "\r\n");

        Edit_SetSel(hwndE, (UINT)-1, (UINT)-1);
        Edit_ReplaceSel(hwndE, ach);
    }
}

/*----------------------------------------------------------------------------*\
|   WinMain( hInst, hPrev, lpszCmdLine, cmdShow )                              |
\*----------------------------------------------------------------------------*/
int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw)
{
    MSG     msg;
    DWORD   dw=0;

    /* Call initialization procedure */
    if (!AppInit(hInst,hPrev,sw,szCmdLine))
        return FALSE;

    /*
     * Polling messages from event queue
     */
    for (;;)
    {
        if (PeekMessage(&amp;msg, NULL, 0, 0,PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
                break;

            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
        }
        else
    {
            WaitMessage();
        }
    }

    return msg.wParam;
}

//
//  GetOptimalDIBFormat
//
//   get the optimal DIB format for a display device.
//   the optimal DIB format is the format that exactly
//   matches the format of the device, this is very important
//   when dealing with 16bpp modes, you need to know
//   what bitfields to use (555 or 565 for example)
//
//   you normaly use this function to get the best
//   format to pass to CreateDIBSection()
//
//  Input
//   hdc device to get the optimal format for.
//   pbi pointer to a bitmapinfo + color table
//       (room for 256 colors are assumed)
//
//  Output
//   pbi contains optimal DIB format, in the &lt;= 8bpp case
//       the color table will contain the system palette
//       in the &gt;=16bpp case the "color table" will contain
//       the correct bit fields (see BI_BITFIELDS for more info)
//
//  Notes
//   if you are going to use this function on a 8bpp device
//   you should make sure the colortable contains a indentity
//   palette for optimal blt'ing
//
void GetOptimalDIBFormat(HDC hdc, BITMAPINFOHEADER *pbi)
{
    HBITMAP hbm;
    hbm = CreateCompatibleBitmap(hdc, 1, 1);
    ZeroMemory(pbi, sizeof(BITMAPINFOHEADER));
    pbi-&gt;biSize = sizeof(BITMAPINFOHEADER);
    pbi-&gt;biBitCount = 0;
    // first call will fill in the optimal biBitCount
    GetDIBits(hdc, hbm, 0, 1, NULL, (BITMAPINFO*)pbi, DIB_RGB_COLORS);
    // second call will get the optimal color table, or the optimal bitfields
    GetDIBits(hdc, hbm, 0, 1, NULL, (BITMAPINFO*)pbi, DIB_RGB_COLORS);
    DeleteObject(hbm);
}</PRE>
<P></P>
<P>TestMM.RC</P>

<PRE>#include &lt;windows.h&gt;

#define ID_TEST_CENTERTOMONITOR     100
#define ID_TEST_CENTERTOWORKAREA    101
#define ID_TEST_CLIPTOMONITOR       102
#define ID_TEST_CLIPTOWORKAREA      103
#define ID_TEST_RUNNOTEPAD          104


#ifdef RC_INVOKED

AppMenu MENU DISCARDABLE
BEGIN
    POPUP "Test"
    BEGIN
        MENUITEM "Center to monitor",           ID_TEST_CENTERTOMONITOR
        MENUITEM "Center to work area",         ID_TEST_CENTERTOWORKAREA
        MENUITEM "Clip to monitor",             ID_TEST_CLIPTOMONITOR
        MENUITEM "Clip to work area.",          ID_TEST_CLIPTOWORKAREA
        MENUITEM "Run NOTEPAD.EXE",             ID_TEST_RUNNOTEPAD
    END
END

#endif</PRE>
<P></P>
<P>MMHelp.C</P>

<PRE>/*----------------------------------------------------------------------------*\
|   MMHELP.C - routines to help a app be multimonitor aware
\*----------------------------------------------------------------------------*/

#include &lt;windows.h&gt;
#include &lt;windowsx.h&gt;
#include "multimon.h"

//
//  GetMonitorRect
//
//  gets the "screen" or work area of the monitor that the passed
//  window is on.  this is used for apps that want to clip or
//  center windows.
//
//  the most common problem apps have with multimonitor systems is
//  when they use GetSystemMetrics(SM_C?SCREEN) to center or clip a
//  window to keep it on screen.  If you do this on a multimonitor
//  system the window we be restricted to the primary monitor.
//
//  this is a example of how you used the new Win32 multimonitor APIs
//  to do the same thing.
//
void GetMonitorRect(HWND hwnd, LPRECT prc, BOOL fWork)
{
    MONITORINFO mi;

    mi.cbSize = sizeof(mi);
    GetMonitorInfo(MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST), &amp;mi);

    if (fWork)
        *prc = mi.rcWork;
    else
        *prc = mi.rcMonitor;
}

//
// ClipRectToMonitor
//
// uses GetMonitorRect to clip a rect to the monitor that
// the passed window is on.
//
void ClipRectToMonitor(HWND hwnd, RECT *prc, BOOL fWork)
{
    RECT rc;
    int  w = prc-&gt;right  - prc-&gt;left;
    int  h = prc-&gt;bottom - prc-&gt;top;

    if (hwnd != NULL)
    {
        GetMonitorRect(hwnd, &amp;rc, fWork);
    }
    else
    {
        MONITORINFO mi;

        mi.cbSize = sizeof(mi);
        GetMonitorInfo(MonitorFromRect(prc, MONITOR_DEFAULTTONEAREST), &amp;mi);

        if (fWork)
            rc = mi.rcWork;
        else
            rc = mi.rcMonitor;
    }

    prc-&gt;left   = max(rc.left, min(rc.right-w,  prc-&gt;left));
    prc-&gt;top    = max(rc.top,  min(rc.bottom-h, prc-&gt;top));
    prc-&gt;right  = prc-&gt;left + w;
    prc-&gt;bottom = prc-&gt;top  + h;
}

//
// CenterRectToMonitor
//
// uses GetMonitorRect to center a rect to the monitor that
// the passed window is on.
//
void CenterRectToMonitor(HWND hwnd, RECT *prc, BOOL fWork)
{
    RECT rc;
    int  w = prc-&gt;right  - prc-&gt;left;
    int  h = prc-&gt;bottom - prc-&gt;top;

    GetMonitorRect(hwnd, &amp;rc, fWork);

    prc-&gt;left    = rc.left + (rc.right  - rc.left - w) / 2;
    prc-&gt;top    = rc.top  + (rc.bottom - rc.top  - h) / 2;
    prc-&gt;right    = prc-&gt;left + w;
    prc-&gt;bottom = prc-&gt;top  + h;
}

//
// CenterWindowToMonitor
//
void CenterWindowToMonitor(HWND hwndP, HWND hwnd, BOOL fWork)
{
    RECT rc;
    GetWindowRect(hwnd, &amp;rc);
    CenterRectToMonitor(hwndP, &amp;rc, fWork);
    SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, 
                 SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

//
// ClipWindowToMonitor
//
void ClipWindowToMonitor(HWND hwndP, HWND hwnd, BOOL fWork)
{
    RECT rc;
    GetWindowRect(hwnd, &amp;rc);
    ClipRectToMonitor(hwndP, &amp;rc, fWork);
    SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, 
                 SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

//
// IsWindowOnScreen
//
BOOL IsWindowOnScreen(HWND hwnd)
{
    HDC hdc;
    RECT rc;
    BOOL f;

    GetWindowRect(hwnd, &amp;rc);
    hdc = GetDC(NULL);
    f = RectVisible(hdc, &amp;rc);
    ReleaseDC(NULL, hdc);
    return f;
}

//
// MakeSureWindowIsVisible
//
void MakeSureWindowIsVisible(HWND hwnd)
{
    if (!IsWindowOnScreen(hwnd))
    {
    ClipWindowToMonitor(hwnd, hwnd, TRUE);
    }
}
</PRE>
<P></P>
<P>Let's walk through some of the sample code, starting with multimon.h and then Figure 5. I'm going to skip over most of the constants and structure definitions of multimon.h since they're pretty self-explanatory. I'll start with the section labeled (via comments) "Implement the API stubs." Notice that just before this comment is an #ifdef COMPILE_MULTIMON_STUBS. This file actually contains code and, therefore, must be included in only one module or it will generate "multiply defined" errors at link time. You should define this constant in one source file before including this include file;  you should not define it in any other source files that require you to include this file. </P>
<P>If COMPILE_MULTIMON_STUBS is defined, then the code that follows in the header will be included. This declares a number of global function pointers that will be used by the stub code to locate the corresponding APIs built into the operating system, if present. </P>
<P>Looking at the first function, InitMultiplMonitorStubs, will clarify things somewhat. It should be called once before any of the APIs defined in the header can proceed, although you don't have to worry about it since the included API stub code calls it as necessary. This function determines if the underlying operating system has built-in support for multiple monitors. If it does, then it gets the correct addresses for the APIs (in the system file USER32) that correspond to those in this header file and initializes the global function pointers appropriately. If the underlying operating system doesn't support multiple monitors, then these pointers are set to NULL. In either case, the function sets a static flag that indicates whether this API was correctly initialized, and returns TRUE on a system that has built-in multimonitor support or FALSE on a system that does not. (You can see this in the very first if construct: if this function was already called, the function quickly exits using one of the function pointers to determine if there is built-in support on the platform.)</P>
<P>At this point, the file moves into stub function implementations. Since many of the stubs are implemented in the same manner, I'll cover only a few in detail. The first real API stub is the GetSystemMetrics function. Notice that the name of the stub is actually xGetSystemMetrics. This allows you to enhance or replace the underlying operating system API without getting compile errors by later redefining GetSystemMetrics as xGetSystemMetrics (see the #defines at the end of the include file).</P>
<P>First, the xGetSystemMetrics implementation makes sure InitMultipleMonitorStubs code was called to initialize things and to determine if you're on a multimonitor-aware operating system. If you are, control is passed directly to the operating system's implementation of GetSystemMetrics. If your system isn't multimonitor-aware, then review the flags, handle those that would not have been recognized on a system without multiple monitors, and return appropriate values (knowing that on such a system there will be only one monitor and that it'll have the standard coordinates). Finally, if the flag is not one of the new ones, you pass control to the operating system for handling as usual. This is a general theme throughout the stubs. </P>
<P>TestMM.C is a basic Windows application with many familiar features, including WinMain with a message loop and some support routines to allow easy printing into the main client area. It also has some standard menu items for executing API calls that illustrate the effect of using those APIs on the application window. </P>
<P>The interesting portion of the application is actually the DoTestMM function, which is called whenever the application window is moved or the user presses F5 (the standard refresh key). It is called every time the application is moved so that it can reprint information specific to the monitor the application is actually displayed on. Notice that the DoTestMM function includes a check that quickly exits if it's on the same monitor as it was the last time it was called (since none of the information would have changed in that case). From that point on, the code just calls the various multimonitor APIs and prints the resulting information into an edit box created and sized to fill the client area of the application window. Although not a very exciting application, it does show how to call the various APIs, their relevant structures and flags, and how to use them, as well as what to expect in response to those APIs.</P>
<P>Finally, the listings include an MMHelp file that contains routines that handle common tasks on a multimonitor system. Although the routines are fairly simple, I'll quickly review some of them here. </P>
<P>GetMonitorRect is used to determine the screen or work area, depending on the flag passed in the third parameter, for a window. This basically passes in the area of the screen that is closest to the window handle. You use this to clip a window onto a visible portion of the screen. The ClipRectToMonitor function uses GetMonitorRect to determine the best monitor to clip a rectangle to, and then returns the updated rectangle that represents the best place to put it. This might be useful if you want to display a dialog and make sure that it's visible. You can pass this function the coordinates that you'd like to use and it will find the closest location where that entire dialog can be visible. In fact, the new function ClipWindowToMonitor does just that. Given a window handle, it gets the bounding rectangle of the window, uses ClipRectToMonitor to find an appropriate location, and then moves the window to that location. </P>
<P>Similarly, CenterRectToMonitor determines the correct monitor on which to center a rectangle and then updates the rectangle so that it is centered on that monitor. CenterWindowToMonitor uses CenterRectToMonitor to determine the appropriate center location and then moves the window to that location. IsWindowOnScreen determines if your window is actually visible anywhere on any screen, and MakeSureWindowIsVisible makes sure your window becomes visible on a screen.</P>
<P></P>
<H2><A NAME="sec5"></A>Installing Multiple Monitors</H2><P>Multiple monitor support is available only on the Memphis and Windows NT 5.0 operating systems that have updated video drivers (that is, updated to support multiple monitors). Any video card that is supported by Windows can be used as your primary display, but the extra cards must have updated drivers to support the new features. Currently, Microsoft has updated drivers for a number of video cards designed for use on a PCI bus that will be shipped with the operating system. (For more details on hardware, see the section on supported hardware in your documentation.) At the time I wrote this article, drivers for the following cards were available:</P>
<SPAN><UL><LI>ATI Mach64, Rage I, II &amp; III</LI><LI>S3 764(Trio), 764V+(765)</LI><LI>Cirrus 5436,7548,5446</LI><LI>Imagine 128 I and II</LI><LI>S3 M65</LI><LI>Matrox Millenium</LI><LI>Matrox Mystique</LI><LI>Cirrus Laguna</LI><LI>ET6000</LI><LI>Rendition</LI><LI>3DFx</LI><LI>STB</LI></UL></SPAN><P>Setup is pretty much plug and play. First, you must get your system working with one monitor. Then, shut down the system and install another video card and monitor. When you restart your machine, Windows should automatically detect the new card (and possibly the monitor). Once the proper drivers get copied to your machine, you can go to the control panel to configure the physical mapping of your virtual desktop to your monitors, as well as the resolution, color depth, and refresh rates for each. </P>
<P>Note that the order of the cards on the bus may impact the configuration. In particular, the VGA monitor where startup MS-DOS text is initially displayed is chosen by the system before Windows even starts. As a result, you may need to rearrange the cards in order to get the configuration the way you want it.</P>
<P></P>
<H2><A NAME="sec6"></A>User Interface Changes</H2><P>One of the nice things that you will notice about adding multiple monitors is that not much has changed in order to provide this support. In fact, if you have only one monitor there will be no noticeable difference on your machine because most of the changes were actually made beneath the surface of the operating system. However, you will notice a few things if you install multiple video cards and monitors.</P>
<P>There was a small change to the Display Properties control panel. The Settings tab was replaced with a Monitors tab, under which the settings for each monitor can be adjusted (see Figure 11). Any changes are then made on a per-monitor basis. If you only have one monitor, you'll still see the Settings tab as illustrated in Figure 12 since there is no need to choose the monitor you want to configure.</P>
<P><img src="mon11.gif"></P>
<P>Figure 11  Monitors tab for multimonitors</P>
<P><img src="mon12.gif"></P>
<P>Figure 12  Settings tab for a single monitor</P>
<P>Some minor changes were made to make the shell multimonitor-aware. This included having the shell's desktop appear on all monitors and adding support for placing the taskbar on any edge of any monitor. (If you combine this with the auto-hide feature, you'll have a lot more places to lose it!) These changes allow you to drag items, such as shortcuts, from the desktop of one monitor to the desktop of another. The system will also try to start an application on the monitor that contained the shortcut. For example, if you want to start an app on a specific monitor, one way would be to place a shortcut on the part of the desktop that is on that monitor.</P>
<P></P>
<H2><A NAME="sec7"></A>Differences&nbsp;Between&nbsp;Memphis and Windows NT 5.0</H2><P>There are some minor differences in the implementation of multimonitor support between Memphis and Windows NT 5.0. However, it's not clear at this time which, if any, of these differences will remain in the final release. Therefore, rather than getting into details of current differences, I'll give you my standard "test on both" speech. </P>
<P>As with most Win32 applications, the user can generally use the application on either Windows 95 or Windows NT since both are Win32 platforms. As a developer, you must make sure your application works as expected on each targeted platform. Test with one monitor and with two, test at high resolutions and in VGA mode, test on fast machines and on slow ones—are you getting the picture? Often there is no difference, but in some cases there may be and it's a lot easier to address the differences before you release an application than it is afterward. All too often developers fail to notice serious flaws because the application works great on the super whiz-bang machine it was developed on, only to fail miserably on the target low-end machine.</P>
<P></P>
<H2><A NAME="sec8"></A>The Cliff Notes</H2><P>Writing multimonitor applications is easy, and making your current application multimonitor-aware is even easier. Let's just summarize what you need to know.</P>
<SPAN><UL><LI>When centering windows and dialogs, make sure you center them to your application window. If you want to center on a monitor, make sure you use the correct system metrics. (Use the MMHelp routines to make it simpler.)</LI><LI>If you are developing screen savers, make sure you are using the latest version of Scrnsave.lib. It runs properly on existing systems as well as multimonitor machines. Make sure you are correctly extracting coordinates to ensure you get the correct sign. Negative coordinates are now valid.</LI><LI>If you are saving window positions to restore later, make sure you check that the positions are still valid before using them. Since the user can move the coordinates of secondary monitors on the fly in the control panel, or even remove a monitor altogether, the position you saved may no longer be valid. (You can use the routines in MMHelp to address this problem.)</LI><LI>Remember that negative coordinates or coordinates larger than SM_CXSCREEN,&nbsp;SM_CYSCREEN may be visible. If you are using off-screen coordinates as a method of hiding windows, use the appropriate system metrics or you may be in for a surprise.</LI><LI>Likewise, don't use 0,0 and SM_CXSCREEN, SM_CYSCREEN to clip windows, menus, and so on onto the screen. This results in inappropriate behavior when your application is not on the primary monitor. (I know of several Microsoft applications that must now be corrected, including Visual C++ 5.0.) Here again, the routines in MMHelp will come in handy.</LI><LI>If you use ShellExecute or ShellExecuteEx in your application, supply an hWnd so that the system can open any new windows on the same monitor as the calling application. This is what the user will expect.</LI><LI>Use multimonitor support to run your development and debugging environment on one monitor and your application on another. This is particularly true for full-screen DirectDraw applications.</LI><LI>For developers, the golden rule is Test! Test! Test! Make sure you test your application thoroughly on all target platforms, with and without multiple monitors. Make sure you test your app on both the primary and secondary monitors. If it's going to mess up, it'll probably be on a secondary monitor.</LI><LI>Finally, don't panic over existing applications. The primary display is always set up to be as compatible as possible with existing applications. If you have released applications that may be multimonitor challenged, they should still work on the primary monitor.</LI></UL></SPAN><H2><A NAME="sec9"></A>Conclusion</H2><P>Having multiple monitors on the same machine and as part of the same desktop is very cool, but it also opens up a whole new set of possibilities for applications—from games that use multiple monitors to give you a more panoramic view to CAD and presentation applications that have built-in support for custom display devices. Since the support is built into the operating system, compatibility with existing applications is excellent and the impact on existing applications is minimal. </P>
<P>If you have a PCI machine and a couple of old monitors lying around, get a few more video cards and I guarantee you'll never go back to just one monitor!   </P>
<H2><A NAME="sec10"></A>Terminology</H2><P>The following terminology for multimonitor support is currently used in the Windows documentation.</P>
<P><B>VGA monitor</B> This is the main monitor that you see text on when the computer initially boots. It's also the monitor that DOS apps will run on when running exclusively (in DOS mode) or when they are running full-screen.</P>
<P><B>Primary monitor</B> Another name might be the compatibility monitor since this is the monitor that is guaranteed to contain traditional screen coordinates. Almost all multimonitor-challenged apps will run correctly on this monitor. The primary monitor may or may not be the VGA monitor. The VGA monitor is determined by the system because of its location on the bus. On the other hand, Windows determines the primary monitor.</P>
<P><B>Secondary monitors</B> These are all of the monitors that are not the primary monitor but are included in the Windows desktop area. </P>
<P><B>Independent displays</B> These monitors are present on the system, but are not part of the Windows desktop. These monitors can still be used by applications, but they do not contain any part of the Windows desktop. The calculation of the virtual desktop does not include this area and, as a result, you cannot drag application windows to or from this monitor to other monitors on the system—even if an application is running that makes use of this monitor.</P>
<P><B>Mirrored monitors</B> These are monitors that are present on the system that receive a duplicate of all activity on the primary monitor. This allows a user to present the same information on multiple displays. A user can configure devices to be mirrors using the control panel. (There aren't really any development aspects to this type of monitor, but it's worth knowing about.)</P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright &copy; 1997 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S. and Canada, or (303) 678-0439 in all other countries. For other inquiries, call (415) 905-2200.</P>
<P></P></font></body></HTML>
