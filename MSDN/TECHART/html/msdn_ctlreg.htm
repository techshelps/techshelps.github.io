<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE Controls: Registration</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_ctlreg"></a></sup>OLE Controls: Registration</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: October 6, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3044">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the CTLREG sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article explains how an application or setup program can register and unregister OLE Controls using OLE's self-registration facility. Registering and unregistering an OLE Control requires examining the control's version information and its registry entry. </p>
<h2>Introduction</h2>
<p>
Before you can use an OLE Control, you must register it with the system. Registering an OLE Control places information about the control in the system registry. Once the control has been registered, applications and development environments can search the registry to determine which controls have been installed. Unlike a Visual Basic® custom control (VBX), an OLE Control does not need to be registered by each application that uses it. Once the control has been registered with the system, any application can find it.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In this article, I use the term "registry" to refer to two implementations of the configuration utility: the registration database in Microsoft® Windows® 3.1 and the Registry in Windows NT™.</p>
<p>
The OLE Control Developer's Kit (CDK) includes a tool called REGSVR.EXE (or REGSVR32.EXE for 32-bit systems) that can register and unregister controls. When you install the CDK, it adds two commands—Register Control and Unregister Control—to the Visual Workbench Tools menu (in Visual C++™ version 1.51 or 2.0). These commands call REGSVR.EXE to register or unregister the control built by the current project. If the current project does not build a control, the attempt to register or unregister it fails.</p>
<p>
Many control containers or installation programs will prefer to handle control registration themselves instead of spawning REGSVR.EXE to do the job. These applications can adopt the method that REGSVR.EXE uses to register controls, and provide additional functionality.</p>
<p>
The OLE Controls specification (OLE Control Developer's Kit, <i>User's Guide and Reference</i>, Part Four: Appendixes, Appendix D: "OLE Controls Architecture") dictates that OLE Controls must be self-registering, that is, an OLE Control must be able to register and unregister itself. REGSVR.EXE takes advantage of this requirement and gets the control to do the registration work.</p>
<p>
Luckily, ControlWizard, a tool included with the CDK, creates controls that support self-registration. In this article, we will discuss how to programmatically register and unregister controls that support self-registration.</p>
<p>
Self-registration simplifies the process of registering a control, because the control does the actual work of adding the necessary information to, or removing it from, the registry. The container need only call the appropriate function exported from the .OCX file to get the control to register itself.</p>
<p>
However, our container will still need to do some work. Before we can tell the control to register or unregister itself, we have to make sure that it supports self-registration. In addition, a container may want to display all registered controls and let the user select the control to unregister. To provide this functionality, we need to search the registry for all registered controls. Some containers may also want to display the toolbox bitmap associated with a control. The CTLREG sample application provides this functionality. It displays the names of registered controls and their bitmaps in an owner-drawn list box. (The Test Container included in the CDK lists registered control names but does not display their bitmaps.)</p>
<p>
We will discuss these issues in detail in this technical article. This article expands on the information about installation and registration in the OLE Control Developer's Kit <i>User's Guide and Reference</i>, Part Four: Appendixes, Appendix D: "OLE Controls Architecture".</p>
<h2>CTLREG Sample Application</h2>
<p>
The CTLREG sample application included with this article registers and unregisters OLE Controls. To register a control, choose the Register command from the Controls menu. This command brings up a dialog box that shows all of the files in the current directory that have the .OCX extension. You can also choose to view files with a .DLL extension.</p>
<p>
To unregister a control, choose the Unregister command from the Controls menu. This command displays an owner-drawn list box with a list of the currently installed controls and their toolbox bitmaps. (Figure 1 shows the controls installed on my system.) It is possible to delete an OLE Control's .OCX file without removing its corresponding registry information. The "Exist" keyword in the dialog box identifies controls whose .OCX files exist. Controls that can be inserted in a standard OLE container are marked with the word "Insert." As you can see in Figure 1, I modified the Spindial control so that it could be inserted in an OLE container. The 16-bit version of CTLREG displays 16-bit controls only, and the 32-bit version of CTLREG displays 32-bit controls only.</p>
<p>
<img src="ctlreg_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The Unregister dialog box in CTLREG32.EXE</b></p>
<p>
Clicking the Cleanup button removes registry entries for controls whose .OCX files have been deleted. More on this in the section on "Cleaning Up the Registry" at the end of this article.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The code fragments in this article reflect the state of the CTLREG sample code when the article was written. These code fragments may differ slightly from the code in the CTLREG sample files provided with this article. </p>
<h2>Self-Registration and Version Information</h2>
<p>
All OLE servers have to be registered before they will work. OLE servers such as Microsoft Excel and Word register themselves when they run stand-alone. The same is true of servers built with AppWizard. Self-registration makes sense for a server such as Microsoft Word that is also a stand-alone application. However, almost all OLE Controls are implemented as DLLs, and you can't "run" a DLL. So, a different method of self-registration had to be devised. ControlWizard builds controls that support self-registration by default.</p>
<h3>What Is Self-Registration?</h3>
<p>
An OLE Control that supports self-registration exports the following two functions:</p>
<pre><code>STDAPI DllRegisterServer(void) ;
STDAPI DllUnregisterServer(void) ;
</code></pre>
<p>
<b>DllRegisterServer</b> adds or updates registry information for all the classes implemented by the DLL. <b>DllUnregisterServer</b> removes information from the registry. Once you know the name of the file, calling these functions is pretty trivial.</p>
<p>
Here is the C++ code for registering a control (without error correction):</p>
<pre><code>#include &lt;stdole.h&gt; 
.
.
.

typedef HRESULT (STDAPICALLTYPE *CTLREGPROC)() ; // Requires stdole.h

.
.
.

// Path to OLE Control in m_strPathName
HMODULE hModule = ::LoadLibrary(m_strPathName) ;
CTLREGPROC DLLRegisterServer =
 &nbsp;&nbsp;&nbsp;&nbsp; (CTLREGPROC)::GetProcAddress(hModule,"DllRegisterServer" ) ;
DLLRegisterServer() ;
::FreeLibrary(hModule) ;
</code></pre>
<p>
The code that I used in CTLREG to register a control is shown below. In CTLREG, the <b>CCtlReg </b>class, which is in the CCLTREG.CPP file (notice the initial "C" in the filename), performs registration and unregistration tasks. When an instance of <b>CCtlReg</b> is created, it is given the path to the OLE control's .OCX file in the constructor.</p>
<pre><code>BOOL CCtlReg::Register()
{
 &nbsp; BOOL bResult = FALSE ;
 &nbsp; if (SupportsSelfRegister())
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Path to OLE Control in m_strPathName
 &nbsp;&nbsp;&nbsp;&nbsp; HMODULE hModule = ::LoadLibrary(m_strPathName) ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (LOADLIBRARY_FAILED(hModule)) return FALSE ;

 &nbsp;&nbsp;&nbsp;&nbsp; CTLREGPROC DLLRegisterServer =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (CTLREGPROC)::GetProcAddress(hModule,"DllRegisterServer" ) ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (DLLRegisterServer != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT regResult = DLLRegisterServer() ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bResult = (regResult == NOERROR) ; 
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; ::FreeLibrary(hModule) ;
 &nbsp; }
 &nbsp; return bResult ;
}
</code></pre>
<p>
<b>LOADLIBRARY_FAILED</b> is a macro defined as follows:</p>
<pre><code>#ifdef _WIN32
#define LOADLIBRARY_FAILED(x) (x == 0)
#else
#define LOADLIBRARY_FAILED(x) (x &lt;= HINSTANCE_ERROR)
#endif
</code></pre>
<h3>Don't I Have to Initialize OLE?</h3>
<p>
Yes, you do. The <b>DLLRegisterServer</b> and <b>DLLUnregisterServer </b>calls require OLE, which must be initialized. If your application is already a container or server, it initializes OLE. However, if your application (like most installation programs) does not use OLE, it will need to initialize OLE. </p>
<p>
If you build an application with AppWizard and do not choose any OLE options, you will need to do the following before you can register and unregister controls:
<ol>
<li>
Include AFXOLE.H in STDAFX.H.<br><br></li>
<li>
Link to OLE2.LIB.<br><br></li>
<li>
Add the following lines to CTLREG.CPP:<pre><code>BOOL CCtlregApp::InitInstance()
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; // Initialize OLE libraries
 &nbsp; if (FAILED(OleInitialize(NULL)))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox("OLE initialization failed. 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Make sure that the OLE libraries are the
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; correct version.") ;
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE ;
 &nbsp; }
 &nbsp; // Standard initialization
 &nbsp; ...
}
</code></pre>
</li>
</ol>
<h3>Does a Control Support Self-Registration?</h3>
<p>
Before calling <b>DllRegisterServer</b> or <b>DllUnregisterServer</b>, we verify that the control supports self-registration. <b>CCtlReg::Register</b> verifies this by calling the <b>CCtlReg::SupportsSelfRegister</b> function, which I wrote for this purpose.</p>
<p>
Ideally, we should be able to determine whether a control supports self-registration without actually loading the control. Loading the control will execute <b>LibMain</b>, which may result in undesirable side-effects. We use the version information for the control to determine whether the control supports self-registration without loading the control and executing <b>LibMain</b>.</p>
<p>
The Microsoft Windows version 3.1 operating system includes a set of functions that standardize version information for .DLLs and .EXEs. These functions simplify the difficulties installation programs face in determining what is currently installed and what should be replaced. The version information is included in .EXEs and .DLLs as a special resource type. The functions that manipulate the version information are exported from VERS.DLL. Applications that call these functions need to link with VERSION.LIB. (If you are still developing for a 16-bit system, you should link with VER.LIB instead.) </p>
<p>
The version information for the CDK Spindial sample control (from the SPINDIAL.RC2 file) is shown below.</p>
<pre><code>#ifdef _WIN32
#include "winver.h"
#else
#include "ver.h"
#endif

VS_VERSION_INFO&nbsp;&nbsp;&nbsp;&nbsp; VERSIONINFO
  FILEVERSION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,0,0,1
  PRODUCTVERSION&nbsp;&nbsp;&nbsp; 1,0,0,1
  FILEFLAGSMASK&nbsp;&nbsp;&nbsp;&nbsp; VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
  FILEFLAGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VS_FF_DEBUG|VS_FF_PRIVATEBUILD|VS_FF_PRERELEASE
#else
  FILEFLAGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 // final version
#endif
#ifdef _WIN32
  FILEOS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VOS__WINDOWS32
#else
  FILEOS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VOS__WINDOWS16
#endif
  FILETYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VFT_DLL
  FILESUBTYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; // not used
BEGIN
 &nbsp; BLOCK "StringFileInfo"
 &nbsp; BEGIN
#ifdef _WIN32
 &nbsp;&nbsp;&nbsp;&nbsp; BLOCK "040904B0" // Lang=US English, CharSet=Unicode
#else
 &nbsp;&nbsp;&nbsp;&nbsp; BLOCK "040904E4" // Lang=US English, CharSet=Windows Multilingual
#endif
 &nbsp;&nbsp;&nbsp;&nbsp; BEGIN
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "CompanyName",&nbsp;&nbsp;&nbsp;&nbsp; "\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "FileDescription", "SPINDIAL OLE Control DLL\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "FileVersion",&nbsp;&nbsp;&nbsp;&nbsp; "1.0.001\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "InternalName",&nbsp;&nbsp;&nbsp; "SPINDIAL\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "LegalCopyright",&nbsp; "Copyright \251 1994, Microsoft Corporation\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "LegalTrademarks", "\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "OriginalFilename","SPINDIAL.DLL\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "ProductName",&nbsp;&nbsp;&nbsp;&nbsp; "SPINDIAL\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "ProductVersion",&nbsp; "1.0.001\0"

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "OLESelfRegister", "\0"</b>

 &nbsp;&nbsp;&nbsp;&nbsp; END
 &nbsp; END
 &nbsp; BLOCK "VarFileInfo"
 &nbsp; BEGIN
#ifdef _WIN32
 &nbsp;&nbsp;&nbsp;&nbsp; VALUE "Translation", 0x409, 1200
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // English language (0x409) and the Unicode codepage (1200)
#else
 &nbsp;&nbsp;&nbsp;&nbsp; VALUE "Translation", 0x409, 1252
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // English language (0x409) and the Windows ANSI codepage (1252)
#endif
 &nbsp; END
END
</code></pre>
<p>
ControlWizard generated this information automatically for us. Notice the <b>OLESelfRegister</b> key. A control that supports self-registration adds this string to the <b>StringFileInfo</b> block of the <b>VERSIONINFO</b> structure.</p>
<h3>How Is the Version Information Read?</h3>
<p>
The following functions manipulate the version information:
<ul type=disc>
<li>
GetFileVersionInfoSize<br><br></li>
<li>
GetFileVersionInfo<br><br></li>
<li>
VerQueryValue</li>
</ul>
<p>
<b>GetFileVersionInfoSize</b> returns the size of the version information, so the correct size buffer can be allocated. <b>GetFileVersionInfo </b>is then used to fill the buffer with the version information. <b>VerQueryValue </b>searches the buffer filled by <b>GetFileVersionInfo</b> and returns the requested values.</p>
<p>
The process of reading the values is complicated by the translation information needed to get to the string. The version information contains two main blocks: the <b>VarFileInfo</b> block and the <b>StringFileInfo</b> block. The <b>StringFileInfo</b> block contains a sub-block, "040904E4". Figure 2 shows this graphically.</p>
<p>
<img src="ctlreg_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Blocks in the version information</b></p>
<p>
To get to the <b>OLESelfRegister</b> key, we need to specify its "path" to <b>VerQueryValue</b>. In the case illustrated above, that path is "\StringFileInfo\040904E4\OLESelfRegister". However, the path may change depending on the "Translation" entry in the <b>VarFileInfo</b> block. Before we query for "OLESelfRegister", we need to query "\VarFileInfo\Translation" and build the path to <b>OLESelfRegister</b> from the result. </p>
<p>
In CTLREG, the <b>CCtlReg::SupportsSelfRegister</b> function handles this process. We have already seen how <b>CCtlReg::Register</b> calls <b>SupportsSelfRegister</b>; you can see how <b>SupportsSelfRegister</b> works below.</p>
<pre><code>BOOL CCtlReg::SupportsSelfRegister()
{
 &nbsp; BOOL bResult = FALSE;
 &nbsp; DWORD&nbsp; handle;
 &nbsp; UINT&nbsp; uiInfoSize;
 &nbsp; UINT&nbsp; uiVerSize ;
 &nbsp; UINT&nbsp; uiSize ;
 &nbsp; BYTE* pbData = NULL ;
 &nbsp; DWORD* lpBuffer;;
 &nbsp; char szName[512] ;

 &nbsp; // Get the size of the version information.
 &nbsp; uiInfoSize = 
 &nbsp;&nbsp;&nbsp;&nbsp; ::GetFileVersionInfoSize( m_strPathName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;handle);
 &nbsp; if (uiInfoSize == 0) return FALSE ;

 &nbsp; // Allocate a buffer for the version information.
 &nbsp; pbData = new BYTE[uiInfoSize] ;

 &nbsp; // Fill the buffer with the version information.
 &nbsp; bResult = 
 &nbsp;&nbsp;&nbsp;&nbsp; ::GetFileVersionInfo( m_strPathName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uiInfoSize,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pbData);
 &nbsp; if (!bResult) goto NastyGoto ;

 &nbsp; // Get the translation information.
 &nbsp; bResult = 
 &nbsp;&nbsp;&nbsp; ::VerQueryValue( pbData,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\\VarFileInfo\\Translation",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;lpBuffer,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;uiVerSize);
 &nbsp; if (!bResult) goto NastyGoto ;

 &nbsp; bResult = uiVerSize ;
 &nbsp; if (!bResult) goto NastyGoto ;

 &nbsp; // Build the path to the OLESelfRegister key
 &nbsp; // using the translation information.
 &nbsp; sprintf( szName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\\StringFileInfo\\%04hX%04hX\\OLESelfRegister",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOWORD(*lpBuffer),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(*lpBuffer)) ;

 &nbsp; // Search for the key.
 &nbsp; bResult = ::VerQueryValue( pbData, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szName, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;lpBuffer, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;uiSize);

NastyGoto:
 &nbsp; delete [] pbData ;
 &nbsp; return bResult ;
}
</code></pre>
<h3>That's All There Is to Registration</h3>
<p>
That's all there is to OLE Control registration. I placed the registration code in the <b>CCtlReg</b> class, so it is easy to call from the view code in an application. In CTLREG, I invoke a <b>CFileDialog</b> object to get a filename, then I attempt to register it. The code is shown below:</p>
<pre><code>void CCtlRegView::OnControlsRegister() 
{

 &nbsp; static char BASED_CODE szFilter[] = 
 &nbsp;&nbsp;&nbsp;&nbsp; "OLE controls (*.ocx) | *.ocx | DLL's (*.dll) | *.dll |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OCX and DLL (*.ocx; *.dll) | *.ocx;*.dll |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All Files (*.*) | *.* ||" ;

 &nbsp; CFileDialog aDlg( TRUE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "OCX",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "*.ocx",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OFN_PATHMUSTEXIST |OFN_FILEMUSTEXIST,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szFilter,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this ) ;

 &nbsp; if (aDlg.DoModal() == IDOK)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CCtlReg aCtlReg(aDlg.GetPathName()) ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (aCtlReg.Register())
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( "Successful control registration.",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Control Registration.",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_OK | MB_ICONINFORMATION) ;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox( "Control registration failed.",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_OK | MB_ICONEXCLAMATION) ;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
}
</code></pre>
<h2>Unregistering a Control</h2>
<p>
The unregistration procedure is the same as the registration procedure, except that you call the <b>DllUnregisterServer</b> entry point (instead of <b>DllRegisterServer</b>) in your control's .OCX file. The <b>CCtlReg::Unregister</b> code, shown below, is identical to the <b>CCtlReg::Register</b> code except that "DLLUnregisterServer" replaces "DLLRegisterServer" in the <b>::GetProcAddress</b> call.</p>
<pre><code>BOOL CCtlReg::Unregister()
{
 &nbsp; BOOL bResult = FALSE ;
 &nbsp; if (SupportsSelfRegister())
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Path to OLE control in m_strPathName
 &nbsp;&nbsp;&nbsp;&nbsp; HMODULE hModule = ::LoadLibrary(m_strPathName) ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (LOADLIBRARY_FAILED(hModule)) return FALSE ;

 &nbsp;&nbsp;&nbsp;&nbsp; CTLREGPROC DLLUnregisterServer =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (CTLREGPROC)::GetProcAddress( hModule,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "DllUnregisterServer" ) ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (DLLUnregisterServer != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT regResult = DLLUnregisterServer() ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bResult = (regResult == NOERROR) ; 
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; ::FreeLibrary(hModule) ;
 &nbsp; }
 &nbsp; return result ;
}
</code></pre>
<h2>Looking in the Registry</h2>
<p>
When you register the Spindial sample control that comes with the CDK, what does it add to the registry? The next section answers this question for 32-bit applications; the section after that ("The Little 16-Bit Popguns") answers the question for 16-bit applications. Depending on your development environment (16-bit, 32-bit, or both) read one or both of these sections. (My technical reviewers did not seem to grasp that I was presenting the same information twice—once for 16-bit and once for 32-bit—that's why I'm stating what appears to be obvious.)</p>
<h3>The Big 32-Bit Guns</h3>
<p>
If you are running Windows NT version 3.5, use REGEDT32.EXE to look at the registry. Windows NT does not automatically give you an icon for REGEDT32.EXE, but the file should be in the WINNT\SYSTEM32 directory.</p>
<p>
Take a look at the <b>HKEY_CLASSES_ROOT</b> tree and the entry labeled something like "SPINDIAL.spindialCtrl.1", as shown in Figure 3.</p>
<p>
<img src="ctlreg_3.gif" border=0></p>
<p class=label>
<b>Figure 3. SPINDIAL.spindial.1 entry under HKEY_CLASSES_ROOT, as displayed by REGEDT32.EXE</b></p>
<p>
This is not the entry we are looking for—there's no information in here that tells us whether this is a control or a server. If you keep looking through the entries under <b>HKEY_CLASSES_ROOT</b>, you will find one for CLSID (Figure 4).</p>
<p>
<img src="ctlreg_4.gif" border=0></p>
<p class=label>
<b>Figure 4. The CLSID section of HKEY_CLASSES_ROOT</b></p>
<p>
In this list, you will find a CLSID that matches the one under SPINDIAL.spindialCtrl.1. Figure 5 shows what I found on my system. This entry provides the information we need to determine which controls are installed.</p>
<p>
<img src="ctlreg_5.gif" border=0></p>
<p class=label>
<b>Figure 5. Registry entry for Spindial control</b></p>
<p>
The next section explains how to find this information on a 16-bit system.</p>
<h3>The Little 16-Bit Popguns</h3>
<p>
Things aren't as pretty in 16-bit land. Instead of running REGEDT32.EXE, you run REGEDT (the Registration Info Editor) with the /V parameter to put it in super-whiz-bang-cool-developer-only mode. REGEDT works, but its interface is not as nice as the REGEDT32.EXE interface; REGEDT always shows the registry fully expanded and does not let you hide child levels.</p>
<p>
Somewhere in this text you will find an entry labeled "SPINDIAL.spindialCtrl.1" or something similar. Luckily, this entry was listed first on my system (Figure 6).</p>
<p>
<img src="ctlreg_6.gif" border=0></p>
<p class=label>
<b>Figure 6. Registration Info Editor screen </b></p>
<p>
Unfortunately, this entry does not tell us whether this is a control or a server. Search for the key "\CLSID". Figure 7 below shows the results of this search on my system. </p>
<p>
<img src="ctlreg_7.gif" border=0></p>
<p class=label>
<b>Figure 7. Search results for "\CLSID"</b></p>
<p>
In this list, you will find a CLSID that matches the one under SPINDIAL.spindialCtrl.1 (Figure 8). This is the information we need to determine which controls are installed.</p>
<p>
<img src="ctlreg_8.gif" border=0></p>
<p class=label>
<b>Figure 8. Registration database entry for the Spindial control</b></p>
<h3>What's in the Registry?</h3>
<p>
Now that we know how to use REGEDT32.EXE and REGEDT.EXE to examine the control information in the registry on 32-bit and 16-bit systems, we can look at the information a control places in the registry. Figure 9 shows the typical information a control might place in the registry.</p>
<p>
<img src="ctlreg_9.gif" border=0></p>
<p class=label>
<b>Figure 9. Registry information</b></p>
<p>
Notice that two entries, <b>InprocServer32</b> and <b>ToolboxBitmap32</b>, have the suffix "32", which indicates that this information applies to the 32-bit version of the control. It is possible to have both 16-bit and 32-bit versions of the same control installed.</p>
<p>
We might want to display a list box that will allow the user to select a registered control to insert into the document. The OLE Test Container tool displays such a list box. After the user has inserted the control, the Test Container also places a button representing the control on the toolbar. The CTLREG sample application displays a dialog box showing the registered controls so the user can select a control to unregister. </p>
<p>
Figure 10 shows the registry information required to determine whether an entry is a control, to unregister an control, and to get the bitmap for a control. The four keys under the class registry entry are discussed in the sections below.</p>
<p>
<img src="ctlreg_10.gif" border=0></p>
<p class=label>
<b>Figure 10. Registry information for registering and unregistering controls</b></p>
<h4>Control</h4>
<p>
OLE Controls put the <b>Control</b> key under their CLSID. Search for this key to determine whether a class is an OLE Control. We will discuss this in more detail in the "Finding Installed Controls" section later in this article.</p>
<h4>Insertable</h4>
<p>
OLE objects that can be embedded include the <b>Insertable</b> key in their class registry entry. OLE servers such as Microsoft Excel, Word, and Scribble include this key when they register. The Insert Object command in Word uses this key to fill a list box with the names of objects that you can embed within your document.</p>
<p>
OLE Controls may or may not include the <b>Insertable</b> key. The control developer will not define this key if inserting the control (for example, a timer) into a document does not make any sense. If the control developer wants to use the control with OLE containers that do not support OLE Controls directly, the control will have an <b>Insertable</b> key. Including this key indicates that the control is compatible with existing OLE containers. </p>
<p>
ControlWizard does not define the <b>Insertable</b> key by default. The code shown below for Spindial from SPINCTL.CPP determines whether the control can be inserted. Change FALSE to TRUE (see the line in bold below) if you would like to insert your control.</p>
<pre><code>BOOL CSpindialCtrl::CSpindialCtrlFactory::UpdateRegistry(BOOL bRegister)
{
 &nbsp; if (bRegister)
 &nbsp;&nbsp;&nbsp;&nbsp; return AfxOleRegisterControlClass(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxGetInstanceHandle(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_clsid,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_lpszProgID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDS_SPINDIAL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDB_SPINDIAL,

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Not insertable</b>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dwSpindialOleMisc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tlid,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _wVerMajor,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _wVerMinor);
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}
</code></pre>
<h4>InprocServer</h4>
<p>
The <b>InprocServer</b> key gives us the path to the 16-bit .OCX file that implements the control. The <b>InprocServer32</b> key points to the 32-bit .OCX file. This path is used when unregistering a control. </p>
<p>
Currently, there is no link between the information in the registry and the .OCX file. If you delete the .OCX file, the registry information is not removed or updated. Therefore, you must check to see if the .OCX file exists before running it. The CTLREG sample application marks controls that have existing .OCX files with the word "Exist".</p>
<h4>ToolboxBitmap</h4>
<p>
The <b>ToolboxBitmap</b> and <b>ToolboxBitmap32</b> keys point to a file containing a bitmap that can be used in toolbars and toolboxes, such as the Visual Basic toolbox. These buttons are defined to be 16x15 pixels. Figure 11 shows the <b>ToolboxBitmap</b> entry for the Spindial control.</p>
<p>
<img src="ctlreg_11.gif" border=0></p>
<p class=label>
<b>Figure 11. Value for ToolboxBitmap32</b></p>
<p>
As you can see in Figure 11, the <b>ToolboxBitmap</b> key value contains the path, followed by a comma and the resource number. The path is used by the <b>LoadLibrary</b> function, and the resource number is used in the <b>LoadBitmap</b> call.</p>
<h3>Finding Installed Controls</h3>
<p>
Now that we know what to look for and where, we need to understand how to find the installed controls. This involves the following functions:
<ul type=disc>
<li>
RegOpenKey<br><br></li>
<li>
RegCloseKey<br><br></li>
<li>
RegEnumKey<br><br></li>
<li>
RegQueryValue</li>
</ul>
<p>
I used these functions instead of <b>RegOpenKeyEx</b> and other <b>Reg...Ex </b>functions because they are available for Win16 as well as Win32®. These four functions are not wrapped by the Microsoft Foundation Class Library (MFC). To emphasize this, I use the scope resolution operator (<b>::</b>).</p>
<p>
Figure 12 shows where these functions are applied.</p>
<p>
<img src="ctlreg_12.gif" border=0></p>
<p class=label>
<b>Figure 12. Functions used for the registry</b></p>
<h4>RegOpenKey and RegCloseKey</h4>
<p>
First, we must understand how to open and close the <b>CLSID</b> key. To open a key, you use the <b>RegOpenKey</b> function with three parameters: <b>HKEY_CLASSES_ROOT</b>, the name of the key you want to open, and a pointer to the variable that receives the handle to the open key. The code below opens the <b>CLSID</b> key under <b>HKEY_CLASSES_ROOT</b>. We use the <b>hKeyClsid</b> handle to get to the keys under the <b>CLSID</b> key, then we close the <b>CLSID</b> key.</p>
<pre><code>&nbsp;&nbsp;&nbsp;HKEY hKeyClsid ;
 &nbsp; LONG regResult = ERROR_SUCCESS;
 &nbsp; regResult = ::RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &amp;hKeyClsid);
 &nbsp; if (regResult != ERROR_SUCCESS) return FALSE ;
 &nbsp; //
 &nbsp; // Use hKeyClsid here.
 &nbsp; //
 &nbsp; ::RegCloseKey(hKeyClsid); 
</code></pre>
<p>
A word to the weary: ERROR_SUCCESS is currently defined as 0, so you cannot do the following:</p>
<pre><code>if (::RegOpenKey(...))
 &nbsp; // Succeeded.
else
 &nbsp; // Failed.
</code></pre>
<p>
You could do the following, but it seems counterintuitive to me:</p>
<pre><code>if (!::RegOpenKey(...))
 &nbsp; // Succeeded.
else
 &nbsp; // Failed.
</code></pre>
<p>
Instead, use:</p>
<pre><code>if (::RegOpenKey(...) == ERROR_SUCCESS)
 &nbsp; // Succeeded.
</code></pre>
<h4>RegEnumKey</h4>
<p>
The second step is to enumerate the keys under <b>CLSID</b> using the <b>RegEnumKey</b> function. We pass four parameters to <b>RegEnumKey</b>: the <b>hKeyClsid</b> that we just got from <b>RegOpenKey</b>, the index that tracks the keys we have already enumerated, a pointer to a buffer that will hold the key name, and the size of the buffer. In this case, the key name will be the <b>CLSID</b> of the control, a string in the form {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}. It's easy to fill a list box with the key names; however, we have to open the key to get its handle before we can do any meaningful work.</p>
<p>
In the code below, <b>RegEnumKey</b> returns a key name. We open this key to obtain its handle (<b>hKeyX)</b>. We then open <b>hKeyX</b>, looking for the <b>Control</b> key. If the key is present, we know we have a control and can add it to our list box. If the <b>Control</b> key is not present, we continue enumerating the keys under <b>CLSID</b>.</p>
<pre><code>&nbsp;&nbsp;&nbsp;DWORD dwIndex = 0 ;
 &nbsp; char szClsidName[MAX_PATH+1] ;
 &nbsp; HKEY hKeyX ;
 &nbsp; HKEY hKeyControl ;
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; while(::RegEnumKey(hKeyClsid, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwIndex++, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szClsidName, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX_PATH+1) == ERROR_SUCCESS)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // 
 &nbsp;&nbsp;&nbsp;&nbsp; // Open the szClsidName key here.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; regResult = ::RegOpenKey(hKeyClsid,szClsidName,&amp;hKeyX) ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (regResult != ERROR_SUCCESS) continue;
 &nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; // Look for the "Control" key.
 &nbsp;&nbsp;&nbsp;&nbsp; regResult = ::RegOpenKey(hKeyX, "Control", &amp;hKeyControl) ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (regResult == ERROR_SUCCESS)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This is a control.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::RegCloseKey(hKeyControl) ;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; ::RegCloseKey(hKeyX) ;
 &nbsp; }
</code></pre>
<h4>RegQueryValue</h4>
<p>
Now that we know we have a control, we can examine the other keys handled by <b>hKeyX</b>. To get the value for a key, we use the <b>RegQueryValue</b> function. <b>RegQueryValue</b> accepts four parameters: a handle to an open key, the name of the key (located under the open key) whose value you wish to retrieve, a buffer to hold the key value, and a size for the buffer. Figure 13 illustrates how this works.</p>
<p>
<img src="ctlreg_13.gif" border=0></p>
<p class=label>
<b>Figure 13. RegQueryValue parameters</b></p>
<p>
Here's the code that calls <b>RegQueryValue</b>:</p>
<pre><code>LONG lSize ;
char szBuffer[MAX_PATH*2] ;
// Look for path of InprocServer. 
lSize = sizeof(szBuffer) ;
::RegQueryValue(hKeyX, "InprocServer32", szBuffer, &amp;lSize) ;&nbsp; 

// Store path name.
char* pPath = new char[lSize] ;
memcpy(pEntry-&gt;m_pPath, szBuffer, (int)lSize) ;
</code></pre>
<p>
I originally wrote CTLREG for Win32; however, I wanted to use functions that were also available in Win16, so I used <b>RegQueryValue</b> instead of <b>RegQueryValueEx</b>. Unfortunately, the Win16 and Win32 versions of <b>RegQueryValue</b> are not interchangeable. In the Win16 version, there is no way to get the size of the buffer before you fill it. In the Win32 version, you can get the size of the buffer (in the <b>lSize</b> parameter) if you pass a NULL instead of a pointer to the buffer. The code below shows my original code before I had to port it to Win16.</p>
<pre><code>// Get size
regResult = ::RegQueryValue(hKeyX, "InprocServer32", NULL, &amp;lSize) ;
if (regResult == ERROR_SUCCESS)
{
 &nbsp; // Allocate buffer
 &nbsp; char* pPath = new char[lSize] ;
 &nbsp; // Fill buffer
 &nbsp; ::RegQueryValue(hKeyX, "InprocServer32", pPath, &amp;lSize) ;
}
</code></pre>
<p>
A word to the wise: You may find a specific function included in both Win32 and Win16, but the two versions of the function may not work the same. </p>
<h4>Putting it all together</h4>
<p>
In the CTLREG application, a <b>CPtrArray</b> (<b>m_PtrArray</b>) in the <b>CUnregisterDlg</b> function is filled with information from the registry, as listed below. <b>m_PtrArray</b> is then used to fill a list box in the dialog box. The code below ties together all the pieces we have talked about. It also shows how to get an <b>hBitmap</b> for the <b>ToolboxBitmap</b> key.</p>
<pre><code>BOOL CUnregisterDlg::GetControlNames()
{
 &nbsp; DWORD dwIndex = 0 ;
 &nbsp; HKEY hKeyClsid ;
 &nbsp; HKEY hKeyX ;
 &nbsp; HKEY hKeyControl ;
 &nbsp; HKEY hKeyInsertable; 
 &nbsp; LONG lSize ;
 &nbsp; LONG regResult = ERROR_SUCCESS;
 &nbsp; char szClsidName[MAX_PATH+1] ;
 &nbsp; char szBuffer[MAX_PATH*2] ;

#ifdef _WIN32
 &nbsp; static char szToolboxBitmap[] = "ToolboxBitmap32" ;
 &nbsp; static char szInprocServer[] = "InprocServer32" ;
#else
 &nbsp; static char szToolboxBitmap[] = "ToolboxBitmap" ;
 &nbsp; static char szInprocServer[] = "InprocServer" ;
#endif


 &nbsp; //HKEY_CLASSES_ROOT
 &nbsp; //&nbsp;&nbsp; CLSID
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Control
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Insertable
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ToolbarBitmap

 &nbsp; regResult = ::RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &amp;hKeyClsid);
 &nbsp; if (regResult != ERROR_SUCCESS) return FALSE ;

 &nbsp; // Enumerate all entries under CLSID.
 &nbsp; while(::RegEnumKey(hKeyClsid, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwIndex++, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szClsidName, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX_PATH+1) == ERROR_SUCCESS)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Open the CLSID key.
 &nbsp;&nbsp;&nbsp;&nbsp; regResult = ::RegOpenKey(hKeyClsid,szClsidName,&amp;hKeyX) ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (regResult != ERROR_SUCCESS) continue;

 &nbsp;&nbsp;&nbsp;&nbsp; // Is this a control?
 &nbsp;&nbsp;&nbsp;&nbsp; regResult = ::RegOpenKey(hKeyX, "Control", &amp;hKeyControl) ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (regResult == ERROR_SUCCESS)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Yes, we have a control. 

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Look for path of InprocServer. 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lSize = sizeof(szBuffer) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regResult = ::RegQueryValue(hKeyX, szInprocServer, szBuffer, &amp;lSize) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (regResult != ERROR_SUCCESS)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {// Didn't find it. It might be 16-bit instead of 32-bit or vice versa.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue ; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Store path name.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRegEntry* pEntry = new CRegEntry ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEntry-&gt;m_pPath = new char[lSize] ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(pEntry-&gt;m_pPath, szBuffer, (int)lSize) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Check to see if .OCX file actually exists.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OFSTRUCT OpenBuff ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (::OpenFile(pEntry-&gt;m_pPath, &amp;OpenBuff, OF_EXIST) == HFILE_ERROR)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEntry-&gt;m_bExists = FALSE ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get control name and put it into array.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lSize = sizeof(szBuffer); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regResult = ::RegQueryValue(hKeyClsid, szClsidName, szBuffer, &amp;lSize) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (regResult != ERROR_SUCCESS) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete pEntry ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEntry-&gt;m_pName = new char[lSize] ; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(pEntry-&gt;m_pName, szBuffer, (int)lSize) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Is it insertable?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regResult = ::RegOpenKey(hKeyX,"Insertable",&amp;hKeyInsertable) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEntry-&gt;m_bInsertable = (regResult == ERROR_SUCCESS) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pEntry-&gt;m_bInsertable) ::RegCloseKey(hKeyInsertable) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Put bitmap in array.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lSize = sizeof(szBuffer) ; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regResult = ::RegQueryValue(hKeyX, szToolboxBitmap, szBuffer, &amp;lSize) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (regResult == ERROR_SUCCESS)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CString strPathAndResNum(szBuffer, (int)lSize) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Let's pretend we're using Basic.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int indexComma = strPathAndResNum.Find(',') ; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CString strPath = strPathAndResNum.Left(indexComma) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CString strResNum = strPathAndResNum.Mid(indexComma+1) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD wResNum = atoi(strResNum) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HINSTANCE hInstCtl&nbsp; = ::LoadLibrary(strPath) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hInstCtl &gt; HINSTANCE_ERROR)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The .OCX file might not actually exist.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEntry-&gt;m_hBitmap = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::LoadBitmap(hInstCtl, MAKEINTRESOURCE(wResNum)) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :FreeLibrary(hInstCtl) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add entry to list.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_PtrArray.Add(pEntry); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Clean up.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::RegCloseKey(hKeyControl) ;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; ::RegCloseKey(hKeyX) ; 
 &nbsp; }
 &nbsp; ::RegCloseKey(hKeyClsid); 

 &nbsp; return TRUE ;
}
</code></pre>
<h2>Cleaning Up the Registry</h2>
<p>
You can delete an OLE Control without unregistering it. Therefore, the registry may contain entries for OLE Controls that no longer exist on the system. I decided to add some minimal support to CTLREG for cleaning up entries associated with non-existing controls. I will not include the code here, but you can look in the UNREGDLG.CPP file for the <b>OnCleanup</b>, <b>WipeOut</b>, and <b>GetControlNames</b> functions. The version of <b>GetControlNames</b> is slightly different from the one listed above. Figure 14 provides a graphical representation of the clean-up code.</p>
<p>
<img src="ctlreg_14.gif" border=0></p>
<p class=label>
<b>Figure 14. Cleaning up the registry</b></p>
<p>
In Figure 14, we examine the registry information under \HKEY_CLASSES_ROOT\CLSID and delete the information for the Time control. We read the <b>TypeLib</b> entry to get the ID for the Time control's type library, then delete this entry from \HKEY_CLASSES_ROOT\TypeLib. Next, we read the ProgID entry that returns TIME.TimeCtrl.1. We use this information to delete the \HKEY_CLASSES_ROOT\TIME.TimeCtrl.1 entry. Now we delete the CLSID entry for the Time control itself. The last thing we do is search through \HKEY_CLASSES_ROOT\CLSID, deleting entries that have an <b>InprocServer</b> name matching that of the Time control.</p>
<p>
This process leaves the dispatch map and events dispatch map entries for the Time control in \HKEY_CLASSES_ROOT\Interface. There is no easy way to find out which dispatch maps belong to a deleted control.</p>
<p>
This clean-up method does work, but it is not 100 percent foolproof, especially on systems that include both 16-bit and 32-bit controls.</p>
<h2>Conclusion</h2>
<p>
OLE Controls support self-registration, so a developer does not have to understand OLE to register or unregister a control. However, the developer will have to learn about version information to determine whether the control supports self-registration. Controls generated by ControlWizard support self-registration. In addition, many applications that use OLE Controls will need to search the registry for information about the control, for example, to find the location of the control's toolbox bitmap.</p>
<h2>Bibliography</h2>
<p>
Microsoft OLE Control Developer's Kit (CDK). <i>User's Guide and Reference</i>.</p>
<p>
Microsoft Windows version 3.1 Software Development Kit (SDK). <i>Programmer's Reference, Volume 1: Overview</i>, Chapter 11. (MSDN Library Archive, Product Documentation, SDKs, Windows 3.1 SDK)</p>
<p>
Microsoft Win32 Software Development Kit (SDK) for Windows NT. <i>Programmer's API Reference, Volume 2: Systems Services, Multimedia, Extensions, and Application Notes</i>, Part 5, Chapter 80. (MSDN Library Archive, Product Documentation, SDKs, Win32 SDK)</p>
</BODY>
</HTML>
