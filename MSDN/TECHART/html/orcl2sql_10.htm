<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Control-of-Flow Language</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Control-of-Flow Language</h1>
<p>
The control-of-flow language is quite similar between PL/SQL and Transact-SQL. Regardless of DBMS, the control-of-flow language controls the flow of execution of SQL statements, statement blocks, and stored procedures.</p>
<h3>Keywords</h3>
<p>
These are the keywords supported by each DBMS.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Statement</b></td>
<td class=label width=39%><b>PL/SQL</b></td>
<td class=label width=31%><b>Transact-SQL</b></td>
</tr>
<tr valign=top>
<td width=30%>Declare variables</td>
<td width=39%>DECLARE</td>
<td width=31%>DECLARE</td>
</tr>
<tr valign=top>
<td width=30%>Statement block</td>
<td width=39%>BEGIN...END;</td>
<td width=31%>BEGIN...END</td>
</tr>
<tr valign=top>
<td width=30%>Conditional processing</td>
<td width=39%><b>IF…THEN,<br>
ELSIF…THEN,<br>
ELSE<br>
ENDIF;</b></td>
<td width=31%><b>IF…[BEGIN…END]<br>
ELSE [BEGIN…END]<br>
CASE expression</b></td>
</tr>
<tr valign=top>
<td width=30%>Unconditional exit</td>
<td width=39%>RETURN</td>
<td width=31%>RETURN</td>
</tr>
<tr valign=top>
<td width=30%>Wait for a specified interval</td>
<td width=39%><b>N/A</b></td>
<td width=31%><b>WAITFOR</b></td>
</tr>
<tr valign=top>
<td width=30%>Loop control</td>
<td width=39%>WHILE…<b>END LOOP;</b><br>
LABEL…GOTO LABEL;<br>
<b>FOR…END LOOP;<br>
LOOP…END LOOP;</b></td>
<td width=31%>WHILE…<br>
LABEL…GOTO LABEL</td>
</tr>
<tr valign=top>
<td width=30%>Program comments</td>
<td width=39%>/* … */, --</td>
<td width=31%>/* … */, --</td>
</tr>
<tr valign=top>
<td width=30%>Print output</td>
<td width=39%><b>DBMS_OUTPUT.PUT_LINE</b></td>
<td width=31%><b>PRINT</b></td>
</tr>
<tr valign=top>
<td width=30%>Raise program error</td>
<td width=39%><b>RAISE_APPLICATION_ERROR</b></td>
<td width=31%><b>RAISERROR</b></td>
</tr>
<tr valign=top>
<td width=30%>Execute program</td>
<td width=39%>EXECUTE</td>
<td width=31%>EXECUTE</td>
</tr>
<tr valign=top>
<td width=30%>Statement terminator</td>
<td width=39%><b>Semicolon (;)</b></td>
<td width=31%><b>N/A</b></td>
</tr>
</table><br>
<h3>Declaring Variables</h3>
<p>
Transact-SQL and PL/SQL variables are created using the DECLARE keyword. Transact-SQL variables must be identified with the at sign (@) and, like PL/SQL variables, are initialized to a null value when they are first created.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>DECLARE<br>
VSSN CHAR(9);<br>
VFNAME VARCHAR2(12);<br>
VLNAME VARCHAR2(20);<br>
VBIRTH_DATE DATE;<br>
VLOAN_AMOUNT NUMBER(12,2);</td>
<td width=51%>DECLARE<br>
@VSSN CHAR(9),<br>
@VFNAME VARCHAR2(12),<br>
@VLNAME VARCHAR2(20),<br>
@VBIRTH_DATE DATETIME,<br>
@VLOAN_AMOUNT NUMERIC(12,2)</td>
</tr>
</table><br>
<p>
Transact-SQL does not support the %TYPE and %ROWTYPE variable data type definitions. A Transact-SQL variable cannot be initialized in the DECLARE statement. The NOT NULL and CONSTANT keywords cannot be used.</p>
<p>
Like Oracle LONG and LONG RAW data types, <b>text</b> and <b>image</b> data types cannot be used for variable declarations. Additionally, the PL/SQL style record and table definitions are not supported. </p>
<h3>Assigning Variables</h3>
<p>
Oracle offers three ways to assign values to local variables:&nbsp; 
<ul type=disc>
<li>
The assignment operator (:=) <br><br></li>
<li>
The SELECT...INTO syntax for selecting column values from a single row<br><br></li>
<li>
The FETCH…INTO syntax for retrieving column values a row at a time from a cursor</li>
</ul>
<p>
SQL Server, in contrast, offers two ways to assign values:
<ul type=disc>
<li>
SELECT @var=&lt;expression&gt; [FROM…] for assigning a literal value, an expression involving other local variables, or a column value from a single row<br><br></li>
<li>
FETCH…INTO for retrieving column values a row at a time from a cursor</li>
</ul>
<p>
Declaring and assigning local variables in Oracle and SQL Server looks like this.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>DECLARE VSSN CHAR(9);<br>
VFNAME VARCHAR2(12);<br>
VLNAME VARCHAR2(20);<br>
BEGIN<br>
<b>VSSN := '123448887'</b>;<br>
SELECT <b>FNAME</b>,<b> LNAME INTO VFNAME</b>, <b>VLNAME</b> FROM STUDENTS WHERE SSN=VSSN;<br>
END; </td>
<td width=51%>DECLARE @VSSN CHAR(9),<br>
@VFNAME VARCHAR(12),<br>
@VLNAME VARCHAR(20)<br>
<b>SELECT @VSSN = '12355887'</b><br>
SELECT <b>@VFNAME=FNAME</b>, <b>@VLNAME=LNAME</b> FROM STUDENTS WHERE SSN = @VSSN</td>
</tr>
</table><br>
<p>
SQL Server does not offer a constant declaration, nor can you assign variables in the DECLARE statement. </p>
<h3>Statement Blocks</h3>
<p>
PL/SQL and Transact-SQL support the use of the BEGIN…END terminology to specify statement blocks. Transact-SQL does not require the use of a statement block following the DECLARE statement. The BEGIN…END statement blocks are required for IF statements and WHILE loops if more than one statement is executed.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>DECLARE<br>
&nbsp;&nbsp;&nbsp;&nbsp;DECLARE VARIABLES ...<br>
<b>BEGIN -- THIS IS REQUIRED SYNTAX</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;PROGRAM_STATEMENTS ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>IF ...THEN</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENT1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENT2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENTN;<br>
<b>END IF;</b><br>
WHILE ... <b>LOOP</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENT1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENT2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENTN;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>END LOOP;<br>
END; -- THIS IS REQUIRED SYNTAX</b></td>
<td width=51%>DECLARE<br>
&nbsp;&nbsp;&nbsp;&nbsp;DECLARE VARIABLES ...<br>
<b>BEGIN -- THIS IS OPTIONAL SYNTAX</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;PROGRAM_STATEMENTS ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF ...<b><br>
&nbsp;&nbsp;&nbsp;&nbsp;BEGIN</b> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENT1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENT2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENTN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>END </b><br>
WHILE ... <b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BEGIN</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENT1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENT2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATEMENTN<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>END <br>
END -- THIS IS REQUIRED SYNTAX</b></td>
</tr>
</table><br>
<h3>Conditional Processing</h3>
<p>
The Transact-SQL conditional statement includes the IF and ELSE terminology. There is no ELSIF as in PL/SQL. However, multiple IF statements can be embedded within each other to achieve the same effect. For extensive conditional tests, it is recommend that you use the CASE statement.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>DECLARE<br>
VDEGREE_PROGRAM CHAR(1);<br>
VDEGREE_PROGRAM_NAME VARCHAR2(20);<br>
BEGIN<br>
&nbsp;&nbsp;&nbsp;&nbsp;VDEGREE_PROGRAM := 'U';<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF VDEGREE_PROGRAM = 'U' THEN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VDEGREE_PROGRAM_NAME := <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Undergraduate';<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSIF VDEGREE_PROGRAM = 'M' THEN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VDEGREE_PROGRAM_NAME := <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Masters';<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSIF VDEGREE_PROGRAM = 'P' THEN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VDEGREE_PROGRAM_NAME := 'PhD';<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSE VDEGREE_PROGRAM_NAME := <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Unknown';<br>
&nbsp;&nbsp;&nbsp;&nbsp;END IF;<br>
END;</td>
<td width=51%>DECLARE<br>
@VDEGREE_PROGRAM CHAR(1),<br>
@VDEGREE_PROGRAM_NAME VARCHAR(20)<br>
SELECT @VDEGREE_PROGRAM = 'U'<br>
SELECT @VDEGREE_PROGRAM_NAME =<br>
&nbsp;&nbsp;&nbsp;&nbsp;CASE @VDEGREE_PROGRAM<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'U' THEN 'Undergraduate'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'M' THEN 'Masters'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'P' THEN 'PhD'.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE 'Unknown'<br>
&nbsp;&nbsp;&nbsp;&nbsp;END</td>
</tr>
</table><br>
<h3>Repeated Statement Execution (Looping)</h3>
<p>
Transact-SQL offers the WHILE loop. The PL/SQL unconditional LOOP and FOR LOOP statements are not supported. The GOTO statement can also be used for looping purposes.</p>
<pre><code>WHILE Boolean_expression
 &nbsp; {sql_statement | statement_block}
 &nbsp; [BREAK] [CONTINUE]
</code></pre>
<p>
The WHILE loop tests a Boolean expression for the repeated execution of one or more statements. The statement(s) are executed repeatedly as long as the specified expression evaluates to TRUE. If multiple statements are to be executed, they must be placed within a BEGIN…END block.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>DECLARE<br>
COUNTER NUMBER;<br>
BEGIN<br>
&nbsp;&nbsp;&nbsp;&nbsp;COUNTER := 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;WHILE (COUNTER &lt;5) LOOP<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COUNTER := COUNTER + 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;END LOOP;<br>
END;</td>
<td width=51%>DECLARE<br>
@COUNTER NUMERIC<br>
SELECT@COUNTER = 1<br>
WHILE (@COUNTER &lt;5)<br>
BEGIN<br>
&nbsp;&nbsp;&nbsp;&nbsp;SELECT @COUNTER = @COUNTER +1<br>
END</td>
</tr>
</table><br>
<p>
Statement execution can be controlled from inside the loop with the BREAK and CONTINUE keywords. The BREAK keyword causes an unconditional exit from the WHILE loop. The CONTINUE keyword causes the WHILE loop to restart, skipping any statements that follow.</p>
<h3>PRINT Statement</h3>
<p>
The Transact-SQL PRINT statement performs the same operation as the PL/SQL DBMS_OUTPUT.<i>put_line</i> procedure. It is used for printing user-specified messages.</p>
<p>
The message limit for the PRINT statement is 255 characters. Variables that are defined using the <b>char</b> or <b>varchar</b> data type can be embedded in the printed statement. If any other data type is used, the CONVERT function must be used. Local variables, global variables, and text can be printed. Both single and double quotes can be used to enclose text.</p>
<h3>Raising Program Errors</h3>
<p>
The Transact-SQL RAISERROR statement returns a user-defined error message and sets a system flag to record that an error has occurred. It is very similar in function to the PL/SQL <i>raise_application_error</i> exception handler.</p>
<pre><code>RAISERROR ({msg_id | msg_str}, severity, state
 &nbsp; [, argument1 [, argument2]])
 &nbsp; [WITH options]
</code></pre>
<p>
The RAISERROR statement allows the client to retrieve an entry from the <b>sysmessages</b> table or build a message dynamically with user-specified severity and state information. Once defined, this message is sent back to the client as a server error message.</p>
<p>
When converting your PL/SQL programs, it may not be necessary to use the RAISERROR statement. In the following code example, the PL/SQL program uses the <i>raise_application_error</i> exception handler, while the Transact-SQL program uses nothing. The <i>raise_application_error</i> exception handler has been included to prevent the PL/SQL program from possibly returning an ambiguous <i>unhandled exception</i> error message. Instead, it always returns the Oracle error message (SQLERRM) whenever an unanticipated problem occurs.</p>
<p>
When a Transact-SQL program fails, it always returns a detailed error message to the client program. Therefore, unless some specialized error handling is required, the RAISERROR statement is not always needed.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=53%><b>Oracle</b></td>
<td class=label width=47%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=53%>CREATE OR REPLACE FUNCTION<br>
DEPT_ADMIN.DELETE_DEPT<br>
(VDEPT IN VARCHAR2) RETURN NUMBER AS<br>
BEGIN<br>
DELETE FROM DEPT_ADMIN.DEPT<br>
WHERE DEPT = VDEPT;<br>
RETURN(SQL%ROWCOUNT);<br>
EXCEPTION<br>
WHEN OTHER THEN<br>
RAISE_APPLICATION_ERROR (-20001,SQLERRM);<br>
END DELETE_DEPT;<br>
/</td>
<td width=47%>CREATE PROCEDURE<br>
DEPT_ADMIN.DELETE_DEPT<br>
@VDEPT VARCHAR(4) AS<br>
DELETE FROM DEPT_DB.DBO.DEPT<br>
WHERE DEPT = @VDEPT<br>
RETURN @@ROWCOUNT<br>
GO</td>
</tr>
</table><br>
</BODY>
</HTML>
