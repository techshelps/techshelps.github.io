<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFC/COM Objects 6: Using COM Objects from Visual Basic</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_house6"></a></sup>MFC/COM Objects 6: Using COM Objects from Visual Basic</h1>
<p>
Nigel Thompson<br>
Microsoft Developer Network Technology Group</p>
<p>
March 20, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4238">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the HOUSE6 sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article is the sixth in a series that looks at creating and using Component Object Model (COM) objects with Visual C++™ and the Microsoft® Foundation Class Library (MFC). In this article, I'll be looking at the possibilities of using COM objects directly from Visual Basic®. You should note that this is a somewhat theoretical article, inasmuch as I did the evaluation using an internal version of Visual Basic 4.0 (32-bit), which is not yet available. As you will see, although it is possible to use COM objects directly from Visual Basic, it is neither easy nor fun. In a future article, I'll be looking at making the entire problem much simpler by using OLE Controls. The OLE Controls will make use of the COM objects, but provide a much better interface for the Visual Basic programmer. The sample code for this article uses COM objects and bitmaps from the earlier articles. Note that to run these samples, you need the correct registry entries for the COM objects. Please refer to the first article in this series (<a href="msdn_house1.htm">"MFC/COM Objects 1: Creating a Simple Object"</a>) for details on how to do this.</p>
<h2>Introduction</h2>
<p>
Because I know that many of you out there in programming land are Visual Basic® programmers, I thought it would be interesting to see if our fledgling 32-bit version of Visual Basic would be able to make direct use of the Component Object Model (COM) objects I've created using Visual C++™. My initial goal was to reproduce the HOUSE example entirely in Visual Basic. The short story is that I didn't get there. I possibly could have, but the effort required seemed ridiculous to me compared to the simplicity afforded by OLE Controls. So in this article, I'm going to tell you how far I did manage to get in building a Visual Basic application that uses COM objects, and then I'll follow that up in a later article with some OLE Controls that make the Visual Basic exercise a lot easier.</p>
<p>
Let me just emphasize again that this example was built using an internal version of our unreleased Visual Basic 4.0 product and, as such, is simply an example of what you might be able to do with the final product. Because Visual Basic 4.0 is not finished yet, what I've done here may or may not work in the final product. Enough warnings; let's see what using COM objects from Visual Basic involves.</p>
<h2>COM Object Interfaces Revisited</h2>
<p>
The idea of using COM objects from Visual Basic is all very well, but to be practically possible, the interfaces that the COM objects provide must be designed in such a way that it is possible to pass all their parameters correctly from Visual Basic. If you read the earlier articles in this series, you might guess where I'm headed with this. Let's briefly revisit the <b>IDrawing</b> interface as defined in previous articles:</p>
<pre><code>class IDrawing : public IUnknown
{
public:
 &nbsp;&nbsp; // Standard IUnknown interface functions
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID* ppvObj) = 0;
 &nbsp;&nbsp; virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
 &nbsp;&nbsp; virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

 &nbsp;&nbsp; // This interface
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE Draw(CDC* pDC,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int y) = 0;
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE SetPalette(CPalette* pPal) = 0;
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE GetRect(CRect* pRect) = 0;
};
</code></pre>
<p>
Have you spotted the problem yet? Right! How is a Visual Basic application going to pass pointers to C++ objects?</p>
<p>
So, defining COM interfaces with C++ objects as arguments wasn't too smart. What we need is an interface definition that's usable from C, C++, Visual Basic, and so on. We can achieve this by confining argument types to a set of types we can handle in every language. It turns out that in a 32-bit world, we really only need two types of arguments: a 32-bit thing and a pointer to a 32-bit thing, both of which can be handled in Visual Basic. A <b>Long</b> in Visual Basic is a 32-bit thing, and if any argument is passed using the <b>ByRef</b> modifier, we get a pointer to that argument. All Microsoft® Windows® objects can be passed as parameters using either a 32-bit value or a pointer.</p>
<p>
In order to make the <b>IDrawing</b> interface usable from Visual Basic, I redefined it as:</p>
<pre><code>class IDrawing : public IUnknown
{
public:
 &nbsp;&nbsp; // Standard IUnknown interface functions
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID* ppvObj) = 0;
 &nbsp;&nbsp; virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
 &nbsp;&nbsp; virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

 &nbsp;&nbsp; // This interface
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE Draw(HDC hDC,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int y) = 0;
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE SetPalette(HPALETTE hPal) = 0;
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE GetRect(RECT* pRect) = 0;
};
</code></pre>
<p>
Now we have an interface that uses only Windows native types, object handles (which are 32-bit values), or pointers. I modified all the other interfaces that I had defined to use no C++ classes, and rebuilt the dynamic-link libraries (DLLs) and the HOUSE application to make sure everything still worked. Having made sure the interfaces were (theoretically) callable from Visual Basic, I set about building a Visual Basic application that would create some COM objects.</p>
<h2>Creating a COM Object</h2>
<p>
COM objects are created using the <b>CoCreateInstance</b> function, which is in COMPOBJ.DLL. So the first thing I needed to do was create a function declaration of <b>CoCreateInstance</b>. Let's look at the C definition of this function:</p>
<pre><code>WINOLEAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);
</code></pre>
<p>
Breaking the arguments down, we have a reference, a pointer, a 32-bit value, a reference, and a pointer. The references are all effectively pointers, so we really have four pointers and a single 32-bit value. This seems like it will be no problem in Visual Basic. The important things to note are (1) which structures the pointers are pointing to, and (2) how possible it is to build those structures in Visual Basic. Well, the only problem with the pointers we have here is the reference to a class ID (rclsid) and the reference to the interface ID (riid). Both of these ID values are 128-bit numbers that we have to find a way to declare and initialize. Here's the structure I used for this:</p>
<pre><code>Public Type GUID
 &nbsp;&nbsp; l As Long
 &nbsp;&nbsp; w1 As Integer
 &nbsp;&nbsp; w2 As Integer
 &nbsp;&nbsp; b1 As Byte
 &nbsp;&nbsp; b2 As Byte
 &nbsp;&nbsp; b3 As Byte
 &nbsp;&nbsp; b4 As Byte
 &nbsp;&nbsp; b5 As Byte
 &nbsp;&nbsp; b6 As Byte
 &nbsp;&nbsp; b7 As Byte
 &nbsp;&nbsp; b8 As Byte
End Type
</code></pre>
<p>
To create a COM object, we will need a class ID and an interface ID, so let's define one each of those to use:</p>
<pre><code>' Standard COM interface IDs
Public IID_IUnknown As GUID

' Appliance COM object class IDs
Public CLSID_LightBulb As GUID
</code></pre>
<p>
Unfortunately, Visual Basic has no way to allow us to initialize these structures when they are declared, so I created some helper routines to simplify this:</p>
<pre><code>' Helper routine to initialize an OLE style GUID
Public Sub DefineOLEGuid(ByRef i As GUID, l As Long, w1 As Integer, w2 As Integer)
 &nbsp;&nbsp; i.l = l
 &nbsp;&nbsp; i.w1 = w1
 &nbsp;&nbsp; i.w2 = w2
 &nbsp;&nbsp; i.b1 = &amp;HC0
 &nbsp;&nbsp; i.b2 = 0
 &nbsp;&nbsp; i.b3 = 0
 &nbsp;&nbsp; i.b4 = 0
 &nbsp;&nbsp; i.b5 = 0
 &nbsp;&nbsp; i.b6 = 0
 &nbsp;&nbsp; i.b7 = 0
 &nbsp;&nbsp; i.b8 = &amp;H46
End Sub

' Helper routine to set up a GUID from its string representation
Public Sub DEFINE_GUID(ByRef cls As GUID, l As Long, w1 As Integer, w2 As Integer, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1 As Byte, b2 As Byte, b3 As Byte, b4 As Byte, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b5 As Byte, b6 As Byte, b7 As Byte, b8 As Byte)
 &nbsp;&nbsp; cls.l = l
 &nbsp;&nbsp; cls.w1 = w1
 &nbsp;&nbsp; cls.w2 = w2
 &nbsp;&nbsp; cls.b1 = b1
 &nbsp;&nbsp; cls.b2 = b2
 &nbsp;&nbsp; cls.b3 = b3
 &nbsp;&nbsp; cls.b4 = b4
 &nbsp;&nbsp; cls.b5 = b5
 &nbsp;&nbsp; cls.b6 = b6
 &nbsp;&nbsp; cls.b7 = b7
 &nbsp;&nbsp; cls.b8 = b8
End Sub
</code></pre>
<p>
Not very exciting stuff, this, but bear with me. Now we can create an initialization function that can be called when the application's main form loads:</p>
<pre><code>Public Sub InitCOMSupport()
 &nbsp;&nbsp; ' Set up the COM interface IDs.
 &nbsp;&nbsp; Call DefineOLEGuid(IID_IUnknown, 0, 0, 0)
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ' Set up the Appliance COM object class IDs and interface IDs.
 &nbsp;&nbsp; Call DEFINE_GUID(CLSID_LightBulb, &amp;H3A015B30, &amp;H41FC, &amp;H11CE, _
 &nbsp;&nbsp;&nbsp;&nbsp; &amp;H9E, &amp;HE5, 0, &amp;HAA, 0, &amp;H42, &amp;H31, &amp;HBF)
 &nbsp;&nbsp; Call DEFINE_GUID(IID_IDrawing, &amp;H15038B10, &amp;H3D3E, &amp;H11CE, &amp;H9E, _
 &nbsp;&nbsp;&nbsp;&nbsp; &amp;HE5, 0, &amp;HAA, 0, &amp;H42, &amp;H31, &amp;HBF)
End Sub
</code></pre>
<p>
The values shown here for class and interface IDs were taken from the C++ header files. When the application's main form is loaded, all class IDs are set up:</p>
<pre><code>Private Sub Form_Load()
 &nbsp;&nbsp; InitCOMSupport
End Sub
</code></pre>
<p>
Having defined the ID values, we can now create the function definition for <b>CoCreateInstance</b>:</p>
<pre><code>Public Declare Function CoCreateInstance Lib "compobj" _
 &nbsp; (ByRef rclsid As GUID, ByVal pUnkOuter As Long, _
 &nbsp; ByVal dwContent As Long, ByRef riid As GUID, _
 &nbsp; ByRef ppv As Long) As Long
</code></pre>
<p>
Now we can actually create a COM object. In my sample I added a button to the main form and put the code to create my test object in the button's click function. That way I could run the piece of test code by simply pressing the button. Here's the first part of the function that creates the object:</p>
<pre><code>Private Sub AddLightBulb_Click()
 &nbsp;&nbsp; ' Try to create a light bulb object.
 &nbsp;&nbsp; Dim hr As Long
 &nbsp;&nbsp; Dim punkLightBulb As Long
 &nbsp;&nbsp; hr = CoCreateInstance(CLSID_LightBulb, 0, CLSCTX_INPROC_SERVER, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IUnknown, punkLightBulb)
 &nbsp;&nbsp; If hr &lt; 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Failed to create light bulb. Error " + Hex(hr) + "H")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Sub
 &nbsp;&nbsp; End If
</code></pre>
<p>
CLSCTX_INPROC_SERVER is a constant taken from the OLE header files.</p>
<p>
So this doesn't look too bad so far, does it? We have managed to create a COM object from our short piece of Visual Basic code. Now what we want to do is get one of the object's interfaces and make it do something. I wanted to get the light bulb's <b>IDrawing</b> interface and tell it to draw itself onto the form's window area somewhere.</p>
<h2>Using COM Object Interfaces</h2>
<p>
Given a pointer to an object's <b>IUnknown</b> interface to get to any other interface, we need to call <b>IUnknown::QueryInterface</b>. We got the <b>IUnknown</b> pointer back when we called <b>CoCreateInstance</b>, so now all we need is a way to call <b>QueryInterface</b> through the pointer. This is where the trouble starts, because Visual Basic is a language that doesn't know too much about pointers, and it's at this point that we have to abandon Visual Basic and write some C code in a DLL to act as glue between the Visual Basic code and the COM object's interface.</p>
<p>
Given that I had to create some "glue" code to go between Visual Basic and the COM objects, I thought it would be a fine idea to try to create a kind of generic "<b>CallObjectMember</b>" function. This would certainly be possible if I were to define a Visual Basic function that took a variable argument list, and somewhere in that argument list it had information about which interface to use and which member to call. Of course, we'd also probably have to figure out what types of data were in the other arguments, too. That was way too much work for this experiment, so instead, I created a number of functions that have a fixed number of arguments. Here are the Visual Basic declarations of the various "glue" functions in my support DLL:</p>
<pre><code>Public Declare Function comQueryInterface Lib "vbsysdbg" _
 &nbsp; (ByVal punkObject As Long, ByRef riid As GUID, _
 &nbsp;&nbsp; ByRef ppv As Long) As Long
Public Declare Function comAddRef Lib "vbsysdbg" _
 &nbsp; (ByVal punkObject As Long) As Long
Public Declare Function comRelease Lib "vbsysdbg" _
 &nbsp; (ByVal punkObject As Long) As Long
Public Declare Function comCallStdMember0 Lib "vbsysdbg" _
 &nbsp; (ByVal punkObject As Long, _
 &nbsp;&nbsp; ByVal dwIndex As Long) As Long
Public Declare Function comCallStdMember1 Lib "vbsysdbg" _
 &nbsp; (ByVal punkObject As Long, _
 &nbsp;&nbsp; ByVal dwIndex As Long, ByVal dwArg1 As Long) As Long
Public Declare Function comCallStdMember2 Lib "vbsysdbg" _
 &nbsp; (ByVal punkObject As Long, _
 &nbsp;&nbsp; ByVal dwIndex As Long, ByVal dwArg1 As Long, ByVal dwArg2 As Long) _
 &nbsp;&nbsp; As Long
Public Declare Function comCallStdMember3 Lib "vbsysdbg" _
 &nbsp; (ByVal punkObject As Long, _
 &nbsp;&nbsp; ByVal dwIndex As Long, ByVal dwArg1 As Long, ByVal dwArg2 As Long, _
 &nbsp;&nbsp; ByVal dwArg3 As Long) As Long
</code></pre>
<p>
Using these functions, we can call <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> on any interface. We can also call any other interface member that takes 0, 1, 2, or 3 32-bit arguments and returns a 32-bit value—this covers most, if not all, interface functions that I care about. So although this isn't a very elegant or generic solution, it fits the bill nicely for what I want to do today. Let's see how these functions are used to get the <b>IDrawing</b> interface to the light-bulb object and then used to draw the light bulb. Here's the entire function:</p>
<pre><code>Private Sub AddLightBulb_Click()
 &nbsp;&nbsp; ' Try to create a light bulb object.
 &nbsp;&nbsp; Dim hr As Long
 &nbsp;&nbsp; Dim punkLightBulb As Long
 &nbsp;&nbsp; hr = CoCreateInstance(CLSID_LightBulb, 0, CLSCTX_INPROC_SERVER, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IUnknown, punkLightBulb)
 &nbsp;&nbsp; If hr &lt; 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Failed to create light bulb. Error " + Hex(hr) + "H")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Sub
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ' Try to get a pointer to its IDrawing interface.
 &nbsp;&nbsp; Dim pIDrawing As Long
 &nbsp;&nbsp; hr = comQueryInterface(punkLightBulb, IID_IDrawing, pIDrawing)
 &nbsp;&nbsp; If hr &lt; 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Failed to get IDrawing interface. Error " + Hex(hr) + "H")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Sub
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ' Set the palette to the palette in the image.
 &nbsp;&nbsp; hr = IDrawing_SetPalette(pIDrawing, Image1.Picture.hPal)
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ' Call IDrawing::Draw and see what we get.
 &nbsp;&nbsp; hr = IDrawing_Draw(pIDrawing, Form1.hDC, 120, 120)
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ' Finished with IDrawing interface
 &nbsp;&nbsp; hr = comRelease(pIDrawing)
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ' Finished with light bulb
 &nbsp;&nbsp; hr = comRelease(punkLightBulb)
End Sub
</code></pre>
<p>
The <b>IDrawing_SetPalette</b> and <b>IDrawing_Draw</b> functions use the <b>comCallStdMember</b> helpers:</p>
<pre><code>Public Function IDrawing_Draw(ByVal punkObject As Long, _
 &nbsp;&nbsp; ByVal hDC As Long, ByVal x As Long, ByVal y As Long) As Long
 &nbsp;&nbsp; IDrawing_Draw = comCallStdMember3(punkObject, 3, hDC, x, y)
End Function

Public Function IDrawing_SetPalette(ByVal punkObject As Long, ByVal hPal) As Long
 &nbsp;&nbsp; IDrawing_SetPalette = comCallStdMember1(punkObject, 4, hPal)
End Function
</code></pre>
<p>
You can see that for any COM interface, we can create some Visual Basic functions that call the COM object's members via these helper routines.</p>
<h2>The Support DLL</h2>
<p>
The support DLL was created using Visual C++ as an MFC-based AppWizard DLL. The source code is in the VBSYSDBG subdirectory. This DLL provides two things: glue for Visual Basic to call COM object interfaces, and a debug window that shows what's going on when its being used.</p>
<p>
Two files contain 99 percent of the interesting material: COMFNS.CPP, which has the implementation of the glue code, and VBSYSDBG.DEF, which has the definitions of the exported functions:</p>
<pre><code>; VBSysDbg.def : Declares the module parameters for the DLL.

LIBRARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VBSYSDBG
DESCRIPTION&nbsp; 'VBSYSDBG Windows Dynamic Link Library'

EXPORTS
 &nbsp;&nbsp; ; Explicit exports can go here
 &nbsp;&nbsp; CoCreateInstance = vbCoCreateInstance
 &nbsp;&nbsp; comQueryInterface
 &nbsp;&nbsp; comAddRef
 &nbsp;&nbsp; comRelease
 &nbsp;&nbsp; comCallStdMember0
 &nbsp;&nbsp; comCallStdMember1
 &nbsp;&nbsp; comCallStdMember2
 &nbsp;&nbsp; comCallStdMember3
</code></pre>
<p>
As you can see, each of the glue functions is named here. <b>CoCreateInstance</b> is actually implemented in a function called <b>vbCoCreateInstance</b> so as to avoid a name conflict with the "real" function in my C code.</p>
<p>
The only reason for implementing <b>CoCreateInstance</b> at all here is so I can watch the calls in the debug window. Here's how:</p>
<pre><code>STDAPI vbCoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv)
{
 &nbsp;&nbsp; // Say what we're about to call.
 &nbsp;&nbsp; dprintf2("CoCreateInstance()");
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Maybe print the arguments.
 &nbsp;&nbsp; dprintf3("&nbsp; CLSID %8.8lX-%4.4X-%4.4X-%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rclsid.Data1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rclsid.Data2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rclsid.Data3,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rclsid.Data4[0], rclsid.Data4[1], rclsid.Data4[2], rclsid.Data4[3],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rclsid.Data4[4], rclsid.Data4[5], rclsid.Data4[6], rclsid.Data4[7]);
 &nbsp;&nbsp; dprintf3("&nbsp; pUnkOuter %8.8lXH", pUnkOuter);
 &nbsp;&nbsp; dprintf3("&nbsp; dwClsContext %8.8lXH", dwClsContext);
 &nbsp;&nbsp; dprintf3("&nbsp; IID %8.8lX-%4.4X-%4.4X-%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; riid.Data1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; riid.Data2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; riid.Data3,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);
 &nbsp;&nbsp; dprintf3("&nbsp; ppv %8.8lXH", ppv);

 &nbsp;&nbsp; // Call the function.
 &nbsp;&nbsp; HRESULT hr = CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // If it failed, print a message.
 &nbsp;&nbsp; if (FAILED(hr)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dprintf1("CoCreateInstance failed: %8.8lXH", hr);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Return the result.
 &nbsp;&nbsp; return hr;
}
</code></pre>
<p>
Boy, that sure looks like a lot of code—until you notice that almost all of it deals with printing the parameters out into the debug window (via the <b>dprintf</b> macros). If you cut out the debug code, it is simply a pass-through to the real <b>CoCreateInstance</b> function in the COMPOBJ DLL.</p>
<p>
Let's take a look at one of the functions that calls an interface member:</p>
<pre><code>STDAPI comCallStdMember3(IUnknown* pInterface, DWORD dwIndex, DWORD dwArg1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwArg2, DWORD dwArg3)
{
 &nbsp;&nbsp; dprintf2("comCallStdMember3");

 &nbsp;&nbsp; if (!pInterface) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dprintf1("Invalid args");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_INVALIDARG;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; dprintf3("&nbsp; pInterface %8.8lXH", pInterface);
 &nbsp;&nbsp; dprintf3("&nbsp; dwIndex %8.8lXH", dwIndex);
 &nbsp;&nbsp; dprintf3("&nbsp; dwArg1 %8.8lXH", dwArg1);
 &nbsp;&nbsp; dprintf3("&nbsp; dwArg2 %8.8lXH", dwArg2);
 &nbsp;&nbsp; dprintf3("&nbsp; dwArg3 %8.8lXH", dwArg3);

 &nbsp;&nbsp; POBJIFACE pObjIface = (POBJIFACE)pInterface;
 &nbsp;&nbsp; PVTABLE pVtable = *pObjIface;
 &nbsp;&nbsp; METHOD3* pMethod = (METHOD3*)pVtable[dwIndex];
 &nbsp;&nbsp; HRESULT hr = pMethod(pInterface, dwArg1, dwArg2, dwArg3);
 &nbsp;&nbsp; if (FAILED(hr)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dprintf1("comCallStdMember3 failed: %8.8lXH", hr);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return hr;
}
</code></pre>
<p>
Again, there's a lot of code here to send stuff to the debug window, but mostly what it does is take the interface pointer and the offset of the interface member function in the COM object's vtable and call the function through the pointer in the correct table entry location.</p>
<h2>Summary</h2>
<p>
You can use Visual Basic and some glue code to create and manipulate COM objects, but it needs some C support code and isn't very robust. If you get the parameters to a call mixed up, all sorts of problems will come your way. You need to create helper functions for each member of each interface you use in order to simplify the Visual Basic code (rather than calling <b>comCallStdMember...</b> directly). On top of this, it's possible that for some interface member functions, you will have to create more specific C glue code.</p>
<p>
So, although you can create and use COM objects directly from Visual Basic, it's certainly not trivial to do so. In a later article, I'll be looking at adding OLE Automation support to COM objects, which will greatly simplify their use from Visual Basic.</p>
</BODY>
</HTML>
