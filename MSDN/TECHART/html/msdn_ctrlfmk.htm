<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ActiveX Controls Framework: Sample Code for Authoring Non-MFC Controls</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_ctrlfmk"></a></sup>ActiveX Controls Framework: Sample Code for Authoring Non-MFC Controls</h1>
<p>
Updated: April 1996</p>
<p>
Marc Wandschneider <br>
Microsoft Corporation</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This document is an early release of the final specification. It is meant to specify and accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final specification or software. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies. Microsoft may have trademarks, copyrights, patents or pending patent applications, or other intellectual property rights covering subject matter in this document. The furnishing of this document does not give you a license to these trademarks, copyrights, patents, or other intellectual property rights.</p>
<h4>Contents:</h4>
<p>
1.&nbsp; <a href="#ctrlfmk_intro">Introduction</a><br>
2.&nbsp; <a href="#ctrlfmk_create">Creating an ActiveX Control</a><br>
3.&nbsp; <a href="#ctrlfmk_working">Working with Your ActiveX Control</a><br>
4.&nbsp; <a href="#ctrlfmk_persist">Persistence</a><br>
5.&nbsp; <a href="#ctrlfmk_proppage">Property Pages</a><br>
6.&nbsp; <a href="#ctrlfmk_string">String Manipulation</a><br>
7.&nbsp; <a href="#ctrlfmk_local">Localization</a><br>
8.&nbsp; <a href="#ctrlfmk_misc">Miscellaneous</a><br>
</p>
<h2><a name="ctrlfmk_intro"></a>1. Introduction</h2>
<p>
The ActiveX™ Controls Framework is a sample code base from which one can author new ActiveX controls for use in existing containers, such as Microsoft® Visual Basic®, Microsoft Access®, and Microsoft Visual FoxPro™, or in future containers of ActiveX controls.</p>
<p>
This Framework differs from the Microsoft Visual C++® Control Developer's Kit (CDK) in many ways. Most notably, it's intended to be considerably more "bare bones." Only minimal functionality is provided to the developer. Little in the way of default handlers for various Windows® messages, ActiveX events, and similar items, has been provided. The ability to add them is there, but the code is not. The Framework's code base has also been designed primarily for performance and reduced code size as much as possible. Whenever a choice between ease of use and performance arose, the latter was typically chosen.</p>
<p>
The code base is extremely extensible, however, and all the source code is there—if something doesn't do what you want it to, you can access the source code and make it happen.</p>
<h3>1.1 Target Audience</h3>
<p>
This Framework targets slightly more advanced developers than the Microsoft Visual C++ Control Developer's Kit. Specifically, they will be required to understand some of the fundamentals of ActiveX automation and dual interfaces. Developers will have to be able to understand and modify an .ODL file on their own. In addition, they will be required to understand and be able to work with ActiveX persistence interfaces, most notably <b>IStream</b> and <b>IPersistStream</b>. However, if it is not desired, developers will not be required to have much knowledge of ActiveX embedding interfaces.</p>
<p>
Developers who do not have specific performance requirements, those who are not familiar with many of the pertinent ActiveX™ technologies, or those who work primarily with the Microsoft Foundation Classes (MFC) will find the Microsoft Foundation Classes Control Developer's Kit far more suited to their needs.</p>
<h3>1.2 Structure of the Framework</h3>
<p>
The directory structure of the ActiveX controls Framework is as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;Controls +
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \AutoSample&nbsp;&nbsp;&nbsp; +
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Debug
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Release
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Button&nbsp;&nbsp;&nbsp; +
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Debug
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Release
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Circle&nbsp;&nbsp;&nbsp; +
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Debug
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Release
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \FontColor&nbsp;&nbsp;&nbsp; +
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Debug
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Release
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Framewrk&nbsp;&nbsp;&nbsp; +
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Debug
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Release
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Include
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Invisible&nbsp;&nbsp;&nbsp; +
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Debug
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Release
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Localize&nbsp;&nbsp;&nbsp; +
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Debug
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Release
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \French
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Template
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- \Wizards
</code></pre>
<p>
The Controls\Framewrk and Controls\Include directories contain the core code for writing an ActiveX control. The Controls\Include directory contains the headers from which most controls will get their information, and the Controls\Framewrk directory contains the core functionality (in the <b>COleControl</b> class) that compiles into a library (.LIB) form.</p>
<p>
In addition, the Controls\Wizards and Controls\Template directories contain the files necessary to generate a control. In the Controls\Wizards directory is a Microsoft Visual Basic 4.0 project, CtlWiz.Vbp. Running this project under Visual Basic 4.0 will generate a skeleton control that will compile right away. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This wizard basically assumes that you're going to place the control in the Controls directory—most of the paths generated are relative and will look for the Controls\Framewrk directory in ...\Framewrk.</p>
<p>
A few samples are provided with the Framework: 
<ul type=disc>
<li>
The Circle sample demonstrates the most trivial of ActiveX controls—it has no interesting properties, no property pages, and only draws a green circle.<br><br></li>
<li>
The Button sample demonstrates how to write a simple, subclassed Windows control, how to change various properties on it, and how to fire events in response to Windows events.<br><br></li>
<li>
The Invisible sample shows how to write an "Invisible at Run Time" control.<br><br></li>
<li>
The Localize sample demonstrates how to support satellite DLL localization in your server.<br><br></li>
<li>
The AutoSample demonstrates how to write an ActiveX automation server, which this Framework supports. To create an automation server, you should run Controls\Wizards\AutoWiz.Vbp.<br><br></li>
<li>
Finally, the FontColor sample demonstrates how to get around an ActiveX automation problem by using properties of types from imported type libraries. (See Section 3, "<a href="#ctrlfmk_working">Working with Your ActiveX Control"</a>, for more information.)</li>
</ul>
<h3>1.3 Target Environment</h3>
<p>
This Framework was developed assuming that you have the Microsoft Visual C++ 4.0 toolset in your path. The MAKECTL.INC and TOOLS.INC files in the Controls\Include directory use various tools from that toolset. In addition, the various wizards assume you have UUIDGEN.EXE, which is included in the Microsoft Win32® Software Development Kit (SDK) as well as in Visual C++ 4.0. If you are using a different environment, it should be fairly easy to change the variables to work with the Visual C++ 4.0 toolset instead. If you have only the Visual C++ 2.<i>x</i> tools and headers in your path, you will get various compile errors.</p>
<p>
All of the makefiles and build processes are command-line based. Various people have reported, however, that integrating these files and processes into their favorite environments is an easy task.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Under Windows 95, Visual C++ will not, by default, register its environment variables to set up for command-line builds. To enable command-line building under Windows 95, you'll either have to <b>chdir </b>C:\MSDEV\BIN and type "vcvars32 x86" to set up your environment variables, or include the above file in your AUTOEXEC.BAT file. Occasionally, you will get "Out of Environment Space" messages when doing this. In the Properties dialog box for the Command Prompt, you can increase the size of the environment from "Auto" to some number like 1024 to take care of the problem. None of this should happen when developing under Windows NT™ Workstation.</p>
<p>
The DWINVERS.H file in Controls\Framewrk contains version and copyright information that should be updated each time you run your builds. The Framework does not do this for you.</p>
<h2><a name="ctrlfmk_create"></a>2. Creating an ActiveX Control</h2>
<p>
Creating an ActiveX control using this Framework isn't a terribly difficult task. The provided wizards will do most of the work for you, but we'll briefly go into the process here. Using the sample code as a template should fill in any holes.</p>
<p>
The Framework implements the core functionality in a few C++ classes, notably <b>CAutomationObject</b>, <b>COleControl</b> (which inherits from <b>CAutomationObject</b>), and <b>CPropertyPage</b>. All objects inherit from <b>CUnknownObject</b>, which provides the support for aggregation.</p>
<p>
So, to write an ActiveX control, you need to declare a new object that inherits from <b>COleControl</b>. In addition, you'll need to inherit from some sort of ActiveX automation interface that describes the properties and methods for your control, for example, <b>IMyControl</b>. This interface description is generated by MKTYPLIB and will be put in an output file created by MKTYPLIB (the wizard sets up an environment in which this file is named MYCONTROLINTERFACES.h). <b>COleControl</b> has a number of virtual methods that are declared as pure, which you must implement in your control class. These include <b>WindowProc</b>, <b>LoadBinaryState</b>, <b>LoadTextState</b>, <b>SaveBinaryState</b>, <b>SaveTextState</b>, <b>OnDraw</b>, and <b>RegisterClassData</b>.</p>
<p>
To write a property page, you declare a new object that inherits from <b>CPropertyPage</b>. This object must implement a <b>DialogProc</b>. You can also implement automation objects and collections by declaring a new object that inherits from <b>CAutomationObject</b>.</p>
<p>
Because an ActiveX control is an in-process ActiveX server, you also need one file to describe all your objects, whether they are controls, automation objects, or property pages. This file should contain a table of all objects and details about each object. In addition, the file should have information on what sort of localization your server would like to use, and what sort of licensing support you'd like to have.</p>
<p>
Finally, you'll need a resource file, an .ODL file to describe your interfaces and event interfaces, a .DEF file for your linking information, and a file to define all the GUIDs that have been declared.</p>
<p>
Although it is possible to use a sample control as a template for all this information, using the wizard to create a new control remains the easiest method.</p>
<h3>2.1 Using the Control Wizard</h3>
<p>
The Control wizard is a simple Visual Basic 4.0 program that can be used to create a new ActiveX control project. It is not the most robust program, and will usually just abort if something odd comes up, but it will save you a considerable amount of time in the beginning.</p>
<p>
We will now walk through a sample to create a control. We will assume that the Framework lies in C:\Controls, and we will create a subclassed scrollbar control.</p>
<p>
First, start up Visual Basic 4.0, and run CTLWIZ.VBP. The Control Wizard will ask for the name of your new control. For this example, we will use "SuperScroll." Select the option to subclass a Windows control, and use satellite localization, because foreign markets are important to us. Do not select the option to avoid long filenames.</p>
<p>
On the next screen, from the combo box, select the SCROLLBAR window class. After that, specify C:\Controls\SuperScroll as the directory for your project. (Please note that the end project generated by this wizard will build correctly only if you choose to put it in a subdirectory of your Framework root, for example, C:\Controls.) Finally, you will be asked for the location of the Template files. Enter C:\Controls\Template.</p>
<p>
The Control wizard will then generate your project, assuming that UUIDGEN.EXE is somewhere in your path. This is not the speediest of processes—on a 486/66 megahertz machine, it takes about 30 seconds.</p>
<h3>2.2 Building the Control</h3>
<p>
To build your control, you first need to generate the libraries for the Framework files. The libraries are not automatically generated; this allows you to modify the libraries if desired. To do this, simply go to the Controls\Framewrk directory, and type "make dep all" in each of the Debug and Release subdirectories. You will need to recompile the Framework files only if you change a file in the Controls\Include or Controls\Framewrk directories.</p>
<p>
Once the Framework files have been built, go back to your control's \Debug and/or \Release subdirectories, and type "make dep all" there. This will build your control.</p>
<h3>2.3 Working with the In-Process Server</h3>
<p>
Your ActiveX control, any property pages, and automation objects are all ActiveX COM objects in an in-process server. These objects must be declared in a global table, <b>g_ObjectInfo</b>, which is found in the main in-process server file. Each object is declared with a wrapper, either CONTROLOBJECT, PROPERTYPAGE, or AUTOMATIONOBJECT. The name of the object is entered as an argument to the macro. In the header file where you declare the COM object, you'll need to use DEFINE_PROPERTYPAGEOBJECT, DEFINE_CONTROLOBJECT, or DEFINE_AUTOMATIONOBJECT to declare the object for use in the global table. If you are declaring objects that aren't creatable from a class factory, they still need to be declared in the global table, but the Creation function specified in the structure should be NULL.</p>
<p>
There is some additional information that must be put in the file for the in-process server. The LIBID of the type library (.TLB) must be put in the global variable <i>g_pLibid</i>. You must indicate what sort of localization your control supports by using the variables <i>g_fSatelliteLocalization</i> and <i>g_lcidLocale</i>. See Section 7, "<a href="#ctrlfmk_local">Localization"</a>, for more information.</p>
<p>
You can put code in five of the routines in your in-process server file. The first two, <b>InitializeLibrary()</b> and <b>UninitializeLibrary()</b>, are called when the DLL is first loaded into and unloaded from memory. This is a good place to do any initialization that can't be delayed. It is worth noting that for performance reasons, delaying the initialization as long as possible is often a good idea. The <b>CheckForLicense</b> function lets the control decide if it is licensed to run. The global variables <i>g_wszLicenseKey</i> and <i>g_wszLicenseLocation</i> describe the license key and its location in the registry. If you don't wish to bother with licensing, you can leave all of the above untouched.</p>
<p>
The <b>RegisterData</b> and <b>UnregisterData</b> routines are called from <b>DllRegisterServer</b> and <b>DllUnregisterServer</b>, and can be used to register and clean up additional information in the registry.</p>
<p>
Finally, two small pieces of code are included in the in-process server file so that your project does not have to link with any of the C run-time libraries. This typically results in smaller DLL size, and can help with performance. If you want to link with the C run-time libraries or the CRTDLL libraries, you can remove these pieces of code from the in-process server file.</p>
<h2><a name="ctrlfmk_working"></a>3. Working with Your ActiveX Control</h2>
<p>
Once you have your control up and running, you'll want to start extending its functionality. The first thing to note is that your control is, in many ways, similar to a window in Microsoft Windows. You have an HWND, you have a <b>WindowProc</b>, and you have to paint the client area yourself using Windows drawing APIs and handles to device contexts (DCs).</p>
<h3>3.1 Structure of a Control</h3>
<p>
Every control in this Framework must implement a core set of methods, based on creation semantics and methods that <b>COleControl</b> does not provide. You may also wish to override and provide implementations for several routines. The following describes of many of these methods and routines:
<ul type=disc>
<li>
<b>Static Create()</b> function. This routine is generated for you by the Control wizard. Every control must create its control object in this routine, and then return a pointer to its private <b>Unknown</b> (for aggregation support).<br><br></li>
<li>
<b>Constructor</b> and <b>Destructor</b>. These routines are also generated for you, and a control should initialize anything here. Controls should try to minimize the amount of work that is done here to help prevent load time from degrading unacceptably.<br><br></li>
<li>
<b>RegisterClassData()</b>. All controls must implement this routine. This routine will be called only the first time a control of a given type is loaded in a process. Controls should register their window class (using <b>RegisterClass</b> and the <b>WNDCLASS</b> structure) here. In addition, subclassed Windows controls should get a pointer to the parent control's <b>WindowProc</b> and set it up in the <b>g_ObjectInfo</b> table using the <b>SUBCLASSWNDPROCOFCONTROL()</b> macro. See the Button and Circle control samples (downloadable from the Framework abstract) for examples of how this is done. Invisible at Run Time controls should return FALSE in this routine, because it should never be called by them.<br><br></li>
<li>
<b>BeforeCreateWindow()</b> and <b>AfterCreateWindow()</b> are not mandatory to implement, but are extremely interesting routines. <b>BeforeCreateWindow()</b> is called right before the call to <b>CreateWindow()</b>, but after persistent state has been loaded. Controls should use this opportunity to set the window title for their control in <i>m_szWindowTitle</i>, and can also set up bits in <i>m_dwWindowStyle</i> and <i>m_dwWindowStyleEx</i> for calls to <b>CreateWindowEx</b>. Doing this work here instead of in the WM_CREATE message handler typically results in better performance.<br><br></li>
<li>
<b>InternalQueryInterface()</b>. Your control implements this to support the <b>QueryInterface</b> (QI) for the control's primary dispatch interface, such as <b>IMyControl</b>. You can also use this method to support additional interfaces in your control. For example, if you want to support <b>IPerPropertyBrowsing</b>, you'd have your control's <b>CMyControl</b> class inherit from <b>IPerPropertyBrowsing</b>, and support the <b>QueryInterface</b> for <b>IID_IPerPropertyBrowsing</b> in <b>InternalQueryInterface</b>. If the control fails the QI, the control should delegate back to <b>COleControl::InternalQueryInterface</b> to see if it likes the IID.<br><br></li>
<li>
<b>LoadTextState</b>, <b>LoadBinaryState</b>, <b>SaveTextState</b>, and <b>SaveBinaryState</b>. All controls must implement these persistence interfaces. See Section 4, "Persistence", for a discussion of these interfaces.<br><br></li>
<li>
<b>OnDraw</b>. This routine is called when your control is expected to draw itself. In Design mode, this call will originate from a container calling <b>IViewObject2::Draw</b>. In run mode, the controls Framework will intercept the WM_PAINT message, and will translate it into a call to your <b>OnDraw</b> routine. See Section 3.2, "Painting a Control", for more information on this routine.<br><br></li>
<li>
<b>WindowProc</b>. Messages that are not handled in the Framework code (such as <b>SimpleFrame</b> messages and WM_PAINT), are sent to your control here. Your control should deal with them here. See Section 3.3, "Handling Messages in a Control", for a discussion of this routine. In addition, please see the description below of <b>OnSpecialKey</b> for more information.<br><br></li>
<li>
<b>OnSpecialKey</b>. Messages for various keyboard events, such as moving the cursor keys, function keys, and other non-standard keys, do not go to the <b>WindowProc</b>. Instead, they are sent to the <b>OnSpecialKey</b> routine. If you want your control to handle special keys and accelerators, you should override and implement this routine. The control should return TRUE if it handles a key, or FALSE if it ignores the key.<br><br></li>
<li>
<b>DoCustomVerb</b>. If you choose to have your control implement custom verbs in addition to the property page verb that is provided by default (if your control has a property page), you should implement <b>DoCustomVerb</b> and take appropriate action depending on which verb was sent in. <b>DoCustomVerb</b> returns OLEOBJ_S_INVALIDVERB if it doesn't recognize the verb given.<br><br></li>
<li>
<b>OnSetExtent</b>. This is called every time your control is resized. The <b><i>m_Size SIZEL</i></b> structure is your control's current size in pixels. Controls should look in here for their size information and override <b>OnSetExtent</b> if they want to regulate how their control is sized. Please see the Invisible sample (downloadable from the Framework abstract) for an example of a fixed-site control.</li>
</ul>
<p>
In addition, the following methods/routines can be called by the ActiveX control, and often prove to be extremely useful:
<ul type=disc>
<li>
<b>DoSuperClassPaint</b>. Subclassed Windows controls can call <b>DoSuperClassPaint</b> from their <b>OnDraw</b> routines to paint themselves. For most Windows controls, this routine will paint them correctly in design mode and run mode. Some Windows controls, however, will prove somewhat moody, and might require a little extra tweaking.<br><br></li>
<li>
<b>RecreateControlWindow</b>. Used for subclassed controls—will go and recreate the control's <i>hWnd</i>. This is useful if the control is changing a style bit that can't be changed with a <b>SetWindowLong(GWL_STYLE ...)</b> call.<br><br></li>
<li>
<b>DesignMode</b>. Returns a BOOL indicating its best guess as to whether the environment is in design mode. If it can't determine that, it will return FALSE.<br><br></li>
<li>
<b>GetAmbientProperty</b>. This routine is used to get an ambient property from the container. Not all containers will return these (they might not support ambient properties), so be careful to check the return code.<br><br></li>
<li>
<b>GetAmbientFont</b>. Gets the current ambient font. Don't forget to release the font once you're done with it. The container may not implement this.<br><br></li>
<li>
<b>ModalDialog</b>. Controls must call this before they show a modal dialog box. This is seen when the control is about to show its About dialog box.<br><br></li>
<li>
<b>InvalidateControl</b>. Much like the <b>InvalidateRect</b> API, but this also operates in design mode. It will force the control to be repainted if you pass in NULL for the rectangle, or will invalidate the given area if it's not NULL.<br><br></li>
<li>
<b>SetControlSize</b>. Controls that are changing their size out of <b>OnSetExtent</b> should use this routine to set their size. The control passes in a <b>SIZEL</b> structure in PIXELS, and should expect a call to <b>OnSetExtent</b>. Be careful of some recursive situations.<br><br></li>
<li>
<b>PropertyChanged</b>. Whenever the value of a property changes, this routine should be called to notify a host. It will cause hosts to update any property browsers (such as those seen in Microsoft Visual Basic 4.0).<br><br></li>
<li>
<b>RequestPropertyEdit</b>. Whenever the control wants to change a property that is marked as <b>requestedit</b> in the .ODL file, the control will need to call this first, and check the return code.<br><br></li>
<li>
<b>GetResourceHandle</b>. Controls should call this whenever they're loading a resource that could be localized. This routine will get the handle to the appropriate DLL, and deal with satellite DLLs or the lack thereof. Please see the Localize sample (downloadable from the Framework abstract) for how this works.<br><br></li>
<li>
<b>FireEvent</b>. The control will pass this routine an <b>EVENTINFO</b> structure, and an event as described in <b>EVENTINFO</b> will be fired. The control will also pass parameters to this routine, as it is a <b>varargs</b> method.<br><br></li>
<li>
<b>ControlFromUnknown</b>. In property page code, it is often useful to get the <b>COleControl</b> <b>*</b> pointer from the <b>IUnknown</b> for a control object. This routine does just that.<br><br></li>
<li>
<b>Exception</b>. Your control (or any automation object) can use this to send the user an error message. Please see Section 3.8, "Throwing an Exception", for more information on using this routine.</li>
</ul>
<h3>3.2 Painting a Control</h3>
<p>
The <b>OnDraw</b> routine is called whenever the control needs to paint. Sometimes the call is from <b>IViewObject2::Draw</b> (as in design mode), and other times it comes from being sent a WM_PAINT message (as handled in <b>ControlWindowProc</b>).</p>
<p>
Your control is given a DC, a rectangle to describe where to paint, a rectangle for describing a metafile, and an Information Context (IC, passed in as an HDC) that describes the device. If the device is a metafile, the control must perform slightly different work. However, if the device is a raster display, the control is typically painting to the screen.</p>
<p>
Your control must be careful not to make any assumptions about the DC, except that it will be in MM_TEXT mapping mode. Often, there will be no default pens, brushes, fonts, or colors selected into the DC. Your control will have to do this work. This will typically manifest itself by having your control look slightly different in design and run modes.</p>
<h3>3.3 Handling Messages in a Control</h3>
<p>
Your control has a method called <b>WindowProc</b>, which is called whenever a message is sent to your control. Your control should respond to messages in the desired fashion here. Again, try to reduce the amount of work that is done in the WM_CREATE message handler, and see if it can be put in <b>BeforeCreateWindow()</b>.</p>
<p>
For certain types of messages, such as keyboard messages for arrow keys and other special keys, <b>OnSpecialKey</b> is called instead of <b>WindowProc.</b> The code in <b>OnSpecialKey</b> should look for WM_KEYDOWN/UP, WM_CHAR, and other messages, and deal with them appropriately.</p>
<p>
A certain class of messages typically involves notifying a window about happenings that are usually sent to a window's parent. These include WM_COMMAND, WM_NOTIFY, WM_CTLCOLOR, and others. These messages will be reflected by the host to your control in the form of OCM_COMMAND, OCM_NOTIFY, OCM_CTLCOLOR, and so on. Your controls should look for these messages instead of WM_COMMAND, and the other WM_ messages. Please see OLECTL.H for other OCM_ messages that the control might be interested in.</p>
<h3>3.4 Adding a Property</h3>
<p>
One of the more important parts of a control is its set of properties. When you create a control with the wizard, you have no properties by default. Adding them is a relatively straightforward and simple process.</p>
<p>
First, you need to modify the primary dispatch interface for your control in the .ODL file. Let's say you have a control called SuperScroll, and you'd like to add a <b>LargeChange </b>method to the control. You'd add the following to the <b>ISuperScroll</b> interface description in the .ODL:</p>
<pre><code>[id(DISPID_LARGECHANGE), propget, helpstring("The largechange property")]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT LargeChange([out, retval] long *plLargeChange);
 &nbsp;&nbsp; [id(DISPID_LARGECHANGE), propput]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT LargeChange([in] long lLargeChange);
</code></pre>
<p>
DISPID_LARGECHANGE is something that you define in DISPIDS.H. You then regenerate the type library (.TLB) file by typing:</p>
<pre><code>make SuperScroll.TLB
</code></pre>
<p>
More importantly, this regenerates SUPERSCROLLINTERFACES.H. You can then cut and paste the following two lines from SUPERSCROLLINTERFACES.H:</p>
<pre><code>STDMETHOD(get_LargeChange)(THIS_ long FAR* plLargeChange) PURE;
 &nbsp;&nbsp; STDMETHOD(put_LargeChange)(THIS_ long lLargeChange) PURE;
</code></pre>
<p>
Take these two lines and add them to your class description for <b>CSuperScroll</b>, and make sure that you remove the PURE declarators at the end; for example:</p>
<pre><code>STDMETHOD(get_LargeChange)(long FAR* plLargeChange);
 &nbsp;&nbsp; STDMETHOD(put_LargeChange)(long lLargeChange);
</code></pre>
<p>
You can now implement these methods in your control file to implement your property.</p>
<p>
Please note that OLECTL.H defines a few standard DISPIDs for you. Whenever you want to declare a property, take a look in this header first to see if there is a standard DISPID for it.</p>
<h3>3.5 Adding a Method</h3>
<p>
Adding a method is much like adding a property to your control: You define a DISPID for the method, then you add the method to the primary interface for your control. Controls generated with the Control wizard will already have an About method defined for them. Let's say we'd like to define a method called <b>MooCow</b>, with three parameters, the last of which is optional. Here is one such method:</p>
<pre><code>[id(DISPID_MOOCOW), helpstring("Makes your Cow moo")]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT MooCow([in] long lSeconds, [in] boolean fLowPitch,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in, optional] VARIANT vPitch);
</code></pre>
<p>
Again, as with properties, you regenerate the type library, and then paste the declaration into your control header (without the PURE declarator) and implement it.</p>
<h3>3.6 Adding an Event</h3>
<p>
In many situations, a control will want to fire an event. For example, when a control gets a WM_?BUTTONDOWN message, it often makes sense to fire a MouseDown event. This turns out to be surprisingly easy.</p>
<p>
First, the event must be defined in an <b>EVENTINFO</b> structure. There are many ways to do this, including declaring a new global variable for each event type, or using an array. We will talk about the latter, since it's a little neater. Let's say you want to have KeyDown, KeyUp, and KeyPushed events. Here's how you might declare them:</p>
<pre><code>typedef enum {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyCtlEvent_KeyDown = 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyCtlEvent_KeyUp = 1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyCtlEvent_KeyPushed = 2
 &nbsp;&nbsp; } MYCTLEVENTS;

 &nbsp;&nbsp; VARTYPE rgI2 [] = { VT_I2 };

 &nbsp;&nbsp; EVENTINFO m_rgMyCtlEvents [] = {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { DISPID_KEYDOWN, 1, rgI2 },
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { DISPID_KEYUP, 1, rgI2 },
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { DISPID_KEYPUSHED, 1, rgI2 }
 &nbsp;&nbsp; };
</code></pre>
<p>
The <b>EVENTINFO</b> structure has three members: the DISPID of the event, the count of arguments in the event, and a pointer to an array of VARTYPEs that describe the types of parameters to the event. Please note that there are many DISPIDs defined for you in OLECTL.H. Before adding an event, check OLECTL.H to see whether there's already a DISPID for the event.</p>
<p>
To fire the added events from code, just call the following:</p>
<pre><code>FireEvent(&amp;(m_rgMyCtlEvents[MyCtlEvent_KeyDown]), sKeyValue);
</code></pre>
<h3>3.7 Using Standard ActiveX Types</h3>
<p>
For many controls, you will find it useful to declare properties of types provided by ActiveX, such as Font, Picture, and Color. Many hosts will detect properties of these types and put up convenient browsers for the user to select values for these types.</p>
<p>
To declare a property of these types, you must first make sure the .ODL includes the following at the top:</p>
<pre><code>importlib(STDTYPE_TLB);
</code></pre>
<p>
Then, to declare a specific property of type Font, Picture, or Color, you would do something similar to the following:</p>
<pre><code>[id(DISPID_FONT), propget]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT Font([out, retval] IFontDisp **ppFont);
 &nbsp;&nbsp; [id(DISPID_FONT), propputref]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT Font([in] IFontDisp *pFont);

 &nbsp;&nbsp; [id(DISPID_MOUSEICON), propget]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT MouseIcon([out, retval] IPictureDisp **ppMouseIcon);
 &nbsp;&nbsp; [id(DISPID_MOUSEICON), propput]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT MouseIcon([in] IPictureDisp *pMouseIcon);

 &nbsp;&nbsp; [id(DISPID_FORECOLOR), propget]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT ForeColor([out, retval] OLE_COLOR *pocForeColor);
 &nbsp;&nbsp; [id(DISPID_FORECOLOR), propputref]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT ForeColor([in] OLE_COLOR ocForeColor);
</code></pre>
<p>
For the <i>get_</i> and <i>put_</i> methods for these types, the control will get a property as declared above. For fonts and pictures, the control will probably want to <b>QueryInterface</b> these for <b>IFont</b> and <b>IPicture</b>, respectively. See the FontColor control sample (downloadable from the Framework abstract) for an example of how this is done.</p>
<p>
The Microsoft Development Library CD contains some very good descriptions of how to use these fonts in your application. For an example, see the topics "Standard Font Type," "Standard Picture Type," and "Standard Color Type" in the <i>OLE Control Developer’s Kit</i>. The following is a short summary:
<ul type=disc>
<li>
To use a font object in your control, the control will typically call the <b>get_hFont</b> method, and pass the resulting HFONT to the control's DC. Pictures will be much the same.<br><br></li>
<li>
To use a color, the control will want to call <b>OleTranslateColor</b> to convert it to a real COLORREF. OLE_COLORs are basically COLORREFs with some support for "generic" colors, such as COLOR_WINDOW, COLOR_WINDOWTEXT, and others. To convert one of these into an OLE_COLOR, just OR (|) them with 0x80000000. For example, to initialize the control's background to COLOR_WINDOW, set the backcolor property to COLOR_WINDOW | 0x80000000. Then, to paint the backdrop, just call <b>OleTranslateColor()</b>, and use the resulting <i>colorref</i>.</li>
</ul>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The Framework uses dual/vtable-bound automation interfaces, and uses ActiveX automation functionality to support <b>IDispatch</b> methods on the automation objects. A known problem in ActiveX automation causes unexpected failures and/or crashes when using the provided <b>ITypeInfo::Invoke</b> on properties that are declared to be of types that are imported from a type library. (For example, any font, picture, or color property has this problem.) The way to get around this problem is to override <b>Invoke()</b> and to look for the DISPIDs of the control's properties that are of this type. In this case, the control can quickly dispatch the call to the appropriate member function. The FontColor sample does just this. See its implementation of <b>IDispatch::Invoke</b> for sample workaround code. This problem will not exist in future versions of ActiveX automation, but until then, the workaround is necessary—and fortunately not terribly difficult.</p>
<h3>3.8 Throwing an Exception</h3>
<p>
Every once in a while, during an operation, your control will find itself rather upset with the state of the union, and will wish to communicate this to the user via an exception. In any of the control's ActiveX automation methods or property operators, the control can call the Exception method when exiting, and the method will set up the appropriate information to trigger the error.</p>
<p>
For example:</p>
<pre><code>CMyControl::put_Eek(long lEek)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lEek == 10)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Exception(MYCTL_E_IHATETHENUMBER10, IDS_ERR_IHATETHENUMBER10, 0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_lEek = lEek;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return S_OK;
 &nbsp;&nbsp; }
</code></pre>
<p>
The Exception routine has three arguments:
<ul type=disc>
<li>
The <i>scode</i> of the error the control wishes to trigger. Define errors unique to the control somewhat like this:<pre><code>#define MYCTL_E_IHATETHENUMBER10 MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 34500)
</code></pre>
</li>
<li>
The resource ID of the string that the control should display. The Exception code will correctly get this information from the control's localized satellite DLL.<br><br></li>
<li>
The <i>helpcontextid</i> that will be passed to the help file defined in your control's structure.</li>
</ul>
<h2><a name="ctrlfmk_persist"></a>4. Persistence</h2>
<p>
One of the most important things your control will do is save out and restore its persistent state. This will typically be done in one of two ways: Through <b>PropertyBags</b> for text persistence, and through <b>Streams</b> for binary persistence. If you use <b>Streams</b>, performance is absolutely critical to make your control load quickly.</p>
<p>
The ActiveX Controls Framework requires that your control implement four member functions to support persistence. The control is required to implement <b>LoadTextState</b>, <b>LoadBinaryState</b>, <b>SaveTextState</b>, and <b>SaveBinaryState</b>. If you are positive that the control will never be in a host that uses <b>IPersistPropertyBag</b>, you can ignore the two text interfaces, but we don't recommend this, because these interfaces are sufficiently straightforward to use easily.</p>
<h3>4.1 Text Persistence</h3>
<p>
Text persistence in the Framework is done via <b>IPersistPropertyBag</b> and <b>IPropertyBag</b>. All ActiveX controls have an implementation of <b>IPersistPropertyBag</b>, and are given pointers to <b>PropertyBag</b> objects to do their work.</p>
<p>
Kraig Brockschmidt's book <i>Inside OLE </i>(2d ed.) (Development Library, Books and Periodicals) provides a description of the <b>IPropertyBag</b> interface. (Editor's note: Since this book's publication date, OLE has evolved to become a key component of the ActiveX™ technologies described in this article.) Effectively, the developer will use two routines: <b>Read</b> and <b>Write</b>. In both cases, the developer will pass in a VARIANT. In the <b>Read</b> case, the property, if it was saved out, will be put in the VARIANT. If the property couldn't be found (it was never saved out), the default value for that property should be used, and an error should probably not be returned. For <b>Write</b>, a VARIANT with the data is passed in. To persist out a collection or an object (such as a Font or Picture object), the developer can pass in a VT_UNKNOWN object, and the <b>PropertyBag</b> will then <b>QueryInterface</b> that object for <b>IPersistPropertyBag</b> or <b>IPersistStream</b> and persist it. This actually proves effective for persisting collections—they can just support <b>IPersistPropertyBag</b>.</p>
<p>
All of the samples (except the Localize and Circle samples) show how to persist out properties using <b>PropertyBags</b>. For controls with many properties, it often makes sense to use some sort of table-driven persistence to reduce code size and bug potential.</p>
<h3>4.2 Binary Persistence</h3>
<p>
Binary persistence turns out to be critical when implementing an ActiveX control. Control loading speed can be severely hampered by a poorly written <b>LoadBinaryState</b> routine, so it's important to plan how to keep this routine fast. The binary persistence code is used by most hosts all the time, and by other hosts when including the control in a generated executable file.</p>
<p>
In both routines, the control is handed a pointer to an <b>IStream</b> object. The key to loading speed here is to reduce the number of operations on the stream. For the <b>SaveBinaryState</b> routine, this is slightly less critical.</p>
<p>
Typically, a control will want to save the following information (often in the order given):
<ul type=disc>
<li>
A header with a magic number, version, and size information<br><br></li>
<li>
Fixed size state information, such as longs, floats, colors, strings, and so on<br><br></li>
<li>
Variable-sized persistent state, such as fonts, pictures, collections, and so on</li>
</ul>
<p>
You'll most likely want to start the control's binary persistent state with some sort of header structure that includes a "magic number" that the control can check for sanity when the control is loading. You'll also want to include a version number so that future versions of your control can deal with older versions; and finally, you will often want the control to write out the number of bytes of data that were written.</p>
<p>
Samples in the Framework that have a binary persistent state use the following structure:</p>
<pre><code>#define STREAMHDR_MAGIC&nbsp;&nbsp;&nbsp; 0x12345678

 &nbsp;&nbsp; typedef struct {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwMagic;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwVersion;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD cbSize;
 &nbsp;&nbsp; } STREAMHDR;
</code></pre>
<p>
The <b>SaveBinaryState</b> routine saves this information, and the <b>LoadBinaryState</b> routine looks for it.</p>
<p>
One way to write out all the fixed-size information (and therefore load it efficiently) is to do it all in one chunk—if all of the control's fixed persistent state is in a structure in the control object, you can write out the structure in the persistence code. Controls generated by the Control wizard will have a structure called <b>MYCTLNAMECTLSTATE</b>, into which you can opt to put the control's fixed-state data. Then, when saving, the control can do the following:</p>
<pre><code>hr = pStream-&gt;Write(&amp;m_state, sizeof(m_state), NULL);
</code></pre>
<p>
For loading, the procedure becomes as simple as:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;hr = pStream-&gt;Read(&amp;(m_state), sizeof(m_state), NULL);
</code></pre>
<p>
Extremely efficient and easy.</p>
<p>
For fonts and pictures, binary persistence is slightly more complicated. Effectively, the control must <b>QueryInterface</b> those objects for <b>IPersistStream</b>, then call the <b>Load</b> or <b>Save</b> routine with the stream that the control has been given. Typically, this can be done after the control has written out all other information. The FontColor control sample is a perfect example.</p>
<p>
If you follow the above suggestions for persistent-state structure, the control's load routine will look something like this:</p>
<pre><code>IPersistStream *pps;
 &nbsp;&nbsp; STREAMHDR sh;
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp; hr;

 &nbsp;&nbsp; // First read in the streamhdr, and make sure we like what we're getting.

 &nbsp;&nbsp; hr = pStream-&gt;Read(&amp;sh, sizeof(sh), NULL);
 &nbsp;&nbsp; RETURN_ON_FAILURE(hr);

 &nbsp;&nbsp; // Sanity check

 &nbsp;&nbsp; if (sh.dwMagic != STREAMHDR_MAGIC || sh.cbSize != sizeof(m_state))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_UNEXPECTED;

 &nbsp;&nbsp; // Read in the control state information.

 &nbsp;&nbsp; hr = pStream-&gt;Read(&amp;(m_state), sizeof(m_state), NULL);
 &nbsp;&nbsp; RETURN_ON_FAILURE(hr);

 &nbsp;&nbsp; // Now read in the font!

 &nbsp;&nbsp; OleCreateFontIndirect(&amp;_fdDefault, IID_IFont, (void **)&amp;m_pFont);
 &nbsp;&nbsp; RETURN_ON_NULLALLOC(m_pFont);

 &nbsp;&nbsp; // QueryInterface it for IPersistStream and load it.

 &nbsp;&nbsp; hr = m_pFont-&gt;QueryInterface(IID_IPersistStream, (void **)&amp;pps);
 &nbsp;&nbsp; RETURN_ON_FAILURE(hr);

 &nbsp;&nbsp; hr = pps-&gt;Load(pStream);
 &nbsp;&nbsp; pps-&gt;Release();

 &nbsp;&nbsp; return hr;
</code></pre>
<p>
This method proves to be acceptably fast and robust.</p>
<h2><a name="ctrlfmk_proppage"></a>5. Property Pages</h2>
<p>
Most ActiveX controls will find property pages an invaluable addition to their design-time functionality. Fortunately, implementing property pages is relatively straightforward. To do so, you merely need to declare an object that inherits from <b>CPropertyPage</b>.</p>
<h3>5.1 Working with a Property Page</h3>
<p>
The control's property page is declared in the header file using the <b>DEFINE_PROPERTYPAGE</b> macro, which puts it into the <b>g_ObjectInfo</b> table. The Framework supports the creation of the property page object, but you are required to implement the static <b>Create()</b> function (which the Control wizard generates for you).</p>
<p>
The property page is created much like a standard Microsoft Windows dialog box is—you use your favorite resource editor to create a DIALOG resource, then just cut and paste it into your control's resource (.RC) file.</p>
<p>
The most important method you'll have to implement will be the <b>DialogProc</b> method, which is where all the work will take place. In addition to the regular Windows messages that one would expect in a <b>DialogProc</b>, there are a few additional ones that developers working with this Framework will expect:
<ul type=disc>
<li>
PPM_NEWOBJECTS. Your control has been given some new objects. The control is expected to populate its page's controls with information from this object. Using the <b>FirstControl()</b> and <b>NextControl()</b> methods from the <b>CPropertyPage</b> class, the control can get the relevant information.<br><br></li>
<li>
PPM_APPLY. The control must apply any changes that have occurred. You can use the <b>FirstControl()</b> and <b>NextControl()</b> routines to loop through the objects for which the property pages were visible and then apply the values. (Note that there can be more than one object for which a property page is being displayed.)<br><br></li>
<li>
PPM_EDITPROPERTY. When the control is sent this message, the control is expected to set the focus to the control instance that represents the property of the given DISPID. You will typically see this message called only if you implement <b>IPerPropertyBrowsing</b> and return a value in <b>MapPropertyToPage</b>.<br><br></li>
<li>
PPM_FREEOBJECTS. You may find it interesting to stash, in some way, the pointers received in PPM_NEWOBJECTS. This message tells you that it is time to free the pointers, because the objects are no longer valid. This can be called from the property page's destructor, so you should be careful not to make too many assumptions about the property page.</li>
</ul>
<p>
Please see one of the sample controls (downloadable from the Framework abstract) for exact details on these messages.</p>
<h3>5.2 Navigating Through Associated Objects</h3>
<p>
Your property pages will operate on one or more controls. When initializing, you will typically get some values from the first control you are given. You can use the <b>FirstControl()</b> method to get the object pointer for this control. You can then <b>QueryInterface</b> it for your primary dispatch interface to get properties with which to populate the page.</p>
<p>
When told to apply the values (PPM_APPLY), you'll want to apply them to all objects, which means you'll want to loop using <b>FirstControl()</b> and <b>NextControl()</b> as follows:</p>
<pre><code>for (pUnk = FirstControl(&amp;dwCookie) ; pUnk; pUnk = NextControl(&amp;dwCookie)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = pUnk-&gt;QueryInterface(IID_IButton, (void **)&amp;pButton);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr)) continue;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDlgItemText(hwnd, IDC_CAPTION, szTmp, 128);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bstr = BSTRFROMANSI(szTmp);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(bstr, "Maggots!");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pButton-&gt;put_Caption(bstr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SysFreeString(bstr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pButton-&gt;Release();
 &nbsp;&nbsp; }
</code></pre>
<p>
Please note that the return values of <b>FirstControl()</b> and <b>NextControl() </b>don't need to be <b>Release()</b>ed.</p>
<h3>5.3 Marking Your Page as Dirty</h3>
<p>
It is important to correctly mark the control's property page as dirty at the appropriate times. This must be done manually. Typically, the control will do this in response to a Windows notification message, such as EN_CHANGE or BN_CLICKED. When the control wishes to mark its page as dirty, the <b>MakeDirty()</b> routine should be called. This will cause the Apply button to be enabled, if it was previously disabled, and will tell the host that the state should be saved before destroying the page.</p>
<p>
The following code causes the page to mark itself as dirty when the user changes text in a text box on the property page:</p>
<pre><code>case WM_COMMAND:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (LOWORD(wParam)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case IDC_CAPTION:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HIWORD(wParam) == EN_CHANGE)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MakeDirty();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
</code></pre>
<h2><a name="ctrlfmk_string"></a>6. String Manipulation</h2>
<p>
The ActiveX Controls Framework provides a robust system of macros for manipulating strings in virtually all of the ways you'll encounter while working with an ActiveX control.</p>
<h3>6.1 Types of Strings</h3>
<p>
32-bit systems include many different types of strings. Understanding these types is important when working with ActiveX, because there is great potential for memory leaks and bugs associated with strings.</p>
<p>
There are two fundamental types of strings—multibyte strings (which can be ANSI or double-byte) and Unicode® strings. For multibyte strings, you almost always work with some sort of <i>char *</i> pointer (<b>LPSTR</b>, <b>LPCSTR</b>). As for Unicode strings, a few types are commonly used, most notably <b>WCHAR *</b> (<b>LPWSTR</b>, <b>LPWCSTR</b>), <b>BSTR</b>, and <b>OLESTR</b> strings.</p>
<p>
<b>LPWSTR</b> pointers are just that—a pointer to a wide string. An <b>LPOLESTR</b> pointer is much the same, with some ActiveX rules added to it. An <b>OLESTR</b> is merely a wide string, but when it's an out-parameter to a function, it should be allocated using the host's <b>IMalloc</b> allocator (that is, <b>CoTaskMemAlloc</b>).</p>
<p>
A <b>BSTR</b> is a string with a little more structure—specifically, a length prefix. To work with <b>BSTR</b>s, you need to use special APIs designed exclusively for them, notably <b>SysAllocString</b>, <b>SysFreeString</b>, and <b>SysStringLen</b>. (There are a few others; see the <i>OLE 2 Programmer’s Reference, Volume II</i>, Microsoft Press, 1994 for more details.</p>
<p>
These data types are fully interchangeable as far as comparisons and copies go, but they are <i>not</i> interchangeable in terms of allocation and freeing—for instance, it is not acceptable to call <b>SysFreeString </b>on an <b>OLESTR</b> or <b>LPWSTR</b> string.</p>
<p>
Both <b>BSTR</b>s and <b>OLESTR</b>s as in-parameters to functions should not be freed (per standard ActiveX COM conventions). By the same token, <b>BSTR</b>s and <b>OLESTR</b>s as out-parameters should be expected to be freed, and thus should be allocated appropriately.</p>
<h3>6.2 Working with Strings</h3>
<p>
Now, the problem is your controls will be working with multibyte strings, except when you work with ActiveX. Therefore, there will be scenarios where you'll either be given a wide string and need the multibyte version of it, or you'll have a multibyte string and need a wide string for it.</p>
<p>
To solve these problems, the ActiveX Controls Framework includes the following macros:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;MAKE_WIDEPTR_FROMANSI(newstringname, convertme)
 &nbsp;&nbsp; MAKE_ANSIPTR_FROMWIDE(newstringname, convertme)

 &nbsp;&nbsp; BSTRFROMANSI(ansistr)
 &nbsp;&nbsp; OLESTRFROMANSI(ansistr)
 &nbsp;&nbsp; BSTRFROMRESID(resourceid)
 &nbsp;&nbsp; OLESTRFROMRESID(resourceid)
 &nbsp;&nbsp; COPYOLESTR(copyme)
 &nbsp;&nbsp; COPYBSTR(copyme)
</code></pre>
<p>
The first two macros will take a string of a given type and a name, and create a variable of the new name (do <i>not</i> declare a variable of this name yourself), and then convert the other string into the new variable. This cannot be used as an <i>rvalue</i> in C/C++ expressions, nor can it be an <i>lvalue</i>—it basically needs to sit on a line by itself.</p>
<p>
The last set of macros do almost all the remaining interesting work. You can get <b>BSTR</b>s or <b>IMalloc</b>ed <b>OLESTR</b>s from an <b>ANSI</b> string, or copy <b>OLESTR</b>s and <b>BSTR</b>s. The only additional functions of real interest are those that take a <b>WORD</b> that is a resource ID, load in a string from your localization DLL (or the main DLL, if you don't do satellite localization), and make either a <b>BSTR</b> or an <b>OLESTR</b> out of it. This proves useful in a few places where you need a localized string.</p>
<p>
Remember that although these macros were designed with a certain amount of speed in mind, converting strings is not a cheap operation, and therefore control writers should try to be moderately conservative about the number of string conversions they perform.</p>
<h2><a name="ctrlfmk_local"></a>7. Localization</h2>
<p>
The ActiveX Controls Framework also provides support for robust localization of your control; most notably, property pages and other resources you will find interesting to localize.</p>
<p>
The scheme is as follows: The resources for the default language (typically English) are in the main in-process server's resources. For each additional language supported, a satellite DLL contains the resources for that language. The name for this satellite DLL is generated by taking the "base" name for the DLL from a string resource in the main in-process server file, and then adding on a three-letter language code generated by the <b>GetLocaleInfo</b> function with the <b>LCTYPE</b> LOCALE_SABBREVLANGNAME.</p>
<p>
The code will first look for the specific language that is set up in the global variable <i>g_lcidLocale</i>. This should be initialized by all servers. For ActiveX controls and property pages, you'll want to get this variable from the host. For ActiveX automation servers, you'll want to set this up some other way, such as using the system language. If the satellite DLL for the specific language is not found, the Framework will look for the primary language ID with SUBLANG_DEFAULT instead. If that satellite is not found, a handle to the default resources will be returned.</p>
<p>
Please note that fully localized type libraries are not supported, because most hosts will ignore these and use the default library.</p>
<h3>7.1 Setting Up for Localization</h3>
<p>
If you want to support satellite localization in your in-process server, you need to set up a few things:
<ul type=disc>
<li>
First, you'll need to set the <i>g_fSatelliteLocalization</i> variable in your in-process server file to TRUE. This will instruct all further code paths to use satellite localization. <br><br></li>
<li>
You will also, at some point, need to set up the <i>g_lcidLocale</i> variable, as described above. For ActiveX controls, you can use <b>GetAmbientProperty()</b> and ask for AMBIENT_DISPID_LOCALE. For property pages, there is a method on the <b>IPropertyPageSite</b> interface that will let you obtain the locale ID. For ActiveX automation objects, you will be required to set this up yourself, typically by obtaining the system locale ID.<br><br></li>
<li>
Whenever you want to load a resource, make sure you use <b>GetResourceHandle()</b> to get the instance handle for the localized resources. </li>
</ul>
<p>
Please see the Localize sample included with the Framework (downloadable from the Framework abstract) for an example of how this works, along with an actual localized satellite DLL (in the French subdirectory). The satellite DLL should contain all localized resources that interest you. </p>
<h2><a name="ctrlfmk_misc"></a>8. Miscellaneous</h2>
<h3>8.1 Recommended Reading</h3>
<ul type=disc>
<li>
Brockschmidt, Kraig. <i>Inside OLE</i>. Second Edition. Redmond, WA: Microsoft Press, 1993. (Development Library, Books and Periodicals). <br>
Chapters 3, 13-15, and 24 contain most of the information you'll need to work with an OLE control and/or Automation server. The chapters on persistence should also prove useful. <br><br></li>
<li>
<i>OLE 2 Programmer’s Reference, Volumes One and Two</i>. Redmond, WA: Microsoft Press, 1994. <br><br></li>
<li>
<i>Microsoft Visual C++ version 4.0</i>. Refer to the MFC source code, located under the \MSDEV\MFC directories. <br>
When looking for ideas on how to do something, the CDK source code proves to be an invaluable resource. Use it—frequently.</li>
</ul>
<h3>8.2 Host-Specific Notes</h3>
<p>
Notes, things to consider, or known problems with specific hosts for ActiveX controls:
<ul type=disc>
<li>
Microsoft Access 95 requires <b>IPerPropertyBrowsing</b>. If you don't implement this routine, you won't able to put one of your controls on a form. See the Microsoft Develoer Network Library CD and the MFC source code for documentation on this method.<br><br></li>
<li>
In addition, you cannot return error <i>scodes</i> from <b>GetPredefinedStrings</b>. You must return either S_OK or S_FALSE. Returning an error <i>scode</i> will cause your system to crash.<br><br></li>
<li>
<b>MapPropertyToPage</b> should return PERPROP_E_NOPAGEAVAILABLE if there are no pages available.</li>
</ul>
</BODY>
</HTML>
