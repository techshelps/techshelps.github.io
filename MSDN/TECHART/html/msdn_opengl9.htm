<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Windows NT OpenGL: Getting Started</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_opengl9"></a></sup>Windows NT OpenGL: Getting Started</h1>
<p>
Dennis Crain<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: April 30, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="2459">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the MYGL sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
OpenGL, an industry-standard three-dimensional software interface, is now a part of Microsoft® Windows NT™ version 3.5. As a hardware-independent interface, the operating system needs to provide pixel format and rendering context management functions. Windows NT provides a generic graphics device interface (GDI) implementation for this as well as a device implementation. This article details these implementations, OpenGL/NT functions, and tasks that applications need to accomplish before OpenGL commands can be used to render images on the device surface.</p>
<h2>Introduction</h2>
<p>
We all knew that it was just a matter of time before three-dimensional (3-D) graphics would become part of a Microsoft operating system. Well, it finally happened. Version 3.5 of Microsoft® Windows NT™ now includes OpenGL (OpenGL/NT). So just what is OpenGL? Originally developed by Silicon Graphics, Inc., it is an industry-standard procedural software interface for producing 3-D graphics. It does so by providing roughly 120 commands to draw various primitives including points, lines, and polygons in various modes. With OpenGL, you can create high-quality still and animated 3-D color images. So now you are an OpenGL expert, right? If you feel that you don’t qualify for that distinction, go to the bookstore and pick up the <i>OpenGL Programming Guide</i> and the <i>OpenGL Reference Manual</i>. Both are authored by the OpenGL Architecture Review Board. They are required reading if you plan to use OpenGL. (For the ISBN numbers for these manuals, see the "Bibliography" section at the end of this article.)</p>
<p>
This article is for anyone who has an interest in OpenGL/NT. Whether you have been writing OpenGL programs for years or are just getting started, this article is for you. OpenGL is a hardware-independent 3-D interface. Because of this, it does not include commands for the initialization and management of devices’ display surfaces. This is the responsibility of the operating system within which you find OpenGL. So you can see that, irrespective of OpenGL experience, anyone new to OpenGL/NT needs to understand the details of the implementation specific to Windows NT. At this point, your hopes may have been dashed. You may have been looking for an article that describes how to create 3-D images. Don’t become too depressed. Future articles will deal with this, but, as some say, "You need to learn to walk before you run." Everyone using OpenGL/NT needs to understand how to get the 3-D images on the device surface.</p>
<p>
This article will frequently discuss pixel format and rendering context management. Successfully managing these tasks provides the connection between the hardware independence of OpenGL/NT. Two mechanisms are provided in Windows NT to provide this connection to OpenGL—pixel format manipulation APIs and WGL APIs. WGL APIs provide a mechanism for managing the OpenGL rendering context.</p>
<h2>MYGL: A Sample OpenGL/NT Application</h2>
<p>
MYGL is a sample OpenGL/NT application written in C++ using the Microsoft Foundation Class Library (MFC). A class, COpenGL, wraps the WGL and pixel format APIs and also provides numerous utility functions for OpenGL/NT applications. Code samples used in this article are taken from MYGL. The MYGL user interface permits you to specify and set the pixel format of a window (MYGL is an SDI [single-document interface] application), enumerate the pixel formats, and query the current pixel format properties.</p>
<h2>Generic vs. Device Format, AKA OpenGL/NT Architecture</h2>
<p>
It is always helpful to understand the architecture of a new feature. From an application developer’s perspective, a good understanding of the architecture eases the application development process. Design and implementation decisions can be made with intelligence instead of confusion. If you buy that, take a look at Figure 1. It is the infamous architecture diagram with an OpenGL/NT flavor this time.</p>
<p>
<img src="opengl9_1.gif" border=0><img src="opengl9_2.gif" border=0></p>
<p class=label>
<b>Figure 1. OpenGL/NT architecture</b></p>
<p>
As you work through this section, don’t worry if you don’t understand everything. Much of what is discussed briefly will be discussed in detail later. You might want to return to this section periodically as you progress through the article.</p>
<p>
If you have a machine like mine (a true antique), OpenGL applications use the generic format. All of the pixel format management, double buffering, and rendering context management is handled by the generic OpenGL module and GDI. If you have a machine with a sophisticated video display adapter and a video display driver that supports OpenGL/NT, you are indeed fortunate. I’m sure I could round up several dozen Dr. GUI T-shirts if you want to consider a trade!</p>
<p>
More seriously, OpenGL/NT calls are intercepted by the installable client driver. The client driver packages these OpenGL and WGL commands and sends them to the video display driver. The video display driver is linked with libraries that contain dispatch functions, OpenGL code, and some portable low-level drawing support functions. The big win with OpenGL support in the video driver and appropriate hardware is speed. Rendering can be accelerated tremendously. Figure 2 broadly illustrates the differences between generic and device formats.</p>
<p>
<img src="opengl9_3.gif" border=0></p>
<p class=label>
<b>Figure 2. Generic and device formats</b></p>
<p>
To illustrate the difference between the generic and device formats a bit more, let’s discuss the new pixel format API, <b>DescribePixelFormat</b>.</p>
<p>
<b>DescribePixelFormat</b> obtains pixel format information about a given device. This information includes values such as the number of color bitplanes, the type of pixel data, and so on (pixel format will be discussed in more detail later). An application calls <b>DescribePixelFormat</b> (found in GDI32.DLL). In the generic format, <b>DescribePixelFormat</b> takes the pixel format index and races through roughly 300 lines of code, filling in a <b>PIXELFORMATDESCRIPTOR</b> structure based on the index. The function then returns the maximum number of generic pixel formats available. In the device format, the pixel format index is compared to the number of device formats (if any). If the pixel format is determined to be a device-supported format, the driver function, <b>DrvDescribePixelFormat</b>, is called. After returning from the driver, <b>DescribePixelFormat</b> returns the sum of the generic formats and the device formats.</p>
<p>
A discussion of the generic format would not be complete without mentioning its limitations. The following list of limitations is taken from the Windows NT OpenGL Help file:
<ul type=disc>
<li>
There are printing limitations.<p class=tl>
An application cannot directly print an OpenGL image to a monochrome printer. There is, however, a workaround for this situation. An application can directly print an OpenGL image to a color printer that offers four or more bits of color information per pixel.</P></li>
<li>
OpenGL and GDI graphics cannot be mixed in a double-buffered window.<p class=tl>
An application can draw both OpenGL graphics and GDI graphics directly into a single-buffered window, but not into a double-buffered window.</P></li>
<li>
There are no per-window hardware color palettes.<p class=tl>
Windows NT has a single system hardware color palette, which applies to the whole screen. An OpenGL window cannot have its own hardware palette. It can have its own logical palette. To do so, it must become a palette-aware application.</P></li>
<li>
There is no direct support for the Clipboard, DDE, metafiles, or OLE.<p class=tl>
A window with OpenGL graphics does not directly support these Windows NT capabilities. There are workarounds, however, for working with the Clipboard.</P></li>
<li>
The Inventor 2.0 C++ class library is not included.<p class=tl>
The Inventor class library, built on top of OpenGL, provides higher-level constructs for programming 3-D graphics. It is not included in version 1.0 of Windows NT OpenGL.</P></li>
<li>
There is no support for several pixel format features: overlay and underlay layers, stereoscopic images, alpha bitplanes, and auxiliary buffers.<p class=tl>
There is, however, support for several ancillary buffers: stencil buffer, accumulation buffer, back buffer (double buffering), and depth (z-axis) buffer.</P></li>
</ul>
<h2>Pixel Format Management</h2>
<p>
The OpenGL frame buffer is nothing more than the sum of all the buffers utilized by OpenGL. These include color buffers, depth buffer, stencil buffer, and an accumulation buffer. Color buffers contain pixel data that is either color indexed (don’t interpret this as "Windows palette") or RGBA values (A, or alpha, is used as a measure of opacity). The depth buffer (z buffer) contains depth values for each pixel. Pixels with larger depth values are "deeper," and a pixel with a smaller value would overwrite the deeper pixel if they both occupied the same location. The stencil buffer restricts drawing to specific screen locations. The accumulation buffer is used for accumulating numerous images into a composite image.</p>
<p>
OpenGL/NT has implemented many of these buffers in the generic format. Single and double buffering are supported. Stereoscopic buffering is not supported. The depth, stencil, and accumulation buffers are also available. To effectively use these buffers, the pixel format must be specified. Every window used by OpenGL has a pixel format. The following sections describe the structures, functions, and issues related to pixel format management.</p>
<h3>PIXELFORMATDESCRIPTOR</h3>
<p>
The <b>PIXELFORMATDESCRIPTOR</b> structure below is used to describe a pixel format in Windows NT. The comments are about the use of the structure in the generic format. Hardware manufacturers may enhance parts of OpenGL, and may support some pixel format properties not supported in the generic format.</p>
<pre><code>typedef struct tagPIXELFORMATDESCRIPTOR
{
 &nbsp;&nbsp; WORD&nbsp; nSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //sizeof(PIXELFORMATDESCRIPTOR)
 &nbsp;&nbsp; WORD&nbsp; nVersion;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //1
 &nbsp;&nbsp; DWORD dwFlags;
 &nbsp;&nbsp; BYTE&nbsp; iPixelType;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //rgba or color indexed
 &nbsp;&nbsp; BYTE&nbsp; cColorBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //# of color bitplanes
 &nbsp;&nbsp; BYTE&nbsp; cRedBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //# red bitplanes
 &nbsp;&nbsp; BYTE&nbsp; cRedShift;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //shift count for red bitplanes
 &nbsp;&nbsp; BYTE&nbsp; cGreenBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //# green bitplanes
 &nbsp;&nbsp; BYTE&nbsp; cGreenShift;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //shift count for green bitplanes
 &nbsp;&nbsp; BYTE&nbsp; cBlueBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //# blue bitplanes
 &nbsp;&nbsp; BYTE&nbsp; cBlueShift;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //shift count for blue bitplanes
 &nbsp;&nbsp; BYTE&nbsp; cAlphaBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //not used in generic format
 &nbsp;&nbsp; BYTE&nbsp; cAlphaShift;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //not used in generic format
 &nbsp;&nbsp; BYTE&nbsp; cAccumBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //total # accum buffer bitplanes
 &nbsp;&nbsp; BYTE&nbsp; cAccumRedBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //# red bitplanes in accum buffer
 &nbsp;&nbsp; BYTE&nbsp; cAccumGreenBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //# green bitplanes in accum buffer
 &nbsp;&nbsp; BYTE&nbsp; cAccumBlueBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //# blue bitplanes in accum buffer
 &nbsp;&nbsp; BYTE&nbsp; cAccumAlphaBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //# alpha bitplanes in accum buffer
 &nbsp;&nbsp; BYTE&nbsp; cDepthBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //depth of depth (z) buffer
 &nbsp;&nbsp; BYTE&nbsp; cStencilBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //depth of stencil buffer
 &nbsp;&nbsp; BYTE&nbsp; cAuxBuffers;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //not used in generic format
 &nbsp;&nbsp; BYTE&nbsp; iLayerType;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //PFD_MAIN_PLANE only in generic format
 &nbsp;&nbsp; BYTE&nbsp; bReserved;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //must be 0
 &nbsp;&nbsp; DWORD dwLayerMask;
 &nbsp;&nbsp; DWORD dwVisibleMask;
 &nbsp;&nbsp; DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR;
;
</code></pre>
<p>
The following, taken from the OpenGL/NT Help file, describes the members of <b>PIXELFORMATDESCRIPTOR</b>. This is long, but it is very important to understanding pixel formats and rendering contexts. So if you are not already familiar with <b>PIXELFORMATDESCRIPTOR</b>, read on.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=41%><b>Member</b></td>
<td class=label width=59%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=41%>nSize</td>
<td width=59%>Specifies the size of this data structure. This value should be set to sizeof(PIXELFORMATDESCRIPTOR).</td>
</tr>
<tr valign=top>
<td width=41%>nVersion</td>
<td width=59%>Specifies the version of this data structure. This value should be set to 1.</td>
</tr>
<tr valign=top>
<td width=41%>dwFlags</td>
<td width=59%>A set of bit flags that specify properties of the pixel buffer. The properties are generally not mutually exclusive. The following bit flag constants are defined:</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; <b>Value</b></td>
<td width=59%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; PFD_DRAW_TO_WINDOW</td>
<td width=59%>The buffer can draw to a window or device surface.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; PFD_DRAW_TO_BITMAP</td>
<td width=59%>The buffer can draw to a memory bitmap.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; PFD_SUPPORT_GDI</td>
<td width=59%>The buffer supports GDI drawing. This flag and PFD_DOUBLEBUFFER are mutually exclusive in the release 1.0 generic implementation.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; PFD_SUPPORT_OPENGL</td>
<td width=59%>The buffer supports OpenGL drawing.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; PFD_GENERIC_FORMAT</td>
<td width=59%>The pixel format is supported by the GDI software implementation. That implementation is also known as the generic implementation. If this bit is clear, the pixel format is supported by a device driver or hardware.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; PFD_NEED_PALETTE</td>
<td width=59%>The buffer uses RGBA pixels on a palette-managed device. A logical palette is required to achieve the best results for this pixel type. Colors in the palette should be specified according to the values of the cRedBits, cRedShift, cGreenBits, cGreenShift, cBluebits, and cBlueShift members. The palette should be created and realized in the device context (DC) before calling <b>wglMakeCurrent</b>.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; PFD_DOUBLEBUFFER</td>
<td width=59%>The buffer is double-buffered. This flag and PFD_SUPPORT_GDI are mutually exclusive in the release 1.0 generic implementation.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; PFD_STEREO</td>
<td width=59%>The buffer is stereoscopic. This flag is not supported in the release 1.0 generic implementation.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; PFD_NEED_SYSTEM_PALETTE</td>
<td width=59%>This flag is used by OpenGL hardware that supports only one hardware palette. To use hardware accelerations in such hardware, the hardware palette has to be in a fixed order (for example, 3-3-2) in RGBA mode or match the logical palette in color index mode. The current PFD_NEED_PALETTE flag does not have such a requirement. That is, if only PFD_NEED_PALETTE is set, an application can use a logical 3-3-2 palette; the logical-to-system-palette mapping is performed by the system. The system palette may not be 3-3-2 and may not have all the logical palette colors. However, if PFD_NEED_SYSTEM_PALETTE is set, an application should take over the system palette by calling <b>SetSystemPaletteUse</b> to force a 1-1 logical-to-system-palette mapping. If an application chooses to ignore PFD_NEED_SYSTEM_PALETTE because it does not want to mess up desktop colors, it will not get maximum performance but it should still work.<p>
The PFD_NEED_SYSTEM_PALETTE flag is not needed if the OpenGL hardware supports multiple hardware palettes and the driver can allocate spare hardware palettes for OpenGL.</p>
<p>
The generic pixel formats do not have this flag set.</p>
</td>
</tr>
</table><br>
<p>
In addition, the following bit flags can be specified when calling <b>ChoosePixelFormat</b>.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=41%><b>Value</b></td>
<td class=label width=59%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=41%>PFD_DOUBLE_BUFFER_DONTCARE</td>
<td width=59%>The requested pixel format can be either single- or double-buffered.</td>
</tr>
<tr valign=top>
<td width=41%>PFD_STEREO_DONTCARE</td>
<td width=59%>The requested pixel format can be either monoscopic or stereoscopic.</td>
</tr>
<tr valign=top>
<td width=41%>iPixelType</td>
<td width=59%>Specifies the type of pixel data. The following types are defined:</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; <b>Value</b></td>
<td width=59%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; PFD_TYPE_RGBA</td>
<td width=59%>RGBA pixels. Each pixel has four components: red, green, blue, and alpha.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; PFD_TYPE_COLORINDEX</td>
<td width=59%>Color index pixels. Each pixel uses a color index value</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cColorBits</td>
<td width=59%>Specifies the number of color bitplanes in each color buffer. For RGBA pixel types, it is the size of the color buffer excluding the alpha bitplanes. For color index pixels, it is the size of the color index buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cRedBits</td>
<td width=59%>Specifies the number of red bitplanes in each RGBA color buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cRedShift</td>
<td width=59%>Specifies the shift count for red bitplanes in each RGBA color buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cGreenBits</td>
<td width=59%>Specifies the number of green bitplanes in each RGBA color buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cGreenShift</td>
<td width=59%>Specifies the shift count for green bitplanes in each RGBA color buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cBlueBits</td>
<td width=59%>Specifies the number of blue bitplanes in each RGBA color buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cBlueShift</td>
<td width=59%>Specifies the shift count for blue bitplanes in each RGBA color buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cAlphaBits</td>
<td width=59%>Specifies the number of alpha bitplanes in each RGBA color buffer. Alpha bitplanes are not supported in the release 1.0 generic implementation.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cAlphaShift</td>
<td width=59%>Specifies the shift count for alpha bitplanes in each RGBA color buffer. Alpha bitplanes are not supported in the release 1.0 generic implementation.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cAccumBits</td>
<td width=59%>Specifies the total number of bitplanes in the accumulation buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cAccumRedBits</td>
<td width=59%>Specifies the number of red bitplanes in the accumulation buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cAccumGreenBits</td>
<td width=59%>Specifies the number of green bitplanes in the accumulation buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cAccumBlueBits</td>
<td width=59%>Specifies the number of blue bitplanes in the accumulation buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cAccumAlphaBits</td>
<td width=59%>Specifies the number of alpha bitplanes in the accumulation buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cDepthBits</td>
<td width=59%>Specifies the depth of the depth (z-axis) buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cStencilBits</td>
<td width=59%>Specifies the depth of the stencil buffer.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; cAuxBuffers</td>
<td width=59%>Specifies the number of auxiliary buffers. Auxiliary buffers are not supported in release 1.0 of the generic implementation.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp; iLayerType</td>
<td width=59%>Specifies the type of layer. Although the following values are defined, version 1.0 supports only the main plane (there is no support for overlay or underlay planes):</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Value</b></td>
<td width=59%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PFD_MAIN_PLANE</td>
<td width=59%>The layer is the main plane.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PFD_OVERLAY_PLANE</td>
<td width=59%>The layer is the overlay plane.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PFD_UNDERLAY_PLANE</td>
<td width=59%>The layer is the underlay plane.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bReserved</td>
<td width=59%>Not used. Must be zero.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwLayerMask</td>
<td width=59%>Specifies the layer mask. The layer mask is used in conjunction with the visible mask to determine if one layer overlays another.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwVisibleMask</td>
<td width=59%>Specifies the visible mask. The visible mask is used in conjunction with the layer mask to determine if one layer overlays another. If the result of the bitwise AND of the visible mask of a layer and the layer mask of a second layer is nonzero, then the first layer overlays the second layer, and a transparent pixel value exists between the two layers. If the visible mask is 0, the layer is opaque.</td>
</tr>
<tr valign=top>
<td width=41%> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwDamageMask</td>
<td width=59%>Specifies whether more than one pixel format shares the same frame buffer. If the result of the bitwise AND of the damage masks between two pixel formats is nonzero, then they share the same buffers.</td>
</tr>
</table><br>
<h3>Pixel Formats</h3>
<p>
The generic implementation of OpenGL/NT supports 24 different pixel formats. Although each format is identified by an index from 1 to 24, they are not constant. That is, never rely on the ordering of the indexes. The pixel formats are characterized by several properties (see Figure 3).</p>
<p>
<img src="opengl9_4.gif" border=0></p>
<p class=label>
<b>Figure 3. Pixel format properties</b></p>
<p>
The primary property by which they are organized is the number of bits per pixel (BPP). Five bitplane organizations are supported, including 32 BPP, 24 BPP, 16 BPP, 8 BPP, and 4 BPP. Eight pixel formats are defined for the number of bits per pixel specified by the display driver. These are referred to as the native formats. The remaining 16 pixel formats (referred to as non-native formats) are divided evenly between the other bitplane organizations and are supplied for bitmap support. The formats are then organized by the pixel type (RGBA or color index), then buffering (single or double), and then the depth of the depth (z) buffer (32 or 16). Given this, you would think that there are 40 generic formats. However, 16 of the non-native formats are eliminated because it doesn’t make sense to double buffer to a bitmap. Table 1 lists all of the native formats.</p>
<p class=label>
<b>Table 1. Native Pixel Formats</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=19%><b>Bits/Pixel</b></td>
<td class=label width=38%><b>Pixel Type</b></td>
<td class=label width=19%><b>Buffering</b></td>
<td class=label width=24%><b>Depth (z) buffer</b></td>
</tr>
<tr valign=top>
<td width=19%>native</td>
<td width=38%>PFD_TYPE_RGBA</td>
<td width=19%>Single</td>
<td width=24%>32</td>
</tr>
<tr valign=top>
<td width=19%>native</td>
<td width=38%>PFD_TYPE_RGBA</td>
<td width=19%>Single</td>
<td width=24%>16</td>
</tr>
<tr valign=top>
<td width=19%>native</td>
<td width=38%>PFD_TYPE_RGBA</td>
<td width=19%>Double</td>
<td width=24%>32</td>
</tr>
<tr valign=top>
<td width=19%>native</td>
<td width=38%>PFD_TYPE_RGBA</td>
<td width=19%>Double</td>
<td width=24%>16</td>
</tr>
<tr valign=top>
<td width=19%>native</td>
<td width=38%>PFD_TYPE_COLORINDEX</td>
<td width=19%>Single</td>
<td width=24%>32</td>
</tr>
<tr valign=top>
<td width=19%>native</td>
<td width=38%>PFD_TYPE_COLORINDEX</td>
<td width=19%>Single</td>
<td width=24%>16</td>
</tr>
<tr valign=top>
<td width=19%>native</td>
<td width=38%>PFD_TYPE_COLORINDEX</td>
<td width=19%>Double</td>
<td width=24%>32</td>
</tr>
<tr valign=top>
<td width=19%>native</td>
<td width=38%>PFD_TYPE_COLORINDEX</td>
<td width=19%>Double</td>
<td width=24%>16</td>
</tr>
</table><br>
<p>
Table 2 lists the remaining pixel formats. These are repeated for each non-native BPP format.</p>
<p class=label>
<b>Table 2. Non-Native Pixel Formats</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=19%><b>Bits/Pixel</b></td>
<td class=label width=38%><b>Pixel Type</b></td>
<td class=label width=19%><b>Buffering</b></td>
<td class=label width=24%><b>Depth (z) buffer</b></td>
</tr>
<tr valign=top>
<td width=19%>non-native</td>
<td width=38%>PFD_TYPE_RGBA</td>
<td width=19%>Single</td>
<td width=24%>32</td>
</tr>
<tr valign=top>
<td width=19%>non-native</td>
<td width=38%>PFD_TYPE_RGBA</td>
<td width=19%>Single</td>
<td width=24%>16</td>
</tr>
<tr valign=top>
<td width=19%>non-native</td>
<td width=38%>PFD_TYPE_COLORINDEX</td>
<td width=19%>Single</td>
<td width=24%>32</td>
</tr>
<tr valign=top>
<td width=19%>non-native</td>
<td width=38%>PFD_TYPE_COLORINDEX</td>
<td width=19%>Single</td>
<td width=24%>16</td>
</tr>
</table><br>
<h3>Enumerating Pixel Formats</h3>
<p>
Enumerating pixel formats is essential to finding a format that is appropriate for an application. Applications are responsible for defining "appropriate." MYGL looks for a native format. The formats are enumerated in response to one of two button clicks—one increases the pixel format index and the other decreases the index. The following code from PIXFORM.CPP demonstrates the enumeration technique used in MYGL. The <i>m_nNextID</i> member variable is used as an index of the pixel formats.</p>
<pre><code>void CPixForm::OnClickedLastPfd()
{
  COpenGL gl;
  PIXELFORMATDESCRIPTOR pfd;
  //
  //Get the hwnd of the view window.
  //
  HWND hwndview = GetViewHwnd();
  //
  //Get a DC associated with the view window.
  //
  HDC&nbsp;&nbsp; hdc&nbsp;&nbsp; = ::GetDC(hwndview);
  int nID = (m_nNextID &gt; 1) ?&nbsp; m_nNextID-- : 1;
  //
  //Get a description of the pixel format. If it is valid, then go and 
  //update the controls in the dialog box, otherwise do nothing.
  //
  if (gl.DescribePixelFormat(hdc, nID, sizeof(PIXELFORMATDESCRIPTOR), &amp;pfd))
 &nbsp;&nbsp; UpdateDlg(&amp;pfd);
  //
  //Release the DC.
  //
  ::ReleaseDC(hwndview, hdc);
}
</code></pre>
<h3>Pixel Format Functions</h3>
<p>
Four functions, shown in Table 3, have been implemented to provide management of pixel formats.</p>
<p class=label>
<b>Table 3. Pixel Format Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Win32 Function</b></td>
<td class=label width=71%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=29%><b>ChoosePixelFormat</b></td>
<td width=71%>Obtains a device context's pixel format that is the closest match to a specified pixel format.</td>
</tr>
<tr valign=top>
<td width=29%><b>SetPixelFormat</b></td>
<td width=71%>Sets a window’s or bitmap’s current pixel format to the pixel format specified by a pixel format index.</td>
</tr>
<tr valign=top>
<td width=29%><b>GetPixelFormat</b></td>
<td width=71%>Obtains the pixel format index of a window’s or bitmap’s current pixel format.</td>
</tr>
<tr valign=top>
<td width=29%><b>DescribePixelFormat</b></td>
<td width=71%>Given a device context and a pixel format index, fills in a <b>PIXELFORMATDESCRIPTOR</b> data structure with the pixel format's properties.</td>
</tr>
</table><br>
<p>
Figure 4 illustrates a general method for calling these functions.</p>
<p>
<img src="opengl9_5.gif" border=0></p>
<p class=label>
<b>Figure 4. Calling pixel format functions</b></p>
<p>
An application generally knows that it will be using double buffering, writing to the screen, or supporting GDI. This is the type of information that would be found in the top box of Figure 4 in <b>PIXELFORMATDESCRIPTOR</b>. The application can either call <b>ChoosePixelFormat</b>, which attempts to match the requested pixel format with the best supported (device or generic) pixel format available, or it can call its own pixel format matching function. The following list describes how <b>ChoosePixelFormat</b> attempts to match the requested pixel format to the pixel formats available:
<ul type=disc>
<li>
First, it attempts to find a pixel format that satisfies the requested attributes:<p class=tl>
PFD_DRAW_TO_WINDOW<br>
PFD_DRAW_TO_BITMAP<br>
PFD_SUPPORT_GDI<br>
PFD_SUPPORT_OPENGL<br>
PFD_TYPE_RGBA<br>
PFD_TYPE_COLORINDEX<br>
PFD_DOUBLEBUFFER<br>
PFD_STEREO</P></li>
<li>
Then it tries to find the best match among the following attributes:<p class=tl>
cColorBits<br>
cAlphaBits<br>
cAccumBits<br>
cDepthBits<br>
cStencilBits<br>
cAuxBuffers<br>
iLayerType</P></li>
<li>
Finally, device pixel formats are given preference over the generic pixel formats.</li>
</ul>
<p>
Once you have an appropriate pixel format, <b>SetPixelFormat</b> is called. If <b>SetPixelFormat</b> is called for a device context that references a window, the function also changes the pixel format of the window. Changing the pixel format of a window more than once can lead to significant complications for the window manager and for multithreaded applications, so it is not allowed. An application can set the pixel format of a window only one time. Once a window's pixel format is set, it cannot be changed.</p>
<h3>Determining the Format</h3>
<p>
It is a simple matter to determine if a pixel format is a generic or device format. The following code illustrates the use of the <b>dwFlags</b> field of the <b>PIXELFORMATDESCRIPTOR</b> structure to detect if the pixel format is generic or device-specific.</p>
<pre><code>BOOL COpenGL::IsDeviceIndex(HDC hdc, int idx)
{
  ASSERT (hdc);
  ASSERT (idx &gt; 0);

  BOOL bRet = FALSE;
  PIXELFORMATDESCRIPTOR pfd;
  int ipfdmax = DescribePixelFormat(hdc, idx, sizeof(PIXELFORMATDESCRIPTOR), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pfd);

  if (!(pfd.dwFlags &amp; PFD_GENERIC_FORMAT))
 &nbsp;&nbsp; bRet = TRUE;
  return (bRet);
}
</code></pre>
<p>
If the PFD_GENERIC_FORMAT bit is set, the pixel format is generic (duh!). It is also very simple to detect if a given pixel format index is a native or non-native index. The following code illustrates this.</p>
<pre><code>BOOL COpenGL::IsNativeIndex(HDC hdc, int idx)
{
  ASSERT (hdc);
  ASSERT (idx &gt; 0);

  BOOL bRet = FALSE;
  PIXELFORMATDESCRIPTOR pfd;
  int ipfdmax = DescribePixelFormat(hdc, idx, sizeof(PIXELFORMATDESCRIPTOR), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pfd);

  if (pfd.dwFlags &amp; PFD_DRAW_TO_WINDOW)
 &nbsp;&nbsp; bRet = TRUE;
  return (bRet);
}
</code></pre>
<p>
If the PFD_DRAW_TO_WINDOW bit is set in <b>dwFlags</b>, the pixel format is native. This may include both generic and device-specific pixel formats. If this bit is not set, the pixel format is non-native and is provided for support of bitmaps.</p>
<h2>OpenGL/NT and Device Contexts</h2>
<p>
As you begin to use device contexts with OpenGL/NT, remember two things:
<ul type=disc>
<li>
Once the pixel format for a window has been set (by calling <b>SetPixelFormat</b> with a DC of that window), it can never be reset.<br><br></li>
<li>
The DC used to create a rendering context may be released or deleted. All DCs subsequently retrieved or created will have the correct pixel format index associated with them.</li>
</ul>
<p>
To retrieve the index of the currently set pixel format, use the <b>GetPixelFormat</b> function. This function is used in several places in MYGL. The following code, found in COPENGL.CPP, illustrates its use.</p>
<pre><code>int COpenGL::GetCurPFDIndex()
{
  int icuridx = GetPixelFormat(wglGetCurrentDC());
  return (icuridx);
  
}
</code></pre>
<p>
In this code, <b>GetPixelFormat</b> is used to retrieve the pixel format index of the current DC. That index is then passed to <b>DescribePixelFormat</b> to obtain more information about the pixel format.</p>
<p>
To retrieve the maximum number of device pixel formats supported for a given DC, use the <b>DescribePixelFormat</b> function. In the code below, the return value of <b>DescribePixelFormat</b> is assigned to the variable <i>ipfdmax</i>.</p>
<pre><code>int COpenGL::GetMaxPFIndex(HDC hdc)
{
  PIXELFORMATDESCRIPTOR pfd;
  
  int ipfdmax = DescribePixelFormat(hdc, 1, sizeof(PIXELFORMATDESCRIPTOR), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pfd);

  return (ipfdmax);
}
</code></pre>
<p>
The total number of device formats would be:</p>
<pre><code>iDevMax = ipfdmax - 24
</code></pre>
<h2>OpenGL/NT Rendering Contexts</h2>
<p>
There are three important things to remember about rendering contexts:
<ul type=disc>
<li>
The pixel format must be set up before creating the rendering context.<br><br></li>
<li>
The rendering context must be associated with a device context (by using <b>wglMakeCurrent</b>) before you can call OpenGL commands.<br><br></li>
<li>
The device context should not be released or deleted when it is associated with a rendering context (unless the DC belongs to a window whose class style is CS_OWNDC).</li>
</ul>
<p>
An OpenGL/NT rendering context (GLRC) is composed of a handle to an OpenGL/NT driver (if any), a client handle (HGLRC), the current pixel format index, a thread ID, and a handle to the DC bound to the rendering context.</p>
<p>
There are five functions, as shown in Table 4, that permit management of a rendering context.</p>
<p class=label>
<b>Table 4. OpenGL/NT Rendering Context Functions (WGL Functions)</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=33%><b>WGL Function</b></td>
<td class=label width=67%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=33%><b>wglCreateContext</b></td>
<td width=67%>Creates a new rendering context.</td>
</tr>
<tr valign=top>
<td width=33%><b>wglMakeCurrent</b></td>
<td width=67%>Sets a thread's current rendering context.</td>
</tr>
<tr valign=top>
<td width=33%><b>wglGetCurrentContext</b></td>
<td width=67%>Obtains a handle to a thread's current rendering context.</td>
</tr>
<tr valign=top>
<td width=33%><b>wglGetCurrentDC</b></td>
<td width=67%>Obtains a handle to the device context that is associated with a thread's current rendering context.</td>
</tr>
<tr valign=top>
<td width=33%><b>wglDeleteContext</b></td>
<td width=67%>Deletes a rendering context.</td>
</tr>
</table><br>
<p>
Of course all of these functions are important, but the one that will make or break you is <b>wglMakeCurrent</b>. It is the function that enables all drawing to take place on a DC. It makes the rendering context the calling thread’s current rendering context through which all OpenGL commands must "pass." Refer to the OpenGL/NT documentation for a more detailed description of these functions.</p>
<p>
In general, an application calls <b>wglCreateContext</b> and then associates the context with a device surface by calling <b>wglMakeCurrent</b>. OpenGL drawing can then take place on the device surface, after which the rendering context can be unassociated with the DC by calling <b>wglMakeCurrent</b> again (with NULL arguments). Finally, the rendering context can be deleted by calling <b>wglDeleteContext</b>.</p>
<h2>Pulling It All Together</h2>
<p>
As you can see, device contexts (including pixel formats) and rendering contexts are closely associated. So, just how does it all fall together? It all starts with a device context.</p>
<p>
The DC is used to create an OpenGL rendering context. This context is used by OpenGL to draw to the DC and ultimately the device surface. There are two ways you can approach the use of DCs. In Figure 5, the DC is created during initialization and destroyed as the application closes. The fact that we are not pairing <b>GetDC/CreateDC</b> and <b>ReleaseDC/DeleteDC</b> within the same scope is unnerving to some. Ah yes, we have been conditioned! Arf arf...drool.</p>
<p>
<img src="opengl9_6.gif" border=0></p>
<p class=label>
<b>Figure 5. First approach to use of device contexts with OpenGL</b></p>
<p>
Rest assured, you can follow your ingrained desire to delete the DC immediately after use. Figure 6 illustrates this. The rendering context is created in the response to WM_CREATE, and the DC used to create the context is released or deleted. It is not until the response to WM_PAINT that the rendering context is bound to a device context, in this case the Paint DC. It is important to note that this way of doing things is quite expensive. Making the context current is not trivial. The point to be made here is that a rendering context must be bound to a DC before OpenGL drawing can take place. You decide where and what DC you are going to bind to the rendering context (as long as the DC has the same pixel format as that used to create the rendering context).</p>
<p>
<img src="opengl9_7.gif" border=0></p>
<p class=label>
<b>Figure 6. Second approach to use of device contexts with OpenGL</b></p>
<p>
The OpenGL sample (GENGL) included with the Windows NT 3.5 Software Development Kit (SDK) takes the first approach. MYGL uses the first approach, although slightly modified. The rendering context is created in response to user input provided in a dialog box. When the dialog box is dismissed, the handle of the view window is used to obtain a DC and rendering context. When the view window is destroyed, the rendering context is deleted.</p>
<p>
There is a little "gotcha" that can prevent setting the pixel format of a device context. The window in which OpenGL drawing will take place must have the style bits WS_CLIPCHILDREN and WS_CLIPSIBLINGS set. Otherwise, <b>SetPixelFormat</b> will fail. The following code taken from MYGLVIEW.CPP shows how to override the <b>PreCreateWindow</b> function in order to set these style bits.</p>
<pre><code>BOOL CMyglView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
  //The view window style bits must include WS_CLIPSIBLINGS and
  //WS_CLIPCHILDREN so that the wgl functions will work.
  //
  cs.style = cs.style | WS_CLIPSIBLINGS | WS_CLIPCHILDREN;

  return CView::PreCreateWindow(cs);
}
</code></pre>
<p>
After the user has entered preliminary <b>PIXELFORMATDESCRIPTOR</b> values by way of the Choose Pixel Format (CPIXFORM.CPP) dialog box, the OK button is clicked and the <b>OnOK</b> function is called. After validating the existence of a rendering context and the appropriateness of the pixel format, the following code, from MYGL (in COPENGL.CPP), is called to set up the pixel format and create the rendering context.</p>
<pre><code>BOOL COpenGL::GetGLRC(HDC hdc)
{ 
 &nbsp; BOOL bRet = TRUE;

 &nbsp; ASSERT (m_pPixFmtDesc);

 &nbsp; if (SetupPixelFormat(hdc, m_pPixFmtDesc))
 &nbsp; {
 &nbsp;&nbsp;&nbsp; if ((m_hglrc = wglCreateContext(hdc)) != NULL)
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!wglMakeCurrent(hdc, m_hglrc))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wglDeleteContext(m_hglrc);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bRet = FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; else bRet = FALSE;
 &nbsp; }
 &nbsp; else 
 &nbsp;&nbsp;&nbsp; bRet = FALSE;

 &nbsp; return bRet;
}
</code></pre>
<p>
Once the pixel format is set up for the DC, the rendering context is created by a call to <b>wglCreateContext</b>. If the rendering context was successfully created, it is bound to the current DC. Note that this DC is not released. This does not happen until MYGL closes.</p>
<p>
MYGL draws by issuing OpenGL commands in the <b>OnDraw</b> function found in MYGLVIEW.CPP.</p>
<pre><code>void CMyglView::OnDraw(CDC* pDC)
{
  CMyglDoc* pDoc = GetDocument();
  RECT rc;
  COpenGL gl;
  HGLRC hglrc = gl.wglGetCurrentContext();

  if (hglrc)
  {
 &nbsp;&nbsp; GetClientRect(&amp;rc);
 &nbsp;&nbsp; DrawScene(rc);
  }
  
}
</code></pre>
<p>
The <b>wglGetCurrentContext</b> function is called to ensure that there is in fact a rendering context. However, if there was not, nothing adverse would happen. No drawing would take place. Note that the DC associated with pDC is not passed to <b>DrawScene</b>. The DC is implicit and is the DC associated with the rendering context.</p>
<p>
The following code is called when MYGL closes.</p>
<pre><code>BOOL COpenGL::ReleaseGLRC(HWND hwnd)
{
  BOOL bRet = TRUE;
  HDC&nbsp;&nbsp; hdc;
  HGLRC hglrc;
  
  if (hglrc = wglGetCurrentContext())
  {
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //Get the DC associated with the rendering context.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; hdc = wglGetCurrentDC();
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //Make the rendering context not current.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; wglMakeCurrent(NULL, NULL);
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //Nuke the DC.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; ::ReleaseDC(hwnd, hdc);
 &nbsp; //
 &nbsp; //Nuke the rendering context.
 &nbsp; //
 &nbsp; wglDeleteContext(hglrc);
  }
  else bRet = FALSE;
  return bRet;

}
</code></pre>
<p>
After retrieving the current DC, using <b>wglGetCurrentDC</b>, it is released. The rendering context is then released.</p>
<h2>Summary</h2>
<p>
Windows NT version 3.5 provides OpenGL capabilities. In the generic implementation, all of the pixel format and rendering management is handled by GDI. In the device implementation, much of this management is supported by the device. Before OpenGL drawing can take place, the window, bitmap, or device’s pixel format must be set up. A rendering context is then created. At this point, drawing can take place. Now that Windows NT provides the structure and functions for 3-D graphics, it is up to applications developers to provide the cool applications. Have fun.</p>
<p>
Future technical articles will zero in on OpenGL specifics. Stay tuned.</p>
<h2>Bibliography</h2>
<p>
<i>OpenGL Reference Manual, The Official Reference Document for OpenGL, Release 1</i>. OpenGL Architecture Review Board, 1992, Addison Wesley, ISBN 0-201-63276-4.</p>
<p>
<i>OpenGL Programming Guide, The Official Guide to Learning OpenGL, Release 1</i>. OpenGL Architecture Review Board, 1992, Addison Wesley, ISBN 0-201-63274-8.</p>
<p>
Windows NT SDK, Windows NT OpenGL documentation (pre-release)</p>
</BODY>
</HTML>
