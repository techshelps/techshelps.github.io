<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ASP Troubleshooting Tips and Techniques</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_tshoot2"></a></sup>ASP Troubleshooting Tips and Techniques</h1>
<p>
Mike Hedley<br>
Developer Support Engineer<br>
Microsoft Technical Support</p>
<p>
April 11, 1997</p>
<h2>Where and When Is the Problem Occurring?</h2>
<p>
When you use Active Server Pages (ASP), you’re operating in the client/server world of Microsoft® Internet Information Server (IIS) and the Hypertext Transfer Protocol (HTTP). Many customers who don’t have a firm grasp of this architecture find themselves puzzled by strange errors in what seems to be straightforward code. If you’ve ever been in this situation, don’t fret. The world of ASP and HTTP can be confusing, especially when you’re new to the technology.</p>
<p>
Let’s take a look at the sequence of events that occur when a client, such as Microsoft Internet Explorer, requests an ASP page. This discussion does not take into account the complexities of authentication on the ASP page. In our simplified discussion, the following three events take place:
<ol>
<li>
The client (Internet Explorer) requests an ASP page by sending an HTTP Request message to the Server.<br><br></li>
<li>
The server (IIS) recognizes that the requested page is an ASP page because it has an .asp file extension, and then sends the .asp file to asp.dll for processing. This processing includes execution of all server-side scripting code. (This step does not occur when the client requests an .htm file.)<br><br></li>
<li>
The server sends the resulting HTML page back to the client in the form of an HTTP Response.</li>
</ol>
<p>
Once the client receives the response, it executes any client-side script code and displays the Web page according to the HTML specification. While this process looks simple, keep in mind that the client and server could be hundreds, or even thousands, of miles apart. Therefore, when a problem arises, you must determine <i>where</i> the error is occurring—on the client or on the server. Equally important is understanding <i>when</i> each operation takes place. After ASP completes its processing in Step 2 and sends the response in Step 3, it moves on to other activities and other clients. The only way the client can recapture the server’s attention is to request another page via the HTTP protocol. In other words, there is no real connection between the client and server. This is a very important concept that must be understood. In the rest of this section, I will describe common types of problems encountered by ASP developers and demonstrate the extra effort that is often required to promote communication between the client and server.</p>
<p>
One type of problem occurs when developers try to access server-side scripts or objects from the client or, conversely, client-side objects from the server. As an example of the first scenario, consider client-side code that attempts to access one of ASP’s intrinsics, such as the Session<i> </i>object. This is destined for failure because the code running in Internet Explorer has no way of accessing the object located on the server. A typical error message might appear as follows:</p>
<pre><code>VBS Script Error: Object Required: Session
</code></pre>
<p>
Now consider the second scenario, where a server-side script attempts to manipulate a client-side object. For example, suppose you use server-side scripting to populate a client-side ActiveX™ list box control. While this seems like a simple task, you must keep in mind that the HTML page, and therefore the list box, does not yet exist when the server-side code is executed. Because the list box control hasn’t been created when the server-side script is run, the following code will generate a similar “Object Required” scripting error:</p>
<pre><code>&lt;% ListBox1.AddItem Value1 %&gt;
</code></pre>
<p>
To accomplish this task, use server-side code to generate client-side code that will populate the list box. You should put this code in the <b>Window_OnLoad</b> event, where it is guaranteed to be executed by the browser after the window and its child controls are created. The following code segment demonstrates this technique. The server-side scripting code substitutes the values stored in variables <i>Value1</i>, <i>Value2</i>, and <i>Value3</i> in the <b>AddItem</b> method calls. </p>
<pre><code>&lt;SCRIPT LANGUAGE="VBScript"&gt; 
&lt;!-- 
Sub Window_OnLoad() 
ListBox1.AddItem&nbsp; "&lt;% = Value1 %&gt;"
ListBox1.AddItem&nbsp; "&lt;% = Value2 %&gt;"
ListBox1.AddItem&nbsp; "&lt;% = Value3 %&gt;" 
End Sub 
--&gt; 
&lt;/SCRIPT&gt;
</code></pre>
<p>
Note that if you use the HTML &lt;SELECT&gt; tag instead of an ActiveX control, the procedure is slightly more direct. Because a list box created with the &lt;SELECT&gt; tag is based on HTML code, you can use server-side scripting to create the &lt;OPTION&gt; tags. The following example fills an &lt;OPTION&gt; tag with data provided by a field in the current record from the <b>rs</b> record set. Since there is no object creation, you do not need to place this code inside the <b>Window_OnLoad</b> event.</p>
<pre><code>&lt;OPTION VALUE= "&lt;%= rs("Name") %&gt;"&gt; &lt;%= rs("Name")%&gt;
</code></pre>
<p>
Another common problem encountered by ASP developers involves passing client data to the server. Suppose you want users to log on to your Web application by providing his or her name and ID number. To do this, create a simple HTML page with two INPUT items in an HTML form. The user is expected to enter the name and ID and click <b>Submit</b>. After the user submits the requested information, ASP verifies the user’s credentials through a database query. If the information is correct, you allow access; otherwise, this user is denied access to the page. The subtle point often overlooked in this procedure is passing the information provided by the user to ASP. Recall that the only way the client can recapture the server’s attention is to request another page via the HTTP protocol. In this case, the best approach is to <b>POST</b> the HTML form to an ASP page. Posting the form generates an HTTP Request that invokes ASP to process the requested page. During this ASP processing, the server-side script retrieves the posted data by calling <b>Request.Form</b> and performs the database query and other verification logic. The following code demonstrates a simplified version of this procedure. Notice that the user information is actually posted back to the same ASP file that displays the form. This is perfectly valid, and is often more convenient than posting to a second ASP page.</p>
<pre><code>&lt;%@ LANGUAGE="VBSCRIPT" %&gt;
&lt;!-- FILE: login.asp --&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Login Example&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;

&lt;% IF IsEmpty(Request.Form("Name")) THEN 
 &nbsp;&nbsp; Response.Write "Please enter your Name"
%&gt;
 &nbsp;&nbsp; &lt;FORM ACTION="login.asp" METHOD=POST&gt;
 &nbsp;&nbsp;&nbsp;&nbsp; &lt;INPUT NAME="Name"
 &nbsp;&nbsp; TYPE=TEXTBOX MAXLENGTH=20&gt;
 &nbsp; &lt;INPUT TYPE="SUBMIT" VALUE="Submit"&gt;
 &nbsp;&nbsp; &lt;/FORM&gt;
&lt;%
 &nbsp; ELSE&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; 'User verification code goes here
 &nbsp;&nbsp;&nbsp;&nbsp; Response.Write "Welcome " &amp; Request.Form("Name") &amp; "!"
 &nbsp; END IF
%&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
<p>
If you need to pass information from ActiveX controls on the page to the server, you will need to add client-side scripting that reads the values from the controls and stores them in members of a “hidden” form, which is posted to the .asp file. Another variation of this technique is to pass the values to ASP using the query string, although this approach is limited by the length restrictions imposed on the query string by the HTTP specifications for the GET request.</p>
<p>
As demonstrated in the preceding examples, ASP development requires a bit of creativity at times. However, keep in mind that many of these hurdles are actually imposed on ASP by the HTTP protocol and the client/server nature of Web development. If you consider some of the alternatives, I think you’ll agree that ASP is well worth the effort.</p>
<h2>Who Is Having the Problem?</h2>
<p>
By far, the largest segment of ASP issues handled in Developer Support involves security and permission problems. In order to avoid these problems, ASP developers must have a firm grasp of IIS authentication and controlling access to pages using NTFS file permissions. Although a thorough discussion of these topics is beyond the scope of this article, I will touch on the basic concepts and highlight the typical problems ASP developers encounter. For more information about securing your ASP application, see "Securing Your ASP Application" in the <i>Active Server Pages Scripting Guide</i> (MSDN Library) included in the ASP online documentation. </p>
<p>
Let’s begin with a quick overview of the client authentication types. Internet Information Server 3.0 supports three authentication schemes: anonymous, basic (clear text), and Microsoft Windows NT® Challenge/Response. Each of these authentication methods is enabled or disabled through the WWW Service Properties page in Microsoft Internet Service Manager. A typical IIS configuration has anonymous authentication enabled, as well as either, or both, of the other methods. Anonymous authentication is the least secure method, while basic authentication and Windows NT Challenge/Response authentication provide differing levels of security for your Web pages. The advantage of basic authentication is that it is part of the HTTP specification and is thus supported by most browsers. The disadvantage of basic authentication is that if someone is monitoring packets on your network, they could easily intercept and decipher your password using publicly available algorithms. This is not possible with Windows NT Challenge/Response authentication because the actual password is never sent over the wire. Instead, the browser returns a custom token that satisfies the server’s authentication request.</p>
<p>
Although NT Challenge/Response is very secure, it does have a couple of limitations. The first limitation is that only Microsoft browsers support this proprietary scheme. Another limitation is that Windows&nbsp;NT Challenge/Response does not work over HTTP proxy connections. Because of these limitations, Windows&nbsp;NT Challenge/Response may not always be the best choice for an <i>Internet</i> server, however it is often ideal for <i>intranet</i> use. As you can see, choosing an authentication method is a trade-off in security verses flexibility. </p>
<p>
Now, let’s discuss the authentication process. Before IIS returns a requested page to a client, it first verifies that the client has permission to view the page. Although you can restrict permission to a page by turning off Read and Execute permissions on its virtual root in IIS, we will assume that both Read and Execute permissions are granted in IIS for the virtual root. The preferred method of restricting access to individual pages is to use the Windows NT File System (NTFS) file permissions to control which users can view the page. Before returning a page to the client, IIS checks the NTFS file permissions on the page to see if the current user is allowed access to the file. In order to know who the current user is, you must understand the authentication process used by IIS. When you configure IIS for anonymous authentication, you must provide a username and password for the anonymous logon account. By default, this account is set to a user called IUSR_<i>MACHINE</i>, where <i>MACHINE</i> is the machine name of the Web server. IIS attempts to authenticate the anonymous logon account by checking to see if the IUSR_<i>MACHINE</i> account has permission to view the file. If the NTFS permissions on the file do not allow IUSR_<i>MACHINE</i> access to the requested page, IIS returns an "HTTP 401 Unauthorized"<i> </i>status code to the browser. At this point, the browser attempts to authenticate the user using one of the other authentication methods. If Windows NT Challenge/Response is used, the browser automatically returns the appropriate information to satisfy the authentication request. The user is not prompted for a username and password unless the server does not recognize the username provided by Windows&nbsp;NT Challenge/Response. If basic authentication is used, the user is prompted for his or her username and password. IIS then checks the user’s credentials against the access permissions on the requested page, and either returns the page to the browser or returns an access denied response.</p>
<p>
Now that we have covered the basics of authentication, let’s return to ASP troubleshooting. The important point of this section is that who you are at any given time in your ASP scripts depends on the authentication scheme used. If a user has been authenticated using either the basic or Window NT Challenge/Response scheme, then server-side scripts and components run in the security credentials of the person logged on to the client machine. If the user has been authenticated as the anonymous logon account, which is usually the case, ASP scripts and components run in the security credentials of IUSR_<i>MACHINE</i>, or whichever account you have designated as your anonymous logon account. If you take away only one piece of information from this article, please remember that <b>ASP scripts are typically executed in the security context of the IUSR_<i>MACHINE</i> account</b>. This concept is important because it is the root of many problems ASP developers encounter. </p>
<h2>What Is the Problem?</h2>
<p>
There is a wide range of problems that occur if the authenticated user does not have adequate permissions to complete a given task. This goes beyond having permissions on .asp files. Errors also occur if the authenticated user does not have sufficient permissions on other files such as custom components, system dynamic-link libraries (DLLs), and even registry keys. Unfortunately, these problems can exhibit a wide range of symptoms and error messages, so they are difficult to diagnose. In the following sections, I describe the three most common classifications of permission problems and provide some debugging techniques that you can use to track down these problems. </p>
<h3>Problems Accessing Remote Machines</h3>
<h4>Common symptoms</h4>
<ul type=disc>
<li>
"Microsoft OLE DB Provider for ODBC drivers error '80004005'" error received when attempting to open an Active Data Objects (ADO) connection.<br><br></li>
<li>
ASP code that worked fine when the database was located on the IIS Server no longer works when the Microsoft SQL Server or Microsoft Access database is moved to a remote machine.</li>
</ul>
<h4>Description</h4>
<p>
One of the most common types of problems occurs when ASP attempts to access resources located on remote machines. A good example of this is using ADO to access either Microsoft SQL Server on a remote machine or a Microsoft Access .mdb file located on another Windows NT machine. The problems stem from the fact that ASP is operating in the context of the IUSR_<i>MACHINE</i> account. On servers that are not primary or backup domain controllers, the IUSR_<i>MACHINE</i> account is a local account. Since this local account is not recognized on the remote machine, access is denied to the database. </p>
<p>
The two most common workarounds for this problem are:
<ol>
<li>
Change the anonymous logon account on the IIS server from IUSR_<i>MACHINE</i> to a domain account that is recognized by both machines and has sufficient permissions to the resource. In addition, be sure that this account has the <i>log on locally</i> user right on the IIS machine.&nbsp; Recall that the anonymous logon account is configured through Internet Service Manager.<p class=atl>
<b><B>Note</B>&nbsp;&nbsp;&nbsp;</b>If you later decide to change back to the IUSR_<i>MACHINE</i> account, be sure that the password provided in Internet Service Manager matches the password provided for this account in the User Manager tool. If the passwords do not match, you will encounter "Access Denied" errors.</p></li>
<li>
Add a local account to the remote machine that exactly matches the username and password of the IUSR_<i>MACHINE</i> account on the IIS machine, and give this account access to the database.<p class=atl>
<b><B>Note</B>&nbsp;&nbsp;&nbsp;</b>This workaround is not recommended because it involves maintaining two separate accounts. If the passwords get “out of sync” at some point in the future, access will be denied to the database, and errors will occur. </p></li>
</ol>
<h3>ADO and Other Component Problems</h3>
<h4>Common symptoms</h4>
<ul type=disc>
<li>
"ASP 0115—A trappable error has occurred" error received when attempting to use ADO. (Note: This is only one of the possible causes of the ASP 0115 error.)<br><br></li>
<li>
ASP pages that use ADO or other components suddenly no longer function properly.<br><br></li>
<li>
ASP pages that work on a development machine don’t work properly on a production Web server.</li>
</ul>
<h4>Description</h4>
<p>
Another type of problem can be attributed to permission settings—when components such as ADO simply don’t function properly. The root of these problems is often restricted NTFS permissions that don’t provide sufficient privileges to the IUSR_<i>MACHINE</i> account. If the same ASP code works on a different machine, or is used to work on the current machine, this is a strong indication of some sort of configuration problem such as restricted permissions. For example, many customers we speak to in Developer Support indicate that their ASP application works fine on their development machine, but does not work on their production Web server. This is due to the fact that most companies like to restrict access to production servers as much as possible. While this is a good practice, care must be taken to ensure that ASP is able to function properly. What typically happens is that NTFS file permissions are restricted on various directories to the point that IUSR_<i>MACHINE</i> cannot access the required files. This is a frequent problem because many administrators don’t realize the important role that the IUSR_<i>MACHINE</i> account plays in the world of ASP. ADO often falls victim to this problem because it depends on many DLLs that are located in various directories on your hard drive. In particular, ADO relies on many Open Database Connectivity (ODBC) DLLs and other database drivers that are located in the WINNT and System32 directories. ADO also depends on certain registry keys that may not be readable by the anonymous logon account if permissions are set incorrectly. In addition, some database drivers attempt to write to the registry, thus requiring write access for the anonymous logon account. The following section provides a few techniques that will assist you in locating the cause of the permissions problem.</p>
<h4>Debugging techniques</h4>
<ol>
<li>
The first step is to determine if you really are seeing a permissions problem. A good test is to <i>temporarily</i> add the anonymous logon account (IUSR_<i>MACHINE</i>) to the administrators group using User Manager. This gives the IUSR_<i>MACHINE</i> account administrative privileges on the machine. If this causes ASP to function properly, you are almost certainly dealing with a permissions issue. <p class=atl>
<b><B>Note</B>&nbsp;&nbsp;&nbsp;</b>When you have finished debugging, be sure to remove the IUSR_<i>MACHINE</i> account from the administrators group to minimize the security risk on your server.</p></li>
<li>
Another useful technique is to attempt to use ADO or the component in question from some other environment such as Microsoft Visual Basic®. This produces nearly the same effect as the first technique because Visual Basic operates in the security context of the user logged on to the workstation. If the component works from Visual Basic but not from ASP, a permissions problem is likely.<br><br></li>
<li>
Once you have concluded that you are dealing with a permissions problem, you need to locate the files that don’t have adequate permissions. This consists of systematically searching the directory tree to locate the problem files. Some users choose to give full control to the entire directory tree, and then work backwards to tighten down security until the error occurs. Since you can’t easily <i>undo</i> this change, consider creating a temporary account to use for this test. Set this account as the anonymous logon account and give it full control to the entire tree. Once you’ve located the problem, you can remove the account without affecting the permissions of the other user accounts on this machine.<br><br></li>
<li>
Another approach for locating files that do not have sufficient permissions is to use the security auditing functions provided by Windows NT. (This technique is explained in more detail in the Appendix.)<br><br></li>
<li>
If you believe you are dealing with a permissions problem in the registry, you can use Regedt32.exe to examine permissions on the various registry keys. In particular, you may want to look at ODBC, Jet, ADO, and other keys that are relevant to the problem. If you have a machine that is working properly, try comparing key permissions between the two machines.</li>
</ol>
<p class=indent>
<b><B>Note</B>&nbsp;&nbsp;&nbsp;</b>Although Windows NT includes registry auditing tools, this topic is not discussed here due to the complexity of the procedure and the danger involved with modifying the registry.</p>
<h3>Inability to Create Components</h3>
<h4>Common symptoms</h4>
<ul type=disc>
<li>
<b>Server.CreateObject</b> fails with an "ASP 0177: Server.CreateObject Failed" error.<br><br></li>
<li>
The problem component works fine on the same machine from Visual Basic or from some other tool.<br><br></li>
<li>
The problem component works fine with ASP on other machines.</li>
</ul>
<h4>Description</h4>
<p>
Other permission problems occur when ASP tries to create server-side components. The causes, symptoms, and debugging techniques are very similar to the previous discussion. The problems arise because the authenticated user does not have permission to invoke the Component Object Model (COM) object. In the simplest scenario, the authenticated user doesn’t have access to the component’s .dll or .exe file. In many cases, however, the component depends on other DLLs that the authenticated user does not have access to.</p>
<h4>Debugging techniques</h4>
<ol>
<li>
Although giving the IUSR_<i>MACHINE</i> account administrative permissions is useful in this scenario, a better first step is to invoke the component from some other tool such as Visual Basic. This approach is preferred because it checks for permission problems, as well as verifying that the component is registered properly on the server. If the component cannot be created from Visual Basic, you are probably not dealing with a permissions problem at all.<br><br></li>
<li>
If you believe you are dealing with a permissions problem, check permissions on the component and any dependent files such as other DLLs.<br><br></li>
<li>
If you still are unable to track down the problem, you may need to resort to other means such as a systematic permissions search, or Windows NT File and Object Auditing.</li>
</ol>
<p>
While the previous sections only touch on the most common permissions issues, I hope that you have gained an appreciation for the types of problems that are caused by permissions and other security settings. With an understanding of authentication and a few debugging tools at your disposal, you should be able to work through any permissions problem that comes your way.</p>
<h2>Conclusion</h2>
<p>
I hope this article has provided some useful insights that will make troubleshooting ASP applications a bit easier. With persistence and a little patience, I’m sure you’ll quickly locate the problem and move on to more important work, such as finding other exciting ways to use Active Server Pages in your business.</p>
<h2>Appendix</h2>
<p>
This appendix contains information on using Microsoft Windows NT security auditing, as well as references to other useful ASP information. Please note that security auditing requires the use of NTFS.</p>
<h3>Using Windows NT Security Auditing</h3>
<ol>
<li>
Start User Manager.<br><br></li>
<li>
On the <b>User</b> menu, click <b>Select Domain</b>. Select the domain for the local machine by entering the name of the local domain and click <b>OK</b>.<br><br></li>
<li>
Enable auditing by clicking <b>Audit. . . </b> on the <b>Policies</b> menu. Select <b>Audit These Events</b>, and then select <b>Failure</b> for <b>File and Object Access</b>. <br><br></li>
<li>
Next you need to tell Windows NT which directories and files you want to audit. Open the properties dialog box for the specified directory or file in Windows Explorer, click the <b>Security</b> tab, and click the<i> </i><b>Auditing. . . </b> button. Now click <b>Add. . . </b>and add the name of the user you want to audit (in this case IUSR_<i>MACHINE</i>). Next, select the desired combination of<i> </i><b>Replace Auditing on Subdirectories</b> and <b>Replace Auditing on Existing Files</b>. Finally, select <b>Failure</b> for the desired events.<br><br></li>
<li>
Using Internet Explorer, attempt to view the ASP pages that cause the permissions violation to occur.<br><br></li>
<li>
Open the Windows NT Event Viewer and choose <b>Security</b> from the <b>Log</b> menu. The security log should show all failed attempts by the specified account to any files that have auditing enabled.</li>
</ol>
<p class=indent>
<b><B>Note</B>&nbsp;&nbsp;&nbsp;</b>When you have finished troubleshooting, turn off auditing for best system performance. See the Windows NT online help for more details on auditing.&nbsp; </p>
<h3>Other ASP References</h3>
<ul type=disc>
<li>
The Microsoft Knowledge Base (KB) in the MSDN Library contains many useful articles on Active Server Pages. Search on "ASP."<br><br></li>
<li>
A collection of useful ASP scripts and component samples is available at <a href="http://www.microsoft.com/iis/">http://www.microsoft.com/iis/</a>. Click <b>Using IIS</b>, point to <b>Developing for IIS</b>, and then click <b>Samples, Components and Utilities</b>. In particular, The Permission Checker component can be used to see whether the Web user has access to a specified page or file.</li>
</ul>
</BODY>
</HTML>
