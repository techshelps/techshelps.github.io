<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating OLE Servers in Visual Basic to Simplify Windows Function Calls</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_apiole"></a></sup>Creating OLE Servers in Visual Basic to Simplify Windows Function Calls </h1>
<p>
Ken Lassesen<br>
Microsoft Developer Network Technology Group</p>
<p>
July 7, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4322">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the APIOLE16 sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article explains how to build both 16-bit and 32-bit out-of-process OLE servers in Visual Basic® version 4.0, servers that can encapsulate common Microsoft® Windows® application programming interface (API) calls or functions in third-party dynamic-link libraries (DLLs). Creating an OLE server wrapper around Windows calls permits 16-bit applications to call 32-bit API functions and 32-bit applications to call 16-bit API functions. The API call is also simplified by: 
<ul type=disc>
<li>
The addition of named properties to the API call.<br><br></li>
<li>
The removal of memory and structure allocations from your project.<br><br></li>
<li>
The removal of API declarations from your project.</li>
</ul>
<p>
The reader is assumed to have passed Microsoft Certification in Microsoft Visual Basic for Windows version 3.0 or have equivalent knowledge in making Windows API calls from Visual Basic.</p>
<h2>The API Journey Continues</h2>
<p>
This article describes how to build a simple out-of-process OLE server in Visual Basic® that allows you to make application programming interface (API) calls using this OLE server's properties and methods instead of using <b>Declare</b> statements. The Win32® Software Development Kit (SDK) and Win16 SDK are procedure-oriented and not object-oriented the way OLE servers are. I use OLE servers to place C-like calls out of sight and to stop rewriting the code to make the same API calls constantly.</p>
<p>
For most Microsoft® Office developers, the most important feature of an OLE server is that with an out-of-process server (an executable), an application can call a 16-bit API from a 32-bit application or call a 32-bit API from a 16-bit application with no difficulty. OLE will move the data across processes automatically—no thunking or determining the "bitness" of the engine by the developer. (See my articles listed in the "Bibliography" section for further information on this issue.) A second feature of this OLE server is the addition of named properties for API arguments (and the changing of some arguments to being optional). A third feature of this OLE server is the ability to access the API calls as classes of functions—classes that can reflect your view of API calls. The fourth feature of this OLE server is the simple way it provides for other developers to leverage the API knowledge of an expert. All of these features do come with the cost of slightly slower execution of API calls and slightly greater use of memory.</p>
<p>
The OLE server implements an approach similar to the one I used in my earlier article <a href="msdn_nativevb.htm">"Creating Useful Native Visual Basic and Microsoft Access Functions."</a> There is no need for the application to allocate space for the API-call arguments because the OLE server will allocate the space for the arguments and Visual Basic for Applications, Access Basic, and Visual Basic will release the space. This approach can also be used in C language as an alternative to thunking.</p>
<p>
Using an OLE server is a better approach for the 16-bit/32-bit interoperability problems than those described in my articles <a href="msdn_32bitapi.htm">"Porting Your 16-Bit Office-Based Solutions to 32-Bit Office"</a> and <a href="msdn_off95api.htm">"Corporate Developer's Guide to Office 95 API Issues."</a> There is no need for the solution code to determine the "bitness" of the application engine.</p>
<p>
Creating an OLE server is so easy in Visual Basic that it should be taught in every beginning Visual Basic class!</p>
<h2>A Map for the Journey</h2>
<p>
For an OLE server to be callable from both 16-bit and 32-bit applications, the server must be <i>out-of-process</i>—that is, an executable (.EXE) file. This article will show you how to:
<ul type=disc>
<li>
Create an invisible OLE server in Visual Basic that can make an API call.<br><br></li>
<li>
Use this OLE server from an Visual Basic for Applications product (Microsoft Excel) and from Microsoft Access version 2.0.</li>
</ul>
<p>
Before proceeding too far, let's look at how our solution code will change in appearance. Calling the <b>GetProfileString</b> function in Visual Basic for Applications has resulted in code like the following:</p>
<pre><code>REM Following line is needed ONCE in project
Declare Function GetProfileString Lib "Kernel" (ByVal lpAppName As String, 
 &nbsp; ByVal lpKeyName As String, ByVal lpDefault As String, ByVal lpReturnedString 
 &nbsp; As String, ByVal nSize As Integer) As Integer
.
.
.
Dim Buffer As String * 255,BufferLen As Integer, RC%, Default As String
BufferLen=255
RC% = GetProfileString("TEST", "KEY", "", Buffer, BufferLen)
If RC% &gt; 0 Then
 &nbsp;&nbsp; TestKey$ = Left$(Buffer, RC%)
Else
 &nbsp;&nbsp; TestKey$ = ""
End If
</code></pre>
<p>
When an OLE server is used, the code becomes much simpler and much clearer:</p>
<pre><code>Dim WinIni As New MyWinAPI.WinINI
.
.
.
TestKey$=WinIni.Value(AppName:="TEST", KeyName:="KEY")
</code></pre>
<p>
<b>MyWinAPI.WinINI</b> is the OLE server class used for API calls. After you declare and create an instance of the OLE server, the server's <b>Value</b> property calls the appropriate API automatically. The use of named properties makes the code easier to read and understand. The OLE server contains any needed declarations or type libraries to actually make the API call.</p>
<p>
So, how do we make this technological miracle happen?</p>
<h2>Creating an API OLE Server in Visual Basic</h2>
<p>
I will start by assuming that you are an experienced programmer in Visual Basic 3.0 who has just opened up Visual Basic 4.0 Professional or Enterprise Edition and that you have not had time to look at the manuals. I will go step by step through the process of building an out-of-process OLE server by building a OLE server that has one class module, <b>WinIni</b>, and one sample property, <b>Value</b>. For further details on building OLE servers, see the book <i>Creating OLE Servers</i> in the Visual Basic 4.0 documentation. </p>
<p>
Follow these four steps to construct an invisible OLE server in Visual Basic:
<ol>
<li>
Create an OLE server project. (I use the 16-bit version of Visual Basic for this sample.)<br><br></li>
<li>
Create a <b>Main</b> subroutine.<br><br></li>
<li>
Create a class module for the properties and methods.<br><br></li>
<li>
Create the properties and methods in this class module of the OLE server.</li>
</ol>
<p>
Steps 3 and 4 may be repeated in one project as often as needed. Once the server's code is completed, it can be used as an OLE server.</p>
<h3>Creating an OLE Server Project</h3>
<p>
The first step is to create an OLE server project:
<ol>
<li>
Start a new project in Visual Basic 4.0.<br><br></li>
<li>
From the Tools menu, choose Options, and then click the Project tab. <br><br></li>
<li>
Select Sub Main in the Startup Form list.<br><br></li>
<li>
Type <b>MyWinAPI</b> in the Project Name text box. This is the name of the OLE object.<br><br></li>
<li>
Type <b>My First WINAPI OLE Server</b> in the Application Description text box.<br><br></li>
<li>
Click OLE Server in the StartMode group, and click OK. See Figure 1.</li>
</ol>
<p>
<img src="apiole_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The Options dialog box set for an OLE server project</b></p>
<h3>Creating a Main Subroutine</h3>
<p>
The second step is to delete the default <b>Form1</b> and create a <b>Main</b> subroutine.
<ol>
<li>
From the File menu, choose Remove File.<br><br></li>
<li>
From the Insert menu, choose Module. <br><br></li>
<li>
From the Insert menu, choose Procedure. In the Insert Procedure dialog box, type <b>Main</b> in the Name text box, click Sub in the Type group, click Public in the Scope group, and then click OK. See Figure 2.<p class=tl>
I will leave this procedure empty so that the executable terminates if directly executed. You may wish to insert an informative message box instead.</P><p>
<img src="apiole_2.gif" border=0></P><p class=label>
<b>Figure 2. Creating the Main subroutine</b>
</li>
</ol>
<h3>Creating a Class Module</h3>
<p>
The third step is to create a class module for the properties and methods.
<ol>
<li>
From the Insert menu, choose Class Module.<br><br></li>
<li>
Press F4 to display the Property Sheet.<br><br></li>
<li>
Type <b>WinINI</b> as the <b>Name</b> property, set the <b>Instancing</b> property to "2 - Creatable MultiUse," and the <b>Public</b> property to "True" as in Figure 3.<br><br></li>
<li>
Close the property sheet by pressing ALT+F4<b>.</b><p>
<img src="apiole_3.gif" border=0></P><p class=label>
<b>Figure 3. The property sheet of a class module</b>
</li>
</ol>
<h3>Creating the Properties and Methods</h3>
<p>
<img src="apiole_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Creating a new property in a class module</b></p>
<p>
The fourth step is to create the properties and methods of the OLE server. The following process is repeated as often as needed:
<ol>
<li>
From the Insert menu, choose Procedure.<br><br></li>
<li>
Type <b>Value</b> in the Name text box, click Property in the Type group, click Public in the Scope group, and then click OK. See Figure 4.<p class=tl>
The following code is the result of this process:</P><pre><code>Public Property Get Value()
End Property
Public Property Let Value(vNewValue)
End Property
</code></pre>
</li>
</ol>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;A property <i>can</i> be on both the left and the right side of an equal sign (that is, you can both assign and read its values). A method is a procedure that can appear <i>only</i> on the right side of an equal sign.</p>
<p>
The default procedures for a property are shown above. Properties can be <b>Get</b> or <b>Let</b> or both. For my example property, a string property, I will use both <b>Get </b>and <b>Let</b>. The next step is to put your code to call the API into the procedures and add appropriate arguments. The names of the arguments will appear in the Visual Basic for Application Object Browser, so I would recommend dropping Hungarian notation prefixes and carefully choosing the names of all arguments. Do not change the name of <b>vNewValue</b>—just add data type information. The code below is based on samples Q82158 and Q142388 in the Visual Basic Knowledge Base. (See the "Bibliography" section for the full reference.) </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;For readability on the CD, we have added returns at the end of long lines of code (for instance, the "Private" lines), which would not normally be the case. To make the code compile properly, you will have to remove the returns.—Ed.</p>
<pre><code>Option Explicit
Private Declare Function GetProfileString Lib "Kernel" (ByVal lpAppName
 As String, ByVal lpKeyName As String, ByVal lpDefault As String, ByVal 
 lpReturnedString As String, ByVal nSize As Integer) As Integer
Private Declare Function WriteProfileString Lib "Kernel" (ByVal
 lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any) 
 As Integer
Const BufferLen = 255&nbsp;&nbsp; 'Max Size of All INI Strings
Public Property Get Value(AppName As String, KeyName As String) As String
Dim Buffer As String * BufferLen, RC%, Default As String
MsgBox AppName + KeyName + Buffer, BufferLen
RC% = GetProfileString(AppName, KeyName, Default, Buffer, BufferLen)
Value = Left$(Buffer, RC%)
End Property
Public Property Let Value(AppName As String, KeyName As String, vNewValue$)
Dim RC%
RC% = WriteProfileString(AppName, KeyName, vNewValue$)
End Property
</code></pre>
<h3>Running the Server</h3>
<p>
The next stage is to make our project into an executable. This is done in the usual way, but when you compile it, your executable is also registered as an OLE server automatically. If you run it by pressing F5, the project is temporarily registered as an OLE server. If you open the References dialog box in Microsoft Excel or some other Visual Basic for Applications product, you will see the OLE server <i>twice</i> as shown in Figure 5. One reference points to the executable and the other to the debug version.</p>
<p>
<img src="apiole_5.gif" border=0></p>
<p class=label>
<b>Figure 5. The References dialog box showing both compiled and debug OLE servers</b></p>
<p>
The extension on the file indicates whether it is the debugging version (.VBP) or the compiled version (.EXE or .DLL). When I need to debug my code, I select the server with the .VBP extension. For more information on debugging, see the documentation for Visual Basic 4.0. Next I will show you how I use this OLE server.</p>
<h2>Using a WinAPI OLE Server from Microsoft Excel and from Microsoft Access 2.0</h2>
<p>
Visual Basic 3.0 and Microsoft Access 2.0 support only ordered arguments for procedures, while later versions of these products and all products incorporating Visual Basic for Applications support both ordered arguments and named arguments. In this section I will illustrate the use of my OLE server in products that support named arguments—specifically 32-bit Microsoft Excel (version 5.0 or higher)—and then illustrate the equivalent use in products that support ordered arguments only (for example, 16-bit Microsoft Access, version 2.0 or lower.)</p>
<h3>Using an OLE Server from Visual Basic for Applications</h3>
<p>
Visual Basic for Applications is available in Visual Basic 4.0 or higher, Microsoft Excel 5.0 or higher, Microsoft Project 4.0 or higher, and Microsoft Access 95 or higher. Visual Basic for Applications may be added to other products in future versions, so this is <i>the </i>language to master for corporate developers or solution providers. After I have selected my OLE server in the References dialog box (see Figure 5), I press F2 to bring up the Object Browser, which I can use to paste in the OLE server code. The code is very simple, as shown below in a Microsoft Excel module sheet. "MyWinAPI" in the declaration points to the project name I entered into the Options dialog box in Figure 1. "WinINI" in the declaration points to the Class Module name I entered into the module property sheet above in Figure 3.</p>
<pre><code>Function WhereisMSINFO$()
Dim WINini As New MyWinAPI.WinINI
WhereisMSINFO$ = WINini.Value(AppName:="MSAPPS", KeyName:="msinfo")
End Function
</code></pre>
<p>
I could dimension the <b>WINini</b> variable either as <b>Object</b> or as <b>MyWinAPI.WinINI</b>. I always do the latter by declaring the <b>MyWinAPI.WinINI</b> template as <b>New</b> because this results in early binding with very significant performance improvements. The <b>Object</b> used with <b>CreateObject</b> or <b>GetObject</b> results in late binding and is considerably slower. See the OLE references in the "Bibliography" section for further information about early and late binding of OLE servers.</p>
<h3>Using an OLE Server from Microsoft Access 2.0 or Lower</h3>
<p>
Two problems are associated with using an OLE server in Microsoft Access 2.0 or lower and in Visual Basic 3.0 or lower: poor performance and the absence of named properties (and the associated Object Browser). The code must always use <b>Object</b> and thus does late binding. My code above becomes: </p>
<pre><code>Function WhereisMSINFO$ ()
Dim WINini As Object
Set WINini = CreateObject("MyWinAPI.WinINI")
WhereisMSINFO$ = WINini.Value("MSAPPS", "msinfo")
End Function
</code></pre>
<p>
The code is longer and is more obtuse because of the absence of named properties. </p>
<h3>OLE Server or Visual Basic Class Module</h3>
<p>
The creation of OLE servers to handle all of your API calls cuts development time, simplifies your code, and adds reusability of compiled code across multiple products. If you are working strictly in 32-bit mode, you may wish to create a version of the OLE server as an in-process server by compiling it as a dynamic-link library (.DLL) instead of an executable (.EXE). An in-process OLE server performs significantly faster than an out-of-process server and almost as fast as an internal procedure.</p>
<p>
If you are working in the Visual Basic 4.0 environment, you have another option: You could include the class modules in your project instead of referring to an OLE server. This results in slightly better performance, but it loses many benefits available from an OLE server. The last question is always, "What is the performance penalty?" If moving API calls to procedures from in-line code is acceptable to you, using an in-process OLE server will be very acceptable—the percentage increase is far less.</p>
<h2>"Rolling Your Own" OLE Server</h2>
<p>
That's it! The simplicity of this solution and the ease of implementation seems anticlimactic. An interesting aspect of this solution is that it has been available for years—the undiscovered OLE server.</p>
<p>
I can now create additional properties and methods for my own server. Actually, I would create <i>three</i> server projects that use the same class modules because there are differences between the API calls in 16-bit Windows and 32-bit Windows (the registry functions, for example). Also, some API calls should be done as in-process OLE server calls—for example, <b>GetCurrentProcess</b> and <b>GetPriorityClass</b>. The best performance is always with an in-process OLE server with early binding (a 32-bit DLL declared using the <b>New</b> keyword). The in-process OLE server will perform almost as fast as a class module or a subroutine in your program. Table 1 summarizes my suggested design.</p>
<p class=label>
<b>Table 1. A group of WinAPI OLE Servers for Visual Basic for Applications</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Name<br>
(note extensions)</b></td>
<td class=label width=25%><b><br>
OLE Server Type</b></td>
<td class=label width=25%><b><br>
16-bit/32-bit</b></td>
<td class=label width=25%><b>Server Name<br>
(see Figure 1)</b></td>
</tr>
<tr valign=top>
<td width=25%>APIOLE16.EXE</td>
<td width=25%>Out-of-process</td>
<td width=25%>16-bit</td>
<td width=25%>APIOLE16</td>
</tr>
<tr valign=top>
<td width=25%>APIOLE32.EXE</td>
<td width=25%>Out-of-process</td>
<td width=25%>32-bit</td>
<td width=25%>APIOLE32</td>
</tr>
<tr valign=top>
<td width=25%>APIOLE32.DLL</td>
<td width=25%>In-process (not accessible from 16-bit)</td>
<td width=25%>32-bit</td>
<td width=25%>APIOLE32P</td>
</tr>
</table><br>
<p>
The actual classes you choose to implement are what you need to examine next: Which API calls go into which class and which server, and what names are you going to give to them? (Keep in mind that a blind copying of the SDK cannot be done for properties.) My journey in this article is finished; your journey has just started.</p>
<h2>Bibliography</h2>
<p>
Brockschmidt, Kraig. <i>Inside OLE 2: The Fast Track to Building Powerful Object-Oriented Applications with Windows Objects</i>. Redmond, WA: Microsoft Press, 1994. (MSDN Library, Books)</p>
<p>
"How to Apply OLE 2 Technologies in Applications." (MSDN Library Archive, Backgrounders)</p>
<p>
Knowledge Base Q82158. "How to Set Windows System Colors Using API and Visual Basic." (MSDN Library, Knowledge Base)</p>
<p>
Knowledge Base Q142388. "Changing WIN.INI Printer Settings from VB using Windows API." (MSDN Library, Knowledge Base)</p>
<p>
Lassesen, Ken. <a href="msdn_off95api.htm">"Corporate Developer's Guide to Office 95 API Issues."</a> (MSDN Library, Technical Articles, Applications)</p>
<p>
Lassesen, Ken. "Issues to Consider When Porting 16-bit Office Solutions to Windows 95." Developer Network News 4 (May 1995). (MSDN Library, Periodicals, Microsoft Developer Network News)</p>
<p>
Lassesen, Ken. <a href="msdn_32bitapi.htm">"Porting Your 16-Bit Office-Based Solutions to 32-Bit Office."</a> (MSDN Library, Technical Articles, Applications)</p>
<p>
"Microsoft OLE Today and Tomorrow: Technology Overview." (MSDN Library Archive, Backgrounders and White Papers, Operating System Extensions)</p>
<p>
"Object Linking and Embedding 2.0 Backgrounder." (MSDN Library Archive, Backgrounders and White Papers, Operating System Extensions)</p>
</BODY>
</HTML>
