<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Migration Planning</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Migration Planning</h1>
<p>
This section addresses three areas that must be considered in a migration from Sybase to Microsoft SQL Server: data and object definitions, Transact-SQL and system stored procedure language changes, and administrative changes. It then discusses how to take advantage of the new features available in Microsoft SQL Server 6.5.</p>
<p>
The steps of the migration process are:
<ol>
<li>
Review the architectural differences between Microsoft SQL Server and Sybase SQL Server that require changes to administrative procedures.<br><br></li>
<li>
Migrate data and objects.<br><br></li>
<li>
Review stored procedures, triggers, Transact-SQL scripts, and applications for necessary language changes.<br><br></li>
<li>
Make necessary changes to client code. Transact-SQL statements issued by applications must reflect changes to object names forced by keyword conflicts. The application Transact-SQL must also reflect any changes required in order to comply with Microsoft Transact-SQL syntax.<br><br></li>
<li>
Test the client code.<br><br></li>
<li>
Make required changes to the site's administrative procedures.<br><br></li>
<li>
Review the new features available in Microsoft SQL Server and start making changes to take advantage of these features.</li>
</ol>
<h3>Addressing Architectural Differences</h3>
<p>
The architectures of Microsoft and Sybase SQL Servers are nearly identical, and most of the administrative procedures remain the same in the two systems. Databases are created on devices. The Data Definition Language (DDL) syntax for defining tables, views, stored procedures, defaults, rules, and most other objects has only a few differences between the two systems. Most of the system stored procedures are the same. Space within a database is still managed in allocation units and extents.</p>
<p>
Although the architectures of Microsoft and Sybase SQL Servers are similar, this section briefly discusses the major architectural differences that must be addressed as part of the migration from Sybase to Microsoft SQL Server.</p>
<h4>Client configuration and net-libraries</h4>
<p>
Microsoft SQL Server clients can use either the Microsoft DB-Library DLL or an ODBC driver to connect with the server. The following Microsoft-supplied components replace the Sybase client components.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Platform</b></td>
<td class=label width=33%><b>DB-Library</b></td>
<td class=label width=37%><b>ODBC Driver</b></td>
</tr>
<tr valign=top>
<td width=30%>Win32®</td>
<td width=33%>Ntwdblib.dll</td>
<td width=37%>Sqlsrv32.dll</td>
</tr>
<tr valign=top>
<td width=30%>Win16</td>
<td width=33%>Msdblib3.dll/W3dblib.dll</td>
<td width=37%>Sqlsrvr.dll</td>
</tr>
</table><br>
<p>
W3dblib.dll is the old name for the Win16 DB-Library DLL and is common between Microsoft and Sybase SQL Server clients. When practicable, Win16 applications for Microsoft SQL Server should be changed to Msdblib3.dll, which contains the same code as the W3dblib.dll but eliminates possible conflicts with the Sybase version of W3dblib.dll. The Win32 Ntwdblib.dll is specific to Microsoft SQL Server.</p>
<p>
Microsoft SQL Server clients should use the appropriate Microsoft Net-Library components.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Net-Library</b></td>
<td class=label width=34%><b>Win32 DLL</b></td>
<td class=label width=36%><b>Win16 DLL</b></td>
</tr>
<tr valign=top>
<td width=30%>TCP/IP Windows Sockets</td>
<td width=34%>Dbmssocn.dll</td>
<td width=36%>Dbmssoc3.dll</td>
</tr>
<tr valign=top>
<td width=30%>Named Pipes</td>
<td width=34%>Dbnmpntw.dll</td>
<td width=36%>Dbnmp3.dll</td>
</tr>
<tr valign=top>
<td width=30%>Multi-Protocol</td>
<td width=34%>Dbmsrpcn.dll</td>
<td width=36%>Dbmsrpc3.dll</td>
</tr>
<tr valign=top>
<td width=30%>Novell SPX/IPX</td>
<td width=34%>Dbmsspxn.dll</td>
<td width=36%>Dbmsspx3.dll</td>
</tr>
<tr valign=top>
<td width=30%>Banyan Vines</td>
<td width=34%>Dbmsvinn.dll</td>
<td width=36%>Dbmsvin3.dll</td>
</tr>
<tr valign=top>
<td width=30%>DECNet</td>
<td width=34%>Dbmsdecn.dll</td>
<td width=36%>N/A</td>
</tr>
<tr valign=top>
<td width=30%>AppleTalk</td>
<td width=34%>Dbmsadsn.dll</td>
<td width=36%>N/A</td>
</tr>
</table><br>
<p>
When the Microsoft SQL Server client software is installed on a computer, one of the components installed in the SQL Server program group is the SQL Client Configuration Utility. This utility is used to manage the client-side Net-Libraries. The user can choose which Net-Library to use as the default. The user can also make advanced entries to connect to servers that cannot be reached by simply using a Net-Library and the network name of the server. The advanced entries hold three components:
<ul type=disc>
<li>
SERVER<p class=tl>
The label by which the entry will be referenced at connect time. For example, if an advanced entry is created with SERVER=XYZ, then when <b>isql</b> is run with a <b>/S</b>xyz switch, this is the entry that will be used for the connection.</P></li>
<li>
DLL<p class=tl>
The name of the Net-Library module to use without the .dll extension. For example, specify dbmsrpcn, not dbmsrpcn.dll.</P></li>
<li>
CONNECTION STRING<p class=tl>
The network address of the server. If this is a Windows Sockets entry, it can be the port and socket address of the server. If it is a named pipes or multi-protocol entry, it is the network name of the server.</P></li>
</ul>
<p>
Note that Sybase and Microsoft maintain a 4.2 level of compatibility in their servers for clients running each other's client software. Microsoft servers can host Sybase clients, or Sybase servers can host Microsoft clients, provided they are limited to the features in SQL Server 4.2. They cannot use features introduced in System 10, System 11, SQL Server 6.0, or SQL&nbsp;Server&nbsp;6.5. These include new data types, new Transact-SQL statements, new ANSI-based statements, or new administrative procedures. Sybase sites planning to migrate to Microsoft SQL Server 6.0 or 6.5 and planning to use 6.0 or 6.5 features must convert the clients to Microsoft client software. Also, the current Microsoft SQL Server ODBC drivers cannot be used with Sybase servers, although ODBC drivers from other vendors can operate with both systems.</p>
<p>
Configuring the client Net-Libraries is covered in more detail in the <i>Microsoft SQL Server</i> <i>Administrator's Companion</i>.</p>
<h4>Database <i>sybsystemprocs</i></h4>
<p>
Beginning with System 10, Sybase SQL Servers store the system stored procedures in a database named <i>sybsystemprocs</i>. In Microsoft SQL Server, there is no <i>sybsystemprocs</i> database; all of the system stored procedures are stored in the <i>master</i> database. If user sites have scripts installing objects into <i>sybsystemprocs</i>, the scripts should be changed to use the <i>master</i> database.</p>
<h4>Database <i>msdb</i></h4>
<p>
Microsoft SQL Server versions 6.0 and 6.5 contain a new system database called the <i>msdb</i> database. This database is allocated on two new devices, msdbdata for data and msdblog for the log. The <i>msdb</i> database stores the data needed to support the new alerts, scheduled tasks, and Microsoft's implementation of replication (all of which are discussed later in the paper).</p>
<h4>System device and database sizes</h4>
<p>
The default size of the master device in Microsoft SQL Server versions 6.0 and 6.5 is 25 MB, the default size of the <i>master</i> database is 17 MB. There is no <i>sybsystemprocs</i> database.</p>
<p>
The following table shows the sizes of system devices and databases in the various versions of Microsoft SQL Server and Sybase SQL Server.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=23%><b>SQL Server version</b></td>
<td class=label width=22%><b>master device size</b></td>
<td class=label width=25%><b>master database size</b></td>
<td class=label width=30%><b>sybsystemprocs <br>
device size</b></td>
</tr>
<tr valign=top>
<td width=23%>Sybase 4.9.2</td>
<td width=22%>14 MB</td>
<td width=25%></td>
<td width=30%>None</td>
</tr>
<tr valign=top>
<td width=23%>Sybase System 10</td>
<td width=22%>17 MB</td>
<td width=25%></td>
<td width=30%>10 MB</td>
</tr>
<tr valign=top>
<td width=23%>Sybase System 11</td>
<td width=22%>21 MB*</td>
<td width=25%></td>
<td width=30%>16 MB</td>
</tr>
<tr valign=top>
<td width=23%>Microsoft 6.0</td>
<td width=22%>25 MB</td>
<td width=25%>17 MB</td>
<td width=30%>None</td>
</tr>
<tr valign=top>
<td width=23%>Microsoft 6.5</td>
<td width=22%>25 MB</td>
<td width=25%>17 MB</td>
<td width=30%>None</td>
</tr>
</table><br>
<p>
* If the <i>pubs2</i> sample database is also installed the size of a System 11 master device will be 28 MB.</p>
<p>
Sybase <i>master</i> databases have a table <i>sysusermessages</i> that holds user-defined messages. In Microsoft <i>master</i> databases, the user-defined messages are stored in the <i>sysmessages</i> table along with the system messages.</p>
<h4>Buffer management</h4>
<p>
Sybase System 11 introduced the concept of user-defined data caches. These caches allow each user to create an area of data cache that can be reserved for specific objects. Binding a specific object to a particular user-defined data cache prevents other objects from flushing the object's data pages from the cache.</p>
<p>
System 11 data caches can be subdivided into pools of 2K, 4K, 8K, or 16K. The larger pools provide the basis for large I/Os, which are reads that read 2, 4, or 8 pages at a time.</p>
<p>
Microsoft SQL Server 6.5 provides a <b>pintable</b> option on <b>sp_tableoptions</b> that prevents a table's pages from being flushed from the data cache. However, Microsoft SQL Server does not support user-defined data caches. See <b>sp_tableoptions</b> in this paper for more details.</p>
<h4>Table <i>syslogshold</i></h4>
<p>
System 11 databases contain a table <i>syslogshold</i><b>,</b> which records the oldest open transaction. In Microsoft SQL Server versions 6.0 and 6.5 the DBCC OPENTRAN statement performs the same function. All references to <i>syslogshold</i> need to be replaced with DBCC OPENTRAN logic.</p>
<h4>Setup</h4>
<p>
The Microsoft SQL Server Setup program automatically installs the DB-Library DLL and the Microsoft SQL Server ODBC driver, because Microsoft considers ODBC to be one of the native SQL Server APIs. Sybase installs only the CT-Library driver, which is its DB-Library equivalent.</p>
<h4>SQL Executive</h4>
<p>
SQL Executive is a separate process that runs as a Windows NT service on the server with SQL Server. It is the process that manages Microsoft SQL Server's replication, alerts, and scheduled tasks.</p>
<h4>Microsoft Distributed Transaction Coordinator</h4>
<p>
The Microsoft Distributed Transaction Coordinator (MS DTC) is a service that allows SQL Server applications to distribute transactions across multiple servers. It includes a simple API for managing transactions using two-phase commits that are easier to use than the two-phase commit functions originally implemented in DB-Library.</p>
<h3>Migrating Data and Objects</h3>
<p>
Moving data from the Sybase server to Microsoft SQL Server requires that the objects containing that data be checked first to ensure that their definitions will work correctly in Microsoft SQL Server.</p>
<p>
All sites should first migrate their Sybase databases to a test Microsoft database and fully test their applications and administrative procedures against the test Microsoft database. This should include stress testing, if possible, before transferring the entire production system over to Microsoft SQL Server.</p>
<p>
Sybase sites must review their SQL statements and the names of SQL Server objects for keyword conflicts, then they can transfer their objects and data to Microsoft SQL Server.</p>
<h4>New keywords</h4>
<p>
The first check is to ensure that none of the objects in your database has a name that conflicts with keywords in SQL Server.</p>
<h4>System 11 keywords not in SQL Server 6.5</h4>
<p>
The following Sybase System 11 keywords are not keywords in Microsoft SQL Server 6.5. Any statements using these keywords must be changed to work in a Microsoft environment.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=32%>ARITH_OVERFLOW</td>
<td width=27%>AT</td>
<td width=41%>CHAR_CONVERT</td>
</tr>
<tr valign=top>
<td width=32%>ENDTRAN</td>
<td width=27%>ERRORDATA</td>
<td width=41%>MAX_ROWS_PER_PAGE</td>
</tr>
<tr valign=top>
<td width=32%>NATIONAL</td>
<td width=27%>NOHOLDLOCK</td>
<td width=41%>NUMERIC_TRANSACTION</td>
</tr>
<tr valign=top>
<td width=32%>ONLINE</td>
<td width=27%>PARTITION</td>
<td width=41%>REPLACE</td>
</tr>
<tr valign=top>
<td width=32%>ROLE</td>
<td width=27%>ROWS</td>
<td width=41%>SHARED</td>
</tr>
<tr valign=top>
<td width=32%>STRIPE</td>
<td width=27%>SYB_IDENTITY</td>
<td width=41%>SYB_RESTREE</td>
</tr>
<tr valign=top>
<td width=32%>UNPARTITION</td>
<td width=27%>USER_OPTION</td>
<td width=41%>USING</td>
</tr>
</table><br>
<p>
<b>SQL Server 6.5 Keywords not in System 11</b></p>
<p>
The following Microsoft SQL Server 6.5 keywords are not listed as keywords in the Sybase System 11 documents. Objects containing these names in a Sybase database must be renamed before they can be moved to a Microsoft SQL Server, or the site must verify that all references to the objects use quoted identifiers.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=32%>CASE</td>
<td width=28%>COALESCE</td>
<td width=40%>COMMITTED</td>
</tr>
<tr valign=top>
<td width=32%>CROSS</td>
<td width=28%>CURRENT_DATE</td>
<td width=40%>CURRENT_TIME</td>
</tr>
<tr valign=top>
<td width=32%>CURRENT_TIMESTAMP</td>
<td width=28%>CURRENT_USER</td>
<td width=40%>DISTRIBUTED</td>
</tr>
<tr valign=top>
<td width=32%>DROP</td>
<td width=28%>FLOPPY</td>
<td width=40%>FULL</td>
</tr>
<tr valign=top>
<td width=32%>IDENTITY</td>
<td width=28%>IDENTITYCOL</td>
<td width=40%>INNER</td>
</tr>
<tr valign=top>
<td width=32%>INSENSITIVE</td>
<td width=28%>JOIN</td>
<td width=40%>LEFT</td>
</tr>
<tr valign=top>
<td width=32%>INSENSITIVE</td>
<td width=28%>NOCHECK</td>
<td width=40%>NULLIF</td>
</tr>
<tr valign=top>
<td width=32%>OUTER</td>
<td width=28%>PIPE</td>
<td width=40%>REPEATABLE</td>
</tr>
<tr valign=top>
<td width=32%>REPLICATION</td>
<td width=28%>RESTRICT</td>
<td width=40%>RIGHT</td>
</tr>
<tr valign=top>
<td width=32%>SCROLL</td>
<td width=28%>SERIALIZABLE</td>
<td width=40%>SESSION_USER</td>
</tr>
<tr valign=top>
<td width=32%>SYSTEM_USER</td>
<td width=28%>TAPE</td>
<td width=40%>THEN</td>
</tr>
<tr valign=top>
<td width=32%>UNCOMMITTED</td>
<td width=28%>UPDATETEXT</td>
<td width=40%>WHEN</td>
</tr>
</table><br>
<h4>Transferring objects and data</h4>
<p>
Two processes can be used to transfer objects and data from a Sybase SQL Server to a Microsoft SQL Server. The most user-friendly tool to use is the Transfer Manager component of SQL Enterprise Manager; the other method is to use SQL scripts to transfer the object definitions and the bcp utility to transfer the data.</p>
<h4>Transfer manager</h4>
<p>
The Transfer Manager component of SQL Enterprise Manager was built to allow easy transfer of databases or specific objects in databases from one Microsoft SQL Server to another. It addresses moving data when DUMP/LOAD cannot be used because SQL Servers may have different sort orders, different code pages, or residing on different hardware platforms (Intel, Alpha, PowerPC, or MIPS). It was also written to support Sybase SQL Servers as the source of a transfer. To transfer a Sybase database to a Microsoft SQL Server:
<ol>
<li>
Use the Microsoft Client Configuration Utility to create an advanced entry that allows Microsoft SQL Server tools to connect to the Sybase SQL Server. Set the server name to the computer name of the server running Sybase. Set the DLL name to the name of a Microsoft Net-Library DLL, without the .dll extension (dbnmpntw, dbmssocn, dbmsspxn, dbmssvinn). Set the connection string to the connection string found in the Sybase Sql.ini file. This is usually located in \Sybase_directory\Ini\Sql.ini.<br><br></li>
<li>
In SQL Enterprise Manager, create a database large enough to hold the data from the Sybase database being transferred.<br><br></li>
<li>
In SQL Enterprise Manager, click <b>Tools-Database/Object_Transfer</b>. Click <b>Foreign Source</b> and specify the Sybase database as the source. Select the database created in step 2 as the target database. Select the other options consistent with the number of objects to be transferred and start the transfer.</li>
</ol>
<p>
Before starting the transfer, check the names of all the objects (tables, columns, views, and so on) against the Microsoft SQL Server list of keywords that are not keywords in Sybase SQL Servers. Objects whose names are Microsoft keywords can still be transferred by using the Quoted Identifier option. After the object has been transferred, decide if the old name should be retained; this forces users trying to access the object to always use SET QUOTED_IDENTIFIERS ON. Consider recreating the object to eliminate the keyword conflict and changing all programs and Transact-SQL scripts to reflect the new name. A table or one of a table's columns can be renamed by selecting the table into a table with a new name, verifying the data in the new table, dropping the old table, and recreating all indexes on the table. If the table name does not have to be changed, use <b>sp_rename</b> to change the new table name to the old table name after dropping the old table.</p>
<p>
Transfer Manager does not convert extended characters if the database is using them. Extended characters are the characters in a code page that evaluate to a value larger than 128 and represent characters such as European accented letters and other special characters.</p>
<h4>SQL scripts and bulk copy program (bcp)</h4>
<p>
Sybase sites that already have SQL scripts to create a database and all of its objects can use the following process instead of using Transfer Manager. Sites without such scripts can generate them by using the Sybase SQL Manager utility.
<ol>
<li>
Review the scripts for keyword conflicts. If any are found, the script should be changed to either rename the object or to use quoted identifiers so that the keyword name can be created in the database.<br><br></li>
<li>
Review generated triggers and stored procedures for statements that must be changed to Microsoft syntax. For details about statements that may need to be changed, see "Language Changes."<br><br></li>
<li>
Create a test database in the Microsoft server and use the scripts with the Microsoft version of <b>isql</b> to create the objects in the Microsoft SQL Server.<br><br></li>
<li>
Change user, database, or server configuration options as necessary. SET statements affect only the connection that issued them. <b>sp_dboption</b> affects an entire database, and <b>sp_configure</b> options affect an entire SQL Server.<br><br></li>
<li>
Use the Sybase version of bcp (usually in the Sybase\Bin directory) to bulk copy the data from the Sybase SQL Server into an intermediate file. Use the character mode bcp option, not the native mode option.<br><br></li>
<li>
Use the Microsoft version of bcp (in either Sql60\Binn for version 6.0 or Mssql\Binn for version 6.5) to bulk copy the data from the intermediate file into the Microsoft SQL Server.</li>
</ol>
<p>
Care must be taken to ensure that the formats of the tables (number, size, and data types of columns) are the same in the Microsoft SQL Server as they are in the Sybase server. The same bcp options should be used on both the transfer out of Sybase and the transfer in to Microsoft. For more information about bcp, see the Sybase and Microsoft documentation.</p>
<h3>Language Changes</h3>
<p>
This section discusses the differences between the Sybase and Microsoft Transact-SQL dialects and system stored procedures that must be addressed for a successful migration.</p>
<h4>Transact-SQL</h4>
<p>
The following issues affect Transact-SQL in scripts, applications, triggers, and stored procedures.</p>
<h4>Transaction management</h4>
<p>
Both Sybase and Microsoft SQL Servers support explicit transactions managed with the statements BEGIN TRANSACTION, SAVE TRANSACTION, COMMIT TRANSACTION, and ROLLBACK TRANSACTION.</p>
<p>
Sybase SQL Server has a ROLLBACK TRIGGER statement that rolls back only the work done by the statement that fired the trigger. Microsoft SQL Server does not support ROLLBACK TRIGGER. The ROLLBACK TRIGGER statements must be replaced with paired SAVE TRANSACTION tr1… ROLLBACK TRANSACTION tr1 statements, which can roll back a single SQL statement without affecting the rest of the transaction. Applications using ROLLBACK TRIGGER should instead issue SAVE TRANSACTION tr1 immediately before executing the statement that fires the trigger, execute the statement that fires the trigger, and then issue the ROLLBACK TRANSACTION tr1 statement (if needed) before executing any other SQL statements.</p>
<p>
Sybase System 10 introduced chained transactions, which have implicit starting points but must be explicitly committed. A connection can put itself into or out of a chained transaction state with the SET statement:</p>
<pre><code>SET CHAINED [ON | OFF]
</code></pre>
<p>
Microsoft SQL Server 6.5 introduced a similar feature called implicit transactions. Microsoft implicit transactions function the same as Sybase chained transactions. Microsoft implicit transactions are also controlled by the SET statement:</p>
<pre><code>SET IMPLICIT_TRANSACTIONS [ON | OFF]
</code></pre>
<p>
SET CHAINED statements in Sybase applications must be changed to SET IMPLICIT_TRANSACTION statements.</p>
<p>
Sybase stored procedures are tagged with the transaction mode (chained or unchained) with which they were created, while Microsoft procedures operate in the transaction mode that exists when they are executed. Therefore, Sybase procedures can have COMMIT TRANSACTIONS that are not matched with a BEGIN TRANSACTION statement; this is not allowed in Microsoft procedures. Because of this, all Sybase procedures created in chained mode must be scanned for COMMIT TRANSACTION statements that do not have matched BEGIN TRANSACTION statements. Either remove the COMMIT or add a BEGIN TRANSACTION to the procedure before it is migrated to Microsoft.</p>
<p>
The Sybase <i>@@tranchain</i> variable indicates the current transaction mode (0=unchained, 1=chained). Microsoft SQL Server has no <i>@@tranchain</i> variable. The 2 bit in the Microsoft variable <i>@@options</i> reports the mode of implicit_transactions:</p>
<pre><code>IF (@@options &amp; 2) &gt; 0
 &nbsp; PRINT 'Implicit_transactions on'
ELSE
 &nbsp; PRINT 'Implicit_transactions off'
</code></pre>
<p>
The Sybase variable <i>@@transtate</i> indicates whether a transaction is in-progress, successful, or aborted. Microsoft SQL Server has no <i>@@transtate</i> variable. Replace <i>@@transtate</i> logic with either <i>@@error</i> checking or SET XACT_ABORT ON for the Microsoft SQL Server to automatically roll back a transaction when an error occurs.</p>
<p>
Microsoft SQL Server has no equivalent for the <b>sp_procxmode</b> system stored procedure, which Sybase sites use to control the transaction modes of stored procedures. Sybase procedures must have COMMIT statements matched with BEGIN TRANSACTION statements or be removed from the stored procedures.</p>
<h4>Transaction isolation levels</h4>
<p>
While Sybase identifies its transaction isolation levels with numbers, Microsoft identifies the levels with character tags. Scan for SET TRANSACTION ISOLATION LEVEL statements and change the Sybase level specifications to Microsoft specifications.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Sybase</b></td>
<td class=label width=52%><b>Microsoft</b></td>
</tr>
<tr valign=top>
<td width=48%>0</td>
<td width=52%>READ UNCOMMITTED</td>
</tr>
<tr valign=top>
<td width=48%>1</td>
<td width=52%>READ COMMITTED</td>
</tr>
<tr valign=top>
<td width=48%>3</td>
<td width=52%>REPEATABLE READ or SERIALIZABLE</td>
</tr>
</table><br>
<p>
Microsoft's current implementation of REPEATABLE READ is the same as the implementation of SERIALIZABLE. Sybase's use of the number 3 corresponds with the SERIALIZABLE label.</p>
<h4>Cursors</h4>
<p>
This section will discuss differences in cursors that must be addressed for a successful migration. The new cursor scrolling options offered in Microsoft's cursor implementation, which sites can start using after migrating, are discussed in "Using New Microsoft Features."</p>
<p>
Microsoft SQL Server supports the Sybase cursor statements, except for a minor difference in the DEALLCATE CURSOR statement. In Microsoft SQL Server, the keyword CURSOR is not used with the DEALLOCATE cursor statement.</p>
<p>
Sybase: DEALLOCATE CURSOR <i>cursor_name</i><br>
Microsoft: DEALLOCATE <i>cursor_name</i></p>
<p>
Error checking is different in the two SQL Server implementations. Sybase cursors report errors through <i>@@sqlstatus</i>, while Microsoft reports errors through <i>@@fetch_status</i>. In addition, Microsoft and Sybase report different values.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=46%><b>Sybase <i>@@sqlstatus</i></b></td>
<td class=label width=54%><b>Microsoft <i>@@fetch_status</i></b></td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=54%>-2 = Row deleted from result set</td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=54%>-1 = End of result set</td>
</tr>
<tr valign=top>
<td width=46%>0 = Success</td>
<td width=54%>0 = Success</td>
</tr>
<tr valign=top>
<td width=46%>1 = Type mismatch</td>
<td width=54%></td>
</tr>
<tr valign=top>
<td width=46%>2 = End of result set</td>
<td width=54%></td>
</tr>
</table><br>
<p>
Sybase allows different stored procedures to open cursors with identical names. Each cursor with the same name gets a separate result set. Microsoft SQL Server considers the scope of a cursor name to be the current session. The server will not allow different stored procedures that are executed by the same connection open cursors with duplicate names.</p>
<p>
Microsoft SQL Server cursors default to optimistic concurrency control, which does not place shared locks on tables. Sybase cursors generally default to pessimistic concurrency control, which places shared locks on the underlying tables. The pessimistic concurrency can reduce concurrency in high use environments.</p>
<h4>Optimizer hints</h4>
<p>
Sybase SQL Server supports index optimizer hints based on either index name or index ID:</p>
<pre><code>SELECT * FROM MyTable (index Idx1)
</code></pre>
<p>
or</p>
<pre><code>SELECT * FROM MyTable (1)
</code></pre>
<p>
Microsoft SQL Server uses a similar format. The only difference is that Microsoft SQL Server requires an equal sign (=) when using index names:</p>
<pre><code>SELECT * FROM MyTable (index = Idx1)
</code></pre>
<p>
Microsoft SQL Server treats the NOHOLDLOCK, HOLDLOCK, and SHARED optimizer hints in the same way as Sybase SQL Server. Microsoft SQL Server also introduces new locking optimizer hints, which are discussed in "Using New Microsoft Features."</p>
<p>
Microsoft SQL Server does not support the System 11 hints PREFETCH, LRU, or MRU. These must be removed. Microsoft SQL Server automatically uses READ AHEAD processing when it is appropriate. This behavior can be tailored with new RA options on <b>sp_configure</b>, which is discussed in "System Stored Procedures."</p>
<h4>Server roles</h4>
<p>
Microsoft SQL Server does not support the Sybase server roles of sa_role, sso_role, or oper. GRANT and REVOKE statements referencing these roles must be removed. In a Microsoft SQL Server system the SA login has the functions for the Sybase sa_role and sso_role. By using the GRANT statement, individual users can be given permissions to do the operator actions of dumping databases and transactions but cannot be given permissions to load databases and transactions.</p>
<p>
Also, the Sybase function <b>proc_name</b>, which validates a user's name, is not supported and must be removed.</p>
<h4>Temporary table names</h4>
<p>
Microsoft SQL Server limits the names of temporary tables to 20 bytes, including the number sign (#). Sybase allows up to 30 bytes in a temporary table name.</p>
<h4>RAISERROR</h4>
<p>
The Sybase version of RAISERROR allows argument substitution in any order, but the arguments must be varchar or char. Microsoft's version of RAISERROR requires positional argument substitution, like C's printf, but supports integer and string substitution: %d, %i, %s. Microsoft's RAISERROR statement also supports the specification of a severity level (range 1 through 25). Microsoft's RAISERROR adds a WITH LOG parameter, which tells the server to put the message in the error log. Messages raised with severities from 19 through 25 require the WITH LOG parameter.</p>
<h4>PRINT</h4>
<p>
The Sybase version of PRINT allows argument substitution, while the Microsoft version does not. The easiest solution is to change any Sybase PRINT that uses argument substitution to a RAISERROR with a severity of 10 or lower. Another solution is to print a string built of substrings in Microsoft SQL Server:</p>
<pre><code>DECLARE @msg VARCHAR(255)
SELECT @msg = 'The object ' + @tablename + 'does not allow duplicate keys.\n'
PRINT @msg
</code></pre>
<h4>Partitioned tables vs. row locking</h4>
<p>
Microsoft SQL Server does not support the keyword PARTITION on the ALTER TABLE statement. In System 11, partitions are supported only on user tables that do not have clustered indexes. Partitioned tables reduce lock contention on inserts by providing multiple page chains. A user can insert into one partition without blocking another user concurrently inserting into another partition. This new System 11 feature alleviates the blocking caused by the lack of row-level locking.</p>
<p>
Microsoft SQL Server 6.5 supports row locking on inserts, which is another method for reducing insert lock contention:</p>
<pre><code>sp_tableoption MyTable, 'insert row lock', true
</code></pre>
<p>
The Microsoft row-locking option is available on all table types, not only on user tables without clustered indexes as in System 11 partitioned tables.</p>
<h4>Setting ANSI NULL behavior</h4>
<p>
Both SQL Server 6.5 and System 10 and 11 support ANSI-compliant NULL behavior. However, the syntax in the two systems is different and must be converted as part of a migration:</p>
<p>
Sybase:</p>
<pre><code>SET ANSINULL {ON|OFF}
</code></pre>
<p>
Microsoft SQL Server 6.5:</p>
<pre><code>SET ANSI_NULLS {ON|OFF}
SET ANSI_WARNINGS {ON|OFF}
</code></pre>
<p>
Microsoft SQL Server supports setting options that define whether columns in CREATE TABLE statements take the ANSI NULL defaults:</p>
<pre><code>SET ANSI_NULL_DFLT_ON {ON|OFF}
SET ANSI_NULL_DFLT_OFF {ON|OFF}
</code></pre>
<h4>IDENTITY columns</h4>
<p>
The Microsoft and Sybase syntax for defining identity columns is the same. The Microsoft default name for an identity column is IDENTITYCOL; the Sybase default name is SYB_IDENTITY. All references to SYB_IDENTITY must be changed to IDENTITYCOL.</p>
<p>
If an identity column is used in an index, it can generate lock contention on the index. In Microsoft SQL Server 6.5, this can be reduced by enabling insert row-level locking on the table by using <b>sp_tableoption</b>.</p>
<p>
For more information about identity columns, see "Using New Microsoft Features."</p>
<h4>SET statement</h4>
<p>
Since their respective 4.2 versions, the SET statement options implemented by both vendors have diverged. Although the new options may have the same or similar names, their defined characteristics can be slightly different. For example, the full effect of the Sybase ANSINULLS option combines behavior defined by the two Microsoft options ANSI_NULLS and ANSI_WARNINGS.</p>
<p>
The following table lists the Sybase-specific options that do not exist with Microsoft SQL Server and the Microsoft options that most closely match the behavior of the Sybase option. The defined behaviors may not be an exact match, so users must review the Microsoft documentation carefully. The table does not list the options that are similar between the two vendors.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=45%><b>Sybase option</b></td>
<td class=label width=55%><b>Microsoft option</b></td>
</tr>
<tr valign=top>
<td width=45%>ANSINULLS</td>
<td width=55%>ANSI_NULLS, ANSI_WARNINGS.</td>
</tr>
<tr valign=top>
<td width=45%>ANSI_PERMISSIONS</td>
<td width=55%>No equivalent.</td>
</tr>
<tr valign=top>
<td width=45%>ARITHABORT can take overflow or trunc. Options.</td>
<td width=55%>ARITHABORT does not support options.</td>
</tr>
<tr valign=top>
<td width=45%>ARITHIGNORE can take overflow option.</td>
<td width=55%>ARITHIGNORE does not support options.</td>
</tr>
<tr valign=top>
<td width=45%>CHAINED</td>
<td width=55%>IMPLICIT_TRANSACTION.</td>
</tr>
<tr valign=top>
<td width=45%>CLOSE ON ENDTRAN</td>
<td width=55%>CURSOR_CLOSE_ON_COMMIT.</td>
</tr>
<tr valign=top>
<td width=45%>CHAR_CONVERT</td>
<td width=55%>Set with either ODBC or DB-Library connect options.</td>
</tr>
<tr valign=top>
<td width=45%>CURSOR ROWS</td>
<td width=55%>No equivalent.</td>
</tr>
<tr valign=top>
<td width=45%>DUP_IN_SUBQUERY (System 10 only)</td>
<td width=55%>DBCC trace flag 242.</td>
</tr>
<tr valign=top>
<td width=45%>FIPSFLAGGER takes ON/OFF</td>
<td width=55%>FIPSFLAGGER takes a FIPS level identifier.</td>
</tr>
<tr valign=top>
<td width=45%>FLUSHMESSAGE</td>
<td width=55%>No equivalent.</td>
</tr>
<tr valign=top>
<td width=45%>PREFETCH</td>
<td width=55%>See Microsoft READ AHEAD processing.</td>
</tr>
<tr valign=top>
<td width=45%>ROLE</td>
<td width=55%>No equivalent.</td>
</tr>
<tr valign=top>
<td width=45%>SELF_RECURSION</td>
<td width=55%>No equivalent.</td>
</tr>
<tr valign=top>
<td width=45%>STATISTICS SUBQUERYCACHE</td>
<td width=55%>No equivalent (STATS TIME and IO supported).</td>
</tr>
<tr valign=top>
<td width=45%>STRING_RTRUNCATION</td>
<td width=55%>No equivalent.</td>
</tr>
<tr valign=top>
<td width=45%>TABLE COUNT</td>
<td width=55%>No equivalent.</td>
</tr>
<tr valign=top>
<td width=45%>TRANSACTION ISOLATION LEVEL {0|1|3}</td>
<td width=55%>Levels specified with strings (like READ COMMITED).</td>
</tr>
</table><br>
<h4>Subquery behavior</h4>
<p>
Subqueries have non-ANSI behavior in Sybase SQL Server 4.9.2 and Microsoft SQL Server 4.2<i>x</i> versions. For example, subqueries return duplicate rows. System 10 and Microsoft SQL Server versions 6.0 and 6.5 default to ANSI-standard behavior, but the old subquery behavior can be turned on to ease migration. System 10 sites do this with the SET DUP_IN_SUBQUERY ON; Microsoft SQL Servers do it with DBCC TRACEON 242. System 11 only supports ANSI subquery behavior.</p>
<h4>System stored procedures</h4>
<p>
The Microsoft and Sybase implementations of the system stored procedures <b>sp_addmessage</b>, <b>sp_dboption</b>, and <b>sp_configure </b>are not the same. Sybase sites must change their use of these stored procedures to match the Microsoft implementation as part of the migration from Sybase SQL Server to Microsoft SQL Server.</p>
<h4>sp_addmessage</h4>
<p>
In Sybase systems, the range for user-defined message numbers starts at 20000. In Microsoft SQL Server the range starts at 50000. Microsoft also requires a severity to be specified (range is 1 through 25) to support alerts. Microsoft SQL Server stores user messages in <b>master.dbo.sysmessages</b>, while Sybase stores them in <b>master.dbo.sysusermessages</b>.</p>
<h4>sp_dboption</h4>
<p>
The following table lists the Sybase specific <b>sp_dboption</b> parameters that do not match Microsoft's <b>sp_dboption</b> parameters and the Microsoft feature that most closely matches the Sybase behavior.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Sybase</b></td>
<td class=label width=51%><b>Microsoft</b></td>
</tr>
<tr valign=top>
<td width=49%>ABORT TRAN ON LOG FULL</td>
<td width=51%>No equivalent.</td>
</tr>
<tr valign=top>
<td width=49%>ALLOW NULLS BY DEFAULT</td>
<td width=51%>ANSI NULL DEFAULT.</td>
</tr>
<tr valign=top>
<td width=49%>AUTO IDENTITY</td>
<td width=51%>No equivalent.</td>
</tr>
<tr valign=top>
<td width=49%>DDL IN TRAN</td>
<td width=51%>Version 6.5 allows DDL in transactions.</td>
</tr>
<tr valign=top>
<td width=49%>IDENTITY IN NONUNIQUE INDEX</td>
<td width=51%>No equivalent.</td>
</tr>
</table><br>
<p>
Sybase SQL Servers require a checkpoint in the affected database after <b>sp_dboption</b> completes, while Microsoft SQL Server 6.0 and 6.5 automatically checkpoint the affected database. Also, Microsoft SQL Server 6.5 allows DDL in transactions without requiring the SA to set any server or database options.</p>
<h4>sp_configure</h4>
<p>
The Sybase and Microsoft versions of <b>sp_configure</b> were similar in the 4.2<i>x</i> releases. The internal architecture of Microsoft SQL Server has changed significantly in the 6.0 and 6.5 versions as a result of Microsoft's effort to tightly integrate the database with Windows NT. Therefore, the post-4.2<i>x</i> <b>sp_configure</b> options are quite different between the two vendors. Detailing all of the differences is beyond the scope of this paper. Sybase DBAs should review the SQL Server documentation for information about the Microsoft tuning options reflected in <b>sp_configure</b>.</p>
<p>
Microsoft configuration options can be set using either <b>sp_configure</b> or SQL&nbsp;Enterprise Manager. Also, Microsoft continues to increase the self-tuning capabilities of Microsoft SQL Server, thereby reducing the number of options administrators have to monitor and manage.</p>
<p>
Microsoft's sp_configure allows the SA to set defaults for user options, such as ANSI options; although, individual connections can later change the settings. The current state of a connection's settings are made visible to it through a global variable @@options. @@options returns a numeric value that records the current option settings. See Microsoft Knowledge Base Article Q156498 "INF: How to Determine the Current Settings for @@options," (MSDN™ Library, Knowledge Base) for a stored procedure that returns a character list of the options recorded by <i>@@options</i>.</p>
<h4>DUMP/LOAD</h4>
<p>
The Sybase DUMP and LOAD statements take a FILE parameter for dump devices. The Microsoft SQL Server 6.<i>x</i> versions of the DUMP and LOAD statements do not use a FILE parameter. Instead, they use a DISK parameter.</p>
<p>
Microsoft SQL Server does not support the Sybase LISTONLY parameter. The Microsoft HEADERONLY parameter does list information about all dumps in a device, while the Sybase version of HEADERONLY lists only the first dump. So LOAD statements using the LISTONLY parameter should be changed to use the HEADERONLY parameter.</p>
<p>
For striping, remove the STRIPE=<i>n</i> parameter from the Sybase DUMP and LOAD statements and set the <b>sp_configure backup threads </b>parameter to <i>n</i>.</p>
<p>
Dumps from Sybase databases cannot be loaded directly into Microsoft databases. If DUMP and LOAD are used to move a database, the target database should be allocated exactly the same in regard to device usage, log allocation, data allocation, and segment allocation as the source database. Failure to allocate the target database the same as the source database can lead to multiple 2558 errors after the load completes.</p>
<p>
All logic using the Sybase <b>syslogshold</b> table to determine the oldest outstanding transaction must be replaced with logic that uses the Microsoft DBCC OPENTRAN statement.</p>
<h3>Administrative Changes</h3>
<p>
The following administrative differences between Sybase and Microsoft SQL Server must be addressed for a successful migration:
<ul type=disc>
<li>
Auditing<br><br></li>
<li>
Server roles<br><br></li>
<li>
Threshold Manager<br><br></li>
<li>
Rebuilding <b>master</b><br><br></li>
<li>
Replication</li>
</ul>
<h4>Auditing</h4>
<p>
Sybase introduced auditing in System 10. Microsoft SQL Server does not have an auditing component. SQL Trace can have filters defined to capture some auditing information. For information about the <b>xp_sqltrace</b> and <b>xp_logevent</b> extended system stored procedures, see the Microsoft SQL Server documentation.</p>
<h4>Server roles</h4>
<p>
As noted previously, Microsoft SQL Server does not support the Sybase sa_role, sso_role, or oper roles. These functions are part of the Microsoft SA login. Administrative practices based on individual user logins having these Sybase server roles applied must be redesigned.</p>
<h4>Threshold Manager</h4>
<p>
Microsoft SQL Server does not have a Threshold Manager for managing transaction logs. The equivalent functionality is provided by using the following:
<ul type=disc>
<li>
Scheduled dumps<p class=tl>
Use SQL Enterprise Manager to set up a system of periodic, scheduled dumps.</P></li>
<li>
Performance Monitor alerts<p class=tl>
Use the SQL Alerter utility to set up Windows NT Performance Monitor alerts to dump transaction logs when they fill to a specified percentage.</P></li>
</ul>
<h4>Rebuilding master</h4>
<p>
Sites running the 4.<i>x</i> versions of Microsoft or Sybase SQL Server rebuild their <i>master</i> databases using the bldmstr utility. In Systems 10 and 11, the sybinit utility is used to rebuild the <i>master</i> database. In Microsoft SQL Server versions 6.0 and 6.5, the Setup program rebuilds the <i>master</i> database. Setup has an option to rewrite the <i>master</i> database and reset the configuration values to their defaults. This process can also be used to change the code page and sort order of a server, although the databases would have to be recreated and the data reloaded.</p>
<h4>Replication</h4>
<p>
Microsoft SQL Server contains replication as a standard part of the product; it is not an add-on component. Microsoft replication is easy to manage and based in a publication/subscription model. One server publishes data in its tables to make it available for replication. Other servers can then subscribe to that publication. Sites should review Microsoft's implementation of replication to determine how it will support their replication needs.</p>
<p>
The replication is performed by several processes that run as part of the SQL Executive, which runs as a Windows NT service on the same server as SQL Server. The SQL Executive contains three replication processes: 
<ul type=disc>
<li>
Log reader process reads the data from the transaction log of the publishing database.<br><br></li>
<li>
The synchronization process synchronizes the data in the publisher and subscribers when a new subscription is added.<br><br></li>
<li>
The distribution process actually moves the synchronization jobs or log data to the subscribing servers.</li>
</ul>
<p>
Replication is administered from the SQL Enterprise Manager graphical administration tool. Microsoft replication also replicates to ODBC data sources, such as DB2 or Oracle. For more information, see the <i>Microsoft SQL Server</i> <i>Administrator's Companion</i>.</p>
<h3>Using New Microsoft Features</h3>
<p>
Microsoft SQL Server offers new features not found in Sybase SQL Server. Sites should investigate these capabilities and determine which ones to incorporate into their new systems.</p>
<h4>New Transact-SQL features</h4>
<p>
The following new Transact-SQL features can be used by Sybase sites after they migrate to Microsoft SQL Server.</p>
<h4>Comments</h4>
<p>
Microsoft SQL Server still supports the /* comment text */ syntax for comments. In addition, it accepts comments in the style:</p>
<p>
-- comment out everything to the end of the line.</p>
<p>
Comments using the -- format can also be nested.</p>
<h4>Execute strings</h4>
<p>
The EXECUTE statement now supports executing strings:</p>
<pre><code>USE master
GO
DECLARE @DBName VARCHAR(30)

DECLARE DBCursor CURSOR FOR
SELECT name FROM sysdatabases ORDER BY name
OPEN DBCursor

FETCH DBCursor INTO @DBName
WHILE (@@fetch_status &lt;&gt; -1)
BEGIN
 &nbsp; EXECUTE ('DBCC CHECKDB(' + @DBName + ')' )
 &nbsp; FETCH DBCursor INTO @DBName
END
GO
</code></pre>
<p>
The executed string can also be a text parameter, so users are not limited to executing only 255-byte statements. Syntax checking and object verification of the executed string are not performed until execution time.</p>
<h4>CASE expression</h4>
<p>
The CASE statement can be used for assignment and lets users simplify the conditional logic in SQL expressions. It is ANSI SQL-92 compliant and is allowed anywhere an expression is used:</p>
<pre><code>SELECT&nbsp;&nbsp;&nbsp; Category = 
 &nbsp;&nbsp;&nbsp;&nbsp; CASE type
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN 'popular_comp' THEN 'Popular Computing'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN 'mod_cook' THEN 'Modern Cooking'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN 'business' THEN 'Business'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN 'psychology' THEN 'Psychology'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN 'trad_cook' THEN 'Traditional Cooking'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE 'Not yet categorized'
 &nbsp;&nbsp;&nbsp;&nbsp; END, 
 &nbsp; "Shortened Title" = CONVERT(varchar(30), title), 
 &nbsp; Price = price
FROM titles
WHERE price IS NOT NULL
ORDER BY type, title
COMPUTE AVG(price) BY type
go
</code></pre>
<p>
CASE can be used to replace nested IF statements with code that is easier to understand and maintain.</p>
<h4>Cursors</h4>
<p>
Microsoft Transact-SQL supports scrollable cursors:</p>
<p>
DECLARE <i>cursor_name</i> [INSENSITIVE] [SCROLL] CURSOR...</p>
<p>
The behaviors of cursor options are discussed in detail in Microsoft Knowledge Base Article Q156489 " INF: Overview of SQL Server, ODBC, and DB-Library Cursors" (MSDN Libarary, Knowledge Base). To summarize:
<ul type=disc>
<li>
DECLARE <i>cursor_name</i> CURSOR...<br><br></li>
<li>
...The cursor is implemented as a forward-only cursor. It reflects committed changes to underlying rows as the user scrolls through the cursor.<br><br></li>
<li>
DECLARE <i>cursor_name</i> INSENSITIVE CURSOR...<p class=tl>
The cursor is implemented as a forward-only and read-only cursor. The cursor is instantiated as a temporary table at cursor open; no changes that affect the rows in the cursor are reflected in the cursor unless it is closed and reopened.</P></li>
<li>
DECLARE <i>cursor_name</i> INSENSITIVE SCROLL CURSOR...<p class=tl>
Similar to the INSENSITIVE cursor except that the resulting cursor is also scrollable.</P></li>
<li>
DECLARE <i>cursor_name</i> SCROLL CURSOR...<p class=tl>
The cursor is implemented as a keyset cursor. A set of the keys for all the qualified rows is built when the cursor is opened. As the user scrolls around the cursor, commited updates to nonkey columns are reflected. Inserts made while the user is scrolling the cursor are not visible. Deleted rows return an <i>@@fetch_status</i> of –2. Updates of key columns appear as a delete of the row with the old key value <i>(@@fetch_status</i> = –2) followed by an insert of a row with the new key value (which is not visible to the cursor).</P></li>
</ul>
<p>
Microsoft SQL Server also supports all of the FETCH options: FIRST, LAST, NEXT, PRIOR, RELATIVE, and ABSOLUTE, where the RELATIVE(<i>n</i>) options asks for the row <i>n</i> rows from the current cursor position and ABSOLUTE(<i>n</i>) asks for the <i>n</i>th row in the result set. Some of these options are supported only with SCROLL cursors.</p>
<p>
The default cursors offer the most consistency because they reflect all committed changes as the user scrolls through the cursor. INSENSITIVE cursors offer the greatest concurrency because they maintain no locks on the underlying tables.</p>
<h4>ANSI join operators</h4>
<p>
Microsoft SQL Server continues to support the original SQL Server specific syntax of *= and =* syntax for specifying outer joins and now it also supports the ANSI-style join syntax with the operators {INNER | LEFT [OUTER] | RIGHT [OUTER] | FULL [OUTER]}. The ANSI join operators also follow the ANSI definitions for join behavior. Using the ANSI-style join operators is recommended rather than using the SQL Server *= and =* syntax. The ANSI-style and SQL Server-style join syntax cannot be mixed in the same SQL statement.</p>
<h4>Optimizer hints</h4>
<p>
Microsoft SQL Server supports the following new optimizer hints:
<ul type=disc>
<li>
UPDLOCK<p class=tl>
Uses update locks instead of the default shared locks and holds them until the end of the transaction.</P></li>
<li>
TABLOCK<p class=tl>
Puts a shared lock on the table and holds it until the end of a transaction if HOLDLOCK is also specified.</P></li>
<li>
TABLOCKX<p class=tl>
Puts an exclusive lock on the table and holds it until the end of a transaction if HOLDLOCK is also specified.</P></li>
<li>
PAGLOCK<p class=tl>
Takes shared page locks when the server would normally take a table lock.</P></li>
<li>
FASTFIRSTROW<p class=tl>
Forces the optimizer to use a nonclustered index that covers an ORDER BY, instead of doing a table scan with the sorted work table. With the new read-ahead processing, the table scan and work table can be faster overall, but the first row cannot be returned until the result set has been built. FASTFIRSTROW speeds the return of the first row by forcing the optimizer to use the nonclustered index; however, overall performance can be reduced.</P></li>
</ul>
<p>
The UPDLOCK hint can help Sybase applications that have high levels of deadlocking. If several users are doing concurrent processing such as the following, there is a potential to deadlock:
<ol>
<li>
BEGIN TRAN<br><br></li>
<li>
SELECT a, b FROM MyTable HOLDLOCK WHERE c = 5<br><br></li>
<li>
UPDATE MyTable SET a = 10 WHERE c = 5<br><br></li>
<li>
COMMIT TRAN</li>
</ol>
<p>
Task1 can acquire shared locks at step 2, then Task2 can acquire another set of shared locks at step 2 before Task1 has a chance to start step 3. When Task1 attempts to update at step 3, it blocks on Task2's shared locks, and when Task2 attempts to update at step 3, it blocks on Task1's shared locks. If the HOLDLOCK keyword is changed to UPDLOCK, then Task2 is blocked at step 2 until Task1 commits its transaction, thereby eliminating the possibility of a deadlock.</p>
<h4>Global temporary tables</h4>
<p>
Microsoft SQL Server 6.5 supports both types of temporary tables supported by Sybase:
<ul type=disc>
<li>
Local temporary tables<p class=tl>
Name starts with the number sign (#), visible only to the connection creating the table. Dropped when they are explicitly dropped, the connection terminates, or when the stored procedure terminates (If they were created by a stored procedure).</P></li>
<li>
Permanent temporary tables<p class=tl>
Created in <i>tempdb</i> with standard table name:</P><pre><code>USE TEMPDB
GO
CREATE TABLE MyTable (cola int, colb char(8))
GO
GRANT ALL ON MyTable TO public
GO
</code></pre>
<p class=tl>
Table can be referenced by all users connected to the server. It will be dropped if the server is recycled, unless it is first dropped explicitly by the owner. Connections currently in a user database must fully qualify the table in order to reference it.</P></li>
</ul>
<p>
Microsoft SQL Server also supports a third type of temporary table called global temporary tables. These tables are identified by names beginning with double number signs (##). Global temporary tables are visible to all users on the system. They persist until either explicitly dropped or all connections referencing them disconnect.</p>
<h4>IDENTITY columns</h4>
<p>
Sybase SQL Server supports only the IDENTITY constraint on numeric columns with a scale of 0. In addition to supporting the IDENTITY property on numeric columns, Microsoft SQL Server also supports the IDENTITY property on decimal columns with a scale of 0 and on integer, smallint, and tinyint columns.</p>
<p>
Microsoft SQL Server does not limit IDENTITY columns to starting with 1 and incrementing by 1. The constraint can be specified as:</p>
<pre><code>IDENTITY (<i>seed</i>, <i>increment</i>)
</code></pre>
<p>
where</p>
<p class=dt>
<i>seed</i></p>
<p class=indent>
Is the value generated for the first row inserted</p>
<p class=dt>
<i>increment</i></p>
<p class=indent>
Is the value by which each new row's identity value is incremented</p>
<p>
The default for <i>seed</i> and <i>increment</i> are 1. The new identity function IDENT_SEED reports a columns seed value, and IDENT_INCR reports its increment value. Microsoft also introduced a new global variable, <i>@@identity</i>, which records the last identity value assigned.</p>
<h4>SET statement</h4>
<p>
Microsoft SQL Server 6.5 users can easily set the behavior of their connection to be ANSI compliant by executing SET ANSI_DEFAULTS ON. This statement sets ON eight different ANSI options. The Microsoft SQL Server ODBC driver automatically sets ANSI_DEFAULTS ON if it detects it is connecting to SQL Server version 6.5.</p>
<h4>CUBE and ROLLUP</h4>
<p>
The SELECT statement on Microsoft SQL Server supports the WITH CUBE and WITH ROLLUP aggregate operators. These operators aid in the generation of reports.</p>
<h4>DEFAULTs on INSERT and UPDATE</h4>
<p>
The INSERT and UPDATE statements have been expanded to include the ability to place default values in all the columns or some of the columns in a table:</p>
<pre><code>INSERT INTO MyTable DEFAULT VALUES
INSERT INTO MyTable VALUES ('abc', DEFAULT, 100.02)
UPDATE MyTable SET cola = DEFAULT WHERE colb = 'abc'
</code></pre>
<p>
If no default has been defined for a column and the columns accept NULL, NULL is used. If the column is a timestamp column, the next timestamp value is used.</p>
<h4>New DBCC options</h4>
<p>
The DBCC statement offers the following new options:
<ul type=disc>
<li>
SHRINKDB<p class=tl>
Reduces the size of a database.</P></li>
<li>
TRACESTATUS<p class=tl>
Displays the connection's current settings for the DBCC trace flags.</P></li>
<li>
SHOWCONTIG<p class=tl>
Displays the link list for a table so fragmentation can be assessed.</P></li>
</ul>
<h4>System stored procedures</h4>
<p>
This section discusses new options in the Microsoft SQL Server system stored procedures.</p>
<p>
<b>sp_configure</b> offers several new options.</p>
<h4>Read-ahead options</h4>
<p>
SQL Server's use of read-ahead processing on table scans and range searches can be controlled by the following parameters:
<ul type=disc>
<li>
RA cache hit limit<p class=tl>
The number of cache hits a read-ahead request can have before it is cancelled.</P></li>
<li>
RA cache miss limit<p class=tl>
The number of cache misses that occur during a horizontal traversal before read-ahead is triggered.</P></li>
<li>
RA delay<p class=tl>
The delay for the read-ahead process, in milliseconds.</P></li>
<li>
RA pre-fetches<p class=tl>
Determines how far ahead the read-ahead process will read before idling.</P></li>
<li>
RA slots per thread<p class=tl>
The number of concurrent requests the read-ahead service will manage.</P></li>
<li>
RA worker threads<p class=tl>
The number of threads used to service read-ahead requests.</P></li>
</ul>
<p>
<b>sp_tableoption</b> allows users to activate insert row-level locking for a table and also "pin" the table or make its pages stay in memory.</p>
<p>
Insert row locking can alleviate page-lock contention in cases where the structure of a table directs all inserts to a single page. In a table with no clustered index, all inserts are made to the last page. In a table with an index built over an identity column, the key inserts are directed to the last page of the index. Insert row locking can alleviate the lock contention these structures cause.</p>
<p>
SQL Server reads table pages from disk to internal memory cache. If SQL Server needs memory for new data, it can flush pages already in the cache to make room for new data. If an administrator uses <b>sp_tableoption</b> to mark a table as a pin table, the table's pages in the cache are "pinned" and are not eligible to be flushed. This can increase performance for tables that are referenced frequently, but it should be used with caution. Marking too many tables as pin tables can adversely affect SQL Server's ability to effectively manage memory. Pinning does not affect writing the data page back out to disk if it has been modified, so it has no impact on recovery.</p>
<h4>Administration</h4>
<p>
The following are new administrative features Sybase sites can take advantage of after migrating to Microsoft SQL Server.</p>
<h4>Dump/Load</h4>
<p>
Microsoft SQL Server 6.5 is not limited to dumping databases and transaction logs; it supports dumping and loading individual tables. SQL Server 6.5 also allows loading a transaction log to a specific point in time. For example, if an administrator finds that a user did something wrong with the data at 3:00 p.m. on Thursday, he or she can reload the database and recover it to that point.</p>
<p>
If administrators need to be able to recover individual tables, they are no longer required to define a separate database for each table with all of the administrative overhead that requires. They can keep logically related tables in one database where they can be managed as a unit but still have the flexibility of loading specific tables if the need arises.</p>
<p>
Tables with <b>text</b> and <b>image</b> columns are not eligible for table loads and table loads cannot be run to a point in time.</p>
<p>
Microsoft SQL Server 6.<i>x</i> also supports dumping to various media: local dump devices, tapes, floppy drives, a named pipe, and network dump devices. It supports the dismount/nodismount, unload/load, init/noinit, and retaindays parameters. It also introduces a new expiredate parameter, which has the same effect as retaindays but a target date can be specified instead of the number of days a dump is to be retained.</p>
<p>
Microsoft SQL Server does not have a separate Backup Server process.</p>
<p>
All logic using the <b>syslogshold</b> table to determine the oldest outstanding transaction must be replaced with DBCC OPENTRAN logic.</p>
<h4>Integrated security</h4>
<p>
SQL Server logins can be integrated with Windows NT user accounts with the following benefits:
<ul type=disc>
<li>
Integrated logins<p class=tl>
SQL Server login accounts based on Windows NT user IDs can be created. After logging onto Windows NT, the user can then make a trusted connection to SQL Server without having to specify a separate SQL Server login and password.</P></li>
<li>
Enhanced security<p class=tl>
The user's login is validated once by Windows NT at login. There is no need to send a password across the network to SQL Server for database login validation.</P></li>
<li>
Security validation<p class=tl>
When a user connects to SQL Server with integrated security, the user's Windows NT domain is stored in <b>master.dbo.sysprocesses.nt_domain</b>, and the user's Windows NT account ID is stored in <b>master.dbo.sysprocesses.nt_username</b>. These columns can be referenced in views and triggers for data access validation.</P></li>
</ul>
<p>
Microsoft SQL Server still supports standard Sybase login security. It can also run with mixed security where some users connect with standard SQL Server logins while others connect through Windows NT Integrated Security.</p>
<h4>Auto-execution procedures</h4>
<p>
SQL Server can be instructed to execute specific stored procedures each time SQL Server is started. This function can be used to load startup data or execute procedures to ensure their execution plans are loaded into the procedure cache. Auto-execution procedures are controlled through:
<ul type=disc>
<li>
<b>sp_makestartup</b><p class=tl>
Makes a procedure a startup procedure.</P></li>
<li>
<b>sp_unmakestartup</b><p class=tl>
Removes a procedure from the startup list.</P></li>
<li>
<b>sp_helpstartup</b><p class=tl>
Lists the current startup procedures.</P></li>
</ul>
<h4>Encrypting stored procedures</h4>
<p>
Vendors of applications running on SQL Server often encode some of their system's logic in stored procedures. In order to protect their proprietary code many of these vendors deleted the text of their stored procedures in the <i>syscomments</i> table during their setup. This loss of the source for the stored procedures can create upgrade problems. </p>
<p>
Microsoft SQL Server versions 6.0 and 6.5 offer a better mechanism. The CREATE PROCEDURE statement accepts a WITH ENCRYPTION parameter. When this is specified, the source of the procedure is stored in an encrypted format in <i>syscomments</i>. Casual readers cannot view the source, but it is still available to SQL Server if it is needed for future Microsoft SQL Server upgrades.</p>
<h4>SQL distributed management framework</h4>
<p>
The SQL Distributed Management Framework (SQL-DMF) is a group of the SQL Server core components that ease administration of Microsoft SQL Servers. SQL-DMF allows automation of both periodic maintenance tasks and responses to potential problems. Using SQL-DMF, sites can set up the administration tasks for their SQL Servers to allow for "Lights Out" operation with minimal administrative needs.</p>
<p>
Administrative procedures based on Transact-SQL statements are also supported, which allows sites to build scripts to manage the administration of their systems. SQL-DMF offers a user-friendly alternative for extending and automating the administration of SQL Servers.</p>
<p>
<b>SQL Distributed Management Objects</b></p>
<p>
The programming API for SQL-DMF is SQL Distributed Management Objects (SQL-DMO). SQL-DMO is a collection of OLE Automation objects that define all of the entities present in a database (tables, views, logs, users, and so on), and their typical administrative actions. SQL-DMO is used by the SQL Server administration tools, but any OLE Automation-compliant programming language can also use the SQL-DMO objects to build custom database administration functions. In conjunction with a rapid development environment such as Visual Basic, SQL-DMO can be used to quickly develop robust custom administration applications.</p>
<p>
<b>SQL Enterprise Manager</b></p>
<p>
SQL Enterprise Manager is a Win32 graphical tool that uses SQL-DMO to administer the Microsoft SQL Servers on a network. SQL Enterprise Manager can represent all of the SQL Servers on a network (and all of their contained objects, such as users, tables, databases, logs, and indexes) in a tree structure similar to that used for files in Windows Explorer. </p>
<p>
SQL Enterprise Manager takes the administration of SQL Servers from a command-prompt environment (<b>isql</b>) to a graphical environment with all of the productivity and ease-of-use that it implies. SQL Enterprise Manager can be used for the traditional administrative tasks of object creation, database dumping and loading, database sizing, and login and user ID management. It can also be used for the new Microsoft SQL Server features such as scheduling tasks, defining alerts, and defining replication.</p>
<p>
SQL Enterprise Manager also includes a new Database Maintenance Plan Wizard that can quickly set up a maintenance schedule for a database. This includes checking data integrity and allocation, updating index statistics, and performing dumps and loads.</p>
<p>
<b>SQL Executive</b></p>
<p>
SQL Executive is a Windows NT service application that runs with SQL Server. SQL Executive is the component that implements several operations that users can specify with SQL Enterprise Manager and SQL-DMO applications. SQL Executive replaces the SQL Monitor component of SQL Server 4.21a.</p>
<p>
<b>Auto-restart of SQL Server</b></p>
<p>
The SQL Executive service can be configured to automatically restart SQL Server if it should stop. This capability can be defined during setup, or later with SQL Enterprise Manager, or in the Services application in Control Panel.</p>
<p>
<b>Alerts and Scheduled Tasks</b></p>
<p>
Two primary features of SQL-DMF that sites should explore after migrating to Microsoft SQL Server are the use of alerts and scheduled tasks.</p>
<p>
Alerts are raised when specific conditions are encountered, for example, when a transaction log reaches 80 percent of capacity or a severity 19 message is written to the SQL Server error log. An alert can drive an SQL statement, which could be a stored procedure. By building a stored procedure for any feature offered by a Microsoft SQL Server, such as SQL Mail and extended stored procedures, the alerts can drive corrective action without requiring administrative intervention, or they can generate e-mails and pages to administrators.</p>
<p>
Scheduled tasks are tasks that are executed at specific times. The tasks administrators schedule are the execution of either an SQL statement or a command-prompt command. For example, an administrator can schedule the execution of a program that has the code to perform DBCC checks of all the databases on a server, then scan the DBCC output for messages about which the administrators should be alerted. All of the periodic maintenance actions for a server can be automated using scheduled tasks.</p>
<h4>Performance Monitor</h4>
<p>
SQL Server adds several counters to the Windows NT Performance Monitor counters so that administrators can use the same tool to monitor the performance of both Windows NT and SQL Server. In addition, the SQL Alerter utility allows alerts to be defined on the SQL Server counters, so that performance issues can be brought automatically to the administrators' attention. For example, a server can be set up to page and e-mail the administrators any time the number of SQL Server tasks blocked on locks exceeds a specified value. SQL Server 6.5 also supports user-defined SQL Server counters in the Performance Monitor, giving sites greater flexibility in monitoring their systems.</p>
<h4>SQL Trace</h4>
<p>
SQL Trace is a graphical utility that can be used to see the SQL statements transmitted from client computers to a SQL Server. With its filtering capabilities, SQL Trace users can focus on any subset of client-to-server connections. SQL Trace filters can also be defined to perform some auditing functions.</p>
<h4>Distributed transactions</h4>
<p>
Microsoft Distributed Transaction Coordinator (MS DTC) manages distributed transactions between two or more SQL Server systems. MS DTC runs as a Windows NT service enabled through SQL Server's administrative interface. Applications use MS DTC through an OLE-based API to manage explicit distributed transactions. The application uses the MS DTC transaction commands instead of the SQL Server transaction statements and enrolls each connection that it wants to have participating in the distributed transaction. When the application issues a commit to MS DTC, MS DTC transparently manages a two-phase commit protocol with all the SQL Server connections enrolled in the transaction. The application is shielded from the complexities of the old DB-Library two-phase commit functions.</p>
<h4>Extended stored procedures</h4>
<p>
The Microsoft version of Open Data Services is an API that programmers can use to code DLLs to work as extended stored procedures. The DLLs coded as extended stored procedures are called in a manner similar to that of a stored procedure, seamlessly extending SQL Servers functionality. The extended stored procedures can implement any kind of C or C++ code to trigger actions outside of SQL Server and return external information to SQL Server. Extended stored procedures can use return status codes and output parameters, just as regular stored procedures do.</p>
<p>
SQL Server uses extended stored procedures to implement some of the functionality unique to Microsoft SQL Server. The names of many of these stored procedures start with <b>xp_</b> and are used to administer integrated security and SQL Mail. Some special extended stored procedures are:
<ul type=disc>
<li>
<b>xp_cmdshell</b><p class=tl>
Submits a command-prompt command to Windows NT:</P><pre><code>EXEC xp_cmdshell "net send /domain:SQL_USERS 'SQL Server shutting 
down in 10 minutes. No more connections allowed.'", no_output</code></pre>
</li>
<li>
<b>xp_logevent</b><p class=tl>
Logs a user-defined message to the SQL Server error log and optionally to the Windows NT event log:</P><pre><code>SELECT @message = 'The table "'&nbsp; @tabname&nbsp; '" is not owned by the user "'&nbsp; @username&nbsp; '."'
EXEC xp_logevent 60000, @message, informational</code></pre>
</li>
<li>
<b>xp_sprintf</b><p class=tl>
Allows character substitution in string variables:</P><pre><code>DECLARE @string varchar (255)
EXEC xp_sprintf @string OUTPUT, 'INSERT INTO %s VALUES (%s, %s)', 'table1', '1', '2'</code></pre>
</li>
<li>
<b>xp_sscanf</b><p class=tl>
Reads data from the string into the argument locations given by each format argument:</P><pre><code>DECLARE @filename varchar (255)
EXEC xp_sscanf 'sync -b -fauthors10.tmp', 'sync -b -f%s',
@argument1=@filename OUTPUT</code></pre>
</li>
<li>
<b>xp_msver</b><p class=tl>
Returns the version information for SQL Server, along with the version information for the Windows NT running on the server computer with SQL Server.</P></li>
</ul>
<h4>SQL Mail</h4>
<p>
SQL Mail provides a set of extended stored procedures that can be used to send e-mail or pages from SQL Server through a MAPI (Messaging API)-compliant e-mail system. SQL Mail messages can consist of short text strings, the output of queries, or an attached file. SQL Mail can be called from Transact-SQL, stored procedures, and triggers. It can be used by alerts and scheduled tasks. SQL Mail can also be set up to receive e-mails containing SQL queries. SQL Server will execute the query and send the results back to the client through e-mail.</p>
</BODY>
</HTML>
