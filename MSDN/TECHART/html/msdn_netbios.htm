<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Aristocratic Communication: NetBIOS</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_netbios"></a>Aristocratic Communication: NetBIOS</h1>
<p>
Ruediger R. Asche<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: October 21, 1994<br>
Revised: June 1, 1995 (redesigned class definitions; incorporated information on MFC sockets)</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3189">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the CommChat sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This is Part 4 of the five-part trilogy "The Hitchhiker's Guide Through the Network Jungle," following <a href="msdn_comclass.htm">"Communication with Class,"</a> <a href="msdn_npipes.htm">"Garden Hoses at Work,"</a> and <a href="msdn_wsockets.htm">"Power Outlets in Action: Windows Sockets."</a> This article describes the NetBIOS interface and explains how it can be encapsulated in a generic C++ networking interface.</p>
<h2>Road Map</h2>
<p>
This article is fourth in a series of technical articles that explore network programming with Visual C++™ and the Microsoft® Foundation Class Library (MFC). The series consists of the following articles:</p>
<p>
<a href="msdn_comclass.htm">"Communication with Class"</a> (introduction and description of the CommChat sample)</p>
<p>
<a href="msdn_npipes.htm">"Garden Hoses at Work"</a> (named pipes)</p>
<p>
<a href="msdn_wsockets.htm">"Power Outlets in Action: Windows Sockets"</a> (Microsoft Windows® sockets)</p>
<p>
"Aristocratic Communication: NetBIOS" (NetBIOS)</p>
<p>
<a href="msdn_compint.htm">"Plugs and Jacks: Network Interfaces Compared"</a> (summary)</p>
<p>
The CommChat sample application illustrates the concepts and implements the C++ objects discussed in these articles.</p>
<h2>Introduction</h2>
<p>
So far, we have looked at named pipes and sockets as application programming interface (API) sets that applications written for Win32® can utilize to transfer data back and forth between computers. Like named pipes and sockets, NetBIOS is a network interface; that is, a set of functions that applications can use to access networks.</p>
<p>
It is important to make the distinction between interfaces and protocols: Named pipes, sockets, and NetBIOS (as well as NetDDE®, which will not be discussed in this article series) are interfaces that provide a means for applications to access networks; these interfaces do not define <i>how</i> the data is actually transferred over the network.</p>
<p>
In contrast, the modules that are responsible for transferring data over a network implement <i>transport</i> <i>protocols</i>. As explained in the Windows NT™ Resource Kit, a transport protocol "packages data that is to be sent on the network in a way that the computer on the receiving end can understand." A number of different protocols are currently available—for example, TCP/IP, UDP/IP, XNS, NetBEUI, and IPX. I may discuss these protocols in upcoming articles, but I would like to emphasize that the network interfaces relieve you from having to worry about the details of the underlying protocol. In some interface implementations, it is possible to influence parameters that are specific to certain protocols; for example, the <b>setsockopt</b> socket function has a number of TCP/IP-specific parameters. In general, however, an interface can be implemented on top of any protocol installed on the two computers that wish to communicate. See the <a href="msdn_compint.htm">"Plugs and Jacks: Network Interfaces Compared"</a> article for more information on how to associate protocols with interfaces.</p>
<p>
This article describes the NetBIOS interface and explains how a <b>CNetBIOS</b> class can be implemented. Note that NetBIOS, unlike other network interfaces, is somewhat more than an interface because it imposes several restrictions on the underlying transport protocol. We will come back to that later.</p>
<h2>What Is NetBIOS?</h2>
<p>
NetBIOS is a specification for an interface that was designed by IBM. From the point of view of an application programmer, the most notable difference between NetBIOS and other interfaces (such as named pipes) seems to be that NetBIOS commands are not submitted to the operating system through a set of functions, but instead by passing the address of a data structure filled in by the application to the operating system. This structure is called a network control block (NCB) and encodes the command as well as command parameters.</p>
<p>
However, it does not really matter what form the commands are passed in. The reason why NetBIOS works via an NCB instead of a functional interface is pretty much pure convenience. The first implementations of NetBIOS required the application to pass the commands to the operating system as a software interrupt; thus, the representation of the function call in an NCB to be passed to the software interrupt made sense.</p>
<p>
Of course, the functionality of an interface is totally independent of how it is made available to applications. I have defined an "intermediate" C++ class for the NetBIOS interface that hides the NCB from the application programmer. That class is called CNCB, its prototype can be found in CNCB.H, and the implementation is in CNCB.CPP. This is what CNCB looks like:</p>
<pre><code>class CNCB
{ 
private:
NCB m_NCB;
public:
// Constructor
CNCB();
// Helper function
void ClearNCB();
UCHAR GetLSN();
WORD GetLength();
void Fill(CNCB ncbSource);
void GetCommand();
// Name management services
UCHAR AddName(PSTR pName);
UCHAR AddGroupName(PSTR pName);
UCHAR DeleteName(PSTR pName);
UCHAR FindName();

// Data transfer services
UCHAR Call(PSTR pWe,PSTR pTheOther,UCHAR wSendTO,UCHAR wRecvTO);
UCHAR Listen(PSTR pWe,PSTR pTheOther,UCHAR wSendTO,UCHAR wRecvTO);
UCHAR Hangup(UCHAR wSessionNumber);
// Connectionless data transfer
UCHAR Cancel();
UCHAR Send(UCHAR wSessionNumber,LPSTR lpPacket, UINT wLength);
UCHAR SendNoAck();
UCHAR SendDatagram(UCHAR wSessionNumber,LPSTR lpPacket, WORD wLength);
UCHAR SendBroadcastDatagram();
UCHAR Receive(UCHAR wSessionNumber,LPSTR lpPacket, UINT wLength);
UCHAR ReceiveAny();
UCHAR ReceiveDatagram(UCHAR wSessionNumber,LPSTR lpPacket, WORD wLength);
UCHAR ReceiveBroadcastDatagram();
UCHAR ChainSend();
UCHAR ChainSendNoAck();

// General-purpose services
UCHAR Reset(UCHAR wSessions, UCHAR wNCBs);
UCHAR GetAdapterStatus(PSTR pName);
UCHAR GetSessionStatus(PSTR pName);
UCHAR EnumerateAdapters();
UCHAR StatusAlert();
UCHAR Action();
};
</code></pre>
<p>
The NCB (whose structure is defined in the NB30.H header file that is provided with Visual C++™ version 2.0) is a private member, and all functions that can be called on an NCB are provided as public member functions. Let us look at a typical implementation of one of those functions:</p>
<pre><code>UCHAR CNCB::Listen(PSTR pWe,PSTR pTheOther,WORD wSendTO,WORD wRecvTO)
{ClearNCB();
 strncpy((char *)&amp;m_NCB.ncb_name,pWe,MAXMACHINENAME);
 strncpy((char *)&amp;m_NCB.ncb_callname,pTheOther,MAXMACHINENAME);
 m_NCB.ncb_rto = (UCHAR)wRecvTO;
 m_NCB.ncb_sto = (UCHAR)wSendTO;
 m_NCB.ncb_command = NCBLISTEN;
 return (Netbios(&amp;m_NCB));
};
</code></pre>
<p>
All this function does is clear its private NCB (that is, fill it up with zeroes), fill in the appropriate parameters (note, in particular, the function code in the <b>ncb_command</b> member), and then call the <b>Netbios</b> system function.</p>
<p>
Going through this intermediate C++ API layer allows us to focus on the important parameters to the individual services without worrying about NCBs.</p>
<h2>The Works of NetBIOS</h2>
<p>
The NetBIOS function set is described fairly well in the article "An Introduction to Network Programming Using the NetBIOS Interface," by Alok Sinha and Raymond Patch, in the March/April 1992 issue of the <i>Microsoft Systems Journal</i> (MSDN Library Archive, Books and Periodicals, Microsoft Systems Journal, Selections from Previous Issues). In this section, I will focus on the differences between NetBIOS and the other interfaces we have seen so far (named pipes and sockets).</p>
<p>
All network interfaces deal with a common set of issues. I will talk about those issues and how they are resolved by the different interfaces in the article <a href="msdn_compint.htm">"Plugs and Jacks: Network Interfaces Compared,"</a> but let me provide a quick preview here. The first issue is name resolution: How does a process address another machine? Second, if the first problem is solved, how can a machine concurrently serve different communications? The third issue involves asynchronous vs. synchronous communications. Finally, some interfaces provide both connection-oriented and "connectionless" communication (allowing two machines to send data back and forth without explicitly establishing a communication).</p>
<h3>Give Me a Name, and I'll Show You a Machine</h3>
<p>
How does NetBIOS address the problem of name resolution? NetBIOS, in a way, is the most dynamic of the three interfaces we have discussed so far in that it allows a process to assign itself a name by which it can be addressed. A central concept in the NetBIOS model is that of a <i>name table</i>: Each computer that has NetBIOS support keeps a table of names under which different applications can address the computer. </p>
<p>
A good way to get a grip on the name table concept is to call the NetBIOS <b>GetAdapterStatus</b> function. This function, among other things, enumerates the name table entries. Here is a typical name table dump from my development machine, with the names changed to protect the innocent:</p>
<pre><code>[EBP-015C]-ADAPTER_STATUS_BLOCK asStatus = {...}
  -_ADAPTER_STATUS asb_header = {...}
 &nbsp;&nbsp; +unsigned char adapter_address[6] = 0x0012f99c ""
 &nbsp;&nbsp;&nbsp; unsigned char rev_major = 3 '\x03'
 &nbsp;&nbsp;&nbsp; unsigned char reserved0 = 0 '\x00'
 &nbsp;&nbsp;&nbsp; unsigned char adapter_type = 254 'þ'
 &nbsp;&nbsp;&nbsp; unsigned char rev_minor = 0 '\x00'
 &nbsp;&nbsp;&nbsp; unsigned short duration = 0
 &nbsp;&nbsp;&nbsp; unsigned short frmr_recv = 0
 &nbsp;&nbsp;&nbsp; unsigned short frmr_xmit = 0
 &nbsp;&nbsp;&nbsp; unsigned short iframe_recv_err = 0
 &nbsp;&nbsp;&nbsp; unsigned short xmit_aborts = 0
 &nbsp;&nbsp;&nbsp; unsigned long xmit_success = 0
 &nbsp;&nbsp;&nbsp; unsigned long recv_success = 0
 &nbsp;&nbsp;&nbsp; unsigned short iframe_xmit_err = 0
 &nbsp;&nbsp;&nbsp; unsigned short recv_buff_unavail = 0
 &nbsp;&nbsp;&nbsp; unsigned short t1_timeouts = 0
 &nbsp;&nbsp;&nbsp; unsigned short ti_timeouts = 0
 &nbsp;&nbsp;&nbsp; unsigned long reserved1 = 0
 &nbsp;&nbsp;&nbsp; unsigned short free_ncbs = 255
 &nbsp;&nbsp;&nbsp; unsigned short max_cfg_ncbs = 255
 &nbsp;&nbsp;&nbsp; unsigned short max_ncbs = 255
 &nbsp;&nbsp;&nbsp; unsigned short xmit_buf_unavail = 0
 &nbsp;&nbsp;&nbsp; unsigned short max_dgram_size = 0
 &nbsp;&nbsp;&nbsp; unsigned short pending_sess = 0
 &nbsp;&nbsp;&nbsp; unsigned short max_cfg_sess = 16
 &nbsp;&nbsp;&nbsp; unsigned short max_sess = 16
 &nbsp;&nbsp;&nbsp; unsigned short max_sess_pkt_size = 0
 &nbsp;&nbsp;&nbsp; unsigned short name_count = 1
  -_NAME_BUFFER asb_Names[16] = 0x0012f9d8
 &nbsp;&nbsp; -_NAME_BUFFER [0] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012f9d8 "BEAKER001!&nbsp;&nbsp;&nbsp;&nbsp; "
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 2 '\x02'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 4 '\x04'
 &nbsp;&nbsp; -_NAME_BUFFER [1] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012f9ea "BEAKER001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \x1F\x01"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 1 '\x01'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [2] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012f9fc "BEAKER001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \x02"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 2 '\x02'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [3] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fa0e "BEAKER001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 3 '\x03'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [4] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fa20 "DOMAIN1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 4 '\x04'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 128 '\x80'
 &nbsp;&nbsp; -_NAME_BUFFER [5] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fa32 "BEAKER001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \x03\x05"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 5 '\x05'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [6] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fa44 "DOMAIN1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \x1E\x06\x80BEAKER001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \x03\a"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 6 '\x06'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 128 '\x80'
 &nbsp;&nbsp; -_NAME_BUFFER [7] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fa56 "BEAKER001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \x03\a"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 7 '\a'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [8] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fa68 "BEAKER001!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 8 '\b'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [9] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fa7a ""
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 0 '\x00'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [10] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fa8c ""
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 0 '\x00'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [11] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fa9e ""
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 0 '\x00'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [12] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fab0 ""
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 0 '\x00'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [13] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fac2 ""
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 0 '\x00'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [14] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fad4 ""
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 0 '\x00'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
 &nbsp;&nbsp; -_NAME_BUFFER [15] = {...}
 &nbsp;&nbsp;&nbsp;&nbsp; +unsigned char name[16] = 0x0012fae6 ""
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_num = 0 '\x00'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char name_flags = 0 '\x00'
</code></pre>
<p>
In case you are interested in how I produced this name table dump: I added a <b>GetAdapterStatus</b> call to the code in NetBIOS.CPP, set a breakpoint to that line, traced until I hit the call to <b>Netbios</b> in CNCB.CPP, and after one more single step, copied and pasted the ADAPTER_STATUS_BLOCK variable from the locals window to another document. Slick, huh?</p>
<p>
Anyway, we see here that the name table has nine entries, seven of which begin with the suspicious prefix BEAKER001. The other two entries are variations of the domain name (DOMAIN1) assigned to the machine. Two kinds of names can exist in a name table: unique names and group names. Unique names are verified over the entire network. If an application tries to add a unique name that is already registered somewhere on the network, the <b>AddName</b> call fails. Group names can exist in the name tables of multiple machines. They allow a machine to broadcast a message to all machines in the DOMAIN1 domain by simply broadcasting the message all over the net; a machine that has the appropriate entry in its name table can then pick up the message.</p>
<p>
This is a very powerful feature of NetBIOS. It allows for fairly elaborate (possibly hierarchical or multi-level) implementations of domain-type structures. An implementation of LAN administration software can utilize the name table so that each machine registers a set of domain names and aliases that can be used by other pieces of the software to group machines logically.</p>
<p>
A name table is a little more complicated than a simple table of names. We see that the BEAKER001 entry shows up a number of times. An entry in the NetBIOS name table consists of two parts: the name itself (a string that does not contain a wildcard character ["*"] and does not exceed 15 characters in length) and a one-byte service identifier. The service identifier distinguishes the name among several network services. For example, the machine name BEAKER001 could be used in a Microsoft LAN Manager environment to identify both a machine that can share logical directories for other machines to attach to, and an end point for a NetDDE conversation. One rule of NetBIOS addressing is that each component that wants to add an entry to a machine's name table must specify a unique name. Another rule is that no process can initiate a conversation without first adding a unique name explicitly to the name table (although in some implementations of NetBIOS, separate processes can share entries in the name table).</p>
<p>
Note that this particular usage of NetBIOS names is implementation-dependent—other implementations may use name tables differently. The important thing to keep in mind is that NetBIOS requires names to be unique; otherwise, the <b>AddName</b> call on a machine name will fail.</p>
<p>
This naming convention gets applications written for the NetBIOS interface into a certain kind of trouble. For example, I would like to have CommChat address a remote machine by its logical name assigned at startup time. However, a machine cannot simply add the logical name to the name table because entries for that name already exist in the table, as you can see in the dump above.</p>
<p>
To work around this problem, the 16th character of the name is reserved to discriminate between different modules (for example, the NetDDE service, RAS, and the network redirector) that share the name. You will note that the name table entries for BEAKER001 in our name table dump have different 16th characters. </p>
<p>
In CommChat, I do not use a unique value for the 16th character, but I use a similar approach: The name that a machine registers is the computer name (obtained with the <b>GetComputerName</b> function) followed by an exclamation point and padded with blanks. This approach cuts down the number of available characters in a machine name from 15 to 14, but it allows for unique names that do not interfere with present or future services sharing the machine name (unless a machine with the same name followed by the exclamation point is already on the net).</p>
<p>
Now we know quite a lot about NetBIOS names. There is more, though. The network software still must know how to translate a logical name into a physical address and vice versa. However, what if a given machine has multiple adapters or several transport protocols that share the same adapter?</p>
<p>
NetBIOS addresses this question by keeping a distinct name table for each adapter installed on a computer. The <b>lana_number</b> field in the NCB selects the adapter and the protocol used for transmission. Using distinct names in the name tables of adapters allows a machine to explicitly select specific adapters and/or protocols.</p>
<p>
CommChat uses only the default adapter; therefore, <b>lana_number</b> is always set to 0 (the first adapter). A more flexible implementation of the CNCB class would require a <b>lana_number</b> to be passed to each NetBIOS command.</p>
<p>
CommChat has a shortcoming with respect to multiple transport protocols and adapters: Because the server is set up to listen only on LANA_NUM 0, clients can establish communications with the server only if (a) their respective client code is bound to the same protocol as the server, and (b) the server's name has been entered into all the name tables on the server side. Using a new NetBIOS service in NetBIOS version 3.0 (NCB.Enum) would enable a server to register its name and listen on all installed adapters, and a client to enumerate the adapters on the server side to look for a specific name on all of the server's LAN addresses. Note that not all implementations of NetBIOS support the Enum service.</p>
<p>
It would be easy to change CommChat to generate unique names for each machine. For example, when a machine starts an instance of CommChat, it could try to add a unique name (say, COMMCHAT0) to the name table. If the call to add the name fails due to a multiple name error, the machine could try COMMCHAT1, COMMCHAT2, and so on until it finds a unique address. The drawback of such an approach would be that a CommChat user would not necessarily know the names associated with other users. The naming scheme of NetBIOS, as you can see, is very flexible—if we were to implement the naming scheme I just suggested using, say, sockets, we would need to provide the software that translates those "custom" names into machine names or IP addresses.</p>
<p>
A group of NetBIOS functions deals with name table management services. These functions let you manipulate the name table: add names, delete names, and query the name table.</p>
<h3>Selecting Communications</h3>
<p>
Now that we've solved the first problem (addressing machines), the next problem is how to sort out multiple communications on the same machine.</p>
<p>
Using NetBIOS, applications can distinguish between several concurrent communications through names, as we discussed earlier. A machine running NetBIOS can register many different names for remote machines to connect with. As we discussed in the previous section, you can even "overload" a name by adding a unique byte in the 16th character of the name field or by internally changing the name to make it unique (as CommChat does).</p>
<p>
Like named pipes and sockets, NetBIOS allows several instances of the same communication type to be active: If two machines want to communicate with each other, one of them (the server) must have an outstanding <b>listen</b> command (this corresponds to the <b>AwaitCommunicationAttempt</b> member in the <b>CCommunication</b> class), and the other machine (the client) must submit a <b>call</b> command. When a communication is established, a local session number (LSN) is returned to each machine. The server can now go back into the listening state and accept another communication. When a third machine establishes a communication with the machine that has gone back to listening, new LSNs are returned to the server and the third machine.</p>
<p>
Note once again that the <b>call</b> and <b>listen</b> commands are directed; that is, both specify the addresses of the communicating machines. NetBIOS offers a very high degree of control over the details of the communication because you can use the wildcard address "*" or any name registered in any name table on one of the participating machines, and you can select specific transport protocols.</p>
<h3>Asynchronous Commands</h3>
<p>
NetBIOS calls can be submitted in asynchronous mode, where an asynchronous callback routine that is invoked as soon as the asynchronous command completes is supplied to the NCB. Asynchronous NetBIOS commands were a big issue under 16-bit Windows—although the non-preemptive nature of the operating system practically enforced the usage of asynchronous over synchronous commands, it also provided a number of challenges concerning the callback (for example, an asynchronous callback routine had to be explicitly page-locked in memory).</p>
<p>
In the <a href="msdn_compint.htm">"Plugs and Jacks: Network Interfaces Compared"</a> article, I will discuss the pros and cons of asynchronous vs. synchronous communications.</p>
<h3>Connectionless Communications</h3>
<p>
In addition to the standard <b>Send</b> and <b>Receive</b> calls, NetBIOS allows applications to transfer data over the network without having previously established a connection. This feature (called <i>connectionless communication</i>) is useful only for small amounts of data sent in a "one-shot" fashion and for messages delivered to a group of machines (namely, to machines that have registered the same group name). Connectionless communication employs the following datagram functions: <b>Send Datagram</b>, <b>Receive Datagram</b>, <b>Send Broadcast Datagram</b>, and <b>Receive Broadcast Datagram</b>. It is important to note that none of these commands is guaranteed to transmit the data correctly.</p>
<h2>Implementing CNetBIOS</h2>
<p>
I already mentioned a number of things that we need to know to implement the <b>CNetBIOS</b> object. Most member functions can be mapped fairly easily to the NetBIOS API. </p>
<p>
Opening a communication object is surprisingly easy. This is because NetBIOS does not require a communication object to be created explicitly—as soon as a NetBIOS name is registered with the NetBIOS library, the object is ready to accept connections. The most complicated piece of code is the one-shot initialization that resides in the <b>Open</b> code so that a possible failure of the <b>AddName</b> call can be propagated to the application. The code for <b>CNetBIOS::Open</b> is shown below.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The code below, like the sockets code, is a bit clumsy: We keep track of the number of objects created to make sure that only one one-shot initialization takes place. The code was originally designed for use with Visual C++ version 1.1, which did not support AFX classes in dynamic-link libraries (DLLs). Ideally, the class definitions for <b>CCommunication</b> and its derived classes would go in a DLL, and the one-shot initialization would take place in the DLL's entry function.</p>
<p class=indent>
Another slip in the code is that the <b>Reset</b> function should be called only once per process. In an application that dynamically creates and deletes many <b>CNetBIOS</b> objects, it is possible for the <b>Reset</b> service to be called more than once. This problem would also be fixed implicitly in a DLL implementation of <b>CNetBIOS</b>.</p>
<pre><code>BOOL CClientNetBIOS::Open(const char* pszFileName, UINT nOpenFlags,
      CFileException* pError)
  {
  // first of all, register the new NetBIOS name and fail for good if this doesn't work
 &nbsp; m_iStatusPending = STATUS_NOT_CONNECTED;
 &nbsp; if (!bAddNameWorked) return FALSE;
 &nbsp; if (iNBObjectCount == 0)
// the first object to be created initializes the machine name string...
// this way, we won't have to do it every time...
 &nbsp; {
 &nbsp;&nbsp; unsigned long iMachineNameLength;
 &nbsp;&nbsp; GetComputerName(achLocalMachineName,&amp;iMachineNameLength);
 &nbsp;&nbsp; MakeNetBIOSName((char *)0,achLocalMachineName);
 &nbsp;&nbsp; CNCB ncbNameAdder;
 &nbsp;&nbsp; ncbNameAdder.Reset(0,0);
   UINT uReturn = ncbNameAdder.AddName(achLocalMachineName);
   if ((uReturn != NRC_GOODRET)) // &amp;&amp; (uReturn != NRC_DUPNAME)) 
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; bAddNameWorked = FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp;&nbsp; };

  };
  iNBObjectCount++; 
  if (!pszFileName)
  {     // we are server
     // nothing to do here, believe it or not!!! :-)
     // the name table already contains the entry for our machine...
  }     
  else
  {
 &nbsp; int iLen = strlen(pszFileName);
 &nbsp; MakeNetBIOSName((char *)pszFileName,m_pszPaddedFileName); 
 &nbsp; m_thisNCB.Call(achLocalMachineName,m_pszPaddedFileName,(UCHAR)0,(UCHAR)0);
 &nbsp; m_lsn = m_thisNCB.GetLSN();
  };
  return TRUE;
 };
</code></pre>
<p>
Once again, this particular way of initializing the library is not multithreading-safe and works with CommChat only because CommChat does not open and close <b>CCommunication</b> objects from separate threads. Before we look at the "real" initialization code, let's examine the corresponding implementation of <b>CNetBIOS::Close</b>:</p>
<pre><code>void CNetBIOS::Close(void)
{
 m_thisNCB.Hangup(m_lsn);

// This code is invoked to clean up after the last object...

 iNBObjectCount--;
 if (!iNBObjectCount)
  {
 &nbsp; CNCB ncbNameDeleter;
 &nbsp; ncbNameDeleter.DeleteName(achLocalMachineName);
  };

};
</code></pre>
<p>
This code suffers from one very ugly shortcoming, which is (once again) related to the problem of several processes not being able to share information easily: The <b>iNBObjectCount</b> variable only counts how many CNCB objects are created and deleted <i>in one process</i>. If a NetBIOS client and server reside on the same machine, both the client and server process keep independent counts of <b>iNBObjectCount</b>. The second process that tries to register the same NetBIOS name will not succeed when it calls <b>AddName</b>, because the NetBIOS name cannot be registered twice on the same machine. However, you could change the <b>CNetBIOS::Open</b> code to succeed if the NetBIOS name has already been registered—you would simply uncomment the line:</p>
<pre><code>&amp;&amp; (uReturn != NRC_DUPNAME))
</code></pre>
<p>
from the code in <b>CNetBIOS::Open</b>. The problem comes into play in the <b>CNetBIOS::Close</b> call, because there is no way for a process to know if another process is still using the same NetBIOS name. Since CommChat was not designed to support communications between processes on the same machine, I have not addressed the issue of correct "global" initialization and cleanup. Be aware, though, that if your application needs to register the same NetBIOS name for several processes, you might have to interact with the registry, use shared kernel objects, or define shared data in a DLL to keep track of how many processes utilize a NetBIOS name.</p>
<p>
Now, what is <i>really</i> involved in opening an object for communication, leaving the name registration aside? Surprisingly enough, the code needed for the server is zero—as soon as the name is registered, NetBIOS can establish a connection without any further work. Note that if we want to set any parameters (such as time-out values), we should probably do this at <b>Open</b> time.</p>
<p>
The heart of connection-oriented communication under NetBIOS consists of the <b>Call</b> and <b>Listen</b> functions. The client, when attempting to open a communication, submits a <b>Call</b> call, passing the local machine name as the first parameter and the target machine name as the second parameter. This is called a <i>directed</i> call. The client could also pass a wildcard to the <b>Call</b> function so that any machine that is ready to accept calls can respond.</p>
<p>
In the <b>AwaitCommunicationAttempt</b> code, the server has previously submitted a <b>listen</b> NetBIOS call, passing the wildcard string "*" as the name of the target machine (this means that the server is accepting a call from any machine). Both calls will block until a communication is established, as discussed earlier. Note that there is an option to initiate a communication in a nonblocking mode; however, as I discussed before, CommChat does not have to worry about nonblocking calls because it runs as a multithreaded application.</p>
<p>
The implementatrion of <b>CancelCommunicationAttempt</b> is worth elaboration. This function maps to the NetBIOS <b>NCBCANCEL</b> function, but a cancel operation on an NCB is fairly generic. A number of NetBIOS calls can be canceled, so how does NetBIOS know which call to cancel? We must pass the address of the NCB to be canceled in the <b>ncb_buffer</b> member of another NCB that contains <b>NCBCANCEL</b> in the <b>ncb_command</b> member. In other words, an NCB that cancels another NCB must contain the address of the NCBs to be canceled in its buffer member. Before I show you the code of <b>CNCB::Cancel</b> to illustrate this process, let me point out that there is a slight difficulty in designing the <b>CNCB</b> class to support a generic cancel command: The code for <b>CNCB::Cancel</b> can cancel only the very last command that was submitted in the <b>m_NCB</b> member variable, because <b>m_NCB</b> gets reused every time a command is issued. Keeping track of every NCB to cancel would require creating a new instance of the <b>CNCB</b> class for every command and deleting that instance only when the request has been completed or canceled Note that there is no need to delete the "helper" <b>CNCB</b> explicitly because it is allocated as an automatic variable and therefore constructed and destroyed automatically. </p>
<pre><code>UCHAR CNCB::Cancel()
{
 CNCB cbCanceller;
 cbCanceller.ClearNCB();
 cbCanceller.m_NCB.ncb_buffer = (unsigned char *)&amp;m_NCB;
 cbCanceller.m_NCB.ncb_length = sizeof(NCB);
 cbCanceller.m_NCB.ncb_command = NCBCANCEL;
 return (Netbios(&amp;cbCanceller.m_NCB));

};
</code></pre>
<h3>Reading and Writing</h3>
<p>
Once a communication is established between two machines, the NetBIOS commands <b>Send</b> and <b>Receive</b> can be used to transfer data back and forth. When you look at the interface that CNCB exports, you will find several flavors of the <b>send</b> and <b>receive</b> functions. In this discussion, we will focus only on the "bare bones" <b>Send</b> and <b>Receive</b> commands.</p>
<p>
Theoretically, <b>CNetBIOS::Read</b> and <b>CNetBIOS::Write</b> are easy to implement, as you can see below:</p>
<pre><code>void CNetBIOS::Write(const void FAR* pBuf, UINT iCount)
{ 
  m_thisNCB.Send(m_lsn,(char *)pBuf,iCount);
};

UINT CNetBIOS::Read(void FAR* lpBuf, UINT nCount)
{ 
  if (m_thisNCB.Receive(m_lsn,(char *)lpBuf,nCount) != NRC_GOODRET)
 &nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp; return (UINT)m_thisNCB.GetLength();
};
</code></pre>
<p>
The problem, as usual, is to get the details right. NetBIOS limits data transmissions to 64K (the identifier that specifies the buffer length for both <b>send</b> and <b>receive</b> calls is of type <b>WORD</b>, which is 16 bits, thereby limiting the buffer to 64K). As a result, I found that chat communications worked just fine, but larger file transfers plainly did not work.</p>
<p>
Fortunately, I designed CommChat in such a way that the file transfer protocol itself is able to handle problems with large data transfers. If a <b>Read</b> operation returns fewer characters than requested, a second <b>Read</b> is initiated with the remaining number of characters until all data is received. Unfortunately, <b>CFile</b>::<b>Write</b> (recall that <b>CCommunication</b> is derived from <b>CFile</b>) does not return a value, so it is not easy to figure out whether a write operation was successful. In CommChat, I solved this problem through structured exception handling: If a write operation fails, an exception is raised, which causes the protocol to retry the write operation with a smaller buffer. (See <a href="msdn_comclass.htm">"Communication with Class"</a> for details.)</p>
<p>
Thus, the code in <b>CNCB</b>::<b>Send</b> and <b>CNCB</b>::<b>Receive</b> must do a little more than simply filling in the NCB and submitting the NetBIOS call. The code also checks the size of the buffer passed in against the size of a <b>WORD</b>. (I know it is ugly to hard-code the size of a <b>WORD</b>, but I haven't been able to find a nice, platform-independent way to determine the largest numeric value that fits into a variable of an arbitrary type.) If the buffer size is larger than the <b>WORD</b> size, the code trims it to a <b>WORD</b> (in the case of <b>Receive</b>) or raises an exception that is caught by the protocol (in the case of <b>Send</b>). Here is the code:</p>
<pre><code>UCHAR CNCB::Send(WORD wSessionNumber,LPSTR lpPacket, UINT wLength)
{ClearNCB();
 if (wLength &gt; 0xffff) RaiseException(EXCEPTION_ACCESS_VIOLATION,0,0,NULL);
 m_NCB.ncb_command = NCBSEND;
 m_NCB.ncb_lsn = wSessionNumber;
 m_NCB.ncb_length = wLength;
 m_NCB.ncb_buffer = (unsigned char *)lpPacket;
 return (Netbios(&amp;m_NCB));
};

UCHAR CNCB::Receive(WORD wSessionNumber,LPSTR lpPacket, UINT wLength)
{ClearNCB();
 m_NCB.ncb_command = NCBRECV;
 m_NCB.ncb_lsn = wSessionNumber;
 if (wLength &gt; 0xffff) m_NCB.ncb_length = 0xffff; else
 m_NCB.ncb_length = wLength;
 m_NCB.ncb_buffer = (unsigned char *)lpPacket;
 return (Netbios(&amp;m_NCB));
};
</code></pre>
<h2>Changes to COMMCHAT.CPP</h2>
<p>
As with sockets, I was very careful to follow good modularity practices and design the <b>CNetBIOS</b> class in a way that wouldn't affect the existing application architecture of CommChat. I changed only the COMMCHAT.CPP file to accommodate the new NetBIOS communication type.</p>
<p>
That is the party line. If you compared this version of COMMCHAT.CPP to the version provided in the October edition of the MSDN Library, you would find that almost all changes affect menu handling and object assignment only (for example, the new file includes options for creating objects of type <b>CNetBIOS</b> and <b>CSocket</b> instead of only <b>CNamedPipe</b>). However, in the small print, you will notice that I had to modify a little bit more than that.</p>
<p>
When I added NetBIOS support, I was fairly surprised to see that the chat communication worked fine, whereas a file transfer communication failed as soon as CommChat tried to access the file mapping that contained the file to be transferred. To make a long story short, in my original design of CommChat, the file to be transferred and its corresponding file mapping were both opened in read-only mode. Because NetBIOS internally probes the buffer that is passed to the NetBIOS <b>Send</b> command in read/write mode, the read-only option results in an access violation that causes NetBIOS to fail. When I changed the file mapping access to read/write, everything was fine again.</p>
<h2>Summary</h2>
<p>
Using the intermediate class definition of CNCB provided for a straightforward implementation of <b>CNetBIOS</b>, although a number of detail issues (such as the 64K limit of data transfers) caused some grief. So far, the class definition for <b>CCommunication</b> has proven to be generic enough to abstract away the differences between the three interfaces and serve most multithreaded communication applications.</p>
<p>
The last article in this series will compare the three interfaces we have discussed so far: named pipes, sockets, and NetBIOS.</p>
<h2>Bibliography</h2>
<p>
Sinha, Alok, and Raymond Patch. "An Introduction to Network Programming Using the NetBIOS Interface." <i>Microsoft Systems Journal</i> 7 (March/April 1992): 61:80. (MSDN Library Archive, Books and Periodicals, Selections from Previous Issues)</p>
<p>
Sinha, Alok, and Raymond Patch. "Developing Network-Aware Programs Using Windows 3.1 and NetBIOS." <i>Microsoft Systems Journal</i> 7 (July/August 1992): 61:80.</p>
</BODY>
</HTML>
