<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Visual Basic Programming Conventions from Microsoft Consulting Services</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Visual Basic Programming Conventions from Microsoft Consulting Services</h1>
<h2>1. Naming Conventions</h2>
<h3>1.1 Objectives</h3>
<ul type=disc>
<li>
To help programmers (especially in multiprogrammer projects) standardize and decode the structure and logic of an application<br><br></li>
<li>
To be precise, complete, readable, memorable, and unambiguous<br><br></li>
<li>
To be consistent with other language conventions (most importantly the Visual Basic™ <i>Programmer's Guide</i> and standard Microsoft® Windows™ Hungarian C)<br><br></li>
<li>
To be efficient from a string size and labor standpoint, thus allowing a greater opportunity for longer/fuller object names<br><br></li>
<li>
To define the minimum requirements necessary to do the above<p class=tl>
<b>Note:</b> On pages 32 and 33 of the Visual Basic 2 <i>Programmer's Guide</i>, Visual Basic has defined control naming conventions that will likely be adopted by many corporations and Visual Basic ISVs. As a result, it would take a very strong argument to justify deviating from the Visual Basic 2 standard without causing a lot of heartache and confusion. Lacking such a compelling argument, this document therefore is a superset of the published Visual Basic conventions.</P></li>
</ul>
<h3>1.2 Conventions</h3>
<h4>1.2.1 Option Explicit</h4>
<p>
"Option Explicit" must always be used to force proper variable declarations and aid good variable commenting. The time lost trying to track down bugs caused by typos (<i>aUserNameTmp</i> vs. <i>sUserNameTmp</i> vs. <i>sUserNameTemp</i>) far outweighs the time needed to Dim variables.</p>
<h4>1.2.2 Control naming</h4>
<p>
The following table defines our standard Control name prefixes. (These are consistent with those documented in the Visual Basic 2 <i>Programmers Guide</i>.)</p>
<p class=label>
<b>Table 1. Standard Control Name Prefixes</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=14%><b>Prefix</b></td>
<td class=label width=86%><b>Control Type Description</b></td>
</tr>
<tr valign=top>
<td width=14%>ani</td>
<td width=86%>Animation button</td>
</tr>
<tr valign=top>
<td width=14%>bed</td>
<td width=86%>Pen Bedit </td>
</tr>
<tr valign=top>
<td width=14%>cbo</td>
<td width=86%>Combobox and dropdown Listbox</td>
</tr>
<tr valign=top>
<td width=14%>chk</td>
<td width=86%>Checkbox</td>
</tr>
<tr valign=top>
<td width=14%>clp</td>
<td width=86%>Picture Clip</td>
</tr>
<tr valign=top>
<td width=14%>cmd</td>
<td width=86%>Command Button</td>
</tr>
<tr valign=top>
<td width=14%>com</td>
<td width=86%>Communications </td>
</tr>
<tr valign=top>
<td width=14%>ctr</td>
<td width=86%>Control (Used within procs when the specific type is unknown)</td>
</tr>
<tr valign=top>
<td width=14%>db</td>
<td width=86%>ODBC Database</td>
</tr>
<tr valign=top>
<td width=14%>dir</td>
<td width=86%>Dir List Box</td>
</tr>
<tr valign=top>
<td width=14%>dlg</td>
<td width=86%>Visual Basic Pro Common Dialog</td>
</tr>
<tr valign=top>
<td width=14%>drv</td>
<td width=86%>Drive List Box</td>
</tr>
<tr valign=top>
<td width=14%>ds</td>
<td width=86%>ODBC Dynaset</td>
</tr>
<tr valign=top>
<td width=14%>fil</td>
<td width=86%>File List Box</td>
</tr>
<tr valign=top>
<td width=14%>frm</td>
<td width=86%>Form</td>
</tr>
<tr valign=top>
<td width=14%>fra</td>
<td width=86%>Frame</td>
</tr>
<tr valign=top>
<td width=14%>gau</td>
<td width=86%>Gauge</td>
</tr>
<tr valign=top>
<td width=14%>gpb</td>
<td width=86%>Group Push Button</td>
</tr>
<tr valign=top>
<td width=14%>grd</td>
<td width=86%>Grid</td>
</tr>
<tr valign=top>
<td width=14%>hed</td>
<td width=86%>Pen Hedit</td>
</tr>
<tr valign=top>
<td width=14%>hsb</td>
<td width=86%>Horizontal Scroll Bar</td>
</tr>
<tr valign=top>
<td width=14%>img</td>
<td width=86%>Image</td>
</tr>
<tr valign=top>
<td width=14%>ink</td>
<td width=86%>Pen Ink</td>
</tr>
<tr valign=top>
<td width=14%>key</td>
<td width=86%>Keyboard key status</td>
</tr>
<tr valign=top>
<td width=14%>lbl</td>
<td width=86%>Label</td>
</tr>
<tr valign=top>
<td width=14%>lin</td>
<td width=86%>Line</td>
</tr>
<tr valign=top>
<td width=14%>lst</td>
<td width=86%>Listbox</td>
</tr>
<tr valign=top>
<td width=14%>mpm</td>
<td width=86%>MAPI Message</td>
</tr>
<tr valign=top>
<td width=14%>mps</td>
<td width=86%>MAPI Session</td>
</tr>
<tr valign=top>
<td width=14%>mci</td>
<td width=86%>MCI</td>
</tr>
<tr valign=top>
<td width=14%>mnu</td>
<td width=86%>Menu</td>
</tr>
<tr valign=top>
<td width=14%>opt</td>
<td width=86%>Option Button</td>
</tr>
<tr valign=top>
<td width=14%>ole</td>
<td width=86%>Ole Client</td>
</tr>
<tr valign=top>
<td width=14%>pic</td>
<td width=86%>Picture</td>
</tr>
<tr valign=top>
<td width=14%>pnl</td>
<td width=86%>3d Panel</td>
</tr>
<tr valign=top>
<td width=14%>shp</td>
<td width=86%>Shape</td>
</tr>
<tr valign=top>
<td width=14%>spn</td>
<td width=86%>Spin Control</td>
</tr>
<tr valign=top>
<td width=14%>txt</td>
<td width=86%>Text/Edit Box</td>
</tr>
<tr valign=top>
<td width=14%>tmr</td>
<td width=86%>Timer</td>
</tr>
<tr valign=top>
<td width=14%>vsb</td>
<td width=86%>Vertical Scroll Bar</td>
</tr>
</table><br>
<h3>1.3 Control Prefix Notes</h3>
<h4>1.3.1 Menus</h4>
<p>
Because Menu handlers can be so numerous, Menu names require a little more attention. Menu prefixes therefore continue beyond the initial Mnu label by adding an additional (upper case) character prefix for each level of nesting, with the final menu caption being spelled out at the end of the name string. When there is ambiguity caused by character duplications, such as a menu having both main <u>F</u>ormat and <u>F</u>ile menus, use an additional (lower case) character to differentiate the items. Examples:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=39%><b>Menu Caption Sequence</b></td>
<td class=label width=61%><b>Menu Handler Name</b></td>
</tr>
<tr valign=top>
<td width=39%><u>H</u>elp.Contents</td>
<td width=61%>mnu<u>H</u>Contents</td>
</tr>
<tr valign=top>
<td width=39%><u>Fi</u>le.Open</td>
<td width=61%>mnu<u>Fi</u>Open</td>
</tr>
<tr valign=top>
<td width=39%><u>Fo</u>rmat.Character</td>
<td width=61%>mnu<u>Fo</u>Character</td>
</tr>
<tr valign=top>
<td width=39%><u>F</u>ile.<u>S</u>end.Fax </td>
<td width=61%>mnu<u>FS</u>Fax</td>
</tr>
<tr valign=top>
<td width=39%><u>F</u>ile.<u>S</u>end.Email</td>
<td width=61%>mnu<u>FS</u>Email</td>
</tr>
</table><br>
<p>
This results in all the family members of a particular menu group being listed right next to each other. This multi-tiered format provides a very direct way to find a menu handler, especially when there are a great many of them.</p>
<h4>1.3.2 Other controls</h4>
<p>
For new controls not listed above, try to come up with a unique 3-character prefix. However, it is more important to be clear than to stick to 3 characters. For derivative controls, such as an enhanced list box, extend the prefixes above so that there is no confusion about what control is really being used. For example, a control instance created from the Visual Basic Pro 1.0 3D Frame could use a prefix of fra3d to make sure there is no confusion over which control is really being used.</p>
<h4>1.3.3 Variable and routine naming</h4>
<p>
Variable and function names have the following structure:</p>
<pre><code>&lt;prefix&gt;&lt;body&gt;&lt;qualifier&gt;&lt;suffix&gt;
</code></pre>
<p>
The prefix describes the use and the scope of the variable, as in <i><u>i</u>GetRecordNext</i> and <i><u>s</u>GetNameFirst</i>. The qualifier is used to denote standard derivatives of a base variable or function, as in<i> iGetRecord<u>Next</u></i> and <i>sGetName<u>First</u></i>. The suffix is the optional Visual Basic type char ($, %, #, and so on).</p>
<p>
<b>Prefixes</b></p>
<p>
The following table defines variable/function name prefixes that are based on Hungarian C. These must be used universally, even when Visual Basic suffixes (such as %, &amp;, #, and so on) are also used.</p>
<p class=label>
<b>Table 2. Prefixes for Variable and Function Names</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=16%><b>Prefix</b></td>
<td class=label width=84%><b>Variable Use Description (precedes Control prefix and body)</b></td>
</tr>
<tr valign=top>
<td width=16%><i>b</i></td>
<td width=84%>Boolean (vb type = %) </td>
</tr>
<tr valign=top>
<td width=16%><i>c</i></td>
<td width=84%>Currency - 64 bits (vb type = @)</td>
</tr>
<tr valign=top>
<td width=16%><i>d</i></td>
<td width=84%>Double - 64 bit signed quantity (vb type = #)</td>
</tr>
<tr valign=top>
<td width=16%><i>db</i></td>
<td width=84%>Database</td>
</tr>
<tr valign=top>
<td width=16%><i>ds</i></td>
<td width=84%>Dynaset</td>
</tr>
<tr valign=top>
<td width=16%><i>dt</i></td>
<td width=84%>Date+Time (vb type = variant)</td>
</tr>
<tr valign=top>
<td width=16%><i>f</i></td>
<td width=84%>Float/Single - 32 bit signed floating point (vb type = !)</td>
</tr>
<tr valign=top>
<td width=16%><i>h</i></td>
<td width=84%>Handle (vb type = %)</td>
</tr>
<tr valign=top>
<td width=16%><i>i</i></td>
<td width=84%>Index (vb type = %) </td>
</tr>
<tr valign=top>
<td width=16%><i>l</i></td>
<td width=84%>Long - 32 bit signed quantity (vb type = &amp;)</td>
</tr>
<tr valign=top>
<td width=16%><i>n</i></td>
<td width=84%>Integer (sizeless, counter) (vb type = %)</td>
</tr>
<tr valign=top>
<td width=16%><i>s</i></td>
<td width=84%>String (vb type = $)</td>
</tr>
<tr valign=top>
<td width=16%><i>u</i></td>
<td width=84%>Unsigned - 16 bit unsigned quantity (must use &amp;)</td>
</tr>
<tr valign=top>
<td width=16%><i>ul</i></td>
<td width=84%>Unsigned Long - 32 bit unsigned quantity (must use #)</td>
</tr>
<tr valign=top>
<td width=16%><i>vnt</i></td>
<td width=84%>Variant (big and ugly to discourage use and make sure it gets the reader's attention)</td>
</tr>
<tr valign=top>
<td width=16%><i>w</i></td>
<td width=84%>Word - 16 bit signed quantity (vb type = %)</td>
</tr>
<tr valign=top>
<td width=16%><i>a</i></td>
<td width=84%>Array</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=84%>User defined type</td>
</tr>
<tr valign=top>
<td class=label width=16%><b>Prefix</b></td>
<td class=label width=84%><b>Scope or Use (precedes Use prefix above)</b></td>
</tr>
<tr valign=top>
<td width=16%><i>g</i></td>
<td width=84%>Global</td>
</tr>
<tr valign=top>
<td width=16%><i>m</i></td>
<td width=84%>Local to module or form</td>
</tr>
<tr valign=top>
<td width=16%><i>st</i></td>
<td width=84%>Static variable</td>
</tr>
<tr valign=top>
<td width=16%><i>v</i></td>
<td width=84%>Variable passed by value (local to a routine)</td>
</tr>
<tr valign=top>
<td width=16%><i>r</i></td>
<td width=84%>Variable passed by reference (local to a routine)</td>
</tr>
</table><br>
<p>
Hungarian is as valuable in Visual Basic as it is in C because the Visual Basic type suffixes alone do not provide standard (and valuable) information about what a variable/function is used for or where it is accessible. For example, <i>iSend</i> (which might be a count of the number of messages sent), <i>bSend</i> (which might be a flag/Boolean defining the success of the last Send operation), and <i>hSend</i> (which might be a handle to the Comm interface) all <i>succinctly</i> tell a programmer something very different. This information is fundamentally lost when the name is reduced down to <i>Send%</i>. Scope prefixes such as <i>g</i> and <i>m</i> also help reduce the problem of name contention, especially in multideveloper projects. Hungarian is also well known to Windows programmers and constantly referenced in Microsoft and industry programming books. Additionally, the bond between C programmers and Visual Basic programmers can be expected to become much stronger as Visual C++ begins to live up to its potential. This transition will result in many Visual Basic programmers moving to C for the first time and many programmers moving fluidly back and forth between each environment.</p>
<p>
<b>Body</b></p>
<p>
The body of variable and routine names should use mixed case and should be as long as needed to describe their purpose. Function names should also begin with a verb, such as <b>InitNameArray</b> or <b>CloseDialog</b>.</p>
<p>
For frequently used or long terms, abbreviations (such as Init, Num, Tbl, Cnt, and Grp for Initialization, Number, Table, Count, and Group) are suggested to help keep name lengths reasonable. Names greater than 32 characters generally begin to inhibit readability on VGA displays. When abbreviations are used, they must be used consistently throughout the application. Randomly switching between "Cnt" and "Count" within a project will greatly frustrate developers.</p>
<p>
<b>Qualifiers</b></p>
<p>
Often related variables and routines are used to manage and manipulate a common object. In these cases it can be very helpful to use standard qualifiers to label the derivative variables and routines. Although putting the qualifier after the body of the name might seem a little awkward (as in <i>sGetNameFirst</i>, <i>sGetNameLast</i> instead of <i>sGetFirstName</i>, and so on), this practice will help order these names together in the Visual Basic editor routine lists, making the logic and structure of the application easier to understand.</p>
<p>
The following table defines common qualifiers and their standard meaning.</p>
<p class=label>
<b>Table 3. Common Qualifiers</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=17%><b>Qualifier</b></td>
<td class=label width=83%><b>Description (follows Body)</b></td>
</tr>
<tr valign=top>
<td width=17%>First</td>
<td width=83%>First element of a set.</td>
</tr>
<tr valign=top>
<td width=17%>Last</td>
<td width=83%>Last element of a set.</td>
</tr>
<tr valign=top>
<td width=17%>Next</td>
<td width=83%>Next element in a set.</td>
</tr>
<tr valign=top>
<td width=17%>Prev</td>
<td width=83%>Previous element in a set.</td>
</tr>
<tr valign=top>
<td width=17%>Cur</td>
<td width=83%>Current element in a set.</td>
</tr>
<tr valign=top>
<td width=17%>Min</td>
<td width=83%>Minimum value in a set.</td>
</tr>
<tr valign=top>
<td width=17%>Max</td>
<td width=83%>Maximum value in a set.</td>
</tr>
<tr valign=top>
<td width=17%>Save</td>
<td width=83%>Used to preserve another variable which must be reset later.</td>
</tr>
<tr valign=top>
<td width=17%>Tmp</td>
<td width=83%>A "scratch" variable whose scope is highly localized within the code. The value of a Tmp variable is usually only valid across a set of contiguous statements.</td>
</tr>
<tr valign=top>
<td width=17%>Src</td>
<td width=83%>Source. Frequently used in comparison and transfer routines.</td>
</tr>
<tr valign=top>
<td width=17%>Dst</td>
<td width=83%>Destination. Often used in conjunction with Source.</td>
</tr>
</table><br>
<h4>1.3.4 Constant naming</h4>
<ul type=disc>
<li>
The body of constant names are described in UPPER_CASE with underscores ("_") between words.<br><br></li>
<li>
Although standard Visual Basic constants do not include Hungarian use information, prefixes such as i, s, g, and m can be very useful in understanding the value and scope of a constant, so constant names follow the same rules as variables. Examples:</li>
</ul>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=29%>mnUSER_LIST_MAX</td>
<td width=71%>'Max entry limit for User list (i<u>n</u>teger value, local to <u>m</u>odule)</td>
</tr>
<tr valign=top>
<td width=29%>gsNEW_LINE</td>
<td width=71%>'New Line character <u>s</u>tring (<u>g</u>lobal to entire application)</td>
</tr>
</table><br>
<h4>1.3.5 Variant data types</h4>
<p>
With the single exception listed below, variants should NOT be used. When a type conversion is needed, variant use would probably provide a slight performance win over the explicit basic type conversion routines (val(), str$(), and the like), but this gain is not sufficient to overcome the ambiguity and general sloppiness they allow in code statements.</p>
<p>
Example:</p>
<pre><code>vnt1 = "10.01" : vnt2 = 11 : vnt3 = "11" : vnt4 = "x4"
vntResult = vnt1 + vnt2&nbsp;&nbsp;&nbsp;&nbsp; ' Does vntResult = 21.01 or 10.0111?
vntResult = vnt2 + vnt1&nbsp;&nbsp;&nbsp;&nbsp; ' Does vntResult = 21.01 or 1110.01?
vntResult = vnt1 + vnt3&nbsp;&nbsp;&nbsp;&nbsp; ' Does vntResult = 21.01 or 10.0111?
vntResult = vnt3 + vnt1&nbsp;&nbsp;&nbsp;&nbsp; ' Does vntResult = 21.01 or 1110.01?
vntResult = vnt2 + vnt4&nbsp;&nbsp;&nbsp;&nbsp; ' Does vntResult = 11x4 or ERROR?
vntResult = vnt3 + vnt4&nbsp;&nbsp;&nbsp;&nbsp; ' Does vntResult = 11x4 or ERROR?
</code></pre>
<p>
Additionally, the type conversion routines assist in documenting implementation details, which make reading, debugging, and maintaining code more straightforward.</p>
<p>
Example:</p>
<pre><code>(iVar1 = 5 + val(sVar2)&nbsp;&nbsp;&nbsp;&nbsp; 'use this
vntVar1 = 5 + vntVar2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'not this!
</code></pre>
<p>
<b>Exception</b></p>
<p>
While working with databases, messages, DDE, or OLE, a generic service routine can receive data that it does not need to know the type of in order to process or pass on.</p>
<p>
Example:</p>
<pre><code>Sub ConvertNulls(rvntOrg As Variant, rvntSub As Variant)
 'If rvntOrg = Null, replace the Null with rvntSub
 &nbsp; If IsNull(rvntOrg) Then rvntOrg = rvntSub
End Sub
</code></pre>
<h2>2. Commenting</h2>
<ul type=disc>
<li>
All procedures and functions must begin with a brief comment describing the <i>functional</i> characteristics of the routine (what it does). This description should <i>not</i> describe the implementation details (how it does it) because these often change over time, resulting in unnecessary comment maintenance work or, worse, erroneous comments. The code itself and any necessary inline or local comments will describe the implementation. Parameters passed to a routine should be described (a) if they are not obvious and (b) when specific ranges are assumed by the routine. Function return values and global variables that are changed by the routine (especially through reference parameters) must also be described at the beginning of each routine.<br><br></li>
<li>
Every nontrivial variable declaration should include an inline comment describing the use of the variable being declared.<br><br></li>
<li>
Variables, controls, and routines should be named clearly enough that inline commenting is only needed for complex or nonobvious implementation details.<br><br></li>
<li>
An overview description of the application enumerating primary data objects, routines, algorithms, user interface dialogs, database and file system dependencies, and so on, should be included at the start of the .BAS module that contains the project's Visual Basic generic constant declarations.<p class=tl>
<b>Note:</b> The Project window inherently describes the list of files in a project, so this overview section only needs to provide information on the most important files and modules or files that the Project window doesn't know about, such as .INI or database files.</P></li>
</ul>
<h2>3. Code Formatting</h2>
<p>
Because many programmers still use VGA displays, screen real estate must be conserved as much as possible while still allowing code formatting to reflect logic structure and nesting. For this reason:
<ul type=disc>
<li>
Standard (tab-based) block nesting indentations should be from two to four spaces. More than four spaces is unnecessary and causes unnecessary statement hiding through truncation. Fewer than two is not effective in reflecting logic nesting.<br><br></li>
<li>
The functional overview comment of a routine should be indented one space. The highest level statements that follow the overview comment should be indented one tab, with each nested block indented an additional tab. Example:<pre><code>Function iFindUser (rasUserList() as String, rsTargetUser as String) as Integer
 'Search UserList and if found, return index of first occurrence of TargetUser, 
' else return -1
 &nbsp;&nbsp; Dim i as Integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'loop counter
 &nbsp;&nbsp; Dim bFound as Integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'target found flag
 &nbsp;&nbsp; iFindUser = -1
 &nbsp;&nbsp; i = 0
 &nbsp;&nbsp; While i &lt;= Ubound(rasUserList) and Not bFound
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If rasUserList(i) = rsTargetUser Then 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bFound = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iFindUser = i
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp; Wend
End Function
</code></pre>
</li>
<li>
Variables and nongeneric constants should be grouped by function rather than being split off into isolated areas or special files. (Visual Basic generic constants such as "HOURGLASS" should be grouped in a generic section of a main global file so that they do not complicate the reading of the application-specific declarations.)</li>
</ul>
<h2>4. Operators</h2>
<ul type=disc>
<li>
Always use "&amp;" when concatenating strings and "+" when working with numerical values. Using only "+" can cause problems when operating on two variants. For example:<pre><code>vntVar1 = "10.01"
vntVar2 = 11
vntResult = vntVar1 + vntVar2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'vntResult = 21.01 
vntResult = vntVar1 &amp; vntVar2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'vntResult = 10.0111
</code></pre>
</li>
</ul>
<h2>5. Scope</h2>
<ul type=disc>
<li>
Always define variables with the smallest scope possible. Global variables can create enormously complex state machines and make understanding the logic of an application extremely difficult. They also make the reuse and maintenance of your code much more difficult. If you have to use globals, keep their declarations grouped by functionality and comment them well.<br><br></li>
<li>
With the exception of globals that should not be passed, procedures and functions should only operate on objects that are passed to them. Global variables that are used in routines should be identified in the general comment area at the beginning of the routine.<br><br></li>
<li>
Likewise, try to put as much logic and as many user interface objects in Dialog Boxes as possible. This will help segment your application's complexity and minimize its run-time overhead.</li>
</ul>
</BODY>
</HTML>
