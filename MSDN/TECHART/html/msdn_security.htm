<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A Visual FoxPro Security System</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_security"></a></sup>A Visual FoxPro Security System</h1>
<p>
Les Pinter<br>
Publisher of <i>The Pinter FoxPro Letter</i></p>
<p>
January 1996</p>
<p>
<i>Les Pinter is the publisher of the Pinter FoxPro Letter, a monthly newsletter for professional FoxPro programmers. He has given presentations at Microsoft FoxPro Developers' Conferences in the United States, Spain, and Russia. Les has written six books about FoxPro for McGraw-Hill. He writes a monthly column for FoxTalk, and is a frequent speaker at FoxPro user groups around the United States and abroad, speaking in Spanish, French, Portuguese, Russian, and English. Les once played lead guitar in the road band for Jerry Lee Lewis.</i></p>
<p>
<i>Les Pinter can be reached at (916) 582-0595, on CompuServe at 76434,104, on the GO PINTER forum on Compuserve, or at 800-995-2797 (voicemail/fax).</i></p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4587">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the SECURITY sample application for this technical article.</a></p>
<h2>Introduction</h2>
<p>
Pinter Consulting has been in the Microsoft® FoxPro® software development business since the first version of FoxPro appeared. Although we've developed many different kinds of applications, most of our clients ask for some kind of security system, so that access to screens and functionality is restricted. After writing a number of these, we've come up with a general-purpose system that seems to meet most clients' needs. The system has evolved through several versions of FoxPro, and our most recent version is based on Microsoft Visual FoxPro™. This article describes that system.</p>
<p>
We patterned our approach after the Novell® security system. Novell uses a two-tiered system of user groups, to which rights are assigned, then assigns users to groups. That way, you only have to describe who can do what one time, as long as users who belong to the same group enjoy the same rights.</p>
<p>
What if a user has the same rights as a particular group, plus one or two additional access rights? Rather than set up a new group, we took a simpler approach. We first load the rights for the group the user is assigned to, then allow additional rights that complement or override those of the group. In that way, your users can create custom rights assignments with the minimum possible effort.</p>
<h2>System Design</h2>
<p>
The user must first log in, as seen in Figure 1. The Logon Screen uses the PassWordChar property to replace the characters typed by the user with an asterisk, or whatever character you choose. This prevents people standing behind the user from seeing the password as it's typed.</p>
<p>
<img src="security_1.gif" border=0></p>
<p class=label>
<b>Figure 1</b></p>
<p>
The ControlSource for UserID is a public variable named <i>pUserID</i>, declared in SECURITY.PRG when the application starts. (See Listing 1, shown below.) Note that SECURITY.APP only runs at the startup of your application, so these public declarations only happen once. If you try to PUBLIC a variable that already exists, you get an error message.</p>
<p>
We use PUBLIC variables so that SECURITY can be called as a procedure. To review, Visual FoxPro lets you refer to a variable in the program, function, or procedure in which it was created, as well as in any functions or procedures called by that program. If, however, you try to do something like this:</p>
<pre><code>* Main.PRG
DO Initial&nbsp;&nbsp; &amp;&amp; initialization procedure
? pUserID
PROCEDURE Initial
pUserID = "FRED"
</code></pre>
<p>
you'll get an error message. But, if the called procedure creates pUserID with a PUBLIC statement, for example:</p>
<pre><code>PUBLIC pUserID
</code></pre>
<p>
then the variable exists as if it had been created in the MAIN routine. So you can use the PUBLIC statement to move all of your initialization code to a called function, thereby making your MAIN easier to read. That's what we're doing here. The prefix <i>p</i>, which is not required, is simply a way of reminding the programmer reading the code that the variable is a public variable. Some programmers use an initial letter <i>l</i> for local variables, but you can also simply assume that variables lacking an initial <i>p</i> are local and save yourself a character.</p>
<p>
The security system uses a function called GRANTED.PRG to return a value of .T. if the user has access to a requested feature, or .F. otherwise. The way we do this is simple: At log in, we build a table with the name "S_" + the UserID, but with the alias "UserRght". A SEEK to the table using a key consisting of the concatenation of (1) the name of the item in question, and (2) the access right in question (for example, "READ", "WRITE", and so on), returns either .T. or .F.. Our screens, menus, and programs have to know what to do with that returned value.</p>
<p>
The framework for the security system is the project shown in Figure 2. This project contains all of the screens needed to manage the security system for an application. It also has a "test" screen to show the effects of the current security settings, and login and logout options in its menu. You would remove the test screen in production, and move the login and logout menu choices to your own menu.</p>
<p>
<img src="security_2.gif" border=0></p>
<p class=label>
<b>Figure 2</b></p>
<p>
Listing 1 shows SECURITY.PRG, the main program for our application.</p>
<pre><code>Listing 1: Security.prg - Main program for security
*--------------------------------------------------
SET TALK OFF
SET ECHO OFF
SET DELE ON
SET EXCL ON
PUBLIC pUserID, pUserPW, pSupervisor
pUserID&nbsp;&nbsp;&nbsp;&nbsp; = SPACE( 4)
pUserPW&nbsp;&nbsp;&nbsp;&nbsp; = SPACE(10)
pSupervisor = .F.
LOCAL Accessed
Accessed&nbsp;&nbsp;&nbsp; = .F.
DO FORM Login TO Accessed
IF Accessed
 &nbsp; DO Security.mpr
 &nbsp; READ EVENTS
 &nbsp; CLOSE DATA
 &nbsp; CLEAR WINDOW
 &nbsp; IF FILE("S_"+ALLT(pUserID)+".dbf")
 &nbsp;&nbsp;&nbsp;&nbsp; IF USED( "UserRght" )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USE IN UserRght
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; DELE FILE ("S_"+ALLT(pUserID)+".dbf")
 &nbsp;&nbsp;&nbsp;&nbsp; DELE FILE ("S_"+ALLT(pUserID)+".cdx")
 &nbsp; ENDIF&nbsp;&nbsp; 
 &nbsp; SET SYSMENU TO DEFA
ENDIF&nbsp;&nbsp; 
</code>*-----------------------------------------------------------
</pre>
<p>
The application only runs if it's able to log in. In normal use, you might restrict entry to the security system to someone with SUPERVISOR rights, but we couldn't demonstrate its features if we did so here.</p>
<h3>Tables Used by the Security System</h3>
<p>
The security system uses five tables. </p>
<p>
The USERS table stores the names of users, a password that ensures that no one else logs in under their UserID, and some descriptive information. In addition, if the user has <i>supervisor</i> status, the GRANTED function simply grants access and returns.</p>
<pre><code>Structure for table: USERS.DBF
Field Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Width
USERID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
PASSWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10
NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30
PHONE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14
NOTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Memo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
SUPER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
** Total **&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64
</code></pre>
<p>
The GROUPS file simply lists the names and descriptions of the available groups for list popups:</p>
<pre><code>Structure for table: GROUPS.DBF
Field Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Width
ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20
NOTES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Memo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
** Total **&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 29
</code></pre>
<p>
The USR2GRP file maps users to groups:</p>
<pre><code>Structure for table: USR2GRP.DBF
Field Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Width
USERID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
GROUPID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
** Total **&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9
</code></pre>
<p>
The RIGHTS file describes which rights are assignable:</p>
<pre><code>Structure for table: RIGHTS.DBF
Field Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Width
USRORGRPID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
ITEMID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20
ACCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
WRITE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
CREATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
DELETE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
PRINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
** Total **&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31
</code></pre>
<p>
The ITEMS file describes who has what rights to what item:</p>
<pre><code>Structure for table: RIGHTS.DBF
Field Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Width
USRORGRPID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
ITEMID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20
ACCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
WRITE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
CREATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
DELETE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
PRINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
** Total **&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31
</code></pre>
<p>
These five tables are used to produce a sixth table at login time. It's created with the name &lt;UserID&gt;.DBF, where the logged-in user's UserID replaces the filename, and has a structural .CDX file of the same name. The only fields are ITEMID and ACCESS, both of which are included in the index tag as a single key. Here's the program that uses the USERRGHT table:</p>
<pre><code>Listing 2: GRANTED.PRG
*-----------------------------------------------------------
* File name : Granted.prg
* Purpose&nbsp;&nbsp; : Checks if user has specified rights for the 
* named item
* Parameters:item Id, &lt;expC&gt; - name of the right
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Type of access &lt;expC&gt; - (ACCESS,READ etc.)
* Returns&nbsp;&nbsp; : .t. or .f. 
* Called by: Various
*-----------------------------------------------------------
PARAMETER inItem,inRight
IF pSupervisor
 &nbsp; RETURN .T.
ENDIF&nbsp;&nbsp; 
IF NOT USED("UserRght")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; Testing
 &nbsp; RETURN .T.
ENDIF&nbsp;&nbsp; 
inItem&nbsp; = padr(upper(inItem),20," ")
inRight = upper(inRight)
RETURN SEEK(inItem+inRight,'UserRght', "USERRGHT")
*-----------------------------------------------------------
</code></pre>
<p>
How you code this function is determined by the way you want the access system to work. The reason we use both a topic and an access right is that we wanted to simplify the process of setting rights. </p>
<p>
The basic rights screen appears in Figure 3. </p>
<p>
<img src="security_3.gif" border=0></p>
<p class=label>
<b>Figure 3</b></p>
<p>
We wanted to simplify the granting of rights, so we limited them to six categories, represented by the rightmost six columns shown in Figure 3. Rights are divided into five groups, represented by the index tabs on the page frame:
<ul type=disc>
<li>
Menu popups<br><br></li>
<li>
Screens<br><br></li>
<li>
Reports<br><br></li>
<li>
Fields<br><br></li>
<li>
Other</li>
</ul>
<p>
This division was done to reduce the number of available selections in the grid, and to help organize users' thinking. Only some of the columns apply to any one of the five groups; for example, menus are only <i>access</i> protected.</p>
<p>
A simpler system can be written based on a hierarchy of rights. For example, viewing a screen might be Level 1, printing reports could be Level 2, and deleting records might be Level 3. Thus, Level 2 users could view screens and print reports, but couldn't delete records. It's easy to program, but that's about all it's got going for itself.</p>
<p>
We've never liked this kind of system, for two reasons. First, such hierarchies are artificial and arbitrary; I can easily imagine an environment where a data entry clerk could enter and delete data, but shouldn't be printing out hard copies that might leave the premises. So it's hard to get consensus on such a hierarchy, and if it changes, it gets really messy.</p>
<p>
But perhaps the more serious criticism of access hierarchies is that they imply a class system, with varying degrees of worthiness. Forgive my chauvinism, but I'm an American, and <i>we ain't got no stinking class system</i>. So I don't like to build systems that declare Mary superior to Joe in a linear fashion. It just goes against my Texan nature.</p>
<p>
The five categories are somewhat arbitrary, and based on a particular application. But you'll be happy to know that all you have to do to use this approach is to change the captions on the pages, or even the number of pages, and the system will know what to do with them. This bit of name-driven magic is shown later.</p>
<p>
The keys to using this system are shown in screen TEST.SCX, which is included in the SECURITY project. The screen is shown in Figure 4, below.</p>
<p>
<img src="security_4.gif" border=0></p>
<p class=label>
<b>Figure 4</b></p>
<h2>Coding the Application</h2>
<p>
This screen's INIT code looks like this:</p>
<pre><code>StandardScreen::Init&nbsp;&nbsp; &amp;&amp; Run the template's default code
THISFORM.ShowButton&nbsp;&nbsp;&nbsp; &amp;&amp; Hide buttons that aren't used here
THISFORM.FinancialFields &amp;&amp; Can they see "FinancialFields"?

THISFORM.InputField1.Value = "USER"
THISFORM.FinancialField2.Value = "5,345.00"
THISFORM.FinancialField3.Value = "10,324.45"
THISFORM.FinancialField4.Value ="-2,349.20"
</code></pre>
<p>
The assignment of values is required so that something will appear in the fields. The other three lines of code call methods in the template class StandardScreen—the standard <i>Init</i> logic and two other library methods.</p>
<p>
The section immediately following this one is a review of the StandardScreen object that is the <i>template</i> for all of our screens. Templates are assigned in the Tools, Options, Forms dialog window. FinancialFields is a <i>method</i> in our StandardScreen class, which is used as the template for all of the screens in our application. When you add properties and methods to a class, then use it as the template for your screens, each screen can reference those methods. So this is what the FinancialFields<b> </b>method does:</p>
<pre><code>PROCEDURE financialfields
IF NOT Granted("OTHFINANCE","READ")
 &nbsp; THISFORM.SetAll ( "Visible",&nbsp; .F., "Financialfield" )
ENDIF
IF NOT Granted("OTHFINANCE","WRITE")
 &nbsp; THISFORM.SetAll ( "Readonly", .T., "Financialfield" )
ENDIF
ENDPROC
</code></pre>
<p>
SetAll is a form method built into Visual FoxPro's form object, and it's used to set properties for classes of screen objects. For example, you can make all of the list boxes on a screen disabled like this:</p>
<pre><code>THISFORM.SetAll ( "Enabled", .F., "Listbox" )
</code></pre>
<p>
Listbox is the name of the Visual FoxPro base class. If you create your own class, just substitute its name:</p>
<pre><code>THISFORM.SetAll ( "Enabled", .F., "Listbox" )
</code></pre>
<p>
However, there's one restriction. While you can refer to a Visual FoxPro base class that isn't represented on your form, the same isn't true for your own class names. If you include the statement</p>
<pre><code>THISFORM.SetAll ( "Enabled", .F., "Financialfield" )
</code></pre>
<p>
and you don't have at least one FinancialField object on the form, you'll get an error.</p>
<p>
Having said that, it's clear that you have to put code into the Init routine for each screen that knows that you have, for example, financial fields to protect. You can't simply add blanket calls to SetAll in the template and expect that they'll have no effect if no such fields are present. But you <i>can</i> create a generic routine in the template screen that can be called as needed. That's what we've done here. The FinancialFields<i> </i>method is in the StandardScreen<i> </i>class, so you call it in screens that have financial fields, and don't refer to it in screens that don't.</p>
<p>
We've done a few more things in each of our screens based on StandardScreen and its contained objects. So let's take a moment to look at the classes used in this application.</p>
<h3>The MYLIB Class Library</h3>
<p>
In the CLASSES subdirectory, you'll find a pair of files called MYLIB.VCX and MYLIB.VCT. This is where our class library resides. To use a library, you SET CLASSLIB TO MYLIB ADDITIVE. Alternatively, from within the Form Designer, activate the Form Controls toolbar, then click the "View Classes" icon, which looks like a small stack of books. If MYLIB isn't showing, click on Add, then go to the CLASSES directory and select it. Once it's in the list of available classes, you can select it. The Form Controls toolbar will change to reflect what's available.</p>
<p>
The first and most important class to consider is StandardScreen. We created this by opening the Form Designer, creating the basic screen we wanted to use for all of our screens, then saving it as a class in a class library called MYLIB.VCX.</p>
<p>
We used the "source code listing" option from the Class Browser that comes with the Professional Edition of Visual FoxPro to list the code. It does a better job of describing the details of the class. However, don't get the impression that we wrote code to do anything in this application; we didn't. The code listing is simply a convenient way to explain what's going on in the class itself. Essentially, in the Init section of the code listing, you can see new properties that we've added, or settings that we've made to properties that the class already contains.</p>
<p>
StandardScreen is shown below in Figure 5. It has a standard set of buttons, which are themselves based on classes that we created previously. Many shops add a logo in the upper right corner of the screen.</p>
<p>
<img src="security_5.gif" border=0></p>
<p class=label>
<b>Figure 5</b></p>
<p>
Here's the code that describes StandardScreen:</p>
<pre><code>Listing 3: StandardScreen in MYLIB.VCX
**************************************************
*-- Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; standardscreen (mylib.vcx)
*-- ParentClass:&nbsp; form
*-- BaseClass:&nbsp;&nbsp;&nbsp; form
DEFINE CLASS standardscreen AS form
 &nbsp; Top = 6
 &nbsp; Left = -6
 &nbsp; Height = 418
 &nbsp; Width = 630
 &nbsp; DoCreate = .T.
 &nbsp; ShowTips = .T.
 &nbsp; BackColor = RGB(192,192,192)
 &nbsp; Caption = "Form"
 &nbsp; Closable = .F.
 &nbsp; WindowState = 0
 &nbsp; Name = "standardscreen"
* The following are new form properties that we added:
 &nbsp; primarytable = ""
 &nbsp; saverecord&nbsp;&nbsp; =&nbsp; 0
 &nbsp; searchkey&nbsp;&nbsp;&nbsp; = ""
 &nbsp; adding&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = .F.
 &nbsp; savealias&nbsp;&nbsp;&nbsp; = ""
 &nbsp; browsefields = ""

 &nbsp; ADD OBJECT box3d1 AS box3d WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; Height = 36, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Left = 4, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Top = 3, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Width = 279, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Name = "Box3d1"

 &nbsp; ADD OBJECT cmdadd1 AS cmdadd WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; Top = 6, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Left = 68, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Height = 29, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Width = 30, ;
 &nbsp;&nbsp;&nbsp;&nbsp; TabIndex = 3, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Name = "Cmdadd1"

 &nbsp; ADD OBJECT cmdedit2 AS cmdedit WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; Top = 6, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Left = 98, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Height = 29, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Width = 30, ;
 &nbsp;&nbsp;&nbsp;&nbsp; TabIndex = 4, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Name = "Cmdedit2"

 &nbsp; ADD OBJECT cmdfind3 AS cmdfind WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; Top = 6, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Left = 128, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Height = 29, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Width = 30, ;
 &nbsp;&nbsp;&nbsp;&nbsp; TabIndex = 5, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Name = "Cmdfind3"

 &nbsp; ADD OBJECT cmddelete4 AS cmddelete WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; Top = 6, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Left = 158, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Height = 29, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Width = 30, ;
 &nbsp;&nbsp;&nbsp;&nbsp; TabIndex = 6, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Name = "Cmddelete4"

 &nbsp; ADD OBJECT cmdsave5 AS cmdsave WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; Top = 6, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Left = 188, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Height = 29, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Width = 30, ;
 &nbsp;&nbsp;&nbsp;&nbsp; TabIndex = 7, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Name = "Cmdsave5"

 &nbsp; ADD OBJECT cmdcancel6 AS cmdcancel WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; Top = 6, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Left = 218, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Height = 29, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Width = 30, ;
 &nbsp;&nbsp;&nbsp;&nbsp; TabIndex = 8, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Name = "Cmdcancel6"

 &nbsp; ADD OBJECT cmdexit7 AS cmdexit WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; Top = 6, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Left = 248, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Height = 29, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Width = 30, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Picture = "..\bmps\close.bmp", ;
 &nbsp;&nbsp;&nbsp;&nbsp; Caption = "", ;
 &nbsp;&nbsp;&nbsp;&nbsp; TabIndex = 9, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Name = "Cmdexit7"

 &nbsp; ADD OBJECT cmdnext8 AS cmdnext WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; Top = 6, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Left = 38, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Height = 29, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Width = 30, ;
 &nbsp;&nbsp;&nbsp;&nbsp; TabIndex = 2, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Name = "Cmdnext8"

 &nbsp; ADD OBJECT cmdprev9 AS cmdprev WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp; Top = 6, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Left = 8, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Height = 29, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Width = 30, ;
 &nbsp;&nbsp;&nbsp;&nbsp; TabIndex = 1, ;
 &nbsp;&nbsp;&nbsp;&nbsp; Name = "Cmdprev9"

 &nbsp; PROCEDURE buttonson
 &nbsp;&nbsp;&nbsp;&nbsp; IF Granted( "SCR"&nbsp;&nbsp; ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + UPPER(THISFORM.Name),"CREATE")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdAdd1.Enabled = .T.
 &nbsp;&nbsp;&nbsp;&nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdAdd1.Enabled = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF Granted("SCR" ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + UPPER(THISFORM.Name),"WRITE")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdEdit2.Enabled = .T.
 &nbsp;&nbsp;&nbsp;&nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdEdit2.Enabled = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdFind3.Enabled&nbsp;&nbsp;&nbsp; = .T.
 &nbsp;&nbsp;&nbsp;&nbsp; IF Granted("SCR"&nbsp;&nbsp; ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + UPPER(THISFORM.Name),"DELETE")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdDelete4.Enabled=.T.
 &nbsp;&nbsp;&nbsp;&nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdDelete4.Enabled=.F.
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdSave5.Enabled&nbsp;&nbsp;&nbsp; = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdCancel6.Enabled&nbsp; = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdExit7.Enabled&nbsp;&nbsp;&nbsp; = .T.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdNext8.Enabled&nbsp;&nbsp;&nbsp; = .T.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdPrev9.Enabled&nbsp;&nbsp;&nbsp; = .T.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.TestBofEof()
 &nbsp; ENDPROC

 &nbsp; PROCEDURE buttonsoff
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdAdd1.Enabled&nbsp;&nbsp;&nbsp;&nbsp; = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdEdit2.Enabled&nbsp;&nbsp;&nbsp; = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdFind3.Enabled&nbsp;&nbsp;&nbsp; = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdDelete4.Enabled&nbsp; = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdSave5.Enabled&nbsp;&nbsp;&nbsp; = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdCancel6.Enabled&nbsp; = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdExit7.Enabled&nbsp;&nbsp;&nbsp; = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdNext8.Enabled&nbsp;&nbsp;&nbsp; = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdPrev9.Enabled&nbsp;&nbsp;&nbsp; = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.TestBofEof()
 &nbsp; ENDPROC

 &nbsp; PROCEDURE testbofeof
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EMPTY ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF ! EOF()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SaveRec = RECNO()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COUNT TO LocalCount FOR NOT DELETED()
 &nbsp;&nbsp;&nbsp;&nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalCount = 0
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF

 &nbsp;&nbsp;&nbsp;&nbsp; IF LocalCount = 0
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F.,"cmdNext")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F.,"cmdPrev")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F.,"cmdEdit")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F.,cmdDelete")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; GO ( SaveRec )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll ("Enabled",&nbsp;&nbsp; .T., "cmdNext")
 &nbsp;&nbsp;&nbsp;&nbsp; SKIP
 &nbsp;&nbsp;&nbsp;&nbsp; IF EOF()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F.,"cmdNext" )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; GO ( SaveRec )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll&nbsp;&nbsp; ("Enabled", .T.,"cmdPrev" )
 &nbsp;&nbsp;&nbsp;&nbsp; SKIP -1
 &nbsp;&nbsp;&nbsp;&nbsp; IF BOF()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F.,"cmdPrev" )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; GO ( SaveRec )
 &nbsp; ENDPROC

 &nbsp; PROCEDURE financialfields
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT Granted("OTHFINANCE","READ")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll ( "Visible",&nbsp; .F., ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Financialfield" )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT Granted("OTHFINANCE","WRITE")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll ( "Readonly", .T., ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Financialfield" )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp; ENDPROC

 &nbsp; PROCEDURE showbutton
* The following code makes invisible those controlbuttons whose SELECT property (which we created) is set to .T. for the current form. It also resizes the 3D box around the controls.

 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdAdd1.Visible&nbsp;&nbsp;&nbsp;&nbsp; = ;
IIF(THISFORM.cmdAdd1.Select&nbsp; = .T., .T., .F.)
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdEdit2.Visible&nbsp;&nbsp;&nbsp;&nbsp; = ;
IIF(THISFORM.cmdEdit2.Select = .T., .T., .F.)
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdFind3.Visible&nbsp;&nbsp;&nbsp;&nbsp; = ;
IIF(THISFORM.cmdFind3.Select = .T., .T., .F.)
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdDelete4.Visible&nbsp; = ;
IIF(THISFORM.cmdDelete4.Select= .T., .T.,.F.)
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdSave5.Visible&nbsp;&nbsp;&nbsp;&nbsp; = ;
IIF(THISFORM.cmdSave5.Select = .T., .T., .F.)
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdCancel6.Visible&nbsp; = ;
IIF(THISFORM.cmdCancel6.Select= .T., .T.,.F.)
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdExit7.Visible&nbsp;&nbsp;&nbsp;&nbsp; = ;
IIF(THISFORM.cmdExit7.Select = .T., .T., .F.)
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdPrev9.Visible&nbsp;&nbsp;&nbsp;&nbsp; = ;
IIF(THISFORM.cmdPrev9.Select = .T., .T., .F.)
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdNext8.Visible&nbsp;&nbsp;&nbsp;&nbsp; = ;
 &nbsp;&nbsp;&nbsp;&nbsp; IIF(THISFORM.cmdNext8.Select = .T., .T., .F.)
 &nbsp;&nbsp;&nbsp;&nbsp; I = 10
 &nbsp;&nbsp;&nbsp;&nbsp; IF THISFORM.cmdFind3.Select = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdFind1.Left = I
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + THISFORM.CmdFind1.Width + 1
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF THISFORM.cmdPrev9.Select = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdPrev9.Left = I
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + THISFORM.cmdPrev9.Width + 1
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF THISFORM.cmdNext8.Select = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdNext8.Left = I
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + THISFORM.cmdNext8.Width + 1
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF THISFORM.cmdAdd1.Select = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdAdd1.Left = I
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + THISFORM.cmdAdd1.Width + 1
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF THISFORM.cmdEdit2.Select = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdEdit2.Left = I
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + THISFORM.cmdEdit2.Width + 1
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF THISFORM.cmdDelete4.Select = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdDelete4.Left = I
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + THISFORM.cmdDelete4.Width + 1
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF THISFORM.cmdSave5.Select = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdSave5.Left = I
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + THISFORM.cmdSave5.Width + 1
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF THISFORM.cmdCancel6.Select = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdCancel6.Left = I
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + THISFORM.cmdCancel6.Width + 1
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF THISFORM.cmdPrev9.Select = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdPrev9.Left = I
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + THISFORM.cmdPrev9.Width + 1
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF THISFORM.cmdNext8.Select = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdNext8.Left = I
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + THISFORm.cmdNext8.Width + 1
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF THISFORM.cmdExit7.Select = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.cmdExit7.Left = I
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + THISFORM.cmdExit7.Width + 1
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF I&gt;10
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Box3d1.Width = I + 2
 &nbsp;&nbsp;&nbsp;&nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Box3d1.Visible = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp; ENDPROC

 &nbsp; PROCEDURE Init
 &nbsp;&nbsp;&nbsp;&nbsp; THIS.AutoCenter = .T.
 &nbsp;&nbsp;&nbsp;&nbsp; THIS.ButtonsOn
 &nbsp; ENDPROC

ENDDEFINE
*
*-- EndDefine: standardscreen
**************************************************
</code></pre>
<p>
This code assumes that the command buttons have already been defined. Here they are:</p>
<pre><code>**************************************************
*-- Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdnext (classes\mylib.vcx)
*-- ParentClass:&nbsp; commandbutton
*-- BaseClass:&nbsp;&nbsp;&nbsp; commandbutton
*
DEFINE CLASS cmdnext AS commandbutton

 &nbsp; Height = 25
 &nbsp; Width = 40
 &nbsp; Picture = "..\bmps\wznext.bmp"
 &nbsp; Caption = ""
 &nbsp; ToolTipText = "Next record"
 &nbsp; select = .T.
 &nbsp; Name = "cmdnext"

 &nbsp; PROCEDURE Click
 &nbsp;&nbsp;&nbsp;&nbsp; SaveAlias = ALIAS()
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EMPTY ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EOF()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SKIP
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF EOF()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO BOTTOM
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Refresh
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EMPTY ( SaveAlias )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; ( SaveAlias )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.TestBofEof
 &nbsp; ENDPROC

ENDDEFINE
*
*-- EndDefine: cmdnext
**************************************************

**************************************************
*-- Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdprev (classes\mylib.vcx)
*-- ParentClass:&nbsp; commandbutton
*-- BaseClass:&nbsp;&nbsp;&nbsp; commandbutton
*
DEFINE CLASS cmdprev AS commandbutton

 &nbsp; Height = 25
 &nbsp; Width = 40
 &nbsp; Picture = "..\bmps\wzback.bmp"
 &nbsp; Caption = ""
 &nbsp; ToolTipText = "Previous record"
 &nbsp; select = .T.
 &nbsp; Name = "cmdprev"

 &nbsp; PROCEDURE Click
 &nbsp;&nbsp;&nbsp;&nbsp; SaveAlias = ALIAS()
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EMPTY ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT BOF()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SKIP -1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF BOF()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TOP
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Refresh
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EMPTY ( SaveAlias )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; ( SaveAlias )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.TestBofEof
 &nbsp; ENDPROC

ENDDEFINE
*
*-- EndDefine: cmdprev
**************************************************

**************************************************
*-- Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdadd (classes\mylib.vcx)
*-- ParentClass:&nbsp; commandbutton
*-- BaseClass:&nbsp;&nbsp;&nbsp; commandbutton
*
DEFINE CLASS cmdadd AS commandbutton

 &nbsp; Height = 25
 &nbsp; Width = 40
 &nbsp; Picture = "..\bmps\wznew.bmp"
 &nbsp; Caption = ""
 &nbsp; ToolTipText = "Add a record"
 &nbsp; select = .T.
 &nbsp; Name = "cmdadd"

 &nbsp; PROCEDURE Click
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EMPTY ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Adding = .T.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SaveRecord = RECNO()
 &nbsp;&nbsp;&nbsp;&nbsp; * Recycle deleted records
 &nbsp;&nbsp;&nbsp;&nbsp; LOCATE FOR DELETED()
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT FOUND()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; APPEND BLANK
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Refresh

 &nbsp;&nbsp;&nbsp;&nbsp; * Activate any base class objects ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and disable command buttons
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "Combobox"&nbsp;&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "Spinner"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled",;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .T.,"Commandbutton")
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "Editbox"&nbsp;&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; * The only derived class that is expected ;
 &nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; on every form is InputField:
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T.,"Inputfield")

 &nbsp;&nbsp;&nbsp;&nbsp; * To add others, type the following into the;
 &nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; edit button click event code window:
 &nbsp;&nbsp;&nbsp;&nbsp; *cmdEdit::Click

 &nbsp;&nbsp;&nbsp;&nbsp; *THISFORM.SetAll("Enabled", .T.,"Classname") * Classname is case-sensitive
 &nbsp;&nbsp;&nbsp;&nbsp; *THISFORM.FirstField.SetFocus

 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdAdd"&nbsp;&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdEdit"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdNext"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdPrev"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdDelete")
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdExit"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdFind"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdSave"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdCancel")
 &nbsp; ENDPROC

ENDDEFINE
*
*-- EndDefine: cmdadd
**************************************************

**************************************************
*-- Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdedit (classes\mylib.vcx)
*-- ParentClass:&nbsp; commandbutton
*-- BaseClass:&nbsp;&nbsp;&nbsp; commandbutton
*
DEFINE CLASS cmdedit AS commandbutton

 &nbsp; Height = 25
 &nbsp; Width = 40
 &nbsp; Picture = "..\bmps\wzedit.bmp"
 &nbsp; Caption = ""
 &nbsp; ToolTipText = "Edit this record"
 &nbsp; Name = "cmdedit"

 &nbsp; Select&nbsp;&nbsp;&nbsp; = .T.&nbsp;&nbsp; &amp;&amp; property added by us

 &nbsp; PROCEDURE Click
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EMPTY ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SaveRecord = recno()
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "Combobox")
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "Spinner" )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled",.T.,Commandbutton")
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "Editbox" )

 &nbsp;&nbsp;&nbsp;&nbsp; * Derived class assumed present on all forms:
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "Inputfield")

 &nbsp;&nbsp;&nbsp;&nbsp; * To add others, type the following into the 
 &nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; edit button click event code window:
 &nbsp;&nbsp;&nbsp;&nbsp; *cmdEdit::Click
 &nbsp;&nbsp;&nbsp;&nbsp; *THISFORM.SetAll("Enabled", .T., "Classname")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *THISFORM.FirstField.SetFocus

 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdAdd"&nbsp;&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdEdit"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdNext"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdPrev"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdDelete")
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdExit"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdFind"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdSave"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdCancel")
 &nbsp; ENDPROC

ENDDEFINE
*
*-- EndDefine: cmdedit
**************************************************

**************************************************
*-- Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdfind (classes\mylib.vcx)
*-- ParentClass:&nbsp; commandbutton
*-- BaseClass:&nbsp;&nbsp;&nbsp; commandbutton
DEFINE CLASS cmdfind AS commandbutton

 &nbsp; Height = 25
 &nbsp; Width = 40
 &nbsp; Picture = "..\bmps\find.bmp"
 &nbsp; Caption = ""
 &nbsp; ToolTipText = "Open/Find a record"
 &nbsp; select = .T.
 &nbsp; Name = "cmdfind"

 &nbsp; PROCEDURE Click
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EMPTY(THISFORM.PrimaryTable)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT (THISFORM.PrimaryTable)
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT "JKEY" $ SET("CLASSLIB")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET LIBRARY TO JKEY ADDITIVE
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; _JExitKey = 13
 &nbsp;&nbsp;&nbsp;&nbsp; =JKeyInit("U")
 &nbsp;&nbsp;&nbsp;&nbsp; IF EMPTY (THISFORM.BrowseFields)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BROWSE TITLE ;
 &nbsp;&nbsp;&nbsp;&nbsp; "Highlight your selection and press ENTER"
 &nbsp;&nbsp;&nbsp;&nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOCAL lFields
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lFields = THISFORM.BrowseFields
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BROWSE FIELDS &amp;lFields TITLE ;
 &nbsp;&nbsp;&nbsp;&nbsp; "Highlight your selection and press ENTER" 
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; =JKeyCanc()
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.TestBofEof
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Refresh
 &nbsp; ENDPROC
ENDDEFINE
*-- EndDefine: cmdfind
**************************************************

**************************************************
*-- Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmddelete (classes\mylib.vcx)
*-- ParentClass:&nbsp; commandbutton
*-- BaseClass:&nbsp;&nbsp;&nbsp; commandbutton

DEFINE CLASS cmddelete AS commandbutton

 &nbsp; Height = 25
 &nbsp; Width = 40
 &nbsp; Picture = "..\bmps\delete.bmp"
 &nbsp; Caption = ""
 &nbsp; ToolTipText = "Delete this record"
 &nbsp; Name = "cmddelete"

 &nbsp; select = .T.&nbsp;&nbsp; &amp;&amp; property added by us

 &nbsp; PROCEDURE Click
 &nbsp;&nbsp;&nbsp;&nbsp; SaveAlias = ALIAS()
 &nbsp;&nbsp;&nbsp;&nbsp; IF TYPE&nbsp; ( "THISFORM.PrimaryTable" ) &lt;&gt; [U]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; IF MessageBox("Delete this record?", ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 + 32 + 256 , "Note: Can't undo" ) = 6
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DELETE NEXT 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET DELETED ON
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TOP
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Refresh
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EMPTY ( SaveAlias )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; ( SaveAlias )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.TestBofEof
 &nbsp; ENDPROC

ENDDEFINE
*
*-- EndDefine: cmddelete
**************************************************

**************************************************
*-- Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdsave (classes\mylib.vcx)
*-- ParentClass:&nbsp; commandbutton
*-- BaseClass:&nbsp;&nbsp;&nbsp; commandbutton
*
DEFINE CLASS cmdsave AS commandbutton

 &nbsp; Height = 25
 &nbsp; Width = 40
 &nbsp; Picture = "..\bmps\wzsave.bmp"
 &nbsp; Caption = ""
 &nbsp; ToolTipText = "Save changes"
 &nbsp; Name = "cmdsave"
 &nbsp; select = .T.&nbsp;&nbsp; &amp;&amp; property added by us

 &nbsp; PROCEDURE Click
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EMPTY ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; =TableUpdate()
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Adding = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "Combobox" )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "Spinner"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled",.F.,Commandbutton")
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "Editbox"&nbsp; )

 &nbsp;&nbsp;&nbsp;&nbsp; * Derived class assumed to exist in every 
 &nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; form (otherwise, an error results)
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled",.F.,"Inputfield" )

 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdAdd"&nbsp;&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdEdit"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdNext"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdPrev"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdDelete")
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdExit"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdFind"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdSave"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdCancel")
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Refresh
 &nbsp; ENDPROC

ENDDEFINE
*
*-- EndDefine: cmdsave
**************************************************

**************************************************
*-- Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdcancel (classes\mylib.vcx)
*-- ParentClass:&nbsp; commandbutton
*-- BaseClass:&nbsp;&nbsp;&nbsp; commandbutton
*
DEFINE CLASS cmdcancel AS commandbutton

 &nbsp; Height = 25
 &nbsp; Width = 40
 &nbsp; Picture = "..\bmps\undo.bmp"
 &nbsp; Caption = ""
 &nbsp; ToolTipText = "Abandon changes"
 &nbsp; Name = "cmdcancel"
 &nbsp; select = .T.&nbsp;&nbsp; &amp;&amp; property added by us

 &nbsp; PROCEDURE Click
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EMPTY ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; ( THISFORM.PrimaryTable )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; =TableRevert() &amp;&amp; PrimaryTable buffermode 3
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT THISFORM.Adding
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO ( THISFORM.SaveRecord )
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Refresh
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Adding = .F.
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "Combobox" )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "Spinner"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled",.F.,"Commandbutton")
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "Editbox"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "Inputfield")

 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdAdd"&nbsp;&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdEdit"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdNext"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdPrev"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdDelete")
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdExit"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .T., "cmdFind"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdSave"&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetAll("Enabled", .F., "cmdCancel")
 &nbsp; ENDPROC

ENDDEFINE
*
*-- EndDefine: cmdcancel
**************************************************

**************************************************
*-- Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdexit (classes\mylib.vcx)
*-- ParentClass:&nbsp; commandbutton
*-- BaseClass:&nbsp;&nbsp;&nbsp; commandbutton
*
DEFINE CLASS cmdexit AS commandbutton

 &nbsp; AutoSize = .F.
 &nbsp; Height = 25
 &nbsp; Width = 40
 &nbsp; FontSize = 9
 &nbsp; Caption = " E\&lt;xit"
 &nbsp; ToolTipText = "Exit this screen"
 &nbsp; Name = "cmdexit"
 &nbsp; select = .T.&nbsp;&nbsp; &amp;&amp; property added by us

 &nbsp; PROCEDURE Click
 &nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Release
 &nbsp; ENDPROC

ENDDEFINE
*
*-- EndDefine: cmdexit
**************************************************
</code></pre>
<p>
We added a property called Select to each of the command buttons, because not all forms use all of the buttons. We found that, after instantiating a form, we had to go back, make the unnecessary buttons invisible, then change the size of the 3D box that surrounds them. We decided that it would be easier to set a property on each button to .F. if we didn't want that button to appear on the form, then let the template calculate the width of the box around the remaining buttons. That's what the code in procedure ShowButton in StandardScreen is all about. It looks like a lot of work, but once we did it, we never had to remove unused command buttons from screens again.</p>
<h3>Form Conventions</h3>
<p>
We added a few properties to our StandardScreen template. First, we wanted to make sure the correct table was selected before we performed record-related operations, like moving the record pointer or deleting a record. So we require that the principal table in each form (the one that we SKIP or SKIP -1 in when the Next or Previous buttons are clicked) be named in our new form property THISFORM.PrimaryTable. Then, we preceded every movement or deletion command with this:</p>
<pre><code>&nbsp;&nbsp;&nbsp;IF NOT EMPTY ( THISFORM.PrimaryTable)
 &nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; ( THISFORM.PrimaryTable)
 &nbsp; ENDIF
</code></pre>
<p>
Second, we decided to use optimistic record locking for editing. That means that changes to a record aren't actually written to disk until (1) the record pointer moves, or (2) the TableUpdate() function is called. In our case, only (2) can happen, because we disable all movement command buttons until adding or editing has either been saved or canceled. (Case 1 is generally used with BROWSE or GRIDS.) </p>
<p>
If you add the primary table to the form's Data Environment, then right click on the Data Environment and select the Properties Sheet, you'll see a property called BufferModeOverride. Set it to 3, and Visual FoxPro will know what to do with the TableUpdate and TableRevert calls in the Save and Cancel buttons. (You also have to SET MULTILOCKS ON in your environment, and of course in your MAIN program.)</p>
<p>
This isn't a form property; it's a convention that we require to make our SAVE and CANCEL commands work right. You can also add the following two lines to every Load event code:</p>
<pre><code>&nbsp;&nbsp;&nbsp;SELECT ( THISFORM.PrimaryTable )
 &nbsp; =CursorSetProp("Buffering",3)
</code></pre>
<p>
Finally, we wanted to make our FIND command easier to customize. As we saw above, we use a BROWSE that relies on Joe Gotthelf's JKEY utility, which turns BROWSE into an incremental search. But BROWSE alone shows the first few fields in the table. The leftmost field isn't always the current key field (which is what JKEY searches on as you type).</p>
<p>
We added a form property called BrowseFields. When you call the Search function, if the form has a comma-delimited list of fields in its BrowseFields property, the Find button (which uses a JKEY search) will display only the named fields. Just make the leftmost field the current key field, and your FIND function will work very intuitively.</p>
<h3>Modifying the Default CLICK Behavior</h3>
<p>
What if you don't want the Find button to do anything? Here's one way: Open up the Click code window in your form based on StandardScreen and type a single asterisk, like this:</p>
<pre><code>* Click code for cmdFind:
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;== this is it!
</code></pre>
<p>
That's all it takes to tell Visual FoxPro to ignore the class's original code! The fact is, if you enter so much as a single comment—even a single asterisk—the original code is ignored. You probably wouldn't do this, except by mistake. A more likely case is when you want to use the original code, then add more commands.</p>
<p>
A typical case is the one where you have a list box on the screen. List boxes that use structured query language (SQL) to load their contents aren't refreshed automatically when you issue the THISFORM.REFRESH command. So, if you FIND a new parent record, and you want a list box to show the related child records, you have to do it yourself:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CmdFind::Click
 &nbsp; THISFORM.ListBox1.Requery
</code></pre>
<p>
The first line is called the <i>scope resolution operator</i>. It has to name the name of the class containing the Click code you want to execute. You can use this with WIZARD-generated command buttons as well, making the Form Wizard a usable tool for the first time.</p>
<h3>Setting Up the Security System</h3>
<p>
The first thing you do when setting up our security system is to define what the protected items are. The screen shown in Figure 6 is used for that purpose.</p>
<p>
<img src="security_6.gif" border=0></p>
<p class=label>
<b>Figure 6</b></p>
<p>
The tabs on the page frame are used to group the items functionally. Although we've used Menus, Screens, Reports, Fields, and Other, there's no requirement as to what categories you choose. To change them, select the page frame in Screen Items, then open the Properties Sheet and click Other. The PageCount property can be set to any number of pages. You'll see something like Figure 7:</p>
<p>
<img src="security_7.gif" border=0></p>
<p class=label>
<b>Figure 7</b></p>
<p>
Then, set the page captions to whatever you want. As you create new item ID records, they'll be stamped with the caption of the page they're created on.</p>
<h3>Coordinating the Grid with the Page Frame</h3>
<p>
The mechanism used to make the grid display the items that correspond to the page frame captions (the tabs) is widely used. The trick consists of two parts:
<ol>
<li>
Place the grid object on the page frame itself, not on page 1 of the page frame.<br><br></li>
<li>
Use the Activate clause of each of the pages to set a new filter and repopulate the page frame.</li>
</ol>
<p>
For example, this is the ACTIVATE code for each one of the pages:</p>
<pre><code>&nbsp;&nbsp;&nbsp;Page&nbsp;&nbsp;&nbsp; = THIS.Name
 &nbsp; PageName = UPPER(THISFORM.PageFrame1.&amp;Page..Caption)
 &nbsp; SET FILTER TO TYPE&nbsp; = PageName
 &nbsp; GO TOP
 &nbsp; THISFORM.Refresh
</code></pre>
<p>
The item ID field can contain any identifier that is easy for you to remember. In the examples shown, we prefixed each ID with a few letters indicating the type of usage, but it's optional.</p>
<p>
This screen isn't used to assign rights to users; it has two other uses: to add items available for assignment elsewhere, and to indicate which selections make sense. For example, we grant ACCESS to menu pads, but we read or write fields, and delete records. So no item has all rights, simply because it wouldn't make sense.</p>
<h3>User Groups</h3>
<p>
Our security system supports user groups. Their purpose is to grant rights in ways that are shared by the same type of user. For example, accounting personnel probably need to have access to almost everything; data entry clerks, on the other hand, might need access only to the data they're entering. Financial information—salaries, for example—might be especially sensitive. By granting rights by group, then assigning users to groups, we can greatly cut down on the work involved in setting up and administering a security system.</p>
<p>
The GROUPS screen is shown in Figure 8. </p>
<p>
<img src="security_8.gif" border=0></p>
<p class=label>
<b>Figure 8</b></p>
<p>
All we do here is add names to the group's member list. We can also enter a note that describes the nature of the grouping. </p>
<p>
The data environment for this screen is shown in Figure 9. Users are related to groups through an intermediate table called USR2GRP.</p>
<p>
<img src="security_9.gif" border=0></p>
<p class=label>
<b>Figure 9</b></p>
<p>
There are eight pieces of event code in this screen. The code for the Activate event consists of a single line:</p>
<pre><code>SELECT GROUPS
</code></pre>
<p>
The standard buttons at the top of the screen also required a little modification. Here's the ADD button code:</p>
<pre><code>cmdAdd::Click
THISFORM.SetAll("Enabled",.T.,"EditBox")
THISFORM.infGroupID.SetFocus
</code></pre>
<p>
This runs the standard cmdAdd CLICK code, then enables the EditBox on the screen (the note field), and sets the focus on the GroupID text box.</p>
<p>
The EDIT button code is almost identical:</p>
<pre><code>cmdAdd::Click
THISFORM.SetAll("Enabled",.T.,"EditBox")
THISFORM.infGr
</code></pre>
<p>
The Save and Cancel buttons are also practically identical:</p>
<pre><code>cmdSave::Click
THISFORM.SetAll("Enabled",.F.,"EditBox")
THISFORM.SetAll("Enabled",.T.,"CommandButton")
cmdCancel::Click
THISFORM.SetAll("Enabled",.F.,"EditBox")
THISFORM.SetAll("Enabled",.T.,"CommandButton")
</code></pre>
<h3>Don't Edit the GroupID...</h3>
<p>
We didn't want users to edit the GroupID, although they can change the description. The technique we used to accomplish this is clean and simple. Here's the When event code for the GroupID:</p>
<pre><code>&nbsp;&nbsp;&nbsp;RETURN THISFORM.Adding
</code></pre>
<p>
which means that if the user is adding a new group, he or she can get into the field, because THISFORM.Adding contains the value .T.. But if the user is editing, the field is effectively disabled, because the statement would return a .F..</p>
<p>
The GroupID VALID clause has to do several things: It avoids duplication of GroupIDs; and it ensures that a GroupID is not entered that's already in use as a UserID, since at the time they're used, GroupIDs and UserIDs are indistinguishable. Returning to the original record location after a SEEK is imperative.</p>
<pre><code>LOCAL SaveRecord
SaveRecord = recno("Groups")
=SEEK (THIS.Value,"Groups","ById")
DO CASE
 &nbsp; CASE FOUND("Groups") AND RECNO("Grops") &lt;&gt; SaveRecord
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =MessageBox("This ID is not Unique",0,"ERROR")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT Groups
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO (SaveRecord)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN .F.
 &nbsp; CASE FOUND()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SKIP
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF NOT EOF() AND Groups.ID = THIS.Value&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =MessageBox("This ID is not Unique",0,"ERROR")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT Groups
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO (SaveRecord) 
 &nbsp; <b> &nbsp; </b> &nbsp; RETURN .F.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF&nbsp;&nbsp; 
ENDCASE
SELECT Groups
GO (SaveRecord)&nbsp;&nbsp; 
=SEEK(THIS.Value,"Users","ById")
IF FOUND("Users")
 &nbsp; =MessageBox("This ID is used for a User",0,"ERROR")
 &nbsp; SELECT Groups
 &nbsp; GO (SaveRecord)&nbsp; 
 &nbsp; RETURN .F.
ENDIF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</code></pre>
<p>
Adding a new member to a group is accomplished using the following code:</p>
<pre><code>&nbsp;&nbsp;&nbsp;DO FORM AddMemb
 &nbsp; SELECT Groups
 &nbsp; THISFORM.Refresh
</code></pre>
<p>
Form AddMemb is shown in Figure 10. However, when it runs, only the Save and Cancel buttons are visible: the rest have their Select property set to .F., so StandardScreen's ShowButton method hides them.</p>
<p>
<img src="security_10.gif" border=0></p>
<p class=label>
<b>Figure 10</b></p>
<p>
This form has three event code segments:</p>
<p>
<b>Init</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;StandardScreen::Init
 &nbsp; THIS.ShowButton
 &nbsp; THIS.Caption = "Add members to "+UPPER(ALLT(Groups.Name))
</code></pre>
<p>
<b>Activate</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;StandardScreen::Activate
 &nbsp; THIS.Setall("Enabled",.T.,"cmdSave")
 &nbsp; THIS.SetAll("Enabled",.T.,"cmdCancel")
</code></pre>
<p>
<b>cmdSave:click</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;WITH THISFORM.List1
 &nbsp; LOCAL I
 &nbsp; I=1
 &nbsp; FOR I=1 TO .ListCount
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF NOT .Selected(I)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF SEEK (.List(i,1)+Groups.ID,"Usr2Grp","ByUser")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT Usr2Grp
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; APPEND BLANK
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REPLACE UserID WITH .List(i,1), ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GroupID WITH GRoups.ID
 &nbsp; ENDFOR
 &nbsp; ENDWITH
 &nbsp; SELECT usr2Grp
 &nbsp; IF NOT EOF() AND NOT BOF()
 &nbsp;&nbsp;&nbsp;&nbsp; GO RECNO()
 &nbsp; ENDIF&nbsp;&nbsp; 
 &nbsp; THISFORM.Release
</code></pre>
<p>
This code uses the WITH statement, which allows you to abbreviate THISFORM.List1.Selected(I) to .Selected(I).</p>
<p>
If the last few lines of code above look wrong, allow me to explain. For some time, we've noticed that SET RELATIONs can do strange things. If you SELECT a child file and move around, then return to the parent and can't get your grid to refresh, try this little trick. It works in both Visual FoxPro version 2.6 and version 3.0. We don't know why.</p>
<p>
Deleting a member also requires refreshing the form:</p>
<pre><code>&nbsp;&nbsp;&nbsp;IF MessageBox(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
 &nbsp;&nbsp;&nbsp;&nbsp; "Delete " + ALLTRIM(Users.Name) + "?",&nbsp;&nbsp;&nbsp; ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 + 32 + 256 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "NOTE: Cannot undo!") = 6
 &nbsp; SELECT Usr2Grp
 &nbsp; DELETE
 &nbsp; GO TOP
 &nbsp; ENDIF
 &nbsp; THISFORM.Refresh
</code></pre>
<p>
The first parameter in MessageBox is a text string to be displayed in the box. Here we build a question asking the user to confirm the name of the user to be deleted. </p>
<p>
The second consists of the sum of three values: 
<ul type=disc>
<li>
Which set of buttons to use<br><br></li>
<li>
Which icon to display<br><br></li>
<li>
Which button to default to</li>
</ul>
<p>
The "6" to the right of the equal sign means "Yes". The numeric values and their meanings can be found under MessageBox Help, or in \VFP\FOXPRO.H. So this says: "If they answer 'yes' to the question in the message box, delete the record."</p>
<p>
So far, this system is a straightforward mechanism for adding records from one file to another. Assigning rights is slightly more complicated, but not much.</p>
<h3>Assigning Rights to Groups and/or Users</h3>
<p>
Rights are assigned to users with the Rights screen, shown in Figure 11.</p>
<p>
<img src="security_11.gif" border=0></p>
<p class=label>
<b>Figure 11</b></p>
<p>
When this screen is first opened, no user or group is selected. After you select a user or group, a grid appears with the rights that have been assigned, based on (1) group membership and (2) individual rights assignment, as seen in Figure 12. Notice that some check boxes on each line are shaded. These options are unavailable because on the Protected Items screen shown previously in Figure 3, they weren't selected as relevant to the type of option. For example, granting WRITE privileges to a menu doesn't make sense, so you can't select it here.</p>
<p>
<img src="security_12.gif" border=0></p>
<p class=label>
<b>Figure 12</b></p>
<p>
This is where you determine what the user or group can do. In Figure 12, above, we're setting the rights for Manager group members. Check those that you want to permit; leave the ones blank that aren't granted. That's all there is to it!</p>
<h3>Guarding the Guards</h3>
<p>
The first thing you want to ensure is that users log in and log out. After all, what good does it do to restrict access rights if users can easily use another user's password? So we've added a few menu features to make the system a little tighter.</p>
<p>
Figure 13 shows the menu that controls our security system. You'll want to add a Log In and Log Out to your menu, and it's very easy.</p>
<p>
<img src="security_13.gif" border=0></p>
<p class=label>
<b>Figure 13</b></p>
<p>
First, click the Options button to the right of the Log In option; then, check the Skip For check box; finally, fill in the Skip For condition with "not empty (pUserID)". The result is shown in Figure 14.</p>
<p>
<img src="security_14.gif" border=0></p>
<p class=label>
<b>Figure 14</b></p>
<p>
Now, users can't do anything except log in when the variable <i>pUserID</i> is empty. Do the same with all of the entries on your application's menu, and all the user can do, when no one is logged in, is log in or exit.</p>
<p>
Our security system menu does something similar. Because only supervisors can change assignment of rights, all of the pads on the Security menu popup are disabled unless a supervisor is logged in. <i>pSupervisor</i> is a global memory variable assigned at login time from a value in the USERS table.</p>
<h3>Adding Users and Assigning Them to Groups</h3>
<p>
The Users screen shown in Figure 15 is used to add users and assign them to groups.</p>
<p>
<img src="security_15.gif" border=0></p>
<p class=label>
<b>Figure 15</b></p>
<p>
While being added, a new user can be designated as a supervisor. This gives him or her the right to enter and make changes in the security system. In order to ensure that the password is entered correctly, it must be entered twice, and both entries must match. This simple but useful technique is seen often in Microsoft products like Windows NT™ and Microsoft Mail.</p>
<p>
Assigning users to groups is done in the second page of the page frame, as seen in Figure 16. Users can belong to several groups, and inherit all of the rights granted by each group to which they belong.</p>
<p>
<img src="security_16.gif" border=0></p>
<p class=label>
<b>Figure 16</b></p>
<p>
This is the most complex screen in this application. It has a two-column "mover" picklist, complex validations, and uses several interesting new types of Visual FoxPro syntax. So let's get started.</p>
<h3>Screen Elements</h3>
<p>
The Form Designer view of the Rights screen appears in Figure 17. </p>
<p>
<img src="security_17.gif" border=0></p>
<p class=label>
<b>Figure 17</b></p>
<p>
The first five fields on page 1 of the page frame are based on our InputField class, which is stored in MYLIB:</p>
<pre><code>**************************************************
*-- Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputfield (classes\mylib.vcx)
*-- ParentClass:&nbsp; textbox
*-- BaseClass:&nbsp;&nbsp;&nbsp; textbox
DEFINE CLASS inputfield AS textbox
 &nbsp; FontBold = .T.
 &nbsp; FontName = "Courier New"
 &nbsp; FontSize =&nbsp; 8
 &nbsp; Enabled&nbsp;&nbsp;&nbsp; = .F.
 &nbsp; Format&nbsp;&nbsp;&nbsp; = ""
 &nbsp; Height&nbsp;&nbsp;&nbsp; = 23
 &nbsp; Width&nbsp;&nbsp;&nbsp; = 113
 &nbsp; Name&nbsp;&nbsp;&nbsp; = "inputfield"

 &nbsp; PROCEDURE GotFocus
 &nbsp;&nbsp;&nbsp;&nbsp; THIS.ForeColor=RGB ( 255, 255, 255 )
 &nbsp;&nbsp;&nbsp;&nbsp; THIS.BackColor=RGB ( 255,&nbsp;&nbsp; 0,&nbsp;&nbsp; 0 )
 &nbsp; ENDPROC
 &nbsp; PROCEDURE LostFocus
 &nbsp;&nbsp;&nbsp;&nbsp; THIS.ForeColor=RGB (&nbsp;&nbsp; 0,&nbsp;&nbsp; 0,&nbsp;&nbsp; 0 )
 &nbsp;&nbsp;&nbsp;&nbsp; THIS.BackColor=RGB ( 255, 255, 255 )
 &nbsp; ENDPROC
ENDDEFINE
*-- EndDefine: inputfield
**************************************************
</code></pre>
<p>
Objects based on this class are initially disabled, use a small boldfaced Courier New font, and change their color from black on white to white on red when they have the focus.</p>
<h3>Command Button Code</h3>
<p>
All of the command buttons in StandardScreen are used in this form. However, four of them have modifications to their Click event code:</p>
<p>
<b>cmdAdd</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;cmdAdd::Click
 &nbsp; THISFORM.PageFrame1.Page1.SetAll("Enabled",.T.,"EditBox")
 &nbsp; THISFORM.PageFrame1.Page1.SetAll("Enabled",.T.,"CheckBox")
 &nbsp; THISFORM.PageFrame1.Page2.SetAll("Enabled",.T.,"ListBox")
 &nbsp; THISFORM.PageFrame1.ActivePage = 1
</code></pre>
<p>
<b>cmdEdit</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;cmdEdit::Click
 &nbsp; THISFORM.PageFrame1.Page1.SetAll("Enabled",.T.,"EditBox")
 &nbsp; THISFORM.PageFrame1.Page1.SetAll("Enabled",.T.,"CheckBox")
 &nbsp; THISFORM.PageFrame1.Page2.SetAll("Enabled",.T.,"ListBox")
</code></pre>
<p>
<b>cmdSave</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;THISFORM.SavingNow = .T.
 &nbsp; cmdSave::Click
 &nbsp; *-------------------------
 &nbsp; * Save Groups assignment
 &nbsp; *-------------------------
 &nbsp; SELE Usr2Grp
 &nbsp; DELETE ALL FOR UserID = MyUser.UserID

 &nbsp; WITH THISFORM.PageFrame1.Page2.List2
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOCAL i
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FOR i=1 TO .ListCount
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; APPEND&nbsp; BLANK
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REPLACE UserId&nbsp; WITH MyUser.UserID,;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GroupID WITH .List(i,2)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDFOR
 &nbsp; ENDWITH&nbsp;&nbsp; 
 &nbsp; THISFORM.PageFrame1.Page1.SetAll("Enabled",.F.,"EditBox")
 &nbsp; THISFORM.PageFrame1.Page1.SetAll("Enabled",.F.,"CheckBox")
 &nbsp; THISFORM.PageFrame1.Page2.SetAll("Enabled",.F.,"ListBox")
 &nbsp; THISFORM.SavingNow = .F.
</code></pre>
<p>
<b>cmdCancel</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;cmdCancel::Click
 &nbsp; THISFORM.PageFrame1.Page1.SetAll("Enabled",.F.,"EditBox")
 &nbsp; THISFORM.PageFrame1.Page1.SetAll("Enabled",.F.,"CheckBox")
 &nbsp; THISFORM.PageFrame1.Page2.SetAll("Enabled",.F.,"ListBox")
</code></pre>
<h3>Input Field Event Code</h3>
<p>
Several of the input fields have event code to ensure correct and complete data, as follows.</p>
<p>
<b>Unique ID (infUserID) WHEN code</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;RETURN THISFORM.Adding
</code></pre>
<p>
<b>Unique ID (infUserID) VALID code</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;IF EMPTY(THIS.Value)
 &nbsp;&nbsp;&nbsp;&nbsp; =MessageBox("ID cannot be empty",0,"ERROR")
 &nbsp;&nbsp;&nbsp;&nbsp; RETURN .F.
 &nbsp; ENDIF
 &nbsp; =SEEK(THIS.Value,"Users1","ById")
 &nbsp; DO CASE
 &nbsp; CASE FOUND("Users1") ;
 &nbsp;&nbsp; and RECNO("Users1") &lt;&gt; RECNO("USERS") 
 &nbsp;&nbsp;&nbsp;&nbsp; =MessageBox("This ID is not unique",0,"ERROR")
 &nbsp;&nbsp;&nbsp;&nbsp; RETURN .F.
 &nbsp; CASE FOUND("Users1")
 &nbsp;&nbsp;&nbsp;&nbsp; SKIP IN Users1
 &nbsp;&nbsp;&nbsp;&nbsp; IF NOT EOF("Users1") ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND Users1.UserID == THIS.Value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =MessageBox("This ID is not unique",0,"ERROR")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN .F.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF&nbsp;&nbsp; 
 &nbsp; ENDCASE
 &nbsp; *---------------------------------------------
 &nbsp; * Rights are common for users and groups,
 &nbsp; * So, ID should be unique through both files
 &nbsp; *---------------------------------------------
 &nbsp; =SEEK(THIS.Value,"Groups","ById")
 &nbsp; IF FOUND()
 &nbsp;&nbsp;&nbsp;&nbsp; =MessageBox("This ID is used for a Group",0,"ERROR")
 &nbsp;&nbsp;&nbsp;&nbsp; RETURN .F.
 &nbsp; ENDIF   
</code></pre>
<p>
<b>Password (infUserPassw) VALID code</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;RETURN NOT EMPTY(THIS.Value)
</code></pre>
<p>
<b>Verify password (infVerifyPW) VALID code</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;LOCAL TorF
 &nbsp; TorF = IIF(THIS.Value==THIS.Parent.infUserPassW.Value,;
 &nbsp;&nbsp;&nbsp;&nbsp; .T., .F. )
 &nbsp; THIS.Value = SPACE(LEN(Users.PassWord))
 &nbsp; RETURN TorF
</code></pre>
<h3>Event Code for Page 2 Objects</h3>
<p>
<b>Page 2 ACTIVATE code</b>:</p>
<pre><code>IF EMPTY(ALIAS())
 &nbsp; SELECT Myuser
ENDIF&nbsp;&nbsp; 
REPLACE MyUser.UserID WITH Users.UserID
THIS.List2.Requery
</code></pre>
<p>
<b>Page 2 List1 RightClick code</b>:</p>
<pre><code>SELECT DIST Users.Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
 &nbsp;&nbsp; FROM Users,Usr2Grp, MyUser&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
 &nbsp; WHERE Users.UserID&nbsp;&nbsp;&nbsp; = Usr2Grp.UserID&nbsp;&nbsp; ;
 &nbsp;&nbsp;&nbsp; AND Usr2Grp.GroupID = THIS.Value&nbsp;&nbsp;&nbsp; ;
 &nbsp;&nbsp;&nbsp; AND Users.UserID &lt;&gt; MyUser.UserID&nbsp;&nbsp;&nbsp; ;
 &nbsp;&nbsp; INTO ARRAY aInGroup
 &nbsp;&nbsp;&nbsp;&nbsp; 
WITH THIS.Parent.List2
 &nbsp; LOCAL I
 &nbsp; FOR I=1 TO .ListCount
 &nbsp;&nbsp;&nbsp;&nbsp; IF .List(i,2) == THIS.Value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIT
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp; ENDFOR
 &nbsp; IF I &lt;= .ListCount
 &nbsp;&nbsp;&nbsp;&nbsp; IF _tally = 0
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIME aInGroup(1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aInGroup(1) = Users.Name
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIME aInGroup(ALEN(aInGroup)+1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aInGroup(ALEN(aInGroup)) = Users.Name
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =ASORT(aIngroup)
 &nbsp;&nbsp;&nbsp;&nbsp; ENDIF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; ENDIF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
ENDWITH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
IF TYPE('aInGroup') = "U"
 &nbsp; =MessageBox (
 &nbsp;&nbsp; "Nobody is assigned to " + THIS.List(THIS.ListIndex,1),;
 &nbsp;&nbsp; 0, ;
 &nbsp;&nbsp; "Information" )
 &nbsp; RETURN
ENDIF&nbsp;&nbsp; 
LOCAL lMessage,i
lMessage = aInGroup(1)
FOR i=2 TO ALEN("aInGroup")
 &nbsp;&nbsp; lMessage = lMessage + CHR(13) + ALLT(aInGroup(i))
ENDFOR
=MessageBox (&nbsp;&nbsp;&nbsp; ;
 &nbsp; lMessage,&nbsp;&nbsp; ;
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
 &nbsp; " assigned to " + THIS.List(THIS.ListIndex,1) )
</code></pre>
<p>
<b>Page 2 List1 DoubleClick code</b>:</p>
<pre><code>LOCAL i
WITH THIS.Parent.List2
 &nbsp;&nbsp;&nbsp; FOR I=1 TO .ListCount
 &nbsp;&nbsp;&nbsp; IF .List(i,2) = THIS.Value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIT
 &nbsp;&nbsp;&nbsp; ENDIF&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp; ENDFOR
 &nbsp;&nbsp;&nbsp; IF i &gt; .ListCount
 &nbsp;&nbsp; .AddItem (THIS.List(THIS.ListIndex))
 &nbsp;&nbsp; .AddListitem(THIS.Value,.ListCount,2)
 &nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp; .Refresh
ENDWITH&nbsp;&nbsp; 
</code></pre>
<p>
<b>Page 2 List2 DoubleClick code</b>:</p>
<pre><code>THIS.RemoveItem(THIS.ListIndex)
THIS.Refresh
</code></pre>
<p>
The two-column mover is one of the more useful tools you can build, and it's particularly easy in Visual FoxPro. In fact, this is a relatively complicated version. In the simplest case, all you need to do is to construct two list boxes on a form, making sure that both have RowSourceType = 0 (None) or 1 (Value). If RowSourceType is 0, you leave RowSource empty and use the AddListItem method to build the contents of the list; if RowSourceType = 1, you simply enter a comma-delimited list of entries into RowSource. Then, your only code is the following:</p>
<p>
<b>List1 DoubleClick code</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THISFORM.List2.AddListItem(THIS.Value)
 &nbsp;&nbsp;&nbsp; THIS.RemoveItem(THIS.ListIndex)
 &nbsp;&nbsp;&nbsp; THISFORM.Refresh
</code></pre>
<p>
<b>List2 DoubleClick code</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THISFORM.List1.AddListItem(THIS.Value)
 &nbsp;&nbsp;&nbsp; THIS.RemoveItem(THIS.ListIndex)
 &nbsp;&nbsp;&nbsp; THISFORM.Refresh
</code></pre>
<p>
You can then post-process the selected items as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;FOR I = 1 TO THISFORM.LIST2.ListCount
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = THISFORM.List2.Item(I)
 &nbsp;&nbsp;&nbsp;&nbsp; * Do what you want with x...
 &nbsp; ENDFOR
</code></pre>
<p>
However, if you use any other RowSourceType, for example, an array (RowSourceType=5), you have to rebuild the array and redisplay the object each time it changes. So we use the form REFRESH code to do so.</p>
<h3>Form Event Code</h3>
<p>
There are five form events that have code:</p>
<p>
<b>FORM LOAD event code</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CREATE CURSOR MyUser (UserId C(4))
 &nbsp; APPEND BLANK
* This cursor holds all of the entries that this user has on file
</code></pre>
<p>
<b>FORM INIT event code</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;StandardScreen::Init
 &nbsp; THISFORM.ButtonsOn
 &nbsp; THISFORM.TestBofEof
</code></pre>
<p>
<b>FORM ACTIVATE event code</b>:</p>
<pre><code>* Ensure that the USERS table is selected when this form is up 
 &nbsp;&nbsp;&nbsp; SELECT USERS
</code></pre>
<p>
<b>FORM REFRESH event code</b>:</p>
<pre><code>* All we do here is ensure that the table matches the screen
 &nbsp; THIS.Caption = "Users - " + ALLT(Users.Name) ;
 &nbsp; + " (" + ALLT(Users.UserID) + ")"
 &nbsp; IF EMPTY(ALIAS())
 &nbsp;&nbsp;&nbsp;&nbsp; SELECT MyUser
 &nbsp; ENDIF   
 &nbsp; REPLACE MyUser.UserID WITH Users.UserID
 &nbsp; IF NOT THISFORM.SavingNow
 &nbsp;&nbsp;&nbsp;&nbsp; SELECT groups.name, usr2grp.groupid;
 &nbsp;&nbsp;&nbsp;&nbsp; FROM Usr2Grp,Groups ,MyUser;
 &nbsp;&nbsp;&nbsp;&nbsp; WHERE&nbsp; usr2grp.UserId&nbsp; ==&nbsp; MyUser.UserID AND;
 &nbsp;&nbsp;&nbsp;&nbsp; Usr2Grp.GroupID == Groups.ID INTO CURSOR X
 &nbsp;&nbsp;&nbsp; WITH THISFORM.PageFrame1.Page2.List2
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Clear
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCAN&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .AddItem(Name)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .AddListItem(GroupId,.ListCount,2)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDSCAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp; ENDWITH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; USE IN X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; ENDIF
</code></pre>
<p>
<b>FORM UNLOAD event code</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;IF USED ('MyUser')
 &nbsp;&nbsp;&nbsp;&nbsp; USE IN MyUser
 &nbsp; ENDIF&nbsp;&nbsp; 
 &nbsp; IF USED ('X')
 &nbsp;&nbsp;&nbsp; USE IN X
 &nbsp; ENDIF
</code></pre>
<h2>Using the Security System</h2>
<p>
To start using the security system, log in as SUP, password SUP, as shown in Figure 18. Only supervisors can have access to the system.</p>
<p>
<img src="security_18.gif" border=0></p>
<p class=label>
<b>Figure 18</b></p>
<p>
Next, add any rights that you want controlled in your screens, as seen in Figure 19:</p>
<p>
<img src="security_19.gif" border=0></p>
<p class=label>
<b>Figure 19</b></p>
<p>
Afterwards, add the users in your system (Figure 20):</p>
<p>
<img src="security_20.gif" border=0></p>
<p class=label>
<b>Figure 20</b></p>
<p>
Then, create any groups that your user(s) might belong to, as shown in Figure 21. You can add users to groups at this point:</p>
<p>
<img src="security_21.gif" border=0></p>
<p class=label>
<b>Figure 21</b></p>
<p>
Finally, go to the Rights screen shown in Figure 22 and determine who can do what. Of course, this can be changed at any time.</p>
<p>
<img src="security_22.gif" border=0></p>
<p class=label>
<b>Figure 22</b></p>
<h3>Programming for Access Control</h3>
<p>
The INIT section of each screen is where most of the security system is implemented. Here, for example, is the Init code form TEST.SCX:</p>
<pre><code>StandardScreen::Init &amp;&amp; call the Init code in StandardScreen

THISFORM.ShowButton&nbsp; &amp;&amp; turn off buttons that have property
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; &nbsp;&nbsp; "select" = .F.
</code></pre>
<p>
These are usually the first two commands in the Init section of each form. The next few lines simply assign values to the on-screen fields, so that you can see how they work. Usually, fields are bound to some control source:</p>
<pre><code>THISFORM.InputField1.Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = "USER"
THISFORM.FinancialField2.Value = "5,345.00"
THISFORM.FinancialField3.Value = "10,324.45"
THISFORM.FinancialField4.Value = "-2,349.20"
THISFORM.Ratings5.Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = "High"
</code></pre>
<p>
Next, we call the FinancialFields method found in the StandardScreen template class. This is an example of a method that's included in the template class to provide standard functionality. If there are lots of places where sensitive information should be displayed only to users who have access to it, you simply tell your programmers to (1) use class FinancialField for all sensitive data; and (2) call this method in the Init event of each screen that contains the FinancialField class, like this:</p>
<pre><code>&nbsp;&nbsp;&nbsp;THISFORM.FinancialFields
</code></pre>
<p>
You can only call this method if the form contains fields that are instantiated from the FinancialField class in MYLIB.VCX. Otherwise, an error results.</p>
<h3>Read-Only Fields Based on Access Rights</h3>
<p>
Another type of functionality is "read-only" access to certain fields. I've created a new class called Ratings, which is based on InputField. Its Enabled property is set to .T., in our test screen, but it's otherwise unchanged. </p>
<p>
To create a read-only object, add the following <i>Init</i> code to any screen that contains an object instantiated from the Ratings class:</p>
<pre><code>IF NOT Granted ( "RATINGS", "READ"&nbsp; )
 &nbsp; THISFORM.SetAll ( "Visible", .F.,&nbsp; "Ratings"&nbsp; )
ENDIF
IF NOT Granted ( "RATINGS", "WRITE" )
 &nbsp; THISFORM.SetAll ( "Readonly", .T.,&nbsp; "Ratings"&nbsp; )
ENDIF
</code></pre>
<p>
If, on the user's Ratings entry in the Rights screen, READ is checked but WRITE isn't, the user can see the data but can't change it.</p>
<p>
To test this, you have to log in as SUP/SUP, then go to the Rights screen and pick user TEST/TEST. Check or uncheck the READ and WRITE column entries for Ratings and exit the screen. Now, log out and log back in as TEST/TEST, then activate the Test screen. Each time you want to test a new combination, you'll have to log back in as SUP/SUP to make the changes, then log out and log in as TEST/TEST to see their effect.</p>
<h3>Controlling Menus</h3>
<p>
If you want a user's access to a menu option to be restricted based on his or her rights, you could simply include a skip for condition that calls the GRANTED function. But, since menu evaluation is almost continuous, it might be preferable to include a public variable HasAccess, and set it at login time. That way, the menu system won't slow your application down unnecessarily.</p>
<p>
We believe that you can do just about anything you can think of using this approach to security. It's powerful, yet fast and simple to use. Next time your client asks for password protection, surprise them with this.</p>
</BODY>
</HTML>
