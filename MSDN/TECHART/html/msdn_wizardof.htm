<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Wizards in Microsoft Office 97</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_wizardof"></a>Creating Wizards in Microsoft Office 97</h1>
<p>
Microsoft Corporation</p>
<p>
March 7, 1997</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5147">
</OBJECT><a href="javascript:sample1.Click()">Click to copy the files in the WIZARD sample application for this technical article.</a></p>
<h2>Table of Contents</h2>
<p>
<a href="#wizardof_intro">Introduction</a></p>
<p>
<a href="#wizardof_interface">The Wizard Interface</a></p>
<p>
<a href="#wizardof_assist">Using the Office Assistant with a Wizard</a></p>
<p>
<a href="#wizardof_temp">Wizard Templates and Add-ins</a></p>
<p>
<a href="#wizardof_where">Where Do You Go from Here?</a></p>
<h2><a name="wizardof_intro"></a>Introduction</h2>
<p>
A wizard is a macro (or set of macros) that presents a series of steps for a user to complete. A wizard includes one or more custom dialog boxes (referred to as forms in this article), that contain a variety of controls for getting information from the user. After the user has completed the steps in the wizard, the wizard creates a document or carries out a task based on the information provided by the user. If you aren’t familiar with wizards, take a moment to run the wizards included with Microsoft® Word and Microsoft Excel. To locate Wizards in Word, click <b>New</b> on the <b>File</b> menu. Wizards can be found, along with templates, on each of the tabs in the <b>New</b> dialog box. A list of Wizards available with Microsoft Excel can be found by clicking on the <b>Tools</b> menu and pointing to <b>Wizard</b>. A wizard has essentially two parts: the user interface that requests information from the user, and the behind-the-scenes part that carries out the actions necessary to accomplish the task. The behind-the-scenes part varies according to what the wizard is designed to accomplish; every wizard is different in that respect. However, most of the wizards included with the Microsoft Office applications share a basic user interface. This article describes how to create this user interface for your custom wizards.</p>
<p>
WizForm.frm, which accompanies this article, includes the controls and the corresponding subroutines used to create the basic wizard user interface. WizForm.frm provides a useful starting point for creating a wizard. Wizard.bas, which also accompanies this article, contains all the code that you need to run the wizard that is not contained in the form.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Microsoft Excel, Word, and Microsoft PowerPoint® share the same tools for creating custom dialog boxes. For information about designing forms in Microsoft Access, see "Building Applications with Microsoft Access&nbsp;97" (MSDN Library, Microsoft Office Development).</p>
<p>
In this article, the first letter of variable names indicates the variable type. For example, “o” indicates the variable type is an object, “l” indicates a long, “b” indicates a Boolean, “i” indicates an integer, and “str” indicates a string.</p>
<h2><a name="wizardof_interface"></a>The Wizard Interface</h2>
<p>
The basic interface shared by most Office wizards is shown in Figure 1. The empty area to the right of the flow chart is a MultiPage control with no tabs. The controls that are unique to each wizard are placed on the pages of this MultiPage control.</p>
<p>
<img src="wizard01.gif" border=0></p>
<p class=label>
<b>Figure 1. The basic Office Wizard interface</b></p>
<p>
A wizard is comprised of a series of steps. The user navigates through the steps using the command buttons at the bottom of the form or the flow chart navigation image. When the user clicks the <b>Finish</b> button, the wizard uses the information from the wizard steps to perform a task. For example, the Memo Wizard included with Word 97 prompts the user for information and then creates a memo based on the user’s responses.</p>
<h3>Step 1. Designing the Form</h3>
<p>
The first step in creating a wizard is to design your wizard on paper. Decide what information you need to gather and what controls are most appropriate. Sketch out the contents of each step in the wizard. After the design is complete, you’re ready to create the user form. This article discusses how to create the user form shown in Figure 1.</p>
<h3>Step 2. Creating the Form</h3>
<p>
The next step in creating a wizard is to create the user form. The user form includes all of the controls that are used to gather information from the user. In addition to defining the basic interface of the wizard, the form includes the majority of the wizard code. This is because much of the wizard code executes in response to a user clicking on a control on the user form. The user form shown in the preceding illustration (WizForm.frm) includes the controls in Table 1</p>
<p class=label>
<b>Table 1. Controls Included with Wizform.frm. </b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=40%><b>Name</b></td>
<td class=label width=27%><b>Control type</b></td>
<td class=label width=33%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=40%>imgFlowChartBackground</td>
<td width=27%>Image</td>
<td width=33%>The black box behind the flow chart</td>
</tr>
<tr valign=top>
<td width=40%>tglAssistant</td>
<td width=27%>ToggleButton</td>
<td width=33%><b>Help</b> button</td>
</tr>
<tr valign=top>
<td width=40%>cmdBack</td>
<td width=27%>CommandButton</td>
<td width=33%><b>Back</b> button</td>
</tr>
<tr valign=top>
<td width=40%>cmdCancel</td>
<td width=27%>CommandButton</td>
<td width=33%><b>Cancel</b> button</td>
</tr>
<tr valign=top>
<td width=40%>cmdFinish</td>
<td width=27%>CommandButton</td>
<td width=33%><b>Finish</b> button</td>
</tr>
<tr valign=top>
<td width=40%>cmdNext</td>
<td width=27%>CommandButton</td>
<td width=33%><b>Next</b> button</td>
</tr>
<tr valign=top>
<td width=40%>lblMap0</td>
<td width=27%>Label</td>
<td width=33%>Start label</td>
</tr>
<tr valign=top>
<td width=40%>lblMap1</td>
<td width=27%>Label</td>
<td width=33%>Step 2 label</td>
</tr>
<tr valign=top>
<td width=40%>lblMap2</td>
<td width=27%>Label</td>
<td width=33%>Step 3 label</td>
</tr>
<tr valign=top>
<td width=40%>lblMap3</td>
<td width=27%>Label</td>
<td width=33%>Step 4 label</td>
</tr>
<tr valign=top>
<td width=40%>lblMap4</td>
<td width=27%>Label</td>
<td width=33%>Finish label</td>
</tr>
<tr valign=top>
<td width=40%>shpChartPathCV</td>
<td width=27%>Label</td>
<td width=33%>Line that connects the squares in the flow chart (an empty label with a border style)</td>
</tr>
<tr valign=top>
<td width=40%>shpMap0</td>
<td width=27%>Label</td>
<td width=33%>Green box in flow chart</td>
</tr>
<tr valign=top>
<td width=40%>shpMap1</td>
<td width=27%>Label</td>
<td width=33%>Gray box in flow chart (this box is green when active)</td>
</tr>
<tr valign=top>
<td width=40%>shpMap2</td>
<td width=27%>Label</td>
<td width=33%>Gray box in flow chart (this box is green when active)</td>
</tr>
<tr valign=top>
<td width=40%>shpMap3</td>
<td width=27%>Label</td>
<td width=33%>Gray box in flow chart (this box is green when active)</td>
</tr>
<tr valign=top>
<td width=40%>shpMap4</td>
<td width=27%>Label</td>
<td width=33%>Red box in flow chart (this box is green when active)</td>
</tr>
<tr valign=top>
<td width=40%>MpgWizardPage</td>
<td width=27%>MultiPage</td>
<td width=33%>Multiple page control with five pages that correspond to the steps in the wizard</td>
</tr>
</table><br>
<p>
Instead of adding these controls one by one to a new user form, you can simply import WizForm.frm.</p>
<h4>To import WizForm.frm</h4>
<ol>
<li>
Create a new Microsoft Excel workbook, Microsoft PowerPoint presentation, or Word template.<br><br></li>
<li>
Switch to the Microsoft Visual Basic® Editor.<br><br></li>
<li>
Select the project associated with the new file.<br><br></li>
<li>
On the <b>File</b> menu, click <b>Import</b> <b>File</b>. Select WizForm.frm and click the <b>Open</b> button.</li>
</ol>
<p>
These steps add the WizForm form to your new project. All of the controls and the corresponding subroutines are copied to your project. To learn how the wizard works, you can remove the subroutines behind the controls and add the subroutines back one by one as described in the remaining steps of this article.</p>
<h4>To remove the existing code in WizForm.frm</h4>
<ol>
<li>
Select WizForm in the <b>Project Explorer</b>.<br><br></li>
<li>
Click <b>Code</b> on the <b>View</b> menu.<br><br></li>
<li>
Click <b>Select All</b> on the <b>Edit</b> menu.<br><br></li>
<li>
Click <b>Cut</b> on the <b>Edit</b> menu.</li>
</ol>
<h3>Step 3. Displaying and Closing the Form</h3>
<p>
The code to display WizForm should be stored in a standard code module. If you want to import a standard module that contains all the code not contained in the form that you need to run the wizard, click <b>Import</b> <b>File</b> on the <b>File</b> menu. Select Wizard.bas and click the <b>Open</b> button.</p>
<p>
If you want to go through the steps of creating your own standard code module and inserting code from this document into it, select your project name in the <b>Project Explorer</b> and click <b>Module</b> from the <b>Insert</b> menu. Create the following subroutine, which uses the <b>Show</b> method to display WizForm:</p>
<pre><code>Public iCurrentPage As Integer

Public Sub InitWizard()
 &nbsp;&nbsp; iCurrentPage = 0
 &nbsp;&nbsp; With WizForm
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .MpgWizardPage.Value = 0
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Show
 &nbsp;&nbsp; End With
End Sub
</code></pre>
<p>
The additional instructions set the MpgWizardPage control to 0 (zero), which is the first page in the group of pages. For more information on the MultiPage control named MpgWizardPage, see “Step 4. Making the Next and Back Buttons Work.”</p>
<p>
Now add the code to close the form. Double-click the <b>Cancel</b> button in the form. Complete the cmdCancel_Click procedure, as shown in the following example. The <b>Unload</b> method is used to close WizForm:</p>
<pre><code>Private Sub cmdCancel_Click()
 &nbsp;&nbsp; Unload WizForm
End Sub
</code></pre>
<p>
Switch back to the wizard form and double-click the <b>Finish</b> button. Complete the cmdFinish_Click procedure, as shown in the following example:</p>
<pre><code>Private Sub cmdFinish_Click()
 &nbsp;&nbsp; Unload WizForm
End Sub
</code></pre>
<p>
In addition to clicking the <b>Finish </b>or <b>Cancel </b>button, the user can click the <b>Close</b> button in the upper-right corner of the form or choose the <b>Close</b> command from the form’s <b>Control</b> menu. However, if the user closes the form in either of these ways, the code in the Click event procedure for the <b>Cancel</b> button does not run. You can use the QueryClose event, which occurs just before a user form closes, to call the Click event procedure for the <b>Cancel</b> button (<b>cmdCancel</b>) if the form is closed using <b>Close </b>(indicated if the value of the CloseMode argument of the QueryClose event is <b>vbFormControlMenu</b>). In the WizForm code module, add the following procedure:</p>
<pre><code>Private Sub WizForm_QueryClose(Cancel As Integer, CloseMode As Integer)
 &nbsp;&nbsp; If (CloseMode = vbFormControlMenu) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Call cmdCancel_Click
 &nbsp;&nbsp; End If
End Sub
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In the preceding code examples, you can use the keyword <b>Me</b> instead of the code name of the form (WizForm). That is, you can replace the statement "WizForm.Show" with the statement "Me.Show". The <b>Me</b> keyword used in code for a UserForm or a control on the UserForm represents the UserForm itself.</p>
<p>
Now it’s time to run the InitWizard macro. Switch to the code module that contains the InitWizard subroutine, position the insertion point in the subroutine, and click <b>Run Sub/UserForm</b> on the <b>Run</b> menu. The Sample Wizard form is displayed and can be closed by using the <b>Cancel </b>or <b>Finish </b>button, or by using the <b>Close</b> button or the <b>Close</b> command on the <b>Control</b> menu.</p>
<h3>Step 4. Making the Next and Back Buttons Work</h3>
<p>
The majority of the WizForm layout is taken up by a MultiPage control named MpgWizardPage. A MultiPage control contains a collection of one or more pages. Each page of a MultiPage control contains its own controls, and therefore can have a unique layout. Each of the pages is a <b>Page</b> object and together they represent the <b>Pages</b> collection of the MultiPage control. The MpgWizardPage control on WizForm includes five different <b>Page</b> objects with the controls noted in Table 2.</p>
<p class=label>
<b>Table 2. Controls for Each Page in Wizform</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=13%><b>Page</b></td>
<td class=label width=45%><b>Control</b></td>
<td class=label width=42%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=13%><b>Page1</b></td>
<td width=45%>lblEmail (Label control)</td>
<td width=42%>“What is your e-mail name?”</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>lblEmail1 (Label control)</td>
<td width=42%>“E-mail”</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>txtEmail (TextBox control)</td>
<td width=42%>Text box for e-mail</td>
</tr>
<tr valign=top>
<td width=13%><b>Page2</b></td>
<td width=45%>lblColor (Label control)</td>
<td width=42%>“Choose a color”</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>frmColors (Frame control)</td>
<td width=42%>Color frame around the option buttons</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>optBlue (OptionButton control)</td>
<td width=42%>Blue option button</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>optGreen (OptionButton control)</td>
<td width=42%>Green option button</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>optRed (OptionButton control)</td>
<td width=42%>Red option button</td>
</tr>
<tr valign=top>
<td width=13%><b>Page3</b></td>
<td width=45%>lblNameAddress (Label control)</td>
<td width=42%>“What is your name and mailing address?”</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>txtName (TextBox control)</td>
<td width=42%>Name text box</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>txtAddress (TextBox control)</td>
<td width=42%>Address text box</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>lblName (Label control)</td>
<td width=42%>“Name”</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>lblAddress (Label control)</td>
<td width=42%>“Address”</td>
</tr>
<tr valign=top>
<td width=13%><b>Page4</b></td>
<td width=45%>lblPersonal (Label control)</td>
<td width=42%>“Which personal items would you like to include?”</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>chkMarital (CheckBox control)</td>
<td width=42%>Marital status check box</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>chkNationality (CheckBox control)</td>
<td width=42%>Nationality check box</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>chkAge (CheckBox control)</td>
<td width=42%>Age check box</td>
</tr>
<tr valign=top>
<td width=13%></td>
<td width=45%>chkBirthPlace (CheckBox control)</td>
<td width=42%>Place of birth check box</td>
</tr>
<tr valign=top>
<td width=13%><b>Page5</b></td>
<td width=45%>lblDone (Label control)</td>
<td width=42%>“The sample wizard is done!”</td>
</tr>
</table><br>
<p>
When a user clicks the <b>Next </b>or <b>Back </b>button to move to the next or previous step in the wizard, the appropriate page in the MultiPage control is displayed. This is done by incrementing the <b>Value</b> property of the MultiPage control. The following example displays the next page in the MultiPage control, named MpgWizardPage:</p>
<pre><code>iCurrentPage = WizForm.MpgWizardPage.Value
WizForm.MpgWizardPage.Value = iCurrentPage + 1
</code></pre>
<p>
Double-click the <b>Back</b> button on the form. Complete the cmdBack_Click procedure, as follows:</p>
<pre><code>Private Sub cmdBack_Click()
 &nbsp;&nbsp; If iCurrentPage &lt;&gt; 0 Then WizForm.MpgWizardPage.Value = _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iCurrentPage - 1
End Sub
</code></pre>
<p>
The value of the first page in a MultiPage control is 0 (zero). The cmdBack_Click event procedure decreases the current page in the MultiPage control by 1 if the current page isn’t zero (0). Double-click the <b>Next</b> button in the form. Complete the cmdNext_Click procedure, as follows:</p>
<pre><code>Private Sub cmdNext_Click()
 &nbsp;&nbsp; If iCurrentPage &lt; 4 Then WizForm.MpgWizardPage.Value = _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iCurrentPage + 1
End Sub
</code></pre>
<p>
The MpgWizardPage control on WizForm has five pages: 0 (zero) through 4. The cmdNext_Click event procedure increases the current page in the MpgWizardPage control by 1 if the current page is less than four. The Change event occurs when the <b>Value</b> property of the MpgWizardPage control changes. Create an event procedure named MpgWizardPage_Change, as follows (this procedure runs when the user moves to a new page).</p>
<pre><code>Private Sub MpgWizardPage_Change()

End Sub
</code></pre>
<p>
If you ran the InitWizard subroutine at this point, the <b>Next</b> button would work only once. The iCurrentPage value is initially set to zero in the InitWizard subroutine. After the <b>Value </b>property of the MpgWizardPage control is changed in the <b>cmdNext_Click</b> event procedure, the iCurrentPage value remains 0 (zero). The iCurrentPage value needs to reflect the new page number. This can be done by modifying the MpgWizardPage_Change event procedure as follows:</p>
<pre><code>Private Sub MpgWizardPage_Change()
 &nbsp;&nbsp; With WizForm
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iCurrentPage = .MpgWizardPage.Value
 &nbsp;&nbsp; End With
End Sub
</code></pre>
<p>
Now, if you run the InitWizard subroutine, the <b>Next</b> button moves through the pages in the MultiPage control. However, the <b>Back </b>button remains disabled. Depending upon the current page, the <b>Next</b> and <b>Back </b>buttons are enabled or disabled. This is done using a <b>Select</b> <b>Case</b> structure that enables and disables buttons depending upon the current page (the value of iCurrentPage). Complete the MpgWizardPage_Change procedure, as follows:</p>
<pre><code>Private Sub MpgWizardPage_Change()
With WizForm
 &nbsp;&nbsp; iCurrentPage = .MpgWizardPage.Value
 &nbsp;&nbsp; Select Case iCurrentPage
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 0
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cmdBack.Enabled = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cmdNext.Enabled = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 1, 2, 3
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cmdBack.Enabled = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cmdNext.Enabled = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 4
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cmdBack.Enabled = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cmdNext.Enabled = False
 &nbsp;&nbsp; End Select
End With
End Sub
</code></pre>
<p>
Now save and run the InitWizard subroutine. At this point, you can move forward and backwards through the pages in the MultiPage control.</p>
<h4>Handling forced steps (part 1)</h4>
<p>
The Sample Wizard included with this article doesn’t include any mandatory, or “forced,” steps. A user can freely move between pages in the MultiPage control regardless of the values on the current page. A wizard can, however, force a user to provide a response before moving on to the next page. In the case of the Sample Wizard discussed in this article, you can disable the <b>Next</b> button until the user types text into the e-mail text box on the first wizard page. To do this, modify Case 0 (zero) in the <b>Select</b> <b>Case</b> structure in the MpgWizardPage_Change event procedure to appear as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;Select Case iCurrentPage
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 0
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cmdBack.Enabled = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If txtEmail.Value = "" Then .cmdNext.Enabled = False
</code></pre>
<p>
The <b>If...Then</b> statement disables the txtEmail TextBox control when the current value is an empty string (""). This instruction executes once when the current page changes to the first page in the MultiPage control. Once the user adds text to the txtEmail control, the <b>Next</b> button should be enabled. This can be done using the Change event of the txtEmail control. Create an event procedure named txtEmail_Change as follows (this procedure runs whenever the user changes the value of the txtEmail control):</p>
<pre><code>Private Sub txtEmail_Change()
 &nbsp;&nbsp; If WizForm.txtEmail.Value = "" Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WizForm.cmdNext.Enabled = False
 &nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WizForm.cmdNext.Enabled = True
 &nbsp;&nbsp; End If
End Sub
</code></pre>
<p>
The <b>If...Then</b> statement disables the <b>Next</b> button if the value of the txtEmail control is an empty string (""). Once text is typed into the txtEmail control, the <b>Value</b> property doesn’t equal an empty string and the <b>Next</b> button is enabled.</p>
<h3>Step 5. Changing the Form Caption</h3>
<p>
You may have noticed that when you move from page to page, the form caption remains the same (“Sample Wizard—Step 1 of 4”). Ideally, the caption should change to reflect the active page number. This can be done by setting the <b>Caption</b> property of the form in the MpgWizardPage_Change procedure as follows:</p>
<pre><code>Private Sub MpgWizardPage_Change()
With WizForm
 &nbsp;&nbsp; iCurrentPage = .MpgWizardPage.Value
 &nbsp;&nbsp; .Caption = strCaption(iCurrentPage)&nbsp;&nbsp;&nbsp; 'add this instruction
</code></pre>
<p>
The <b>Caption</b> property changes the caption text of the form (WizForm). The strCaption() variable refers to an array of strings defined in the InitWizard module. This allows the caption to vary depending upon the current page. Add the following instruction to the declarations section of the <b>InitWizard</b> subroutine:</p>
<pre><code>Public strCaption(4) As String
</code></pre>
<p>
This declaration creates an array of strings named strCaption(). Now define the individual strings in the InitWizard subroutine before WizForm is displayed using the <b>Show</b> method:</p>
<pre><code>Private Sub InitWizard()
 &nbsp;&nbsp; iCurrentPage = 0

 &nbsp;&nbsp; 'caption strings for WizForm
 &nbsp;&nbsp; strCaption(0) = "Sample Wizard - Step 1 of 4"
 &nbsp;&nbsp; strCaption(1) = "Sample Wizard - Step 2 of 4"
 &nbsp;&nbsp; strCaption(2) = "Sample Wizard - Step 3 of 4"
 &nbsp;&nbsp; strCaption(3) = "Sample Wizard - Step 4 of 4"
 &nbsp;&nbsp; strCaption(4) = "Sample Wizard - Steps 1-4 are complete"
</code></pre>
<p>
At this point, you can run the InitWizard subroutine and see the caption text change when you use the <b>Next</b> and <b>Previous </b>buttons to navigate through the wizard steps.</p>
<h3>Step 6. Making the Flow Chart Work</h3>
<p>
The flow chart controls that appear on WizForm show users the individual wizard steps and allow users to navigate through the wizard. For example, by clicking the Step 3 label or the corresponding flow chart box, a user can jump ahead to Step 3. </p>
<p>
The names of the flow chart labels are lblMap0 through lblMap4, and the names of the box shapes are shpMap0 through shpMap4. Using the Click event, you can change the current page when the user clicks either a label or a flow chart box. To do this, you need to add the Click event procedure for each of the labels and flow chart boxes. </p>
<p>
The lplMap#_Click procedures are called when a label (for example, “Step 1”) beside a flow chart box is clicked. Set the <b>Value</b> property to change the current page in the MultiPage control. For example, the first event procedure (lblMap0_Click) changes the page to the first page (page zero) when lblMap0 is clicked:</p>
<pre><code>Private Sub lblMap0_Click()
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 0
End Sub

Private Sub lblMap1_Click()
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 1
End Sub

Private Sub lblMap2_Click()
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 2
End Sub

Private Sub lblMap3_Click()
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 3
End Sub

Private Sub lblMap4_Click()
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 4
End Sub
</code></pre>
<p>
The shpMap#_Click procedures are called when a flow chart box is clicked. Set the <b>Value</b> property to change the current page in the MultiPage control. For example, the second procedure (shpMap1_Click) changes the page to the second page (page one) when the box beside Step 2 is clicked:</p>
<pre><code>Private Sub shpMap0_Click()
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 0
End Sub

Private Sub shpMap1_Click()
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 1
End Sub

Private Sub shpMap2_Click()
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 2
End Sub

Private Sub shpMap3_Click()
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 3
End Sub

Private Sub shpMap4_Click()
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 4
End Sub
</code></pre>
<p>
If you run the InitWizard subroutine at this point, the flow chart controls can be used to navigate through the wizard pages. However, the controls don’t change in appearance. This can be confusing to the user. In order to make the flow chart more useful, you can add instructions to visually differentiate the current step and the previously visited steps. The wizards included with the Office applications do this by using color and bold text formatting. Specifically, when a user jumps to a step, that step's text appears in bold and the box beside the step is changed to green. The other steps are marked with a dark gray box and the label text is not bold.</p>
<p>
These visual changes need to occur when the user changes the current page (by using either the <b>Next </b>or <b>Previous </b>command buttons or the flow chart image). Adding instructions to the MpgWizardPage_Change event procedure can do this. Add the following instructions to the MpgWizardPage_Change procedure:</p>
<pre><code>Private Sub MpgWizardPage_Change()
 &nbsp;&nbsp; With WizForm
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iCurrentPage = .MpgWizardPage.Value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Caption = strCaption(iCurrentPage)

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'deselect current flow chart marker
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Controls(strSHP_MAP &amp; iPreviousPage).BackColor = COLOR_DARKGREY
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Controls(strLBL_MAP &amp; iPreviousPage).FontBold = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'select new flow chart marker
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Controls(strSHP_MAP &amp; iCurrentPage).BackColor = COLOR_GREEN
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Controls(strLBL_MAP &amp; iCurrentPage).FontBold = True
</code></pre>
<p>
The new instructions concatenate a string, either shpMap or lblMap, with the current or previous page number. This is done in order to refer to a label or shape control name such as lblMap2 or shpMap3. Bold formatting is turned off and the box of the previous page is colored dark gray. The current page label text is made bold and the box is colored green.</p>
<p>
The instructions added to the MpgWizardPage_Change event procedure require the following declarations. Add the following statements to the declarations section of your InitWizard subroutine:</p>
<pre><code>Public iPreviousPage As Integer

'used for visited page's shape
Public Const COLOR_DARKGREY As Long = &amp;H808080
'used for active page
Public Const COLOR_GREEN As Long = vbGreen

'prefix to the box names in the flow chart
Public Const strSHP_MAP As String = "shpMap"
'prefix to the label names in the flow chart
Public Const strLBL_MAP As String = "lblMap"
</code></pre>
<p>
The iPreviousPage variable stores the number of the previous page. For example, if the user jumps from page 2 to page 4, iPreviousPage would be 2 and iCurrentPage would be 4. The iCurrentPage value is set near the beginning of the MpgWizardPage_Change event procedure (this was done in Step 4). The iPreviousPage value needs to be set before the MpgWizardPage value is changed. Look for places in your existing code where the <b>Value</b> property of the MpgWizardPage control is set. This is done in the cmdBack_Click and cmdNext Click event procedures as well as the eight Click event procedures added for the flow chart navigation. In each of the shpMap#_Click and lblMap#_Click event procedures, add the following instruction before the <b>Value</b> property is set:</p>
<pre><code>iPreviousPage = iCurrentPage
</code></pre>
<p>
For example, the complete lblMap0_Click event procedure should appear as follows:</p>
<pre><code>Private Sub lblMap0_Click()
 &nbsp;&nbsp; iPreviousPage = iCurrentPage
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 0
End Sub
</code></pre>
<p>
Now add the same instruction to the cmdBack_Click and cmdNext _Click event procedures so that they appear as follows:</p>
<pre><code>Private Sub cmdBack_Click()
 &nbsp;&nbsp; If iCurrentPage &lt;&gt; 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iPreviousPage = iCurrentPage
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WizForm.MpgWizardPage.Value = iCurrentPage - 1
 &nbsp;&nbsp; End If
End Sub

Private Sub cmdNext_Click()
 &nbsp;&nbsp; If iCurrentPage &lt; 4 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iPreviousPage = iCurrentPage
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WizForm.MpgWizardPage.Value = iCurrentPage + 1
 &nbsp;&nbsp; End If
End Sub
</code></pre>
<p>
At this point, you can run the InitWizard subroutine and move forward and backward using the flow chart controls. When you change pages, the flow chart updates to reflect the current page as well as the pages you’ve visited.</p>
<h4>Handling forced steps (part 2)</h4>
<p>
If you create a wizard with mandatory or forced steps, you may want to control how the user moves between steps. “Handling Forced Steps (Part 1)” in Step 4 addressed this issue for the <b>Next</b> and <b>Back</b> buttons, but now the flow chart controls need to be addressed. This can be done in a couple of different ways. The easiest way is to remove the Click event procedures associated with the flow chart controls (that is, the various shpMap#_Click and lblMap#_Click procedures). This way the flow chart controls can’t be used for navigation, but you can still see the current and visited steps.</p>
<p>
If you want to keep the navigation functionality of the flow chart controls, you need to add instructions that check the values of the controls on the current page before allowing the user to change pages. This can be done by calling a function that determines whether the user can move to another step prior to changing the mpgWizardPage value. For example, the current lblMap1_Click event procedure changes the page to the second page (page 1) when the label named lblMap1 is clicked:</p>
<pre><code>Private Sub lblMap1_Click()
 &nbsp;&nbsp; iPreviousPage = iCurrentPage
 &nbsp;&nbsp; WizForm.MpgWizardPage.Value = 1
End Sub
</code></pre>
<p>
Instead of moving directly to page 1, call a function that approves the move prior to changing the page. For example, the following lblMap1_Click event procedure calls the OKToMoveOn function prior to changing the page. The instructions within the <b>If...End If</b> structure run only if the OKToMoveOn function returns True:</p>
<pre><code>Private Sub lblMap1_Click()
 &nbsp;&nbsp; If OKToMoveOn() = True Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iPreviousPage = iCurrentPage
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WizForm.mpgWizardPage.Value = 1
 &nbsp;&nbsp; End If
End Sub
</code></pre>
<p>
Now create the following OKTOMoveOn function:</p>
<pre><code>Private Function OKToMoveOn()
 &nbsp;&nbsp; Select Case iCurrentPage
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 0
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If WizForm.txtEmail.Value = "" Then fOKToMove = False _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else fOKToMove = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fOKToMove = True
 &nbsp;&nbsp; End Select
 &nbsp;&nbsp; OKToMoveOn = fOKToMove
End Function
</code></pre>
<p>
The OKToMoveOn function includes a special case for the first page (Case 0). If the <b>txtEmail</b> textbox is empty, the fOKToMove flag is set to <b>False</b>. In the lblMap1_Click event procedure, the mpgWizardPage value is only changed if the OKToMoveOn function returns <b>True</b>; the user can’t move to another step until the txtEmail control includes some text.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If your wizard includes one or more forced steps, the OKToMoveOn function needs to be called in each of the various shpMap#_Click and lblMap#_Click event procedures. Modify each routine to include the <b>If...End If</b> structure shown in the lblMap1_Click procedure.</p>
<h2><a name="wizardof_assist"></a>Using the Office Assistant with a Wizard</h2>
<p>
If you run the wizards included with Word and Microsoft Excel, you may notice that each one has a button in the lower-left corner for displaying help about using the wizard. If you click this button, the Office Assistant is displayed, and the balloon shown in Figure 2 allows you to indicate whether you want help with the wizard or help about another feature of the product. In this article, this built-in balloon is referred to as the <i>branch balloon</i>.</p>
<p>
<img src="wizard02.gif" border=0></p>
<p class=label>
<b>Figure 2. The "branch balloon"</b></p>
<p>
If you click <b>Help with this feature</b>, another balloon is displayed with the appropriate information about the current page of the wizard. If you click <b>Help with something else</b>, the standard Assistant balloon with a text box for typing queries is displayed.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The branch balloon is also displayed when you click the Assistant window while a wizard is running.</p>
<p>
Also, if the <b>Help with wizards</b> check box on the <b>Options</b> tab of the <b>Office Assistant</b> dialog box is selected, the Assistant is displayed automatically when the wizard starts, and the balloon shown in Figure 3 allows you to indicate whether you want help with the wizard right away. In this article, this built-in balloon is referred to as the <i>decision balloon</i>.</p>
<p>
<img src="wizard03.gif" border=0></p>
<p class=label>
<b>Figure 3. The "decision balloon"</b></p>
<p>
If you click <b>Yes, please provide help</b>, the appropriate balloon is displayed. If you click <b>No, don’t provide help now</b>, the balloon is dismissed and the Assistant remains visible.</p>
<p>
Both of these balloons, as well as the way the Assistant displays them, and the way the Assistant responds to the user’s actions are built into Office. To control when the built-in balloons are displayed while your wizard is running, use the <b>StartWizard</b>, <b>ActivateWizard</b>, and <b>EndWizard</b> methods of the <b>Assistant</b> object in the Office object library, as outlined in Table 3.</p>
<p class=label>
<b>Table 3. Assistant-Object Methods to Use with Wizards</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Method</b></td>
<td class=label width=45%><b>Purpose</b></td>
<td class=label width=31%><b>Where it is used</b></td>
</tr>
<tr valign=top>
<td width=24%><b>StartWizard</b></td>
<td width=45%>Initiates a wizard session with the Assistant and returns a unique session ID. (If the <b>Help with wizards</b> check box is selected, displays the built-in decision balloon automatically.) Until the session ends, the Assistant displays the built-in branch balloon whenever it is clicked. </td>
<td width=31%>InitWizard()</td>
</tr>
<tr valign=top>
<td width=24%><b>ActivateWizard</b></td>
<td width=45%>Displays the Assistant (if it isn’t visible already) and the built-in branch balloon when the user clicks the <b>Office Assistant </b>button on WizForm. If the Assistant is already displaying Help, this method can be used to close the visible Help balloon.</td>
<td width=31%>TglAssistant_Click()</td>
</tr>
<tr valign=top>
<td width=24%><b>EndWizard</b></td>
<td width=45%>Ends the wizard session indicated by a unique session ID. When there are no active wizard sessions, the Assistant displays the built-in query balloon whenever it is clicked.</td>
<td width=31%>CmdCancel_Click(), cmdFinish_Click()</td>
</tr>
</table><br>
<p>
To control how the Assistant responds when the user clicks a button in the decision balloon or branch balloon, you must create a callback procedure in your wizard code. A <i>callback </i>procedure is a subroutine that takes a predefined set of arguments and uses decision structures to direct subsequent actions based on the values of one or more of those arguments. The callback procedure required by the Assistant while a wizard is running must be a private subroutine that takes two <b>Long</b> arguments. The name of the callback procedure, as well as the names of the two arguments required by the procedure, can be anything you want. For example, the callback procedure may appear as follows:</p>
<pre><code>Private Sub wizCallback(lButton As Long, lpriv As Long)
'
' decision structures for directing action
'
End Sub
</code></pre>
<p>
When your wizard starts running, you must identify the name of the callback procedure you’ve created to control the Assistant’s behavior. Do this with the second argument of the <b>StartWizard</b> method.</p>
<p>
The five steps in this section describe how to bring these elements together to incorporate the Assistant into your wizard just as it was incorporated into the wizards that ship with Microsoft Excel and Word. Follow each of the steps in this section. Each step adds an essential element, so no step should be omitted.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This article describes one possible approach for incorporating Office Assistant Help with your custom wizard. The Assistant’s behavior is not restricted to the behavior described in this article, however. You may choose to program the Assistant differently in your custom wizards. For more information about programming the Office Assistant, see Chapter 9 of the <i>Microsoft Office 97/Visual Basic Programmer’s Guide </i>(MSDN Library, Microsoft Office Development).</p>
<h3>Step 1. Beginning the Session</h3>
<p>
Before you start programming the <b>Assistant</b> object, add the following global variables to the declaration section of the module that contains the InitWizard procedure:</p>
<pre><code>Public lwizID As Long, lprefState As Long
Public oTheBalloon As Balloon
Public bExitTglEvent As Boolean, bVis As Boolean
Public strArray(4) As String
</code></pre>
<p>
Insert the following statements into the InitWizard procedure, directly before the iCurrentPage variable is set to 0 (zero). These statements initialize the global variables related to the Assistant:</p>
<pre><code>lwizID = 0
lprefState = 0
bExitTglEvent = False
bVis = False
</code></pre>
<p>
Now insert the following block of code after bVis is set to <b>False</b>. The <b>If</b> statement identifies the value of the <b>Help with wizards</b> check box on the <b>Options</b> tab of the <b>Office Assistant</b> dialog box and assigns the correct value to the lprefState variable. This variable is passed to the <b>StartWizard</b> method and determines whether the Assistant and the decision balloon are displayed when your wizard starts. If the <b>Help with wizards</b> check box is selected, lprefState is assigned msoWizardActActive. If <b>Help with wizards</b> is cleared or in a mixed state, lprefState is assigned msoWizardActInactive:</p>
<pre><code>'record user preference in the lprefState variable
If Assistant.AssistWithWizards = True Then
 &nbsp;&nbsp; lprefState = msoWizardActActive
Else
 &nbsp;&nbsp; lprefState = msoWizardActInactive
End If
</code></pre>
<p>
Insert the following block of code directly after the preceding <b>If...End If</b> statement. This block of code creates a modeless balloon that is used to display Help throughout the session. Later, this balloon is customized with Help text for each wizard page:</p>
<pre><code>'create standard balloon
Set oTheBalloon = Assistant.NewBalloon
With oTheBalloon
 &nbsp;&nbsp; .Heading = "Here's some help..."
 &nbsp;&nbsp; .Mode = msoModeModeless
 &nbsp;&nbsp; .Button = msoButtonSetNone
End With
</code></pre>
<p>
You may notice that a callback procedure isn’t specified for this modeless balloon. Normally, modeless balloons require a callback procedure. But because it’s being used during a wizard session, statements in the callback procedure for the built-in decision and branch balloons control this balloon instead.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you decide to add controls or buttons to this balloon, you must specify a callback procedure to handle each control that the user may click.</p>
<p>
After oTheBalloon is defined in the InitWizard procedure, insert this call to a procedure named "fillArray:"</p>
<pre><code>'fill the message array
Call fillArray
</code></pre>
<p>
Now insert the private fillArray procedure (shown in the following code) in the module. The fillArray procedure fills strArray() with text messages used to provide Help for each page of the wizard’s MultiPage control. The Help message for each page is placed in the array in a location that corresponds to the number of the page. For example, Help text for the first page, page number 0 (zero), is placed in strArray(0). This way, text is added to the oTheBalloon easily by assigning the appropriate text in the array to the <b>Text</b> property (see “Step 4. Using Navigation Buttons and Maps” later in this article):</p>
<pre><code>Private Sub fillArray()
strArray(0) = "Type your e-mail alias in the space provided. " &amp; _
 &nbsp;&nbsp; "If you don't know your e-mail alias, contact " &amp; _
 &nbsp;&nbsp; "your system administrator."

strArray(1) = "Select a color from the list provided by " &amp; _
 &nbsp;&nbsp; "clicking the button next to the color choice."

strArray(2) = "Type your full name and and mailing address " &amp; _
 &nbsp;&nbsp; "in the space provided."

strArray(3) = "All of the following personal items will be " &amp; _
 &nbsp;&nbsp; "included. Please clear the box next to the " &amp; _
 &nbsp;&nbsp; "items you don't want included."

strArray(4) = "To change any settings, click Back."
End Sub
</code></pre>
<p>
Finally, insert the following code in the InitWizard procedure after the call to the fillArray procedure. This code begins the wizard session. The <b>StartWizard</b> method returns an integer that uniquely identifies the session and associates the session with a specific wizard. This integer is used later by the <b>ActivateWizard</b> and <b>EndWizard</b> methods. The first argument, which is assigned lprefState, indicates whether the Assistant and the built-in decision balloon are displayed automatically. The second argument indicates the name of the callback procedure that controls the built-in decision and branch balloons. The third argument is an integer that uniquely identifies the balloon that runs the callback procedure:</p>
<pre><code>'start the session and assign the returned value
lwizID = Assistant.StartWizard(On:=lprefState, _
 &nbsp;&nbsp; Callback:="wizCallback", PrivateX:=1)
</code></pre>
<h3>Step 2. Using Callback Procedures</h3>
<p>
When the user clicks <b>Yes, please provide help</b> in the built-in decision balloon, or <b>Help with this feature</b> in the built-in branch balloon, a custom balloon offering help with the current page of the MultiPage control is displayed. When the user clicks <b>Help with something else</b> in the branch balloon, the built-in query balloon is displayed and the user can get help with any Office feature. What makes this behavior possible is the callback procedure specified in the <b>StartWizard</b> method.</p>
<p>
The callback procedure required by these built-in balloons is structured differently from callback procedures required by other modeless balloons. The callback procedure for the built-in balloons receives only two arguments: the index of the button the user clicked and the integer that identifies the balloon. The <b>Balloon</b> object, included in standard callback procedures for modeless balloons, is omitted because the same callback procedure runs for both the branch balloon and the decision balloon.</p>
<p>
Your callback procedure for these balloons must use a <b>Select</b> <b>Case</b> structure to test lButton to determine the user’s response to the built-in balloons, as shown in Table .4.</p>
<p class=label>
<b>Table 4. IButton Values</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Branch balloon button</b></td>
<td class=label width=32%><b>Decision balloon button</b></td>
<td class=label width=42%><b><br>
lButton value</b></td>
</tr>
<tr valign=top>
<td width=26%>Help with this feature</td>
<td width=32%>Yes, please provide help</td>
<td width=42%><b>msoWizardMsgShowHelp</b></td>
</tr>
<tr valign=top>
<td width=26%>Help with something else</td>
<td width=32%>No, don’t provide help now</td>
<td width=42%><b>msoWizardMsgLocalStateOff</b></td>
</tr>
</table><br>
<p>
In each case, the following things must happen:
<ul type=disc>
<li>
The global lprefState variable must be set to <b>msoWizardActActive</b> or <b>msoWizardActInactive</b>. The value of this variable is tested later, in the tglAssistant_Click event procedure, to ensure the correct behavior of the <b>Office Assistant</b> button on WizForm when the user clicks it.<br><br></li>
<li>
The value of bVis must be checked to determine the state of oTheBalloon. The balloon is hidden if lButton is <b>msoWizardMsgLocalStateOff</b>, and it should be visible, with the correct text for the current page of the MultiPage control, if lButton is <b>msoWizardMsgShowHelp</b> and oTheBalloon isn’t visible already.<br><br></li>
<li>
The <b>Office Assistant</b> button must be set to the appropriate state (pushed in or raised) if it isn’t already. Note that the bExitTglEvent variable is set to <b>True</b> to ensure that the tglAssistant_Click procedure ends immediately when the <b>Value</b> property of the control is set by the callback procedure.</li>
</ul>
<p>
Copy the following procedure into the same module that contains the InitWizard procedure:</p>
<pre><code>Private Sub wizCallback(lButton, lpriv)
 &nbsp;&nbsp; Select Case lButton
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case msoWizardMsgLocalStateOff
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lprefState = msoWizardActInactive
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If bVis Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oTheBalloon.Close
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bVis = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If WizForm.tglAssistant.Value Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bExitTglEvent = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WizForm.tglAssistant.Value = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case msoWizardMsgShowHelp
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lprefState = msoWizardActActive
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If bVis Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Sub
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oTheBalloon.Text = strArray(iCurrentPage)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oTheBalloon.Show
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bVis = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Not (WizForm.tglAssistant.Value) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bExitTglEvent = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WizForm.tglAssistant.Value = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp; End Select
End Sub
</code></pre>
<h3>Step 3. Using the Office Assistant Button</h3>
<p>
The <b>Office Assistant </b>button on the wizard allows the user to display or dismiss Help at any point in the wizard. While the wizard is running, the <b>Office Assistant</b> button must reflect the state of the Assistant. If the Assistant is visible and displaying oTheBalloon, the button should be pushed in, whereas if the Assistant is not visible or is visible but is not displaying oTheBalloon, the button should be raised.</p>
<p>
You may assume that the code that sets the state of the <b>Office Assistant</b> button belongs in the Click event procedure for the control (tglAssistant_Click). However, that’s not the case. The user’s response to the built-in branch or decision balloon determines whether the Assistant displays oTheBalloon, so the code that sets the state of the <b>Office Assistant</b> button must appear in the callback procedure as discussed in “Step 2. Using Callback Procedures.”</p>
<p>
The tglAssistant_Click procedure must do the following:
<ul type=disc>
<li>
If there is no current wizard session (that is, <b>StartWizard</b> hasn’t run or an error value was returned), the procedure must end.<br><br></li>
<li>
If the global bExitTglEvent variable that indicates the Click event was triggered by code is <b>True</b>, the procedure must reset the variable to <b>False</b> and then end. This variable will be <b>True</b> whenever the <b>Value</b> property of the <b>Office Assistant</b> button is set by code.<br><br></li>
<li>
If the global lprefState variable that indicates the current state of the Assistant is <b>msoWizardActInactive</b>, the procedure must use the <b>ActivateWizard</b> method to activate the Assistant and display the branch balloon. If the current state of the Assistant is <b>msoWizardActActive</b>, the procedure must use the <b>ActivateWizard</b> method to call the callback procedure directly, signaling the callback to close the visible Help balloon.</li>
</ul>
<p>
Add the following Click event procedure to WizForm:</p>
<pre><code>Private Sub tglAssistant_Click()
 &nbsp;&nbsp; If lwizID = 0 Then Exit Sub

 &nbsp;&nbsp; If bExitTglEvent Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bExitTglEvent = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Sub
 &nbsp;&nbsp; End If

 &nbsp;&nbsp; If lprefState = msoWizardActInactive Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If tglAssistant.Value Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bExitTglEvent = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tglAssistant.Value = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Assistant.ActivateWizard WizardID:=lwizID, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Act:=msoWizardActActive
 &nbsp;&nbsp; ElseIf prefState = msoWizardActActive Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Assistant.ActivateWizard WizardID:=lwizID, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Act:=msoWizardActInactive
 &nbsp;&nbsp; End If
End Sub
</code></pre>
<h3>Step 4. Using Navigation Buttons and Maps</h3>
<p>
Each time the user clicks a navigation button or clicks a section of the navigation map, the text in the Assistant balloon must change to display Help for the new wizard page. You accomplish this by assigning the appropriate string from the message array to the <b>Text</b> property of oTheBalloon. </p>
<p>
Each time the user advances to the next wizard page, the value of the <b>mpgWizardPage</b> control is increased by one. Similarly, each time the user moves to a previous page the value of the control is decreased. The code needed to handle page changes for the wizard is in one procedure and the corresponding Assistant code should be in the same place.</p>
<p>
If the balloon is visible (bVis is <b>True</b>), the following code closes the Assistant’s balloon, assigns text from strArray to the <b>Text</b> property of the <b>Balloon</b> object, and displays the balloon again.</p>
<p>
Insert the following code after the iCurrentPage variable is set near the beginning of the MpgWizardPage_Change procedure:</p>
<pre><code>If bVis Then
 &nbsp;&nbsp; oTheBalloon.Close
 &nbsp;&nbsp; oTheBalloon.Text = strArray(iCurrentPage)
 &nbsp;&nbsp; oTheBalloon.Show
End If
</code></pre>
<h3>Step 5. Ending the Session</h3>
<p>
As discussed previously, the <b>StartWizard</b> method returns a session number. Assign this value to a variable, and reference the variable in the <b>ActivateWizard</b> and <b>EndWizard</b> methods. The <b>EndWizard</b> method releases the variable returned by the <b>StartWizard</b> method; therefore, it is important to include the <b>EndWizard</b> method to each exit point of your wizard. The exit points in this wizard are the <b>Cancel</b> button, the <b>Finish </b>button, and the built-in <b>Close</b> button of WizForm.</p>
<p>
In the following subroutines, the <b><i>WizardID</i></b> argument of the <b>EndWizard</b> method is set to the lwizID variable. The <b><i>varfSuccess</i></b> argument is a Boolean value that indicates whether the user has successfully completed the wizard. This argument should be set to <b>False</b> if the <b>Cancel</b> button is clicked and <b>True</b> if the <b>Finish</b> button is clicked. The <b>msoAnimationCharacterSuccessMajor</b> animation type is applied to the Assistant if the <b><i>varfSuccess</i></b> argument is <b>True</b>.</p>
<p>
Edit the existing code in the specified procedures to appear as follows:</p>
<pre><code>Private Sub cmdCancel_Click()
 &nbsp;&nbsp; If bVis Then oTheBalloon.Close
 &nbsp;&nbsp; Assistant.EndWizard WizardID:=lwizID, varfSuccess:=False
 &nbsp;&nbsp; Unload WizForm
End Sub

Private Sub cmdFinish_Click()
 &nbsp;&nbsp; If bVis Then oTheBalloon.Close
 &nbsp;&nbsp; ' end the session and unload the wizard
 &nbsp;&nbsp; Assistant.EndWizard WizardID:=lwizID, varfSuccess:=True
 &nbsp;&nbsp; Unload WizForm
End Sub
</code></pre>
<h2><a name="wizardof_temp"></a>Wizard Templates and Add-ins</h2>
<p>
Once your wizard is complete, you need to think about your distribution strategy. Where should the code module and the user form be stored? A wizard can be stored in a template or add-in depending on the Office application. How does the user run the wizard? For example, is the wizard run from the <b>New</b> dialog box, a menu, or a toolbar button? The following information describes wizard distribution techniques for Word, Microsoft Excel, and Microsoft PowerPoint.</p>
<h3>Word Wizards</h3>
<p>
Word wizards, such as the wizards included with Word 97, are typically stored in a template (.dot file). If you want the user to access your wizard from the <b>New</b> dialog box, change the extension to .wiz&nbsp; and place it in the Template folder or a subfolder of the Templates folder.</p>
<p>
If you want the wizard to run when the user creates a new document based on the wizard, use the <b>New</b> event with the <b>Document</b> object. Use the following steps to create the event procedure.
<ol>
<li>
Under your project in the Project Explorer window, double-click <b>ThisDocument</b>. (In folder view, <b>ThisDocument</b> is located in the Microsoft Word Objects folder.)<br><br></li>
<li>
Select <b>Document</b> from the Object box. An empty Document_New subroutine is added to the class module.<br><br></li>
<li>
Add a statement that calls the subroutine that initializes and displays the wizard form (in this case InitWizard).<pre><code>Private Sub Document_New()
 &nbsp;&nbsp; Call InitWizard
End Sub
</code></pre>
</li>
</ol>
<p>
Word wizards can also be designed to modify existing documents. In this case, the wizard macros are again stored in a template, but the template extension is not renamed. Instead, the template is loaded as a global template either manually (from <b>Templates and Add-Ins</b> on the <b>Tools</b> menu) or automatically when Word starts. Templates in the \Office\Startup folder are automatically loaded as global templates when Word starts.</p>
<p>
To give users easy access to your wizard, consider customizing the menu commands or toolbar buttons in the template that contains your wizard. Open or switch to the open wizard template in Word. On the <b>Tools</b> menu, click <b>Customize</b> and then click the <b>Commands</b> tab. In the <b>Categories</b> box, click <b>Macros</b>. Make sure your template is selected in the <b>Save In</b> box. Now, drag the InitWizard macro from the <b>Commands</b> box over to a menu or toolbar button. After the button or menu item is added, you may want to customize the toolbar image or menu text using the options available when you right-click on the new item (while the <b>Customize</b> dialog box is displayed).</p>
<p>
Now when the global template is loaded, the menu item or toolbar button becomes available so that your wizard can be accessed. Later when the template is unloaded the menu item or toolbar button disappears.</p>
<h3>PowerPoint Wizards</h3>
<p>
PowerPoint wizards can be initially created in a presentation file (.ppt). After the wizard is ready, save the presentation file as a PowerPoint add-in file (.ppa). If you want to run the wizard from <b>New</b> on the <b>File</b> menu, change the extension to .pwz. After changing the extension, PowerPoint identifies the template as a wizard in the <b>New</b> dialog box (the .pwz file needs to reside in the Template folder or a subfolder of the Templates folder).</p>
<p>
PowerPoint supports Auto_Open and Auto_Close subroutines, which are automatically executed when add-ins are loaded and unloaded. In the case of a wizard run from the <b>New</b> dialog box, you can add wizard initialization code to the Auto_Open subroutine or you can call the subroutine that includes the initialization code. The following Auto_Open subroutine calls a subroutine named InitWizard, which includes instructions to initialize and display the wizard form created in this article:</p>
<pre><code>Sub Auto_Open()
 &nbsp;&nbsp; Call InitWizard
End Sub
</code></pre>
<p>
In this case, the PowerPoint wizard (an add-in with a .pwz extension) includes a module with two subroutines: InitWizard and Auto_Open.</p>
<p>
In addition to running a wizard from the <b>New</b> dialog box, a wizard can be designed to modify an existing presentation. In this case, the wizard macros are again stored in an add-in, but the add-in file isn’t renamed so that it appears in the <b>New</b> dialog box. Instead, the add-in is loaded from <b>Add-Ins</b> on the <b>Tools</b> menu.</p>
<p>
Using Auto_Open and Auto_Close subroutines in your add-in code module, you can control when the wizard is accessible. Menu items or toolbar buttons can be added when the wizard add-in is loaded and later removed when the add-in is unloaded. The instructions to add and remove menu items automatically runs if they are stored in the Auto_Open and Auto_Close subroutines.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;An add-in that is loaded during the current session is automatically loaded the next time PowerPoint starts.</p>
<h3>Microsoft Excel Wizards</h3>
<p>
Microsoft Excel wizards, such as those included with Microsoft Excel 97, can be stored in add-in files (.xla) or templates (.xlt). If you want the wizard to run from the <b>New</b> dialog box, create a new workbook that includes a reference to your wizard project (use the <b>References</b> dialog box in the Visual Basic Editor). Save the new workbook as a template (.xlt) in the Templates or Spreadsheet Solutions folder. Use the Call statement in the Workbook_Open subroutine to call the wizard initialization routine (InitWizard) in the referenced wizard project.</p>
<p>
The following sample Workbook_Open subroutine is stored in the <b>ThisDocument</b> class module. The routine calls the subroutine that initializes and displays the wizard form (in this case InitWizard) in the referenced wizard project. The <b>If...Then</b> structure calls the InitWizard routine if the active workbook hasn’t been saved:</p>
<pre><code>Private Sub Workbook_Open()
 &nbsp;&nbsp; If ActiveWorkbook.Path = "" Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Call InitWizard
 &nbsp;&nbsp; End If
End Sub
</code></pre>
<p>
Now when a new workbook is based on the template (in the <b>New</b> dialog box), the wizard runs. For more information on referencing another project, refer to <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_addins97">
</object><a href=JavaScript:alink_1.Click()>"Distributing Microsoft Excel 97, Word 97, and PowerPoint 97 Solutions"</a>. </p>
<p>
In addition to running a wizard from the <b>New</b> dialog box, a wizard can be designed to modify an existing workbook. The wizards included with Microsoft Excel, such as the Lookup and Conditional Sum wizards, use this technique. To use this method, save your Microsoft Excel workbook or template as an add-in file (.xla). Microsoft Excel add-ins can be loaded manually from <b>Add-Ins</b> on the <b>Tools</b> menu or automatically when Microsoft Excel starts. Add-ins in the \Office\XLStart folder are automatically loaded when Microsoft Excel starts.</p>
<p>
Microsoft Excel supports Workbook_Open and Workbook_Close events, which are automatically executed when an add-in is opened or closed. Additionally, the Workbook_AddinInstall and Workbook_AddinUnInstall events execute when an add-in is loaded or unloaded from <b>Add-Ins</b> on the <b>Tools</b> menu.</p>
<p>
You can add instructions that make the wizard accessible in the WorkBook_Open subroutine. For example, the WorkBook_Open subroutine can add a menu item or toolbar button that in turn runs the wizard. When the add-in is unloaded, the WorkBook_Close subroutine is automatically called. This subroutine can include instructions that remove the menu items or buttons added in the WorkBook_Open subroutine. Using a combination of WorkBook_Open and WorkBook_Close subroutines, your wizard can be made accessible when the add-in is loaded from <b>Add-Ins</b> on the <b>Tools</b> menu.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;An add-in that is loaded during the current session is automatically loaded the next time Microsoft Excel starts. To increase the speed with which Microsoft Excel loads, you can <i>demand</i> <i>load </i>an add-in. This means the add-in is loaded when the user chooses to use the add-in, instead of when Microsoft Excel starts. For more information about creating demand loaded add-ins, refer to <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_addins97">
</object><a href=JavaScript:alink_2.Click()>"Distributing Microsoft Excel 97, Word 97, and PowerPoint 97 Solutions."</a> This article includes information about how to use registry keys to create menu items that provide entry points to an add-in without loading the add-in automatically when Microsoft Excel starts.</p>
<p>
If your wizard requires multiple menu items or toolbar buttons, you can distribute a workbook-level menu bar or toolbar with your wizard. For information on this technique, see Chapter 8 in <i>Microsoft Office 97/Visual Basic Programmer’s Guide</i> (MSDN Library, Microsoft Office Development).</p>
<h2><a name="wizardof_where"></a>Where Do You Go from Here?</h2>
<p>
Now that the wizard user interface is complete, you need to add additional code to perform operations based on the user’s responses to the various wizard steps. For example, after the user completes the Memo Wizard included with Word, the wizard creates a memo based on the user’s preferences. The subroutines that perform the actions can be stored in an existing or new code module included with the project. </p>
<p>
In the existing cmdFinish_Click() subroutine (in the WizForm UserForm), add an instruction that calls a routine in a code module. For example, the following cmdFinish_Click() subroutine calls the PerformTask subroutine after WizForm is unloaded:</p>
<pre><code>Private Sub cmdFinish_Click()
 &nbsp;&nbsp; If bVis Then oTheBalloon.Close
 &nbsp;&nbsp; Assistant.EndWizard WizardID:=lwizID, varfSuccess:=True
 &nbsp;&nbsp; Unload WizForm
 &nbsp;&nbsp; Call Module1.PerformTask
End Sub
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Any data that a user enters in WizForm is lost when WizForm is unloaded. If you return the values of controls in WizForm after the form has been unloaded, you get the initial values for the controls rather than any values the user may have entered. If you want to save the data entered by a user in WizForm, you can do so by saving the information to variables prior to unloading WizForm. For example, if you want to save the e-mail name from the txtEmail TextBox control, add the following instruction before the <b>Unload</b> statement in the previous example.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;strEmail = WizForm.txtEmail

</code></pre>
</BODY>
</HTML>
