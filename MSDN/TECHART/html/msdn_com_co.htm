<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The COM Programmer's Cookbook</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_com_co"></a></sup>The COM Programmer's Cookbook</h1>
<p>
Crispin Goswell<br>
Microsoft Office Product Unit</p>
<p>
Spring 1995<br>
Revised: September 13, 1995</p>
<h2>Abstract</h2>
<p>
This cookbook shows you how to create Microsoft® OLE Component Object Model (COM) objects and use them effectively. The examples are mostly in C, as this shows most clearly what is actually being done. Some programmers will prefer to use C++ to implement their objects. Kraig Brockschmidt's book <i>Inside OLE</i> (2nd edition)<i> </i>(MSDN Library, Books) covers the concepts of COM and basic usage from the C++ programmer's perspective. Readers interested in gaining a better understanding of what COM is, as well as the motivations behind its design and philosophy, should read the first two chapters of the <i>Component Object Model Specification</i> (MSDN Library, Specifications). Chapter 1 is a brief introduction, and Chapter 2 provides a thorough overview. This cookbook builds on the information found in <i>Inside OLE</i> and the COM specification by showing some good ways to implement COM objects.</p>
<h2>The Component Object Model</h2>
<p>
Creating a Microsoft® OLE Component Object Model (COM) object simply requires you to expose one or more interfaces that follow the COM rules. There are many other ways to structure software components. What makes COM interesting is that it is a widely accepted interoperability standard. When you use COM to connect pieces of software, deviations from the standard just cause interoperability problems. I mention this because there are many perfectly reasonable variants and alternatives to COM. The problem with these is that they do not interoperate with other COM objects. This cookbook focuses solely on what you can do with COM implementation within the constraints of the COM standard.</p>
<p>
A COM class may be registered in the system registry in order to become a COM server. This is an optional step: It increases the usefulness of a COM object but is not required. For COM objects that are part of some larger whole, it is sometimes not appropriate.</p>
<p>
The creation of object instances and the use of interfaces obtained from those instances are often done by separate pieces of code. This separation allows the interface user to be attached to different classes at different times, and is an important feature of COM. Most existing software assumes great knowledge about the implementation details of the code that it calls. By deliberately avoiding such coupling, COM encourages a style of programming in which different pieces of code can be truly independent of one another. Rather than assuming knowledge about the implementation of some called code, a COM client assumes a <i>service</i> from an interface or collection of interfaces. Different implementations can provide that service. COM interfaces provide a standard means by which a client of an object can perform an initial negotiation for a particular service and then assume some behavior from that service that conforms to a known contract.</p>
<h3>COM Interfaces</h3>
<p>
The separation between service user and implementation is done by indirect function calls. A COM interface is nothing more than a named table of function pointers (<i>methods</i>), each of which has documented behavior. The behavior is documented in terms of the interface function's parameters and a <i>model</i> of the state within the object instance. The description of the model within the instance will say no more than is required to make the behavior of the other methods in the interface understandable. The table of functions is referred to as a <i>vtable</i>. Here is an example interface expressed in C:</p>
<pre><code>typedef struct
{
 &nbsp;&nbsp; struct IFooVtbl *<b>lpVtbl</b>;
} <b>IFoo</b>;

typedef struct
{
 &nbsp;&nbsp; // IUnknown methods
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp; (*<b>QueryInterface</b>) (IFoo *, REFIID, void **);
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*<b>AddRef</b>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (IFoo *);
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*<b>Release</b>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (IFoo *);
 &nbsp;&nbsp; // IFoo methods
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp; (*<b>SetValue</b>)&nbsp;&nbsp;&nbsp; (IFoo *, int);
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp; (*<b>GetValue</b>)&nbsp;&nbsp;&nbsp; (IFoo *,int *);
} <b>IFooVtbl</b>;
</code></pre>
<p>
An interface is actually a pointer to a vtable. The vtables are usually shared by multiple instances, so the methods need a different pointer to be able to find the object that the interface is attached to. This is the interface pointer, and the vtable pointer is the only thing that is accessible from it by clients of the interface. By design, this arrangement matches the virtual method-calling convention of C++ classes, so a COM interface is binary-compatible with a C++ abstract class.</p>
<p>
<img src="com_co_1.gif" border=0></p>
<p>
An interface can be declared in a way that is usable from C or C++ using the COM macros. Here is IFOO.H:</p>
<pre><code>#include &lt;objbase.h&gt;

#undef INTERFACE
#define INTERFACE IFoo

DECLARE_INTERFACE_ (<b>IFoo</b>, IUnknown)
{
 &nbsp;&nbsp; // IUnknown methods
 &nbsp;&nbsp; STDMETHOD (<b>QueryInterface</b>)&nbsp;&nbsp; (THIS_&nbsp; REFIID, void **) PURE;
 &nbsp;&nbsp; STDMETHOD_(ULONG, <b>AddRef</b>)&nbsp;&nbsp;&nbsp; (THIS) PURE;
 &nbsp;&nbsp; STDMETHOD_(ULONG, <b>Release</b>)&nbsp;&nbsp; (THIS) PURE;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; STDMETHOD (<b>SetValue</b>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (THIS_&nbsp; int) PURE;
 &nbsp;&nbsp; STDMETHOD (<b>GetValue</b>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (THIS_&nbsp; int *) PURE;
};

// {A46C12C0-4E88-11ce-A6F1-00AA0037DEFB}
DEFINE_GUID(<b>IID_IFoo</b>, 0xa46c12c0, 0x4e88, 0x11ce, 0xa6, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0xde, 0xfb);
</code></pre>
<p>
This declaration expands into the C <b>typedefs</b> described earlier. The last two lines were created using GUIDGEN. This creates a unique 16-byte number for the <i>interface ID</i> (IID_IFoo here) and can copy it to the Clipboard for pasting into source code. An IID (which appears as the parameter type <b>REFIID</b> in the <b>QueryInterface</b> method above) is a means of identifying a particular interface for the purposes of run-time lookup.</p>
<p>
The interface can also be described in interface definition language (IDL), which is input to a tool, Microsoft IDL (MIDL), which can produce a header file from a specification such as the following (IFOO.IDL):</p>
<pre><code>[ object, uuid(A46C12C0-4E88-11ce-A6F1-00AA0037DEFB) ]
interface IFoo : IUnknown
{
 &nbsp;&nbsp; HRESULT SetValue ([in] int);
 &nbsp;&nbsp; HRESULT GetValue ([out] int *);
};
</code></pre>
<p>
MIDL is also able to generate COM remoting code (remote procedure calls [RPC]) from this description. This allows one process to call interfaces across process or machine boundaries.</p>
<h3>The COM Interface Rules</h3>
<p>
A full description of the COM interface rules can be found in the COM specification or in the technical article <a href="msdn_therules.htm">"The Rules of the Component Object Model"</a> in the Microsoft Development (MSDN) Library and in the COM Resource Kit. Readers will also find useful information for designing, implementing, and using COM interfaces in the <a href="msdn_mfccom.htm">"Tom's Handy Dandy MFC/COM/MIDL Recipe Book for Creating Custom Interfaces"</a> technical article.</p>
<p>
Here is a summary of the rules:
<ul type=disc>
<li>
The first three methods in a COM interface are required to be the same for all COM interfaces. These are the methods of the <b>IUnknown</b> interface: <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b>. C++ programmers would say that the interface must <i>inherit</i> from <b>IUnknown</b>.<br><br></li>
<li>
The <b>QueryInterface</b> method takes an interface ID (an IID) and returns the requested COM interface on the same object. The set of interface IDs accessible via <b>QueryInterface</b> is the same from every interface on the object.<br><br></li>
<li>
<b>QueryInterface</b> must have stable behavior: If it succeeds once for a particular interface on a particular instance, it should always succeed. If it fails once for a particular interface, it should always fail. If it succeeds, it should return NOERROR; otherwise, it should normally return E_NOINTERFACE and, importantly, zero its out parameter.<br><br></li>
<li>
The interface returned by <b>QueryInterface</b> in response to a request for <b>IID_IUnknown</b> (the interface ID for <b>IUnknown</b>) should have the same pointer value at all times and from all interfaces on that instance. This is not required of any other interface. This pointer value is the instance's <i>identity</i>. The identity of an object is the way in which one compares two objects to see if they are actually the same one. This can be found only by comparing the <b>IUnknown</b> interface pointers. You can find the identity of the object behind any interface by first doing a <b>QueryInterface</b> for <b>IUnknown</b> and then comparing the pointers.<br><br></li>
<li>
Each <i>interface</i> has a nominal reference count associated with it. When a piece of code <i>receives</i> an interface, it should assume the reference count is notionally 1 unless it has other knowledge. <b>AddRef</b> increments the count, <b>Release</b> decrements it. When the client has made one more call to <b>Release</b> than to <b>AddRef</b> (meaning that the nominal count is zero), then it must assume that the interface pointer is invalid. The provider of the interface may choose to invalidate the interface pointer at that point (or not), but not before. Some implementations have more relaxed behavior (for example, sharing reference counts for all interfaces and/or only invalidating interface pointers when the object is freed), but such behavior is not required, and should certainly not be depended on. Although <b>AddRef</b> and <b>Release</b> return a ULONG, the value returned is not required to have any meaning. Client code should not depend in any way on the value returned. It exists solely for debugging code to use, typically to return the new object reference count.</li>
</ul>
<p>
The reference-counting rules are very simple. When a client calls a member function and passes one or more interface pointers:
<ul type=disc>
<li>
The callee should <b>AddRef</b> its interface parameters if it wants them to stay around after it has gone.<br><br></li>
<li>
The caller should <b>Release</b> the callee's returned interfaces when it is done with them.</li>
</ul>
<p>
A straightforward consequence of the above rules is that <b>QueryInterface</b> does an implicit <b>AddRef</b> on the returned interface, as do the application programming interfaces (APIs) that create objects, such as <b>CoCreateInstance</b>.</p>
<h3>Reference-Counting</h3>
<p>
In spite of the straightforward rules, getting the reference-counting right requires some care. Programmers coming from languages that do garbage collection have a similar problem with remembering to free heap blocks. From the reference-counting viewpoint, an interface pointer is a heap block that multiple people are using, so they all have to stake a claim to it, and all have to free it when they're done.</p>
<h4>Bug detection</h4>
<p>
What typically goes wrong is that one user forgets to stake that claim (with <b>AddRef</b>), or forgets to <b>Release</b> it when he or she is done. When that happens there's no obvious way to find out who was responsible.</p>
<p>
A surplus <b>AddRef</b> can be detected late by watching the return value of <b>Release</b> (debug only) and Asserting that it reaches zero when expected. This can be done when an object is releasing an aggregated object (see below) during its own release, or a contained object that it knows should not be externally referenced. I use a macro, <b>ReleaseLast</b>, which asserts that the <b>Release </b>returns zero.</p>
<p>
A surplus <b>Release</b> can be detected by zeroing out the vtable pointer of the <b>Released</b> interface or object when the reference count reaches zero. Obviously this works better with interface-specific reference counts than when all the object's interfaces are sharing a reference count. I just zero memory when I free it. It's also generally a good idea to zero interface pointers when you release them, as in most circumstances you do not know whether they will be valid afterward or not. This will often detect surplus <b>Releases</b> when they happen rather than later.</p>
<h4>Bug avoidance</h4>
<p>
Like a lot of programming issues, avoidance is mostly a matter of good programming practices and conventions. Many interface uses follow the pattern:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;<b>QueryInterface</b> () // (or some other function or method that returns 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; an interface pointer)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...some method calls ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> ().
</code></pre>
<p>
A good practice is to keep these lines as close together as possible. I tend to use extra indentation for a zone of code where there is a temporary <b>AddRef</b> outstanding. The same advice can be applied to any kind of resource management.</p>
<h3>Boxology</h3>
<p>
COM has its own visual notation, which looks like this:</p>
<p>
<img src="com_co_2.gif" border=0></p>
<p>
These diagrams represent the connectivity between instances of COM objects in an active system. This is quite different from class hierarchies in C++, or flowcharts in procedural programming. The square boxes represent object instancesspecifically the <i>data</i> encapsulated by an object and usually a label identifying the class of the code associated with it.</p>
<p>
The small circles represent individual interfaces exposed by an object, of which there may be many. An arrow represents a <i>use</i> of an interface, of which there may also be many. In this diagram, object A uses the <b>IFoo</b> interface on object B.</p>
<p>
I was amused to learn recently that some people refer to the interface pictures as "lollipops."</p>
<h2>Building a COM Component</h2>
<p>
So, putting all this together, here is a simple COM class, OUTSIDE.C:</p>
<p>
<img src="com_co_3.gif" border=0></p>
<p>
This one implements <b>IUnknown</b> and <b>IFoo;</b> <b>IFoo</b> has members to set and get a value. It's not a very interesting class. I should point out that it is, intentionally, mostly COM mechanism. A reasonable COM class has an overhead of about a page of code, but this is roughly constant.</p>
<p>
Each member function uses the <b>IMPL</b> macro to get from the interface pointer to the <b>COutside</b> instance data. We call the result "this" because it matches closely what C++ does for you. <b>FooQueryInterface</b> returns a pointer to the <b>IFoo</b> interface structure in response to <b>IID_IUnknown</b> or <b>IID_IFoo</b>. If the IID is not either of those, it return E_NOINTERFACE and zeros its out parameter, <i>ppv</i> (as required by the interface specification). Note that we are using the fact that all interfaces are "prefixed" with the <b>IUnknown</b> methods to implement <b>IUnknown</b> for free, thus these two interfaces are also sharing the reference count. (It is important to remember that two or more interfaces sharing a single reference count is an implementation detail of the object. Users of COM objects, however, must always assume interface counting is per-interface.)</p>
<p>
The <b>typedef</b> ... <b>COutside</b> describes the layout of the instance data for this class of object, and the <b>CreateOutside</b> function allocates this structure and fills it in. The <b>QueryInterface</b> call at the end allows the created object to return the requested interface. The <b>Release</b> afterwards causes the object to be deallocated again if the interface requested was not available.</p>
<p>
The <b>CreateOutside</b> function has a signature that makes it suitable for use in a generic class factory. The class factory may be associated with a CLSID (Class ID) that eventually appears in the system registry. A class factory is an object that exists to create instances of other objects. It exists to separate the process of finding a class implementation from the process of creating instances. The CLSID is a 16-byte number that uniquely identifies the class (and thus its class factory). These are described later in more detail.</p>
<p>
The <b>CreateOutside</b> function is the only "extern" object here: We declare other functions static so that we can use the file as the unit of scoping. Static functions do not interfere with other code, so we can be a little more relaxed about Hungarian notation than would otherwise be necessary in C. (Note that in the code samples that follow, I've highlighted sections deserving special attention with rows of dashes.)</p>
<pre><code>#include "<b>util.h</b>"
#include "<b>ifoo.h</b>"

typedef struct
{
 &nbsp;&nbsp; IFoo <b>ifoo</b>;
 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; int <b>value</b>;
} <b>COutside</b>;

static HRESULT <b>FooQueryInterface</b> (IFoo *<b>pfoo</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown) || <b>IsEqualIID</b> (riid, &amp;IID_IFoo))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ifoo;
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
//--------------------------------------------------------------------
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
\\--------------------------------------------------------------------
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; AddRef</b> ((IUnknown *)*ppv);
 &nbsp;&nbsp; return NOERROR;
}

static ULONG <b>FooAddRef</b> (IFoo *<b>pfoo</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; return ++this-&gt;cRef;
}

static ULONG <b>FooRelease</b> (IFoo *<b>pfoo</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; if (--this-&gt;cRef == 0)
 &nbsp;&nbsp; {
//--------------------------------------------------------------------
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;
\\--------------------------------------------------------------------

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRef;
}

static HRESULT <b>FooSetValue</b> (IFoo *<b>pfoo</b>, int <b>value</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;value = value;
 &nbsp;&nbsp; return NOERROR;
}

static HRESULT <b>FooGetValue</b> (IFoo *<b>pfoo</b>, int *<b>pValue</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; if (!pValue)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp; *pValue = this-&gt;value;
 &nbsp;&nbsp; return NOERROR;
}

//--------------------------------------------------------------------
static IFooVtbl <b>vtblFoo</b> =
{
 &nbsp;&nbsp; <b>FooQueryInterface</b>, <b>FooAddRef</b>, <b>FooRelease</b>,
 &nbsp;&nbsp; <b>FooSetValue</b>,
 &nbsp;&nbsp; <b>FooGetValue</b>
};
\\--------------------------------------------------------------------

HRESULT <b>CreateOutside</b> (IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp; if (hr = <b>Alloc</b> (sizeof (COutside), &amp;this))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
//--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;ifoo.lpVtbl = &amp;<b>vtblFoo</b>;
 &nbsp;&nbsp; this-&gt;cRef = 1;
 &nbsp;&nbsp; this-&gt;value = 0;
 &nbsp;&nbsp; ++<b>vcObjects</b>;
 &nbsp;&nbsp; hr = <b>QueryInterface</b> (&amp;this-&gt;ifoo, riid, ppv);

<b> &nbsp;&nbsp; Release</b> (&amp;this-&gt;ifoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; return hr;
}
</code></pre>
<p>
In the creation function above, we initialize the reference count to 1 so that should the initial <b>QueryInterface</b> fail, the subsequent <b>Release</b> will cleanly deallocate the object.</p>
<p>
For comparison, here's the same class in C++:</p>
<pre><code>#include "<b>ifoo.h</b>"

extern "C" int <b>vcObjects</b>;

struct <b>COutside </b>: IFoo
{
//--------------------------------------------------------------------
//&nbsp;&nbsp;&nbsp; IUnknown methods
 &nbsp;&nbsp; HRESULT __stdcall <b>QueryInterface</b> (REFIID <b>riid</b>, void **<b>ppv</b>);
 &nbsp;&nbsp; ULONG __stdcall <b>AddRef</b> (void);

<b> &nbsp;&nbsp; </b>ULONG<b> </b>__stdcall <b>Release</b> (void);

//&nbsp;&nbsp;&nbsp; IFoo methods
 &nbsp;&nbsp; HRESULT __stdcall <b>SetValue</b> (int <b>value</b>);
 &nbsp;&nbsp; HRESULT __stdcall <b>GetValue </b>(int *<b>pvalue</b>);

 &nbsp;&nbsp; <b>COutside</b> (void);
\\--------------------------------------------------------------------

 &nbsp;&nbsp; int <b>m_cRef</b>;
 &nbsp;&nbsp; int <b>m_value</b>;
};

HRESULT COutside::<b>QueryInterface</b> (REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; if (riid == IID_IUnknown || riid == IID_IFoo)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IFoo *) this;
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; 

<b> &nbsp;&nbsp; </b>((IUnknown *)*ppv)-&gt;<b>AddRef</b> ();
 &nbsp;&nbsp; return NOERROR;
}

ULONG COutside::<b>AddRef</b> (void)
{
 &nbsp;&nbsp; return ++<b> </b>m_cRef;
}

ULONG COutside::<b>Release</b> (void)
{
 &nbsp;&nbsp; if (--m_cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;

<b> &nbsp;&nbsp; </b> &nbsp;&nbsp; <b>delete</b> this;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return m_cRef;
}

HRESULT COutside::<b>SetValue</b> (int <b>v</b>)
{
 &nbsp;&nbsp; m_value = v;
 &nbsp;&nbsp; return NOERROR;
}

HRESULT COutside::<b>GetValue</b> (int *<b>pv</b>)
{
 &nbsp;&nbsp; if (!pv)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp; *pv = m_value;
 &nbsp;&nbsp; return NOERROR;
}

inline COutside::<b>COutside</b> (void)
{
 &nbsp;&nbsp; m_cRef = 1;
 &nbsp;&nbsp; m_value = 0;
 &nbsp;&nbsp; ++<b>vcObjects</b>;
}

extern "C" HRESULT <b>CreateOutside</b> (IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>pout</b>;
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp; if (!(pout = <b>new</b> COutside))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_OUTOFMEMORY;
 &nbsp;&nbsp; HRESULT hr = pout-&gt;<b>QueryInterface</b> (riid, ppv);

<b> &nbsp;&nbsp; </b>pout-&gt;<b>Release</b> ();
 &nbsp;&nbsp; return hr;
}
</code></pre>
<p>
This example looks smaller and cleaner than the equivalent C code. There are several things to notice:
<ul type=disc>
<li>
The class declaration, <b>COutside</b>, is in the C++ source file, not a header file. This is because the implementation is private and COM does not encourage classes to share implementation with inheritance.<br><br></li>
<li>
We have to list the call signature of every member function that we implement in the class declaration (which means all of them) and again when we write the code.<br><br></li>
<li>
We don't have to initialize the vtable, as we do in C.<br><br></li>
<li>
We don't have to set up or use the <b>this</b> pointers in this simple example.<br><br></li>
<li>
The class name, <b>COutside</b>, is joined with the member names and the member names are "extern", so implementation class names have to be unique across the whole DLL/EXE being implemented and across any libraries it includes. In C, the creation function is the only extern symbol, and it is used only in one place, so giving it a long name is not a real burden.</li>
</ul>
<p>
The generated executable code for the C and C++ examples are almost identical. </p>
<p>
Here is some sample code that uses the class:</p>
<pre><code>#include "util.h"
#include "ifoo.h"

// {8836A5A0-4E8A-11ce-A6F1-00AA0037DEFB}
DEFINE_GUID(<b>CLSID_Outside</b>, 0x8836a5a0, 0x4e8a, 0x11ce, 0xa6, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0xde, 0xfb);

void <b>SomeFunction</b> ()
{
 &nbsp;&nbsp; IFoo *<b>pfoo</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; int <b>result</b>;

 &nbsp;&nbsp; hr = <b>CoCreateInstance</b> (&amp;<b>CLSID_Outside</b>, NULL, CLSCTX_SERVER, &amp;IID_IFoo,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pfoo);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfoo-&gt;lpVtbl-&gt;<b>SetValue</b> (pfoo, 42);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ....
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfoo-&gt;lpVtbl-&gt;<b>GetValue</b> (pfoo, &amp;result);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ....
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (pfoo);
}
</code></pre>
<p>
<b>CoCreateInstance</b> is a COM API which takes the CLSID for a class, finds its class factory, and calls its <b>CreateInstance</b> member. The requested interface for the newly created object is returned in <b>Pfoo</b>. The NULL parameter is described below in the section on aggregation. The <i>CLSCTX_SERVER</i> parameter can be used to constrain the contexts in which the server may run. See the OLE/COM documentation for further details. Following that and for illustrative purposes, the above code calls the <b>SetValue</b> and <b>GetValue</b> members of the <b>IFoo</b> interface on the new object and then releases the interface. Because there are no other references to the object in this case, this will cause the new object instance to be freed.</p>
<p>
Here is my UTIL.H:</p>
<pre><code>#include &lt;objbase.h&gt;

#define <b>VTABLE</b>(ob, member) (*((ob)-&gt;lpVtbl-&gt;member))

#define IUNK_VTABLE_OF(x) ((IUnknownVtbl *)((x)-&gt;lpVtbl))

#define <b>QueryInterface</b>(pif, iid, pintf) \
 &nbsp;&nbsp; (IUNK_VTABLE_OF(pif)-&gt;QueryInterface((IUnknown *)(pif), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iid, (void **)(pintf)))

#define <b>AddRef</b>(pif) \
 &nbsp;&nbsp; (IUNK_VTABLE_OF(pif)-&gt;AddRef((IUnknown *)(pif)))

#define <b>Release</b>(pif) \
....(IUNK_VTABLE_OF(pif)-&gt;Release((IUnknown *)(pif)))

// from stddef.h
#ifndef offsetof
#define <b>offsetof</b>(s,m)&nbsp; (size_t)&amp;(((s *)0)-&gt;m)
#endif

#define <b>IMPL</b>(class, member, pointer) \
 &nbsp;&nbsp; (&amp;((class *)0)-&gt;member == pointer, ((class *) (((long) pointer) - <b>offsetof</b> 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (class, member))))

extern HRESULT <b>Alloc</b> (size_t, void **ppv);
extern HRESULT <b>Free</b> (void *pv);

#define <b>QITYPE</b> HRESULT (*)(void *, REFIID, void **)
#define <b>ARTYPE</b> ULONG (*)(void *)
#define <b>RLTYPE</b> ULONG (*)(void *)

extern int <b>vcObjects</b>;
</code></pre>
<p>
<b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> are defined to enable us to leave out the <b>punk-&gt;lpVtbl-&gt; </b>at the front of every method call. The OLE headers contain macros for all members of all defined interfaces that support this abbreviation. They are of the form <b>IUnknown_QueryInterface</b>, <b>IClassFactory_CreateInstance</b>, and so on.</p>
<p>
<b>IMPL</b> is a means to get from an <i>interface </i>pointer to an <i>instance </i>pointer by subtracting the offset of the interface in the object structure. For objects with a single interface that is the first element of the structure, this subtracts zero, which compiles down to nothing. For other interfaces, it compiles to a SUB instruction that subtracts a constant from the interface pointer at the top of each member function. The <b>IMPL</b> macro is a "comma expression," which compares the pointer with a NULL pointer of the correct type, and then throws away the result. This allows the macro to be a type-safe cast from one known type to another. Because the result of the comparison is not used, it also compiles to nothing. <b>Alloc</b> and <b>Free</b> are wrappers for your favorite allocator.</p>
<p>
Here is the client example code in C++:</p>
<pre><code>#include "ifoo.h"

// {8836A5A0-4E8A-11ce-A6F1-00AA0037DEFB}
DEFINE_GUID(<b>CLSID_Outside</b>, 0x8836a5a0, 0x4e8a, 0x11ce, 0xa6, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0xde, 0xfb);

void <b>SomeFunction</b> ()
{
 &nbsp;&nbsp; IFoo *<b>pfoo</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; int <b>result</b>;

 &nbsp;&nbsp; hr = <b>CoCreateInstance</b>(<b>CLSID_Outside</b>, NULL, CLSCTX_SERVER, IID_IFoo, &amp;pfoo);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfoo-&gt;<b>SetValue</b>(42);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ....
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfoo-&gt;<b>GetValue</b>(&amp;result);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ....
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfoo-&gt;<b>Release</b>();
}
</code></pre>
<p>
Notice that in C++, the calls look a little tidier: The vtable indirection is hidden, and <i>const &amp;</i> arguments are used to pass CLSIDs and IIDs around.</p>
<h3>Class Factories and COM Servers</h3>
<p>
A client can always call <b>CreateOutside</b> directly to create an instance of the class, but doing so wires in the assumption that a particular implementation will be used, and also that it will be linked with the client code. The COM mechanisms make it possible to be more flexible about locating <b>Outside</b>.</p>
<p>
<img src="com_co_4.gif" border=0></p>
<p>
COM separates the steps of identifying the code for a class (which involves a lookup in the system registry) from the process of creating an instance of that class, which involves indirectly calling <b>CreateOutside</b> in this case.</p>
<p>
The code may reside in a dynamic-link library (DLL), the current .DLL or .EXE, another .EXE, or on another machine. When you call <b>CoCreateInstance</b>, COM figures out from the registry which will be the nearest at hand.</p>
<p>
What about the lookup cost of <b>CoCreateInstance</b>? <b>CoCreateInstance</b> is actually just a wrapper for <b>CoGetClassObject</b> and a call to <b>IClassFactory::CreateInstance</b>. If you know you're going to be creating <b>Outsides</b> often, but don't want to wire in unnecessary assumptions, you can cache the registry lookup by holding onto the class factory pointer:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;hr = <b>CoGetClassObject</b> (&amp;<b>CLSID_Outside</b>, CLSCTX_INPROC_SERVER, NULL, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;IID_IClassFactory, &amp;pcfFoo);
 &nbsp;&nbsp; if (pcfFoo)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcfFoo-&gt;<b>LockServer</b> (pcfFoo, TRUE);
 &nbsp;&nbsp; // ....
 &nbsp;&nbsp; while (1)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcfFoo-&gt;lpVtbl-&gt;<b>CreateInstance</b> (pcfOutside, 0, &amp;IID_IFoo, &amp;pfoo);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // .....
 &nbsp;&nbsp; }
</code></pre>
<p>
It is rare for this to be worth the effortthe class factory lookup is not expensive, though if you're creating <b>Outside</b>s very often, it might be significant. Your mileage may vary.</p>
<p>
If you keep hold of a class factory, it's important to call <b>IClassFactory::LockServer</b>, because a reference count on a class factory is not sufficient to keep a remote server running. This is a rare exception in COM. If you do not call <b>LockServer</b>, the server may shut down, after which calls to <b>CreateInstance</b> may fail.</p>
<p>
The registry entry (OUTSIDE.REG) for <b>Outside</b> looks like this:</p>
<pre><code>REGEDIT
HKEY_CLASSES_ROOT\CLSID\{8836A5A0-4E8A-11ce-A6F1-00AA0037DEFB} = <b>Outside</b>
HKEY_CLASSES_ROOT\CLSID\{8836A5A0-4E8A-11ce-A6F1-00AA0037DEFB}\InprocServer32 = outside.dll
</code></pre>
<p>
You can enter this data by double-clicking the file in File Manager or by adding keys in REGEDIT. OUTSIDE.DLL is the DLL that contains the in-process server implementation of <b>Outside</b> (and its class factory).</p>
<p>
Here is OUTDLL.C:</p>
<pre><code>#include "util.h"
#include &lt;initguid.h&gt;
#include "ifoo.h"

// {8836A5A0-4E8A-11ce-A6F1-00AA0037DEFB}
DEFINE_GUID(<b>CLSID_Outside</b>, 0x8836a5a0, 0x4e8a, 0x11ce, 0xa6, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0xde, 0xfb);

static IClassFactory *<b>vpcfOutside</b> = 0;
int <b>vcObjects</b> = 0;

HRESULT <b>DllGetClassObject</b> (REFCLSID <b>rclsid</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (<b>IsEqualCLSID</b> (rclsid, &amp;<b>CLSID_Outside</b>))
 &nbsp;&nbsp; {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!<b>vpcfOutside</b>)

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>{

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>HRESULT <b>hr</b> =<b> CreateClassFactory</b> (&amp;<b>CLSID_Outside</b>, <b>CreateOutside</b>,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;IID_IClassFactory, &amp;<b>vpcfOutside</b>);

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>if (hr != NOERROR)

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>return hr;

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>}

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>return <b>QueryInterface</b> (<b>vpcfOutside</b>, riid, ppv);

<b> &nbsp;&nbsp; </b>}

<b> &nbsp;&nbsp; </b>return E_FAIL;
}

HRESULT <b>DllCanUnloadNow</b> ()
{

<b> &nbsp;&nbsp; </b>return <b>vcObjects</b> == 0 ? S_OK : S_FALSE;
}
</code></pre>
<p>
How, then, does one build a class factory? Here is an example implementation. This one is not specific to a particular class, so it will serve for most in-process servers that you might want to build:</p>
<pre><code>#include "<b>util.h</b>"

typedef struct
{
 &nbsp;&nbsp; IClassFactory <b>icf</b>;
 &nbsp;&nbsp; int <b>cRef</b>;

 &nbsp;&nbsp; HRESULT (*<b>pfnCreate</b>)(IUnknown *, REFIID, void **);
} <b>ClassFactory</b>;

static IClassFactoryVtbl <b>vtblClassFactory</b>;

static HRESULT <b>CFQueryInterface</b> (IClassFactory *<b>pcf</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; ClassFactory *<b>this</b> = IMPL (ClassFactory, icf, pcf);

 &nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>IsEqualIID</b> (riid, &amp;IID_IClassFactory))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;icf;
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; <b>AddRef</b> ((IClassFactory *)*ppv);

 &nbsp;&nbsp; return NOERROR;
}

static ULONG <b>CFAddRef</b> (IClassFactory *<b>pcf</b>)
{
 &nbsp;&nbsp; ClassFactory *<b>this</b> = IMPL (ClassFactory, icf, pcf);

 &nbsp;&nbsp; return ++this-&gt;cRef;
}

static ULONG <b>CFRelease</b> (IClassFactory *<b>pcf</b>)
{
 &nbsp;&nbsp; ClassFactory *<b>this</b> = IMPL (ClassFactory, icf, pcf);

 &nbsp;&nbsp; if ( --this-&gt; cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; return this-&gt;cRef;
}

static HRESULT <b>CreateInstance</b> (IClassFactory *<b>pcf</b>, IUnknown *<b>punkOuter</b>, REFIID 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; ClassFactory *<b>this</b> = IMPL (ClassFactory, icf, pcf);

 &nbsp;&nbsp; return (*this-&gt;pfnCreate)(punkOuter, riid, ppv);
}

static HRESULT <b>LockServer</b> (IClassFactory *<b>pcf</b>, BOOL <b>flock</b>)
{
 &nbsp;&nbsp; if (flock)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++<b>vcObjects</b>;
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;

 &nbsp;&nbsp; return NOERROR;
}

static IClassFactoryVtbl <b>vtblClassFactory</b> =
{
 &nbsp;&nbsp; <b>CFQueryInterface</b>, <b>CFAddRef</b>, <b>CFRelease</b>,
 &nbsp;&nbsp; <b>CreateInstance</b>,
 &nbsp;&nbsp; <b>LockServer</b>
};

HRESULT <b>CreateClassFactory</b> (REFCLSID <b>rclsid</b>,
 &nbsp;&nbsp; HRESULT (*<b>pfnCreate</b>)(IUnknown *, REFIID, void **), 
 &nbsp;&nbsp; REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; ClassFactory *<b>this</b>;
 &nbsp;&nbsp; HRESULT hr;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (hr = <b>Alloc</b> (sizeof (ClassFactory), &amp;this))
 &nbsp;&nbsp; return hr;

 &nbsp;&nbsp; this-&gt;icf.lpVtbl = &amp;<b>vtblClassFactory</b>;
 &nbsp;&nbsp; this-&gt;cRef = 1;

 &nbsp;&nbsp; this-&gt;pfnCreate = pfnCreate;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; hr = <b>QueryInterface</b> (&amp;this-&gt;icf, riid, ppv);
 &nbsp;&nbsp; <b>Release</b> (&amp;this-&gt;icf);

 &nbsp;&nbsp; return hr;
}
</code></pre>
<p>
Note that the class factory does not alter the <b>vcObjects</b> global object count, and thus does not prevent the DLL from being unloaded merely by existing.</p>
<p>
Simply <i>becoming</i> an in-process COM server does not require you to link with any extra libraries or load any DLLs. <i>Using</i> a COM object obtained from <b>CoCreateInstance</b> requires that the OLE libraries be linked to obtain the <b>CoCreateInstance</b> function.</p>
<p>
The size of the COM server DLL built above is 3552 bytes; 336 bytes of this is the actual object implementation. The rest is constant DLL overhead.</p>
<p>
The story for EXEs is a little different. When the EXE is ready to expose a class factory, it needs to register it using the <b>CoRegisterClassObject</b> function (and use <b>CoRevokeClassObject</b> when it is ready to shut down). This requires linking with OLE32.LIB and will load the corresponding DLL.</p>
<h3>COM Objects with More Than One Interface</h3>
<h4>C techniques</h4>
<p>
Building a COM object that supports more than one interface is straightforward. The simplest version is shown below in order to introduce the concepts, and the differences from the previous example are marked with rows of dashes. Following this code is a recommended refinement, which is best understood after looking first at this code.</p>
<p>
<img src="com_co_5.gif" border=0></p>
<p>
In the code below, another interface object is added to the instance structure, <b>FooQueryInterface</b> gets a clause to expose it, the methods are implemented, the vtable is declared, and the interface is initialized in the creation function. You'll notice that we end up implementing another set of the <b>IUnknown</b> methods for <b>IBaz</b>. We reuse the implementation in <b>IFoo</b> by <i>delegating</i> these calls to those functions. This is irksome: Although it would be straightforward to define a macro to make this a one-liner, that doesn't save the increase in EXE size.</p>
<pre><code>#include "<b>util.h</b>"
#include "<b>ifoo.h</b>"
//--------------------------------------------------------------------
#include "<b>ibaz.h</b>"
\\--------------------------------------------------------------------

typedef struct
{
 &nbsp;&nbsp; IFoo <b>ifoo</b>;
//--------------------------------------------------------------------
 &nbsp;&nbsp; IBaz <b>ibaz</b>;
\\--------------------------------------------------------------------
 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; int <b>value</b>;
} <b>COutside</b>;

static HRESULT <b>FooQueryInterface</b> (IFoo *<b>pfoo</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown) || <b>IsEqualIID</b> (riid, &amp;IID_IFoo))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ifoo;
//--------------------------------------------------------------------
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IBaz))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ibaz;
\\--------------------------------------------------------------------
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; AddRef</b> ((IUnknown *)*ppv);
 &nbsp;&nbsp; return NOERROR;
}

static ULONG <b>FooAddRef</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; return ++this-&gt;cRef;
}

static ULONG <b>FooRelease</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (--this-&gt;cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRef;
}

static HRESULT <b>SetValue</b> (IFoo *<b>pfoo</b>, int <b>value</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; this-&gt;value = value;
 &nbsp;&nbsp; return NOERROR;
}

static HRESULT <b>GetValue</b> (IFoo *<b>pfoo</b>, int *<b>pValue</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (!pValue)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp; *pValue = this-&gt;value;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return NOERROR;
}

static IFooVtbl <b>vtblFoo</b> =
{
 &nbsp;&nbsp; <b>FooQueryInterface</b>, <b>FooAddRef</b>, <b>FooRelease</b>,
 &nbsp;&nbsp; <b>SetValue</b>,
 &nbsp;&nbsp; <b>GetValue</b>
};

//--------------------------------------------------------------------
static HRESULT <b>BazQueryInterface</b> (IBaz *<b>pbaz</b>, REFIID r<b>i</b>id, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ibaz, pbaz);
 &nbsp;&nbsp; return QueryInterface (&amp;this-&gt;ifoo, riid, ppv);
}

static ULONG <b>BazAddRef</b> (IBaz *<b>pbaz</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ibaz, pbaz);
 &nbsp;&nbsp; return AddRef (&amp;this-&gt;ifoo);
}

static ULONG <b>BazRelease</b> (IBaz *<b>pbaz</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ibaz, pbaz);
 &nbsp;&nbsp; return Release (&amp;this-&gt;ifoo);
}

static HRESULT <b>SquareValue</b> (IBaz *<b>pbaz</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ibaz, pbaz);
 &nbsp;&nbsp; this-&gt;value *= this-&gt;value;
 &nbsp;&nbsp; return NOERROR;
}

static IBazVtbl <b>vtblBaz</b> =
{
 &nbsp;&nbsp; <b>BazQueryInterface</b>, <b>BazAddRef</b>, <b>BazRelease</b>,
 &nbsp;&nbsp; <b>SquareValue</b>
};
\\--------------------------------------------------------------------

HRESULT <b>CreateOutside</b> (IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (hr = <b>Alloc</b> (sizeof (COutside), &amp;this))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; this-&gt;ifoo.lpVtbl = &amp;<b>vtblFoo</b>;
//--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;ibaz.lpVtbl = &amp;<b>vtblBaz</b>;
\\--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;cRef = 1;
 &nbsp;&nbsp; this-&gt;value = 0;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ++<b>vcObjects</b>;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; hr = <b>QueryInterface</b> (&amp;this-&gt;ifoo, riid, ppv);

<b> &nbsp;&nbsp; Release</b> (&amp;this-&gt;ifoo);
 &nbsp;&nbsp; return hr;
}
</code></pre>
<p>
<b>The recommended method</b></p>
<p>
One can write <b>IUnknown</b> methods that are able to deduce which interface they are called from, and use the same methods in every vtable. This is not expressible in C++, though the adjuster thunks used in multiple inheritance are fairly cheap.</p>
<p>
In the example below, the <b>FindImpl</b> function replaces the <b>IMPL</b> macro in the <b>IUnknown</b> members (all other members continue to use <b>IMPL</b>). <b>FindImpl</b> steps back through the instance structure until it finds the <b>IUnknown</b> vtable. Thus, that vtable needs to be the first in the class structure, and they need to be contiguous. This does introduce some extra cost to the <b>IUnknown</b> methods. Some benchmarking of common usage will show the degree to which this is significant. Note that the other methods on the interfaces continue to use the <b>IMPL</b> macro, and thus do not pay this cost.</p>
<p>
Here is the implementation of <b>FindImpl</b>:</p>
<pre><code>__inline void *<b>FindImpl</b> (void *<b>punkPassed</b>, void *<b>lpVtblFirst</b>)
{
 &nbsp;&nbsp; void **<b>punkVtbl</b> = (void **)punkPassed;
 &nbsp;&nbsp; while (*punkVtbl != lpVtblFirst)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --punkVtbl;
 &nbsp;&nbsp; return punkVtbl;
}
</code></pre>
<p>
When you have only a couple interfaces, you could check the <b>lpVtbl</b> pointer directly, though <b>FindImpl</b> is generally cheap enough.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;Foo *<b>this</b> = (pfoo-&gt;lpVtbl == &amp;vtblFoo) ?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPL (Foo, ifoo, pfoo) : 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPL (Foo, ibaz, (IBaz *)pfoo);
</code></pre>
<p>
<b>FindImpl</b> is inlined because the inline expansion is only 10 percent larger than a call to it and involves executing half as many instructions.</p>
<p>
Here is the code for OUTSIDE2.C:</p>
<pre><code>#include "<b>util.h</b>"
#include "<b>ifoo.h</b>"
#include "<b>ibaz.h</b>"

typedef struct
{
 &nbsp;&nbsp; IFoo <b>ifoo</b>;
 &nbsp;&nbsp; IBaz <b>ibaz</b>;
 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; int <b>value</b>;
} <b>COutside</b>;

//--------------------------------------------------------------------
static IFooVtbl <b>vtblFoo</b>;
\\--------------------------------------------------------------------

static HRESULT <b>OutsideQueryInterface</b> (IFoo *<b>pfoo</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown) || <b>IsEqualIID</b> (riid, &amp;IID_IFoo))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ifoo;
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IBaz))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ibaz;
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; AddRef</b> ((IUnknown *)*ppv);
 &nbsp;&nbsp; return NOERROR;
}

static ULONG <b>OutsideAddRef</b> (IFoo *<b>pfoo</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; return ++this-&gt;cRef;
}

static ULONG <b>OutsideRelease</b> (IFoo *<b>pfoo</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (--this-&gt;cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRef;
}

static HRESULT <b>SetValue</b> (IFoo *<b>pfoo</b>, int <b>value</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; this-&gt;value = value;
 &nbsp;&nbsp; return NOERROR;
}

static HRESULT <b>GetValue</b> (IFoo *<b>pfoo</b>, int *pValue)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (!pValue)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp; *pValue = this-&gt;value;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return NOERROR;
}

static IFooVtbl <b>vtblFoo</b> =
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; (QITYPE)<b> OutsideQueryInterface</b>,
 &nbsp;&nbsp; (ARTYPE)<b> OutsideAddRef</b>,
 &nbsp;&nbsp; (RLTYPE)<b> OutsideRelease</b>,
\\--------------------------------------------------------------------
 &nbsp;&nbsp; <b>SetValue</b>,
 &nbsp;&nbsp; <b>GetValue</b>
};


static HRESULT <b>SquareValue</b> (IBaz *<b>pbaz</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ibaz, pbaz);
 &nbsp;&nbsp; this-&gt;value *= this-&gt;value;
 &nbsp;&nbsp; return NOERROR;
}

static IBazVtbl <b>vtblBaz</b> =
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; (QITYPE)<b> OutsideQueryInterface</b>,
 &nbsp;&nbsp; (ARTYPE)<b> OutsideAddRef</b>,
 &nbsp;&nbsp; (RLTYPE)<b> OutsideRelease</b>,
\\--------------------------------------------------------------------
 &nbsp;&nbsp; <b>SquareValue</b>
};

HRESULT <b>CreateOutside</b> (IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (hr = <b>Alloc</b> (sizeof (COutside), &amp;this))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; this-&gt;ifoo.lpVtbl = &amp;<b>vtblFoo</b>;
 &nbsp;&nbsp; this-&gt;ibaz.lpVtbl = &amp;<b>vtblBaz</b>;
 &nbsp;&nbsp; this-&gt;cRef = 1;
 &nbsp;&nbsp; this-&gt;value = 0;
 &nbsp;&nbsp; ++<b>vcObjects</b>;
 &nbsp;&nbsp; hr = <b>QueryInterface</b> (&amp;this-&gt;ifoo, riid, ppv);

<b> &nbsp;&nbsp; Release</b> (&amp;this-&gt;ifoo);
 &nbsp;&nbsp; return hr;
}
</code></pre>
<p>
<b>Other methods</b></p>
<p>
Another alternative method is to store back pointers with each interface that point to the instance structure. Most of the OLE samples use these back pointers in every method. It might be reasonable to use them only for the <b>IUnknown</b> methods, although doing so doubles the space overhead for an interface from four to eight bytes per interface per instance. For situations where the space overhead for the interfaces themselves is too much, there are alternatives in the form of tear-off interfaces. See the section below on optimizations.</p>
<p>
<b>Implementing interface-specific reference counts in C</b></p>
<p>
If you fold together the implementation of the <b>IUnknown</b> methods, it is not obvious how interface-specific reference-counting can be achieved. Here's one way that it can be done with <b>FindImpl</b>. We provide a macro that can generate an interface index number for a given interface pointer:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;#define <b>INTERFACE_INDEX</b>(this, pfoo) \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((((char *)pfoo) - (char *)this) / sizeof(IUnknown))
</code></pre>
<p>
We then place within the object an array of interface reference counts. The debug code below will assert whether an interface is released one time too many:</p>
<pre><code>typedef struct
{
 &nbsp;&nbsp; IFoo <b>ifoo</b>;
 &nbsp;&nbsp; IBaz <b>ibaz</b>;
//--------------------------------------------------------------------
#ifdef DEBUG
 &nbsp;&nbsp; int <b>cRefs</b>[2];
#endif
\\--------------------------------------------------------------------
 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; int <b>value</b>;
} <b>COutside</b>;

//--------------------------------------------------------------------
static IFooVtbl <b>vtblFoo</b>;
\\--------------------------------------------------------------------

static ULONG <b>OutsideAddRef</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);

//--------------------------------------------------------------------
#ifdef DEBUG
 &nbsp;&nbsp; ++this-&gt;cRefs[INTERFACE_INDEX (this, pfoo)];
#endif
\\--------------------------------------------------------------------
 &nbsp;&nbsp; return ++this-&gt;cRef;
}

static ULONG <b>OutsideRelease</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; 
//--------------------------------------------------------------------
#ifdef DEBUG
 &nbsp;&nbsp; if (--this-&gt;cRefs[INTERFACE_INDEX (this, pfoo)] &lt; 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT (FALSE);
#endif
\\--------------------------------------------------------------------
 &nbsp;&nbsp; if (--this-&gt;cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRef;
}
</code></pre>
<h4>C++ techniques</h4>
<p>
There are two major techniques for implementing multiple interfaces in C++, which may be used separately or in combination: multiple inheritance and nested classes.</p>
<p>
<b>Multiply inherit each interface</b></p>
<p>
The most direct method is to multiply inherit from all of the interfaces. Much of the time this is very convenient:</p>
<pre><code>class <b>COutside</b> : IFoo, IBaz
{
 &nbsp;&nbsp; HRESULT __stdcall <b>QueryInterface</b> (REFIID riid, void **ppv);
 &nbsp;&nbsp; ULONG __stdcall <b>AddRef</b> (void) { return ++cRef; };
 &nbsp;&nbsp; ULONG __stdcall <b>Release</b> (void);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // IFoo methods
 &nbsp;&nbsp; HRESULT __stdcall <b>SetValue</b> (int value);
 &nbsp;&nbsp; HRESULT __stdcall <b>GetValue</b> (int *pvalue);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // IBaz methods
 &nbsp;&nbsp; HRESULT __stdcall <b>SquareValue</b> ();
 &nbsp;&nbsp; 
 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; int <b>value</b>;
};

HRESULT COutside::<b>QueryInterface</b> (REFIID riid, void **ppv)
{
 &nbsp;&nbsp; if (riid == IID_IFoo)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IFoo *)this;
 &nbsp;&nbsp; else if (riid == IID_IBaz)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IBaz *)this;
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; <b>AddRef</b> ();
 &nbsp;&nbsp; return NOERROR;
}

ULONG COutside::<b>AddRef</b> (void);
{
 &nbsp;&nbsp; return ++cRef;
};

ULONG COutside::<b>Release</b> (void);
{
 &nbsp;&nbsp; if (--cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>delete</b> this;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return cRef;
};
</code></pre>
<p>
At times, there will be clashes between members from different interfaces that have the same name and signature. If a different implementation is required for these, a different technique is required. By default, C++ will generate adjuster thunks to call one implementation from every vtable.</p>
<p>
One alternative is to rename one of the interface methods by using a macro:</p>
<pre><code>#define <b>ClashingName</b> FooClashingName
#include "ifoo.h"
#define <b>ClashingName</b> BazClashingName
#include "ibaz.h"
#undef <b>ClashingName</b>
</code></pre>
<p>
Because the method names are never used outside the implementation, this causes no problems. COM defines a <i>binary</i> standard for vtablesthe method names used by the server are not significant to clients.</p>
<p>
There's another problem. When you are looking at the implementation of a method, you have no clue as to which interface it belongs to. Unless you've renamed it, you have to use its declared name. The class that it's attached to will be your outer implementation class, not the name of an interface. Thus it's advisable to use a comment convention to group methods for interfaces.</p>
<p>
<b>Nested classes</b></p>
<p>
An alternative is to use a nested class for one or more of the interfaces. A situation where this commonly occurs is when different implementations are required for the <b>IUnknown</b> methods on different interfaces. This happens when an object is aggregatable, as described below in the section on aggregation. It is desirable for most classes to be aggregatable, so this may be expected to be common.</p>
<p>
With this technique, each interface is implemented by a nested class. The outer class (<b>COutside</b> below) contains the instance data. The nested class code must be coupled to the outer class using either a back pointer or, preferably, the <b>IMPL</b> macro described earlier. A drawback of nested classes is that the C++ convenience of an implied <b>this</b> pointer at every reference is lost, causing the code to look very like the C equivalent. There's also no way to avoid the <b>IUnknown</b> delegation, as is possible in C. The Microsoft Foundation Class Library (MFC) uses nested classes with an equivalent to the <b>IMPL</b> macro for its OLE implementation.</p>
<p>
The examples in <i>Inside OLE </i>use dynamically allocated interface implementations. This is somewhat like the nested class approach, but has more overhead. This dynamic allocation is fine for pedagogical purposes because it is clear and easy to understand, but I would not recommend it for shipping code.</p>
<p>
Here's an example that shows the nested class approach:</p>
<pre><code>struct <b>COutsideCFoo</b> : IFoo
{
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; __stdcall <b>QueryInterface</b> (int iid, void **ppv);
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __stdcall <b>AddRef</b> ();
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __stdcall <b>Release</b> ();
 &nbsp;&nbsp; 
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; __stdcall <b>SetValue</b> (int);
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; __stdcall <b>GetValue</b> (int *pvalue);
};

struct <b>COutsideCBaz</b> : IBaz
{
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; __stdcall <b>QueryInterface</b> (int iid, void **ppv);
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __stdcall <b>AddRef</b> ();
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __stdcall <b>Release</b> ();

 &nbsp;&nbsp; HRESULT __stdcall <b>SquareValue</b> ();
};

struct <b>COutside</b>
{
 &nbsp;&nbsp; COutsideCFoo <b>ifoo</b>;
 &nbsp;&nbsp; COutsideCBaz <b>ibaz</b>;

 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; int <b>value</b>;
};
......
HRESULT COutsideCBaz::<b>SquareValue</b> ()
{
 &nbsp;&nbsp; COutside *<b>This</b> = IMPL (COutside, ibaz, this);
 &nbsp;&nbsp; This-&gt;value *= This-&gt;value;
 &nbsp;&nbsp; return NOERROR;
}
</code></pre>
<p>
Note that in C++, member functions have "extern" scope, so all member functions in the code must have unique names. This is so that the linker can populate vtables for derived classes in different compilation units (which is never needed with COM). For this reason, either the interface implementation classes must be nested within the <b>COutside</b> class as truly nested classes, or their names must be made globally unique, as shown here.</p>
<p>
<b>Implementing interface-specific reference counts in C++</b></p>
<p>
With nested classes, interface-specific reference counts are straightforward. Because we will be implementing distinct <b>IUnknown</b> methods that typically delegate to a distinguished implementation, each implementation can place a reference count in its nested class.</p>
<p>
With multiple inheritance, this does not work. An alternative here is to introduce an intermediate implementation for the <b>IUnknown</b> methods that calls some renamed <b>IUnknown</b> methods that the main class implements:</p>
<pre><code>struct <b>COutsideCIFoo</b> : IFoo
{
 &nbsp;&nbsp; STDMETHOD (<b>DebugQueryInterface</b>) (REFIID <b>riid</b>, void **<b>ppv</b>) = 0;
 &nbsp;&nbsp; STDMETHOD_(ULONG, <b>DebugAddRef</b>) () = 0;
 &nbsp;&nbsp; STDMETHOD_(ULONG, <b>DebugRelease</b>) () = 0;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; STDMETHODIMP <b>QueryInterface</b> (REFIID <b>riid</b>, void **<b>ppv</b>)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>DebugQueryInterface</b> (riid, ppv);
 &nbsp;&nbsp; };
 &nbsp;&nbsp; STDMETHODIMP_(ULONG) <b>AddRef</b> ()
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++cRef;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>DebugAddRef</b> ();
 &nbsp;&nbsp; }
 &nbsp;&nbsp; STDMETHODIMP_(ULONG) <b>Release</b> ()
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (--cRef &lt; 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT (FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>DebugRelease</b> ();
 &nbsp;&nbsp; }
 &nbsp;&nbsp; int cRef;
};

struct <b>COutsideCIBaz</b> : IBaz
{
//..... same as above
};

struct <b>COutside</b> : COutsideCIFoo, COutsideCIBaz
{
 &nbsp;&nbsp; STDMETHODIMP <b>DebugQueryInterface</b> (REFIID <b>riid</b>, void **<b>ppv</b>)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (riid == IID_IFoo)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IFoo *) this;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (riid == IID_IBaz)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IBaz *) this;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (riid == IID_IUnknown)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IPersist *) this;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>DebugAddRef</b> ();

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NOERROR;
 &nbsp;&nbsp; };
 &nbsp;&nbsp; STDMETHODIMP_(ULONG) <b>DebugAddRef</b> ()
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ++cRef;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; STDMETHODIMP_(ULONG) <b>DebugRelease</b> ()
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return --cRef;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; int cRef;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // IFoo methods
 &nbsp;&nbsp; ...
 &nbsp;&nbsp; // IBaz methods
};
</code></pre>
<p>
Much of the bulk here can be removed by using macros; because the <b>CIFoo</b> and <b>CIBaz</b> classes are nearly identical, they can be reduced to:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;DECLARE_DEBUG_IMPLEMENTATION (COutsideCIFoo, IFoo);
 &nbsp;&nbsp; DECLARE_DEBUG_IMPLEMENTATION (COutsideCIBaz, IBaz);
</code></pre>
<p>
In nondebug code, this would be declared:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;#define <b>DECLARE_DEBUG_IMPLEMENTATION</b>(COutsideCIFoo, IFoo) \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct COutsideCIFoo : IFoo {}
</code></pre>
<p>
Further, we would have a header file somewhere containing:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;#ifndef DEBUG
 &nbsp;&nbsp; #define <b>DebugQueryInterface</b> QueryInterface
 &nbsp;&nbsp; #define <b>DebugAddRef</b> AddRef
 &nbsp;&nbsp; #define <b>DebugRelease</b> DebugRelease
 &nbsp;&nbsp; #endif // DEBUG
</code></pre>
<h2>Connection and Composition Paradigms</h2>
<p>
A very common paradigm with COM is for two objects to be connected. One object holds an interface to another. There are even diagrammatic methods of describing this:</p>
<p>
<img src="com_co_6.gif" border=0></p>
<p>
The diagram indicates that the client holds an interface pointer to the <b>IFoo</b> interface on the server. When the client is given its <b>IFoo</b>, it calls <b>AddRef</b> on it, to hold the interface in existence. When the client no longer needs the <b>IFoo</b>, it releases it. The client should certainly do that when it is released.</p>
<h3>Containment</h3>
<p>
It is often useful when implementing a COM object to be able to use other COM objects as part of the implementation. This is straightforward. Such an object can be created during the outer object's creation function, and released during the outer object's <b>Release</b> function. Interfaces from the inner object can be used to assist in the implementation of interfaces of the outer object. This kind of containment reuse is common. Generally the contained object is not visible outside: if it is, then it would be best described as a connection relationship.</p>
<p>
<img src="com_co_7.gif" border=0></p>
<h3>Delegation</h3>
<p>
When a new object is implemented that supports a known interface suite, a good reuse of code is to use an existing class to implement some aspects of an outer class. Conceptually, the simplest way to do this is to contain the existing class, implement all the required interfaces, and <i>delegate</i> calls on the interfaces to the interfaces of the existing object, where appropriate.</p>
<p>
<img src="com_co_8.gif" border=0></p>
<p>
For example:</p>
<pre><code>static HRESULT <b>SomeMethod</b> (ISomeInterface *<b>psi</b>, int <b>a</b>, int <b>b</b>, int <b>c</b>)
{
 &nbsp;&nbsp; SomeClass *<b>this</b> = IMPL (SomeClass, isi, psi);

 &nbsp;&nbsp; return this-&gt;pold-&gt;lpVtbl-&gt;<b>SomeMethod</b> (this-&gt;pold, a, b, c);
}
</code></pre>
<p>
This is a powerful technique: The new class can retain the richness of the previous class. It can insert code before or after the call to the existing method, or simply not call the existing implementation for some methods. As far as the client is concerned, the new object is indistinguishable from the old one, so it happily continues providing its old behavior.</p>
<p>
One thing to be aware of when doing this is that the set of interfaces that a client and object share represents a <i>service agreement </i>between the two objects. This kind of contract is sometimes referred to as a <i>type</i>. Clearly, COM objects can have multiple types. The OLE embedding interfaces, <b>IOleObject</b>, <b>IDataObject</b>, and <b>IPersistStorage</b> taken together form such a type. In this particular scenario, the requirements are fairly relaxed, and most violations would simply show up as unexpected user interface behavior. In other scenarios, breaking a service agreement may cause more serious problems.</p>
<p>
If the existing object is later changed to support additional services, the containing object will continue to support only the old services. It's important to realize that if you modify the way that the contained object is called during the delegation, you must understand the services of which the interface is a part. If you interfere with the service agreement between two objects without understanding it fully, the two objects will likely not interoperate correctly.</p>
<p>
Sometimes you may wish to modify the behavior of some interfaces, but leave others alone. When this happens, implementing trivial delegators for all those other interfaces becomes irksome. It will also start using significant amounts of code space. If you have several layers of nested reuse, the cost of the extra function call at each level will begin to mount up and your system will become large and slow. The traditional solution to this has been to start collapsing some of the layers of abstraction by opening up the old class and copying the code out of it. This wins locally, by avoiding function indirections and delegator implementations, but loses globally because you end up with multiple, slightly different copies of implementations, which tend to increase your working set (generally more than the delegators would), and which have new bugs. Trivial delegators don't tend to have bugs. Fortunately, COM supports some better methods.</p>
<h4>The Universal Trivial Delegator</h4>
<p>
A Universal Trivial Delegator can be built that with a single implementation can delegate any interface with a much lower overhead than the C version above. Changing the compiler to support tail-call optimization would enable it to generate equivalent code, but would not achieve a single implementation for multiple interfaces. The example below uses some assembly code to share the stack frame and adjust the interface pointer, and does so with five instructions per method. Generally we want the <b>IUnknown</b> and other methods to be treated by different pieces of code, so the delegators separate the delegation into two targets. The <b>IUnknown</b> entries in the various "Other" interfaces below are never used by the delegators.</p>
<p>
Clearly this is a generic piece of code that should be written once and shared by a number of groups. It is platform-specific and should be shipped with an SDK.</p>
<p>
The C declarations look like this:</p>
<pre><code>typedef struct
{
 &nbsp;&nbsp; struct _IDelegatorVtbl *<b>lpVtbl</b>;
} <b>IDelegator</b>;

typedef struct _IDelegatorVtbl
{
 &nbsp;&nbsp; int (*<b>fn</b>[64])(IDelegator *<b>pdel</b>);
} <b>IDelegatorVtbl</b>;
// ....
typedef struct
{
 &nbsp;&nbsp; IDelegator <b>idel</b>;
 &nbsp;&nbsp; IUnknown <b>iunkUnknown</b>;
 &nbsp;&nbsp; IUnknown <b>iunkOther</b>;
} <b>Delegator</b>;

typedef struct
{
 &nbsp;&nbsp; IDelegatorIndirect <b>idel</b>;
 &nbsp;&nbsp; IUnknown *<b>punkUnknown</b>;
 &nbsp;&nbsp; IUnknown *<b>punkOther</b>;
} <b>IndirectDelegator</b>;

typedef struct
{
 &nbsp;&nbsp; IDelegator <b>idel</b>;
 &nbsp;&nbsp; IUnknown <b>iunkUnknown</b>;
 &nbsp;&nbsp; IUnknown *<b>punkOther</b>;
} <b>MethodIndirectDelegator</b>;

typedef struct
{
 &nbsp;&nbsp; IDelegatorIndirect <b>idel</b>;
 &nbsp;&nbsp; IUnknown *<b>punkUnknown</b>;
 &nbsp;&nbsp; IUnknown <b>iunkOther</b>;
} <b>UnknownIndirectDelegator</b>;

extern IDelegatorVtbl <b>VtblDelegator</b>;
extern IDelegatorIndirectVtbl <b>VtblIndirectDelegator</b>;
extern IDelegatorMethodIndirectVtbl <b>VtblMethodIndirectDelegator</b>;
extern IDelegatorUnknownIndirectVtbl <b>VtblUnknownIndirectDelegator</b>;
</code></pre>
<p>
The Intel® assembly code for each (direct) <b>IUnknown</b> method looks like this:</p>
<pre><code>_del$ = 8
name2 PROC NEAR
 &nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; eax, DWORD PTR _del$[esp-4]&nbsp;&nbsp;&nbsp; ; pull interface pointer from stack
 &nbsp;&nbsp; add&nbsp;&nbsp;&nbsp; eax, 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; adjust by offsetof(Delegator, iunkUnknown)
 &nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; DWORD PTR _del$[esp-4], eax&nbsp;&nbsp;&nbsp; ; return interface pointer to stack
 &nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; eax, DWORD PTR [eax]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; load the lpVtbl pointer from it
 &nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD PTR [eax+offset*4]&nbsp;&nbsp;&nbsp;&nbsp; ; jump indirect to to the member function at offset
name2 ENDP
</code></pre>
<p>
The indirect code for each <b>IUnknown</b> method looks like this:</p>
<pre><code>_del$ = 8
name PROC NEAR
 &nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; eax, DWORD PTR _del$[esp-4]&nbsp;&nbsp;&nbsp;&nbsp; ; pull interface pointer from stack
 &nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; eax, DWORD PTR [eax+4]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; pull delegating interface pointer 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (punkUnknown) from just after it
 &nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; DWORD PTR _del$[esp-4], eax&nbsp;&nbsp;&nbsp;&nbsp; ; return interface pointer to stack
 &nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; eax, DWORD PTR [eax]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; load the lpVtbl pointer from it
 &nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; DWORD PTR [eax+offset*4] ]&nbsp;&nbsp;&nbsp;&nbsp; ; jump indirect to to the member 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function at offset
name ENDP
</code></pre>
<p>
To use these delegators, include one in the class structure, initialize its <b>idel</b> member with the appropriate <b>VtblDelegator</b>, and fill in either the <b>IUnknownVtbl</b> or <b>IUnknown</b> pointers with your own vtable or interface pointer as appropriate.</p>
<p>
An example follows. Here we arrange to create an object of class <b>CLSID_Inside</b> to provide the implementation of the <b>IFeep</b> interface of <b>COutside</b>. Here, we want the <b>IUnknown</b> methods of <b>IFeep</b> to delegate to the <b>IUnknown</b> implementation of <b>COutside</b>, and the other methods to delegate to the <b>IFeep</b> interface of <b>CInside</b>. We arrange to <b>CoCreateInstance</b> a <b>CLSID_Inside</b> in the creation function, and release it in the <b>OutsideRelease</b> member. We set up the delegator structure in <b>COutside</b> and initialize it in the creation function. The delegator structure is an interface implementation, and we can hand out its address as one of our interfaces, because the <b>IUnknown</b> methods delegate to our own <b>IUnknown</b> implementation:</p>
<pre><code>#include "<b>ifoo.h</b>"
#include "<b>ibaz.h</b>"
#include "<b>ifeep.h</b>"
#include "<b>inside.h</b>"
#include "<b>util.h</b>"
#include "<b>idelegat.h</b>"

typedef struct
{
 &nbsp;&nbsp; IFoo <b>ifoo</b>;
 &nbsp;&nbsp; IBaz <b>ibaz</b>;
 &nbsp;&nbsp; int <b>cRef</b>;
//--------------------------------------------------------------------
 &nbsp;&nbsp; IndirectDelegator <b>del</b>;
 &nbsp;&nbsp; IFeep *<b>pfeep</b>;
\\--------------------------------------------------------------------
 &nbsp;&nbsp; int <b>value</b>;
} COutside;

static HRESULT <b>OutsideQueryInterface</b> (IFoo *<b>pfoo</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>IsEqualIID</b> (riid, &amp;IID_IFoo))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ifoo;
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IBaz))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ibaz;
//--------------------------------------------------------------------
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IFeep))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;del.idel;
\\--------------------------------------------------------------------
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; AddRef</b> ((IUnknown *)*ppv);
 &nbsp;&nbsp; return NOERROR;
}

static ULONG <b>OutsideAddRef</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return ++this-&gt;cRef
}

static ULONG <b>OutsideRelease</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (--this-&gt;cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;
//--------------------------------------------------------------------
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (this-&gt;pfeep);
\\--------------------------------------------------------------------

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRef;
}
........

HRESULT <b>CreateOutside</b> (IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (hr = <b>Alloc</b> (sizeof (<b>COutside</b>), &amp;this))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; this-&gt;ifoo.lpVtbl = &amp;<b>vtblFoo</b>;
 &nbsp;&nbsp; this-&gt;ibaz.lpVtbl = &amp;<b>vtblBaz</b>;
 &nbsp;&nbsp; this-&gt;cRef = 1;

 &nbsp;&nbsp; <b>CoCreateInstance</b> (&amp;<b>CLSID_Inside</b>, CLSCTX_SERVER, NULL, &amp;IID_IFeep, &amp;this-
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;pfeep);

//--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;del.idel = <b>VtblIndirectDelegator</b>;
 &nbsp;&nbsp; this-&gt;del.punkUnknown = (IUnknown *)&amp;this-&gt;ifoo;
 &nbsp;&nbsp; this-&gt;del.punkOther = this-&gt;pfeep;
\\--------------------------------------------------------------------


 &nbsp;&nbsp; this-&gt;value = 0;
 &nbsp;&nbsp; ++<b>vcObjects</b>;
 &nbsp;&nbsp; hr = <b>QueryInterface</b> (&amp;this-&gt;ifoo, riid, ppv);
 &nbsp;&nbsp; <b>Release</b> (&amp;this-&gt;ifoo);
 &nbsp;&nbsp; return hr;
}
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Not all interfaces <i>should </i>be trivially delegated this way. Some objects have interfaces that hand out interface pointers for other objects that they manage. Think of the object as a "parent" and the handed-out interface as being a "child." When the child is created, it may be given an interface to its parent, from which it can get some services. If the object wrapping the parent trivially delegates this interface, it will hand out a child who thinks its parent is the inner object. If some external code asks the child for its parent, it will then start invoking the old implementation of the parent's behavior. At the very least, it will not be able to get to the new behavior.</p>
<p>
<img src="com_co_9.gif" border=0></P><p class=tl>
While this doesn't break any COM rules, it's unlikely to be what the interface specifications for the parent and child intended.</P><p class=tl>
If this is a problem, the outer parent can create an outer child to contain the inner parent's child. This obviously requires a little more than trivial delegation.</P><h3>Split Identities</h3>
<h4>Passing service interfaces to a contained object</h4>
<p>
At times, we need to deal with an inside object that needs some service from its outside object. Here the inside object cannot be passed an interface pointer to the outside object, as this would set up a cycle of references.</p>
<p>
<img src="com_co_10.gif" border=0></p>
<p>
The best way to deal with this is to arrange for the outer object to have two object identities accessing the same data. Although the object has two identities, because they share an implementation they are not <b>AddRef</b>ing one another, so no reference cycle occurs. The identities have separate reference counts: the strong identity will cause the outside object to "shut down" when it is finally released. The way to think about shutdown is that the outside object makes some change that will break the reference cycle. Typically this involves signaling any objects holding the weak identity to let go of it. In our example, <b>Outside </b>will release the inside object, which will cause it to let go of the weak identity when it closes. Any other objects may let go of the weak identity some considerable time later: The shared data does not actually go away until both reference counts reach zero. For more information on "strong" versus "weak" references, see the <a href="msdn_objlife.htm">"Managing Object Lifetimes in OLE"</a> technical article in the MSDN Library.</p>
<p>
The inner object needs to understand that it does not have a reference to the "real" outside/parent identity, and would need some additional service to obtain it transiently. There is not presently a standard interface for doing this, although some work is under way to establish one.</p>
<p>
For example, suppose the inner object needs the <b>IService</b> interface, and the outer object wishes to provide it. Here's how that can be done. <b>IService</b> is another identity within <b>COutside</b>. Its <b>AddRef</b> and <b>Release</b> implementations manage a separate "weak" reference count. The outer object is freed only when both counts are zero, but can initiate that process when the "strong" count reaches zero, by releasing the inner object.</p>
<p>
Some care is required with <b>Release</b> to deal with possible reentrancy: When <b>FooRelease</b> calls <b>Release</b> (<b>this-&gt;pfeep</b>), below, the inner object will turn around and release its <b>IService</b> interface. This will call <b>SvcRelease</b>, which would free the outside object if the weak reference count were zero. To prevent this, we bracket the release of weak reference holders with an extra <b>AddRef/Release</b> pair on the weak identity, which controls the resource freeing. This delays the deallocation until the outside object is ready:</p>
<pre><code>#include "<b>util.h</b>"
#include "<b>ifoo.h</b>"
#include "<b>ibaz.h</b>"
//--------------------------------------------------------------------
#include "<b>ifeep.h</b>"
#include "<b>iservice.h</b>"
#include "<b>inside.h</b>"
\\--------------------------------------------------------------------

typedef struct
{
 &nbsp;&nbsp; IFoo <b>ifoo</b>;
 &nbsp;&nbsp; IBaz <b>ibaz</b>;
 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; int <b>value</b>;
 &nbsp;&nbsp; IFeep *<b>pfeep</b>;

//--------------------------------------------------------------------
 &nbsp;&nbsp; IService <b>iservice</b>;
 &nbsp;&nbsp; int <b>cRefWeak</b>;
\\--------------------------------------------------------------------
} <b>COutside</b>;
.....
//--------------------------------------------------------------------
static ULONG <b>FooRelease</b> (IBaz *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;<b>vtblFoo</b>)
 &nbsp;&nbsp; if (--this-&gt;cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>SvcAddRef</b> (&amp;this-&gt;iservice);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;pfeep)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (this-&gt;pfeep);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>SvcRelease</b> (&amp;this-&gt;iservice);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRef;
}
\\--------------------------------------------------------------------

......
//--------------------------------------------------------------------
static HRESULT <b>SvcQueryInterface</b> (IService *<b>psvc</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, iservice, psvc);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown) || <b>IsEqualIID</b> (riid, &amp;IID_IBaz))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;iservice;
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; AddRef</b> ((IUnknown *)*ppv);
 &nbsp;&nbsp; return NOERROR;
}

static ULONG <b>SvcAddRef</b> (IService *<b>psvc</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, iservice, psvc);
 &nbsp;&nbsp; return ++this-&gt;cRefWeak;
}

static ULONG <b>SvcRelease</b> (IService *<b>psvc</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, iservice, psvc);
 &nbsp;&nbsp; if (--this-&gt;cRefWeak == 0 &amp;&amp; this-&gt;cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRefWeak;
}

static HRESULT <b>SvcExample</b> (IService *<b>psvc</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, iservice, pbaz);
 &nbsp;&nbsp; // ???
 &nbsp;&nbsp; return NOERROR;
}

static IServiceVtbl <b>vtblService</b> =
{
 &nbsp;&nbsp; (QITYPE)<b> SvcQueryInterface</b>,
 &nbsp;&nbsp; (ARTYPE)<b> SvcAddRef</b>,
 &nbsp;&nbsp; (RLTYPE)<b> SvcRelease</b>,
 &nbsp;&nbsp; <b>SvcExample</b>
};
\\--------------------------------------------------------------------
......
HRESULT <b>CreateOutside</b> (IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;

 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (hr = <b>Alloc</b> (sizeof (COutside), &amp;this))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; this-&gt;ifoo.lpVtbl = &amp;<b>vtblFoo</b>;
 &nbsp;&nbsp; this-&gt;ibaz.lpVtbl = &amp;<b>vtblBaz</b>;
 &nbsp;&nbsp; this-&gt;cRef = 1;
//--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;iservice.lpVtbl = &amp;<b>vtblService</b>;
 &nbsp;&nbsp; this-&gt;cRefWeak = 0;
\\--------------------------------------------------------------------

 &nbsp;&nbsp; this-&gt;value = 0;
 &nbsp;&nbsp; hr = <b>CoCreateInstance</b> (&amp;<b>CLSID_Inside</b>, NULL, CLSCTX_INPROC_SERVER, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;IID_IFeep, &amp;this-&gt;pfeep);

//--------------------------------------------------------------------
 &nbsp;&nbsp; if (hr == NOERROR)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pfeep-&gt;lpVtbl-&gt;<b>SetService</b> (this-&gt;pfeep, &amp;this-&gt;iservice);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = <b>QueryInterface</b> (&amp;this-&gt;ifoo, riid, ppv);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; ++<b>vcObjects</b>;

<b> &nbsp;&nbsp; Release</b> (&amp;this-&gt;ifoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return hr;
}
</code></pre>
<p>
Mutual references between multiple contained objects are not a problem because the container is in control of their lifetime and can break the cycle when it decides to shut down. References between contained objects do not hold their container alive.</p>
<p>
Another scenario in which split identities work well is in notification. The outside object may be changing the state of some object it contains, but may wish to be notified of the effect of such changes. This is particularly important if other clients can change the object's state (as would happen in a connection scenario), or if the outcome of the state change would otherwise be difficult to predict.</p>
<h4>Implementing split identities with many common interfaces</h4>
<p>
Any interfaces exposed by outside that are passed to inside must be delegated to avoid a reference cycle. If the interfaces are large or called often, this is not an attractive solution. The Universal Trivial Delegator can be used again to avoid adding delegator code, but if the inner object requires most or all of the interfaces that the outer object provides, we will have to provide two implementations of all our interfaces.</p>
<p>
Fortunately, there is another way to implement split identities that avoids delegation. Let's assume that the inner object may wish to <b>QueryInterface</b> for other interfaces that the outer supports (excluding <b>IFeep</b> . . .).</p>
<p>
This technique accesses the state of <b>COutside</b> through an indirection, <b>pOutsideThis</b>. It costs an extra indirection that most existing COM implementations are already paying by using back pointers. We can still share the <b>IUnknown</b> implementation by making it slightly smarter. We rely on <b>pOutsideThis</b> being the first element of the <b>COutsideIdentity</b> structure so that the <b>SPLIT_IMPL</b> macro can find it without depending on its name. This method is much cheaper than even the Universal Trivial Delegator discussed earlier. Here is the implementation of the <b>SPLIT_IMPL</b> macro:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;#define <b>SPLIT_IMPL</b>(outerClass, innerClass, member, pointer) \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*(outerClass **) <b>IMPL</b> (innerClass, member, pointer))
</code></pre>
<p>
It works by first using the <b>IMPL</b> macro to find the top of the structure containing the interfaces and then assuming that the first member of that structure is a back pointer to the <b>Outside </b>class structure. <b>FIND_SPLIT_IMPL</b>, the split identity equivalent of <b>FindImpl</b>, is similar. It uses <b>FindImpl</b> to find the first vtable and then finds the top of structure using offsets:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;#define <b>FIND_SPLIT_IMPL</b>(innerClass, iFirst, vtblFirst, pointer) \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((innerClass *) (((char&nbsp; *)<b>FindImpl</b> (pointer, vtblFirst)) - <b>offsetof</b> (innerClass, iFirst)))
</code></pre>
<p>
Notice that in the example below, <b>IBaz</b> is supported only on the strong identity because it requires the inner object, which will be removed when there are no longer any strong references. It is up to the split object to ensure that the weak identity has stable behavior after the strong identity has been released. There is a vtable pointer for each split interface on both identities, even if one of them isn't used. If this is too much cost, then they can be placed in <b>COutside</b> with more coding complexity.</p>
<p>
Here is FOOSPLIT.C:</p>
<pre><code>#include "<b>util.h</b>"
#include "<b>ifoo.h</b>"
#include "<b>ibaz.h</b>"
#include "<b>ifeep.h</b>"
#include "<b>iservice.h</b>"
#include "<b>inside.h</b>"

typedef struct COutside
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; struct _identity {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct COutside *<b>pOutsideThis</b>;
\\--------------------------------------------------------------------
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IFoo <b>ifoo</b>;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IBaz <b>ibaz</b>;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IService <b>iservice</b>;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int <b>cRef</b>;
//--------------------------------------------------------------------
 &nbsp;&nbsp; } <b>strong</b>, <b>weak</b>;
\\--------------------------------------------------------------------
 &nbsp;&nbsp; int <b>value</b>;
 &nbsp;&nbsp; IFeep *<b>pfeep</b>;
} <b>COutside</b>;

//--------------------------------------------------------------------
typedef struct _identity <b>COutsideIdentity</b>;
\\--------------------------------------------------------------------
static IFooVtbl <b>vtblFoo</b>;

static HRESULT <b>OutsideQueryInterface</b> (IFoo *<b>pfoo</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutsideIdentity *<b>thisId</b> = <b>FIND_SPLIT_IMPL</b>(COutsideIdentity, ifoo, &amp;vtblFoo,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfoo);
 &nbsp;&nbsp; COutside *<b>this</b> = thisId-&gt;pOutsideThis;

\\--------------------------------------------------------------------
 &nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown) || <b>IsEqualIID</b> (riid, &amp;IID_IFoo))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;thisId-&gt;ifoo;
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IBaz) &amp;&amp; thisId == &amp;this-&gt;strong)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;thisId-&gt;ibaz;
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IService) &amp;&amp; thisId == &amp;this-&gt;weak)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;thisId-&gt;iservice;
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; AddRef</b> ((IUnknown *)*ppv);
 &nbsp;&nbsp; return NOERROR;
}

static ULONG <b>OutsideAddRef</b> (IFoo *<b>pfoo</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutsideIdentity *<b>thisId</b> = <b>FIND_SPLIT_IMPL</b>(COutsideIdentity, ifoo, &amp;vtblFoo, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; return ++thisId-&gt;cRef;
}

static ULONG <b>OutsideRelease</b> (IFoo *<b>pfoo</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutsideIdentity *<b>thisId</b> = <b>FIND_SPLIT_IMPL</b>(COutsideIdentity, ifoo, &amp;vtblFoo, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfoo);
 &nbsp;&nbsp; COutside *<b>this</b> = thisId-&gt;pOutsideThis;

 &nbsp;&nbsp; if (--thisId-&gt;cRef != 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return thisId-&gt;cRef;
 &nbsp;&nbsp; if (thisId == &amp;this-&gt;strong)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>AddRef</b> (&amp;this-&gt;weak.ifoo);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;pfeep)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (this-&gt;pfeep);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (&amp;this-&gt;weak.ifoo);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else // weak identity
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;strong.cRef == 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return 0;
}
\\--------------------------------------------------------------------

static HRESULT <b>SetValue</b> (IFoo *<b>pfoo</b>, int <b>value</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = SPLIT_IMPL (COutside, COutsideIdentity, ifoo, pfoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;value = value;
 &nbsp;&nbsp; return NOERROR;
}

static HRESULT <b>GetValue</b> (IFoo *<b>pfoo</b>, int *<b>pValue</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = SPLIT_IMPL (COutside, COutsideIdentity, ifoo, pfoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; if (!pValue)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp; *pValue = this-&gt;value;
 &nbsp;&nbsp; return NOERROR;
}

static IFooVtbl <b>vtblFoo</b> =
{
 &nbsp;&nbsp; (QITYPE)<b> OutsideQueryInterface</b>, (ARTYPE)<b> OutsideAddRef</b>, (RLTYPE)<b> </b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutsideRelease</b>,
 &nbsp;&nbsp; <b>SetValue</b>,
 &nbsp;&nbsp; <b>GetValue</b>
};

static HRESULT <b>SquareValue</b> (IBaz *<b>pbaz</b>)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = SPLIT_IMPL (COutside, COutsideIdentity, ibaz, pbaz);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;value *= this-&gt;value;
 &nbsp;&nbsp; this-&gt;pfeep-&gt;lpVtbl-&gt;<b>Sum</b> (this-&gt;pfeep, this-&gt;value);

 &nbsp;&nbsp; return NOERROR;
}

static IBazVtbl <b>vtblBaz</b> =
{
 &nbsp;&nbsp; (QITYPE)<b> OutsideQueryInterface</b>, (ARTYPE)<b> OutsideAddRef</b>, (RLTYPE)<b> </b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutsideRelease</b>,
 &nbsp;&nbsp; <b>SquareValue</b>
};

static HRESULT <b>SvcExample</b> (IService *psvc)
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; COutside *<b>this</b> = SPLIT_IMPL (COutside, COutsideIdentity, iservice, psvc);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; // ???
 &nbsp;&nbsp; return NOERROR;
}

static IServiceVtbl <b>vtblService</b> =
{
 &nbsp;&nbsp; (QITYPE)<b> OutsideQueryInterface</b>, (ARTYPE)<b> OutsideAddRef</b>, (RLTYPE)<b> </b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutsideRelease</b>,
 &nbsp;&nbsp; <b>SvcExample</b>
};


HRESULT <b>CreateOutside</b> (IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp; if (hr = <b>Alloc</b> (sizeof (COutside), &amp;this))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; 
//--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;strong.pOutsideThis = this;
 &nbsp;&nbsp; this-&gt;strong.ifoo.lpVtbl = &amp;<b>vtblFoo</b>;
 &nbsp;&nbsp; this-&gt;strong.ibaz.lpVtbl = &amp;<b>vtblBaz</b>;
 &nbsp;&nbsp; this-&gt;strong.iservice.lpVtbl = &amp;<b>vtblService</b>;
 &nbsp;&nbsp; this-&gt;strong.cRef = 1;
 &nbsp;&nbsp; this-&gt;weak = this-&gt;strong;
 &nbsp;&nbsp; this-&gt;weak.cRef = 0;
\\--------------------------------------------------------------------

 &nbsp;&nbsp; this-&gt;value = 0;
//--------------------------------------------------------------------
 &nbsp;&nbsp; hr = <b>CoCreateInstance</b> (&amp;<b>CLSID_Inside</b>, NULL, CLSCTX_INPROC_SERVER, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;IID_IFeep, &amp;this-&gt;pfeep);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; if (hr == NOERROR)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pfeep-&gt;lpVtbl-&gt;<b>SetService</b> (this-&gt;pfeep, &amp;this-&gt;weak.iservice);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = <b>QueryInterface</b> (&amp;this-&gt;strong.ifoo, riid, ppv);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; ++<b>vcObjects</b>;

<b> &nbsp;&nbsp; Release</b> (&amp;this-&gt;strong.ifoo);

 &nbsp;&nbsp; return hr;
}
</code></pre>
<p>
<b>The same example in C++</b></p>
<p>
Up until now, the C++ samples have looked clearer, mostly by virtue of hiding the <b>this</b> pointer. For this example, that is no longer feasible, as we have to introduce a back pointer to access the shared state. The C++ methods look very like the equivalent C code. I've highlighted the actual member functions, since in a real example they will constitute the bulk of the code. Here is FOOSPLIT.CPP:</p>
<pre><code>#include "<b>ifoo.h</b>"
#include "<b>ibaz.h</b>"
#include "<b>ifeep.h</b>"
#include "<b>iservice.h</b>"
#include "<b>inside.h</b><i>"</i>

extern "C" int <b>vcObjects</b>;

class <b>COutside</b>;

struct <b>COutsideIdentity</b> : IFoo, IBaz, IService
{
// IUnknown methods
 &nbsp;&nbsp; ULONG __stdcall <b>AddRef</b> () { return ++m_cRef; };
// IFoo methods
 &nbsp;&nbsp; HRESULT __stdcall <b>SetValue</b> (int <b>v</b>);
 &nbsp;&nbsp; HRESULT __stdcall <b>GetValue</b> (int *<b>pv</b>);
// IBaz methods
 &nbsp;&nbsp; HRESULT __stdcall <b>SquareValue</b> ();

// IService methods
 &nbsp;&nbsp; HRESULT __stdcall <b>Example</b> ();

 &nbsp;&nbsp; COutside *<b> m_pThis</b>;
 &nbsp;&nbsp; int <b>m_cRef</b>;
};

struct <b>COutsideStrong</b> : COutsideIdentity
{
 &nbsp;&nbsp; HRESULT __stdcall <b>QueryInterface</b> (REFIID <b>riid</b>, void **<b>ppv</b>);
 &nbsp;&nbsp; ULONG __stdcall <b>Release</b> ();
};

struct <b>COutsideWeak</b> : COutsideIdentity
{
 &nbsp;&nbsp; HRESULT __stdcall <b>QueryInterface</b> (REFIID <b>riid</b>, void **<b>ppv</b>);
 &nbsp;&nbsp; ULONG __stdcall <b>Release</b> ();
};

struct <b>COutside</b>
{
 &nbsp;&nbsp; COutsideStrong <b>m_strong</b>;
 &nbsp;&nbsp; COutsideWeak <b>m_weak</b>;

<b> &nbsp;&nbsp; COutside</b> ();
 &nbsp;&nbsp; ~<b>COutside</b> ();
 &nbsp;&nbsp; int <b>m_value</b>;
 &nbsp;&nbsp; IFeep *<b> m_pfeep</b>;
};

COutside::<b>COutside</b> ()
{
 &nbsp;&nbsp; m_weak.m_cRef = 0;
 &nbsp;&nbsp; m_weak. m_pThis = this;
 &nbsp;&nbsp; m_strong. m_cRef = 1;
 &nbsp;&nbsp; m_strong. m_pThis = this;
 &nbsp;&nbsp; ++<b>vcObjects</b>;
}

COutside::<b> ~COutside</b> ()
{
 &nbsp;&nbsp; --<b>vcObjects</b>;
}

// Strong IUnknown methods

HRESULT COutsideStrong::<b>QueryInterface</b> (REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; if (riid == IID_IUnknown || riid == IID_IFoo)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IFoo *) this;
 &nbsp;&nbsp; else if (riid == IID_IBaz)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IBaz *) this;
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; </b>((IUnknown *)*ppv)-&gt;<b>AddRef </b>();
 &nbsp;&nbsp; return NOERROR;
}

ULONG COutsideStrong::<b>Release</b> ()
{
 &nbsp;&nbsp; if (--m_pThis-&gt;m_strong.m_cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pThis-&gt;m_weak.<b>AddRef</b> ();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pThis-&gt;m_pfeep<b>-&gt;Release</b> ();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pThis-&gt;m_weak.<b>Release</b> ();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return m_pThis-&gt;m_strong.cRef;
}

// Weak IUnknown methods

HRESULT COutsideWeak::<b>QueryInterface</b> (REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; if (riid == IID_IUnknown || riid == IID_IFoo)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IFoo *) this;
 &nbsp;&nbsp; else if (riid == IID_IService)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IService *) this;
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; </b>((IUnknown *)*ppv)-&gt;<b>AddRef </b>();
 &nbsp;&nbsp; return NOERROR;
}

ULONG COutsideWeak::<b>Release</b> ()
{
 &nbsp;&nbsp; if (--m_pThis-&gt; m_weak.m_cRef == 0 &amp;&amp; m_pThis-&gt;m_strong. m_cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>delete</b> this;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return m_pThis-&gt; m_weak.m_cRef;
}

//--------------------------------------------------------------------
// IFoo methods

HRESULT COutsideIdentity::<b> SetValue</b> (int <b>v</b>)
{
 &nbsp;&nbsp; m_pThis-&gt; m_value = v;
 &nbsp;&nbsp; return NOERROR;
}

HRESULT COutsideIdentity::<b>GetValue</b> (int *<b>pv</b>)
{
 &nbsp;&nbsp; if (!pv)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp; *pv = m_pThis-&gt; m_value;
 &nbsp;&nbsp; return NOERROR;
}

// IBaz methods

HRESULT COutsideIdentity::<b>SquareValue</b> ()
{
 &nbsp;&nbsp; m_pThis-&gt; m_value *= m_pThis-&gt; m_value;
 &nbsp;&nbsp; m_pThis-&gt; m_pfeep-&gt;<b>Sum</b> (m_pThis-&gt; m_value);
 &nbsp;&nbsp; return NOERROR;
}

// IService methods

HRESULT COutsideIdentity::<b>Example</b> ()
{
 &nbsp;&nbsp; // ???
 &nbsp;&nbsp; return NOERROR;
}

\\--------------------------------------------------------------------
extern "C" HRESULT <b>CreateOutside</b> (IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp; COutside *<b>pout</b> = <b>new</b> COutside;
 &nbsp;&nbsp; hr = <b>CoCreateInstance</b> (<b>CLSID_Inside</b>, NULL, CLSCTX_INPROC_SERVER, IID_IFeep,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void **)&amp;pout-&gt;m_pfeep);
 &nbsp;&nbsp; if (hr == NOERROR)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pout-&gt;m_pfeep-&gt;<b>SetService</b> ((IService *)&amp;pout-&gt;m_weak);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = pout-&gt;m_strong.<b>QueryInterface</b> (riid, ppv);
 &nbsp;&nbsp; }

<b> &nbsp;&nbsp; </b>pout<b>-&gt;</b> m_strong.<b>Release</b> ();
 &nbsp;&nbsp; return hr;
}
</code></pre>
<p>
There is in fact a way to hide the back pointer again in C++, by inheriting the strong and weak identities and moving the instance data into a virtual base class. Unfortunately, the code generated for virtual base classes is more general than necessary for this context, and the required multiple inheritance nesting breaks the compiler. I dare say it would break the more casual readers also.</p>
<h4>Reference cycles and part-whole hierarchies</h4>
<p>
Another scenario in which the reference cycle issue commonly comes up is in part-whole hierarchies. Here we have a tree, where each node is a COM object. To facilitate navigation around the tree and to obtain contextual information, nodes in the tree will usually require references to their parents as well as to their children. This thus indicates a reference cycle between parent and child. There are two ways to deal with this problem: Either you avoid keeping references to the parent node, and instead have some other means to obtain the parent, or you keep references, but inform the parent when you <b>AddRef</b> or <b>Release</b> the item so that it knows that the reference is from a child, and thus should not prevent shutdown.</p>
<p>
<img src="com_co_11.gif" border=0></p>
<p>
In many situations the child's view of its parent is different from one of the parent's peers, so a split identity is appropriate. If the child needs or is asked for the parent's identity, it can use a <i>service </i>from the parent to obtain that identity.</p>
<p>
<img src="com_co_12.gif" border=0></p>
<h4>Symmetric lifetime management</h4>
<p>
In some situations it is necessary to have two mutually dependent objects that have different identities, but share a common lifetime. The requirement is that a reference to either identity will hold both objects alive and that when those references are released, that both objects are freed. This necessarily involves sharing a reference count. Solutions to this problem will be discussed in a later document (also see the <a href="msdn_objlife.htm">"Managing Object Lifetimes in OLE"</a> technical article).</p>
<h3>Aggregation</h3>
<p>
In the section on delegation, we discussed ways of arranging for an interface on a contained object to appear on its container. While the Universal Trivial Delegator is much smaller and faster than explicit delegator functions, there is another technique available to the COM programmer.</p>
<p>
<img src="com_co_13.gif" border=0></p>
<p>
Rather than delegating an entire interface trivially, it would be very tempting simply to hand out the inner object's interface pointers in response to the outer object's <b>QueryInterface</b>. Unfortunately, this breaks the COM rules. The inner object's <b>IUnknown</b> methods do not know about the outer object, and the inner <b>QueryInterface</b> would not be able to succeed or fail the same way as the outer <b>QueryInterface</b> on the exposed interface, and would not be able to return the outer object's identity. This may not be a problem for a particular client of the outer COM object, but it will be for someparticularly the remoting code. Such an object may be usable in a limited way, but it is not a COM object.</p>
<h4>Aggregating another object</h4>
<p>
There is a way to make this work, however: The inner object can be given the <b>IUnknown</b> pointer of the outer object in its <b>IClassFactory::CreateInstance</b> call. It then delegates its <b>IUnknown</b> methods to that pointer, much as other interfaces do in a single object. This is called <i>COM aggregation</i>.</p>
<p>
Here we assume the existence of a class <b>Inside</b>, which supports <b>IUnknown</b> and <b>IFeep</b>, which we want to expose as an interface on <b>COutside</b>. <b>COutside</b> also requires the <b>IFeep</b> interface to implement its <b>IBaz</b> interface. This is just an example; not all aggregation outer objects need internal services from their inner objects. <b>COutside</b> requests the <b>IFeep</b> interface from the inner object and places it in its class structure. This is called <i>caching</i> an interface pointer. When it does so, it releases <i>itself</i> to balance the extra reference count. During shutdown, <b>Outside</b> will <b>AddRef</b> itself before releasing <b>this-&gt;pfeep</b> to balance the reference counts the other way. It performs and stabilizes the reference count to 1 before this to prevent the <b>OutsideRelease</b> method being reentered when <b>this-&gt;pfeep</b> is released:</p>
<pre><code>#include "<b>util.h</b>"
#include "<b>ifoo.h</b>"
#include "<b>ibaz.h</b>"
//--------------------------------------------------------------------
#include "<b>ifeep.h</b>"
#include "<b>inside.h</b>"
\\--------------------------------------------------------------------

typedef struct
{
 &nbsp;&nbsp; IFoo <b>ifoo</b>;
 &nbsp;&nbsp; IBaz <b>ibaz</b>;
 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; int <b>value</b>;
//--------------------------------------------------------------------
 &nbsp;&nbsp; IUnknown *<b>punkInside</b>;
 &nbsp;&nbsp; IFeep *<b>pfeep</b>;
\\--------------------------------------------------------------------
} <b>COutside</b>;

static IFooVtbl <b>vtblFoo</b>;

static HRESULT <b>OutsideQueryInterface</b> (IFoo *<b>pfoo</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>IsEqualIID</b> (riid, &amp;IID_IFoo))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ifoo;
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IBaz))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ibaz;
//--------------------------------------------------------------------
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IFeep))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = this-&gt;pfeep;
\\--------------------------------------------------------------------
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; AddRef</b> ((IUnknown *)*ppv);
 &nbsp;&nbsp; return NOERROR;
}

static ULONG <b>OutsideAddRef</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; return ++this-&gt;cRef;
}

static ULONG <b>OutsideRelease</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; if (--this-&gt;cRef == 0)
 &nbsp;&nbsp; {
//--------------------------------------------------------------------
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;cRef = 1; // guard
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;pfeep)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>AddRef</b> (&amp;this-&gt;ifoo); // release cached pointer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (this-&gt;pfeep); //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (this-&gt;punkInside);
\\--------------------------------------------------------------------

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRef;
}

static HRESULT <b>SetValue</b> (IFoo *<b>pfoo</b>, int <b>value</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; this-&gt;value = value;
 &nbsp;&nbsp; return NOERROR;
}

static HRESULT <b>GetValue</b> (IFoo *<b>pfoo</b>, int *pValue)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; if (!pValue)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp; *pValue = this-&gt;value;
 &nbsp;&nbsp; return NOERROR;
}

static IFooVtbl <b>vtblFoo</b> =
{
 &nbsp;&nbsp; (QITYPE)<b> OutsideQueryInterface</b>,&nbsp;&nbsp;&nbsp;&nbsp; (ARTYPE)<b> OutsideAddRef</b>,
 &nbsp;&nbsp; (RLTYPE)<b> OutsideRelease</b>,
 &nbsp;&nbsp; <b>SetValue</b>,
 &nbsp;&nbsp; <b>GetValue</b>
};

static HRESULT <b>SquareValue </b>(IBaz *<b>pbaz</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ibaz, pbaz);
 &nbsp;&nbsp; this-&gt;value *= this-&gt;value;
//--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;pfeep-&gt;lpVtbl-&gt;<b>Sum</b> (this-&gt;pfeep, this-&gt;value);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; return NOERROR;
}

static IBazVtbl <b>vtblBaz</b> =
{
 &nbsp;&nbsp; (QITYPE)<b> OutsideQueryInterface</b>,&nbsp;&nbsp;&nbsp;&nbsp; (ARTYPE)<b> OutsideAddRef</b>,
 &nbsp;&nbsp; (RLTYPE)<b> OutsideRelease</b>,
 &nbsp;&nbsp; <b>SquareValue</b>
};

HRESULT <b>CreateOutside</b> (IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp; if (hr = <b>Alloc</b> (sizeof (COutside), &amp;this))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; this-&gt;ifoo.lpVtbl = &amp;<b>vtblFoo</b>;
 &nbsp;&nbsp; this-&gt;ibaz.lpVtbl = &amp;<b>vtblBaz</b>;
 &nbsp;&nbsp; this-&gt;cRef = 1;
 &nbsp;&nbsp; this-&gt;value = 0;
 &nbsp;&nbsp; this-&gt;pfeep = 0;

 &nbsp;&nbsp; ++<b>vcObjects</b>;
//--------------------------------------------------------------------
 &nbsp;&nbsp; hr = <b>CoCreateInstance</b> (&amp;<b>CLSID_Inside</b>, (IUnknown *)&amp;this-&gt;ifoo, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSCTX_INPROC_SERVER, &amp;IID_IUnknown, &amp;this-&gt;punkInside);
 &nbsp;&nbsp; if (hr != NOERROR)
 &nbsp;&nbsp; {
\\--------------------------------------------------------------------

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Release</b> (&amp;this-&gt;ifoo);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; }
//--------------------------------------------------------------------
 &nbsp;&nbsp; hr = <b>QueryInterface</b> (this-&gt;punkInside, &amp;IID_IFeep, &amp;this-&gt;pfeep);
 &nbsp;&nbsp; if (hr == NOERROR)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (&amp;this-&gt;ifoo);
\\--------------------------------------------------------------------
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = <b>QueryInterface</b> (&amp;this-&gt;ifoo, riid, ppv);
 &nbsp;&nbsp; }

<b> &nbsp;&nbsp; Release</b> (&amp;this-&gt;ifoo);
 &nbsp;&nbsp; return hr;
}
</code></pre>
<p>
Here, then, are the rules for being an aggregator:
<ul type=disc>
<li>
The aggregator should pass its own <b>punkOuter</b> implementation to the object to aggregate as the <i>punkOuter</i> parameter of <b>CoCreateInstance</b> (or in other creation scenarios in which a <i>punkOuter</i> is required). This <i>punkOuter</i> will be the one it received as its <i>punkOuter</i> when it was created, or its own <b>IUnknown</b> implementation if it is not part of an aggregate.<br><br></li>
<li>
When creating the inner object, the aggregator must ask initially for the <b>IUnknown</b> interface. If it does not, it will have no way to control the inner object's lifetime.<br><br></li>
<li>
When caching a pointer to an interface on the inner object, the outer object should not release any interface it obtains for private use because the inner object may be keeping per-interface reference counts, and may invalidate the interface if it is released. This is a change to the OLE version 2.0 aggregation rules, which was done for 32-bit OLE specifically to allow this. Instead, to hold an interface pointer to an inner object, the outer object must release the<i> </i><b>punkOuter</b> that was passed to the inner object. This is because the interface, though obtained from the inner object, now belongs to the outer object (<b>COutside</b>) and thus <b>AddRef</b>s that <b>punkOuter</b>. This prevents a reference cycle, though it does restrict an implementation of <b>QueryInterface</b> to adding one reference.<br><br></li>
<li>
When it closes down, the outer object should <b>AddRef</b> the <b>punkOuter</b> passed to its inner object, and release any held interface pointer from the inner object, thus enabling the per-interface reference counts in the inner object to be balanced.<br><br></li>
<li>
The aggregator must guard its shutdown by increasing its reference count again before releasing the aggregated object. This is to prevent the inner object causing the <b>Release</b> to be reentered when the inner releases any cached pointers.</li>
</ul>
<p>
A present limitation with aggregation is that the outer and inner objects have to be in the same process (and multithreading apartment for that matter), though it's possible that this restriction may be lifted in the future.</p>
<h4>Being part of an aggregate</h4>
<p>
The rules of behavior for an object when it is an inner part of an aggregate are as follows:
<ul type=disc>
<li>
When the inner object receives a <b>QueryInterface</b> on one of its interfaces <i>other than <b>IUnknown</b></i>, it delegates it to its <b>punkOuter</b> (the second argument to <b>CoCreateInstance</b>). This way, when one of those interfaces is exposed outside the outer object, the same delegation occurs that the other interfaces on the outside object are already doing. The <b>QueryInterface</b> should always <b>AddRef</b> the pointer it is returning, not some other one.<br><br></li>
<li>
The inner object does not delegate the <b>QueryInterface</b> of its <b>IUnknown</b>, but instead returns one of its own interfaces, and <b>AddRef</b>s its <b>punkOuter</b> instead of its own reference count. This is because the interfaces of an aggregated object "belong" to the outer object.<br><br></li>
<li>
The inner object does not <b>AddRef</b> its <b>punkOuter</b> when it first passed it in, even though it is being stored by the object. This is to avoid a reference cycle between the outer and inner objects. Such a reference cycle would prevent either from being freed when all external references have gone away.<br><br></li>
<li>
If the aggregator does not initially ask for the <b>IUnknown</b> interface of the inner object, then the creation should fail.</li>
</ul>
<p>
So what does an object have to do differently to be aggregatable? Actually, very little. Although aggregatability is optional in COM, it costs so little that it makes sense to make most COM classes aggregatable unless there is a specific reason not to. After all, if you want to aggregate things, it makes sense to build things that are aggregatable.</p>
<p>
There are a couple of differences from the earlier examples: It is no longer possible to share the <b>IUnknown</b> vtable with the first interface. This is because an aggregatable object behaves differently with <b>IUnknown</b> than with other interfaces. The <b>IUnknown</b> implementation must also be prepared to delegate to the <b>punkOuter</b> if it detects that it is not being called from the <b>IUnknown</b> interface. It does this detection by comparing the vtable pointers in <b>FindImpl</b>.</p>
<p>
If you are using <b>IUnknown</b> delegators in the other interfaces, they can delegate directly to <b>punkOuter</b>. The <b>IUnknown</b> implementation would then not need to do this detection. </p>
<p>
Being aggregatable thus costs 8 bytes per instance and 9 lines of code per class. For all but the smallest objects, this is worthwhile.</p>
<p>
Here is INSIDE.C. This sample is pretty close to boilerplate for most of my own COM object implementations:</p>
<pre><code>#include "<b>util.h</b>"
#include "<b>ifeep.h</b>"

typedef struct
{
//--------------------------------------------------------------------
 &nbsp;&nbsp; IUnknown <b>iunk</b>;
\\--------------------------------------------------------------------
 &nbsp;&nbsp; IFeep <b>ifeep</b>;
 &nbsp;&nbsp; int <b>cRef</b>;
//--------------------------------------------------------------------
 &nbsp;&nbsp; IUnknown *<b>punkOuter</b>;
\\--------------------------------------------------------------------
 &nbsp;&nbsp; int <b>value</b>;
 &nbsp;&nbsp; IService *<b>psvc</b>;
} <b>CInside</b>;

static IUnknownVtbl <b>vtblUnknown</b>;

static HRESULT <b>UnkQueryInterface</b> (IUnknown *<b>punk</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; CInside *<b>this</b> = <b>FindImpl</b> (punk, &amp;<b>vtblUnknown</b>);
 &nbsp;&nbsp; 
//--------------------------------------------------------------------
 &nbsp;&nbsp; if (punk-&gt;lpVtbl != &amp;<b>vtblUnknown</b> &amp;&amp; this-&gt;punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>QueryInterface</b> (this-&gt;punkOuter, riid, ppv);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;iunk;
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IFeep))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ifeep;
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; AddRef</b> ((IUnknown *)*ppv);
 &nbsp;&nbsp; return NOERROR;
}

static ULONG <b>UnkAddRef</b> (IUnknown *<b>punk</b>)
{
 &nbsp;&nbsp; CInside *<b>this</b> = <b>FindImpl</b> (punk, &amp;<b>vtblUnknown</b>);
 &nbsp;&nbsp; 
//--------------------------------------------------------------------
 &nbsp;&nbsp; if (punk-&gt;lpVtbl != &amp;<b>vtblUnknown</b> &amp;&amp; this-&gt;punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>AddRef</b> (this-&gt;punkOuter);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; return ++this-&gt;cRef;
}

static ULONG <b>UnkRelease</b> (IUnknown *<b>punk</b>)
{
 &nbsp;&nbsp; CInside *<b>this</b> = <b>FindImpl</b> (punk, &amp;<b>vtblUnknown</b>);
 &nbsp;&nbsp; 
//--------------------------------------------------------------------
 &nbsp;&nbsp; if (punk-&gt;lpVtbl != &amp;<b>vtblUnknown</b> &amp;&amp; this-&gt;punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>Release</b> (this-&gt;punkOuter);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; if (--this-&gt;cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;psvc)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (this-&gt;psvc);

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRef;
}

//--------------------------------------------------------------------
static IUnknownVtbl <b>vtblUnknown</b> =
{
 &nbsp;&nbsp; <b>UnkQueryInterface</b>, <b>UnkAddRef</b>, <b>UnkRelease</b>
};
\\--------------------------------------------------------------------



static HRESULT <b>SetService</b> (IFeep *<b>pfeep</b>, IService *<b>psvc</b>)
{
 &nbsp;&nbsp; CInside *<b>this</b> = IMPL (CInside, ifeep, pfeep);
 &nbsp;&nbsp; if (this-&gt;psvc)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (this-&gt;psvc);
 &nbsp;&nbsp; this-&gt;psvc = psvc;
 &nbsp;&nbsp; if (this-&gt;psvc)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>AddRef</b> (this-&gt;psvc);
 &nbsp;&nbsp; return NOERROR;
}

static HRESULT <b>Sum</b> (IFeep *<b>pfeep</b>, int <b>value</b>)
{
 &nbsp;&nbsp; CInside *<b>this</b> = IMPL (CInside, ifeep, pfeep);
 &nbsp;&nbsp; this-&gt;value += value;
 &nbsp;&nbsp; if (this-&gt;psvc)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;psvc-&gt;lpVtbl-&gt;<b>Example</b> (this-&gt;psvc);
 &nbsp;&nbsp; return NOERROR;
}

static HRESULT <b>GetSum</b> (IFeep *<b>pfeep</b>, int *<b>pvalue</b>)
{
 &nbsp;&nbsp; CInside *<b>this</b> = IMPL (CInside, ifeep, pfeep);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (!pvalue)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp; *pvalue = this-&gt;value;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return NOERROR;
}

static IFeepVtbl <b>vtblFeep</b> =
{
 &nbsp;&nbsp; (QITYPE)<b>UnkQueryInterface</b>, (ARTYPE)<b>UnkAddRef</b>, (RLTYPE)<b>UnkRelease</b>,
 &nbsp;&nbsp; <b>SetService</b>,
 &nbsp;&nbsp; <b>Sum</b>,
 &nbsp;&nbsp; <b>GetSum</b>
};

HRESULT <b>CreateInside</b> (IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; CInside *<b>this</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (hr = <b>Alloc</b> (sizeof (CInside), &amp;this))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; this-&gt;iunk.lpVtbl = &amp;<b>vtblUnknown</b>;
 &nbsp;&nbsp; this-&gt;ifeep.lpVtbl = &amp;<b>vtblFeep</b>;
 &nbsp;&nbsp; this-&gt;cRef = 1;
//--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;punkOuter = punkOuter; // will be NULL when not aggregated
\\--------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;value = 0;
 &nbsp;&nbsp; this-&gt;psvc = 0;
 &nbsp;&nbsp; ++<b>vcObjects</b>;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; hr = <b>QueryInterface</b> (&amp;this-&gt;iunk, riid, ppv);

<b> &nbsp;&nbsp; Release</b> (&amp;this-&gt;iunk);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return hr;
}
</code></pre>
<h4>More aggregation rules</h4>
<p>
There are some more usage rules about aggregation behavior:
<ul type=disc>
<li>
An inner object should not assume that the address of its <b>punkOuter</b> is the address of the identity <b>IUnknown</b> of the outer object. If it wants the identity of the outer object, it should <b>QueryInterface</b> for it (though see the following rule).<br><br></li>
<li>
An inner object should not obtain services for its own use from its outer object by calling <b>QueryInterface</b> on its <b>punkOuter</b>. There are a couple of reasons for this: one is that the outer object may actually not <i>want</i> the inner object to use that particular implementation, and will not be able to distinguish such a <b>QueryInterface</b> from one from outside itself. The other reason is that when aggregation is nested, the <b>QueryInterface</b> will delegate through to the outermost object, which might choose not to expose some interface on the middle object. If it does that, then the middle and innermost objects will be broken. Aggregation is not allowed to be visible from outside the outer object, and this behavior breaks that encapsulation rule.<br><br></li>
<li>
For similar reasons, an outer object should not pass its own interfaces (including its <b>punkOuter</b>) inwards to inner objects. If it does, the inner object will be obliged to <b>AddRef</b> them, which will cause a reference cycle. Because it can't tell where the interface came from, the inner object may also choose to keep other references to the interface, so the outer object will not know how many releases it would need to perform to avoid the cycle. A way to deal correctly with this situation is described below.</li>
</ul>
<h4>"Blind" delegation of QueryInterface</h4>
<p>
One possibility with aggregation is to delegate to an inner object the <b>QueryInterface</b> calls for all interfaces that are not understood by the outer object. This is tempting because it is easy, and gives an effect that is quite similar to inheritance in C++. The problem, as with C++, is that if the inner object (base class) changes, it may expose services that involve interfaces that the outer object already implements, and is thus obscuring. What then happens is that the outer object is interfering with services that it is not aware of. This can cause the outer object to appear to support a service that it does not then implement correctly. This is a <i>bug</i>. In C++ there is no way that a client can prevent this kind of problem when using inheritanceit is the default behavior.</p>
<p>
It is unwise to delegate interfaces that you do not understand unless you also do not interfere with any other interfaces (meaning that you pass all other interfaces through unchanged, with only additional "before" and "after" code in the delegators). The only other case where this is safe is where you have knowledge or control over the future of the object you are aggregating. If the inner object is provided by someone else, then you will not generally have such assurances.</p>
<p>
A place where this issue arises is in creating a custom handler using the OLE default handler. This is aggregated into custom handlers provided by some OLE embedding object implementors. If your custom handler could be broken by the default handler being exposed directly, or you are implementing interfaces that the default handler may later implement, you will need to avoid blind delegation.</p>
<h4>Passing service interfaces to an aggregated object</h4>
<p>
How then can an aggregated object obtain services from its outer object? The short answer is that an object should not use the fact that it is aggregated to obtain services that it would not otherwise have. It is up to the outer object to provide such services using an object with an identity different than its own. This is another case where split identities are useful. The inner object is aggregated with the strong identity of the outside object, but gets its service connection from the weak identity.</p>
<p>
<img src="com_co_14.gif" border=0></p>
<h4>Multiple aggregation</h4>
<p>
Multiple aggregation is the COM equivalent of multiple inheritance (MI). Most reasonable people will avoid the multiple inheritance of implementations, mostly because MI doesn't scale linearly either in complexity or code space costs, and has dire consequences in the face of independently versioned classes. A C++ class that inherits multiply exposes all the classes it inherits from <i>and everything that every one of those classes inherits from, even indirectly</i>. Fortunately, multiple aggregation is somewhat more benign. With <b>QueryInterface</b>, the aggregator has complete control over the set of interfaces it exposes, so selecting from multiple aggregated objects is reasonable and safe.</p>
<p>
<img src="com_co_15.gif" border=0></p>
<h4>Passing service interfaces between aggregated objects</h4>
<p>
It is important to bear in mind that the aggregated objects each share the identity (and reference count) of their outer object, so passing an interface between them will immediately generate a reference cycle. A reasonable solution to this is again to use a split identity in the outer object, so that inner objects see interfaces on an identity other than the outer one. If inner objects need to use interfaces from one another, the simplest solution is to delegate those interfaces on the weak identity. The delegator uses a cached interface pointer to one of the other inner objects.</p>
<p>
<img src="com_co_16.gif" border=0></p>
<h4>Nested aggregation</h4>
<p>
Nested aggregation occurs when an object aggregates something that is already an aggregate. Because aggregation is private, the outermost object is fully isolated from the inner aggregation. The object in the middle has one extra concern: The <b>punkOuter</b> that it passes to the innermost object should be the <b>punkOuter</b> it receives from its own outer object, or should delegate to it. Nested aggregation is important because it provides a way to flatten multiple layers of abstraction without losing performance, and yet it does so in a way that is completely transparent to implementors.</p>
<p>
<img src="com_co_17.gif" border=0></p>
<h2>Optimizations</h2>
<p>
As implementations become richer, they tend to support a large number of interfaces. As objects scale up they tend to require more resources and more initialization time. If the use of an object is simple and lightweight, it makes sense for the object to delay or avoid some initialization in order to provide better services for humbler customers. There are a number of techniques possible within the COM standard that enable this. It's important to note that these are just implementation techniques. The fact that they are being used is invisible outside the object involved.</p>
<h3>Delayed Initialization</h3>
<p>
Many kinds of initialization can occur during <b>QueryInterface</b> for particular interfaces. Not much needs to be said about this, other than that because you know that none of the member functions of an interface can be called before a <b>QueryInterface</b> for that interface, there is an opportunity to do some delayed initialization for that interface or a collection of interfaces in the <b>QueryInterface</b> implementation. Members of those interfaces can then assume the initialization without having to test for it.</p>
<h3>Delayed Aggregation</h3>
<p>
Large and complex objects often aggregate other objects to provide particular services. If those services are not always required, then creating the aggregated objects is not necessary. </p>
<p>
In the example below the <b>punkInside</b> member is initialized to zero during <b>CreateFoo</b>, and released if nonzero during <b>FooRelease</b>. The aggregation of inside occurs when either <b>IFeep</b> or <b>IBaz</b> is requested by calling <b>InitInside</b>, because <b>IBaz</b> also uses the inner object. The advantage of this technique is that if <b>IFoo</b> is the only interface of interest to the client, the client doesn't pay the cost of loading the inside object. For large objects, this may be quite significant. Further, some initialization can be delayed until the service is actually required, which smoothes the responsiveness of the collection of COM objects.</p>
<p>
Here is the code:</p>
<pre><code>typedef struct
{
 &nbsp;&nbsp; IFoo <b>ifoo</b>;
 &nbsp;&nbsp; IBaz <b>ibaz</b>;
 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; int <b>value</b>;
 &nbsp;&nbsp; IUnknown *<b>punkInside</b>;
 &nbsp;&nbsp; IFeep *<b>pfeep</b>;
} <b>COutside</b>;

//--------------------------------------------------------------------
static HRESULT <b>InitInside</b> (COutside *<b>this</b>);
{
 &nbsp;&nbsp; HRESULT <b>hr</b> = <b>CoCreateInstance</b> (&amp;<b>CLSID_Inside</b>, (IUnknown *)&amp;this-&gt;ifoo,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSCTX_INPROC_SERVER, &amp;IID_IUnknown, &amp;this-&gt;punkInside);

 &nbsp;&nbsp; if (this-&gt;punkInside)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = <b>QueryInterface</b> (this-&gt;punkInside, &amp;IID_IFeep, &amp;this-&gt;pfeep);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (&amp;this-&gt;ifoo);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return hr;
}
\\--------------------------------------------------------------------

static IFooVtbl <b>vtblFoo</b>;

static HRESULT <b>FooQueryInterface</b> (IFoo *<b>pfoo</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown) || <b>IsEqualIID</b> (riid, &amp;IID_IFoo))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ifoo;
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IFeep) || <b>IsEqualIID</b> (riid, &amp;IID_IBaz))
 &nbsp;&nbsp; {
//--------------------------------------------------------------------

<i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>HRESULT <b>hr</b>;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!this-&gt;punkInside &amp;&amp; NOERROR != (hr = <b>InitInside</b> (this)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IBaz))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ibaz;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>QueryInterface</b> (this-&gt;punkInside, riid, ppv);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; AddRef</b> ((IUnknown *)*ppv);
 &nbsp;&nbsp; return NOERROR;
}
</code></pre>
<h3>Tear-Off Interfaces</h3>
<p>
In some scenarios, an object may wish to support a large number of interfaces, some of which are used rarely (for example, for backward compatibility) or only transiently (for example, for initialization or in order to obtain other services, such as <b>IConnectionPointContainer</b> in the OLE Controls specification). Objects that have a lot of behavior but comparatively little state are good candidates for this technique.</p>
<p>
<img src="com_co_18.gif" border=0></p>
<p>
A <i>tear-off interface</i> is one that depends on interface-specific reference-counting. The interface implementation is allocated by a <b>QueryInterface</b> on some other interface, and released when no one is still using the tear-off. This is a technique that really relies on clients adhering correctly to the COM rules, since releasing a tear-off really does make it go away.</p>
<p>
An implementation of tear-offs looks a lot like the split-identity implementation shown earlier. The example below shows <b>COutside</b> rewritten so that <b>IBaz</b> is available as a tear-off.</p>
<p>
This example shows how <b>CreateTearOff</b> delegates <b>IUnknown</b> to a <b>punkOuter</b> that is passed to it. This is done so that this same paradigm can be used when <b>COutside</b> is aggregatable, as the <b>IUnknown</b> would then need to delegate to the <b>punkOuter</b>. In this case, we simply pass in the <b>IUnknown</b> from <b>COutside</b>. For this example, we could make the tear-off four bytes smaller by accessing <b>COutside</b>'s <b>IUnknown</b> through <b>pThis</b>.</p>
<p>
This example will create a distinct <b>TearOff</b> for each <b>QueryInterface</b> for <b>IBaz</b>. This is permitted by COM. A variant on this technique is to have the <b>TearOff</b> implement a collection of transient interfaces. If <b>COutside</b> kept a pointer to the <b>TearOff</b>, it would be possible to go to the same <b>TearOff</b> for a number of interfaces. If they are likely to be wanted together, <b>COutside</b> could keep the <b>TearOff</b> around even when its reference count is zero. It might decide to lazily deallocate it when "normal operation" is under way. This would reduce the overhead of creating multiple <b>TearOff</b>s.</p>
<p>
This is very like delayed aggregation, except that the tear-off has access to the outer object's implementation:</p>
<pre><code>#include "<b>util.h</b>"
#include "<b>ifoo.h</b>"
#include "<b>ibaz.h</b>"

typedef struct
{
 &nbsp;&nbsp; IFoo <b>ifoo</b>;
 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; int <b>value</b>;
} <b>COutside</b>;

//--------------------------------------------------------------------
static HRESULT <b>CreateTearOff</b> (COutside *<b>this</b>, IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void **<b>ppv</b>);
\\--------------------------------------------------------------------

static IFooVtbl <b>vtblFoo</b>;

static HRESULT <b>OutsideQueryInterface</b> (IFoo *<b>pfoo</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown) || <b>IsEqualIID</b> (riid, &amp;IID_IFoo))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ifoo;
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IBaz))
//--------------------------------------------------------------------
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>CreateTearOff</b> (this, (IUnknown *)&amp;this-&gt;ifoo, riid, ppv);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp; AddRef</b> ((IUnknown *)*ppv);
 &nbsp;&nbsp; return NOERROR;
}

static ULONG <b>OutsideAddRef</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; return ++this-&gt;cRef;
}

static ULONG <b>OutsideRelease</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (--this-&gt;cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --<b>vcObjects</b>;

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRef;
}

static HRESULT <b>SetValue</b> (IFoo *<b>pfoo</b>, int <b>value</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; this-&gt;value = value;
 &nbsp;&nbsp; return NOERROR;
}

static HRESULT <b>GetValue</b> (IFoo *<b>pfoo</b>, int *<b>pValue</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (!pValue)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp; *pValue = this-&gt;value;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return NOERROR;
}

static IFooVtbl <b>vtblFoo</b> =
{
 &nbsp;&nbsp; (QITYPE)<b> FooQueryInterface</b>,
 &nbsp;&nbsp; (ARTYPE)<b> FooAddRef</b>,
 &nbsp;&nbsp; (RLTYPE)<b> FooRelease</b>,
 &nbsp;&nbsp; <b>SetValue</b>,
 &nbsp;&nbsp; <b>GetValue</b>
};


HRESULT <b>CreateOutside</b> (IUnknown *punkOuter, REFIID riid, void **ppv)
{
 &nbsp;&nbsp; COutside *<b>this</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (hr = <b>Alloc</b> (sizeof (COutside), &amp;this))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; this-&gt;ifoo.lpVtbl = &amp;<b>vtblFoo</b>;
 &nbsp;&nbsp; this-&gt;cRef = 1;
 &nbsp;&nbsp; this-&gt;value = 0;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ++<b>vcObjects</b>;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; hr = <b>QueryInterface</b> (&amp;this-&gt;ifoo, riid, ppv);

<b> &nbsp;&nbsp; Release</b> (&amp;this-&gt;ifoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return hr;
}

//--------------------------------------------------------------------
typedef struct
{
 &nbsp;&nbsp; COutside *<b>pThis</b>;
 &nbsp;&nbsp; IBaz <b>ibaz</b>;
 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; IUnknown *<b>punkOuter</b>;
} <b>TearOff</b>;

static HRESULT <b>TearOffQueryInterface</b> (IBaz *<b>pbaz</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; TearOff *<b>this</b> = IMPL (TearOff, ibaz, pbaz);
 &nbsp;&nbsp; return <b>QueryInterface</b> (this-&gt;punkOuter, riid, ppv);
}

static ULONG <b>TearOffAddRef</b> (IBaz *<b>pbaz</b>)
{
 &nbsp;&nbsp; TearOff *<b>this</b> = IMPL (TearOff, ibaz, pbaz);
 &nbsp;&nbsp; ++this-&gt;cRef;
 &nbsp;&nbsp; return <b>AddRef</b> (this-&gt;punkOuter);
}

static ULONG <b>TearOffRelease</b> (IBaz *<b>pbaz</b>)
{
 &nbsp;&nbsp; TearOff *<b>this</b> = IMPL (TearOff, ibaz, pbaz);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; <b>Release</b> (this-&gt;punkOuter);
 &nbsp;&nbsp; if (--this-&gt;cRef == 0)
 &nbsp;&nbsp; {

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRef;
}

static HRESULT <b>SquareValue</b> (IBaz *<b>pbaz</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = SPLIT_IMPL (COutside, TearOff, ibaz, pbaz);

 &nbsp;&nbsp; this-&gt;value *= this-&gt;value;

 &nbsp;&nbsp; return NOERROR;
}

static IBazVtbl <b>vtblBaz</b> =
{
 &nbsp;&nbsp; (QITYPE)<b> TearOffQueryInterface</b>, (ARTYPE)<b> TearOffAddRef</b>, (RLTYPE)<b> TearOffRelease</b>,
 &nbsp;&nbsp; <b>SquareValue</b>
};

static HRESULT <b>CreateTearOff</b> (COutside *<b>this</b>, IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; TearOff *<b>ptearOff</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;

 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (NOERROR != (hr = <b>Alloc</b> (sizeof (TearOff), &amp;ptearOff)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; ptearOff-&gt;pThis = this;
 &nbsp;&nbsp; ptearOff-&gt;ibaz.lpVtbl = &amp;<b>vtblBaz</b>;
 &nbsp;&nbsp; ptearOff-&gt;cRef = 1;
 &nbsp;&nbsp; ptearOff-&gt;punkOuter = punkOuter;
 &nbsp;&nbsp; <b>AddRef</b> (punkOuter);
 &nbsp;&nbsp; *ppv = &amp;ptearOff-&gt;ibaz;

 &nbsp;&nbsp; return hr;
}
\\--------------------------------------------------------------------
</code></pre>
<h3>Tear-Off Aggregation</h3>
<p>
If it is possible to delay aggregation to avoid the time cost of initializing an aggregate, and to tear off interfaces to avoid paying the space cost of maintaining an interface, then can we combine these two to support tear-off aggregates? The answer is Yes. The idea here is that having used an aggregated inner object for a while, it would be useful to unload the inner object before the outer object shuts down.</p>
<p>
One might imagine that the outer object could release the <b>punkInner</b> after creating it, so that the inner would be closed down when the last use of one of its interfaces goes away. Unfortunately, this does not work. The aggregation rules require that the <b>IUnknown</b> of the inner object be kept around to keep the inner object alive. Because the inner objects are expected to simply delegate the <b>IUnknown</b> methods on other interfaces to their controlling <b>IUnknown</b>, the inner object will not be tracking the lifetime of the other interfaces. It is up to the outer object to release them first. While the inner object is free to track the reference counts and not shut down until they are all released, this is not required by the COM aggregation rules.</p>
<p>
The problem for the outer object, then, is to know when all of the inner object's interface pointers have been released. This may be done by introducing an <i>intermediate controlling identity </i>to give to the aggregated object. The purpose of the intermediate identity is to track reference counts that occur because of delegations from the inner object. When that number reaches zero, the inner object's <b>IUnknown</b> can be released.</p>
<p>
Here's how it's done:</p>
<pre><code>#include "<b>util.h</b>"
#include "<b>ifoo.h</b>"
#include "<b>inside.h</b>"
#include "<b>ifeep.h</b>"

typedef struct
{
 &nbsp;&nbsp; IFoo <b>ifoo</b>;
 &nbsp;&nbsp; int <b>cRef</b>;
 &nbsp;&nbsp; int <b>value</b>;
//-------------------------------------------------------------------
 &nbsp;&nbsp; IUnknown <b>iunkInner</b>;
 &nbsp;&nbsp; int <b>cRefInner</b>;
\\--------------------------------------------------------------------
 &nbsp;&nbsp; IUnknown *<b>punkInside</b>;
} <b>COutside</b>;

//--------------------------------------------------------------------
static HRESULT <b>InitInside</b> (COutside *<b>this</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; if (!this-&gt;punkInside)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = <b>CoCreateInstance</b> (&amp;CLSID_Inside, &amp;this-&gt;iunkInner, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSCTX_INPROC_SERVER, &amp;IID_IUnknown,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;this-&gt;punkInside);
 &nbsp;&nbsp; if (this-&gt;punkInside)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>AddRef</b> (&amp;this-&gt;iunkInner);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = <b>QueryInterface</b> (this-&gt;punkInside, riid, ppv);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (&amp;this-&gt;iunkInner);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // AR, RL shutdown punkInside if QI fails
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return hr;
}
\\--------------------------------------------------------------------

static IFooVtbl <b>vtblFoo</b>;

static HRESULT <b>OutsideQueryInterface</b> (IFoo *<b>pfoo</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (<b>IsEqualIID</b> (riid, &amp;IID_IUnknown) || <b>IsEqualIID</b> (riid, &amp;IID_IFoo))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = &amp;this-&gt;ifoo;
//--------------------------------------------------------------------
 &nbsp;&nbsp; else if (<b>IsEqualIID</b> (riid, &amp;IID_IFeep))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <b>InitInside</b> (this, riid, ppv);
\\--------------------------------------------------------------------
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; <b>AddRef</b> ((IUnknown *)*ppv);
 &nbsp;&nbsp; return NOERROR;
}

static ULONG <b>OutsideAddRef</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; return ++this-&gt;cRef;
}

static ULONG <b>OutsideRelease</b> (IFoo *<b>pfoo</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>FindImpl</b> (pfoo, &amp;vtblFoo);
 &nbsp;&nbsp; if (--this-&gt;cRef == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Free</b> (this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return this-&gt;cRef;
}

static HRESULT <b>SetValue</b> (IFoo *<b>pfoo</b>, int <b>value</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; this-&gt;value = value;
 &nbsp;&nbsp; return NOERROR;
}

static HRESULT <b>GetValue</b> (IFoo *<b>pfoo</b>, int *<b>pValue</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = IMPL (COutside, ifoo, pfoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (!pValue)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp; *pValue = this-&gt;value;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return NOERROR;
}

static IFooVtbl <b>vtblFoo</b> =
{
 &nbsp;&nbsp; <b>OutsideQueryInterface</b>, <b>OutsideAddRef</b>, <b>OutsideRelease</b>,
 &nbsp;&nbsp; <b>SetValue</b>,
 &nbsp;&nbsp; <b>GetValue</b>
};

static HRESULT <b>InnerQueryInterface</b> (IUnknown *<b>punk</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>IMPL</b> (COutside, iunkInner, punk);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return <b>QueryInterface</b> (&amp;this-&gt;ifoo, riid, ppv);
}

static ULONG <b>InnerAddRef</b> (IUnknown *<b>punk</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>IMPL</b> (COutside, iunkInner, punk);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ++this-&gt;cRefInner;
 &nbsp;&nbsp; return <b>AddRef</b> (&amp;this-&gt;ifoo);
}

//--------------------------------------------------------------------
static ULONG <b>InnerRelease</b> (IUnknown *punk)
{
 &nbsp;&nbsp; COutside *<b>this</b> = <b>IMPL</b> (COutside, iunkInner, punk);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (--this-&gt;cRefInner == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Release</b> (this-&gt;punkInside);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;punkInside = 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return <b>Release</b> (&amp;this-&gt;ifoo);
}

static IUnknownVtbl <b>vtblUnknownInner</b> =
{
 &nbsp;&nbsp; <b>InnerQueryInterface</b>, <b>InnerAddRef</b>, <b>InnerRelease</b>
};
\\------------------------------------------------------------------------------

HRESULT <b>CreateOutside</b> (IUnknown *<b>punkOuter</b>, REFIID <b>riid</b>, void **<b>ppv</b>)
{
 &nbsp;&nbsp; COutside *<b>this</b>;
 &nbsp;&nbsp; HRESULT <b>hr</b>;
 &nbsp;&nbsp; *ppv = 0;
 &nbsp;&nbsp; if (punkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (hr = <b>Alloc</b> (sizeof (<b>COutside</b>), &amp;this))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; this-&gt;ifoo.lpVtbl = &amp;<b>vtblFoo</b>;
 &nbsp;&nbsp; this-&gt;cRef = 1;
 &nbsp;&nbsp; this-&gt;value = 0;
//------------------------------------------------------------------------------
 &nbsp;&nbsp; this-&gt;iunkInner.lpVtbl = &amp;<b>vtblUnknownInner</b>;
 &nbsp;&nbsp; this-&gt;cRefInner = 0;
 &nbsp;&nbsp; this-&gt;punkInside = 0;
\\------------------------------------------------------------------------------
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ++<b>vcObjects</b>;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; hr = <b>QueryInterface</b> (&amp;this-&gt;ifoo, riid, ppv);
 &nbsp;&nbsp; <b>Release</b> (&amp;this-&gt;ifoo);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return hr;
}
</code></pre>
<h3>Adaptive Behavior</h3>
<p>
Continuing the track of objects that scale their cost with the complexity of their use, for some objects the cost of implementing an interface may escalate dramatically for large data sets or when "high-end" features are required. At the same time, when many instances of the class are used simply, the setup time and memory cost for being prepared for the general case may be excessive.</p>
<p>
Sometimes, the client of the object can predict easily what features will be required, and pick an appropriate class to instantiate based on its requirements. On other occasions, this is not feasible, because the pattern of usage changes during the lifetime of the object. Tombstoning is an example: An object is <i>tombstoned</i> if it represents some feature of an object that has a lifetime shorter than the reference to it. In this case, the reference has to change behavior drastically (all methods return failure).</p>
<p>
Many programmers are familiar with the technique of using function pointers to implement such adaptive behavior: When the requirements change (for example, because the data set has reached a certain size, or some service that was being depended on has been removed), it would be useful to be able to switch the vtable of an interface, for one with an alternative "strategy."</p>
<p>
At first sight, it would seem reasonable in these situations to have a method on an object change the <b>lpVtbl</b> pointer in one or more of its interfaces. Unfortunately, some C++ compilers, notably Microsoft Visual C++® version 2.0, cache the vtable pointers and their entries in some circumstances, so they will continue to use the old vtable after the change. Some C compilers with aggressive optimizers may even do this if the vtables are declared <i>const</i>. If the adaptive code can survive this, then changing the vtable will work, but this obviously limits the usefulness of this technique. Even if you build in C, you will still have to deal with C++ -built code in your address space. The OLE remoting infrastructure is an example. It is thus an indirect rule of COM compliance that client code is permitted to cache vtable entries, and that servers must operate correctly in the light of this.</p>
<p>
Fortunately, when an interface is already delegating to some interface, the object can change the interface to which it delegates. If the testing required to decide on the correct behavior exceeds the cost of a delegation for an interface (about six instructions involving memoryor two to three branch tests of a member against a constant), it may be worth introducing a delegation to one of a number of specialized interface implementations. The process of choosing a class for some purpose is a way that this occurs outside an object; this form of delegation can allow it to be used within an object implementation also.</p>
<h2>Wrap-Up</h2>
<p>
The COM standard is a fairly new technology that already has a great many uses. Hopefully, this cookbook has demonstrated that COM classes can be implemented easily and efficiently. There are a great many techniques that I have not discussed herefor lifetime management, funnels for folding similar methods together, custom handlers for optimizing cross-process performance, building cross-process code for custom interfaces, fly-weight objects, and so on. These techniques may make it into another cookbook at some future time.</p>
<p>
COM is lightweight and adaptable. I am exploring its use as a means of structuring reusable software even within an application, as well as a means of combining software components from different sources. I think it has great potential as a robust means of building component-based software.</p>
<p>
Happy programming!</p>
</BODY>
</HTML>
