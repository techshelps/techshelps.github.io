<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Converting Large Dialogs into Property Sheets</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_satprops"></a>Converting Large Dialogs into Property Sheets</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
January 1995</p>
<h2>Abstract</h2>
<p>
Does your application have dialog boxes that will not fit onto a 640 x 480 display? When your dialog boxes are displayed, do people run screaming from the room? Do you get headaches just looking at some of your dialog boxes because they are so large and confusing? Well, maybe you should think about converting those awe-inspiring dialog boxes into property sheets (also commonly known as tabbed dialog boxes). In this article, I take one such large dialog box and convert it into a property sheet using the built-in <b>CPropertyPage</b> and <b>CPropertySheet</b> classes of Microsoft® Foundation Class Library (MFC) 3.0 in Microsoft Visual C++™ 2.0. By the time you finish reading this article, you should be able to convert your dialog boxes with little effort.</p>
<h2>Who Designed <i>That</i>?</h2>
<p>
If you are like most developers, you know quite a bit about software development, bits, bytes, optimization, and debugging. You may not, however, be the most expert when it comes to designing usable dialog boxes. You may also have run into some problems in your applications where you ended up with either a very large dialog box or a set of endlessly tunneling modal dialog boxes. These dialog boxes may have been the best that you could do without redesigning your application.</p>
<p>
Well, it's no longer necessary for you to have to design these complex dialog boxes. The Microsoft® Foundation Class Library (MFC) 3.0 includes classes for creating and manipulating tabbed dialog boxes (also commonly known as property sheets). Property sheets are easier to use than tunneling dialog boxes and are used extensively in Microsoft's newest operating system, Windows® 95. If you want to add this functionality to your application now, you do not have to wait for the release of Windows 95—you can convert your dialog boxes to property sheets today using Microsoft Visual C++™ 2.0 and MFC 3.0.</p>
<p>
Okay. Take a deep breath and then look at this dialog box for entering satellite tracking data.</p>
<p>
<img src="satprops_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The Satellite Data dialog box</b></p>
<p>
This is the tragic result of allowing developers to design dialog boxes without the aid of usability experts. I think that you will probably agree that the above dialog box is a bit, um, cumbersome. Not to mention that if you are running 640 x 480 screen resolution, you need to scroll to see all of it.</p>
<h2>And Now for Something Completely Different</h2>
<p>
I am going to give you a sneak peek at the property sheet I created to replace the dialog box. As you can see in Figure 2, this property sheet is far easier on the eyes and much less confusing. If cleaning up your dialog boxes appeals to you, read on and follow the steps that I outline below. You will find that you, too, can have cool property sheets and look like an awesome programming stud.</p>
<p>
<img src="satprops_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The General page of the Satellite Properties property sheet</b></p>
<h2>Converting the Dialog Box</h2>
<p>
Converting the dialog box to a property sheet consisted of the following steps:
<ol>
<li>
Group the information in the dialog box based upon how the user will use the property sheet.<br><br></li>
<li>
Create each property page using the resource editor.<br><br></li>
<li>
Use ClassWizard to create a derived class for each page.<br><br></li>
<li>
Create and initialize your property page objects and create the property sheet itself.</li>
</ol>
<h3>Step One: Group the Information</h3>
<p>
To convert the existing dialog box into a series of pages for a property sheet, I first needed to take a look at the dialog box and group the settings based on how the user will need the information. When I was satisfied with the groupings, I was able to proceed to the next step.</p>
<h3>Step Two: Create Each Property Page</h3>
<p>
Use the resource editor to create a dialog box for each property page. The first page you add to the property sheet determines how much space to allocate for the other property pages in the property sheet. Make sure it is as large as the largest page that you need. I first opened the original dialog box, deleted the OK and Cancel buttons, and selected the controls that I wanted for a page. Then I copied and pasted them into the dialog box. The identifiers for the controls in the original dialog box are the same as the identifiers for each control in the tabbed dialog box. And pasting them meant a lot less work for me later because I didn't have to keep track of each ID.</p>
<p>
Set the dialog box styles to standard property page styles. In the Styles page, use the Style list box to set the style of the dialog box to <i>Child</i>, set the Border list box to <i>Thin</i>, and check the Disabled and Titlebar check boxes. Then switch to the General page, and enter the text for that tab into the Caption edit box. For example, I named a tab "Elements," as you'll see in Figure 6 later in this article.</p>
<p>
<img src="satprops_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Dialog Properties property sheet</b></p>
<h3>Step Three: Put ClassWizard to Work for You</h3>
<p>
I then used ClassWizard to create a <b>CPropertyPage</b>-derived class for each page. To create the class, select the dialog box resource, choose ClassWizard from the Project menu, and then choose <b>CPropertyPage</b> as the base class in ClassWizard. By default, ClassWizard will create a .CPP file and an .H file for each of these new classes. As a result, you will have two files for each new class. Include header files at the beginning of the file to make the call to create the property page. If you included a special header file for the original dialog box, remove it.</p>
<p>
<img src="satprops_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Creating a class using ClassWizard</b></p>
<p>
When I created these classes, I also created the member variables to hold the values for each control in the property page. In the original dialog box, I used member variables in each field. To make things a bit easier for conversion, use the exact same names for the member variables for each page.</p>
<p>
<img src="satprops_5.gif" border=0></p>
<p class=label>
<b>Figure 5. Creating member variables using ClassWizard</b></p>
<h3>Step Four: Make Your Declarations and Go!</h3>
<p>
I then declared my property pages and my <b>CPropertySheet</b> object. The constructor for the <b>CPropertySheet</b> object can take three parameters: a caption to be displayed in the caption bar of the property sheet window, a pointer to the parent window, and the index of the page to be shown initially. The pointers to the parent window and the index are optional parameters. If you do not pass them to the constructor, the parent window will be the main window of the application, and the first page selected will be the first page added to the property sheet.</p>
<p>
Add the pages to the property sheet via a call to <b>::AddPage</b>. Then use <b>::DoModal</b> to display and run the property sheet. This is all done in the following substeps:
<ol>
<li>
Remove the directive to include the previous dialog box header file. For example, I had to remove SATDLG.H.<br><br></li>
<li>
Add directives to include the header files for each new class for each page of the property sheet: GENERAL.H, ELEMENTS.H, MODES.H, TRACK.H, and NOTES.H.<p class=tl>
Substitute dialog initialization code with code to initialize each page:</P><pre><code>// Show the editing dialog.
int CSatellite::DoEditDialog()
{
 &nbsp; // Declare a property sheet.
 &nbsp; CPropertySheet dlgPropSheet("Satellite Properties");

 &nbsp; // Declare the pages.
 &nbsp; General genPage;
 &nbsp; Elements eltPage;
 &nbsp; Track trackPage;
 &nbsp; Modes modesPage;
 &nbsp; Notes notesPage;

 &nbsp; // Initialize the General page.
 &nbsp;&nbsp; genPage.m_strName = m_strName;
 &nbsp;&nbsp; genPage.m_dwCatalogNum = m_dwCatalogNum;
 &nbsp;&nbsp; genPage.m_iEpochYear = m_iEpochYear;
 &nbsp;&nbsp; genPage.m_iLaunchYear = m_iLaunchYear;
 &nbsp;&nbsp; genPage.m_dEpochDay = m_dEpochDay;
 &nbsp;&nbsp; genPage.m_iEpochRev = m_iEpochRev;
 &nbsp;&nbsp; genPage.m_iElementSet = m_iElementSet;

 &nbsp; // Initialize the Elements page.
 &nbsp;&nbsp; eltPage.m_dDecayRate = m_dDecayRate;
 &nbsp;&nbsp; eltPage.m_dInclination = m_dInclination;
 &nbsp;&nbsp; eltPage.m_dRightAsAsNode = m_dRightAsAsNode;
 &nbsp;&nbsp; eltPage.m_dEccentricity = m_dEccentricity;
 &nbsp;&nbsp; eltPage.m_dArgOfPerigee = m_dArgOfPerigee;
 &nbsp;&nbsp; eltPage.m_dMeanAnomaly = m_dMeanAnomaly;
 &nbsp;&nbsp; eltPage.m_dMeanMotion = m_dMeanMotion;

 &nbsp; // Intialize the Track page.
 &nbsp;&nbsp; trackPage.m_dBahnLat = m_dBahnLat;
 &nbsp;&nbsp; trackPage.m_dBahnLong = m_dBahnLong;
 &nbsp;&nbsp; trackPage.m_dBeaconFreq1 = m_dBeaconFreq1;
 &nbsp;&nbsp; trackPage.m_dBeaconFreq2 = m_dBeaconFreq2;
 &nbsp;&nbsp; trackPage.m_bTrack = m_bTrack;

 &nbsp; // Initialize the Notes page.
 &nbsp;&nbsp; notesPage.m_strNotes = m_strNotes;

 &nbsp; // Initialize the Modes page.
 &nbsp; int i;
 &nbsp;&nbsp; for (i=0; i&lt;MAXMODES; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_Mode[i].m_iStartPhase != m_Mode[i].m_iEndPhase) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buf[256];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(buf, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "% 3d % 3d&nbsp; %s\r\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Mode[i].m_iStartPhase,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Mode[i].m_iEndPhase,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Mode[i].m_strDescription);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modesPage.m_strModes += buf;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }

 &nbsp; // Add each page.
 &nbsp; dlgPropSheet.AddPage(&amp;genPage);
 &nbsp; dlgPropSheet.AddPage(&amp;eltPage);
 &nbsp; dlgPropSheet.AddPage(&amp;trackPage);
 &nbsp; dlgPropSheet.AddPage(&amp;modesPage);
 &nbsp; dlgPropSheet.AddPage(&amp;notesPage);

 &nbsp; // Invoke the property sheet.
 &nbsp; int iRet;
 &nbsp; if ((iRet = dlgPropSheet.DoModal()) != IDOK)
 &nbsp;&nbsp;&nbsp;&nbsp; return iRet;

 &nbsp; // Update the satellite data.
 &nbsp;&nbsp; m_strName = genPage.m_strName;
 &nbsp;&nbsp; m_dwCatalogNum = genPage.m_dwCatalogNum;
 &nbsp;&nbsp; m_iEpochYear = genPage.m_iEpochYear;
 &nbsp;&nbsp; m_iLaunchYear = genPage.m_iLaunchYear;
 &nbsp;&nbsp; m_dEpochDay = genPage.m_dEpochDay;
 &nbsp;&nbsp; m_iEpochRev = genPage.m_iEpochRev;
 &nbsp;&nbsp; m_iElementSet = genPage.m_iElementSet;
 &nbsp;&nbsp; m_dDecayRate = eltPage.m_dDecayRate;
 &nbsp;&nbsp; m_dInclination = eltPage.m_dInclination;
 &nbsp;&nbsp; m_dRightAsAsNode = eltPage.m_dRightAsAsNode;
 &nbsp;&nbsp; m_dEccentricity = eltPage.m_dEccentricity;
 &nbsp;&nbsp; m_dArgOfPerigee = eltPage.m_dArgOfPerigee;
 &nbsp;&nbsp; m_dMeanAnomaly = eltPage.m_dMeanAnomaly;
 &nbsp;&nbsp; m_dMeanMotion = eltPage.m_dMeanMotion;
 &nbsp;&nbsp; m_dBahnLat = trackPage.m_dBahnLat;
 &nbsp;&nbsp; m_dBahnLong = trackPage.m_dBahnLong;
 &nbsp;&nbsp; m_dBeaconFreq1 = trackPage.m_dBeaconFreq1;
 &nbsp;&nbsp; m_dBeaconFreq2 = trackPage.m_dBeaconFreq2;
 &nbsp;&nbsp; m_bTrack = trackPage.m_bTrack;
 &nbsp;&nbsp; m_strNotes = notesPage.m_strNotes;

 &nbsp;&nbsp; // Reset the mode info.
 &nbsp;&nbsp; for (i=0; i&lt;MAXMODES; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Mode[i].m_iStartPhase = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Mode[i].m_iEndPhase = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Mode[i].m_strDescription = "";
 &nbsp;&nbsp; }
 &nbsp;&nbsp; // Extract the info from the mode string.
 &nbsp;&nbsp; i=0;
 &nbsp;&nbsp; const char *p = modesPage.m_strModes;
 &nbsp;&nbsp; while (i&lt;MAXMODES) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iS, iE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buf[256];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!p || (*p == '\0')) break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Skip any white space
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (*p &amp;&amp; !isgraph(*p)) p++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the start value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iS = atoi(p);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Move on
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (*p &amp;&amp; isdigit(*p)) p++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (*p &amp;&amp; !isgraph(*p)) p++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get end value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iE = atoi(p);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (*p &amp;&amp; isdigit(*p)) p++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (*p &amp;&amp; !isgraph(*p)) p++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get comment
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pb = buf;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (*p &amp;&amp; (*p != '\n') &amp;&amp; (*p != '\r')) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pb++ = *p++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pb = '\0';
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iE != 0) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Mode[i].m_iStartPhase = iS;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Mode[i].m_iEndPhase = iE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Mode[i].m_strDescription = buf;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*p == '\0') break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Advance to start of the next line
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (*p &amp;&amp; ((*p == '\r') || (*p == '\n'))) p++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*p == '\0') break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; ComputeFixedData();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; ComputePosition(Today());
 &nbsp;&nbsp; return iRet;
}
</code></pre>
</li>
</ol>
<h3>What You Get</h3>
<p>
After doing all this work, you are probably wondering what the new and improved property sheet looks like. Bear in mind that usability experts didn't design this. If your company has a usability department, I encourage you to get its feedback about the design of the property pages.</p>
<p>
Following are the rest of the pages in the property sheet I created based upon groupings set up by someone who knows something about satellites (certainly not me!). One comment that I received from a usability expert is that the property sheet design should be organized around the way that the intended user will use the information. Preferably, all the information the user needs to finish a specific task should reside on one tab. The headings that I chose included a tab entitled “General.” This heading is abstract and should be changed to something a bit more descriptive. A better heading might be “Identification.” The point is that the heading should be descriptive enough so that the user of this dialog box (who <i>does</i> know something about satellites) would immediately be able to tab to the correct page by reading the headings.</p>
<p>
<img src="satprops_6.gif" border=0></p>
<p class=label>
<b>Figure 6. The Elements page of the Satellite Properties property sheet</b></p>
<p>
<img src="satprops_7.gif" border=0></p>
<p class=label>
<b>Figure 7. The Tracking page of the Satellite Properties property sheet</b></p>
<p>
<img src="satprops_8.gif" border=0></p>
<p class=label>
<b>Figure 8. The Modes page of the Satellite Properties property sheet</b></p>
<p>
<img src="satprops_9.gif" border=0></p>
<p class=label>
<b>Figure 9. The Notes page of the Satellite Properties property sheet</b></p>
<h3>Great Job, MFC Designers!</h3>
<p>
This whole bit of conversion only took me a couple of hours. To some of you that may seem like a lot of time, but I didn't even write the original code. Had I originally written the code, the amount of time required to convert this dialog box would easily have been under half an hour.</p>
<p>
The people who designed the <b>CPropertySheet</b> class obviously went to a great deal of effort to make it relatively painless to convert your dialog boxes into property pages. For one thing, the methods for gathering input that's entered into property sheets are the same as for dialog boxes. Also, if you have written code for dialog boxes before, you'll find that the code to create and use property sheets is nearly identical.</p>
<h2>Summary</h2>
<p>
Converting large, unruly dialog boxes into small and elegant property sheets is painless and easy if you use the <b>CPropertyPage</b> and <b>CPropertySheet</b> built-in classes of MFC 3.0 and if you use the ClassWizard that is supplied with Visual C++ 2.0. You will not have to learn any new methods for handling property sheets rather than using dialog boxes. The MFC designers have made it as easy as possible to use property sheets rather than dialog boxes. If you would like more information about property sheets in general, see the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_commctl6">
</object><a href=JavaScript:alink_1.Click()>"Win32 Common Controls, Part 6: Tab Controls and Property Sheets"</a> technical article in the MSDN Library.</p>
</BODY>
</HTML>
