<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Stretching 256-Color Images Using Interpolation</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_interp"></a></sup>Stretching 256-Color Images Using Interpolation</h1>
<p>
Nigel Thompson<br>
Microsoft Developer Network Technology Group</p>
<p>
March 7, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4226">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the Interp sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes how a 256-color palettized image can be stretched by a fixed integral factor with excellent performance. The Interp sample application, which accompanies this article, demonstrates stretching by factors of 2, 4, and 8.</p>
<h2>Introduction</h2>
<p>
Many Video for Windows applications are designed with images that are much smaller than common display resolutions. The images are deliberately kept small by two factors: the target machine blt performance and the data transfer rate of image data from its storage medium.</p>
<p>
Because some target machines have much better blt performance than others, but still share a limited data transfer rate (typically from CD-ROM), some attempt is often made to stretch the image at run time to better fit the display. Using a simple call to <b>StretchBlt</b> (or <b>WinGStretchBlt</b>) results in large blocky images as the individual pixels of the source image are magnified.</p>
<p>
A better solution would be to expand the source image to the destination image, interpolating between the source image pixels in order to provide a smoother-looking destination image. This technique is simple to do on 16-, 24-, or 32-bit-per-pixel (bpp) images, but is difficult to do for a 256-color, 8-bpp palettized image, because for each new interpolated pixel value, a search must be done to find the nearest color in the image's palette. Searching for matching colors in a palette is extremely slow.</p>
<h2>Interpolating with Tables</h2>
<p>
Let's consider stretching an image by a factor of 2. Figure 1 shows how the pixels from a 2 x 2 source image would be stretched to a 4 x 4 destination image.</p>
<p>
<img src="interp_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Stretching a 2 x 2 image by a factor of 2</b></p>
<p>
The pixels from the source image are copied sparsely to the destination (cells <b>a</b>, <b>c</b>, <b>I</b> and <b>k</b>). The remainder of the destination cells need to be constructed in some way. The simplest and fastest way to construct the missing destination cells is simply to replicate the source cells. So cell <b>b</b> in the destination is a copy of cell <b>a</b>. Cell <b>d</b> is a copy of cell <b>c</b>, and the row <b>e</b> through <b>h</b> is simply a copy of the row <b>a</b> through <b>d</b>. This simple method results in the "big pixel" rendition we are used to when we call <b>StretchBlt</b> in Windows®.</p>
<p>
A better solution is to fill in the missing pixels in the destination with colors interpolated from its nearest neighbors. There are many possible algorithms for doing this, but what we are after here is speed, so I chose to simply create the new pixel based on the colors of two of its neighbors. Referring again to Figure 1, pixel <b>b</b> is generated by averaging the colors of pixels <b>a</b> and <b>c</b>. Pixel <b>j</b> is the average of pixels <b>I</b> and <b>k</b>. Pixel <b>e</b> is the average of pixels <b>a</b> and <b>I</b>. Because pixel <b>d</b> has no neighbor on the right side, it is simply a copy of pixel <b>c</b>. Pixel <b>h</b> is constructed as the average of pixels <b>d</b> and <b>l</b>. OK, so you see the idea. We sparsely copy the source lines to the destination. We walk over those lines, filling in the gaps. We then walk the destination lines, filling in the lines that are missing by averaging them from the lines above and below. The last line of the destination is simply a copy of the line above it.</p>
<p>
So how do we average the colors of two pixels? The simplest (but probably not the best) way is to take the red, green, and blue values of the two pixels and average them. Then find a new color as close as possible in the image's palette that matches the new RGB value. Looking up palette index values with <b>GetNearestPaletteIndex</b> is extremely slow, so we build a lookup table of 256 x 256, which contains the results of looking up every possible pair of colors in the image. Finding the average is simply a matter of looking up the correct index value in the table.</p>
<p>
Note that the table contains some redundancy since the average of index values 1 and 2 is the same as the average of index values 2 and 1.</p>
<h2>The Interp Sample Application</h2>
<p>
The Interp sample application was built using Visual C++™ version 2.0 to be a simple multiple-document-interface (MDI) application. When an image file is opened, two things happen. First, a new lookup table is created from the image's palette. Second, a series of images stretched from the source image are draw to the screen. The image is stretched 2, 4, and 8 times into the output window. Menu items allow you to select regular <b>StretchBlt</b>-type stretching or interpolated stretching.</p>
<p>
Let's look at the code that creates the interpolation table from the image's palette:</p>
<pre><code>// Build a new interpolation map.
 &nbsp;&nbsp; PALETTEENTRY pe[256];
 &nbsp;&nbsp; int r1, g1, b1, r2, g2, b2;
 &nbsp;&nbsp; BYTE pixel;
 &nbsp;&nbsp; pDoc-&gt;m_pal.GetPaletteEntries(0, 256, pe);
 &nbsp;&nbsp; for (int i = 0; i &lt; 256; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r1 = pe[i].peRed;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g1 = pe[i].peGreen;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1 = pe[i].peBlue;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = i; j &lt; 256; j++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i == j) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Imap2[i][j] = i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2 = pe[j].peRed;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g2 = pe[j].peGreen;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b2 = pe[j].peBlue;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pixel = pDoc-&gt;m_pal.GetNearestPaletteIndex(RGB((r1+r2)/2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (g1+g2)/2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (b1+b2)/2));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Imap2[i][j] = pixel;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Imap2[j][i] = pixel;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
</code></pre>
<p>
Note that the redundant parts of the table are simply copied to save time.</p>
<p>
To stretch an image with interpolation, this routine is used:</p>
<pre><code>void CInterpView::Interp2(int xd, int yd, int wd, int hd, int xs, int ys)
{
 &nbsp;&nbsp; // Copy source to dest, stretching by 2.
 &nbsp;&nbsp; int ws = wd / 2;
 &nbsp;&nbsp; int hs = wd / 2;

 &nbsp;&nbsp; BITMAPINFO* pBMI = m_dsBuffer.GetBitmapInfoAddress();
 &nbsp;&nbsp; ASSERT(pBMI);
 &nbsp;&nbsp; ASSERT(pBMI-&gt;bmiHeader.biBitCount == 8);
 &nbsp;&nbsp; // Test for silly cases.
 &nbsp;&nbsp; if (ws == 0 || hs == 0) return;

 &nbsp;&nbsp; // Get pointers to the start points in the source and destination
 &nbsp;&nbsp; // DIBs. Note that this will be the bottom-left corner of
 &nbsp;&nbsp; // the DIB because the scan lines are reversed in memory.
 &nbsp;&nbsp; BYTE* pSrcLine = (BYTE*)m_dsBuffer.GetPixelAddress(xs, ys + hs - 1);
 &nbsp;&nbsp; ASSERT(pSrcLine);
 &nbsp;&nbsp; BYTE* pDestLine = (BYTE*)m_dsBuffer.GetPixelAddress(xd, yd + hs*2 - 1);
 &nbsp;&nbsp; ASSERT(pDestLine);

 &nbsp;&nbsp; // Get the scan line widths of each DIB.
 &nbsp;&nbsp; int iScanS = m_dsBuffer.GetStorageWidth();
 &nbsp;&nbsp; int iScanD = m_dsBuffer.GetStorageWidth();

 &nbsp;&nbsp; BYTE* pd;
 &nbsp;&nbsp; BYTE* ps;
 &nbsp;&nbsp; BYTE* ps1;
 &nbsp;&nbsp; BYTE* ps2;
 &nbsp;&nbsp; int i;
 &nbsp;&nbsp; // Process each source line.
 &nbsp;&nbsp; for (int l = 0; l &lt; hs; l++) {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Copy the source pixels to every other destination pixel.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pd = pDestLine;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps = pSrcLine;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; ws; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pd = *ps++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pd += 2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Fill in the gaps with the average of the pixels either side.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps1 = pDestLine;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps2 = pDestLine + 2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pd = pDestLine + 1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; ws - 1; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pd = m_Imap2[*ps1][*ps2];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps1 += 2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps2 += 2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pd += 2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The last pixel is a simple copy of the one before it.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pd = *ps1;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDestLine += iScanD * 2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSrcLine += iScanS;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Process the missing lines in the destination.
 &nbsp;&nbsp; pSrcLine = (BYTE*)m_dsBuffer.GetPixelAddress(xd, yd + hs*2 - 1);
 &nbsp;&nbsp; ASSERT(pSrcLine);

 &nbsp;&nbsp; for (l = 0; l &lt; hs-1; l++) {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps1 = pSrcLine;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps2 = pSrcLine + iScanD * 2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pd = pSrcLine + iScanD;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; wd; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pd++ = m_Imap2[*ps1++][*ps2++];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSrcLine += iScanS * 2;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // The last line is a simple copy of the one before it.
 &nbsp;&nbsp; ps = pSrcLine;
 &nbsp;&nbsp; pd = pSrcLine + iScanD;
 &nbsp;&nbsp; for (i = 0; i &lt; wd; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pd++ = *ps++;
 &nbsp;&nbsp; }
}
</code></pre>
<p>
Note that <b>Interp2</b> stretches chunks of the off-screen buffer and that its arguments would need to be modified slightly to be more like <b>StretchBlt</b>.</p>
<h2>Other Stretch Factors</h2>
<p>
It's fairly easy to modify the sample to expand by 3 instead of 2. You will need two lookup tables instead of one. One table will look up the 1/3 distance between two pixels; the other table will look up the 2/3 value.</p>
</BODY>
</HTML>
