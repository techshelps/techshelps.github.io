<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Windows NT Kernel-Mode Driver Cookbook, Featuring Visual C++</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_msvcdrv"></a>The Windows NT Kernel-Mode Driver Cookbook, Featuring Visual C++</h1>
<p>
Ruediger R. Asche<br>
Microsoft Developer Network Technology Group</p>
<p>
January 27, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3273">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the CPPDRV sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article is the first part of a two-part series that describes how to write Windows NT™ kernel-mode drivers in C++ using the Microsoft® Visual C++™ version 2.0 development system. This article focuses on the pragmatics of writing the driver—building the make file, setting up the debugging environment, installing a driver, using symbols, and source-level debugging the driver—while the second article, <a href="msdn_ntcpp.htm">"Writing Windows NT Kernel-Mode Drivers in C++,"</a> focuses on the C++ aspects of developing kernel-mode drivers. </p>
<h2>Introduction</h2>
<p>
Before I go into anything technical, I would like to let you, dear reader, know that I am very proud of this article. Why? Well, after I finished the associated sample, my colleague Dale Rogerson dropped by my office, and I said unto him, "Dale, you must check this out!" And so I popped up Microsoft® Visual C++™, went through the source code, looked up symbols, built a call graph, and did all the cool things you can do with Visual C++. Dale wasn't impressed. Then I popped up WinDbg, double-clicked a line in a source file, and typed something on the other machine. The highlighted line in the WinDbg source file changed color, and with repeated F10 keystrokes, I single-stepped through the code. Source-level debugging!</p>
<p>
Dale still wasn't impressed. "So?" he said. "Well, Dale," I explained, "This is a KERNEL-MODE DEVICE DRIVER." Dale cracked up. "Ruediger, this time you have out-nerded me." If that's not a reason to be proud, I don't know what is.</p>
<p>
This article serves two purposes: First, it introduces you to the pragmatics of writing Windows NT™ kernel-mode device drivers (tools you need, coding, symbolic debugging, testing), and second, it explains how to write a driver using the Microsoft Visual C++ environment. You can exploit the powerful features of Visual C++, such as the ability to browse source files or display class hierarchies—these features come in <i>very</i> handy when you're performing a complex task such as writing a device driver. By modifying the Visual C++ project appropriately, you can generate debug versions of your drivers that can be source-level debugged with the WinDbg utility.</p>
<p>
The first section of this article, "The Basics," provides "one-stop shopping" for learning the mechanics of writing Windows NT kernel-mode device drivers. If you are already familiar with writing device drivers and are eager to learn how to use Visual C++, you can safely start with the third section, "Switching to Visual C++."</p>
<p>
You cannot use Visual C++ version 2.0 to debug your driver, because you need kernel debug capabilities (which are not provided by Visual C++) to do that. It's sort of a bummer that you need different tools to build and debug your driver, but that's life. If you are used to debugging with Visual C++, you will find that the WinDbg interface is very similar to the Visual C++ IDE, only much more powerful.</p>
<p>
To prevent this discussion from becoming too theoretical, I have taken one driver from the Windows NT Device Driver Kit (DDK) and modified the driver project files to demonstrate what we are talking about. To be more precise, I have taken two drivers—the mouse and keyboard class drivers—and merged them into one because the underlying code is almost identical.</p>
<p>
The <a href="msdn_ntcpp.htm">"Writing Windows NT Kernel-Mode Drivers in C++"</a> article in the Development Library complements this article; it describes how you can exploit the features of C++ to understand and write device drivers more easily.</p>
<p>
I assume that you have at least a rudimentary knowledge of Windows NT kernel-mode device drivers before you attack this article. For those of you who don't (in particular, those who start writing drivers for Windows NT from scratch), I begin this article by explaining the basics of device drivers. Please refer also to the article <a href="msdn_lildev.htm">"The Little Device Driver Writer"</a> in the Development Library for more information on Windows NT device drivers.</p>
<h2>The Basics</h2>
<p>
A Windows NT kernel-mode device driver implements the "lower end" of the operating system's I/O system. That is, Windows NT accepts an I/O request from an application, packs it up in a well-defined form, and passes the request to a driver. The driver must implement a predefined set of entry points. The driver executes trusted code that might crash the entire system if it fails. Thus, the driver must handle all possible failures in a well-defined and predictable way.</p>
<p>
Kernel drivers implement a maximum of around 10 entry points that can be called by the I/O system in Windows NT, including driver opened, driver closed, device opened, device closed, read from device, write to device, device I/O control, and interrupt service routine.</p>
<p>
Unlike application code, drivers cannot link with the standard C run-time routines. If device drivers need support for tasks such as logging errors, outputting messages to the debugger, accessing character strings, or allocating memory, they need to call the operating system. The libraries and header files that provide the necessary entry points or prototypes are shipped with the Windows NT DDK; the information can be found in the <i>Kernel-Mode Driver Reference </i>in the Development Library (see Product Documentation, DDKs, Windows NT 3.5 Device Driver Kit, Kernel-mode Drivers, Reference).</p>
<p>
You can build two versions of your driver: the "free" version (in Visual C++ terminology, this corresponds to the "retail" version) or the "checked" version (corresponding to the "debug" version).</p>
<h3>Setting Up a Debugger</h3>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Most of the information in this section can also be found in the Windows NT DDK (see Product Documentation, DDKs, in the Development Library), but I decided to include it here for the sake of "one-stop shopping."</p>
<p>
If you wish to debug your driver, you will need to set up a debugging system, which consists of two machines running Windows NT. To debug your driver, you can use either the KD console debugger or WinDbg, which is a graphical user interface (GUI) debugger. In this article, I will describe how to use WinDbg to debug a driver. The debugger machine (also referred to as the "host") runs WinDbg, and the debuggee (also referred to as the "target") runs the system with the driver that you wish to debug.</p>
<p>
You can optionally install the checked build of Windows NT on your target machine, but there is no need to do that—the symbols and everything will be there as long as you build the checked version of the driver. The checked version of Windows NT may be useful for obtaining additional debugging information on the Windows NT kernel.</p>
<p>
You can connect the host and target machines either with a serial cable or through a network using a named pipe transport. If you have trouble getting the serial transport to work, connect the two Windows NT machines with a serial cable (pins 2 and 3 crossed). Run the Windows Terminal application on both machines, choose corresponding communication settings, and see if you can send information back and forth between the two machines. If you can, your hardware and communications are fine.</p>
<p>
To set up your debugging system, follow the instructions below for the target and host machines.</p>
<h4>Instructions for the target machine</h4>
<p>
Make sure that you have a debug option in the BOOT.INI file of the target machine. If you do, the target machine will display a multi-boot screen with a debug option when it starts up. If that is not the case, follow these steps:
<ul type=disc>
<li>
Edit the BOOT.INI file. This file is located in the root directory of your boot partition, and is normally flagged as hidden and read-only. Using the <b>Attrib</b> command or the File Manager, remove those two attributes from BOOT.INI, and edit the file. In the <b>[operating systems]</b> section of the BOOT.INI file, copy the line that looks something like this:<pre><code>multi(0)disk(0)rdisk(0)partition(1)\winnt="Windows NT" 
</code></pre>
<p class=tl>
to a new line. Append the switches <b>/DEBUGPORT=<i>port</i></b> (COM1 or COM2) and <b>/BAUDRATE=<i>data transfer speed</i> </b>to the new line, for example:</P><pre><code>multi(0)disk(0)rdisk(0)partition(1)\winnt="Windows NT"&nbsp; /DebugPort=COM1 
/BaudRate=9600
</code></pre>
<p class=tl>
Save the BOOT.INI file, and reset the file attributes to hidden and read-only.</P></li>
<li>
When you shut down and restart the target machine, your boot screen should now offer you an additional choice:<pre><code>Windows NT [debugger enabled]
</code></pre>
<p class=tl>
If you don't see "[debugger enabled]" on that line, the debugging switch was ignored. On some machines, the boot loader expects the debugging switch to be in a special position on the command line. If your command line has multiple switches, try rearranging the switches.</P></li>
<li>
Reboot the target machine, select the debug version of Windows NT from the boot screen, and wait for the blue screen. At the top of the screen, you should now see something like the following:<pre><code>Kernel Debugger Using: COM2 (Port 0x2f8, Baud rate 9600),
</code></pre>
<p class=tl>
and "SND" flashing in the upper-right corner of the screen.</P><p class=tl>
If the kernel debugger wasn't started on the host machine, you will see "SND" flash a few more times, and the operating system will load as usual, with no debugger support. If you do not see the message above, the target machine has not been configured correctly.</P></li>
</ul>
<h4>Instructions for the host machine</h4>
<p>
Meanwhile, on the host machine:</p>
<p>
Run WINDBG.EXE. </p>
<p>
Make sure that the host machine has the following files:
<ul type=disc>
<li>
Copies of NTOSKRNL.EXE and HAL.DLL from the system directory of the target machine.<br><br></li>
<li>
Copies of the driver binaries that you wish to debug. Specify the location of these files in the Options/User/DLLs/Symbol Search Paths dialog box in WinDbg.<br><br></li>
<li>
Copies of the source file(s) for your driver. Specify the location of these files in the Options/Debug/Source Search Path dialog box in WinDbg.</li>
</ul>
<p>
You do <b>not</b> need to modify any environment variables on the host machine. </p>
<p>
From the WinDbg Options menu, choose Kernel Debugger, and select the appropriate options for your transport.</p>
<p>
From the WinDbg Program menu, choose Open, select the copy of NTOSKRNL.EXE, and choose Go from the Run menu.</p>
<p>
The command window of WinDbg should now display something like the following:</p>
<pre><code>Kernel debugger waiting to connect on com2 @ 9600 baud
</code></pre>
<p>
As soon as you reboot the target machine, you should see the following displayed in the WinDbg command window:</p>
<pre><code>Kernel Debugger connection established on com2 @ 9600 baud
Kernel Version 807 Free loaded @ 0x80100000
</code></pre>
<p>
followed by a genial exchange of messages between the target and the host (indicated by "SND" and "RCV" merrily flickering on the top line of the target machine's blue screen, and a number of messages in the WinDbg command window on the host machine).</p>
<p>
If you have reached this point, your kernel debugger is set up correctly, and you are ready to rock and roll.</p>
<h2>Building Drivers in the DDK Environment</h2>
<p>
When you install the Windows NT DDK, your environment is, by default, set up to work with the build tools from the DDK. If you have not built a driver with the DDK yet, you should first take the time to figure out if it works correctly—if it doesn't, you will definitely not be able to build the driver in Visual C++. Follow the steps below.</p>
<h3>Do the Homework First . . .</h3>
<p>
The DDK installation program will have created a new program group called "Windows NT DDK" in Program Manager. In this program group, double-click the Checked Build icon to open up a command prompt, which will provide you with an environment for building checked versions of your driver. From the command prompt, switch to the directory that contains one of the sample drivers, for example:</p>
<pre><code>cd c:\ddk\src\input\kbdclass
</code></pre>
<p>
and type:</p>
<pre><code>build
</code></pre>
<p>
If everything is set up correctly, this command will start the build process for the kbdclass driver (or whatever you selected), and, if successful, will place the driver in the default target directory (for example, C:\DDK\LIB\I386\CHECKED). Note that the build process also generates a file called BUILD.LOG in the current directory—this file contains the complete output from the build process.</p>
<p>
You can build the driver on the host machine or the target machine—it doesn't really matter. If you build the driver on the target machine, you must copy the source and binary files to the host machine first. If you build the driver on the host machine, you will need to copy the driver's binary file to the target machine. Thus, building the driver on the host is probably a little more efficient. In the remainder of this section, I will assume that you built the driver on the host machine.</p>
<p>
If the driver you need to build is a file system or disk driver, it is a good idea to keep a copy (or the originals) of the source files for your driver somewhere on the host at all times—otherwise, a driver bug that wipes out your hard drive may provide you with an enlightening experience.</p>
<h3>Did You Do Everything Right?</h3>
<p>
Next, you should check to see whether symbolic debugging works. Copy the binary of the checked version of the driver to the target machine—either to your %SYSTEMROOT%\SYSTEM32\DRIVERS directory, or to a custom directory. In the latter case, you need to modify the Registry to point to that directory in the HKEY_LOCAL_MACHINE\CurrentControlSet\Services\<i>driver-name</i>\ImagePath key. If you have trouble installing your driver, please refer to the next section, "Installing the Driver."</p>
<p>
If the checked version of the driver has been built correctly, you should now be able to symbolically debug the driver. If the symbols for your driver have already been loaded, you will see a line similar to:</p>
<pre><code>Module Load: <i>drivername</i>.sys (symbol load deferred)
</code></pre>
<p>
in the WinDbg command window. From the WinDbg command prompt, you can now type:</p>
<pre><code>ld <i>drivername</i>
</code></pre>
<p>
WinDbg will display one of the following messages:
<ul type=disc>
<li>
"Symbols loaded." This message indicates that the symbols have been loaded correctly. You can now view the symbols (for example, using the <b>xe <i>drivername</i>!*</b> command from the WinDbg command prompt), set symbolic breakpoints, load a source file and set a breakpoint using F9, single-step through the source file, and so on. If you are at this point, continue with the next section.<br><br></li>
<li>
"No symbols loaded." This message indicates that either the source file/binary paths in WinDbg were not set correctly (go back to the section "Setting Up a Debugger"), or no symbols exist in the driver binary. If you are using the standard make file that comes with the DDK, this should not happen. Did you perhaps build the free version of the driver instead of the checked version? See the "Switching to Visual C++" section below.<br><br></li>
<li>
"Symbol format not supported." This message indicates that some of the linker options are incorrect. Proceed with the "Switching to Visual C++" section.</li>
</ul>
<h3>Installing the Driver</h3>
<p>
If you're rebuilding an existing driver, you do not need to do anything special to install the driver because Windows NT already knows about it. If you're building a custom driver, however, you must first tell Window NT to add the driver to the system. To do that, you must add a few entries to the Registry.</p>
<p>
For the shipping version of the driver, you will want to write an installation program that uses the Registry functions to create the appropriate keys and values. For the development process, you can edit the Registry by hand using the REGEDT32 program. Note that adding device-driver entries to the system Registry requires special privileges. If REGEDT32 does not allow you to add the appropriate entries, log off the target machine and log on as an administrator, or manipulate the Registry from an administrator machine.</p>
<p>
You will need to add a new key under HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services. Please see the Windows NT DDK, <i>Programmer's Guide</i>, Part 1, Chapter 2 (under Product Documentation, DDKs, Windows NT 3.5 Device Driver Kit, in the Microsoft Developer Network Library) for details.</p>
<h2>Switching to Visual C++</h2>
<p>
Now that we have all the pieces we need to build a driver with the DDK, let's move on to Microsoft Visual C++. Once you have built the driver with Visual C++, why not switch to C++ to write your driver? If you're game, read the article <a href="msdn_ntcpp.htm">"Writing Windows NT Kernel-Mode Drivers in C++"</a> in the Development Library.</p>
<p>
The main reason to exploit Visual C++ to build your driver is that the Visual C++ integrated development environment (IDE) offers a number of very powerful features that you can use to simplify the development process. For example, given a project it can understand, Visual C++ builds a browse table that lets you jump from a function call to the function's definition in no time flat, lets you search the entire project for definitions and references of symbols, lets you jump to a compilation error by double-clicking the error message line, and so on.</p>
<p>
To exploit all of these features, you need to generate a project for your driver. Unfortunately, AppWizard in Visual C++ does not currently support device drivers, so you need to tweak the project yourself using the Settings dialog boxes from the Visual C++ Project menu. But let's start at the beginning, where it makes sense to begin, and generate a project.</p>
<p>
All of the steps I describe are applicable to the Visual C++ version 2.0 (32-bit) IDE.</p>
<h3>Step 1: Create a New Project</h3>
<p>
From the Visual C++ File menu, choose New, generate a new project, and add the source file(s) for your driver to the project. For the time being, select "Dynamic-Link Library" as the project type. You might also want to rename the targets as "NT Kernel-Mode Driver (Release)" and "NT Kernel-Mode Driver (Debug)," or something along those lines.</p>
<p>
At this point, it is probably a good idea to choose Options from the Tools menu, select the Directories tab, and add the directories for the DDK libraries and include files to the appropriate search directories.</p>
<h3>Step 2: Change the Compiler Options</h3>
<p>
The Windows NT DDK header files expect a certain number of defined constants in the preprocessor options. These constants may vary slightly from driver to driver—if you run into any preprocessor trouble, the safe bet is to proceed as follows: Build the driver using the DDK build process (as described earlier in this article), load the BUILD.LOG file into an editor, and compare the compiler options specified in the log files with the options set in your Visual C++ project—this is the exact process I used to port my project to Visual C++.</p>
<p>
The preprocessor options that I determined would work for my driver were: _X86, _I386, STD_CALL, CONDITION_HANDLING, WIN32_LEAN_AND_MEAN, and NT_UP. I undefined the symbol NT_INST. In the debug (checked) version of the driver, I also defined DBG. </p>
<p>
Note that most drivers in the DDK have local include files, the paths of which you need to add to the project as well.</p>
<p>
For the code generation options, you should, at the minimum, select the <b>__stdcall</b> option (<i>/G7</i>) and ensure 64-bit alignment of structures (8 bytes). You can safely ignore the run-time library settings—these only add preprocessor <b>DEFINE </b>statements to the compile line, and those <b>DEFINE</b>s are pretty much bogus because we do not rely on any run-time libraries. Precompiled headers and C++ options can be ignored for the time being.</p>
<p>
I don't see how the C language options would affect the driver, so play it by ear here. I decided to include the <i>/Gf</i> and <i>/Gy</i> options (check the boxes for enabling function-level linking and eliminating duplicate strings). For the optimization options, I chose disable optimization (<i>/Od</i>) for the checked version and full optimization (<i>/Ox</i> and <i>/Oy–</i>) for the free version.</p>
<h3>Step 3: Select the Linker Options</h3>
<p>
The linker options are probably the trickiest ones to handle, because some of the options you must specify are not offered by the predefined interface. </p>
<p>
First, delete all the default libraries shown in the Object/Library Modules text box, and insert NTOSKRNL.LIB and HAL.LIB instead. NTOSKRNL.LIB contains the entry points for almost all of the system services that a driver needs to access, and HAL.LIB contains the entry points for the routines that the hardware abstraction layer (HAL.DLL) provides. For some driver types, you might need additional libraries.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;For the checked and free versions of the driver, you need to link your driver with different versions of the libraries, so you should probably either override the library path in the free (or checked) linker option, or specify the full library path in the Object/Library Modules text box.</p>
<p>
You will also want to select the Ignore All Default Libraries check box to prevent accidental linkage with one of the user-mode run-time libraries (which will cause all hell to break loose).</p>
<p>
In the Project Options text box, change the entry:</p>
<pre><code>/Subsystem: Windows
</code></pre>
<p>
to:</p>
<pre><code>/Subsystem: native
</code></pre>
<p>
This entry will tell the linker to build a kernel-mode module. In the Output category, change the entry point symbol to <b>DriverEntry@8</b>. All other options depend on the selections you made for your driver.</p>
<p>
For the free version of your driver, your work is complete. There is a small problem involving the checked version, however. For WinDbg to be able to find your symbols, your link line must contain the following two entries:</p>
<pre><code>/DEBUG:full 
</code></pre>
<p>
and:</p>
<pre><code>/DEBUGTYPE: both
</code></pre>
<p>
Unfortunately, Visual C++ does not understand the <b>/DEBUG:full</b> entry, and, even worse, will not allow you to set both options on the same link line. The only way I was able to link the driver with symbols that WinDbg could understand was to invoke the linker manually with both debug options set. One way to accomplish that would be to write a batch file that you invoke after Visual C++ finishes compiling, or to delete the executable after Visual C++ is done and run a custom, external make file that contains only the link line. My solution to the problem is both sleazy and pragmatic: First, I built a sample driver using the DDK, copied the resulting log file to a file with the .LNK extension, edited the .LNK file so it contained the link options that the DDK make file had set earlier, and added the project-specific input and output files. The MOUCLASS.LNK file looks like this:</p>
<pre><code>-MERGE:.CRT=.data -MERGE:_PAGE=PAGE -MERGE:_TEXT=.text 
-SECTION:INIT,d 
-PDB:NONE 
-RELEASE 
-FORCE 
-INCREMENTAL:NO&nbsp; 
-NODEFAULTLIB 
-IGNORE:4037,4065&nbsp; 
-debug:FULL 
-debugtype:both 
-machine:i386 
-ENTRY:DriverEntry@8 
-align:0x20&nbsp; 
-subsystem:native&nbsp; 
-base:0x10000 
-out:C:\DDK\lib\i386\checked\mouclass.sys&nbsp; 
c:\ddk\lib\i386\checked\ntoskrnl.lib 
c:\ddk\lib\i386\checked\hal.lib 
windebug\inpclass.obj 
windebug\drvclass.obj 
windebug\mclasses.obj
</code></pre>
<p>
Now all we have to do to build the driver is to run:</p>
<pre><code>link @<i>drivername</i>.lnk
</code></pre>
<p>
Note that you will need to do this "external linking" only for the checked (debug) version of the driver.</p>
<p>
You should now select Build from the Project menu. As the build progresses in the Visual C++ build window, you can double-click error messages to pop up the appropriate source windows.</p>
<p>
If the build is successful, you should now copy the driver binary to the target machine and begin debugging, following my instructions in the section "Did You Do Everything Right?" earlier in this article.</p>
<h2>Summary</h2>
<p>
The powerful Visual C++ IDE provides a great advantage when you're building Windows NT kernel-mode drivers. Although Visual C++ does not currently allow you to debug a device driver, the combination of Visual C++ and WinDbg can significantly facilitate the development of a Windows NT kernel-mode device driver.</p>
</BODY>
</HTML>
