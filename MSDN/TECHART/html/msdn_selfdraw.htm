<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFC Self-Drawing Menus</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_selfdraw"></a></sup>MFC Self-Drawing Menus</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
April 18, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4055">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the EasyBit sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4058">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the GLlib DLL for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes how to implement self-drawing menus with the Microsoft® Foundation Class (MFC) Library. Self-drawing menus provide an object-oriented way to implement owner-drawn menus. Owner-drawn menus are drawn by the menu owner, usually the frame window, instead of the Microsoft Windows® operating system. Self-drawing menus, on the other hand, are drawn by an object derived from the <b>CMenu</b> class. The EasyBit sample application, which accompanies this article, and CTRLTEST, which accompanies Visual C++™, demonstrate self-drawing menus.</p>
<h2>Introduction</h2>
<p>
Sometimes plain text is not enough. Sometimes you need different typefaces, different point sizes, or different attributes, such as bold or italics, to communicate information to your users. Sometimes a picture is worth a thousand words. This is true for menus: In most instances, plain text is perfectly suitable for explaining the function of menu items, but in some cases, using a picture results in a better, more intuitive, interface. A menu that shows colors instead of listing their names, a menu that illustrates fonts or font effects in addition to naming them, and an owner-drawn menu that shows pen widths instead of simply providing measurements are examples of menus that benefit from non-textual representation. Owner-drawn menus were created for these situations. Owner-drawn menus behave the same as normal menus, but they are drawn by the application and not by the Microsoft® Windows® operating system. The application can draw whatever it desires for an owner-drawn menu item.</p>
<p>
The Microsoft Foundation Class (MFC) Library has introduced self-drawing menus, which extend the idea of owner-drawn menus. Self-drawing menus are drawn neither by the menu owner nor by Windows, but by an object derived from the MFC <b>CMenu</b> class. This article explores self-drawing menus and covers the following topics:
<ul type=disc>
<li>
How a self-drawing menu differs from an owner-drawn menu<br><br></li>
<li>
How MFC implements self-drawing menus<br><br></li>
<li>
How to change an existing menu into a self-drawing menu<br><br></li>
<li>
How to add a self-drawing menu at run time</li>
</ul>
<h2>Owner-Drawn vs. Self-Drawing Menus</h2>
<p>
The Windows operating system is responsible for drawing menus, but it is not responsible for drawing owner-drawn menus. As the term "owner-drawn" indicates, the window that owns a menu is responsible for drawing owner-drawn menus. The menu sends WM_MEASUREITEM and WM_DRAWITEM messages to its owner whenever an owner-drawn menu item needs to be drawn. Figure 1 shows this process.</p>
<p>
<img src="selfdraw_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Process for owner-drawn menus</b></p>
<p>
Owner-drawn menus add color and flair to a program. However, having the menu owner draw the menu isn't a very object-oriented approach, because it groups the menu-drawing code with the window-drawing code. Why doesn't the menu draw itself? That's exactly what MFC does with self-drawing menus. Instead of putting the drawing code in your view class, you place it in a menu class derived from <b>CMenu</b>. This process is illustrated in Figure 2.</p>
<p>
<img src="selfdraw_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Process for self-drawing menus</b></p>
<p>
Basically, owner-drawn menus are the same as self-drawing menus—the only real difference lies in the location of the code. The code for an owner-drawn menu resides with the window-drawing code, whereas the code for a self-drawing menu is located in the menu's own class. Furthermore, it is easier to use self-drawing menu classes in other applications.</p>
<h2>Self-Drawing Mechanics</h2>
<p>
MFC adds a little magic behind the scenes to turn owner-drawn menus into self-drawing menus. The <b>CWnd </b>object that owns a menu forwards WM_MEASUREITEM and WM_DRAWITEM messages to the appropriate <b>CMenu</b> object for handling. The magic happens in <b>CWnd::OnMeasureItem</b> and <b>CWnd::OnDrawItem</b>, which can be found in WINCORE.CPP. The code for <b>CWnd::OnMeasureItem</b> (with some of the error-checking code removed) is shown below.</p>
<pre><code>// Measure item implementation relies on unique control/menu IDs.
void CWnd::OnMeasureItem( int /*nIDCtl*/, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
 &nbsp; if (lpMeasureItemStruct-&gt;CtlType == ODT_MENU)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CMenu* pMenu;

 &nbsp;&nbsp;&nbsp;&nbsp; AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
 &nbsp;&nbsp;&nbsp;&nbsp; if (pThreadState-&gt;m_hTrackingWindow == m_hWnd)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Start from pop-up menu.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMenu = CMenu::FromHandle(pThreadState-&gt;m_hTrackingMenu);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Start from menu bar.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMenu = GetMenu();
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp; pMenu = FindPopupMenuFromID(pMenu, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpMeasureItemStruct-&gt;itemID);
 &nbsp;&nbsp;&nbsp;&nbsp; if (pMenu != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMenu-&gt;MeasureItem(lpMeasureItemStruct);
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE1("Warning: unknown WM_MEASUREITEM for menu item 0x%04X.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpMeasureItemStruct-&gt;itemID);
 &nbsp; }
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CWnd* pChild 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = GetDescendantWindow(lpMeasureItemStruct-&gt;CtlID, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp; if (pChild != NULL &amp;&amp; pChild-&gt;SendChildNotifyLastMsg())
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;&nbsp;&nbsp;&nbsp; // eaten by child
 &nbsp; }
 &nbsp; // Not handled - do default.
 &nbsp; Default();
}
</code></pre>
<p>
The key piece in the above code is the call to <b>FindPopupMenuFromID</b>, which is listed below.</p>
<pre><code>static CMenu* FindPopupMenuFromID(CMenu* pMenu, UINT nID)
{
 &nbsp; ASSERT_VALID(pMenu);
 &nbsp; // Walk through all items, looking for ID match.
 &nbsp; UINT nItems = pMenu-&gt;GetMenuItemCount();
 &nbsp; for (int iItem = 0; iItem &lt; (int)nItems; iItem++)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CMenu* pPopup = pMenu-&gt;GetSubMenu(iItem);
 &nbsp;&nbsp;&nbsp;&nbsp; if (pPopup != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Find child pop-up menu.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPopup = FindPopupMenuFromID(pPopup, nID);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // check popups on this popup
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pPopup != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pPopup;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else if (pMenu-&gt;GetMenuItemID(iItem) == nID)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // It is a normal item inside our pop-up menu.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMenu = CMenu::FromHandlePermanent(pMenu-&gt;m_hMenu);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pMenu;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
 &nbsp; // Not found.
 &nbsp; return NULL;
}
</code></pre>
<p>
<b>FindPopupMenuFromID</b> starts with the main menu bar and descends to each child pop-up menu looking for the ID of the command that generated the WM_MEASUREITEM message. If it finds a pop-up menu that contains the ID, <b>FindPopupMenuFromID</b> looks into the permanent handle map for an instance of a <b>CMenu</b>-derived object attached to the handle of the pop-up menu. "Technical Note 3: Mapping of Windows Handles to Objects" (MSDN Library Archive, Technical Articles, Visual C++ 1.5 [16-bit] Articles, MFC 2.5 Technical Notes) discusses handle maps to some extent. Figure 3 illustrates the function of the permanent handle map.</p>
<p>
<img src="selfdraw_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Permanent handle map</b></p>
<p>
The permanent handle map handles the mapping of Windows handles to MFC objects. Using the map, MFC gets a pointer to the instance of the <b>CMenu </b>object attached to the menu and calls its <b>MeasureItem </b>function:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pMenu-&gt;MeasureItem(lpMeasureItemStruct);
</code></pre>
<p>
The process is similar for the WM_DRAWITEM message. <b>CWnd::OnDrawItem </b>looks in the permanent handle map for the <b>CMenu </b>object and calls its <b>DrawItem </b>method. The edited code for <b>CWnd::OnDrawItem</b> is shown below.</p>
<pre><code>void CWnd::OnDrawItem(&nbsp; int /*nIDCtl*/, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPDRAWITEMSTRUCT lpDrawItemStruct)
{
 &nbsp; if (lpDrawItemStruct-&gt;CtlType == ODT_MENU)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CMenu* pMenu = CMenu::FromHandlePermanent(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (HMENU)lpDrawItemStruct-&gt;hwndItem);
 &nbsp;&nbsp;&nbsp;&nbsp; if (pMenu != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMenu-&gt;DrawItem(lpDrawItemStruct);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; // eat it
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CWnd* pChild = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWnd::FromHandlePermanent(lpDrawItemStruct-&gt;hwndItem);
 &nbsp;&nbsp;&nbsp;&nbsp; if (pChild != NULL &amp;&amp; pChild-&gt;SendChildNotifyLastMsg())
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;&nbsp;&nbsp;&nbsp; // Eat it.
 &nbsp; }
 &nbsp; // Not handled - do default.
 &nbsp; Default();
}
</code></pre>
<p>
<b>CWnd::FromHandlePermanent </b>and <b>CMenu::FromHandlePermanent </b>are internal MFC functions; don't use these in your applications. These functions differ from <b>CWnd::FromHandle </b>and <b>CMenu::FromHandle </b>in that they return NULL if no MFC object is attached to the Windows handle, instead of creating a temporary MFC object attached to the handle.</p>
<p>
The pop-up menu is at the lowest level of a self-drawing menu, as shown by <b>FindPopupMenuFromID</b>. In other words, a pop-up menu is attached to an MFC <b>CMenu</b>-derived object. A <b>CMenu </b>object cannot be attached to a single menu item, mainly because a single menu item doesn't have a handle. In Windows and MFC, menu items are not objects themselves but are part of the pop-up menu, which is an object. (This is similar to buttons in toolbars: The buttons are not objects; they are part of the toolbar.)</p>
<p>
<img src="selfdraw_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Pop-up menu attached to an MFC CMenu-derived object</b></p>
<p>
The EasyBit sample application changes an existing pop-up menu so that it resembles Figure 4 (above). The CTRLTEST sample included with Microsoft Visual C++™ shows how to dynamically add a cascading pop-up menu with self-drawing items, as shown in Figure 5 (below).</p>
<p>
<img src="selfdraw_5.gif" border=0></p>
<p class=label>
<b>Figure 5. Cascading pop-up menu attached to an MFC CMenu-derived object</b></p>
<p>
If you want to call different drawing code for different menu items, your <b>CMenu</b>-derived object will have to handle the delegation to other drawing functions.</p>
<h2>Making a Menu Self-Drawing</h2>
<p>
The EasyBit sample application contains a self-drawing menu that displays a cube, a pyramid, and a dodecahedron. The user selects an object to rotate by picking the picture of the object (see Figure 6) instead of picking the name of the object (see Figure 7). In this section, I'll discuss how I added support for these self-drawing menu items to EasyBit.</p>
<p>
<img src="selfdraw_6.gif" border=0></p>
<p class=label>
<b>Figure 6. Self-drawing menus from EasyBit</b></p>
<h3>EasyBit with Normal Menus</h3>
<p>
Before I added self-drawing menus, EasyBit had normal menus with text (Figure 7). I created the menus and status bar strings using the resource editor in Visual C++. I added COMMAND and UPDATE_COMMAND_UI handlers to the view class for each menu item. The menu looked similar to Figure 7.</p>
<p>
<img src="selfdraw_7.gif" border=0></p>
<p class=label>
<b>Figure 7. Before self-drawing menus</b></p>
<p>
In other words, I had a normally functioning application with standard menus, just like any other MFC application.</p>
<h3>Implementing the Self-Drawing Menu Class (CShapeMenu)</h3>
<p>
To add self-drawing menus to EasyBit, my first task was to add a new class derived from <b>CMenu</b>. I called this class <b>CShapeMenu</b>. The code is in the CSHAPEMENU.H and CSHAPEMENU.CPP files. The header file for <b>CShapeMenu</b> is listed below:</p>
<pre><code>class CShapeMenu : public CMenu
{
public:
 &nbsp; enum enum_SHAPES {BOX, PYRAMID, DODEC} ; 

// Operations
 &nbsp; void ChangeMenuItem(UINT nID, enum_SHAPES shape);
 &nbsp; void Init() ;

// Implementation
 &nbsp; virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
 &nbsp; virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);

 &nbsp; CShapeMenu();
 &nbsp; virtual ~CShapeMenu();

private:
 &nbsp; CSize m_sizeCheck ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // size of menu check mark
 &nbsp; CGL* m_pScenes[3] ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OpenGL scenes of the three shapes
 &nbsp; CSimpleDIB m_DIB[3] ;&nbsp;&nbsp;&nbsp; // DIB sections on which scenes are rendered
};
</code></pre>
<p>
Most of the work is done in <b>CShapeMenu::MeasureItem </b>and <b>CShapeMenu::DrawItem</b>. <b>CShapeMenu::MeasureItem </b>simply returns the size of the menu item. </p>
<pre><code>#define MENU_HEIGHT 100
#define MENU_WIDTH&nbsp; 100

void CShapeMenu::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
 &nbsp; int iWidthCheck = LOWORD(GetMenuCheckMarkDimensions()) ;

 &nbsp; // All items are fixed in size.
 &nbsp; lpMIS-&gt;itemHeight = MENU_HEIGHT;
 &nbsp; // Remove space automatically added for the check mark.
 &nbsp; lpMIS-&gt;itemWidth = MENU_WIDTH - iWidthCheck ;
}
</code></pre>
<p>
The only trick is to remove the horizontal space the system automatically adds for the check mark. To remove the space, subtract the width of the check mark from the width of your menu. The width of the check mark is obtained using the command:</p>
<pre><code>&nbsp;&nbsp;&nbsp;int iWidthCheck = LOWORD(GetMenuCheckMarkDimensions()) ;
</code></pre>
<p>
<b>CShapeMenu::DrawItem</b> is not quite as simple as <b>CShapeMenu::MeasureItem</b>, as shown below:</p>
<pre><code>void CShapeMenu::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
 &nbsp; CDC* pDC = CDC::FromHandle(lpDIS-&gt;hDC);
 &nbsp; enum_SHAPES nShape = (enum_SHAPES)lpDIS-&gt;itemData;

 &nbsp; const COLORREF crSelect = RGB(255,0,0) ;&nbsp;&nbsp; // selection color
 &nbsp; const COLORREF crCheck = RGB(0,0,255) ;&nbsp;&nbsp;&nbsp; // checked color
 &nbsp; const COLORREF crNormal = RGB(0,255,0) ;&nbsp;&nbsp; // normal Color
 &nbsp; COLORREF cr = crNormal;

 &nbsp; if (lpDIS-&gt;itemAction &amp; ODA_DRAWENTIRE)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Draw the scene.
 &nbsp;&nbsp;&nbsp;&nbsp; CPalette* pOldPal = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp; CPalette* pPalTemp = m_pScenes[nShape]-&gt;GetPalette() ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (pPalTemp != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOldPal = pDC-&gt;SelectPalette(pPalTemp, FALSE) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDC-&gt;RealizePalette() ;
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp; m_DIB[nShape].Draw(pDC,lpDIS-&gt;rcItem.left, lpDIS-&gt;rcItem.top) ;

 &nbsp;&nbsp;&nbsp;&nbsp; if (pOldPal != NULL) pDC-&gt;SelectPalette(pOldPal, FALSE ) ;
 &nbsp; }

 &nbsp; if (lpDIS-&gt;itemState &amp; ODS_CHECKED)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Menu item is checked.
 &nbsp;&nbsp;&nbsp;&nbsp; cr = crCheck ;
 &nbsp; }

 &nbsp; if (lpDIS-&gt;itemAction &amp; ODA_SELECT)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (lpDIS-&gt;itemState &amp; ODS_SELECTED)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Menu item is selected.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cr = crSelect ;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }

 &nbsp; // Draw the border.
 &nbsp; CBrush br(cr);
 &nbsp; CRgn rgn;
 &nbsp; rgn.CreateRectRgnIndirect(&amp;lpDIS-&gt;rcItem) ;
 &nbsp; pDC-&gt;FrameRgn(&amp;rgn,&amp;br,4,4) ;
}
</code></pre>
<p>
I drew the menu by blting the device-independent bitmap (DIB) that contains an image rendered by OpenGL™. For more information on the OpenGL code used in EasyBit, see my article series on OpenGL, including <a href="msdn_gl6.htm">"OpenGL VI: Rendering on DIBs with PFD_DRAW_TO_BITMAP,"</a> in the MSDN Library.</p>
<p>
Next, I drew a border around the image using <b>FrameRgn</b>. This function can create a border thicker than 1 pixel that doesn't extend outside the rectangle it frames. The color of the border depends on the state of the menu item. The state information is contained in <b>DRAWITEMSTRUCT.itemState</b>. For more information, see the MFC <b>CMenu </b>entry in the Visual C++ documentation.</p>
<h3>Attaching CShapeMenu</h3>
<p>
Creating a new class doesn't do you any good unless you attach the class to your application somewhere. To attach <b>CShapeMenu </b>to EasyBit, the first step is to add the line:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CShapeMenu m_ShapeMenu ;
</code></pre>
<p>
to the header file for <b>CMainFrame</b>.</p>
<p>
The next step is to attach the Rotate pop-up menu to <b>m_menuOwner</b>. Adding the following code to <b>CMainFrame::OnCreate</b> does the trick:</p>
<pre><code>CMenu* pFrameMenu = GetMenu() ;
CMenu* pSubMenu = pFrameMenu-&gt;GetSubMenu(1) ;
m_ShapeMenu.Attach(pSubMenu-&gt;GetSafeHmenu()) ;
</code></pre>
<p>
The File menu is at position 0, and the Rotate menu is at position 1. The menu is detached in the destructor for <b>CShapeMenu</b>.</p>
<pre><code>CShapeMenu::~CShapeMenu()
{
.
.
.
 &nbsp; Detach() ;
 &nbsp; ASSERT(m_hMenu == NULL) ;
}
</code></pre>
<p>
Now that the pop-up menu is attached to the <b>CShapeMenu</b> object, we need to change the menu style to owner-drawn. I added a convenient helper function, <b>ChangeMenuItem</b>, to <b>CShapeMenu</b>. This function takes a menu ID and a value to determine which shape to draw. It is called from <b>CMainFrame</b> as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;m_ShapeMenu.ChangeMenuItem(ID_ROTATE_BOX,CShapeMenu::BOX) ;
 &nbsp; m_ShapeMenu.ChangeMenuItem(ID_ROTATE_PYRAMID,CShapeMenu::PYRAMID) ;
 &nbsp; m_ShapeMenu.ChangeMenuItem(ID_ROTATE_DODEC,CShapeMenu::DODEC) ;
</code></pre>
<p>
The code for <b>ChangeMenuItem</b> consists simply of a call to <b>CMenu::ModifyMenu</b>:</p>
<pre><code>void CShapeMenu::ChangeMenuItem(UINT nID, enum_SHAPES shape)
{
 &nbsp; ModifyMenu( nID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MF_BYCOMMAND | MF_ENABLED | MF_OWNERDRAW,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPCTSTR)shape) ;
}
</code></pre>
<p>
That's all there is to making a menu a self-drawing menu. Pretty simple, isn't it?</p>
<h2>Adding a Self-Drawing Menu at Run Time</h2>
<p>
The CTRLTEST sample application takes a slightly different approach. Instead of modifying an existing pop-up menu, it dynamically adds a new pop-up menu cascading off an existing pop-up menu, as simulated in Figure 8.</p>
<p>
<img src="selfdraw_8.gif" border=0></p>
<p class=label>
<b>Figure 8. Example of cascading menu from CTRLTEST</b></p>
<p>
In general, this doesn't differ from what I described in the previous section. The <b>CColorMenu</b> class is derived from <b>CMenu</b>. <b>CColorMenu </b>implements <b>DrawItem</b> and <b>MeasureItem</b> in the CUSTMENU.CPP file. The color menu items are added at run time using <b>AppendMenu</b>, which is called from <b>CColorMenu::AppendColorMenu</b>.</p>
<p>
Because the menu items are added at run time instead of build time, MFC and ClassWizard don't know anything about them. This makes life a little more difficult. For more information on adding menu items dynamically, see the DYNAMENU sample application in the MSDN Library.</p>
<p>
The <b>CTestWindow::AttachCustomMenu</b> function in CUSTMENU.CPP appends the pop-up menu to the Colors menu. This function is called by <b>CTestWindow::SetupMenus</b>, which is called by <b>CTestApp::InitInstance</b>.</p>
<p>
I like the EasyBit method better than the CTRLTEST method because it allowed me to:
<ul type=disc>
<li>
Use ClassWizard to add menu command handlers.<br><br></li>
<li>
Test EasyBit without the self-drawing menus.<br><br></li>
<li>
Use the resource editor to add the menus and status bar strings.</li>
</ul>
<h2>Conclusion</h2>
<p>
Self-drawing menus are very easy to add to an application. Because of the object-oriented nature of self-drawing menus, you can easily create different self-drawing menu classes that your application can reuse. These menu classes can make your application more informative, visually appealing, and easier to use.</p>
<h2>Bibliography</h2>
<p>
Rogerson, Dale. <a href="msdn_gl6.htm">"OpenGL VI: Rendering on DIBs with PFD_DRAW_TO_BITMAP."</a> April 1995. (MSDN Library, Technical Articles)</p>
<p>
"Technical Note 3: Mapping of Windows Handles to Objects." (MSDN Library Archive, Technical Articles, Visual C++ 1.5 [16-bit] Articles, MFC 2.5 Technical Notes)</p>
<p>
"Technical Note 14: Custom Controls." (MSDN Library Archive, Technical Articles, Visual C++ 1.5 [16-bit] Articles, MFC 2.5 Technical Notes)</p>
</BODY>
</HTML>
