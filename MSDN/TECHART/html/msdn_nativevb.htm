<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Useful Native Visual Basic and Microsoft Access Functions</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_nativevb"></a></sup>Creating Useful Native Visual Basic and Microsoft Access Functions</h1>
<p>
Kenneth Lassesen<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: August 26, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3000">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the NATIVEVB sample DLL for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes how you can add compiled C functions to Microsoft® Visual Basic® and Microsoft Access®—functions that appear to be native functions in Visual Basic rather than application programming interface (API) functions being called from Visual Basic. This approach results in fewer lines of code, less coding time, and better performance. The examples in this article and in the accompanying sample files show how structures, pointers to pointers, and C++-related agony can be avoided by the Visual Basic and Microsoft Access programmer.</p>
<h2>What Are Native Functions?</h2>
<p>
Programmers of Microsoft® Access® and Visual Basic® are familiar with two styles of functions: native functions and application programming interface (API) functions. <i>Native functions</i> will allocate memory<i> </i>automatically without the programmer’s intervention. For example, here are typical lines of Basic code:</p>
<pre><code>ThisPath$=Environ ("Path") 'The string returned is created by the function and 
A$=dir("*.txt")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'the programmer does not need to allocate memory first. 
</code></pre>
<p>
<i>API functions</i> can be either entry points into the operating system architecture or special functions not visible in the application language. API functions do not allocate memory space, but require the programmer to create the space for them. API functions called by preallocating space use what I call a <i>C-like method</i>. For example:</p>
<pre><code>cbBufferLen% = 255&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Determine maximum length of string returned.
SzbUffer = Space(cbBufferLen%)
rc% = GetProfileString("intl", "sLongDate", "-1", SzbUffer, cbBufferLen%)'Make API Call
If rc% &gt; 0 Then&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'rc% contains the NUMBER OF CHARACTERS in string
 &nbsp;&nbsp; WinIniValue$ = Left(SzbUffer, rc%) 'Truncate garbage off end of string
Else
 &nbsp;&nbsp; WinIniValue$ = ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Failed or no string
End If
</code></pre>
<p>
This style of coding is exceedingly long, can be confusing, and requires lengthy debugging. For example, the above function call, <b>GetProfileString</b>, will fail with some versions of the declaration statement for it.</p>
<p>
This C-like method is contrary to the way Basic programmers code. Each line of code should do one useful unit of work at a higher level of abstraction than in C. For example, each line below in this filling of a list box would be a routine or several lines of code in C:</p>
<pre><code>Open "Mydata.dat" for input as #fno&nbsp;&nbsp; 'Open file. 
While not eof(fno)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Is this the end?
 &nbsp; Line Input #fno, A$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'No, read next line.
 &nbsp; ListBox1.AddItem A$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Place in listbox.
WEND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Repeat until end of file.
Close #fno&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Close file.
</code></pre>
<p>
A function to obtain a value from an .INI file should ideally be called as:</p>
<pre><code>IniValue$=GetWinIni("Fonts","Arial")&nbsp; 'Get location of Arial font file.
</code></pre>
<p>
This way of obtaining a value means no memory allocation or cleanup by the Basic programmer and constitutes one line of code for one useful unit of work.</p>
<p>
Functions that exhibit this latter style I say have the <i>Visual Basic–native method</i> of calling because, although the function is contained in a dynamic-link library (DLL), it returns a Visual Basic string, and the way it is called from Visual Basic appears to be the same way other Visual Basic functions are called. In other words, it is natural or native.</p>
<h3>History</h3>
<p>
When I started programming in Visual Basic version 1.0, I developed a library of functions coded in Visual Basic and placed their code in modules that were used time and time again—my Visual Basic library. Work pressures prevented me from converting this library into a DLL written in the C language as I slaved away generating Visual Basic and Microsoft Access applications. When I sat down to rewrite the code in C, I found that C could easily handle the Microsoft Windows® structures and return numeric values from them. Normally, C cannot return a string from a function unless it is given space by the program calling it. The returning of a string from a DLL appeared to be impossible using a Visual Basic–native approach. The choices appeared to be as follows: 
<ul type=disc>
<li>
Allocate space in Visual Basic first and then call the function, but this is ugly and a kluge.<br><br></li>
<li>
Change the functions into properties of a Visual Basic control (VBX), so space can be allocated from the VBX memory segment.<br><br></li>
<li>
Pass multiple arguments using a VBX and, therefore, set properties one at a time—another kluge.</li>
</ul>
<p>
Given these unappealing options, I was determined to find a coding solution that is natural to Visual Basic. The answer was the <b>VBCreateTempHlstr</b> function in the Visual Basic version 3.0 <i>Control Development Guide</i> (Product Documentation, Office Developer's Kit 1.0, Visual Basic 3.0 Professional Edition). This function creates space in the Visual Basic memory space which Visual Basic recovers automatically when the handle is passed back to Visual Basic. This function thereby allows the development of Visual Basic–native functions, which allows me to exchange the Visual Basic-module-based library of functions for a C-version DLL. As my Microsoft Access work increased, I speculated that Microsoft Access would borrow significantly from Visual Basic and was delighted to discover by experiment that Visual Basic–native functions appear to work with both languages. Figure 1 shows the difference between these methods.</p>
<p>
<img src="nativevb_1.gif" border=0></p>
<p class=label>
<b>Figure 1. C-like method</b></p>
<p>
In the C-like method, memory and structures must be created and initialized before the API call and cleaned up afterwards, all in Visual Basic code (Figure 2). </p>
<p>
<img src="addinvb4_1.gif" border=0></p>
<p class=label>
<b>Figure 2. Visual Basic–native method</b></p>
<p>
In the Visual Basic–native method, Visual Basic does not need to create or initialize memory, nor clean up afterwards. The intermediate DLL handles any structures or memory requirements and obtains space from Visual Basic using the <b>VBCreateTempHlstr </b>function. The Visual Basic engine (VBRUN<i>x</i>00.DLL) automatically handles the cleanup of this space. </p>
<p>
Although the Visual Basic–native method appears to be more complicated, it is very simple when used from Visual Basic. Any API call is reduced to a single declaration and a one-line call, no matter how complex the API is. The rest of the work is in the intermediate DLL away from the Visual Basic programmer.</p>
<p>
With this approach, it's apparent that a rich collection of native functions can easily be added to Visual Basic and Microsoft Access. This article shows examples of various styles of functions that can appear as Visual Basic–native functions rather than C-like functions.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The use of <b>VBCreateTempHlstr</b> with Microsoft Access version 1.1 or 2.0 is not officially supported nor documented and may not work for future versions of Microsoft Access.</p>
<h2>Splitting the Clock Tick</h2>
<p>
Code performance has always been a concern of professional programmers. In my MS-DOS® days, I ended up programming clock chips to accurately measure the performance of code. In Windows this is not so simple and risks ugly side effects from using timers already in use by other applications. Many Visual Basic programmers believe that under Windows the accuracy of timing is 55 milliseconds (1 clock tick)—the accuracy of time returned from <b>Now</b> or<b> Timer</b>. You can get true millisecond accuracy very easily by using the correct function—but you may have the overhead of calling it in Visual Basic. </p>
<p>
Our first example of a native Visual Basic function shows how structures can be hidden from the Visual Basic programmer. I encapsulated this function call to reduce the number of lines of Visual Basic code and improve readability. The following two routines encapsulate <b>TimerCount</b>, one of the Windows API timer functions that requires a structure.
<ul type=disc>
<li>
<code>Sub StopWatch_Reset </code>resets the stopwatch to 0 milliseconds. This occurs automatically on the first call.<br><br></li>
<li>
<code>Function StopWatch_Time() as Long</code> reports the number of milliseconds since either the <b>this</b> function was first called or <b>StopWatch_Reset</b> was last called.</li>
</ul>
<p>
The <b>TimerCount</b> function is in TOOLHELP.DLL, which can be used with Windows version 3.0. <b>TimerCount</b>'s functionality is also provided by <b>timeGetTime</b> in MMSYSTEM.DLL (available from Windows 3.1 and Windows NT™), which does not require a structure and would be preferred in practice.</p>
<h3>C Coding</h3>
<p>
When a Visual Basic application needs to obtain information from Windows, a structure is often required for the API call. The steps to implement this call are as follows: 
<ol>
<li>
Convert the C structural declaration into the equivalent Visual Basic structure.<br><br></li>
<li>
Initialize the structure if required<b>.</b><br><br></li>
<li>
Call the function.<br><br></li>
<li>
Check the results.<br><br></li>
<li>
Extract the data.</li>
</ol>
<p>
This process may add 10, 20, or 50 lines of code to an application. Frequently, this code is needed again in the next project, causing the programmer to rewrite the code and test it again, or locate and copy it from another project. Our first example of a Visual Basic–native method function places the code in a DLL that returns only the information requested and requires only one line of code to use.</p>
<p>
The C code for the two functions described above—<b>StopWatch_Reset</b> and <b>StopWatch_Time</b>—is shown below. The <b>StopWatch_Reset</b> function initializes the structure and keeps track of the exact time it was called so that the milliseconds elapsed since it was called can be reported.</p>
<pre><code>#include &lt;toolhelp.h&gt; &nbsp; //For StopWatch
TIMERINFO tiThisTime;
DWORD dwStopWatchStarted=0;
//--------------------------------------------------------------------
//&nbsp; .StopWatch_Reset()
//--------------------------------------------------------------------
// We set StopWatchStarted to the current ticks.
void&nbsp; _pascal __export StopWatch_Reset()
{&nbsp;&nbsp;&nbsp; 
if (tiThisTime.dwSize==0)
 &nbsp; tiThisTime.dwSize=sizeof(TIMERINFO);
if (0==TimerCount(&amp;tiThisTime))
 &nbsp; MessageBox(NULL,"Unable to obtain current time for StopWatch.",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Unexpected Error",MB_ICONSTOP);
 &nbsp; dwStopWatchStarted=tiThisTime.dwmsThisVM; //Records starting millisecond.
}&nbsp; 
</code></pre>
<p>
The second function, <b>StopWatch_Time</b>, calls <b>TimerCount</b> and returns the number of milliseconds since <b>StopWatch_Reset</b> was called.</p>
<pre><code>//-------------------------------------------------------------------
//&nbsp; .StopWatch_Time()
//-------------------------------------------------------------------
// We return the ticks since StopWatchStarted was reset above.
long _pascal __export StopWatch_Time()
{
if (dwStopWatchStarted==0)&nbsp; //If user forgot to set it, we reset it.
 &nbsp;&nbsp;&nbsp;&nbsp; StopWatch_Reset();
if (0==TimerCount(&amp;tiThisTime)) //Get time
 &nbsp; MessageBox(NULL,"Unable to obtain current time for StopWatch.",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Unexpected Error",MB_ICONSTOP);
return&nbsp; (long) (tiThisTime.dwmsThisVM-dwStopWatchStarted);
// Returns milliseconds since start.
}
</code></pre>
<p>
The code cooperates with Visual Basic programming. Visual Basic has no simple mechanism for detecting an error that occurs in a DLL. Error information from the DLL can be returned by a parameter that is set to inform the program or by a message box that informs the user. </p>
<p>
If the parameter approach is used, most programmers would need to check for the error condition and then display a message box containing their own message. I favor the message box option over the parameter one for two reasons:
<ul type=disc>
<li>
It requires less code in Visual Basic.<br><br></li>
<li>
It is more informative and gives complete error reports to users.</li>
</ul>
<p>
Many Visual Basic programmers fail to do all of the appropriate checks on return values and usually add error handling <i>after the error has occurred the first time.</i> Visual Basic programmers should never be counted on to call things properly or in order. If some step should be done and the programmer has forgotten to do it, the function should do it for them automatically rather than give an error message, as in the calling of <b>StopWatch_Reset</b> above.</p>
<p>
The code below shows both methods of calling <b>TimerCount</b> and its alternative function, <b>timeGetTime</b>.</p>
<pre><code>Declare Function TimerCount Lib "ToolHelp.DLL" (tagTimerInfo As Any) As Integer
Declare Function StopWatch_Time Lib "NATIVEVB.DLL" () As Long 
Type tagTimerInfo
 &nbsp;&nbsp; dwSize As Long
 &nbsp;&nbsp; dwStart As Long
 &nbsp;&nbsp; dwVM&nbsp; As Long
End Type

Dim i As Integer, b&nbsp;&nbsp;&nbsp; As Integer, j As Integer
Dim TimerInfo As tagTimerInfo
TimerInfo.dwSize = Len(TimerInfo)

'Find out how many milliseconds to execute 1000 times using the C-like method.
t1&amp; = Stopwatch_time()
For j = 1 To 1000
 &nbsp;&nbsp; rc% = TimerCount(TimerInfo)
 &nbsp;&nbsp; T&amp; = TimerInfo.dwVM
Next j
t2&amp; = Stopwatch_time()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Difference between this and t1&amp; is milliseconds 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'to execute loop.
'Find out how many milliseconds to execute 1000 times using the
'VB-native method.
For j = 1 To 1000
 &nbsp;&nbsp; T&amp; = Stopwatch_time()
Next j
t3&amp; = Stopwatch_time()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Difference between this and t2&amp; is millseconds
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'to execute.
For j = 1 To 1000
 &nbsp;&nbsp; 
Next j
t4&amp; = Stopwatch_time()
For j = 1 To 1000
 &nbsp;&nbsp; T&amp; = timegettime()
Next j
t5&amp; = Stopwatch_time()
MsgBox <b>"</b>C-Like Method:<b>"</b> &amp; Str$(t2&amp; - t1&amp;) &amp; <b>"</b>  VB-Native Method:<b>"</b> &amp; Str$(t3&amp; - 
t2&amp;) &amp; <b>"</b>  Loop time:<b>"</b> &amp; Str$(t4&amp; - t3&amp;) &amp; <b>"</b> timeGetTime:<b>"</b> &amp; Str$(t5&amp; - t4&amp;) &amp; <b>""</b>
</code></pre>
<p>
This code also allows comparisons among the C-like, Visual Basic–native, and direct-API-call methods. We repeatedly ran the code above, producing the following times:
<ul type=disc>
<li>
calls for the C-like method: 249 milliseconds with standard deviation of 9.5<br><br></li>
<li>
calls by Visual Basic–native method: 208 milliseconds with standard deviation of 6.7<br><br></li>
<li>
calls by <b>timeGetTime</b> method: 131 milliseconds with standard deviation of 5.7</li>
</ul>
<p>
The performance of the Visual Basic–native method approach was marginally better than the C-like method, <i>despite the additional functionality and checking for errors</i>. Using the <b>timeGetTime</b> method was fastest, but did not include any checking for errors. You may wish to try this with your PC; the Visual Basic project <b>Perf0.Mak</b> in the NATIVEVB sample that accompanies this article contains the source code.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;For accurate timing, remember to unload other applications from Windows and disconnect from the network to reduce sources of variance.</p>
<h3>Example of Using Stopwatch</h3>
<p>
The following code sample shows how we can use these new native functions to monitor performance in our Visual Basic and Microsoft Access code. It is important that we remove as much measurement overhead as possible, so we'll use an array to store our data while timing and then write the data out for later analysis. If you are on a network, it is recommended that you restart Windows without the network (that is, type <b>win /n</b> or disconnect your network card before running the included LOAD_CTL.MAK project). A sample of one procedure is shown below:</p>
<pre><code>Declare Function STopWatch_Time Lib <b>"</b>NATIVEVB.DLL<b>"</b> () As Long
Dim Datapts(0 To 1000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Long

Dim i As Integer, j As Integer, fno As Integer
On Error GoTo Combo1_Unload
Datapts(0) = StopWatch_Time()
For i = 1 To 1000
 &nbsp;&nbsp; Load Combo1(i)'Load 1000 copies or until memory out.
 &nbsp;&nbsp; CtlMax% = i
 &nbsp;&nbsp; Datapts(i) = StopWatch_Time()
Next i

Combo1_exit:
Exit Sub
Combo1_Unload:
On Error Resume Next
For j = CtlMax% To 1 Step -1
 &nbsp;&nbsp; Unload Combo1(j)'Load 1000 copies or until memory out.
Next j
LogData <b>"</b>Combo1<b>"</b>, i%
Resume Combo1_exit
</code></pre>
<p>
The LOAD_CTL.MAK project writes the information to a tab-delimited text file that can be imported into Microsoft Excel or Microsoft Access. The chart below shows the very significant difference between load time and number of instances allowed of Visual Basic image controls and Visual Basic picture controls. I suspect everybody will be profiling the code and load times for their favorite controls after reading this.</p>
<p>
<img src="nativevb_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Load times for image and picture controls</b></p>
<h3>What Is the Advantage?</h3>
<p>
The Visual Basic–native method is simply a C wrapper around the call of a DLL, so why go to the trouble of writing a DLL? Some benefits of writing a DLL are the following:
<ul type=disc>
<li>
Better performance—that is, less time per call, as well as more accurate results.<br><br></li>
<li>
Less code to write. The Visual Basic–native method of calling the API requires a single statement for a declaration and a single statement per use. The C-like method requires 8 declaration/initialization statements and 2 statements per use. <br><br></li>
<li>
The Visual Basic–native method reduces the need for a Visual Basic programmer to know the operating system function calls.</li>
</ul>
<h2>Initialization Functions</h2>
<p>
Initialization functions such as <b>GetProfileString</b> are not the simplest functions to use successfully from Visual Basic’s perspective, despite their apparent simplicity. A brief review of the Knowledge Base reveals many articles on using the initialization functions and Visual Basic: Q105807, Q75639, Q110219, Q109290, Q86470, and Q69888. Several shareware products are available that solely handle .INI files—a reflection of the frustration many Visual Basic users have had using the <b>GetProfileString</b> function. </p>
<p>
The code below is a robust implementation of the <b>GetPrivateProfileString</b> call. It verifies that appropriate arguments are passed in—a needed caution, given the use of variants in Visual Basic and multiple ways of declaring calls from Visual Basic. The function then makes the call using its own buffer (iniBuffer) and checks for error conditions. Then the function creates a Visual Basic string to return to Visual Basic via <b>VBCreateTempHlstr</b>.</p>
<pre><code>#define MAXINISTRING 4096 //Largest string that can be returned
#define EmptyString <b>"</b>\0<b>"</b>
char iniBuffer[MAXINISTRING];&nbsp;&nbsp; 
HLSTR hlstr;
HLSTR __export&nbsp; _pascal vbGetIni(LPSTR Section, LPSTR Entry, LPSTR FileName)
{int cb;
 &nbsp;&nbsp;&nbsp;&nbsp; if((Section==NULL) || (Entry==NULL))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL,<b>"</b>Section or Entry is NULL -- wrong function 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; called.<b>"</b>,<b>"</b>GetWinIni()<b>"</b>,MB_ICONSTOP);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; cb = GetPrivateProfileString(Section, Entry, EmptyString, iniBuffer, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAXINISTRING, FileName);
 &nbsp;&nbsp;&nbsp;&nbsp; if (cb &lt; 1) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; if (cb ==MAXINISTRING)&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL,<b>"</b>Value may be 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; truncated.<b>"</b>,<b>"</b>vbGetIni()<b>"</b>,MB_ICONEXCLAMATION);
 &nbsp;&nbsp;&nbsp;&nbsp; hlstr = VBCreateTempHlstr(iniBuffer, cb);
 &nbsp;&nbsp;&nbsp; if (HIWORD(hlstr) == -1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp; { MessageBox(NULL,<b>"</b>VBCreateTempHlstr failed -- Contact Support.<b>"</b> , 

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "</b>CRITICAL ERROR<b>"</b>,MB_ICONSTOP);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;}
 &nbsp;&nbsp;&nbsp; return hlstr;
}&nbsp;&nbsp; 
</code></pre>
<p>
The code follows normal conventions of programming for Windows until the last few lines, where memory is allocated from Visual Basic, lines that you will see again and again:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hlstr = VBCreateTempHlstr(iniBuffer, cb);
 &nbsp;&nbsp;&nbsp; if (HIWORD(hlstr) == -1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp; { MessageBox(NULL,<b>"</b>VBCreateTempHlstr failed -- Contact Support.<b>"</b> ,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>"</b>CRITICAL ERROR<b>"</b>,MB_ICONSTOP);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;}
</code></pre>
<p>
This obtains memory space from Visual Basic and copies the needed characters into it. The purpose of the test after copying is to validate that space has been successfully allocated. These lines can be placed in a macro to reduce coding. For example:</p>
<pre><code>#define VALIDHLSTR(x)&nbsp; if (HIWORD(x) == -1)
 { MessageBox(NULL,<b>"</b>VBCreateTempHlstr failed -- Contact Support.<b>"</b> ,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>"</b>CRITICAL ERROR<b>"</b>,MB_ICONSTOP);return NULL;}
</code></pre>
<h3>VBCreateTempHlstr and HLSTR</h3>
<p>
The Visual Basic version 3.0 <i>Control Development Guide</i> (Product Documentation, Office Developer's Kit 1.0, Visual Basic 3.0 Professional Edition) has a function contained in VBAPI.LIB called <b>VBCreateTempHlstr</b>, which permits a DLL to create a Visual Basic–style <i>temporary </i>string. The string space is obtained from Visual Basic, which allows a maximum of 20 temporary strings. These strings are automatically deleted the first time they are used by Visual Basic. Unlike many other functions in the CDK, this function does not require you to explicitly destroy the memory allocated; Visual Basic destroys it for you after Visual Basic copies the contents into its own memory space.</p>
<p>
People who have not developed VBXes are unfamiliar with what an HLSTR is. It is a handle to a Basic language string. These are roughly similar to Pascal strings—the size is stored separately from the characters—without a terminating <b>Chr$(0)</b>. This format permits any character, including <b>Chr$(0)</b>, to be in a string. The code handling of a HLSTR is different from an LPSTR that terminates with <b>Chr$(0)</b>. Calling functions that pass the wrong type from Visual Basic can create nasty problems; for example, if you send an HLSTR instead of an LPSTR because of an incorrect declaration in Visual Basic, you may find that the string could be several megabytes long instead of 4 bytes because the first <b>Chr$(0)</b> may be in another application's memory space—nasty!</p>
<h4>Naming standards</h4>
<p>
In the examples in the rest of this article, you will note that some functions use <i>vb</i> before the name. This signifies that this function only works with Visual Basic and Microsoft Access. Care must be taken in the Visual Basic declarations because HLSTR and LPSTR are very different creatures.</p>
<h4>Performance results</h4>
<p>
Now that we have the first function using HLSTR, let us test it against the C-like method, the Visual Basic–native method, and a shareware VBX that provides the same functionality. The code below was used to create Table 1. When measuring performance, <i>it is important to begin on the second or subsequent pass of code</i> because components like Windows or SMARTDRV caching may affect the results. You may wish to try this with your PC. The Visual Basic PERF1.MAK project in the NATIVEVB sample contains the source code. The unsupported VBNATIVE tool that accompanies the related article "A Collection of Useful Native Visual Basic and Microsoft Access Functions" (MSDN Library Archive, Technical Articles) has all the initialization functions, including code.</p>
<pre><code>Declare Function vbGetIni Lib <b>"</b>NATIVEVB.DLL<b>"</b> (ByVal Section$, ByVal KeyWord$, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal Filename$) As String

Dim i As Integer, b As Integer, j As Integer
Section$ = <b>"</b>TEST<b>"</b>
FileIni$ = <b>"</b>C:\TEST.INI<b>"</b>
For i = 1 To 100&nbsp;&nbsp;&nbsp; 'Fill a dummy .INI file with 100 values.
 &nbsp;&nbsp; Ent$(i) = Format(i, <b>"</b>0<b>"</b>)
 &nbsp;&nbsp; PutIni Section$, Ent$(i), Ent$(i), FileIni$
Next i
Init1.Application = <b>"</b>Test<b>"</b>  'Get Shareware VBX an advantage.
For b = 0 To 1&nbsp;&nbsp;&nbsp; 'We do a dummy pass to compensate for caching.
 For i = 0 To 2&nbsp;&nbsp;&nbsp; 'Method to try
  For j = 1 To 100&nbsp;&nbsp;&nbsp; 'Retrieve all values.
 &nbsp;&nbsp; Select Case i&nbsp;&nbsp;&nbsp; 'Select method.
 &nbsp;&nbsp; Case 0&nbsp;&nbsp;&nbsp; 'C-like method
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Buffer$ = String(128, <b>"</b> <b>"</b>)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc% = GetPrivateProfileString(Section$, Ent$(j), <b>""</b>, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Buffer$, 4096, FileIni$)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A$ = Left$(Buffer$, rc%)
 &nbsp;&nbsp; Case 1&nbsp;&nbsp;&nbsp; 'VB-native method
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A$ = vbGetIni(Section$, Ent$(j), FileIni$)
 &nbsp;&nbsp; Case 2&nbsp;&nbsp;&nbsp; 'Shareware VBX
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Init1.Parameter = Ent$(j)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A$ = Init1.Value
 &nbsp;&nbsp; End Select
 &nbsp;&nbsp; If b = 1 Then TimeData(i, j) = STOPWATCH_Time()
  Next j
 Next i
Next b
T$ = Chr$(9)&nbsp;&nbsp;&nbsp; 'Tab character so easy to read into Excel
fno = FreeFile
Open <b>"</b>C:\TEST.TXT<b>"</b> For Output As #fno
For j = 1 To 100&nbsp;&nbsp;&nbsp; 'Write the elapsed time only.
 &nbsp;&nbsp; Print #fno, TimeData(0, j) - TimeData(0, j - 1); T$,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TimeData(1, j) - TimeData(1, j - 1); T$, TimeData(2, j)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - TimeData(2, j - 1)
Next j
Close
MsgBox <b>"</b>Timing complete<b>"</b>
End
</code></pre>
<p>
The bottom line of Table 1 displays the average number of milliseconds it takes to read 100 values from a .INI file. The data in the table is a sample from these 100 timings. As you can see from the bottom line of the table, the Visual Basic–native method provided almost a 500 percent improvement in performance over the C-like method. The shareware VBX was twice as slow as the C-like method.</p>
<p class=label>
<b>Table 1. Performance Comparison in Milliseconds of Three Methods</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=32%><b><br>
C-like method</b></td>
<td class=label width=31%><b>Visual Basic–native method</b></td>
<td class=label width=37%><b><br>
VBX</b></td>
</tr>
<tr valign=top>
<td width=32%>5</td>
<td width=31%>1</td>
<td width=37%>10</td>
</tr>
<tr valign=top>
<td width=32%>5</td>
<td width=31%>0</td>
<td width=37%>11</td>
</tr>
<tr valign=top>
<td width=32%>9</td>
<td width=31%>0</td>
<td width=37%>9</td>
</tr>
<tr valign=top>
<td width=32%>6</td>
<td width=31%>1</td>
<td width=37%>12</td>
</tr>
<tr valign=top>
<td width=32%>7</td>
<td width=31%>2</td>
<td width=37%>11</td>
</tr>
<tr valign=top>
<td width=32%>4</td>
<td width=31%>1</td>
<td width=37%>10</td>
</tr>
<tr valign=top>
<td width=32%>6</td>
<td width=31%>1</td>
<td width=37%>12</td>
</tr>
<tr valign=top>
<td width=32%>8</td>
<td width=31%>0</td>
<td width=37%>10</td>
</tr>
<tr valign=top>
<td width=32%>5</td>
<td width=31%>0</td>
<td width=37%>8</td>
</tr>
<tr valign=top>
<td width=32%>6</td>
<td width=31%>2</td>
<td width=37%>11</td>
</tr>
<tr valign=top>
<td width=32%>4</td>
<td width=31%>2</td>
<td width=37%>10</td>
</tr>
<tr valign=top>
<td width=32%>5</td>
<td width=31%>0</td>
<td width=37%>9</td>
</tr>
<tr valign=top>
<td width=32%>6</td>
<td width=31%>1</td>
<td width=37%>7</td>
</tr>
<tr valign=top>
<td width=32%>4</td>
<td width=31%>1</td>
<td width=37%>7</td>
</tr>
<tr valign=top>
<td width=32%>9</td>
<td width=31%>0</td>
<td width=37%>90</td>
</tr>
<tr valign=top>
<td width=32%>4</td>
<td width=31%>1</td>
<td width=37%>10</td>
</tr>
<tr valign=top>
<td width=32%>6</td>
<td width=31%>0</td>
<td width=37%>51</td>
</tr>
<tr valign=top>
<td width=32%>6.08 Avg.</td>
<td width=31%>1.22 Avg.</td>
<td width=37%>11.29 Avg.</td>
</tr>
</table><br>
<h2>Version Information</h2>
<p>
Version information is often critical for diagnosing problems when an application is distributed in a corporation. If you read the Setup Wizard code, you'll see a classic use of the C-like method to get this information; using the Visual Basic–native method approach is much simpler. I have frequently found that other applications load different versions of DLLs and VBXes. If these DLLs and VBXes are already in memory when my application is launched, they may affect my programs, so I would like to have version information easily available when my application is running.</p>
<p>
I hate reinventing the wheel, so I looked in the MSDN Library Archive for an example using version information. VERSTAMP (MSDN Library Archive, Sample Code; search for VERSTAMP), contains a project demonstrating how to get version information. In the following section, I will take you through the process of converting VERSTAMP's sample code into a Visual Basic–native method function.</p>
<h3>The Fast Sample Hack</h3>
<p>
VERORIG.C contains the following procedures: <b>WinMain</b>, <b>WndProc</b>, <b>About</b>, <b>MyGetOpenFileName</b>, <b>ShowVerInfo</b>, <b>ClearDlgVer</b>, <b>FillVerDialog</b>, <b>MyVerFindFile</b>, <b>MyVerInstallFile</b>, <b>MoreVerInfo</b>, <b>HandleVerFindFileRes</b>, <b>PostInstallProcessing</b>, and <b>HandleVerInstallFileRes</b>. After reading their contents, I deleted all of these procedures except <b>MoreVerInfo</b>, <b>ShowVerInfo</b>, and <b>FillVerDialog</b>. These routines access the functions I need, but place the values I want in a dialog box instead of returning these values. For example, this code places a string in a dialog box:</p>
<pre><code>lstrcpy(gszUserMsg, <b>"</b>Unknown<b>"</b>);
....
SetDlgItemText(hWnd, ++wDlgItem, gszUserMsg);
</code></pre>
<p>
Instead of filling a dialog box with strings, we want to return the values to the calling program as HLSTRs. This is done by replacing the last line above with the three lines shown below:</p>
<pre><code>hlstr = VBCreateTempHlstr(gszUserMsg, strlen(gszUserMsg));
VALIDHLSTR(hlstr);
return hlstr;
</code></pre>
<p>
The function calls were changed as shown below.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=12%><b>Before</b></td>
<td width=88%><code>BOOL ShowVerInfo(HWND hWnd, LPSTR szDir, LPSTR szFile, WORD <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wDlgItem)</code></td>
</tr>
<tr valign=top>
<td width=12%><b>After</b></td>
<td width=88%><code>HLSTR&nbsp; ShowVerInfo(LPSTR szFullPath, int item)</code></td>
</tr>
<tr valign=top>
<td width=12%></td>
<td width=88%></td>
</tr>
<tr valign=top>
<td width=12%><b>Before</b></td>
<td width=88%><code>void FillVerDialog(HWND hWnd, VS_VERSION FAR *pVerInfo, WORD <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wDlgItem)</code></td>
</tr>
<tr valign=top>
<td width=12%><b>After</b></td>
<td width=88%><code>HLSTR FillVerDialog( VS_VERSION FAR *pVerInfo, int I)</code></td>
</tr>
<tr valign=top>
<td width=12%></td>
<td width=88%></td>
</tr>
<tr valign=top>
<td width=12%><b>Before</b></td>
<td width=88%><code>BOOL FAR PASCAL __export MoreVerInfo (HWND hDlg, unsigned wMsg, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD wParam, LONG lParam)</code></td>
</tr>
<tr valign=top>
<td width=12%><b>After</b></td>
<td width=88%><code>HLSTR FAR PASCAL MoreVerInfo (LPSTR szFullPath, int I)</code></td>
</tr>
</table><br>
<p>
Because we want the function to return information rather than fill a dialog window, we must change the functions so that they return LHSTR and drop the HWND parameters in the call. The LPSTR <i>szDir</i> and LPSTR <i>szFile</i> parameters were replaced with LPSTR <i>szFullPath</i>, similar to the value returned by the common dialog control (COMMDLG.VBX) filename property. The <b>__export</b> reserved word was removed from a call I did not want visible.</p>
<pre><code>#include &lt;vbapi.h&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // For HLSTR and so forth
#include&nbsp; &lt;string.h&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // For strlen 
#include <b>"</b>NativeVB.h<b>"</b> &nbsp;&nbsp;&nbsp;&nbsp; // For VALIDHLSTR and so forth
</code></pre>
<p>
The example filled multiple dialog boxes with information, but I wanted it to return a single HLSTR. The simple solution was to add a <b>switch</b> statement so that I could specify which piece of information I wanted returned. The code was originally:</p>
<pre><code>// Fill in the file version.
  wsprintf(gszUserMsg,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>"</b>%d.%d.%d.%d<b>"</b>,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(pVerInfo-&gt;vffInfo.dwFileVersionMS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOWORD(pVerInfo-&gt;vffInfo.dwFileVersionMS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(pVerInfo-&gt;vffInfo.dwFileVersionLS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOWORD(pVerInfo-&gt;vffInfo.dwFileVersionLS));
  SetDlgItemText(hWnd, wDlgItem, gszUserMsg);

  // Fill in the product version.
  wsprintf(gszUserMsg,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>"</b>%d.%d.%d.%d<b>"</b>,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(pVerInfo-&gt;vffInfo.dwProductVersionMS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOWORD(pVerInfo-&gt;vffInfo.dwProductVersionMS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(pVerInfo-&gt;vffInfo.dwProductVersionLS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOWORD(pVerInfo-&gt;vffInfo.dwProductVersionLS));
  SetDlgItemText(hWnd, ++wDlgItem, gszUserMsg);

  // File flags are bitwise or'ed so there can be more than one.
  // dwNum is used to make this easier to read.
  dwNum = pVerInfo-&gt;vffInfo.dwFileFlags;
  wsprintf(gszUserMsg, <b>"</b>%s %s %s %s %s %s %s<b>"</b>,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_DEBUG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; dwNum ? <b>"</b>Debug<b>"</b> &nbsp; : <b>""</b>),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_PRERELEASE&nbsp;&nbsp;&nbsp; &amp; dwNum ? <b>"</b>PreRel<b>"</b>  : <b>""</b>),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_PATCHED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; dwNum ? "Patched" : ""),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_PRIVATEBUILD&nbsp; &amp; dwNum ? "Private" : ""),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_INFOINFERRED&nbsp; &amp; dwNum ? "Info"&nbsp;&nbsp;&nbsp; : ""),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_DEBUG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; dwNum ? "Special" : ""),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (0xFFFFFF00L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; dwNum ? "Unknown" : ""));
  SetDlgItemText(hWnd, ++wDlgItem, gszUserMsg);
</code></pre>
<p>
With the added switch statement, the code became:</p>
<pre><code>switch (i) 
 {
 &nbsp; case 9:&nbsp; 
 &nbsp;&nbsp;&nbsp; // Fill in the file version.
 &nbsp;&nbsp;&nbsp; wsprintf(gszUserMsg,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%d.%d.%d.%d",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(pVerInfo-&gt;vffInfo.dwFileVersionMS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOWORD(pVerInfo-&gt;vffInfo.dwFileVersionMS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(pVerInfo-&gt;vffInfo.dwFileVersionLS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOWORD(pVerInfo-&gt;vffInfo.dwFileVersionLS));&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlstr = VBCreateTempHlstr(gszUserMsg, strlen(gszUserMsg));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALIDHLSTR(hlstr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hlstr;

 &nbsp; case 10:
 &nbsp;&nbsp;&nbsp; // Fill in the product version.
 &nbsp;&nbsp;&nbsp; wsprintf(gszUserMsg,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%d.%d.%d.%d",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(pVerInfo-&gt;vffInfo.dwProductVersionMS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOWORD(pVerInfo-&gt;vffInfo.dwProductVersionMS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(pVerInfo-&gt;vffInfo.dwProductVersionLS),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOWORD(pVerInfo-&gt;vffInfo.dwProductVersionLS));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlstr = VBCreateTempHlstr(gszUserMsg, strlen(gszUserMsg));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALIDHLSTR(hlstr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hlstr;
 &nbsp; case 11:
 &nbsp;&nbsp;&nbsp; // File flags are bitwise or'ed so there can be more than one.
 &nbsp;&nbsp;&nbsp; // dwNum is used to make this easier to read.
 &nbsp;&nbsp;&nbsp; dwNum = pVerInfo-&gt;vffInfo.dwFileFlags;
 &nbsp;&nbsp;&nbsp; wsprintf(gszUserMsg, "%s %s %s %s %s %s %s",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_DEBUG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; dwNum ? "Debug"&nbsp;&nbsp; : ""),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_PRERELEASE&nbsp;&nbsp;&nbsp; &amp; dwNum ? "PreRel"&nbsp; : ""),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_PATCHED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; dwNum ? "Patched" : ""),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_PRIVATEBUILD&nbsp; &amp; dwNum ? "Private" : ""),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_INFOINFERRED&nbsp; &amp; dwNum ? "Info"&nbsp;&nbsp;&nbsp; : ""),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (VS_FF_DEBUG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; dwNum ? "Special" : ""),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (0xFFFFFF00L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; dwNum ? "Unknown" : ""));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlstr = VBCreateTempHlstr(gszUserMsg, strlen(gszUserMsg));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALIDHLSTR(hlstr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hlstr;
</code></pre>
<p>
The switch operates on a passed-in parameter that specifies the information to be returned. This allows the code to stay in the same structure as originally written—"If it ain’t broke, don’t recode it."</p>
<h3>Putting It All Together</h3>
<p>
We have most of the version information function completed, with the exception of adding any features to make it easier to use from Visual Basic. The VERSTAMP example, VERORIG.C, has two routines that return data—and inasmuch as we want to keep the code structured like the example, we'll add an entry-point function to point us to the correct routine.</p>
<pre><code>HLSTR _pascal __export vbGetVerInfo(LPSTR szFullPath, int item)
{
 &nbsp; if (item &lt;=8)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; //0 "Illegal string"&nbsp;&nbsp;&nbsp;&nbsp; ,
 &nbsp;&nbsp;&nbsp;&nbsp; //1 "CompanyName" //These are all handled by the same call.
 &nbsp;&nbsp;&nbsp;&nbsp; //2 "FileDescription"
 &nbsp;&nbsp;&nbsp;&nbsp; //3 "FileVersion"
 &nbsp;&nbsp;&nbsp;&nbsp; //4 "InternalName" 
 &nbsp;&nbsp;&nbsp;&nbsp; //5 "LegalCopyright"
 &nbsp;&nbsp;&nbsp;&nbsp; //6 "LegalTrademarks"&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; //7 "ProductName"
 &nbsp;&nbsp;&nbsp;&nbsp; //8 "ProductVersion
 &nbsp;&nbsp;&nbsp;&nbsp; return ShowVerInfo(szFullPath,item);
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return BasicVerInfo(szFullPath,item);
 &nbsp; }
}&nbsp;&nbsp; 
</code></pre>
<p>
Some files may not have version information. An empty string returned above does not imply that there is no version information string; that element may simply have been left blank. To determine if version information is available, I created a second function, <b>HasVerInfo</b>.</p>
<p>
In Visual Basic the code might appear as follows:</p>
<pre><code>CMDialog1.Filename = "*.*" 'Look for all files.
CMDialog1.DialogTitle = "Select file to obtain version info from."
CMDialog1.Flags = &amp;H1800&amp;  'Selected file must exist.
CMDialog1.Action = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'OpenFile action
vsinfo(i) = CMDialog1.Filename
If HasVerInfo(CMDialog1.Filename) Then 'Should we call vbGetVerInfo?
 &nbsp;&nbsp; For i = 1 To 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '15 pieces of VerInfo are available.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vsinfo(i) = vbGetVerInfo(CMDialog1.Filename, i)
 &nbsp;&nbsp; Next I
Else
 &nbsp; For i = 1 To 15 'There are 15 pieces of VerInfo available.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vsinfo(i) = "n/a" 'Inform user that there is no info.
 &nbsp;&nbsp; Next I
End if
</code></pre>
<p>
To implement the function <b>HasVerInfo</b> in our DLL, we add:</p>
<pre><code>BOOL __export _pascal HasVerInfo(LPSTR szFullPath)
{
  DWORD dwVerInfoSize;
  DWORD dwVerHnd;
  
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // You must find the size first before getting any file info.
  dwVerInfoSize =GetFileVersionInfoSize(szFullPath, &amp;dwVerHnd);
  if (dwVerInfoSize)&nbsp; 'If size is 0, no information is there.
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return TRUE;&nbsp;&nbsp; // Return success
 &nbsp;&nbsp; }
  else
 &nbsp;&nbsp; {
 &nbsp;&nbsp; return FALSE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Return failure
 &nbsp;&nbsp; }
}
</code></pre>
<p>
The source code in NATIVEVB.DLL, which accompanies this article, applies the same techniques to other encapsulated functions. For homework, locate the original code of VERSTAMP in the MSDN Library Archive and compare to see how the conversion was done. The OLE Summary Information functions in the sample code demonstrate how very complex processing can be handled quite simply from Visual Basic's perspective.</p>
<h3>VBX or Visual Basic–Native Method?</h3>
<p>
The version information function represents a style of functions that uses structures. These structure-based functions require allocation of memory and navigation to obtain the information—why not encapsulate these functions in a VBX that has all the version information properties? Unless there are significant <i>demonstrated</i> performance differences, I would discourage this encapsulation approach for the following reasons:
<ul type=disc>
<li>
The VBX will definitely be slower if you need only a few properties.<br><br></li>
<li>
You have to add the VBX to the project and place an instance on a form.<br><br></li>
<li>
You no longer have dual Visual Basic and Microsoft Access functions.<br><br></li>
<li>
Encapsulation requires more lines of C code.</li>
</ul>
<p>
As a general principle, never write a VBX or OLE Control (OCX) that does not have events. DLLs can provide the same functionality as a VBX or OCX with better performance in most cases.</p>
<h2>Going in the Other Direction</h2>
<p>
We have discussed functions that take C-like parameters and return an HLSTR. Visual Basic strings can contain <b>Chr$(0)</b> or<b> \0</b>. When we pass a string with <b>Byval A$</b>, Visual Basic creates a copy of the string and then passes its pointer to the function. This string is a C string or LPSTR; that is, it is terminated by the first <b>Chr$(0)</b>. If the Visual Basic string happens to have a <b>Chr$(0)</b> in it, any characters after <b>Chr$(0)</b> will not be processed by the function. This problem can be resolved by passing in the Visual Basic string as an HLSTR instead of as an LPSTR. An LPSTR is a C string that terminates with a \0 or <b>Chr$(0)</b>.</p>
<p>
For example, if you open a file in binary mode, you can place the data into a Visual Basic string simply by reading it. Any manipulation of this string of binary data must be done using Visual Basic functions that accept the presence of <b>Chr$(0)</b> in the string. This manipulation can be slow, making a C-coded function preferable.</p>
<h3>Count the Nulls</h3>
<p>
Some API calls like <b>GetProfileString</b> return a string with a <b>Chr$(0)</b> between elements and <b>Chr$(0)+Chr$(0)</b> at the end of an array. It would be nice to be able to count the NULLs in the string. The trick is to pass the Visual Basic string in as a HLSTR not as a LPSTR. This means that the call is not like this:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=10%><pre><code>Visual Basic:</code></pre>
</td>
<td width=90%><pre><code>Declare Function Lib "NATIVEVB.DLL" vbCountNulls(Byval Buffer$) as Integer</code></pre>
</td>
</tr>
<tr valign=top>
<td width=10%><pre><code>C:</code></pre>
</td>
<td width=90%><pre><code>int __export _pascal vbCountNulls(LPSTR buffer)</code></pre>
</td>
</tr>
</table><br>
<p>
Instead, the call should be like this:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=10%><pre><code>Visual Basic:</code></pre>
</td>
<td width=90%><pre><code>Declare Function Lib "NATIVEVB.DLL" vbCountNulls(Buffer$) as Integer</code></pre>
</td>
</tr>
<tr valign=top>
<td width=10%><pre><code>C:</code></pre>
</td>
<td width=90%><pre><code>int __export _pascal vbCountNulls(HLSTR buffer)</code></pre>
</td>
</tr>
</table><br>
<p>
The latter call allows the string to be passed in as an HLSTR whereas the former will have the string passed in as an LPSTR. The string may not be the complete string because the first <b>Chr$(0)</b> will truncate it.</p>
<p>
Care must be taken with the string passed into a DLL as an HLSTR because any changes made to it in the DLL may be reflected in the original string in Visual Basic.</p>
<p>
The code to implement <b>vbCountNulls</b> is shown below. Instead of waiting for <b>*lpstr=='\0'</b> to identify when the end of the string is reached, a counter is used. The key to working with an HLSTR is obtaining the length and then knowing when you have reached the last character.</p>
<pre><code>int __export _pascal vbCountNulls(HLSTR hlstr)
{USHORT i=0, cb=VBGetHlstrLen(hlstr);&nbsp; //Obtain length of string.
 int cnt=0;&nbsp;&nbsp; //Set count to zero.
 LPSTR lpStr=VBDerefHlstr(hlstr);
 while(i++ &lt; cb)&nbsp; //Are we at the end of the string?
 &nbsp;&nbsp; if(*lpStr++=='\0') cnt++;&nbsp; //If a Chr$(0), increment counter.
 return cnt;
}
</code></pre>
<h3>AllTrim</h3>
<p>
In Visual Basic, the need for trimming spaces off both ends of a string is often solved by <b>Trim</b>. This function does not handle other white space, such as embedded tabs or carriage returns, which results in character-by-character analysis of the ends of the string, a painful and slow process in Visual Basic. The solution is to create a Visual Basic–native method function that does the trimming of white space for you, <b>vbAllTrim</b>. The code is shown below.</p>
<pre><code>// AllTrim: Moves all control characters and spaces from both ends of
// a C string.
HLSTR __export _pascal vbAllTrim(LPSTR buffer)
{LPSTR lpStart=buffer,lpEnd;
 USHORT cb=0;
 HLSTR hlstr;
 &nbsp; while((unsigned char)*lpStart &lt; 33)
 &nbsp;&nbsp;&nbsp;&nbsp; lpStart++; //Skip all characters that are spaces (x32) or below (x00.x32).
 &nbsp; lpEnd=lpStart;
 &nbsp; while(*lpEnd++ != 0); //Move to end of string.
 &nbsp; lpEnd--;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Backtrack to first good character but don't overshoot.
 &nbsp; while((lpEnd &gt; lpStart)&nbsp; //Don't go before start.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; ((unsigned char)*lpEnd &lt; 33)) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpEnd--;
 &nbsp; cb=1+(USHORT)( lpEnd-lpStart); //Bytes
 &nbsp; if (cb&lt; 1) return NULL;
 &nbsp; hlstr=VBCreateTempHlstr(lpStart,cb);
 &nbsp; VALIDHLSTR(hlstr);
 &nbsp; return hlstr;
}
</code></pre>
<p>
The use of <b>unsigned char</b> in the C code restricts characters deemed white space to values from 0 to 32, the control characters, and space. If a <b>signed char</b> was used, characters 128-255 would be included as white space because these characters are represented as negative numbers. This function obtains an LPSTR from Visual Basic, which means that the first <b>Chr$(0)</b> truncates the string. For homework, convert it to use a HLSTR parameter.</p>
<h3>vbChangeChar</h3>
<p>
The <b>vbChangeChar</b> function returns a string with all occurrences of one character replaced by another character. We create new memory and use it to build the transformed string.</p>
<pre><code>//------------------------------------------------------------
// ChangeChar: Changes all of one character to another.
//------------------------------------------------------------
HLSTR __export _pascal vbChangeChar(LPSTR buffer, LPSTR lpFrom, LPSTR lpTo)
{&nbsp;&nbsp; //Create a Visual Basic string and copy.
 &nbsp; LPSTR lpStart;
 &nbsp; short cbBuffer= strlen(buffer) ;
 &nbsp; short I=0;
 &nbsp; HLSTR hlstr=VBCreateTempHlstr(buffer,cbBuffer);
 &nbsp; lpStart=VBDerefHlstr(hlstr);
 &nbsp; 
 &nbsp; VALIDHLSTR(hlstr);&nbsp; //Make sure of success.
 while(I &lt; cbBuffer)&nbsp;&nbsp; //Are we at the end of the string?
 &nbsp;&nbsp; {
 &nbsp;&nbsp; if(*lpStart==*lpFrom)&nbsp; //If this character is to be changed, then 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *lpStart=*lpTo;&nbsp;&nbsp;&nbsp;&nbsp; //change it.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpStart++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Move to next character.
 &nbsp;&nbsp;&nbsp;&nbsp; I++;
 &nbsp;&nbsp; }
 &nbsp; 
 &nbsp; return hlstr;
}
</code></pre>
<p>
The use of this function from Visual Basic is simple and is done with the following line that normalizes a file’s UNC name:</p>
<pre><code>&nbsp;&nbsp;&nbsp;NormalUNC$=vbChangeChar(FileName$,"/","\")
</code></pre>
<p>
For homework, convert this function to use an HLSTR parameter and do string substitution instead of character substitution.</p>
<h2>Summary</h2>
<p>
This article shows how you can speed the coding of your Visual Basic and Microsoft Access code several fold, as well as improve its performance. The benefit of this method is having fewer lines of code to write, more robust exception handling, and a bit of C coding that you have to do only once. A further benefit is better isolation of the Visual Basic programmer from the operating system environment.</p>
<p>
One of the strengths of Visual Basic is its string manipulations. The original Visual Basic functions can be augmented with additional functions using the Visual Basic–native methodology described here. Future technical articles will include some of my string libraries and discuss issues in their design.</p>
<p>
One side benefit of this article is the ability to accurately time the performance of different coding styles. For many Visual Basic users, changing coding style may increase the performance speed of their existing applications by 50 percent. A future technical article will examine performance issues in detail.</p>
<h2>Bibliography</h2>
<p>
Appleman, Daniel. "Ten Commandments for Accessing the Windows API." <i>Visual Basic Programmer’s Journal</i>, August/September, 1993.</p>
<p>
Barlow, Chris, and Ken Henderson. "Mix C and VB for Maximum Performance and Productivity." <i>Visual Basic Programmer’s Journal</i>, August/September, 1993.</p>
<p>
Gunderson, Bob. "Extending Visual Basic with Microsoft Windows DLLs." January 1993.</p>
<p>
Knowledge Base Q71106. "How to Pass One-Byte Parameters from VB to DLL Routines."</p>
<p>
Knowledge Base Q112673. "How to Pass &amp; Return Unsigned Integers to DLLs from VB."</p>
<p>
Knowledge Base Q85108. "VB 'Bad DLL Calling Convention' Means Stack Frame Mismatch."</p>
<p>
Lassesen, Ken. "A Collection of Useful Native Visual Basic and Microsoft Access Functions." August 1994. (MSDN Library Archive, Technical Articles)</p>
<p>
The Cobb Group. "Accessing Initialization Files." <i>Inside Visual Basic</i>, July 1992 (Periodicals).</p>
<p>
Visual Basic 3.0 Professional Edition <i>Control Development Guide.</i> Microsoft Corporation, 1993.</p>
</BODY>
</HTML>
