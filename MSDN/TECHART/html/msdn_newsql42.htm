<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>New For SQL Server Version 4.2: DB-Library Cursors</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_newsql42"></a>New for SQL Server Version 4.2: DB-Library Cursors</h1>
<p>
Rick Vicik</p>
<p>
Created: March 20, 1992</p>
<h2>Abstract</h2>
<p>
A key new feature in Microsoft® SQL Server version 4.2 is the implementation of cursors. This article gives an overview of cursors and how they are implemented using DB-Library. The new DB-Library functions are listed and discussed.</p>
<h2>Introduction</h2>
<p>
Relational databases are set oriented. There is no concept of "next row" nor is there any way to operate on rows of a set individually, except with cursors. A cursor allows the individual rows of a results set to be processed one at a time, in a fashion similar to using a conventional disk file. The cursor is so called because it indicates the current position in a results set, as the cursor on a CRT screen indicates the current position.</p>
<p>
A new feature of the Microsoft® DB-Library (version 4.2 and later) is the implementation of cursors. This implementation is unique because it permits forward and backward scrolling (within certain limitations), direct access by position in the results set, and positioned UPDATE (even if the results set was defined with an ORDER BY clause). The current row can be an entire screenful of rows, and changes to the locally buffered rows can be reflected to the database in a single operation. Sensitivity to changes made by users is adjustable, and there are several concurrency control options.</p>
<p>
Cursors can be used in place of browse mode whenever scrolling through a results set, making occasional updates, is necessary. Cursors are less restrictive than browse mode because updating tables that do not contain timestamps is possible and because using multiple database connections is unnecessary. Unlike browse mode, cursors access data from the original tables, not from a snapshot copy. A unique index is required, but this should not be a problem because good relational database design requires that each table have a primary key, and the only efficient way to enforce uniqueness is with an index. A single front-end can have multiple cursors in use at any time through a single connection.</p>
<p>
Catalog information is obtained by using the Microsoft catalog stored procedures rather than by accessing the catalog tables directly. Thus, DB-Library cursors can be used with the Micro Decisionware® DB2 gateway and with other gateways that implement the Microsoft catalog stored procedures.</p>
<h2>Sensitivity to Change</h2>
<p>
Cursors can be classified into three main categories with regard to sensitivity to change: static, keyset-driven, and dynamic. Most databases on the market today are either static or keyset-driven.</p>
<h3>Static Cursor</h3>
<p>
In a static cursor, neither values, membership in the results set, nor ordering of the results set can change while the cursor is open. Making a snapshot copy of the entire results set or locking the entire results set ensures this behavior. You can implement static cursors by doing a SELECT ... INTO on a temporary table and then using the CURSOR application programming interfaces (APIs) on that table. Explicit static cursor functionality is unnecessary.</p>
<h3>Keyset-Driven Cursor</h3>
<p>
In a keyset-driven cursor, membership of rows in the results set as well as the ordering are fixed at open time (although changes to values made by the cursor owner or other users are visible). If a change causes the row to no longer qualify for membership or affects its ordering, the row does not disappear or move unless the cursor is closed and reopened. Deleted rows return a special "missing" error code when accessed, as do updates to the key field. Inserts by other users are not visible. In version 4.2, inserts made by the cursor owner are not visible either, but adding them to the end of the keyset is technically possible. Rows can be accessed by relative or absolute position in the results set.</p>
<h3>Dynamic Cursor</h3>
<p>
In a dynamic cursor, the effect of all changes made by anyone is visible at the next SCROLL operation. Changes that affect membership or ordering are visible, as well as inserts and deletes (deleted rows do not leave "holes"). Rows can be accessed by relative (but not absolute) position in the results set.</p>
<h3>Mixed (Keyset/Dynamic) Cursor</h3>
<p>
If the results set is too large to fit in the keyset buffer, the cursor is "mixed" (keyset/dynamic). Within the keyset, the cursor behavior is keyset-driven. Cursor behavior is dynamic when a FETCH operation crosses a keyset boundary. In a mixed cursor, fetch previous cannot cross a keyset boundary.</p>
<h2>Restrictions</h2>
<p>
The cursor definition can contain joins, views, or subselects. In Microsoft® SQL Server version 4.2, only a single view can be used. The view can contain joins, but the view cannot be joined with other views or base tables. ORDER BY, GROUP BY, and HAVING can be used in the cursor definition. FOR BROWSE, INTO, COMPUTE, and UNION cannot be used. Aggregates and expressions can be used but cannot be updated. Updates to a cursor on a view are allowed subject to the normal restrictions on view updates.</p>
<p>
In SQL Server version 4.2, ORDER BY, GROUP BY, and HAVING cannot be used with a dynamic cursor. This restriction may be lifted in a later release. The other restrictions on what is allowed in the SELECT statement are the same as for static cursors.</p>
<p>
A clustered index is necessary for optimum performance. If there is an ORDER BY or GROUP BY, be sure the clustered index can be used instead of sorting.</p>
<p>
No results can be pending on the connection when a DB-Library CURSOR operation is executed. DB-Library row buffering cannot be used with DB-Library cursors. The old DB-Library row buffering should be unnecessary given the capabilities of the cursor fetch buffer.</p>
<h2>Concurrency Control</h2>
<p>
The Microsoft implementation of DB-Library cursors provides several options for controlling concurrent access to the same data. At cursor open time, one of the following options must be specified: READONLY, LOCKCC, OPTCC, or OPTCCVAL.</p>
<p>
If READONLY is specified, updates are not permitted. If LOCKCC is specified, the set of rows currently in the fetch buffer is locked, and no other user can update or read those rows. Updates issued by the cursor owner, however, are guaranteed to succeed. Locks set with the LOCKCC option require a BEGIN TRAN statement. If OPTCC or OPTCCVAL is specified, the rows currently in the fetch buffer are not locked, and other users can access them freely. Collisions between updates issued by the cursor owner and updates made by other users are detected by saving and comparing timestamps or column values. If either of the optimistic concurrency control options is specified, the application must handle collisions with the updates of other users. This might involve showing the user both original and current row contents, for example, and asking if the update should still be applied.</p>
<p>
The two optimistic concurrency control options detect collisions differently. If OPTCC is specified, timestamps are used if available; otherwise, the value of each selected column is saved and compared with its previous value. If OPTCCVAL is specified, the value comparison is used regardless of whether a timestamp is available.</p>
<h2>New Functions</h2>
<p>
Five new functions were added to DB-Library to support cursors:
<ul type=disc>
<li>
<b>dbcursoropen</b><br><br></li>
<li>
<b>dbcursorbind</b><br><br></li>
<li>
<b>dbcursorfetch</b><br><br></li>
<li>
<b>dbcursor</b><br><br></li>
<li>
<b>dbcursorclose</b></li>
</ul>
<h3>Dbcursoropen</h3>
<p>
Declares and opens the cursor; specifies the fetch buffer size, the keyset size, and the concurrency control option.</p>
<p>
<b><i>hc</i>=dbcursoropen(<i>dbproc</i>,<i> stmt</i>,<i> keyset</i>,<i> ccopt</i>,<i> nrows</i>,<i> rowstat</i>)</b></p>
<p>
where:
<ul type=disc>
<li>
<i>hc</i> ("cursor handle") is returned and is used in subsequent cursor functions. All other cursor operations use <i>hc</i>, not <i>dbproc</i>, which allows multiple cursors to be used simultaneously with only one connection.<br><br></li>
<li>
<i>stmt</i> is a SQL SELECT statement that defines the results set. It cannot contain FOR BROWSE, INTO, COMPUTE, or UNION. The statement can be a join, or it can reference a single view (which contains joins). Stored procedures and batches containing multiple SQL statements or flow-of-control logic are not allowed.<br><br></li>
<li>
<i>keyset</i> specifies the size of the keyset in multiples of the fetch buffer window size (the maximum number of rows of keys to be buffered by DB-Library). <i>keyset</i> is specified not in rows but in units of <i>nrows</i>. The size of the keyset with respect to the size of the results set determines whether the cursor is forward-only, fully dynamic, keyset-driven, or mixed. The special values are:<ul type=disc>
<li>
CUR_FORWARD, which indicates scroll forward only<br><br></li>
<li>
CUR_DYNAMIC, which indicates fully dynamic<br><br></li>
<li>
CUR_KEYSET, which indicates fully keyset-driven</li>
</ul>
<p class=tl>
Any other integer indicates mixed (keyset-driven within the keyset, fully dynamic outside the keyset).</P></li>
<li>
<i>ccopt</i> is the concurrency control option and specifies whether the cursor is read-only (CUR_READONLY) or if "intent-to-update" locks (CUR_LOCKCC) or optimistic concurrency control (CUR_OPTCC) is to be used. Positioned UPDATE and DELETE can be performed only within the buffered row set and only if the rows were fetched with CUR_LOCKCC, CUR_OPTCC, or CUR_OPTCCVAL. CUR_LOCKCC guarantees the success of the operation. CUR_OPTCC performs optimistic concurrency control by comparing timestamps, and CUR_OPTCCVAL performs optimistic concurrency control by comparing values; the operation fails if the row has changed since last fetched.<br><br></li>
<li>
<i>nrows</i> is the fetch buffer size. All fetches attempt to fetch the specified number of rows. If fewer rows are fetched, <i>rowstat</i> indicates how many were fetched.<br><br></li>
<li>
<i>rowstat</i> is an array of row status codes indicating which rows had a problem during multirow fetches of multirow updates, deletes, or inserts. <i>rowstat</i> must contain <i>nrows</i> elements. The possible status codes are:<ul type=disc>
<li>
FTC_SUCCEED, which indicates row fetched<br><br></li>
<li>
FTC_MISSING, which indicates row deleted since cursor opened<br><br></li>
<li>
FTC_ENDOFKEYSET, which indicates row not fetched because keyset reached<br><br></li>
<li>
FTC_ENDOFRESULTS, which indicates row not fetched because end of results reached</li>
</ul>
<p class=tl>
The last two can apply at the same time. The values are ORed together.</P></li>
</ul>
<p>
This function sets up for the execution of the SELECT statement but does not actually execute it until the FETCH.</p>
<p>
Error conditions:
<ul type=disc>
<li>
SELECT statement fails<br><br></li>
<li>
No unique index<br><br></li>
<li>
Not enough memory for keyset</li>
</ul>
<h3>Dbcursorbind</h3>
<p>
Registers an array of datatype <i>datatype</i> and an array to receive the actual length of each instance of the column. This function works exactly like the original <b>dbbind</b> function.</p>
<p>
<b>dbcursorbind(<i>hc</i>,<i> col</i>,<i> datatype</i>,<i> size</i>,<i> outlen</i>,<i> buffer</i>)</b></p>
<p>
where:
<ul type=disc>
<li>
<i>hc</i> is the cursor handle created by a previous <b>dbcursor</b> function.<br><br></li>
<li>
<i>col</i> is the column number in the select list (1-based, same as <b>dbbind</b>).<br><br></li>
<li>
<i>datatype</i> is one of the <b>dbbind</b> datatypes. <b>nobind</b> is a special flag indicating that the data should not be moved into program buffers when the FETCH executes; instead, the addresses of the data are inserted into the BUFADR array. The application can then use those addresses to access the data directly from the DB-Library buffers.<br><br></li>
<li>
<i>size</i> is the maximum buffer size (required for variable-length items only). Fixed-length items such as integers have an implicit length.<br><br></li>
<li>
<i>outlen</i> is an optional array of integers to receive the actual length of each instance of this column. The number of elements must be the same as the <i>nrows</i> parameter used on the <b>dbcursoropen</b> function. <i>outlen</i> elements can also be used to indicate null input columns when updating or inserting from buffers bound with <b>dbcursorbind</b> (0=NULL). If a variable-length datatype (<i>varycharbind</i> or <i>varybinarybind</i>) or the <b>nobind</b> flag is specified, the actual lengths of the items must be inserted into this parameter before calling <b>dbcursor</b> with the UPDATE or INSERT <i>optype.</i> If a null-terminated datatype is specified (<i>stringbind</i> or <i>ntbstringbind</i>), nonzero values of this parameter are ignored, and the length of each item is determined by scanning for the null terminator.<br><br></li>
<li>
<i>buffer</i> is an array program buffer to receive the column data. The number of elements must match the <i>nrows</i> parameter of the <b>dbcursoropen</b> function that created the <i>hc</i>. The maximum size of each element is either implied by the <i>datatype</i> parameter or specified by the <i>size</i> parameter.</li>
</ul>
<p>
Error conditions:
<ul type=disc>
<li>
Invalid cursor handle<br><br></li>
<li>
Invalid datatype</li>
</ul>
<h3>Dbcursorfetch</h3>
<p>
Fills the fetch buffer with rows from the database. If program variables are registered with a valid <b>dbbind</b> type, the data is moved into those variables (they are assumed to be arrays). If <b>nobind</b> is specified, the address(es) of each row is placed in the array of buffer pointers specified in the <b>dbcursorbind</b> function.</p>
<p>
<b>dbcursorfetch(<i>hc</i>, <i>fetchtype</i>, <i>rownumber</i>)</b></p>
<p>
where:
<ul type=disc>
<li>
<i>fetchtype</i> is either FETCH_NEXT, FETCH_PREV, FETCH_FIRST, FETCH_LAST, FETCH_RANDOM, or FETCH_RELATIVE. (RANDOM can be used only if the cursor was declared keyset-driven.)<br><br></li>
<li>
<i>rownumber</i> is used only with RANDOM or RELATIVE. The buffer is filled starting with the specified row.</li>
</ul>
<p>
If a FETCH operation reaches a keyset boundary before completely filling the fetch buffer on mixed cursors, the FETCH operation terminates, and the remaining fetch buffer rows are not filled. The row-status array can be used to determine which rows were actually fetched.
<ul type=disc>
<li>
Error conditions:<br><br></li>
<li>
Out of memory<br><br></li>
<li>
Server or connection failure<br><br></li>
<li>
Can't go back to previous keyset (mixed) <br><br></li>
<li>
RANDOM and LAST require keyset-driven cursor<br><br></li>
<li>
FORWARD-ONLY can use only NEXT or FIRST </li>
</ul>
<h3>Dbcursor</h3>
<p>
Performs positioned UPDATE and DELETE with a single function that also does inserts, updates for specific rows, and read-for-updates (which prevent other users from changing the data read).</p>
<p>
<b>dbcursor</b>(<b><i>hc</i></b>, <b><i>optype</i></b>, <b><i>bufno</i></b>, <b><i>table</i></b>, <b><i>values</i></b>)</p>
<p>
where:
<ul type=disc>
<li>
<i>optype</i> is the operation type: CRS_UPDATE, CRS_DELETE, CRS_INSERT, CRS_REFRESH, or CRS_LOCKCC.<br><br></li>
<li>
<i>bufno</i> specifies the row on which the fetch buffer is to operate. "0" indicates "all buffers" (SQL Server version 4.2 implements this only for REFRESH). The new values for UPDATE and INSERT operations are taken from the specified buffer or from the <i>values</i> parameter if one is supplied. <i>bufno</i> is 1-based; references to array elements in C are 0-based.<br><br></li>
<li>
<i>table</i> identifies the table to which the operation applies when the cursor definition involves a join. It may be specified as NULL when the cursor definition does not involve a join.<br><br></li>
<li>
<i>values</i> is used only with the UPDATE or INSERT <i>optype</i> and only when the new value must be specified as an expression involving the old value (c1=c1+1). It must be a SET clause for updates or a VALUES clause for inserts. In most cases this parameter can be set to NULL, and the new value for each column is taken from the fetch buffer (the program variable specified by <b>dbcursorbind</b>).<p class=tl>
Four formats are possible for the <i>values</i> parameter: two for UPDATE and two for INSERT. Each has a full format and an abbreviated format. The format must match the <i>optype</i> (UPDATE or INSERT). The full format is a complete SQL statement (UPDATE or INSERT) without a WHERE clause. The abbreviated format is the SET clause (UPDATE) or the VALUES clause (INSERT) only. When the full format is used, the specified table name overrides the table specified in the <i>table</i> parameter of <b>dbcursor</b>.</P></li>
</ul>
<p>
Updates and deletes are guaranteed to succeed if the cursor is defined with CUR_LOCKCC. If the rows are not locked, optimistic concurrency control is used, and the UPDATE or DELETE may fail with "row not found" or "row changed." If a row has changed, the buffer value can be updated with CRS_REFRESH. To guarantee that a row cannot change without locking all the rows in the fetch buffer, use the <b>dbcursor </b>function with <i>optype</i> CRS_LOCKCC to refetch a specific row and acquire an exclusive lock on it. These locks are released at COMMIT time. Locks are not automatically released when the next FETCH is executed.</p>
<p>
If a positioned operation that applies to multiple rows fails, the array of row status indicators (declared on the <b>dbcursoropen</b>) can be used to determine which failed.</p>
<h4>Dbcursor update subfunction</h4>
<p>
The specified row in the fetch buffer is used to construct a searched UPDATE. The WHERE clause is constructed from the values in the specified fetch buffer. The WHERE clause includes only the key columns if the row was locked when fetched. If the row was not locked, the WHERE clause also contains either the timestamp or the rest of the selected columns. The SET clause is constructed from the values in the specified fetch buffer or from the expressions supplied in the <i>values</i> parameter. If the cursor definition involves a join, the <i>table</i> parameter must be used to specify that the update applies to only one of the tables in the join. An update with a <i>values</i> parameter updates the specified row in the fetch buffer. If the update changes the unique index value, the row appears as missing.</p>
<p>
Error conditions:
<ul type=disc>
<li>
Row changed or deleted<br><br></li>
<li>
Invalid bufno<br><br></li>
<li>
Read-only cursor<br><br></li>
<li>
Invalid SET clause<br><br></li>
<li>
No buffers bound<br><br></li>
<li>
Other update errors (security, rules, and so on)</li>
</ul>
<h4>Dbcursor insert subfunction</h4>
<p>
This is a convenient way to construct an INSERT statement from the buffers bound with <b>dbcursorbind</b>. The data from the specified buffer is used to construct an INSERT statement. The buffer is not updated until the next <b>dbcursorfetch</b> is executed.</p>
<p>
Error conditions:
<ul type=disc>
<li>
<font face="Symbol">·</font>No buffers bound<br><br></li>
<li>
<font face="Symbol">·</font>Invalid <i>bufno</i><br><br></li>
<li>
<font face="Symbol">·</font>Read-only cursor<br><br></li>
<li>
<font face="Symbol">·</font>Other insert failures (security, rules, and so on)</li>
</ul>
<h4>Dbcursor refresh subfunction</h4>
<p>
The specified row in the fetch buffer is updated using the concurrency control specified with the cursor definition. This function is used to update the specified row if an UPDATE or DELETE fails as a result of optimistic concurrency control. It can also be used to update the buffer after a delete or an update to a join. For example, a positioned UPDATE to a column in the master base table of a master-detail join would require that the entire buffer be updated so that all rows in the buffer would have the new value. Whether deletes disappear or leave holes depends on whether the cursor is keyset-driven or dynamic.</p>
<p>
Error conditions:
<ul type=disc>
<li>
Row locked<br><br></li>
<li>
Row deleted<br><br></li>
<li>
Row changed</li>
</ul>
<h4>Dbcursor lock subfunction</h4>
<p>
An exclusive lock is acquired on the database page corresponding to the specified row in the fetch buffer. This function is used to gain exclusive control over a single row for the purpose of updating it. Set a "deadman" timer to avoid holding this lock forever.</p>
<p>
Error conditions:
<ul type=disc>
<li>
Row locked<br><br></li>
<li>
Row deleted<br><br></li>
<li>
Row changed<br><br></li>
<li>
Read-only cursor</li>
</ul>
<h3>Dbcursorclose</h3>
<p>
Closes the specified cursor and releases all resources such as buffered keys and timestamps, bound columns, and so on.</p>
<p>
<b>dbcursorclose(<i>hc)</i></b></p>
<h2>Examples</h2>
<h3>Keyset-Driven</h3>
<p>
If the results set is small or if static membership is appropriate for the application, set Scroll-Option to Keyset Driven. Relative and absolute row access is possible, and deletes leave holes. Values change between fetches, but rows do not move around if the changes affect ORDER BY columns; nor do they disappear if they no longer satisfy the WHERE clause. The example demonstrates page forward and page back and direct access positioning by means of the scroll bar slider position.</p>
<pre><code>DBPROC&nbsp;&nbsp; *dbproc;
 DBCURSOR *hc;
 DBINT&nbsp;&nbsp;&nbsp; rowstats[20],idl[20],namel[20],cols,rows,r,RC;
 DBINT&nbsp;&nbsp;&nbsp; id[20];
 char&nbsp;&nbsp;&nbsp;&nbsp; name[20][40];
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; hC=dbcursoropen(dbproc,"SELECT id,name FROM emp",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUR_KEYSET, CUR_READONLY, 20, rowstats);
 &nbsp; dbcursorinfo(hC,&amp;cols,&amp;maxrows);
 &nbsp; dbcursorbind(hC, 1,&nbsp;&nbsp;&nbsp; INTBIND,&nbsp;&nbsp; sizeof(id),&nbsp;&nbsp; idl,&nbsp;&nbsp; id );
 &nbsp; dbcursorbind(hC, 2, STRINGBIND, sizeof(name), namel, name );
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp;&nbsp;&nbsp; case SB_PAGEDOWN:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursorfetch(hC, FETCH_NEXT, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 
 &nbsp;&nbsp;&nbsp; case SB_PAGEUP:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursorfetch(hC, FETCH_PREV, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 
 &nbsp;&nbsp;&nbsp; case SB_THUMBPOSITION:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursorfetch(hC, FETCH_RANDOM, (lParam*,maxrows)/100 );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp;&nbsp;&nbsp; if( RC!=ERROR ){
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( r=0,y=y0; r&lt;20; r++,y+=VSpacing ){
 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rowstats[r]==FTC_MISSING )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTextColor(hDC, RGB(255,0,0) );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTextColor(hDC, RGB(0,0,0) );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextOut(hDC, x1, y,&nbsp;&nbsp; id[r],&nbsp;&nbsp; idl[r] );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextOut(hDC, x2, y, name[r], namel[r] );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp; .
 &nbsp; .
 &nbsp; .
</code></pre>
<p>
For very large results sets, buffering all the keys may be impossible. In such cases, set Scroll-Option to the maximum number of rows of keys to be buffered. Within the keyset, fast relative and absolute row access is possible, regardless of the availability of a suitable index. The keyset window can scroll as the buffered row set is about to leave the keyset. If a clustered index is available, scrolling the keyset forward is relatively fast, but scrolling it back is slow. If the SELECT statement contains an ORDER BY clause that cannot be executed by using a clustered index, scrolling the keyset forward is slow because repeated sorting is necessary.</p>
<h3>Dynamic Scrolling</h3>
<p>
If dynamic membership is appropriate for the application, set Scroll-Option to Dynamic. The keyset size then equals the buffered keyset size. For adequate performance, fetch 1020 rows. Paging forward is relatively fast if a clustered index matches the ORDER BY clause, but paging back is slow. Absolute positioning is impossible.</p>
<pre><code>&nbsp;&nbsp; DBPROC&nbsp;&nbsp; *dbproc;
 DBCURSOR *hc;
 DBINT&nbsp;&nbsp;&nbsp; rowstats[20],idl[20],namel[20],cols,rows,r;
 DBINT&nbsp;&nbsp;&nbsp; RC,delta,CurRow=0,maxrows=40;
 DBINT&nbsp;&nbsp;&nbsp; *idptrs[20];
 char&nbsp;&nbsp;&nbsp;&nbsp; *nameptrs[20];
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; hC=dbcursoropen(dbproc,"SELECT id,name FROM emp",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUR_DYNAMIC, CUR_READONLY, 20, rowstats);
 &nbsp; dbcursorbind(hC, 1, NOBIND,&nbsp;&nbsp; sizeof(id),&nbsp;&nbsp; idl,&nbsp;&nbsp; idptrs );
 &nbsp; dbcursorbind(hC, 2, NOBIND, sizeof(name), namel, nameptrs );
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp;&nbsp;&nbsp; case SB_PAGEDOWN:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursorfetch(hC, FETCH_NEXT, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delta=20;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 
 &nbsp;&nbsp;&nbsp; case SB_PAGEUP:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursorfetch(hC, FETCH_PREV, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delta=-20;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 
 &nbsp;&nbsp;&nbsp; case SB_THUMBPOSITION:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delta=(lParam*maxrows)/100 -CurRow;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursorfetch(hC, FETCH_RANDOM, delta );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp;&nbsp;&nbsp; if( RC!=ERROR ){
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CurRow+=delta;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( maxrows/CurRow&lt;=2 )&nbsp; maxrows+=maxrows*(CurRow/delta);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( r=0,y=y0; r&lt;20; r++,y+=VSpacing ){
 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rowstats[r]==FTC_MISSING )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTextColor(hDC, RGB(255,0,0) );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTextColor(hDC, RGB(0,0,0) );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextOut(hDC, x1, y,&nbsp;&nbsp; *idptrs[r],&nbsp;&nbsp; idl[r] );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextOut(hDC, x2, y, *nameptrs[r], namel[r] );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp; .
 &nbsp; .
 &nbsp; .
</code></pre>
<h3>Updates with Optimistic Concurrency Control</h3>
<p>
For typical interactive browse or update applications, set Scroll-Option to handle the greatest page-backward request anticipated. The keyset size is specified in units of the local buffer size (20 * 50 = 1000 rows). Fetch one screenful of rows at a time. Rely on optimistic concurrency control to protect against lost updates. The <i>bufno</i> parameter in <b>dbcursor</b> is specified as <i>row+1</i> because it is 1-based; references to array elements in C are 0-based.</p>
<pre><code>DBPROC&nbsp;&nbsp; *dbproc;
 DBCURSOR *hc;
 DBINT&nbsp;&nbsp;&nbsp; rowstats[20],idl[20],namel[20],cols,rows,r,RC;
 DBINT&nbsp;&nbsp;&nbsp; id[20];
 char&nbsp;&nbsp;&nbsp;&nbsp; name[20][40];
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; hC=dbcursoropen(dbproc,"SELECT id,name FROM emp",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUR_KEYSET, CUR_OPTCC, 20, rowstats);
 &nbsp; dbcursorbind(hC, 1,&nbsp;&nbsp;&nbsp; INTBIND,&nbsp;&nbsp; sizeof(id),&nbsp;&nbsp; idl,&nbsp;&nbsp; id );
 &nbsp; dbcursorbind(hC, 2, STRINGBIND, sizeof(name), namel, name );
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp;&nbsp;&nbsp; case VK_PAGEDOWN:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursorfetch(hC, FETCH_NEXT, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 
 &nbsp;&nbsp;&nbsp; case VK_PAGEUP:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursorfetch(hC, FETCH_PREV, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 
 &nbsp;&nbsp;&nbsp; case VK_ENTER:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( r=0,y=y0,RC=SUCCEED; r&lt;20; r++,y+=VSpacing ){
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( SendMessage( hID[r],&nbsp;&nbsp; EM_GETMODIFY, ... )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ||&nbsp; SendMessage( hName[r], EM_GETMODIFY, ... )&nbsp; ){
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage( hID,&nbsp;&nbsp; EM_GETLINE, 0, id[r]&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage( hName, EM_GETLINE, 0, name[r] );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursor( hC, CRS_UPDATE, r+1, NULL, NULL );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( SendMessage( hDelFlag[r], EM_GETMODIFY, ... ) )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursor( hC, CRS_DELETE, r+1, NULL, NULL );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( RC!=SUCCEED ){
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursor( hC, CRS_REFRESH, r+1, NULL, NULL );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTextColor(hDC, RGB(255,0,0) );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextOut(hDC, x1, y[r],&nbsp;&nbsp; id[r],&nbsp;&nbsp; idl[r] );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextOut(hDC, x2, y[r], name[r], namel[r] );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; .
 &nbsp; .
 &nbsp; .
</code></pre>
<h3>Updates with Short-Duration Locking</h3>
<p>
In high-contention environments, refetching the row on which the user is operating with the <b>lock</b> option may be more desirable than locking an entire screenful of rows. In the example below, when an entry field gets focus, an array of entry field window IDs is scanned. If there is a match, the row and column numbers corresponding to the entry field are known. The appropriate row can then be refetched with <b>lock</b>. Whenever focus is lost, the entry field is asked whether it was changed. If it was, the row is updated. The application must issue BEGIN TRAN and COMMIT at the appropriate places to control the holding and releasing of locks.</p>
<p>
Fetching the entire buffered row set with <b>lock</b> may be appropriate in some environments, although concurrency will be reduced.</p>
<pre>&nbsp;&nbsp;<code> DBPROC&nbsp;&nbsp; *dbproc;</code>
<code> DBCURSOR *hc;</code>
<code> DBINT&nbsp;&nbsp;&nbsp; rowstats[20],idl[20],namel[20],cols,rows,r,RC;</code>
<code> DBINT&nbsp;&nbsp;&nbsp; id[20];</code>
<code> char&nbsp;&nbsp;&nbsp;&nbsp; name[20][40];</code>
<code> &nbsp; .</code>
<code> &nbsp; .</code>
<code> &nbsp; .</code>
<code> &nbsp; hC=dbcursoropen(dbproc,"SELECT id,name FROM emp",</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUR_KEYSET, CUR_OPTCC, 20, rowstats);</code>
<code> &nbsp; dbcursorbind(hC, 1,&nbsp;&nbsp; INTBIND,&nbsp;&nbsp; sizeof(id),&nbsp;&nbsp;&nbsp; idl,&nbsp;&nbsp; id );</code>
<code> &nbsp; dbcursorbind(hC, 2, STRINGBIND, sizeof(name), namel, name );</code>
<code> &nbsp; .</code>
<code> &nbsp; .</code>
<code> &nbsp; .</code>
<code> &nbsp;&nbsp;&nbsp; case EN_SETFOCUS:</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execsql(dbproc,"begin tran");</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( r=0; r&lt;20; r++ ){</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( lParam==hID[r] || lParam==hName[r] )</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursor(hC, CRS_LOCKCC, r+1 NULL, NULL);</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</code>
<code> </code>
<code> </code>
<code> &nbsp;&nbsp;&nbsp; case EN_KILLFOCUS:</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( r=0; r&lt;20; r++ ){</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( SendMessage( hID[r],&nbsp;&nbsp; EM_GETMODIFY, ... )</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ||&nbsp; SendMessage( hName[r], EM_GETMODIFY, ... )&nbsp; ){</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage( hID,&nbsp;&nbsp; EM_GETLINE, 0, id[r]&nbsp;&nbsp; );</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage( hName, EM_GETLINE, 0, name[r] );</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RC=dbcursor( hC, CRS_UPDATE, r+1, NULL, NULL );</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execsql(dbproc,"commit tran");</code>
<code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</code>
<code> &nbsp; .</code>
<code> &nbsp; .</code>
<code> &nbsp; .</code>
</pre>
</BODY>
</HTML>
