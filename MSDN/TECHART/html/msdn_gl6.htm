<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OpenGL VI: Rendering on DIBs with PFD_DRAW_TO_BITMAP</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_gl6"></a></sup>OpenGL VI: Rendering on DIBs with PFD_DRAW_TO_BITMAP</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
April 18, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4057">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the EasyBit sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4060">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the GLlib DLL for this technical article.</a></p>
<h2>Abstract</h2>
<p>
The PFD_DRAW_TO_BITMAP pixel format descriptor flag allows OpenGL™ applications to render on a Microsoft® Windows® device-independent bitmap (DIB). The resulting DIB can be manipulated to the full extent using the commands in the Windows graphics device interface (GDI). This article explains how you can render OpenGL scenes on DIBs with PFD_DRAW_TO_BITMAP. The EasyBit sample application demonstrates the techniques presented in the article.</p>
<h2>Introduction</h2>
<p>
Recently, I took a trip back home to visit my parents. The first evening, I walked out to the dock to watch the setting sun turn the sky crimson orange. The silence of the coming night didn't match the intensity of the fiery inferno appearing in the sky. Eventually, the fire subsided into the waters of the lake, and the only lights were those of the stars above.</p>
<p>
I lay down on the dock to see the stars better. It wasn't long before I felt something pushing tentatively on my chest. Satisfied with his search, the neighbor's cat, Zephyr, climbed on my chest, purring with an intensity rivaling an asthma attack. I was amazed. I had only known the cat for nine months, and I had last seen him over two years ago. Did he remember me? Did he even know who I was? Did he care?</p>
<p>
Like Zephyr, who doesn't care whose lap he sits on, OpenGL™ doesn't care which surface it renders on. Again like Zephyr, who pokes my chest to see whether it's okay to lie down on it, OpenGL must make sure that the rendering surface is okay. Currently, OpenGL will render in windows and on bitmaps. Zephyr is more promiscuous than that; I have no idea how many laps he sits on.</p>
<p>
The previous articles in this series focused on rendering in a window. This article will focus on rendering on a bitmap or, more specifically, on a device-independent bitmap (DIB) section. The article covers the following topics:
<ul type=disc>
<li>
A description of the EasyBit sample application<br><br></li>
<li>
Reasons for drawing on bitmaps<br><br></li>
<li>
Using the PFD_DRAW_TO_BITMAP pixel format descriptor<br><br></li>
<li>
Modifications to GLlib to support rendering on DIBs<br><br></li>
<li>
A discussion of DIB sections<br><br></li>
<li>
Selecting the correct pixel format<br><br></li>
<li>
Complications introduced by palettes<br><br></li>
<li>
Using the same palette as the system to improve performance<br><br></li>
<li>
A guide to troubleshooting your application</li>
</ul>
<h2>EasyBit Sample Application</h2>
<p>
The EasyBit sample application demonstrates how to render OpenGL images on a bitmap. Figure 1 below provides a simulated screen shot of EasyBit. (I didn't use a real screen shot because the Microsoft® Development Library software doesn't display 256-color images.)</p>
<p>
<img src="gl6_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Simulated screen shot from EasyBit</b></p>
<p>
The client area of the window is rendered using the same code (<b>CScene</b>) that EasyGL uses. This scene is rendered on the window (PFD_DRAW_TO_WINDOW) using double buffering (PFD_DOUBLEBUFFER). As you can see in Figure 1, the left side of the screen contains four squares containing images rendered by OpenGL. In the first square, <b>CScene</b> renders on an 8-bits-per-pixel (bpp) <b>CDIBSurface</b>, a class defined in Nigel Thompson's animation library. (<b>CDIBSurface </b>was created after Nigel's book, <i>Animation Techniques for Win32</i>, was released.)</p>
<p>
In the next three squares, <b>CSceneBox</b>, <b>CScenePyramid</b>, and <b>CSceneDodec </b>render on an 8-bpp, 16-bpp, and 24-bpp <b>CSimpleDIB</b>, which is defined in EasyBit. Both <b>CSimpleDIB </b>and <b>CDIBSurface </b>will be discussed later in this article. The graphics device interface (GDI) <b>Rectangle </b>command draws a border around the DIBs, and <b>TextOut </b>writes a caption for each DIB. As you can see, GDI and OpenGL commands can be mixed on the DIB.</p>
<p>
I added the ability to rotate any object (from the GLEasy sample application) to EasyBit. The user selects a shape from the Rotate menu, which is the self-drawing menu illustrated in Figure 2.</p>
<p>
<img src="gl6_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Self-drawing menu in EasyBit</b></p>
<p>
<b>CSceneBox</b>, <b>CScenePyramid</b>, and <b>CSceneDodec </b>are rendered on <b>CSimpleDIB</b>s for display in the Rotate menu. If the screen has 8 bpps, 8-bpp <b>CSimpleDIB</b>s are created for rendering the OpenGL scenes. If the screen does not have 8 bpps, 24-bpps <b>CSimpleDIB</b>s are created. (See the article <a href="msdn_selfdraw.htm">"MFC Self-Drawing Menus"</a> in the Development Library for more information on how I created this menu.)</p>
<p>
The shape currently selected for rotating is displayed in the status bar, as shown in Figure 3. For more information on customizing the status bar, see my article <a href="msdn_status.htm">"Bitmaps and Other CStatusBar Customizations"</a> in the Development Library.</p>
<p>
<img src="gl6_3.gif" border=0></p>
<p class=label>
<b>Figure 3. EasyBit status bar with bitmap of shape to rotate</b></p>
<p>
EasyBit also measures the blting performances of the DIBs with different bpps; select the Blting option from the Time menu.</p>
<p>
When a shape is rotating, I decided not to display the figures on the left side of the EasyBit screen (see Figure 1), because displaying these bitmaps resulted in too much flickering. The main client area is painted using <b>CScene</b> with double buffering. The new GDI <b>SwapBuffers</b> function in Win32® copies the contents of the back buffer to the screen. It paints the entire client area of the window associated with the current rendering context. This requires blting the bitmaps on the left side of the screen each time the shape rotates.</p>
<p>
If you wish to display the bitmaps but avoid flashing, you can use one of the following options:
<ul type=disc>
<li>
Create a child window on the view on which <b>CScene </b>rendered. <b>SwapBuffers</b> can update the client area of the child window instead of the client area of the view.<br><br></li>
<li>
Change <b>CScene</b> to render on a bitmap, and then blt this bitmap to the screen.</li>
</ul>
<p>
However, I didn't bother because I didn't think it was necessary to display the bitmaps on the screen while the object was rotating.</p>
<h3>Class Map</h3>
<p>
The table below describes the important classes in EasyBit.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>File Name</b></td>
<td class=label width=22%><b>Class Name</b></td>
<td class=label width=51%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=27%>shapes.cpp</td>
<td width=22%>&lt;no class&gt;</td>
<td width=51%>Contains code to build OpenGL display lists for the box, pyramid, and dodecahedron.</td>
</tr>
<tr valign=top>
<td width=27%>scene.cpp</td>
<td width=22%><b>CScene</b></td>
<td width=51%>Identical to the <b>CScene</b> class in EasyGL, except that it uses the display lists in shapes.cpp and includes rotation for the shapes.</td>
</tr>
<tr valign=top>
<td width=27%>scenevw.cpp</td>
<td width=22%><b>CSceneVw</b></td>
<td width=51%>Inherits from the GLlib <b>CGLView</b> class. I also added rotation support and code to render images on the DIB sections displayed on the left side of the EasyBit screen.</td>
</tr>
<tr valign=top>
<td width=27%>csimpledib.cpp</td>
<td width=22%><b>CSimpleDIB</b></td>
<td width=51%>Implements a simple encapsulation of a DIB section. Supports the creation of 8-, 16-, and 24-bpp DIB sections. OpenGL images are rendered on these DIB sections. The application also uses Nigel Thompson's <b>CDIBSurface</b> class.</td>
</tr>
<tr valign=top>
<td width=27%>cscenebox.cpp</td>
<td width=22%><b>CSceneBox</b></td>
<td width=51%>Inherits from the GLlib <b>CGL</b> class. Uses the OpenGL display list for a box contained in shapes.cpp.</td>
</tr>
<tr valign=top>
<td width=27%>cscenepyramid.cpp</td>
<td width=22%><b>CScenePyramid</b></td>
<td width=51%>Inherits from the GLlib <b>CGL</b> class. Uses the OpenGL display list for a pyramid contained in shapes.cpp.</td>
</tr>
<tr valign=top>
<td width=27%>cscenedodec.cpp</td>
<td width=22%><b>CSceneDodec</b></td>
<td width=51%>Inherits from the GLlib <b>CGL</b> class. Uses the OpenGL display list for a dodecahedron contained in shapes.cpp.</td>
</tr>
<tr valign=top>
<td width=27%>sceneci.cpp</td>
<td width=22%><b>CSceneCI</b></td>
<td width=51%>A color index mode version of <b>CScene</b>. Demonstrates the creation of an identity palette. The code for <b>CSceneCI</b> comes from the EasyCI sample application.</td>
</tr>
<tr valign=top>
<td width=27%>cmystatusbar.cpp</td>
<td width=22%><b>CMyStatusBar</b></td>
<td width=51%>Implements a customized status bar. See <a href="msdn_status.htm">"Bitmaps and Other CStatusBar Customizations"</a> in the Development Library and Figure 3 earlier in this article.</td>
</tr>
<tr valign=top>
<td width=27%>cownermenu.cpp</td>
<td width=22%><b>COwnerMenu</b></td>
<td width=51%>Implements the self-drawing Rotate Menu. See <a href="msdn_selfdraw.htm">"MFC Self-Drawing Menus"</a> in the Development Library and Figure 2 earlier in this article.</td>
</tr>
</table><br>
<h2>Reasons for Drawing on Bitmaps</h2>
<p>
In the previous articles in this series, we covered rendering OpenGL directly to the client area of a window, as illustrated in Figure 4.</p>
<p>
<img src="gl6_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Rendering in a window</b></p>
<p>
In <a href="msdn_gl1.htm">"OpenGL I: Quick Start"</a> and <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started"</a>, we discussed how to set up the pixel format descriptor of a window so we could use OpenGL commands. Rendering to a window requires using the PFD_DRAW_TO_WINDOW flag in the pixel format descriptor.</p>
<p>
In some cases, you don't want to draw directly to the screen. Nothing looks worse than watching an application paint the client area piece by piece. For smooth animation, off-screen rendering isn't only nice, it's required. OpenGL for Windows NT™ supports off-screen rendering whenever the pixel format for a window is set for double buffering. Use the PFD_DOUBLEBUFFER pixel format descriptor flag to enable double buffering for a particular window. My OpenGL sample applications use double buffering. With double buffering enabled, OpenGL renders to an off-screen buffer, and the GDI <b>SwapBuffers</b> command moves the contents of the off-screen buffer onto the screen. Figure 5 illustrates this process.</p>
<p>
<img src="gl6_5.gif" border=0></p>
<p class=label>
<b>Figure 5. Double buffering</b></p>
<p>
For the generic pixel formats, the off-screen buffer is a DIB section. Some OpenGL graphic accelerators use special hardware to implement the off-screen buffer on the card. </p>
<p>
Double buffering, as supported by the Windows NT implementation of OpenGL, solves many of the problems caused by rendering directly to the screen. However, you cannot access the off-screen buffer. You can't draw on it or manipulate it, except with OpenGL commands.</p>
<p>
Another limitation is caused by the <b>SwapBuffers</b> command. When <b>SwapBuffers </b>is called, it clears the entire client area of the window associated with the current rendering context. There is no way to restrict <b>SwapBuffers </b>to a specific part of the client area. Remember that <b>SwapBuffers</b> is a Windows® GDI command and not part of OpenGL. The OpenGL scissor and stencil features are generally used to restrict OpenGL from drawing to parts of the screen, but they do not affect <b>SwapBuffers</b>. This can be a major limitation if you are mixing GDI and OpenGL in your application. Another limitation of <b>SwapBuffers </b>is that the effects of calling it a second time are undefined. Thus, you can't render a scene once, and then call <b>SwapBuffers </b>multiple times to update the display.</p>
<p>
An approach to off-screen rendering that provides the application with more control is rendering on a bitmap. If you use the PFD_DRAW_TO_BITMAP pixel format descriptor flag instead of PFD_DRAW_TO_WINDOW, OpenGL will render the image on a bitmap instead of rendering it to a window. After OpenGL has rendered on the bitmap, you can use GDI commands to do whatever you want with the bitmap, from simply blting it on the screen to writing text on the bitmap. If you use a DIB section (more on this later), you can even play with the bits of the bitmap directly. Figure 6 illustrates how OpenGL renders on a bitmap.</p>
<p>
<img src="gl6_6.gif" border=0></p>
<p class=label>
<b>Figure 6. Rendering on a bitmap</b></p>
<p>
Rendering images on a bitmap gives the programmer much better control over the display of the final image.</p>
<h2>PFD_DRAW_TO_BITMAP</h2>
<p>
OpenGL will render on anything that has a proper pixel format descriptor. (Dr. GUI is working on a pixel format descriptor to allow rendering on lattes, since he spends so much time looking at his coffee.) Setting the pixel format descriptor is always the first step. When rendering on a window, we set the pixel format descriptor for a device context (DC) associated with the window. When rendering on a bitmap, we set the pixel format descriptor for the DC containing the selected bitmap. </p>
<p>
After setting the pixel format to PFD_DRAW_TO_BITMAP, we must use the same DC for all <b>wglMakeCurrent</b> calls that we used in the <b>SetPixelFormat </b>and <b>wglCreateContext</b> calls. This differs from PFD_DRAW_TO_WINDOW, where we can use any DC associated with the window on which we are drawing. This means that we cannot "unselect" the bitmap in the DC and replace it with another bitmap. It also means that we cannot resize the bitmap without starting over and resetting the pixel format.</p>
<p>
You can use PFD_DRAW_TO_BITMAP with either PFD_TYPE_RGBA or PFD_TYPE_COLORINDEX; you cannot use it with PFD_DOUBLEBUFFER.</p>
<p>
The following code sets up a <b>PIXELFORMATDESCRIPTOR</b> structure for rendering on a bitmap:</p>
<pre><code>PIXELFORMATDESCRIPTOR pfd ;
memset(&amp;pfd,0,sizeof(PIXELFORMATDESCRIPTOR)) ;
pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR) ;
pfd.nVersion = 1 ;
pfd.dwFlags = <b>PFD_DRAW_TO_BITMAP</b> | // replaces PFD_DRAW_TO_WINDOW
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PFD_SUPPORT_OPENGL |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PFD_SUPPORT_GDI ;
pfd.iPixelType = PFD_TYPE_RGBA ; 
pfd.cColorBits = 8 ;
pfd.cDepthBits = 16 ;
pfd.iLayerType = PFD_MAIN_PLANE ; 
</code></pre>
<p>
When filling in the pixel format descriptor, you must set the <b>cColorBits</b> element to the number of bits per pixel in the bitmap. <b>ChoosePixelFormat </b>gives you the number of bits per pixel you asked for, not the number of bits per pixel for the bitmap format. (Note that the behavior of <b>ChoosePixelFormat</b> changes, depending on the pixel format descriptor flag. If you use PFD_DRAW_TO_WINDOW, <b>ChoosePixelFormat </b>returns an appropriate <b>cColorBits </b>value based on the screen resolution.)</p>
<h2>Changes to GLlib</h2>
<p>
I had to make some changes to GLlib to support rendering on bitmaps. GLlib<b> </b>doesn't contain code that is specific to DIB sections, bitmaps, or <b>CDIBSurface</b>. The only changes I made were in the <b>CGL </b>class; I left <b>CGLView </b>and <b>CGLImage </b>unchanged.</p>
<h3>CGL::Create</h3>
<p>
The main change to <b>CGL::Create</b> for bitmap-rendering support is a new function that takes a <b>CDC*</b> instead of a <b>CWnd*</b>. The new function prototype is listed below:</p>
<pre><code>BOOL Create(CDC* pdcMemory,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iPixelType = PFD_TYPE_RGBA,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwFlags&nbsp; = PFD_SUPPORT_OPENGL |&nbsp; // Use OpenGL.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PFD_SUPPORT_GDI |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PFD_DRAW_TO_BITMAP ); // Pixel format for bitmap
</code></pre>
<p>
Notice the difference in default values between the new bitmap-rendering <b>Create </b>function and the existing window-rendering <b>Create </b>function:</p>
<pre><code>BOOL Create(CWnd* pWnd, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iPixelType&nbsp; = PFD_TYPE_RGBA,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwFlags&nbsp;&nbsp; = PFD_DOUBLEBUFFER |&nbsp;&nbsp;&nbsp; // Use double buffer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PFD_SUPPORT_OPENGL |&nbsp; // Use OpenGL.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PFD_DRAW_TO_WINDOW ); // Pixel format for window
</code></pre>
<p>
The code for the new <b>Create </b>function is shown below. The important changes are in bold.</p>
<pre><code>BOOL CGL::Create(CDC* pdcMemory, int iPixelType, DWORD dwFlags)
{

<b> &nbsp; m_pdc = pdcMemory ;</b>

<b> &nbsp; CBitmap* pBitmap = m_pdc-&gt;GetCurrentBitmap() ;</b>

<b> &nbsp; BITMAP bmInfo ;</b>

<b> &nbsp; pBitmap-&gt;GetObject(sizeof(BITMAP), &amp;bmInfo) ;</b>


 &nbsp; ASSERT(bmInfo.bmPlanes == 1) ;
 &nbsp; ASSERT((bmInfo.bmBitsPixel == 8) || 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (bmInfo.bmBitsPixel == 16) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (bmInfo.bmBitsPixel == 24)) ;

 &nbsp; //
 &nbsp; // Fill in the pixel format descriptor.
 &nbsp; //
 &nbsp; PIXELFORMATDESCRIPTOR pfd ;
 &nbsp; memset(&amp;pfd,0, sizeof(PIXELFORMATDESCRIPTOR)) ;
 &nbsp; pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR); 
 &nbsp; pfd.nVersion = 1 ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Version number
 &nbsp; pfd.dwFlags =&nbsp; dwFlags ;
 &nbsp; pfd.iPixelType = iPixelType ;
 &nbsp; pfd.cColorBits = (<b>BYTE)bmInfo.bmBitsPixel</b> ;
 &nbsp; pfd.cDepthBits = 32 ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 32-bit depth buffer
 &nbsp;&nbsp; pfd.iLayerType = PFD_MAIN_PLANE ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Layer type

 &nbsp; // Let children change creation.
 &nbsp; OnCreate(NULL, &amp;pfd) ;

 &nbsp; ASSERT( (dwFlags &amp; PFD_DRAW_TO_BITMAP)) ;
 &nbsp; ASSERT( !(dwFlags &amp; PFD_DOUBLEBUFFER)) ;
 &nbsp; ASSERT( (iPixelType == PFD_TYPE_RGBA) || 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (iPixelType == PFD_TYPE_COLORINDEX)) ;

 &nbsp; // Draw onto a bitmap.

<b> &nbsp; m_bDrawToBitmap = TRUE ;</b>


 &nbsp; // Determine double buffering state.

<b> &nbsp; m_bDoubleBuffer = FALSE ;</b>


 &nbsp; // Choose the pixel format.
 &nbsp; int nPixelFormat = ChoosePixelFormat(m_pdc-&gt;m_hDC, &amp;pfd);
 &nbsp; if (nPixelFormat == 0)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; TRACE("ChoosePixelFormat Failed %d\r\n",GetLastError()) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE ;
 &nbsp; }
 &nbsp; TRACE("Pixel Format %d\r\n", nPixelFormat) ;

 &nbsp; // Set the pixel format.
 &nbsp; BOOL bResult = SetPixelFormat(m_pdc-&gt;m_hDC, nPixelFormat, &amp;pfd);
 &nbsp; if (!bResult)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; TRACE("SetPixelFormat Failed %d\r\n",GetLastError()) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE ;
 &nbsp; }

 &nbsp; // Create the palette.
 &nbsp; CreatePalette() ;

 &nbsp; //
 &nbsp; // Create a rendering context.
 &nbsp; //
 &nbsp; m_hrc = wglCreateContext(m_pdc-&gt;m_hDC);
 &nbsp; if (!m_hrc)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; TRACE("wglCreateContext Failed %x\r\n", GetLastError()) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp; }
 &nbsp; return TRUE;
}
</code></pre>
<p>
As you can see from the code above, we pass a <b>CDC </b>pointer instead of a <b>CWnd </b>pointer to the <b>Create</b> function. The DC should have selected the bitmap, DIB, or DIB section to be rendered on. The number of bits per pixel is determined by a call to <b>CDC::GetObject</b>. The Boolean <b>m_bDrawToBitmap </b>is set to TRUE. The rest of the code is unchanged.</p>
<h3>CGL::CreatePalette</h3>
<p>
I also had to change <b>CGL::CreatePalette</b> to support 16- and 24-bpp displays. Otherwise, if the display is 24 bpp and you try to render on an 8-bpp DIB, PFD_NEED_PALETTE is not set and <b>CGL::CreatePalette</b> will not create a palette.</p>
<p>
To fix this problem, I changed <b>CGL::CreatePalette</b> to create a palette if <b>m_bDrawToBitmap</b> is TRUE and the number of bits per pixel in the pixel format descriptor is 8. The code is shown below.</p>
<pre><code>.
.
.
 &nbsp; BOOL b8bppDIB = (m_bDrawToBitmap) &amp;&amp; (pfd.cColorBits == 8) ;
 &nbsp; if ( (pfd.dwFlags &amp; PFD_NEED_PALETTE) || 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (b8bppDIB) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (bColorIndex))
 &nbsp; {
.
.
.
 &nbsp; }
</code></pre>
<h3>m_bDrawToBitmap</h3>
<p>
In addition to these major changes, I made a number of small modifications to the GLlib code. Most of these changes use the Boolean <b>m_bDrawToBitmap</b>. The <b>CGL::Create</b> functions call <b>CGL::CreatePalette</b>, which normally selects a palette into the DC associated with a rendering context. We do not want to do this with DIB sections, so I changed <b>CGL::CreatePalette</b> as shown below.</p>
<pre><code>BOOL CGL::CreatePalette()
{
.
.
.
 &nbsp;&nbsp;&nbsp;&nbsp; // Select and realize palette.
 &nbsp;&nbsp;&nbsp;&nbsp; if (!m_bDrawToBitmap) // BIT 
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pOldPal = m_pdc-&gt;SelectPalette(m_pPal, 0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pdc-&gt;RealizePalette();
 &nbsp;&nbsp;&nbsp;&nbsp; }
.
.
.
}
</code></pre>
<p>
We don't own the DC given to us at creation time, so we shouldn't delete it:</p>
<pre><code>void CGL::Destroy() 
{
.
.
.
 &nbsp; if (m_pdc &amp;&amp; !m_bDrawToBitmap)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; delete m_pdc ;
 &nbsp;&nbsp;&nbsp;&nbsp; m_pdc = NULL ;
 &nbsp; }
}
</code></pre>
<p>
Those are the changes I had to make to GLlib to handle rendering on bitmaps. In some of my earlier designs, I handled the DIBs and bitmaps in the <b>CGL </b>class itself. After I used the class, it quickly became apparent that the DIB code did not belong in <b>CGL</b>. Having <b>CGL </b>depend only on a <b>CDC</b>* instead of an internal or external DIB or bitmap class makes it more useful, as the code in the next section demonstrates.</p>
<h2>DIB Sections</h2>
<p>
The EasyBit sample application works exclusively with DIB sections. A DIB section is a special version of a DIB that was introduced in Windows NT version 3.5 and is supported in Windows 95. DIB sections have two advantages over normal DIBs and bitmaps:
<ul type=disc>
<li>
You can draw on DIB sections with GDI, and you can directly modify the bits in memory. This differs from device dependent bitmaps (on which only GDI can draw), and DIBs (which don't support GDI but which you can modify directly).<br><br></li>
<li>
DIB sections (especially large DIBs) can be blted to the screen faster than normal DIBs and bitmaps.</li>
</ul>
<p>
For more information on DIB sections, see Nigel Thompson's book <i>Animation Techniques for Win32</i> (available from Microsoft Press®) and latest animation articles.</p>
<h3>CDIBSurface</h3>
<p>
Speaking of Nigel, I rendered OpenGL scenes on his <b>CDIBSurface</b> class. <b>CDIBSurface</b> encapsulates both a DIB section and a DC within one object that is easy to manipulate. The scene in the upper-left corner of the client area in Figure 1 is a <b>CScene </b>object rendered on a <b>CDIBSurface </b>object.</p>
<p>
I used the following <b>CDIBSurface</b> commands:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Command</b></td>
<td class=label width=79%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=21%><b>Create</b></td>
<td width=79%>Creates a <b>CDIBSurface</b> object. You can specify the size and a palette. </td>
</tr>
<tr valign=top>
<td width=21%><b>GetDC</b></td>
<td width=79%>Gets the DC attached to the <b>CDIBSurface</b>.</td>
</tr>
<tr valign=top>
<td width=21%><b>SetPalette</b></td>
<td width=79%>Sets the palette for the DIB section.</td>
</tr>
<tr valign=top>
<td width=21%><b>BitBlt</b></td>
<td width=79%>Blts the DIB section to the screen. Make sure that you are using the latest version of the animation library; some early versions of <b>CDIBSurface</b> selected the palette into the destination DC before blting. </td>
</tr>
<tr valign=top>
<td width=21%><b>Draw</b></td>
<td width=79%>Draws the <b>CDIBSurface</b> object by calling <b>BitBlt</b>.</td>
</tr>
</table><br>
<p>
See Nigel's technical articles<a href="msdn_custctl.htm"> "Simple Custom Controls for 32-Bit Visual C++ Applications"</a> and <a href="msdn_markpnt.htm">"Creating Programs Without a Standard Windows User Interface Using Visual C++ and MFC"</a> in the MSDN Library for more information.</p>
<p>
To render on a <b>CDIBSurface </b>object, you must first create the object. The code below, taken from <b>CSceneView::OnSize</b>, creates a <b>CDIBSurface </b>object with no palette. The <b>sizeBitmap</b> parameter contains the size of the <b>CDIBSurface</b> object. The last parameter is a pointer to a <b>CPalette </b>object. I don't have a palette built yet, so I pass in a NULL.</p>
<pre><code>&nbsp;&nbsp;&nbsp;CDIBSurface aDIBSurface ;
 &nbsp; aDIBSurface.Create(sizeBitmap.cx, sizeBitmap.cy, NULL) ;
</code></pre>
<p>
I need the DC to create the OpenGL rendering context, so I get the DC for the <b>CDIBSurface</b> object:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CDC* pdcTemp = aDIBSurface.GetDC() ;
</code></pre>
<p>
I pass the DC to the <b>CScene</b> object's <b>Create </b>function. <b>CScene </b>inherits from <b>CGL</b>, which is contained in GLlib. <b>CGL </b>has two <b>Create </b>functions, one of which takes a pointer to a <b>CDC </b>object. This is the <b>Create </b>function you should use when you want to render on a bitmap:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CScene aSceneOnDIB ;
 &nbsp; aSceneOnDIB.Create(pdcTemp) ;
</code></pre>
<p>
When I created the <b>CDIBSurface </b>object, I didn't specify a palette because the palette hadn't been constructed yet. I need a DC before I can create <b>CScene</b>, which creates the palette. Therefore, I get a pointer to the palette used in <b>aSceneOnDib</b> to set the palette in the <b>aDIBSurface</b>.</p>
<pre><code>&nbsp;&nbsp;&nbsp;CPalette* pPalTemp = aSceneOnDIB.GetPalette() ;
 &nbsp; if (pPalTemp) aDIBSurface.SetPalette(pPalTemp) ;
</code></pre>
<p>
<b>CDIBSurface::SetPalette </b>does not copy the palette that <b>pPalTemp</b> points to, so you should keep the palette around for the life of <b>aDIBSurface</b>. This is not a requirement of a DIB section, but of the <b>CDIBSurface </b>class. Later, we will look at <b>CSimpleDIB::SetPalette</b> to see how <b>CDIBSurface::SetPalette</b> works.</p>
<p>
Now we can actually do the rendering:</p>
<pre><code>&nbsp;&nbsp;&nbsp;aSceneOnDIB.Resize(sizeBitmap.cx, sizeBitmap.cy) ; //Doesn't resize?!!!!
 &nbsp; aSceneOnDIB.Init() ;
 &nbsp; aSceneOnDIB.Render() ;
</code></pre>
<p>
The code above calls the <b>CScene::Resize</b>, <b>CScene::Init</b>, and <b>CScene::Render</b> functions, which are discussed in the <a href="msdn_gl3.htm">"OpenGL III: Building an OpenGL C++ Class"</a> article in the MSDN Library.</p>
<p>
<b>CScene:Resize</b> does not resize the <b>CDIBSurface</b> object; it only sets up the projection matrices for transforming a 3-D object onto the 2-D screen.</p>
<p>
Finally, we draw a blue border around the bitmap using GDI commands with the <b>CSceneView::DrawBlueBorder</b> helper function:</p>
<pre><code>&nbsp;&nbsp;&nbsp;DrawBlueBorder(pdcTemp) ;
</code></pre>
<p>
At this point, I could delete the <b>CScene </b>object, <b>aSceneOnDIB</b>, except that <b>aDIBSurface</b> contains a pointer to the palette in <b>aSceneOnDIB</b>. There are several methods you could use to delete <b>aSceneOnDIB</b>. The simplest is to make a copy of the palette object in <b>aSceneOnDIB</b> and pass the pointer to the copy to <b>aDIBSurface</b>. You could then delete <b>aSceneOnDIB </b>and keep the palette object.</p>
<p>
In the EasyBit sample application, there is another way around the problem. The main client area of the window is painted using a <b>CScene </b>object, <b>m_aScene</b>, which has the same palette as the <b>aSceneOnDIB</b> object. Therefore, we could simply use the palette from <b>m_aScene</b>. If you have a 16- or 24-bpp display, <b>m_aScene</b> won't have a palette, but you won't need one when drawing an 8-bpp DIB to a 16- or 24-bpp display.</p>
<h4>CDIBSurface internals</h4>
<p>
So far, I've kept this discussion at a fairly high level; I haven't gone into the details of how the <b>CDIBSurface </b>class actually works. Refer to Nigel's book, his technical article <a href="msdn_markpnt.htm">"Creating Programs Without a Standard Windows User Interface Using Visual C++ and MFC,"</a> and the <b>CDIBSurface</b> source code for more information on the internals of <b>CDIBSurface</b>.</p>
<p>
However, I won't leave you up a creek without a paddle, so I will explain the internals of <b>CDIBSurface </b>indirectly. Instead of looking at <b>CDIBSurface</b> internals, I will examine the internals of an equivalent class, <b>CSimpleDIB</b>, which is a minimal encapsulation of a DIB section and DC. For our purposes in this article, <b>CSimpleDIB </b>is equivalent to <b>CDIBSurface</b> but it is much simpler to understand. The next two sections discuss <b>CSimpleDIB</b>.</p>
<h3>CSimpleDIB</h3>
<p>
When I started writing this article, my intention was to use Nigel's <b>CDIBSurface</b> class. However, in the process of trying to use <b>CDIBSurface</b>, I encountered problems that I couldn't debug. The code started to get very confusing: <b>CDIBSurface </b>inherits from <b>CDIB</b> and the creation code builds on top of a <b>CDIB </b>object, and it becomes very difficult to see who is controlling what. There is also a lot of WinG-dependent code in <b>CDIBSurface</b>, which only adds to the confusion. I needed to generate 16- and 24-bpp DIB sections in addition to the 8-bpp DIB sections that <b>CDIBSurface</b> creates. I just didn't have the time to add this support to <b>CDIBSurface</b> while ensuring that other <b>CDIBSurface</b> features were not affected.</p>
<p>
I thought it would much easier to work with a simpler class first, and then figure out what I needed to do to make the code work with <b>CDIBSurface</b>. I decided that if I found it difficult to understand the internals of <b>CDIBSurface</b>, so would other developers. For these reasons, I decided to write <b>CSimpleDIB</b>.</p>
<h4>Using CSimpleDIB</h4>
<p>
The code below, taken from <b>CSceneView::OnSize</b>, provides an example of how to use <b>CSimpleDIB</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CSimpleDIB m_theSimpleDIB;
 &nbsp; m_theSimpleDIB.Create(m_sizeBitmap.cx, m_sizeBitmap.cy, 8) ;
 &nbsp; CDC* pdcTemp = m_theSimpleDIB.GetDC() ;

 &nbsp; CSceneDodec aSceneDodec;
 &nbsp; aSceneDodec.Create(pdcTemp) ;

 &nbsp; CPalette* pPalTemp = aSceneDodec.GetPalette() ;
 &nbsp; if (pPalTemp) m_theSimpleDIB.SetPalette(pPalTemp) ;

 &nbsp; aSceneDodec.Resize(m_sizeBitmap.cx, m_sizeBitmap.cy) ;
 &nbsp; aSceneDodec.Init() ;
 &nbsp; aSceneDodec.Render() ;

 &nbsp; DrawBlueBorder(pdcTemp) ;
 &nbsp; DrawCaption(pdcTemp, _T("8 bpp")) ;
</code></pre>
<p>
As you can see, <b>CSimpleDIB</b> is used in basically the same way as <b>CDIBSurface</b>. The only difference is the call to <b>CSimpleDIB::Create</b> in the code above. The last parameter to <b>CSimpleDIB::Create</b> specifies the number of bits per pixel for the DIB section, whereas <b>CDIBSurface::Create</b> provides a pointer to a palette. <b>CSimpleDIB</b> supports 8-, 16-, and 24-bpp DIB sections. In the example above, I created an 8-bpp DIB section. The following code creates a 24-bpp DIB section:</p>
<pre><code>&nbsp;&nbsp;&nbsp;m_theSimpleDIB.Create(m_sizeBitmap.cx, m_sizeBitmap.cy, 24) ;
 &nbsp; CDC* pdcTemp = m_theSimpleDIB.GetDC() ;

 &nbsp; CScenePyramid aScenePyramid ;
 &nbsp; aScenePyramid.Create(pdcTemp) ;

 &nbsp; aScenePyramid.Resize(m_sizeBitmap.cx, m_sizeBitmap.cy) ;
 &nbsp; aScenePyramid.Init() ;
 &nbsp; aScenePyramid.Render() ;

 &nbsp; DrawBlueBorder(pdcTemp) ;
 &nbsp; DrawCaption(pdcTemp, _T("24 bpp")) ;
</code></pre>
<p>
Careful readers will have noticed that the following two lines:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CPalette* pPalTemp = aScenePyramid.GetPalette() ;
 &nbsp; if (pPalTemp) m_theSimpleDIB.SetPalette(pPalTemp) ;
</code></pre>
<p>
are missing from the example above. <b>aScenePyramid</b> is attached to a 24-bpp DIB; therefore, it does not have a palette, so <b>pPalTemp </b>will always be NULL.</p>
<h4>CSimpleDIB internals</h4>
<p>
<b>CSimpleDIB </b>is a bare-bones class that encapsulates both <b>CreateDIBSection</b> and a <b>CDC </b>object.</p>
<pre><code>class CSimpleDIB
{
.
.
.
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; CSimpleDIB() ;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual ~CSimpleDIB() ;

 &nbsp;&nbsp;&nbsp;&nbsp; void Create(int cx, int cy, int ibitcount ) ;
 &nbsp;&nbsp;&nbsp;&nbsp; void Draw(CDC* pdcDest, int x, int y) ;
 &nbsp;&nbsp;&nbsp;&nbsp; void SetPalette(CPalette* pPal) ;
 &nbsp;&nbsp;&nbsp;&nbsp; CDC* GetDC() {return m_pdc;}
.
.
.
} ;
</code></pre>
<p>
As the header file above shows, <b>CSimpleDIB</b> is simple. It does not inherit from a base class, so there's nothing to learn except what's already in the code above. I tried to make the interface to <b>CSimpleDIB </b>similar to <b>CDIBSection </b>to keep down the confusion level.</p>
<p>
To create a <b>CSimpleDIB</b> object, you simply call <b>Create </b>with the desired size and number of bits per pixel for the DIB section.</p>
<pre><code>void CSimpleDIB::Create(int cx, int cy, int ibitcount) 
{
 &nbsp; ASSERT((ibitcount == 8) || (ibitcount == 16) || (ibitcount = 24)) ;
 &nbsp; ASSERT(cx &gt; 0);
 &nbsp; ASSERT(cy &gt; 0);

 &nbsp; // Destroy parts of objects if we are recreating it.
 &nbsp; if ((m_pdc != NULL) || (m_hbmp != NULL)) destroy() ;

 &nbsp; // Save size for drawing later.
 &nbsp; m_sizeDIB.cx = cx ;
 &nbsp; m_sizeDIB.cy = cy ;

 &nbsp; // Create a BITMAPINFOHEADER structure to describe the DIB.
 &nbsp; BITMAPINFOHEADER BIH ;
 &nbsp; int iSize = sizeof(BITMAPINFOHEADER) ;
 &nbsp; memset(&amp;BIH, 0, iSize);

 &nbsp; // Fill in the header info. 
 &nbsp; BIH.biSize = iSize;
 &nbsp; BIH.biWidth = cx;
 &nbsp; BIH.biHeight = cy;
 &nbsp; BIH.biPlanes = 1;
 &nbsp; BIH.biBitCount = ibitcount;
 &nbsp; BIH.biCompression = BI_RGB;

 &nbsp; // Create a new device context.
 &nbsp; m_pdc = new CDC ;
 &nbsp; m_pdc-&gt;CreateCompatibleDC(NULL);

 &nbsp; // Create the DIB section.
 &nbsp; m_hbmp = CreateDIBSection(m_pdc-&gt;GetSafeHdc(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (BITMAPINFO*) &amp;BIH,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIB_PAL_COLORS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;m_pBits,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);

 &nbsp;&nbsp; ASSERT(m_hbmp);
 &nbsp;&nbsp; ASSERT(m_pBits);

 &nbsp;&nbsp; // Select the new bitmap into the buffer DC.
 &nbsp;&nbsp; if (m_hbmp)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_hbmOld = (HBITMAP)::SelectObject(m_pdc-&gt;GetSafeHdc(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_hbmp);
 &nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; 
}
</code></pre>
<p>
Calling <b>CreateDIBSection </b>is as simple as filling out a <b>BITMAPINFO</b> structure, which consists of a <b>BITMAPINFOHEADER</b> structure with color information. Because I don't have a palette when I create the DIB section, I don't need the color information, so I simply use a <b>BITMAPINFOHEADER</b> structure. I create a DC because <b>CreateDIBSection</b> requires one as a parameter. When the new DIB section is created, it is selected into the DC.</p>
<p>
To display the <b>CSimpleDIB</b> on the screen, call <b>CSimpleDIB::Draw</b>, which simply encapsulates a call to <b>CDC::BitBlt</b>.</p>
<pre><code>void CSimpleDIB::Draw(CDC* pdcDest, int x, int y) 
{
 &nbsp; pdcDest-&gt;BitBlt(x, y,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_sizeDIB.cx, m_sizeDIB.cy,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pdc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SRCCOPY);

}
</code></pre>
<p>
If the destination DC, <b>pdcDest</b>, has 8 bpp, you'll need to select and realize a palette before calling <b>CSimpleDIB::Draw</b>.</p>
<p>
Speaking of palettes. . . If you are creating an 8-bpp <b>CSimpleDIB</b> object, you will need to set the palette. Otherwise, when you attempt to draw the object, you'll get a black square. To set the palette, use <b>CSimpleDIB::SetPalette</b>.</p>
<pre><code>void CSimpleDIB::SetPalette(CPalette* pPal)
{
 &nbsp;&nbsp; ASSERT(pPal);

 &nbsp;&nbsp; // Get the colors from the palette.
 &nbsp;&nbsp; int iColors = 0;
 &nbsp;&nbsp; pPal-&gt;GetObject(sizeof(iColors), &amp;iColors);
 &nbsp;&nbsp; ASSERT(iColors &gt; 0);
 &nbsp;&nbsp; PALETTEENTRY* pPE = new PALETTEENTRY[iColors];
 &nbsp;&nbsp; pPal-&gt;GetPaletteEntries(0, iColors, pPE);

 &nbsp;&nbsp; // Build a table of RGBQUADS.
 &nbsp;&nbsp; RGBQUAD* pRGB = new RGBQUAD[iColors];
 &nbsp;&nbsp; ASSERT(pRGB);
 &nbsp;&nbsp; for (int i = 0; i &lt; iColors; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pRGB[i].rgbRed = pPE[i].peRed;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pRGB[i].rgbGreen = pPE[i].peGreen;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pRGB[i].rgbBlue = pPE[i].peBlue;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pRGB[i].rgbReserved = 0;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ::SetDIBColorTable(m_pdc-&gt;GetSafeHdc(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, iColors,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pRGB);

 &nbsp;&nbsp; delete [] pRGB;
 &nbsp;&nbsp; delete [] pPE;
}
</code></pre>
<p>
<b>SetPalette </b>encapsulates a call to the GDI function <b>::SetDIBColorTable</b>. This function sets up an internal color table to map the colors in the DIB to equivalent RGB functions. This color table is not a Windows palette object.</p>
<p>
<b>SetPalette </b>builds an array of RGBQUADs from the colors in the palette parameter. The array of RGBQUADs is passed to <b>::SetDIBColorTable</b>.</p>
<p>
That's all there is to <b>CSimpleDIB </b>and <b>CreateDIBSection</b>. You can use <b>CDIBSurface</b> or <b>CSimpleDIB</b>, or you can create your own class.</p>
<h2>Pixel Format Choices</h2>
<p>
Rendering on DIBs instead of the window gives us a new choice: We can pick the number of bits per pixel we use for our DIB sections. However, we can't pick the number of bits per pixel for the display. How do you determine which format to use for your DIBs? Figure 7 shows the possible combinations.</p>
<p>
<img src="gl6_7.gif" border=0></p>
<p class=label>
<b>Figure 7. Possible combinations of DIB and display bit formats</b></p>
<p>
The answer depends on what you are doing with the DIBs. If you want small size, use 8-bpp DIBs. If you want fast blt performance, you should test each technique on your system and see which provides the best performance. The Blting command in the EasyBit Time menu displays the time it takes to blt 30 8-, 16-, and 24-bpp DIBs to the screen. On my system, the 16-bpp DIBs are significantly slower to blt than the 8- and 24-bpp DIBs. The following table shows the results of running the Time Blting command on my system. </p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=45%><b><br>
</b></td>
<td class=label width=19%><b>8-bpp display</b></td>
<td class=label width=18%><b>16-bpp display</b></td>
<td class=label width=18%><b>24-bpp display</b></td>
</tr>
<tr valign=top>
<td width=45%><b>CDIBSurface</b></td>
<td width=19%>62</td>
<td width=18%>66</td>
<td width=18%>137</td>
</tr>
<tr valign=top>
<td width=45%><b>CSimpleDIB</b> (8-bpp)</td>
<td width=19%>45</td>
<td width=18%>64</td>
<td width=18%>125</td>
</tr>
<tr valign=top>
<td width=45%><b>CSimpleDIB</b> (16-bpp)</td>
<td width=19%>9909</td>
<td width=18%>891</td>
<td width=18%>843</td>
</tr>
<tr valign=top>
<td width=45%><b>CSimpleDIB</b> (24-bpp)</td>
<td width=19%>140</td>
<td width=18%>670</td>
<td width=18%>44</td>
</tr>
<tr valign=top>
<td width=45%><b>CSimpleDIB</b> (Identity)</td>
<td width=19%>46</td>
<td width=18%>60</td>
<td width=18%>143</td>
</tr>
</table><br>
<p>
Blt performance is affected by many factors, including the size of the DIB and the number of colors used in the DIB. Refer to Nigel's book or the <i>WinG Programmer's Reference</i> (in the Development Library, see Product Documentation, SDKs) for more information on blting performance.</p>
<p>
A good compromise is to use the same number of bits per pixel for the DIB and the screen. This approach simplifies the code significantly, but there is a performance penalty on 16-bpp displays. For <b>CMyStatusBar</b> and <b>CShapeMenu</b>, I used 8-bpp DIBs except in 24-bpp display mode. </p>
<p>
If you manipulate the memory in the DIB section directly, you might not want to use different pixel formats, because you'll have to write different code to manipulate the formats. If the application I'm writing modifies the pixel values directly, I prefer to support a single pixel format. I usually choose either 24-bpp or 8-bpp, because these formats are the easiest to work with.</p>
<h2>A Few Choice Words About Palettes</h2>
<p>
Palettes have complicated this discussion. The general rule is that objects that have an 8-bpp format need a palette or some kind of color information. Objects that have 16-bpp or 24-bpp formats do not need palettes.</p>
<p>
A DIB section is not a palettized device. DIB sections do not use palettes, but they do have a color table. The color table can be initialized in three ways:
<ul type=disc>
<li>
With colors in the <b>BITMAPINFO</b> structure during creation<br><br></li>
<li>
From the palette selected into the device context passed to <b>CreateDIBSection</b><br><br></li>
<li>
With <b>::SetDIBColorTable</b></li>
</ul>
<p>
Only 8-bpp DIBs have color tables—24- and 16-bpp DIBs do not. If an-8 bpp DIB does not have the color table initialized, the DIB section will be a black rectangle when it is blted to the screen.</p>
<p>
Let's look at three cases:
<ul type=disc>
<li>
Blting an 8-bpp DIB section to an 8-bpp display<br><br></li>
<li>
Blting an 8-bpp DIB section to a 24-bpp display<br><br></li>
<li>
Blting a 24-bpp DIB section to an 8-bpp display</li>
</ul>
<p>
In the first case, we have an 8-bpp DIB section, which we will blt to an 8-bpp display. Because the DIB section is 8 bpp, the color table needs to be initialized. Regardless of whether we're using <b>CDIBSurface </b>or <b>CSimpleDIB</b>, we use the <b>SetPalette </b>function, which calls <b>::SetDIBColorTable</b>. The display is also 8 bpp, so we need to select and realize a palette before we can display the DIB section, as shown in Figure 8.</p>
<p>
<img src="gl6_8.gif" border=0></p>
<p class=label>
<b>Figure 8. Palette use with 8-bpp DIB section and display</b></p>
<p>
The palettes should be the same if you created the DIB using DIB_PAL_COLORS in the <b>CreateDIBSection</b> call. If you used DIB_RGB_COLORS instead, GDI will map colors from the color table to the currently selected palette. This is slow and can result in really ugly displays, depending on the palettes. It's best to keep the number of palettes used by your application to a minimum. Using zero palettes is the easiest, but doesn't result in very colorful displays. Therefore, the best approach is to have one palette in your application.</p>
<p>
The next case we'll examine is an 8-bpp DIB section and a 24-bpp display. Because the DIB section is 8 bpp, we need to initialize the color table in the DIB section. However, a 24-bpp display does not need a palette to display colors, so we do not need to select and realize a palette when displaying the 8-bpp DIB section on the screen, as illustrated in Figure 9.</p>
<p>
<img src="gl6_9.gif" border=0></p>
<p class=label>
<b>Figure 9. Palette use with 8-bpp DIB section and 24-bpp display</b></p>
<p>
The last case we'll look at is a 24-bpp DIB section and an 8-bpp display. We don't have to set the color table because a 24-bpp DIB does not need one. An 8-bpp display needs a palette to show more than 20 colors. Therefore, we must select and realize a palette before we can display our DIB section. This process is illustrated in Figure 10.</p>
<p>
<img src="gl6_10.gif" border=0></p>
<p class=label>
<b>Figure 10. Palette use with 24-bpp DIB section and 8-bpp display</b></p>
<p>
However, this method poses one problem: Where do you get the palette from? The <b>CGL</b> class has been building all of our palettes for us, but <b>CGL</b> does not create a palette when it creates a rendering context for a 24-bpp DIB. This means that it is the application's responsibility to create a palette. <b>CGL </b>could be extended to generate a 3-3-2 palette on demand, just for this case. Because GDI will map the DIB section to the current palette when it is blting, the palette does not have to be a 3-3-2 palette, as discussed in the <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode"</a> article in the MSDN Library.</p>
<h2>Identity Palettes</h2>
<p>
If you have read Nigel Thompson's book <i>Animation Techniques for Win32</i>, you know that an identity palette is one of the keys to fast blt performance. An identity palette is a logical palette that is identical to the system palette. A logical palette is the palette you select into the DC. If you use a non-identity palette, GDI must get a color from the logical palette and then look for this color in the system palette. If you use an identity palette, GDI can simply use the logical palette indexes without any translation. In theory, bypassing the translation step may result in much better performance, as illustrated in Figures 11 and 12.</p>
<p>
<img src="gl6_11.gif" border=0></p>
<p class=label>
<b>Figure 11. Non-identity logical palettes use translation tables.</b></p>
<p>
<img src="gl6_12.gif" border=0></p>
<p class=label>
<b>Figure 12. Identity palettes are identical to system palettes.</b></p>
<p>
In the second article in this series, <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode,"</a> I explained why you could not have an identity palette when using RGBA color mode. The system palette has 10 system colors in the first 10 entries and 10 system colors in the last 10 entries. Because the identity palette is identical to the system palette, it must have the same arrangement of system colors. The standard 3-3-2 color palette used by OpenGL applications on Windows NT have the 20 system colors spread throughout the palette. </p>
<p>
Although we can't use RGBA mode to get an identity palette, we can use color index mode. In color index mode, we specify each color by its palette index instead of using its RGB value. In RGBA mode, we can't pick the palette; in color index mode, we can. For more information on color index mode, see my <a href="msdn_gl4.htm">"OpenGL IV: Color Index Mode"</a> article in the MSDN Library.</p>
<p>
To make an identity palette using color index mode, you must construct the palette so that the first 10 and last 10 entries are available for the system colors. The other 236 colors are left up to you. </p>
<p>
The <b>CSceneView::TimeIdentity</b> function creates an identity palette that you can use with a <b>CDIBSurface </b>object. I use Nigel's <b>CDIBPal </b>class for its <b>SetSysPalColors </b>function, which creates an identity palette. The code in this section is taken from the <b>TimeIdentity</b> function.</p>
<p>
The first step is to create a <b>CDIBSurface</b> object and render on it with OpenGL. This process is the same as we discussed previously in the section on <b>CDIBSurface</b>; the only difference is that we use <b>CSceneCI</b> instead of <b>CScene</b>. <b>CSceneCI </b>is a color index version of <b>CScene</b> and is discussed in the <a href="msdn_gl4.htm">"OpenGL IV: Color Index Mode"</a> article in the MSDN Library.</p>
<pre><code>&nbsp;&nbsp;&nbsp;CClientDC dc(this) ;
 &nbsp; CDC* pDC = &amp;dc ;

 &nbsp; CDIBSurface aDIBSurfaceIdent ;
 &nbsp; aDIBSurfaceIdent.Create(m_sizeBitmap.cx, m_sizeBitmap.cy, NULL) ;
 &nbsp; CDC* pdcTemp = aDIBSurfaceIdent.GetDC() ;

 &nbsp; CSceneCI aSceneCI ;&nbsp;&nbsp; // Use color index mode.
 &nbsp; aSceneCI.Create(pdcTemp) ;

 &nbsp; CPalette* pPalTemp = aSceneCI.GetPalette() ;
 &nbsp; if (pPalTemp)&nbsp; aDIBSurfaceIdent.SetPalette(pPalTemp) ;

 &nbsp; aSceneCI.Resize(m_sizeBitmap.cx, m_sizeBitmap.cy) ; //Doesn't resize?!!!!
 &nbsp; aSceneCI.Init() ;
 &nbsp; aSceneCI.Render() ;
</code></pre>
<p>
Because I am going to use Nigel's <b>CDIBPal</b> class, I must get the palette that <b>CSceneCI</b> creates into a form that <b>CDIBPal</b> can use. <b>CDIBPal </b>requires a <b>LOGPALETTE</b> pointer at creation. Notice the use of the PC_NOCOLLAPSE flag below; this is to ensure that we get all 236 colors in our palette, even if they repeat.</p>
<pre><code>&nbsp;&nbsp;&nbsp;int iColors = 0;
 &nbsp; pPalTemp-&gt;GetObject(sizeof(iColors), &amp;iColors) ;
 &nbsp; int iSysColors = pDC-&gt;GetDeviceCaps(NUMCOLORS);

 &nbsp; LOGPALETTE *pPal = (LOGPALETTE *) malloc(sizeof(LOGPALETTE) + 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iColors *sizeof(PALETTEENTRY));
 &nbsp; PALETTEENTRY* pe = pPal-&gt;palPalEntry ;
 &nbsp; pPal-&gt;palVersion = 0x300;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Windows 3.0
 &nbsp; pPal-&gt;palNumEntries = (WORD) iColors;&nbsp; // table size
 &nbsp; pPalTemp-&gt;GetPaletteEntries(0,iColors, pe) ;
 &nbsp; int i ;
 &nbsp; for (i = 0; i &lt; iSysColors/2; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp; pe[i].peFlags = 0;
 &nbsp; }
 &nbsp; for (; i &lt; iColors-iSysColors/2; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp; pe[i].peFlags = PC_NOCOLLAPSE;
 &nbsp; }
 &nbsp; for (; i &lt; iColors; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp; pe[i].peFlags = 0;
 &nbsp; }
</code></pre>
<p>
We use the <b>LOGPALETTE</b> structure created in the code above to create a <b>CDIBPal </b>object, and we call <b>SetSysPalColors</b> to create the identity palette. We can now draw the object with an identity palette.</p>
<pre><code>&nbsp;&nbsp;&nbsp;CDIBPal aIdentPal ;
 &nbsp; BOOL bResult = aIdentPal.CreatePalette(pPal);
 &nbsp; free (pPal);
 &nbsp; aIdentPal.SetSysPalColors() ;

 &nbsp; aDIBSurfaceIdent.Draw(pDC) ;
</code></pre>
<p>
To look at the palette, you can use the following function:</p>
<pre><code>&nbsp;&nbsp;&nbsp;aIdentPal.Draw(pDC,&amp;CRect(100,0,400,300));
</code></pre>
<p>
For debugging purposes, I wrote the following <b>IsIdentityPal</b> function in <b>CSceneView</b> to confirm that I really had a system palette:</p>
<pre><code>BOOL CSceneView::IsIdentityPal(CDC* pDC)
{
 &nbsp; int iColors = 0 ;
 &nbsp; PALETTEENTRY peCurrent[256];
 &nbsp; PALETTEENTRY peSystem[256] ;

 &nbsp; // Current logical palette
 &nbsp; CPalette* pCurrentPal = pDC-&gt;GetCurrentPalette() ;
 &nbsp; pCurrentPal-&gt;GetObject(sizeof(iColors), &amp;iColors);
 &nbsp; pCurrentPal-&gt;GetPaletteEntries(0, iColors, peCurrent);

 &nbsp; // System Palette
 &nbsp; int iPalEntries = pDC-&gt;GetDeviceCaps(SIZEPALETTE);
 &nbsp; ::GetSystemPaletteEntries( pDC-&gt;GetSafeHdc(), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iPalEntries,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; peSystem);

 &nbsp; int iNum = min(iColors, iPalEntries) ;
 &nbsp; for (int i = 0; i &lt; iColors; I++)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (peCurrent[i].peRed != peSystem[i].peRed) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (peCurrent[i].peGreen != peSystem[i].peGreen) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (peCurrent[i].peBlue != peSystem[i].peBlue)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE ;
 &nbsp; }
 &nbsp; 
 &nbsp; return TRUE ;
}
</code></pre>
<p>
<b>IsIdentityPalette </b>gets the colors for the logical palette and the system palette, and compares them. Make sure that you have your logical palette selected and realized in the DC before calling <b>IsIdentityPalette</b>.</p>
<p>
Nigel assures me that identity palettes really speed things up. My timing tests showed that identity palettes were faster than non-identity palettes, but not significantly, perhaps because the images that I was blting in the test cases did not contain many colors. GDI may be caching the colors it looks up, resulting in increased performance for the non-identity palette cases.</p>
<h2>Getting It Right</h2>
<p>
It's easy to make mistakes when rendering on a bitmap. This section provides a checklist of guidelines you can follow.
<ul type=disc>
<li>
When you use PFD_DRAW_TO_BITMAP, the DC passed to <b>SetPixelFormat</b> and <b>wglCreateContext </b>must be the same DC for all <b>wglMakeCurrent</b> calls. The rendering context is tied to the DC. When you use PFD_DRAW_TO_WINDOW, the rendering context is tied to the window, and any DC obtained from the window can be used in the "wiggle" functions.<br><br></li>
<li>
You must select the bitmap into the DC before calling <b>SetPixelFormat</b>.<br><br></li>
<li>
The DC must remain valid; you can't delete the DC and create a new one.<br><br></li>
<li>
The DIB section can't be resized. To resize a DIB, you must create a new DIB section and rendering context from scratch. If you want to paint the client area of a window with a DIB section that you are rendering with OpenGL, you must recreate the DIB section and rendering context. Another solution is to pick a DIB section as big as you will ever need, then use only the part that you need. However, this approach could waste a lot of memory.<br><br></li>
<li>
<b>ChoosePixelFormat</b> and <b>SetPixelFormat</b> require the correct number of bits per pixel. These functions will not examine a DIB section to determine the appropriate pixel format. You must pass the same number of bits per pixel to <b>SetPixelFormat</b> as you do to <b>::CreateDIBSection</b>.<br><br></li>
<li>
Don't select a palette into the DC for the DIB section. A DIB section uses a color table. Selecting a palette into the DC of the DIB section results in incorrect output.<br><br></li>
<li>
If the DIB section is 8 bpp, initialize its color table. Objects that have 8-bpp pixel formats require color information. Use <b>::SetDIBColorTable</b>, <b>CSimpleDIB::SetPalette</b>, or <b>CDIBSurface::SetPalette</b>.<br><br></li>
<li>
If the display is 8 bpp, select and realize a palette. To display an 8-bpp, 16-bpp, or 24-bpp DIB section on an 8-bpp device correctly, you must select and realize a palette first.<br><br></li>
<li>
Remember that <b>CDIBSurface::BltBit </b>and <b>CDIBSurface::Draw </b>select and realize the palette. This can lead to unexpected results if you don't keep it in mind.<br><br></li>
<li>
Remember that PFD_NEED_PALETTE is not set for displays that are not 8 bpp, even if PFD_DRAW_TO_BITMAP is set and the destination rendering surface is an 8-bpp DIB section.</li>
</ul>
<h2>Conclusion</h2>
<p>
Rendering OpenGL scenes on a DIB section gets OpenGL out of the client area and into menus and status bars. Once you have rendered an OpenGL scene on a DIB section, you can use any GDI function you desire to manipulate that DIB section. This includes blting the DIB section to the screen, as well as drawing and printing text on the bitmap.</p>
<p>
You can use bitmaps almost anywhere, so OpenGL-rendered bitmaps can easily appear in menus, status bars, button bars, and anywhere else you might want to use them.</p>
<h2>Bibliography</h2>
<p>
Rogerson, Dale. <a href="msdn_status.htm">"Bitmaps and Other CStatusBar Customizations."</a> April 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_selfdraw.htm">"MFC Self-Drawing Menus."</a> April 1995. (MSDN Library, Technical Articles)</p>
<h3>Sources of Information on OpenGL</h3>
<p>
Crain, Dennis. <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started."</a> April 1994. (MSDN Library, Technical Articles)</p>
<p>
Neider, Jackie, Tom Davis, and Mason Woo. <i>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1993. ISBN 0-201-63274-8. (This book is also known as the "Red Book".)</p>
<p>
OpenGL Architecture Review Board. <i>OpenGL Reference Manual: The Official Reference Document for OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1992. ISBN 0-201-63276-4. (This book is also known as the "Blue Book".)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: Introducing the OpenGL Interface, Part I." <i>Microsoft Systems Journal</i> 9 (October 1994). (MSDN Library Archive Edition, Library, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: The OpenGL Interface, Part II." <i>Microsoft Systems Journal</i> 9 (November 1994). (MSDN Library Archive Edition, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Understanding Modelview Transformations in OpenGL for Windows NT." <i>Microsoft Systems Journal</i> 10 (February 1995).</p>
<p>
Rogerson, Dale. <a href="msdn_gl1.htm">"OpenGL I: Quick Start."</a> December 1994. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode."</a> December 1994. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl3.htm">"OpenGL III: Building an OpenGL C++ Class."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl4.htm">"OpenGL IV: Color Index Mode."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl5.htm">"OpenGL V: Translating Windows DIBs."</a> February 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl7.htm">"OpenGL VII: Scratching the Surface of Texture Mapping."</a> May 1995. (MSDN Library, Technical Articles)</p>
<p>
Microsoft Win32 Software Development Kit (SDK) for Windows NT 3.5 <i>OpenGL Programmer's Reference</i>.</p>
<h3>Sources of Information on DIBs</h3>
<p>
Gery, Ron. <a href="msdn_dibs2.htm">"DIBs and Their Use."</a>. March 1992. (MSDN Library, Technical Articles) </p>
<p>
Gery, Ron. <a href="msdn_dibpal.htm">"Using DIBs with Palettes."</a> March 1992. (MSDN Library, Technical Articles)</p>
<p>
Microsoft Win32 Software Development Kit (SDK) for Windows NT 3.5 <i>Video for Windows</i> </p>
<p>
Rodent, Herman. "16- and 32-Bit-Per-Pixel DIB Formats for Windows: The Color of Things to Come." January 1993. (MSDN Library Archive, Technical Articles)</p>
<p>
Thompson, Nigel. <i>Animation Techniques for Win32</i>. Redmond, WA: Microsoft Press, 1995. (MSDN Library, Books and Periodicals)</p>
<p>
Thompson, Nigel. <a href="msdn_markpnt.htm">"Creating Programs Without a Standard Windows User Interface Using Visual C++ and MFC."</a> September 1994. (MSDN Library, Technical Articles)</p>
<p>
Thompson, Nigel. <a href="msdn_custctl.htm">"Simple Custom Controls for 32-Bit Visual C++ Applications."</a> November 1994. (MSDN Library, Technical Articles)</p>
</BODY>
</HTML>
