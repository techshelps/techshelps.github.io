<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Developing 32-Bit SQL Server Applications for the Microsoft Windows NT Operating System</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_ntdblib"></a></sup>Developing 32-Bit SQL Server Applications for the Microsoft Windows NT Operating System</h1>
<p>
Christopher Moffatt<br>
Microsoft Technical Resources Group</p>
<h2>Abstract</h2>
<p>
The Microsoft® Windows NT™ operating system is an ideal platform for building robust, feature-rich applications for Microsoft SQL Server. The SQL Server Programmer’s Toolkit for Windows NT contains a 32-bit (Win32™ API) version of DB-Library™, making it possible to develop DB-Library client applications for Microsoft SQL Server on the Windows NT operating system.</p>
<p>
The purpose of this technical article is to introduce DB-Library developers to the Microsoft Windows NT platform, address issues involved in porting existing DB-Library applications for the Windows™ version 3.<i>x</i> and OS/2® operating systems to the Windows NT operating system, and outline some of the ways in which DB-Library applications can take advantage of the Win32 application programming interface (API).</p>
<p>
This technical article assumes that you are familiar with the DB-Library API, C programming, and the following documentation:
<ul type=disc>
<li>
Microsoft SQL Server Programmer’s Reference for C<br><br></li>
<li>
Microsoft Win32 API Programmer’s Reference, Volumes 1 &amp; 2<br><br></li>
<li>
Converting OS/2 Applications to Windows</li>
</ul>
<h2>Building Win32-Based DB-Library Applications</h2>
<p>
The following sections describe uses relevant to building DB-Library™ applications using the Microsoft® Win32™ Application Programming Interface (API).</p>
<h3>Win32 DB-Library Architecture</h3>
<p>
Internally, the Win32 version of the DB-Library dynamic-link library (DLL) is implemented similarly to the version for OS/2®. In Win32, as in OS/2, a separate operating system thread is spawned for each connection that DB-Library makes with SQL Server. Each instance of the DB-Library DLL that is loaded by a calling process gets a private data area, while sharing code.</p>
<p>
The Win32 DB-Library architecture differs from the implementation in Microsoft Windows™ version 3.<i>x</i>. In Windows 3.<i>x</i>, the DB-Library DLL has a single data segment that is shared among all calling processes. W3DBLIB.DLL maintains DB-Library connections as a linked list of connections in a single data segment. This architecture is required because in Windows 3.<i>x</i> dynamic-link libraries have a single data segment that is shared among all calling processes. This necessitates the initialization and clean-up of the DB-Library DLL data structures through calls to the <b>dbinit</b> and <b>dbwinexit</b> functions.</p>
<h3>Libraries</h3>
<p>
The DB-Library functions for Win32 are located in NTWDBLIB.DLL, and the named pipe driver is located in DBNMPNTW.DLL. Set the PATH environment variable to include the directory where the dynamic-link libraries reside.</p>
<p>
Another file, NTWDBLIB.LIB, contains import definitions that your applications for the Win32 API use. Set the LIB environment variable to include the directory where NTWDBLIB.LIB resides.</p>
<h3>Include Files</h3>
<p>
The SQL Server Programmer’s Toolkit for Windows NT™ contains the following include files:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Include file</b></td>
<td class=label width=79%><b>Contains</b></td>
</tr>
<tr valign=top>
<td width=21%>SQLFRONT.H</td>
<td width=79%>Error codes and severity levels, miscellaneous definitions, and type definitions.</td>
</tr>
<tr valign=top>
<td width=21%>SQLDB.H</td>
<td width=79%>Function prototypes for all DB-Library functions.</td>
</tr>
</table><br>
<p>
You can append the path to the INCLUDE environment variable to include the directory where the include files reside. Or you can use the <b>/I</b> compile line switch to point to the include file directory.</p>
<p>
Because your applications for the Win32 API must always include the SQLDB.H file, you don’t need to define the DB-Library functions you use. These functions and their proper declarations are already defined in the include file. You must define an application’s operating system before including the DB-Library include files. Include the following statements at the beginning of all DB-Library applications that are designed for the Win32 API:</p>
<pre><code>#define DBNTWIN32
#include &lt;sqlfront.h&gt;
#include &lt;sqldb.h&gt;
</code></pre>
<p>
You can also define the operating system by using the <b>/D</b> compile line switch (for example, /DDBNTWIN32 instead of a <b>#define</b> declaration).</p>
<h3>Compiling and Linking</h3>
<p>
The following example shows a simple build file that can be used with the <b>NMAKE</b> utility to compile and link debuggable DB-Library applications for the Win32 API:</p>
<pre><code>NTLIB=\nt\sdk\lib\i386
DBLIB=\sql\dblib\lib
guilibs= $(NTLIB)\gdi32.lib $(NTLIB)\user32.lib $(NTLIB)\ 
 &nbsp;&nbsp;&nbsp; userrtl.lib $(NTLIB)\kernel32.lib $(NTLIB)\ntdll.lib \ 
 &nbsp;&nbsp;&nbsp; $(NTLIB)\libcmt.lib
all: sqltestw.exe
# Update the object file if necessary.
sqltestw.obj:&nbsp; sqltestw.c sqltestw.h sqltestw.rc makefile
 &nbsp;&nbsp;&nbsp; cl386 -c -G3d -Di386=1 -DWIN32 sqltest.c
# Update the resource file if necessary.
sqltestw.res: sqltestw.rc sqltestw.h dilaogs.h dialogs.dlg makefile
rc -r -fo sqltestw.tmp sqltest.rc
cvtres -i386 sqltestw.tmp&nbsp; -O sqltestw.res
del sqltestw.tmp
# Update the exe file if necessary.
sqltestw.exe: sql.obj sqltestw.obj sqltestw.res makefile
 &nbsp;&nbsp;&nbsp; link -machine:i386 -subsystem:windows -out:sqltestw.exe\
 &nbsp;&nbsp;&nbsp; -entry:WinMainCRTStartup\
 &nbsp;&nbsp;&nbsp; sqltestw.res sqltestw.obj $(guilibs)\
 &nbsp;&nbsp;&nbsp; ($DBLIB)\ntwdblib.lib
</code></pre>
<h2>Porting Windows 3.x-Based DB-Library Applications to Win32</h2>
<p>
All DB-Library functions are completely portable between platforms. You should not have to modify any of your DB-Library calls. You simply need to define the application’s operating system at compile time (for example, <b>#define DBNTWIN32</b> for Windows NT).</p>
<p>
Because the Win32 API maintains compatibility with the Windows 3.<i>x</i> operating system, the Win32 DB-Library DLL supports all Windows 3.<i>x</i>-based DB-Library functions, even if they are not required. DB-Library functions present in Windows 3.<i>x</i> but not needed in Windows NT (for example, <b>DBLOCKLIB</b> and <b>DBUNLOCKLIB</b>) are accepted, but return without performing any actions.</p>
<p>
Two DB-Library functions, <b>dbprhead</b> and <b>dbprrow</b>, not supported in Windows 3.<i>x</i> because they send output to STDIO, are supported in Win32 and can be used when developing applications for the CONSOLE subsystem. The <b>dbprhead</b> and <b>dbprrow</b> functions provide a convenient way to display the results of a query to the default output device.</p>
<p>
If you have existing Windows-based DB-Library applications that you want to run with Windows NT, you can take three approaches:
<ul type=disc>
<li>
<b>Run your 16-bit application for Windows 3.<i>x</i> unchanged in the Windows 3.<i>x</i> subsystem</b>. If you have an application for Windows 3.<i>x</i> that has been completed and will not require changes in the future, simply run it unchanged.<br><br></li>
<li>
<b>Change your application source code so that it can be compiled for the Win32 API or Windows 3.<i>x</i></b>. If your DB-Library application is under development or is evolving to meet changing user needs, and you want to run the application with Windows 3.<i>x</i> and Windows NT, make small changes to the source code to build 16-bit (Windows 3.<i>x</i>) and 32-bit (Win32) versions of your application from the same source.<br><br></li>
<li>
<b>Port your application source code entirely to Win32</b>. If you decide to modify your application to run only as a 32-bit (Win32-based) application (for example, you require Win32-specific features such as threads or preemptive multitasking), you can port your application to the Win32 API, removing redundant Windows 3.<i>x</i> calls and dependencies.</li>
</ul>
<h3>Porting to Maintain DB-Library Compatibility for Windows 3.<i>x</i></h3>
<p>
This section explains how to port a DB-Library application for Windows 3.<i>x</i> to the Windows NT operating system while retaining compatibility with applications for Windows 3.<i>x</i>.</p>
<h4>API calls for Windows 3.<i>x</i> and C run-time</h4>
<p>
In general, you can change your source code to easily build 16-bit or 32-bit versions. For an in-depth discussion of writing applications for the Win32 API that retain compatibility with Windows 3.<i>x</i>, see the <i>Microsoft Win32 API Programmer’s Reference,</i> Volume 1.</p>
<p>
The following guidelines apply to the development of applications for the Win32 API:
<ul type=disc>
<li>
<b>Function definitions and prototypes</b>. Be sure that your function definitions and function prototypes use portable datatypes.<br><br></li>
<li>
<b>Windows message parameter packing</b>. The widening of handles to 32 bits means that the packing of handles and other values in <i>wParam</i> and <i>lParam</i> has changed. Verify whether or not you need to change the decoding of <i>wParam</i> and <i>lParam</i> in your application.</li>
</ul>
<h4>DB-Library functions and datatypes</h4>
<p>
All DB-Library functions are completely portable between operating systems. You simply need to define the target operating system at compile time.</p>
<p>
Many DB-Library functions return values of type <i>int</i>. Note that the <i>int</i> datatype is a 16-bit value in Windows 3.<i>x</i> and a 32-bit value in the Win32 API. Therefore, verify that your application uses the correct type of variable to receive return values from DB-Library functions that return an <i>int </i>datatype. For example, a variable defined as the datatype <i>short</i> receives a correct <i>int</i> value from DB-Library in Windows 3.<i>x</i> but receives an incorrect value in the Win32 API.</p>
<p>
Apart from verifying that variables receiving return values from DB-Library are of the correct type, no changes are needed to DB-Library functions.</p>
<h3>Additional Porting Considerations</h3>
<p>
If you port an application for the Windows 3.<i>x</i> operating system to the Windows NT operating system and do not need to maintain compatibility with Windows 3.<i>x</i>, you can change your DB-Library code to remove redundant or unnecessary Windows 3.<i>x</i> functions.</p>
<h4>Redundant Windows 3.<i>x</i>-specific DB-Library functions</h4>
<p>
The following Windows 3.<i>x</i>-specific DB-Library functions are redundant in the Win32 version of DB-Library:</p>
<p class=dt>
dbinit</p>
<p class=indent>
In the Win32 API, there is no need to call <b>dbinit</b> before issuing other DB-Library functions. As in the MS-DOS® and OS/2® operating systems, a Win32 call to <b>dbinit</b> returns a version string. In Windows 3.<i>x</i>, it is necessary to call <b>dbinit</b> to initialize DB-Library data structures.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;It is generally recommended that you retrieve the DB-Library version string, by calling dbinit, and make it viewable by the user (for example, in an “About” dialog box).</p>
<p class=dt>
dbwinexit</p>
<p class=indent>
This function is unnecessary in Win32.</p>
<p class=dt>
DBLOCKLIB/DBUNLOCKLIB</p>
<p class=indent>
In Win32, each process has a unique 32-bit linear virtual address space that allows it to address up to 4 gigabytes of memory (the 2 gigabytes in low memory are available to the user). In effect, all data is in one large segment, and you are freed from the concerns of segments, far pointers, and so on. Therefore, you don’t have to call the <b>DBLOCKLIB</b> and <b>DBUNLOCKLIB</b> macros before accessing pointers to data in the DB-Library DLL or pointers that pass data to the DB-Library DLL.</p>
<h4>Changes to error/message handler registration</h4>
<p>
The following changes apply to the registration of error and message handlers for Win32:
<ul type=disc>
<li>
<b>No need to export callback functions</b>. You don’t need to export the DB-Library error and message handler callback functions in a .DEF file.<br><br></li>
<li>
<b>No need to call MakeProcInstance</b>. You don’t need to call <b>MakeProcInstance</b> to obtain a pointer to pass to the <b>dberrhandle </b>and <b>dbmsghandle</b> functions. Simply call <b>dberrhandle </b>and <b>dbmsghandle</b>, passing the function address. The following examples show the differences in calling the <b>dberrhandle </b>and <b>dbmsghandle</b> functions in Windows 3.<i>x</i> and in Win32:</li>
</ul>
<p>
For Windows 3.<i>x</i>:</p>
<pre><code>// Define variables 
static FARPROC lpdbMsgHandler;
static FARPROC lpdbErrHandler;

// Get Procedure Instances
lpdbMsgHandler = MakeProcInstance((FARPROC)dbMsgHandler, hInst);
lpdbErrHandler = MakeProcInstance((FARPROC)dbErrHandler, hInst);

// Install the instances into dblib 
dbmsghandle(lpdbMessageHandler);
dberrhandle(lpdbErrorHandler);
</code></pre>
<p>
For Win32:</p>
<pre><code>// Install the instances into dblib 
dbmsghandle(dbMessageHandler);
dberrhandle(dbErrorHandler);
</code></pre>
<h4>Preemptive multitasking (Win32) vs. cooperative multitasking (Windows 3.<i>x</i>)</h4>
<p>
To support asynchronous processing in the cooperative multitasking environment in Windows 3.<i>x</i>, each application must behave well and yield to the CPU at regular intervals. Therefore, when you process SQL Server queries in the Windows operating system, you need to use Windows-based timers or the <b>PeekMessage</b> function in combination with the DB-Library function calls for asynchronous processing (<b>dbsqlsend</b>, <b>dbdataready</b>, and<b> dbsqlok</b>). For more information about implementing asynchronous query processing in Windows 3.<i>x</i>, see the<i> Microsoft SQL Server Programmer’s Reference for C </i>(page 43).</p>
<p>
The support for preemptive multitasking in the Win32 API simplifies the implementation of asynchronous query processing. The preemptive multitasking nature of the Windows NT operating system ensures that other processes always obtain CPU cycles regardless of any processing that another application is doing. Within a single process, asynchronous processing can be implemented using Win32 threads or by using the DB-Library functions that support asynchronous processing in conjunction with the <b>PostMessage</b> Windows function. For more information about asynchronous processing, see “Taking Advantage of Win32 API Features in DB-Library Applications,” later in this article.</p>
<h3>Porting the SQLTEST3 Sample Application</h3>
<p>
This section uses the sample program SQLTEST3, provided with the DB-Library Programmer’s Toolkit, as an example of how to port a DB-Library application from Windows 3.<i>x</i> to Windows NT. Although it uses a simple application, this example illustrates how easily you can port applications for the Windows 3.<i>x</i> operating system to the Windows NT operating system.</p>
<h4>Minimum port to Win32 (maintaining compatibility with Windows 3.<i>x</i>)</h4>
<p>
The following procedure shows how to modify the SQLTEST3 sample application to port it to the Win32 API while maintaining compatibility with Windows 3.<i>x</i>:
<ol>
<li>
<b>Change the operating system definition:</b><p class=tl>
Change (Windows 3.<i>x</i>):</P><pre><code>#define DBMSWIN<b> </b>
</code></pre>
<p class=tl>
To (Win32):</P><pre><code>#define DBNTWIN32
</code></pre>
</li>
<li>
<b>Modify the function prototypes in SQLTEST3.H to be portable:</b><p class=tl>
Change (Windows 3.<i>x</i>):</P><pre><code>long FAR PASCAL SqlTestWndProc(HWND, unsigned, WORD, LONG);
BOOL FAR PASCAL AboutSQL(HWND, unsigned, WORD, LONG);
BOOL FAR PASCAL SelectSQL(HWND, unsigned, WORD, LONG);
BOOL FAR PASCAL ConnectSQL(HWND, unsigned, WORD, LONG);
int dbwinErrorHandler(DBPROCESS *, int, int, int, LPSTR, LPSTR);
int dbwinMessageHandler(DBPROCESS *,DBINT,DBSMALLINT,DBSMALLINT,LPSTR);
</code></pre>
<p class=tl>
To (Win32):</P><pre><code>LONG APIENTRY SqlTestWndProc(HWND, UINT, DWORD, LONG);
LONG APIENTRY&nbsp; AboutSQL(HWND, UINT, DWORD, LONG);
LONG APIENTRY SelectSQL(HWND, UINT, DWORD, LONG);
LONG APIENTRY ConnectSQL(HWND, UINT, DWORD, LONG);
int API dbwinErrorHandler(DBPROCESS *, int, int, int, LPSTR, LPSTR);
int API dbwinMessageHandler(DBPROCESS* DBINTDBSMALLINT, DBSMALLINT, LPSTR);
</code></pre>
</li>
<li>
<b>Modify the following function parameters and return values to match all changes made to the matching function prototypes in Step 2:</b><pre><code>SqlTestWndProc
AboutSQL
SelectSQL
ConnectSQL
dbwinErrorHandler
dbwinMessageHandler
</code></pre>
</li>
</ol>
<h4>Full port to Win32</h4>
<p>
The following procedure shows how to modify the SQLTEST3 sample application to port it to the Win32 API without maintaining compatibility with Windows 3.<i>x</i>.
<ol>
<li>
<b>Remove redundant DB-Library calls:</b><pre><code>DBLOCKLIB or DBUNLOCKLIB&nbsp; <b> (in three places)</b>
dbwinexit
</code></pre>
</li>
<li>
<b>Change error/message handler registration:</b><p class=tl>
Change (Windows 3.<i>x</i>):</P><pre><code>static FARPROC lpdbwinMessageHandler; 
static FARPROC lpdbwinErrorHandler;&nbsp; 
...
lpdbwinMessageHandler = 
MakeProcInstance((FARPROC)dbwinMessageHandler, hInst);
lpdbwinErrorHandler = 
MakeProcInstance((FARPROC)dbwinErrorHandler, hInst);
dbmsghandle(lpdbwinMessageHandler);
dberrhandle(lpdbwinErrorHandler);
...
FreeProcInstance(lpdbwinMessageHandler)
FreeProcInstance(lpdbwinErrorHandler);
</code></pre>
<p class=tl>
To (Win32):</P><pre><code>dbmsghandle(dbwinMessageHandler);
dberrhandle(dbwinErrorHandler);
</code></pre>
</li>
<li>
<b>Change dialog box instantiations:</b><p class=tl>
Modify all <b>DialogBox</b> function calls to pass the address of the function instead of calling <b>MakeProcInstance</b> and passing the pointer returned from this function.</P></li>
<li>
<b>Delete the .DEF file (it is unnecessary):</b></li>
</ol>
<h2>Porting OS/2-Based DB-Library Applications to Win32</h2>
<p>
All DB-Library functions are completely portable across the OS/2 and Win32 APIs, and you should not need to modify to any of your DB-Library calls.</p>
<p>
If you have existing OS/2-based DB-Library applications that you want to run with the Windows NT operating system, there are two basic approaches you can take:
<ul type=disc>
<li>
<b>Change your source code to replace base OS/2 and/or Presentation Manager</b>®<b> functions with equivalent Win32 API functions</b>. Because C run-time functions and DB-Library functions are completely portable between the OS/2 and Windows NT platforms, if you decide to port an OS/2-based application to the Windows NT platform, you only need to replace base OS/2 and/or Presentation Manager API calls with equivalent Win32 API calls. <i>Converting OS/2 Applications to Windows</i> is an exhaustive treatment of this topic and provides an overview of porting considerations, as well as giving an in-depth treatment of using Win32 API functions to replace base OS/2 and Presentation Manager functions. The Win32 API provides equivalent, and in some cases superior, functionality in replacing OS/2 functions.<br><br></li>
<li>
<b>Run your character-mode application for OS/2 unchanged</b>. The initial release of the Windows NT operating system will provide an OS/2 subsystem that will run OS/2 character-mode applications with binary compatibility. If you have a character-mode DB-Library application written for OS/2, you should be able to run this with the Windows NT platform without making any changes or having to rebuild the application. Consult the documentation for Windows NT to determine which OS/2 functions are supported in the OS/2 subsystem.</li>
</ul>
<h3>OS/2 to Win32 API Conversion</h3>
<p>
As mentioned earlier, the topic of converting applications from OS/2 to the Win32 API is covered extensively in <i>Converting OS/2 Applications to Windows</i>. This section highlights two major areas of functionality that are found in a large number of OS/2-based DB-Library applications, namely thread management and synchronization mechanisms. (This information is taken directly from the <i>Converting OS/2 Applications to Windows</i>.)</p>
<h4>Processes and threads</h4>
<p>
The Win32 API provides equivalent functionality to OS/2 process and thread calls. You can consider their functionality to be conceptually equivalent, except in the areas outlined below:
<ul type=disc>
<li>
<b>Security:</b> Win32 on the Windows NT platform provides complete security, and security access can be assigned to all objects including processes and threads.<br><br></li>
<li>
<b>Parent Process:</b> There is no concept of a parent process in Win32.<br><br></li>
<li>
<b>Exit List Processing:</b> Exit List Processing is not supported in the Win32 API. However, in some cases the DLL load and unload entry point can be used to similar effect.<br><br></li>
<li>
<b>Handles and IDs:</b> In OS/2, processes and threads are identified by an ID that is a global value. In Win32, processes and threads have IDs that are global and HANDLEs that are only valid within a particular process. All functions that manipulate processes and threads require a valid HANDLE.</li>
</ul>
<h4>Semaphores and synchronization</h4>
<p>
There are two types of synchronization provided by both OS/2 and the Win32 API set: mutual exclusion and signaling.</p>
<p>
<b>Mutual exclusion</b></p>
<p>
Mutual exclusion involves denying other threads of execution access to a critical section of code. Both OS/2 and Win32 have mechanisms designed to facilitate mutual exclusion within a process and mutual exclusion between processes.
<ul type=disc>
<li>
<b>DosEnterCritSec</b> and <b>DosExitCritSec</b> provide for mutual exclusion in OS/2 by preventing other threads within a process from executing while a thread is between these two calls. Win32 does not have a similar mechanism. Programs using these calls should organize their code so that all code that accesses a protected resource is located in one place and therefore protectable by the other mutual exclusion mechanisms.<br><br></li>
<li>
<b>DosFSRamSemClear</b> and <b>DosFSRamSemRequest</b> are used for mutual exclusion within a process. Win32 provides the Mutex object to implement this functionality. Calls valid on a Mutex object include <b>CreateMutex</b>, <b>OpenMutex</b>, <b>ReleaseMutex</b>, <b>WaitForSingleObject</b>, and <b>CloseHandle</b>. A Mutex can be shared by more than one process.<br><br></li>
<li>
<b>DosCreateSem</b>, <b>DosOpenSem</b>, <b>DosCloseSem</b>, <b>DosSemRequest</b>, and <b>DosSemClear</b> are used for mutual exclusion between processes. Win32 provides the Semaphore object, which provides a superset of these functions. The Win32 Semaphore can be either named or unnamed, thus providing a replacement for either RAM semaphores or system semaphores. Win32 functions that manage Semaphore objects include <b>CreateSemaphore</b>, <b>OpenSemaphore</b>, <b>CloseSemaphore</b>, <b>ReleaseSemaphore</b>, and <b>WaitForSingleObject</b>.</li>
</ul>
<p>
<b>Signaling</b></p>
<p>
OS/2 semaphores can be used for signaling between processes. The OS/2 functions used for this purpose are <b>DosSemSet</b>, <b>DosSemWait</b>, <b>DosSemSetWait</b>, and <b>DosMuxSemWait</b>. The Win32 API provides the Event object, which implements a superset of this functionality. The Win32 functions used to manage the Event object include <b>CreateEvent</b>, <b>OpenEvent</b>, <b>SetEvent</b>, <b>PulseEvent</b>, and <b>ResetEvent</b>.</p>
<h2>Taking Advantage of Win32 API Features in DB-Library Applications</h2>
<p>
The following sections describe how to take advantage of the unique features of the Win32 API.</p>
<h3>Asynchronous Query Processing</h3>
<p>
Preemptive multitasking in the Win32 API makes implementing asynchronous query processing easy. There are several ways to implement asynchronous query processing, depending on whether you want your application to exhibit asynchronous behavior between processes or within a single process.
<ul type=disc>
<li>
<b>Switch tasks between processes</b>. Use the standard <b>dbsqlexec</b> call to send a query to SQL Server. Although <b>dbsqlexec</b> is synchronous from the calling thread’s perspective (<b>dbsqlexec</b> returns only when SQL Server processes the query and is ready to return results), the preemptive nature of Win32 allows other applications or threads of the same application to continue to work and process user input while the query is executing.<br><br></li>
<li>
<b>Implement asynchronous processing within a single process</b>.<ul type=disc>
<li>
<b>Use threads</b>. The easiest way to implement asynchronous processing within a process is to use threads in Win32. You can spawn a thread that calls <b>dbsqlexec</b> and continue to do other work or receive user input while the query is being processed.<br><br></li>
<li>
<b>Single-thread approach</b>. If you require a single-thread process to implement asynchronous query processing, use the asynchronous DB-Library functions <b>dbsqlsend</b>,<b> dbdataready</b>, and <b>dbsqlok</b> in combination with the <b>PostMessage</b> function, as shown in this example:<pre><code>case WM_SENDQUERY:
 &nbsp;&nbsp;&nbsp; dbsqlsend (dbproc);
 &nbsp;&nbsp;&nbsp; PostMessage(hWnd,WM_CHECKQUERY,0,0L);
 &nbsp;&nbsp;&nbsp; break;

case WM_CHECKQUERY:
 &nbsp;&nbsp;&nbsp; if ( dbdataready(dbproc) )
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbsqlok (dbproc);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostMessage(hWnd,WM_GETRESULTS,0,0L);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostMessage(hWnd,WM_CHECKQUERY,0,0L);
 &nbsp;&nbsp;&nbsp; }
break;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3>Memory Management in Win32</h3>
<p>
The 32-bit linear virtual memory address space available to processes in the Win32 API makes memory management simpler and cleaner. This applies to DB-Library programming as well as to any other programming for the Win32 API.</p>
<p>
Although the memory management functions (<b>GlobalAlloc</b>, <b>LocalAlloc</b>, and so on) in Windows 3.<i>x</i> are supported by the Win32 API, consider using the C run-time functions <b>malloc</b> and <b>free</b> to perform dynamic memory management when you develop applications to run only with Win32. The <b>malloc</b> and <b>free</b> functions are not safe to use with Windows 3.<i>x</i> and OS/2 because of the segmented architecture of those systems. However, with Win32 these functions are both safe and elegant. In addition to the standard memory management functions (<b>Global</b> and <b>Local</b>, C run-time support), Win32 also provides heap and virtual memory management functions for applications that require specialized memory management.</p>
<p>
Two specific areas of DB-Library programming can take advantage of the ability to address greater than 64K of data:
<ul type=disc>
<li>
<b>The processing of text and image data.</b> There are many uses for SQL Server text and image datatypes. All require manipulation of text and image data, and the ability to transfer data between the application and SQL Server. The ability to address large chunks of memory can make this easier. Because it is possible to address up to 2 gigabytes of user memory in an application for the Win32 API, you can develop text/image handling functions that transfer text/image data in a single operation instead of transferring data chunks of less than 64K. (Note, however, that waiting for 2 gigabytes of data to transfer can take considerable time.)<br><br></li>
<li>
<b>Row buffering.</b> In DB-Library for MS-DOS, OS/2, and Windows 3.<i>x</i>, you are constrained because DB-Library cannot handle more than 64K of data at a time, including memory allocated for row buffering. This value is further reduced by overhead taken up by data structures, variables, and so on. In Win32, it is possible to use DBSETOPT(DBBUFFER,...) to enable row buffering for data sets greater than 64K.</li>
</ul>
<h3>Threads in Win32</h3>
<p>
The multithreaded process structure of Win32 opens up powerful and elegant solutions to high-end applications. Each thread within a process has its own stack and machine state. On multiprocessor systems with the Windows NT platform, multiple threads can execute at the same time but on different processors. Applications that need to perform intensive processing, I/O, and so on, can do this in the background using threads and still offer a responsive user interface.</p>
<h3>DB-Library and Reentrancy</h3>
<p>
The DB-Library API is basically non-reentrant, because all DB-Library functions that access a named pipe connection are not reentrant. You must serialize the DB-Library calls that access the named pipe connection in multithreaded applications.
<ul type=disc>
<li>
It is necessary to serialize calls to the named pipe connection (for example, <b>dbsqlexec</b>, <b>dbsqlsend</b>, <b>dbdataready</b>, <b>dbcancel</b>, <b>dbsqlok</b>, and so on) in an application where more than one thread accesses a single DBPROCESS.<br><br></li>
<li>
If each thread accesses a different DBPROCESS, you are freed of serialization concerns except for operations that involve global variables. Error and message handling is maintained globally within DB-Library; therefore, you should block on a semaphore or use a flag variable when an error or message occurs, so that you are not preempted by another thread. The DBPROCESS passed to the error/message handler will distinguish which thread is involved. Or you can store information about a thread along with the DBPROCESS using <b>dbsetuserdata</b>/<b>dbgetuserdata</b>.</li>
</ul>
<p>
Time-outs are also managed globally in DB-Library.</p>
<h3>Structured Exception Handling</h3>
<p>
The Win32 API supports structured exception handling to aid the development of robust software and is made available to developers through compiler support. Consider using this functionality in your application. For more information about structured exception handling, see the <i>Microsoft Win32 API Programmer’s Reference,</i> Volume 1 (Chapter 11<i>).</i></p>
<h3>Symmetric Multiprocessing</h3>
<p>
The Windows NT platform supports symmetric multiprocessing (SMP), thereby allowing applications with multiple threads of execution to run across multiple processors. If your DB-Library application uses Win32 threads, it can advantage of Windows NT SMP support without any additional work being done.</p>
<h2>Sample Code: SQLSTRES</h2>
<p>
SQLSTRES is a sample Windows NT-based DB-Library application. It can be used to simulate a large number of SQL Server clients to help determine the effect of “scaling up” an application when more users are added.</p>
<p>
When a SQL Server client application is developed, questions often arise as to how response time and throughput will be affected when the application is deployed and a large number of users use the application simultaneously. Standard benchmarks are useful for getting a idea of performance and scalability, but these factors vary tremendously and are highly dependent on the types of queries and updates done by a specific application. In the development phase of an application, it is often difficult to simulate realistic operating environments with large numbers of workstations. The SQLSTRES application allows you to simulate a large number of users executing operations of your particular application from a single workstation:
<ul type=disc>
<li>
SQLSTRES uses Windows NT threads to simulate each client connection, with status and the results of queries displayed in MDI child windows.<br><br></li>
<li>
SQLSTRES loads the Transact-SQL™ queries to be performed from <b>isql</b>-compatible text files, allowing you to easily control the queries being executed.<br><br></li>
<li>
SQLSTRES allows you to specify the number of clients to simulate and the number of iterations to perform.</li>
</ul>
<p>
The sample code described here can be found in the Microsoft Online Software Library or in the Microsoft Forum Software Library on CompuServe® in a file called SQLSTRES.ZIP. It can be located by searching on the keyword SQLSTRES, the Q number of this article in the Microsoft KnowledgeBase (Q87953), or S13580. SQLSTRES.ZIP was archived using the PKware file-compression utility.</p>
<p>
SQLSTRES.ZIP contains the following files:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Filename</b></td>
<td class=label width=74%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=26%>SQLSTRES.C</td>
<td width=74%>Main source code file</td>
</tr>
<tr valign=top>
<td width=26%>SQLSTRES.H</td>
<td width=74%>Source code header file</td>
</tr>
<tr valign=top>
<td width=26%>SQLSTRES.RC</td>
<td width=74%>Windows-based resource script file</td>
</tr>
<tr valign=top>
<td width=26%>SQL.C</td>
<td width=74%>Source code file for DB-Library–specific functions</td>
</tr>
<tr valign=top>
<td width=26%>SQL.H</td>
<td width=74%>Header file for DB-Library–specific functions</td>
</tr>
<tr valign=top>
<td width=26%>DIALOGS.DLG</td>
<td width=74%>Dialog box resource script file</td>
</tr>
<tr valign=top>
<td width=26%>DIALOGS.H</td>
<td width=74%>Dialog box header file</td>
</tr>
<tr valign=top>
<td width=26%>DIALOGS.RES</td>
<td width=74%>Windows NT–based Dialog Editor resource</td>
</tr>
<tr valign=top>
<td width=26%>MAKEFILE</td>
<td width=74%>NMAKE File</td>
</tr>
<tr valign=top>
<td width=26%>TESTX.SQL</td>
<td width=74%>Sample query file</td>
</tr>
</table><br>
<h2>References</h2>
<h3>Books</h3>
<p>
<i>Microsoft SQL Server Programmer’s Reference for C</i> (Part number 27445)</p>
<p>
<i>Microsoft Win32 API Programmer’s Reference</i>, Volumes 1 &amp; 2 (Microsoft Press)</p>
<p>
<i>Converting OS/2 Applications to Windows</i> (Part number 098-35176)</p>
<h3>Available Technical Notes</h3>
<p>
"Using Microsoft SQL Server on a Banyan VINES Network" (Part number 098-30193)</p>
<p>
"Query Optimization Techniques: Contrasting Various Optimizer Implementations with Microsoft SQL Server" (Part number 098-30199)</p>
<p>
"Microsoft Open Data Services: Application Sourcebook" (Part number 098-32078)</p>
<p>
"Using Microsoft SQL Server on a Novell NetWare Network" (Part number 098-32655)</p>
<p>
"Developing 32-Bit Open Data Services Applications for the Microsoft Windows NT Operating System" (Part number 098-36256)</p>
<h3>Additional Information</h3>
<p>
To receive more information, contact Microsoft Inside Sales, Systems Software, at 1-800-227-4679.</p>
</BODY>
</HTML>
