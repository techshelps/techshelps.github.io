<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Other Application Considerations</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Other Application Considerations</h1>
<p>
This section discusses some additional issues to consider when programming ODBC SQL&nbsp;Server applications.</p>
<h3>Asynchronous Mode and SQLCancel</h3>
<p>
Some ODBC functions can operate either synchronously or asynchronously (see the <i>ODBC 2.0 Programmer's Reference</i> for the list of functions). The application can enable asynchronous operations for either a statement handle or a connection handle. If the option is set for a connection handle, it affects all statement handles on the connection handle. The application uses the following statements to enable or disable asynchronous operations:</p>
<pre><code>SQLSetConnectOption(hdbc, SQL_ASYNC_ENABLE, SQL_ASYNC_ENABLE_ON);
SQLSetConnectOption(hdbc, SQL_ASYNC_ENABLE, SQL_ASYNC_ENABLE_OFF);
SQLSetStmtOption(hdbc, SQL_ASYNC_ENABLE, SQL_ASYNC_ENABLE_ON);
SQLSetStmtOption(hdbc, SQL_ASYNC_ENABLE, SQL_ASYNC_ENABLE_OFF);
</code></pre>
<p>
When an application calls an ODBC function in synchronous mode, the driver does not return control to the application until it is notified that the server has completed the command.</p>
<p>
When operating asynchronously, the driver immediately returns control to the application, even before sending the command to the server. The driver sets the return code to SQL_STILL_EXECUTING. The application is then free to perform other work. </p>
<p>
To test for completion of the command, make the same function call with the same parameters to the driver. If the driver is still waiting for an answer from the server, it will again return SQL_STILL_EXECUTING. The application must keep testing the command periodically until it returns something other than SQL_STILL_EXECUTING. When the application gets some other return code, even SQL_ERROR, the command has completed.</p>
<p>
Sometimes a command is outstanding for a long time. If the application needs to cancel the command without waiting for a reply, it can do so by calling <b>SQLCancel</b> with the same statement handle as the outstanding command. This is the only time <b>SQLCancel</b> should be used. Some programmers use <b>SQLCancel</b> when the application has processed part way through a result set and they want to cancel the rest of the result set. <b>SQLMoreResults</b> or <b>SQLFreeStmt</b> with <i>fOption</i> set to SQL_CLOSE should be used to cancel the remainder of an outstanding result set, not <b>SQLCancel</b>.</p>
<h3>Multithread Applications</h3>
<p>
The SQL&nbsp;Server ODBC driver is a fully multithreaded driver. Writing a multithread application is an alternative to using asynchronous calls to have multiple ODBC calls outstanding. A thread can make a synchronous ODBC call, and other threads can process while the first thread is blocked waiting for the response to its call. This model is more efficient than making asynchronous calls because it eliminates the overhead of the repeated ODBC function calls testing for SQL_STILL_EXECUTING to see if the function has completed.</p>
<p>
Asynchronous mode is still an effective method of processing. The performance improvements of a multithread model are not enough to justify rewriting asynchronous applications. If users are converting DB-Library applications that use the DB-Library asynchronous model, it is easier to convert them to the ODBC asynchronous model.</p>
<p>
Multithread applications need to have coordinated calls to <b>SQLError</b>. After a message has been read from <b>SQLError</b>, it is no longer available to the next caller of <b>SQLError</b>. If a connection or statement handle is being shared between threads, one thread may read a message needed by the other thread.</p>
<h3>SET Options Used by the Driver</h3>
<p>
The ODBC standard is closely matched to the ANSI SQL standard, and ODBC applications expect standard behavior from an ODBC driver. To make its behavior conform more closely with that defined in the ODBC standard, the SQL&nbsp;Server ODBC driver always uses any ANSI options available in the version of SQL&nbsp;Server to which it connects. The server exposes these ANSI options through the Transact-SQL SET statement. The driver also sets some other options to help it support the ODBC environment.</p>
<p>
The SQL&nbsp;Server ODBC driver that ships with SQL&nbsp;Server 6.5 issues the following Transact-SQL SET statements:
<ul type=disc>
<li>
Connect to SQL&nbsp;Server version 6.5:<pre><code>SET QUOTED_IDENTIFIER ON
SET TEXTSIZE 2147483647
SET ANSI_DEFAULTS ON
SET CURSOR_CLOSE_ON_COMMIT OFF
SET IMPLICIT_TRANSACTIONS OFF
</code></pre>
</li>
<li>
Connect to SQL&nbsp;Server version 6.0:<pre><code>SET ANSI_NULL_DFLT_ON ON
SET TEXTSIZE 2147483647
SET QUOTED_IDENTIFIER ON
SET ARITHABORT ON
</code></pre>
</li>
<li>
Connect to SQL&nbsp;Server version 4.21a:<pre><code>SET TEXTSIZE 2147483647
SET ARITHABORT ON
</code></pre>
</li>
</ul>
<p>
The driver issues these statements itself; the ODBC application does nothing to request them. Setting these options allows ODBC applications using the driver to be more portable because the driver's behavior then matches the ANSI standard.</p>
<p>
DB-Library based applications, including the SQL&nbsp;Server utilities, generally do not turn these options on. Sites observing different behavior between ODBC or DB-Library clients when running the same SQL statement should not assume this points to a problem with the ODBC driver. They should first rerun the statement in the DB-Library environment (such as ISQL/w) with the same SET options as would be used by the SQL&nbsp;Server ODBC driver.</p>
<p>
Since the SET options can be turned on and off at any time by users and applications, developers of stored procedures and triggers should also take care to test their procedures and triggers with the SET options listed above turned both on and off. This ensures that the procedures and triggers work correctly regardless of what options a particular connection may have SET on when they invoke the procedure or trigger.</p>
<p>
The SET options used by the version 2.65 driver when connected to SQL&nbsp;Server 6.5 has the net effect of setting on three more ANSI options than in the 6.0 environment: ANSI_NULLS, ANSI_PADDING, and ANSI_WARNINGS. These options can cause problems in existing stored procedures and triggers. The version 2.65.0240 driver that shipped with SQL&nbsp;Server 6.5 SP2 allows data sources and connection statements to turn these options off. For more information, see Microsoft Knowledge&nbsp;Base article Q149921.</p>
<p>
The version 2.50 driver that shipped with SQL&nbsp;Server 6.0 also sets on the QUOTED_IDENTIFIER option. With this option set on, SQL statements should comply with the ANSI rule that character data strings be enclosed in single quotes and that only identifiers, such as table or column names, be enclosed in double quotes:</p>
<pre><code>SELECT "au_fname"
FROM "authors"
WHERE "au_lname" = 'O''Brien'
</code></pre>
<p>
For more information about working with QUOTED_IDENTIFIER, see Microsoft Knowledge&nbsp;Base article Q156501.</p>
<p>
Like the ANSI options noted above, the version 2.65.0240 driver that shipped with SQL&nbsp;Server 6.5 SP2 allows <b>SQLDriverConnect</b>, <b>SQLBrowseConnect</b>, and data sources to specify that QUOTED_IDENTIFIERS not be turned on.</p>
<p>
ODBC applications should not use the Transact-SQL SET statement to turn these options on or off. They should only set these options in either the data source or the connection options. The logic in the driver depends on it correctly knowing the current state of the SET options. If the application issues the SET statements itself, the driver may generate incorrect SQL statements due to not knowing that the option has been changed.</p>
<h3>Diagnostic Messages</h3>
<p>
This section discusses how to interpret the error messages that are returned by the SQL&nbsp;Server ODBC driver. All ODBC functions have return codes. The ODBC header files have #define statements that equate the return codes to literals, such as SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, and SQL_ERROR. If a function returns SQL_SUCCESS_WITH_INFO, it means the function was successful but there is information available. If a function returns SQL_ERROR, it means the function failed and there is information available indicating the nature of the problem. To get these messages, the application can call <b>SQLError</b>. <b>SQLError</b> returns three parameters that have important information:
<ul type=disc>
<li>
<i>SQLState</i>—a 5-byte character string with an ODBC error code.<br><br></li>
<li>
<i>pfNative</i>—a signed doubleword holding whatever error code is returned by the native database.<br><br></li>
<li>
<i>szErrorMsg</i>—a character string holding a header identifying the source of the error and the text of the error message.</li>
</ul>
<h4>Identifying the Source of an Error</h4>
<p>
The heading of <i>szErrorMsg</i> can be used to determine the source of the error:</p>
<pre><code>[Microsoft][ODBC Driver Manager]
</code></pre>
<p class=indent>
These are errors encountered by the ODBC Driver Manager.</p>
<pre><code>[Microsoft][ODBC Cursor Library]
</code></pre>
<p class=indent>
These are errors encountered by the ODBC Cursor Library.</p>
<pre><code>[Microsoft][ODBC SQL&nbsp;Server Driver]
</code></pre>
<p class=indent>
If there are no other nodes identifying other components, these are errors encountered by the driver.</p>
<pre><code>[Microsoft][ODBC SQL&nbsp;Server Driver][<i>Net-Libraryname</i>]
</code></pre>
<p class=indent>
These are errors encountered by the Net-Library, where <i>Net-Libraryname</i> is the name of a SQL&nbsp;Server Net-Library (see "Setup and Connecting" for a list of the names). This also includes errors raised from the underlying network protocol because these errors are reported to the driver from the Net-Library. In these errors, the <i>pfNative</i> code contains the actual error returned by the network. (For more information about <i>pfNative</i> codes, see "<i>pfNative</i> Error Codes," later in this paper.) The remainder of the message contains two parts: the Net-Library function called, and (within parenthesis afterward) the underlying network API function called.</p>
<pre><code>[Microsoft][ODBC SQL&nbsp;Server Driver][SQL&nbsp;Server]
</code></pre>
<p class=indent>
These are errors encountered by SQL&nbsp;Server. In this case, the <i>pfNative</i> parameter is the SQL&nbsp;Server error code.</p>
<p>
For example, when an application attempts to open a named-pipe connection to a server that is currently shut down, the error string returned is:</p>
<pre><code>[Microsoft][ODBC SQL&nbsp;Server Driver][dbnmpntw]ConnectionOpen (CreateFile())
</code></pre>
<p>
This indicates that the driver called the dbnmpntw <b>ConnectionOpen</b> function and that dbnmpntw in turn called the named-pipe API function <b>CreateFile</b>.</p>
<h4>pfNative Error Codes</h4>
<p>
The value of the <i>pfNative</i> code in an error message is based on the source of the error:
<ul type=disc>
<li>
If an error is raised by an ODBC component (the Driver Manager, Cursor Library, or the SQL&nbsp;Server ODBC driver), then the <i>pfNative</i> code is 0.<br><br></li>
<li>
If an error is raised by the server, the <i>pfNative</i> code is the SQL&nbsp;Server error code. For more information about SQL&nbsp;Server errors, see chapters 25 and 26 in the <i>Microsoft SQL&nbsp;Server Administrator's Companion</i>.<br><br></li>
<li>
If an error is raised by the Net-Library, the <i>pfNative</i> code is the error code returned to the Net-Library from the underlying network protocol stack.</li>
</ul>
<p>
For more information about the codes returned by the different underlying network protocol stacks, see the following sources:
<ul type=disc>
<li>
dbnmpntw, dbnmp3<p class=tl>
These codes are generally the same as those listed in Operating System Error Codes in Microsoft Knowledge&nbsp;Base article Q116401.</P></li>
<li>
dbmssocn, dbmssoc3<p class=tl>
These codes, returned by the Winsock API, are listed in "Appendix A, Error Codes," of the <i>Windows Sockets Specification 1.1</i>. The <i>Windows Sockets Specification</i> can be found on the MSDN Library compact disc.</P></li>
<li>
dbmsspxn, dbmsspx3<p class=tl>
These codes, returned from Novell, are in <i>Novell NetWare Client Protocol Transport API for C</i> under the section for the API function listed in the <i>szErrorMsg</i>. For example, if the <i>pfNative</i> is 253, and <i>szErrorMsg</i> lists <b>SPXListenForSequencedPacket</b> as the function, the reference manual states a 0xFD (253) return from SPX Listen For Sequenced Packet is a Packet Overflow.</P></li>
<li>
dbmsvinn, dbmsvin3<p class=tl>
These codes, returned from Banyan Vines, are listed in the <i>Vines Client Developer's Guide</i>.</P></li>
<li>
dbmsrpcn, dbmsrpc3<p class=tl>
These codes, returned by the RPC API, are listed in the RPC section of Winerror.h.</P></li>
</ul>
<h4>Mapping SQLState Codes</h4>
<p>
The values for the SQLState code are listed in the <i>Microsoft ODBC 2.0 Programmer's Reference and SDK Guide</i>.</p>
</BODY>
</HTML>
