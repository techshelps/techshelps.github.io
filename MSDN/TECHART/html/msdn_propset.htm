<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE Property Sets Exposed</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_propset"></a></sup>OLE Property Sets Exposed</h1>
<p>
Charlie Kindel<br>
Program Manager, Windows NT/Cairo</p>
<p>
Created: August 27, 1993<br>
Updated: October 6, 1995</p>
<h2>Abstract</h2>
<p>
This article is designed to help you understand OLE persistent property sets and how to use them. Property sets are documented in the OLE 2.0 <i>Programmer's Reference</i>. Unfortunately, documentation in earlier versions of the OLE and Win32® software development kits (SDKs) were incomplete. Therefore, this document was originally created in an attempt to create a "one-stop shopping place" for OLE property set information. Today, the OLE property sets topic in the Win32 SDK is accurate; however, this article strives to explain OLE persistent property sets in more detail.</p>
<p>
Also included in this article are helpful code snippets and structure definitions that you may find useful when implementing property-set–related code. To some, this kind of information may be obvious, but for others it will save them the trouble of trying to figure it out themselves.</p>
<p>
This article assumes the reader is familiar with the overall architecture of OLE and understands the OLE structured storage model (in particular, the IStorage and IStream interfaces).</p>
<h2>1. What Are Persistent Property Sets?</h2>
<p class=indent>
<i>"Property sets are tagged collections of values, whose meaning (schema) is known to the code that manipulates them; that is, as much as that code needs to know the meaning."</i></p>
<p>
That's the first sentence from the section on property sets in the original OLE 2.0 <i>Programmer's Reference</i> (Appendix B, page 636). When I first read it, I said "Huh?" and read it again. It didn't help. As I read on, it became obvious that <i>someone</i> needed to document these things better.</p>
<h3>1.1. A Standard Structure</h3>
<p>
Property sets are a means of storing information in such a way that any conforming program can manipulate that information. OLE does not currently provide any code for manipulating property sets; all it does is specify a standard structure for a data format. However, future versions of Microsoft® operating systems may include component object module (COM)–style interfaces for accessing property sets and the properties they contain.</p>
<p>
Because the data format is made up of tagged collections of values, the data format is partially self-identifying. In other words, each <i>value</i> stored within a property set has a <i>type</i> associated with it that indicates how the value is stored. For example, if a specific property within a property set were to hold an animal's scientific name, that name would be stored as a zero-terminated string. Stored along with the name would be a type indicator that indicated that the value was a zero-terminated string. Any piece of code that knew the OLE property set data format could read (and write) the property that holds the animal's scientific name because the property would indicate that it was a zero-terminated string.</p>
<p>
Every property consists of three things: an <i>identifier</i>, a <i>type indicator</i>, and a <i>value</i>. Each property within a property set has a unique identifier, which is used to name the property. The type indicator describes the representation of the data in the value. For example, if the property contained a 2-byte (16-bit) integer specifying the number of legs an animal had, the property would look something like this:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=36%><b>Property Identifier</b></td>
<td class=label width=33%><b>Type Indicator</b></td>
<td class=label width=31%><b>Value</b></td>
</tr>
<tr valign=top>
<td width=36%>PID_LEGCOUNT</td>
<td width=33%>VT_I2</td>
<td width=31%>WORD</td>
</tr>
</table><br>
<p>
Again, any application that knows about property sets would be able to look at the property with an ID of PID_LEGCOUNT, recognize that it is a 2-byte integer (VT_I2), and extract the value. Of course, the given application might not know anything about animals, much less what legs are. The standard structure defined by OLE for property sets is generic with respect to the semantics of the properties being represented; it says nothing about what they mean.</p>
<p>
Each property set can have a dictionary associated with it. This dictionary provides a human-readable name for each of the property IDs that define the set. An application can read the dictionary of a property set and allow the user to pick and choose using informative names.</p>
<h3>1.2. Examples of Property Set Usage</h3>
<p>
In order to better illustrate what property sets are, several examples are in order. The first example shows how property sets can be stored within files to allow common access to the information represented by the property set. The second example shows how property sets can be transferred, or communicated, between applications or OLE objects.</p>
<h4>1.2.1. Storing Document Summary Information</h4>
<p>
One of the simplest and most commonly used property sets is the Summary Information property set. Most documents that are created by applications have a common set of attributes that are useful to users of those documents. These attributes include the author of the document, the subject of the document, when it was created, and so on. In the Microsoft Windows® 3.1 world, each application has a different way of storing this information within its documents. In order for a user to examine the summary information for a given document, it is necessary to run the application that created the document, open it, and invoke the application's Summary Information dialog box. The Summary Information dialog boxes that Microsoft Word 2.0 displayed for this document are shown below (Figures 1 and 2).</p>
<p>
<img src="propset_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Word for Windows 2.0 Summary Info dialog box</b></p>
<p>
<img src="propset_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Word for Windows Document Statistics dialog box</b></p>
<p>
Unfortunately, no application but Word for Windows 2.0 is going to be able to display the summary information for this document because Word 2.0 used a proprietary file format. Wouldn't it be great if <i>any</i> application could display the summary information stored in <i>any</i> document? Wouldn't it be neat if you could choose the File Properties menu item in the Windows File Manager and have it display the document summary information similar to that shown above for any file?</p>
<p>
Newer versions of Microsoft Word and many other OLE-enabled applications now save their documents using OLE structured storage, and store document summary information using the standard described here. The Windows 95 shell is able to display the summary information property set for <i>any </i>file, as long as that file is an OLE structured storage file, and the creating application saved the information in the OLE property set format. Right-click on any Word 6.0 document in the Windows 95 shell, and choose "Properties...". You'll see a property sheet that looks like this (Figure 3):</p>
<p>
<img src="propset_3.gif" border=0></p>
<p class=label>
<b>Figure 3. The Windows 95 File property sheet</b></p>
<p>
If you click on the Summary tab, the Windows 95 Summary Information property page is displayed (Figure 4). It shows the values of the properties for the document by opening the file and reading the summary information property set stream.</p>
<p>
<img src="propset_4.gif" border=0></p>
<p class=label>
<b>Figure 4. The Windows 95 Summary Information property page</b></p>
<p>
The Document Summary Information Property Set ("\005SummaryInformation") is the only property set actually proposed in the OLE specification (see the "Document Summary Information Property Set" topic in the Win32® SDK). </p>
<p>
Microsoft Office for Windows 95 introduced a second standard property set, called the "DocumentSummaryInformation" property set ("\005DocumentSummaryInformation"—a poor choice of names, considering how easily it is confused with the one above). This set can be thought of as an extension to the original SummaryInformation property set. The applications in Office 95 include a property page for viewing the DocumentSummaryInformation property set. (See the Microsoft Office Software Development Kit for more details on the DocumentSummaryInformation property set.)</p>
<h4>1.2.2. Transferring Data Contained in Property Sets</h4>
<p>
Storing information about what is contained inside a document is handy, and having a standard that allows all files to share the same information with all applications is even nicer. But SummaryInfo is only one example of how property sets can be used.</p>
<p>
Another use for property sets is in the transfer of data between OLE objects, or even applications. To illustrate this, we'll use an example from the Securities Industry (no, not <i>security</i> like alarms and dogs, but <i>securities</i> like stocks and bonds).</p>
<p>
Traders on Wall Street rely on large amounts of data, such as stock quotes and news stories, to make decisions regarding trades of securities. This data is referred to as <i>market data</i> and is delivered to traders' workstations in <i>real time</i> (or at least very soon after the data was generated). In this example, we are talking about transferring <i>real time market data</i> between two OLE objects.</p>
<p>
In this example we will ignore all securities except stocks, and we'll even simplify the model that Wall Street traders really use. . . after all, it's just an illustration.</p>
<p>
Let's assume that at any given time during an open day on Wall Street, we are interested in the opening, high, low, current, and last closing price of an instrument (a specific stock), and the volume that the stock has traded so far that day. The other piece of information we are interested in is the <i>ticker symbol</i> for the stock. Thus we have the following data items:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=13%><b>Item</b></td>
<td class=label width=87%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=13%>SYMBOL</td>
<td width=87%>The ticker symbol for the instrument we are interested in (for example, "MSFT").</td>
</tr>
<tr valign=top>
<td width=13%>OPEN</td>
<td width=87%>The price the instrument opened on (assume every instrument opens every working day).</td>
</tr>
<tr valign=top>
<td width=13%>CLOSE</td>
<td width=87%>The price of the instrument when the market last closed.</td>
</tr>
<tr valign=top>
<td width=13%>HIGH</td>
<td width=87%>The highest price of the instrument since it opened.</td>
</tr>
<tr valign=top>
<td width=13%>LOW</td>
<td width=87%>The lowest price of the instrument since it opened.</td>
</tr>
<tr valign=top>
<td width=13%>LAST</td>
<td width=87%>The last or current price of the instrument.</td>
</tr>
<tr valign=top>
<td width=13%>VOLUME</td>
<td width=87%>The number of shares of this instrument that have traded so far.</td>
</tr>
</table><br>
<p>
Let's assume that the trader wants to watch the above values for four different stocks during the day. That is, he or she wants his/her trading application to receive updates for these four stocks as their values change. For the sake of this example, we'll choose MSFT, IBM, AAPL, and BORL as the four stocks our trader wants to keep an eye on.</p>
<p>
Assume that the trader has installed on his/her workstation some sort of server that gets real time market data off the network and provides services to other applications on the system for accessing that data. Call this server application the <i>Data Server</i>. Also assume that the trader has on his/her workstation a "<i>Trader's Application</i>" that allows him or her to choose instruments to monitor and to make trades. This application communicates with the Data Server in some way to get the appropriate data updates.</p>
<p>
Without thinking about <i>how</i> the data is transferred between the Data Server and the Trader's Application, we can still think about <i>what</i> <i>data</i> is transferred and <i>what</i> <i>format</i> the data is in. Assume that the <i>what</i> is answered by the above table, and that the <i>format</i> is property sets.</p>
<p>
Recall that a property in a property set has three attributes: the property identifier, a value type indicator, and a value. For this example we can define the following properties:</p>
<p class=label>
<b>The FormatID_StockQuote Property Set Definition</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Property Identifier</b></td>
<td class=label width=24%><b>Type Indicator</b></td>
<td class=label width=49%><b>Value</b></td>
</tr>
<tr valign=top>
<td width=27%>PID_SYMBOL</td>
<td width=24%>VT_LPSTR</td>
<td width=49%>Zero-terminated string</td>
</tr>
<tr valign=top>
<td width=27%>PID_OPEN</td>
<td width=24%>VT_CY</td>
<td width=49%>Currency value</td>
</tr>
<tr valign=top>
<td width=27%>PID_CLOSE</td>
<td width=24%>VT_CY</td>
<td width=49%>Currency value</td>
</tr>
<tr valign=top>
<td width=27%>PID_HIGH</td>
<td width=24%>VT_CY</td>
<td width=49%>Currency value</td>
</tr>
<tr valign=top>
<td width=27%>PID_LOW</td>
<td width=24%>VT_CY</td>
<td width=49%>Currency value</td>
</tr>
<tr valign=top>
<td width=27%>PID_LAST</td>
<td width=24%>VT_CY</td>
<td width=49%>Currency value</td>
</tr>
<tr valign=top>
<td width=27%>PID_VOLUME</td>
<td width=24%>VT_I4</td>
<td width=49%>32-bit unsigned integer</td>
</tr>
</table><br>
<p>
Every property set must have a <i>Format Identifier</i> associated with it. The Format ID identifies the class of objects that know the <i>meaning</i> of the properties in the set. Let's call this set FormatID_StockQuote and refer to it from here on as the <i>StockQuote</i> property set.</p>
<p>
A single data element representing the stock of IBM during the day might look like this:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=31%>PID_SYMBOL </td>
<td width=69%>contains "IBM"</td>
</tr>
<tr valign=top>
<td width=31%>PID_OPEN</td>
<td width=69%>contains 42 3/4</td>
</tr>
<tr valign=top>
<td width=31%>PID_CLOSE</td>
<td width=69%>contains 42 3/4</td>
</tr>
<tr valign=top>
<td width=31%>PID_HIGH</td>
<td width=69%>contains 49 1/8</td>
</tr>
<tr valign=top>
<td width=31%>PID_LOW</td>
<td width=69%>contains 40 7/8</td>
</tr>
<tr valign=top>
<td width=31%>PID_LAST</td>
<td width=69%>contains 47 3/8</td>
</tr>
<tr valign=top>
<td width=31%>PID_VOLUME</td>
<td width=69%>contains 123,032</td>
</tr>
</table><br>
<p>
During a trading day on Wall Street only a few of the properties of a single instrument change. For example, the opening price doesn't change all day, and the low price may go unchanged for several hours. Using property sets as the data transfer format allows us to transfer <i>only the data that has changed</i>. For example, at some point during the day the Data Server may update the Trader's Application by transferring the following StockQuote property set:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=46%>PID_SYMBOL </td>
<td width=54%>contains "IBM"</td>
</tr>
<tr valign=top>
<td width=46%>PID_HIGH</td>
<td width=54%>contains 49 1/8</td>
</tr>
<tr valign=top>
<td width=46%>PID_LAST</td>
<td width=54%>contains 49 1/8</td>
</tr>
<tr valign=top>
<td width=46%>PID_VOLUME</td>
<td width=54%>contains 23,321</td>
</tr>
</table><br>
<p>
This example demonstrates how property sets can be used as a data transfer format, allowing sparse data representation. By transferring only the changed data, the overall performance of the trader's workstation is enhanced. As you can imagine, using property sets as a data transfer format has many advantages beyond this example.</p>
<h4>1.2.3. Properties of Arbitrary Objects</h4>
<p>
Another use of OLE persistent property sets, one that you will see a lot of in the future version of Windows NT™ (code-named "Cairo"), is to tag just about any object in the system with properties. Just as a word processor document can be tagged with a Summary Information property set containing properties such as "Author", a printer object could have a "Location" property. Another example would be a "User" object, which might have properties with names like "First Name", "Last Name", and "Office Number". </p>
<p>
Such pervasive use of property sets allows for very powerful querying capabilities. For example a user of Cairo will be able to essentially tell the system, "Find all printers in my building that understand PostScript™, have more than 4 MB of RAM, and have a full paper bin."</p>
<h3>1.3. Notes on Property Set Usage</h3>
<p>
It is important to note that the OLE designers intended that property sets be used to store data suited to representation as a collection of fine-grained values. The assumption was that the entire stream containing the property set would be read and/or written as a whole. Data sets that are too large for this to be feasible should be broken into separate streams and/or storages, which can be transacted, and so forth. It was not the intention of the OLE designers to provide a substitute for a database of millions of tiny objects.</p>
<h2>2. The Property Set Specification</h2>
<p>
OLE defines property sets; it does not provide any code or interfaces to manipulate them (although, as mentioned above, future Microsoft operating systems may include interfaces to manipulate property sets). This section describes the OLE persistent property set specification in detail.</p>
<h3>2.1. The Serialized Data Format</h3>
<p>
The OLE 2.0 specification defines a standard serialized format for property sets. This format has the following characteristics:
<ul type=disc>
<li>
It allows storage (using IStream or IStorage interfaces). Property sets may be stored in a single stream or in an IStorage instance that contains multiple streams.<br><br></li>
<li>
It allows communication (through IDataObject or the clipboard). Because property sets are self-identifying, they are ideal for transferring data between applications.<br><br></li>
<li>
It allows for extensibility. A property set may be defined as an extension of an existing property set, allowing readers to skip over unknown extensions and preserve them, while still extracting information from the properties that they do know.<br><br></li>
<li>
It allows for a dictionary of human-readable names to be included to further describe the contents.</li>
</ul>
<p>
Figure 5 shows the overall structure of the format.</p>
<p>
<img src="propset_5.gif" border=0></p>
<p class=label>
<b>Figure 5. Serialized format for property sets</b></p>
<p>
All data elements are stored in the Intel® representation (little endian). </p>
<p>
The overall length of this property set stream is limited to 256K bytes.</p>
<p>
Names in an IStorage that begin with the value '\0x05' are reserved exclusively for the storage of property sets. Streams or storages that begin with '\0x05' must therefore be in the format described below; storages so named must contain a "Contents" stream in the format. One of the things the inventor of a new standard property set does is specify the standard string name under which instances of that type are stored. For example, the summary information property set defined by OLE is always found under the name "\005SummaryInformation". The original OLE 2.0 specification provided no conventions for choosing this name; however, a convention for choosing such names has subsequently been specified and is discussed below. Use of this convention is required to enable the property set interfaces that will appear in future versions of Windows to open the property set.</p>
<p>
Given the overall picture of the serialized format in Figure 5, we can discuss the individual components of the format.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The OLE 2.0 specification for the serialized property set format allowed for more than one section, but use of that functionality is now discouraged and will not be supported through the property-related interfaces in future versions of Windows.</p>
<h4>2.1.1. Property Set Header</h4>
<p>
At the beginning of the property set stream is a header. The following structures illustrate the header:</p>
<pre><code>typedef struct PROPERTYSETHEADER
{
 &nbsp;&nbsp;&nbsp; // Header
 &nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp; wByteOrder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Always 0xFFFE
 &nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp; wFormat;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Always 0
 &nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp; dwOSVer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // System version
 &nbsp;&nbsp;&nbsp; CLSID&nbsp;&nbsp; clsid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Application CLSID
 &nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp; dwReserved;&nbsp;&nbsp;&nbsp;&nbsp; // Should be 1
} PROPERTYSETHEADER;
</code></pre>
<p>
Following are the definitions of the members of this structure.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=18%><b>Member</b></td>
<td class=label width=82%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=18%>wByteOrder</td>
<td width=82%>The byte-order indicator is a WORD and should always hold the value 0xFFFE. This is the same as the Unicode™ byte-order indicator. When written in little-endian (Intel) Intel byte order, this appears in the file or stream as 0xFe, 0xFF. </td>
</tr>
<tr valign=top>
<td width=18%>wFormat</td>
<td width=82%>The format version is a WORD and indicates the format version of this stream. Property set writers should write zero for this value. Property set readers should check this value; if it is non-zero, then they should refuse to read the set, for it is in a format that they don't in fact understand.</td>
</tr>
<tr valign=top>
<td width=18%>dwOSVer</td>
<td width=82%>The OS version number is encoded as OS kind in the high order word (0 for Windows on DOS, 1 for Macintosh, 2 for Windows NT) and the OS-supplied version number in the low order word. For Windows on DOS and Windows NT, the latter is the low order word of the result of GetVersion().</td>
</tr>
<tr valign=top>
<td width=18%>clsid</td>
<td width=82%>The class identifier is the CLSID of a class that can display and/or provide programmatic access to the property values. If there is no such class, it is recommended that the Format ID be used (see below), though a value of all zeros is also acceptable; the former simply allows for greater future extensibility.</td>
</tr>
<tr valign=top>
<td width=18%>dwReserved</td>
<td width=82%>Reserved for future use. A writer of a property set should write the value one here; however , a reader of a property set should only check that the value is at least one.</td>
</tr>
</table><br>
<p>
<b>2.1.1.1. Originating OS Version</b></p>
<p>
The dwOSVer DWORD should hold the operating system kind in the high WORD and the OS-supplied version number in the low WORD. Possible values for the operating system kind are:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Operating System Kind</b></td>
<td class=label width=50%><b>HIWORD of dwOSVer</b></td>
</tr>
<tr valign=top>
<td width=50%>16-Bit Windows (Win16)</td>
<td width=50%>0x0000</td>
</tr>
<tr valign=top>
<td width=50%>Macintosh®</td>
<td width=50%>0x0001</td>
</tr>
<tr valign=top>
<td width=50%>32-Bit Windows (Win32)</td>
<td width=50%>0x0002</td>
</tr>
</table><br>
<p>
For Windows, the operating system version is the low order word of GetVersion. For example, in Windows the following would correctly set the Originating OS Version:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;#ifdef WIN32
 &nbsp;&nbsp; dwOSVer = (DWORD)MAKELONG( LOWORD(GetVersion()), 2 ) ;
 &nbsp;&nbsp; #else
 &nbsp;&nbsp; dwOSVer = (DWORD)MAKELONG( LOWORD(GetVersion()), 0 ) ;
 &nbsp;&nbsp; #endif
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In previous versions of this document, dwReserved was documented as containing the count of sections in the property set. Since that time, the specification has been revised such that only one section is allowed.</p>
<h4>2.1.2. Format Identifier/Offset Pairs</h4>
<p>
Each Format Identifier/Offset pair (FIDO for short) both names and points to a section. The Format ID (FMTID) is represented in the same 16-byte format as OLE GUIDs (and CLSIDs) and uniquely identifies a section. The offset is the distance of bytes from the <i>start of the whole stream</i> to where the section begins. The Format ID is the semantic name of its corresponding section, telling how to interpret the property values therein.</p>
<p>
The following structure is helpful in dealing with Format Identifier/Offset pairs:</p>
<pre><code>typedef struct FORMATIDOFFSET
{
 &nbsp; FMTID&nbsp;&nbsp;&nbsp;&nbsp; fmtid ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // semantic name of a section
 &nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp; dwOffset ;&nbsp;&nbsp;&nbsp; // offset from start of whole property set 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // stream to the section
} <b>FORMATIDOFFSET</b>;
</code></pre>
<p>
See the "Format Identifiers" section for more information on Format IDs.</p>
<h4>2.1.3. Sections</h4>
<p>
Each section is made of up a property section header followed by an array that locates each property value within the section. Properties in this array are <i>not</i> sorted in any particular order. Offsets within this array are the distance from the start of the section to the start of the property (type, value) pair. This allows entire sections to be copied as an array of bytes without any translation of internal structure.</p>
<pre><code>typedef struct tagPROPERTYSECTIONHEADER
{
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbSection ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Size of section
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cProperties ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Count of properties in section
 &nbsp;&nbsp; PROPERTYIDOFFSET&nbsp;&nbsp; rgPropIDOffset[];&nbsp;&nbsp;&nbsp; // Array of property locations
} <b>PROPERTYSECTIONHEADER</b>
typedef struct PROPERTYIDOFFSET 
{
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propid;&nbsp;&nbsp;&nbsp;&nbsp; // name of a property
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwOffset;&nbsp;&nbsp; // offset from the start of the section to that 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // property type/value pair
} <b>PROPERTYIDOFFSET</b>;
</code></pre>
<p>
The members of this structure are described below.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=18%><b>Member</b></td>
<td class=label width=82%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=18%>cbSection</td>
<td width=82%>This DWORD indicates the size of the section. Having the section size as the first four bytes lets you copy and manipulate entire sections as VT_BLOB values without any translation of internal structure. </td>
</tr>
<tr valign=top>
<td width=18%>cProperties</td>
<td width=82%>This DWORD gives a count of the property values in the section.</td>
</tr>
<tr valign=top>
<td width=18%>rgPropIDOffset</td>
<td width=82%>An array of property ID/offset pairs. Property IDs are 32-bit values that uniquely identify a property within a section. The offsets indicate the distance from the start of the section to the start of the property type/value pair. By having the offsets relative to the section, sections can be copied as BLOBs.</td>
</tr>
</table><br>
<p>
Each property value contains a type tag followed by the bytes of the actual property value. The tag indicates the type of the property. All type/value pairs begin on a 32-bit boundary. Thus values may be followed with null bytes to align the subsequent pair on a 32-bit boundary (note though that there is no guarantee that property values are in fact as tightly packed in a section as this restriction permits; that is, there may be additional gratuitous padding).</p>
<pre><code>typedef struct SERIALIZEDPROPERTYVALUE 
{
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwType;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // type tag
 &nbsp;&nbsp; BYTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgb[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the actual property value
} <b>SERIALIZEDPROPERTYVALUE</b>;
</code></pre>
<p>
A consequence of these rules is that the smallest legal section, one containing zero properties, contains the following eight bytes: 08 00 00 00 00 00 00 00.</p>
<p>
As was mentioned above, all type/value pairs begin on a 32-bit boundary. It follows that in turn, the type indicators and values of a type value pair are so aligned. This means that values may be necessarily followed by null bytes to align a subsequent type/value pair.</p>
<p>
However, <i>within </i>a vector of values, each repetition of a value is to be aligned with its <i>natural </i>alignment rather than with 32-bit alignment. In practice, this is only significant for types VT_UI1, VT_I2, VT_UI2, and VT_BOOL (which have 2-byte natural alignment); all other types have 4-byte natural alignment. Therefore, a value with type tag VT_I2 | VT_VECTOR would be a DWORD element count, followed by a sequence of packed 2-byte integers with <i>no</i> padding between them; whereas a value of with type tag VT_LPSTR | VT_VECTOR would be a DWORD element count, followed by a sequence of (DWORD cch, char rgch[]) strings, each of which may be followed by null padding to round to a 32-bit boundary.</p>
<h4>2.1.5. Property Identifiers</h4>
<p>
Property identifiers are unsigned 32-bit values that uniquely identify a given property within a property set. As a designer of property sets, you can use any property ID with a value between 0x00000001 and 0x80000000, noninclusive. Properties with IDs of 0x00000000 and 0x00000001 are used for a dictionary of human-readable property names and a code page indicator, respectively. Property IDs with the high bit set (that is, greater than 0x80000000) are reserved for future use by Microsoft.</p>
<p>
<b>2.1.5.1. Property ID Zero: Property Set Dictionary</b></p>
<p>
To enable users of property sets to attach meaning to properties beyond those provided by the type indicator, property ID zero is reserved in all property sets for an optional dictionary giving human-readable names for the properties in the set and for the property set itself. The value is an array of (property ID, string) pairs. </p>
<p>
The value of property ID zero is an array of property ID/string pairs. Entries in the array are the IDs and corresponding names of the properties; these are not in any particular order with respect to their property IDs. Not all of the names of the properties in the set need appear in the dictionary: The dictionary may omit entries for properties that are assumed to be universally known by clients that manipulate the property set. Typically, names for the base property sets for widely accepted standards will be omitted.</p>
<p>
Property names that begin with the binary Unicode characters 0x0001 through 0x001F are reserved for future use.</p>
<p>
The name indicated as corresponding to property ID zero is to be interpreted as the human-readable name of the property set itself; like all property names, this may or may not be present.</p>
<p>
The dictionary is stored as a list of property ID/string pairs; the code page for the strings involved is as indicated in property ID one. This can be illustrated using the following pseudo-structure definition for a dictionary entry (it is a pseudo-structure because the sz[] member is variable size):</p>
<pre><code>typedef struct tagENTRY {
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; propid;&nbsp; // Property ID
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; cb;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Count of bytes in the string, including the null 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // at the end.
 &nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp; sz[cb];&nbsp; // Zero-terminated string. Code page as indicated 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // by property ID one.
 &nbsp;&nbsp; } <b>ENTRY</b>;
typedef struct tagDICTIONARY {
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; cEntries;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Count of entries in the list.
 &nbsp;&nbsp; ENTRY&nbsp;&nbsp;&nbsp; rgEntry[cEntries]; 
 &nbsp;&nbsp; } <b>DICTIONARY</b>;
</code></pre>
<p>
Note the following:
<ul type=disc>
<li>
Property ID zero does not have a type indicator. The DWORD that indicates the count of entries sits in the usual type indicator position (apologies to those who are confused).<br><br></li>
<li>
The count of bytes in the string (cb) includes the zero character that terminates the string.<br><br></li>
<li>
If the code page indicator is not 1200 (Unicode), there is no padding between entries to achieve reasonable alignment. However, if the code page indicator is Unicode, each entry should be aligned on a DWORD boundary.<br><br></li>
<li>
If the code page indicator is not 1200 (Unicode), property names are stored double-byte character strings (DBCS). If the code page indicator does indicate Unicode, property name strings are stored as Unicode.<br><br></li>
<li>
Property name strings are restricted in length to 128 characters including the NULL terminating character. </li>
</ul>
<p>
The following example may be useful to help illustrate the dictionary format:</p>
<p>
The property set described in the second example in the introduction of this paper (real time stock market data transfer example) might have a human-readable name of "Stock Quote" for the entire set and "Ticker Symbol" for PID_SYMBOL (#define PID_SYMBOL 7). If a property set contained just a symbol ("MSFT") and the dictionary, the property set section would have a byte stream that looked like the following:</p>
<pre><code>Offset&nbsp;&nbsp;&nbsp;&nbsp; Bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
; Start of section
0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 43 01 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD size of section
0004&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 04 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD number of properties in section
; Start of PropID/Offset pairs
0008&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD Property ID (0 == dictionary)
000C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD offset to property ID
0010&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD Property ID (1 == code page)
0014&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD offset to property ID
0018&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 07 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD Property ID (i.e. PID_SYMBOL)
001C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD offset to property ID
; Start of Property 0 (which is really the dictionary
0020&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 08 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD Number of entries in dictionary
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; (Note: No type indicator!)
0024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD dwPropID = 0
0028&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD cb = (wstrlen("Stock Quote")+1) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; * sizeof(WCHAR) == 24
002C&nbsp;&nbsp;&nbsp; L"Stock Quote\0"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; char sz[24]
0044&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 03 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD dwPropID = 3 (PID_SYMBOL)
0048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1C 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD cb = (wstrlen("Ticker 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Symbol")+1) * sizeof(WCHAR) == 28
003C&nbsp;&nbsp;&nbsp; L"Ticker Symbol\0"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; char sz[28]
... ; dictionary would continue, but may not contain entries for
 &nbsp;&nbsp; ; every possible entry. Also, entries do not need to be in order
 &nbsp;&nbsp; ; (except dwPropID == 0 must be first).
; Start of Property 1 (code page indicator)
00D0&nbsp;&nbsp;&nbsp; 02 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD type indicator (VT_I2)
00D4&nbsp;&nbsp;&nbsp; B0 04 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; USHORT codepage (0x04B0 == 1200 == Unicode)
; Start of Property 7 (PID_SYMBOL)
0134&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1E 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD type indicator (VT_LPWSTR == 1F)
0138&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DWORD count of bytes
013C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L"MSFT\0"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; WCHAR sz[5] (+ 2 bytes for the NULL)
</code></pre>
<p>
<b>2.1.5.2. Property ID Ox00000001: Code Page Indicator</b></p>
<p>
Property ID one (0x00000001) is reserved as an indicator of which code page or script any not-always-Unicode strings in the property set originated from (code pages are used in Windows and scripts are from the Macintosh world). All such string values in the entire property set, such as VT_LPSTRs, VT_BSTRs, and the names in the property name dictionary found in property ID zero, use characters from this one code page. If the code page indicator is not present, the prevailing code page on the reader's machine must be assumed (use the Win32 API <b>GetACP</b> to determine the current code page). If an application cannot understand the indicated code page, it should not try to modify strings stored in the property set.</p>
<p>
When an application that is not the author of a property set changes a property of type string in the set, it should examine the code page indicator and take one of the following courses of action:
<ul type=disc>
<li>
Write the new value using the code page found in the code page indicator.<br><br></li>
<li>
Rewrite all string values in the property set using the new code page (including the new value), and modify the code page indicator to reflect the new code page.</li>
</ul>
<p>
Possible values for the code page indicator are given in the Win32 API reference (see the <b>NLSAPI</b> functions, and specifically the <b>GetACP</b> function) and <i>Inside Macintosh Volume VI</i>, §14-111. For example, the code page US ANSI is represented by 0x04e4 (or 1252 in decimal); the code page for Unicode is 1200. Whether a Windows code page or a Macintosh script is found in property ID one is determined by the "originating OS version" (PROPERTYSETHEADER::dwOSVer) of the property set as a whole. Note that Windows code page equivalents exist for the Macintosh scripts numbers (Windows code page 10000, for example, is the Macintosh Roman script).</p>
<p>
<i>It is strongly recommended that the Unicode code page (1200) be used</i>. This is the only practical way to achieve worldwide interoperable property sets. In code page 1200, note especially that the count at the start of a VT_LPSTR or VT_BSTR is to be interpreted as a <i>byte</i> count, not a <i>character</i> count. The byte count includes the two zero bytes at the end of the string.</p>
<p>
Property ID one is of type VT_I2, and therefore consists of a DWORD containing VT_I2 followed by a USHORT indicating the code page. For example, the type/value pair for property ID one representing the US ANSI code page is the following six bytes:</p>
<pre><code>02 00 00 00 e4 04
</code></pre>
<p>
plus any necessary padding.</p>
<p>
<b>2.1.5.3. Property ID 0x80000000: Locale Indicator</b></p>
<p>
Property ID 0x80000000 (PID_LOCALE) is reserved as an indication of which locale the property set was written in. The default locale for a property set, in the event that PID_LOCALE does not exist in the property set, will be the system's default locale (LOCALE_SYSTEM_DEFAULT).</p>
<p>
Applications can choose to support the locale or accept the default behavior. Applications that allow users to specify a working locale should write that locale identifier to this property. Applications that use the user's default locale (LOCALE_USER_DEFAULT) should write the user's default locale identifier.</p>
<p>
Applications should be concerned with the possibility of getting information from a property set that is of a different locale than that of the application, the user, or the system (that is, a foreign object).</p>
<p>
Property ID PID_LOCALE is of type VT_U4, and therefore consists of a DWORD containing VT_U4 followed by a DWORD containing the Locale Identifier (LCID) as defined by Appendix C of the Win32 SDK.</p>
<h4>2.1.6. Type Indicators</h4>
<p>
A property pair (type, value) is a DWORD type indicator, followed by a value whose representation depends on the type. The serialized representations of each of the different types of values are as follows:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Type indicator</b></td>
<td class=label width=71%><b>Value Representation</b></td>
</tr>
<tr valign=top>
<td width=29%>VT_EMPTY</td>
<td width=71%>No bytes.</td>
</tr>
<tr valign=top>
<td width=29%>VT_NULL</td>
<td width=71%>No bytes.</td>
</tr>
<tr valign=top>
<td width=29%>VT_I2</td>
<td width=71%>2-byte signed integer.</td>
</tr>
<tr valign=top>
<td width=29%>VT_I4</td>
<td width=71%>4-byte signed integer.</td>
</tr>
<tr valign=top>
<td width=29%>VT_R4</td>
<td width=71%>32-bit IEEE floating-point value.</td>
</tr>
<tr valign=top>
<td width=29%>VT_R8</td>
<td width=71%>64-bit IEEE floating point value.</td>
</tr>
<tr valign=top>
<td width=29%>VT_CY</td>
<td width=71%>8-byte two's complement integer (scaled by 10,000).</td>
</tr>
<tr valign=top>
<td width=29%>VT_DATE</td>
<td width=71%>A 64-bit floating-point number representing the number of days (not seconds) since December 31, 1899. (That is, January 1, 1900, is 2.0, January 2, 1900, is 3.0, and so on.) This is stored in the same representation as VT_R8.</td>
</tr>
<tr valign=top>
<td width=29%>VT_BSTR</td>
<td width=71%>Counted, null terminated binary string; represented as a DWORD byte count of the number of bytes in the string (including the terminating null) followed by the bytes of the string. Character set is as indicated by the code page indicator.</td>
</tr>
<tr valign=top>
<td width=29%>VT_ERROR</td>
<td width=71%>A DWORD containing a status code.</td>
</tr>
<tr valign=top>
<td width=29%>VT_BOOL</td>
<td width=71%>A Boolean (WORD) value containing 0 (false) or -1 (true).</td>
</tr>
<tr valign=top>
<td width=29%>VT_VARIANT</td>
<td width=71%>A type indicator (a DWORD) followed by the corresponding value. VT_VARIANT is only used in conjunction with VT_VECTOR: see below.</td>
</tr>
<tr valign=top>
<td width=29%>VT_UI1</td>
<td width=71%>1-byte unsigned integer.</td>
</tr>
<tr valign=top>
<td width=29%>VT_UI2</td>
<td width=71%>2-byte unsigned integer.</td>
</tr>
<tr valign=top>
<td width=29%>VT_UI4</td>
<td width=71%>4-byte unsigned integer.</td>
</tr>
<tr valign=top>
<td width=29%>VT_I8</td>
<td width=71%>8-byte signed integer.</td>
</tr>
<tr valign=top>
<td width=29%>VT_UI8</td>
<td width=71%>8-byte unsigned integer.</td>
</tr>
<tr valign=top>
<td width=29%>VT_LPSTR</td>
<td width=71%>This is the representation of many strings. It is stored in the same representation as VT_BSTR. Note that the serialized representation of VT_LPSTR has a preceding byte count, whereas the in-memory representation does not. Character set is as indicated by the code page indicator.</td>
</tr>
<tr valign=top>
<td width=29%>VT_LPWSTR</td>
<td width=71%>A counted and null terminated Unicode string; a DWORD character count (where the count includes the terminating null) followed by that many Unicode (16-bit) characters. Note that the count is a character count, not a byte count.</td>
</tr>
<tr valign=top>
<td width=29%>VT_FILETIME</td>
<td width=71%>64-bit FILETIME structure, as defined by Win32.</td>
</tr>
<tr valign=top>
<td width=29%>VT_BLOB</td>
<td width=71%>A DWORD count of bytes, followed by that many bytes of data. The byte count does not include the four bytes for the length of the count itself: An empty blob would have a count of zero, followed by zero bytes. Thus, the serialized representation of a VT_BLOB is similar to that of a VT_BSTR but does not guarantee a null byte at the end of the data.</td>
</tr>
<tr valign=top>
<td width=29%>VT_STREAM</td>
<td width=71%>Indicates the value is stored in a stream that is sibling to the CONTENTS stream. Following this type indicator is data in the format of a serialized VT_LPSTR, which names the stream containing the data.</td>
</tr>
<tr valign=top>
<td width=29%>VT_STORAGE</td>
<td width=71%>Indicates the value is stored in an <b>IStorage</b> that is sibling to the "CONTENTS" stream. Following this type indicator is data in the format of a serialized VT_LPSTR, which names the <b>IStorage</b> containing the data.</td>
</tr>
<tr valign=top>
<td width=29%>VT_STREAMED_OBJECT</td>
<td width=71%>Same as VT_STREAM, but indicates that the stream contains a serialized object, which is a class ID followed by initialization data for the class.</td>
</tr>
<tr valign=top>
<td width=29%>VT_STORED_OBJECT</td>
<td width=71%>Same as VT_STORAGE, but indicates that the designated <b>IStorage</b> contains a loadable object.</td>
</tr>
<tr valign=top>
<td width=29%>VT_BLOB_OBJECT</td>
<td width=71%>A BLOB containing a serialized object in the same representation as would appear in a VT_STREAMED_OBJECT. That is, following the VT_BLOB_OBJECT tag is a DWORD byte count of the remaining data (where the byte count does not include the size of itself) which is in the format of a class ID followed by initialization data for that class.<p>
The only significant difference between VT_BLOB_OBJECT and VT_STREAMED_OBJECT is that the former does not have the system-level storage overhead that the latter would have, and is therefore more suitable for scenarios involving numbers of small objects.</p>
</td>
</tr>
<tr valign=top>
<td width=29%>VT_CF</td>
<td width=71%>A BLOB containing a clipboard format identifier followed by the data in that format. That is, following the VT_CF tag is data in the format of a VT_BLOB: a DWORD count of bytes, followed by that many bytes of data in the format of a packed VTCFREP (described just below), followed immediately by an array of bytes as appropriate for data in the clipboard format format (text, metafile, or whatever).</td>
</tr>
<tr valign=top>
<td width=29%>VT_CLSID</td>
<td width=71%>A class ID (or other GUID).</td>
</tr>
<tr valign=top>
<td width=29%>VT_VECTOR</td>
<td width=71%>If the type indicator is one of the above values with this bit on in addition, the value is a DWORD count of elements, followed by that many repetitions of the value.<p>
For example, a type indicator of VT_LPSTR | |VT_VECTOR has a DWORD element count, a DWORD byte count, the first string data, a DWORD byte count, the second string data, and so on.</p>
</td>
</tr>
</table><br>
<p>
Clipboard format identifiers, stored with the tag VT_CF, use one of five different representations:</p>
<pre><code>typedef struct VTCFREP {
 &nbsp;&nbsp; LONG&nbsp;&nbsp;&nbsp; lTag;
 &nbsp;&nbsp; BYTE&nbsp;&nbsp;&nbsp; rgb[];
 &nbsp;&nbsp; } <b>VTCFREP</b>;
</code></pre>
<p>
The values for RGB are determined by the different values for lTag:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=17%><b>lTag Value</b></td>
<td class=label width=83%><b>RGB Value</b></td>
</tr>
<tr valign=top>
<td width=17%>-1L</td>
<td width=83%>A DWORD containing a built-in Windows clipboard format value.</td>
</tr>
<tr valign=top>
<td width=17%>-2L</td>
<td width=83%>A DWORD containing a Macintosh clipboard format value.</td>
</tr>
<tr valign=top>
<td width=17%>-3L</td>
<td width=83%>A GUID containing a format identifier (seldom used).</td>
</tr>
<tr valign=top>
<td width=17%>Any positive value</td>
<td width=83%>A null-terminated string containing a Windows clipboard format name, one suitable for passing to <b>RegisterClipboardFormat</b>. The code page used for characters in the string is per the code page indicator. The "positive value" here is the length of the string, including the null byte at the end.</td>
</tr>
<tr valign=top>
<td width=17%>0L</td>
<td width=83%>No data (rarely used).</td>
</tr>
</table><br>
<p>
All type/value pairs begin on a 32-bit boundary. Thus values may be followed with null bytes to align the subsequent pair on a 32-bit boundary. Given a count of bytes, the following code will calculate how many bytes are needed to align on a 32-bit boundary:</p>
<pre><code>cbAdd = (((cbCurrent + 3) &gt;&gt; 2) &lt;&lt; 2) - cbCurrent ;
</code></pre>
<p>
<b>2.1.6.1. Defining New Types</b></p>
<p>
There is no provision for adding new type indicators to the list above. Property sets are designed to be partially self-describing, such that code that does not know all about the property set can at least tell the types of values contained in it. If new VT tags were allowed to be defined, it would be impossible for code to skip over values that are not understood. However, new types <i>can</i> be defined by using the VT_VARIANT type combined with the VT_VECTOR flag. For example, assume you wanted to store the following packed structure in a property set:</p>
<pre><code>typedef struct tagPACKED
{
 &nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; dwValue1 ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 32 bit value
 &nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wFlag ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 16 bits of flags
 &nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wValue2 ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 16 bit value
} PACKED ;
</code></pre>
<p>
This 64 bit structure could be stored using VT_VARIANT | VT_VECTOR as follows:</p>
<pre><code>DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // dwTypeIndicator = VT_VARIANT | VT_VECTOR ;
DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // dwElementCount = 3 ;
DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // dwTypeIndicator = VT_I4 ;
DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // dwValue1 ;
DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // dwTypeIndicator = VT_I2 ;
WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wFlag ;
DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // dwTypeIndicator = VT_I2 ;
WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wValue2 ;
</code></pre>
<h4>2.1.7. Storing Property Sets</h4>
<p>
OLE 2.0 provides standard facilities for storing documents to the file system (OLE 2.0 Structured Storage). The interfaces for doing this are IStorage, IStream, and so on. It is logical (and useful) for property sets to be stored in documents, and OLE 2.0 specifies how they should be stored so that other applications can find and manipulate the information.</p>
<p>
If the property set you are storing is internal to your application, you may not want to adhere to the rules described here. On the other hand, if you want to expose your property set to other applications, you need to follow these rules:
<ul type=disc>
<li>
Name the IStorage or IStream that the property set is stored in using the algorithm described in the section below titled "Property Set Stream and Storage Names".<br><br></li>
<li>
Store your property set in a single IStream instance or an IStorage instance that contains multiple streams.<br><br></li>
<li>
If you use an IStorage, the contained stream named CONTENTS is the primary stream containing the property values. Set the class ID of the IStorage to be the same as the class ID stored in the property set.<br><br></li>
<li>
Properties with VT_STREAM, VT_STORAGE, VT_STREAMED_OBJECT, VT_STORED_OBJECT, and VT_BLOB_OBJECT types have as a value the name of a stream or storage that is a sibling to the stream in which the&nbsp; property set is stored. These type indicators are only valid when the property set is stored in an IStorage; they are not legal if the property set is stored in an IStream.</li>
</ul>
<h4>2.1.7. Property Set Stream and Storage Names</h4>
<p>
Persistent property sets are named within the format with Format IDs (FMTID); but in an IStorage or IStream, they are named using strings with a maximum length of 32 characters. In addition, all OLE persistent property sets stored in a stream or storage must have "\005" as the first character of the stream or storage name. A normal "string-ized" version of an FMTID contains 38 characters (for example, "{F29F85E0-4FF9-1068-AB91-08002B27B3D9}"). How can we squeeze this down to fit in the space legally allowed for IStorage and IStream names?</p>
<p>
The first task is to establish a mapping between FMTIDs and strings. Converting in one direction, we have in hand an FMTID, and need a corresponding string name. First, we check whether the FMTID is one of a fixed set of well-known values, and use the corresponding well-known string name (from the following table) if so. (The first FMTID was defined as part of OLE2; the second one was defined by Microsoft Office.)</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=46%><b>FMTID</b></td>
<td class=label width=33%><b>String Name</b></td>
<td class=label width=21%><b>Semantic</b></td>
</tr>
<tr valign=top>
<td width=46%>F29F85E0-4FF9-1068-AB91-08002B27B3D9</td>
<td width=33%>\005SummaryInformation</td>
<td width=21%>OLE2 summary information</td>
</tr>
<tr valign=top>
<td width=46%>D5CDD502-2E9C-101B-9397-08002B2CF9AE</td>
<td width=33%>\005DocumentSummaryInformation</td>
<td width=21%>Office 95 document summary information</td>
</tr>
</table><br>
<p>
Otherwise, we algorithmically form a string name as follows: First, convert the FMTID to little-endian byte order if necessary. Then take the FMTID and consider it as one long bit string (128 bits) by concatenating each of the bytes together. The first bit of the 128-bit value is the most significant bit of the first byte in memory of the FMTID; the last bit of the 128-bit value is the least significant bit of the last byte in memory of the FMTID. Extend these 128 bits to 130 bits by adding two zero bits to the end. Next, chop the 130 bits into groups of 5 bits; there will be 26 such groups. Consider each group as an integer, and map it as an index into the array of 32 characters:</p>
<p>
ABCDEFGHIJKLMNOPQRSTUVWXYZ012345</p>
<p>
This yields a sequence of 26 Unicode characters that uses only uppercase characters and numerals. Note that no two characters in this range compare equally in a case-insensitive manner in any locale. The final string is the concatenation of the string "\005" with these 26 characters, for a total length of 27 characters.</p>
<p>
The name-to-FMTID mapping is the obvious inverse of the above. However, converters of property string names to GUIDs should accept lowercase letters as synonymous with their uppercase counterparts.</p>
<p>
For example, assume there is a class of applications that edit information about animals (such as a database of all pets in a city). We define a class ID (CLSID_AnimalApp = {43D67B39-E3BA-11ce-9050-080036F12502}) for this set of applications so they can indicate that they understand property sets containing animal information (FormatID_AnimalInfo = {43D67B3A-E3BA-11ce-9050-080036F12502}) and property sets containing medical information (FormatID_MedicalInfo = {43D67B3B-E3BA-11ce-9050-080036F12502}). One possible way of storing the information about a specific animal (in this case, my dog, Revo) is given below. This implementation stores the animal information property set in an IStream:</p>
<pre><code>IStorage (File): "C:\OLE\REVO.DOC" CLSID = CLSID_AnimalApp
 &nbsp;&nbsp; // AnimalInfo 
 &nbsp;&nbsp; IStream: "\0050z4m3bjxDxtdbickIaamtyxeCa" 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD dwByteOrder, WORD wFmtVersion, DWORD dwOSVer, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSID CLSID_AnimalApp, DWORD cSections...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FormatID = FormatID_AnimalInfo
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Property: ID = PID_ANIMALTYPE, Type = VT_LPSTR, Value = "Dog"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Property: ID = PID_ANIMALNAME, Type = VT_LPSTR, Value = "Revo"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Property: ID = PID_MEDICALHISTORY, Type = VT_STREAM, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value = "\005MedicalInfo"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp; // MedicalInfo 
 &nbsp;&nbsp; IStream: "\0051z4m3bjxDxtdbickIaamtyxeCa" 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD dwByteOrder, WORD wFmtVersion, DWORD dwOSVer, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSID CLSID_AnimalApp, DWORD cSections...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FormatID = CLSID_MedicalInfo
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Property: ID = PID_VETNAME, Type = VT_LPSTR, Value = "Dr. Woof"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Property: ID = PID_LASTEXAM, Type = VT_DATE, Value = ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp;&nbsp; ...
</code></pre>
<p>
Note that the class IDs of the IStorage and both property sets is CLSID_AnimalApp. CLSID_AnimalApp identifies any application that can display and/or provide programmatic access to these property sets. Any application can read the information within the property sets (which is the point of property sets), but only applications identified with the class ID of CLSID_AnimalApp can <i>understand the meaning</i> of the data in the property sets.</p>
<p>
Applications should be written to expect that a property set may be stored in either an IStorage or IStream, unless the property set definition indicates otherwise. For example, the SummaryInformation property set has in its definition that it can only be stored in a named IStream. In the cases where you are searching for a property set, and you do not know whether it is in a storage or stream, it is suggested that you look for an IStream with your property set name first; then, if that fails, look for an IStorage.</p>
<h3>2.2. Sample Code to Convert To and From Property Set Names</h3>
<p>
The sample application below is a console application that can convert an FMTID to a property set name and vice versa.</p>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1993 - 1995&nbsp; Microsoft Corporation. All Rights Reserved.
//
//&nbsp; MODULE:&nbsp;&nbsp; propsetname.cpp
//
//&nbsp; PURPOSE:&nbsp; Convert between OLE persistent property set names and
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Format IDs (FMTIDs).
//
//&nbsp; FUNCTIONS:
//
//&nbsp; COMMENTS:
//&nbsp;&nbsp;&nbsp; Comply with "cl propsetname.cpp /link ole32.lib"
//&nbsp;&nbsp; 
//
#define _INC_OLE
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#define CBIT_CHARMASK&nbsp;&nbsp; 5
#define CBIT_BYTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8
#define CBIT_GUID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (CBIT_BYTE * sizeof(GUID))
#define CWC_PROPSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 + (CBIT_GUID + CBIT_CHARMASK-1)/CBIT_CHARMASK)
#define WC_PROPSET0&nbsp;&nbsp;&nbsp;&nbsp; ((WCHAR) 0x0005)
#define CCH_MAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; CBIT_CHARMASK)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 32
#define CHARMASK&nbsp;&nbsp;&nbsp; (CCH_MAP - 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 0x1f
CHAR awcMap[CCH_MAP + 1] = "abcdefghijklmnopqrstuvwxyz012345";
#define CALPHACHARS&nbsp;&nbsp;&nbsp; ('z' - 'a' + 1)
GUID guidSummary =
 &nbsp;&nbsp; { 0xf29f85e0,
 &nbsp;&nbsp;&nbsp;&nbsp; 0x4ff9, 0x1068,
 &nbsp;&nbsp;&nbsp;&nbsp; { 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9 } };
WCHAR wszSummary[] = L"SummaryInformation";

GUID guidDocumentSummary =
 &nbsp;&nbsp; { 0xd5cdd502,
 &nbsp;&nbsp;&nbsp;&nbsp; 0x2e9c, 0x101b,
 &nbsp;&nbsp;&nbsp;&nbsp; { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };
WCHAR wszDocumentSummary[] = L"DocumentSummaryInformation";

__inline WCHAR
MapChar(IN ULONG i)
{
 &nbsp;&nbsp; return((WCHAR) awcMap[i &amp; CHARMASK]);
}

//+--------------------------------------------------------------------------
// Function:&nbsp;&nbsp;&nbsp; GuidToPropertySetName
//
// Synopsis:&nbsp;&nbsp;&nbsp; Map property set GUID to null-terminated UNICODE name string.
//
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The awcname parameter is assumed to be a buffer with room for
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWC_PROPSETSZ (28) UNICODE characters. The first character
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is always WC_PROPSET0 (0x05), as specified by the OLE Appendix
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B documentation. The colon character normally used as an NT
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stream name separator is not written to the caller's buffer.
//
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; No error is possible.
//
// Arguments:&nbsp;&nbsp; IN GUID *pguid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- pointer to GUID to convert
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT WCHAR awcname[] -- output string buffer
//
// Returns:&nbsp;&nbsp;&nbsp;&nbsp; count of non-NULL characters in the output string buffer
//---------------------------------------------------------------------------
ULONG GuidToPropertySetName( IN GUID const *pguid, OUT WCHAR awcname[])
{
 &nbsp;&nbsp; BYTE *pb = (BYTE *) pguid;
 &nbsp;&nbsp; BYTE *pbEnd = pb + sizeof(*pguid);
 &nbsp;&nbsp; ULONG cbitRemain = CBIT_BYTE;
 &nbsp;&nbsp; WCHAR *pwc = awcname;
 &nbsp;&nbsp; *pwc++ = WC_PROPSET0;
 &nbsp;&nbsp; // Note: CWC_PROPSET includes the WC_PROPSET0, and sizeof(wsz...)
 &nbsp;&nbsp; // includes the trailing L'\0', so sizeof(wsz...) is OK because the
 &nbsp;&nbsp; // WC_PROPSET0 character compensates for the trailing NULL character.
 &nbsp;&nbsp; //ASSERT(CWC_PROPSET &gt;= sizeof(wszSummary)/sizeof(WCHAR));
 &nbsp;&nbsp; if (*pguid == guidSummary)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; RtlCopyMemory(pwc, wszSummary, sizeof(wszSummary));
 &nbsp;&nbsp; return(sizeof(wszSummary)/sizeof(WCHAR));
 &nbsp;&nbsp; }
 &nbsp;&nbsp; //ASSERT(CWC_PROPSET &gt;= sizeof(wszDocumentSummary)/sizeof(WCHAR));
 &nbsp;&nbsp; if (*pguid == guidDocumentSummary)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; RtlCopyMemory(pwc, wszDocumentSummary, sizeof(wszDocumentSummary));
 &nbsp;&nbsp; return(sizeof(wszDocumentSummary)/sizeof(WCHAR));
 &nbsp;&nbsp; }
 &nbsp;&nbsp; while (pb &lt; pbEnd)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; ULONG i = *pb &gt;&gt; (CBIT_BYTE - cbitRemain);
 &nbsp;&nbsp; if (cbitRemain &gt;= CBIT_CHARMASK)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pwc = MapChar(i);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cbitRemain == CBIT_BYTE &amp;&amp; *pwc &gt;= L'a' &amp;&amp; *pwc &lt;= L'z')
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pwc += (WCHAR) (L'A' - L'a');
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwc++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbitRemain -= CBIT_CHARMASK;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cbitRemain == 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbitRemain = CBIT_BYTE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (++pb &lt; pbEnd)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i |= *pb &lt;&lt; cbitRemain;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pwc++ = MapChar(i);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbitRemain += CBIT_BYTE - CBIT_CHARMASK;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; *pwc = L'\0';
 &nbsp;&nbsp; return(CWC_PROPSET);
}

//+--------------------------------------------------------------------------
// Function:&nbsp;&nbsp;&nbsp; NtPropertySetNameToGuid
//
// Synopsis:&nbsp;&nbsp;&nbsp; Map non-null-terminated UNICODE string to a property set GUID.
//
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If the name is not properly formed as per
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NtGuidToPropertySetName(), STATUS_INVALID_PARAMETER is
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returned. The pguid parameter is assumed to point to a buffer
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with room for a GUID structure.
//
// Arguments:&nbsp;&nbsp; IN ULONG cwcname&nbsp;&nbsp; -- count of WCHARs in string to convert
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IN WCHAR awcname[] -- input string to convert
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT GUID *pguid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- pointer to buffer for converted GUID
//
// Returns:&nbsp;&nbsp;&nbsp;&nbsp; NTSTATUS
//---------------------------------------------------------------------------
HRESULT PropertySetNameToGuid(IN ULONG cwcname,IN WCHAR const awcname[],OUT GUID *pguid)
{
 &nbsp;&nbsp; HRESULT Status = E_INVALIDARG;
 &nbsp;&nbsp; WCHAR const *pwc = awcname;
 &nbsp;&nbsp; if (pwc[0] == WC_PROPSET0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Note: cwcname includes the WC_PROPSET0, and sizeof(wsz...)
 &nbsp;&nbsp; // includes the trailing L'\0', but the comparison excludes both
 &nbsp;&nbsp; // the leading WC_PROPSET0 and the trailing L'\0'.
 &nbsp;&nbsp; if (cwcname == sizeof(wszSummary)/sizeof(WCHAR) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcsnicmp(&amp;pwc[1], wszSummary, cwcname - 1) == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pguid = guidSummary;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(S_OK);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; if (cwcname == sizeof(wszDocumentSummary)/sizeof(WCHAR) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcsnicmp(&amp;pwc[1], wszDocumentSummary, cwcname - 1) == 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pguid = guidDocumentSummary;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(S_OK);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; if (cwcname == CWC_PROPSET)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG cbit;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BYTE *pb = (BYTE *) pguid - 1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RtlZeroMemory(pguid, sizeof(*pguid));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (cbit = 0; cbit &lt; CBIT_GUID; cbit += CBIT_CHARMASK)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG cbitUsed = cbit % CBIT_BYTE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG cbitStored;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WCHAR wc;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cbitUsed == 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc = *++pwc - L'A';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Assume uppercase
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (wc &gt; CALPHACHARS)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc += (WCHAR) (L'A' - L'a');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Oops, try lowercase
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (wc &gt; CALPHACHARS)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc += L'a' - L'0' + CALPHACHARS;&nbsp;&nbsp;&nbsp; // Must be a digit
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (wc &gt; CHARMASK)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto fail;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Invalid character
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pb |= (BYTE) (wc &lt;&lt; cbitUsed);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbitStored = min(CBIT_BYTE - cbitUsed, CBIT_CHARMASK);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the translated bits wouldn't all fit in the current byte
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cbitStored &lt; CBIT_CHARMASK)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc &gt;&gt;= CBIT_BYTE - cbitUsed;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cbit + cbitStored == CBIT_GUID)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (wc != 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto fail;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // extra bits
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pb |= (BYTE) wc;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Status = S_OK;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; }
fail:
 &nbsp;&nbsp; return(Status);
}
//---------------------------------------------------------------------------
// Function:&nbsp;&nbsp;&nbsp; Usage
//
// Synopsis:&nbsp;&nbsp;&nbsp; Spits out usage information and exits.
//---------------------------------------------------------------------------
void Usage(char * pszProgramName)
{
 &nbsp;&nbsp; fprintf(stderr, "\nUsage:&nbsp; %s [&lt;fmtid&gt; | &lt;propset name&gt;\n", pszProgramName);
 &nbsp;&nbsp; fprintf(stderr, " &lt;fmtid&gt; is a FMTID\n");
 &nbsp;&nbsp; fprintf(stderr, "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (e.g. \"{B8081511-E3BB-11CE-9050-080036F12502}\"\n");
 &nbsp;&nbsp; fprintf(stderr, " &lt;propset name&gt; is a stringized property set Name\n");
 &nbsp;&nbsp; fprintf(stderr, "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (e.g. \"\\005Rifqa2oxDxtdbickIaamtyxeCa\"\n");
 &nbsp;&nbsp; exit(1);
}
//---------------------------------------------------------------------------
// Function:&nbsp;&nbsp;&nbsp; main
//
// Synopsis:&nbsp;&nbsp;&nbsp; main entry point.
//---------------------------------------------------------------------------
void main(int argc, char **argv)
{
 &nbsp;&nbsp; WCHAR wcsFmtID[39] ;
 &nbsp;&nbsp; GUID&nbsp; fmtid ;
 &nbsp;&nbsp; char szOutput[39] ;
 &nbsp;&nbsp; strcpy(szOutput, "&lt;error!&gt;") ;
 &nbsp;&nbsp; if (argc &lt; 2)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage(argv[0]) ;
 &nbsp;&nbsp; if (*argv[1] == '{') // Specified a format ID; convert to string name.
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Convert to Unicode.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiByteToWideChar(CP_ACP, 0, argv[1], -1, wcsFmtID, 39) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Convert to GUID.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(CLSIDFromString(wcsFmtID, &amp;fmtid)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Could not convert format ID string to a FMTID\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage(argv[0]) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WCHAR wcsName[32] ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GuidToPropertySetName( &amp;fmtid, wcsName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Convert back to ANSI.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WideCharToMultiByte(CP_ACP, 0, wcsName, -1, szOutput, 39, NULL, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Output.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Stringized name: \\005%s", szOutput+1) ;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else // Must be a string-ized name; convert to format ID.
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* pStart = argv[1] ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Convert "\005" or "\0x05" to '\005'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*pStart== '\\')
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*(pStart+1) == '0' &amp;&amp; *(pStart+2) == '0' &amp;&amp; *(pStart+3) == '5')
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pStart = pStart + 3;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (*(pStart+1) == '0' &amp;&amp; *(pStart+2) == 'x' &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(pStart+3) == '0' &amp;&amp; *(pStart+4) == '5' )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pStart = pStart + 4;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Stringized name is invalid.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage(argv[0]) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pStart = '\005' ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*pStart != '\005')
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Stringized name must begin with '\\005'.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage(argv[0]) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG cwcname = (ULONG)MultiByteToWideChar(CP_ACP, 0, pStart, -1, NULL, 0) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cwcname == 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Invalid input string.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage(argv[0]) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WCHAR* pwcsName = (WCHAR*)malloc(cwcname * sizeof(WCHAR));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiByteToWideChar(CP_ACP, 0, pStart, -1, pwcsName, cwcname) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT hr = PropertySetNameToGuid(CWC_PROPSET, pwcsName, &amp;fmtid) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(pwcsName) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Could not convert name to FMTID.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage(argv[0]);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(StringFromGUID2(fmtid, wcsFmtID, 39)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "String to GUID conversion failed.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage(argv[0]);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Convert wcsFmtID back to ANSI.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WideCharToMultiByte(CP_ACP, 0, wcsFmtID, -1, szOutput, 39, NULL, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Output.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Format ID: %s", szOutput) ;
 &nbsp;&nbsp; }
}
// Eof
</code></pre>
</BODY>
</HTML>
