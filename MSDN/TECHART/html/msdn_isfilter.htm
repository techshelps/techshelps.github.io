<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Building ISAPI Filters and the CVTDOC Sample</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_isfilter"></a></sup>Building ISAPI Filters and the CVTDOC Sample</h1>
<p>
Adam Blum<br>
Microsoft Corporation</p>
<p>
April 1996</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This document is an early release of the final specification. It is meant to specify and accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final specification or software. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies. Microsoft may have trademarks, copyrights, patents or pending patent applications, or other intellectual property rights covering subject matter in this document. The furnishing of this document does not give you a license to these trademarks, copyrights, patents, or other intellectual property rights.</p>
<h3>Contents</h3>
<p>
<a href="#isfilterab">Abstract</a></p>
<p>
<a href="#isfilterov">Introduction</a></p>
<p>
<a href="#isfilter1">1. Introduction to ISAPI Filters</a></p>
<p>
<a href="#isfilter2">2. Building the CVTDOC ISAPI Filter</a><br>
<a href="#isfilter2.1">2.1. What CVTDOC Does</a><br>
<a href="#isfilter2.2">2.2. Building the Filter</a><br>
<a href="#isfilter2.2.1">2.2.1. Requirements</a><br>
<a href="#isfilter2.2.2">2.2.2. GetFilterVersion</a><br>
<a href="#isfilter2.2.3">2.2.3. HttpFilterProc</a><br>
<a href="#isfilter2.2.4">2.2.4. Building and Testing</a><br>
<a href="#isfilter2.3">2.3. Building the Conversion Programs</a><br>
<a href="#isfilter2.3.1">2.3.1. Word-to-HTML Conversion: DOC2HTM.EXE</a><br>
<a href="#isfilter2.3.2">2.3.2. Microsoft Excel-to-HTML Conversion: XL2HTM.EXE</a><i><br>
</i><a href="#isfilter2.3.3">2.3.3. Text-to-HTML Conversion: TXT2HTML.BAT</a><br>
<a href="#isfilter2.3.4">2.3.4. Creating Your Own Conversions</a></p>
<p>
<a href="#isfilter3">3. Using CVTDOC</a><br>
<a href="#isfilter3.1">3.1. Installation</a><br>
<a href="#isfilter3.2">3.2. Conversion Programs</a><br>
<a href="#isfilter3.3">3.3. Usage</a></p>
<p>
<a href="#isfilter4">4. References</a></p>
<h2><a name="isfilterab"></a>Abstract</h2>
<p>
This article details the programming required to successfully build Internet server application programming interface (ISAPI) filters, a powerful technology for extending the functionality of ISAPI-compliant Web servers such as the Microsoft® Internet Information Server (IIS). After explaining the ISAPI filter specification (part of the Microsoft ActiveX™ server framework) in general, it describes an example ISAPI filter, CVTDOC, in detail. CVTDOC is an ISAPI filter that allows a Web server to perform automatic file publishing by converting files on the fly from their application's native format to HTML.</p>
<h2><a name="isfilterov"></a>Introduction</h2>
<p>
The Web's growing popularity for information publishing and retrieval has made many a custom-developed application obsolete. End users and Webmasters can easily create Web content that approximates what was done with custom applications. As a developer, does this mean that if a Web-based approach is chosen for building a solution, you are out of the loop? No way! Microsoft® Internet Information Server (IIS) provides a host of capabilities in the Microsoft ActiveX™ server framework for using your Microsoft Visual C++® development magic to provide advanced capabilities for Web-based applications. In this article, I'll explain one of these technologies, ISAPI filters, that will allow you to add some particularly cool features to your Web site. To get you hooked, I'll give you a free sample. Use the CVTDOC filter to generate HTML files dynamically. A filtered Web server provides smooth HTML conversion every time. (Warning: ISAPI programming is definitely addictive.)</p>
<p>
The ISAPI Filter specification (included in the <a href="http://www.microsoft.com/intdev/sdk/">Microsoft ActiveX SDK</a> at http://www.microsoft.com/intdev/sdk/)provides the capability of registering a DLL to intercept specific server events and perform appropriate actions. Unlike ISAPI itself, which is an improvement over the Common Gateway Interface (CGI) that Web servers have used for years, ISAPI filters are an entirely new capability in the world of Web servers. In effect, ISAPI filters let you extend the capabilities of your Web server. The ISAPI filter you build says to the Web server, "Hey, when something like this happens, let me handle it." Your filter can then handle the event entirely, process the event, and leave it available for the Web server and other filters to handle, or your filter can decide on the fly that it's not an event it needs to process at all. For example, you can create ISAPI filters to:
<ul type=disc>
<li>
Provide enhanced logging capabilities for your Web server by tracking more information than the Web server does with a potentially different data storage format.<br><br></li>
<li>
Provide custom authentication techniques by interposing your filter with its own user ID and password method on access requests for a particular resource or type of resource.<br><br></li>
<li>
Enhance the functionality of your Web server by serving data in a different way than the Web server would by default.</li>
</ul>
<p>
This last, extremely powerful capability is one that I'd like to explain in this article. First, I'll show you briefly what you need to do to write an ISAPI filter in general. Then we'll walk through the code of an example filter that enhances the capabilities of a Web server. The CVTDOC ISAPI filter sample allows your Web server to "automatically publish" files by dynamically converting them to HTML. Although CVTDOC is primarily meant as an example of ISAPI filters, you may find it useful in its own right. In the final section, I'll show the details of how to install and use the CVTDOC sample.</p>
<h2><a name="isfilter1"></a>1. Introduction to ISAPI Filters</h2>
<p>
ISAPI filter authors must create two main functions for export: <b>GetFilterVersion()</b> and <b>HttpFilterProc()</b>. <b>GetFilterVersion()</b> is called<i> </i>just once by the Web server: On server startup when loading all filters. <b>GetFilterVersion()</b><i> </i>should:
<ul type=disc>
<li>
Provide version information to the server.<br><br></li>
<li>
Set the priority of the filter (<b>GetFilterVersion()</b> determines the order in which it's called for these events).<br><br></li>
<li>
Registers events that interest the filter.</li>
</ul>
<p>
<b>GetFilterVersion()</b><i> </i>takes just one argument of a structure that will store this information (version info, priority, and event flags).</p>
<pre><code>BOOL WINAPI GetFilterVersion( PHTTP_FILTER_VERSION pVer );
</code></pre>
<p>
The <b>HTTP_FILTER_VERSION</b> structure looks like this:</p>
<pre><code>typedef struct _HTTP_FILTER_VERSION {
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp; dwServerFilterVersion;
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp; dwFilterVersion;
 &nbsp;&nbsp; CHAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszFilterDesc[SF_MAX_FILTER_DESC_LEN+1];
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp; dwFlags;
} HTTP_FILTER_VERSION, *PHTTP_FILTER_VERSION;
</code></pre>
<p>
The <b>GetFilterVersion()</b> function should fill in the <i>dwFilterVersion</i>, <i>lpszFilterDesc</i>, and<i> dwFlags </i>structure members. Most importantly, <i>dwFlags</i> needs to have all events that it is interested in registered for by turning that flag bit on.</p>
<p>
The events available to register are listed in Table 1.</p>
<p class=label>
<b>Table 1. GetFilterVersion() Function—Events Available to Register</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Event ID</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=50%>SF_NOTIFY_READ_RAW_DATA</td>
<td width=50%>Intercept data going to the server.</td>
</tr>
<tr valign=top>
<td width=50%>SF_NOTIFY_SEND_RAW_DATA</td>
<td width=50%>Intercept data going from the server back to the client.</td>
</tr>
<tr valign=top>
<td width=50%>SF_NOTIFY_AUTHENTICATION</td>
<td width=50%>Call your filter when authentication event occurs. Used to implement custom password schemes.</td>
</tr>
<tr valign=top>
<td width=50%>SF_NOTIFY_LOG</td>
<td width=50%>Call your filter when the server is about to log a resource access or other event. Lets you implement your own custom logging schemes.</td>
</tr>
<tr valign=top>
<td width=50%>SF_NOTIFY_URL_MAP</td>
<td width=50%>Call your filter when the server is mapping a logical path to a physical path. In effect, this is called every time a resource on your server is accessed.</td>
</tr>
<tr valign=top>
<td width=50%>SF_NOTIFY_PREPROC_HEADERS</td>
<td width=50%>Called before server preprocesses headers coming from Web client.</td>
</tr>
<tr valign=top>
<td width=50%>SF_NOTIFY_END_OF_NET_SESSION</td>
<td width=50%>Call your filter when the user's session is about to end.</td>
</tr>
<tr valign=top>
<td width=50%>SF_NOTIFY_SECURE_PORT</td>
<td width=50%>Include with other flags if you want filter called when running over secure port (such as http://...).</td>
</tr>
<tr valign=top>
<td width=50%>SF_NOTIFY_NONSECURE_PORT</td>
<td width=50%>Include with other flags when running over a normal HTTP connection (almost always included in your filter flags).</td>
</tr>
</table><br>
<p>
The SF_NOTIFY_READ_RAW_DATA and SF_NOTIFY_SEND_RAW_DATA flags allow the ISAPI filter dynamic-link library (DLL) to intercept data going from the client to the server (READ) or from the server back to the client (SEND), and store and manipulate the data for its own purposes. Intercepting the SF_NOTIFY_AUTHENTICATION event allows the filter to insert its own authentication scheme for use with the server. The SF_NOTIFY_LOG event allows the filter to supplement or replace the IIS logging mechanism with its own logging method. The SF_NOTIFY_URL_MAP is a good event to intercept if you want to change how the server responds to a request for a URL resource. For example, we will intercept the SF_NOTIFY_URL_MAP in the CVTDOC filter to create the file requested by the URL. The SF_NOTIFY_SECURE_PORT and SF_NOTIFY_NON_SECURE_PORT flags can be ORed with the events requested to allow your filter to restrict its operation to situations where the HTTP server is running over a secure port or over a normal HTTP session.</p>
<p>
The other externally available function, <b>HttpFilterProc()</b>, is called by the HTTP server (for example, IIS) each time one of these events the filter is interested in occurs.</p>
<pre><code>DWORD WINAPI HttpFilterProc(
 &nbsp;&nbsp; PHTTP_FILTER_CONTEXT pfc,
 &nbsp;&nbsp; DWORD NotificationType,
 &nbsp;&nbsp; LPVOID pvNotification
);
</code></pre>
<p>
The first argument is an <b>HTTP_FILTER_CONTEXT</b> structure that has information about the server session, has function pointers available that can get more information about the server session, and can add headers or data to the response going back to the client. In the CVTDOC sample, this argument is not used; you won't always need to use this argument. The next argument indicates the event notification type. This determines what event triggered the call of your filter. It is almost always used because, as good form, you want to make sure that you are not processing events that do not interest you. Also, a single filter may be registered for multiple events, and <b>HttpFilterProc()</b><i> </i>may have conditional logic based on the event that triggered its call. For example, a filter may be registered for the SF_NOTIFY_READ_RAW_DATA and SF_NOTIFY_SEND_RAW_DATA events, where it processes some of the data passing from the client to the server or from the server to the client. But the details of its actions will likely vary slightly depending on the direction, so it needs to know the triggering event. The third argument stores data associated with an event in a structure. Available structure types are listed in Table 2.</p>
<p class=label>
<b>Table 2. HttpFilterProc() Function—Available Structure Types</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=41%><b>Structure Type</b></td>
<td class=label width=59%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=41%><b>HTTP_FILTER_RAW_DATA</b></td>
<td width=59%>Points to the data passed back by a READ or SEND event.</td>
</tr>
<tr valign=top>
<td width=41%><b>HTTP_FILTER_PREPROC_HEADERS</b></td>
<td width=59%>Accesses the client headers before the server processes them.</td>
</tr>
<tr valign=top>
<td width=41%><b>HTTP_FILTER_AUTHENT</b></td>
<td width=59%>Provides user and password information from the server about to authenticate the client.</td>
</tr>
<tr valign=top>
<td width=41%><b>HTTP_FILTER_URL_MAP</b></td>
<td width=59%>Provides the physical path resulting from the server mapping a logical path.</td>
</tr>
<tr valign=top>
<td width=41%><b>HTTP_FILTER_LOG</b></td>
<td width=59%>Provides a variety of information about the client and its request that can be logged by the filter or changed to affect the native logging of IIS.</td>
</tr>
</table><br>
<p>
Once you have the information on the event type and the data associated with the event, your filter can do its work. Once the work is complete, the filter should return a valid return code. If you are not concerned with the event, you should immediately return SF_STATUS_REQ_NEXT_NOTIFICATION. If you handle an event and do not want any other filter or the server to handle it, return SF_STATUS_REQ_HANDLED_NOTICATION. If you handled an event, but it's all right for other filters and the server to deal with the event as well, return SF_STATUS_REQ_NEXT_NOTIFICATION. SF_STATUS_REQ_ERROR can be returned to indicate an error in the filter (reserve this for fairly serious problems). SF_STATUS_REQ_READ_NEXT can be returned to request to see more of the data being passed back to the client or received by the server, expecting to be called again with more data in the <b>HTTP_FILTER_RAW_DATA</b> structure.</p>
<p class=label>
<b>Table 3. Valid Filter Return Codes</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Return Code</b></td>
<td class=label width=52%><b>Use</b></td>
</tr>
<tr valign=top>
<td width=48%>SF_STATUS_REQ_NEXT_NOTIFICATION</td>
<td width=52%>The filter is not concerned with the event.</td>
</tr>
<tr valign=top>
<td width=48%>SF_STATUS_REQ_HANDLED_NOTICATION</td>
<td width=52%>The filter handled the event and will restrict other filters and the server from handling the event.</td>
</tr>
<tr valign=top>
<td width=48%>SF_STATUS_REQ_NEXT_NOTIFICATION</td>
<td width=52%>Event is handled. It is all right for other filters and the server to handle the event now.</td>
</tr>
<tr valign=top>
<td width=48%>SF_STATUS_REQ_ERROR</td>
<td width=52%>An error occurred in the filter. Reserve this return for fairly serious problems.</td>
</tr>
<tr valign=top>
<td width=48%>SF_STATUS_REQ_READ_NEXT</td>
<td width=52%>Request to see more of the data being passed back to the client or received by the server. Expects to be called again.</td>
</tr>
</table><br>
<p>
Once your filter is built, you can install it on IIS by running REGEDT32.EXE and adding the DLL name to the key: HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W3Svc\Parameters\Filter DLLs. Ideally, this should be done by a SETUP program that accompanies your filter.</p>
<p>
This is the essence of what's required to build and use an ISAPI filter. To give you a better sense of what's involved in building an ISAPI filter, I'll describe the construction of an ISAPI filter sample that ships with ActiveX server framework: CVTDOC. This should also give you a sense of the types of problems to which ISAPI filters can be applied.</p>
<h2><a name="isfilter2"></a>2. Building the CVTDOC ISAPI Filter</h2>
<p>
First, I'll briefly describe the purpose of CVTDOC, then how I developed the ISAPI filter itself, and finally present how each of the supplied conversion programs was built.</p>
<h3><a name="isfilter2.1"></a>2.1. What CVTDOC Does</h3>
<p>
CVTDOC is a simple ISAPI filter I wrote in response to a need from several clients for "automatic file publishing": Generating HTML on the fly for specific document types. CVTDOC uses the capability of an ISAPI filter to supplement server capabilities by registering itself as intercepting all URL map events and then checking to see whether the document type requested is one that it knows how to convert.</p>
<p>
The following fragment from the CVTDOC documentation (CVTDOC.DOC when you download the sample) may explain this requirement better:</p>
<p class=indent>
Web content creators and Webmasters often want to "publish" a document or data file on the Web. However, it can be very inconvenient to constantly run a conversion program to generate new HTML each time the document or data file is updated. Relying on the Webmaster to run the conversion program for data that is often updated is also prone to error. If you are positive that the user has the software to display the document in native form, no conversion is necessary, but this is dangerous to assume. It would be great to be able to leave the document in native form and have the Web server (or a Web server add-in such as CVTDOC) convert the document to HTML on the fly as needed.</p>
<p class=indent>
CVTDOC is an Internet Services API (ISAPI) filter that dynamically converts documents to HTML if required when the HTML file is accessed. If the HTML document is out of date (older than the source document) or missing, it is automatically generated from the ISAPI filter, based on "conversion programs" registered for the source document type in the Registry. I provide sample conversion programs for Word documents, Microsoft Excel spreadsheets, and text files, but it's important to remember that this can be used for any document type. The primary purpose of CVTDOC is to demonstrate the powerful capabilities of ISAPI filters. Nevertheless, I think you will find it useful in its own right.</p>
<p>
The following section describes in detail how the filter was constructed. It's relatively easy to lose sight of the forest for the trees here: A quick glance at Section 3 on installing and using the filter (both of which are really quite simple) may help avoid any disorientation as you plow through the minutiae of how this was built.</p>
<h3><a name="isfilter2.2"></a>2.2. Building the Filter</h3>
<p>
Now that we know what's required, we can proceed to develop the filter. The basic steps are:
<ul type=disc>
<li>
Specify precisely how the filter is invoked, including the events for which it is registered.<br><br></li>
<li>
Write <b>GetFilterVersion</b>, registering for required events.<br><br></li>
<li>
Write <b>HttpFilterProc</b>, processing the required event.<br><br></li>
<li>
Build and test the filter.</li>
</ul>
<h4><a name="isfilter2.2.1"></a>2.2.1. Requirements</h4>
<p>
The filter needs to be able to intercept URL requests ending with a reference in the format:</p>
<p>
<i>filename.extension.htm</i></p>
<p>
...and convert the file <i>filename.extension</i> to <i>filename.extension.htm</i> if and only if the HTML file is missing or older than the source. For example, an HTML hyperlink reference such as:</p>
<p>
&lt;A HREF="specials.doc.htm"&gt;</p>
<p>
...should result in CVTDOC conditionally converting the SPECIALS.DOC<i> </i>file to HTML. CVTDOC should first check whether the HTML for that document already exists. If not, or if the HTML file is older than the source data file, it is a candidate for automatic conversion to HTML. CVTDOC searches through a list of registered data file types and associated conversion programs stored in the Registry, looking for a conversion program for the given extension (such as .DOC, .XLS, or .TXT). If it finds a conversion program, that program is launched to generate the specified <i>filename.extension.htm</i> file (for example, SPECIALS.DOC.HTM).</p>
<p>
Why does the HTML author need to use the strange syntax (SPECIALS.DOC.HTM) instead of just embedding the file reference (SPECIALS.DOC) and somehow configuring CVTDOC to know to convert all .DOC files to HTML? First of all, you may still want to embed references to a .DOC file and have it launch Word or, in general, embed a reference to the native file format and have the reference launch a viewer for that format if it is present. Using the syntax presented, references to the native format are still possible. More fundamentally, the Web browser is always going to attempt to launch a helper application if the URL ends with an extension of the native file format and not .HTM or .HTML. The<i> </i>URL ending with .HTM makes the browser expect HTML back, which is what it gets.</p>
<p>
What we need is a filter that intercepts every request for a file of a type for which our filter can perform a conversion. From looking at Table 1, it might seem that there is no explicit "file requested" event, but in fact there is. As long as the request is for a file on our local site, a URL mapping event (which can be intercepted with the SF_NOTIFY_URL_MAP flag) takes place. That is, if the URL reference is SPECIALS.DOC.HTM or any other URL that resolves to a local file, such as http://ourstore.com/specials.doc.htm<i>, </i>a URL mapping event will take place on the server to convert the logical URL to a physical file path. The filter should intercept each URL mapping event by setting the SF_NOTIFY_URL_MAP flag in the <b>HTTP_FILTER_VERSION</b> structure on the <b>GetFilterVersion()</b><i> </i>call. The other flag set should be SF_NOTIFY_ORDER_HIGH in order to get the notification as early as possible and make the necessary conversion, before other filters that may need to use the resulting data try to access it.</p>
<p>
As preparation for writing the <b>HttpFilterProc</b><i> </i>call, the pseudo-code for doing actual filter processing is the following:</p>
<pre><code>IF URL request is <i>filename.ext.htm</i>
&lt;!--HtmlStart--&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;!--HtmlEnd--&gt;IF <i>filename.ext</i> EXISTS
&lt;!--HtmlStart--&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;!--HtmlEnd--&gt;IF <i>filename.ext.htm</i> MISSING or OLDER than <i>filename.ext</i>
&lt;!--HtmlStart--&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;!--HtmlEnd--&gt;LOOK FOR CONVERSION PROGRAM FOR <i>ext</i>
&lt;!--HtmlStart--&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;!--HtmlEnd--&gt;IF FOUND
&lt;!--HtmlStart--&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;!--HtmlEnd--&gt;CONVERT <i>filename.ext</i> TO <i>filename.ext.htm</i>
</code></pre>
<p>
With this information about the desired functionality, we're now ready to write the ISAPI filter.</p>
<h4><a name="isfilter2.2.2"></a>2.2.2. GetFilterVersion</h4>
<p>
The first function we need to write is <b>GetFilterVersion()</b>. This performs the three steps outlined in the discussion of <b>GetFilterVersion</b><i> </i>responsibilities for all ISAPI filters identified earlier:
<ul type=disc>
<li>
Provides version information to the server.</li>
</ul>
<p class=indent>
This is done with:</p>
<pre><code>pFilterVersion-&gt;dwFilterVersion = HTTP_FILTER_REVISION;
strcpy (pFilterVersion-&gt;lpszFilterDesc,
"CVTDOC - Converts document or data into HTML if HTML not present or older");
</code></pre>
<p class=indent>
This first step provides the ISAPI filter revision number back to the server, as well as a text description of CVTDOC.
<ul type=disc>
<li>
Sets the priority of the filter (determines the order in which it's called for these events).<br><br></li>
<li>
Registers events that interest the filter.</li>
</ul>
<p class=indent>
Both of these latter steps are accomplished by setting flags as shown:</p>
<pre><code>pFilterVersion-&gt;dwFlags=(SF_NOTIFY_ORDER_HIGH | // be sure to intercept!
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SF_NOTIFY_SECURE_PORT |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SF_NOTIFY_NONSECURE_PORT |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SF_NOTIFY_URL_MAP&nbsp; // tell us about all URL requests
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
</code></pre>
<p class=indent>
This sets the notification priority high, tells the filter that we are interested in both in sessions over secure and nonsecure ports, and registers the filter for all URL map events.</p>
<p>
The entire <b>GetFilterVersion()</b> code is:</p>
<pre><code>BOOL WINAPI GetFilterVersion (PHTTP_FILTER_VERSION pFilterVersion)
{
pFilterVersion-&gt;dwFilterVersion = HTTP_FILTER_REVISION;
strcpy (pFilterVersion-&gt;lpszFilterDesc,
"CVTDOC - Converts document or data into HTML if HTML not present or older");&nbsp; 
// now register for events we're interested in 
pFilterVersion-&gt;dwFlags=(SF_NOTIFY_ORDER_HIGH | // be sure to intercept!
 &nbsp;&nbsp; SF_NOTIFY_SECURE_PORT |
 &nbsp;&nbsp; SF_NOTIFY_NONSECURE_PORT |
 &nbsp;&nbsp; SF_NOTIFY_URL_MAP&nbsp; // tell us about all URL requests
 &nbsp;&nbsp; );
 &nbsp;&nbsp; hEvtLog=RegisterEventSource(NULL,"CVTDOC");// open up event log
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<h4><a name="isfilter2.2.3"></a>2.2.3. HttpFilterProc</h4>
<p>
Now we just need to write the <b>HttpFilterProc()</b> procedure, and then we're almost done. We've already developed the pseudo-code for what it needs to do. Here is the essence of the implemented <b>HttpFilterProc</b>:</p>
<pre><code>// Make a copy of the supplied filename that was requested
// so that we can determine what the source file is
strcpy(szSrcFile,pURLMap-&gt;pszPhysicalPath);

// Check to see if there's an extension and then save a pointer to it
if (pszExt=strrchr(szSrcFile,'.')){ // check for extension

 &nbsp; // This is the request for a .htm or .html file
 &nbsp; if (!strnicmp(pszExt,".htm",3)){ // is it HTML?

 &nbsp;&nbsp;&nbsp;&nbsp; // Zap the extension on the copy of the file to get the source filename
 &nbsp;&nbsp;&nbsp;&nbsp; *pszExt='\0';
 &nbsp;&nbsp;&nbsp;&nbsp; // check for access() returning zero, indicating presence of source file
 &nbsp;&nbsp;&nbsp;&nbsp; if (!access(szSrcFile,0)){//check for presence of file
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This function checks to see if the source file is newer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // than the requested file, or if the requested file is
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // just not present
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FileDateCompare(szSrcFile,pURLMap-&gt;pszPhysicalPath)&gt;0) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This looks for a conversion program to run based on extension
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // then runs the conversion program
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (CvtToHTML(szSrcFile,pURLMap-&gt;pszPhysicalPath)==TRUE)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This indicates that the filter handled the request for 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the URL so no other filters process
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return SF_STATUS_REQ_HANDLED_NOTIFICATION;
 &nbsp;&nbsp;&nbsp;&nbsp; } // end check for presence of file

} // End is it HTML?

} // End check for extension
// .
// .
// If we didn't attempt conversion, control is passed to next filter
// by returning SF_STATUS_NEXT_NOTIFICATION
return SF_STATUS_NEXT_NOTIFICATION;
</code></pre>
<p>
First, we parse out the source file from the full HTML file (<i>pURLMap-&gt;pszPhysicalPath</i>) by copying the physical file path into <i>szSrcFile</i> and stripping off the .HTM extension if the extension is there (if it's not, then this is not a candidate URL for automatic conversion). Then we check for existence of the source file (<b>access()</b> returning 0 indicates presence). If the source file is there, then we check to see whether the source file is newer or if the HTML file is missing (with the <b>FileDateCompare() </b>function that we write elsewhere). If so, we attempt to convert the source file into HTML using the <b>CvtToHTML()</b> function. This function checks for available conversions in a Registry subkey called Conversions, created just for CVTDOC, which contains extensions (such as .DOC, .XLS, and .TXT) and their associated conversion programs. The Conversions<i> </i>key is located under the HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W3SVC\Parameters<i> </i>key. Creating it and filling it with values (file extensions and corresponding conversion programs) is part of the installation process documented in Section 3 If the conversion is not attempted, then control is passed to the next filter or to the server itself by returning SF_STATUS_NEXT_NOTIFICATION. If the conversion fails or no conversion program is found, these failures are reported to the Microsoft Windows NT® event log. In this case, the likely message to the Web user is a "404 Not found" error showing on their Web browser, unless the HTML file is already present on the server. </p>
<h4><a name="isfilter2.2.4"></a>2.2.4. Building and testing</h4>
<p>
This section provides some tips on building ISAPI filters that may illustrate to you how simple it really is and so to encourage you. Make sure that your source file contains the following headers:</p>
<pre><code>#include &lt;httpext.h&gt;
#include &lt;httpfilt.h&gt;
</code></pre>
<p>
Make sure that your INCLUDE environment variable contains the ISAPI header directory (such as C:\INETSDK\INCLUDE) and that your LIB environment variable points to the ISAPI libraries (such as C:\INETSDK\LIB\I386).<i> </i>A makefile is supplied with CVTDOC on which you can model your ISAPI filter makefile, but it's worth a look to see how simple it is. ISAPI programs in general, and ISAPI filters in particular, are really very lightweight.</p>
<pre><code>CC=cl -c
CVARS=-DWIN32 -DNDEBUG 
LINK=link
LINKOPT=/DLL
LIBS=wininet.lib user32.lib 
OBJS=cvtdoc.obj
LINKOUT=/OUT:cvtdoc.dll
DEFS=cvtdoc.def
.cpp.obj:
 &nbsp;&nbsp; $(CC) $(CFLAGS) $(CVARS) $*.cpp
cvtdoc.dll: $(OBJS) $(DEFS)
 &nbsp;&nbsp; $(LINK) $(LINKOPT) /DEF:$(DEFS) $(LINKOUT) $(LIBS) $(OBJS)
</code></pre>
<p>
To do initial testing on the created filter, we wanted to see that a conversion program actually got called. Running REGEDT32.EXE, we created the Conversions subkey below the W3SVC\Parameters<i> </i>key in the Registry and added a value of .TXT with data of TXT2HTML.BAT %s. We created a batch file TXT2HTML.BAT with one line:</p>
<pre><code>COPY %1 %1.htm
</code></pre>
<p>
This batch file also shows the primary requirement of any conversion program that will be registered with CVTDOC. It needs to take the source file as its argument and create a destination HTML file that has the same name as the source file, with an .HTM appended to it. This is a characteristic of all the conversion programs supplied with CVTDOC and should be the convention followed by your own conversion programs that you register with CVTDOC. We do supply a text-to-HTML converter with the delivered CVTDOC filter. This "real" text-to-HTML conversion program is another TXT2HTML.BAT file that invokes a Perl script called TXT2HTML.PL.</p>
<p>
Now we need to install the filter as part of the running IIS Web server. Still running REGEDT32.EXE, add the full path for CVTDOC.DLL to the <i>Filter DLLs </i>parameter in HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W3Svc\Parameters.</p>
<p>
Now create an HTML file with contents of:</p>
<pre><code>&lt;A HREF="test.txt.htm"&gt;Quick test"&lt;/A&gt;
</code></pre>
<p>
Create a file called TEST.TXT with contents of:</p>
<pre><code>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;CVTDOC Test&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;Test data.&lt;/BODY&gt;&lt;/HTML&gt;
</code></pre>
<p>
If you place the HTML file onto your IIS Web server, load the HTML file into your Web browser, and click on the Quick Test link. It should result in the TXT2HTML.BAT<i> </i>file being invoked, and you will see the contents of TEST.TXT on your Web browser. This means that the server is calling our ISAPI filter successfully. Of course, you don't need to do any of this testing for CVTDOC; that is already complete. But this should give you some idea of the testing process for your own ISAPI filters.</p>
<h3><a name="isfilter2.3"></a>2.3. Building the Conversion Programs</h3>
<p>
Now that we have a working CVTDOC ISAPI filter, we need to supply some conversion programs for it. As you'll see in Section 3, CVTDOC ships with conversion programs for Word .DOC files, Microsoft Excel .XLS files, and text files (with a real text-to-HTML converter written in Perl script rather than the stub batch file shown above). This is an immediately useful set of conversions, and you could just use the supplied conversion programs. However, CVTDOC is primarily meant to be a tool with which to register any data file type and associated conversion program. If you are planning to create conversion programs for other file types, a discussion of how these types were created may be useful. Note that the code for these conversion programs is <i>not</i> included with the CVTDOC sample as shipped with the ActiveX SDK, which concentrates on the CVTDOC ISAPI filter code itself, <i>not</i> the code for conversion programs.</p>
<h4><a name="isfilter2.3.1"></a>2.3.1. Word-to-HTML conversion: DOC2HTM.EXE</h4>
<p>
DOC2HTM.EXE is invoked with the name of the source Word document as its argument. It will create an HTML file named with the source filename and an appended .HTM. To install it for use by CVTDOC, create a value under the W3Svc\Parameters\Conversions<i> </i>key with name of .DOC<i> </i>and data of—for example—C:\WWWROOT\CGI-BIN\DOC2HTM.EXE %s.</p>
<p>
This was an easy conversion program to create. Microsoft Word combined with Microsoft Internet Assistant for Word allows you to load a Word document and convert it to HTML by selecting the Save As HTML option from the File menu. Creating the conversion program was just a matter of automating this with Microsoft Visual Basic® and the WordBasic OLE Automation interface. Here is the entire code for the Word-to-HTML converter supplied with CVTDOC.</p>
<pre><code>Private Sub Form_Load()
Dim X As Object
Set X = CreateObject("Word.Basic")
 &nbsp;&nbsp; X.FileOpen Name:=Command
 &nbsp;&nbsp; NewFile = Command + ".htm"
 &nbsp;&nbsp; fmt = X.ConverterLookup("HTML")
 &nbsp;&nbsp; X.FileSaveAs Name:=NewFile, Format:=fmt
 &nbsp;&nbsp; Set X = Nothing
 &nbsp;&nbsp; Unload Me
End Sub
</code></pre>
<p>
You must have Word 6.0 or later <i>and</i> Internet Assistant for Word installed on the IIS server machine for this code to work. Once a new conversion program is built, registering it with CVTDOC is as simple as adding a new value to the Conversions subkey of the W3Svc\Parameters key, with data of the full path to the conversion program, followed by "%s".</p>
<h4><a name="isfilter2.3.2"></a>2.3.2. Microsoft Excel-to-HTML conversion: XL2HTM.EXE</h4>
<p>
XL2HTM.EXE<i> </i>is invoked with the name of the source Microsoft Excel spreadsheet. It will create an HTML file named with the source filename and an appended .HTM. It will only take the data from a named range in your Microsoft Excel spreadsheet titled <i>Export. </i>If no Export<i> </i>range is available, it will just export A1 through H20. To install it for use by CVTDOC, create a value under the W3Svc\Parameters\Conversions<i> </i>key with name of .XLS<i> </i>and data of—for example—C:\WWWROOT\CGI-BIN\XL2HTM.EXE %s.</p>
<p>
Unfortunately, the Internet Assistant for Microsoft Excel cannot be invoked via OLE Automation (you cannot save as HTML within Microsoft Excel as you can with Word). So I had to write this conversion program from scratch. The entire program handling character formatting and alignment is quite long and not that interesting for the purpose at hand (to show you how to build your own conversions). Below is a grossly oversimplified (but functional) version of the code that just shows how to get the data from the Export range into an HTML table.</p>
<pre><code>Private Sub Form_Load()
 &nbsp;&nbsp; Dim X As Object
 &nbsp;&nbsp; Set X = CreateObject("Excel.Sheet")
 &nbsp;&nbsp; Dim App as Object
 &nbsp;&nbsp; Set App = X.Application
 &nbsp;&nbsp; App.Workbooks.Open Command
 &nbsp;&nbsp; Dim CurSheet As Object
 &nbsp;&nbsp; Set CurSheet = App.ActiveWorkbook.Worksheets("Sheet1")
 &nbsp;&nbsp; Result =CurSheet.Range("Export").Select
 &nbsp;&nbsp; If (Result &lt;&gt; True) Then Result = CurSheet.Range("A1:H20").Select

 &nbsp;&nbsp; Dim OutputFile As String
 &nbsp;&nbsp; OutputFile = Command + ".htm"
 &nbsp;&nbsp; Open OutputFile For Output As #1

 &nbsp;&nbsp; Header = "Data From " + Command
 &nbsp;&nbsp; Line = "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;" &amp; Header &amp; "&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;"
 &nbsp;&nbsp; Print #1, Line
 &nbsp;&nbsp; Line = "&lt;H1&gt;" &amp; Header &amp; "&lt;/H1&gt;"
 &nbsp;&nbsp; Print #1, Line
 &nbsp;&nbsp; Print #1, "&lt;TABLE&gt;"

 &nbsp;&nbsp; NoRows = App.Selection.Rows.Count
 &nbsp;&nbsp; NoCols = App.Selection.Columns.Count
 &nbsp;&nbsp; ' now loop through all rows and columns printing out contents
 &nbsp;&nbsp; For Row = 1 to NoRows
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print #1, "&lt;TR&gt;"
 &nbsp;&nbsp; For Col = 1 to NoCols
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print #1, "&lt;TD&gt;"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print #1, App.Selection.Cells(Row, Col).Text
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next Col
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next Row
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print #1, "&lt;/TABLE&gt;&lt;/BODY&gt;&lt;/HTML&gt;"

 &nbsp;&nbsp; Set X = Nothing
 &nbsp;&nbsp; Set App = Nothing
 &nbsp;&nbsp; Set CurSheet = Nothing
 &nbsp;&nbsp; Unload Me
End Sub
</code></pre>
<h4><a name="isfilter2.3.3"></a>2.3.3. Text-to-HTML conversion: TXT2HTML.BAT</h4>
<p>
TXT2HTML.BAT is invoked with the name of the source Word document as its argument. It will create an HTML file named with the source filename and an appended .HTM. To install it for use by CVTDOC, create a value under the W3Svc\Parameters\Conversions<i> </i>key with name of .TXT<i> </i>and data of—for example—C:\WWWROOT\CGI-BIN\TXT2HTML.BAT %s. You will need to have Windows NT Perl installed on your IIS machine, executable in the PATH. You can find Windows NT Perl on the Windows NT 3.51 Resource Kit, and at <a href="http://www.perl.hip.com/">http://www.perl.hip.com/</a>.</p>
<p>
This batch file is a wrapper around TXT2HTML.PL,<i> </i>a Perl script for text-to-HTML conversion written by Seth Golub of the University of Washington. The script is entirely too large to present here. The batch file is as follows:</p>
<pre><code>perl txt2html.pl &lt; %1 &gt; %1.htm
</code></pre>
<p>
The Perl script moves through the text file placing headers around logical breakpoints, generally attempting to convert the content to HTML. It won't be perfect, but the result is a bit more attractive than a plain text file displayed on a Web browser.</p>
<h4><a name="isfilter2.3.4"></a>2.3.4. Creating your own conversions</h4>
<p>
You can get a pretty good idea from the discussion above of how to create your own conversion program. It should take an argument of the source file. It should generate an HTML file named with the source filename and an appended .HTM. If the program in question exposes an OLE Automation interface, this usually makes writing a small Visual Basic application to do the work very easy. You should be able to use the <b>Form_Load()</b><i> </i>subroutines presented as a model to build another Visual Basic-based conversion program.</p>
<h2><a name="isfilter3"></a>3. Using CVTDOC</h2>
<p>
As mentioned earlier in this article, the primary purpose of CVTDOC is to demonstrate the capabilities of ISAPI filters. Hopefully, presenting how this filter was built has made it clear how to create your own filters. If you don't need the specific functionality offered by CVTDOC, you can stop here, fire up Developer Studio and start hacking your own ISAPI filters.</p>
<p>
However, based on what you now know about the functionality available in CVTDOC, it may have value to you in and of itself. Assuming you now would like to use CVTDOC on your own Web site, here are the instructions to do so. CVTDOC is included in the ActiveX SDK in the directory \INETSDK\SAMPLES\ISAPI\CVTDOC. We recommend downloading and installing the ActiveX SDK to ensure you have what you need for the sample. Currently, the ActiveX SDK can be downloaded from <a href="http://www.microsoft.com/intdev/sdk/">http://www.microsoft.com/intdev/sdk</a>.</p>
<h3><a name="isfilter3.1"></a>3.1. Installation</h3>
<ol>
<li>
Copy CVTDOC.DLL to an appropriate subdirectory, such as the CGI-BIN subdirectory of your Web content directory.<br><br></li>
<li>
Update the <i>Filter DLLs</i> parameter of IIS. Run REGEDT32.EXE.<br><br></li>
<li>
Add the full path of CVTDOC.DLL to HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W3SVC\Parameters\Filter DLLs<i> </i>(the DLLs are separated by commas).<br><br></li>
<li>
Create a Conversions subkey of the W3SVC\Parameters key.<br><br></li>
<li>
Add each extension (such as .XLS or .DOC) as a separate value.<br><br></li>
<li>
Enter the full path of the conversion program to run for each extension as the value's data.<br><br></li>
<li>
List each conversion program as taking two arguments of "%s %s", unless the conversion program in question will automatically add an .HTM to the source filename as its generated output file. For example, a value under the Conversions<i> </i>key might be .DOC, and the data would be C:\WWWROOT\CGI-BIN\DOC2HTM.EXE%s.<br><br></li>
<li>
Place the conversion programs in the directories referenced. Sample conversion programs supplied are discussed below.</li>
</ol>
<h3><a name="isfilter3.2"></a>3.2. Conversion Programs</h3>
<p>
There are three conversion programs supplied with this sample:
<ol>
<li>
DOC2HTM.EXE converts Word documents (.DOC files) to HTML. It requires that Internet Assistant for Word (WordIA) be installed on the IIS server machine. It has only been tested with Word for Windows 95. Usage is: <i>DOC2HTM.EXE &lt;Word .DOC file&gt;</i>. An HTML file will be generated with the filename of the original Word document and an appended .HTM (for example, SPECIALS.DOC.HTM).<br><br></li>
<li>
XL2HTM.EXE<i> </i>converts Microsoft Excel spreadsheets (.XLS files) to HTML. It does not require any other software beyond Microsoft Excel 5.0 or later. Usage is <i>XL2HTM.EXE &lt;Excel spreadsheet file&gt;</i>. Output is an HTML file with the extension .HTM (for example, SAMPLE.XLS.HTM). The area exported to the HTML file is the range named <i>Export</i>.<br><br></li>
<li>
TXT2HTML.BAT converts text files (.TXT files) to HTML, attempting to mark it up with HTML tags as best as possible. It invokes Seth Golub's TXT2HTML.PL Perl script to do this. This requires that Windows NT Perl be installed on the IIS server machine. Output is an HTML file with an .HTM extension.</li>
</ol>
<p>
These conversion programs are intended only as samples. You can use one installation of the CVTDOC filter to convert many different data file types. In fact, CVTDOC has the most value when it has conversions installed for uncommon file types that the user may not be able to handle. You should be able to find HTML conversion programs for almost any data format on the Internet and the World Wide Web. However, you may need to write "wrapper" batch files or programs that allow the conversion program to conform to the CVTDOC calling convention. This just means that the program must take two arguments, the first being the original document file and the second being the HTML output file. Alternatively, the program can take just one argument and generate HTML with the input filename and an appended .HTM<i> </i>(as do the three supplied conversion programs).</p>
<h3><a name="isfilter3.3"></a>3.3. Usage</h3>
<p>
Embed a reference in your <i>referring</i> HTML page to the document or data filename <i>with an appended </i>.HTM. For example:</p>
<pre><code>&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;Simple CVTDOC Example&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Welcome to the CyberStore&lt;/H1&gt;
For maximum savings, please check out our 
&lt;A HREF="specials.doc.htm"&gt;daily specials!&lt;/A&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
<p>
The SPECIALS.DOC file will be converted automatically by the CVTDOC ISAPI filter if either the HTML file doesn't exist yet or it's older than the updated SPECIALS.DOC file. This allows the Webmaster to keep the HTML content current with very little intervention.</p>
<h2><a name="isfilter4"></a>4. References</h2>
<p>
The following files and URLs will be useful references in your ISAPI filter development efforts. The first reference is the ActiveX SDK page on the Microsoft Web site. The remaining references are files and directories in the ActiveX SDK itself.
<ol>
<li>
ActiveX SDK: <a href="http://www.microsoft.com/intdev/sdk/">http://www.microsoft.com/intdev/sdk/</a><br><br></li>
<li>
ActiveX SDK <i>ISAPI Filter Specification.</i> After downloading and installing the SDK, the file location is \specs\isfilter.htm.<br><br></li>
<li>
ActiveX SDK CVTDOC ISAPI Filter Sample. After downloading and installing the SDK, the file location is \samples\isapi\cvtdoc.</li>
</ol>
</BODY>
</HTML>
