<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Edit Controls</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_editctls"></a></sup>Edit Controls</h1>
<p>
Kyle Marsh<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: January 31, 1992</p>
<p>
Revised: October 16, 1992. Added GMEM_ZEROINIT to code in step 3 in "Edit Controls and Memory" section.</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="168">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the EDALIGN sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article is a complete reference for edit controls. It describes all edit control styles, messages, and notifications in more detail than those in the Microsoft® Windows™ versions 3.0 and 3.1 Software Development Kit (SDK) documentation. Techniques for solving common problems with edit controls are also described in this article.</p>
<h2>Introduction</h2>
<p>
Edit controls are a way for an application to receive input from a user. They also provide a way for the application to display information, especially when the information requires more than one line. There are two types of edit controls:
<ul type=disc>
<li>
<i>Single-line edit controls</i> have only one line of text.<br><br></li>
<li>
<i>Multiple-line edit controls</i> have one or more lines of text.</li>
</ul>
<p>
Edit controls will not accept virtual-key code less than 0x20. The only exception is that multiple-line edit controls will accept TAB and ENTER key codes. Single-line edit controls do not accept TAB and ENTER keys.</p>
<h2>Limits of Edit Controls</h2>
<p>
Edit controls were designed to enter, display, and edit small amounts of text. They were not meant to be the basis for large-scale text editors. Edit controls in Microsoft® Windows™ have the following limits:
<ul type=disc>
<li>
Single-line edit controls are limited to a maximum of 32K (32,767 bytes) of text and, of course, to a single line. By default, single-line edit controls are limited to 30,000 characters. An application can change this limit to a maximum of 32,767 characters with the EM_LIMITTEXT message described in "Edit Control Messages," later in this article.<br><br></li>
<li>
Multiple-line edit controls are limited to a maximum of 64K (65,535 bytes) of text. Whether a multiple-line edit control is actually able to approach this limit is based on how the edit control uses memory. Techniques to control the way edit controls use memory are described in the next section, "Edit Controls and Memory." Multiple-line edit controls are also limited to the following:<ul type=disc>
<li>
characters per line of text<br><br></li>
<li>
lines of text<br><br></li>
<li>
pixels per line of text</li>
</ul>
</li>
</ul>
<h2>Edit Controls and Memory</h2>
<p>
An edit control allocates its control structure, tab stop settings, and text buffer from a local heap by calling <b>LocalAlloc</b> or <b>LocalRealloc</b>. A multiple-line edit control allocates its character-width buffer and line-break array from the local heap as well. The Undo buffer is allocated in the global heap. Because a local heap has a maximum size of 64K bytes, and the text buffer for an edit control plus the edit control's support information are all allocated from one local heap, the actual amount of text that an edit control can hold is always less than 64K.</p>
<p>
Table 1 shows some guidelines on the amount of local heap an edit control uses. These rules are not likely to be accurate for versions of Windows later than version 3.1.</p>
<p class=label>
<b>Table 1. Local Heap Guidelines</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=36%><b>Element</b></td>
<td class=label width=64%><b>Amount of local heap used</b></td>
</tr>
<tr valign=top>
<td width=36%>Control structure</td>
<td width=64%>Windows version 3.0: 100 bytes<p>
Windows version 3.1: 100 bytes</p>
<p>
As many as 14 more bytes for Windows versions that utilize double characters, such as kanji and Korean versions.</p>
</td>
</tr>
<tr valign=top>
<td width=36%>Tab stop setting</td>
<td width=64%>Not allocated unless set by the application with a WM_SETTABSTOPS message.<p>
The number of tab stops specified plus 1, times the size of an integer.</p>
</td>
</tr>
<tr valign=top>
<td width=36%>Character-width buffer</td>
<td width=64%>512 bytes. (265 * sizeof(int))</td>
</tr>
<tr valign=top>
<td width=36%>Line-break array</td>
<td width=64%>Initially two times the size of an integer.<p>
The number of lines plus two times the size of an integer.</p>
</td>
</tr>
<tr valign=top>
<td width=36%>Text buffer</td>
<td width=64%>The number of characters in the control. Windows allocates an extra 32 bytes each time it allocates memory for the text buffer so that a reallocation is not needed each time a character is inserted into the edit control. </td>
</tr>
</table><br>
<p>
Edit controls that are not in a dialog box use the data segment (DS) of their parent for the edit control's local heap. The amount of text an edit control can store is affected by the amount of memory that has already been used in this heap. To maximize the amount of text that an edit control can contain, the application should supply a heap for the edit control that has not been used for any other allocations. To do this, an application should perform the following steps:
<ol>
<li>
Allocate a global memory block 256 bytes in length. This block becomes the local heap for the edit control. In real mode, this handle must be less than 0x2000. If the handle returned is greater than 0x2000 and Windows is running in real mode, you cannot use this global memory block as a local heap.<br><br></li>
<li>
Pass the handle to the newly allocated global memory block to <b>CreateWindow</b> (or <b>CreateWindowEx</b>) in the <i>hInstance</i> parameter.<br><br></li>
<li>
Send the edit control an EM_LIMITTEXT message to set the maximum number of characters in the edit control. A zero value passed with EM_LIMITTEXT allows for the maximum number of characters as shown in the following sample code:<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Assuming PROTECTED MODE ONLY
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // Real mode would need to check for 0x2000 returned.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; hEditDS = GlobalAlloc(GMEM_MOVEABLE |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GMEM_ZEROINIT | GMEM_SHARE, 256L);
 &nbsp;&nbsp;&nbsp;&nbsp; if (hEditDS == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Allocation failed; use default.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hEditDS = hInst;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // Create the edit control.
 &nbsp;&nbsp;&nbsp;&nbsp; // Pass the local heap handle in hInstance.
 &nbsp;&nbsp;&nbsp;&nbsp; hwndEdit = CreateWindow("edit", NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_CHILD | WS_VISIBLE | WS_BORDER | WS_HSCROLL |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_VSCROLL | ES_MULTILINE | ES_AUTOHSCROLL |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ES_AUTOVSCROLL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10, 10, 250, 200, hWnd, IDEDITCTL, hEditDS, NULL);

 &nbsp;&nbsp;&nbsp;&nbsp; // Now limit the text to the maximum possible amount.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; SendMessage(hwndEdit, EM_LIMITTEXT, 0, 0L);
</code></pre>
</li>
</ol>
<p>
When an edit control is in a dialog box, the dialog manager controls which local heap the dialog box will use. By default, Windows allocates a local heap for each dialog box that contains an edit control. All the edit controls in a dialog box share the same local heap. If the dialog box is created with the DS_LOCALEDIT style, the edit controls use the data segment of the parent window for their local heap. It is not possible for edit controls within a dialog box to each use a different local heap.</p>
<p>
In real mode, a local heap must have a handle of less than 0x2000. If, when the dialog manager attempts to allocate a local heap for a dialog box, a handle greater than or equal to 0x2000 is returned, it uses one of its own local heap handles. Windows keeps 10 handles to use as local heaps. If all 10 of these handles have been used by other dialog boxes, and if Windows cannot allocate a handle less than 0x2000, Windows is unable to create the dialog box. In protected mode, the problem will not occur.</p>
<h2>Edit Control Styles</h2>
<p>
Edit controls implement the styles in the sections that follow.</p>
<h3>ES_AUTOHSCROLL</h3>
<p>
ES_AUTOHSCROLL tells the edit control to scroll the text horizontally, when necessary, as the user enters text. However, if ES_AUTOHSCROLL is <i>not</i> specified, the edit control cannot scroll horizontally. For single-line edit controls without ES_AUTOHSCROLL, only the characters that fill the visible area of the control are accepted. For multiple-line edit controls without ES_AUTOHSCROLL, the text wraps to the next line when the user enters more text than can be displayed on a single line. If ES_AUTOHSCROLL is specified for a multiple-line edit control, the control scrolls horizontally when the user enters more text than can be displayed on a single line; the text will not wrap.</p>
<p>
ES_AUTOHSCROLL is automatically applied to an edit control that has a WS_HSCROLL style. In other words, any edit control that has a horizontal scroll bar automatically scrolls horizontally.</p>
<p>
ES_AUTOHSCROLL is ignored when an edit control is not left-aligned. Centered and right-aligned multiple-line edit controls cannot be horizontally scrolled.</p>
<h3>ES_AUTOVSCROLL</h3>
<p>
ES_AUTOVSCROLL tells the edit control to scroll the text vertically when the user enters more text than can be displayed within the edit control. This style only applies to multiple-line edit controls. If this style is not specified for a multiple-line edit control, the edit control will not accept the input when more text is entered than can be displayed.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Windows uses the Undo buffer to ensure that any displayable text is accepted. If an edit control does not have ES_AUTOVSCROLL specified, using the <b>undo</b> command will not work correctly in that only the last character entered can be undone. Edit controls with ES_AUTOVSCROLL can undo all the characters entered since the last cut, paste, or replace.</p>
<p>
ES_AUTOVSCROLL is automatically applied to an edit control that has a WS_VSCROLL style. In other words, any edit control that has a vertical scroll bar automatically scrolls vertically.</p>
<h3>ES_LEFT, ES_RIGHT, and ES_CENTER</h3>
<p>
ES_LEFT, ES_RIGHT, and ES_CENTER specify the alignment the text in an edit control should have. Single-line edit controls can only be left-aligned. ES_LEFT is the default for both single-line and multiple-line edit controls. Single-line edit controls ignore ES_RIGHT and ES_CENTER. Multiple-line edit controls can be right-aligned, left-aligned, or centered. Right-aligned and centered edit boxes cannot have horizontal scroll bars and cannot have the ES_AUTOHSCROLL style.</p>
<p>
Although it's not possible to change the alignment style of an edit control dynamically, two techniques are commonly used to work around this restriction:
<ul type=disc>
<li>
The first workaround is to create multiple edit controls, one for each style the application needs, and to switch between them as required.<br><br></li>
<li>
The second technique is to create a new edit control with the desired style as it is needed and switch to the new control.</li>
</ul>
<p>
The Knowledge Base has article Q66942, which describes the details of these techniques. EDALIGN, a sample application, demonstrates the code required.</p>
<h3>ES_LOWERCASE</h3>
<p>
ES_LOWERCASE causes all uppercase characters entered into the edit control to be converted to lowercase.</p>
<h3>ES_MULTILINE</h3>
<p>
ES_MULTILINE causes the edit control to be a multiple-line edit control.</p>
<h3>ES_NOHIDESEL</h3>
<p>
When ES_NOHIDESEL is specified for an edit control, selected text remains highlighted when the edit control does not have the focus. Normally, without ES_NOHIDESEL specified, an edit control "hides" the selection when it loses focus. In other words, the selection is not highlighted, but the text still appears as normal.</p>
<h3>ES_OEMCONVERT</h3>
<p>
ES_OEMCONVERT causes text entered into the edit control to be converted from ANSI to OEM and then back to ANSI. This ensures proper character conversion when the application calls the <b>AnsiToOem</b> function to convert a Windows string in the edit control to OEM characters. ES_OEMCONVERT is most useful for edit controls that contain filenames.</p>
<h3>ES_PASSWORD</h3>
<p>
ES_PASSWORD causes all characters entered into the edit control to be displayed as an asterisk (*). An application can use the EM_SETPASSWORDCHAR message to change the character that is displayed. In Windows version 3.1, edit controls with the ES_PASSWORD style do not copy their text to the Clipboard.</p>
<h3>ES_READONLY (Windows Version 3.1)</h3>
<p>
ES_READONLY causes the edit control to not allow any entering or editing of text by the user. This style is only recognized by Windows version 3.1 or later. The user cannot add or modify any text in the edit control, but copying text from the edit control is allowed. The technique to make a read-only edit control in Windows version 3.0 is described in the "Common Techniques" section, later in this article.</p>
<h3>ES_UPPERCASE</h3>
<p>
ES_UPPERCASE causes all lowercase characters entered into the edit control to be converted to uppercase.</p>
<h3>ES_WANTRETURN</h3>
<p>
The default behavior for the ENTER key in a multiple-line edit control within a dialog box is to perform the default button of the dialog box, usually the OK button, which accepts any changes made in the dialog box and then dismisses the dialog box. The ES_WANTRETURN style changes the behavior of the edit control so that the ENTER key advances the cursor to the next line. When a user is editing text in a multiple-line edit control, it may be preferred to have the ENTER key advance to the next line of the edit control. By default, without ES_WANTRETURN, multiple-line edit controls accept CTRL+ENTER to advance to the next line.</p>
<p>
ES_WANTRETURN only applies to multiple-line edit controls in Windows version 3.1 or later. The "Common Techniques" section, later in this article, describes how to implement this behavior in Windows version 3.0.</p>
<h2>Edit Control Messages</h2>
<p>
Edit controls implement the messages in the sections that follow.</p>
<h3>EM_CANUNDO</h3>
<p>
The EM_CANUNDO message is sent by an application to an edit control to determine if an Undo operation is possible. The edit control returns a TRUE to the application if an Undo is possible.</p>
<h3>EM_EMPTYUNDOBUFFER</h3>
<p>
The EM_EMPTYUNDOBUFFER message is sent by an application to an edit control to clear the Undo buffer for an edit control. Once an edit control processes this message, an Undo operation is not possible until the user modifies the contents of the edit control again.</p>
<h3>EM_FMTLINES</h3>
<p>
By default, an edit control does not store end-of-line characters—those caused by wordwrapping and not specified by the user with ENTER or CTRL+ENTER. Hard carriage returns, specified by the user with ENTER or CTRL+ENTER, are stored as a CR LF character combination (0x0D 0x0A).</p>
<p>
An application sends an EM_FMTLINES message to an edit control to control end-of-line characters. If the <i>wParam</i> parameter is non-zero, the edit control adds CR CR LF (0x0D 0x0D 0x0A) character sequences to mark the end of lines. If the <i>wParam</i> parameter is zero, the edit control removes any CR CR LF character sequences. The display of the text in the edit control is unaffected by either setting, but the amount of memory required to store the text will change.</p>
<h3>EM_GETFIRSTVISIBLELINE (Windows version 3.1 and later)</h3>
<p>
The EM_GETFIRSTVISIBLELINE message is sent by an application to a multiple-line edit control to determine what the topmost visible line in the edit control is. The "Common Techniques" section, later in this article, describes a way to determine what the topmost visible line is in Windows versions earlier than version 3.1.</p>
<h3>EM_GETLINE</h3>
<p>
The EM_GETLINE message is sent by an application to an edit control to retrieve a line of text from an edit control. The <i>wParam</i> parameter specifies the line number to retrieve. The first line of the edit control is line 0. Single-line edit controls always return the first line because that is all they have. The <i>lParam</i> parameter points to where the line will be copied. When an application sends this message, it must first place the maximum number of bytes that the buffer can receive into the first <b>WORD</b> of the buffer.</p>
<p>
The edit control returns the number of bytes actually copied or zero if the line number specified by the <i>wParam</i> parameter is greater than the number of lines in the edit control.</p>
<p>
The copied line does not contain a null-termination character.</p>
<p>
For example:</p>
<pre><code>unsigned char szBuf[128];
WORD cbText;

*(WORD *)szBuf = sizeof(szBuf); /* Sets the buffer size.&nbsp;&nbsp;&nbsp;&nbsp; */
cbText = (WORD) SendDlgItemMessage(hdlg, ID_MYEDITCONTROL,
 &nbsp;&nbsp; EM_GETLINE,
 &nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Line number.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
 &nbsp;&nbsp; (DWORD) (LPSTR) szBuf);&nbsp;&nbsp;&nbsp;&nbsp; /* Buffer address.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
szBuf[cbText] = '\0';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Null-terminates the line. */
</code></pre>
<h3>EM_GETLINECOUNT</h3>
<p>
The EM_GETLINECOUNT message is sent by an application to an edit control to retrieve the number of lines in a multiple-line edit control. This message is processed only by multiple-line edit controls.</p>
<h3>EM_GETMODIFY</h3>
<p>
The EM_GETMODIFY message is sent by an application to an edit control to determine whether the contents of an edit control have been modified.</p>
<p>
The edit control returns TRUE if the edit control contents have been modified or FALSE if they have remained unchanged. Windows maintains an internal flag indicating whether the contents of the edit control have changed. This flag is cleared when the edit control is first created and may also be cleared by sending an EM_SETMODIFY message.</p>
<h3>EM_GETSEL</h3>
<p>
The EM_GETSEL message is sent by an application to an edit control to get the starting and ending character positions of the current selection in an edit control. The edit control returns the starting position in the low-order word and the position of the first nonselected character after the end of the selection in the high-order word. The starting position is always less than the ending position; thus, no indication is given of which end the caret occupies.</p>
<h3>EM_GETTHUMB</h3>
<p>
The EM_GETTHUMB message is sent by an application to an edit control to get the current thumb position for a multiple-line edit control's vertical scroll bar. A multiple-line edit control returns a value between 0 and 100, which represents the current position of the edit control's vertical scroll bar's thumb.</p>
<h3>EM_GETRECT</h3>
<p>
The EM_GETRECT message is sent by an application to an edit control to get the formatting rectangle of an edit control. The formatting rectangle is the rectangle into which the text of the edit control will be drawn. Usually this is the same size as the edit control, including the border of the edit control (if there is one). An application can set the formatting rectangle to be different (see "EM_SETRECT," later in this article).</p>
<p>
To get the edit control's formatting rectangle, an application sends a far pointer to a RECT structure in the <i>lParam</i> parameter of the EM_GETRECT message.</p>
<p>
For example:</p>
<pre><code>RECT rcl;
SendMessage(hWnd, EM_GETRECT, 0, (DWORD) ((LPRECT) &amp;rcl));
</code></pre>
<h3>EM_LIMITTEXT</h3>
<p>
The EM_LIMITTEXT message is sent by an application to an edit control to limit the length of the text that the user may enter into an edit control.</p>
<p>
An application specifies the maximum number of characters for the edit control in the <i>wParam</i> parameter sent with the EM_LIMITTEXT message. If this parameter is zero, the text length is set to the maximum number of bytes possible.</p>
<p>
The EM_LIMITTEXT message only limits the text the user can enter. It has no effect on any text already in the edit control when the message is sent, nor does it affect the length of the text copied to the edit control by the WM_SETTEXT message.</p>
<p>
If an application uses the WM_SETTEXT message to place more text into an edit control than is specified in the EM_LIMITTEXT message, the user can edit the entire contents of the edit control.</p>
<h3>EM_LINEFROMCHAR</h3>
<p>
The EM_LINEFROMCHAR message is sent by an application to a multiple-line edit control to retrieve the line number of the line that contains the specified character index. A character index is the number of characters from the beginning of the edit control.</p>
<p>
This message is only processed by multiple-line edit controls.</p>
<p>
An application sends the character index to the edit control in the <i>wParam</i> parameter. The edit control returns the number of the line that contains the specified character.</p>
<p>
Line numbers for an edit control begin with zero.</p>
<p>
If the character index sent to the edit control is –1, the line number of the line containing the caret is returned. If there is a selection, the line number containing the beginning of the selection is returned.</p>
<h3>EM_LINEINDEX</h3>
<p>
The EM_LINEINDEX message is sent by an application to a multiple-line edit control to retrieve the character index of a line within the edit control. The character index is the number of characters from the beginning of the edit control to the specified line.</p>
<p>
This message is only processed by multiple-line edit controls.</p>
<p>
An application sends the line number desired to the edit control in the <i>wParam</i> parameter. The edit control returns the character index of the line. If the line specified is larger than the number of lines in the edit control, the edit control returns –1. If the application specifies –1 as the line number in <i>wParam,</i> the character index of the line containing the caret is returned. A selection does not affect the return value.</p>
<p>
Line numbers for an edit control begin with zero.</p>
<h3>EM_LINELENGTH</h3>
<p>
The EM_LINELENGTH message is sent by an application to an edit control to retrieve the length of a line in the edit control.</p>
<p>
For a single-line edit control, the edit control returns the length of the line it contains.</p>
<p>
For a multiple-line edit control, the application specifies the character index of a character in the line whose length is desired in the <i>wParam</i> parameter. If the application specifies –1 in the <i>wParam</i>, the line containing the caret is used. If characters are selected on the current line, the length of the line does not include the length of the selection.</p>
<h3>EM_LINESCROLL</h3>
<p>
The EM_LINESCROLL message is sent by an application to a multiple-line edit control to scroll the text of a multiple-line edit control.</p>
<p>
This message is processed only by multiple-line edit controls.</p>
<p>
An application specifies the number of lines to scroll vertically in the low-order word of the <i>lParam</i> and the number of characters to scroll horizontally in the high-order word.</p>
<p>
The edit control will not scroll vertically past the last line of text in the edit control. If the current line plus the number of lines specified by the low-order word of the <i>lParam</i> parameter exceed the total number of lines in the edit control, the value is adjusted such that the last line of the edit control is scrolled to the top of the edit-control window.</p>
<p>
The EM_LINESCROLL message can be used to scroll horizontally past the last character of any line.</p>
<p>
This message is ignored if the multiple-line edit control was created with either the ES_RIGHT or the ES_CENTER style.</p>
<h3>EM_REPLACESEL</h3>
<p>
The EM_REPLACESEL message is sent by an application to an edit control to replace the current selection in an edit control. If there is no current selection, the text is inserted at the current caret position. An application specifies the new text by passing a far pointer to the text in the <i>lParam</i> parameter. The new text must be null-terminated. This message is useful to replace a portion of the contents of an edit control.</p>
<h3>EM_SETMODIFY</h3>
<p>
The EM_SETMODIFY message is sent by an application to an edit control to set or clear the modification flag for an edit control. The modification flag indicates whether the text within the edit control has been modified. It is automatically set whenever the user changes the text. The value of the modification flag may be retrieved by sending an EM_GETMODIFY message.</p>
<p>
An application specifies the new value for the modification flag in the <i>wParam</i> parameter.</p>
<h3>EM_SETPASSWORDCHAR</h3>
<p>
The EM_SETPASSWORDCHAR message is sent by an application to an edit control to set or remove a password character displayed in an edit control when the user enters text. When a password character is set, that character is displayed for each character the user types.</p>
<p>
This message has no effect on a multiple-line edit control.</p>
<p>
An application specifies the new password character in the <i>wParam</i> parameter. If the value is zero, the actual characters typed by the user are displayed. This message can be used to effectively set or remove the ES_PASSWORD style on an edit control.</p>
<p>
When the EM_SETPASSWORDCHAR message is received by an edit control, it redraws all visible characters using the character specified.</p>
<h3>EM_SETREADONLY (Windows Version 3.1 or Later)</h3>
<p>
The EM_SETREADONLY message is sent by an application to an edit control to set the read-only state of an edit control. This message sets or removes the ES_READONLY style on an edit box. An application specifies the new state in the <i>wParam</i> parameter of the message.</p>
<h3>EM_SETRECT</h3>
<p>
The EM_SETRECT message is sent by an application to an edit control to set the formatting rectangle of a multiple-line edit control. The formatting rectangle is the rectangle into which the text of the edit control will be drawn. Initially, this is the same size as the edit control. By using the EM_SETRECT message, an application can make the formatting rectangle larger or smaller than the edit-control window.</p>
<p>
This message is processed only by multiple-line edit controls.</p>
<p>
To set a new formatting rectangle, an application sends a far pointer to a <b>RECT</b> structure that contains the new rectangle points.</p>
<p>
The EM_SETRECT message causes the text of the edit control to be redrawn. To change the size of the formatting rectangle without redrawing the text, an application must use the EM_SETRECTNP message.</p>
<p>
If the edit control does not have a horizontal scroll bar, and the application sets the formatting rectangle to be larger than the edit-control window, Windows clips lines of text exceeding the width of the edit-control window (but smaller than the width of the format rectangle).</p>
<p>
If the edit control contains a border, the formatting rectangle is reduced by the size of the border. If the application adjusts the rectangle returned by an EM_GETRECT message, the application must remove the size of the border before using the rectangle with the EM_SETRECT message.</p>
<h3>EM_SETRECTNP</h3>
<p>
The EM_SETRECTNP message is sent by an application to an edit control to set the formatting rectangle of a multiple-line edit control without having the edit control redrawn. This message causes the same actions as the EM_SETRECT message, except that the EM_SETRECT message causes the edit control to redraw the text while EM_SETRECTNP does not.</p>
<h3>EM_SETSEL</h3>
<p>
The EM_SETSEL message is sent by the application to an edit control to select a range of characters within the edit control or to place the caret within the edit control. The <i>lParam</i> argument for the EM_SETSEL message is used to specify the starting and ending character for the selection. The low-order word specifies the starting character position of the selection, and the high-order word specifies the ending character position. These character positions are specified with their offsets from the first character in the edit control, with the first character at offset 0. When the ending selection is –1 (0xffff) and the starting position is 0, all the text in the edit control is selected. When the starting position is –1 ( (0xffff), any current selection is unselected. When the starting and ending positions are the same, the caret is placed after the specified position and no text is selected.</p>
<p>
For example, use these lines of code to accomplish these actions:
<ul type=disc>
<li>
To select the 10th through 20th characters in an edit control:<pre><code>SendMessage(hEditWnd, EM_SETSEL, 0, MAKELONG(9,19) );
</code></pre>
</li>
<li>
To deselect a selection:<pre><code>SendMessage(hEditWnd, EM_SETSEL, 0, MAKELONG(0xffff, 0) );
</code></pre>
</li>
<li>
To set the caret at the end of the edit control:<pre><code>SendMessage(hEditWnd, EM_SETSEL, 0, MAKELONG(0xffff, 0xffff) );
</code></pre>
</li>
<li>
To set the caret after the position of the Nth character:<pre><code>SendMessage(hEditWnd, EM_SETSEL, 0, MAKELONG(N, N) );
</code></pre>
</li>
</ul>
<p>
The order of the start and end positions is not important. The edit control always places the caret at the high end of the selection. If the selection is too large to be displayed within the edit control, the text is scrolled as far to the left as necessary to display the caret.</p>
<p>
In Windows version 3.1, an application can set the <i>wParam</i> to 1 to cause the edit control not to scroll the caret into view.</p>
<h3>EM_SETTABSTOPS</h3>
<p>
An application sends an EM_SETTABSTOPS message to set the tab stops in a multiple-line edit control. When text is copied to a multiple-line edit control, any tab character in the text causes space to be generated up to the next tab stop.</p>
<p>
This message is processed only by multiple-line edit controls.</p>
<p>
An application specifies the number of tab stops contained in the <i>wParam</i> parameter. If this parameter is 0, the <i>lParam</i> parameter is ignored, and default tab stops are set at every 32 dialog box units. If this parameter is 1, tab stops are set at every <i>n</i> dialog box units, where <i>n</i> is the distance pointed to by the <i>lParam</i> parameter. If this parameter is greater than 1, <i>lParam</i> points to an array of tab stops, given in dialog box units.</p>
<p>
The low-order and high-order words of <i>lParam</i> point to an array of unsigned integers specifying the tab stops. If the <i>wParam</i> parameter is 1, <i>lParam</i> points to an unsigned integer containing the distance between all tab stops, given in dialog box units.</p>
<p>
The EM_SETTABSTOPS message does not automatically redraw the edit-control window. If the application is changing the tab stops for text already in the edit control, it should call the <b>InvalidateRect</b> function to redraw the edit-control window.</p>
<p>
The example that follows sends an EM_SETTABSTOPS message to set tab stops at every 64 dialog box units. It then calls <b>InvalidateRect</b> to redraw the edit window.</p>
<pre><code>WORD wTabSpacing = 64;
SendDlgItemMessage(hdlg, ID_MYEDITCONTROL, EM_SETTABSTOPS, 1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (DWORD) (LPWORD) &amp;wTabSpacing);
InvalidateRect(GetDlgItem(hdlg, ID_MYEDITCONTROL), NULL, TRUE);
</code></pre>
<p>
In Windows version 3.0, edit controls calculate tab-stop positions on the size of the default system font. This can cause incompatibilities between tab stops set for edit controls and list boxes that base tab-stop calculations on the size of the font used in the list box. When an array of tab-stop positions is used to set the tab stops for an edit control and a list box in Windows version 3.0, the tab positions may not line up the same for both the edit control and the list box. Windows version 3.1 calculates the tab-stop positions using the control's font in both list boxes and edit controls.</p>
<h3>EM_SETWORDBREAK</h3>
<p>
EM_SETWORDBREAK is documented for Windows version 3.0 but, unfortunately, is not implemented. This message was dropped from Windows version 3.1 and replaced with EM_SETWORDBREAKPROC.</p>
<h3>EM_SETWORDBREAKPROC</h3>
<p>
The EM_SETWORDBREAKPROC message is sent by an application to an edit control to replace the default word-break function with an application-defined word-break function.</p>
<p>
An application sends the procedure-instance address of the new word-break function in the <i>lParam</i> parameter. This address is obtained with the <b>MakeProcInstance</b> function, and the new word-break function must be exported in the application module definition file.</p>
<h4>Word-break function</h4>
<p>
A word-break function scans a text buffer, which contains text to be sent to the display, looking for the first word that will not fit on the current display line. The word-break function places this word at the beginning of the next line on the display. A word-break function defines at what point Windows should break a line of text for multiple-line edit controls, usually at a blank character that separates two words. Either a multiple-line or a single-line edit control might call this function when the end user presses arrow keys in combination with the CTRL key to move the cursor to the next word or previous word. The default word-break function breaks a line of text at a blank character. The application-defined function may define a word break to be a hyphen or a character other than the blank character.</p>
<p>
There are three action codes that a word-break function must respond to:
<ul type=disc>
<li>
WB_LEFT: The word-break function must look for the beginning of a word to the left of the current position.<br><br></li>
<li>
WB_RIGHT: The word-break function must look for the beginning of a word to the right of the current position.<br><br></li>
<li>
WB_ISDELIMITER: The word-break function must check if the character at the current position is a delimiter. The example that follows illustrates these three action codes:<pre><code>//
// Sample WordBreakProc
//
// This routine uses "." as delimiters instead of spaces.
//
int FAR PASCAL WordBreakProc(LPSTR lpszEditText, int ichCurrent,
 &nbsp; int chEditText, int wActionCode)
{
 &nbsp; char FAR *lpCurrentChar;
 &nbsp; int&nbsp; nIndex;

 &nbsp; switch (wActionCode) {

 &nbsp;&nbsp;&nbsp;&nbsp; case WB_LEFT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Look for the beginning of a word to the left
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the current position.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( lpCurrentChar = lpszEditText+ichCurrent,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nIndex = ichCurrent; nIndex &gt;= 0; nIndex--,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpCurrentChar = AnsiPrev(lpszEditText,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpCurrentChar) )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( *lpCurrentChar == '.' ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ++nIndex;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case WB_RIGHT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Look for the beginning of a word to the right
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the current position.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( lpCurrentChar = lpszEditText+ichCurrent,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nIndex = ichCurrent; nIndex &lt; cchEditText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nIndex++,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpCurrentChar = AnsiNext(lpCurrentChar) )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( *lpCurrentChar == '.' ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpCurrentChar = AnsiNext(lpCurrentChar);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nIndex++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( *lpCurrentChar == '.' ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpCurrentChar = AnsiNext(lpCurrentChar);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nIndex++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nIndex;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cchEditText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case WB_ISDELIMITER:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Is the character at the current position a delimiter?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( lpszEditText[ichCurrent] == '.' )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; }
}
</code></pre>
</li>
</ul>
<h3>EM_UNDO</h3>
<p>
The EM_UNDO message is sent by an application to an edit control to undo the last edit control operation. Undo operations can also be undone.</p>
<h3>WM_GETTEXT</h3>
<p>
The WM_GETTEXT message is sent by an application to get the contents of an edit control. An application could use <b>GetWindowText</b>, <b>SendDlgItemMessage</b>, or <b>GetDlgItemText</b> to get the contents of an edit control as well.</p>
<p>
The following example shows how these functions can be used to get the contents of an edit control:</p>
<pre><code>char szText[128];
SendMessage(hEditWnd, WM_GETTEXT, 128, (LPSTR) szText);
SendDlgItemMessage(hWndDlg, ID_EDITCTL, WM_GETTEXT, 128,
 &nbsp; (LPSTR)szText);
GetWindowText(hEditWnd, (LPSTR) szText, 128);
GetDlgItemText(hWndDlg, ID_EDITCTL, (LPSTR) szText, 128 );
</code></pre>
<h3>WM_SETTEXT</h3>
<p>
The WM_SETTEXT message is sent by an application to set the contents of an edit control. An application could use <b>SetWindowText</b>, <b>SendDlgItemMessage</b>, or <b>SetDlgItemText</b> to set the contents of an edit control as well.</p>
<p>
The following example shows how these functions can be used to set the contents of an edit control:</p>
<pre><code>char szText[] = "This is sample Text";
SendMessage(hEditWnd, WM_SETTEXT, 0, (LPSTR) szText);
SendDlgItemMessage(hWndDlg, ID_EDITCTL, WM_SETTEXT, 0,
 &nbsp; (LPSTR)szText);
SetWindowText(hEditWnd, (LPSTR) szText);
SetDlgItemText(hWndDlg, ID_EDITCTL, (LPSTR) szText );
</code></pre>
<p>
When an application sends a WM_SETTEXT message to an edit control to set the text, or uses any of the other techniques above to set the text, more text than is allowed by an EM_LIMITTEXT message can be added to the control. This is a designed behavior for an edit control, allowing an application to have an edit control where only the first part is entered by the user while the rest is specified by the application. Unfortunately, when the application adds more text to a control than is allowed with the EM_LIMITTEXT message, the user can edit the entire text. To work around this problem, the application must either clear the edit control before allowing the user to enter text or truncate the added text to less than the limit set by EM_LIMITTEXT.</p>
<h2>Using a Multiple-Line Edit Control's Text Buffer Handle</h2>
<p>
Windows stores the contents of a multiple-line edit control in a buffer that Windows allocates by calling <b>LocalAlloc</b>. An application can use the return value of <b>LocalAlloc</b> to read the contents of an edit control without the overhead of having the multiple-line edit control copy the text (using <b>GetWindowText</b>, for example) into another buffer supplied by the application. It is also possible for an application to change the contents of the multiple-line edit control in place or to quickly change the contents of a multiple-line edit control by setting the text buffer handle.</p>
<p>
The return value of <b>LocalAlloc</b> is the handle to a memory block allocated in the local heap used by the multiple-line edit control. For a multiple-line edit control outside of a dialog box, this local heap will be in the application's data segment; thus, the text buffer is allocated from the application's local heap, and the application can use the local heap functions <b>LocalLock</b> and <b>LocalUnlock</b> to establish a pointer by which the application can access the text.</p>
<p>
The dialog manager sets up a local heap for each dialog box that has an edit control. Text buffers for edit controls in dialog boxes are not in the application's local heap; therefore, the local heap functions cannot be used directly to access the text. Edit controls that are created as child windows and are given an alternate local heap to use also have their text buffers outside of the application's local heap and cannot use the local heap functions. See the "Edit Controls and Memory" section, earlier in this article.</p>
<p>
There are two ways for an application to make use of a multiple-line edit control's text buffer handle:
<ul type=disc>
<li>
If you use the DS_LOCALEDIT style to create a dialog box with multiple-line edit controls, the dialog manager uses the application's local heap for the edit controls in the dialog box. This means that all text buffer handles are from the application's local heap. One drawback of this method is that the amount of memory available for the edit controls to store their data is less than when the edit controls have a local heap of their own.<br><br></li>
<li>
An application can adjust the "current local heap" to the local heap used by the multiple-line edit control. Once the switch is made, the local heap functions can be used. After accessing the data, the application can then switch the local heap back to the application's local heap. To do this, some code must be written in assembly language. The following code demonstrates how to switch to the multiple-line edit control's local heap:<pre><code>&nbsp;&nbsp;&nbsp;WORD wEditSelector, wEditCtl;
 &nbsp; HANDLE hMem;
 &nbsp; //
 &nbsp; // Get the handle.
 &nbsp; //
 &nbsp; hMem =(HANDLE) SendMessage(hWndEdit, EM_GETHANDLE, 0, 0L);

 &nbsp; // Switch local heaps.
 &nbsp; //
 &nbsp; // Edit controls keep the handle to their local heap in the
 &nbsp; // hInstance member of their window information structure.
 &nbsp; //
 &nbsp; wEditCtl = (WORD) GetWindowWord( hWndEdit, GWW_HINSTANCE);
 &nbsp; // GlobalHandle always returns the handle to a global object
 &nbsp; // in the LOWORD and the selector in HIWORD.
 &nbsp; //
 &nbsp; wEditSelector = HIWORD(GlobalHandle(wEditCtl));

 &nbsp; //
 &nbsp; // Save the Data Segment; then set the Data Segment
 &nbsp; // to the local heap's selector.
 &nbsp; //
 &nbsp; //
 &nbsp; _asm {
 &nbsp;&nbsp;&nbsp;&nbsp; push DS
 &nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; AX,wEditSelector
 &nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; DS,AX
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; //
 &nbsp; // Do something with the text.
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; int i, length, NumChars;

 &nbsp;&nbsp;&nbsp; // ***************************************
 &nbsp;&nbsp;&nbsp; //&nbsp; IMPORTANT...IMPORTANT...IMPORTANT
 &nbsp;&nbsp;&nbsp; // ***************************************
 &nbsp;&nbsp;&nbsp; // Only use stack variables and the pointer
 &nbsp;&nbsp;&nbsp; // to text. At this moment SS != DS and all
 &nbsp;&nbsp;&nbsp; // the application's DS-based variables are
 &nbsp;&nbsp;&nbsp; // unavailable.
 &nbsp;&nbsp;&nbsp; // ********************************************
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBufText = LocalLock(hNewMem);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length = strlen(pBufText);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( i = 0, NumChars = 0; i &lt; length; i++ )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( isalpha(pBufText[i]) )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumChars++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBufText = LocalUnlock(hNewMem);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Switch DS back.
 &nbsp;&nbsp;&nbsp; //

 &nbsp;&nbsp;&nbsp; _asm {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp; DS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
</li>
</ul>
<h4>EM_GETHANDLE</h4>
<p>
An application sends the EM_GETHANDLE message to a multiple-line edit control to get the edit control's text buffer handle. Each time an application needs to access the multiple-line edit control's contents, it must send this message to the edit control. There are two reasons for this:
<ul type=disc>
<li>
Because text is being added to the edit control or removed from the edit control, it may be necessary for the edit control to reallocate the text buffer. It is possible that, when the edit control reallocates the text buffer, the handle to the buffer may change.<br><br></li>
<li>
An edit control will null-terminate its text before passing the handle back to the application. Normally, an edit control does not keep its text null-terminated. When text is added to an edit control, any null-terminator that was on the text will be overwritten. If an application keeps the handle to the edit control's text buffer between input by the user into the edit control, it will no longer know how much text is in the edit control. An application could use the <b>GetWindowTextLength</b> function to get the edit control's text length.</li>
</ul>
<h4>EM_SETHANDLE</h4>
<p>
An application sends the EM_SETHANDLE message to a multiple-line edit control to set the edit control's text buffer handle. This handle must be allocated from the local heap that the edit control is using. If the edit control is using a local heap other than the application's default local heap, the application must switch the "current local heap" to the local heap used by the edit control before allocating a new handle.</p>
<p>
If an application is using the DS_LOCALEDIT style on a dialog box (or the edit control is a child window without its own local heap) and the application gets the text buffer handle using the EM_GETHANDLE message and then replaces the handle using the EM_SETHANDLE message, the application must be sure to free the memory block when it is no longer needed. If the application fails to free the block, it continues to use memory until the application is terminated.</p>
<p>
The following example switches an edit control's text buffer between two buffers:</p>
<pre><code>BOOL FAR PASCAL DialogMsgProc(HWND hWndDlg, WORD Message, WORD
 &nbsp; wParam, LONG lParam)
{
 static int&nbsp;&nbsp;&nbsp; nHandleNum = -1;
 static HANDLE hMem[2];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; *pBufText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp; wEditCtlDS;

 switch(Message)
 &nbsp; {
 &nbsp;&nbsp; case WM_CLOSE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No need to free extra buffer because heap it is from
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // will be freed.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EndDialog(hWndDlg, FALSE);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; // End of WM_CLOSE

 &nbsp;&nbsp; case WM_COMMAND:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(wParam)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 202: // Switch buffers.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE hNewMem;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp; wEditSelector;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nHandleNum == -1 ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Get the handle to the original memory */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hMem[0] = (HANDLE) LOWORD
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SendMessage(GetDlgItem(hWndDlg,101),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EM_GETHANDLE, 0, 0L));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wEditCtlDS =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (WORD)GetWindowWord(GetDlgItem(hWndDlg,101),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GWW_HINSTANCE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wEditSelector =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(GlobalHandle(wEditCtlDS));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asm {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push DS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; AX,wEditSelector
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; DS,AX
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Allocate new memory. */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hNewMem = LocalAlloc(LMEM_MOVEABLE |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LMEM_ZEROINIT, 64);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asm {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp; DS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hMem[1] = hNewMem;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nHandleNum = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the old handle.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We do this EACH TIME for two reasons:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1. It may have changed with a realloc.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2. Windows needs to put the NULL byte at the
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // end of the string. EM_GETHANDLE will ensure
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // this.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hMem[nHandleNum] = (HANDLE)LOWORD(SendMessage(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDlgItem(hWndDlg,101), EM_GETHANDLE, 0, 0L));

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Switch DS and lock handle.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hNewMem = hMem[nHandleNum];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wEditCtlDS =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (WORD)GetWindowWord(GetDlgItem(hWndDlg,101),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GWW_HINSTANCE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wEditSelector =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(GlobalHandle(wEditCtlDS));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asm {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push DS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; AX,wEditSelector
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; DS,AX
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }


 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do something with the text...count spaces.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i, count;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBufText = LocalLock(hNewMem);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( i =0; i &lt; strlen(pBufText); i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( pBufText[i] == ' ')
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBufText = LocalUnlock(hNewMem);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Switch DS back.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asm {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp; DS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }


 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( nHandleNum == 0 )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nHandleNum = 1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nHandleNum = 0;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Set the handle to the new buffer. */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage(GetDlgItem(hWndDlg,101),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EM_SETHANDLE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hMem[nHandleNum], 0L);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp; /* End of WM_COMMAND

 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp; }
 return TRUE;
} /* End of DialogMsgProc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
</code></pre>
<h2>Notification Messages</h2>
<p>
The edit control's parent window receives notification messages through WM_COMMAND messages.</p>
<p>
The <i>wParam</i> parameter specifies the identifier of the edit control, and the <i>lParam</i> parameter specifies the handle to the edit control in the low-order word and the notification code in the high-order word.</p>
<h3>EN_CHANGE</h3>
<p>
An edit control sends the EN_CHANGE notification code when the user takes an action that may have altered text in an edit control. This notification code is sent after Windows updates the display (unlike the EN_UPDATE notification code). In Windows version 3.0, this message was sent at the wrong time during an Undo operation. When an edit control received an EM_UNDO message, the operation was performed in two steps:
<ol>
<li>
The edit control removed any text that was added.<br><br></li>
<li>
The edit control inserted any text that had been deleted.</li>
</ol>
<p>
Windows version 3.0 would send an EN_CHANGE message after the first step instead of after the second step. If an application used <b>GetWindowText</b> to get the contents of the edit control in response to the EN_CHANGE message, the application could receive incorrect text. This problem has been corrected in Windows version 3.1.</p>
<h3>EN_ERRSPACE</h3>
<p>
The EN_ERRSPACE notification code is sent when an edit control cannot allocate enough memory to meet a specific request.</p>
<h3>EN_HSCROLL</h3>
<p>
The EN_HSCROLL notification code is sent when the user clicks an edit control's horizontal scroll bar. The parent window is notified before the display is updated.</p>
<h3>EN_KILLFOCUS</h3>
<p>
The EN_KILLFOCUS notification code is sent when an edit control loses the input focus.</p>
<h3>EN_MAXTEXT</h3>
<p>
The EN_MAXTEXT notification code is sent when any of these conditions exist:
<ul type=disc>
<li>
The current insertion has exceeded the specified number of characters for the edit control and has been truncated.<br><br></li>
<li>
An edit control does not have the ES_AUTOHSCROLL style, and the number of characters to be inserted would exceed the width of the edit control.<br><br></li>
<li>
An edit control does not have the ES_AUTOVSCROLL style, and the total number of lines resulting from a text insertion would exceed the height of the edit control.</li>
</ul>
<p>
In Windows version 3.1, the EN_MAXTEXT message is sent by a multiple-line edit control when an attempt is made to insert text into an edit control where the maximum number of characters has already been reached or will be reached with the addition of new characters. Single-line edit controls and multiple-line edit controls in Windows version 3.0 only send EN_MAXTEXT messages when an insertion is unable to add all its characters because that insertion causes the maximum number of characters to be reached.</p>
<h3>EN_SETFOCUS</h3>
<p>
The EN_SETFOCUS notification code is sent when an edit control receives the input focus.</p>
<h3>EN_UPDATE</h3>
<p>
The EN_UPDATE notification code is sent when the edit control is about to display altered text. This notification is sent after the control has formatted the text but before it displays the text. This makes it possible to alter the window size, if necessary.</p>
<h3>EN_VSCROLL</h3>
<p>
The EN_VSCROLL notification code is sent when the user clicks an edit control's vertical scroll bar. The parent window is notified before the display is updated.</p>
<h2>Common Techniques</h2>
<p>
The following techniques help to solve some common problems with edit controls.</p>
<h3>Finding the Caret Position</h3>
<p>
An application can perform the following steps to determine the current position of the caret:</p>
<pre><code>{
 &nbsp; WORD&nbsp; wLineNumber;
 &nbsp; WORD&nbsp; wLineIndex;
 &nbsp; WORD&nbsp; dwGetSel;
 &nbsp; WORD&nbsp; wStart;
 &nbsp; WORD&nbsp; wEnd;
 &nbsp; WORD&nbsp; wColNumber;
 &nbsp; char&nbsp; szBuffer[128];

 &nbsp; wLineNumber = (WORD)SendMessage(GetDlgItem(hWndDlg,IDEDIT),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EM_LINEFROMCHAR, -1, 0L);

 &nbsp; // Send the EM_GETSEL message to the edit control.
 &nbsp; // The low-order word of the return value is the character
 &nbsp; // position of the caret relative to the first character in the
 &nbsp; // edit control.
 &nbsp; dwGetSel = (WORD)SendMessage(GetDlgItem(hWndDlg,101), EM_GETSEL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0L);
 &nbsp; wStart = LOWORD(dwGetSel);

 &nbsp; // Send the EM_LINEINDEX message with the value of -1 in wParam.
 &nbsp; // The return value is the absolute number of characters
 &nbsp; // that precede the first character in the line containing
 &nbsp; // the caret.
 &nbsp; wLineIndex = (WORD)SendMessage(GetDlgItem(hWndDlg,101),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EM_LINEINDEX, -1, 0L);

 &nbsp; // Subtract the LineIndex from the start of the selection,
 &nbsp; // and then add 1 (since the column is zero-based).
 &nbsp; // This result is the column number of the caret position.
 &nbsp; wColNumber = wStart - wLineIndex;

 &nbsp; sprintf(szBuffer,"Caret at Line:%d Column:%d", wLineNumber+1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wColNumber+1);
 &nbsp; MessageBox(hWndDlg, szBuffer, "Current Caret Position",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_APPLMODAL);
}
</code></pre>
<h3>Finding the First Visible Line</h3>
<p>
Windows versions 3.1 and later supply the edit-control message EM_GETFIRSTVISIBLELINE, which an application can use to obtain the topmost visible line. Windows version 3.0 did not supply this edit-control message. An application can perform the following steps to determine the topmost visible line in Windows version 3.0:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;{
 &nbsp;&nbsp; TEXTMETRIC&nbsp;&nbsp; tm;
 &nbsp;&nbsp; HDC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDC;
 &nbsp;&nbsp; HFONT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFont;
 &nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iLine;
 &nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iSel;
 &nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iTopLine;
 &nbsp;&nbsp; POINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pt;

 &nbsp; iSel=(WORD)SendMessage(hWndEdit, EM_GETSEL, NULL, 0L);
 &nbsp; // Get the line number; add 1 to correct for zero-based.
 &nbsp; iLine=(WORD)SendMessage(hWndEdit, EM_LINEFROMCHAR, iSel, 0L)+1;

 &nbsp; // Call GetCaretPos() to fill a POINT structure with the caret
 &nbsp; // coordinates relative to the client area of the edit control.
 &nbsp; // (The client area is inside the border.)
 &nbsp; GetCaretPos(&amp;pt);

 &nbsp; // Call GetDC using the handle to the edit control. The return
 &nbsp; // value is the handle to a display context for subsequent
 &nbsp; // operations.
 &nbsp; hDC=GetDC(hWndEdit);

 &nbsp; // Send the WM_GETFONT message to the edit control. The return
 &nbsp; // value is a handle to the font currently used by the edit
 &nbsp; // control.
 &nbsp; hFont=SendMessage(hWndEdit, WM_GETFONT, 0, 0L);

 &nbsp; // If the font used is not the system font, select it.
 &nbsp; if (hFont != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SelectObject(hDC, hFont);

 &nbsp; // Call GetTextMetrics using hDC to fill a TEXTMETRIC structure
 &nbsp; // with information about the font used by the edit control,
 &nbsp; // which is selected into hDC. The field of interest is
 &nbsp; // tmHeight.
 &nbsp; GetTextMetrics(hDC, &amp;tm);
 &nbsp; ReleaseDC(hWndEdit, hDC);

 &nbsp; cyLine=tm.tmHeight;

 &nbsp; // Calculate the first visible line.
 &nbsp; // While the vertical coordinate of the caret is greater than
 &nbsp; // tmHeight, subtract tmHeight from the vertical coordinate and
 &nbsp; // subtract 1 from the line number of the caret.
 &nbsp; // The value remaining in the line number variable is the line
 &nbsp; // number of the first visible line in the edit control.
 &nbsp; iTopLine=iLine;
 &nbsp; while (pt.y &gt; cyLine) {
 &nbsp;&nbsp;&nbsp;&nbsp; pt.y -=cyLine;
 &nbsp;&nbsp;&nbsp;&nbsp; iTopLine--;
 &nbsp; }
}
</code></pre>
<h3>Coloring an Edit Control</h3>
<p>
Each time an edit control is about to be painted to the screen, Windows sends the parent window a WM_CTLCOLOR message. The <i>wParam</i> parameter contains the handle to the display context of the edit control, the low-order word of the <i>lParam</i> parameter identifies the edit control, and the high-order word of <i>lParam</i> contains CTLCOLOR_EDIT. The application can set the color or pattern for the edit control by returning a handle to a brush. Brush handles can be obtained by selecting a stock object or by building a brush from a pattern bitmap. The application can also set the text foreground and background colors.</p>
<p>
The following code sets the colors for an edit control to white text on a gray background. The colors for other controls use the defaults.</p>
<pre><code>.
.
.
 &nbsp; case WM_CTLCOLOR:
 &nbsp;&nbsp;&nbsp;&nbsp; if ( HIWORD(lParam) == CTLCOLOR_EDIT ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set the text background color.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetBkColor(wParam, RGB(128,128,128));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set the text foreground color.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTextColor(wParam, RGB(255, 255, 255) );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Return the control background brush.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetStockObject(LTGRAY_BRUSH);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetStockObject(WHITE_BRUSH);
.
.
.
</code></pre>
<p>
In Windows version 3.0, there is a bug that caused a single-line edit control to be colored incorrectly. Windows would draw the control with the colors and brush from a WM_CTLCOLOR message and then again with the standard colors. Here are two workarounds to this problem:
<ul type=disc>
<li>
Create a multiple-line edit control instead of a single-line edit control.<br><br></li>
<li>
Use the following code instead of the code earlier in this section:<pre><code>.
.
.
 &nbsp; case WM_CTLCOLOR:
 &nbsp;&nbsp;&nbsp;&nbsp; if ( HIWORD(lParam) == CTLCOLOR_EDIT
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>|| HIWORD(lParam) == CTLCOLOR_MSGBOX</b> ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set the text background color.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetBkColor(wParam, RGB(128,128,128));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set the text foreground color.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTextColor(wParam, RGB(255, 255, 255) );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Return the control background brush.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetStockObject(LTGRAY_BRUSH);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetStockObject(WHITE_BRUSH);
.
.
.
</code></pre>
</li>
</ul>
<p>
<b>SetBkColor</b> does not support dithered colors. This is not specific to edit controls, but the application developer needs to be aware of the situation when attempting to color edit controls. Windows uses the closest solid color for background color of a control. Thus both of the following statements produce a gray control background with a 16-color driver:</p>
<pre><code>&nbsp;&nbsp;&nbsp;SetBkColor(wParam, RGB(64,128,128));
 &nbsp; SetBkColor(wParam, RGB(128,128,128));
</code></pre>
<p>
With a 256-color driver the first statement creates a gray/green background, and the second statement produces a gray background.</p>
<h3>Using an Edit Control for Clipboard I/O</h3>
<p>
Edit controls have built-in functionality to perform cut, copy, and paste operations between the control and the Clipboard. Using these built-in functions instead of writing the Clipboard I/O from scratch can be convenient, especially during the prototype and early development phases of a project or when time is extremely short. To take advantage of this built-in functionality, applications can create an edit control just for the purpose of Clipboard I/O. This technique results in an application that is slower and takes more memory than if you had developed the Clipboard I/O, but it is a quick way to program Clipboard I/O. Details on implementing this are available in the Knowledge Base under article Q35100.</p>
<h3>TAB and ENTER Keys for Multiple-Line Edit Controls in Dialog Boxes</h3>
<p>
When a multiple-line edit control is used in a dialog box, Windows assigns a default behavior for the ENTER and TAB keys. The ENTER key is used to perform the default function of the dialog box. Usually this is to accept any changes made in the dialog box and then dismiss the dialog box. When a user is editing text in a multiple-line edit control, it may be preferred to have the ENTER key advance to the next line of the edit control. By default, multiple-line edit controls accept CTRL+ENTER to advance to the next line.</p>
<p>
Similarly, by default the TAB key moves the input focus to the next control in the tabbing sequence. However, it might be useful for the user to be able to enter TAB characters in an edit control. By default, multiple-line edit controls accept CTRL+TAB to enter TAB characters in an edit control.</p>
<p>
The following sections describe four methods that can be used to implement alternative behavior for the ENTER and TAB keys. It should be noted that some users may object if the ENTER and TAB keys no longer act in the default fashion.</p>
<h4>Use ES_WANTRETURN in Windows version 3.1</h4>
<p>
Windows version 3.1 supplies a new edit control style, ES_WANTRETURN, which causes an ENTER key to advance to a new line and not be passed to the dialog manager. ES_WANTRETURN does not affect TAB keys.</p>
<h4>Subclass the edit control</h4>
<p>
An edit control subclass procedure could respond to the WM_GETDLGCODE message with DLGC_WANTALLKEYS to receive all keyboard input. This causes the edit control to be sent all key input, including ENTER and TAB keys. The following subclass procedure could be used:</p>
<pre><code>LONG FAR PASCAL AllKeyFunc(HWND hWnd, WORD Message, WORD wParam,
 &nbsp; LONG lParam)
{
 &nbsp; //
 &nbsp; // This subclass function makes pressing an ENTER key
 &nbsp; // create a new line when the focus is in an edit control.
 &nbsp; //

 &nbsp; if ( Message == WM_GETDLGCODE )
 &nbsp;&nbsp;&nbsp;&nbsp; return DLGC_WANTALLKEYS;

 &nbsp; return CallWindowProc(lpfnOldClassProc, hWnd, Message, wParam,
 &nbsp;&nbsp;&nbsp;&nbsp; lParam);
}
</code></pre>
<h4>Process the DM_GETDEFID message</h4>
<p>
Windows sends a DM_GETDEFID message to a dialog box procedure when the user presses ENTER in a dialog box. By intercepting this message and keeping track of whether the focus is in an edit control, an application can change the behavior of the ENTER key. This does not work for TAB keys. This technique takes these three steps:
<ol>
<li>
Process WM_COMMAND messages with the HIWORD(<i>lParam</i>) set to EN_SETFOCUS and EN_KILLFOCUS to determine if a multiple-line edit control has the focus. When EN_SETFOCUS signals that a multiple-line edit control has the focus, set a static flag to TRUE. When EN_KILLFOCUS signals that a multiple-line edit control has lost the focus, reset the flag to FALSE.<br><br></li>
<li>
When the dialog procedure receives a DM_GETDEFID message, an edit control has the focus, and if the ENTER key is down, then post a WM_CHAR message with <i>wParam</i> set to 0x0a to the edit control with the focus.<br><br></li>
<li>
If an edit control has the focus, the dialog function should return TRUE; otherwise, the function must return FALSE. Failing to do so keeps the ENTER key from behaving properly when an edit control does not have the focus.</li>
</ol>
<p>
The following code fragment demonstrates this procedure:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static fEditFocus;
 &nbsp;&nbsp;&nbsp; switch (msg)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case WM_COMMAND:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ID_EDIT is a multiline edit control.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ID_EDIT == wParam)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (EN_KILLFOCUS == HIWORD(lParam))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fEditFocus = FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (EN_SETFOCUS == HIWORD(lParam))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fEditFocus = TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DM_GETDEFID:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Check to see that an edit control has the focus
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * and that the ENTER key is down. DM_GETDEFID may be
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * sent in other situations when the user did not press
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the ENTER key.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fEditFocus &amp;&amp; (0x8000 &amp; GetKeyState(VK_RETURN)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostMessage(hEdit, WM_CHAR, 0x0A, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return FALSE;
</code></pre>
<h4>Intercept messages before calling IsDialogMessage</h4>
<p>
Applications that use modeless dialog boxes are required to filter messages through the <b>IsDialogMessage</b> function. <b>IsDialogMessage</b> modifies certain messages to implement dialog box behavior. For example, the ENTER key message is modified to generate a WM_COMMAND message with <i>wParam</i> set to IDOK.</p>
<p>
An application is, however, free to modify the message before passing it to <b>IsDialogMessage</b>. The code example below modifies the WM_KEYDOWN message containing a VK_RETURN to be an EM_REPLACESEL message with a carriage return (CR) and linefeed (LF) combination.</p>
<p>
The disadvantage to this method is that it places additional code in the main message loop for the application, slowing the processing of every message. In addition, code in the message loop is far removed from the dialog procedure and is therefore harder to maintain.</p>
<p>
The following code fragment demonstrates this method:</p>
<pre><code>// hWndEditControl is the handle to the multiline edit control.
// hWndModeless is the handle to the modeless dialog box.
while (GetMessage(&amp;msg, NULL, 0, 0)) {
 &nbsp; if (msg.hWnd == hWndEditControl
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; msg.message == WM_KEYDOWN
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; msg.wParam == VK_RETURN) {
 &nbsp;&nbsp;&nbsp;&nbsp; // Normally, Windows will translate this to IDOK.
 &nbsp;&nbsp;&nbsp;&nbsp; // Perform a custom translation to something more
 &nbsp;&nbsp;&nbsp;&nbsp; // useful (replace selection with carriage-return,
 &nbsp;&nbsp;&nbsp;&nbsp; // line feed).
 &nbsp;&nbsp;&nbsp;&nbsp; msg.message = EM_REPLACESEL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.wParam&nbsp; = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.lParam&nbsp; = (long)(LPSTR)"\015\012";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; if (!IsDialogMessage(hWndModeless, &amp;msg)) {
 &nbsp;&nbsp;&nbsp;&nbsp; TranslateMessage(&amp;msg);
 &nbsp;&nbsp;&nbsp;&nbsp; DispatchMessage(&amp;msg);
 &nbsp; }
}
</code></pre>
<p>
If the functionality of a modal dialog box is desired in an application but you still want to use this interception method, it can be simulated by using a modeless dialog box that disables its parent window when the dialog box is created.</p>
<h3>Read-Only Edit Control</h3>
<p>
Windows versions 3.1 and later supply an ES_READONLY edit control style and the EM_SETREADONLY edit control message to make an edit control read-only. Windows version 3.0 did not supply these features. The easiest way to make an edit control read-only in Windows version 3.0 is to subclass the edit control and have the subclass function absorb any messages that would cause the edit control to change its contents.</p>
<p>
Here is how to make an edit control read-only in Windows version 3.0:</p>
<pre><code>// Declare the subclass function.
long FAR PASCAL SubEditWndProc(HWND hWnd, unsigned wMessage,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD wParam, LONG lParam);

//
// Create an edit control.
//
hWndEdit=CreateWindow("EDIT",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Edit Control Line Numbers",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_OVERLAPPEDWINDOW,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 35, 35, 400, 150,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, NULL, hInstance, NULL);
//
// Subclass the edit control.
//
static FARPROC&nbsp;&nbsp;&nbsp;&nbsp; lpSubClassProc;

lpSubClassProc=MakeProcInstance((FARPROC)SubEditWndProc,hInstance);
 &nbsp;&nbsp;&nbsp; SetWindowLong(hWndEdit, GWL_WNDPROC, (LONG)lpSubClassProc);
.
.
.

//
// Read-only subclass function for an edit control.
//
long FAR PASCAL SubEditWndProc(HWND hWnd, unsigned wMessage, WORD
 &nbsp; wParam, LONG lParam)
{
 &nbsp; switch ( wMessage ) {
 &nbsp;&nbsp;&nbsp;&nbsp; case WM_CUT:
 &nbsp;&nbsp;&nbsp;&nbsp; case WM_KEYDOWN:
 &nbsp;&nbsp;&nbsp;&nbsp; case WM_PASTE:
 &nbsp;&nbsp;&nbsp;&nbsp; case WM_CHAR:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do nothing here.
 &nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CallWindowProc (lpPrevWndFunc, hWnd, wMessage, wParam,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lParam );
 &nbsp; }
}
</code></pre>
<h2>Final Warnings</h2>
<p>
In working with edit controls, you need to be aware of some situations to avoid.</p>
<h3>Don't Use getc with Edit Controls</h3>
<p>
When an application uses <b>getc</b> in a Windows edit control, data corruption can occur. When an application uses an edit control and needs <b>getc</b> functionality, the <b>fgetc</b> function should be used because it does not produce the data corruption.</p>
<h3>Single-Line Edit Controls and the BACKSPACE Key</h3>
<p>
In Windows version 3.0, single-line edit controls that have a font larger than the default system font do not correctly implement the BACKSPACE key. When the user uses the BACKSPACE key to delete characters, the edit control does not remove the lower half of each character from the screen. This problem can be avoided by creating the edit control with the ES_MULTILINE attribute. If you do not specify the ES_AUTOVSCROLL attribute, the edit control will be a multiple-line edit control that behaves like a single-line edit control but will not exhibit this problem.</p>
</BODY>
</HTML>
