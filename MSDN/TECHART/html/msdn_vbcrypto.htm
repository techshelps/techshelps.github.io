<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A Cryptographic Filter Box Class in Visual Basic</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_vbcrypto"></a></sup>A Cryptographic Filter Box Class in Visual Basic</h1>
<p>
Steve Kirk<br>
Microsoft Developer Network Technology Group</p>
<p>
September 17, 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5004">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the VBCrypto sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
The Microsoft® Cryptography API (CryptoAPI for short) is a set of functions for maintaining security of data as it is transmitted over non-secure paths. This article demonstrates a cryptography class in Visual Basic® that encapsulates these functions in a <b>Cryptography</b> object. The Cryptography Filter Box object, <b>CryptoFilterBox</b>, brings a Component Object Model (COM) interface to applications that use encryption and digital signature techniques.</p>
<p>
The Microsoft CryptoAPI is the foundation of the Microsoft Internet Security Framework and provides system-level certificate management and cryptography functions to applications developers under Windows NT® version 4.0 and Windows® 95 with Internet Explorer 3.0.</p>
<h2>Interfacing with the Cryptographic Services Provider</h2>
<p>
The actual implementation of cryptographic services is done by the <i>cryptographic services</i> <i>provider</i> (CSP). Although a CSP is supplied with Windows NT 4.0 and Internet Explorer 3.0, many cryptographic companies are shipping or developing CSPs as software only or software/hardware combinations with a range of security levels, costs, and export restrictions. The architectural justification for an abstract interface that hides implementation details from the applications developer is strong for cryptographic services because:
<ul type=disc>
<li>
The application developer is shielded from the licensing and export issues raised by different cryptographic technologies. The CSP vendor and end user handle these issues independently from the applications developer. <br><br></li>
<li>
The application developer is shielded from technical differences in cryptographic technologies. The CSP looks the same to the application regardless of the actual vendor or cryptographic technology being employed.<br><br></li>
<li>
The CryptoAPI Architecture is shown below in Figure 1.</li>
</ul>
<p>
<img src="vbcrypto_1.gif" border=0></p>
<p class=label>
<b>Figure 1. CryptoAPI architecture</b></p>
<h2>High-Level Processes</h2>
<p>
Because the details of cryptographic functions are left to the CSP, the application developer only needs to be concerned with two high-level processes: <i>encryption</i> and <i>validation</i> <i>(signature/certification)</i>. </p>
<h3>Encryption</h3>
<p>
Encryption actually changes the content of the message. The main advantage of encryption is that an encrypted message cannot be read without decryption so the message is only readable by those privileged with the matching CSP and password or key. The main disadvantage of encryption is the high computing cost of encrypting the whole message and the resulting time delay.</p>
<h3>Validation</h3>
<p>
It is often more important to be able to validate a message for authenticity and integrity than to encrypt it. Signature validation and certificate validation authenticate the message source and verify that the message is not altered between the time that it is signed and the time that it is validated.</p>
<h4>Signature Validation</h4>
<p>
The message and an optional password are inputs to the signature process, which generates a signature. The message, signature, and password are examined during validation, which will fail if any of the components have changed.</p>
<h4>Certificate Validation</h4>
<p>
Certificate validation is similar to signature validation in that the process is used to authenticate the source of the message and to make sure that the message has not been altered. Certificate validation also identifies the source of the message via a certificate that includes the source's name and phone number. Certificate validation is offered as a protection against virus-carrying and malicious software being downloaded over the Internet, by providing identification of the source of the software. </p>
<h2>The CryptoFilterBox Object</h2>
<p>
The <b>CryptoFilterBox</b> object has methods and properties that provide the high-level cryptographic processes.</p>
<p>
<b>Table 1. CryptoFilterBox Methods</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=15%><b>Method</b></td>
<td width=85%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=15%><b>Encrypt</b></td>
<td width=85%>Encrypt the contents of InBuffer into OutBuffer</td>
</tr>
<tr valign=top>
<td width=15%><b>Decrypt</b></td>
<td width=85%>Decrypt the contents of InBuffer into OutBuffer</td>
</tr>
<tr valign=top>
<td width=15%><b>Sign</b></td>
<td width=85%>Create an electronic signature based on PrivateKey and the contents of InBuffer and place in Signature</td>
</tr>
<tr valign=top>
<td width=15%><b>Validate</b></td>
<td width=85%>Validate Signature based on InBuffer and PublicKey and place result in Valid</td>
</tr>
</table><br>
<p>
<b>Table 2. CryptoFilterBox Properties</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=27%><b>Property</b></td>
<td width=73%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=27%><b>InBuffer</b></td>
<td width=73%>Text input buffer (used for Sign, Validate, Decrypt, and Encrypt)</td>
</tr>
<tr valign=top>
<td width=27%><b>OutBuffer</b></td>
<td width=73%>Text output buffer (used for Decrypt and Encrypt)</td>
</tr>
<tr valign=top>
<td width=27%><b>Password</b></td>
<td width=73%>Text password buffer (used for Sign, Validate, Decrypt, and Encrypt)</td>
</tr>
<tr valign=top>
<td width=27%><b>Signature</b></td>
<td width=73%>Text signature buffer (used for Sign and Validate)</td>
</tr>
<tr valign=top>
<td width=27%><b>Status</b></td>
<td width=73%>Integer<br>
Invalid = 0<br>
Valid = 1<br>
Busy = 2</td>
</tr>
</table><br>
<h2>The CryptoFilterBox Class Module</h2>
<h3>Declarations Section of the Class Module</h3>
<p>
The following <b>Declare</b> <b>Function</b> statements create an interface between our Visual Basic class module and the cryptography functions in ADVAPI32.DLL. Use of the PRIVATE option hides these functions from everything outside the class module.</p>
<pre><code>Private Declare Function CryptAcquireContext Lib "advapi32.dll" _
 &nbsp; Alias "CryptAcquireContextA" (phProv As Long, pszContainer As _
 &nbsp; String, pszProvider As String, ByVal dwProvType As Long, ByVal _
 &nbsp; dwFlags As Long) As Long

Private Declare Function CryptCreateHash Lib "advapi32.dll" (ByVal _
 &nbsp; hProv As Long, ByVal Algid As Long, ByVal hKey As Long, ByVal _
 &nbsp; dwFlags As Long, phHash As Long) As Long

Private Declare Function CryptDeriveKey Lib "advapi32.dll" ( _
 &nbsp;&nbsp; ByVal hProv As Long, ByVal Algid As Long, ByVal hBaseData As Long, _
 &nbsp;&nbsp; ByVal dwFlags As Long, phKey As Long) As Long

Private Declare Function CryptDestroyHash Lib "advapi32.dll" (ByVal hHash _
 &nbsp; As Long) As Long

Private Declare Function CryptDestroyKey Lib "advapi32.dll" (ByVal hKey _
 &nbsp; As Long) As Long

Private Declare Function CryptEncrypt Lib "advapi32.dll" (ByVal hKey As _
 &nbsp; Long, ByVal hHash As Long, ByVal Final As Long, ByVal dwFlags As _
 &nbsp; Long, pbData As Byte, pdwDataLen As Long, ByVal dwBufLen As Long) As Long

Private Declare Function CryptExportKey Lib "advapi32.dll" (ByVal hKey As _
 &nbsp; Long, ByVal hExpKey As Long, ByVal dwBlobType As Long, ByVal dwFlags As _
 &nbsp; Long, pbData As Byte, pdwDataLen As Long) As Long

Private Declare Function CryptGenKey Lib "advapi32.dll" ( _
 &nbsp; ByVal hProv As Long, ByVal Algid As Long, ByVal dwFlags As Long, phKey _
 &nbsp; As Long) As Long

Private Declare Function CryptGetProvParam Lib "advapi32.dll" ( _
 &nbsp; ByVal hProv As Long, ByVal dwParam As Long, pbData As Any, _
 &nbsp; pdwDataLen As Long, ByVal dwFlags As Long) As Long

Private Declare Function CryptGetUserKey Lib "advapi32.dll" ( _
 &nbsp; ByVal hProv As Long, ByVal dwKeySpec As Long, phUserKey As Long) As Long

Private Declare Function CryptHashData Lib "advapi32.dll" (ByVal hHash As _
 &nbsp; Long, pbData As Byte, ByVal dwDataLen As Long, ByVal dwFlags As Long) As Long

Private Declare Function CryptReleaseContext Lib "advapi32.dll" (ByVal hProv _
 &nbsp; As Long, ByVal dwFlags As Long) As Long

Private Declare Function CryptSignHashA Lib "advapi32.dll" (ByVal hHash _
 &nbsp; As Long, ByVal dwKeySpec As Long, ByVal sDescription As String, ByVal _
 &nbsp; dwFlags As Long, pbSignature As Byte, pdwSigLen As Long) As Long

Private Declare Function CryptVerifySignatureA Lib "advapi32.dll" (ByVal _
 &nbsp; hHash As Long, pbSignature As Byte, ByVal dwSigLen As Long, ByVal _
 &nbsp; hPubKey As Long, ByVal sDescription As String, ByVal dwFlags As Long) As Long

'API error function
Private Declare Function GetLastError Lib "kernel32" () As Long

'API memory functions
Private Declare Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, _
 &nbsp; ByVal dwBytes As Long) As Long

Private Declare Function GlobalFree Lib "kernel32" (ByVal hMem As Long) As Long

Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long

Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As _
 &nbsp; Long

Private Declare Sub CpyMemValAdrFromRefAdr Lib "kernel32" Alias _
 &nbsp; "RtlMoveMemory" (ByVal hpvDest As Any, hpvSource As Any, ByVal _
 &nbsp; cbCopy As Long)

Private Declare Sub CpyMemRefAdrFromValAdr Lib "kernel32" Alias _
 &nbsp; "RtlMoveMemory" (hpvDest As Any, ByVal hpvSource As Any, ByVal _
 &nbsp; cbCopy As Long)
</code></pre>
<h3>Property Procedures</h3>
<p>
The property procedures handle assignment and retrieval of the object's properties.</p>
<p>
Each property that is exposed has a <b>Public Property Get</b> procedure corresponding to the property name.</p>
<pre><code>Public Property Get FileName() As String
'Return object's FileName property.
FileName = sFileName
End Property
</code></pre>
<p>
Each property that is writeable has a <b>Public Property Let</b> or <b>Public Property Set</b> corresponding to the property name. Object type properties have a <b>Public Property Set</b>. Non-object type properties have a <b>Public Property Let</b>.</p>
<pre><code>Public Property Let FileName(vNewValue As String)
'Handle assignment of object's FileName property.
sFileName = vNewValue
End Property
</code></pre>
<h3>Object Methods</h3>
<p>
Public procedures in the class module are exposed as methods on objects instantiated from the <b>CryptoFilterBox</b> Class. <b>Encrypt</b>, <b>Decrypt</b>, <b>Sign</b>, and <b>Verify</b> are the methods that are exposed.</p>
<h3>Encrypt Method</h3>
<p>
The <b>Encrypt</b> method is provided by <b>Public Sub Encrypt()</b> that encrypts <b>InBuffer</b> and places the result in <b>OutBuffer</b>.</p>
<pre><code>Public Sub Encrypt()
'Encrypt InBuffer into OutBuffer.
Dim lHExchgKey As Long
Dim lHkeyBlobLen As Long
Dim lHCryptprov As Long
Dim lHHash As Long
Dim lHkey As Long
Dim lResult As Long
Dim sContainer As String
Dim sProvider As String
ReDim aKeyBlob(0) As Byte
ReDim aPassword(0) As Byte
ReDim aCryptBuffer(0) As Byte
Dim lCryptLength As Long
Dim lCryptBufLen As Long
Dim lCryptPoint As Long
Dim lPasswordPoint As Long
Dim lPasswordCount As Long

On Error GoTo ErrEncrypt

'Switch Status property.
lStatus = CFB_BUSY

'Get handle to the default provider.
sContainer = Chr$(0)
sProvider = Chr$(0)
sProvider = MS_DEF_PROV &amp; Chr$(0)
If bApiNot(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal _
  sProvider, PROV_RSA_FULL, 0)) Then
 &nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptAcquireContext!")
 &nbsp;&nbsp; GoTo Done
End If

If sPassword = "" Then
 &nbsp;&nbsp; 'Encrypt the file with a random session key.
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Create a random session key.
 &nbsp;&nbsp; If bApiNot(CryptGenKey(lHCryptprov, ENCRYPT_ALGORITHM, CRYPT_EXPORTABLE, _
 &nbsp;&nbsp;&nbsp;&nbsp; lHkey)) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Error during CryptGenKey! " &amp; CStr(GetLastError))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GoTo Done
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Get handle to key exchange public key.
 &nbsp;&nbsp; If bApiNot(CryptGetUserKey(lHCryptprov, AT_KEYEXCHANGE, lHExchgKey)) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Error during CryptGetUserKey! " &amp; CStr(GetLastError))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GoTo Done
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; 'Determine size of the key blob and allocate memory.
 &nbsp;&nbsp; 'if(!CryptExportKey(hKey, hXchgKey, SIMPLEBLOB, 0, NULL, &amp;dwKeyBlobLen)) {
 &nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; printf("Error %x computing blob length!\n", GetLastError());
 &nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; goto done;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; 'Determine size of the key blob and allocate memory.
 &nbsp;&nbsp; If bApiNot(CryptExportKey(lHkey, lHExchgKey, SIMPLEBLOB, 0, 0, _
 &nbsp;&nbsp;&nbsp;&nbsp; lHkeyBlobLen)) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " computing blob length!")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GoTo Done
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ReDim aKeyBlob(lHkeyBlobLen)
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Export session key into a simple key blob.
 &nbsp;&nbsp; If bApiNot(CryptExportKey(lHkey, lHExchgKey, SIMPLEBLOB, 0, aKeyBlob(0), _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lHkeyBlobLen)) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptExportKey!")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GoTo Done
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Release key exchange key handle.
 &nbsp;&nbsp; CryptDestroyKey (lHExchgKey)
 &nbsp;&nbsp; lHExchgKey = 0
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Write size of key blob to destination file.
 &nbsp;&nbsp; 'Write key blob to destination file.

Else
 &nbsp;&nbsp; 'Encrypt the file with a session key derived from a password.

 &nbsp;&nbsp; 'Create a hash object.
 &nbsp;&nbsp; If bApiNot(CryptCreateHash(lHCryptprov, CALG_MD5, 0, 0, lHHash)) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptCreateHash!")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GoTo Done
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; 
 &nbsp;&nbsp; lPasswordCount = Len(sPassword)
 &nbsp;&nbsp; If lPasswordCount &gt; 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReDim aPassword(lPasswordCount - 1)
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; lPasswordPoint = 1
 &nbsp;&nbsp; While lPasswordPoint &lt;= lPasswordCount
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aPassword(lPasswordPoint - 1) = Asc(Mid$(sPassword, lPasswordPoint, 1))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lPasswordPoint = lPasswordPoint + 1
 &nbsp;&nbsp; Wend
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Hash in the password data.
 &nbsp;&nbsp; If bApiNot(CryptHashData(lHHash, aPassword(0), lPasswordCount, 0)) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptHashData!")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GoTo Done
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Derive a session key from the hash object.
 &nbsp;&nbsp; If bApiNot(CryptDeriveKey(lHCryptprov, ENCRYPT_ALGORITHM, lHHash, 0,_
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lHkey)) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptDeriveKey!")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GoTo Done
 &nbsp;&nbsp; End If

 &nbsp; 'Destroy the hash object.
 &nbsp; CryptDestroyHash (lHHash)
 &nbsp; lHHash = 0

End If

'ReDim aCryptBuffer(0) As Byte
'Dim lCryptLength As Long
'Dim lCryptBufLen As Long
'Dim lCryptPoint As Long

lCryptLength = Len(sInBuffer)
lCryptBufLen = lCryptLength * 2
ReDim aCryptBuffer(lCryptBufLen)
lCryptPoint = 1
While lCryptPoint &lt;= lCryptLength
 &nbsp;&nbsp; aCryptBuffer(lCryptPoint - 1) = Asc(Mid$(sInBuffer, lCryptPoint, 1))
 &nbsp;&nbsp; lCryptPoint = lCryptPoint + 1
Wend

'Encrypt data
If bApiNot(CryptEncrypt(lHkey, 0, 1, 0, aCryptBuffer(0), lCryptLength, _
 &nbsp; lCryptBufLen)) Then
 &nbsp;&nbsp; MsgBox ("bytes required:" &amp; CStr(lCryptLength))
 &nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptEncrypt!")
 &nbsp;&nbsp; 'GoTo Done
End If

sOutBuffer = ""
lCryptPoint = 0
While lCryptPoint &lt;= lCryptBufLen
 &nbsp;&nbsp; If aCryptBuffer(lCryptPoint) = 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lCryptPoint = lCryptBufLen
 &nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sOutBuffer = sOutBuffer &amp; Chr$(aCryptBuffer(lCryptPoint))
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; lCryptPoint = lCryptPoint + 1
Wend
 &nbsp;&nbsp; 
Done:

'Destroy session key.
 &nbsp;&nbsp; If (lHkey) Then lResult = CryptDestroyKey(lHkey)

'Release key exchange key handle.
 &nbsp;&nbsp; If lHExchgKey Then CryptDestroyKey (lHExchgKey)

'Destroy hash object.
 &nbsp;&nbsp; If lHHash Then CryptDestroyHash (lHHash)

'Release provider handle.
 &nbsp;&nbsp; If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)

'switch Status property
lStatus = CFB_READY

Exit Sub
ErrEncrypt:
 &nbsp;&nbsp; MsgBox ("ErrEncrypt " &amp; Error$)
 &nbsp;&nbsp; GoTo Done
End Sub
</code></pre>
<h3>Decrypt Method</h3>
<p>
The decrypt method does this, that, the other, and the other-other.</p>
<pre><code>Public Sub Decrypt()
'Decrypt InBuffer into OutBuffer
Dim lHExchgKey As Long
Dim lHkeyBlobLen As Long
Dim lHCryptprov As Long
Dim lHHash As Long
Dim lHkey As Long
Dim lResult As Long
Dim sContainer As String
Dim sProvider As String
ReDim aKeyBlob(0) As Byte
ReDim aPassword(0) As Byte
ReDim aCryptBuffer(0) As Byte
Dim lCryptLength As Long
Dim lCryptBufLen As Long
Dim lCryptPoint As Long
Dim lPasswordPoint As Long
Dim lPasswordCount As Long
On Error GoTo ErrDecrypt
'switch Status property
lStatus = CFB_BUSY
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
'Get handle to the default provider.
sContainer = Chr$(0)
sProvider = Chr$(0)
sProvider = MS_DEF_PROV &amp; Chr$(0)
If bApiNot(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal _
 &nbsp; sProvider, PROV_RSA_FULL, 0)) Then
 &nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptAcquireContext!")
 &nbsp;&nbsp; GoTo Done
End If

If sPassword = "" Then
'Decrypt the file with the saved session key.
'Read key blob length from source file and allocate memory.

 &nbsp;&nbsp; 'Import key blob into CSP.
 &nbsp;&nbsp; 'if(!CryptImportKey(hProv, pbKeyBlob, dwKeyBlobLen, 0, 0, &amp;hKey)) {
 &nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; printf("Error %x during CryptImportKey!\n", GetLastError());
 &nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; goto done;
 &nbsp;&nbsp; '}

Else
 &nbsp;&nbsp; 'Decrypt the file with a session key derived from a password.

 &nbsp;&nbsp; 'Create a hash object.
 &nbsp;&nbsp; 'if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash)) {
 &nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; printf("Error %x during CryptCreateHash!\n", GetLastError());
 &nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; goto done;
 &nbsp;&nbsp; '}

 &nbsp;&nbsp; 'Hash in the password data.
 &nbsp;&nbsp; 'if(!CryptHashData(hHash, szPassword, strlen(szPassword), 0)) {
 &nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; printf("Error %x during CryptHashData!\n", GetLastError());
 &nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; goto done;
 &nbsp;&nbsp; '}

 &nbsp;&nbsp; 'Derive a session key from the hash object.
 &nbsp;&nbsp; 'if(!CryptDeriveKey(hProv, ENCRYPT_ALGORITHM, hHash, 0, &amp;hKey)) {
 &nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; printf("Error %x during CryptDeriveKey!\n", GetLastError());
 &nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; goto done;
 &nbsp;&nbsp; '}

 &nbsp;&nbsp; 'Destroy the hash object.
 &nbsp;&nbsp; 'CryptDestroyHash(hHash);
 &nbsp;&nbsp; 'hHash = 0;

End If
'&nbsp;&nbsp;&nbsp; // Determine number of bytes to decrypt at a time. This must be a 
'&nbsp;&nbsp;&nbsp; // multiple of ENCRYPT_BLOCK_SIZE.
'&nbsp;&nbsp;&nbsp; dwBlockLen = 1000 - 1000 % ENCRYPT_BLOCK_SIZE;
'&nbsp;&nbsp;&nbsp; dwBufferLen = dwBlockLen;''''
'
'&nbsp;&nbsp;&nbsp; // Allocate memory.
'&nbsp;&nbsp;&nbsp; if((pbBuffer = malloc(dwBufferLen)) == NULL) {
'&nbsp;&nbsp;&nbsp; printf("Out of memory!\n");
'&nbsp;&nbsp;&nbsp; goto done;
'&nbsp;&nbsp;&nbsp; }
'
'&nbsp;&nbsp;&nbsp; // Decrypt source file and write to destination file.
'&nbsp;&nbsp;&nbsp; do {
'&nbsp;&nbsp;&nbsp; // Read up to 'dwBlockLen' bytes from source file.
'&nbsp;&nbsp;&nbsp; dwCount = fread(pbBuffer, 1, dwBlockLen, hSource);
'&nbsp;&nbsp;&nbsp; if(ferror(hSource)) {
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error reading Ciphertext!\n");
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto done;
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
'&nbsp;&nbsp;&nbsp; eof = feof(hSource);
'
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Decrypt data
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!CryptDecrypt(hKey, 0, eof, 0, pbBuffer, &amp;dwCount)) {
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error %x during CryptDecrypt!\n", GetLastError());
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto done;
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
'
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write data to destination file.
'&nbsp;&nbsp;&nbsp; fwrite(pbBuffer, 1, dwCount, hDestination);
'&nbsp;&nbsp;&nbsp; if(ferror(hDestination)) {
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error writing Plaintext!\n");
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto done;
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
'&nbsp;&nbsp;&nbsp; } while(!feof(hSource));
'

Done:

'Destroy session key.
 &nbsp;&nbsp; If (lHkey) Then lResult = CryptDestroyKey(lHkey)

'Release key exchange key handle.
 &nbsp;&nbsp; If lHExchgKey Then CryptDestroyKey (lHExchgKey)

'Destroy hash object.
 &nbsp;&nbsp; If lHHash Then CryptDestroyHash (lHHash)

'Release provider handle.
 &nbsp;&nbsp; If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)

'switch Status property
lStatus = CFB_READY

Exit Sub

ErrDecrypt:
MsgBox ("ErrDecrypt " &amp; Error$)
GoTo Done
End Sub
</code></pre>
<h3>Sign Method</h3>
<p>
The <b>Sign</b> method is provided by <b>Public Sub Sign()</b>, which creates a signature for the combination of the contents of <b>InBuffer</b> and <b>Password</b> and places it in <b>Signature</b>.</p>
<pre><code>Public Sub Sign()
'Create a signature for Inbuffer and place in Signature.
Dim sContainer As String
Dim sDescription As String
Dim sProvider As String
Dim lDataLen As Long
Dim lDataPoint As Long
Dim lHCryptprov As Long
Dim lHHash As Long
Dim lResult As Long
Dim lSignatureLen As Long
ReDim aByteData(0) As Byte

On Error GoTo ErrSign
 &nbsp;&nbsp; 
'Switch Status property.
lStatus = CFB_BUSY

'Initialize Signature property.
sSignature = ""

'Get handle to the default provider.
sContainer = Chr$(0)
sProvider = MS_DEF_PROV &amp; Chr$(0)
If bApiNot(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal _
 &nbsp; sProvider, PROV_RSA_FULL, 0)) Then
 &nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptAcquireContext!")
 &nbsp;&nbsp; GoTo ReleaseHandles:
End If

'Create a hash object.
If bApiNot(CryptCreateHash(lHCryptprov, CALG_MD5, 0, 0, lHHash)) Then
 &nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptCreateHash!")
 &nbsp;&nbsp; GoTo ReleaseHandles:
End If

'Add data to hash object.
lDataLen = Len(sInBuffer)
If lDataLen &gt; 0 Then
 &nbsp;&nbsp; ReDim aByteData(lDataLen - 1)
End If
lDataPoint = 1
While lDataPoint &lt;= lDataLen
 &nbsp;&nbsp; aByteData(lDataPoint - 1) = Asc(Mid$(sInBuffer, lDataPoint, 1))
 &nbsp;&nbsp; lDataPoint = lDataPoint + 1
Wend

If bApiNot(CryptHashData(lHHash, aByteData(0), lDataLen, 0)) Then
 &nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptHashData!")
 &nbsp;&nbsp; GoTo ReleaseHandles:
End If

'Sign hash object.
'Determine size of signature.
sDescription = Chr$(0)
lResult = CryptSignHashA(lHHash, AT_SIGNATURE, sDescription, 0, 0, _
 &nbsp; lSignatureLen)

If lSignatureLen &lt;&gt; 0 Then
 &nbsp;&nbsp; ReDim aByteData(lSignatureLen - 1)
Else
 &nbsp;&nbsp; ReDim aByteData(0)
End If

'Sign hash object (with signature key).
If bApiNot(CryptSignHashA(lHHash, AT_SIGNATURE, sDescription, 0, _
 &nbsp; aByteData(0), lSignatureLen)) Then
 &nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError()) &amp; " during CryptSignHash")
 &nbsp;&nbsp; GoTo ReleaseHandles:
End If

lDataPoint = 0
While lDataPoint &lt;= lSignatureLen - 1
 &nbsp;&nbsp; sSignature = sSignature &amp; Chr$(aByteData(lDataPoint))
 &nbsp;&nbsp; lDataPoint = lDataPoint + 1
Wend

ReleaseHandles:
'Destroy hash object.
If lHHash Then lResult = CryptDestroyHash(lHHash)
'Release provider handle.
If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)

'switch Status property
lStatus = CFB_READY

Exit Sub
ErrSign:
MsgBox ("ErrSign " &amp; Error$)
GoTo ReleaseHandles
End Sub
</code></pre>
<h3>ValidateMethod</h3>
<p>
The <b>Validate</b> method is provided by <b>Public Sub Validate()</b>, which validates the combination of <b>InBuffer</b>, <b>Password</b>, and <b>Signature</b>, and updates <b>Status</b> with the result.</p>
<pre><code>Public Sub Validate()
'Validate InBuffer with Signature and assign Status with result.
Dim bValid As Boolean
Dim sContainer As String
Dim sDescription As String
Dim sProvider As String
Dim lDataLen As Long
Dim lDataPoint As Long
Dim lHCryptprov As Long
Dim lHHash As Long
Dim lResult As Long
Dim lSignatureLen As Long
Dim lHCryptKey As Long
ReDim aByteData(0) As Byte

On Error GoTo ErrValidate

'switch Status property
lStatus = CFB_BUSY

'Initialize internal valid flag.
bValid = True

'Get handle to the default provider.
sContainer = Chr$(0)
sProvider = MS_DEF_PROV &amp; Chr$(0)
If bApiNot(CryptAcquireContext(lHCryptprov, ByVal sContainer, ByVal _
 &nbsp; sProvider, PROV_RSA_FULL, 0)) Then
 &nbsp;&nbsp; bValid = False
 &nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptAcquireContext!")
 &nbsp;&nbsp; GoTo ReleaseHandles:
End If

'Create a hash object.
If bApiNot(CryptCreateHash(lHCryptprov, CALG_MD5, 0, 0, lHHash)) Then
 &nbsp;&nbsp; bValid = False
 &nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptCreateHash!")
 &nbsp;&nbsp; GoTo ReleaseHandles:
End If

'Add data to hash object.
lDataLen = Len(sInBuffer)
If lDataLen &gt; 0 Then
 &nbsp;&nbsp; ReDim aByteData(lDataLen - 1)
End If
lDataPoint = 1
While lDataPoint &lt;= lDataLen
 &nbsp;&nbsp; aByteData(lDataPoint - 1) = Asc(Mid$(sInBuffer, lDataPoint, 1))
 &nbsp;&nbsp; lDataPoint = lDataPoint + 1
Wend

If bApiNot(CryptHashData(lHHash, aByteData(0), lDataLen, 0)) Then
 &nbsp;&nbsp; bValid = False
 &nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptHashData!")
 &nbsp;&nbsp; GoTo ReleaseHandles:
End If

'Determine size of signature.
'sDescription = Chr$(0)
'lResult = CryptSignHashA(lHHash, AT_SIGNATURE, sDescription, 0, 0, _
 &nbsp; lSignatureLen)

'Get handle to signature key.
If bApiNot(CryptGetUserKey(lHCryptprov, AT_SIGNATURE, lHCryptKey)) Then
 &nbsp;&nbsp; bValid = False
 &nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptGetUserKey!")
 &nbsp;&nbsp; GoTo ReleaseHandles:
End If

lSignatureLen = Len(sSignature)
If lSignatureLen &gt; 0 Then
 &nbsp;&nbsp; ReDim aByteData(lSignatureLen - 1)
Else
 &nbsp;&nbsp; ReDim aButeData(0)
End If
lDataPoint = 1
While lDataPoint &lt;= lSignatureLen
 &nbsp;&nbsp; aByteData(lDataPoint - 1) = Asc(Mid$(sSignature, lDataPoint, 1))
 &nbsp;&nbsp; lDataPoint = lDataPoint + 1
Wend


'Verify signature.
If bApiNot(CryptVerifySignatureA(lHHash, aByteData(0), lSignatureLen, _
 &nbsp; lHCryptKey, sDescription, 0)) Then

 &nbsp;&nbsp; If GetLastError = NTE_BAD_SIGNATURE Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bValid = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GoTo ReleaseHandles:
 &nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bValid = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Error " &amp; CStr(GetLastError) &amp; " during CryptVerifySignature!")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GoTo ReleaseHandles:
 &nbsp;&nbsp; End If

End If


ReleaseHandles:
'Release signature key.
If lHCryptKey Then lResult = CryptDestroyKey(lHCryptKey)
'Destroy hash object.
If lHHash Then lResult = CryptDestroyHash(lHHash)
'Release provider handle.
If lHCryptprov Then lResult = CryptReleaseContext(lHCryptprov, 0)

Select Case bValid
 &nbsp;&nbsp; Case True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lStatus = CFB_VALID
 &nbsp;&nbsp; Case Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lStatus = CFB_READY
End Select

Exit Sub

ErrValidate:
MsgBox ("ErrValidate " &amp; Error$)
bValid = False
GoTo ReleaseHandles

End Sub
</code></pre>
<h2>The VBCrypto Sample Application</h2>
<p>
The VBCrypto sample application is built around the <b>CryptoFilterBox</b> class. It has text boxes for each object property, a list box of methods, and a Go button. Clicking the Go button assigns the object properties from the text boxes and executes the method selected in the method list. The text boxes are then updated from the object properties. The status property is read only so that its text box is not enabled. </p>
<h3>Create the Sample Application</h3>
<ol>
<li>
Create a new project.<br><br></li>
<li>
Add the file CRYPTO.CLS.<br><br></li>
<li>
Remove the default form1 from the project.<br><br></li>
<li>
Add the file CRYPTO.FRM.<br><br></li>
<li>
Set the project startup option to frm1.<br><br></li>
<li>
Press F5 to run.</li>
</ol>
<p>
The <b>CryptoFilterBox</b> object is instantiated when the form is loaded.</p>
<pre><code>Private Sub Form_Load()
'Instantiate CryptoFilterBox object and populate the method list.
Dim lResult As Long
On Error GoTo ErrForm_Load

Set objCryptoFilterBox = New clsCryptoFilterBox

'Populate the method list.
lstMethod.AddItem "Decrypt"
lstMethod.AddItem "Encrypt"
lstMethod.AddItem "Sign"
lstMethod.AddItem "Validate"

Exit Sub
ErrForm_Load:
MsgBox ("ErrForm_Load " &amp; Error$)
Exit Sub
End Sub
</code></pre>
<p>
The <b>Go Button</b> assigns <b>CryptoFilterBox</b> properties from the text boxes, runs the selected method, and updates the text boxes.</p>
<pre><code>Private Sub cmbGo_Click()
'Assign CryptoFilterBox properties, call the selected method, 
' and update text boxes.
 On Error GoTo ErrcmbGo_Click
 Select Case lstMethod.Text
 &nbsp; Case "Decrypt"
 &nbsp;&nbsp;&nbsp;&nbsp; objCryptoFilterBox.InBuffer = txtInput.Text
 &nbsp;&nbsp;&nbsp;&nbsp; objCryptoFilterBox.Password = txtPassword.Text
 &nbsp;&nbsp;&nbsp;&nbsp; objCryptoFilterBox.Decrypt
 &nbsp;&nbsp;&nbsp;&nbsp; txtOutput.Text = objCryptoFilterBox.OutBuffer
 &nbsp; Case "Encrypt"
 &nbsp;&nbsp;&nbsp;&nbsp; objCryptoFilterBox.InBuffer = txtInput.Text
 &nbsp;&nbsp;&nbsp;&nbsp; objCryptoFilterBox.Password = txtPassword.Text
 &nbsp;&nbsp;&nbsp;&nbsp; objCryptoFilterBox.Encrypt
 &nbsp;&nbsp;&nbsp;&nbsp; txtOutput.Text = objCryptoFilterBox.OutBuffer
 &nbsp; Case "Sign"
 &nbsp;&nbsp;&nbsp;&nbsp; objCryptoFilterBox.InBuffer = txtInput.Text
 &nbsp;&nbsp;&nbsp;&nbsp; objCryptoFilterBox.Sign
 &nbsp;&nbsp;&nbsp;&nbsp; txtSignature.Text = objCryptoFilterBox.Signature
 &nbsp; Case "Validate"
 &nbsp;&nbsp;&nbsp;&nbsp; objCryptoFilterBox.InBuffer = txtInput.Text
 &nbsp;&nbsp;&nbsp;&nbsp; objCryptoFilterBox.Signature = txtSignature.Text
 &nbsp;&nbsp;&nbsp;&nbsp; objCryptoFilterBox.Validate
 &nbsp;&nbsp;&nbsp;&nbsp; Select Case objCryptoFilterBox.Status
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case CFB_VALID
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Signature is valid")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Invalid signature")
 &nbsp;&nbsp;&nbsp;&nbsp; End Select
 &nbsp; Case ""
 &nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Method not selected")
 &nbsp; Case Else
 &nbsp;&nbsp;&nbsp;&nbsp; MsgBox ("Unknown method selected.")
End Select
Exit Sub

ErrcmbGo_Click:
 &nbsp;&nbsp; MsgBox ("ErrcmbGo_Click " &amp; Error$)
 &nbsp;&nbsp; Resume
End Sub
</code></pre>
<h3>Cryptography Demonstrations</h3>
<h4>Encrypt a Text String</h4>
<ol>
<li>
Enter <b>This is a secret</b> in input box.<br><br></li>
<li>
Select <b>Encrypt</b> from the methods list and click <b>Go</b>.<br><br></li>
<li>
The encrypted message fills the output box.</li>
</ol>
<h4>Decrypt a Text String</h4>
<ol>
<li>
Copy the encrypted message from the output box to the input box.<br><br></li>
<li>
Select <b>Decrypt</b> from the methods list and click <b>Go</b>.<br><br></li>
<li>
<b>This is a secret</b> is displayed in the output box.</li>
</ol>
<h4>Sign a Text String and Validate the Signature</h4>
<ol>
<li>
Enter <b>The price is ten dollars</b> in the input box.<br><br></li>
<li>
Enter a password in the input box.<br><br></li>
<li>
Select <b>Sign</b> from the methods list and click the <b>Go</b> button.</li>
</ol>
<h4>Validate the Input, Password, and Signature</h4>
<ol>
<li>
Change the input box, the password, or the signature.<br><br></li>
<li>
Select <b>Validate</b> from the methods list and click the <b>Go</b> button.<br><br></li>
<li>
Status becomes <b>Invalid</b>.</li>
</ol>
<h2>Conclusion</h2>
<p>
The <b>CryptoFilterBox</b> server provides data encryption and signing functionality to applications written in any language that can use a COM server with just a few lines of code. Although this article has covered only a small part of the Microsoft Internet Security Framework, and has omitted many issues that must be addressed before employing a security system, it has demonstrated the fundamental techniques required for secure communication and commerce on public networks. </p>
<h2>Additional References</h2>
<p>
Application Programmer's Guide and Reference, CryptoAPI Version 2.0 Beta (Sept. 10, 1996 <b>Preliminary)</b>.</p>
<p>
Robert Coleridge, <a href="msdn_cryptapi.htm">"The Cryptography API, or "How to Keep a Secret."</a> (MSDN Library, Technical Articles)</p>
<p>
Microsoft Internet Security Framework at<u> </u><a href="http://www.microsoft.com/intdev/security/">http://www.microsoft.com/intdev/security/</a>.</p>
</BODY>
</HTML>
