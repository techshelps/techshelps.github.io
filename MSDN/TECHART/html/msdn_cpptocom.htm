<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>From CPP to COM</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_cpptocom"></a></sup>From CPP to COM</h1>
<p>
Markus Horstmann<br>
OLE Program Manager, Microsoft Corporation</p>
<p>
Created: September 28, 1995<br>
Revised: October 19, 1995</p>
<p>
<i>Markus Horstmann joined Microsoft in September 1995 as a Program Manager for OLE. Prior to that, he worked for Información Selectiva, Mexico, leading the design and development of their next-generation, real-time information management platform, as well as leading the design, development, and roll-out of a distributed, interactive financial application based on this platform. He studied Informatics at the University of Dortmund, Germany. He is a Microsoft Certified Systems Engineer and a Microsoft Certified Product Specialist for Microsoft Excel.</i></p>
<h4>Table of Contents</h4>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=74%><b><br>
Topic</b></td>
<td class=label width=26%><b><br>
Associated Sample</b></td>
</tr>
<tr valign=top>
<td width=74%><a href="#abstract">Abstract</a></td>
<td width=26%></td>
</tr>
<tr valign=top>
<td width=74%><a href="#introcpptocom">Introduction</a></td>
<td width=26%></td>
</tr>
<tr valign=top>
<td width=74%><a href="#db">DB: C++ Object Used in a C++ Client</a></td>
<td width=26%>DB</td>
</tr>
<tr valign=top>
<td width=74%><a href="#dbcppdll">DB_CPPDLL: C++ Object in a DLL, Used by a C++ Client</a></td>
<td width=26%>DB_CPPDLL</td>
</tr>
<tr valign=top>
<td width=74%><a href="#dbvtbl">DB_VTBL: C++ Object Exposing "Pure" Abstract Base Class</a></td>
<td width=26%>DB_VTBL</td>
</tr>
<tr valign=top>
<td width=74%><a href="#dbvtbldl">DB_VTBLDLL: C++ Object in a DLL Exposing "Pure" Abstract Base Class</a></td>
<td width=26%>DB_VTBLDLL</td>
</tr>
<tr valign=top>
<td width=74%><a href="#db2com">DBAlmostCOM: C++ Object in a DLL, Loaded Through COM</a></td>
<td width=26%>DBAlmostCOM </td>
</tr>
<tr valign=top>
<td width=74%><a href="#dbcom">DBCOM: COM Object in a DLL, Loaded Through COM</a></td>
<td width=26%>DBCOM</td>
</tr>
<tr valign=top>
<td width=74%><a href="#dbcommul">DBCOMMUL: COM Object with Multiple Interfaces</a></td>
<td width=26%>DBCOMMul</td>
</tr>
<tr valign=top>
<td width=74%><a href="#dbcomrem">DBCOMREM: COM Object in a Separate Process</a></td>
<td width=26%>DBCOMRem</td>
</tr>
<tr valign=top>
<td width=74%><a href="#conclude">Conclusion</a></td>
<td width=26%></td>
</tr>
<tr valign=top>
<td width=74%><a href="#biblio">Bibliography</a></td>
<td width=26%></td>
</tr>
</table><br>
<h2><a name="abstract"></a>Abstract</h2>
<p>
The Microsoft® Component Object Model (COM) borrows a key part of its architecture from standard implementations of C++. This article uses an existing project written in C++ and turns it into a component-based design that runs the object in a separate process, leveraging the COM infrastructure provided natively on all newer Microsoft operating systems. The focus is on explaining and deducing why and how features are implemented in COM, providing a robust, portable, and transparent model for distributed component software.</p>
<h2><a name="introcpptocom"></a>Introduction</h2>
<p>
The idea for this technical article arose from a deep frustration about the apparent complexity of COM and OLE, as they are presented in the OLE Design Specification and in many later publications. After having studied these publications and the online documentation many times, I finally understood how everything fit together. This, in turn, illuminated how COM supplies a great foundation for safe and robust interaction among objects.</p>
<p>
Once I understood the basic structure of COM and how it interacts with and supports objects, I realized that it would have been very helpful if, from the beginning, the specification and product documentation had clearly separated the COM discussions from the implementation of OLE features. Also, being a person who needs to understand a system from the "bottom up," this separation would have made OLE much easier to learn. This approach for explaining OLE and COM is now taken more frequently; for example, the new edition of Kraig Brockschmidt's <i>Inside OLE</i> does a very good job of explaining each of the technologies separately.</p>
<p>
Before his book was available, I was asked to give a class on COM and OLE. For this class I implemented, among other things, a code sample that explains all the design features of the basic COM architecture by turning a simple object and its client, implemented in C++, first into a standard Windows® dynamic-link library (DLL) architecture and then into a COM object. In this environment, C++ objects just communicate directly in their own "language." [In fact, in my personal opinion this technology will sooner or later (probably later) replace the current way in which DLLs interface to the outside world (through exported entry points, that are bound at load time), although COM currently needs a few standard entry points using conventional DLL technology. Objects could receive a parameter to their standard entry point—that is, a pointer to the “Operating System Object”—and access all the functionality through this object, using only COM Interfaces (window creation, file access, and so on). Device drivers could be COM objects, managed (dispatched?) by the operating system.]</p>
<p>
I originally used the Microsoft Foundation Classes (MFC) to create a project to accompany this article, consisting of a main directory and several subdirectories. For ease of use, this has been split up into eight samples, each associated with a major heading in this article. You may want to incorporate all the step-by-step changes into a single directory, or you may copy each sample to a new directory to keep the original version for reference. If you choose to copy the sample, you will need to change the references to certain files to point to the new directory, because Visual C++® will not always update them correctly.</p>
<p>
The project uses MFC, but only to implement a fairly reasonable application and user interface framework. All COM-related features are implemented in straight C++ without MFC, and they can be passed to any other framework or to an application implemented directly to Win32®. The (trivial) implementation of the object's functionality also takes advantage of MFC's array and string management features, but this can easily be replaced.</p>
<p>
The project is written using the Microsoft Visual C++ 2.2 development environment and provides projects for Intel®-based Windows NT™ or Windows 95 platforms. For the last sample, which illustrates the use of remoted custom interfaces, you will need the MIDL compiler that comes with the Win32 Software Development Kit (SDK).</p>
<p>
I assume that you have a working knowledge of the C++ language, especially the concepts of virtual functions and abstract base classes. To follow my explanations on exports and related topics, knowledge of Windows DLLs is advantageous, although not essential for understanding the structure of COM.</p>
<h2><a name="db"></a>DB: C++ Object Used in a C++ Client</h2>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4524">
</OBJECT><a href="javascript:sample1.Click()">Click to view or copy the files for the DB sample application.</a></p>
<p>
This sample consists of two parts:
<ul type=disc>
<li>
An object that implements features that are good candidates for reuse in other projects<br><br></li>
<li>
A client application that uses part of the functionality in the object by means of a rudimentary user interface</li>
</ul>
<h3>The "Database" Object</h3>
<p>
The DB sample application implements a simple, database-like object that manages all its data in memory. Each "database" contains an array of pointers to the tables inside the database. The tables are arrays of strings, and each array element represents one row in the table. A parallel string array to the pointer array contains the "names" of the tables.</p>
<p>
Queries are extremely simple: just indicate a table number (a zero-based index to the array of table pointers) and the row number (a zero-based index into the <i>n</i>th string array). Thus, the <b>Read</b> function looks like this:</p>
<pre><code>HRESULT Read(short nTable, short nRow, LPTSTR lpszData);
</code></pre>
<p>
The application passes in a preallocated buffer of sufficient size, and the object copies the string data to this buffer.</p>
<p>
The <b>Write</b> function looks very similar:</p>
<pre><code>HRESULT Write(short nTable, short nRow, LPCTSTR lpszData);
</code></pre>
<p>
Additional functions let you create tables (giving each table a name), remove tables, and obtain information about the database:</p>
<pre><code>typedef long HRESULT;
class CDB {
 &nbsp; // Interfaces
 &nbsp; public:
 &nbsp; // Interface for data access
 &nbsp; HRESULT Read(short nTable, short nRow, LPTSTR lpszData);
 &nbsp; HRESULT Write(short nTable, short nRow, LPCTSTR lpszData);

 &nbsp; // Interface for database management
 &nbsp; HRESULT Create(short &amp;nTable, LPCTSTR lpszName);
 &nbsp; HRESULT Delete(short nTable);

 &nbsp; // Interface for database information
 &nbsp; HRESULT GetNumTables(short &amp;nNumTables);
 &nbsp; HRESULT GetTableName(short nTable, LPTSTR lpszName);
 &nbsp; HRESULT GetNumRows(short nTable, short &amp;nRows);

 &nbsp; // Implementation
 &nbsp; private:
 &nbsp; CPtrArray m_arrTables;// Array of pointers to CStringArray (the "database")
 &nbsp; CStringArray m_arrNames; // Array of table names
 &nbsp; public:
 &nbsp; ~CDB();
};
</code></pre>
<p>
All functions return the same kind of error/success code, which, in general, is a good design for a class, because it facilitates error reporting even on simple functions such as <b>CDB::GetNumTables</b>, where one is tempted to simply return the "short" value. If there was something wrong with the database, the function can return something more intelligent than "0" or "-1".</p>
<h3>The "Database" Client</h3>
<p>
The client is an MFC/AppWizard-generated Windows-based application. Each document creates a new CDB object in its <b>OnNewDocument</b> function and stores a pointer to the object in <b>CDB::m_pDB</b>.</p>
<p>
The document class implements four menu items:
<ul type=disc>
<li>
Create<br><br></li>
<li>
Write<br><br></li>
<li>
Read<br><br></li>
<li>
Read multiple</li>
</ul>
<p>
<b>Create</b> adds a new table called "Testing" to the database associated with the document and saves the number of the last created table in a member variable (<i>m_nTable</i>) of <b>CDBDoc</b>.</p>
<p>
<b>Write</b> writes a generated string into row 0 of the last created table.</p>
<p>
<b>Read</b> reads whatever is stored in row 0 of the last created table and stores it in <b>CDBDoc::m_csData</b>, which the view class CDBView displays in the client area. </p>
<p>
<b>Read multiple</b> performs as many reads as indicated in the DB.INI file "ReadMultiple" section, in the entry "NumCalls," and measures the time this took using the system-provided tick count.</p>
<h3>The Reuse Mechanism</h3>
<p>
The DB sample uses standard C++ source code reuse, for which the client needs the complete source code for the object and compiles it into the project. The project uses three directories: \CLIENT, \INTERFACE, and \OBJECT. The \INTERFACE directory contains the header file DBSRV.H, which declares the object (see above). This file is used by both the client and the object. The client directly includes DBSRV.CPP, which is the only file in the \OBJECT directory.</p>
<h2><a name="dbcppdll"></a>DB_CPPDLL: C++ Object in a DLL, Used by a C++ Client</h2>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4525">
</OBJECT><a href="javascript:sample2.Click()">Click to view or copy the files for the DB_CPPDLL sample application.</a></p>
<p>
One severe limitation of the standard C++ reuse model is that if I wanted to sell my fancy database object, I would have to distribute my complete and valuable know-how in form of the source code.</p>
<p>
A standard solution to this problem under Windows is to package the implementation into a DLL and provide one or more header files that declare the functions and structures used. (Microsoft currently ships a large part of Windows and Windows NT in this form; in fact, the headers are shipped separately from the DLLs in the form of software development kits.)</p>
<p>
To package the implementation into a DLL, you must consider the following issues:
<ul type=disc>
<li>
Exporting of member functions<br><br></li>
<li>
Memory allocation only in the DLL or only in the EXE<br><br></li>
<li>
Unicode™/ASCII interoperability</li>
</ul>
<h3>Exporting Member Functions</h3>
<p>
One simple way to export functions is by using the <b>__declspec(dllexport)</b> modifier (since Visual C++ 2.0), which can be applied to any function, including member functions. This instructs the compiler to place an entry into the exports table, just like declaring an export in the module definition file (.DEF) for the linker. [In the 16-bit world, <b>_export</b> did the same thing; in addition, the compiler provided additional code to change to the data segment of the DLL before entering the function, and then switch back to the caller's data segment before leaving the function (prologue/epilogue).]</p>
<p>
For C++ this is the only practical way to export big numbers of functions, because C++ provides function overloading (that is, using one function name for many functions that differ only in the kind of parameter declared). Thus, the C++ compiler combines all the information it has about a member function (return type, class, parameter types, public/private) into one big name. (See the technical article “Exporting with Class" in the MSDN Library Archive for more details.)</p>
<p>
By simply applying the <b>_declspec(dllexport)</b> modifier to all the functions in the CDB class, we make the class exportable in a DLL. We then just have to provide a make file to create the binary.</p>
<p>
Due to the name mangling, it is very difficult for the client to use dynamic loading: We would have to pass all the decorated names to <b>GetProcAddress</b> and save the returned pointer somewhere. Then we would have to set up a simulation class that calls each of these functions. Therefore, it's definitely better to use implicit linking (using the DB.LIB file generated by the linker).</p>
<p>
Another issue, related to name mangling, is incompatibility between compilers. The name mangling is not standardized, and thus each compiler decorates functions differently. A DLL compiled by one compiler cannot be used by another. If you did not want to give away your source code, you would have to provide all the compiled versions yourself. Using this technique in a component software scenario is simply not acceptable. There would have to be many objects with the same functionality to satisfy all possible clients.</p>
<h3>Memory Allocation</h3>
<p>
Both the DLL and the executable file (EXE) maintain their own lists of allocated memory blocks, which they maintain through the <b>malloc</b> memory allocator. The C++ <b>new</b> and <b>delete</b> functions also rely on these lists of memory blocks, so that C++ tends to use dynamic memory allocation more often than C. If the DLL allocates some memory—for example, for the creation of a new instance of a class—this memory is marked in the allocation list of the DLL. If the EXE tries to free this memory, the run-time library looks through its list of allocated memory blocks and fails (usually with a GP fault). Thus, even if the memory between the DLL and the EXE is completely shared, the logic for managing allocation breaks if two modules mix their allocation schemes.</p>
<p>
There are basically three solutions to this problem: 
<ul type=disc>
<li>
Have the EXE always allocate <i>and</i> free a given kind of memory.<br><br></li>
<li>
Have the DLL always allocate <i>and</i> free a given kind of memory.<br><br></li>
<li>
Have something neutral (the operating system) allocate <i>and </i>free <i>all</i> the memory.</li>
</ul>
<p>
The third approach seems to be the most flexible one, but unfortunately cannot be used easily for operations involving the C/C++ run-time libraries, even for basic functions such as <b>new</b> and <b>delete</b>.</p>
<p>
From an object-based point of view, it is more convenient to have the memory allocation done by the object (encapsulation). This way the client does not need to be aware of the size of the object. If the object's implementation changes, chances are that the client will still be able to use the object (if the object's exported functions do not change).</p>
<p>
In this sample, we will use a global function to have the object instantiate a copy of itself (using <b>new</b>) and return the pointer to the client (later, we will see that COM takes the same approach). The client will then use this pointer in all its calls to the object's member functions (as a hidden first parameter). The client obtains the address of the functions (the same for all instances of the object) through implicit linking of the DLL.</p>
<p>
From a global perspective, there can be many things involved in creating an object. For example, you probably need to provide some password or security information before you are allowed to create an object. Thus, it can be convenient to have an additional object that handles instantiation of the actual object instead of having the client create the object directly. </p>
<p>
Our global instantiation function will return an object of another class that will allow us to produce instances of the <b>CDB</b> class. This class will be called <b>CDBSrvFactory</b>, and it will have only one member function: <b>CDBSrvFactory::CreateDB</b>(CDB** <i>ppDB</i>). This function creates the object and returns a pointer to it through the parameter <i>ppDB</i> (basically, <i>*ppDB</i>=<b>new</b> <b>CDB</b>): It is a "factory" that produces object instances of a given class. We will also call this object a <i>class factory object</i>.</p>
<h3>Unicode/ASCII Interoperability</h3>
<p>
All samples associated with the DB project can be built in both Unicode and ASCII. Some of the functions take parameters that are strings. These change their binary representation when being compiled for Unicode rather than for ASCII (see the Win32 SDK for details on Unicode). This works as long as both the client and the object are compiled within the same project—they will always match. If you compile them separately, as we will do here, you can take any of the following approaches:
<ul type=disc>
<li>
Provide two versions of your object. <br><br></li>
<li>
Standardize all function parameters to be ASCII, and convert inside the client and/or the server if they compile for Unicode.<br><br></li>
<li>
Standardize all function parameters to be Unicode, and convert inside the client and/or the server if they compile for ASCII.</li>
</ul>
<p>
Again, providing two versions can be very expensive: You double the size of your object if you want to be available for both kinds of clients. For a global component management system like COM, this is definitely not a good idea.</p>
<p>
If you want to standardize on one of the two without loosing functionality, the choice is obviously Unicode, because it is a superset of ASCII.</p>
<p>
These samples (and COM) standardize on Unicode for any parameters to any interface that is to be seen by another object. The cost is minimal: You will need to convert your strings to and from ASCII to Unicode before calling, or when receiving a parameter. If you compile for Unicode, there is no performance penalty.</p>
<h3>Changes: Step by Step</h3>
<p class=indent>
First we will work on the object:
<ol>
<li>
Use AppWizard to create a new Dynamic-Link Library project called Object\DB.MAK (not an MFC AppWizard DLL, which creates an MFC Extension DLL). Add Object\DBSrv.cpp to the project and copy Client\stdafx.h to Object\stdafx.h. Create new targets for Unicode (Win32 Unicode Debug and Win32 Unicode Release; in Project Settings include a preprocessor symbol UNICODE). Through stdafx.h, set precompiled headers for all targets.<p class=tl>
Now we will change the interface that the client sees (Interface\DBSrv.h).</P><p class=tl>
<b>Export Member Functions</b></P></li>
<li>
Export all the interface member functions of CDB in Interface\DBSrv.h. Use <b>__declspec(dllexport)</b> to instruct the compiler to export these functions.<p class=tl>
<b>Memory Allocation</b></P></li>
<li>
Add the <b>ULONG CDB::Release()</b> function that will delete the object when it is no longer needed (in Interface\DBSrv.h).<br><br></li>
<li>
Declare the class factory object <b>CDBSrvFactory</b> in Interface\DBSrv.h.<br><br></li>
<li>
Declare the function that will return the factory object and export it (in Interface\DBSrv.h).<p class=tl>
The resulting header file up to this point should look as follows (new parts in <b>bold</b>):</P><pre><code><b>#define DEF_EXPORT _declspec(dllexport) // Step 2

</b>class CDB {
// Interfaces
public:
// Interface for data access
HRESULT <b>DEF_EXPORT</b> Read(short nTable, short nRow, LPTSTR lpszData);
HRESULT <b>DEF_EXPORT</b> Write(short nTable, short nRow, LPCTSTR lpszData);
(. . .)

<b>// Step 3</b>

<b>ULONG DEF_EXPORT Release(); // Need to free an object from within the DLL.</b>

// Implementation
(. . .)
};

<b>class CDBSrvFactory { // Step 4</b>

<b>// Interface</b>

<b>public:</b>

<b>HRESULT DEF_EXPORT CreateDB(CDB** ppObject);</b>

<b>ULONG&nbsp; DEF_EXPORT Release();</b>

<b>};</b>

<b>HRESULT DEF_EXPORT DllGetClassFactoryObject(CDBSrvFactory ** ppObject); //Step 5</b>
</code></pre>
<p class=tl>
Now we will change the implementation of the object (Object\DBSrv.cpp)</P></li>
<li>
Implement <b>CDB::Release()</b> in DBSrv.cpp<pre><code>ULONG CDB::Release() {
delete this; // Cannot access data member after this!!!
return 0; 
}
</code></pre>
</li>
<li>
Implement <b>CDBSrvFactory</b> in a new file called Object\DBSrvFactory.cpp (don't forget to add it to the project) . Also implement the function that returns the <b>CDBSrvFactory</b> Object:<pre><code>#include "stdafx.h"
#include "..\interface\bdsrv.h"
// Create a new database object and return a pointer to it.
HRESULT CDBSrvFactory::CreateDB(CDB** ppObject) {
*ppObject=new CDB;
return NO_ERROR;
}
ULONG CDBSrvFactory::Release() {
delete this;
return 0;
}
HRESULT DEF_EXPORT DllGetClassFactoryObject(CDBSrvFactory ** ppObject) {
*ppObject=new CDBSrvFactory;
return NO_ERROR;
}
</code></pre>
<p class=tl>
Now we will make the necessary changes to the client:</P></li>
<li>
Change <b>CDBDoc::~CDBDoc</b> to call <b>m_pDB-&gt;Release()</b> instead of <b>delete m_pDB</b>.<pre><code>CDBDoc::~CDBDoc() {
if (m_pDB) {

<b>m_pDB-&gt;Release();</b>

m_pDB=NULL;
}
}
</code></pre>
</li>
<li>
Obtain <b>CDB*</b> through the class factory object.<pre><code>// Create a database object through the exported function and class factory
// object.
CDBSrvFactory *pDBFactory=NULL;

DllGetClassFactoryObject(&amp;pDBFactory); 
pDBFactory-&gt;CreateDB(&amp;m_pDB);

pDBFactory-&gt;Release(); // We no longer need the factory.
</code></pre>
</li>
<li>
Modify the project: Remove Object\DBsrv.cpp and include Object\xxx\db.lib instead in Projects Settings/Linker. (For each target use the appropriate directory, for example, \Windebug.)<p class=tl>
<b>Standardize on Unicode</b></P></li>
<li>
Modify the object again: Change all parameters in <b>CDB</b> that have the string LPxTSTR to LPxWSTR. The <i>T</i> version is the portable one, which compiles to ASCII or Unicode, depending on the preprocessor symbol UNICODE. The <i>W</i> version always uses wide characters (short instead of char).<br><br></li>
<li>
Put in conditional statements (#ifdef UNICODE) to convert incoming parameters to ASCII, if you are not compiling for UNICODE (<b>Write</b>/<b>Create</b>: Use the Win32 API <b>MultiByteToWideChar</b>), and convert outgoing parameters to Unicode (<b>Read</b>/<b>GetTableName</b>: Use <b>WideCharToMultiByte</b>).<br><br></li>
<li>
In the client, convert outgoing parameters to Unicode (#ifdef UNICODE)—<b>Create</b>: Use L"xxx" to declare a Unicode string; <b>Write</b>: use <b>MultiByteToWideChar</b>)—and incoming parameters to ASCII (<b>Read</b>: Use <b>WideCharToMultiByte</b>).<pre><code>void CDBDoc::OnDatabaseCreate() 
{
m_pDB-&gt;Create(m_nTable, <b>L</b>"Testing");&nbsp;&nbsp; 
m_nCount=0; // Set number of writes to 0 
}
void CDBDoc::OnDatabaseWrite() 
{
m_nCount++;
CString csText;
csText.Format(_T("Test data #%d in table %d, row 0!"), m_nCount,
(int) m_nTable);

<b>#ifdef UNICODE</b>

m_pDB-&gt;Write(m_nTable, 0, csText);

<b>#else</b>

<b>WCHAR szuText[80]; // Special treatment for ASCII client</b>

<b>MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, csText, -1, szuText,</b>

<b>sizeof(szuText));</b>

<b>m_pDB-&gt;Write(m_nTable, 0, szuText);</b>

<b>#endif</b>

}
void CDBDoc::OnDatabaseRead() 
{

<b>#ifdef UNICODE</b>

m_pDB-&gt;Read(m_nTable, 0, m_csData.GetBuffer(80));

<b>#else</b>

<b>WCHAR szuData[80];</b>

<b>m_pDB-&gt;Read(m_nTable, 0, szuData);</b>

<b>WideCharToMultiByte(CP_ACP, 0, szuData, -1, m_csData.GetBuffer(80),</b>

<b>NULL, NULL);</b>

<b>#endif</b>

m_csData.ReleaseBuffer();
UpdateAllViews(NULL);
}
</code></pre>
</li>
<li>
Compile the object before compiling the client, because the client needs DB.LIB in order to link.<br><br></li>
<li>
Be sure to either copy the appropriate DB.DLL to the client's directory or include the directory of the DLL in the path. Any client should be able to work with any server (except, perhaps, for debug versions, since name mangling can be different).<p class=tl>
Don't miss the opportunity to run DumpBin.EXE /exports db.dll and see all the cryptic names that the compiler generates for the member function!</P></li>
</ol>
<h2><a name="dbvtbl"></a>DB_VTBL: C++ Object Exposing "Pure" Abstract Base Class</h2>
<p>
<OBJECT id=sample3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4526">
</OBJECT><a href="javascript:sample3.Click()">Click to view or copy the files for the DB_VTBL sample application.</a></p>
<h3>Problem: C++ Does Not Encapsulate Data Members</h3>
<p>
One problem with the bare C++ approach is that part of the implementation details of an object still have to be included in the declaration of the class: The client "sees" all the private member (arrays and so forth) even though the compiler will not allow a derived class to access them. </p>
<p>
For the monolithic case, where everything is compiled from the complete source code, this approach is probably still acceptable, although not necessarily desirable.</p>
<p>
For binary (public) distribution of an object, revealing the implementation details in a header file is probably still too much. The client (specifically, the compiler, when compiling the client code) needs to know, at a minimum, the size of the data members when doing memory allocation for instances of the object, even if it never accesses any of the data members. When the object implementer changes the size of the data members, all clients must recompile. Our approach of having the object do the allocation lets you get away with not recompiling, because all the client code ever needs from the object is the addresses of its member functions. But I would definitely not feel comfortable about having a mission-critical system work with an internal discrepancy such as this.</p>
<p>
As stated above, the only information the client needs from the object is the address of the member functions. Therefore, we could set up a table of pointers to all the (exported) member functions of the object. Then, when invoking the function, the client would simply look up the <i>n</i>th member function's address and jump to it.</p>
<p>
This approach sounds a little complicated to do in C++: We would have to set up a "wrapper class" to replicate the functions within the client code and, within each function, look up and call indirectly the corresponding member function in the object. Next, it would be convenient to have a tool that generates these trivial but tedious-to-implement wrapper functions.</p>
<h3>C++ Solution: Abstract Base Class</h3>
<p>
Moving back from the binary world of member function addresses, let's get back to the higher levels of C++. There is a feature in C++ that provides a similar functionality: the <i>abstract base class</i>. </p>
<h4>Common Syntax in Derived Classes</h4>
<p>
The term <i>abstract base class</i> sounds formidable, but actually it is nothing but a class that declares the syntax of one or more of its functions without implementing them. This class cannot be instantiated—it merely serves as a base class for other classes that fill in the missing "link." To be a "real" C++ class that can be instantiated, the deriving class must implement all the "abstract" functions with the exact same syntax.</p>
<h4>Calls to Operations in Derived Classes from Abstract Operations in the Base Class</h4>
<p>
There is another advantage to abstract base classes, besides letting you force derived classes to implement an exact function signature: They also let you use the unimplemented function from code in the base class and have C++ choose the actual code at run time.</p>
<p>
You can provide operations in the base class that use other operations (the missing functions) to provide higher-level functionality—essentially, an abstract algorithm with replaceable elementary operations. You could implement a sorting algorithm as an abstract base class, one that uses comparisons and swaps as elementary operations. A derived class can then fill in these operations and the same algorithm can sort completely different objects.</p>
<p>
If two classes derive from the same abstract base class, they can share the same abstract operations defined in the base class, and yet they can provide very different functionality by providing different elementary operations. The code in the base class calls functions depending on the class of the actual instance of the object it operates on.</p>
<h4>Common Interface to All Derived Classes</h4>
<p>
A side effect of this architecture is that you can cast a pointer to an instance of a class derived from an abstract base class back to the base class, and then you can use this pointer to invoke functions in the derived class.</p>
<p>
If multiple classes derive from one abstract base class, a client can invoke the same function on two different objects and C++ will find—at run time—the correct function in the correct derived class.</p>
<h4>Implementation Secret: Virtual Functions</h4>
<p>
How does the compiler accomplish this magic? All the functions in an abstract base class must be virtual functions: You can call a virtual function on a pointer to a base class, and the compiler will call the correct implementation depending on the actual object referred to by the pointer.</p>
<p>
How does the compiler implement virtual functions? The compiler builds a table for each class that contains pointers to all the virtual functions declared in the class, whether they are declared (and possibly implemented) in a base class or declared in the derived class. The table is filled in "order of declaration"; that is, if there is no base class with virtual functions, the first declared member function in the derived class (source code order) corresponds to the first entry in the virtual function table for this class. If there are virtual functions declared in base classes, they go before the newly defined virtual functions. The virtual function table is also called the <i>vtable</i> of the class.</p>
<p>
Note the following: 
<ul type=disc>
<li>
The table is built on a per-class basis, not for each instance of the class.<br><br></li>
<li>
The memory image of an instance of a class has one pointer to the vtable of this class, stored in front of the actual data members of the object. Thus an object that uses virtual functions occupies 4 additional bytes for each instance. The vtable itself occupies 4 bytes for each virtual function, but there is only one vtable per class and it is shared by all instances. When you invoke a virtual function from a base class, the C++ compiler has a pointer to the object's instance data (the "this" pointer). It obtains the pointer to the vtable of the class from the first 4 bytes of the object's instance data. Each virtual function has a unique index in the vtable of a given class. The compiler simply obtains the function address from the vtable at the function's index and branches to this address. When you invoke calls through a pointer to the base class, the technique is the same.<br><br></li>
<li>
Non-virtual functions do not appear in the vtable.</li>
</ul>
<p>
<img src="cpptocom_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Memory layout of an instance of an object with virtual classes. </b>[Reprinted from "Object Mapping in C++," by Tom Germond, Jan Gray, Dale E. Rogerson. MSDN Library Archive, Technical Articles, C/C++ Articles.]</p>
<h3>Using "Pure" Abstract Base Classes as Function Table Wrappers</h3>
<p>
When I described the problem of changing implementations of objects and I stated that the client needs only the addresses of the object's member functions, I proposed a tool to generate wrappers for tables with the exported functions of an object.</p>
<p>
Well, here it is: your C++ compiler. As we saw above, virtual functions are implemented exactly that way: The compiler sets up a table with the addresses of the function (<i>vtable</i>) and lets you wrap these functions with an abstract base class that simply maps calls to members through the table. As you will see, we will use abstract base classes in our samples that provide no actual code—all the members will be pure virtual functions, and all they will do is let you invoke functions in any derived class, once you have cast a pointer to the base class. For the purposes of this article, I call this kind of abstract base class a <i>pure abstract base class</i>; COM calls it an <i>interface</i>.</p>
<p>
Let's use this idea, to begin with, in a subdirectory of the DB sample that has everything compiled into one executable file. Even in this situation, using abstract base classes can be advantageous. You can make sure that you will not accidentally use implementation data that for technical reasons you had to make "public" for C++.</p>
<h3>Changes: Step by Step</h3>
<p>
Use the DB_CPPDLL sample as the basis. The next sample will be very similar to this one, so if you are short of time, you can skip this one. Its primary purpose is to illustrate that using abstract base classes as function table wrappers is a standard C++ feature, which can also be very useful in a non-component world.
<ol>
<li>
Copy the header file (interface\dbsrv.h) to \object\dbsrvimp.h. The first file will contain the abstract base class, which is the only code the client needs. The second file will be the header for the actual implementation.<br><br></li>
<li>
Make all functions in interface\dbsrv.h pure virtual functions and remove the data members. Change the name of the class from <b>CDB</b> to <b>IDB</b> (Interface to DB).<br><br></li>
<li>
Derive <b>CDB</b> in object\dbsrvimp.h from <b>IDB</b> and include ...\interface\bdsrv.h. (Don't forget to change the #ifndef at the beginning of the file to something like _DBSRVIMP_INCLUDE.)<br><br></li>
<li>
Because the client can not instantiate an abstract base class, we will have to have the object instantiate itself and return a pointer to itself, cast to <b>IDB*</b>: Declare and define a <b>CreateDB()</b> function in dbsrv.h/cpp that does this.<p class=tl>
The resulting header file Interface\dbsrv.h:</P><pre><code>class IDB {
 // Interfaces
 public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Interface for data access
 &nbsp;&nbsp;&nbsp;&nbsp; <b>virtual </b>HRESULT Read(short nTable, short nRow, LPTSTR lpszData) <b>=0</b>;
 &nbsp;&nbsp;&nbsp;&nbsp; <b>virtual </b>HRESULT Write(short nTable, short nRow, LPCTSTR lpszData) <b>=0</b>;
 &nbsp;&nbsp;&nbsp;&nbsp; (...)
};

<b>HRESULT CreateDB(IDB** ppObj);</b>
</code></pre>
<p class=tl>
The new header "Object\dbsrvimp.h":</P><pre><code>#include "..\Interface\dbsrv.h"
typedef long HRESULT;
class CDB : public IDB {
 // Interfaces
 public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Interface for data access
 &nbsp;&nbsp;&nbsp;&nbsp; HRESULT Read(short nTable, short nRow, LPTSTR lpszData);
 &nbsp;&nbsp;&nbsp;&nbsp; (...)
};
</code></pre>
</li>
<li>
Make dbsrv.cpp include dbsrvimp.h instead of dbsrv.h.<p class=tl>
The resulting DBSRV.CPP (no changes, just adding the instantiation function):</P><pre><code>(...)

<b>HRESULT CreateDB(IDB** ppObj) {</b>

<b> &nbsp; *ppObj=(IDB*) new CDB; // Cast to abstract base class.</b>

<b> &nbsp; return NO_ERROR;</b>

<b>}</b>
</code></pre>
</li>
<li>
Now we will adjust the client: Change <b>CDB::m_pDB</b> to <b>IDB*</b> and use <b>CreateDB</b> instead of <b>new</b> to instantiate it.</li>
</ol>
<p>
Everything works just as before. If we look at the binary level, there is a slight overhead cost for the indirect function call (get vtable pointer from instance data, get function pointer from vtable, jump), but the performance measured with "Read Multiple" is not significantly affected. The actual "work" performed in the member functions takes orders of magnitude longer than these two additional memory accesses.</p>
<h2><a name="dbvtbldl"></a>DB_VTBLDLL: C++ Object in a DLL Exposing "Pure" Abstract Base Class</h2>
<p>
<OBJECT id=sample4 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4527">
</OBJECT><a href="javascript:sample4.Click()">Click to view or copy the files for the DB_VTBLDLL sample application.</a></p>
<p>
It is even more beneficial to apply the technique of abstract base classes to the scenario of binary packaging in DLLs. In the previous DLL sample, we had to export each function of the object, and we depended on the name-mangling scheme of the compiler. There is no standard for name-mangling, so you have to provide objects for each compiler that a potential client might want to use for their implementation.</p>
<p>
Remember that pure abstract base classes provide little more than a table of function entry points, and the entry points are allocated by the compiler of the object. They are initialized at load time and not freed until the module is unloaded. If we create object instances indirectly, memory management is not a problem. Code generated by a client's compiler can freely access all these tables through the vtable pointer, which is always located in the first 4 bytes of the memory image of the object. All C++ compilers use the same memory layout for their implementations of vtables, so vtables are actually a de facto binary standard in the C++ world.</p>
<p>
Thus, this technique lets you export C++ classes without exporting any function name. (16-bit Windows still requires the <b>_export</b> tag or compilation with a special compiler option, because we need prologue/epilogue code to switch between different data segments of DLL and EXE.) All that the client and the object have to agree on is the layout of the vtable—that is, the order of the functions in the vtable, the number and kind of parameters for each function, and the way the parameters are passed (in most cases on the stack: calling convention!).</p>
<p>
The layout of the vtable and the function parameters is completely defined by an abstract base class, so that a C++ header file can server as a complete description of the syntax of an interface contract.</p>
<h3>Changes: Step by Step</h3>
<p>
This sample is based on the first DLL subdirectory, DB_CPPDLL. The changes are almost identical to the ones for DB_VTBL, except that we already implemented the indirect instantiation of <b>CDB</b> for other reasons (memory management!).
<ol>
<li>
Copy the interface\dbsrv.h header file to object\dbsrvimp.h. The first file will contain the abstract base class, which is the only code the client needs. The second file will be the header for the actual implementation.<br><br></li>
<li>
Make all functions in interface\dbsrv.h (both <b>CDB</b> and <b>CDBSrvFactory</b>) pure virtual functions and remove the data members. Remove the export on all member functions. Change the name of the class from <b>CDB</b> to <b>IDB</b> (Interface to DB), and <b>CDBSrvFactory</b> to <b>IDBSrvFactory</b>.<br><br></li>
<li>
Derive <b>CDB</b> in object\dbsrvimp.h from <b>IDB</b> and include ...\interface\bdsrv.h. (Don't forget to change the #ifndef at the beginning of the file to something like _DBSRVIMP_INCLUDE.) Derive <b>CDBSrvFactory</b> from <b>IDBSrvFactory</b>.<br><br></li>
<li>
Change the parameter of <b>IDBSrvFactory::CreateDB to IDB**</b> instead of <b>CDB**</b>. Change the parameter of <b>DllGetClassFactoryObject</b> to <b>IDBSrvFactory**</b>.<p class=tl>
The following code illustrates the resulting Interface\dbsrv.h header file:</P><pre><code>class <b>I</b>DB {
 // Interfaces
 public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Interface for data access.
 &nbsp;&nbsp;&nbsp;&nbsp; <b>virtual </b>HRESULT Read(short nTable, short nRow, LPWSTR lpszData) <b>=0</b>;
 &nbsp;&nbsp;&nbsp;&nbsp; (...)
};
class <b>I</b>DBSrvFactory {
 &nbsp; // Interface
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; <b>virtual </b>HRESULT CreateDB(IDB** ppObject) <b>=0</b>;
 &nbsp;&nbsp;&nbsp;&nbsp; <b>virtual </b>ULONG&nbsp; Release() <b>=0</b>;
};
HRESULT DEF_EXPORT DllGetClassFactoryObject(<b>I</b>DBSrvFactory ** ppObject);
</code></pre>
<p class=tl>
The new Object\dbsrvimp.h header:</P><pre><code><b>#include "..\Interface\dbsrv.h"

</b>class CDB : <b>public IDB </b>{
 // Interfaces
 public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Interface for data access.
 &nbsp;&nbsp;&nbsp;&nbsp; HRESULT Read(short nTable, short nRow, LPWSTR lpszData);
};
class CDBSrvFactory : <b>public IDBSrvFactory </b>{
 &nbsp; // Interface
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; HRESULT CreateDB(<b>I</b>DB** ppObject);
 &nbsp;&nbsp;&nbsp;&nbsp; ULONG&nbsp; Release();
};
</code></pre>
</li>
<li>
Make object\dbsrv.cpp and object\dbsrvfact.cpp include dbsrvimp.h instead of dbsrv.h.<p class=tl>
The resulting DBSrvFact.CPP (no changes, just adjusting the instantiation function):</P><pre><code>HRESULT CDBSrvFactory::CreateDB(<b>I</b>DB** ppvDBObject) {
 *ppvDBObject=<b>(IDB*)</b> new CDB;
 return NO_ERROR;
}
(...)
HRESULT DEF_EXPORT DllGetClassFactoryObject(<b>I</b>DBSrvFactory ** ppObject) {
 &nbsp; *ppObject=<b>(IDBSrvFactory*)</b> new CDBSrvFactory;
 &nbsp; return NO_ERROR;
}
</code></pre>
</li>
<li>
Now we will adjust the client: Change <b>CDB::m_pDB</b> to <b>IDB*</b>. In <b>CDBDoc::OnNewDocument</b>, change <b>CDBSrvFactory*</b> to <b>IDBSrvFactory*</b>.</li>
</ol>
<p>
Everything works just as before. The performance is identical to that of the prior version of the code where everything is compiled into one executable! The compiler does the same indirect function call through the vtable.</p>
<p>
Run <b>DumpBin.EXE</b> /<b>exports db.dll</b> and you will see that the only exported entry point is <b>DllGetClassFactoryObject</b>! </p>
<p>
All the rest of the dangerous, mangled names have disappeared. All member functions are now cleanly accessed through vtables. We could even dare to load the DLL dynamically (through <b>LoadLibrary</b>/<b>GetProcAddress</b>), because there is only one exported entry point.</p>
<h2><a name="db2com"></a>DBAlmostCOM: C++ Object in a DLL, Loaded Through COM</h2>
<p>
<OBJECT id=sample5 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4528">
</OBJECT><a href="javascript:sample5.Click()">Click to view or copy the files for the DBAlmostCOM sample application.</a></p>
<p>
The previous sample provided a very flexible mechanism for object packaging: Only one entry point had to be declared in the DLL, and all other interchange was done through pointers to pure abstract base classes.</p>
<p>
Next, we will make some minor changes that will make this object almost COM-compliant.</p>
<h3>Single Standard Entry Point for Object Creation</h3>
<p>
Suppose you want to pack multiple objects into a single DLL. Basically, you have two options:
<ul type=disc>
<li>
Provide one entry point function for each class you want to export.<br><br></li>
<li>
Pass an additional parameter to a standard entry point, indicating which class you want.</li>
</ul>
<p>
The second approach seems to be more appropriate for a generic component model, because it provides one central entry point for creating all the objects you want. COM does exactly this, and requires all objects implemented in DLLs (also called in-process servers) to export the entry point through the <b>DllGetClassObject</b> function.</p>
<p>
This function receives a parameter of type CLSID that specifies which class the caller wants to access. The CLSID is nothing but a relatively big number (16 bytes—yes, bytes, not bits—in case many people want to create objects). </p>
<p>
The DLL checks the number of the class that is requested, and if it provides that class, it returns a pointer to an object that implements the creation method for the actual object. This is the architecture we used already for both of our DLL samples. Introducing this intermediate object allows for flexible instantiation of objects. There is another technical reason for this approach that is related to objects implemented in executables, which we will discuss later.</p>
<p>
Microsoft provides a tool for generating CLSIDs that are guaranteed to be globally unique. This is done (a little simplified) by using the worldwide unique ID of the network card, combined with the current date and time. This combination fits into 16 bytes, plus there is plenty of space left over for a simple counter that can give you an (almost) arbitrarily large range of contiguous CLSIDs. Because these numbers are used for many things — not just as class identifiers—they are called <i>globally unique identifiers</i> (GUIDs).</p>
<p>
Here is our standard entry-point function in completed form:</p>
<pre><code>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppObject);
</code></pre>
<p>
STDAPI is just a macro that is replaced (by the compiler) with HRESULT and some calling convention.</p>
<p>
We find our CLSID (here declared as a reference to a CLSID), and our "pointer to a pointer" that receives the pointer to the object's instance. Note that this pointer is declared as "void," because we will return arbitrary base class pointers through this parameter. </p>
<p>
What about the additional parameter, <i>riid</i>, that looks like another of those GUIDs? <i>IID</i> stands for <i>interface ID</i>. With the <i>riid</i> parameter, the caller indicates what kind of pointer it expects to be returned through <i>ppObject</i>. The object returned is the class factory object, and the interface ID assures the caller that it "understands" the pointer. The object will check that the caller actually requests our interface <b>IDBSrvFactory</b>, for which we will designate a unique IID.</p>
<h3>Standard Object Creation API</h3>
<p>
Once this standard entry point is exported, the COM libraries can manage our DLL as an object, even though it is not yet a real COM object. We can register our object—its CLSID and the path to the DLL—and have COM worry about loading the DLL. Before we used implicit DLL linking in our client—the linker put in some code to load the specific DLL we had compiled with, and the name of the DLL was hard-coded into the client's executable. Now we will just tell the COM libraries the CLSID of the object that we want, and COM will find and load the DLL for us.</p>
<p>
The API that COM provides for this purpose is <b>CoGetClassObject:</b> </p>
<pre><code>HRESULT CoGetClassObject(
 &nbsp; REFCLSID rclsid, 
 &nbsp; DWORD dwClsContext, LPVOID pvReserved&nbsp;&nbsp; REFIID riid, LPVOID * ppv);
</code></pre>
<p>
The first parameter is the CLSID of the object that we want to load. COM looks for it in the registry under HKEY_CLASSES_ROOD\CLSID\{xxx}. </p>
<p>
The second and third parameters give more information about the activation context of our object. For now we will just ask for any server (CLSCTX_SERVER), and pass NULL for <b>lpReserved</b>. </p>
<p>
The next parameter is the IID of the initial abstract base class pointer that we want to retrieve from the object, and the last parameter is our pointer to a pointer that will receive the pointer to the object.</p>
<p>
But how does <b>CoGetClassObject</b> find the DLL that implements this CLSID, if the CLSID is just a number (admittedly, a large one) with no encoded information?</p>
<h3>Standard Object Registration</h3>
<p>
All the object-related information that the COM libraries need is concentrated under one entry in the registry: HKEY_CLASSES_ROOT\CLSID. Each object has a key that is named with the string representation of its CLSID. Under this key, the COM libraries look for the information they need in order to create an object. </p>
<p>
For now, we just need one of these entries: <b>InprocServer32</b>. This entry indicates the path to a DLL with the standard entry-point mechanism. Thus, given the CLSID, the COM library can look under HKEY_CLASSES_ROOT\CLSID, find the appropriate key for the object, look for the sub-key <b>InprocServer32</b>, and obtain the name of the DLL.</p>
<p>
<b>CoGetClassObject</b> then loads the DLL (using <b>LoadLibrary</b>) , obtains the entry point for the <b>DllGetClassObject</b> function (using the Win32 <b>GetProcAddress</b> function), calls <b>DllGetClassObject</b> with the parameters the caller provided, and passes the pointer to the class object back to the client. </p>
<p>
From there on, everything is just between the object and the client: The pointer returned is an indirect pointer to the vtable of the class factory implemented by the object. [Theoretically the pointer does not even have to be a pointer to a vtable, because it is typed as void. You could simply return a pointer to a standard C++ object (if you don’t need to access functions), any other type of function lookup table, or whatever you wanted. It does not make sense to do so, but I want to make it clear that COM (in the in-process case) does no interpretation whatsoever on this returned pointer.] Any call on this pointer is a normal C++ virtual function call. COM does not interfere in this process; it just provides the service of locating and loading the object. The performance of this sample and the pure vtable-based sample are exactly identical.</p>
<h3>Changes: Step by Step</h3>
<ol>
<li>
Generate two GUIDs using GUIDGEN.EXE: Choose the third option, "struct . . . GUID", and copy and paste the new GUIDs one by one to interface\bdsrv.h—they are part of the <i>contract</i> between the object and the client (see the Note below). Name them CLSID_DBSAMPLE and IID_IDBSrvFactory, respectively. Leave just the declaration part in "dbsrv.h" ("extern") and put the definition in "object\dbsrvfact.cpp". (Later we will see two other methods for managing GUIDs within source files: one with a macro DECLARE_GUID and the other when we use the Interface Definition Language [IDL] to describe interfaces.)<p class=tl>
<b>Note:</b> If you want to be prepared for future needs of GUIDs, and want to have them in consecutive order, take time now to generate some 10 or 20—using the “New GUID” button—and pass them to a separate file somewhere (perhaps a Microsoft Excel spreadsheet?). If you need a lot of GUIDs, you might also want to look at the command-line utility uuidgen.exe, which allows automatic generation of multiple GUIDs (/n parameter). The advantage of having your GUIDs together range from “aesthetic” (all registry keys appear together) to more relevant performance issues (COM needs to do a lookup of GUIDs quite often and works a little more efficiently on clusters of GUIDs than on widely separated GUIDs.</P><p class=tl>
The following code shows the definition of the GUIDs in object\bdsrvfact.cpp (they look dangerous, but are nothing but <i>really big</i> numbers):</P><pre><code>// {30DF3430-0266-11cf-BAA6-00AA003E0EED}
static const GUID CLSID_DBSAMPLE =
{ 0x30df3430, 0x266, 0x11cf, { 0xba, 0xa6, 0x0, 0xaa, 0x0, 0x3e, 0xe, 0xed } };
// {30DF3431-0266-11cf-BAA6-00AA003E0EED}
static const GUID IID_IDBSrvFactory =
{ 0x30df3431, 0x266, 0x11cf, { 0xba, 0xa6, 0x0, 0xaa, 0x0, 0x3e, 0xe, 0xed } };
</code></pre>
</li>
<li>
Remove the declaration of <b>DllGetClassFactoryObject</b> in dbsrv.h (already declared in OLE2.H), and change the implementation in dbsrvfact.cpp to the following:<pre><code>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject)
</code></pre>
<p class=tl>
Validate the two parameters as CLSID_DBSAMPLE and IID_IDBSrvFactory, respectively. If one of them does not have the expected value, return CLASS_E_CLASSNOTAVAILABLE or E_INVALIDARG, as follows:</P><pre><code>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject) {
if (rclsid!=CLSID_DBSAMPLE) { // Is this the number of our class?
return CLASS_E_CLASSNOTAVAILABLE;
}
if (riid!=IID_IDBSrvFactory) { // Is this the number of our interface?
return E_INVALIDARG;
}
*ppObject=(IDBSrvFactory*) new CDBSrvFactory;
return NO_ERROR;
}
</code></pre>
</li>
<li>
Include ole2.h as follows: In stdafx.h append "#include &lt;ole2.h&gt;". Add "#define _AFX_NO_BSTR_SUPPORT" before the other includes, because the MFC header files define some symbols differently than OLE2.H does. (Be careful not to include afxole.h, because doing so provides an ASCII/Unicode mapping layer, which can get into your way when using some COM interfaces or APIs. This mapping layer was removed in MFC 4.0.)<br><br></li>
<li>
Create a module definition file, DB.DEF, and export <b>DllGetClassObject</b>. (You cannot use <b>_declspec(dllexport)</b> because the function is already declared in ole2.h with different modifiers.)<br><br></li>
<li>
For the client, in client\dbdoc.cpp, call COM instead of loading our DLL directly: Call <b>CoGetClassObject</b> instead of <b>DllGetClassObject</b>. Validate the result using the <b>FAILED</b>-macro provided by OLE2.H:<pre><code>HRESULT hRes;
hRes=CoGetClassObject(CLSID_DBSAMPLE, CLSCTX_SERVER, NULL, 
IID_IDBSrvFactory, (void**) &amp;pDBFactory);
if (FAILED(hRes)) {
CString csError;
csError.Format(_T("Error %d creating DB Object!"), hRes);
AfxMessageBox(csError);
return FALSE;
}
</code></pre>
</li>
<li>
Call <b>CoInitialize(NULL)</b> in <b>CDBApp::InitInstance</b> to initialize the COM libraries; and call <b>CoUninitialize()</b> in <b>CDBApp::ExitInstance</b>.<br><br></li>
<li>
Add the definitions of CLSID_DBSAMPLE and IID_IDBSrvFactory to the beginning of dbdoc.cpp. Instead of hard-coding the name of the DLL, we now hard-code the CLSID of the object that we want to use!<br><br></li>
<li>
Add ole32.lib to the project and remove db.lib from the project (in Project/Setting/Linker).<br><br></li>
<li>
Change stdafx.h to include both ole2.h and #define _AFX_NO_BSTR_SUPPORT.<br><br></li>
<li>
Register the DLL in register HKEY_CLASSES_ROOT\CLSID\{&lt;&lt;your clsid&gt;&gt;}\InprocServer32={your path}db.dll. (If your DLL is in your system path or in the same directory as the client, you do not need to specify the complete path to the DLL.). All GUIDs in the registry appear in ASCII form within brackets. You can get your GUID's string representation from the definition provided by GUIDGEN (should be in your header file).<p class=tl>
a. Run Regedt32.exe and open HKEY_CLASSES_ROOT\CLSID.</P><p class=tl>
b. Add a Key with the name of your CLSID:</P><p class=tl>
{30DF3430-0266-11cf-BAA6-00AA003E0EED}</P><p class=tl>
c. To this new Key add an unnamed Value, with Data Type = REG_SZ and String = DB Sample Object. This string is not used by COM but can help you to find your CLSID later.</P><p class=tl>
d. Add a Key named InprocServer32.</P><p class=tl>
e. Add an unnamed Value, with Data Type = REG_SZ and String = <i>&lt;path&gt;</i>\db.dll, replacing &lt;path&gt; with the actual path of your DLL. Optionally you can just register db.dll and add its path to the system or user path.</P></li>
</ol>
<p>
Compile the object and the client. (This time the order does not matter because we no longer link to the DLL.) If you receive errors when creating the object, you can look up the error codes (hRes) in WINERROR.H. The most probable failure is an incorrect registration of the DLL or a non-exported entry point for <b>DllGetClassObject</b>. (Of course, this has <i>never</i> happened to me!)</p>
<p>
You can still mix and match Unicode/ASCII and Debug/Release clients and servers.</p>
<h2><a name="dbcom"></a>DBCOM: COM Object in a DLL, Loaded Through COM</h2>
<p>
<OBJECT id=sample6 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4529">
</OBJECT><a href="javascript:sample6.Click()">Click to view or copy the files for the DBCOM sample application.</a></p>
<p>
The previous sample illustrated a portion of COM's infrastructure for creating instances of objects. In order to make our object a real COM object, only minor details are missing:
<ul type=disc>
<li>
Allow reference counting on our exposed interfaces.<br><br></li>
<li>
Allow multiple interfaces on an object.<br><br></li>
<li>
Use the standard <b>IClassFactory</b> interface on the class factory object.<br><br></li>
<li>
Use the _stdcall calling convention.<br><br></li>
<li>
Allow for dynamic unloading of a DLL.<br><br></li>
<li>
Allow for self-registration of an object.</li>
</ul>
<p>
None of these features requires a lot of implementation and their implementation is highly reusable. They take up some space to explain them, less space to implement them, and once you have implemented them for one object (as I did for this sample) you can reuse most of the implementation for all of your objects. The class factory, the loading and unloading code, and registration support simply require you to adjust the name of the class and the GUIDs involved.</p>
<h3>Reference Counting</h3>
<p>
Suppose that our little database object will be used by several clients simultaneously. Currently we could return the same instance of CDB to all calls to <b>IDBSrvFactory::CreateDB</b> and all of the documents of our client would access the same object. But problems will arise if one of the clients calls <b>Release</b> on our object—the object would destroy itself, and all other clients would perform calls on a nonexistent object.</p>
<p>
The solution to this problem is so simple that it is required for all COM objects: The object maintains a count of how many pointers to itself it gave away, and when <b>Release</b> is called, it decrements this reference count. If the count reaches zero, the object has no reason to exist anymore (at least, concerning external references), and it is free to destroy itself.</p>
<p>
How does the object count the references when it gives away a pointer? One way would be to have the class factory object and the object work together: The class factory object increments the object's reference count whenever it gives away an external reference on a call to <b>CreateInstance</b>. But this approach would have a fairly limited application. Therefore, the object actually exposes another function to increment the reference count: Whoever has a pointer to the object can tell the object that she or he just gave the pointer to somebody else. This entity can be the class factory object or any other client. The function referred to above has a very simple name: <b>AddRef</b>.</p>
<p>
Therefore, the two <i>required</i> member functions for managing reference counts on any COM object are:</p>
<pre><code>ULONG AddRef();
ULONG Release();
</code></pre>
<p>
The functions are not really required. However, the approach makes so much sense for any object, even the tiniest, and the implementation of those functions is so inexpensive, that you should just implement them.</p>
<p>
If you want your object to be accessible remotely (from another process and/or another machine), your object must provide these functions. The cost is very low for the benefit you receive, both in terms of a programming philosophy within your own code and in terms of migration to a distributed environment.</p>
<p>
These two functions do not return HRESULT, because they cannot really fail, unless the object does not exist anymore. And if so, who is going to give back an error code? Inasmuch as these functions do not need a return value, they simply return the current reference count of the object, but only if the object feels that it is necessary to do so. In other words, the object is not even required to return a reasonable value. This leaves the return value useful only for debugging purposes; you should not use it for anything in your program.</p>
<h3>Multiple Interfaces</h3>
<p>
In the next section we will take a look in greater depth at providing multiple interfaces. For now, let's suppose that an object wants to return different interfaces for different clients. The clients would need some way to ask the object for a specific interface, and in fact we already introduced a method for doing so—the IID passed to <b>DllGetClassObject</b>. Remember that the client passed an interface ID to the class factory object, and in the object we validated whether it was our class factory interface.</p>
<p>
This is a good approach for a class factory: One client can obtain the class factory object, asking for one interface, perhaps, so that the client can instantiate an object without a user ID or password, and another client can create the object through an interface that passes in UserID/Password. (This is not a very useful example; it is just to explain why there could be multiple interfaces on an object, and why this mechanism is also provided for the class factory object.)</p>
<p>
If an object wants to expose two different interfaces, we can have the <b>CreateDB</b> function of the class factory object—the function that actually instantiates an object—receive another parameter, an IID, and we can create the appropriate objects based on the requested interface.</p>
<p>
But what if a client needs two interfaces on a given object—perhaps one interface for creating tables and another for reading or writing? It would be great if the client could ask the object for another interface, once it has a pointer to the first interface.</p>
<p>
To provide this functionality, the object can expose an additional member function on its initial interface, a member function to which the client could pass the interface ID it wants and a pointer to where it wants to receive the new interface:</p>
<pre><code>HRESULT QueryInterface(RIID riid, void** ppObj);
</code></pre>
<p>
On receiving a call to this function, the object could check the interface ID and return a pointer to a vtable that implements the requested functionality. The object can provide this pointer however it pleases, as long as the contract expressed by the interface ID is fulfilled. In other words, the <i>order</i> of the functions and their parameters must be correct. </p>
<p>
The object can create another C++ object, one that exposes a different interface but works as a client to the real object and returns this pointer. It is important that the returned interface work on the same logical object: If you delete a table through the second interface, the first interface must show the changes. (This is actually one way of implementing multiple interfaces on a COM object—composing a COM object of multiple interrelated C++ objects. This is the most tedious, but also the most flexible, way of doing it. Later we will see another approach using multiple inheritance from multiple abstract base classes, and another technique using C++ nested classes. You could even set up a table of pointers with the addresses of the functions of the interface, and return the address of a pointer to this table. You must do this if you want to use COM from plain C.)</p>
<p>
The idea behind exposing multiple interfaces through <b>QueryInterface</b> is to allow for different ways of seeing the same object, not to access separate objects. Separate objects should be assigned individual CLSIDs. They can share the same interface: A database object in memory could allow the same methods as a database object working on a file. The two objects could be accessed through the same interface (<b>IDB</b>) but each have a unique CLSID for reaching the code that implements them. The file-based database would probably provide an additional interface for setting the filename and committing changes to the file.</p>
<p>
If an object is actually a sub-object of another object—for example, an object that represents a given table of the database—it can simply be returned by a member function of its parent object. That is, a <b>Read</b> function could return a pointer to a table object instead of returning a row of data.</p>
<p>
If this sounds a little confusing, wait until the next section, where we will see the real-world benefit of this feature. For now, I hope I have convinced you to implement this way of asking for other interfaces to an object. It is especially important if you think about a world of component objects communicating with each other and being able to inquire into each others' level of functionality, the version of that functionality, and so on.</p>
<h3>Reference Counting and Support for Multiple Interfaces: IUnknown</h3>
<p>
We have seen two great features to have on any object: Reference Counting (<b>AddRef</b> and <b>Release</b>) and multiple interfaces (<b>QueryInterface</b>). COM requires any object to implement these three functions, in the sense I mentioned above. It makes a lot of sense to have them on any object, and without them COM cannot handle remote processing for your object.</p>
<p>
In order to formalize this set of requirements, COM defines a standard interface called <b>IUnknown</b> (declared by including OLE2.H):</p>
<pre><code>class IUnknown {
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; virtual HRESULT QueryInterface(RIID riid, void** ppObj) =0;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual ULONG&nbsp;&nbsp; AddRef() =0;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual ULONG&nbsp;&nbsp; Release() =0;
};
</code></pre>
<p>
An object can simply derive from <b>IUnknown</b> and implement the three functions. Another way to implement <b>IUnknown</b> is to add the three functions to the beginning of your custom interface. Let's use <b>IDB</b> as an example:</p>
<pre><code>class IDB {
 // Interfaces
 public:

<b> &nbsp;&nbsp;&nbsp;&nbsp; // Interfaces for COM and useful anyway</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp; virtual HRESULT QueryInterface(RIID riid, void** ppObj) =0;</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp; virtual ULONG&nbsp; AddRef() =0;</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp; virtual ULONG&nbsp; Release() =0;</b>

 &nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Interface for data access
 &nbsp;&nbsp;&nbsp;&nbsp; virtual HRESULT Read(short nTable, short nRow, LPWSTR lpszData) <b>=0</b>;
 &nbsp;&nbsp;&nbsp;&nbsp; (...)
};
</code></pre>
<p>
Another way of achieving the same goal is to simply derive <b>IDB</b> from <b>IUnknown</b>—that is, derive one abstract base class from another abstract base class, as follows:</p>
<pre><code>class IDB : public IUnknown {
 // Interfaces
 public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Interface for data access
 &nbsp;&nbsp;&nbsp;&nbsp; virtual HRESULT Read(short nTable, short nRow, LPWSTR lpszData) =0;
 &nbsp;&nbsp;&nbsp;&nbsp; (...)
};
</code></pre>
<p>
This approach simply combines the two vtables into one: <b>IDB</b> includes all the functions of <b>IUnknown</b>; <b>IDB</b> has the same three functions at the beginning of its vtable. These functions are polymorphic, even on the binary level. </p>
<p>
With this in mind, we will re-implement our <b>DBAlmostCOM</b> to make it DBCOM. For <b>QueryInterface</b>, we already have two possible answers: The last sample we created can satisfy the requests for <b>IDB</b>. But now we can also satisfy the requests for <b>IUnknown</b> by simply returning <b>IDB</b>. Somebody who does not know <b>IDB</b>, but just <b>IUnknown</b>, will simply call the first three functions in our vtable, which happen to implement the same functions that <b>IUnknown </b>does.</p>
<p>
Again, the real benefit of this approach will not be seen until the next sample, in which we implement really useful multiple interfaces.</p>
<h3>Standard Class Factory Interface: IClassFactory</h3>
<p>
Up to now, our <b>CDBSrvFactory</b> class factory object has been very specialized. Its only member function is</p>
<pre><code>HRESULT CreateDB(IDB* ppObj)
</code></pre>
<p>
which it exposes through a very specialized interface, <b>IDBSrvFactory</b>. Each object would need a specialized interface because the initial interface returned would probably be different for each object. It sounds like a good idea, if the caller of the <b>CreateXXX</b> function could be allowed to specify the initial interface on the actual object, just as COM does for the class factory:</p>
<pre><code>HRESULT MyCreateInstance(RIID riid, void** ppObj);
</code></pre>
<p>
The class factory object could check the IID and instantiate the appropriate object, implementing the required interface, or it could create an object and call <b>QueryInterface</b> on that object to obtain the requested IID.</p>
<p>
It is important to distinguish between the class ID (CLSID) and the interface ID (IID): The class ID refers to a logical object that provides a given functionality through a given interface—possibly multiple interfaces. The interface ID refers to a specific layout of a vtable that is used to "talk" to the object.</p>
<p>
This almost completes our standard class factory interface. Like any COM object, the class factory object also exports the <b>IUnknown</b> functions for reference counting and for supporting multiple interfaces:</p>
<pre><code>class IClassFactory : public IUnknown {
 &nbsp; virtual HRESULT CreateInstance(IUnknown *pUnkOuter, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID riid, void**&nbsp; ppvObject) = 0;
 &nbsp; virtual HRESULT LockServer(BOOL fLock) = 0;
};
</code></pre>
<p>
Well, we almost have it: <b>CreateInstance</b> has an additional parameter, <i>pUnkOuter</i>, that allows for a sophisticated reuse mechanism called <i>aggregation</i>. We will not deal with aggregation in these samples, so we just pass in NULL and when we receive a call, we will check for NULL, and fail if <i>pUnkOuter</i> is not NULL.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Aggregation allows you to effectively merge two objects and make them appear as one to a client. An “outer object” receives all the calls to <b>IUnknown</b> (reference count and queries for new interfaces) and can—usually—selectively return pointers to an “inner object” to the client. If the client calls a function from <b>IUnknown</b> on the inner object, the inner object must call back to the outer unknown (hence the parameter <i>pUnkOuter</i> at creation time of the inner object), in order for the two objects to be perceived as identical. See the Win32 SDK or the OLE Design Specification for details.</p>
<p>
Another function we have passed over is <b>LockServer</b>. This function lets the client keep alive the module that implements the class factory object. Why do so, if reference counting through <b>IUnknown</b>'s <b>AddRef/Release</b> methods lets the object know if someone still needs it? Some objects (such as local servers implemented in an EXE) do not count references to the class factory object as sufficient to keep the code for the object in memory; they exit when nothing but a class factory remains. Clients can keep these kind of objects alive by calling <b>LockServer</b> on the class factories that they want to keep after creating them.</p>
<p>
For now, we will implement <b>LockServer</b> by effecting a global reference count for the DLL that combines all outstanding references, whether it is to the database object(s) or class factory object(s).</p>
<h3>Dynamic Unloading of an Object's Code</h3>
<p>
In this sample, our client requires that the object be loaded while the client is running, unless the user closes all the documents. In that case, the DLL is no longer used by the client. If we had to optimize memory resources, we could unload the DLL in this situation.</p>
<p>
With implicit linking, there is no way to do this, and using the COM Libraries for loading our DLL leaves us without access to the <b>LoadLibrary/FreeLibrary</b> calls. COM takes the responsibility for unloading the code, which it does by querying the DLLs it has loaded to see if they are still in use. COM calls another DLL exported function, <b>DllCanUnloadNow</b>, and expects the DLL to answer S_OK or S_FALSE. </p>
<p>
We will implement this function by maintaining a global reference count: Whenever a pointer is given away, whether to a class factory or to a database object, we call <b>AddRef</b> to increment both the object's reference count and a global variable containing all the reference counts. <b>DllCanUnloadNow</b> simply checks to see if the global reference count is 0 and returns S_OK. COM then knows that it can safely unload this DLL.</p>
<p>
The COM libraries check the modules on behalf of the client: The client should call <b>CoFreeUnusedLibraries</b> periodically if it wants to ensure that COM unloads unused libraries.</p>
<h3>Self-Registration</h3>
<p>
It is very practical for an object to provide for self-registration. This facilitates installation (and de-installation!) of an object. The idea is very simple: Two standard entry points, <b>DllRegisterServer</b> and <b>DllUnregisterServer</b>, provide this functionality and can be called by any program that needs to register a DLL. The regsrv32.exe utility provided with the OLE Controls CDK does nothing more than call one of these functions on a DLL.</p>
<p>
The implementation of these functions can be a little tedious due to the nature of the registry (or is it the Win32 API used for accessing it?), but is nonetheless straightforward.</p>
<h3>Changes: Step by Step</h3>
<ol>
<li>
Derive <b>IDB</b> from <b>IUnknown</b>. Remove the old declaration of <b>Release</b> from <b>IDB</b>. Add _stdcall to all members of <b>IDB</b>, since this is the standard calling convention for COM objects under Win32.<br><br></li>
<li>
Remove the declaration of <b>IDBSrvFactory</b>. We will now use the standard class factory interface, <b>IClassFactory</b>. Also remove the IID_IDBSrvFactory.<br><br></li>
<li>
Create a new IID_IDB with GUIDGen (or use one of the GUIDs that you generated in advance). Do not reuse IIDB_IDBSrvFactory: GUIDs should never be reused, because they define a unique contract and they are not a limited resource. Add the declaration and implementation to interface\dbsrv.h, object\dbsrvfact.cpp, and client\dbdoc.cpp respectively.<p class=tl>
The new Interface\DBSRV.H looks like this:</P><pre><code>(...)
// {30DF3432-0266-11cf-BAA6-00AA003E0EED}
extern const GUID IID_IDB;
//{ 0x30df3432, 0x266, 0x11cf, { 0xba, 0xa6, 0x0, 0xaa, 0x0, 0x3e, 0xe, 0xed } };
class IDB <b>: public IUnknown</b> {
// Interfaces
public:
// Interface for data access
virtual HRESULT _<b>stdcall</b> Read(short nTable, short nRow, LPWSTR lpszData) =0;
virtual HRESULT _<b>stdcall</b> Write(short nTable, short nRow, LPCWSTR lpszData)=0;
// Interface for database management
virtual HRESULT _<b>stdcall</b> Create(short &amp;nTable, LPCWSTR lpszName) =0;
virtual HRESULT _<b>stdcall</b> Delete(short nTable) =0;
// Interfase para obtenber informacion sobre la base de datos
virtual HRESULT _<b>stdcall</b> GetNumTables(short &amp;nNumTables) =0;
virtual HRESULT _<b>stdcall</b> GetTableName(short nTable, LPWSTR lpszName) =0;
virtual HRESULT _<b>stdcall</b> GetNumRows(short nTable, short &amp;nRows) =0;

<b>//virtual ULONG Release() =0;</b>

};
</code></pre>
</li>
<li>
Derive <b>CDBSrvFactory</b> from <b>IClassFactory</b> instead of from <b>IDBSrvFactory</b>.<br><br></li>
<li>
Change <b>CDBSrvFactory::CreateDB</b> to <b>CDBSrvFactory::CreateInstance</b>, and add a member function called <b>CDBSrvFactory::LockServer</b>.<br><br></li>
<li>
Add a <b>ULONG m_dwRefCount</b> member to both <b>CDB</b> and <b>CDBSrvFactory</b> for their respective reference counts. Also add a constructor to both classes and initialize m_dwRefCount to 0.<br><br></li>
<li>
Add a global variable, <i>ULONG g_dwRefCount</i>, to dbsrvimp.h and dbsrvimp.cpp.<br><br></li>
<li>
Add <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> member functions to both <b>CDB</b> and <b>CDBSrvFactory</b>. (The order of the declaration in the implementation header file does not affect the order in the vtable. The vtable is defined by the order of declarations in IDB!)<p class=tl>
The new Object\DBSrvImp.h looks like this:</P><pre><code>class CDB : public IDB {
// Interfaces
public:
// Interface for data access
HRESULT _<b>stdcall</b> Read(short nTable, short nRow, LPWSTR lpszData);
(...)
HRESULT _<b>stdcall</b> GetNumRows(short nTable, short &amp;nRows);

<b>HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);</b>

<b>ULONG&nbsp; _stdcall AddRef();</b>

ULONG&nbsp; _<b>stdcall</b> Release();
// Implementation
private:
CPtrArray m_arrTables; // Array of pointers to CStringArray
CStringArray m_arrNames; // Array of table names

<b>ULONG m_dwRefCount;</b>

public:

<b>CDB();</b>

~CDB();
};

<b>extern ULONG g_dwRefCount;</b>

class CDBSrvFactory : public <b>IClassFactory </b>{
// Interface
public:

<b>HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);</b>

<b>ULONG&nbsp; _stdcall AddRef();</b>

<b>ULONG&nbsp; _stdcall Release();</b>

HRESULT <b>_stdcall </b>Create<b>Instance(IUnknown *pUnkOuter, REFIID riid, </b>

<b>void** </b>ppObject);

<b>HRESULT&nbsp;&nbsp; _stdcall LockServer(BOOL fLock);</b>

// Implementation

<b>private:</b>

<b>ULONG m_dwRefCount;</b>

<b>public:</b>

<b>CDBSrvFactory();</b>

};
</code></pre>
</li>
<li>
Implement <b>AddRef</b>, <b>Release</b>, and <b>QueryInterface</b> for <b>CDB</b> and <b>CDBSrvFactory</b>.<br><br></li>
<li>
Change <b>CDBSrvFactory::CreateDB</b> to <b>CreateInstance</b>, and validate the new parameters.<br><br></li>
<li>
Implement <b>CDBSrvFactory::LockServer</b>.<p class=tl>
Here is the new implementation in DBSRV.CPP:</P><pre><code><b>CDB::CDB() {

m_dwRefCount=0;

}

HRESULT CDB::QueryInterface(REFIID riid, void** ppObject) {

if (riid==IID_IUnknown || riid==IID_IDB) {

*ppObject=(IDB*) this;

}

else {

return E_NOINTERFACE;

}

AddRef();

return NO_ERROR;

}

ULONG CDB::AddRef() {

g_dwRefCount++;

m_dwRefCount++;

return m_dwRefCount;

}

</b>ULONG CDB::Release() {

<b>g_dwRefCount--;</b>

<b>m_dwRefCount--;</b>

<b>if (m_dwRefCount==0) {</b>

delete this;

<b>return 0;</b>

<b>}</b>

<b>return m_dwRefCount;</b>

}
</code></pre>
<p class=tl>
And the new implementation in DBSRVFact.cpp:</P><pre><code><b>ULONG g_dwRefCount=0;

</b>// {30DF3430-0266-11cf-BAA6-00AA003E0EED}
static const GUID CLSID_DBSAMPLE = 
{ 0x30df3430, 0x266, 0x11cf, { 0xba, 0xa6, 0x0, 0xaa, 0x0, 0x3e, 0xe, 0xed } };
// Create a new database object and return a pointer to it.
HRESULT CDBSrvFactory::Create<b>Instance(IUnknown *pUnkOuter, REFIID riid, </b>

<b>void** ppObject) {</b>

<b>if (pUnkOuter!=NULL) {</b>

<b>return CLASS_E_NOAGGREGATION;</b>

<b>}</b>

<b>CDB* pDB=new CDB;</b>

<b>if (FAILED(pDB-&gt;QueryInterface(riid, ppObject))) {</b>

<b>delete pDB;</b>

<b>*ppObject=NULL;</b>

<b>return E_NOINTERFACE;</b>

<b>}</b>

<b>return NO_ERROR;</b>

}

<b>HRESULT&nbsp;&nbsp; CDBSrvFactory::LockServer(BOOL fLock) {</b>

<b>if (fLock) {</b>

<b>g_dwRefCount++;</b>

<b>}</b>

<b>else {</b>

<b>g_dwRefCount--;</b>

<b>}</b>

<b>return NO_ERROR;</b>

<b>}</b>

<b>CDBSrvFactory::CDBSrvFactory() {</b>

<b>m_dwRefCount=0;</b>

<b>}</b>

<b>HRESULT CDBSrvFactory::QueryInterface(REFIID riid, void** ppObject) {</b>

<b>if (riid==IID_IUnknown || riid==IID_IClassFactory) {</b>

<b>*ppObject=(IDB*) this;</b>

<b>}</b>

<b>else {</b>

<b>return E_NOINTERFACE;</b>

<b>}</b>

<b>AddRef();</b>

<b>return NO_ERROR;</b>

<b>}</b>

<b>ULONG CDBSrvFactory::AddRef() {</b>

<b>g_dwRefCount++;</b>

<b>m_dwRefCount++;</b>

<b>return m_dwRefCount;</b>

<b>}</b>

<b>ULONG CDBSrvFactory::Release() {</b>

<b>g_dwRefCount--;</b>

<b>m_dwRefCount--;</b>

<b>if (m_dwRefCount==0) {</b>

<b>delete this;</b>

<b>return 0;</b>

<b>}</b>

<b>return m_dwRefCount;</b>

<b>}</b>

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject) {
if (rclsid!=CLSID_DBSAMPLE) {
return CLASS_E_CLASSNOTAVAILABLE;
}

<b>CDBSrvFactory *pFactory= new CDBSrvFactory;</b>

<b>if (FAILED(pFactory-&gt;QueryInterface(riid, ppObject))) {</b>

<b>delete pFactory;</b>

<b>*ppObject=NULL;</b>

<b>return E_INVALIDARG;</b>

<b>}</b>

<b>return NO_ERROR;</b>

}
</code></pre>
<p class=tl>
Note that my implementations of <b>CreateInstance</b> and <b>DllGetClassObject</b> do not verify the IID themselves but let the objects do the work by using <b>QueryInterface</b> on the newly created objects. This makes the implementation very reusable: You just change the name of the class and everything works fine. If you add more interfaces to the object, you only have to change <b>QueryInterface</b> in the object. </P><p class=tl>
<b>QueryInterface</b> does an implicit <b>AddRef</b>, since it returns another pointer to the same object. Since we always use <b>QueryInterface</b> after creating an object, we initialize <i>m_dwRefCount</i> to 0. </P><p class=tl>
This is just one way of implementing <b>IUnknown</b>, but a very modular one.</P></li>
<li>
Add <b>DllCanUnloadNow</b>, <b>DllRegisterServer</b>, and <b>DllUnregisterServer</b> to bdsrvfact.cpp and export them in DB.DEF.<pre><code>HRESULT _stdcall DllCanUnloadNow() {
if (g_dwRefCount) {
return S_FALSE;
}
else {
return S_OK;
}
}
STDAPI DllRegisterServer(void) {
HKEY hKeyCLSID, hKeyInproc32;
DWORD dwDisposition;
if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
"CLSID\\{30DF3430-0266-11cf-BAA6-00AA003E0EED}"), 
NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
&amp;hKeyCLSID, &amp;dwDisposition)!=ERROR_SUCCESS) {
return E_UNEXPECTED;
}
(. . .) // See dbsrvfact.cpp for details.
return NOERROR;
}
STDAPI DllUnregisterServer(void) {
if (RegDeleteKey(HKEY_CLASSES_ROOT, 
"CLSID\\{30DF3430-0266-11cf-BAA6-00AA003E0EED}
\\InprocServer32"))!=ERROR_SUCCESS) {
return E_UNEXPECTED;
}
if (RegDeleteKey(HKEY_CLASSES_ROOT, 
"CLSID\\{30DF3430-0266-11cf-BAA6-00AA003E0EED}"))!=ERROR_SUCCESS) {
return E_UNEXPECTED;
}
return NOERROR;
}
</code></pre>
</li>
<li>
Add uuid.lib in "Linker - Object/Library modules" to import the declaration of IID_IUnknown and IID_IClassFactory.<br><br></li>
<li>
Client: Change DBDOC.CPP to create (through a class factory object) <b>QueryInterface</b> for IDB. (There is a Helper API in COM—<b>CoCreateInstance</b>—that combines all the calls in one. For showing the technical details, I chose to implement it here step by step.)<br><br></li>
<li>
Client: Add the definition of IID_IDB to DBDOC.CPP.<br><br></li>
<li>
Client: Add <b>CDBApp::OnIdle</b> (using ClassWizard). During idle processing, call <b>CoFreeUnusedLibraries</b> to make sure that any DLLs loaded by COM that do not have any reference to them get unloaded.<pre><code>BOOL CDBApp::OnIdle(LONG lCount) 
{
if (CWinApp::OnIdle(lCount)) {
return TRUE;
}
CoFreeUnusedLibraries();
return FALSE;
}
</code></pre>
</li>
<li>
Add uuid.lib to the Linker - Object/Library Modules section, for IID_IClassFactory.<pre><code>(...)

<b>IClassFactory</b> *pDBFactory=NULL;
 &nbsp; 
HRESULT hRes;
hRes=CoGetClassObject(CLSID_DBSAMPLE, CLSCTX_SERVER, NULL, IID_<b>IClassFactory</b>,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**) &amp;pDBFactory);
if (FAILED(hRes)) {
 &nbsp; CString csError;
 &nbsp; csError.Format(_T("Error %x obtaining class factory for DB Object!"), hRes);
 &nbsp; AfxMessageBox(csError);
 &nbsp; return FALSE;
 &nbsp; }
hRes=pDBFactory-&gt;<b>CreateInstance</b>(<b>NULL</b>, <b>IID_IDB</b>, <b>(void**) </b>&amp;m_pDB);
if (FAILED(hRes)) {
 &nbsp; CString csError;
 &nbsp; csError.Format(_T("Error %x creating DB Object!"), hRes);
 &nbsp; AfxMessageBox(csError);
 &nbsp; return FALSE;
 &nbsp; }
 &nbsp; 
pDBFactory-&gt;Release(); // Do not need the factory anymore.
(...)
</code></pre>
</li>
</ol>
<p>
Compile both the client and the object, register DB.DLL with regsvr32.exe, and run the client. Again, you can mix and match Unicode/ASCII and Release/Debug versions!</p>
<p>
More than code, there was object philosophy involved, and your object design can benefit from that philosophy even if you do not use COM. Reference counting on objects and managing multiple interfaces on a single object are both useful concepts. The other part of the code sample illustrated standard "infrastructure," such as standard entry points and self-registration, that you can use in your own design, even if you are not planning to use COM.</p>
<h2><a name="dbcommul"></a>DBCOMMUL: COM Object with Multiple Interfaces</h2>
<p>
<OBJECT id=sample7 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4530">
</OBJECT><a href="javascript:sample7.Click()">Click to view or copy the files for the DBCOMMUL sample application.</a></p>
<h3>Theory</h3>
<p>
The previous section introduced the <b>QueryInteface</b> function, which must be present on any COM interface. This function allows a client to ask the object for different pointers to itself that also point to different abstract base classes (also known as interfaces). The only interfaces we have implemented so far are <b>IUnknown</b> and <b>IDB</b>. </p>
<p>
We will now look at a really useful way of implementing multiple interfaces. In the previous sample, <b>IDB</b> was just a superset of <b>IUnknown</b>. The <b>IDB</b> interface basically consists of three semantically related sections: 
<ul type=disc>
<li>
Functions for accessing a table.<br><br></li>
<li>
Functions that allow creation and deletion of tables (that is, they manage the database).<br><br></li>
<li>
Functions that return information on the database and a table.</li>
</ul>
<p>
Suppose different clients have different ways of using our object. For example, some clients may just want to read and write to existing tables. Others may want to create and delete tables but not to read their contents. Having additional functions on the interface to the object is not a major overhead cost, and has the advantage of exposing all the complexity of an object to all its users: A programmer who accesses the content of a table gets to see all the functions for managing the database. In our case, the functions are not tremendously complex, but real objects could expose hundreds of different functions.</p>
<p>
To show the general technique behind grouping of member functions, we will break down our <b>IDB</b> interface into three new interfaces, each derived from <b>IUnknown</b>:</p>
<pre><code>class IDBAccess : public IUnknown {
 &nbsp; public:
 &nbsp; // Interface for data access
 &nbsp; virtual HRESULT _stdcall Read(short nTable, short nRow, LPWSTR lpszData) =0;
 &nbsp; virtual HRESULT _stdcall Write(short nTable, short nRow, LPCWSTR 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszData) =0;
};
class IDBManage : public IUnknown {
 &nbsp; // Interface for database management
 &nbsp; public:
 &nbsp; virtual HRESULT _stdcall Create(short &amp;nTable, LPCWSTR lpszName) =0;
 &nbsp; virtual HRESULT _stdcall Delete(short nTable) =0;
};
class IDBInfo : public IUnknown {
 &nbsp; // Interface for retrieval of information about the database.
 &nbsp; public:
 &nbsp; virtual HRESULT _stdcall GetNumTables(short &amp;nNumTables) =0;
 &nbsp; virtual HRESULT _stdcall GetTableName(short nTable, LPWSTR lpszName) =0;
 &nbsp; virtual HRESULT _stdcall GetNumRows(short nTable, short &amp;nRows) =0;
};
</code></pre>
<p>
These three abstract base classes define three different vtable layouts: <b>IDBAccess</b> has five entries in its vtable—the three <b>IUnknown</b> functions plus two actual functions. <b>IDBManage</b> also has five member functions and <b>IDBInfo</b> has six entries in its vtable: three for <b>IUnknown</b> and three functions of its own.</p>
<p>
A client should be able to ask our object for any of these three interfaces. We have to return a pointer to a vtable that contains only the appropriate function addresses. How can we accomplish this?</p>
<p>
The easiest way to achieve this is through multiple inheritance. We simply derive our <b>CDB</b> implementation class from all the base classes that we want to provide interfaces for: <b>IDB</b>, <b>IDBAccess</b>, <b>IDBManage</b>, and <b>IDBInfo</b>. We keep <b>IDB</b> for providing backwards compatibility for existing clients.</p>
<p>
What do multiple abstract base classes mean from the perspective of C++? If I have a pointer to an object cast to one of its base classes, I can call the correct member functions through the abstract base class. C++ implements this through one vtable layout per class that the object points to in its instance data. If I have a pointer to the same object, but cast to another abstract base class, I am able to do the same—call the members through their vtable position. The cast pointer to the instance must also contain a pointer to the vtable in its instance data.</p>
<p>
How does C++ handle multiple pointers to different base classes? It provides multiple vtables, one for each base class, and multiple pointers within the object's instance data. When casting a pointer, the compiler simply adds the offset to the correct part of the object's instance data. In our case, the object derives from four abstract base classes, and thus has four vtable pointers at the beginning of its instance data.</p>
<p>
For example, when casting occurs from <b>CDB</b> to <b>IDB</b>, the compiler adds 0; when casting occurs from <b>CDB</b> to <b>IDBAccess</b>, the compiler adds 4 to the pointer; when casting occurs from <b>CDB</b> to <b>IDBManage</b>, the compiler adds 8; and so forth.</p>
<p>
There is one dedicated vtable for each interface on <b>CDB</b>—four total for all instances of <b>CDB</b>. The compiler initializes these vtables with the correct function addresses. If two abstract base classes include the same function (such as <b>Read</b> in <b>IDB</b> and <b>IDBAccess</b>, or <b>AddRef</b> in all four interfaces), the compiler simply repeats the function address. One implementation of <b>AddRef</b> is called from an invocation of any base interface's <b>AddRef</b>.</p>
<p>
This makes implementing multiple interfaces ridiculously simple—we just derive <b>CDB</b> from all four interfaces and expand <b>QueryInterface</b> to return the correctly cast pointer. C++ takes care of the rest.</p>
<p>
This section definitely contains more new ideas than new code, and really understanding what it does will help you a lot in understanding the flexibility and power of COM.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;One of the major drawbacks of this approach to implementing multiple interfaces is that <i>you can’t provide reference counting on an interface basis</i>. More complex objects could need to load additional code or initialize additional data structures, when being asked for more complex functionality. With multiple inheritance, any call to <b>Release</b> goes to the same function. The object can not free the additional code/data, because it does not know which interface pointer was released. The big advantage of using multiple inheritance for this lies in its simplicity. All the dangers of normal C++ multiple inheritance, such as multiple common base classes, and so forth, do not really apply, because interfaces contain no data members.</p>
<h3>Practice</h3>
<p>
Inasmuch as we are not going to add a lot of code, but we will add three new interfaces, I will present a more elegant way of managing the interface IDs (in general, GUIDs). In the previous samples, the GUIDs were not defined in the Interface\dbsrv.h header file, because multiple "includes" of the header in a project would have resulted in multiple definitions of the GUIDs. There is a simple macro, defined through OLE2.H, that helps us provide the GUID in a header file: <b>DEFINE_GUID</b>. This macro expands in two different ways, depending on an INITGUID symbol. If this symbol is defined, it expands to a definition of the GUID. If it is not defined, it expands to a declaration of the GUID without initializing it.</p>
<p>
One source file must contain #define INITGUID before including DBSRV.H, in order to provide the definition of the symbol. This requires precompiled headers to be disabled for this source file, otherwise the compiler uses the precompiled header that includes the wrong macro expansion.</p>
<h3>Changes: Step by Step</h3>
<p>
Keep a copy of the unmodified client to test the backwards compatibility of the new object!
<ol>
<li>
Add definitions for <b>IDBAccess</b>, <b>IDBManage</b>, and <b>IDBInfo</b> to DBSRV.H.<br><br></li>
<li>
Declare IIDs using the <b>DEFINE_GUID</b> macro: Generate new IIDs with <b>GUIDGEN/UUIDGEN</b> or use one of your unused, pre-generated GUIDs.<br><br></li>
<li>
Derive <b>CDB</b> multiply from <b>IDB</b>, <b>IDBAccess</b>, <b>IDBManage</b>, and <b>IDBInfo</b> (in Object\dbsrvimp.h).<pre><code>class CDB : public IDB, public IDBAccess, public IDBManage, public IDBInfo {
(...)
};
</code></pre>
</li>
<li>
Change <b>CDB::QueryInterface</b> to allow for the new interfaces.<pre><code>HRESULT CDB::QueryInterface(REFIID riid, void** ppObject) {
if (riid==IID_IUnknown || riid==IID_IDB) {
*ppObject=(IDB*) this;
}

<b>else if (riid==IID_IDBAccess) {</b>

<b>*ppObject=(IDBAccess*) this;</b>

<b>}</b>

<b>else if (riid==IID_IDBManage) {</b>

<b>*ppObject=(IDBManage*) this;</b>

<b>}</b>

<b>else if (riid==IID_IDBInfo) {</b>

<b>*ppObject=(IDBInfo*) this;</b>

<b>}</b>

else {
return E_NOINTERFACE;
}
AddRef();
return NO_ERROR;
}
</code></pre>
</li>
<li>
Remove the old definition of the CLSID and the IID in object\dbsrv.cpp and object\dbsrvfact.cpp. Create a file called Interface\guids.cpp that #defines INITGUID, #includes ole2.h, and then #includes dbsrv.h. Add interface\guids.cpp to the project and deactivate precompiled headers for it.<br><br></li>
<li>
In the client, call <b>CreateInstance</b> with IID_IUnknown and change m_pDB to <b>IUnknown*</b>.<br><br></li>
<li>
In the client, before calling <b>Create</b>, <b>Read</b>, and <b>Write</b>, use <b>QueryInterface</b> on m_pDB to obtain the appropriate interface. <b>Release</b> the obtained interface pointer after using it.<br><br></li>
<li>
Add Interface\Guids.cpp to the project and deactivate precompiled headers for it. Remove the declaration of CLSID and IIDs from client\dbdoc.cpp</li>
</ol>
<p>
Test the new object: Register it using regsrv32.exe and run the client. Also, try running the client that used <b>IDB</b> (from the DBCOM sample). Since we still support this interface, this client continues to work.</p>
<p>
<b>QueryInterface</b> provides a great mechanism for maintaining backwards compatibility between versions of an object. It also provides a method for very flexible version checking. The client and the server do not check an abstract "version number" where both have to agree somehow what a specific version means in terms of functionality and interfaces. A client can check for each specific feature by asking for an interface through <b>QueryInterface</b>. A client could also ask first for a more sophisticated new interface, and if the object does not provide it, the client can ask for an "older" interface and provide a workaround. Using this mechanism you can provide interoperability between both a new client with an old server and an old client with a new server.</p>
<p>
This is why OLE 2.0 is not OLE 2.0 anymore. It is just OLE. New features do not require a totally new version, they are just added on top of the old ones and each user queries for the features it needs.</p>
<h2><a name="dbcomrem"></a>DBCOMREM: COM Object in a Separate Process</h2>
<p>
<OBJECT id=sample8 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4531">
</OBJECT><a href="javascript:sample8.Click()">Click to view or copy the files for the DBCOMREM sample application.</a></p>
<h3>Shipping and Handling of Function Calls</h3>
<p>
If this were all there were to COM, it would still be interesting, but not really allow for a "component software revolution." (See note.) You could build tremendously complex software using objects implemented in DLLs and use them from a client. But what if you wanted to share an object between different processes? Or if you did not want to load another object in your same address space for security and reliability reasons? Or what if you wanted to share an object between several machines, like a SQL Server Database?</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Other technologies, such as OpenDoc or SOM, actually stop here! Their underlying technology does not even provide a way for objects in different processes to communicate with each other: Their programming model for in-process and out-of-process objects is fundamentally different (SOM vs. DSOM), and their standardization is based on the in-process model! </p>
<p>
COM provides a very easy way to make objects in other processes (on the same machine, and soon on remote machines) appear as standard COM objects as we know them now. The underlying idea is to simply extend the idea of directing a function call through a vtable—you provide a special object that implements your interface in a special way. A function in this special object (called a <i>proxy</i> object) receives all the parameters, writes them sequentially into a buffer in memory, and sends the buffer to the other process. In the other process, another special object (called a <i>stub</i> object) receives this buffer, unpacks the parameters again, and calls the function that the caller meant to call in the first place. Then the return value(s) are packed into another buffer, sent back to the calling process, and the proxy unpacks the return value(s) and returns them to the caller.</p>
<p>
This sounds complicated—and actually is even a bit more complicated—but to both the client and the server, this whole process of packing, sending, and unpacking is completely transparent, except for the difference in speed, due to the context switch or the network message sent.</p>
<p>
All that an object has to supply is the code that actually packs and unpacks the parameters. COM takes care of shipping and handling—setting up the connections between proxy and stub, sending the packed parameters and return values. The marshalling code (as the proxy and stub are also called) is not provided on a per-object basis, but on a per-interface basis: The interface designer can provide the proxy and stub objects and everybody wanting to use this interface takes advantage of the remoting capability.</p>
<p>
We will provide a DLL that implements a COM object and takes care of this packing and unpacking (also called marshalling and unmarshalling). We will register this COM object like any other COM object under the HKEY_CLASSES_ROOT\CLSID registry key.</p>
<p>
In addition, we will tell COM that this specific object is able to marshall a specific interface by registering its CLSID under another key called HKEY_CLASSES_ROOT\Interfaces\{iid}. COM knows how to marshall <b>IUnknown</b>, and when asked for a different interface, it looks under this key, finds the CLSID of the object that handles marshalling, and starts using it. I will not go into detail on this here, since it is explained in great detail in Kraig Brockschmidt's <i>Inside OLE</i>.</p>
<p>
The object that does marshalling and unmarshalling is also called a proxy or stub. The part that pretends to be the object on the side of the client is called the proxy, and the part pretending to be the client on the side of the object is called the stub. The entry under HKEY_CLASSED_ROOT\Interfaces\{iid} is therefore called ProxyStubClsid32. There is another entry, NumMethods, that simply indicates the number of methods in this interface, including the three <b>IUnknown</b> methods.</p>
<p>
The generation of the proxy/stub object is actually trivial: The header file defining the interface needs to be enhanced to indicate more about the parameters than the C++ language provides, such as which parameters only go into the object, which parameters only go out (are actually return values), and which go in and out. Also, the length of buffers needs to be defined, and some other tedious details about pointers need to be added. For most simple parameters, the changes are actually straightforward, as we will see. This modified header file is not in C++ anymore—the language is called IDL, or Interface Definition Language.</p>
<p>
This IDL file is then passed to a compiler for this language, which generates C source code necessary to build the DLL.</p>
<h3>Exporting an Object from an Executable</h3>
<p>
There is now just one minor technical detail missing. How can COM call into an object that is implemented in an executable? EXEs do not provide callable entry points, so we cannot use the same approach as we did with a DLL using <b>DllGetClassObject</b>.</p>
<p>
The solution is relatively simple and spins around the class factory object: When initializing, the EXE simply calls an application programming interface (API) function in the COM libraries (<b>CoRegisterClassObject</b>) and passes it a pointer to <b>IUnknown</b> on a class factory object. COM saves this pointer in an internal table and uses it when clients want to create an object of this class. The only problem this creates in the object's code is that class factory objects are not supposed to keep an object running once a "real" object has been created and released. The object's code is not needed anymore, even if it still has its class factories registered with the COM libraries. Thus for global reference counting, references to the class factory object should not count. When the executable is finished, it revokes the class factory objects (<b>CoRevokeClassObject</b>), passing in an identifier that COM returned in <b>CoRegisterClassObject</b>.</p>
<p>
A COM object in an executable (also called a local server) is registered very similarly to an object in a DLL (in-proc server). The entry is called LocalServer32 and contains the path to the executable. Both entries can be present, allowing clients to choose which implementations they prefer.</p>
<p>
For the client, all this is completely transparent. It just calls <b>CoGetClassObject</b> (or <b>CoCreateInstance</b>). If it asks for just a server (CLSCTX_SERVER), COM first checks if there is an in-proc server registered, and if not, it checks for a local server. It then loads the local server by running the executable and waits for the executable to call <b>CoRegisterClassObject</b>. It then wraps the pointer with a special proxy/stub for <b>IUnknown</b> (class factory objects are always registered as <b>IUnknown</b> first) and returns the client a pointer to the proxy. From there on, COM uses the mechanisms briefly described above: When the client calls <b>QueryInterface</b>, COM loads another stub object on the server, lets it wrap the object's interface, connects the stub to a proxy that it loads on the client's side, and returns a pointer to the proxy to the client.</p>
<p>
The client never sees any of this; it just gets pointers to vtables, which it uses as before. The only time a client might be aware of an in-proc/remote difference is while creating the object: It can indicate to COM the context that it wants the object to run in—CLSCTX_LOCAL_SERVER, CLSCTX_INPROC_SERVER, or just CLSCTX_SERVER. There are some other flags, which I will not discuss here.</p>
<h3>Creating the Proxy/Stub Object</h3>
<p>
COM needs just a little bit of help to perform all these miracles: It needs an object that knows how to pack and unpack the specific parameters of an interface's functions.</p>
<p>
The tool that generates these helper objects is the MIDL compiler (Microsoft IDL compiler). We feed it with a simple IDL file, which is basically an extended C++-header file, and it returns a whole bunch of files:
<ul type=disc>
<li>
<b>Dlldata.c and xxx_p.c</b>—Files compiled into a DLL.<br><br></li>
<li>
<b>Xxx.h</b>—A C++ header file with the interface declaration. All IDL- extensions are either removed or commented out.<br><br></li>
<li>
<b>Xxx_i.c</b>—A file with the definitions of the interface IDs.</li>
</ul>
<p>
The header file and the file with the interface IDs will form part of the interface definition: They will be used by clients of the object and by the object itself.</p>
<p>
We will put the two other files into a new directory, \ProxyStub, where we will also create a project for the DLL, a module definition file, and an additional file with support for self-registration.</p>
<p>
The DLL will export one COM object that provides proxy/stubs for all four interfaces. The object provides methods that let COM query for the correct proxy/stub implementation (see <i>Inside OLE</i> for details). Thus, under one CLSID, COM finds the proxy/stubs for four interfaces. By default, the MIDL-generated code uses the interface ID of the first interface declared in the IDL file as the CLSID for the proxy/stub object. Look in RPCPROXY.H for instructions on changing the default and some other options.</p>
<p>
For the default proxy/stub, we will have to register the following keys:</p>
<pre><code>CLSID\{30DF3432-0266-11cf-BAA6-00AA003E0EED}="DB Sample ProxyStub" 
// This is the IID of IDB used as the CLSID of the proxy/stub for all 
// four interfaces.
CLSID\{30DF3432-0266-11cf-BAA6-00AA003E0EED}\InprocServer32=&lt;path&gt;\db.dll
Interface\{30DF3432-0266-11cf-BAA6-00AA003E0EED}="IDB"
Interface\{30DF3432-0266-11cf-BAA6-00AA003E0EED}\ProxyStubClsid32="
 &nbsp; {30DF3432-0266-11cf-BAA6-00AA003E0EED}"
Interface\{30DF3432-0266-11cf-BAA6-00AA003E0EED}\NumMethods = "10" 
Interface\{30DF3433-0266-11cf-BAA6-00AA003E0EED}="IDBAccess"
Interface\{30DF3433-0266-11cf-BAA6-00AA003E0EED}\ProxyStubClsid32="
 &nbsp; {30DF3432-0266-11cf-BAA6-00AA003E0EED}"
Interface\{30DF3433-0266-11cf-BAA6-00AA003E0EED}\NumMethods = "5" 
Interface\{30DF3434-0266-11cf-BAA6-00AA003E0EED}="IDBManage"
Interface\{30DF3434-0266-11cf-BAA6-00AA003E0EED}\ProxyStubClsid32="
 &nbsp; {30DF3432-0266-11cf-BAA6-00AA003E0EED}"
Interface\{30DF3434-0266-11cf-BAA6-00AA003E0EED}\NumMethods = "5" 
Interface\{30DF3435-0266-11cf-BAA6-00AA003E0EED}="IDBInfo"
Interface\{30DF3435-0266-11cf-BAA6-00AA003E0EED}\ProxyStubClsid32="
 &nbsp; {30DF3432-0266-11cf-BAA6-00AA003E0EED}"
Interface\{30DF3435-0266-11cf-BAA6-00AA003E0EED}\NumMethods = "6" 
</code></pre>
<p>
This looks like a lot of work, but the MIDL-generated code provides even implementations of <b>DllRegisterServer</b> and <b>DLLUnregisterServer</b>, if you compile (the C code) with the preprocessor symbol REGISTER_PROXY_DLL. For those of you who prefer to see how it is done, I also implemented a manual version of the registration functions.</p>
<h3>IDL</h3>
<p>
Some comments regarding the IDL file: We will need to include unknwn.idl in order to derive our interfaces from <b>IUnknown</b>. If you need to use windows types such as DWORD and others, you can also include wtypes.idl.</p>
<p>
Each interface is prefixed by a special header of the following structure:</p>
<pre><code>[object, uuid(606C3DE0-FCF4-11ce-BAA3-00AA003E0EED), pointer_default(unique)]
</code></pre>
<p>
This header instructs MIDL to generate a proxy/stub ("object"), tells it the IID ("uuid") and assumes pointers as unique (see the RPC reference for more information).</p>
<p>
MIDL does not accept parameters by reference. Since on the binary level references are just pointers, we can "cheat" the MIDL with some typedefs (refshort.idl; I copied this idea from wtypes.idl): For C we provide a pointer to short, for C++ we provide a reference to short. </p>
<p>
In order to receive string parameters ([out]), we will use a fixed buffer size, both to avoid having to free returned memory and to maintain "compatibility" with previous clients. This is indicated by an attribute [size_is(80)] to a string parameter. (See the RPC Reference for more information.)</p>
<h3>Changes: Step by Step</h3>
<h4>The Proxy/Stub</h4>
<ol>
<li>
Copy interface\bdsrv.h and save as interface\ibd.idl.<br><br></li>
<li>
Add [in], [out], and [size_is] flags, remove DECLARE_GUIDs, provide [object] headers for each interface.<br><br></li>
<li>
Create refshort.idl to provide C declarations for the short parameters.<br><br></li>
<li>
Import unknwn.idl and refshort.idl in idb.idl.<br><br></li>
<li>
Compile idb.idl with the following:<pre><code>midl ..\interface\idb.idl 
/header ..\interface\idb.h 
/iid ..\interface\idb_i.c /ms_ext /c_ext
</code></pre>
<p class=tl>
running it with a working directory \ProxyStub. This instructs the compiler to write the interface files in our interface directory.</P></li>
<li>
Compile refshort.idl with <code>midl ..\interface\refshort.idl /out ..\interface /ms_ext /c_ext</code>. This will provide refshort.h, which is included in the generated idb.h.<br><br></li>
<li>
Create a project for a plain DLL (idbps.mak) and include dlldata.cpp, idb_p.cpp, and interface\idb_i.c. Change idb_p.c to include ..\interface\idb.h instead of idb.h. (The MIDL compiler does not change the paths in the generated include files; you will have to apply this change anytime you recompile the IDL file.)<br><br></li>
<li>
Link with rpcrt4.lib to include the RPC run-time library used by the generated proxy/stub.<br><br></li>
<li>
Create a module definition file called idbps.def, add it to the project, and export <b>DllGetClassObject</b>, <b>DllCanUnloadNow</b>, <b>DllRegisterServer</b>, and <b>DllUnregisterServer</b>.<br><br></li>
<li>
Self-registration. You can either define a REGISTER_PROXY_DLL symbol in Preprocessor options or, if you do not want to use the self-registration provided by MIDL for whatever reason, you must create a file called idbpsref.cpp and implement <b>DllRegisterServer</b>/<b>DllUnregisterServer</b> (see above for the exact keys we need to register). You could also register your proxy/stub manually (or in a special installer, or with a simple .REG file), but it is much more in keeping with object-oriented philosophy to provide self-registration within the same DLL.<br><br></li>
<li>
Compile the DLL and register it using regsvr32.exe.<p class=tl>
We just expanded COM to handle our four custom interfaces for remote access. Note that I named all the files IDB, to indicate that they deal with the "database"-interfaces, and not the object implementing these interfaces.</P><p class=tl>
<b>The Object</b></P><p class=tl>
With the "expanded" COM, all we need to provide is an object implemented in an executable.</P></li>
<li>
Remove the IID definitions from dbsrv.h. They will be provided in IDB.H/IDB_C.C. Just leave the DEFINE_GUID for the CLSID of the object. Again, note that the proxy/stub is related to the interface, not to the database object itself. Any object that wants to use this custom interface will use the same proxy/stub. The proxy/stub is actually an extension of COM and not part of the object.<br><br></li>
<li>
Include idb.h.<br><br></li>
<li>
Create a new MFC Project called ObjectEXE\DBLocal.mak. Defaults: MDI, no support for anything OLE-related.<br><br></li>
<li>
Add #define _AFX_NO_BSTR_SUPPORT and #include ole2.h to stdafx.h. Define a preprocessor symbol, LOCALSERVER, which we will use for conditional compilation of dbsrv.cpp. Add targets for Unicode. Add OLE32.LIB and UUID.LIB libraries.<br><br></li>
<li>
Add Object\DBSRV.CPP and Object\DBSrvFact.CPP to the project. We will use a common code base for in-process and local servers. Also add interface\idb_i.c and interface\guids.cpp, and disable precompiled headers for both.<br><br></li>
<li>
In <b>CDBLocalApp::InitInstance</b> call <b>CoInitialize</b>; create a CDBFactory object and register it with <b>CoRegisterClassObject</b>. Also check for command-line parameters (/REGSERVER and /UNREGSERVER) and calls (<b>DllRegisterServer</b> or <b>DllUnregisterServer</b>) if appropriate. You could also have the object register itself all the time (except when executed with /UNREGSERVER).<pre><code>BOOL CDBLocalApp::InitInstance() {
if (m_lpCmdLine[0] != '\0')
{
if (lstrcmpi(m_lpCmdLine, "/REGSERVER")==0) {
if (FAILED(DllRegisterServer())) {
AfxMessageBox("Unable to register the server!");
}
return FALSE;
}
else if (lstrcmpi(m_lpCmdLine, "/UNREGSERVER")==0) {
if (FAILED(DllUnregisterServer())) {
AfxMessageBox("Unable to unregister the server!");
}
return FALSE;
}
}
DllRegisterServer();
CoInitialize(NULL);
CDBFactory *pFactory=new CDBFactory();
pFactory-&gt;AddRef();
if (FAILED(CoRegisterClassObject(CLSID_DBSAMPLE, (IUnknown*) pFactory, 
CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE, 
&amp;m_dwDBFactory))) {
pFactory-&gt;Release();
return FALSE;
}
pFactory-&gt;Release(); // COM keeps a reference to the class factory.
(...)
}
</code></pre>
</li>
<li>
Add <b>CDBLocalApp::ExitInstance</b> and revoke the class factory object (<b>CoRevokeClassObject</b>). Then call <b>CoUninitialize()</b>.<pre><code>int CDBLocalApp::ExitInstance() {
if (m_dwDBFactory) {
CoRevokeClassObject(m_dwDBFactory);
m_dwDBFactory=0;
}&nbsp;&nbsp; 
return CWinApp::ExitInstance();
}
</code></pre>
</li>
<li>
Declare <b>CDBLocalApp::m_dwDBFactory</b> and initialize it to 0 in the constructor. This data member saves the identifier that COM returns when registering the class factory object. Include ...\object\dbsrvimp.h in DBLocal.cpp. Remove the call to <b>OnFileNew</b>, because we will associate a document with each server object created.<br><br></li>
<li>
Change <b>DllRegisterServer</b>/<b>UnregisterServer</b> to write the name of the EXE in LocalServer32 instead of the name of the DLL in InprocServer32. (Use #ifdef LOCALSERVER to keep a common code base for local and in-process server!)<br><br></li>
<li>
<b>CDBFactory::AddRef</b> and <b>Release</b> should not modify g_dwRefCount for a LOCALSERVER.<br><br></li>
<li>
For a LOCALSERVER: <b>CDBRelease()</b> should check g_dwRefCount and close the EXE if it is no longer used. <pre><code>ULONG CDB::Release() {
g_dwRefCount--;
m_dwRefCount--;
if (m_dwRefCount==0) {
#ifdef LOCALSERVER
if (g_dwRefCount==0) {
AfxGetMainWnd()-&gt;PostMessage(WM_CLOSE);
}
#endif
delete this;
return 0;
}
return m_dwRefCount;
}
</code></pre>
<p class=tl>
The following steps are optional. The procedure creates a document whenever a database object is created, and closes the document when a database object is released. Note that this implementation is not thread safe—you would need to synchronize object creation.</P></li>
<li>
Add a member <b>CDBLocalApp::m_pLastDoc</b>, set it to NULL in the constructor, and set its value to the this pointer in the constructor of <b>CDBLocalDoc</b>.<br><br></li>
<li>
In <b>CDB::CDB</b> create a new document and keep a pointer to it (#ifdef LOCALSERVER): Declare <b>CDB</b> as a friend of <b>CDBLocalApp</b>, call <b>CDBLocalApp::OnFileNew</b>, obtain m_pLastDoc and save it in a data member <b>CDB::m_pDoc</b>. Don't forget to include dblocal.h.<br><br></li>
<li>
In <b>CDB:~CDB</b> close the document m_pDoc.<br><br></li>
<li>
Declare CDB::m_pDoc (#ifdef!) and DllRegisterServer/DllUnregisterServer in dbsrv.h.<br><br></li>
<li>
Optional: It is a good idea to make the object thread-safe. This is not required for remoting, because OLE's default uses only a single thread. It is easy to make your object thread-safe and be prepared for OLE's multithreading models (see the SDK for details).<p class=tl>
If multiple functions are executed "simultaneously," we must guarantee that all our code is prepared for this by (a) making it reentrant, and (b) synchronizing access to global memory. Reentrancy is easy—most variables are local variables on the stack and are allocated exclusively for each thread executing a function. In our sample, all we have to worry about is the reference counters—both the global and the object counter—and the "database" structures. We will secure our <b>AddRef</b> and <b>Release</b> by using the Win32 API functions <b>InterlockedIncrement</b> and <b>InterlockedDecrement</b>. The structures use MFC classes that are thread-safe already for threads accessing different objects. We must protect each object instance against multiple use with a critical section per object.</P><p class=tl>
Here is the thread-safe implementation of <b>IUnknown</b> in dbsrv.cpp (analog in dbsrvfact.cpp):</P><pre><code>(...)
ULONG CDB::AddRef() {
InterlockedIncrement((long*) &amp;g_dwRefCount);
InterlockedIncrement((long*) &amp;m_dwRefCount);
return m_dwRefCount;
}
ULONG CDB::Release() {
ULONG dwRefCount=m_dwRefCount-1;
ULONG dwGlobalCount=InterlockedDecrement((long*) &amp;g_dwRefCount);
if (InterlockedDecrement((long*) &amp;m_dwRefCount)==0) {
#ifdef LOCALSERVER
if (dwGlobalCount==0) {
AfxGetMainWnd()-&gt;PostMessage(WM_CLOSE);
}
#endif
delete this;
return 0;
}
return dwRefCount;
}
</code></pre>
<p class=tl>
Making the object itself thread-safe: Declare a critical section in CDB:</P><pre><code>class CDB : public IDB, public IDBAccess, public IDBManage, public IDBInfo {
(...)
// Implementation
private:
(...)
ULONG m_dwRefCount;

<b>CRITICAL_SECTION m_secDB;</b>

(...)
};
</code></pre>
<p class=tl>
The implementation in dbsrv.cpp: Use the critical section.</P><pre><code>HRESULT CDB::Read(short nTable, short nRow, LPWSTR lpszData) {

<b>EnterCriticalSection(&amp;m_secDB);</b>

(...)

<b>LeaveCriticalSection(&amp;m_secDB);</b>

return NO_ERROR;
}
(...)
CDB::~CDB() {

<b>EnterCriticalSection(&amp;m_secDB);</b>

short nNumTables;
for (GetNumTables(nNumTables);nNumTables&gt;0; GetNumTables(nNumTables)) {
Delete(nNumTables-1);
}
#ifdef LOCALSERVER
m_pDoc-&gt;OnCloseDocument();
m_pDoc=NULL;
#endif

<b>LeaveCriticalSection(&amp;m_secDB);</b>

<b>DeleteCriticalSection(&amp;m_secDB);</b>

}
CDB::CDB() {

<b>InitializeCriticalSection(&amp;m_secDB);</b>

m_dwRefCount=0;
#ifdef LOCALSERVER
((CDBLocalApp*) AfxGetApp())-&gt;OnFileNew();
m_pDoc=((CDBLocalApp*) AfxGetApp())-&gt;m_pLastDoc;
#endif
}
</code></pre>
<p class=tl>
Compile the local server. If you want, also compile the in-process server, to validate your "common code base" (you'll need to add idb_c.c for the IIDs!).</P><p class=tl>
<b>The Client</b></P><p class=tl>
The clients DBCOM and DBCOMMUL work without change! You just have to unregister the in-process server, register the local server, and COM does the rest.</P><p class=tl>
We will make a minor change to allow the user to choose between in-process and local server. In a real-world application this is a design decision, but for the purpose of this section we provide a "user-interface":</P></li>
<li>
Before creating an object, show a message box and let the user choose. Use CLSCTX_LOCAL_SERVER to force a local server, if both server types are registered. Use CLSCTX_SERVER to use an in-process server if present, and default to a local server.<pre><code>(...)
if (AfxMessageBox(_T("Do you want a local server?"), MB_YESNO)==IDYES) {
hRes=CoGetClassObject(CLSID_DBSAMPLE, CLSCTX_LOCAL_SERVER, NULL,
IID_IClassFactory, (LPVOID*) &amp;pDBFactory);
}
else {
hRes=CoGetClassObject(CLSID_DBSAMPLE, CLSCTX_SERVER, NULL, 
IID_IClassFactory, (LPVOID*) &amp;pDBFactory);
}
(...)
</code></pre>
</li>
<li>
Add idb_c.c to the project for the IIDs (we removed them from dbsrv.h!).</li>
</ol>
<p>
COM provides a completely transparent model for in-process and out-of-process objects. The same object code can be used as a high-performance/low-security in-process object or as a network-speed/high-security out-of-process object. The client does not see any difference in using an in-process or out-of-process object. Our client from the DBCOM sample works transparently with a server implemented in another process!</p>
<h2><a name="conclude"></a>Conclusion</h2>
<p>
As you have seen, it does not really take a lot to implement and use objects based on the programming model introduced by COM. The techniques are very valuable on their own, even if you do not intend to use the COM Libraries for whatever (strange!) reason.</p>
<p>
Taking advantage of COM allows you to:
<ul type=disc>
<li>
Package your objects in a uniform way as executables or dynamic-link libraries.<br><br></li>
<li>
Break your application into really reusable components, ones that you can redistribute easily to others.<br><br></li>
<li>
Be prepared to distribute your components on multiple machines, through a simple change in configuration. As COM is being ported to other platforms, you can take even take advantage of real, standardized, efficient interoperability between different platforms.</li>
</ul>
<p>
Some general tips for implementing your objects using COM:
<ul type=disc>
<li>
Before implementing a custom interface, look for interfaces that COM and/or OLE provide already. A wide variety of functionality is already covered by these interfaces. Your advantages are multiple:<ul type=disc>
<li>
You can take advantage of the remoting code provided for these interfaces. <br><br></li>
<li>
Chances are high that other standard clients—ones that you may not have thought of—will be able to use at least part of the functionality of your object, just because they know how to use a COM/OLE-provided interface.<br><br></li>
<li>
COM provides—for free!—additional functionality related to some interfaces through standard implementations.</li>
</ul>
</li>
<li>
When you design your interfaces, try to make them as general as possible, so that either you or others will be able to take advantage of them in the future. Publish your interfaces as widely as possible; if you can make them a standard, they will be no different from any Microsoft-provided interface, because they merge into the extensible COM architecture.</li>
</ul>
<p>
Making an object "COM compliant" requires a very low overhead, in terms of both implementation cost and overhead incurred.</p>
<p>
To implement a COM object, simply reuse all the "adorning" code, such as class factory objects, <b>IUnknown</b> implementation, Registration code (you could even make it a macro or a C++ template), and start implementing your object's functionality!</p>
<p>
Overhead in memory is very small: You basically have a 4- byte overhead per interface (the vtable pointers in the object's instance data) plus 4 bytes for the reference counter. Even the smallest object can live with this overhead (8 bytes), and you get all the advantages of making it a COM component.</p>
<p>
Performance overhead in the in-process case can be beaten only by direct function calls, but the overhead is irrelevant for any real-world use. In the local case, you basically have to implement your own remoting infrastructure, either on top of RPC (like COM) or through windows messages, shared memory, and semaphores, or whatever you wish. You could probably be a little more efficient if you optimized your implementation for your kind of interface and interface usage. But usually COM's performance will be more than sufficient and will save you a lot of work!</p>
<p>
Just spend some time thinking about which of your objects or libraries you could implement as COM objects. Which would be in-process servers, which could be local servers? How would your overall design gain, if you could use local servers?</p>
<p>
COM can make your life a lot easier today, and prepares you for a very exciting future!</p>
<h2><a name="biblio"></a>Bibliography</h2>
<p>
Brockschmidt, Kraig. <i>Inside OLE</i>, 2nd edition. Redmond, WA: Microsoft Press, 1995. (MSDN Library, Books)</p>
<p>
Germond, Tom; Jan Gray; and Dale E. Rogerson. "Object Mapping in C++." (MSDN Library Archive, Technical Articles, C/C++ Articles)</p>
<p>
Rogerson, Dale E. "Exporting with Class." (MSDN Library Archive, Technical Articles, C/C++ Articles)</p>
<p>
<i>RPC Programmer's Guide and Reference.</i></p>
</BODY>
</HTML>
