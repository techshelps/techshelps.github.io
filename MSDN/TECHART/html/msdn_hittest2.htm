<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Win32: Hit Testing Lines and Curves</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_hittest2"></a></sup>Win32: Hit Testing Lines and Curves</h1>
<p>
Dennis Crain<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: February 8, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="2103">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the W32HIT sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
Useful graphics applications, such as CAD or drawing programs, permit the user to select and manipulate graphics objects. This article describes three methods for detecting if the user has selected a line or a curve.</p>
<p>
The first method is used to hit test lines. It uses two-dimensional vector techniques that resolve the vector components of the line and the point at which the user clicked the mouse. These vector methods are described in detail in the <a href="msdn_vector.htm">"Use of Two-Dimensional Vectors with Windows NT"</a> technical article in the Microsoft® Development Library.</p>
<p>
The second method illustrates how to hit test Bézier curves using one of two techniques. The first technique involves calculating the points of the Bézier curve. The distance from the mouse click to the nearest point of the Bézier curve determines if the line was successfully hit. The second technique illustrates the use of paths in Win32®. Bézier curves or arcs are drawn into a path, which is flattened to produce an array of points that describes line segments. These line segments are then tested using the vector method to detect line hit testing. An accompanying sample program, W32HIT, demonstrates these methods. W32HIT is a modification of the W32PEN sample that accompanies the <a href="msdn_w32pens.htm">"Pens in Win32"</a> article in the Development Library.</p>
<h2>What Is Hit Testing?</h2>
<p>
To the user, the act of hit testing in a graphical user interface seems natural. The pointing device's cursor is placed over an object, and the user initiates an action to "hit" the object. Most often this pointing device is a mouse, and the action is a mouse click.</p>
<p>
Within the context of this article, let's agree that hit testing is the process of determining if the user has selected a line or a curve by means of a mouse click. I will describe three methods for selecting these objects. Two methods are general in that they do not rely on any of the functionality of Win32®. The third method combines the line hit-testing method with a new feature of Win32, paths.</p>
<p>
Many programmers know hit testing as "picking," the term used in many textbooks on graphics and in many graphics languages. For example, you pick a line segment on the screen and move it to another location.</p>
<h2>Action, Reaction</h2>
<p>
The methods described in this article hinge on a single user-initiated event. The user has placed the mouse cursor over a line or a curve and has clicked a mouse button, indicating that the object is to be selected. The challenge then is to ensure that the application will detect and act on this intent. What goes on after this detection takes place is up to the application. The application often considers the line or curve as a "selected object." This object may then be acted on in some fashion, such as moving it to a different location or changing its attributes (such as line style or width). The sample code provided with this article does two things: First, it indicates that the object has been selected by redrawing the object using the inverse of the current pen color. Second, it displays a dialog box that permits the user to change the attributes of the object, such as the pen attributes and object type (straight line, curve, or arc).</p>
<h2>Hit Testing Lines</h2>
<p>
In this scenario, the user is attempting to select a previously drawn line. There are many methods for detecting the presence of a point (the mouse click) on or near a line. The simplest but least accurate test is to detect if the point is within the rectangular area bounding the line. This works great if the line is horizontal or vertical, but it is obviously less useful for lines that are not parallel to the x or y axes. However, by using the bounding rectangle you can quickly determine if you should continue using this method or switch to a different, more accurate method to determine the distance of the point to the line. It is possible to use various algebraic methods involving the angle between the lines formed by one endpoint of the line, the point at the mouse click, and the second endpoint of the original line. However, having to deal with angles can be somewhat time consuming (unless you have a lookup table). A more reasonable approach might involve comparing the slopes of the two lines. As we will see, this approach also has some problems.</p>
<h3>Comparing the Slopes of the Lines</h3>
<p>
Figures 1 and 2 illustrate this concept. In Figure 1, the slope of the line from (x0, y0) to (x1, y1) is not the same as the line from (x0, y0) to (x2, y2). In Figure 2, the slope of these lines is the same. But is it reasonable to assume that, by simply comparing the slopes, in all cases it's safe to say that a point is on the line if the slopes are equal? To say yes to this, some boundary checking needs to take place before comparing the slopes. Again, this is where the bounding rectangle is useful. In the case of Figure 1, the point (x1, y1) lies outside the bounding rectangle. This can easily be checked by using the <b>PtInRect</b> function, which is found in all versions of Microsoft® Windows™. Because the point is not within the bounding rectangle, there is no need to compare the two slopes.</p>
<p>
<img src="hittest2_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Slopes of lines are not equal</b></p>
<p>
In Figure 2, the point (x1, y1) is obviously within the bounding rectangle. Comparing the slopes of the two lines makes sense in this case.</p>
<p>
<img src="hittest2_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Slopes of lines are equal</b></p>
<p>
The calculation of the slope of a line is likely stamped in our brains from our grade school days. Recall that the slope of the line between two points (x0, y0) and (x1, y1) is as follows:</p>
<p>
<img src="hittest2_3.gif" border=0></p>
<p>
This approach will work—sometimes. But there are some problems. If the comparison is based on equality, you might as well forget it. Your user may click on the line until he or she is blue in the face. Remember, this is a raster output device. The resolution of your slope calculations may not coincide with the pixels that are turned on. Okay, so try comparing it to a range of slopes. Create two lines on either side of the point of the mouse click (not inclusive of the point). Figure 3 illustrates this concept. This will minimize error, but you are left to find the points perpendicular to the line at any given slope of the original line, and you double your calculations. In addition, it is really dependent on points. The use of points tends to constrain one to a specific coordinate system. Although there are ways to work around all of this, it is probably easier to address the issue with vectors.</p>
<p>
<img src="hittest2_4.gif" border=0></p>
<p class=label>
<b>Figure 3. Using a range of slopes</b></p>
<h3>Using Vectors to Find the Distance from a Point to a Line</h3>
<p>
One of the challenges of the previous solution involves finding points at an equal distance from the mouse click and perpendicular to the line. Call it coincidence, but the perpendicular line just happens to be a normal vector. So why not take the normal vector and the magnitude of that vector to achieve a solution? As it turns out, it works—and it is accurate and reliable. The technique for finding the distance from a point to a line involves resolving the vector between one of the endpoints of the line and the point at which the mouse click occurred into its components. Figure 4 illustrates the two vectors involved. Vector <b><i>a</i></b> is the vector from the left endpoint of the line to the mouse click. Vector <b><i>b</i></b> is the vector between the two endpoints of the line.</p>
<p>
<img src="hittest2_5.gif" border=0></p>
<p class=label>
<b>Figure 4. Vectors between points of line and mouse click</b></p>
<p>
Figure 5 shows how vector <b><i>a</i></b> is projected onto vector <b><i>b</i></b>. The components of the newly projected vector are shown as well. Notice that the length of the normal (perpendicular to the line) vector is the distance from the mouse click to the line.</p>
<p>
<img src="hittest2_6.gif" border=0></p>
<p class=label>
<b>Figure 5. Components of a vector</b></p>
<h4>Finding the components of a vector</h4>
<p>
To find the length of vector <b><i>e</i></b> in Figure 5, you need to find the components of vector <b><i>c</i></b>, which is vector <b><i>a</i></b> projected onto vector <b><i>b</i></b>. The following code illustrates the process of finding the length of the vector normal to the line.</p>
<pre><code>typedef struct tagVECTOR2D&nbsp; {
  double&nbsp;&nbsp;&nbsp;&nbsp; x;
  double&nbsp;&nbsp;&nbsp;&nbsp; y;
} VECTOR2D, *PVECTOR2D;

double vGetLengthOfNormal(PVECTOR2D a, PVECTOR2D b)
{
  VECTOR2D c, vNormal;
  //
  //Obtain projection vector.
  //
  //c = ((a * b)/(|b|^2))*b
  //
  c.x = b-&gt;x * (vDotProduct(a, b)/vDotProduct(b, b));
  c.y = b-&gt;y * (vDotProduct(a, b)/vDotProduct(b, b));
//
  //Obtain perpendicular projection : e = a - c
  //
  vSubtractVectors(a, &amp;c, &amp;vNormal);
  //
  //Fill PROJECTION structure with appropriate values.
  //
  return (vVectorMagnitude(&amp;vNormal));
}
</code></pre>
<p>
This code calls three functions: <b>vDotProduct</b>, <b>vSubtractVectors</b>, and <b>vVectorMagnitude</b>. The <i>dot product</i> of two vectors is the sum of the products of the components of the vectors. The dot product for the vectors <b><i>a</i></b> and <b><i>b</i></b> is <b><i>a</i></b>1 * <b><i>a</i></b>2 + <b><i>b</i></b>1 * <b><i>b</i></b>2. Given the sample vectors (4, 5) and (2, 3), the dot product is 4 * 2 + 5 * 3, or 23. This may be implemented as follows:</p>
<pre><code>double vDotProduct(PVECTOR2D v0, PVECTOR2D v1)
{
  double dotprod;

  dotprod = (v0 == NULL || v1 == NULL) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? 0.0 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (v0-&gt;x * v1-&gt;x) + (v0-&gt;y * v1-&gt;y);

  return(dotprod);
}
</code></pre>
<p>
Subtraction of vectors is straightforward. The corresponding elements of the vectors are simply subtracted, as the following code illustrates.</p>
<pre><code>PVECTOR2D vSubtractVectors(PVECTOR2D v0, PVECTOR2D v1, PVECTOR2D v)
{
  if (v0 == NULL || v1 == NULL)
 &nbsp;&nbsp; v = (PVECTOR2D)NULL;
  else
  {
 &nbsp;&nbsp; v-&gt;x = v0-&gt;x - v1-&gt;x;
 &nbsp;&nbsp; v-&gt;y = v0-&gt;y - v1-&gt;y;
  }
  return(v);
}
</code></pre>
<p>
The length or magnitude of a vector is the distance from the head of the vector to the tail of the vector. Distance is the operative word here. Remember the Pythagorean theorem? It asserts that the distance between two points can be obtained by the formula:</p>
<p>
<img src="hittest2_7.gif" border=0></p>
<p>
If you have doubts, take a look at a math textbook. Because the components of a two-dimensional vector are the differences between two points, this formula can be restated as follows, given the vector <b><i>a</i></b>:</p>
<p>
<img src="hittest2_8.gif" border=0></p>
<p>
This relationship is easily implemented in the following code.</p>
<pre><code>double vVectorMagnitude(PVECTOR2D v0)
{
  double dMagnitude;

  if (v0 == NULL)
 &nbsp;&nbsp; dMagnitude = 0.0;
  else
 &nbsp;&nbsp; dMagnitude = sqrt(vVectorSquared(v0));
  return (dMagnitude);
}
</code></pre>
<h4>Using VECTOR2D.DLL</h4>
<p>
The following code demonstrates the use of VECTOR2D.DLL and an exported function called <b>vDistFromPointToLine</b>. This function basically does all of what I described earlier in the <b>vGetLengthOfNormal</b> function. The "Use of Two-Dimensional Vectors with Windows NT" technical article in the Microsoft Development Library describes this dynamic-link library (DLL) in detail. The <b>HitTestLine</b> function creates two vectors from the line to be hit tested, and a combination of the left endpoint of the line and the point at which the mouse was clicked. <b>vDistFromPointToLine</b> is then called. This function projects the mouse vector onto the line and resolves it into its components as outlined above. I've removed error and line boundary checking from this code fragment for readability.</p>
<pre><code>//Macro to convert mouse points (short) to points (long).
#define MPOINT2POINT(mpt, pt)&nbsp;&nbsp; ((pt).x = (mpt).x, (pt).y = (mpt).y)
//Macro to convert two points to a 2-D vector.
#define POINTS2VECTOR2D(pt0, pt1, vect) \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((vect).x = (double)((pt1).x - (pt0).x), \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (vect).y = (double)((pt1).y - (pt0).y))

BOOL HitTestLine(POINT pt0, POINT pt1, POINTS ptMouse, int nWidth)
{
  POINT PtM;
  VECTOR2D tt0, tt1;
  double dist;
  int nHalfWidth;
  //
  //Get the half width of the line to adjust for hit testing of wide lines.
  //
  nHalfWidth = (nWidth/2 &lt; 1) ? 1 : nWidth/2;
  //
  //Convert the line into a vector using the two endpoints.
  //
  POINTS2VECTOR2D(pt0, pt1, tt0);
  //
  //Convert the mouse points (short) into a POINT structure (long).
  //
  MPOINT2POINT(ptMouse ,PtM);
  //
  //Convert the line from the left endpoint to the mouse point into a vector.
  //
  POINTS2VECTOR2D(pt0, PtM, tt1);
  //
  //Obtain the distance of the point from the line.
  //
  dist = vDistFromPointToLine(&amp;pt0, &amp;pt1, &amp;PtM);
  //
  //Return TRUE if the distance of the point from the line is within the width 
  //of the line
  //
  return (dist &gt;= -nHalfWidth &amp;&amp; dist &lt;= nHalfWidth);
}
</code></pre>
<p>
That's all there is to it! Once you determine that you hit the line, you can do anything you want. Applications most often set the status of the line as "selected"; then the user decides what happens to the line. As I mentioned previously, the sample provided with this article, W32HIT, does two things: First, it indicates that the object has been selected by redrawing the object using the inverse of the current pen color. Second, it displays a dialog box that permits the user to change the attributes of the object, such as the pen attributes and object type (straight line, curve, or arc).</p>
<h2>Hit Testing Bézier Curves</h2>
<p>
Hit testing a Bézier curve presents a challenge. If you use the Bézier functions of Win32, the points used to draw the line are not immediately available to you. Consider the Win32 <b>PolyBezier</b> function. This function takes as a parameter a pointer to an array of <b>POINT</b> structures that contain the endpoints and control points of the spline(s). Do not mistake these control points for the actual points used to draw the curve. Figure 6 illustrates a Bézier curve and the control points used to determine the shape of the curve. The control polygon (not to be confused with the convex hull) is simply the polygon formed by the control points. It should be clear that the points on the curve itself are not specified. The <b>PolyBezier</b> function is responsible for generating the points that lie on the curve. You may recall that the Bézier curves may be generated as a special case of B-spline curves (if you don't recall this, I recommend that you take a look at one of the many textbooks available on the subject). Win32 implements Bézier curves as cubic B-splines. There is much more to the subject of Bézier curves than this simple explanation—the point I am making is that these four points, in and of themselves, are not sufficient to determine if a mouse click is on the line generated by a Bézier curve.</p>
<p>
<img src="hittest2_9.gif" border=0></p>
<p class=label>
<b>Figure 6. Bézier curve and associated control points and control polygon</b></p>
<h3>Determining the Points of a Bézier curve</h3>
<p>
So just how do you go about determining the points used to draw the curve? In Win32, you have two choices: You can either calculate the points yourself or use the path functions new to Win32. Once you come up with the points, you then need to determine whether the point at which the mouse click occurred is on the curve.</p>
<h4>Calculating the points</h4>
<p>
Calculating the points of a Bézier curve is not complex, but it does lend itself to a long-winded exegesis. So, if you don't already understand how to do this, I offer this intuitive explanation: Bézier curves can be subdivided into smaller curves to the point at which the control polygon of those smaller curves is flat. When this condition exists, the curve segment can be drawn as a straight line. Arriving at this, you have two control points that are very close to one another. You can find points on the line by means of linear interpolation, or just test the distance of a point from the line, as was done above.</p>
<p>
This subdivision works best if done recursively. To do this, you need to write your own recursive subdivision function and a function to determine if the control polygon is flat. Or you can use the code provided in the W32HIT sample. I ported code from the public domain à la the book <i>Graphics Gems</i>. This code determines the nearest point on a curve to a test point.</p>
<h4>The Win32 way</h4>
<p>
Win32 provides a convenient method for obtaining the line segments used to produce curves. Using paths and the associated application programming interfaces (APIs), you can draw curves and subsequently flatten them to produce the line segments. The problem of hit testing is then reduced to testing if a mouse click was on one of the line segments. The following code fragment demonstrates this.</p>
<pre><code>//
//This structure is referred to in the following code fragment as pTempPR.
//
typedef struct tagPENRECORD&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwPenType;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; POINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PtsToDraw[NUMPOINTS];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwPenStyle;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwJoinStyle;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwEndCapStyle;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwWidth;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGBRUSH&nbsp;&nbsp; lb;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XFORM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xf;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPickPriority;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwLineType;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwFlags;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp;&nbsp; tagPENRECORD *next;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp;&nbsp; tagPENRECORD *prev;
} PENRECORD, *PPENRECORD, FAR *LPPENRECORD; 
//
//Begin the path.
//
if (BeginPath(hdc))
{
  //
  //Draw a Bézier curve into the path.
  //
  PolyBezier(hdc, (LPPOINT)pTempPR-&gt;PtsToDraw, NUMPOINTS);
  //
  //Select the path into the DC.
  //
  if (EndPath(hdc))
  {
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //Flatten the path to produce a list of the line segments used to produce 
 &nbsp;&nbsp; //the curve.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (FlattenPath(hdc))
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; //Get the number of vertices contained in the list of line segments.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; nNumPoints = GetPath(hdc, (LPPOINT)NULL, (LPBYTE)NULL, 0);
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //If the call was successful then the number of points is known and &gt; 0.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (nNumPoints &gt; 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; //Allocate memory for the list of path vertices and vertex types.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; lpPt = (LPPOINT)malloc((DWORD)(sizeof(POINT) * nNumPoints));
 &nbsp;&nbsp;&nbsp;&nbsp; lpB&nbsp; = (LPBYTE)malloc((DWORD)(sizeof(BYTE) * nNumPoints));
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; //Go and really get them this time.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; nNumPoints = GetPath(hdc, lpPt, lpB, nNumPoints);
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; //Move through the list and test if the mouse click happened on any of the
 &nbsp;&nbsp;&nbsp;&nbsp; //line segments.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; for (nPt = 0; nPt &lt; nNumPoints - 1; nPt++)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Is the point on the line?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HitTestLine(lpPt[nPt], lpPt[nPt + 1], ptMouse, pTempPR-&gt;dwWidth))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBeep(0);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; free(lpPt);
 &nbsp;&nbsp;&nbsp;&nbsp; free(lpB);
 &nbsp;&nbsp; }
  }
}
</code></pre>
<p>
The call to <b>BeginPath</b> is the first part of what is called a <i>path bracket</i>. Once you call <b>BeginPath</b>, you can specify the points in the path by calling one or more of the functions that can be used with paths, as shown in Table 1.</p>
<p class=label>
<b>Table 1&nbsp; Functions That Can Be Used with Paths</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=33%>AngleArc</td>
<td width=31%>LineTo</td>
<td width=36%>Polyline </td>
</tr>
<tr valign=top>
<td width=33%>Arc</td>
<td width=31%>MoveToEx</td>
<td width=36%>PolylineTo </td>
</tr>
<tr valign=top>
<td width=33%>ArcTo</td>
<td width=31%>Pie</td>
<td width=36%>PolyPolygon </td>
</tr>
<tr valign=top>
<td width=33%>Chord</td>
<td width=31%>PolyBezier</td>
<td width=36%>PolyPolyline </td>
</tr>
<tr valign=top>
<td width=33%>CloseFigure</td>
<td width=31%>PolyBezierTo</td>
<td width=36%>Rectangle </td>
</tr>
<tr valign=top>
<td width=33%>Ellipse</td>
<td width=31%>PolyDraw</td>
<td width=36%>RoundRect </td>
</tr>
<tr valign=top>
<td width=33%>ExtTextOut</td>
<td width=31%>Polygon</td>
<td width=36%>TextOut</td>
</tr>
</table><br>
<p>
In the above code, a call to <b>PolyBezier</b> is made into the path. The call to <b>EndPath</b> selects the path into the device context. The <b>FlattenPath</b> function transforms any curves in the selected path into a sequence of lines. Finally, the code retrieves the coordinates of the line segments by calling the <b>GetPath</b> function.</p>
<h2>Hit Testing Curves Other Than Bézier</h2>
<p>
The most convenient technique for hit testing curves other than Bézier curves is the path method described above. However, remember that this technique is restricted to those functions that can be used with paths as listed in Table 1, and it only works in Win32.</p>
<h2>Using the Sample Application: W32HIT</h2>
<p>
The sample application, W32HIT, demonstrates the methods described in this article. The application should look familiar to those who have seen the W32PEN application, also included in the Development Library. However, there are differences. W32HIT adds new functionality to W32PEN. Support for Bézier curves and arcs is included (W32PEN provided only polyline support). Hit testing is included; the hit-testing methods are the same as those described above. The user interface changed slightly; an extra menu item was added that permits the user to select one of two methods for hit testing Bézier curves (calculating the points or using paths). Hit testing of lines uses the vector method; hit testing of arcs uses the path method.</p>
<p>
To draw a line or curve in the workspace of W32HIT, press the left mouse button while the mouse cursor is over the workspace (denoted by the presence of the left-slanted pen cursor). This brings up the pen and line selection dialog box as shown in Figure 7.</p>
<p>
<img src="hittest2_10.gif" border=0></p>
<p class=label>
<b>Figure 7. Pen and line selection dialog box</b></p>
<p>
To hit test a line, place the mouse cursor over the line and press the left mouse button as shown in Figure 8. If you have hit the line, it will be redrawn using the inverse of the pen color. Then the dialog box in Figure 7 will appear. You can change any of the attributes of the pen and line/curve at that time.</p>
<p>
<img src="hittest2_11.gif" border=0></p>
<p class=label>
<b>Figure 8. Place cursor over line and press left mouse button</b></p>
<h2>Summary</h2>
<p>
Hit testing lines and curves is basic to a good drawing program. Even so, it is not immediately clear how you should go about implementing this in applications. I have described three methods you can use. The first method illustrated the use of vectors for hit testing lines. The second method used a recursive subdivision of a Bézier curve to generate the points of the curve. The third method discussed the use of paths. These paths were flattened and the subsequent lines were hit tested using the vector method. A note of caution, though—paths are restricted to Win32. If you are hit testing outside this environment, you will need to generate the points for hit testing curves.</p>
</BODY>
</HTML>
