<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Processing Queries and Results</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Processing Queries and Results</h1>
<h3>General Good Practices</h3>
<p>
The following sections discuss general practices that will increase the performance of SQL&nbsp;Server ODBC applications. Many of the concepts apply to database applications in general.</p>
<h4>Columns in a Result Set</h4>
<p>
Applications should select only the columns needed to perform the task at hand. Not only does this reduce the amount of data sent across the network, it also reduces the impact of database changes on the application. If an application does not reference a column from a table, then the application is not affected by any changes made to that column.</p>
<h4>Stored Procedures</h4>
<p>
Sites can realize performance gains by coding most of their SQL statements into stored procedures and having applications call the stored procedures rather than issuing the SQL statements themselves. This offers the following benefits:
<ul type=disc>
<li>
Higher performance<p class=tl>
The SQL statements are parsed and compiled only when the procedures are created, not when the procedures are executed by the applications.</P></li>
<li>
Reduced network overhead<p class=tl>
Having an application execute a procedure instead of sending sometimes complex queries across the network can reduce the traffic on the network. If an ODBC application uses the ODBC { CALL MyProcedure} syntax to execute a stored procedure, the ODBC driver makes additional optimizations that eliminate the need to convert parameter data (for more information, see "ODBC Call vs. Transact-SQL EXECUTE").</P></li>
<li>
Better consistency<p class=tl>
The organization's business rules can be coded and debugged once in a stored procedure, and they will then be consistently applied by all of the applications. The site does not have to depend on all application programmers coding their SQL statements correctly in all the applications.</P></li>
<li>
Better accuracy<p class=tl>
Most sites will have their best SQL programmers developing stored procedures. This means that the SQL statements in procedures tend to be more efficient and have fewer errors than when the code is developed multiple times by programmers of varying skill levels.</P></li>
</ul>
<p>
The Enterprise versions of the Microsoft Visual&nbsp;C++® development system and Microsoft Visual&nbsp;Basic® programming system also offer a new SQL debugger tool. With SQL&nbsp;Debugger, programmers can use the standard debugger facilities of their programming environment, such as setting break points and watching variables, to debug their SQL&nbsp;Server stored procedures.</p>
<h4>Batches</h4>
<p>
An application that builds several SQL statements to execute realizes better performance if it batches the statements together and sends them to the server all at once. This will reduce the number of network roundtrips the application uses to perform the same work. For example:</p>
<pre><code>SQLExecDirect(hstmt, 
 &nbsp;&nbsp;&nbsp;&nbsp; "select * from authors; select * from titles",
 &nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS);'
</code></pre>
<p>
The application uses <b>SQLMoreResults</b> to be positioned on the next result set when they are finished with the current result set.</p>
<h4>SQLBindCol and SQLGetData</h4>
<p>
Excess use of <b>SQLBindCol</b> to bind a result set column to a program variable is expensive because <b>SQLBindCol</b> causes an ODBC driver to allocate memory. When an application binds a result column to a variable, that binding remains in effect until the application either calls <b>SQLFreeStmt</b> with <i>fOption</i> set to either SQL_DROP or SQL_UNBIND. The bindings are not automatically undone when the statement completes.</p>
<p>
This logic allows applications to effectively deal with situations where they may execute the same SELECT statement several times with different parameters. Since the result set will keep the same structure, the application can bind the result set once, process all the different SELECT statements, then do a <b>SQLFreeStmt</b> with <i>fOption</i> set to SQL_UNBIND after the last execution. Applications should not call <b>SQLBindCol</b> to bind the columns in a result set without first calling <b>SQLFreeStmt</b> with <i>fOption</i> set to SQL_UNBIND to free any previous bindings.</p>
<p>
When using <b>SQLBindCol</b>, applications can either do row-wise or column-wise binding. Row-wise binding is somewhat faster than column-wise binding.</p>
<p>
Applications can use <b>SQLGetData</b> to retrieve data on a column-by-column basis, instead of binding the result set columns using <b>SQLBindCol</b>. If a result set contains only a couple of rows, then using <b>SQLGetData</b> instead of <b>SQLBindCol</b> is faster, otherwise, <b>SQLBindCol</b> gives the best performance. If an application does not always put the data in the same set of variables, it should use <b>SQLGetData</b> instead of constantly rebinding. Applications can only use <b>SQLGetData</b> on columns that are in the select list after all columns are bound with <b>SQLBindCol</b>. The column must also appear after any columns on which the application has already used a <b>SQLGetData</b>.</p>
<h4>Data Conversion</h4>
<p>
The ODBC functions dealing with moving data into or out of program variables, such as <b>SQLBindCol</b>, <b>SQLBindParameter</b>, and <b>SQLGetData</b>, allow implicit conversion of data types. For example, an application that displays a numeric column can ask the driver to convert the data from numeric to character:</p>
<pre><code>retcode = SQLBindCol(hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Point to integer column
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_C_CHAR,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;szCharVar,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARRAYSIZE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;cbCharVar);
printf("fetched row cola = %s\n", szCharVar);
</code></pre>
<p>
Applications should minimize data conversions. Unless data conversion is a required part of the application, the application should bind columns to a program variable of the same data type as the column in the result set.</p>
<p>
If the application needs to have the data converted, it is more efficient for the application to ask the driver to do the data conversion than for the application to do it.</p>
<p>
The driver normally just transfers data directly from the network buffer to the application's variables. Requesting the driver to perform data translation forces the driver to buffer the data and use CPU cycles to perform the conversion.</p>
<h4>Data Truncation</h4>
<p>
If an application attempts to retrieve data into a variable that is too small to hold it, the driver generates a warning. The driver must allocate memory for the warning messages and spend CPU resources on some error handling. This can all be avoided if the application allocates variables large enough to hold the data from the columns in the result set, or uses the SUBSTRING function in the select list to reduce the size of the columns in the result set.</p>
<h4>Query Options</h4>
<p>
Timeout intervals can be adjusted to prevent problems. Also, having different settings for some ODBC statement and connection options among several open connection or statement handles can generate excess network traffic.</p>
<p>
Calling <b>SQLSetConnectOption</b> with <i>fOption</i> set to SQL_LOGIN_TIMEOUT controls the amount of time an application waits for a connection attempt to timeout while waiting to establish a connection (0 specifies an infinite wait). Sites with slow response times can set this value high to ensure connections have sufficient time to complete, but the interval should always be low enough to give the user a response in a reasonable amount of time if the driver cannot connect.</p>
<p>
Calling <b>SQLSetStmtOption</b> with <i>fOption</i> set to SQL_QUERY_TIMEOUT sets a query timeout interval to protect the server and the user from long running queries.</p>
<p>
Calling <b>SQLSetStmtOption</b> with <i>fOption</i> set to SQL_MAX_LENGTH limits the amount of <b>text</b> and <b>image</b> data that an individual statement can retrieve. Calling <b>SQLSetStmtOption</b> with <i>fOption</i> set to SQL_MAX_ROWS also limits a rowset to the first <i>n</i> rows if that is all the application needs. Note that setting SQL_MAX_ROWS causes the driver to issue a SET ROWCOUNT statement to the server, which will affect all SQL statements, including triggers and updates.</p>
<p>
Care should be used when setting these options, however. It is best if all statement handles on a connection handle have the same settings for SQL_MAX_LENGTH and SQL_MAX_ROWS. If the driver switches from a statement handle to another with different values for these options, the driver must generate the appropriate SET TEXTSIZE and SET ROWCOUNT statements to change the settings. The driver cannot put these statements in the same batch as the user SQL since the user SQL can contain a statement that must be the first statement in a batch, therefore the driver must send the SET TEXTSIZE and SET ROWCOUNT statements in a separate batch, which automatically generates an extra roundtrip to the server.</p>
<h4>SET NOCOUNT</h4>
<p>
Applications can execute the Transact-SQL statement SET NOCOUNT ON. When this is set on, SQL&nbsp;Server does not return an indication of how many rows were affected by data-modification statements, or by any statements within procedures. When SET NOCOUNT is ON, the driver does not get the information it needs to return the number of rows affected should the application call <b>SQLRowCount</b> after a data-modification statement.</p>
<p>
All statements executed in a stored procedure, including SELECT statements, generate an "<i>x</i> rows affected" message. Issuing a SET NOCOUNT ON at the start of a large stored procedure can significantly reduce the network traffic between the server and client and improve performance by eliminating these messages. These messages are typically not needed by the application when it is executing a stored procedure.</p>
<h3>Cursors</h3>
<p>
Starting with SQL&nbsp;Server 6.0, the SQL&nbsp;Server ODBC driver supports the ODBC cursor options by using server cursors.</p>
<h4>Cursor Types</h4>
<p>
The ODBC standard assumes that a cursor is automatically opened on each result set and, therefore, does not make a distinction between a result set and a cursor. SQL&nbsp;Server SELECT statements, however, always return a result set. A SQL&nbsp;Server cursor is a separate entity created when the application needs to perform cursor operations such as scrolling and positioned updates.</p>
<p>
In the ODBC model, all SQL statements return a result set within a cursor, and an application retrieves rows through the cursor using either <b>SQLFetch</b> or <b>SQLExtendedFetch</b>. Before executing an SQL statement, an ODBC application can call <b>SQLSetStmtOption</b> to set statement options that control the cursor's behavior. These are the default settings for the cursor options.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=46%><b>Option</b></td>
<td class=label width=54%><b>Default</b></td>
</tr>
<tr valign=top>
<td width=46%>SQL_CURSOR_TYPE</td>
<td width=54%>SQL_CURSOR_FORWARD_ONLY</td>
</tr>
<tr valign=top>
<td width=46%>SQL_CONCURRENCY</td>
<td width=54%>SQL_CONCUR_READ_ONLY</td>
</tr>
<tr valign=top>
<td width=46%>SQL_ROWSET_SIZE</td>
<td width=54%>1</td>
</tr>
</table><br>
<p>
When running with these default settings, the application can only use <b>SQLFetch</b> to fetch through the result set one row at a time from the start of the result set to the end. When running with these default settings, the SQL&nbsp;Server ODBC driver requests a default result set from the server. In a default result set, SQL&nbsp;Server sends the results back to the client in a very efficient, continuous stream. The calls to <b>SQLFetch</b> retrieve the rows out of the network buffers on the client.</p>
<p>
It is possible to execute a query with these default settings, and then change the SQL_ROWSET_SIZE after the <b>SQLExecDirect</b> or <b>SQLExecute</b> complete. In this case, SQL&nbsp;Server still uses a default result set to efficiently send the results to the client, but the application can also use <b>SQLExtendedFetch</b> to retrieve multiple rows at a time from the network buffers.</p>
<p>
An ODBC application can change the SQL_CURSOR_TYPE to request different cursor behaviors from the result set. The types of cursors that can be set are:
<ul type=disc>
<li>
Static cursors<pre><code>SQL_CURSOR_TYPE=SQL_CURSOR_STATIC
</code></pre>
<p class=tl>
In a static cursor, the complete result set is built when the cursor is opened. The cursor does not reflect any changes made in the database that affect either the rows in the result set, or the values in the columns of those rows. In other words, static cursors always display the result set as it was when the cursor was opened. If new rows have been inserted that satisfy the conditions of the cursor's SELECT statement, they do not appear in the cursor. If rows in the result set have been updated, the new data values do not appear in the cursor. Rows appear in the result set even if they have been deleted from the database. No UPDATE, INSERT, or DELETE operations are reflected in a static cursor (unless the cursor is closed and reopened), not even modifications made by the same user who opened the cursor. Static cursors are read-only.</P></li>
<li>
Dynamic cursors<pre><code>SQL_CURSOR_TYPE=SQL_CURSOR_DYNAMIC
</code></pre>
<p class=tl>
Dynamic cursors are the opposite of static cursors; they reflect all changes made to the rows in their result set as the user scrolls around the cursor. In other words, the data values and membership of rows in the cursor can change dynamically on each FETCH. The cursor shows all DELETE, INSERT, and UPDATE statements either made by the user who opened the cursor or committed by other users. Dynamic cursors do not support FETCH ABSOLUTE because the size of the result set and the position of rows within the result set are not constant. The row that starts out as the tenth row in the result set may be the seventh row the next time a FETCH is performed.</P></li>
<li>
Forward-only cursors<pre><code>SQL_CURSOR_TYPE=SQL_CURSOR_FORWARD_ONLY
</code></pre>
<p class=tl>
This cursor is similar to a dynamic cursor, but it only supports fetching the rows serially in sequence from the start to the end of the cursor.</P></li>
<li>
Keyset-driven cursor<pre><code>SQL_CURSOR_TYPE=SQL_CURSOR_KEYSET_DRIVEN
</code></pre>
<p class=tl>
With a keyset-driven cursor, the membership of rows in the result set and their order is fixed when the cursor is opened. Keyset-driven cursors are controlled through a set of unique identifiers (keys), known as the keyset. The keys are built from a set of columns that uniquely identify the rows. The keyset is the set of all the key values that made up the rows in the result set when the cursor was opened. Changes to data values in nonkeyset columns for the rows (made by the current user or committed by other users) are reflected in the rows as the user scrolls through the cursor. Inserts are not reflected unless the cursor is closed and reopened. Deletes generate an "invalid cursor position" error (SQLState S1109) if the application attempts to fetch the missing row. If an update is made to a key-column value, it operates like a delete of the old key value followed by an insert of the new key value, and the new key value is not visible to the cursor. Attempts to fetch the old key value generate the S1109 error, but the new key value is not visible to the cursor.</P></li>
<li>
Mixed cursors<pre><code>SQL_CURSOR_TYPE=SQL_CURSOR_KEYSET_DRIVEN
SQL_KEYSET_SIZE=n
</code></pre>
<p class=tl>
SQL&nbsp;Server does not support mixed cursors.</P><p class=tl>
All ODBC cursors support the concept of a rowset, which is the number of rows returned on an individual <b>SQLExtendedFetch</b>. For example, if an application is presenting a 10-row grid to the user, the cursor can be defined with a rowset size of 10 to simplify mapping data into the grid.</P></li>
</ul>
<h4>Concurrency Option Overview</h4>
<p>
In addition to the cursor types, cursor operations are also affected by the concurrency options set by the application:</p>
<pre><code>SQL_CONCURRENCY = SQL_CONCUR_READONLY
</code></pre>
<p class=indent>
With this option set, the cursor does not support UPDATE, INSERT, or DELETE statements. Locks are not held on the underlying rows that make up the result set.</p>
<pre><code>SQL_CONCURRENCY = SQL_CONCUR_VALUES
</code></pre>
<p class=indent>
This option offers optimistic concurrency control. Optimistic concurrency control is a standard part of transaction control theory and is discussed in most papers and books on the subject. The application uses optimistic control when "optimistic" that there is a slight chance that anyone else may have updated the row in the interval between when the row is fetched and when the row is updated. When the cursor is opened in this mode, no locks are held on the underlying rows to maximize throughput. If the user attempts an UPDATE, the current values in the row are compared with the values retrieved when the row was fetched. If any of the values have changed, SQL&nbsp;Server returns an error. If the values are the same, the cursor engine performs the UPDATE.</p>
<p class=indent>
Selecting this option means the application must deal with an occasional error indicating that another user updated the row and changed the values. A typical action taken by an application that receives this error would be to refresh the cursor, to get the new values, and then let the user or application decide if the UPDATE should still be performed. Note that <b>text</b> and <b>image</b> columns are not used for concurrency comparisons.</p>
<pre><code>SQL_CONCURRENCY = SQL_CONCUR_ROWVER
</code></pre>
<p class=indent>
This optimistic concurrency control option is based on row versioning. With row versioning, the underlying table must have a version identifier of some type that the cursor engine can use to determine whether the row has been changed since it was read into the cursor. In SQL&nbsp;Server, this is the facility offered by the<b> timestamp</b> data type. SQL&nbsp;Server timestamps are binary numbers that indicate the relative sequence of modifications in a database. Each database has a global current timestamp value, <b>@@dbts</b>, which is incremented with every change in the database. If a table has a <b>timestamp</b> column, then its<b> timestamp</b> column is updated with the current <b>@@dbts</b> value every time the row is updated. The cursor engine can then compare a row's current timestamp value with the timestamp value that was first retrieved into the cursor to determine whether the row has been updated. The engine does not have to compare the values in all columns, only the timestamp value. If an application requests SQL_CONCUR_ROWVER on a table that does not have a <b>timestamp</b> column, the cursor defaults to the values-based optimistic concurrency control, SQL_CONCUR_VALUES.</p>
<pre><code>SQL_CONCURRENCY = SQL_CONCUR_LOCK
</code></pre>
<p class=indent>
This option implements pessimistic concurrency control, in which the application attempts to lock the underlying database rows at the time they are read into the cursor result set. For cursors using server cursors, an update intent lock is placed on the page holding the row when it is read into the cursor. If the cursor is opened within a transaction, these intent-to-update locks are held until the transaction is committed or rolled back. If the cursor has been opened outside a transaction, the lock is dropped when the next row is fetched. Thus, applications wanting full pessimistic concurrency control would typically open the cursor within a transaction. An update intent lock prevents any other task from acquiring an update intent or exclusive lock, which prevents any other task from updating the row. An update intent lock, however, will not block a shared lock, so it does not prevent other tasks from reading the row, unless the second task is also requesting a read with an update intent lock.</p>
<p>
In all of these concurrency options, when any row in the cursor is updated, SQL&nbsp;Server locks it with an exclusive lock. If the update has been done within a transaction, the exclusive lock is held until the transaction is terminated. If the update has been done outside of a transaction, the update is automatically committed when it is completed and the exclusive lock is freed. Because SQL&nbsp;Server must acquire an exclusive lock before it updates the row, positioned updates done through a cursor (just like standard updates) can be blocked by other connections holding a shared lock on the row.</p>
<h4>Isolation Levels</h4>
<p>
The full locking behavior of cursors is based on an interaction between the concurrency options discussed above and the transaction isolation level set by the client. ODBC clients set the transaction isolation level by setting the connection option SQL_TXN_ISOLATION. Users should combine the locking behaviors of the concurrency and transaction isolation level options to determine the full locking behavior of a specific cursor environment.
<ul type=disc>
<li>
READ COMMITTED (The default for both SQL&nbsp;Server and ODBC)<pre><code>SQL_TXN_ISOLATION = SQL_TXN_READ_COMMITED
</code></pre>
<p class=tl>
SQL&nbsp;Server acquires a shared lock while reading a row into a cursor but frees the lock immediately after reading the row. Because a shared lock request is blocked by an exclusive lock, a cursor is prevented from reading a row that another task has updated but not yet committed.</P></li>
<li>
READ UNCOMMITTED<pre><code>SQL_TXN_ISOLATION = SQL_TXN_READ_UNCOMMITED
</code></pre>
<p class=tl>
SQL&nbsp;Server requests no locks while reading a row into a cursor and honors no exclusive locks. This means that cursors can be populated with values that have already been updated but not yet committed. The user is bypassing all of SQL&nbsp;Server's locking transaction control mechanisms.</P></li>
<li>
REPEATABLE READ or SERIALIZABLE<pre><code>SQL_TXN_ISOLATION = SQL_TXN_REPEATABLE_READ_UNCOMMITED
</code></pre>
<p class=tl>
Or </P><pre><code>SQL_TXN_ISOLATION = SQL_TXN_SERIALIZABLE
</code></pre>
<p class=tl>
SQL&nbsp;Server still requests a shared lock on each row as it is read into the cursor as in READ COMMITTED, but if the cursor is opened within a transaction, the shared locks are held until the end of the transaction instead of being freed after the row is read. This is the same effect as specifying HOLDLOCK on a SELECT statement.</P></li>
</ul>
<p>
Note that the ODBC API specifies additional transaction isolation levels, but these are not supported by SQL&nbsp;Server or the Microsoft SQL&nbsp;Server ODBC driver.</p>
<h4>Server Cursors</h4>
<p>
Prior to version 6.0, SQL&nbsp;Server sent result sets back to clients using only one type of result set, the default result set. While the default result set is efficient at sending results back to clients, it only supports the characteristics of the default ODBC result set: forward-only, read-only, and a rowset size of one. Because of this, the Microsoft SQL&nbsp;Server ODBC drivers that shipped with SQL&nbsp;Server version 4.2<i>x</i> only supported the default ODBC settings.</p>
<p>
When using a default result set, there is only one roundtrip between the client and server; this occurs at the time the SQL statement is executed. After the statement is executed, the server sends the packets containing the results back to the client until all of the results have been sent back or the client has cancelled the results by calling <b>SQLMoreResults</b>. Calls to <b>SQLFetch</b> or <b>SQLExtendedFetch</b> do not generate roundtrips to the server, they just pull data from the client network buffers into the application.</p>
<p>
SQL&nbsp;Server 6.0 introduced cursors that are implemented on the server (server cursors). There are two types of server cursors:
<ul type=disc>
<li>
Transact-SQL cursors<p class=tl>
This type of cursor is based on the ANSI syntax for cursors and is meant to be used in Transact-SQL batches, primarily in triggers and stored procedures. Transact-SQL cursors are not intended to be used in client applications.</P></li>
<li>
API server cursors<p class=tl>
This type of cursor is created by either the DB-Library or ODBC APIs. The SQL&nbsp;Server ODBC driver that shipped with SQL&nbsp;Server 6.0 uses API server cursors to support the ODBC cursor options.</P></li>
</ul>
<p>
Users access the functionality of API server cursors through either ODBC or DB-Library. If an ODBC application executes a statement with the default cursor settings, the SQL&nbsp;Server ODBC driver requests a default result set from SQL&nbsp;Server. If the application sets the ODBC cursor type options to anything other than the defaults, however, then the SQL&nbsp;Server ODBC driver instead requests the server to implement a server cursor with the same options requested by the application. Since the cursor is implemented on the server, the driver does not have to use memory on the client to build a client-based cursor. Server cursors can also reduce network traffic in cases where a user decides they do not need to retrieve an entire result set. For example, if a user opens a cursor with 1,000 rows but then finds what they were looking for in the first 100 rows they scroll through, the other 900 rows are never sent across the network.</p>
<p>
When using server cursors, each call to <b>SQLFetch</b>, <b>SQLExtendedFetch,</b> or <b>SQLSetPos</b> causes a network roundtrip from the client to the server. All cursor statements must be transmitted to the server because the cursor is actually implemented on the server.</p>
<p>
One potential drawback of server cursors is that they currently do not support all SQL statements. Server cursors do not support any SQL statements that generate multiple result sets, therefore they cannot be used when the application executes either a stored procedure or a batch containing more than one select. If the application has set options that cause the driver to request an API server cursor, and then it executes a statement that server cursors do not support, the application gets an error:</p>
<pre><code>SQLState: 37000
pfNative: 16937
szErrorMsg: [Microsoft][ODBC SQL&nbsp;Server Driver][SQL&nbsp;Server]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cannot open a cursor on a stored procedure that
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; has anything other than a single select statement in it.
</code></pre>
<p>
Or</p>
<pre><code>SQLState: 37000
pfNative: 16938
szErrorMsg: [Microsoft][ODBC SQL&nbsp;Server Driver][SQL&nbsp;Server]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sp_cursoropen.&nbsp; The statement parameter can only
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be a single select or a single stored procedure.
</code></pre>
<p>
ODBC applications getting either of these errors when attempting to use server cursors with multiple statement batches or stored procedures should switch to using the ODBC default cursor options.</p>
<h4>Multiple Active Statements per Connection</h4>
<p>
After SQL&nbsp;Server has received a statement, the SQL&nbsp;Server TDS protocol does not allow acceptance of any other statements from that connection until one of the following occurs:
<ul type=disc>
<li>
The client application processes the entire result set.<br><br></li>
<li>
The client sends a statement telling the server it can close the remainder of the result set.</li>
</ul>
<p>
This means that when an ODBC application is using a default result set, SQL&nbsp;Server does not support multiple active statement handles on a connection handle and only one statement can be actively processed at any point in time.</p>
<p>
When an ODBC application is using API server cursors, however, the driver can support multiple active statements on a connection. When the rowset for each cursor command has been received back at the client, SQL&nbsp;Server considers the statement to have completed, and it accepts another statement from another statement handle over that connection handle.</p>
<p>
For example, an application can do the following to initiate processing on two statement handles:</p>
<pre><code>SQLAllocEnv(&amp;henv):
SQLAllocConnect(henv, &amp;hdbc);
SQLAllocStmt(hdbc, &amp;hstmt1);
SQLAllocStmt(hdbc, &amp;hstmt2);
SQLSetConnectOption(hdbc, SQL_CURSOR_TYPE, SQL_CURSOR_DYNAMIC);
SQLSetConnectOption(hdbc, SQL_ROWSET_SIZE, 5);
SQLExecDirect(hstmt1, "select * from authors", SQL_NTS);
</code></pre>
<p>
When the <b>SQLExecDirect</b> on hstmt1 is executed, the SQL&nbsp;Server ODBC driver issues a cursor open request. When SQL&nbsp;Server completes the cursor open, it considers the statement to be finished and allows the application to then issue a statement on another hstmt:</p>
<pre><code>SQLExecDirect(hstmt2, "select * from titles", SQL_NTS);
</code></pre>
<p>
Once again, after the server has finished with the cursor open request issued by the client, it considers the statement to be completed. If at this point the ODBC application makes a fetch request as follows, the SQL&nbsp;Server ODBC driver sends SQL&nbsp;Server a cursor fetch for the first five rows of the result set:</p>
<pre><code>SQLExtendedFetch(hstmt1, SQL_FETCH_NEXT, 1, ...);
</code></pre>
<p>
After the server has transferred the five rows to the driver, it considers the fetch processing completed and accepts new requests. The application could then do a fetch on the cursor opened for the other statement handle:</p>
<pre><code>SQLExtendedFetch(hstmt2, SQL_FETCH_NEXT, 1, ...);
</code></pre>
<p>
SQL&nbsp;Server accepts this second statement on the connection handle because, as far as it is concerned, it has completed the last statement on the connection handle, which was the fetch of the first five rows of the rows for hstmt1.</p>
<h4>Choosing a Cursor Option</h4>
<p>
The choice of cursor type depends on several variables, including:
<ul type=disc>
<li>
Size of the result set.<br><br></li>
<li>
Percentage of the data likely to be needed.<br><br></li>
<li>
Performance of the cursor open.<br><br></li>
<li>
Need for cursor operations like scrolling or positioned updates.<br><br></li>
<li>
Desired level of visibility to data modifications made by other users.</li>
</ul>
<p>
The default settings would be fine for a small result set if no updating is done, while a dynamic cursor would be preferred for a large result set where the user is likely to find their answer before retrieving many of the rows.</p>
<p>
Some simple rules to follow in choosing a cursor type are:
<ul type=disc>
<li>
Use default settings for singleton selects (returns one row), or other small result sets. It is more efficient to cache a small result set on the client and scroll through the cache.<br><br></li>
<li>
Use the default settings when fetching an entire result set to the client, such as when producing a report. After <b>SQLExecute</b> or <b>SQLExecDirect</b>, the application can increase the rowset size to retrieve multiple rows at a time using <b>SQLExtendedFetch</b>.<br><br></li>
<li>
The default settings cannot be used if the application is using positioned updates.<br><br></li>
<li>
The default settings cannot be used if the application is using multiple active statements.<br><br></li>
<li>
The default settings must be used for any SQL statement or batch of SQL statements that will generate multiple result sets.<br><br></li>
<li>
Dynamic cursors open faster than static or keyset-driven cursors. Internal temporary work tables must be built when static and keyset-driven cursors are opened but are not required for dynamic cursors.<br><br></li>
<li>
Use keyset-driven or static cursors if SQL_FETCH_ABSOLUTE is used.<br><br></li>
<li>
Static and keyset-driven cursors increase the usage of <b>tempdb</b>. Static server cursors build the entire cursor in <b>tempdb</b>; keyset-driven cursors build the keyset in <b>tempdb</b>.</li>
</ul>
<p>
Each call to <b>SQLFetch</b> or <b>SQLExtendedFetch</b> causes a roundtrip to the server when using server cursors. Applications should minimize these roundtrips by using a reasonably large rowset size and by using <b>SQLExtendedFetch</b> instead of <b>SQLFetch</b> whenever possible.</p>
<h4>Implicit Cursor Conversions</h4>
<p>
Applications can request a cursor type through <b>SQLSetStmtOption</b> and then execute an SQL statement that is not supported by server cursors of the type requested. A call to <b>SQLExecute</b> or <b>SQLExecDirect</b> returns SQL_SUCCESS_WITH_INFO and <b>SQLError</b> returns:</p>
<pre><code>szSqlState = "01S02", *pfNativeError = 0,
szErrorMsg="[Microsoft][ODBC SQL&nbsp;Server Driver]Cursor type changed"
</code></pre>
<p>
The application can determine what type of cursor is now being used by calling <b>SQLGetStmtOption</b> with <i>fOption</i> set to SQL_CURSOR_TYPE. The cursor type conversion applies to only one statement. The next <b>SQLExecDirect</b> or <b>SQLExecute</b> will be done using the original statement cursor settings.</p>
<p>
Both SQL&nbsp;Server 6.0 and 6.5 have the following restrictions:
<ul type=disc>
<li>
If an SQL statement contains UNION, UNION ALL, GROUP BY, an outer join, or DISTINCT, all cursor types other than static are converted to static.<br><br></li>
<li>
If a keyset-driven cursor is requested and there is at least one table that does not have a unique index, the cursor is converted to a static cursor.</li>
</ul>
<p>
SQL&nbsp;Server 6.0 has the following additional restrictions:
<ul type=disc>
<li>
If a dynamic cursor is requested and there is at least one table that does not have a unique index, the cursor is converted to a static cursor.<br><br></li>
<li>
If a dynamic cursor is requested and the SQL statement contains an ORDER BY that does not match a unique index or subquery, the cursor is converted to a static cursor.</li>
</ul>
<h3>SQLExecDirect vs. SQLPrepare/SQLExecute</h3>
<p>
This section discusses when <b>SQLExecDirect</b> or <b>SQLPrepare</b>/<b>SQLExecute</b> should be used.</p>
<h4>Driver Implementation Overview</h4>
<p>
ODBC offers two options for executing a statement. If a statement is only executed once or twice, the application can use <b>SQLExecDirect</b> to execute the statement. The ODBC definition of <b>SQLExecDirect</b> states that the database engine parses the SQL statement, compiles an execution plan, executes the plan, and then returns results to the application.</p>
<p>
If an application executes the same statement many times, then the overhead of having the engine compile the plan every time degrades performance. An application in this case can call <b>SQLPrepare</b> once and then call <b>SQExecute</b> each time it executes the statement. The ODBC definition of <b>SQLPrepare</b> states that the database engine just parses the statement and compiles an execution plan, then returns control to the application. On <b>SQLExecute</b>, the engine simply executes the precompiled execution plan and returns the results to the client, thereby saving the overhead of parsing and recompiling the execution plan.</p>
<p>
SQL&nbsp;Server itself does not directly support the <b>SQLPrepare</b>/<b>SQLExecute</b> model, but the SQL&nbsp;Server ODBC driver can use stored procedures to emulate this behavior. On a <b>SQLPrepare</b>, the driver asks the server to create a stored procedure that contains the SQL statement from the application. On <b>SQLExecute</b>, the driver executes the created stored procedure. The ODBC driver uses stored procedures to support <b>SQLPrepare</b>/<b>SQLExecute</b> when the option is enabled either in the data source or the <b>SQLDriverConnect</b> keywords. For example, if an application calls:</p>
<pre><code>SQLPrepare(hstmt, "select *from authors", SQL_NTS);
</code></pre>
<p>
The driver sends a statement to the server:</p>
<pre><code>CREATE PROCEDURE #ODBC#nnnnnnnn as
SELECT * FROM authors
</code></pre>
<p>
When the application then does:</p>
<pre><code>SQLExecute(hstmt);
</code></pre>
<p>
The driver sends a remote stored procedure call to have the server run the #ODBC#nnnnnnnn procedure.</p>
<p>
Because a CREATE PROCEDURE statement essentially compiles an SQL statement into an execution plan, and an EXECUTE statement simply executes the precompiled plan, this meets the criteria for the <b>SQLPrepare</b>/<b>SQLExecute</b> mode.</p>
<p>
Excess or inappropriate use of <b>SQLPrepare</b>/<b>SQLExecute</b> degrades an application's performance. SQL&nbsp;Server applications should only use <b>SQLPrepare</b>/<b>SQLExecute</b> if they plan to execute a statement more than 3 to 5 times. If an application needs to execute a statement only once, using <b>SQLPrepare</b>/<b>SQLExecute</b> generates two roundtrips to the server: one to create the stored procedure and another to execute it. <b>SQLExecDirect</b> would only use one roundtrip and would also save the overhead of creating and storing a stored procedure. Excess use of <b>SQLPrepare</b> can also cause locking contention in the system tables in <b>tempdb</b> as concurrent users continually try to create the stored procedures to support <b>SQLPrepare</b>.</p>
<p>
You may think that applications must use <b>SQLPrepare</b>/<b>SQLExecute</b> to use parameter markers, even if the application will only execute the statement once or twice. This is not true, applications can use parameter markers with <b>SQLExecDirect</b> by calling <b>SQLBindParameter</b> before <b>SQLExecDirect</b>.</p>
<p>
If an application will be run by many concurrent users and the users will all be using the same SQL statement, the best approach is to create the SQL statement as a permanent, parameterized, stored procedure and executed it with <b>SQLExecDirect</b>. Having many users concurrently issue <b>SQLPrepare</b> commands can create a concurrency problem on the system tables in <b>tempdb</b>. Even if each user is executing exactly the same statement, the SQL&nbsp;Server ODBC driver on each client is creating its own copy of a temporary stored procedure in <b>tempdb</b>. If the SQL statement is created as a parameterized stored procedure, however, the procedure is created only once. Each ODBC application does not have to create a new procedure for its exclusive use, it simply uses a copy of the permanent procedure's execution plan from the procedure cache.</p>
<p>
When used in the appropriate circumstances (to execute a single statement several times), <b>SQLPrepare</b>/<b>SQLExecute</b> can provide significant performance savings.</p>
<h4>Impact on Tempdb</h4>
<p>
SQL&nbsp;Server 6.0 introduced temporary stored procedures, which are identified by having a number sign (#) as the first character in the name. These procedures operate like temporary tables and are automatically dropped by the server if the connection is broken. The SQL&nbsp;Server ODBC driver now creates the procedures that support <b>SQLPrepare</b> as temporary procedures. This makes it impossible for the ODBC-related stored procedures to build up as a result of broken network connections or client computer failures. However, the temporary stored procedures are always created in <b>tempdb</b>. This means that sites running SQL&nbsp;Server 6.0 or 6.5 with ODBC applications that use <b>SQLPrepare</b> must ensure that <b>tempdb</b> is large enough to hold the temporary procedures generated to support <b>SQLPrepare</b>.</p>
<p>
There is another factor to consider in relation to how many stored procedures exist in <b>tempdb</b>. ODBC applications call <b>SQLSetConnectoption</b> with <i>fOption</i> set to the driver-specific value SQL_USE_PROCEDURE_FOR_PREPARE and <i>vParam</i> set to either SQL_UP_OFF, SQL_UP_ON, or SQL_UP_ON_DROP to control the generation of temporary procedures.
<ul type=disc>
<li>
SQL_UP_OFF means that the driver does not generate stored procedures.<br><br></li>
<li>
SQL_UP_ON_DROP means that the driver generates stored procedures, and that they are dropped when the application does a <b>SQLDisconnect</b>, a <b>SQLFreeStmt</b> with <i>fOption</i> set to SQL_DROP, or the next time the application issues <b>SQLPrepare</b> on the same statement handle.<br><br></li>
<li>
SQL_UP_ON means that temporary procedures are created, but they are only dropped on a <b>SQLDisconnect.</b></li>
</ul>
<p>
SQL_UP_ON is the default setting. The driver can reuse procedures if an application re-prepares the same SQL statement, and most applications realize a performance boost because the driver is not having to continually drop stored procedures. This may result in a build up of #ODBC procedures in <b>tempdb</b>, however, from applications that never disconnect or applications that make heavy use of <b>SQLPrepare</b>. These applications should set SQL_UP_ON_DROP by calling <b>SQLSetConnectOption</b>. Starting with the driver that shipped in SQL&nbsp;Server 6.5 SP2, SQL_UP_ON_DROP is now an option that can be specified on data sources for the SQL&nbsp;Server ODBC driver.</p>
<h4>Other Considerations of SQLPrepare</h4>
<p>
To keep from having to hold locks on the <b>tempdb</b> system tables for the length of a user transaction, the SQL&nbsp;Server ODBC driver does not generate a stored procedure for <b>SQLPrepare</b> if it is called within a transaction. The exception to this is when the <b>SQLPrepare</b> is the first statement in the transaction. In this case, the driver generates a stored procedure but then immediately commits the CREATE PROCEDURE statement.</p>
<p>
The driver does not generate a stored procedure for a <b>SQLPrepare</b> that uses the ODBC CALL escape clause to call a stored procedure. On <b>SQLExecute,</b> the driver executes the called stored procedure (there is no need to create a temporary stored procedure).</p>
<p>
Calling either <b>SQLDescribeCol</b> or <b>SQLDescribeParam</b> before calling <b>SQLExecute</b> generates an extra roundtrip to the server. On <b>SQLDescribeCol</b>, the driver removes the WHERE clause from the query and sends it to the server with SET FMTONLY ON to get the description of the columns in the first result set returned by the query. On <b>SQLDescribeParam</b>, the driver calls the server to get a description of the columns in the tables referenced by the query. This method also has some restrictions, such as not being able to resolve parameters in subqueries.</p>
<h3>Stored Procedures</h3>
<p>
This section discusses issues related to executing stored procedures using the SQL&nbsp;Server ODBC driver.</p>
<h4>ODBC Call vs. Transact-SQL EXECUTE</h4>
<p>
Applications can call SQL&nbsp;Server procedures using either the Transact-SQL EXECUTE statement or the ODBC SQL CALL escape clause (the Transact-SQL statement appears first, followed by the ODBC SQL CALL):</p>
<pre><code>SQLExecDirect(hstmt, "EXECUTE sp_helpdb 'pubs' ", SQL_NTS);
SQLExecDirect(hstmt, "{ call sp_helpdb ('pubs') }", SQL_NTS);
</code></pre>
<p>
Using the ODBC syntax is recommended. The ODBC syntax, in addition to being more portable, offers improved features and performance over the EXECUTE statement.</p>
<p>
The SQL&nbsp;Server TDS protocol provides two methods of sending a procedure to the server: the procedure can be sent to the server as a regular SQL statement, or it can be sent as a TDS Remote Procedure Call (RPC).</p>
<p>
The TDS RPC syntax was originally defined for use by servers when one server is asked to execute a remote stored procedure on another server, but it can also be used by applications. Using the TDS RPC syntax means neither the driver nor the server need to perform any parameter conversions. This improves performance, especially for image parameters. The SQL&nbsp;Server ODBC driver uses the TDS RPC syntax if the application uses the ODBC CALL escape clause; it uses the regular SQL statement syntax if the application uses the Transact-SQL EXECUTE statement.</p>
<p>
Using the ODBC CALL escape clause also allows the application to retrieve output parameters and return codes from a stored procedure. Output parameter and return code processing is discussed below.</p>
<h4>Output Parameters and Return Codes</h4>
<p>
SQL&nbsp;Server stored procedures can return both output parameters and return codes to an application:</p>
<pre><code>CREATE PROCEDURE odbcproc @oparm int OUTPUT AS
SELECT name FROM sysusers WHERE uid &lt; 2
SELECT @oparm = 88
RETURN 99
GO
</code></pre>
<p>
The parameters and return codes can be bound to program variables in an ODBC application where the application can reference them. For example, to execute the procedure above using the ODBC CALL escape clause and bind the return code and output parameters to program variables:</p>
<pre><code>SQLRETURN&nbsp;&nbsp; rcd;
DWORD&nbsp;&nbsp;&nbsp; ProcRet = 0, OParm = 0;
long&nbsp;&nbsp;&nbsp;&nbsp; cbProcRet = 0, cbOParm = 0;
// Bind the return code.
rcd = SQLBindParameter(hstmt, 1, SQL_PARAM_OUTPUT,
 &nbsp;&nbsp;&nbsp;&nbsp; SQL_C_SLONG, SQL_INTEGER, 0, 0, &amp;ProcRet, 0, &amp;cbProcRet);
// Bind the output parameter.
rcd = SQLBindParameter(hstmt, 2, SQL_PARAM_OUTPUT,
 &nbsp;&nbsp;&nbsp;&nbsp; SQL_C_SLONG, SQL_INTEGER, 0, 0, &amp;OParm, 0, &amp;cbOParm;
// First ? marks the return code,
// second ? marks the output parameter.
rcd = (SQLExecDirect(hstmt, "{? = call odbcproc(?)}", SQL_NTS;
</code></pre>
<p>
SQL&nbsp;Server does not send back the values for the return code or output parameters until the end of all result sets for the procedure. The program variables ProcRet and OParm do not hold the output values of 99 and 88 until <b>SQLMoreResults</b> returns SQL_NO_DATA_FOUND.</p>
<h3>Text and Image Data</h3>
<p>
The SQL&nbsp;Server ODBC driver has a couple of optimizations for <b>text</b> and <b>image</b> column processing that applications can use to improve performance.</p>
<h4>Bound vs. Unbound Text and Image Columns</h4>
<p>
When using server cursors (see "Cursors"), the driver is optimized to not transmit the data for unbound <b>text</b> or <b>image</b> columns at the time the row is fetched. The <b>text</b> or <b>image</b> data is not actually retrieved from the server until the application issues <b>SQLGetData</b> for the column.</p>
<p>
This optimization can be applied to applications so that no <b>text</b> or <b>image</b> data is displayed while a user is scrolling up and down a cursor. After the user selects a row, the application can call <b>SQLGetData</b> to retrieve the <b>text</b> or <b>image</b> data. This saves transmitting the <b>text</b> or <b>image</b> data for any of the rows the user does not select and can save the transmission of very large amounts of data.</p>
<h4>Logged vs. Nonlogged</h4>
<p>
An application can request that the driver not log <b>text</b> and <b>image</b> modifications:</p>
<pre><code>SQLSetStmtOption(hstmt,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_SOPT_SS_TEXTPTR_LOGGING,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_TL_OFF);
</code></pre>
<p>
This option should only be used for situations where the <b>text</b> or <b>image</b> data is not critical, and the data owners are willing to trade data recovery for higher performance.</p>
<h4>Data-At-Execution and Text and Image Columns</h4>
<p>
ODBC Data-At-Execution allows applications to work with extremely large amounts of data on bound columns or parameters. When retrieving very large <b>text</b> or <b>image</b> columns, an application cannot simply allocate a huge buffer, bind the column into the buffer, and fetch the row. When updating very large <b>tex</b>t or <b>image</b> columns, the application cannot simply allocate a huge buffer, bind it to a parameter marker in an SQL statement, and then execute the statement. Whenever the size of the <b>text</b> or <b>image</b> data exceeds 400K (64K with SQL&nbsp;Server 4.21a), the application must use <b>SQLGetData</b> or <b>SQLPutData</b> with their Data-At-Execution options. Applications should always use Data-At-Execution if there is any possibility that the size of the data will exceed these limits.</p>
<p>
Data-At-Execution is described in the <i>ODBC 2.0 Programmer's Reference</i>; however, it remains one of the hardest parts of the ODBC API for an application programmer to learn. The Appendix of this paper contains the source code of two Win32 console applications, Getimage.c and Putimage.c, that illustrate using Data-At-Execution to read and write large amounts of <b>image</b> data. <b>Text</b> columns would use similar calls, the only difference would be binding between SQL_C_CHAR and SQL_LONGVARCHAR instead of SQL_C_BINARY and SQL_LONGVARBINARY. Programmers interested in working with <b>text</b> or <b>image</b> columns should look up the Data-At-Execution index entries of the <i>ODBC 2.0 Programmer's Reference</i>, then search for "text" and "image" in <i>Microsoft SQL&nbsp;Server Programming ODBC for SQL&nbsp;Server.</i></p>
<h3>Querying Metadata</h3>
<p>
This section discusses some common issues when getting metadata and catalog information from the driver.</p>
<h4>Instcat.sql</h4>
<p>
Both the SQL&nbsp;Server system catalog stored procedures and the ODBC API catalog functions address the need of applications to retrieve catalog information from a database. Because there is a high correlation between the ODBC catalog functions and the SQL&nbsp;Server catalog stored procedures, the SQL&nbsp;Server ODBC driver implements many of the ODBC API catalog functions as calls to a corresponding SQL&nbsp;Server catalog procedure. The driver is therefore dependent on the catalog stored procedures in any SQL&nbsp;Server to which it connects.</p>
<p>
Each version of the SQL&nbsp;Server ODBC driver is developed in conjunction with a specific version of SQL&nbsp;Server. The proper operation of each driver version requires the versions of the catalog stored procedures associated with the specific version of SQL&nbsp;Server with which the driver was developed, or a later version of the procedures. For example, the 2.50.0121 driver was developed in conjunction with Microsoft SQL&nbsp;Server version 6.0, and requires either the versions of the system catalog stored procedures that were released with SQL&nbsp;Server 6.0, or with later versions, such as 6.5. The driver does not work properly with older versions of the catalog stored procedures, such as those in SQL&nbsp;Server version 4.21a.</p>
<p>
If a driver attempts to connect to a SQL&nbsp;Server running an older version of the catalog stored procedures than those required by the driver, the connection completes with SQL_SUCCESS_WITH_INFO and a call to <b>SQLError</b> returns the following message:</p>
<pre><code>SqlState:&nbsp;&nbsp; 01000
pfNative:&nbsp;&nbsp; 0
szErrorMsg: "[Microsoft][ODBC SQL&nbsp;Server Driver]The ODBC
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catalog stored procedures installed on server
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; My421Server are version 02.00.4127; version 06.00.0115
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or later is required to ensure proper operation.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Please contact your system administrator."
</code></pre>
<p>
Although the connection is successful, the application may later encounter errors on calls to the ODBC API catalog functions.</p>
<p>
Sites running multiple versions of the driver against a server need to ensure that the server is running with at least the version of Instcat.sql associated with the newest ODBC driver that will connect to it. For example, a site running multiple version 6.0 servers could buy SQL&nbsp;Server version 6.5 and upgrade some clients to use the new 2.65.0201 driver that comes with version 6.5. The site would also need to run the 6.5 version of Instcat.sql against the 6.0 servers before the new driver can connect to them.</p>
<p>
Installing a newer version of Instcat.sql into an older server does not break any existing applications connecting to that server, even ones still using the old drivers. It simply allows the applications using the new driver to operate correctly.</p>
<p>
Sites should run the Instcat.sql script at the server command prompt by using the <b>isql</b> utility.</p>
<pre><code>C:\&gt;cd \Mssql\Install
<b>isql /U</b><i>sa</i> <b>/P</b><i>password</i> <b>/S</b><i>servername</i> <b>/iInstcat.sql /oInstcat.rpt</b>
</code></pre>
<p>
For more information about determining the version of Instcat.sql currently applied to a server, see Microsoft Knowledge&nbsp;Base article Q137636. For more information about the<b> isql</b> utility, see the <i>Microsoft SQL&nbsp;Server Transact-SQL Reference</i>.</p>
<h4>Multiple Active Statements per Connection</h4>
<p>
Starting with <i>SQL&nbsp;Server</i> 6.5 and its associated driver, users can have multiple outstanding calls for metadata. In SQL&nbsp;Server 6.5, the catalog procedures underlying the ODBC catalog API implementations can be called by the ODBC driver while it is using static server cursors. This allows applications to concurrently process multiple calls to the ODBC catalog functions.</p>
<h4>Caching Metadata</h4>
<p>
If an application uses a particular set of metadata more than once, it will probably benefit by caching the information in private variables when it is first obtained. This eliminates the overhead of later calls to&nbsp; the ODBC catalog functions for the same information (which forces the driver to make roundtrips to the server).</p>
</BODY>
</HTML>
