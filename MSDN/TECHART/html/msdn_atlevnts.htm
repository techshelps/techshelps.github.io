<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Events: From an ATL Server to a Visual Basic Sink</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_atlevnts"></a></sup>Events: From an ATL Server to a Visual Basic Sink</h1>
<p>
Robert Coleridge<br>
MSDN Content Development Group</p>
<p>
March 26, 1997</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5054">
</OBJECT><a href="javascript:sample1.Click()">Click to copy the files for the ATLEVNTS sample discussed in this technical article</a></p>
<h2>Introduction</h2>
<p>
This article demonstrates how to create an Active Template Library (ATL) Component Object Model (COM) server that triggers events in a Microsoft® Visual Basic® sink object. Although this may sound like a straightforward COM coding task, there are several idiosyncrasies that must be taken into account. These idiosyncrasies will be demonstrated by writing a simple ATL COM server that reads a Uniform Resource Locator (URL) that has been requested by a Visual Basic client. Once the URL is read, the server raises an event that is picked up by the Visual Basic client.</p>
<p>
Most of us who have used Visual Basic are familiar with the terms VBX and OCX. These are generally third-party controls that, when added to a project, give it increased functionality. The ATL COM server that this article will help you to build functions just like a VBX or OCX control.</p>
<p>
In order to compile and run the ATLEVNTS sample, you must be running Microsoft Visual C++® version 5.0 and Visual Basic version 5.0. These tools are available either separately or as part of the Microsoft Visual Studio™ 97 package.</p>
<h2>Creating the Project and Objects</h2>
<p>
Creating a project and an object with the new Visual C++ 5.0 ATL COM Wizard is a very straightforward process, as described in the following steps.
<ol>
<li>
To create a new project, select <b>New</b> from the <b>File</b> menu.<br><br></li>
<li>
Select <b>ATL COM Wizard</b>, fill in the <b>Project name</b> and, if necessary, the <b>Location</b> and <b>Platforms</b> text boxes, and click <b>OK</b>.<br><br></li>
<li>
Select the <b>Server</b> <b>Type</b> and click <b>Finish</b>.<br><br></li>
<li>
From the Workspace window, right-click on the <b>Classes</b> entry you just created, and then select <b>New</b> <b>ATL</b> <b>Object</b>. Select <b>Simple Object</b> and click <b>Next</b>. <br><br></li>
<li>
After filling in the class and object information, click the <b>Attributes</b> tab and select the <b>Support Connection Points</b> and <b>Support ISupportErrorInfo</b> options.<br><br></li>
<li>
Add methods or properties to the created object.<br><br></li>
<li>
Voilà! You have just created a complete ATL COM Server.</li>
</ol>
<p>
That is all it takes to create a generic ATL COM Server. For further details, see the Visual C++ 5.0 documentation. Now let us examine how to add events to make the object work with a Visual Basic sink.</p>
<h2>Creating the Event Interfaces</h2>
<p>
In order to generate the event interface, we must first generate a dispinterface for the event object. This is because Visual Basic does <i>not</i> generate vtables for its event sinks. The events must be fired through an <b>IDispatch</b> object. Therefore, source and interface attributes are not allowed because ATL assumes that a vtable is supported. </p>
<p>
Let's generate an interface for our event methods. First, generate a GUID for the interface with the GuidGen.exe utility. Then, add the event methods to the .idl file, as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;[
 &nbsp;&nbsp;&nbsp;&nbsp; object,
 &nbsp;&nbsp;&nbsp;&nbsp; dual,
 &nbsp;&nbsp;&nbsp;&nbsp; uuid(<b>723B5B11-9EEF-11d0-BD88-00A0C90F282F</b>),
 &nbsp;&nbsp;&nbsp;&nbsp; helpstring("IUrlReaderEvent Interface"),
 &nbsp;&nbsp;&nbsp;&nbsp; version(1.0)
 &nbsp; ]
 &nbsp; interface IUrlReaderEvents : IDispatch {

<b> &nbsp;&nbsp;&nbsp;&nbsp; HRESULT ReadUrlFinished(long lFlags);</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp; HRESULT ReadUrlError(long lErrorCode);</b>

 &nbsp; };
</code></pre>
<p>
Note that since events are in essence subroutines, they must be defined as HRESULT methods that do not return any value.</p>
<p>
Once this is done, we need to generate the dispinterface for the .idl file as well. Use the GuidGen.exe utility to generate another GUID, and then place the dispinterface definition <i>inside </i>the library definition, as follows:</p>
<pre><code>[
 &nbsp; uuid(511A66F3-9EEE-11D0-BD88-00A0C90F282F),
 &nbsp; version(1.0),
 &nbsp; helpstring("ReadUrl 1.0 Type Library")
]
library READURLLib
{
 &nbsp; importlib("stdole32.tlb");
 &nbsp; importlib("stdole2.tlb");

<b> &nbsp; [</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp; uuid(723B5B10-9EEF-11d0-BD88-00A0C90F282F),</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp; nonextensible,</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp; helpstring("DIUrlReaderEvents Interface")</b>

<b> &nbsp; ]</b>

<b> &nbsp; dispinterface DIUrlReaderEvents</b>

<b> &nbsp; {</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp; properties:</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp; methods:</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [id(1)] void ReadUrlFinished(long lFlags);</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [id(2)] void ReadUrlError(long lErrorCode);</b>

<b> &nbsp; };</b>


 &nbsp; . . . 
};
</code></pre>
<p>
Note that the event methods use a void return. This is due to the fact, as stated above, that the events are treated as subroutines and do not return values. The difference in syntax is due to the different requirements of an interface object and a dispinterface object.</p>
<p>
The final step in creating the event interfaces is to modify the coclass definition so that the interfaces are exposed and COM knows which interface is the source of events. The sample .idl file looks like the following:</p>
<pre><code>[
 &nbsp; uuid(511A66F3-9EEE-11D0-BD88-00A0C90F282F),
 &nbsp; version(1.0),
 &nbsp; helpstring("ReadUrl 1.0 Type Library")
]
library READURLLib
{
 &nbsp; . . . 
 &nbsp; [
 &nbsp;&nbsp;&nbsp;&nbsp; uuid(511A6703-9EEE-11D0-BD88-00A0C90F282F),
 &nbsp;&nbsp;&nbsp;&nbsp; helpstring("UrlReader Class")
 &nbsp; ]
 &nbsp; coclass UrlReader
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; [default] interface IUrlReader;

<b> &nbsp;&nbsp;&nbsp;&nbsp; interface IUrlReaderEvents;</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp; [default, source] dispinterface DIUrlReaderEvents;</b>

 &nbsp; };
};
</code></pre>
<p>
The "<b>interface IUrlReaderEvents;</b>" line informs COM of the event interface and the "<b>[default, source] dispinterface DIUrlReaderEvents;</b>" line informs COM which interface is the source of events. This source <i>must</i> be the dispinterface in order to work with a Visual Basic sink.</p>
<h2>The ATL Proxy Generator</h2>
<p>
The ATL Proxy Generator (ATLPG) is an add-in with Visual C++ 5.0 that generates the code necessary for the proxy stub. This code is also the code we will use to cause the firing of the Visual Basic event.</p>
<p>
To have the ATLPG generate the event code, do the following: 
<ol>
<li>
On the <b>Projects</b> menu, point to <b>Add To Project</b>, and then click <b>Components and Controls</b>. <br><br></li>
<li>
From the list of available components, double-click <b>Developer Studio Components</b>, select <b>ATL Proxy Generator</b>, and then click <b>Insert</b>.<br><br></li>
<li>
The ATL Proxy generator requires the name of the type library containing the objects. You simply need to click on the button marked " <b>. . .</b> ", select our generated type library (you may have to browse for it), and click <b>Open</b>.<br><br></li>
<li>
You will then see a list of defined interfaces in the type library. One of them will be the dual interface we defined in our .idl file. Select the <b>DIUrlReaderEvents</b> interface. Set the proxy type to <b>Connection</b> <b>Points</b>, and then click <b>Insert</b>. Click <b>Save</b> and close all remaining<b> </b>dialog boxes.</li>
</ol>
<p>
That is all it takes to have the ATLPG generate the event code. The ATLPG will examine the type library, find our events, and generate code titled <b>Fire_<i>xxxx</i></b><i>,</i> where <i>xxxx</i> is the event we defined in the .idl file. To fire a specified event, we simply invoke one of these <b>Fire_<i>xxxx</i></b> functions.</p>
<p>
The last step we need to take with the ATLPG-generated code is to add an #include line in the object implementation file. The above "walk-through" generated a file called cprdurl.h. Our object is the UrlReader<b>,</b> so we need to add the following line to the urlrdr.h file:</p>
<pre><code>#include "cprdurl.h"
</code></pre>
<h2>Altering the Templates and Macros</h2>
<p>
This is the next-to-last step in modifying the generated ATL code. What is necessary here is to modify the inheritance list for the object that fires events. The generated intermittence list for the CUrlReader<b> </b>class looks like the following:</p>
<pre><code>class ATL_NO_VTABLE CUrlReader : 
 &nbsp; public CComObjectRootEx&lt;CComSingleThreadModel&gt;,
 &nbsp; public CComCoClass&lt;CUrlReader, &amp;CLSID_UrlReader&gt;,
 &nbsp; public ISupportErrorInfo,
 &nbsp; public IConnectionPointContainerImpl&lt;CUrlReader&gt;,
 &nbsp; public IDispatchImpl&lt;IUrlReader, &amp;IID_IUrlReader, &amp;LIBID_READURLLib&gt;
{
</code></pre>
<p>
Note that this list does not contain anything we don't need. The two CComxxxx templates are used to derive the base COM object and the base object for our CUrlReader class. The <b>ISupportErrorInfo</b> class and <b>IConnectionPointContainerImpl</b> template are simply a result of our selecting the <b>Supports Connection Points</b> and the <b>Support ISupportErrorInfo</b> options. The <b>IDispatchImpl</b> template is required because we selected a dual interface object. We need to add the template for the ATLPG-generated template, like so:</p>
<pre><code>class ATL_NO_VTABLE CUrlReader : 
 &nbsp; public CComObjectRootEx&lt;CComSingleThreadModel&gt;,
 &nbsp; public CComCoClass&lt;CUrlReader, &amp;CLSID_UrlReader&gt;,
 &nbsp; public ISupportErrorInfo,
 &nbsp; public IConnectionPointContainerImpl&lt;CUrlReader&gt;,

<b> &nbsp; public CProxyDIUrlReaderEvents&lt;CUrlReader&gt;,</b>

 &nbsp; public IDispatchImpl&lt;IUrlReader, &amp;IID_IUrlReader, &amp;LIBID_READURLLib&gt;
{
</code></pre>
<p>
Once this template is added to the inheritance list, we need to add an entry to the connection point map. This is done by making the following change to the connection point map:</p>
<pre><code>BEGIN_CONNECTION_POINT_MAP(CUrlReader)
 &nbsp; <b>CONNECTION_POINT_ENTRY(DIID_DIUrlReaderEvents)</b>
END_CONNECTION_POINT_MAP()
</code></pre>
<p>
The final urlrdr.h file should look something like the following (our additions are in bold face):</p>
<pre><code>// urlrdr.h : Declaration of the CUrlReader

. . . 

#include "resource.h"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // main symbols

<b>#include "cprdurl.h"</b>

#include &lt;ComDef.h&gt; &nbsp; // for _bstr_t class

/////////////////////////////////////////////////////////////////////////////
// CUrlReader
class ATL_NO_VTABLE CUrlReader : 
 &nbsp; . . . 
 &nbsp; <b>public CProxyDIUrlReaderEvents&lt;CUrlReader&gt;,</b>
 &nbsp; . . . 
{

. . . 

BEGIN_CONNECTION_POINT_MAP(CUrlReader)
 &nbsp; <b>CONNECTION_POINT_ENTRY(DIID_DIUrlReaderEvents)</b>
END_CONNECTION_POINT_MAP()

. . . 

#endif //__URLREADER_H_
</code></pre>
<p>
That's it! We now have a fully functional ATL COM Server that can fire events to a Visual Basic sink object. All that is left is to fire the event whenever it is logically necessary. In the ATLEVNTS sample, the firing code is launched on a separate thread to allow asynchronous processing. The thread creation code looks like the following:</p>
<pre><code>// Create URL reading thread, passing in address of the thread code.
// The "this" pointer is passed in so that the thread code has
// access to the calling object. 
m_hThread = ::CreateThread(
 &nbsp; NULL,
 &nbsp; 0,

<b> &nbsp; (LPTHREAD_START_ROUTINE)&amp;CUrlReader::ProcessUrl,</b>

<b> &nbsp; this,</b>

 &nbsp; 0,
 &nbsp; &amp;m_dwThreadId);
</code></pre>
<p>
The following sample code fires the event:</p>
<pre><code>DWORD WINAPI CUrlReader::ProcessUrl(void * pParam)
{
 &nbsp; // The "pParam" is a "this" pointer to the calling object,
 &nbsp; // so cast appropriately.
 &nbsp; CUrlReader * pCaller = (CUrlReader *)pParam;
...
 &nbsp; // Raise event notification
 &nbsp; <b>pCaller-&gt;Fire_ReadUrlFinished(0);</b>

 &nbsp; return 0;
}
</code></pre>
<h2>Tying It All Together</h2>
<p>
The following list reiterates the 16 steps required to generate an ATL object that fires events to a Visual Basic sink object. 
<ol>
<li>
Create an ATL COM Wizard project.<br><br></li>
<li>
Create an ATL object with support for connection points.<br><br></li>
<li>
Add methods and properties to the object(s).<br><br></li>
<li>
Run GuidGen.exe to get a GUID for the dispinterface event object.<br><br></li>
<li>
Add the dispinterface definition <i>inside</i> the library definition.<br><br></li>
<li>
Add void event methods to this interface.<br><br></li>
<li>
Run GuidGen.exe to get a GUID for the interface event object.<br><br></li>
<li>
Add the event interface.<br><br></li>
<li>
Add HRESULT event methods to this interface.<br><br></li>
<li>
Add dispinterface and interface to coclass.<br><br></li>
<li>
Add forward references to the top of the .idl file.<br><br></li>
<li>
Generate a typelib with the ATL Proxy Generator.<br><br></li>
<li>
Add #include for the generated file to the object .h file.<br><br></li>
<li>
Modify the class inheritance list.<br><br></li>
<li>
Add connection point entries to the connection point map.<br><br></li>
<li>
Add event firing to the appropriate code.</li>
</ol>
<h2>UrlReader: The Sample Code</h2>
<p>
The sample Visual Basic client is quite simple. All it does is provide two editboxes—one to enter the desired URL and the other for the name of the output file. Once the user enters the desired URL and the output file specification and clicks the <b>Read URL</b> button, the client will request the HTML page from the COM server and then immediately return to the client application. (Since this is a multithreaded application, the client can do further processing until the event notification is fired from the server.)</p>
<p>
The COM server will establish a link to the web and attempt to read the specified URL. In order to allow the Visual Basic code to return immediately, the COM server creates a separate thread to do the Web work. If the Web work fails, then the COM server fires the UrlReader_ReadUrlError event. If the URL is read successfully, then the UrlReader_ReadUrlFinished event is fired.</p>
<p>
For a technical discussion of the Visual Basic client and its event syntax, please refer to the Visual Basic documentation. See entries on <b>WithEvents</b> and classes.</p>
<h2>Conclusion</h2>
<p>
As you can see from this article, adding the requisite components to an ATL object is not difficult at all. It is simply a series of sequential steps. With this knowledge in mind, you can now combine the power of ATL, the Visual C++ 5.0 wizardry, and what you've learned from this article to create a multitude of useful objects.</p>
</BODY>
</HTML>
