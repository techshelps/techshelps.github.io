<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OpenGL IV: Color Index Mode</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_gl4"></a></sup>OpenGL IV: Color Index Mode</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
January 19, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3224">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the EasyCl sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3223">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the GLlib DLL for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article explores the Windows NT™ implementation of OpenGL™ color index mode. In color index mode, colors are specified as indexes into a palette instead of as levels of red, green, and blue. The EasyCI sample application (provided with this article) is a conversion of EasyGL that uses color index mode. EasyCI uses the GLlib.DLL, also included with this article. </p>
<h2>Introduction</h2>
<p>
I still remember visiting Grandpa Albert every year before school started. Grandpa Albert and his twin brother Bartholomew, locally known as the Bert and Bart brothers, would take us kids fly fishing up on the North Fork of the Snoqualmie River. Now, Great-Uncle Bartholomew would take every fly that he owned with him. He had this large MyFishingBuddyPal tackle box in which he carried thousands of flies. He knew all of the flies and referred to them by name; for example, Super Humbler Bumbler Bee #2, Megamoth Pro, or Jake's Snake. Grandpa Albert, on the other hand, would study the weather conditions before he left and would select what he considered the 17 most appropriate flies for those conditions. He would arrange these flies on his hat. If you asked him which fly he was using, he would tell you the location of the fly on his hat. Grandpa Albert was no computer scientist, so this number was one-based.</p>
<p>
Amazingly enough, Bart's method was similar to the RGBA color mode found in OpenGL™. Grandpa Albert's method was not unlike OpenGL's color index mode, because he picked from a palette of flies on his hat by index.</p>
<p>
The previous OpenGL articles in this series (see bibliography) all used RGBA color mode. RGBA color mode uses the <b>glColor </b>command to specify colors by the levels of red, green, or blue they contain; for example:</p>
<pre><code>glColor3d(1.0, 0.14, 0.6667) ; // purple people eater purple
</code></pre>
<p>
In color index mode, the color is specified by its index into a palette of colors; for example:</p>
<pre><code>glIndexs(37) ;
</code></pre>
<p>
The command above picks the thirty-eighth color in the palette. (Because OpenGL was designed by computer scientists and not by Grandpa Albert, the index is zero-based.) The thirty-eighth color can be anything from mauve to Super Humbler Bumbler Bee yellow, depending on what you put in the palette. In practice, you don't use <b>glIndex</b> all that much (you use <b>glMaterial</b> instead); but we'll talk more about that later.</p>
<p>
In this article, we'll examine the advantages and disadvantages of using color index mode. We'll also look at some of the differences between a program that uses color index mode and one that uses RGBA mode. The information in this article is based on my experience converting the EasyGL sample application to EasyCl, which uses color index mode. The changes I made to EasyGL and GLlib are discussed in the last section of the article. For information on EasyGL and GLlib, see my article <a href="msdn_gl3.htm">"OpenGL III: Building an OpenGL C++ Class"</a> in the MSDN Library.</p>
<h2>Choosing Color Index Mode</h2>
<p>
RGBA mode and color index mode are mutually exclusive: You can use either mode, but not simultaneously. In the Windows NT™ implementation of OpenGL, you choose the mode by changing a field in the pixel format descriptor and calling the <b>ChoosePixelFormat</b> and <b>SetPixelFormat</b> functions. Change the <b>iPixelType</b> field of the <b>PIXELFORMATDESCRIPTOR</b> structure to indicate which mode you would like to use. For RGBA mode, use: </p>
<pre><code>pfd.iPixelType = PFD_TYPE_RGBA ;
</code></pre>
<p>
For color index mode, use:</p>
<pre><code>pfd.iPixelType = PFD_TYPE_COLORINDEX ;
</code></pre>
<p>
In GLlib.DLL, the pixel format descriptor is set up in <b>CGL::Create</b>.</p>
<p>
Once you set up a pixel format for a window, you cannot change it. Therefore, if you need to switch between the two modes, you will have to destroy and recreate the window. This information is buried in the documentation for <b>SetPixelFormat</b> in the Win32® Software Development Kit (SDK) for Windows NT.</p>
<h3>Reasons for Choosing Color Index Mode</h3>
<p>
Chapter 5 of the <i>OpenGL Programming Guide</i> (hereafter called the "Red Book"; see the bibliography at the end of this article) explains some of the reasons for choosing color index mode instead of RGBA mode. In this section, I will give you my own reasons for using color index mode. My reasons are more specific to the Windows NT implementation than those given in the Red Book. Color index mode gives you:
<ul type=disc>
<li>
More control over the palette<br><br></li>
<li>
The ability to create identity palettes<br><br></li>
<li>
The ability to use false colors<br><br></li>
<li>
The ability to use palette animation<br><br></li>
<li>
Greater speed</li>
</ul>
<h4>More of what you want</h4>
<p>
One reason for using color index mode is to get the colors you want. If you are running on an 8-bits-per-pixel (bpp) device, you have a 256-color palette. As we discussed in the article <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode"</a> in the MSDN Library, you have control over only 236 of the palette colors. To make matters worse, the Windows NT implementation of OpenGL requires that these colors be arranged in a 3-3-2 format. You can change these colors slightly by using gamma correction, but you are basically stuck with the 3-3-2 format. If your application needs 128 reds or 200 grays, you are out of luck. </p>
<p>
In color index mode, the palette can have the 236 colors that you want. If you want 236 reds, you can have them. A scene rendered with color index mode can look more brilliant and alive than the same scene rendered with RGBA mode, because you can choose brighter colors from the color index mode palette. </p>
<p>
The SYSPAL_NOSTATIC and PC_NOCOLLAPSE flags give you more control over the palette. In practice, however, these flags aren't very useful. For more information, read <a href="msdn_palette.htm">"The Palette Manager: How and Why"</a> in the MSDN Library. Other good articles on palettes are listed in the bibliography at the end of this article.</p>
<h4>Identity palettes</h4>
<p>
If you need to render an OpenGL scene on a bitmap and blt it to the screen, you might need to use color index mode to speed up the blting.</p>
<p>
Fast blting is the key to fast animation. The key to fast blting is using identity palettes. The key to identity palettes? Well, read Nigel Thompson's book <i>Animation Techniques for Win32: A C++ Programmer's Guide to DIBs, Palettes, and Sprites</i>.</p>
<p>
An identity palette is a logical palette that is identical to the system palette. A logical palette must have fewer than 236 colors (not including system colors) before it can aspire to be an identity palette. The first color in the logical palette that is not a system color is placed at (zero-based) index 10 in the system palette. </p>
<p>
The palette that we build when PFD_NEED_PALETTE is set cannot be an identity palette, because the location of the color within the palette is significant. Without an identity palette, blting is slow, because each pixel has to be translated from the logical palette to the system palette. If we use color index mode, we can choose almost any palette we want, so we can pick a palette that has a better chance of being an identity palette. I will explore this issue further in a future article on OpenGL and rendering on bitmaps.</p>
<h4>False color</h4>
<p>
Some people claim that the main reason applications use color index mode is because they use color to illustrate another dimension. For example, a mapping program might use color to show the height of a particular area on the map. The mapping program might show areas between 1000 and 2000 feet as green, areas between 5000 and 10,000 feet as brown, and the top of Mount Tahoma as white.</p>
<p>
An application could use color index mode to illustrate the pressure on an aircraft fuselage: The high pressure areas could be red, and the low pressure areas could be blue, with a whole range of colors in between. An aeronautical engineer could quickly glance at the three-dimensional (3-D) representation of the plane and determine the low-pressure locations instantly.</p>
<p>
In the last two examples, we don't necessarily care what the colors are; we care only that each color is different. Color index mode fits the bill nicely. It is fairly easy to create a function <b>f(<i>x</i>)</b> that returns the index, where <i>x</i> is the pressure or height of a point. Note, however, that RGBA mode can do the same thing by using an array of colors. </p>
<h4>Palette animation</h4>
<p>
Another use for color index mode is palette animation. You can change the colors on the screen instantly by changing the values in the palette. You do not have to repaint the scene, because the palette indexes in screen memory are still valid. The same index points to the new color in the palette.</p>
<h4>Speed</h4>
<p>
Color index mode can be faster than RGBA mode, because calculations are performed on one color channel rather than three. However, the performance improvement is not exactly a factor of three, because you may need to perform tasks that are unique to color index mode. For example, lighting calculations in color index mode require a light intensity to be calculated from a weighted sum of the light's RGB components.</p>
<h3>Reasons for Not Choosing Color Index Mode</h3>
<p>
The Red Book lists some of the reasons for not choosing color index mode. The main reason is that OpenGL is unable to perform much of its magic in this mode. For example, <b>glColorMaterial</b>, which EasyGL and GLEasy both use, is not available in color index mode. In fact, only GL_DIFFUSE and GL_SPECULAR of the ten <b>glLight</b> parameters are used in color index mode. Similarly, only GL_SHININESS and GL_COLOR_INDEXES of the seven <b>glMaterial</b> parameters affect color index mode. </p>
<h2>GL_SHININESS</h2>
<p>
The <i>OpenGL Reference Manual </i>(also called the "Blue Book"; see the bibliography at the end of this article) states that GL_COLOR_INDEXES is the only <b>glMaterial</b> parameter that works in color index mode. This is incorrect. The GL_SHININESS parameter also works in color index mode. EasyGI uses the GL_SHININESS parameter. If you don't use GL_SHININESS, for example, if you comment out the following lines in <b>CScene::OnRender</b>:</p>
<pre><code>&nbsp;&nbsp;&nbsp;GLfloat matShiny[] = { 120.0f };
 &nbsp; glMaterialfv(GL_FRONT, GL_SHININESS, matShiny) ;
</code></pre>
<p>
the objects will be rendered white instead of the desired colors. The GL_SHININESS parameter determines the size and brightness of a specular highlight. The larger the number, the smaller and brighter (more focused) the highlight. A GL_SHININESS value of 0 (the default) results in a large, unfocused highlight that obliterates the color of the object. Therefore, instead of using the default, we set this parameter to a reasonable value. (The maximum value for CL_COLOR_INDEXES is 128.)</p>
<p>
See the section "Lighting in Color-Index Mode" in Chapter 6 of the Red Book for more information on lighting.</p>
<h2>GL_COLOR_INDEXES</h2>
<p>
The EasyGI sample application used <b>glColorMaterial </b>to color objects. Because <b>glColorMaterial </b>does not work in color index mode, EasyCI had to use something different. Therefore, it uses the GL_COLOR_INDEXES parameter of <b>glMaterial</b>.</p>
<p>
The GL_COLOR_INDEXES parameter is valid only for color index mode; RGBA mode does not use it. The following commands use the GL_COLOR_INDEXES parameter to color the pyramid purple:</p>
<pre><code>GLfloat matPurple[] = {16.0f, 47.0f, 79.0f} ;
glMaterialfv(GL_FRONT, GL_COLOR_INDEXES, matPurple) ;
glCallList(Pyramid) ;
</code></pre>
<p>
The <b>matPurple </b>array contains three numbers representing the indexes for the ambient, diffuse, and specular material reflectance:
<ul type=disc>
<li>
<i>Diffuse reflectance</i> determines the color of an object, so it is usually set to the color of the object.<br><br></li>
<li>
<i>Ambient reflectance</i> affects the color of an object when light is not directly shining on it (when it is illuminated only by the ambient lights). Ambient reflectance is usually set either to the same color as diffuse reflectance or to a darker color. It makes sense for the ambient reflectance to be darker because the object has less light shining on it.<br><br></li>
<li>
<i>Specular reflectance</i> determines the color of the object's highlights. A white specular reflectance is the color of the light shining on the object in RGBA mode. In color index mode, lights don't have colors; they only have intensities.</li>
</ul>
<p>
In the code example above, index 16 contains the pure ambient color, index 47 contains the pure diffuse color, and index 79 contains the pure specular color. If OpenGL used only these three indexes to shade objects, the results would be pitiful. Therefore, OpenGL uses colors between these indexes to shade objects. For smooth shading, the colors between the indexes should form a color ramp—that is, the colors should progress from the pure ambient color at index 16 in the example, to the pure diffuse color in index 47, and finally to the pure specular color in index 79.</p>
<p>
To understand this, you need to know which colors the palette contains at these indexes and at the indexes in between.</p>
<p>
The code below is from <b>CScene::OnCreatePaletteCI </b>in EasyCI. It fills up part of the palette with a purple, red, and green color ramp.</p>
<pre><code>&nbsp;&nbsp;&nbsp;// Purple ramp
 &nbsp; for (int i=0; i&lt; 32; i++)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // 16 to 47 is a linear ramp from black to purple
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[16+i].peRed&nbsp; = 255* i / 32 ;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[16+i].peGreen= 0 ;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[16+i].peBlue = 255* i / 32 ;

 &nbsp;&nbsp;&nbsp;&nbsp; // 48 to 79 is a linear ramp from purple to white
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[48+i].peRed&nbsp; = 255 ;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[48+i].peGreen= 255* i / 32 ;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[48+i].peBlue = 255 ;
 &nbsp; }

 &nbsp; // Red ramp
 &nbsp; for (i=0; i&lt; 32; i++)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // 80 to 111 is a linear ramp from black to red
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[80+i].peRed&nbsp; = 255* i / 32 ;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[80+i].peGreen= 0 ;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[80+i].peBlue = 0 ;

 &nbsp;&nbsp;&nbsp;&nbsp; // 112 to 143 is a linear ramp from red to white
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[112+i].peRed&nbsp; = 255 ;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[112+i].peGreen= 255 * i / 32 ;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[112+i].peBlue = 255 * i / 32 ;
 &nbsp; }

 &nbsp; // Green ramp
 &nbsp; for (i=0; i&lt; 32; i++)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // 144 to 175 is a linear ramp from black to green
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[144+i].peRed&nbsp; = 0;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[144+i].peGreen= 255 * i / 32 ;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[144+i].peBlue = 0 ;

 &nbsp;&nbsp;&nbsp;&nbsp; // 176 to 207 is a linear ramp from green to white
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[176+i].peRed&nbsp; = 255 * i / 32&nbsp; ;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[176+i].peGreen= 255&nbsp; ;
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[176+i].peBlue = 255 * i / 32 ;
 &nbsp; }
</code></pre>
<p>
Because I am such a nice guy, I created Figure 1 to illustrate what the above code puts into the palette.</p>
<p>
<img src="gl4_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Palette filled in by CScene::OnCreatePaletteCI</b></p>
<p>
Here's the code that makes an object red and green using the above palette:</p>
<pre><code>GLfloat matRed[] = {80.0f, 111.0f, 143.0f} ;
glMaterialfv(GL_FRONT, GL_COLOR_INDEXES, matRed) ;
glCallList(Dodec) ;

GLfloat matGreen[] = {144.0f, 175.0f, 207.0f} ;
glMaterialfv(GL_FRONT, GL_COLOR_INDEXES, matGreen) ;
glCallList(Box) ;
</code></pre>
<p>
In the example above, I used black for the pure ambient color, so an object that has only ambient light on it will appear black. The diffuse color of the object is maximum red (255, 0, 0), green (0, 255, 0), or purple (255, 0, 255). An object in a bright light will appear in this (pure red, green, or purple) color. A bright highlight is white (255, 255, 255). I used a smooth ramp to fill the indexes between these three key colors. For more information, see the Red Book, Chapter 6 (pages 192–194) for details. (In particular, see the "Advanced Topic" section, which explains the mathematics.)</p>
<p>
Now, that's the code I used. The colors can be anything that you want them to be. The diffuse color can be anything that your heart desires. The ambient reflectance could be dark blue, dark green, dark purple, orange, or even white. The same is true for the specular reflectance. The color ramps can be any length. You can have the diffuse and ambient colors share the same index and have a 5-color ramp to the highlight color, if you desire. It's up to you—experiment to your heart's content.</p>
<h2>Changes to EasyCI</h2>
<p>
To get EasyCI to use the color index mode instead of RGBA mode, I changed the classes in GLlib and some of the OpenGL code in EasyCI. Figure 2 illustrates the changes.</p>
<p>
<img src="gl4_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Changes and additions to GLlib and EasyCI</b></p>
<h2>Changes to GLlib</h2>
<p>
Inside CGlib, I changed both <b>CGL</b> and <b>CGLView</b> to support color index mode. I made most of the Windows NT OpenGL implementation changes in <b>CGL</b>. I modified the EasyCI class <b>CScene</b> to meet OpenGL requirements for color index mode. <b>CScene::OnRender </b>includes the bulk of the OpenGL code and most of the OpenGL changes for color indexing.</p>
<p>
First, we will examine the changes in <b>CGL</b>.</p>
<h3>CGL Changes</h3>
<p>
In <b>CGL</b>, I changed both <b>CGL::Create </b>and <b>CGL::CreatePalette</b> and exported a new function, <b>CGL::OnCreatePaletteCI</b>, as shown in Figure 3.</p>
<p>
<img src="gl4_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Changes to CGL</b></p>
<h4>CGL::Create</h4>
<p>
The major change in <b>CGL::Create</b> is the addition of a new parameter, <b>iPixelType</b>, which is declared in CGL.H as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;BOOL Create(CWnd* pWnd, int iPixelType = PFD_TYPE_RGBA) ;
</code></pre>
<p>
<b>iPixelType </b>has a default value, so EasyGL didn't require any changes. In <b>CGL::Create</b>, I changed the following line: </p>
<pre><code>pfd.iPixelType = PFD_TYPE_RGBA ;
</code></pre>
<p>
to:</p>
<pre><code>pfd.iPixelType = iPixelType ;
</code></pre>
<p>
In EasyCI, <b>CSceneView::OnCreate </b>calls <b>CGL::Create</b> and passes it PFD_TYPE_COLORINDEX to set OpenGL to color index mode.</p>
<h4>CGL::CreatePalette</h4>
<p>
Color index mode requires a palette. The whole point of color index mode is having a palette so you can specify palette indexes instead of palette colors. However, PFD_NEED_PALETTE is not set for color index mode. The previous version of <b>CGL::CreatePalette</b> included the line:</p>
<pre><code>if (!(pfd.dwFlags &amp; PFD_NEED_PALETTE)) return FALSE;
</code></pre>
<p>
This means that a palette won't be created unless PFD_NEED_PALETTE is set. I replaced this line with the following code:</p>
<pre><code>BOOL bColorIndex = (pfd.iPixelType &amp; PFD_TYPE_COLORINDEX) ;
if ((pfd.dwFlags &amp; PFD_NEED_PALETTE) || bColorIndex)
{
 &nbsp; // Need to create a palette
 &nbsp; LOGPALETTE* pPal = (LOGPALETTE*)malloc(sizeof(LOGPALETTE)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + 256 * sizeof(PALETTEENTRY));
 &nbsp; pPal-&gt;palVersion = 0x300 ;
 &nbsp; pPal-&gt;palNumEntries = 256 ;
 &nbsp; if (bColorIndex)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Let user create palette for color index mode
 &nbsp;&nbsp;&nbsp;&nbsp; OnCreatePaletteCI(pPal) ;
 &nbsp; }
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Create RGB palette for RGBA mode
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp; }
}
</code></pre>
<p>
With these changes, <b>CreatePalette</b> will create a palette for color index mode in addition to creating a palette when PFD_NEED_PALETTE is set. However, it is the application's job to set the palette to whatever it wants. Therefore, <b>CreatePalette</b> calls <b>CGL::OnCreatePaletteCI</b>.</p>
<h4>CGL::OnCreatePaletteCI</h4>
<p>
<b>CGL::OnCreatePaletteCI </b>is declared and defined as follows:</p>
<pre><code>virtual BOOL OnCreatePaletteCI(LOGPALETTE* pPal)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { TRACE0("CGL::OnCreatePaletteCI\r\n"); return FALSE; }
</code></pre>
<p>
<b>CGL::OnCreatePaletteCI </b>is implemented by classes derived from <b>CGL</b>, in a manner similar to <b>CGL::OnResize</b>, <b>CGL::OnInit</b>, and <b>CGL::OnRender</b>. <b>CGL::OnCreatePaletteCI </b>differs from these functions in that it is not a pure virtual function. I didn't make <b>OnCreatePaletteCI </b>a pure virtual function because only derived classes using color index mode need to implement it. </p>
<p>
See the sections on GL_COLOR_INDEXES (earlier in this article) and <b>CScene::OnCreatePaletteCI</b> (in "EasyCl Changes," later in this article) for instructions on setting up the palette.</p>
<h3>CGLView Changes</h3>
<p>
In <b>CGLView</b>, I modified <b>CGLView::OnCreate</b> and added <b>CGLView::OnNcCreate</b>, as illustrated in Figure 4.</p>
<p>
<img src="gl4_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Changes to CGLView</b></p>
<p>
I moved the following lines from <b>CGLView::OnCreate</b> to <b>CGLView::OnNcCreate</b>:</p>
<pre><code>pGL = GetGLptr() ;
ASSERT(pGL) ;
</code></pre>
<p>
I moved these lines to simplify using GLlib with color index mode. To use color index mode with GLlib, you must pass PFD_TYPE_COLORINDEX to <b>CGL::Create</b>. <b>CGLView::OnCreate</b> calls <b>CGL::Create </b>with the PFD_TYPE_RGBA parameter. We override <b>CGLView::OnCreate </b>to pass PFD_TYPE_COLORINDEX to <b>CGL::Create </b>in our <b>CGLView </b>derived class. Moving the above lines to <b>CGLView::OnNcCreate</b> means that we have less to remember when implementing the overridden version of <b>CGLView::OnCreate</b>.</p>
<p>
For more information on the overridden version of <b>CGLView::Create</b>, see the explanation of <b>CSceneView::Create</b> in the "CSceneView Changes" section later in this article.</p>
<h2>Changes to EasyCl</h2>
<p>
In creating EasyCI from EasyGL, I had to change functions in both the <b>CScene </b>class and the <b>CSceneView</b> class.</p>
<h3>CScene Changes</h3>
<p>
I changed <b>CScene::OnRender</b> and added <b>CScene::OnCreatePaletteCI</b>, as shown in Figure 5.</p>
<p>
<img src="gl4_5.gif" border=0></p>
<p class=label>
<b>Figure 5. Changes to CScene</b></p>
<h4>CScene::OnRender</h4>
<p>
To make it easier to detect the differences between the EasyGL and EasyCl versions of <b>CScene::OnRender</b>, I separated the new code from the old code with an <b>#if </b>/ <b>#else </b>/ <b>#endif</b> block in EasyCl:</p>
<pre><code>#if COLORINDEX
 &nbsp;&nbsp; glMaterialFv(GL_FRONT, GL_COLOR_INDEXES, matPurple) ;
#else
 &nbsp;&nbsp; glColor3dv(purple);
#endif
</code></pre>
<p>
The EasyCl version of <b>CScene::OnRender</b> differs from the EasyGL version in the following areas:
<ul type=disc>
<li>
·I changed <b>glClearColor</b> to <b>glClearIndex</b>.<br><br></li>
<li>
·I removed <b>glColorMaterial</b>. (It doesn't work in color index mode, so I replaced it with <b>glMaterialfv</b>, as described below.) <br><br></li>
<li>
·I set the material's shininess with <b>glMaterialfv</b>, using the GL_SHININESS parameter.<br><br></li>
<li>
·Instead of using <b>glColor</b>, I used <b>glMaterialfv</b> with the GL_COLOR_INDEXES parameter to set the color.</li>
</ul>
<p>
Refer to the "GL_SHININESS" and "GL_COLOR_INDEXES" sections earlier in this article for more information on these parameters.</p>
<h4>CScene::OnCreatePaletteCI</h4>
<p>
The <b>CScene::OnCreatePaletteCl</b> virtual function is overridden by <b>CScene </b>so that it can create any palette it wants. The virtual function happens to create a purple ramp, a green ramp, and a red ramp. See the "GL_COLOR_INDEXES" section earlier in this article for more information.</p>
<h3>CSceneView Changes</h3>
<p>
I implemented <b>CSceneView::OnCreate</b>, as shown in Figure 6, to pass PFD_TYPE_COLORINDEX to <b>CGL::Create</b>:</p>
<pre><code>int CSceneView::OnCreate(LPCREATESTRUCT lpcs)
{
 &nbsp; if (CView::OnCreate(lpcs) == -1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1 ;

 &nbsp; BOOL bResult = pGL-&gt;Create(this, PFD_TYPE_COLORINDEX) ;
 &nbsp; if (bResult)
 &nbsp;&nbsp;&nbsp;&nbsp; return 0 ;
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; return -1 ;
}
</code></pre>
<p>
<img src="gl4_6.gif" border=0></p>
<p class=label>
<b>Figure 6. Change to CSceneView</b></p>
<p>
Notice that we call <b>CView::OnCreate</b>, not <b>CGLView::OnCreate</b>.</p>
<h2>Conclusion</h2>
<p>
Using color index mode is not more difficult than using RGBA mode, but it is slightly different. OpenGL code that uses RGBA mode can be difficult to convert to color index mode. This is especially true if the code uses many material properties, because color index mode doesn't support most of the material properties, and the properties that it does support are set differently. Converting an application from color index mode to RGBA can also be difficult.</p>
<p>
Choosing color index mode instead of RGBA mode is a simple matter of changing one field in the pixel format descriptor. The application will also need to set up a palette that meets its specific requirements.</p>
<h2>Bibliography</h2>
<h3>Sources of Information on OpenGL</h3>
<p>
Crain, Dennis. <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started."</a> April 1994. (MSDN Library, Technical Articles)</p>
<p>
Neider, Jackie, Tom Davis, and Mason Woo. <i>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1993. ISBN 0-201-63274-8. (This book is also known as the "Red Book".)</p>
<p>
OpenGL Architecture Review Board. <i>OpenGL Reference Manual: The Official Reference Document for OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1992. ISBN 0-201-63276-4. (This book is also known as the "Blue Book".)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: Introducing the OpenGL Interface, Part I." <i>Microsoft Systems Journal</i> 9 (October 1994). (MSDN Library Archive Edition, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: The OpenGL Interface, Part II." <i>Microsoft Systems Journal</i> 9 (November 1994). (MSDN Library Archive Edition, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Understanding Modelview Transformations in OpenGL for Windows NT." <i>Microsoft Systems Journal</i> 10 (February 1995).</p>
<p>
Rogerson, Dale. <a href="msdn_gl1.htm">"OpenGL I: Quick Start."</a>. December 1994. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl3.htm">"OpenGL III: Building an OpenGL C++ Class."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl5.htm">"OpenGL V: Translating Windows DIBs."</a> February 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl6.htm">"OpenGL VI: Rendering on DIBs with PFD_DRAW_TO_BITMAP."</a> April 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl7.htm">"OpenGL VII: Scratching the Surface of Texture Mapping."</a> May 1995. (MSDN Library, Technical Articles)</p>
<p>
Microsoft Win32 Software Development Kit (SDK) for Windows NT 3.5 <i>OpenGL Programmer's Reference</i>.</p>
<h3>Sources of Information on Palettes</h3>
<p>
Gery, Ron. <a href="msdn_palaware.htm">"Palette Awareness."</a> April 1992. (MSDN Library, Technical Articles)</p>
<p>
Gery, Ron. <a href="msdn_palette.htm">"The Palette Manager: How and Why."</a> March 1992. (MSDN Library, Technical Articles)</p>
<p>
Gery, Ron. <a href="msdn_dibpal.htm">"Using DIBs with Palettes."</a> March 1992. (MSDN Library, Technical Articles)</p>
<p>
Rodent, Herman. <a href="msdn_anim32.htm">"Animation in Win32."</a> February 1994. (MSDN Library, Technical Articles)</p>
<p>
Rodent, Herman. <a href="msdn_sprites.htm">"Animation in Windows."</a> April 1993. (MSDN Library, Technical Articles)</p>
<p>
Thompson, Nigel. <i>Animation Techniques for Win32</i>. Redmond, WA: Microsoft Press, 1995. </p>
</BODY>
</HTML>
