<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A Homegrown RPC Mechanism</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_homegrwn"></a>A Homegrown RPC Mechanism</h1>
<p>
Ruediger R. Asche<br>
Microsoft Developer Network Technology Group</p>
<p>
May 9, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4084">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the CLIAPP/SRVAPP sample applications.</a></p>
<h2>Abstract</h2>
<p>
This article is last in a series of technical articles that describe the implementation and application of a C++ class hierarchy that encapsulates the Windows NT™ security application programming interface (API). The series consists of the following articles:</p>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_seccpp">
</object><a href=JavaScript:alink_1.Click()>"Windows NT Security in Theory and Practice"</a> (introduction)</p>
<p>
<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_secguts">
</object><a href=JavaScript:alink_2.Click()>"The Guts of Security"</a> (implementation of the security class hierarchy)</p>
<p>
<object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_bitspcs">
</object><a href=JavaScript:alink_3.Click()>"Security Bits and Pieces"</a> (architecture of the sample application suite)</p>
<p>
"A Homegrown RPC Mechanism" (description of the remote communication implemented in the sample application suite)</p>
<p>
CLIAPP/SRVAPP, a sample application suite that consists of a database client and server, illustrates the concepts introduced in this article series.</p>
<h2>Introduction</h2>
<p>
In <object id=alink_4 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_bitspcs">
</object><a href=JavaScript:alink_4.Click()>"Security Bits and Pieces,"</a> I described the architecture of the CLIAPP/SRVAPP sample application suite that I wrote to demonstrate security programming under Windows NT™. The only missing piece in that article is the discussion of the mechanism that allows the client and server to communicate over the network. This article fills that hole. I will describe the C++ class, <b>CDatabaseProtocol</b>, which is responsible for letting the client and server call each other's functions over the network. The <b>CDatabaseProtocol</b> class hierarchy, in effect, implements a small remote procedure call (RPC) protocol.</p>
<p>
However, RPC is a well-abused buzzword that has several meanings, so here's my disclaimer: This article will not teach you anything about the RPC layer that is provided by Microsoft® operating systems, neither will it teach you to code for that interface. Instead, the article will introduce you to the kinds of problems that any RPC mechanism will need to solve, and will give you the option to code small rudimentary RPC layers for yourself.</p>
<p>
Why do I reinvent the wheel and design my own RPC scheme instead of using the Windows NT RPC layer? There are two answers to this question: One that makes me look good, and one that makes me look like a dinkeldorf.</p>
<p>
Let's start with the charming answer: Of course I know all about RPC, and I could have easily cranked out an application based completely on built-in RPC. However, I decided that introducing RPC with all the security stuff would result in a steep learning curve for readers.</p>
<p>
The not-so-charming answer is that I am a liar. I did not use the RPC layer in Windows NT because I really don't know how to use it. (Well, I built and ran a few RPC applications, but I decided that it was too much work.) Nevertheless, I felt that introducing RPC with all the security stuff would result in too steep a learning curve for readers.</p>
<p>
In either case, I decided to design my own RPC scheme. In a later article, I will simply unplug the networking layer and replace it with one that uses the Windows NT built-in RPC mechanism.</p>
<h2>What Is RPC?</h2>
<p>
To answer this question, let me quote myself from the article <object id=alink_5 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_comclass">
</object><a href=JavaScript:alink_5.Click()>"Communication with Class"</a> in the MSDN Library:</p>
<p class=indent>
<i>And there are only two ways for two computers to communicate: via passing data back and forth or via calling each other's routines—though the latter strategy can be viewed as nothing but a variation of the first.</i></p>
<p>
In the article series that begins with <object id=alink_6 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_comclass">
</object><a href=JavaScript:alink_6.Click()>"Communication with Class,"</a> I describe the first communication strategy (passing data back and forth). If you look at the definition of the <b>CCommunication</b> class hierarchy, you will find that all classes in this hierarchy support the <b>Read</b> and <b>Write</b> members for sending and receiving data over a communication channel; thus, we are dealing with a data-exchange mechanism only.</p>
<p>
RPC, very roughly, is a mechanism that allows one process to invoke a function that executes in another process. Let us look at the prototype of the <b>CDatabaseProtocol</b> hierarchy class to see what I mean by that:</p>
<pre><code>class CDatabaseProtocol&nbsp;&nbsp;&nbsp; : public CProtocol
{
 private:
  CClientCommunication *m_cBothways;
 public:
  CDatabaseProtocol(CClientCommunication *);
  BOOL Open(const char* pszFileName, UINT nOpenFlags,
 &nbsp;&nbsp;&nbsp;&nbsp; CFileException* pError = NULL);

  UINT Read(void FAR* lpBuf, UINT nCount);
  void Write(const void FAR* lpBuf, UINT nCount);
  void Close();
};

class CClientDatabaseProtocol : public CDatabaseProtocol
{

 public:
  CClientDatabaseProtocol(CClientCommunication *);
  BOOL AddData(int *iIndex,CHAINLIST *clElement);
  BOOL RemoveData(int iIndex);
  BOOL RetrieveData(int iIndex, CHAINLIST *cpResult);
  BOOL GetEntries(int *);
  BOOL Terminate();

};

#ifdef SERVER

class CServerDatabaseProtocol&nbsp;&nbsp;&nbsp; : public CDatabaseProtocol
{ 
 public:
  CServerDatabaseProtocol(CServerCommunication *);
  BOOL AcceptCommand(int *iCommand, CHAINLIST *cpElement, int *iIndex);
  BOOL ProcessCommand(CHAINLIST *cpElement, int *iIndex);
  BOOL Fail(int iErrorCode);
  BOOL Acknowledge(int iIndex);
};


#endif
</code></pre>
<p>
Remember what the CLIAPP/SRVAPP sample application suite does: The database that both the client and server work on resides on the server, but the database operations are accessible from both the client and the server. In other words, the server can call Insert, Delete, and Retrieve operations (recall that the database itself is implemented in the <b>ChainedQueue</b> object, which provides the <b>Insert</b>, <b>Retrieve</b>, and <b>Remove </b>member functions), and the client can also call the same set of operations—namely, <b>CClientDatabaseProtocol::AddData</b>, <b>CClientDatabaseProtocol::RemoveData</b>, and <b>CClientDatabaseProtocol::RetrieveData</b>. </p>
<p>
The client, when working on the database, is not aware of the location of the database; it simply uses a functional interface that hides all of the details from the client application. (Note that the client calls a function that performs an operation on a database, which resides somewhere far away from the client, possibly somewhere on the network.)</p>
<p>
This is basically what RPC is all about—it provides a mechanism for encoding a functional interface over the network. You can implement an RPC mechanism in many ways. The one I provide is very rudimentary, but it shows two pitfalls that you must take into consideration when designing functional interfaces across networks:
<ul type=disc>
<li>
The interface must be logically separated from the network transport. In other words, a change in the underlying network bindings must not require any changes to the RPC code.<br><br></li>
<li>
The RPC layer may have to convert any compound structures passed to functions before sending them over the network. Here is a simple example: Imagine that we want to implement an RPC function with the following prototype:<pre><code>void RPCFunc(WEIRDSTRUCT ws);
</code></pre>
<p class=tl>
where <b>WEIRDSTRUCT</b> is any structure that contains indirect references (that is, pointers). Pointers are valid only within the context of the current application, so if we simply passed <b>WEIRDSTRUCT</b> over the network, the pointer would not make any sense on the receiving end of the function. Even worse, for the pointer to make sense, we must pack up whatever structure it points to, send it over the network as well, reassemble both structures on the receiving end, and correctly adjust the pointer in the copy of <b>WEIRDSTRUCT</b>.</P></li>
</ul>
<p>
Uh-oh. Weird thoughts come to mind: What about calls by reference? What about functions that operate on large chunks of memory? How do we know what to copy? Will we run into situations that require copying megabytes of memory from one machine to the other? These nasty thoughts are only the tip of the iceberg: Just imagine what would happen if a structure that you copied back and forth had to be serialized between the two processes—how do you claim a "remote mutex" to ensure mutual exclusion on the shared data structure? How do you ensure that the client does not hang if the RPC layer does not claim this mysterious "remote mutex" (once we know how to implement and use it), and the network dies? How do you implement decent error handling that catches network problems as well as the expected error returns?</p>
<h2>RPC Architecture in the Sample Application Suite</h2>
<p>
The way RPC is implemented in the sample application suite is surprisingly straightforward—there are only two C++ class hierarchies, one of which (the <b>CNamedPipe</b> hierarchy) has already been discussed in detail (see <object id=alink_7 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_npipes">
</object><a href=JavaScript:alink_7.Click()>"Garden Hoses at Work"</a>). By the way, nothing forces the communication object to be a named pipe except for the fact that named pipes are easiest to secure in the Windows NT security model. For the sake of the RPC implementation, the RPC mechanism could be built around any other derivative of <b>CClientCommunication</b> (that is, a <b>CClientNetBIOS</b> or <b>CClientSocket</b> object, or any other derivative of <b>CClientCommunication</b> that you care to implement).</p>
<p>
The other group of classes that is used to implement the RPC layer is <b>CDatabaseProtocol</b> and its derivatives, <b>CServerDatabaseProtocol</b> and <b>CClientDatabaseProtocol</b>. I have already introduced the base class, <b>CProtocol</b>, in the article <object id=alink_8 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_comclass">
</object><a href=JavaScript:alink_8.Click()>"Communication with Class,"</a> where I used protocol objects to implement file transfer and chat abstractions over <b>CCommunication</b> objects.</p>
<p>
In fact, I like to think of <b>CProtocol</b> derivatives as objects that translate some kind of object-specific data exchange into raw data exchange with the communication object. Sounds confusing? Recall the prototypes for the <b>CDatabaseProtocol</b> class hierarchy. Note that the member functions supported by the client side of the protocol (<b>CClientDatabaseProtocol</b>) are identical to the functions supported by the <b>ChainedQueue</b> class, which implements our little homegrown database. In other words, all that the client application "sees" of the RPC mechanism is an interface that looks exactly like the one that operates on the database. </p>
<p>
However, to the network, the data looks considerably different. No matter which communication object we use to take care of the data transport, the network level contains no such thing as a "database," but only a raw stream of data to be sent back and forth. The protocol objects are responsible for translating the database API (or whatever API the RPC layer chooses to implement) into a communication API that the <b>CCommunication</b> object understands (which is simply <b>Read</b> and <b>Write</b>).</p>
<p>
Let's see how the <b>AddData</b> function works on the client side to get an understanding of what's going on (from PROTOCOL.CPP):</p>
<pre><code>BOOL CClientDatabaseProtocol::AddData(int *iIndex, CHAINLIST *clElement)
  { 
 &nbsp; int iData;
 &nbsp; // First write the stuff out.
 &nbsp; iData = CMD_ADDRECORD;
 &nbsp; _try
 &nbsp; {
 &nbsp; Write((char *)&amp;iData,sizeof(int));
 &nbsp; Write((char *)&amp;clElement-&gt;iSecuredElement,sizeof(int));
 &nbsp; Write((char *)&amp;clElement-&gt;iInsecuredElement,sizeof(int));
 &nbsp; // Then wait for the response.
 &nbsp; Read((char *)&amp;iData,sizeof(int));
 &nbsp; if (iData == CMD_SUCCESS) 
 &nbsp;&nbsp; {
 &nbsp;&nbsp; Read ((char *)iIndex,sizeof(int));
 &nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp; }
 &nbsp; else 
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; Read((char *)&amp;m_iErrorCode,sizeof(int));
 &nbsp;&nbsp; return FALSE;
 &nbsp; };
 &nbsp; }
 &nbsp; _except (EXCEPTION_EXECUTE_HANDLER)
 &nbsp; {
 &nbsp;&nbsp; m_iErrorCode = GetExceptionCode();
 &nbsp; };
 &nbsp; return FALSE;
  };
</code></pre>
<p>
The code first writes a command identifier (in this case, CMD_ADDRECORD) to the server. The server uses this command identifier to discriminate between commands. The client "flattens out" the data record to be transmitted by sending each of the elements individually, and then waits for a response from the server. The <b>RemoveRecord</b> and <b>RetrieveRecord</b> members work in a similar way.</p>
<p>
Let's look at the server side of the transaction (also from PROTOCOL.CPP):</p>
<pre><code>BOOL CServerDatabaseProtocol::AcceptCommand(int *iCommand, CHAINLIST *cpElement, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *iIndex)
  {
 &nbsp; _try
 &nbsp; {
 &nbsp; if (Read((char *)iCommand,sizeof(int))!=sizeof(int)) return FALSE;
 // Fetch the command first.
 &nbsp; switch (*iCommand)
 &nbsp; { case CMD_ADDRECORD:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Read ((char *)&amp;cpElement-&gt;iSecuredElement,sizeof(int))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !=sizeof(int)) return FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp; if (Read ((char *)&amp;cpElement-&gt;iInsecuredElement,sizeof(int))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !=sizeof(int)) return FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp; case CMD_DELETERECORD:
 &nbsp;&nbsp;&nbsp;&nbsp; if (Read((char *)iIndex,sizeof(int))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !=sizeof(int)) return FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp; case CMD_RETRIEVERECORD:
 &nbsp;&nbsp;&nbsp;&nbsp; if (Read((char *)iIndex,sizeof(int))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !=sizeof(int)) return FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp; case CMD_GETENTRIES:
 &nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp; }; // switch 
 &nbsp; return TRUE;
 &nbsp; }
 &nbsp; _except (EXCEPTION_EXECUTE_HANDLER)
 &nbsp; {
 &nbsp;&nbsp; m_iErrorCode = GetExceptionCode();
 &nbsp; };
 &nbsp;&nbsp; return FALSE;
  };
</code></pre>
<p>
The <b>AcceptCommand</b> member function listens on [to?] the associated communication object and "decodes" an incoming request. The parameters for the <b>AcceptCommand</b> member specify addresses of variables that will receive the command identifier as well as provide additional information. For example, for an add record request, the CHAINLIST member stores the record that the client wants to add. </p>
<p>
How is <b>AcceptCommand</b> used? Let us look at SRVVIEW.CPP:</p>
<pre><code>long WINAPI PipeThreadFunction(CNpscesrvView *cvTarget) 
{ char szDiagnosticMessage[255];
  CServerDatabaseProtocol *cpProt;
  BOOL bFinished;
  ServerChainedQueue *cqTheQueue = cvTarget-&gt;m_cqQueue;
  if (!cvTarget-&gt;m_cpPipe-&gt;AwaitCommunicationAttempt())
  { 
  cvTarget-&gt;DisplayTextErrorMessage("Open named pipe failed -- %s",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvTarget-&gt;m_cpPipe-&gt;m_iErrorCode);
  goto ErrorExit;
  }
  else
  {
  sprintf(szDiagnosticMessage,"Open named pipe succeeded");
  cvTarget-&gt;AddStringandAdjust(szDiagnosticMessage);
  }
  // Acknowledge communication to the UI.
  cpProt = new CServerDatabaseProtocol(cvTarget-&gt;m_cpPipe);
  if (!cpProt-&gt;Open("",CFile::modeReadWrite)) // We are server...
  // Log an error here.
 &nbsp;&nbsp; goto ErrorExit;
  int iCommand,iIndex;
  CHAINLIST cpElement;
  bFinished=FALSE;
  while (!bFinished)&nbsp; // We'll break out of this loop later...
  {
 &nbsp; if (!cpProt-&gt;AcceptCommand(&amp;iCommand,&amp;cpElement,&amp;iIndex))
 &nbsp; { 
 &nbsp;&nbsp;&nbsp; cvTarget-&gt;DisplayTextErrorMessage("accepting command from named pipe failed 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- %s",cpProt-&gt;m_iErrorCode);
 &nbsp;&nbsp;&nbsp; bFinished = TRUE;
 &nbsp;&nbsp;&nbsp; continue;
 &nbsp; };
 &nbsp; switch (iCommand)
 &nbsp; { case CMD_EXIT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvTarget-&gt;AddStringandAdjust("Client terminated connection!");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bFinished=TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; case CMD_GETENTRIES:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpProt-&gt;Acknowledge(cqTheQueue-&gt;GetEntries());
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; case CMD_ADDRECORD:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!cqTheQueue-&gt;SafeInsert(&amp;iIndex,&amp;cpElement))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvTarget-&gt;DisplayTextErrorMessage("Remote insert failed; propagating 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error code -- %s",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cqTheQueue-&gt;m_iErrorCode);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpProt-&gt;Fail(cqTheQueue-&gt;m_iErrorCode);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpProt-&gt;Acknowledge(iIndex);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvTarget-&gt;AddStringandAdjust("Remote insert succeeded!");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; case CMD_DELETERECORD:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!cqTheQueue-&gt;SafeRemove(iIndex))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvTarget-&gt;DisplayTextErrorMessage("Remote remove failed; propagating 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error code -- %s",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cqTheQueue-&gt;m_iErrorCode);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpProt-&gt;Fail(cqTheQueue-&gt;m_iErrorCode);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpProt-&gt;Acknowledge(0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvTarget-&gt;AddStringandAdjust("Remote remove succeeded!");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; case CMD_RETRIEVERECORD:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!cqTheQueue-&gt;SafeRetrieve(iIndex,&amp;cpElement))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvTarget-&gt;DisplayTextErrorMessage("Remote retrieve failed; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propagating error code -- 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %s",cqTheQueue-&gt;m_iErrorCode);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpProt-&gt;Fail(cqTheQueue-&gt;m_iErrorCode);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpProt-&gt;Acknowledge(cpElement.iInsecuredElement);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpProt-&gt;Acknowledge(cpElement.iSecuredElement);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvTarget-&gt;AddStringandAdjust("Remote retrieve succeeded!");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; }; // switch
 &nbsp;&nbsp; };&nbsp;&nbsp; // while
 cpProt-&gt;Close();
 delete (cpProt);
 cvTarget-&gt;m_cpPipe-&gt;CloseInstance();
 ErrorExit:
 CloseHandle(cvTarget-&gt;m_hThread);
 cvTarget-&gt;m_bThreadIsActive = FALSE;
 return 0;
};&nbsp;&nbsp;&nbsp; // Thread fn
</code></pre>
<p>
On the server side, the logic for responding to client requests is located in a secondary thread whose thread function we just saw. The thread repeatedly calls <b>AcceptCommand</b> on its associated <b>CServerDatabaseProtocol</b> object until it encounters the CMD_TERMINATE command identifier. Each command is dispatched to the associated database object. Note that by using the <b>SafeInsert</b>, <b>SafeRemove</b>, and <b>SafeRetrieve</b> members of the <b>ChainedQueue</b> database object, the security check is made in these members; if access to the database is denied, the code sends the appropriate error code to the client.</p>
<p>
After processing a command, the server either sends a failure code for the client to scrutinize, or sends a success code, possibly including more information (such as the values of the retrieved element in response to a Retrieve request). The server side of the <b>CDatabaseProtocol</b> class supports the two members <b>Fail(int iErrorCode)</b> and <b>Acknowledge(int iVal)</b> for this purpose. </p>
<p>
Note that the "serialization" of data structures (that is, the conversion from an arbitrary data structure to a "raw" stream of bytes and vice versa) can be anything between a no-brainer and a nightmare, depending on the complexity of the data structures to be transferred between the server and client processes. In the CLIAPP/SRVAPP application suite, the serialization is a no-brainer, because I kept my sample database very simple. More complex data structures naturally involve more work. One way to simplify the task would be to delegate serialization to, say, a <b>Serialize</b> member function. Nigel Thompson demonstrates this technique in his article <object id=alink_9 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_ddlist">
</object><a href=JavaScript:alink_9.Click()>"Simple Drag and Drop for List Boxes in 32-Bit Visual C++ Applications"</a> in the MSDN Library.</p>
<h2>Summary</h2>
<p>
The database architecture that is used to demonstrate security in the CLIAPP/SRVAPP sample application suite is rather primitive. As a result, an RPC layer that implements remote database operations on this architecture can be designed rather easily. The separation between communication objects and protocol objects provides an elegant and clean framework for translating complex and "raw" interfaces back and forth. </p>
<p>
Derivatives of the protocol object may have to be considerably more complex to accommodate more elaborate interfaces.</p>
<p>
Although the protocol/communication RPC architecture I provided is not as powerful as the built-in RPC mechanism in Windows NT, you can use this architecture to implement simple functional client-server interactions.</p>
</BODY>
</HTML>
