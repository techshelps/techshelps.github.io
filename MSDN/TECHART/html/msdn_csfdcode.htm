<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Client/Server Solutions: Coding Guidelines</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_csfdcode"></a></sup>Client/Server Solutions: Coding Guidelines</h1>
<p>
Ken Bergmann<br>
Microsoft Developer Network Technology Group</p>
<p>
September 29, 1995</p>
<h2>Abstract</h2>
<p>
This technical article illustrates and discusses several fundamental coding practices and guidelines recommended for developing client/server solutions in Visual Basic. It is part of a series beginning with the article <a href="msdn_csarctop.htm">"Client/Server Solutions: The Architecture Process,"</a> also available in the Microsoft® Development Library.</p>
<h2>Overview</h2>
<p>
The following are practices and techniques that should be used when writing Visual Basic code. Most of the items do not deal with style, but with proven techniques for writing solid code. The more habitual that good coding practices become for you, the easier it will be to read and modify your code. Standard techniques and practices also help in debugging and sharing code among programmers. Using these standards should provide some commonality among programming styles that otherwise might differ greatly.</p>
<p>
You can modify these ideas to fit your individual coding style and the stability level of the project. Common sense should dictate which suggestions should be rules for code review and which are optional guidelines.</p>
<p class=label>
<b>Table 1. Default Settings</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Item</b></td>
<td class=label width=80%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=20%><b>Option Explicit</b></td>
<td width=80%>This is pretty standard. Always put this in every module and every form.</td>
</tr>
<tr valign=top>
<td width=20%><b>Option Compare</b></td>
<td width=80%>String comparisons are handled differently depending on how this is set; therefore, always explicitly set this value in modules and forms.</td>
</tr>
<tr valign=top>
<td width=20%><b>Option Base</b></td>
<td width=80%>This changes what the default lower bound of arrays is set to. Always explicitly set this value in modules and forms.</td>
</tr>
<tr valign=top>
<td width=20%><b>DefVar</b></td>
<td width=80%>This will declare variables without type definitions to be a particular type. Always explicitly declare all variables to be of a certain type. Also define the defaults.</td>
</tr>
<tr valign=top>
<td width=20%>Text</td>
<td width=80%>Always save all files as text. This will make available the many tools that utilize Visual Basic code stored as text. Examples are analyzers, source control systems, etc. Also in the case of reconstruction or reuse, text files are easier to manipulate than binary data files.</td>
</tr>
</table><br>
<p class=label>
<b>Table 2. External Declarations</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Item</b></td>
<td class=label width=80%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=20%>Declaration organization</td>
<td width=80%>External declarations should be grouped consistently and all should be included in the same module. Any grouping convention may be used as long as consistency is maintained. Some common groupings would be by library or by task type.</td>
</tr>
<tr valign=top>
<td width=20%>Pointers to strings</td>
<td width=80%>Pointers to strings are common when using API functions. Because Visual Basic handles strings differently and because Visual Basic lacks pointers, you must handle these situations specially. Use the <b>STRCPY</b> API function to copy from a long pointer to a string. When copying a pointer to other data types, including user-defined data types (UDTs), use the <b>MEMCPY</b> API function.</td>
</tr>
</table><br>
<p class=label>
<b>Table 3. Operations</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Item</b></td>
<td class=label width=80%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=20%>Proper operator</td>
<td width=80%>Always use the proper operator for the data types involved. Always use the ampersand (&amp;) when concatenating strings and the plus sign (+) when adding numeric values. If you use variants, it is possible to add two strings together and mistakenly produce a number instead of concatenating strings together.</td>
</tr>
<tr valign=top>
<td width=20%>Explicit conversion</td>
<td width=80%>Always explicitly convert values to the appropriate data types before operating on them. This is essential when working with variants. The <b>Val()</b> function is a good general purpose number conversion routine. However, the standard <b>CStr</b>, <b>CLng</b>, and <b>Ccur</b> functions are considered the most proper of all forms.</td>
</tr>
<tr valign=top>
<td width=20%>String comparisons</td>
<td width=80%>Using strings for comparisons is not recommended. If you must do this, however, I would suggest that you apply the <b>UCase(Trim$())</b> formula to both sides of the comparison. This will ensure a case-insensitive, nonwhite-spaced (leading or trailing) comparison.</td>
</tr>
<tr valign=top>
<td width=20%>Control usage</td>
<td width=80%>Never load list boxes, combo boxes, or grids with more than one hundred (100) static items. A good rule is that if there are more than fifty (50) items, use a virtual load or use a searchable system. One technique is to have a text box in which to enter the first few characters. Then when the focus leaves or the drop down is triggered, execute the search using the text as a filter and so limit the contents of the controls.</td>
</tr>
<tr valign=top>
<td width=20%>Control loading</td>
<td width=80%>Most of the time needed to load controls is required by the paint events as data changes. Because of this, it is wise when loading controls, such as list boxes or grids, to either make the control invisible or—better still—turn off the redrawing of the control. Then, once the data is properly loaded, the control can be redrawn. This can be done easily with the <b>SendMessage</b> API function.</td>
</tr>
<tr valign=top>
<td width=20%><b>Select Case</b></td>
<td width=80%>Using a <b>Select Case</b> instead of multiple <b>If</b> statements adds to readability and an increase in performance. <b>Select Case</b> statements are the preferred method for branching execution when there are more than three possible branches. Remember to cover all inputs. Always have an <b>Else Case </b>defined, and make sure that all criteria that can be handled are handled cleanly. Defined ranges are often helpful for covering all possible inputs.</td>
</tr>
<tr valign=top>
<td width=20%>Resource usage</td>
<td width=80%>When using file handles or memory, always close the files and release memory. When using file handles, call <b>FreeFile</b> to reserve a handle. Always restore system property settings if you use them.</td>
</tr>
<tr valign=top>
<td width=20%>Transaction usage</td>
<td width=80%>When using transactional logic or <b>BeginTrans</b> syntax, make sure that the logic begins and ends in the same function. For the <b>BeginTrans</b> syntax, this is required. For custom logic, it adds readability, consistency, and simplicity.</td>
</tr>
<tr valign=top>
<td width=20%>Loops</td>
<td width=80%>Every loop should have well-defined, obtainable, termination criteria. This is especially true in algorithms that require recursion.</td>
</tr>
</table><br>
<p class=label>
<b>Table 4. Variable Usage</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Item</b></td>
<td class=label width=80%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=20%>Array declaration</td>
<td width=80%>You should always use the lower to upper syntax as in <b>iArray(0 to 10)</b>. By explicitly defining the lower and upper bounds of static arrays, the impact of the <b>Option Base</b> statement can be removed.</td>
</tr>
<tr valign=top>
<td width=20%>Array traversal</td>
<td width=80%>Because of the flexibility in array dimensioning and the availability of the <b>Option Base</b> statement, always use the <b>LBound()</b> and <b>UBound()</b> functions as starting and ending points when traversing an array from top to bottom. It is <i>not </i>recommended that you store the upper and lower bounds in variables. The <b>LBound()</b> and <b>UBound()</b> functions are the only ways to guarantee accuracy through <b>ReDim</b> statements.</td>
</tr>
<tr valign=top>
<td width=20%>String literals</td>
<td width=80%>When using the same string literal more than three (3) times, you should implement the literal as a constant. This offers several benefits: compactness (constants require less memory for storage), efficiency (operations involving constants are much faster), and modularization (changes to the literal are confined to one place).</td>
</tr>
<tr valign=top>
<td width=20%>Scoping technique</td>
<td width=80%>A general rule of thumb when deciding on the scope of a variable is: Give it as little scope as possible. If the variable is used in only one function, limit the scope to that function. If it is only used in one module, limit the scope to that module. Consider reorganizing code to follow these techniques while ensuring that your organization fits the requirements of the layered paradigm.</td>
</tr>
<tr valign=top>
<td width=20%>Scoping initialization</td>
<td width=80%>Ensure that any variables that are not locally scoped are initialized before they are used. Variables that are of higher than local scope may be changed during the execution of a procedure.</td>
</tr>
</table><br>
<p class=label>
<b>Table 5. Syntax and Structure</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Item</b></td>
<td class=label width=80%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=20%>Variable declaration</td>
<td width=80%>Declare all variables on a separate line. Explicitly declare the type of each variable as you declare it. This enhances readability, offers easier debugging, and leads to fewer type definition errors.</td>
</tr>
<tr valign=top>
<td width=20%>Executable statements</td>
<td width=80%>All executable statements should be on separate lines. While the Visual Basic processor accepts several statements separated by colons included on the same line, it is considered bad form. You should adopt readability as an important goal for the structure and syntax of your code; therefore, don't use shortcuts like this to simply conserve space.</td>
</tr>
<tr valign=top>
<td width=20%><b>Goto</b> statements</td>
<td width=80%>When writing structured code, avoid the use of <b>Goto</b> statements. There are special cases where the use of <b>Goto</b> statements can be considered acceptable and proper—for example, in error handling. However, you should limit your use of these statements to one or two labels per function and should uphold the guidelines on usability.</td>
</tr>
<tr valign=top>
<td width=20%>Parentheses</td>
<td width=80%>Use parentheses in statements with care. For example, you should always use parentheses to force the order of evaluation when necessary. You might also use parentheses when you decide that the code would be more readable because of tricky precedence or to qualify information for operations. In Visual Basic, the use of parentheses introduces an extra step in the operation. A memory copy is performed, and the remainder of the operation is applied to the copy of the result of the operation within the procedure. You can take advantage of this copy functionality when writing critical code to ensure that operations don't change the value of a variable, but operate on a copy of the variable instead. Of course, this advantage comes at a slight expense in the performance of operations.</td>
</tr>
<tr valign=top>
<td width=20%>Naming the main module</td>
<td width=80%>When naming the main module of a project, always give the primary module the same name as the executable name. This allows for cross-project consistency and for easier work transference. It establishes a common starting point for all applications.</td>
</tr>
</table><br>
<p class=label>
<b>Table 6. Formatting</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Item</b></td>
<td class=label width=80%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=20%>Consistency</td>
<td width=80%>Consistency is rule number one!</td>
</tr>
<tr valign=top>
<td width=20%>Headers</td>
<td width=80%>Every module and every function in every module should have a header. Some information for the header is: Description, Inputs, Outputs, External Function Calls, External References, Revision history.<br>
Comments are very important for understanding process flow and other settings, especially during debug, and maintenance phases of application development. Inline comments are good for covering key areas of complexity. Header comments are used primarily to outline complex algorithms or routines.</td>
</tr>
<tr valign=top>
<td width=20%>Error trapping</td>
<td width=80%>Every function should have an enabled error handler. In cases where failure is a simple exit, this lets you institute more complex error handling easily, with a minimum of changes.</td>
</tr>
<tr valign=top>
<td width=20%>Naming conventions</td>
<td width=80%>It is considered proper when naming functions and controls to use a naming convention. Some recommended conventions are &lt;object&gt;&lt;verb&gt; or &lt;verb&gt;&lt;object&gt;. The choice is usually dictated by the vertical organization of the relevant code. For example: If several routines to retrieve data for several objects are included in the same module, I suggest you use &lt;verb&gt;&lt;object&gt; naming such as: <b>GetCustomer</b>, <b>GetProduct</b>, <b>GetOrders</b>, and so forth. However if the routines to support a single object all reside in the same module, it is considered proper to use &lt;object&gt;&lt;verb&gt; naming such as: <b>CustomerLoad</b>, <b>CustomerUpdate</b>, <b>CustomerInsert</b>, and so forth.</td>
</tr>
<tr valign=top>
<td width=20%>Indentation</td>
<td width=80%>It's a good idea to indent your code to indicate the flow of control. Don't, however, indent the base level. The first level of code should be on the margin with no preceding tabs. Code that resides inside an <b>If...Then...Else</b> statement should be indented one tab.</td>
</tr>
</table><br>
<p class=label>
<b>Table 7. Procedure Organization</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Item</b></td>
<td class=label width=80%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=20%>Consistency</td>
<td width=80%>Consistency is rule number one!</td>
</tr>
<tr valign=top>
<td width=20%>Defined inputs and outputs for functions</td>
<td width=80%>Every function should have a defined range for each input and a defined range for acceptable success and error return values. It is critical that the return ranges be defined, attainable, and nonoverlapping.</td>
</tr>
<tr valign=top>
<td width=20%>Input value checking</td>
<td width=80%>Every procedure should perform range checking validation on all input values. This will often simplify algorithms and logic in the remainder of the routine. This practice will also allow you to catch and return error conditions as early as possible. By catching input range errors before commencing complex algorithms or logic, you can do cleanup and create graceful exit procedures with minimal logic impact.</td>
</tr>
<tr valign=top>
<td width=20%>Parameter lists</td>
<td width=80%>Procedures that perform similar functions or tasks should have similar parameter lists and output values. This level of consistency lends itself readily to reusable and maintainable code.</td>
</tr>
<tr valign=top>
<td width=20%>Modularize code</td>
<td width=80%>Code that is repeated or duplicated should be modularized. The general rule of thumb is that any code statement repeated more than three (3) times should be put in a separate routine. Similarly, code that exists in more than two (2) modules should be consolidated and generalized for reuse.</td>
</tr>
<tr valign=top>
<td width=20%>Procedure depth</td>
<td width=80%>Procedures calling other procedures should not require too many levels of procedure nesting. A general rule of thumb is that the procedure depth should not exceed six (6) levels.</td>
</tr>
</table><br>
<p class=label>
<b>Table 8. Writing Process</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Item</b></td>
<td class=label width=79%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=21%>Consistency</td>
<td width=79%>Consistency is rule number one!</td>
</tr>
<tr valign=top>
<td width=21%>Define coding goals</td>
<td width=79%>You should always have a defined list of objectives for each portion of code you write. Always reevaluate any code when you don't have a specific goal for its use. Never write code to provide a particular solution if the general case solution is as simple.</td>
</tr>
<tr valign=top>
<td width=21%>Generalization</td>
<td width=79%>Before writing new code, always clearly think through the uses for the code and consider whether you can write it in a reusable fashion. Custom code is usually the easiest to write, but is almost never the easiest to maintain or reuse.</td>
</tr>
<tr valign=top>
<td width=21%>Code reviews</td>
<td width=79%>Always review new code before releasing. Formal reviews are good, but not always practical. At a minimum, have all work read over by one of your peers to check for consistency and general appearance. Code that is poorly organized or isn't well commented can be spotted easily without intimate knowledge of the code. This quick once-over by another developer will serve as a good sanity check to prevent you from releasing substandard code to others. This is especially important in high stress situations with code that is quickly written. Never review more than two thousand (2000) lines of code at any one time: It's difficult to do a good job of reviewing such an unwieldy amount.</td>
</tr>
<tr valign=top>
<td width=21%>Code analysis</td>
<td width=79%>Code that is being put into production should be run through analyzers or profilers. If it is a front-end application for a database system, it should also be thoroughly benchmarked. Analyzers can tell a lot about the design of code by generating statistics about the code, such as executable-to-comment ratios, lines per module, local-to-global variable usage, literal usage frequency, and module level function break downs. Analyzers should also be used to generate call trees and relationship diagrams. These are helpful for graphically understanding the organization and structure of the code. </td>
</tr>
<tr valign=top>
<td width=21%>Code testing</td>
<td width=79%>Never test more than three (3) functions at a time. It is important for code coverage purposes that your testing be as focused as possible. By keeping the number of function jumps to a minimum, you can more effectively scrutinize the focus areas.</td>
</tr>
</table><br>
<h3>Class-level Concepts</h3>
<p>
These ideas are more suited to C++ developers, but with the changes in the Visual Basic language, developers using either language can benefit from these concepts.</p>
<h4>Class Definitions</h4>
<ul type=disc>
<li>
Class interfaces should be as consistent as possible.<br><br></li>
<li>
Each class should describe a set of objects.<br><br></li>
<li>
Each class should serve a single, coherent, described purpose.<br><br></li>
<li>
Class interfaces should always be complete and as minimal as required.<br><br></li>
<li>
Classes should have as narrow a focus as possible.<br><br></li>
<li>
Base classes should contain only members that apply to all derivations.<br><br></li>
<li>
Base classes should contain only members that are used by all derivations.<br><br></li>
<li>
Classes should have as little coupling and interaction with other classes as possible.</li>
</ul>
<h4>Class Implementation</h4>
<ul type=disc>
<li>
Every class should have a copy constructor defined.<br><br></li>
<li>
Every class should have a defined assignment operator.<br><br></li>
<li>
Class constructors should put the constructed objects in well defined states.<br><br></li>
<li>
Class destructors should adequately clean up after themselves.<br><br></li>
<li>
Destructors in base classes should be defined as virtual.<br><br></li>
<li>
Destructors should never call anything that might raise errors unless they can be dealt with.<br><br></li>
<li>
Every class assignment operator should assign all members.<br><br></li>
<li>
Member functions should not return references to members less accessible than themselves.</li>
</ul>
<h4>Objects</h4>
<ul type=disc>
<li>
Objects should be designed for abstraction, not modularization.<br><br></li>
<li>
Collections of functions do not constitute an object.<br><br></li>
<li>
Objects that are independent should have independent behavior.<br><br></li>
<li>
Objects whose purpose is strictly management usually indicate poor design.<br><br></li>
<li>
Object states should be defined consistently.<br><br></li>
<li>
Object error states should always be strictly and completely defined.<br><br></li>
<li>
Special care should be taken when objects become multidimensional. These usually involve multiple versions or an element of temporal relationship.<br><br></li>
<li>
Objects that are services should not look for resources. Objects that are resources should register themselves with the services.</li>
</ul>
<h4>Relationships</h4>
<ul type=disc>
<li>
Take notice of the cardinality of defined relationships. They should always be delineated using the 1:1, 1:M, or M:M notations.<br><br></li>
<li>
The constraints on a relationship should always be strictly delineated along with the attributes of the constraint: Required, Unique, Distinct, Max, Min.<br><br></li>
<li>
Always distinguish an ISA relationship from an HASA relationship—to use Rumbaugh notation. (The notation isn't important, but distinguishing the relationship is.)<br><br></li>
<li>
Relationships should be defined inside Get and Set functions of the associated classes. <br><br></li>
<li>
Always consider both sides of a defined relationship. If one side is not implemented, this decision should be properly noted and explanations provided.</li>
</ul>
</BODY>
</HTML>
