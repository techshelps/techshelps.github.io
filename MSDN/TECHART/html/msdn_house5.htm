<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFC/COM Objects 5: Using Multiple Inheritance</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_house5"></a></sup>MFC/COM Objects 5: Using Multiple Inheritance</h1>
<p>
Nigel Thompson<br>
Microsoft Developer Network Technology Group</p>
<p>
March 20, 1995</p>
<h2>Abstract</h2>
<p>
This technical article is the fifth in a series that describes creating and using 32-bit Component Object Model (COM) objects with Visual C++™ and the Microsoft® Foundation Class Library (MFC). This article looks at using multiple inheritance to create COM objects. There is no sample code with this technical article.</p>
<h2>Introduction</h2>
<p>
In the first article of this series (<a href="msdn_house1.htm">"MFC/COM Objects 1: Creating a Simple Object"</a>), I described how to create a Component Object Model (COM) object using the tools and macros provided with the Microsoft® Foundation Class Library (MFC). If you are familiar with C++, you may well have asked why we needed to use nested classes to define interfaces, when simply inheriting from multiple base classes would have simplified things tremendously. That's what I thought, too, until I did some research into what it would take to create a COM object that used MFC classes, but was based on a multiple inheritance (MI) design. Inasmuch as you may be considering an MI approach yourself, I thought I'd pass on what I learned to help you make a more informed decision.</p>
<p>
So the question is: "Can I use multiple inheritance to create COM objects that also use the MFC classes?" There are two answers. The short answer is "Yes," but you'll lock yourself out from being able to use any of the Visual C++™ wizards to add support for OLE Automation. The second answer is a bit longer. . . .</p>
<h2>The Long Answer</h2>
<p>
The "Cairo" group at Microsoft is working on the next major version of Windows NT™, which is based largely on COM objects. This group has decided to use multiple inheritance in creating at least some of its COM objects. To support this, they created a standard COM object class from which other objects can be derived. The base class supports the <b>IUnknown</b> interface and deals with object aggregation as well as implementing table-driven support for the <b>QueryInterface </b>function. Part of the support also includes a standard class for creating class factories for the objects.</p>
<p>
Using the "Cairo" group base classes, one can create a COM object by deriving from the standard object base class and also from any interface classes the object supports.</p>
<pre><code>class CMyObject : public CStdComponentObject,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IMyOwnInterface,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public ISomeOtherInterface
{
 &nbsp; [...]
};
</code></pre>
<p>
In the implementation of the class, macros are used to create a static class factory object derived from <b>CStdClassFactory</b>. The class factory keeps a list of all interfaces supported by the object either directly (<b>IMyOwnInterface</b> and <b>ISomeOtherInterface</b> above) or indirectly through the aggregation of other COM objects.</p>
<p>
The <b>CStdClassFactory</b> implementation also supplies the <b>DllCreateClassObject</b> and <b>DllCanUnloadNow</b> functions required in any dynamic-link library (DLL) that can provide COM objects.</p>
<p>
So using classes derived from <b>CStdComponentObject</b> and <b>CStdClassFactory</b>, we could build a DLL that supported a set of COM objects. The great advantage of using MI to define the objects is that the implementation requires no nested classes and no use of the <b>pThis</b> pointer, which MFC's implementation uses to access the object's members. The <b>IUnknown</b> interface is supplied by the <b>CStdComponentObject</b> base class, so additional interfaces do not need to define or implement the <b>IUnknown</b> methods.</p>
<p>
So what's the catch? Well, if all you want to do is create simple COM objects, there isn't one. But if you want to be able to support OLE Automation, you're going to find that you will also need to provide the entire implementation of that yourself because MFC's implementation of OLE Automation (via the <b>IDispatch</b> interface) relies heavily on the fact that MFC's COM objects are derived from the <b>CCmdTarget</b> class. So if you build your COM objects from some other base class, you can't use any MFC COM features at all. Of course, this also means you can't use any ClassWizard support for adding features to your COM objects either.</p>
<h2>Summary</h2>
<p>
Although you <i>can</i> build COM objects using multiple inheritance, and that implementation is much cleaner than MFC's nested class approach, you are going to find it hard to integrate your object code with other MFC classes and features. Because my main focus is on helping you create COM objects using Visual C++ and MFC, I'm going to punt on using MI and concentrate on showing you how to make the most out of what MFC has to offer. To the best of my knowledge, there are no plans for MFC to use an MI approach in the future.</p>
</BODY>
</HTML>
