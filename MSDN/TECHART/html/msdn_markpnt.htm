<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Programs Without a Standard Windows User Interface Using Visual C++ and MFC</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_markpnt"></a>Creating Programs Without a Standard Windows User Interface Using Visual C++ and MFC</h1>
<p>
Nigel Thompson<br>
Microsoft Developer Network Technology Group</p>
<p>
November 23, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3216">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the MarkPnt sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3215">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the Animate library for this technical article.</a></p>
<h2>Abstract</h2>
<p>
Microsoft® Visual C++™ and the Microsoft Foundation Class Libraries (MFC) provided a very fast way to get a standard Windows™-based application up and running. But what if you don't want the normal look and feel? Many games and educational applications have special user interface needs that can't be met with the standard Windows user interface. This article takes a look at creating a simple child's coloring game that uses only a single window and has no window border, caption, buttons, cursor, or any other recognizable elements of a Windows user interface.</p>
<p>
The sample application MarkPnt (Mark Paint) is a simple paint program that I developed for my young son, Mark. It runs full screen with no caption, menus, or cursor. There is no keyboard interface, and the mouse buttons need not be used at all. </p>
<p>
The application uses sprite animation technology to simulate drawing with a crayon on paper. The animation is done partly with direct pixel access to a device-independent (DIB) structure and partly with graphics device interface (GDI) operations on the same DIB.</p>
<h2>Introduction</h2>
<p>
I was recently allowed a brief glimpse of the future, and I'd really like to tell you all about it, but then I'd have to kill you. Anyway, the result of my viewing this new piece of technology was the realization that there are a lot of applications that can use the Microsoft® Windows™ platform that don't need or want to conform to the current Windows user interface (UI) guidelines. Of course, this desire to depart from the world of rectangular buttons and system menu boxes is not new. Many Windows products—notably games and educational applications—have for some time been doing their own UI. In part, this is because they are ported from the MS-DOS® environment, where there was no free UI support, and also because the Windows UI just doesn't cut it for the under-five set. </p>
<p>
So in the spirit of the new world, I thought I'd see just how hard it was to create a Windows-based application with no recognizable Windows UI, using my favorite tools—Visual C++™ and the Microsoft Foundation Class Libraries (MFC). To make life a little easier on myself, I also made use of my own C++ class library, which provides support for simple sprite animation. The result is a simple drawing game that requires no keyboard input and no mouse button usage—it just lets you draw.</p>
<p>
The final version was tested by my son Mark, who is 18 months old, and Nicholas Cluts, who is 2-1/2 years old. Neither of them managed to trash the machine, and a good time was had by all.</p>
<h2>Why Bother with MFC?</h2>
<p>
Inasmuch as the application we want to create uses none of the standard Windows UI, why should we bother to use the MFC libraries? And I guess an associated question might be, If I use Visual C++, won't I get a lot of stuff I don't need?</p>
<p>
To answer the second question first: Yes, you do get a lot of stuff you don't need if you use AppWizard to create the initial framework of the application, but removing the few unneeded files and a couple of lines of code is trivial. As to why we should use MFC, my own answer is simply that MFC provides a lot of classes not related to the UI, such as simple window management and file I/O, which we will probably benefit from. The bottom line for me is that I now know MFC quite well, and my own animation library classes are all derived from MFC base classes, so, providing I can get the look and feel I want in the application, using MFC is going to make programming easier for me.</p>
<h2>The Application Architecture</h2>
<p>
Let's look at the required appearance on the screen first and then at the C++ classes needed to create it.</p>
<h3>Screen Design</h3>
<p>
I hate using the word <i>architecture</i> because it always sounds so grand, and my application designs are often so trivial. Nonetheless, Figure 1 shows what I wanted the screen to look like when the application was running. I haven't included a screen shot here because the application runs full-screen and uses 256 colors, so it's a little difficult to get a decent rendition in a document.</p>
<p>
<img src="markpnt_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Screen design for the application</b></p>
<p>
As you can see, the screen is to look like a ring-bound notebook. A number of drawing tools live at the bottom of the page, while the current tool can be moved with the mouse. A click-sensitive area at the top right (which looks like a folded-over page corner) is designed to be used to erase the page and start again.</p>
<p>
Because most very small kids can't use mouse buttons, I designed the application to draw all the time. No mouse clicks at all are required to draw. Tool selection is done by simply dragging the current tool over one of the inactive tools. As a compromise for adults, I added two features: the new page sensor, which erases the entire picture if it is clicked, and the ability to lift the tool up if either mouse button is held down.</p>
<p>
Given that my own son couldn't click the new page sensor, I made the picture fade out over a period of about 15 minutes.</p>
<h3>Class Design</h3>
<p>
So how are we going to do all this with MFC? The design is very simple: One window will be used to fill the entire screen. The drawing tools, binder rings, and new page sensor will all be sprites. The active tool will be a sprite that moves with the mouse. The cursor will be made invisible. The sprite code will be from my animation library.</p>
<p>
For the actual drawing, we will use a device-independent bitmap (DIB) as a buffer. As the drawing tools move, we will modify the content of the DIB buffer and draw the changes to the screen. The grunt work of this is done by using the <b>CDIBSurface</b> class from my animation library.</p>
<p>
Figure 2 shows the main classes used in the application. Each class is derived from an MFC class.</p>
<p>
<img src="markpnt_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The main classes used in the application</b></p>
<p>
I split the window class into two classes, <b>CAnimWnd</b> and <b>CPaintWnd</b>, because I thought I could try to make <b>CAnimWnd</b> more general and maybe use it in other applications. The sprite notification object is used to track changes in the sprites—we'll see how that works shortly. The drawing tools are all simply derivations of the sprite class.</p>
<p>
If you're not familiar with sprites or animation in general, you might like to scan through the first chapter or two of my book <i>Animation Techniques in Win32</i>, which has been published by Microsoft Press (January 1995).</p>
<h2>Building the Application with Visual C++</h2>
<p>
Use AppWizard in Visual C++ to create a minimal application framework. In other words, select a single document interface (SDI) application with no printing, toolbars, and so forth. This will give you an application that has a main frame window, a view class, and a document class. If you want, you can build it and the Mr. Boring regular Windows-based application it produces.</p>
<p>
The next step is to remove the main frame window class files (usually MAINFRM.CPP and MAINFRM.H) and the files used to create the document and view classes. What this leaves you is a single .CPP file for the application (for example, MARKPNT.CPP). You'll need to remove references to the main frame, document, and view headers from the remaining files.</p>
<p>
Having removed the junk, we need to alter the startup code in the <b>InitInstance</b> member of the main application file. This normally creates the frame window by creating a new empty document. We're going to replace the initialization code generated by AppWizard with some code to create our own main window, which in this case is of the <b>CPaintWnd</b> class. Here is what <b>InitInstance</b> looks like after these changes have been made:</p>
<pre><code>BOOL CMarkPntApp::InitInstance()
{
 &nbsp;&nbsp; CPaintWnd* pWnd = new CPaintWnd;
 &nbsp;&nbsp; pWnd-&gt;Create("", 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_POPUP | WS_VISIBLE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::GetSystemMetrics(SM_CXSCREEN),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::GetSystemMetrics(SM_CYSCREEN));
 &nbsp;&nbsp; m_pMainWnd = pWnd;
 &nbsp; return TRUE;
}
</code></pre>
<p>
An instance of the window class is created, and its <b>Create</b> member function is called to create the actual window. In this case, the window is a simple pop-up window with no border or caption, and the window is created the same size as the screen. Once the window has been created, a pointer to it is stored in the application's <b>m_pMainWnd</b> variable.</p>
<p>
Ignoring what goes on in the <b>CPaintWnd</b> class for the moment, what we have done so far is to create an application with a single pop-up window that occupies the entire screen of the machine. The remaining steps are all concerned with how we implement the functionality of the application. The framework is complete. </p>
<h2>The Main Window</h2>
<p>
As I mentioned earlier, the main window class is built in two stages: <b>CAnimWnd</b> is derived from <b>CWnd</b> and is used to create a window with the basic requirements we will need to support animated sprites. <b>CPaintWnd</b> is derived from <b>CAnimWnd</b> and implements the features specific to this application. Let's look at these two classes now.</p>
<h3>The CAnimWnd Class</h3>
<p>
The <b>CAnimWnd </b>class is designed to support a set of sprites that may be moved around the window under program control. This window class must be responsible for maintaining the list of sprites and be capable of drawing them to the screen as they are moved around. Because there must be some sort of background to the animation (even if it's only a flat color), this window must also take care of drawing the background, too. Normally an animation involves a background scene that is quite complex, but in this case, I decided to leave out support for a background image and simply support a fill color. This isn't exactly a general solution, but it does what we need for this application, and it's easy to modify it to display a background image if that's what you need.</p>
<p>
In order to make management of the sprites simple, I included some sprite-handling functions in the animation window class. This makes it extremely simple to load a sprite and add it to the animation. It also makes it easy to keep track of where the sprites are and keeps all the dirty region paint code in one place. We'll look at the details shortly, but let's look first at the public member functions of <b>CAnimWnd</b>:</p>
<pre><code>BOOL InsertSprite(CSprite* pNewSprite);
CSprite* RemoveSprite(CSprite *pSprite);
void ReorderSprite(CSprite* pSprite);
CSprite* CAnimWnd::HitTestSprite(CPoint point);

virtual void Render(RECT* pClipRect = NULL);
void Draw(RECT* pClipRect = NULL);
void RenderAndDrawDirtyList();
void RenderSprites(RECT* pClipRect = NULL);
void AddDirtyRegion(RECT* pRect);
</code></pre>
<p>
The first group of functions deals with allowing sprites to be added to or removed from the list. The <b>Reorder</b> function is used to reposition a sprite correctly in the list when its z-order changes, so that when the sprite list is rendered and drawn to the screen, the relative positions will come out right.</p>
<p>
The second group of functions is used in the construction of the displayed image. The rendering functions are used to create a composite image in the off-screen rendering buffer and the drawing functions are used to copy areas of the off-screen buffer to the screen. The <b>Render</b> function will normally be implemented in a class derived from <b>CAnimWnd</b>, so the function has been defined as virtual. To understand why we need this to be virtual, let's look at how WM_PAINT messages are handled by this window class in its <b>OnPaint</b> function:</p>
<pre><code>void CAnimWnd::OnPaint() 
{
 &nbsp;&nbsp; PAINTSTRUCT ps;
 &nbsp;&nbsp; BeginPaint(&amp;ps);
 &nbsp;&nbsp; Render(&amp;ps.rcPaint);
 &nbsp;&nbsp; Draw(&amp;ps.rcPaint);
 &nbsp;&nbsp; EndPaint(&amp;ps);
}
</code></pre>
<p>
The WM_PAINT message is sent to get the window to repaint a given area to the screen. We handle this in two main steps: First the affected area is rendered to the off-screen buffer, then that area is copied to the screen. These steps correspond to the calls to <b>Render</b> and <b>Draw</b>, above. In the simple case where there is no class derived from <b>CAnimWnd</b>, it's easy to see what happens. <b>CAnimWnd::Render</b> is called, followed by <b>CAnimWnd::Draw</b>. If we derive a class from <b>CAnimWnd</b>, we have done this presumably to add to the functionality—to add a background image, perhaps. If <b>CAnimWnd</b> is still handling the WM_PAINT messages, the <b>Render </b>function in the derived class will be called rather than <b>CAnimWnd::Render</b>. Because the derived class doesn't know how to render the sprite list in <b>CAnimWnd</b>, the <b>CAnimWnd::RenderSprites</b> function is provided. Here's <b>CAnimWnd::Render</b>:</p>
<pre><code>void CAnimWnd::Render(RECT* pClipRect/*= NULL*/)
{
 &nbsp;&nbsp; // Compute the clip box.
 &nbsp;&nbsp; CRect rcDraw;
 &nbsp;&nbsp; m_dsBuffer.GetRect(&amp;rcDraw);
 &nbsp;&nbsp; if (pClipRect) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcDraw.IntersectRect(&amp;rcDraw, pClipRect);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // The default action is to fill the buffer with the
 &nbsp;&nbsp; // background color or the background image and then to
 &nbsp;&nbsp; // render the sprite list.
 &nbsp;&nbsp; CBrush br (m_clrBackground);
 &nbsp;&nbsp; CDC* pDC = m_dsBuffer.GetDC();
 &nbsp;&nbsp; ASSERT(pDC);
 &nbsp;&nbsp; pDC-&gt;FillRect(&amp;rcDraw, &amp;br);

 &nbsp;&nbsp; // Flush the GDI queue before doing any direct pixel ops.
 &nbsp;&nbsp; GdiFlush();
 &nbsp;&nbsp; RenderSprites(pClipRect);
}
</code></pre>
<p>
As you can see, the default action is to fill the area with the background color and then render the sprites. So a typical class derived from <b>CAnimWnd</b> might do something like this in its <b>Render</b> function:</p>
<pre><code>void CMyWnd::Render()
{
 &nbsp;&nbsp; // Compute the clip box.
 &nbsp;&nbsp; CRect rcDraw;
 &nbsp;&nbsp; m_dsBuffer.GetRect(&amp;rcDraw);
 &nbsp;&nbsp; if (pClipRect) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcDraw.IntersectRect(&amp;rcDraw, pClipRect);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Do some fascinating stuff of my own.
 &nbsp;&nbsp; ...

 &nbsp;&nbsp; // Flush the GDI queue before doing any direct pixel ops.
 &nbsp;&nbsp; GdiFlush();
 &nbsp;&nbsp; CAnimWnd::RenderSprites(pClipRect);
}
</code></pre>
<p>
This is pretty much what <b>CPaintWnd</b> does, as we'll see next. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;As my colleague Mr. Rogerson points out, there is, of course, more than one way to implement this kind of functionality. The base class could have two functions: <b>Render</b> and <b>RenderDetail</b>. <b>Render</b> would set things up and then call <b>RenderDetail</b>. When <b>RenderDetail</b> returned, the tail end of <b>Render</b> would tidy up and call <b>RenderSprites</b>. A class derived from <b>CAnimWnd</b> would then simply override <b>RenderDetail</b> for its own needs.</p>
<h3>The CPaintWnd Class</h3>
<p>
The <b>CPaintWnd </b>class is derived from <b>CAnimWnd</b> and uses the sprite functions in the base class to implement a set of drawing tools, some "cute look" features, and some additional user interface functions. In addition, <b>CPaintWnd</b> handles the mouse input, takes care of palette messages, and implements a timer event-driven background process that fades out the image over a period of time. Of course, it's also responsible for doing the actual drawing, which is, after all, what the application is all about. This all sounds like a lot of code, but in practice, it's mostly a case of using existing classes. Let's start by looking at the window create, size, and delete handlers.</p>
<pre><code>BOOL CPaintWnd::Create(const char* pszTitle, DWORD dwStyle, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWnd* pParent, int x, int y, int cx, int cy)
{
 &nbsp;&nbsp; m_dsPaint.Create(cx, cy, &amp;m_Pal);

 &nbsp;&nbsp; // Fill the paint buffer with the background color.
 &nbsp;&nbsp; ErasePaintSurface();

 &nbsp;&nbsp; if (!CAnimWnd::Create(pszTitle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwStyle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pParent,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x, y,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cx, cy,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::LoadCursor(AfxGetResourceHandle(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAKEINTRESOURCE(IDC_CURSOR)),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;m_Pal)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; m_uiTimer = SetTimer(1, 100, NULL);
 &nbsp;&nbsp; return TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
}
</code></pre>
<p>
The window uses a <b>CDIBSurface</b> object as a painting buffer, and this object is created first, the same size as the window. The paint surface is erased, and the base class for the window is called to create the actual window:</p>
<pre><code>BOOL CAnimWnd::Create(const char* pszTitle, DWORD dwStyle, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWnd* pParent, int x, int y, int cx, int cy,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HCURSOR hCur, CPalette* pPal/*= NULL*/)
{
 &nbsp;&nbsp; // Save the palette, or create one.
 &nbsp;&nbsp; if (pPal) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pPal = pPal;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bMyPal = FALSE;
 &nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDIBPal* pWashPal = new CDIBPal;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(pWashPal);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWashPal-&gt;CreateWash();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pPal = pWashPal;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bMyPal = TRUE;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Create the off-screen rendering buffer.
 &nbsp;&nbsp; m_dsBuffer.Create(cx, cy, m_pPal);

 &nbsp;&nbsp; // Create a class name.
 &nbsp;&nbsp; const char* pszClassName 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = AfxRegisterWndClass(CS_HREDRAW | CS_VREDRAW, hCur);

 &nbsp;&nbsp; // Create the window.
 &nbsp;&nbsp; return CWnd::CreateEx(0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszClassName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszTitle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwStyle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x, y,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cx, cy,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pParent-&gt;GetSafeHwnd(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);
}
</code></pre>
<p>
If a palette was supplied, it is saved; if not, a default color cube palette is created. The off-screen drawing buffer (another <b>CDIBSurface</b> object) is then created. A new window class is registered with the cursor passed by the caller. In the case of this application, the cursor is completely transparent—we'll use a drawing tool instead. The <b>CWnd::CreateEx</b> function is then called to create the window.</p>
<p>
As a part of the main window creation process, all the drawing tools are added to the sprite list. This is done in <b>CPaintWnd::OnCreate</b>:</p>
<pre><code>int CPaintWnd::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
 &nbsp; if (CAnimWnd::OnCreate(lpCreateStruct) == -1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;
 &nbsp; 
 &nbsp;&nbsp; // Add all the pens to the sprite list.
 &nbsp;&nbsp; for (int i = 0; i &lt; m_iNumPens; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InsertSprite(&amp;m_Crayon[i]);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Make the first one current and on top.
 &nbsp;&nbsp; m_pCurrentTool = &amp;m_Crayon[0];
 &nbsp;&nbsp; m_pCurrentTool-&gt;SetZ(10);

 &nbsp;&nbsp; // Add the eraser to the sprite list.
 &nbsp;&nbsp; InsertSprite(&amp;m_Eraser);

 &nbsp;&nbsp; // And the other bits and pieces.
 &nbsp;&nbsp; InsertSprite(&amp;m_Corner);

 &nbsp;&nbsp; // Build the binder sprite.
 &nbsp;&nbsp; m_Binder.Create(m_dibRing.GetWidth(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::GetSystemMetrics(SM_CYSCREEN),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;m_Pal);
 &nbsp;&nbsp; CRect rcBinder;
 &nbsp;&nbsp; m_Binder.GetRect(&amp;rcBinder);
 &nbsp;&nbsp; CRect rcRing;
 &nbsp;&nbsp; m_dibRing.GetRect(&amp;rcRing);
 &nbsp;&nbsp; int iRingHeight = m_dibRing.GetHeight();
 &nbsp;&nbsp; int iRingWidth = m_dibRing.GetWidth();
 &nbsp;&nbsp; for (int y = 0; y &lt; rcBinder.bottom; y += iRingHeight) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcRing.top = y;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcRing.bottom = y + iRingHeight;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRect rc;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rc.IntersectRect(&amp;rcRing, &amp;rcBinder)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Something we should draw.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dibRing.CopyBits(&amp;m_Binder,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.left, rc.top,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.right - rc.left, rc.bottom - rc.top,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; // Tell the sprite to reacquire its transparency information.
 &nbsp;&nbsp; m_Binder.MapColorsToPalette(&amp;m_Pal);
 &nbsp;&nbsp; InsertSprite(&amp;m_Binder);

 &nbsp; return 0;
}
</code></pre>
<p>
The crayons and the eraser are all objects derived from <b>CSprite</b>. The binder sprite (the set of rings on the left of the image) is constructed by building a composite image of a single ring. Each sprite is added to the sprite list in the <b>CAnimWnd</b> object. The next step is to put the sprites in the correct positions and adjust their z-order values. This is done in response to a WM_SIZE message:</p>
<pre><code>void CPaintWnd::OnSize(UINT nType, int cx, int cy) 
{
 &nbsp; CAnimWnd::OnSize(nType, cx, cy);
 &nbsp; 
 &nbsp;&nbsp; // Move all the crayons down to the bottom.
 &nbsp;&nbsp; int h = m_Crayon[0].GetHeight();
 &nbsp;&nbsp; int w = m_Crayon[0].GetWidth();
 &nbsp;&nbsp; int y = cy - h - 1;
 &nbsp;&nbsp; int iCellWidth = cx / m_iNumPens;
 &nbsp;&nbsp; for (int i = 0; i &lt; m_iNumPens; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x = i * iCellWidth 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + cx / m_iNumPens / 2
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - w / 2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Crayon[i].SetPosition(x, y);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Put the eraser at the bottom left.
 &nbsp;&nbsp; m_Eraser.SetPosition(iCellWidth / 2 - m_Eraser.GetWidth() / 2, y);&nbsp;&nbsp;&nbsp; 

 &nbsp;&nbsp; // Set up the new page sensor at the top right.
 &nbsp;&nbsp; m_Corner.SetPosition(cx - m_Corner.GetWidth(), 0);

 &nbsp;&nbsp; // And the binder rings on the left.
 &nbsp;&nbsp; m_Binder.SetPosition(-1, 0);
 &nbsp;&nbsp; m_Binder.SetZ(80);

 &nbsp;&nbsp; // Set up the background fading.
 &nbsp;&nbsp; InitFade();

 &nbsp;&nbsp; Invalidate();
}
</code></pre>
<p>
Using <b>OnSize</b> here is convenient because it's the first time we know the actual size of the window; and because this application occupies the entire window by design and cannot have its size changed, the call to this function occurs only once.</p>
<p>
The final step in the creation of the window is to have it all painted, which is handled in part by <b>CPaintWnd</b> and in part by <b>CAnimWnd</b>, as we saw earlier. Here's the <b>Render</b> function from <b>CPaintWnd</b>:</p>
<pre><code>void CPaintWnd::Render(RECT* pClipRect)
{
 &nbsp;&nbsp; // Compute the clip box.
 &nbsp;&nbsp; CRect rcDraw;
 &nbsp;&nbsp; m_dsPaint.GetRect(&amp;rcDraw);
 &nbsp;&nbsp; if (pClipRect) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcDraw.IntersectRect(&amp;rcDraw, pClipRect);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Copy the paint area to the buffer.
 &nbsp;&nbsp; m_dsPaint.CopyBits(&amp;m_dsBuffer,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcDraw.left, rcDraw.top,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcDraw.right - rcDraw.left, rcDraw.bottom - rcDraw.top,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcDraw.left, rcDraw.top);

 &nbsp;&nbsp; // Call base class to render the sprites.
 &nbsp;&nbsp; CAnimWnd::RenderSprites(pClipRect);
}
</code></pre>
<p>
This is extremely simple. The paint buffer (with the squiggly line drawn by the user) is copied to the off-screen buffer (part of the base class). The base class is then called to render all the sprites on top of the drawing. Of course, a high-resolution screen means that a lot of memory is being used for buffer space, but that's one of the trade-offs I've made for simple code and high performance.</p>
<p>
That takes care of creating and painting the window. When the user closes the application, there is a bit of tidy-up work we need to do. The application framework won't delete the main window object, so we need to take care of this in a <b>PostNcDestroy</b> handler:</p>
<pre><code>void CPaintWnd::PostNcDestroy() 
{
 &nbsp;&nbsp; // We must delete the window object ourselves because the
 &nbsp;&nbsp; // app framework doesn't do this.
 &nbsp;&nbsp; delete this;
}
</code></pre>
<p>
If you leave this out, Visual C++ will report a number of memory leaks, including a <b>CWnd</b> object when the application terminates.</p>
<h2>Dealing with Palettes</h2>
<p>
I have written quite a lot about palettes at one time or another, and I don't want to repeat myself unnecessarily here, so I will say only that the application has a single palette that is created as a simple color cube to give a rough variety of colors. The application needs to handle two palette messages, and these are taken care of by these two functions:</p>
<pre><code>void CPaintWnd::OnPaletteChanged(CWnd* pFocusWnd) 
{
 &nbsp;&nbsp; // See if the change was caused by us and ignore it if not.
 &nbsp;&nbsp; if (pFocusWnd != this) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnQueryNewPalette();
 &nbsp;&nbsp; }
}

BOOL CPaintWnd::OnQueryNewPalette() 
{
 &nbsp;&nbsp; // We are going active, so realize our palette.
 &nbsp;&nbsp; if (m_pPal) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDC* pdc = GetDC();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPalette *poldpal = pdc-&gt;SelectPalette(m_pPal, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT u = pdc-&gt;RealizePalette();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReleaseDC(pdc);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (u != 0) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Some colors changed, so we need to repaint.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InvalidateRect(NULL, TRUE); // Repaint the lot.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE; // Say we did something.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return FALSE; // Say we did nothing.
}
</code></pre>
<p>
That's more or less all there is to it, except to know that each time a new <b>CDIB</b> or <b>CSprite</b> object image is loaded, it must be mapped to this common palette by calling its <b>MapColorsToPalette</b> function. The <b>CCrayon</b> and <b>CEraser</b> classes are both derived from <b>CDrawingTool</b>, which does this for you in its <b>Load </b>function:</p>
<pre><code>void CDrawingTool::Load(UINT uiID, CPalette* pPal)
{
 &nbsp;&nbsp; ASSERT(uiID);
 &nbsp;&nbsp; ASSERT(pPal);
 &nbsp;&nbsp; BOOL b = CSprite::Load(uiID);
 &nbsp;&nbsp; ASSERT(b);
 &nbsp;&nbsp; MapColorsToPalette(pPal);
}
</code></pre>
<p>
No big deal, but if you don't do it, you won't get the colors you expect—be warned!</p>
<h2>The User Interface</h2>
<p>
Given that we have no size border, menus, buttons, and so forth, writing the user interface code shouldn't take long! Three main functions are controlled by the mouse: drawing, tool selection, and clearing the image. Drawing is done any time the mouse is moved and no mouse button is down. If any mouse button is down, the drawing tool (crayon or eraser) doesn't affect the image. A new tool is selected by simply moving the tip of the current tool over the image of the new tool. A timer is used to prevent tool changes from happening too rapidly in succession. A mouse click on the new page sensor is detected and used to clear the drawing image.</p>
<p>
In addition to these functions, remember that we have no cursor as such, and the current drawing tool sprite needs to be moved around as the mouse is moved. Here's the code for handling mouse move events:</p>
<pre><code>void CPaintWnd::OnMouseMove(UINT nFlags, CPoint point) 
{

 &nbsp;&nbsp; // Move the current pen to the new position.
 &nbsp;&nbsp; ASSERT(m_pCurrentTool);
 &nbsp;&nbsp; m_pCurrentTool-&gt;SetPosition(point.x, point.y - m_pCurrentTool-&gt;GetHeight());

 &nbsp;&nbsp; // If no buttons are down, we paint.
 &nbsp;&nbsp; if ((nFlags &amp; (MK_LBUTTON | MK_RBUTTON)) == 0) {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the paint area DC.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDC* pDC = m_dsPaint.GetDC();
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create the pen.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPen pen(PS_SOLID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pCurrentTool-&gt;GetSize(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pCurrentTool-&gt;GetColor());&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPen* ppenOld = pDC-&gt;SelectObject(&amp;pen);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_ptPrev.x == -1) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ptPrev = point;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDC-&gt;MoveTo(m_ptPrev);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDC-&gt;LineTo(point);&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDC-&gt;SelectObject(ppenOld);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GdiFlush();

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRect rc;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.left = min(point.x, m_ptPrev.x);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.top = min(point.y, m_ptPrev.y);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.right = max(point.x, m_ptPrev.x);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.bottom = max(point.y, m_ptPrev.y);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.InflateRect(m_pCurrentTool-&gt;GetSize(), m_pCurrentTool-&gt;GetSize());

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddDirtyRegion(&amp;rc);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // See if we are in tool-change lockout time.
 &nbsp;&nbsp; if (m_iChangeLockoutTime == 0) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK for a tool change

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Test for a hit in a sprite just below where the tool
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is (so we don't hit-test inside the tool itself).
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x = m_pCurrentTool-&gt;GetX();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int y = m_pCurrentTool-&gt;GetY();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDrawingTool* pspNewTool = (CDrawingTool*)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitTestSprite(CPoint(x, y + m_pCurrentTool-&gt;GetHeight() + 10));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pspNewTool &amp;&amp; pspNewTool-&gt;IsKindOf(RUNTIME_CLASS(CDrawingTool))) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pCurrentTool-&gt;SetPosition(pspNewTool-&gt;GetX(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pspNewTool-&gt;GetY());
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pCurrentTool-&gt;SetZ(50);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pCurrentTool = pspNewTool;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pCurrentTool-&gt;SetPosition(x, y);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pCurrentTool-&gt;SetZ(10);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Restart the lockout timer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_iChangeLockoutTime = 10; // 1.0s
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Draw all the changes.
 &nbsp;&nbsp; RenderAndDrawDirtyList();

 &nbsp;&nbsp; m_ptPrev = point;
}
</code></pre>
<p>
The current tool is first moved to the mouse location. After that, a test is made to see if any mouse button is down, and if not, a pen is created for a drawing operation. The pen is used to draw a straight line from the last known mouse position to the current one.</p>
<p>
A test is then made to see if the tool lockout timer has expired. If it has, a test is made to see if the current mouse position is over a new tool, and if so, the current tool is swapped with that one.</p>
<p>
Finally, all the areas affected by the sprite movement and drawing operations are rendered and drawn to the screen.</p>
<p>
Mouse clicks are handled separately:</p>
<pre><code>void CPaintWnd::OnLButtonDown(UINT nFlags, CPoint point) 
{
 &nbsp;&nbsp; // See if we got a hit in the new page sensor.
 &nbsp;&nbsp; if (m_Corner.HitTest(point)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErasePaintSurface();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Invalidate();
 &nbsp;&nbsp; }
}
</code></pre>
<p>
If the click occurs in the new page sensor, the current image is erased and the screen redrawn to reflect the change.</p>
<h2>Background Processing</h2>
<p>
I wanted the image to fade away slowly in the background; this is implemented by using a timer and some simple software that gradually sets all the pixels in the paint buffer back to the background color. To make the transition look more natural, I used a 16-by-16 grid of points and randomized the order in which the points in the grid are reset to the background color. Each timer tick, a certain number of passes are made over the paint buffer. Each pass sets one pixel in each grid square back to the background color. The code for this is in FADE.CPP. I'll leave this to you to investigate.</p>
<h2>Summary</h2>
<p>
Not all Windows-based applications need to look like Windows-based applications. You can use Visual C++ and MFC to create applications that have their own style and function just as easily as you can use them to create more regular-looking Windows-based applications. As ever, if you have comments on this article, send me e-mail: nigelt@microsoft.com.</p>
</BODY>
</HTML>
