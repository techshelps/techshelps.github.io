<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Common Error Messages</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Common Error Messages</h1>
<h3>Table name skipped or export failed</h3>
<p>
This generic message is provided by the Upsizing Wizard when something goes wrong. Check for a more meaningful error message on the Upsizing Report. If there is no additional information there, review the section below on the Convert OEM to ANSI Problem and review your data source. Find additional information in the SQL Server error log or the Windows NT Event Log.</p>
<p>
If you can't find a more meaningful message, use the Upsizing Wizard to upsize the table structure without the data. Then link to the table and use an append query to move the data from Microsoft Access to SQL Server.</p>
<p>
If the table structure won't transfer, try it again without transferring the table relationships. If that succeeds, modify the final table later to restore referential integrity. If all else fails, try exporting the table without the wizard. If you do this, you must attend to the indexes, referential integrity, defaults, and other elements on your own.</p>
<h3>The Convert OEM to ANSI Problem</h3>
<p>
The common upsizing error "Table &lt;table name&gt; skipped or export failed" is usually caused by an incorrect setting in the ODBC data source.</p>
<p>
Open Windows Control Panel and double-click ODBC. Select the data source for your server and click <b>Configure</b>. Click <b>Options</b> and verify that the <b>Convert OEM to ANSI Characters</b> check box is not checked. If it is, uncheck it, click <b>OK</b>, and close the <b>ODBC</b> dialog box. Try the Upsizing Wizard again.</p>
<p>
If this fails, it may be because a user selected the language options associated with OEM to ANSI conversion while the box was checked. If that is the case, you can't easily undo those selections. Instead, make a note of the other values in the dialog box, remove the whole data source, and recreate it, taking care not to check the OEM to ANSI check box. Upsizing will normally proceed without this error if you use a data source newly created in this way.</p>
<h3>ODBC Call Failed</h3>
<p>
This is an incomplete error message. After you click <b>OK</b>, it should be followed by the error that caused the ODBC call to fail.</p>
<pre><code>ODBC Query Timeout
Server Error 0: Timeout expired
SQL that Caused Error(s) 
UT_CopyData
</code></pre>
<p>
The queries that move the data are internal to the wizard. Their timeout was lengthened programmatically to prevent the default 60-second timeout. Unfortunately, if you have a table that is several megabytes or if your network has a lot of traffic, the timeout still may not be long enough. Upsize the table structure without data, link to the new table, then move the data into it a Microsoft Access append query. Either set the ODBC Timeout property to 0 for your append query, or use a criteria that selects and moves only a portion of the data at a time. Repeat this until the entire table has been moved.</p>
<p>
Microsoft does not support modifications of the Upsizing Wizard tool, however if this problem is causing a major stumbling block, try this:
<ol>
<li>
Close and reopen Microsoft Access.<br><br></li>
<li>
Open the wizard database Wzcx.mda (Microsoft Access 95) or Wzcs97.mda (Microsoft Access 97).<br><br></li>
<li>
Open the UT_modGlobals module and search for "CLng(vODBCTimeout)".<br><br></li>
<li>
You should have found the following:<pre><code>If Not IsMissing(vODBCTimeout) Then
 &nbsp;&nbsp; qry.ODBCTimeout = CLng(vODBCTimeout)
End IF</code></pre>
</li>
<li>
Comment out this line:<pre><code>'If Not IsMissing(vODBCTimeout) Then&nbsp;&nbsp; </code></pre>
</li>
<li>
Change the ODBC Timeout to zero.<pre><code>qry.ODBCTimeout = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></pre>
</li>
<li>
Comment out this line:<pre><code>'End If&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></pre>
</li>
<li>
Now, the Upsizing Wizard should never time out. Use this carefully.</li>
</ol>
<h3>SQL Server error 1105: Can't allocate space</h3>
<p>
Here is the full error.</p>
<pre><code>Can't allocate space for object '&lt;usually a table name&gt;' in database '&lt;dbname&gt;' because the '&lt;name&gt;' segment is full. If you ran out of space in Syslogs, dump 
the transaction log. Otherwise, use ALTER DATABASE or sp_extendsegment to increase 
the size of the segment.
</code></pre>
<p>
This error means your database is full. There are two situations in which this problem will occur. First, your database may be too small to hold the data. You must make the SQL Server database larger.</p>
<p>
The second problem is more complicated and more common. The Upsizing Wizard moves the tables over in a transaction so that either the whole table is successfully transferred or none of the table is transferred. During the move, the data is written to the database twice: to the target table and to the transaction log. The log is integral to the transaction mechanism. If the transfer fails, the log establishes which records must be removed again. Because of this, you need to have twice as much room in the database as the largest table being moved. If the log and data are on separate devices, both the log portion and the data portion must be large enough to hold the largest table.</p>
<p>
Sometimes you don't want to increase the size of your database. During the upsizing you are moving a lot of data, an activity that may not be a typical use pattern. The large log size required during the move may not be needed later. Though it is easy to increase the size of a database, it is difficult to shrink one. To get around this problem, consider one of these options:
<ul type=disc>
<li>
Use the Upsizing Wizard to create the table structure. Move the data over in smaller sections. Link to the table and use a Microsoft Access append query with a criteria that selects only portions of the data at one time. Repeat this until the entire table has been moved.<br><br></li>
<li>
Use <b>trunc. log on chkpt.</b> to clear out the transaction log after each transaction. That way, the logged data from the first table is dropped before you start moving the second table.</li>
</ul>
<h3>Server Error 191: SQL Statement Nested Too Deeply</h3>
<p>
Each field in a Microsoft Access table has a required property. If that field has a Yes property, indicating that a value must be entered, the Upsizing Wizard preserves that property when the table is move to SQL Server. By default, the Upsizing Wizard creates a trigger to enforce a required entry, nesting IF statements for each required field. The result is a trigger like:</p>
<pre><code>CREATE TRIGGER customers_Utrig ON customers FOR UPDATE AS
/* PREVENT NULL VALUES IN 'cust_ID' */
IF (SELECT Count(*) FROM inserted WHERE 'cust_ID' IS NULL) &gt;0
BEGIN
RAISERROR 44444 'Field' 'cust_ID' 'cannot contain a null value.'
ROLLBACK TRANSACTION
END
ELSE
/* PREVENT NULL VALUES IN 'name' */
IF (SELECT Count(*) FROM inserted WHERE 'name' IS NULL) &gt;0
BEGIN
RAISERROR 44444 'Field' 'name' 'cannot contain a null value.'
ROLLBACK TRANSACTION
END
ELSE
</code></pre>
<p>
The Upsizing Wizard uses triggers because they can be changed easily to allow null values later, most closely resembling Microsoft Access behavior. A SQL Server developer would more likely specify either NULL or NOT NULL for each field when creating the table definition. This looks like:</p>
<pre><code>CREATE TABLE customers
(
cust_ID&nbsp;&nbsp; (CHAR(5) NOT NULL,
name&nbsp;&nbsp; VARCHAR(50) NOT NULL,
license&nbsp;&nbsp; VARCHAR(7) NULL,
…
</code></pre>
<p>
There are three reasons why you might not use triggers to prevent the entry of null values into a field. First, a NOT NULL constraint (the NOT NULL table definition) fires before data is entered into the table. It is very fast. A trigger, on the other hand, permits the entry of the null record before evaluating the entry. If the trigger discovers an invalid value, it rolls back the insert or update. This is inherently slow.</p>
<p>
Second, if you have many required fields, the creation of the trigger fails with errors similar to the following:</p>
<pre><code>Server Error 170: Line 600: Incorrect syntax near 'WHERE;.
Server Error 191: Some part of your SQL Statement is nested too deeply. 
Please re-write the query or break it up into smaller queries.
</code></pre>
<p>
This is because the nesting level eventually fails.</p>
<p>
Third, database purists like to use NULL and NOT NULL in their table definitions because that is the ANSI standard. Triggers don't exist in all databases, and when they do they are not implemented the same across all databases. Defining your tables with NULL and NOT NULL is good programming practice because it makes your applications more portable.</p>
<p>
The Upsizing Wizard can be changed to use the standard NULL / NOT NULL syntax to specify required fields. Start Microsoft Access and open the Upsizing Wizard library database. For Microsoft Access 95, the filename is Wzcs.mda. For Microsoft Access 97, the filename is Wzcs97.mda. When the database is open, click the <b>Modules</b> tab and open the UT_ModUserConstants module. Search for the UT_USE_NULL_CONSTRAINTS constant and change the default value from False to True.</p>
<h3>Run Out of Locks</h3>
<p>
SQL Server is initially installed with the configuration setting of 5,000 locks. If you run out you will receive this error:</p>
<pre><code>Server Error 1204: SQL Server has run out of LOCKS. Re-run your command when there are fewer active users, or ask your System Administrator to reconfigure SQL Server with more LOCKS.
</code></pre>
<p>
Use the <b>Server</b> <b>Configuration</b> dialog box to increase the locks. The lock setting can be increased while you upsize your data, then reduced for the smaller activity expected during normal use. Alternatively, use the <b>Edit</b> <b>Database</b> dialog box to put your database in single-user mode so that SQL Server can maintain transaction integrity without using locking.</p>
<h3>#Deleted or Data has Changed, Operation Stopped</h3>
<p>
These errors occur when Microsoft Access thinks a record is no longer present. It usually occurs because of data type conversion issues. The solution is to add a timestamp column to the table.</p>
<p>
If adding a timestamp field to your table does not resolve the problems, you probably are using a <b>float</b> data type as your primary key. To update a record, Microsoft Access identifies it by the primary key value. If that key is of a data type that cannot be accurately converted, the update will fail. The best solution is to avoid float and datetime fields as primary keys or as part of combined field primary keys. If this is not possible, use stored procedures to manipulate the table data.</p>
<p>
Often, a special problem occurs when you upsize a Microsoft Access 95 database to a SQL Server 6.5 database. The Upsizing Wizard creates the table, moves the data into it, and then alters the table to add the timestamp. The timestamps are still blank when the process is completed. The SQL Server 6.5 ODBC driver enforces ANSI syntax not supported by Microsoft Access 95. Microsoft Access mistakenly creates queries with NULL timestamp fields "<b>= 0x00</b>" instead of "<b>IS NULL</b>." This syntax error prevents Microsoft Access from finding timestamp fields with null values. To solve this problem, update every record in the table after the upsizing has completed. This will populate the timestamp field. You can update simply by setting a field value to itself. Pick some non-indexed field to do this quickly. For example:</p>
<pre><code>UPDATE mytable
SET zipcode = zipcode
</code></pre>
<p>
This will update every record without changing data.</p>
<p>
If you get the #Deleted value when sorting large record sets in SQL Server 6.5, apply Service Pack 2.</p>
<h3>Invalid Argument</h3>
<p>
To resolve this problem with zero-length strings in Microsoft Access 2.0, replace the zero-length string with a null. Create a query with the field defined below, replacing &lt;fieldname&gt; with the name of your problem field:</p>
<pre><code>Expr1:Len([&lt;fieldname&gt;])
Critieria: 0
</code></pre>
<p>
Run this query to return records with fields containing zero-length strings. </p>
<p>
Now change the SELECT query to an UPDATE query and type null in the Update To row of &lt;fieldname&gt;. Run the query. All zero length strings in the field are changed to null values. Now you can export the table to SQL Server. For more information, see the Microsoft Access Knowledge Base article Q131584, "ACC2: 'Invalid Argument' Error Msg Exporting Table to SQL Server."</p>
<h3>Table Is Read Only</h3>
<p>
Because the data in a SQL Server table is not in a native Microsoft Access format, Microsoft Access cannot manage it the same way it manages a native Microsoft Access table. It must have a unique index for identifying each row individually. For best performance, provide a unique index on each table.</p>
<p>
When you link to a table without a unique index, you are prompted for a unique field or combination of fields.</p>
<pre><code>In order to update records in this table you must select which field or fields uniquely identify each record. Select up to ten fields.
</code></pre>
<p>
The status bar at the bottom of the screen presents the message "<i>This Recordset is not updateable</i>" if it attempts to edit a record in a table without a unique index.</p>
<p>
The status bar at the bottom of the screen presents the message "<i>Records not deleted. Data is read only</i>" if it attempts to delete a record in a table without a unique index.</p>
<p>
If a unique field or combination of fields exists but has no unique index, you can create an index in Microsoft Access, creating a copy of the field or fields so that Microsoft Access can identify each record. You can do one of the following:
<ul type=disc>
<li>
Identify the field or fields for the unique index when you link to the table.<br><br></li>
<li>
Open a new query in design view and then create and run a query like:<pre><code>CREATE UNIQUE INDEX myindex 
ON
NameOfTheTable(UniqueColumnName)</code></pre>
</li>
</ul>
<p>
No matter how the index is created, it keeps a copy of the field or fields necessary to identify each row uniquely. If you can create a unique index on the server, SQL Server performs much faster in almost all circumstances. An index constructed in Microsoft Access for a SQL Server table is less useful, requires more space, and needs more maintenance to keep current. Use a Microsoft Access index only when the table must be updated and the index cannot be created on the server.</p>
<h3>Numeric Data Out of Range</h3>
<p>
This error occurs with the original release of Microsoft Access for Windows 95 and a linked SQL Server table with an identity column. This bug is fixed in the free upgrade Microsoft Access 7.0a. Knowledge Base articles Q149535 and Q153151 describe this problem. To obtain this upgrade, call the Microsoft Order Desk at (800) 360-7561.</p>
<h3>Timeout Expired from 16-bit Applications</h3>
<p>
If you receive a timeout expired message immediately after your second asynchronous retry, you may need an updated SQL Server ODBC driver. This problem can occur with any network library when connecting with Microsoft Access 2.0, Visual Basic 3 or Visual Basic 4 16-Bit in asynchronous mode. The problem occurs in the SQL Server ODBC driver (Sqlsrvr.dll) version 2.65.0201 and is corrected in the drivers shipped with SQL Server 6.5, Service Pack 1. Upgrade to the new driver. You can also work around the problem by setting DisableAsync = 1 in the Msacc20.ini file. For more information, see Knowledge Base article Q153908, "16 bit Driver Times Out in calls to SQL Server."</p>
<h3>Domain Credentials Are Requested Twice on a Novell Network</h3>
<p>
When you make a trusted connection to SQL Server using the 16-bit Multi-Protocol Netlibrary on a Windows for Workgroups client computer that is logged on to both a Microsoft domain and a Netware network, you may be asked for your domain credentials again. This can happen even if the connection is forced over Named Pipes. This problem is discussed in Knowledge Base article Q154631, "BUG: Domain Credentials Inappropriately Requested." Currently, the only resolutions are to provide the domain credentials again or to remove the Netware network shell.</p>
<h3>Tables Do Not Show in SQL Enterprise Manager After Upsizing</h3>
<p>
Remember that SQL Enterprise Manager is not SQL Server, it is a client just like Microsoft Access. If you make a change to your server using SQL Enterprise Manager, it will reflect that change. If you make a change to the server from some other client (such as Microsoft Access), SQL Enterprise Manager will not know about it until it checks with the server for new information. In the Server Manager window of SQL Enterprise Manager, right-click in the appropriate place ("Tables" or "Databases") and select <b>Refresh</b> from the menu.</p>
<h3>Text Fields Are Incomplete</h3>
<p>
By default, a limit of 4K is transmitted for text fields. Increase this amount by using the SET statement. When upsizing tables, the Upsizing Wizard increases the text size to 2,147,483,647 bytes. You can do the same with the command:</p>
<pre><code>SET TEXTSIZE 2147483647
</code></pre>
<p>
SET statements only persist for the current session and connection.</p>
</BODY>
</HTML>
