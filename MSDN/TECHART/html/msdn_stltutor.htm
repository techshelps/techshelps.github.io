<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Visual C++ 4.2 Standard Template Library Tutorial</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_stltutor"></a></sup>Visual C++ 4.2 Standard Template Library Tutorial</h1>
<p>
Kalindi Sanghrajka, Rick Troemel, Nevenka Subotic-Burina, and Linda Koontz</p>
<p>
October 1996</p>
<h3>CONTENTS</h3>
<p>
<a href="#stlabout">1. About This Tutorial</a></p>
<p>
<a href="#stlintroto">2. Introduction to the Standard C++ Library</a></p>
<p>
<a href="#stloverview">3. C++ Template Overview</a></p>
<p>
<a href="#stlthestl">4. The Standard Template Library</a></p>
<p>
<a href="#stlsequence">5. Sequence Containers</a></p>
<p>
<a href="#stlassociative">6. Associative Containers</a></p>
<p>
<a href="#stliterators">7. Iterators</a></p>
<p>
<a href="#stladaptors">8. Container Adapters</a></p>
<p>
<a href="#stlstring">9. The C++ String Class</a></p>
<p>
<a href="#stlfunctobj">10. Function Objects</a></p>
<p>
<a href="#stlalgorith">11. Standard Template Library Algorithms</a></p>
<p>
<a href="#stllangsupport">12. Standard C++ Library Language Support</a></p>
<p>
<a href="#stlexhandle">13. Exception Handling</a></p>
<p>
<a href="#stllibdiag">14. Standard C++ Library Diagnostics</a></p>
<p>
<a href="#stlappendixa">15. Appendix A: STL References and Further Reading</a></p>
<p>
<a href="#stlappendixb">16. Appendix B: STL Container Class Definitions</a></p>
<p>
<a href="#stlappendixc">17. Appendix C: STL Container Class Methods</a></p>
<p>
<a href="#stlappendixd">18. Appendix D: Allocator Class</a></p>
<h2><a name="stlabout"></a>1. About This Tutorial</h2>
<h3>1.1 Objectives</h3>
<p>
This tutorial will provide an overview of the Standard C++ Libraries as implemented in Microsoft® Visual C++® version 4.2, with an emphasis on the Standard Template Library. Upon completion of this tutorial, you will be able to:
<ul type=disc>
<li>
Identify the different components of the Standard C++ Library.<br><br></li>
<li>
Write simple programs using Visual C++ version 4.2. that use the Standard Template Library components.<br><br></li>
<li>
Understand the Standard C++ Library implementation of exception handling and language support in Visual C++ version 4.2.</li>
</ul>
<h3>1.2 Prerequisites</h3>
<p>
This tutorial assumes that you understand basic C++ programming. It is also necessary to have a good understanding of C++ templates.</p>
<h2><a name="stlintroto"></a>2. Introduction to the Standard C++ Library</h2>
<h3>2.1 Introduction</h3>
<p>
Every C++ programmer has probably, at one time or another, written a linked list or set, searching and sorting routines. Most likely, the programmer has re-invented the wheel for every new user-defined data type. Design changes are not easy to implement in such cases. Maintaining such code is not very easy, either.</p>
<p>
If the common programming components were part of the C++ language, programmers would not need to "re-invent the wheel." </p>
<p>
Finally, the C++ language provides you with general purpose components for common programming tasks through the Standard C++ Library. The Standard C++ Library provides powerful and flexible containers, programmable algorithms, and other components that are efficient and extensible. </p>
<p>
The facilities provided by the Standard C++ Library are as follows:
<ul type=disc>
<li>
<b>Language support:</b> Provides common type definitions used throughout the library such as characteristics of predefined types, functions supporting start and termination of C++ programs, support for dynamic memory allocation, support for dynamic type identification, support for exception processing, and other run-time support.<br><br></li>
<li>
<b>Diagnostics:</b> Includes components for reporting several kinds of exceptional conditions, components for documenting program assertions, and a global variable for error number codes.<br><br></li>
<li>
<b>General utilities:</b> Includes components used in other elements of the Standard C++ Library. These components may also be used by any C++ programs. This category also includes components used by the Standard Template Library (STL) and function objects, dynamic memory management utilities, and date/time utilities. This category also includes memory management components from the C library.<br><br></li>
<li>
<b>Strings:</b> Includes components for manipulating sequences of characters, where characters may be of type <i>char</i>, <i>w_char</i>, or of a type defined in a C++ program. The library provides a class template, <b>basic_string</b>, that defines the basic properties of strings. The <b>string</b> and <b>wstring</b> types are predefined template instantiations provided by the library.<br><br></li>
<li>
<b>Localization:</b> Includes internationalization support for character classification and string collation; numeric, monetary, and date/time formatting and parsing; and message retrieval.<br><br></li>
<li>
<b>The Standard Template Library (STL):</b> Provides a C++ program access to the most widely used algorithms and data structures. STL headers can be grouped into three major organizing concepts: containers, iterators, and algorithms. <i>Containers</i> are template classes that provide powerful and flexible ways to organize data: for example, vectors, lists, sets and maps. <i>Iterators</i> are the glue that pastes together algorithms and containers. STL provides a large set of programmable <i>algorithms</i> to handle sorting, searching, and other common tasks.<br><br></li>
<li>
<b>Numerics:</b> Includes components to perform seminumerical operations and components for complex number types, numeric arrays, generalized numeric algorithms, and facilities included from the ISO C library.<br><br></li>
<li>
<b>Input/output:</b> Includes components for forward declarations of iostreams, predefined iostream objects, base iostream classes, stream buffering, stream formatting and manipulators, string streams, and file streams.</li>
</ul>
<p>
The Standard C++ Library also incorporates the Standard C Library.</p>
<h3>2.2 Using the Standard C++ Libraries in Visual C++ 4.2</h3>
<p>
Microsoft® Visual C++® version 4.2 provides the Standard C++ Library facilities through included files and associated static and dynamic libraries. </p>
<p>
A C++ program can use the different components of the Standard C++ Library by including the required header and linking with the appropriate static or dynamic library.</p>
<p>
Tables 1 and 2 list all the Standard C++ Library headers and the associated static and dynamic libraries provided by Visual C++ 4.2.</p>
<p class=label>
<b>Table 1. The Standard C++ Library Headers</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td width=25%>ALGORITHM</td>
<td width=25%>BITSET</td>
<td width=25%>CASSERT</td>
<td width=25%>CCTYPE</td>
</tr>
<tr valign=top>
<td width=25%>CERRNO</td>
<td width=25%>CFLOAT</td>
<td width=25%>CISO646</td>
<td width=25%>CLIMITS</td>
</tr>
<tr valign=top>
<td width=25%>CLOCALE</td>
<td width=25%>CMATH</td>
<td width=25%>COMPLEX</td>
<td width=25%>CSETJMP</td>
</tr>
<tr valign=top>
<td width=25%>CSIGNAL</td>
<td width=25%>CSTDARG</td>
<td width=25%>CSTDDEF</td>
<td width=25%>CSTDIO</td>
</tr>
<tr valign=top>
<td width=25%>CSTDLIB</td>
<td width=25%>CSTRING</td>
<td width=25%>CTIME</td>
<td width=25%>CWCHAR</td>
</tr>
<tr valign=top>
<td width=25%>CWCTYPE</td>
<td width=25%>DEQUE</td>
<td width=25%>EXCEPTION</td>
<td width=25%>FSTREAM</td>
</tr>
<tr valign=top>
<td width=25%>FUNCTIONAL</td>
<td width=25%>IOMANIP</td>
<td width=25%>IOS</td>
<td width=25%>IOSFWD</td>
</tr>
<tr valign=top>
<td width=25%>IOSTREAM</td>
<td width=25%>ISTREAM</td>
<td width=25%>ITERATOR</td>
<td width=25%>LIMITS</td>
</tr>
<tr valign=top>
<td width=25%>LIST</td>
<td width=25%>LOCALE</td>
<td width=25%>MAP</td>
<td width=25%>MEMORY</td>
</tr>
<tr valign=top>
<td width=25%>NEW</td>
<td width=25%>NUMERIC</td>
<td width=25%>OSTREAM</td>
<td width=25%>QUEUE</td>
</tr>
<tr valign=top>
<td width=25%>SET</td>
<td width=25%>SSTREAM</td>
<td width=25%>STACK</td>
<td width=25%>STDEXCEPT</td>
</tr>
<tr valign=top>
<td width=25%>STREAMBUF</td>
<td width=25%>STRING</td>
<td width=25%>STRSTREAM</td>
<td width=25%>TYPEINFO</td>
</tr>
<tr valign=top>
<td width=25%>UTILITY</td>
<td width=25%>VALARRAY</td>
<td width=25%>VECTOR</td>
<td width=25%>XIOSBASE</td>
</tr>
<tr valign=top>
<td width=25%>XLOCALE</td>
<td width=25%>XLOCINFO</td>
<td width=25%>XLOCMON</td>
<td width=25%>XLOCNUM</td>
</tr>
<tr valign=top>
<td width=25%>XLOCTIME</td>
<td width=25%>XMEMORY</td>
<td width=25%>XSTDDEF</td>
<td width=25%>XSTRING</td>
</tr>
<tr valign=top>
<td width=25%>XTREE</td>
<td width=25%>XUTILITY</td>
<td width=25%></td>
<td width=25%></td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The Standard C++ Library headers do not have an “.h” extension. This is in accordance with the latest C++ working papers.</p>
<p>
Visual C++ 4.2 includes the following static and dynamic libraries (in addition to the Microsoft Class Library [MFC]):
<ul type=disc>
<li>
Basic C run-time library<br><br></li>
<li>
Standard C++ Library from Plum Hall<br><br></li>
<li>
Old iostream library </li>
</ul>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;With Visual C++ 4.2, the iostream support has been pulled out of the C run-time library and exists as an independent entity. Now Visual C++ has the following libraries:</p>
<p class=label>
<b>Table 2. Static and Dynamic Libraries Included with Microsoft Visual C++ 4.2</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Library types and related compiler switches</b></td>
<td class=label width=24%><b>Basic C run-time library</b></td>
<td class=label width=24%><b>Standard C++ Library</b></td>
<td class=label width=22%><b>Old iostream library</b></td>
</tr>
<tr valign=top>
<td width=30%>Single Threaded (ML)</td>
<td width=24%>LIBC.LIB</td>
<td width=24%>LIBCP.LIB</td>
<td width=22%>LIBCI.LIB</td>
</tr>
<tr valign=top>
<td width=30%>Multithreaded (MT)</td>
<td width=24%>LIBCMT.LIB</td>
<td width=24%>LIBCPMT.LIB</td>
<td width=22%>LIBCIMT.LIB</td>
</tr>
<tr valign=top>
<td width=30%>Multithreaded DLL version (MD)</td>
<td width=24%>MSVCRT.LIB (import library for MSVCRT.DLL)</td>
<td width=24%>MSVCPRT.LIB (also uses MSVCRT.DLL)</td>
<td width=22%>MSVCIRT.LIB (import library for MSVCIRT.DLL)</td>
</tr>
<tr valign=top>
<td width=30%>Debug Single Threaded (MLd)</td>
<td width=24%>LIBCD.LIB</td>
<td width=24%>LIBCPD.LIB</td>
<td width=22%>LIBCID.LIB</td>
</tr>
<tr valign=top>
<td width=30%>Debug Multithreaded (MTd)</td>
<td width=24%>LIBCMTD.LIB</td>
<td width=24%>LIBCPMTD.LIB</td>
<td width=22%>LIBCIMTD.LIB</td>
</tr>
<tr valign=top>
<td width=30%>Debug Multithreaded DLL (MDd)</td>
<td width=24%>MSVCRTD.LIB (import library for MSVCRTD.DLL)</td>
<td width=24%>MSVCPRTD.LIB (also uses MSVCRTD.DLL)</td>
<td width=22%>MSVCIRTD.LIB (import library for MSVCIRTD.DLL)</td>
</tr>
</table><br>
<p>
<b>Case 1.</b> Consider the following sample C++ program where test.cpp uses the Standard C++ Library iostream to print "Hello World".</p>
<pre><code>// test.cpp
#include &lt;iostream&gt;
void main()
{
 &nbsp;&nbsp; cout &lt;&lt; "Hello World" &lt;&lt; endl ;
}
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>Building test.cpp using</b></td>
<td class=label width=58%><b>Will cause test.cpp to link with</b></td>
</tr>
<tr valign=top>
<td width=42%>cl /ML /GX test.cpp</td>
<td width=58%>LIBC.LIB, LIBCP.LIB</td>
</tr>
<tr valign=top>
<td width=42%>cl /MLd /GX test.cpp</td>
<td width=58%>LIBCD.LIB, LIBCPD.LIB</td>
</tr>
<tr valign=top>
<td width=42%>cl /MT /GX test.cpp</td>
<td width=58%>LIBCMT.LIB, LIBCPMT.LIB</td>
</tr>
<tr valign=top>
<td width=42%>cl /MTd /GX test.cpp</td>
<td width=58%>LIBCMTD.LIB, LIBCPMTD.LIB</td>
</tr>
<tr valign=top>
<td width=42%>cl /MD /GX test.cpp</td>
<td width=58%>MSVCRT.LIB, MSVCPRT.LIB</td>
</tr>
<tr valign=top>
<td width=42%>cl /MDd /GX test.cpp</td>
<td width=58%>MSVCRTD.LIB, MSVCPRTD.LIB</td>
</tr>
</table><br>
<p>
In Case 1, test.cpp used the Standard C++ Library input/output component to print "Hello World." The program just includes the Standard C++ Library header <b>&lt;iostream&gt;</b>. When compiling the program, specify a run-time library option: /ML[d],/MT[d], or /MD[d]. The program will then link with a basic run-time library (for example, LIBC.LIB with the /ML option) and a Standard C++ Library (for example, LIBCP.LIB with the /ML option). The /GX option enables exception handling. Exception handling must be enabled for any programs that use the Standard C++ Library.</p>
<p>
It is important to remember that starting with Visual C++ 4.2, a C++ program, depending on the run-time library compiler option specified (/ML[d],/MT[d], or /MD[d]), will always link with one Basic C run-time library and, depending on headers included, will link with either a Standard C++ Library (as in the case 1), an old iostream library (as in Case 3), or neither (as in Case 2).</p>
<p>
<b>Case 2.</b> Consider the following sample program:</p>
<pre><code>// test.cpp
void main()
{
}
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=44%><b>Building test.cpp using</b></td>
<td class=label width=56%><b>Will cause test.cpp to link with</b></td>
</tr>
<tr valign=top>
<td width=44%>cl /ML test.cpp</td>
<td width=56%>LIBC.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MLd test.cpp</td>
<td width=56%>LIBCD.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MT test.cpp</td>
<td width=56%>LIBCMT.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MTd test.cpp</td>
<td width=56%>LIBCMTD.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MD test.cpp</td>
<td width=56%>MSVCRT.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MDd test.cpp</td>
<td width=56%>MSVCRTD.LIB</td>
</tr>
</table><br>
<p>
<b>Case 3.</b> Consider the following sample program:</p>
<pre><code>// test.cpp
#include &lt;iostream.h&gt;
void main()
{
}
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=44%><b>Building test.cpp using</b></td>
<td class=label width=56%><b>Will cause test.cpp to link with</b></td>
</tr>
<tr valign=top>
<td width=44%>cl /ML test.cpp</td>
<td width=56%>LIBC.LIB, LIBCI.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MLd test.cpp</td>
<td width=56%>LIBCD.LIB, LIBCID.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MT test.cpp</td>
<td width=56%>LIBCMT.LIB, LIBCIMT.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MTd test.cpp</td>
<td width=56%>LIBCMTD.LIB, LIBCIMTD.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MD test.cpp</td>
<td width=56%>MSVCRT.LIB, MSVCIRT.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MDd test.cpp</td>
<td width=56%>MSVCRTD.LIB, MSVCIRTD.LIB</td>
</tr>
</table><br>
<h2><a name="stloverview"></a>3. C++ Template Overview</h2>
<h3>3.1 Introduction</h3>
<p>
Many C++ programs use common data structures such as stacks, queues, and lists. Imagine a program that requires a queue of customers and a queue of messages. You could easily implement a queue of customers, and then take the existing code and implement a queue of messages. If the program grows and there is a need for a queue of orders you could take the queue of messages and convert it to a queue of orders. But what if you need to make some changes to the queue implementation? This would not be a very easy task because the code has been duplicated in many places. Re-inventing source code is not an intelligent approach in an object-oriented environment that encourages re-usability. It seems to make more sense to implement a queue that can contain any arbitrary type rather than duplicating code. How does one do that? The answer is to use <i>Type Parameterization</i>, more commonly referred to as <i>Templates.</i> </p>
<p>
C++ templates allow one to implement a generic Queue&lt;<i>T</i>&gt; template that has a <i>T </i>type parameter. <i>T</i> can be replaced with actual types. For example, if the type parameter is <i>&lt;Customers&gt;</i>, C++ will generate the class <b>Queue&lt;Customers&gt;</b>. Therefore, changing the implementation of the Queue becomes relatively simple. In our example, once the changes are implemented in the template Queue&lt;<i>T</i>&gt;, they are immediately reflected in the classes <b>Queue&lt;Customers&gt;</b>, <b>Queue&lt;Messages&gt;</b>, and <b>Queue&lt;Orders&gt;</b>.</p>
<p>
Templates are very useful when implementing generic constructs such as vectors, stacks, lists, and queues that can be used with any arbitrary type. C++ templates provide a way to reuse source code, as opposed to inheritance and composition, which provide a way to reuse object code. </p>
<p>
C++ provides two types of templates: <i>class templates</i> and <i>function templates</i>. Use function templates to write generic functions: for example, searching and sorting routines that can be used with arbitrary types. The Standard Template Library generic algorithms have been implemented as function templates and the containers have been implemented as class templates.</p>
<h3>3.2 Class Templates</h3>
<h4>3.2.1 Implementing a class template</h4>
<p>
A class template definition looks like a regular class definition, except it is prefixed by the keyword <b>template</b>. For example, here is the definition of a class template for a stack:</p>
<pre><code><b>template &lt;class T&gt;

class Stack

</b>{
public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack(int = 10) ; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~Stack() { delete [] stackPtr ; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int push(const T&amp;); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pop(T&amp;) ;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int isEmpty()const { return top == -1 ; } 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int isFull() const { return top == size - 1 ; } 
private:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int size ;&nbsp; // number of elements on Stack.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int top ;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T* stackPtr ;&nbsp; 
} ;
</code></pre>
<p>
<i>T</i> is any type parameter, for example, <b>Stack&lt;Tokens<i>&gt;</i></b>, where <b>Token</b> is a user defined class. <i>T</i> does not have to be a class type as implied by the keyword class. For example, <b>Stack&lt;int&gt;</b> and <b>Stack&lt;Message*&gt;</b> are valid instantiations, even though int and <i>Message*</i> are not classes.</p>
<h4>3.2.2 Implementing class template member functions</h4>
<p>
Implementing template member functions is somewhat different than implementing the regular class member functions. The declarations and definitions of the class-template member functions should all be in the same header file. Why do the declarations and definitions need to be in the same header file? Consider the following:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=33%><pre><pre><code>//B.h
template &lt;class t&gt;
class b
{
public:
 &nbsp;&nbsp; b() ;
 &nbsp;&nbsp; ~b() ;
} ;</code></pre>
</pre>
</td>
<td width=33%><pre><pre><code>// B.cpp
#include “B.h”
template &lt;class t&gt;
b&lt;t&gt;::b()
{
}
template &lt;class t&gt;
b&lt;t&gt;::~b()
{
}</code></pre>
</pre>
</td>
<td width=34%><pre><pre><code>//main.cpp
#include “B.h”
void main()
{
 &nbsp;&nbsp;&nbsp; b&lt;int&gt; bi ;
 &nbsp;&nbsp;&nbsp; b &lt;float&gt; bf ;
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<p>
When compiling B.cpp, the compiler has both the declarations and the definitions available. At this point, the compiler does not need to generate any definitions for template classes, since there are no instantiations. When the compiler compiles main.cpp, there are two instantiations: template classes <b>B&lt;int&gt;</b> and <b>B&lt;float&gt;</b>. At this point, the compiler has the declarations but no definitions!</p>
<p>
While implementing class-template member functions, the definitions are prefixed by the keyword <b>template</b>. Here is the complete implementation of the <b>Stack</b> class template:</p>
<pre><code>//stack.h
#pragma once

<b>template &lt;class T&gt;</b>

<b>class Stack</b>

{
public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack(int = 10) ; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~Stack() { delete [] stackPtr ; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int push(const T&amp;); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pop(T&amp;) ;&nbsp; // pop an element off the stack
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int isEmpty()const { return top == -1 ; } 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int isFull() const { return top == size - 1 ; } 
private:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int size ;&nbsp; // Number of elements on Stack
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int top ;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T* stackPtr ;&nbsp; 
} ;

//Constructor with the default size 10

<b>template &lt;class T&gt;</b>

<b>Stack&lt;T&gt;::Stack(int s)</b>

{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = s &gt; 0 &amp;&amp; s &lt; 1000 ? s : 10 ;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; top = -1 ;&nbsp; // initialize stack
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stackPtr = new T[size] ; 
}

//Push an element onto the Stack.<b> </b>

<b>template &lt;class T&gt;</b>

<b>int Stack&lt;T&gt;::push(const T&amp; item)</b>

{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isFull())
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stackPtr[++top] = item ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1 ;&nbsp; // push successful
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0 ;&nbsp; // push unsuccessful
}

//Pop an element off the Stack.

<b>template &lt;class T&gt; </b>

<b>int Stack&lt;T&gt;::pop(T&amp; popValue) </b>

{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isEmpty())
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popValue = stackPtr[top--] ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1 ;&nbsp; // pop successful
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0 ;&nbsp; // pop unsuccessful
}
</code></pre>
<h4>3.2.3 Using a class template</h4>
<p>
Using a class template is very easy. Create the required classes by plugging in the actual type for the type parameters. This process is commonly known as <i>instantiating</i> a class. Here is a sample driver class that uses the <b>Stack</b> class template:</p>
<pre><code>#include &lt;iostream&gt;
#include “stack.h”
void main()
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>typedef Stack&lt;float&gt; FloatStack ;</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef Stack&lt;int&gt; IntStack ;</b>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FloatStack fs(5) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float f = 1.1 ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Pushing elements onto fs" &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (fs.push(f))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; f &lt;&lt; ' ' ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f += 1.1 ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "Stack Full." &lt;&lt; endl
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl &lt;&lt; "Popping elements from fs" &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (fs.pop(f))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; f &lt;&lt; ' ' ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "Stack Empty" &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IntStack is ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i = 1.1 ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Pushing elements onto is" &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (is.push(i))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; i &lt;&lt; ' ' ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1 ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "Stack Full" &lt;&lt; endl
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl &lt;&lt; "Popping elements from is" &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (is.pop(i))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; i &lt;&lt; ' ' ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "Stack Empty" &lt;&lt; endl ;
}
</code></pre>
<p>
Here is the output:</p>
<pre><code>Pushing elements onto fs
1.1 2.2 3.3 4.4 5.5 
Stack Full.
Popping elements from fs
5.5 4.4 3.3 2.2 1.1 
Stack Empty
Pushing elements onto is
1 2 3 4 5 6 7 8 9 10 
Stack Full
Popping elements from is
10 9 8 7 6 5 4 3 2 1 
Stack Empty
</code></pre>
<p>
In the above example we defined a class template <b>Stack</b>. In the driver program we instantiated a <b>Stack</b> of <b>float (FloatStack)</b> and a <b>Stack</b> of <b>int(IntStack)</b>. Once the template classes are instantiated, you can instantiate objects of that type (for example, <b>fs</b> and <b>is</b>.) </p>
<p>
A very good programming practice is to use <b>typedef</b> while instantiating template classes. Then throughout the program, one can use the <b>typedef</b> name. There are two advantages:
<ul type=disc>
<li>
<b>typedef</b>s are very useful when “templates of templates” are used. For example, when instantiating an int STL vector, you could use: <pre><code>typedef vector&lt;int, allocator&lt;int&gt; &gt; INTVECTOR ; 
</code></pre>
</li>
<li>
If the template definition changes, simply change the <b>typedef</b> definition. </li>
</ul>
<p>
This practice is especially helpful when using STL components. There are many implementations of STL available, some of which are incompatible. The implementation in Visual C++ 4.2 may change in future versions. For example, currently the definition of the <b>vector</b> required you to specify an <i>allocator</i> parameter:</p>
<pre><code>typedef vector&lt;int, allocator&lt;int&gt; &gt; INTVECTOR ;
INTVECTOR vi1 ;
</code></pre>
<p>
In a future version, the second parameter may not be required, for example,</p>
<pre><code>typedef vector&lt;int&gt; INTVECTOR ;
INTVECTOR vi1 ;
</code></pre>
<p>
Imagine how many changes would be required if there was no <b>typedef</b>!</p>
<h3>3.3 Sharing Data Using Static Members</h3>
<p>
Each instantiation of a class template has it’s own static members that are shared with other objects of that instantiation. This is true of static data members and static member functions.</p>
<h3>3.4 Function Templates</h3>
<p>
To perform identical operation for each type of data compactly and conveniently, use <i>function templates</i>. You can write a single function template definition. Based on the argument types provided in calls to the function, the compiler automatically instantiates separate object code functions to handle each type of call appropriately. The STL algorithms are implemented as function templates.</p>
<p>
Function templates are implemented like regular functions, except they are prefixed with the keyword <b>template</b>. Using function templates is very easy; just use them like regular functions. Here is a sample with a function template:</p>
<pre><code>#include &lt;iostream&gt;
//max returns the maximum of the two elements
template &lt;class T&gt;
T max(T a, T b)
{
 &nbsp;&nbsp; return a &gt; b ? a : b ;
}
void main()
{
 &nbsp;&nbsp; 
 &nbsp;&nbsp; cout &lt;&lt; "max(10, 15) = " &lt;&lt; max(10, 15) &lt;&lt; endl ;
 &nbsp;&nbsp; cout &lt;&lt; "max('k', 's') = " &lt;&lt; max('k', 's') &lt;&lt; endl ;
 &nbsp;&nbsp; cout &lt;&lt; "max(10.1, 15.2) = " &lt;&lt; max(10.1, 15.2) &lt;&lt; endl ;
}
</code></pre>
<p>
Here is the output:</p>
<pre><code>max(10, 15) = 15
max('k', 's') = s
max(10.1, 15.2) = 15.2
</code></pre>
<h3>3.5 Template Specialization</h3>
<p>
In some cases it is possible to override the template-generated code by providing special definitions for specific types. This is called <i>template specialization</i>. For example:</p>
<pre><code>#include &lt;iostream.h&gt;
//max returns the maximum of the two elements of type T, where T is a
//class or data type for which operator&gt; is defined.
template &lt;class T&gt;
T max(T a, T b)
{
 &nbsp;&nbsp; return a &gt; b ? a : b ;
}
void main()
{&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; cout &lt;&lt; "max(10, 15) = " &lt;&lt; max(10, 15) &lt;&lt; endl ;
 &nbsp;&nbsp; cout &lt;&lt; "max('k', 's') = " &lt;&lt; max('k', 's') &lt;&lt; endl ;
 &nbsp;&nbsp; cout &lt;&lt; "max(10.1, 15.2) = " &lt;&lt; max(10.1, 15.2) &lt;&lt; endl ;
 &nbsp;&nbsp; cout &lt;&lt; "max(\"Aladdin\", \"Jasmine\") = " &lt;&lt; max("Aladdin", "Jasmine") &lt;&lt; endl ;
}
</code></pre>
<p>
Here is the output:</p>
<pre><code>max(10, 15) = 15
max('k', 's') = s
max(10.1, 15.2) = 15.2
max("Aladdin", "Jasmine") = Aladdin
</code></pre>
<p>
Not quite the expected results! Why did that happen? The function call <b>max(“Aladdin”, “Jasmine”)</b> causes the compiler to generate code for <i>max(char*, char*)</i>, which compares the addresses of the strings! To correct special cases like these or to provide more efficient implementations for certain types, one can use template specializations. The above example can be rewritten with specialization as follows:</p>
<pre><code>#include &lt;iostream.h&gt;
#include &lt;string.h&gt;
//max returns the maximum of the two elements
template &lt;class T&gt;
T max(T a, T b)
{
 &nbsp;&nbsp; return a &gt; b ? a : b ;
}
// Specialization of max for char*
char* max(char* a, char* b)
{
 &nbsp;&nbsp; return strcmp(a, b) &gt; 0 ? a : b ;
}
void main()
{
 &nbsp;&nbsp; 
 &nbsp;&nbsp; cout &lt;&lt; "max(10, 15) = " &lt;&lt; max(10, 15) &lt;&lt; endl ;
 &nbsp;&nbsp; cout &lt;&lt; "max('k', 's') = " &lt;&lt; max('k', 's') &lt;&lt; endl ;
 &nbsp;&nbsp; cout &lt;&lt; "max(10.1, 15.2) = " &lt;&lt; max(10.1, 15.2) &lt;&lt; endl ;
 &nbsp;&nbsp; cout &lt;&lt; "max(\"Aladdin\", \"Jasmine\") = " &lt;&lt; max("Aladdin", "Jasmine") &lt;&lt; endl ;
}
</code></pre>
<p>
Here is the output:</p>
<pre><code>max(10, 15) = 15
max('k', 's') = s
max(10.1, 15.2) = 15.2
max("Aladdin", "Jasmine") = Jasmine
</code></pre>
<h3>3.6 Templates and Friends</h3>
<p>
Friendship can be established between a class template and a global function, a member function of another class (possibly a template class), or even an entire class (possibly a template class). Table 3 lists the results of declaring different kinds of friends of a class:</p>
<p class=label>
<b>Table 3. Friend Declarations</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Class Template</b></td>
<td class=label width=41%><b>Friend declaration in class template X</b></td>
<td class=label width=30%><b>Result of giving friendship</b></td>
</tr>
<tr valign=top>
<td width=29%>template class <b>&lt;T&gt;</b> class <b>X</b></td>
<td width=41%>friend void f1() ;</td>
<td width=30%>makes <b>f1()</b> a friend of all instantiations of template X. For example, <b>f1()</b> is a friend of <b>X&lt;int&gt;</b>, <b>X&lt;A&gt;</b>, and <b>X&lt;Y&gt;</b>.</td>
</tr>
<tr valign=top>
<td width=29%>template class <b>&lt;T&gt;</b> class <b>X</b></td>
<td width=41%>friend void f2(X&lt;T&gt;&amp;) ;</td>
<td width=30%>For a particular type <i>T</i> for example, float, makes <b>f2(X&lt;float&gt;&amp;)</b> a friend of class<b> X&lt;float&gt;</b> only. <b>f2(x&lt;float&gt;&amp;)</b> cannot be a friend of class <b>X&lt;A&gt;</b>.</td>
</tr>
<tr valign=top>
<td width=29%>template class <b>&lt;T&gt;</b> class <b>X</b></td>
<td width=41%>friend A::f4() ; <p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A is a user defined class </p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//with a </p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//member function f4() ;</p>
</td>
<td width=30%>makes <b>A::f4()</b> a friend of all instantiations of template X. For example, <b>A::f4() </b>is a friend of <b>X&lt;int&gt;</b>, <b>X&lt;A&gt;</b>, and <b>X&lt;Y&gt;</b>.</td>
</tr>
<tr valign=top>
<td width=29%>template class <b>&lt;T&gt;</b> class <b>X</b></td>
<td width=41%>friend C&lt;T&gt;::f5(X&lt;T&gt;&amp;) ; <p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// C is a class </p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// template</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// with a member </p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// function f5</p>
</td>
<td width=30%>A particular type <i>T</i> (for example, float) makes <b>C&lt;float&gt;::f5(X&lt;float&gt;&amp;)</b> a friend of class <b>X&lt;float&gt;</b> only. <b>C&lt;float&gt;::f5(x&lt;float&gt;&amp;)</b> cannot be a friend of class <b>X&lt;A&gt;</b>.</td>
</tr>
<tr valign=top>
<td width=29%>template class <b>&lt;T&gt;</b> class <b>X</b></td>
<td width=41%>friend class Y ;</td>
<td width=30%>makes every member function of class <b>Y</b> a friend of every template class produced from the class template <b>X</b>.</td>
</tr>
<tr valign=top>
<td width=29%>template class <b>&lt;T&gt;</b> class <b>X</b></td>
<td width=41%>friend class Z&lt;T&gt; ;</td>
<td width=30%>when a template class is instantiated with a particular type <i>T</i>, such as a float, all members of class <b>Z&lt;float&gt;</b> become friends of template class <b>X&lt;float&gt;</b>.</td>
</tr>
</table><br>
<h3>3.7 Class Templates and Nontype Parameters </h3>
<p>
The <b>Stack</b> class template, described in the previous section, used only type parameters in the template header. It is also possible to use nontype parameters. For example, the template header could be modified to take an <i>int elements</i> parameter as follows:</p>
<pre><code>template &lt;class T, int elements&gt;
class Stack ;
</code></pre>
<p>
Then, a declaration such as:</p>
<pre><code>Stack&lt;float, 100&gt; mostRecentSalesFigures ;
</code></pre>
<p>
could instantiate (at compile time) a 100 element <b>Stack</b> template class named <b>mostRecentSalesFigures</b> (of float values); this template class would be of type <b>Stack&lt;float, 100&gt;</b>.</p>
<h3>3.8 Default Template Parameters </h3>
<p>
Let us look at the <b>Stack</b> class template again:</p>
<pre><code>template &lt;class T, int elements&gt; Stack { ....} ; 

</code></pre>
<p>
C++ allows you to specify a <i>default template parameter</i>, so the definition could now look like:</p>
<pre><code>template &lt;class T = float, int elements = 100&gt; Stack { ....} ;

</code></pre>
<p>
Then a declaration such as:</p>
<pre><code>Stack&lt;&gt; mostRecentSalesFigures ;

</code></pre>
<p>
would instantiate (at compile time) a 100 element <b>Stack</b> template class named <b>mostRecentSalesFigures</b> (of float values); this template class would be of type <b>Stack&lt;float, 100&gt;</b>. </p>
<p>
If you specify a default template parameter for any formal parameter, the rules are the same as for functions and default parameters. Once a default parameter is declared, all subsequent parameters must have defaults. </p>
<h3>3.9 Member Templates </h3>
<p>
The following example demonstrates <i>member templates</i>. When you define a class template or a function template as a member of a class, it is called a member template. Visual C++ 4.2 does not support member templates.</p>
<pre><code>class MyAllocator 
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int size ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template class&lt;T&gt; class types; // member class template
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template class&lt;T&gt; print(T type) ;&nbsp; // member function template
} ;
</code></pre>
<h2><a name="stlthestl"></a>4. The Standard Template Library</h2>
<h3>4.1 Introduction</h3>
<p>
The Standard Template Library is a part of the Standard C++ Library. Every C++ programmer at one time or another has implemented common data structures such as a list or queue, and common algorithms such as binary search, sort, and so on. Through STL, C++ gives programmers a set of carefully designed generic data structures and algorithms. The generic data structures and algorithms are parameterized types (templates) that require only plugging in of actual types to be ready for use. Finally, STL brings to C++ the long promised dream of re-usable software components. </p>
<p>
The STL components are well crafted solutions, which are efficient in code space and execution time.</p>
<h3>4.2 STL Components</h3>
<ul type=disc>
<li>
<b>Containers</b> are objects that hold other objects. <p class=tl>
The <i>sequential containers</i> include vector, list, and deque.</P><p class=tl>
The <i>associative containers</i> include map, multimap, set, and multiset.</P></li>
<li>
<b>Algorithms</b> are generic functions that handle common tasks such as searching, sorting, comparing, and editing.<p class=tl>
<i>Find</i>, <i>search</i>, <i>merge</i>, <i>count</i>, <i>reverse</i>, and <i>sort</i>, are some of the algorithms provided by STL. For a complete list of algorithms refer to the documentation.</P></li>
<li>
<b>Iterators</b> are generalized pointers and act as the glue between containers and algorithms. STL algorithms are written in terms of iterator parameters, and STL containers provide iterators that can be plugged into the algorithms. <p class=tl>
STL provides the following iterators: input, output, forward, bidirectional and random access, ostream_iterator, and istream_iterator.</P></li>
<li>
<b>Function objects</b> are objects of any class or struct that overload the function call <b>operator()</b>. Most STL algorithms accept a function object as a parameter that can change the default behavior of the algorithm. <p class=tl>
STL defines function objects for basic arithmetic operations such as addition, subtraction, multiplication, and division. The associated function object types are<b> plus</b>, <b>minus</b>, <b>times</b>, and <b>divides</b>. </P><p class=tl>
STL also provides function objects for built-in operations such as unary, logical, bitwise, and comparison operators. The associated function object types are <b>modulus</b>, <b>negate</b>, <b>equal_to</b>, <b>not_equal_to</b>, <b>greater</b>, <b>less</b>, <b>greater_equal</b>, <b>less_equal</b>, <b>logical_and</b>, <b>logical_or</b>, and <b>logical_not</b>.</P></li>
<li>
<b>Adapter</b> is a component that modifies the interface of another component. For example, reverse_iterator is a component that adapts an iterator type into a new type of iterator with all the capabilities of the original, but with the same direction of traversal reversed. STL provides three kind of adapters: <b>Container Adapter</b>, <b>Iterator Adapter</b>,<b> </b>and <b>Function Adapters</b>.<br><br></li>
<li>
<b>Container adapters</b> provided by STL include <b>stack</b>, <b>queue</b>, and <b>priority_queue</b>.<br><br></li>
<li>
<b>Iterator adapters</b> provided by STL include reverse iterators, reverse_bidirectional_iterator, back_insert_iterator, front_insert_iterator, and insert_iterator.<br><br></li>
<li>
<b>Function adapters</b> provided by STL include <b>not1</b>, <b>not2</b>, <b>bind1st</b>, and <b>bind2nd</b>.</li>
</ul>
<p>
These very general components are designed to "plug together" in myriad different useful ways to produce the kind of larger and more specialized components required by programs. </p>
<h3>4.3 General Rules About STL and User-Defined Data Types</h3>
<ul type=disc>
<li>
When an object is used with an STL container, it is copied (the copy constructor is called) first and the copy is what is actually inserted into the container. <p class=tl>
This means an object held by an STL container must have a copy constructor.</P></li>
<li>
When an object is removed from an STL container, the object is destroyed (the destructor is called).<br><br></li>
<li>
When an STL container is destroyed, it destroys all objects it currently holds.<br><br></li>
<li>
Many STL components rely on making comparisons of the objects they hold (<b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, <b>&gt;=</b>, <b>==</b>, <b>!=</b>). <p class=tl>
This means the comparison operators must be defined for objects used with an STL component.</P></li>
<li>
Some STL components modify the value of an object. This is accomplished using the assignment operator. <p class=tl>
This means the assignment operator ( <b>= </b>) must be defined for objects used with an STL component. </P></li>
</ul>
<p>
The header file &lt;utility&gt; defines global versions of the <b>&lt;=</b>, <b>&gt;</b>, <b>&gt;=</b>, and <b>!=</b> operators, which are all defined in terms of the <b>&lt;</b> and <b>==</b>. Therefore, if only the <b>&lt;</b> and <b>==</b> operators are defined, the rest are defined "for free" (if any of the rest are explicitly defined for an object, the explicit definition will override the global definition). </p>
<p>
In general, it is assumed that objects to be used with STL containers have at least the following:
<ul type=disc>
<li>
A copy constructor.<br><br></li>
<li>
An assignment operator ( <b>=</b> ).<br><br></li>
<li>
An equality comparison operator ( <b>==</b> ).<br><br></li>
<li>
A less than comparison operator ( <b>&lt;</b> ).</li>
</ul>
<h2><a name="stlsequence"></a>5. Sequence Containers</h2>
<p>
Sequence containers store and retrieve their data in a sequential fashion. There are three different sequence containers defined in STL: <i>vector</i>,<b> </b><i>deque</i><b> </b>and<b> </b><i>list</i><b>.</b></p>
<h3>5.1 Vector</h3>
<pre><code>#include &lt;vector&gt;
vector&lt;class TYPE, allocator&lt;class TYPE&gt; &gt;
</code></pre>
<p>
A <i>vector</i> is similar to a normal C array, except that it can change size automatically as needed. Data access or modification is random and can be accomplished via operator[]. Insertion or erasure is efficient at the end only. Insertion or erasure of data at the beginning or in the middle requires shifting the entire array. Therefore, insertion or erasure anywhere but at the end is a <i>linear</i> operation, meaning that the time to execute the operation is a function of the number of elements that must be shifted right or left. Insertion or erasure at the end is a <i>constant</i> operation, meaning that the time to execute the operation will remain unchanged regardless of how many (or how few) elements are in the array. </p>
<p>
The following function declares a vector of 10 ints, fills the vector with the values 0 - 9, and then prints the values.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef vector&lt;int, allocator&lt;int&gt; &gt; INTVECT;
 &nbsp;&nbsp;&nbsp; void somefunct()
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp; // declare an INTVECT with slots for 10 ints
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTVECT myVector(10);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 10; i++) // fill myVector with the values 0 - 9
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myVector[i] = i;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 10; i++)&nbsp; // print the values in myVector
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; myVector[i] &lt;&lt; ", ";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
Output of <b>somefunct</b>:</p>
<pre><code>0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
</code></pre>
<p>
See <a href="#stlappendixb">APPENDIX B</a> for the vector class definition.</p>
<p>
See <a href="#stlappendixc">APPENDIX C</a> for a table of vector methods.</p>
<p>
See <a href="#stlappendixd">APPENDIX D</a> for an explanation of the <b>allocator</b> class (second template parameter above).</p>
<h3>5.2 Deque</h3>
<pre><code>#include &lt;deque&gt;
deque&lt;class TYPE, allocator&lt;class TYPE&gt; &gt;
</code></pre>
<p>
A <i>deque</i> is similar to a vector, except that insertion or erasure is efficient at either the beginning or the end. Like a vector, data access or modification is random and can be accomplished via operator[]. Insertion or erasure at either the beginning or the end is a constant operation, meaning that the time to execute the operation will remain the same, regardless of how many elements are in the array. Insertion or erasure anywhere in the middle is a linear operation, meaning that the time to execute the operation is a function of the number of items that must be shifted right or left. A deque will generate larger, slower code than a vector. In general, a vector should be used if efficient insertion/erasure at the beginning of the array is not required and a deque should be used if it is. </p>
<p>
The following function declares a deque of ints, fills the deque with the values 0-9, inserting each new value at the beginning, then prints the values.</p>
<pre><code>&nbsp;typedef deque&lt;int, allocator&lt;int&gt; &gt; INTDQ;
 &nbsp;&nbsp;&nbsp; void somefunct()
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTDQ myDeque;&nbsp;&nbsp;&nbsp;&nbsp; // declare a deque of ints
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 9; i &gt;= 0; i--)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myDeque.push_front(i);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 10; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; myDeque[i] &lt;&lt; ", ";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
Output of <b>somefunct</b>:</p>
<pre><code>0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
</code></pre>
<ul type=disc>
<li>
See <a href="#stlappendixb">APPENDIX B</a> for the deque class definition.<br><br></li>
<li>
See <a href="#stlappendixc">APPENDIX C</a> for a table of deque methods.<br><br></li>
<li>
See <a href="#stlappendixd">APPENDIX D</a> for an explanation of the <b>allocator</b> class (second template parameter above).</li>
</ul>
<h3>5.3 List</h3>
<pre><code>#include &lt;list&gt;
list&lt;class TYPE, allocator&lt;class TYPE&gt; &gt;
</code></pre>
<p>
A <i>list</i>, like a vector or a deque, is an extensible array. Lists are implemented as doubly linked lists. Therefore, insertion or erasure at any point in the array is a constant operation, meaning that the time to execute the operation will remain the same, regardless of how many elements are in the list. The penalty for using a list instead of a vector or a deque is paid in data access. There is no random access (no operator[]) for a list, meaning that accessing the <i>n</i>th object in a list requires "surfing" from the beginning of the list through N-1 objects. The following function declares a list of ints, fills the list with the values 0-9, inserting each new value at the beginning, and then prints the values.</p>
<pre><code>&nbsp;typedef list&lt;int, allocator&lt;int&gt; &gt; INTLIST;
 &nbsp;&nbsp;&nbsp; void somefunct()
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTLIST myList;&nbsp;&nbsp;&nbsp;&nbsp; // declare a list of ints
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTLIST::iterator myListPtr;&nbsp;&nbsp; // and an iterator
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 9; i &gt;= 0; i--)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myList.push_front(i);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(myListPtr = myList.begin(); myListPtr != myList.end();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myListPtr++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *myListPtr &lt;&lt; ", ";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
Output of <b>somefunct</b>:</p>
<pre><code>0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
</code></pre>
<ul type=disc>
<li>
See <a href="#stlappendixb">APPENDIX B</a> for the list class definition.<br><br></li>
<li>
See <a href="#stlappendixc">APPENDIX C</a> for a table of list methods.<br><br></li>
<li>
See <a href="#stlappendixd">APPENDIX D</a> for an explanation of the <b>allocator</b> class (second template parameter above).</li>
</ul>
<h2><a name="stlassociative"></a>6. Associative Containers</h2>
<p>
Associative containers store and retrieve their objects according to an association with each other. In other words, the data is stored and retrieved in a sorted order. Therefore, associative containers rely heavily upon comparison operators. There are four different associative containers defined in the STL. They are: <i>set</i>, <i>multiset</i>, <i>map</i> and <i>multimap</i>.</p>
<h3>6.1 Set and Multiset</h3>
<pre><code>#include &lt;set&gt;
set&lt;TYPE, PREDICATE, ALLOCATOR&gt;
</code></pre>
<p>
A <i>set</i> is optimized for fast associative lookup. For lookup purposes, objects are matched using <b>operator==</b>. Objects are ordered within the set according to the user-defined <b>comparator</b> object (the second template argument). The <b>comparator</b> object is typically "less&lt;TYPE&gt;", which causes the data to be sorted in ascending order. Each object in a set has a unique value, as duplicate objects are not allowed. A <i>multiset</i> is similar to a set, except that a multiset can contain objects with duplicate values. </p>
<p>
The following function declares a set of ints, fills it with 10 random values, then prints them:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef set&lt;int, less&lt;int&gt;, allocator&lt;int&gt; &gt; INTSET;

 &nbsp;&nbsp;&nbsp; void somefunct()
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTSET mySet;&nbsp;&nbsp; // declare a set of ints
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTSET::iterator mySetPtr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and an iterator for the set
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpVal;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srand(13);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // seed the rand function
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fill the set with 10 random ints - print them as they are added.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; 9; i++){
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpVal = rand();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; tmpVal &lt;&lt; ", ";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySet.insert(tmpVal);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // print the contents of the set (note the values are sorted)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(mySetPtr = mySet.begin(); mySetPtr != mySet.end();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySetPtr++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *mySetPtr &lt;&lt; ", ";

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp; }

</code></pre>
<p>
Output of <b>somefunct</b>:</p>
<p>
<code>81, 16376, 24096, 20348, 11872, 30076, 16059, 26999, 28493, <br>
81, 11872, 16059, 16376, 20348, 24096, 26999, 28493, 30076, </code>
<ul type=disc>
<li>
See <a href="#stlappendixb">APPENDIX B</a> for the set and multiset class definitions.<br><br></li>
<li>
See <a href="#stlappendixc">APPENDIX C</a> for a table of set and multiset methods.<br><br></li>
<li>
See <a href="#stlappendixd">APPENDIX D</a> for an explanation of the <b>allocator</b> class (third template parameter above).</li>
</ul>
<h3>6.2 Map and Multimap</h3>
<pre><code>#include &lt;map&gt;
map&lt;KEY, TYPE, PREDICATE, ALLOCATOR&gt;
</code></pre>
<p>
A <i>map</i> holds a set of ordered key/value pairs. The pairs are ordered by key, based upon the user-defined <b>comparator</b> object (3rd template parameter). A map defines a one-to-one relationship, allowing only one value to be associated with a particular key; a <i>multimap</i> defines a one-to-many relationship, allowing many values to be associated with a particular key. </p>
<p>
The following declares a map of ints to strings, fills it with 10 key/value pairs and prints them:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef map&lt;int, string, less&lt;int&gt;, allocator&lt;string&gt; &gt; INT2STRING;
 &nbsp;&nbsp;&nbsp; void somefunct()
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT2STRING myMap;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT2STRING::iterator i2sPtr;

 &nbsp;&nbsp;&nbsp;&nbsp; // Fill myMap with the digits 9 - 0 in reverse order, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // each mapped to its character string counterpart
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMap.insert(INT2STRING::value_type(9,"Nine"));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMap.insert(INT2STRING::value_type(8,"Eight"));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMap.insert(INT2STRING::value_type(7,"Seven"));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMap.insert(INT2STRING::value_type(6,"Six"));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMap.insert(INT2STRING::value_type(5,"Five"));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMap.insert(INT2STRING::value_type(4,"Four"));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMap.insert(INT2STRING::value_type(3,"Three"));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMap.insert(INT2STRING::value_type(2,"Two"));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMap.insert(INT2STRING::value_type(1,"One"));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMap.insert(INT2STRING::value_type(0,"Zero"));

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Now print the pairs - note they are now sorted
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // into ascending order...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i2sPtr = myMap.begin(); i2sPtr != myMap.end(); i2sPtr++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "(" &lt;&lt; (*i2sPtr).first &lt;&lt; ", "
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; (*i2sPtr).second &lt;&lt; “)” &lt;&lt; endl;
  }
</code></pre>
<p>
Output of <b>somefunct</b>:</p>
<pre><code>(0, Zero)
(1, One)
(2, Two)
(3, Three)
(4, Four)
(5, Five)
(6, Six)
(7, Seven)
(8, Eight)
(9, Nine)
</code></pre>
<ul type=disc>
<li>
See <a href="#stlappendixb">APPENDIX B</a> for the map and multimap class definitions<br><br></li>
<li>
See <a href="#stlappendixc">APPENDIX C</a> for a table of map and multimap methods<br><br></li>
<li>
See <a href="#stlappendixd">APPENDIX D</a> for an explanation of the <b>allocator</b> class (fourth template parameter above)</li>
</ul>
<h2><a name="stliterators"></a>7. Iterators</h2>
<p>
Iterators are generalized pointers that may be used to traverse the contents of a sequence (for example, an STL container or a C++ array). 
<ul type=disc>
<li>
Iterators provide data access for both reading and writing data in a sequence. <br><br></li>
<li>
A C++ pointer is an iterator, but an iterator is not necessarily a C++ pointer. <br><br></li>
<li>
Iterators, like pointers can be dereferenced, incremented and decremented. <br><br></li>
<li>
At any point in time, an iterator is positioned at exactly one place in one collection, and remains positioned there until explicitly moved.</li>
</ul>
<h3>7.1 Types of Iterators</h3>
<h4>7.1.1 Table of iterator categories</h4>
<p>
There are five categories of iterators. With the exception of input and output iterators, the relationship between each category of iterator is hierarchical: each iterator inherits the characteristics and behavior of the previous type, as Table 4 illustrates: </p>
<p class=label>
<b>Table 4. Iterator Categories and Characteristics</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Iterator category</b></td>
<td class=label width=76%><b>Characteristics</b></td>
</tr>
<tr valign=top>
<td width=24%>input</td>
<td width=76%>Can read one item at a time; can only move forward (increment)</td>
</tr>
<tr valign=top>
<td width=24%>output</td>
<td width=76%>Can write one item at a time; can only move forward (increment)</td>
</tr>
<tr valign=top>
<td width=24%>forward</td>
<td width=76%>Multiply derived from input and output iterators; combines their characteristics (read or write)</td>
</tr>
<tr valign=top>
<td width=24%>bidirectional</td>
<td width=76%>Derived from forward iterator; adds ability to move backwards (decrement)</td>
</tr>
<tr valign=top>
<td width=24%>random access</td>
<td width=76%>Derived from bidirectional; adds ability to jump forward or backward by an arbitrary distance</td>
</tr>
</table><br>
<p>
In classical C++ terms, input and output iterator classes are base classes, the forward iterator class is doubly derived from both the input and output iterator classes, the bidirectional iterator class is derived from the forward iterator class, and the random access iterator class is derived from the bidirectional iterator class. This hierarchy implies the following:
<ul type=disc>
<li>
An algorithm that requires only input or output iterators can also be used with forward, bidirectional, or random access iterators.<br><br></li>
<li>
An algorithm that can be used with forward iterators can also be used with bidirectional or random access iterators.<br><br></li>
<li>
An algorithm that can be used with bidirectional iterators can also be used with random access iterators.</li>
</ul>
<p>
It should also be noted that regular C++ pointers fit the characteristics of a random access iterator (and in fact can be used as a random access iterator for STL operations that support random access iterators). </p>
<h3>7.2 Iterator Interface Requirements</h3>
<p>
Different iterator types are required to have a minimum set of interface functions defined, which conform to the behaviors described below. For the following, the value type<i> T</i> is understood to be the data type of the underlying container that the iterator is interfacing with (for example, for a vector&lt;int, allocator&lt;int&gt; &gt;, <i>T</i> = int).</p>
<h4>7.2.1 Input iterator interface requirements</h4>
<p>
A class or built-in data type <i>X</i> can be used as an <i>input iterator</i> for the value type <i>T</i> if and only if the following expressions are defined for <i>X</i> and meet the behavioral requirements stated below. For Table 5, assume <i>a</i> and <i>b</i> are values of type <i>X</i>, <i>r</i> is a reference of type <i>X</i>, and <i>t</i> is a value of type <i>T</i>.</p>
<p class=label>
<b>Table 5. Input Iterator Required Behaviors</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Operator/function</b></td>
<td class=label width=76%><b>Required behavior</b></td>
</tr>
<tr valign=top>
<td width=24%><b>Copy Constructor</b></td>
<td width=76%><i>X</i>(<i>a</i>) == <i>a</i><p>
<i>X b</i>(<i>a</i>) must result in <i>a</i> == <i>b</i> </p>
</td>
</tr>
<tr valign=top>
<td width=24%><b>operator=</b></td>
<td width=76%><i>X b</i> = <i>a</i> and <i>a</i> = <i>b</i> both must result in <i>a</i> == <i>b</i></td>
</tr>
<tr valign=top>
<td width=24%><b>operator==</b></td>
<td width=76%>The return type must be convertible to bool and ‘==’ must be an equality relation (such as reflexive, transitive, or associative.)</td>
</tr>
<tr valign=top>
<td width=24%><b>operator!= </b></td>
<td width=76%>The return type must be convertible to bool and <i>a</i> != <i>b</i> must be the same as !(<i>a</i> == <i>b</i>)</td>
</tr>
<tr valign=top>
<td width=24%><b>operator*</b></td>
<td width=76%>The return type must be convertible to T. If <i>a </i>== <i>b</i> then *<i>a</i> == *<i>b</i>. Dereferencing an input stream returns a read-only reference of type <i>T</i>. This means that <b>operator*</b> can only appear on the right-hand side of an assignment statement (is an rvalue). <i>t</i> = *<i>a</i> results in <i>t</i> being assigned a value through <i>a</i>.</td>
</tr>
<tr valign=top>
<td width=24%><b>operator++</b><br>
(prefix)</td>
<td width=76%>The return type must be convertible to type <b>const X&amp;</b>. It is also assumed that the return type is dereferenceable or is the “past-the-end” value of the container. </td>
</tr>
<tr valign=top>
<td width=24%><b>operator++(int)</b><br>
(postfix)</td>
<td width=76%>The return must be convertible to type <b>const X&amp;</b>. The result must be identical to <p>
{<i>X</i> tmp = <i>r</i>; ++<i>r</i>; return tmp; }.</p>
</td>
</tr>
</table><br>
<h4>7.2.2 Output iterator interface requirements</h4>
<p>
A class or built-in data type <i>X</i> can be used as an <i>output iterator</i> for the value type <i>T</i> if and only if the following expressions are defined for <i>X</i> and meet the behavioral requirements stated below. For Table 6, assume <i>a</i> and <i>b</i> are values of type <i>X</i>, <i>r</i> is a reference of type <i>X</i>, and<i> t</i> is a value of type <i>T</i>.</p>
<p class=label>
<b>Table 6. Output Iterator Required Behavior</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=22%><b>Operator/function</b></td>
<td class=label width=78%><b>Required behavior</b></td>
</tr>
<tr valign=top>
<td width=22%><b>Copy Constructor</b></td>
<td width=78%>*<i>a</i> = <i>t</i> and *<i>X</i>(<i>a</i>) = <i>t</i>. The result of <i>X b</i>(<i>a</i>) is that <i>b</i> is a copy of <i>a</i> (Note that equality and inequality are not necessarily defined for output iterators).</td>
</tr>
<tr valign=top>
<td width=22%><b>operator=</b></td>
<td width=78%>The result of <i>X b</i> = <i>a</i> is that <i>b</i> is a copy of <i>a</i>.</td>
</tr>
<tr valign=top>
<td width=22%><b>operator*</b></td>
<td width=78%>*<i>a </i>=<i> t</i> results in the value of <i>t</i> being written to the location referenced by <i>a</i>. The return value of the operation is meaningless. Note that the only valid use of <b>operator*</b> on output iterators is on the left-hand side of an assignment (as an lvalue).</td>
</tr>
<tr valign=top>
<td width=22%><b>operator++</b> <br>
(prefix)</td>
<td width=78%>The return type must be convertible to type <b>const X&amp;</b>. It is also assumed that the return type is dereferenceable or is the “past-the-end” value of the container.</td>
</tr>
<tr valign=top>
<td width=22%><b>operator++(int)</b><br>
(postfix)</td>
<td width=78%>The return type must be convertible to type <b>const X&amp;</b>. The result must be identical to: <br>
{<i>X</i> tmp = <i>r</i>; ++<i>r</i>; return tmp; }</td>
</tr>
</table><br>
<h4>7.2.3 Forward iterator interface requirements</h4>
<p>
A class or built-in data type <i>X</i> can be used as a <i>forward iterator</i> for the value type <i>T</i> if and only if the following expressions are defined for <i>X</i>, and meet the behavioral requirements stated below. For Table 7, assume <i>a</i> and <i>b</i> are values of type <i>X</i>, <i>t</i> is a value of type <i>T</i>, and <i>r</i> and <i>s</i> are references of type <i>X</i>.</p>
<p class=label>
<b>Table 7. Forward Iterator Required Behavior</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Operator/function</b></td>
<td class=label width=76%><b>Required behavior</b></td>
</tr>
<tr valign=top>
<td width=24%><b>Default Constructor</b></td>
<td width=76%><i>X</i>() and <i>X</i> <i>a</i> both create an iterator whose position is <i>undefined</i></td>
</tr>
<tr valign=top>
<td width=24%><b>Copy Constructor</b></td>
<td width=76%><i>X</i>(<i>a</i>) == <i>a</i> and <i>X</i> <i>b</i>(<i>a</i>) must result in <i>a</i> == <i>b</i> </td>
</tr>
<tr valign=top>
<td width=24%><b>operator=</b></td>
<td width=76%><i>X b</i> = <i>a</i> and <i>a</i> = <i>b</i> must result in <i>a</i> == <i>b</i></td>
</tr>
<tr valign=top>
<td width=24%><b>operator==</b></td>
<td width=76%>The return type must be convertible to bool, and ‘==’ must be an equality relation (reflexive, transitive, associative, etc.)</td>
</tr>
<tr valign=top>
<td width=24%><b>operator!=</b></td>
<td width=76%>The return type must be convertible to bool, and a != b must be the same as !(<i>a</i> == <i>b</i>)</td>
</tr>
<tr valign=top>
<td width=24%><b>operator*</b></td>
<td width=76%>The return type must be convertible to <i>T</i>. If <i>a</i> == <i>b</i>, then *<i>a</i> == *<i>b</i>. If <i>X </i>is mutable (writable), then *<i>a</i> =<i> t</i> is valid and results in the value of <i>t</i> being written to the location referenced by <i>a</i>.</td>
</tr>
<tr valign=top>
<td width=24%><b>operator++</b> <br>
(prefix)</td>
<td width=76%>The return type must be convertible to type <b>const X&amp;</b>. It is also assumed that the return type is dereferenceable or is the “past-the-end” value of the container. In addition, <i>r</i> == <i>s</i> implies that ++<i>r</i> == ++<i>s</i>.</td>
</tr>
<tr valign=top>
<td width=24%><b>operator++(int)</b><br>
(postfix)</td>
<td width=76%>The return type must be convertible to type <b>const X&amp;</b>. The result must be identical to:<br>
{<i>X</i> tmp = <i>r</i>; ++<i>r</i>; return tmp; }</td>
</tr>
</table><br>
<h4>7.2.4 Bidirectional iterator interface requirements</h4>
<p>
A class or built-in data type <i>X</i> can be used as a <i>bidirectional</i> iterator for the value type <i>T</i> if and only if <i>X</i> conforms to the requirements of a forward iterator and defines the following expressions, which meet the behavioral requirements stated below. For Table 8, assume <i>r </i>and <i>s</i> are references of type <i>X</i>.</p>
<p class=label>
<b>Table 8. Bidirectional Iterator Required Behavior</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=22%><b>Operator/function</b></td>
<td class=label width=78%><b>Required behavior</b></td>
</tr>
<tr valign=top>
<td width=22%><b>operator--</b><br>
(prefix)</td>
<td width=78%>The return type must be convertible to type <b>const X&amp;.</b> In addition, the following properties must hold: --(++<i>r</i>) == <i>r</i>, and <i>r</i> == <i>s</i> implies that --<i>r</i> == --<i>s</i>.</td>
</tr>
<tr valign=top>
<td width=22%><b>operator--(int)</b><br>
(postfix)</td>
<td width=78%>The return type must be convertible to type <b>const X&amp;.</b> The result must be identical to:<br>
{<i>X</i> tmp = <i>r</i>; --<i>r</i>; return tmp;}</td>
</tr>
</table><br>
<h4>7.2.5 Random Access Iterator Interface Requirements</h4>
<p>
A class or built-in data type <i>X</i> can be used as a <i>random access iterator</i> for the value type <i>T </i>if and only if <i>X</i> conforms to the requirements of a bidirectional iterator and defines the following expressions, which meet the behavioral requirements stated below. For Table 9, assume <i>a</i> and <i>b</i> are values of type <i>X</i>, <i>r</i> is a reference of type <i>X</i>, and <i>n</i> is an int.</p>
<p class=label>
<b>Table 9. Random Access Iterator Required Behavior</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=23%><b>Operator/function</b></td>
<td class=label width=77%><b>Required behavior</b></td>
</tr>
<tr valign=top>
<td width=23%><b>operator+=</b></td>
<td width=77%>The return type must be convertible to <i>X</i>&amp;. The result of <i>r</i> += <i>n</i> must be the same as computing ‘<i>r</i>++’ <i>n</i> times if <i>n</i> &gt; 0 or ‘<i>r</i>--‘ abs(<i>n</i>) times if <i>n</i> &lt; 0 (trivially, <i>r</i>+=0 == 0).</td>
</tr>
<tr valign=top>
<td width=23%><b>operator+</b></td>
<td width=77%>The return type must be convertible to <i>X</i>. The result of <i>a</i> + <i>n</i> must be identical to:<br>
{<i>X</i> tmp = <i>a</i>; return tmp += <i>n</i>; }. The result of <i>n</i> + <i>a</i> must be the same as <i>a</i> + <i>n</i> (reflexive).</td>
</tr>
<tr valign=top>
<td width=23%><b>operator-=</b></td>
<td width=77%>The return type must be convertible to<i> X</i>&amp;. The result of <i>r</i> -= <i>n</i> must be the same as the result of <i>r</i> += (-<i>n</i>)</td>
</tr>
<tr valign=top>
<td width=23%><b>operator-</b></td>
<td width=77%>The result of <i>a</i> - <i>n</i> must be convertible to<i> X</i>, and identical to {<i>X</i> tmp = <i>a</i>; <br>
return tmp -= <i>n</i>; }. The result of <i>a</i> - <i>b</i> must be convertible to an integral type that can describe the difference between two locations (difference_type). If <i>a</i> - <i>b</i> = <i>n</i>, then:<br>
<i>a</i> + <i>n</i> = <i>b</i>;</td>
</tr>
<tr valign=top>
<td width=23%><b>operator[]</b></td>
<td width=77%>The return type must be convertible to <i>T</i>. The result of <i>a</i>[<i>n</i>] must be identical to *(<i>a</i> + <i>n</i>). </td>
</tr>
<tr valign=top>
<td width=23%><b>operator&lt;</b></td>
<td width=77%>The return type must be convertible to bool and operator&lt; must be a total ordering relation</td>
</tr>
<tr valign=top>
<td width=23%><b>operator&gt;</b></td>
<td width=77%>The return type must be convertible to bool. The result of <i>a</i> &gt; <i>b</i> must be identical to:<br>
<i>a</i> &lt; <i>b</i>.</td>
</tr>
<tr valign=top>
<td width=23%><b>operator&gt;=</b></td>
<td width=77%>The return type must be convertible to bool. The result of <i>a</i> &gt;= <i>b</i> must be identical to:<br>
!(<i>a</i> &lt; <i>b</i>).</td>
</tr>
<tr valign=top>
<td width=23%><b>operator&lt;=</b></td>
<td width=77%>The return type must be convertible to bool. The result of <i>a</i> &lt;= <i>b</i> must be identical to:<br>
!(<i>a</i> &gt; <i>b</i>).</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;STL provides global definitions of "<b>&gt;</b>," "<b>&gt;=</b>," "<b>&lt;=</b>," and "<b>!=</b>" defined in terms of "<b>==</b>" or "<b>&lt;</b>". This means that any object which defines "<b>==</b>" and "<b>&lt;</b>" gets the rest “for free.”</p>
<h3>7.3 Categories of Iterators Associated With STL Containers</h3>
<p>
The description of each STL container class includes the category of iterator types they provide. Table 10 lists the various STL containers and the iterators associated with each:</p>
<p class=label>
<b>Table 10. STL Containers and Iterators</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=39%><b>STL container</b></td>
<td class=label width=61%><b>Type of iterator</b></td>
</tr>
<tr valign=top>
<td width=39%>vector</td>
<td width=61%>random access</td>
</tr>
<tr valign=top>
<td width=39%>deque</td>
<td width=61%>random access</td>
</tr>
<tr valign=top>
<td width=39%>list</td>
<td width=61%>bidirectional</td>
</tr>
<tr valign=top>
<td width=39%>multiset</td>
<td width=61%>bidirectional</td>
</tr>
<tr valign=top>
<td width=39%>set</td>
<td width=61%>bidirectional</td>
</tr>
<tr valign=top>
<td width=39%>multimap</td>
<td width=61%>bidirectional</td>
</tr>
<tr valign=top>
<td width=39%>map</td>
<td width=61%>bidirectional</td>
</tr>
</table><br>
<p>
It is not necessary to remember which type of iterator works with which container. Each container, <i>C</i>&lt;<i>T</i>&gt;, supplies <b>typedefs</b> for iterators:
<ul type=disc>
<li>
<b>iterator</b> (mutable)<br><br></li>
<li>
<b>const_iterator</b> (nonmutable)</li>
</ul>
<p>
To declare an iterator, simply use the syntax <i>C</i>&lt;<i>T</i>&gt;::iterator or <i>C</i>&lt;<i>T</i>&gt;::const_iterator (see example below).</p>
<p>
The following example illustrates how to declare an iterator for a vector of ints and use that iterator to display the values:</p>
<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
typedef vector&lt;int, allocator&lt;int&gt; &gt; INTVECT;
void main()
{
 &nbsp;&nbsp;&nbsp; INTVECT myVector(5);&nbsp;&nbsp;&nbsp;&nbsp; // declare a vector of 5 ints
 &nbsp;&nbsp;&nbsp; INTVECT::iterator myIter;&nbsp;&nbsp;&nbsp;&nbsp; // declare an iterator for the vector
 &nbsp;&nbsp;&nbsp; for(int iv = 0; iv &lt; 5; iv++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myVector[iv] = iv;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fill the vector with values
 &nbsp;&nbsp;&nbsp; for(myIter = myVector.begin(); myIter != myVector.end(); myIter++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *myIter &lt;&lt; “, “;
 &nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;
}
</code></pre>
<p>
Output:</p>
<pre><code>0, 1, 2, 3, 4,
</code></pre>
<p>
Note that the termination condition for the "for loop" was “myIter != myVector.end()” instead of “myIter &lt; myVector.end()”. In the above example, the <b>&lt;</b> operator would have worked because the iterator supplied by a vector is a random access iterator. If our container had been a list, the <b>&lt;</b> operator would not have worked, as the <b>&lt;</b> operator is not defined for the bidirectional iterator that list supplies. The moral of the story is that in such a situation, using <b>!=</b> will give the same result and you don’t have to remember which kind of iterator a particular container is supplying.</p>
<h3>7.4 Stream Iterators</h3>
<p>
One of the reasons input and output iterators are defined separately is so that they can be associated with I/O streams.</p>
<h4>7.4.1 Istream iterators</h4>
<p>
STL provides a predefined iterator class called <b>istream_iterator</b>. The <b>istream_iterator</b> class is an input iterator. In<b> </b>Visual C++ version 4.2, <b>istream_iterator&lt;Value_Type, Char_Type</b>,<b> Traits_Type&gt;</b> is derived from the base class <b>iterator&lt;Value_Type, Char_Type</b>,<b> Traits_Type&gt;</b> and conforms to the requirements of an input iterator as described above. <b>istream_iterator</b> provides two constructors, one that takes an <i>input stream</i> as an argument (and ties the iterator to that stream). The other takes no arguments, and is used to provide an <i>end-of-stream marker</i> for several algorithms. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Books Online says that istream_iterator takes two template parameters, <i>Value_Type</i> and <i>Distance_Type</i>, and is derived from <b>input_iterator&lt;Value_Type, Distance_Type&gt;</b>. The classes were modified to the structure stated above for Visual C++&nbsp; 4.2 to overcome some compiler limitations. A future version of Visual C++ will return to the structure and hierarchy reflected in the Books Online. The STL is an emerging standard and will undoubtedly be changed again in the future. In order to minimize the impact these types of changes will have on existing code, the use of <b>typedefs</b> is highly recommended when declaring a particular instantiation of any STL component.</p>
<p>
The following fills a vector of strings from an input stream using the <b>copy</b> algorithm in conjunction with an <b>istream_iterator</b>:</p>
<pre><code>// STRING_INPUT is an istream iterator for objects of type string
typedef istream_iterator&lt;string, char, char_traits&lt;char&gt; &gt; STRING_INPUT;
// STRVECTOR is a vector which holds objects of type string
typedef vector&lt;string, allocator&lt;string&gt; &gt; STRVECTOR;
void main()
{
 &nbsp;&nbsp;&nbsp; string FileName;
 &nbsp;&nbsp;&nbsp; STRVECTOR theStrings;
 &nbsp;&nbsp;&nbsp; cout &lt;&lt; "Enter Input File Name: ";
 &nbsp;&nbsp;&nbsp; cin &gt;&gt; FileName;
 &nbsp;&nbsp;&nbsp; ifstream ifs(FileName.c_str());&nbsp;&nbsp; // Open the file read only
 &nbsp;&nbsp;&nbsp; // read to eof, storing each string in theStrings.
 &nbsp;&nbsp;&nbsp; copy(STRING_INPUT(ifs),STRING_INPUT(),back_inserter(theStrings));
}
</code></pre>
<p>
See section 7.6.1 for more information on the back inserter class.</p>
<h4>7.4.2 Ostream iterators</h4>
<p>
STL provides a predefined iterator class called <b>ostream_iterator</b>. The <b>ostream_iterator</b> class is an <b>output iterator</b>. In Visual C++ version 4.2, <b>ostream_iterator&lt;Value_Type, Char_Type, Traits_Type&gt;</b> is derived from the base class <b>iterator&lt;Value_Type, Char_Type, Traits_Type&gt;</b> and conforms to the requirements of an output iterator as described above. <b>ostream_iterator</b> provides two constructors, one which takes an output stream as an argument (and ties the iterator to that stream). The other takes two arguments, an <i>output stream</i> (with the same effect as the one argument <i>ctor</i>) and a <i>delimiting character</i>, which will be inserted into the stream after each object.</p>
<p>
The following is the sample from the <b>istream_iterator</b> section with a new addition. Now, the program prints the strings it has read to <i>stdout</i>, each on a new line. It accomplishes this by again calling the copy<b> </b>algorithm, this time in conjunction with the string container, and sends its output to an <b>ostream_iterator</b> object associated with <i>cout</i>:</p>
<pre><code>// STRING_INPUT is an istream_iterator for objects of type string
typedef istream_iterator&lt;string, char, char_traits&lt;char&gt; &gt; STRING_INPUT;
// STRING_OUTPUT is an ostream_iterator for objects of type string
typedef ostream_iterator&lt;string, char, char_traits&lt;char&gt; &gt; STRING_OUTPUT;
// STRVECTOR is a vector which holds objects of type string
typedef vector&lt;string, allocator&lt;string&gt; &gt; STRVECTOR;
void main()
{
 &nbsp;&nbsp;&nbsp; string FileName;
 &nbsp;&nbsp;&nbsp; STRVECTOR theStrings;
 &nbsp;&nbsp;&nbsp; cout &lt;&lt; "Enter Input File Name: ";
 &nbsp;&nbsp;&nbsp; cin &gt;&gt; FileName;
 &nbsp;&nbsp;&nbsp; ifstream ifs(FileName.c_str());&nbsp;&nbsp; // Open the file read only
 &nbsp;&nbsp;&nbsp; // read to eof, storing each string in theStrings.
 &nbsp;&nbsp;&nbsp; copy(STRING_INPUT(ifs),STRING_INPUT(),back_inserter(theStrings));
// print the contents of theStrings to cout, 
// using copy and STRING_OUTPUT
 &nbsp;&nbsp;&nbsp; copy(theStrings.begin(), theStrings.end(),&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRING_OUTPUT(cout,"\n"));
}
</code></pre>
<h3>7.5 Iterator Adapters</h3>
<p>
An adapter in STL is a<i> wrapper class</i> that takes an existing class and provides it with a new interface. There are two adapters provided by the STL for iterators: <i>reverse iterators </i>and <i>insert iterators</i>.</p>
<h4>7.5.1 Reverse iterators</h4>
<p>
Reverse iterator adapters transform their iterators to traverse a collection from back to front. There are two adapters supplied by the STL: <b>reverse_bidirectional_iterator</b>, which transforms bidirectional iterators, and <b>reverse_iterator</b>, which transforms random access iterators. Each container, <i>C</i>&lt;<i>T</i>&gt;, supplies <b>typedefs</b> for reverse iterators:
<ul type=disc>
<li>
<b>reverse_iterator</b> (mutable)<br><br></li>
<li>
<b>const_reverse_iterator</b> (nonmutable)</li>
</ul>
<p>
to declare an iterator, simply use the syntax <b>C&lt;T&gt;::reverse_iterator</b> or <b>C&lt;T&gt;::const_reverse_iterator</b> (see example below).</p>
<p>
The following example illustrates how to declare a reverse iterator for a vector of ints and use that iterator to display the values in reverse order:</p>
<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
typedef vector&lt;int, allocator&lt;int&gt; &gt; INTVECT;
void main()
{
 &nbsp;&nbsp;&nbsp; INTVECT myVector(5);&nbsp;&nbsp;&nbsp;&nbsp; // declare a vector of 5 ints
 &nbsp;&nbsp;&nbsp; // declare a reverse iterator for the vector
 &nbsp;&nbsp;&nbsp; INTVECT::reverse_iterator myIter; 
 &nbsp;&nbsp;&nbsp; for(int iv = 0; iv &lt; 5; iv++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myVector[iv] = iv;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fill the vector with values
 &nbsp;&nbsp;&nbsp; for(myIter = myVector.rbegin(); myIter != myVector.rend(); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myIter++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *myIter &lt;&lt; “, “;
 &nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;
}
</code></pre>
<p>
Output:</p>
<pre><code>4, 3, 2, 1, 0,
</code></pre>
<p>
Note the use of <b>rbegin</b> and <b>rend</b> in the above example. Just as each type of STL container supplies <b>begin</b> and <b>end</b> member functions (which return regular iterators), each also supplies <b>rbegin</b> and <b>rend</b> member functions (which return reverse iterators).</p>
<p>
When reverse iterators are passed to a generic algorithm, they make the algorithm work in reverse. Consider the <b>sort</b> algorithm:</p>
<pre><code>sort(myVector.begin(), myVector.end());
</code></pre>
<p>
Sorts the contents of <b>myVector</b> into ascending order, and:</p>
<pre><code>sort(myVector.rbegin(), myVector.rend());
</code></pre>
<p>
Sorts the contents into ascending order as seen from back to front, which results in the contents being sorted into descending order.</p>
<h3>7.6 Insert Iterators</h3>
<p>
Insert iterators put an algorithm into <i>insert mode</i>. The most useful effect of this is that insert iterators use insert operations (which expand allocated memory as needed) instead of assignment operations (which assume the space is available) to add objects to a target container. This is done via a redefinition of <b>operator*</b>, so that <b>*i =</b> … calls one of the container’s insert functions instead of <b>operator=</b>. Consider the following use of the <b>copy</b> algorithm to copy the objects from a deque to a vector:</p>
<pre><code>// v1 is and empty vector
vector&lt;int, allocator&lt;int&gt; &gt; v1;&nbsp;&nbsp; 
// d1 holds 100 1’s
deque&lt;int, allocator&lt;int&gt; &gt; d1(100, 1);
// causes an error
copy(d1.begin(), d1.end(), v1.begin());&nbsp;&nbsp; 
</code></pre>
<p>
The call to <b>copy</b> above will cause a run-time error (probably a GPF) when<b> *(v1.begin()) = *(d1.begin())</b> is called, because v1 does not have any memory allocated for itself. Replacing <b>v1.begin()</b> with an insert iterator, such as <b>back_inserter</b> will solve the problem as follows:</p>
<pre><code>copy(d1.begin(), d1.end(), back_inserter(v1));&nbsp; // executes correctly
</code></pre>
<p>
Now, <b>*(v1.begin()) = *(d1.begin())</b> (and all subsequent assignments) map to <b>vector::push_back</b> instead of <b>vector::operator=</b>. STL provides three insert adapters: <b>back_inserter</b>, <b>front_inserter</b>, and <b>inserter</b>.</p>
<h4>7.6.1 back_inserter iterators</h4>
<p>
As noted above, <b>back_inserter</b> iterators call the <b>push_back</b> method of the container instead of <b>operator=</b> when the iterator’s <b>operator*</b> method is invoked as an l-value. This means that <b>back_inserter</b> iterators can only be used with containers that support the <b>push_back</b> method (vector, deque, list). The following illustrates a declaration of a <b>back_inserter</b> iterator to be associated with a vector:</p>
<pre><code>// declare a vector of ints
vector&lt;int, allocator&lt;int&gt; &gt; iV;&nbsp;&nbsp; 
// declare a back_inserter iterator associated with iV
back_inserter iVPtr(iV);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</code></pre>
<h4>7.6.2 front_inserter iterators</h4>
<p>
Because<b> front_inserter</b> iterators call the <b>push_front</b> method of the container instead of <b>operator=</b> when the iterator’s <b>operator*</b> method is invoked as an l-value, <b>front_inserter</b> iterators can only be used with containers that support the <b>push_front</b> method (deque, list). The following illustrates a declaration of a <b>front_inserter</b> iterator to be associated with a list:</p>
<pre><code>// declare a list of ints
list&lt;int, allocator&lt;int&gt; &gt; iL;
// declare a front_inserter iterator associated with iL
front_inserter iLPtr(iL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</code></pre>
<h4>7.6.3 Inserter iterators</h4>
<p>
<b>Inserter</b> iterators call the <b>insert</b> method of the container instead of <b>operator=</b> when the iterator’s <b>operator*</b> method is invoked as an l-value. This means that <b>inserter iterators</b> can be used with all the STL containers, even the sorted associative containers, as they all support an <b>insert</b> method. The following illustrates a declaration of an <b>inserter </b>iterator to be associated with a set that inserts its objects beginning at the second item in the set.</p>
<pre><code>// declare a set of ints
set&lt;int, less&lt;int&gt;, allocator&lt;int&gt; &gt; iS;&nbsp;&nbsp; 
// declare an inserter iterator associated with iS
inserter(iS, iS.begin() + 1); 
</code></pre>
<h2><a name="stladaptors"></a>8. Container Adapters</h2>
<p>
An adapter in STL is a <i>wrapper class</i> that takes an existing class and provides it with a new interface. There are three adapters provided by the STL for containers: <b>stack, queue,</b> and <b>priority_queue.</b></p>
<h3>8.1 Stack</h3>
<p>
A <b>stack</b> adapts any STL container that supports the <b>push_back</b> and <b>pop_back</b> member functions. It implements a container that performs as stack (Last In, First Out). A <b>stack</b> may be used to adapt the behavior of a vector, deque or list (as all three support <b>push_back</b> and <b>pop_back</b>). The deque is the most commonly used container with a <b>stack.</b></p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In most implementations of the STL, deque is the default value for the second template parameter of a <b>stack</b> (the second template parameter specifies the stored container type). In Visual C++ 4.2, the default argument is not defined due to compiler limitations.</p>
<p>
The following declares a <b>stack</b> of ints, pushes nine values onto the <b>stack</b>, and then pops each one after printing it:</p>
<pre><code>typedef allocator&lt;int&gt; IALLOC;
typedef deque&lt;int, IALLOC&gt; IDQ;
typedef stack&lt;int, IDQ, IALLOC&gt; ISTACK;
void somefunct(void)
{
 &nbsp; ISTACK MyStack;
 &nbsp; for(int i = 1; i &lt; 10; i++)
 &nbsp;&nbsp;&nbsp;&nbsp; MyStack.push(i);
 &nbsp; while(MyStack.size()){
 &nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; MyStack.top() &lt;&lt; ", ";
 &nbsp;&nbsp;&nbsp;&nbsp; MyStack.pop();
 &nbsp; }
 &nbsp; cout &lt;&lt; endl;
}
</code></pre>
<p>
Output:</p>
<pre><code>9, 8, 7, 6, 5, 4, 3, 2, 1,
</code></pre>
<ul type=disc>
<li>
See <a href="#stlappendixb">APPENDIX B</a> for the <b>stack</b> class definition<br><br></li>
<li>
See <a href="#stlappendixc">APPENDIX C</a> for a table of <b>stack</b> methods<br><br></li>
<li>
See <a href="#stlappendixd">APPENDIX D</a> for an explanation of the <b>allocator</b> class (typedef’d as IALLOC above)</li>
</ul>
<h3>8.2 Queue</h3>
<p>
A <b>queue</b> adapts any STL container that supports the <b>push_back</b> and <b>pop_front</b> member functions. It implements a container that performs as a queue (First In First Out). A <b>queue</b> may be used to adapt the behavior of a deque or list (as both support <b>push_back</b> and <b>pop_front</b>). The deque is the most commonly used container with a <b>queue</b>. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In most implementations of the STL, deque is the default value for the second template parameter of a queue (the second template parameter specifies the stored container type). In Visual C++ version 4.2, the default argument is not defined due to compiler limitations.</p>
<p>
The following declares a <b>queue</b> of ints, pushes nine values onto the <b>queue</b>, and then pops each one after printing it:</p>
<pre><code>typedef allocator&lt;int&gt; IALLOC;
typedef deque&lt;int, IALLOC&gt; IDQ;
typedef queue&lt;int, IDQ, IALLOC&gt; IQUEUE;
void somefunct(void)
{
 &nbsp; IQUEUE MyQueue;
 &nbsp; for(int i = 1; i &lt; 10; i++)
 &nbsp;&nbsp;&nbsp;&nbsp; MyQueue.push(i);
 &nbsp; while(MyQueue.size()){
 &nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; MyQueue.front() &lt;&lt; ", ";
 &nbsp;&nbsp;&nbsp;&nbsp; MyQueue.pop();
 &nbsp; }
 &nbsp; cout &lt;&lt; endl;
}
</code></pre>
<p>
Output:</p>
<pre><code>1, 2, 3, 4, 5, 6, 7, 8, 9,
</code></pre>
<ul type=disc>
<li>
See <a href="#stlappendixb">APPENDIX B</a> for the <b>queue</b> class definition<br><br></li>
<li>
See <a href="#stlappendixc">APPENDIX C</a> for a table of <b>queue</b> methods<br><br></li>
<li>
See <a href="#stlappendixd">APPENDIX D</a> for an explanation of the <b>allocator</b> class (<b>typedef</b> as IALLOC above)</li>
</ul>
<h3>8.3 Priority_Queue</h3>
<p>
A <b>priority_queue</b> adapts any STL container that has a random access iterator to maintain a sorted collections of items. A <b>priority_queue</b> may be used to adapt the behavior of a vector or a deque (as both are associated with a random access iterator and support <b>operator[]</b>). The vector is the most commonly used container with a <b>priority_queue</b>. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In most implementations of the STL, vector is the default value for the second template parameter of a <b>priority_queue</b> (the second template parameter specifies the stored container type). In Visual C++ 4.2, the default argument is not defined due to compiler limitations.</p>
<p>
The third template parameter allows you to specify the comparator used to sort the items. The following declares a <b>priority_queue</b> of ints, fills it with 10 random values and prints them in sorted order:</p>
<pre><code>typedef allocator&lt;int&gt; IALLOC;
typedef vector&lt;int, IALLOC&gt; IV;
typedef priority_queue&lt;int, IV, less&lt;int&gt;, IALLOC&gt; PQUEUE;
void somefunct(void)
{
 &nbsp; PQUEUE MyQueue;
 &nbsp; for(int i = 1; i &lt; 10; i++)
 &nbsp;&nbsp;&nbsp;&nbsp; MyQueue.push(rand() % 10);
 &nbsp; while(MyQueue.size()){
 &nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; MyQueue.top() &lt;&lt; ", ";
 &nbsp;&nbsp;&nbsp;&nbsp; MyQueue.pop();
 &nbsp; }
 &nbsp; cout &lt;&lt; endl;
}
</code></pre>
<p>
Output:</p>
<pre><code>9, 8, 8, 7, 4, 4, 2, 1, 0,
</code></pre>
<ul type=disc>
<li>
See <a href="#stlappendixb">APPENDIX B</a> for the <b>priority_queue</b> class definition<br><br></li>
<li>
See <a href="#stlappendixc">APPENDIX C</a> for a table of <b>priority_queue</b> methods<br><br></li>
<li>
See <a href="#stlappendixd">APPENDIX D</a> for an explanation of the <b>allocator</b> class (<b>typedef</b> to IALLOC above)</li>
</ul>
<h2><a name="stlstring"></a>9. The C++ String Class</h2>
<h3>9.1 Introduction</h3>
<p>
How often have C++ programmers wished they could add two strings using an obvious syntax like <i>s1 + s2</i>? Or add characters to a string using a syntax like <i>s1 + “Hi”</i>? Even Microsoft Basic allows that syntax.</p>
<p>
The Standard C++ Library provides C++ programmers with a powerful string class. The <b>string</b> class is based on the <b>basic_string </b>class template. </p>
<p>
Standard C++ declares two type definitions, <b>string</b> and <b>wstring</b>, based on <b>basic_string</b>:</p>
<pre><code>typedef basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; <b>string</b>;
typedef basic_string&lt;wchar_t, char_traits&lt;wchar_t&gt;, allocator&lt;wchar_t&gt; &gt; <b>wstring</b>;
</code></pre>
<p>
The <b>basic_string</b> has been defined in the header <b>&lt;xstring&gt;. </b></p>
<p>
The C++ <b>string</b> class is very easy to use. Table 11 describes all the member functions in brief and the sample in the following section demonstrates the C++ <b>string</b> class.</p>
<p class=label>
<b>Table 11. String Class Member Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Member function</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; append(const char *s);</b></td>
<td width=50%>Appends the sequence specified by <i>*s</i> to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; append(const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n);</b></td>
<td width=50%>Appends <i>n</i> characters of the sequence specified by <i>*s</i> to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; append(const string&amp; str, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n);</b></td>
<td width=50%>Appends <i>n</i> characters of the sequence specified by <i>str</i> starting at position <i>pos</i> to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; append(const string&amp; str);</b></td>
<td width=50%>Appends the sequence specified by <i>str</i> to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; append(size_type n, char c);</b></td>
<td width=50%>Appends <i>n</i> copies of the character specified by <i>c</i> to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; append(const_iterator first, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const_iterator last);</b></td>
<td width=50%>Appends the sequence specified by [first, last) to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp;assign(const char *s);</b></td>
<td width=50%>Replaces the sequence controlled by *<i>this</i> with the sequence specified by <i>*s</i>, then returns *this.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; assign(const char *s, size_type n);</b></td>
<td width=50%>Replaces the sequence controlled by *<i>this</i> with <i>n</i> characters of the sequence specified by <i>*s</i>, then returns *<i>this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; assign(const string&amp; str,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n);<br>
</b></td>
<td width=50%>Replaces the sequence controlled by *<i>this</i> with <i>n</i> characters of the sequence specified by <i>str</i>, starting at position <i>pos</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; assign(const string&amp; str);</b></td>
<td width=50%>Replaces the sequence controlled by *<i>this</i> with the sequence specified by <i>str</i>, then returns *<i>this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; assign(size_type n, char c);</b></td>
<td width=50%>Replaces the sequence controlled by *<i>this</i> with <i>n</i> copies of the character specified by <i>c</i>, then returns *<i>this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; assign(const_iterator first, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const_iterator last);</b></td>
<td width=50%>Replaces the sequence specified by [first, last) to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_reference at(size_type pos) const;<br>
reference at(size_type pos) ;</b></td>
<td width=50%>Returns a reference to the element of the controlled sequence at position <i>pos</i>, or reports an out-of-range error.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_iterator begin() const;<br>
iterator begin();</b></td>
<td width=50%>Returns a random-access iterator that points at the first element of the sequence (or just beyond the end of an empty sequence).</td>
</tr>
<tr valign=top>
<td width=50%><b>const char *c_str() const;</b></td>
<td width=50%>Returns a pointer to a nonmodifiable C string constructed by adding a terminating null element (<i>traits_type:: eos()</i>) to the controlled sequence. Calling any non-<b>const</b> member function for *<i>this</i> can invalidate the pointer.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type capacity() const;</b></td>
<td width=50%>The member function returns the storage currently allocated to hold the controlled sequence, a value at least as large as <i>size()</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>int compare(const string&amp; str) const;</b></td>
<td width=50%>Compares elements of the controlled sequence, if these arguments are not supplied, to the sequence specified by <i>str</i>. The function returns:<p>
· &nbsp;&nbsp;&nbsp; a negative value if the first differing element in the controlled sequence compares less than the corresponding element in <i>str</i> , or if the two have a common prefix but <i>str</i><b> </b>is longer.</p>
<p>
· &nbsp;&nbsp;&nbsp; zero if the two compare equal, element by element, and are the same length.</p>
<p>
· &nbsp;&nbsp;&nbsp; a positive value otherwise.</p>
</td>
</tr>
<tr valign=top>
<td width=50%><b>int compare(size_type p0, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const string&amp; str);</b></td>
<td width=50%>Compares up to <i>n0</i> elements of the controlled sequence, beginning with position <i>p0</i>, to the sequence specified by <i>str</i>. The function returns:<p>
· &nbsp;&nbsp;&nbsp; a negative value if the first differing element in the controlled sequence compares less than the corresponding element in <i>str</i>, or if the two have a common prefix but <i>str</i> is longer.</p>
<p>
· &nbsp;&nbsp;&nbsp; zero if the two compare equal, element by element, and are the same length.</p>
<p>
· &nbsp;&nbsp;&nbsp; a positive value otherwise.</p>
</td>
</tr>
<tr valign=top>
<td width=50%><b>int compare(size_type p0, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const string&amp; str, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n);</b></td>
<td width=50%>compares up to <i>n0</i> elements of the controlled sequence beginning with position <i>p0</i>, to <i>n</i> elements of <i>str</i> beginning with position <i>pos. </i>The function returns:<p>
· &nbsp;&nbsp;&nbsp; a negative value if the first differing element in the controlled sequence compares less than the corresponding element in <i>str</i>, or if the two have a common prefix but <i>str</i> is longer.</p>
<p>
· &nbsp;&nbsp;&nbsp; zero if the two compare equal, element by element, and are the same length.</p>
<p>
· &nbsp;&nbsp;&nbsp; a positive value otherwise.</p>
</td>
</tr>
<tr valign=top>
<td width=50%><b>int compare(const char *s) const;</b></td>
<td width=50%>Compares elements of the controlled sequence, if these arguments are not supplied, to the sequence specified by <i>*s</i>. The function returns:<p>
· &nbsp;&nbsp;&nbsp; a negative value if the first differing element in the controlled sequence compares less than the corresponding element in <i>*s</i> , or if the two have a common prefix but <i>*s</i> is longer.</p>
<p>
· &nbsp;&nbsp;&nbsp; zero if the two compare equal, element by element, and are the same length.</p>
<p>
· &nbsp;&nbsp;&nbsp; a positive value otherwise.</p>
</td>
</tr>
<tr valign=top>
<td width=50%><b>int compare(size_type p0, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s);</b></td>
<td width=50%>Compares up to <i>n0</i> elements of the controlled sequence, beginning with position <i>p0</i>, to the sequence specified by <i>*s</i>. The function returns:<p>
· &nbsp;&nbsp;&nbsp; a negative value if the first differing element in the controlled sequence compares less than the corresponding element in <i>*s</i> , or if the two have a common prefix but <i>*s</i> is longer.</p>
<p>
· &nbsp;&nbsp;&nbsp; zero if the two compare equal, element by element, and are the same length.</p>
<p>
· &nbsp;&nbsp;&nbsp; a positive value otherwise.</p>
</td>
</tr>
<tr valign=top>
<td width=50%><b>int compare(size_type p0, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n);</b></td>
<td width=50%>Compares up to <i>n0</i> elements of the controlled sequence beginning with position <i>p0</i>, to <i>n</i> elements of <i>*s</i> beginning with position <i>pos. </i>The function returns:<p>
· &nbsp;&nbsp;&nbsp; a negative value if the first differing element in the controlled sequence compares less than the corresponding element in <i>*s</i> , or if the two have a common prefix but <i>*s</i> is longer.</p>
<p>
· &nbsp;&nbsp;&nbsp; zero if the two compare equal element by element and are the same length.</p>
<p>
· &nbsp;&nbsp;&nbsp; a positive value otherwise.</p>
</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type copy(char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Copies up to <i>n</i> elements from the controlled sequence, beginning at position <i>pos</i>, to the array of <b>char</b> beginning at <i>*s</i>. It returns the number of elements actually copied.</td>
</tr>
<tr valign=top>
<td width=50%><b>const E *data() const;</b></td>
<td width=50%>The member function returns a pointer to the first element of the sequence (or, for an empty sequence, a non-null pointer that cannot be dereferenced).</td>
</tr>
<tr valign=top>
<td width=50%><b>bool empty() const;</b></td>
<td width=50%>The member function returns true for an empty controlled sequence.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_iterator end() const;<br>
iterator end();</b></td>
<td width=50%>The member functions each return a random-access iterator that points just beyond the end of the sequence.</td>
</tr>
<tr valign=top>
<td width=50%><b>iterator erase(iterator first, iterator last);</b></td>
<td width=50%>Removes the elements of the controlled sequence in the range [first, last). Returns an iterator that designates the first element remaining beyond any elements removed, or <b>end()</b> if no such element exists.</td>
</tr>
<tr valign=top>
<td width=50%><b>iterator erase(iterator it);</b></td>
<td width=50%>Removes the element of the controlled sequence pointed to by it. Return an iterator that designates the first element remaining beyond any elements removed, or <b>end()</b> if no such element exists.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; erase(size_type p0 = 0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n = npos);</b></td>
<td width=50%>Removes up to <i>n</i> elements of the controlled sequence beginning at position <i>p0</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find(char c, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the first character in the controlled sequence, beginning on or after position <i>pos</i>, that matches the character specified by <i>c</i>. If it succeeds, it returns the position where the matching character was found. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find(const char *s,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the first subsequence in the controlled sequence, beginning on or after position <i>pos</i>, that matches the sequence specified by <i>*s</i>. If it succeeds, it returns the position where the matching subsequence begins. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find(const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n) const;</b></td>
<td width=50%>Finds the first subsequence in the controlled sequence, beginning on or after position <i>pos</i>, that matches the first <i>n</i> characters of sequence <i>*s</i>. If it succeeds, it returns the position where the matching subsequence begins. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find(const string&amp; str, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the first subsequence in the controlled sequence, beginning on or after position <i>pos</i>, that matches the sequence specified by <i>str</i>. If it succeeds, it returns the position where the matching subsequence begins. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_first_not_of(char c, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the first (lowest position) element of the controlled sequence, at or after position <i>pos</i>, that does not match with the character <i>c</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_first_not_of(const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the first (lowest position) element of the controlled sequence, at or after position <i>pos</i>, that matches none of the elements in the sequence specified by <i>*s</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_first_not_of(const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n) const;</b></td>
<td width=50%>Finds the first (lowest position) element of the controlled sequence, at or after position <i>pos</i>, that matches none of the elements in the sequence specified by the first <i>n</i> characters of <i>*s</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_first_not_of<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (const string&amp; str,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the first (lowest position) element of the controlled sequence, at or after position <i>pos</i>, that matches none of the elements in the sequence specified by <i>str</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_first_of(char c, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the first (lowest position) element of the controlled sequence, at or after position <i>pos</i>, that does matches with the character <i>c</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_first_of(const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the first (lowest position) element of the controlled sequence, at or after position <i>pos</i>, that matches any of the elements in the sequence specified by <i>*s</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_first_of(const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n) const;</b></td>
<td width=50%>Finds the first (lowest position) element of the controlled sequence, at or after position <i>pos</i>, that matches any of the elements in the sequence specified by the first <i>n</i> characters of <i>*s</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_first_of<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (const string&amp; str,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the first (lowest position) element of the controlled sequence, at or after position <i>pos</i>, that matches any of the elements in the sequence specified by <i>str</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_last_not_of(char c, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the last (highest position) element of the controlled sequence, at or after position <i>pos</i>, that does not match with the character <i>c</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_last_not_of(const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the last (highest position) element of the controlled sequence, at or after position <i>pos</i>, that matches none of the elements in the sequence specified by <i>*s</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_last_not_of(const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n) const;</b></td>
<td width=50%>Finds the last (highest position) element of the controlled sequence, at or after position <i>pos</i>, that matches none of the elements in the sequence specified by last <i>n</i> characters of <i>*s</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_last_not_of<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (const string&amp; str,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the last (highest position) element of the controlled sequence, at or after position <i>pos</i>, that matches none of the elements in the sequence specified by <i>str</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_last_of(char c, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the last (highest position) element of the controlled sequence, at or after position <i>pos</i>, that does matches with the character <i>c</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_last_of(const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the last (highest position) element of the controlled sequence, at or after position <i>pos</i>, that matches any of the elements in the sequence specified by <i>*s</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_last_of(const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n) const;</b></td>
<td width=50%>Finds the last (highest position) element of the controlled sequence, at or after position <i>pos</i>, that matches any of the elements in the sequence specified by the last <i>n</i> characters of <i>*s</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type find_last_of<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (const string&amp; str,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the last (highest position) element of the controlled sequence, at or after position <i>pos</i>, that matches any of the elements in the sequence specified by <i>str</i>. If it succeeds, it returns the position. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; insert(size_type p0, const char *s);</b></td>
<td width=50%>Inserts, after position <i>p0</i> or after the element it points to in the controlled sequence, the sequence specified by <i>*s</i>. It returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; insert(size_type p0, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n);</b></td>
<td width=50%>Inserts, after position <i>p0</i> or after the element it points to in the controlled sequence, the first <i>n</i> characters of the sequence specified by <i>*s</i>. It returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; insert(size_type p0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const string&amp; str,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n);</b></td>
<td width=50%>Inserts, after position <i>p0</i> or after the element itpoints to in the controlled sequence, <i>n</i> characters of the sequence specified by <i>str</i>, beginning at position <i>pos</i>. It returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; insert(size_type p0, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const string&amp; str);</b></td>
<td width=50%>Inserts, after position <i>p0</i> or after the element it points to in the controlled sequence, the sequence specified by <i>str</i> It returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; insert(size_type p0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char c);</b></td>
<td width=50%>Inserts, after position <i>p0</i> or after the element it points to in the controlled sequence, <i>n</i> copies of character <i>c</i>. It returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>void insert(iterator it,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const_iterator first, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const_iterator last);</b></td>
<td width=50%>Inserts, after position <i>it</i> in the controlled sequence, the sequence specified by [first, last). </td>
</tr>
<tr valign=top>
<td width=50%><b>iterator insert(iterator it, char c);</b></td>
<td width=50%>Inserts, after position <i>it</i> in the controlled sequence, the character specified by <i>c</i>. </td>
</tr>
<tr valign=top>
<td width=50%><b>void insert(iterator it, size_type n, char c);</b></td>
<td width=50%>Inserts, after position <i>it</i> in the controlled sequence, <i>n</i> copies of the character specified by <i>c</i>. </td>
</tr>
<tr valign=top>
<td width=50%><b>size_type length() const;</b></td>
<td width=50%>Returns the length of the controlled sequence (same as <b>size()</b>).</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type max_size() const;</b></td>
<td width=50%>Returns the length of the longest sequence that the object can control.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; operator+=(const char *s);</b></td>
<td width=50%>Appends the sequence specified by <i>*s</i> to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; operator+=(const string&amp; str);</b></td>
<td width=50%>Appends the sequence specified by <i>str</i> to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; operator+=(char c);</b></td>
<td width=50%>Appends the character specified by <i>c</i> to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; operator=(const char *s);</b></td>
<td width=50%>Replaces the sequence specified by <i>*s</i> to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; operator=(const string&amp; str);</b></td>
<td width=50%>Replaces the sequence specified by <i>str</i> to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; operator=(char c);</b></td>
<td width=50%>Replaces the character specified by <i>c</i> to the end of the sequence controlled by <i>*this</i>, then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_reference operator[]<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (size_type pos) const;<br>
reference operator[](size_type pos);</b></td>
<td width=50%>Returns a reference to the element of the controlled sequence at position <i>pos</i>. If that position is invalid, the behavior is undefined.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_reverse_iterator rbegin() const;<br>
reverse_iterator rbegin();</b></td>
<td width=50%>Returns a reverse iterator that points just beyond the end of the controlled sequence. Hence, it designates the beginning of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_reverse_iterator rend() const;<br>
reverse_iterator rend();</b></td>
<td width=50%>Returns a reverse iterator that points at the first element of the sequence (or just beyond the end of an empty sequence). Hence, it designates the end of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; replace(size_type p0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s);</b></td>
<td width=50%>Replaces up to <i>n0</i> elements of the controlled sequence beginning with position <i>p0</i>. The replacement is the sequence specified by <i>*s</i>. The function then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; replace(size_type p0, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n);</b></td>
<td width=50%>Replaces up to <i>n0</i> elements of the controlled sequence beginning with position <i>p0</i>. The replacement is the first <i>n</i> specified by *<i>s</i>. The function then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; replace(size_type p0, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const string&amp; str);</b></td>
<td width=50%>Replaces up to <i>n0</i> elements of the controlled sequence beginning with position <i>p0</i>. The replacement is the first <i>n</i> characters of <i>str</i>. The function then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; replace(size_type p0, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const string&amp; str,&nbsp;&nbsp;&nbsp; <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n);</b></td>
<td width=50%>Replaces up to <i>n0</i> elements of the controlled sequence beginning with position <i>p0</i>. The replacement is <i>n</i> characters of <i>str</i>, beginning at position <i>pos</i>. The function then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; replace(size_type p0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char c);</b></td>
<td width=50%>Replaces up to <i>n0</i> elements of the controlled sequence beginning with position <i>p0</i>. The replacement is <i>n</i> copies of character <i>c</i>. The function then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; replace(iterator first0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s);</b></td>
<td width=50%>Replaces the elements of the controlled sequence beginning with the one pointed to by <i>first0</i>, up to but not including <b>last0</b>. The replacement is the sequence specified by <i>*s</i>. The function then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; replace(iterator first0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n);</b></td>
<td width=50%>Replaces the elements of the controlled sequence beginning with the one pointed to by <i>first0</i>, up to but not including <b>last0</b>. The replacement is first <i>n</i> characters of the sequence specified by <i>*s</i>. The function then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; replace(iterator first0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const string&amp; str);</b></td>
<td width=50%>Replaces the elements of the controlled sequence beginning with the one pointed to by <b>first0</b>, up to but not including <b>last0</b>. The replacement is the sequence specified by <i>str</i>. The function then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; replace(iterator first0, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char c);</b></td>
<td width=50%>Replaces the elements of the controlled sequence beginning with the one pointed to by <b>first0</b>, up to but not including <b>last0</b>. The replacement is <i>n</i> copies of the character <i>c</i>. The function then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string&amp; replace(iterator first0, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const_iterator first,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const_iterator last);</b></td>
<td width=50%>Replaces the elements of the controlled sequence beginning with the one pointed to by <b>first0</b>, up to but not including <b>last0</b>. The replacement is the elements of the sequence beginning with the one pointed to by <b>first</b>, up to but not including <b>last</b>. The function then returns <i>*this</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>void reserve(size_type n);</b></td>
<td width=50%>The member function ensures that <b>capacity</b>() henceforth returns at least <i>n</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>void resize(size_type n, char c = char());</b></td>
<td width=50%>The member function ensures that <b>size</b>() henceforth returns <i>n</i>. If it must make the controlled sequence longer, it appends elements with value <i>c</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type rfind(char c, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the last character in the controlled sequence, beginning on or after position <i>pos</i>, that matches the character specified by <i>c</i>. If it succeeds, it returns the position where the matching character was found. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type rfind(const char *s,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the last subsequence in the controlled sequence, beginning on or after position <i>pos</i>, that matches the sequence specified by <i>*s</i>. If it succeeds, it returns the position where the matching subsequence begins. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type rfind(const char *s, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n) const;</b></td>
<td width=50%>Finds the last subsequence in the controlled sequence, beginning on or after position <i>pos</i>, that matches the first <i>n</i> characters of sequence <i>*s</i>. If it succeeds, it returns the position where the matching subsequence begins. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type rfind(const string&amp; str, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type pos = 0) const;</b></td>
<td width=50%>Finds the last subsequence in the controlled sequence, beginning on or after position <i>pos</i>, that matches the sequence specified by <i>str</i>. If it succeeds, it returns the position where the matching subsequence begins. Otherwise, the function returns <i>npos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type size() const;</b></td>
<td width=50%>Returns the length of the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=50%><b>string substr(size_type pos = 0,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_type n = npos) const;</b></td>
<td width=50%>Returns an object whose controlled sequence is a copy of up to <i>n</i> elements of the controlled sequence beginning at position <i>pos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>void swap(string&amp; str);</b></td>
<td width=50%>Swaps the controlled sequences between <i>*this</i> and <i>str</i>. </td>
</tr>
<tr valign=top>
<td width=50%><b>string()</b></td>
<td width=50%>Constructs an empty string.</td>
</tr>
<tr valign=top>
<td width=50%><b>string(char* s)</b></td>
<td width=50%>Constructs a string from the sequence specified by <i>*s</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string(const string&amp; str<br>
 &nbsp;&nbsp;&nbsp; size_t pos, <br>
 &nbsp;&nbsp;&nbsp; size_t n)</b></td>
<td width=50%>Constructs a string from <i>n</i> characters of the sequence specified by <i>str</i>, beginning at position <i>pos</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string(const char* s, size_t n)</b></td>
<td width=50%>Constructs a string from <i>n</i> characters of the sequence specified by <i>*s</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>string(const string&amp; str)</b></td>
<td width=50%>Constructs a string from the sequence specified by <i>str</i>.</td>
</tr>
</table><br>
<h3>9.2 Example</h3>
<p>
The following sample converts a word to Pig Latin. To convert a word to Pig Latin, take the first character of a word, stick it at the end of the word and add the characters "ay" to the end of the word. For example, <i>Pig Latin(“hello”) = ellohay.</i></p>
<pre><code>//piglatin.cpp
#include &lt;string&gt;
#include &lt;iostream&gt;
//convert a string to piglatin
string piglatin(const string&amp; s)
{
 &nbsp;&nbsp; string s1 ;
 &nbsp;&nbsp; string s2(" .,;:?") ;&nbsp; //word separators
 &nbsp;&nbsp; //word boundary markers
 &nbsp;&nbsp; size_t start, end, next, p0 ;
 &nbsp;&nbsp; int done = 0 ;
 &nbsp;&nbsp; start = end = next = 0 ;
 &nbsp;&nbsp; while (!done)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Find start of word.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start = s.find_first_not_of(s2, next) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Find end of word.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Check for end of string.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p0 = s.find_first_of(s2, start) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end = (p0 &gt;= s.length()) ? s.length() : p0 - 1 ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Copy all the word separators.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s1 = s1 + s.substr(next, start - next) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Convert word to piglatin.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s1 = s1 + s.substr(start + 1, end - start) + s[start] + "ay" ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = end + 1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Check for end of string.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( next &gt;= s.length())
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; done = 1 ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return s1 ;
}
void main()
{
 &nbsp;&nbsp; string s("she sells sea shells by the sea shore") ;
 &nbsp;&nbsp; cout &lt;&lt; "s = " &lt;&lt; s &lt;&lt; endl ;
 &nbsp;&nbsp; cout &lt;&lt; "\npiglatin(s) = " &lt;&lt; piglatin(s) &lt;&lt; "\n"&lt;&lt; endl;&nbsp;&nbsp; 
}
</code></pre>
<p>
Output:</p>
<pre><code>s = she sells sea shells by the sea shore
piglatin(s) = hesay ellssay easay hellssay ybay hetay easay horesay
</code></pre>
<h2><a name="stlfunctobj"></a>10. Function Objects</h2>
<h3>10.1 Function Objects and the Strange Syntax...</h3>
<p>
<i>Function objects</i> are a fairly new concept of the C++ programming language. Their usage may seem odd at first glance, and the syntax may appear to be confusing. It may be a good idea to read this chapter slowly and deliberately, several times. Readers are encouraged to pull out the code snippets, build them, and try stepping through the debugger. </p>
<h3>10.2 Introduction</h3>
<p>
A function object<i> </i>is an object of a class/struct type that includes an <b>operator()</b> member function. An <b>operator()</b> member function allows us to create an object that behaves like a function. For example, a <b>Matrix</b> class could overload <b>operator()</b> to access an element whose row and column index are specified as arguments to <b>operator()</b>.</p>
<pre><code>class Matrix
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix(int, int) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //…
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int operator(int, int) const ;
 &nbsp;&nbsp;&nbsp;&nbsp; private:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Array&lt;int&gt; m_matrix ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m_row ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m_col ;
} ;
int Matrix::operator(int r, int c) const
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( r &gt; 0 &amp;&amp; r &lt;= m_row &amp;&amp; c &gt; 0 &amp;&amp; c &lt;= m_col)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_matrix[r, c] ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0 ;
}
Matrix m(10, 10) ;
//….
int&nbsp; element = m(5, 5) ;
</code></pre>
<p>
Function objects also have the advantage of the fact that <b>()</b> is the only operator that can take an arbitrary number of arguments. Ever felt the need to create a new function from existing function(s)? C++ does not allow that. How about using function objects? It is important to note:
<ul type=disc>
<li>
Function objects are objects that behave like functions. <br><br></li>
<li>
Since they are objects they can be created.<br><br></li>
<li>
Function objects always return a value.</li>
</ul>
<h3>10.3 STL Function Objects</h3>
<p>
The Standard Template Library provides function objects for standard math operations such as addition, subtraction, multiplication, and division. STL also provides function objects for unary operations, logical operations, bitwise operations, and comparison operations. Table 12 lists all the function objects provided by STL. The function objects have been defined in the header file <b>&lt;functional&gt;</b>.</p>
<p class=label>
<b>Table 12. STL Function Objects</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=53%><b>divides</b></td>
<td width=47%><b>logical_and</b></td>
</tr>
<tr valign=top>
<td width=53%><b>equal_to</b></td>
<td width=47%><b>logical_not</b></td>
</tr>
<tr valign=top>
<td width=53%><b>greater</b></td>
<td width=47%><b>logical_or</b></td>
</tr>
<tr valign=top>
<td width=53%><b>greater_equal</b></td>
<td width=47%><b>minus</b></td>
</tr>
<tr valign=top>
<td width=53%><b>less</b></td>
<td width=47%><b>modulus</b></td>
</tr>
<tr valign=top>
<td width=53%><b>less_equal</b></td>
<td width=47%><b>negate</b></td>
</tr>
<tr valign=top>
<td width=53%><b>plus</b></td>
<td width=47%><b>not_equal_to</b></td>
</tr>
<tr valign=top>
<td width=53%><b>times</b></td>
<td width=47%></td>
</tr>
</table><br>
<p>
These function objects can be used with STL algorithms to change the default behavior of the STL algorithms. Consider the STL algorithm <b>sort</b>. By default, <b>sort</b> sorts the elements of a sequence in ascending order. To sort the elements in a descending order use the STL function object <b>greater&lt;T&gt;</b> as demonstrated in the following example:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
void main()
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef vector&lt;int, allocator&lt;int&gt; &gt; VECTOR_INT ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef ostream_iterator&lt;int, char, char_traits&lt;char&gt; &gt; OUTIT ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a[10] = {30, 56, 79, 80, 45, 10, 4, 125, 67, 80} ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_INT v1(a, a + 10) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUTIT out(cout, ", ") ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "v1 before sort(first, last)" &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy(v1.begin(), v1.end(), out) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // using default sort algorithm, sorts elements in ascending order
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sort(v1.begin(), v1.end()) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "v1 after sort(first, last)" &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy(v1.begin(), v1.end(), out) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; random_shuffle(v1.begin(), v1.end()) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "v1 before sort(first, last, using STL function object)"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy(v1.begin(), v1.end(), out) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //customizing sort algorithm, to sort elements in descending order
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //using a function object.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sort(v1.begin(), v1.end(), greater&lt;int&gt;()) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "v1 after sort(first, last, using STL function-object)" 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy(v1.begin(), v1.end(), out) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl ;
}
</code></pre>
<p>
Build the above sample and see the output. We recommend stepping through the code in the debugger to see what is happening under the covers.</p>
<p>
STL function objects can also be used in&nbsp; C++ programs directly. For example:</p>
<pre><code>int n1 = (times&lt;int&gt;())(10, 20) ;&nbsp;&nbsp; // sets n1 to value 200
int n2 = (minus&lt;int&gt;())(300, 100) ; // sets n2 to value 200
</code></pre>
<h3>10.4 STL Function Adapters</h3>
<p>
<i>Function adapters</i> help us construct a wider variety of function objects using existing function objects. Using function adapters is often easier than directly constructing a new function object type with a struct or class definition.</p>
<p>
STL provides three categories of function adapters: <i>negators</i>, <i>binders</i>, and <i>adapters</i> <i>for</i> <i>pointer</i> <i>to</i> <i>functions</i>. </p>
<h4>10.4.1 Binders</h4>
<p>
Binders are function adapters that convert binary function objects into unary function objects by binding an argument to some particular value.</p>
<p>
STL provides two types of binder function objects: <b>binder1st&lt;Operation&gt;</b> and <b>binder2nd&lt;Operation&gt;</b>.<b> </b>A binder function object takes only a single argument.</p>
<p>
STL provides two template functions, <b>bind1st</b> and <b>bind2nd</b>, to create binder function objects. The functions <b>bind1st</b> and <b>bind2nd</b> each take as arguments a binary function object <i>f</i> and a value <i>x</i>. As might be surmised, <b>bind1st</b> returns a function object of type <b>binder1st&lt;Operation&gt;</b>, and <b>bind2nd</b> returns a function object of type <b>binder2nd&lt;Operation&gt;</b>. Here are the function prototypes for the <b>bind1st</b> and <b>bind2nd</b> functions:</p>
<pre><code>template &lt;class Operation, class T&gt;
binder1st&lt;Operation&gt; bind1st(const Operation&amp; f, const T&amp; x) ;
template &lt;class Operation, class T&gt;
binder2nd&lt;Operation&gt; bind2nd(const Operation&amp; f, const T&amp; x) ;
</code></pre>
<p>
Let us try to understand what binders do by looking at the following:</p>
<pre><code>int result = (bind2nd(greater&lt;int&gt;(), 200))(i)
</code></pre>
<p>
Assume <i>i</i> is an integer. You can rewrite the above expression as follows:</p>
<pre><code>int result = (greater&lt;int&gt;())(i, 200)
</code></pre>
<p>
The expression "bind2nd(greater&lt;int&gt;(), 200)" really is a more convenient way to implement the following:</p>
<pre><code>// f is a binary function object that takes two integers, x and y.
// returns true if x &gt; y
greater&lt;int&gt; f ;
// b is a unary function object; it returns true if its argument is &gt; 200.
binder2nd&lt; greater&lt;int&gt; &gt; b = bind2nd(f, 200) ;
// Store the results of the comparison i &gt; 200.
int result = b(i) ; // equivalent to the expression f(i, 200) ;
</code></pre>
<p>
So now it is easier to understand: <i>f</i> is a binary function object that compares two integers, <i>x</i> and y; <i>b</i> is a unary function object that sets the second argument of <i>f</i> to the value 200; and <i>result</i> is therefore <i>(i &gt; </i>200<i>)</i>.</p>
<p>
Then why use an expression as complex as "bind2nd(greater&lt;int&gt;(), 200)"? Consider the following example:</p>
<pre><code>int a1[1000] ;
//code to initialize a1 …
int* where = find_if(a1, a1+1000, bind2nd(greater&lt;int&gt;(), 200));
</code></pre>
<p>
The <b>find_if</b> function finds the first element in array <i>a1</i>, which is &gt; 200. In this case it is not possible to use the expression "(greater&lt;int&gt;())(i, 200)" as the third argument to <b>find_if</b>. How does one determine the value of <i>i</i>? The <b>find_if</b> function will supply the value <i>i</i> to the function object <b>greater </b>and the unary function object created by <b>bind2nd</b>. Also, <b>bind2nd</b> binds the value 200 to the second argument of function object <b>greater</b>.</p>
<p>
This notation makes it possible to work with the entire container at once, instead of writing loops to deal with individual elements. It makes the source code smaller, more reliable, and easier to read.</p>
<p>
<b>bind1st</b> converts the binary function object <i>f</i> into a unary function object by binding the argument <i>x</i> to the first argument of function object <i>f</i>.</p>
<p>
<b>bind2nd</b> converts the binary function object <i>f</i> into a unary function object by binding the argument <i>x</i> to the second argument of function object <i>f</i>.</p>
<h4>10.4.2 Negators</h4>
<p>
A negator returns the complement of a result obtained by applying a provided unary or binary operation.</p>
<p>
STL provides two types of negator function objects: <b>unary_negate&lt;Operation&gt;</b> and <b>binary_negate&lt;Operation&gt;</b>. A negator function object takes only a single argument.</p>
<p>
The two template functions, <b>not1</b> and <b>not2</b>, create negator function objects. The function <b>not1</b> takes a unary function object <i>f</i> as its argument and returns a function object of type <b>unary_negate&lt;Operation&gt;</b>. The function <b>not2</b> takes a binary function object <i>f</i> as its argument and returns a function object of type <b>binary_negate&lt;Operation&gt;</b>. Here are the function prototypes for the <b>not1</b> and <b>not2</b> functions:</p>
<pre><code>template &lt;class Operation&gt;
unary_negate&lt;Operation&gt; not1(const Operation&amp; f) ;
template &lt;class Operation&gt;
binary_negate&lt;Operation&gt; not2(const Operation&amp; f) ;
</code></pre>
<p>
Let us try to understand what negators do by looking at the following example:</p>
<pre><code>int a1[1000] ;
//code to initialize a1 …
int* where = find_if(a1, a1+1000, not1(bind2nd(greater&lt;int&gt;(), 200)));
</code></pre>
<p>
In this case, <b>find_if</b> finds the first element in array <i>a1</i> that is not &gt; 200 (that is, &lt;= 200). The function <b>bind2nd</b> creates a unary function object which returns the result of the comparison <i>i</i> &gt;<i> </i>200. The function <b>not1</b> takes the unary function object as an argument and creates another function object. This function object merely negates the results of the comparison <i>i </i>&gt; 200. Here is an example of using the <b>not2</b> function:</p>
<pre><code>sort(v1.begin(), v1.end(), not2(greater&lt;int&gt;())) ;
</code></pre>
<p>
In this case, <b>sort</b> will sort elements in ascending order. The <b>not2</b> function negates the results of the function object <b>greater</b>.</p>
<h4>10.4.3 Pointer-to-function adapters</h4>
<p>
Adapters for pointers to functions convert existing binary or unary functions to function objects. Adapters for pointers to functions allow the programmer to utilize the existing code to extend the library, apply idioms unique to your application, and so forth.</p>
<p>
STL provides two types of pointer-to-function objects: <b>pointer_to_unary_function&lt;Arg, Result&gt;</b> and <b>pointer_to_binary_function&lt;Arg1, Arg2, Result&gt;</b>. The <b>pointer_to_unary_function</b> function object takes one argument of type <i>Arg</i>, and <b>pointer_to_binary_function</b> takes two arguments of type <i>Arg1</i> and <i>Arg2</i>.</p>
<p>
STL provides two versions of the template function <b>ptr_fun</b> to create pointer-to-function function objects. The first version of <b>ptr_fun</b> takes a unary function <i>f</i> as its argument and returns a function object of type <b>pointer_to_unary_function&lt;Arg, Result&gt;</b>. The second version of <b>ptr_fun</b> takes a binary function<i> f</i> as its argument and returns a function object of type <b>pointer_to_binary_function&lt;Arg1, Arg2, Result&gt;</b>. Here are the function prototypes for the <b>ptr_fun</b> functions:</p>
<pre><code>template&lt;class Arg, class Result&gt; inline
pointer_to_unary_function&lt;Arg, Result&gt; ptr_fun(Result (*F)(Arg))
 &nbsp;&nbsp;&nbsp;&nbsp; 
template&lt;class Arg1, class Arg2, class Result&gt; inline
pointer_to_binary_function&lt;Arg1, Arg2, Result&gt; 
ptr_fun(Result(*F)(Arg1, Arg2)) ;
</code></pre>
<p>
Let us look at an example and try to understand what pointers to functions do:</p>
<pre><code>#pragma warning(disable: 4786)
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
// Return an integral random number in the range [0, n).
int Rand(int n)
{
 &nbsp;&nbsp; return rand() % n ;
}
void main()
{
 &nbsp; const int VECTOR_SIZE = 8 ;
 &nbsp; // A template class vector of int
 &nbsp; typedef vector&lt;int, allocator&lt;int&gt; &gt; IntVector ;
 &nbsp; //Define an iterator for template class vector of strings
 &nbsp; typedef IntVector::iterator IntVectorIt ;
 &nbsp; IntVector Numbers(VECTOR_SIZE) ;
 &nbsp; IntVectorIt start, end, it ;
 &nbsp; // Initialize vector Numbers
 &nbsp; Numbers[0] = 4 ;
 &nbsp; Numbers[1] = 10;
 &nbsp; Numbers[2] = 70 ;
 &nbsp; Numbers[3] = 30 ;
 &nbsp; Numbers[4] = 10;
 &nbsp; Numbers[5] = 69 ;
 &nbsp; Numbers[6] = 96 ;
 &nbsp; Numbers[7] = 100;
 &nbsp; start = Numbers.begin() ;&nbsp;&nbsp; // location of first
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // element of Numbers
 &nbsp; end = Numbers.end() ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // one past the location
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // last element of Numbers
 &nbsp;&nbsp; cout &lt;&lt; "Before calling random_shuffle\n" &lt;&lt; endl ;
 &nbsp; // Print content of Numbers.
 &nbsp; cout &lt;&lt; "Numbers { " ;
 &nbsp; for(it = start; it != end; it++)
 &nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *it &lt;&lt; " " ;
 &nbsp; cout &lt;&lt; " }\n" &lt;&lt; endl ;
 &nbsp; 
 &nbsp; // Shuffle the elements in a random order
 &nbsp;&nbsp; // the ptr_fun adaptor converts
 &nbsp;&nbsp; // a function to a function object.
 &nbsp;&nbsp; random_shuffle(start, end, ptr_fun&lt;int, int&gt;(Rand)) ;
 &nbsp;&nbsp; cout &lt;&lt; "After calling random_shuffle\n" &lt;&lt; endl ;
 &nbsp;&nbsp; cout &lt;&lt; "Numbers { " ;
 &nbsp; for(it = start; it != end; it++)
 &nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *it &lt;&lt; " " ;
 &nbsp; cout &lt;&lt; " }\n" &lt;&lt; endl ;&nbsp;&nbsp; 
}
</code></pre>
<p>
In this example, function <b>ptr_fun </b>converts the C++ unary function <b>Rand</b> into a <b>pointer_to_binary_function</b> function object. Build the above sample and examine the output. We recommend stepping through the code in the debugger to see what is happening under the covers!!</p>
<h2><a name="stlalgorith"></a>11. Standard Template Library Algorithms</h2>
<h3>11.1 Introduction</h3>
<p>
This chapter will introduce the STL algorithm fundamentals and present some examples. Remembering some basic rules will help you to understand the algorithms and how to use them.
<ul type=disc>
<li>
STL provides generic parameterized, iterator-based functions (a fancy description for template functions). These functions implement some common array-based utilities, including searching, sorting, comparing, and editing.<br><br></li>
<li>
The STL algorithms are <i>user programmable</i>. What this means is that you can modify the default behavior of an algorithm to suit your needs. For example, the <b>sort</b> algorithm: <pre><code>sort(first, last) ; //sorts elements of a sequence 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //in ascending order by default. 
</code></pre>
<p class=tl>
In this case the STL algorithm assumes an <b>operator ==</b> or <b>operator &lt;</b> exists, and uses it to compare elements. </P><p class=tl>
The default behavior of the STL algorithms can be changed by specifying a <i>predicate</i><b>.</b> The predicate function could be:</P><ul type=disc>
<li>
A C++ function. For example, <b>sort_descending</b> is a C++ function that compares two elements. In this case the <b>sort</b> algorithm takes a function pointer, as follows:<pre><code>// User programmable version of sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
sort(first, last, sort_descending); 
</code></pre>
</li>
<li>
Or, the predicate function could be a function object. Either define a function object, or use the function objects provided by STL. For example: <pre><code>//using function object greater&lt;int&gt;()
//provided by STL
sort(first, last, greater&lt;int&gt;()) ; 
</code></pre>
</li>
</ul>
</li>
<li>
Every algorithm operates on a range of <i>sequence</i>. A sequence is a range of elements in an array or container, or user-defined data structures delimited by a pair of iterators. <ul type=disc>
<li>
The identifier <b>first</b> points to the first element in the sequence. <br><br></li>
<li>
The identifier <b>last</b> points one element beyond the end of the region you want the algorithm to process.<br><br></li>
<li>
A common notation used to represent the sequence is [first, last). This is a notation for an open interval. The notation [first, last) implies that the sequence ranges from first to last, including first but not including last.<br><br></li>
<li>
The algorithm will increment an internal iterator with the <b>++</b> operator until it equals <b>last</b>. The element pointed to by <b>last</b> will not be processed by the algorithm.</li>
</ul>
</li>
<li>
STL Algorithms do not perform range or validity checking on the iterator or pointer values. Many algorithms work with two sequences. For example, the <b>copy</b> algorithm takes three parameters, as follows:<pre><code>//Copy contents of sequence1 to sequence2.
// First1 and last1 mark start and end of
// Sequence1, respectively. First2 marks the start
// of sequence2.
copy(first1, last1, first2) ; 
</code></pre>
<ul type=disc>
<li>
·If <i>sequence2</i> is shorter than <i>sequence1</i>, <b>copy</b> will merrily continue writing into unconnected areas of memory. </li>
</ul>
</li>
<li>
Some STL algorithms also creates an in-place version and a copying version. For example: <pre><code>// In-place version places the results back in
//the same container.
reverse(first, last) ;
// Copying version places the results in
//in another sequence and does not modify the 
//original sequence.
reverse_copy(first1, last1, first1) ; 
</code></pre>
</li>
<li>
The STL generic algorithms can be divided into the following four main categories: <ol>
<li>
<i>Nonmutating-Sequence Algorithms </i>operate on containers without, in general, modifying the contents of the container. <br><br></li>
<li>
<i>Mutating-Sequence Algorithms </i>typically modify the containers on which they operate. <br><br></li>
<li>
The <i>Sorting-Related Algorithms </i>include sorting and merging algorithms, binary searching algorithms, and set operations on sorted sequences. <br><br></li>
<li>
Finally there is a small collection of<i> Generalized Numeric Algorithms</i>. </li>
</ol>
</li>
<li>
The STL algorithms are defined in the three header files: <b>&lt;algorithm&gt;</b>, <b>&lt;functional&gt;</b>,<b> &lt;numeric&gt;</b>.</li>
</ul>
<p>
Let us look at some examples now. These examples demonstrate how to use the algorithms and explain different concepts.</p>
<h3>11.2 reverse and reverse_copy</h3>
<p>
<b>Description:</b> Reverse the order of items in a sequence specified by the range [first, last). </p>
<p>
Signature:</p>
<pre><code>template &lt;class BidirectionalIterator&gt;
void reverse(BidirectionalIterator first, BidirectionalIterator last) ;
</code></pre>
<p>
<b>Description:</b> Create a reversed copy of a sequence. Copy a sequence specified by [first, last) into a sequence of the same size, starting at result. Return an iterator positioned immediately after the last new element. </p>
<p>
Signature: </p>
<pre><code>template &lt;class BidirectionalIterator, class OutputIterator&gt;
OutputIterator reverse_copy(BidirectionalIterator first, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BidirectionalIterator last, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputIterator result) ;
</code></pre>
<h4>11.2.1 Using reverse and reverse_copy </h4>
<p>
The following example demonstrates how to use the <b>reverse</b> and <b>reverse_copy</b> functions.</p>
<pre><code>//reverse.cpp

#pragma warning(disable:4786)

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;string&gt;

void main()
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef list&lt;string, allocator&lt;string&gt; &gt; STRINGLIST ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef STRINGLIST::iterator STRINGLIST_ITERATOR ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef ostream_iterator&lt;string, char, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char_traits&lt;char&gt; &gt; OS_ITERATOR ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string Names1[6] = {"Bob", "Tim", "David", "Lisa", "Donna",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Cathy" } ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string Names2[6] ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OS_ITERATOR out(cout, ", ") ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRINGLIST namesList1, namesList2(6) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRINGLIST_ITERATOR iT, iT2 ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // print contents of Names1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Names1 array: " &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 6; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; Names1[i] &lt;&lt; ", " ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "\n" &lt;&lt; endl ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reverse contents of Names1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //using in-place version of reverse.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse(&amp;Names1[0], &amp;Names1[6]) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Print contents of Names1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Names1 array after reverse: " &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 6; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; Names1[i] &lt;&lt; ", " ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "\n" &lt;&lt; endl ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Reverse contents of Names1 and place results in Names2
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //using copying version of reverse.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse_copy(&amp;Names1[0], &amp;Names1[6], &amp;Names2[0]) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Print contents of Names2.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Names2 array after reverse_copy: " &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 6; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; Names1[i] &lt;&lt; ", " ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "\n" &lt;&lt; endl ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Initialize nameList1 with contents of array Names.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 6; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; namesList1.push_back(Names1[i]) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Print contents of nameList1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "namesList1 list: " &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(iT = namesList1.begin(); iT != namesList1.end(); iT++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *iT &lt;&lt; ", " ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "\n" &lt;&lt; endl ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Reverse contents of namesList1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // using in-place version of reverse.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse(namesList1.begin(), namesList1.end()) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Print contents of nameList1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "namesList1 list after reverse: " &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(iT = namesList1.begin(); iT != namesList1.end(); iT++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *iT &lt;&lt; ", " ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "\n" &lt;&lt; endl ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Reverse contents of namesList1 and place results in
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //namesList2 using copying version of reverse.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse_copy(namesList1.begin(), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; namesList1.end(), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; namesList2.begin()) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Print contents of nameList1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "namesList2 list after reverse_copy: " &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(iT2 = namesList2.begin(); iT2 != namesList2.end(); iT2++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *iT2 &lt;&lt; ", " ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "\n" &lt;&lt; endl&nbsp; &lt;&lt; flush;
 &nbsp; }
</code></pre>
<h3>11.3 sort </h3>
<p>
<b>Description:</b> Sort a sequence. Sort all elements in the range [first, last) into ascending order. The first version uses operator&lt; to compare elements while the second version uses a function/function object.</p>
<p>
Signature:</p>
<pre><code>template &lt;class RandomAccessIterator&gt;
void sort(RandomAccessIterator first_, RandomAccessIterator last_) ;

template &lt;class RandomAccessIterator, class Compare&gt;
void sort(RandomAccessIterator first_, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last_,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compare compare_) ;
</code></pre>
<h4>11.3.1 Using sort </h4>
<p>
The following example demonstrates how to use the nonpredicate and predicate version of the <b>sort</b> function.</p>
<pre><code>//sort.cpp
//Using the generic sort algorithm

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;

bool comp(int x, int y)
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x &gt; y ;
}

class compObj
{
public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool operator()(int x, int y)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x &gt; y ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
} ;
void main()
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef vector&lt;int, allocator&lt;int&gt; &gt; VECTOR_INT ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef ostream_iterator&lt;int, char, char_traits&lt;char&gt; &gt; OUTIT ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a[10] = {30, 56, 79, 80, 45, 10, 4, 125, 67, 80} ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_INT v1(a, a + 10) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUTIT out(cout, ". ") ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "v1 before sort(first, last)" &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy(v1.begin(), v1.end(), out) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Default sort algorithm: sorts elements in ascending order.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sort(v1.begin(), v1.end()) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "v1 after sort(first, last)" &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy(v1.begin(), v1.end(), out) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; random_shuffle(v1.begin(), v1.end()) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "v1 before sort(first, last, comp_function)" &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy(v1.begin(), v1.end(), out) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Customizing sort algorithm: to sort elements
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //in descending order using a compare function.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sort(v1.begin(), v1.end(), comp) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "v1 after sort(first, last, comp_function)" &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy(v1.begin(), v1.end(), out) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; random_shuffle(v1.begin(), v1.end()) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "v1 before sort(first, last, your function-object)"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy(v1.begin(), v1.end(), out) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Customizing sort algorithm: to sort elements 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //in descending order using a function.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sort(v1.begin(), v1.end(), compObj()) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "v1 after sort(first, last, your function-object)"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy(v1.begin(), v1.end(), out) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; random_shuffle(v1.begin(), v1.end()) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "v1 before sort(first,last,using STL function-object)" 
&lt;&lt; endl ;
 copy(v1.begin(), v1.end(), out) ;
 cout &lt;&lt; endl ;

 //Customizing sort algorithm: to sort elements
 //in descending order using a function object.
 sort(v1.begin(), v1.end(), greater&lt;int&gt;()) ;

 cout &lt;&lt; "v1 after sort(first, last, using STL function-object)"
 &nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl ;
 copy(v1.begin(), v1.end(), out) ;
 cout &lt;&lt; endl ;
}
</code></pre>
<h2><a name="stllangsupport"></a>12. Standard C++ Library Language Support</h2>
<h3>12.1 Introduction</h3>
<p>
The language support section of the Standard C++ Library provides common type definitions used throughout the library, characteristics of pre-defined types, functions supporting start and termination of C++ programs, support for dynamic memory allocation, support for dynamic type identification, support for exception processing, and other run-time support.</p>
<h3>12.2 Types: cstddef</h3>
<p>
This header file basically includes stddef.h. There are two macros, NULL and <b>offsetof</b>, and two types, <b>ptrdiff_t</b> and <b>size_t</b>, specifically listed in this section of the standard. </p>
<p>
To determine the distance (or the number of elements) between two elements you can use the <b>distance()</b> function. If you pass it an iterator pointing to the first element and one pointing to the third element, it will return a 2. </p>
<p>
The <b>distance</b> function is in the utility header file and it takes two iterators as parameters and returns a number of type <b>difference_type</b>. <b>Difference_type</b> maps is an int. The sequence is: </p>
<pre><code>typedef _PDFT difference_type 
#define _PDFT ptrdiff_t 
typedef int ptrdiff_t 
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;With Visual C++ 4.2 the online help states the difference function takes 3 parameters and returns void. For example: </p>
<pre><code>template &lt;class Init, class Dist&gt; 
void distance(InIt first, InIt last, Dist&amp;n); 
</code></pre>
<p>
However, it actually takes two parameters and returns a value, as follows: </p>
<pre><code>&nbsp;&nbsp;&nbsp;template &lt;class Init, class Dist&gt;
Dist distance(InIt first, InIt last) 
</code></pre>
<h3>12.3 Using the distance() Function</h3>
<p>
The following example demonstrates the <b>distance()</b> function:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#pragma warning (disable:4786)
typedef vector&lt;string, allocator&lt;string&gt; &gt; VTRLIST;
void main() {
 &nbsp;&nbsp; VTRLIST Vector;
 &nbsp;&nbsp; VTRLIST::iterator iVector;
 &nbsp;&nbsp; VTRLIST::difference_type dTheDiff;
 &nbsp;&nbsp; Vector.push_back("A1");
 &nbsp;&nbsp; Vector.push_back("B2");
 &nbsp;&nbsp; Vector.push_back("C3");
 &nbsp;&nbsp; Vector.push_back("D4");
 &nbsp;&nbsp; Vector.push_back("E5");
 &nbsp;&nbsp; Vector.push_back("F6");
 &nbsp;&nbsp; Vector.push_back("G7");
 &nbsp;&nbsp; // Print out the list.
 &nbsp;&nbsp; iVector=Vector.begin();
 &nbsp;&nbsp; cout &lt;&lt; "The list is: ";
 &nbsp;&nbsp; for (int i = 0; i &lt; 7 ; i++, iVector++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *iVector&nbsp; &lt;&lt; "&nbsp; ";
 &nbsp; 
 &nbsp;&nbsp; // Initialize the iterator the first element".
 &nbsp;&nbsp; iVector=Vector.begin();
 &nbsp;&nbsp; cout &lt;&lt; "\n\nAdvance to the 3rd element." &lt;&lt; endl;
 &nbsp;&nbsp; advance( iVector, 2);
 &nbsp;&nbsp; cout &lt;&lt; "The element is " &lt;&lt; *iVector &lt;&lt; endl;
 &nbsp;&nbsp; dTheDiff = distance( Vector.begin(), iVector);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "The distance from the beginning is " &lt;&lt; dTheDiff &lt;&lt; endl;
 &nbsp;&nbsp; cout &lt;&lt; "Calculate it in reverse order " &lt;&lt; endl;
 &nbsp;&nbsp; dTheDiff = distance( iVector, Vector.begin());
 &nbsp;&nbsp; cout &lt;&lt; "The distance is " &lt;&lt; dTheDiff &lt;&lt; endl;
 &nbsp;&nbsp; cout &lt;&lt; "\nUse distance() to count from the 3rd element to the 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end."&nbsp; &lt;&lt; endl;
 &nbsp;&nbsp; dTheDiff = distance( iVector, Vector.end());
 &nbsp;&nbsp; // Note that end() returns one past the end of the sequence.
 &nbsp;&nbsp; cout &lt;&lt; "The distance is " &lt;&lt; dTheDiff &lt;&lt; endl;
 &nbsp;&nbsp; cout &lt;&lt;"\nUse distance() to count the total length." &lt;&lt; endl;
 &nbsp;&nbsp; dTheDiff = distance( Vector.begin(), Vector.end() );
 &nbsp;&nbsp; cout &lt;&lt; "The total distance is " &lt;&lt; dTheDiff &lt;&lt; endl;
}
</code></pre>
<p>
The program output is:</p>
<pre><code>The list is: A1&nbsp; B2&nbsp; C3&nbsp; D4&nbsp; E5&nbsp; F6&nbsp; G7
Advance to the 3rd element.
The element is C3
The distance from the beginning is 2
Calculate it in reverse order
The distance is -2
Use distance() to count from the 3rd element to the end.
The distance is 5
Use distance() to count the total length.
The total distance is 7
</code></pre>
<h3>12.4 Implementation Properties: limits, climits, cfloat</h3>
<p>
The <b>numeric_limits</b> component provides information about properties of fundamental types. Specializations are provided for each fundamental type such as int, floating point, and bool. The member i<b>s_specialized</b> returns true for the specializations of <b>numeric_limits</b> for the fundamental types </p>
<p>
The <b>numeric_limits</b> class is defined in the limits header file. </p>
<pre><code>template&lt;class T&gt;  class numeric_limits {
public:
static const bool has_denorm;
static const bool has_denorm_loss;
static const bool has_infinity;
static const bool has_quiet_NaN;
static const bool has_signaling_NaN;
static const bool is_bounded;
static const bool is_exact;
static const bool is_iec559;
static const bool is_integer;
static const bool is_modulo;
static const bool is_signed;
static const bool is_specialized;
static const bool tinyness_before;
static const bool traps;
static const float_round_style round_style;
static const int digits;
static const int digits10;
static const int max_exponent;
static const int max_exponent10;
static const int min_exponent;
static const int min_exponent10;
static const int radix;
static T denorm_min() throw();
static T epsilon() throw();
static T infinity() throw();
static T max() throw();
static T min() throw();
static T quiet_NaN() throw();
static T round_error() throw();
static T signaling_NaN() throw();
};
</code></pre>
<h3>12.5 numeric_limits Class Member Functions</h3>
<p>
Table 13 describes the member functions of the <b>numeric_limit</b> class.</p>
<p class=label>
<b>Table 13. Member Functions of the numeric_limit Class</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Member function</b></td>
<td class=label width=73%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=27%><b>has_denorm</b></td>
<td width=73%>Stores true for a floating-point type that has denormalized values (effectively a variable number of exponent bits).</td>
</tr>
<tr valign=top>
<td width=27%><b>has_denorm_loss</b></td>
<td width=73%>Stores true for a type that determines whether a value has lost accuracy because it is delivered as a denormalized result (too small to represent as a normalized value) or because it is inexact (not the same as a result and not subject to limitations of exponent range and precision). </td>
</tr>
<tr valign=top>
<td width=27%><b>has_infinity</b></td>
<td width=73%>The member stores true for a type that has a representation for positive infinity. True if <b>is_iec559</b> is true.</td>
</tr>
<tr valign=top>
<td width=27%><b>has_quiet_NaN</b></td>
<td width=73%>Stores true for a type that has a representation for a quiet NaN, an encoding that is "Not a Number'' which does not signal its presence in an expression. True if i<b>s_iec559</b> is true.</td>
</tr>
<tr valign=top>
<td width=27%><b>has_signaling_NaN</b></td>
<td width=73%>The member stores true for a type that has a representation for a signaling NaN, an encoding that is ``Not a Number'' which signals its presence in an expression by reporting an exception. True if <b>is_iec559</b> is true.</td>
</tr>
<tr valign=top>
<td width=27%><b>is_bounded</b></td>
<td width=73%>Stores true for a type that has a bounded set of representable values (which is the case for all predefined types).</td>
</tr>
<tr valign=top>
<td width=27%><b>is_exact</b></td>
<td width=73%>Stores true for a type that has exact representations for all its values (which is the case for all predefined integer types). A fixed-point or rational representation is also considered exact, but not a floating-point representation.</td>
</tr>
<tr valign=top>
<td width=27%><b>is_iec559</b></td>
<td width=73%>Stores true for a type that has a representation conforming to IEC 559, an international standard for representing floating-point values (also known as IEEE 754 in the USA).</td>
</tr>
<tr valign=top>
<td width=27%><b>is_integer</b></td>
<td width=73%>Stores true for a type that has an integer representation.</td>
</tr>
<tr valign=top>
<td width=27%><b>is_modulo</b></td>
<td width=73%>Stores true for a type that has a modulo representation, where all results are reduced modulo some value.</td>
</tr>
<tr valign=top>
<td width=27%><b>is_signed</b></td>
<td width=73%>Stores true for a type that has a signed representation (which is the case for all predefined floating-point and signed integer types).</td>
</tr>
<tr valign=top>
<td width=27%><b>is_specialized</b></td>
<td width=73%>Stores true for a type that has an explicit specialization defined for template class numeric_limits.</td>
</tr>
<tr valign=top>
<td width=27%><b>tinyness_before</b></td>
<td width=73%>Stores true for a type that determines whether a value is ``tiny'' (too small to represent as a normalized value) before rounding.</td>
</tr>
<tr valign=top>
<td width=27%><b>traps</b></td>
<td width=73%>Stores true for a type that generates some kind of signal to report certain arithmetic exceptions.</td>
</tr>
<tr valign=top>
<td width=27%><b>round_style</b></td>
<td width=73%>Stores a value that describes the various methods that an implementation can choose for rounding a floating-point value to an integer value. The round styles are: <br>
<b>enum float_round_style {<br>
round_indeterminate&nbsp;&nbsp;&nbsp; = -1</b>,<br>
<b>round_toward_zero&nbsp;&nbsp;&nbsp;&nbsp; = 0</b>,<br>
<b>round_to_nearest&nbsp;&nbsp;&nbsp;&nbsp; = 1</b>,<br>
<b>round_toward_infinity&nbsp;&nbsp; = 2</b>,<br>
<b>round_toward_neg_infinity =</b> 3</td>
</tr>
<tr valign=top>
<td width=27%><b>digits</b></td>
<td width=73%>The member stores the number of radix digits that the type can represent without change (which is the number of bits other than any sign bit for a predefined integer type, or the number of mantissa digits for a predefined floating-point type).</td>
</tr>
<tr valign=top>
<td width=27%><b>digits10</b></td>
<td width=73%>Stores the number of decimal digits that the type can represent without change.</td>
</tr>
<tr valign=top>
<td width=27%><b>max_exponent</b></td>
<td width=73%>The member stores the maximum positive integer that the type can represent as a finite value radix raised to that power (which is the value FLT_MAX_EXP for type float). Meaningful only for floating-point types.</td>
</tr>
<tr valign=top>
<td width=27%><b>max_exponent10</b></td>
<td width=73%>The member stores the maximum positive integer that the type can represent as a finite value 10 raised to that power (which is the value FLT_MAX_10_EXP for type float). Meaningful only for floating-point types.</td>
</tr>
<tr valign=top>
<td width=27%><b>min_exponent</b></td>
<td width=73%>The member stores the minimum negative integer that the type can represent as a normalized value radix raised to that power (which is the value FLT_MIN_EXP for type float). Meaningful only for floating-point types.</td>
</tr>
<tr valign=top>
<td width=27%><b>min_exponent10</b></td>
<td width=73%>The member stores the minimum negative integer that the type can represent as a normalized value 10 raised to that power (which is the value FLT_MIN_10_EXP for type float). Meaningful only for floating-point types.</td>
</tr>
<tr valign=top>
<td width=27%><b>radix;</b></td>
<td width=73%>The member stores the base of the representation for the type (which is 2 for the predefined integer types), and the base to which the exponent is raised(which is FLT_RADIX for the predefined floating-point types).</td>
</tr>
<tr valign=top>
<td width=27%><b>denorm_min()</b></td>
<td width=73%>The function returns the minimum value for the type (which is the same as <b>min()</b> if <b>has_denorm</b> is <b>False</b>).</td>
</tr>
<tr valign=top>
<td width=27%><b>epsilon()</b></td>
<td width=73%>The function returns the difference between 1 and the smallest value greater than 1 that is representable for the type (which is the value FLT_EPSILON for type float). </td>
</tr>
<tr valign=top>
<td width=27%><b>infinity()</b></td>
<td width=73%>The function returns the representation of positive infinity for the type. The return value is meaningful only if <b>has_infinity</b> is true.</td>
</tr>
<tr valign=top>
<td width=27%><b>max()</b></td>
<td width=73%>The function returns the maximum finite value for the type (which is INT_MAX for type int and FLT_MAX for type float). The return value is meaningful if <b>is_bounded</b> is true.</td>
</tr>
<tr valign=top>
<td width=27%><b>min()</b></td>
<td width=73%>The function returns the minimum normalized value for the type (which is INT_MIN for type int and FLT_MIN for type float). The return value is meaningful if <b>is_bounded</b> is true or <b>is_signed</b> is <b>False</b>.</td>
</tr>
<tr valign=top>
<td width=27%><b>quiet_ Nan()</b></td>
<td width=73%>The function returns a representation of a quiet NaN for the type. The return value is meaningful only if <b>has_quiet_NaN</b> is true.</td>
</tr>
<tr valign=top>
<td width=27%><b>round_error()</b></td>
<td width=73%>The function returns the maximum rounding error for the type.</td>
</tr>
<tr valign=top>
<td width=27%><b>Signaling_Nan()</b></td>
<td width=73%>The function returns a representation of a signaling NaN for the type. The return value is meaningful only if <b>has_signaling_NaN</b> is true.</td>
</tr>
</table><br>
<h3>12.6 Using the numeric_limits Class Member Functions</h3>
<p>
The following example demonstrates the <b>numeric_limits</b> class member functions:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;
void main() {
 &nbsp; cout &lt;&lt; " 1 The minimum value for char is " &lt;&lt; 
 &nbsp;&nbsp;&nbsp;&nbsp; (int)numeric_limits&lt;char&gt;::min() &lt;&lt; endl;
 &nbsp; cout &lt;&lt; " 2 The minimum value for int&nbsp; is " &lt;&lt; 
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;int&gt;::min() &lt;&lt; endl;
 &nbsp; cout &lt;&lt; " 3 The maximum value for char is " &lt;&lt; 
 &nbsp;&nbsp;&nbsp;&nbsp; (int)numeric_limits&lt;char&gt;::max() &lt;&lt; endl;
 &nbsp; cout &lt;&lt; " 4 The maximum value for int&nbsp; is " &lt;&lt; 
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;int&gt;::max() &lt;&lt; endl;
 &nbsp; cout &lt;&lt; " 5 The number of bits to represent a char is " &lt;&lt; 
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;char&gt;::digits &lt;&lt; endl;
 &nbsp; cout &lt;&lt; " 6 The number of bits to represent an int is " &lt;&lt; 
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;int&gt;::digits &lt;&lt; endl;
 &nbsp; cout &lt;&lt;" 7 The number of digits representble in base 10 for float is" 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; numeric_limits&lt;float&gt;::digits10 &lt;&lt; endl;
 &nbsp; cout &lt;&lt; " 8 Is a char signed?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;char&gt;::is_signed &lt;&lt; endl;
 &nbsp; cout &lt;&lt; " 9 Is an unsigned integer signed? " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;unsigned int&gt;::is_signed &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "10 Is a integer an integer? " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;int&gt;::is_integer &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "11 Is a float an integer?&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::is_integer &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "12 Is a integer exact? " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;int&gt;::is_exact &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "13 Is a float&nbsp; exact?&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::is_exact &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "14 The radix for float is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp; &lt;&lt; 
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::radix &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "15 The epsilon for float is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::epsilon() &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "16 The round error for float is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::round_error() &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "17 The minimum exponent for float is " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::min_exponent &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "18 The minimum exponent in base 10&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::min_exponent10 &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "19 The maximum exponent is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::max_exponent &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "20 The maximum exponent in base 10&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::max_exponent10 &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "21 Can float represent positive infinity?&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::has_infinity &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "22 Can double represent positive infinity? " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;double&gt;::has_infinity &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "23 Can int represent positive infinity? " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;int&gt;::has_infinity &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "24 Can float represent a NaN?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::has_quiet_NaN &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "25 Can float represent a signaling NaN? " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::has_signaling_NaN &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "26 Does float allow denormalized values?&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::has_denorm &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "27 Does float detect denormalization loss? " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::has_denorm_loss &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "28 Representation of positive infinity for float " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::infinity() &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "29 Representation of quiet NaN for float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::quiet_NaN() &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "30 Minimum denormalized number for float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::denorm_min() &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "31 Minimum positive denormalized value for float " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::denorm_min() &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "32 Does float adhere to IEC 559 standard?&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::is_iec559 &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "33 Is float bounded? " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::is_bounded &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "34 Is float modulo?&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::is_modulo &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "35 Is int modulo?&nbsp;&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::is_modulo &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "36 Is trapping implemented for float?&nbsp;&nbsp;&nbsp; " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::traps &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "37 Is tinyness detected before rounding? " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; numeric_limits&lt;float&gt;::tinyness_before &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "38 What is the rounding style for float? " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; (int)numeric_limits&lt;float&gt;::round_style &lt;&lt; endl;
 &nbsp; cout &lt;&lt; "39 What is the rounding style for int? " &lt;&lt;
 &nbsp;&nbsp;&nbsp;&nbsp; (int)numeric_limits&lt;int&gt;::round_style &lt;&lt; endl;
}
</code></pre>
<p>
Output:</p>
<pre><code>&nbsp;1 The minimum value for char is -128
 2 The minimum value for int&nbsp; is -2147483648
 3 The maximum value for char is 127
 4 The maximum value for int&nbsp; is 2147483647
 5 The number of bits to represent a char is 7
 6 The number of bits to represent an int is 31
 7 The number of digits representable in base 10 for float is 6
 8 Is a char signed?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
 9 Is an unsigned integer signed? 0
10 Is a integer an integer? 1
11 Is a float an integer?&nbsp;&nbsp; 0
12 Is a integer exact? 1
13 Is a float&nbsp; exact?&nbsp; 0
14 The radix for float is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
15 The epsilon for float is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.19209e-007
16 The round error for float is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.5
17 The minimum exponent for float is -125
18 The minimum exponent in base 10&nbsp;&nbsp; -37
19 The maximum exponent is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 128
20 The maximum exponent in base 10&nbsp;&nbsp; 38
21 Can float represent positive infinity?&nbsp; 1
22 Can double represent positive infinity? 1
23 Can int represent positive infinity? 0
24 Can float represent a NaN?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
25 Can float represent a signaling NaN? 1
26 Does float allow denormalized values?&nbsp;&nbsp; 1
27 Does float detect denormalization loss? 1
28 Representation of positive infinity for float 1.#INF
29 Representation of quiet NaN for float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1.#IND
30 Minimum denormalized number for float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.4013e-045
31 Minimum positive denormalized value for float 1.4013e-045
32 Does float adhere to IEC 559 standard?&nbsp; 1
33 Is float bounded? 1
34 Is float modulo?&nbsp; 0
35 Is int modulo?&nbsp;&nbsp;&nbsp; 0
36 Is trapping implemented for float?&nbsp;&nbsp;&nbsp; 1
37 Is tinyness detected before rounding? 1
38 What is the rounding style for float? 1
39 What is the rounding style for int? 0
</code></pre>
<p>
Additional values defined from the &lt;climits&gt; and &lt;cfloat&gt; header files which include &lt;limits.h&gt; and float.h, respectively, are:</p>
<pre><code>CHAR_BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LONG_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCHAR_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UCHAR_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  CHAR_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_LEN_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHRT_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  CHAR_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LONG_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCHAR_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHRT_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG_MAX&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; USHRT_MAX 
  DBL_DIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBL_MIN_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLT_MIN_10_EXP&nbsp;&nbsp;&nbsp;&nbsp; LDBL_MAX_10_EXP 
  DBL_EPSILON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLT_DIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLT_MIN_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LDBL_MAX_EXP&nbsp;&nbsp;&nbsp; 
  DBL_MANT_DIG&nbsp;&nbsp;&nbsp; FLT_EPSILON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLT_RADIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LDBL_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  DBL_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLT_MANT_DIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLT_ROUNDS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LDBL_MIN_10_EXP&nbsp; 
  DBL_MAX_10_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLT_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LDBL_DIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LDBL_MIN_EXP&nbsp;&nbsp;&nbsp; 
  DBL_MAX_EXP&nbsp;&nbsp;&nbsp; FLT_MAX_10_EXP&nbsp;&nbsp;&nbsp; LDBL_EPSILON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  DBL_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLT_MAX_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LDBL_MANT_DIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  DBL_MIN_10_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLT_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LDBL_MAX</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The LDBLxxx constants are not listed in the online help for Visual C++ 4.2 but they are defined in &lt;float.h&gt;</p>
<p>
There are two additional constants defined in the Visual C++ 4.2 implementation that are not a part of the Standard C++ Library, they are:</p>
<pre><code>_DBL_RADIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
_DBL_ROUNDS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</code></pre>
<p>
See the online help with Visual C++ 4.2 for descriptions of these constants. </p>
<h3>12.7 Start and Termination: cstdlib</h3>
<p>
The cstdlib header file includes the C header file &lt;cstdlib.h&gt;. Table 14 lists the functions specified.</p>
<p class=label>
<b>Table 14. Functions Specified in cstdlib</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=47%><b>Function</b></td>
<td class=label width=53%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=47%><b>void abort( void );</b></td>
<td width=53%>Aborts the current process and returns an error code.</td>
</tr>
<tr valign=top>
<td width=47%><b>int atexit( void ( __cdecl *<i>func</i> )( void ) );</b></td>
<td width=53%>Processes the specified function at exit.</td>
</tr>
<tr valign=top>
<td width=47%><b>void exit( int <i>status</i> );</b></td>
<td width=53%>Terminate the calling process after cleanup (exit) or immediately (_exit).</td>
</tr>
</table><br>
<h3>12.8 Dynamic Memory Management: new</h3>
<p>
The online help for the new header file lists the following<code>. </code></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;typedef void (*new_handler)();
 &nbsp;&nbsp; class bad_alloc;
 &nbsp;&nbsp; class nothrow;
 &nbsp;&nbsp; new_handler set_new_handler(new_handler ph) throw();
 &nbsp;&nbsp; void operator delete(void *p) throw();
 &nbsp;&nbsp; void operator delete(void *, void *) throw();
 &nbsp;&nbsp; void operator delete(void *p, const nothrow&amp;) throw();
 &nbsp;&nbsp; void operator delete[](void *p) throw();
 &nbsp;&nbsp; void operator delete[](void *, void *) throw();
 &nbsp;&nbsp; void operator delete[](void *p, const nothrow&amp;) throw();
 &nbsp;&nbsp; void *operator new(size_t n) throw(bad_alloc);
 &nbsp;&nbsp; void *operator new(size_t n, const nothrow&amp;) throw();
 &nbsp;&nbsp; void *operator new(size_t n, void *p) throw();
 &nbsp;&nbsp; void *operator new[](size_t n) throw(bad_alloc);
 &nbsp;&nbsp; void *operator new[](size_t n, const nothrow&amp;) throw();
 &nbsp;&nbsp; void *operator new[](size_t n, void *p) throw();
 &nbsp;&nbsp; };
</code></pre>
<p>
The main thing to note is that there is support for the operator <b>new</b> either returning NULL or throwing an exception on failure.</p>
<p>
The class <b>nothrow{} </b>is used as a function parameter to indicate that the function should never throw an exception.</p>
<p>
The online help for the operator <b>new</b> in the Visual C++ 4.2 Standard C++ Library Reference is pretty good. Either query on 'operator new' or look in the help for the <i>&lt;</i>new<i>&gt;</i> header file.</p>
<p>
In the above prototypes, don't let the <b>throw()</b>, throw you. Visual C++ 4.2 does not implement these exception specifications. This is noted in the online help.</p>
<p>
Microsoft C++ does not support the function <b>throw</b> signature mechanism, as described in section 15.5 of the ANSI C++ draft.</p>
<p>
Microsoft C++ does not support the function <b>exception</b> specification mechanism, as described in section 15.4 of the ANSI C++ draft.</p>
<p>
An exception specification specifies the type of exceptions a function can throw, for example:</p>
<pre><code>void Func() throw (ProblemOne, ProblemTwo) {}
is equivalent to:
void Func() {
{
 &nbsp; try {}
 &nbsp; catch (ProblemOne) {}
 &nbsp; catch (ProblemTwo) {}
 &nbsp; catch (…) { unexpected(); }
}
</code></pre>
<p>
These operators:</p>
<pre><code>&nbsp;&nbsp;&nbsp;void *operator new(size_t n) throw(bad_alloc);
 &nbsp; void *operator new[](size_t n) throw(bad_alloc);
</code></pre>
<p>
will throw a <b>bad_alloc</b> exception if the memory allocation fails. Or if you define a <b>new_handler</b> function via <b>set_new_handler</b>, the new handler function will be called instead.</p>
<p>
These operators:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;void *operator new(size_t n, const nothrow&amp;) throw();
 &nbsp;&nbsp; void *operator new(size_t n, void *p) throw();
 &nbsp;&nbsp; void *operator new[](size_t n, const nothrow&amp;) throw();
 &nbsp;&nbsp; void *operator new[](size_t n, void *p) throw();
</code></pre>
<p>
will simply return NULL if the memory allocation fails. </p>
<p>
In the following sample, the first operator new will attempt to allocate memory and, if it fails, will throw an exception. The second operator new accepts a second parameter of type <b>nothrow</b>. This parameter indicates that if the allocation fails, it should return NULL and not throw an exception. The third operator, <b>new</b>, will allocate memory for an array of that type and, if it fails, throw an exception.</p>
<pre><code>#include &lt;new&gt;
#include &lt;iostream&gt;
class BigClass {
public:
 &nbsp;&nbsp; BigClass() {};
 &nbsp;&nbsp; ~BigClass(){}
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double BigArray[99999999];
};
void main() {
 &nbsp;&nbsp; try {
 &nbsp;&nbsp; BigClass * p = new BigClass;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; catch( bad_alloc a) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * temp = a.what();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; temp &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Threw a bad_alloc exception" &lt;&lt; endl;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; BigClass * q = new(nothrow) BigClass;
 &nbsp;&nbsp; if ( q == NULL )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Returned a NULL pointer" &lt;&lt; endl;
 &nbsp;&nbsp; try {
 &nbsp;&nbsp; BigClass * r = new BigClass[3];
 &nbsp;&nbsp; }
 &nbsp;&nbsp; catch( bad_alloc a) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * temp = a.what();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; temp &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Threw a bad_alloc exception" &lt;&lt; endl;
 &nbsp;&nbsp; }
}
Program Output is:
bad allocation
Threw a bad_alloc exception
Returned a NULL pointer
bad allocation
Threw a bad_alloc exception
 &nbsp;&nbsp; 
</code></pre>
<p>
Note that the above example uses the <b>what()</b> function to print out the type of exception. This function is a part of the exception class. The value returned by <b>what()</b> is implementation defined. </p>
<p>
An important thing to note is that code which previously returned a NULL when a call to new failed will instead throw an exception if you use the standard C++ header files. This means that if you modify your code to include &lt;new&gt; then you also need to modify your code to check for an exception rather than checking to see if new returned NULL.</p>
<h4>12.8.1 Mixing old iostream and Standard C++ Libraries </h4>
<p>
Intermixing old header files with the new standard C++ header files can cause multiple problems with the new operator. For example, if the following code:</p>
<pre><code>class BigClass {
public:
 &nbsp; BigClass() {};
 &nbsp; ~BigClass(){}
 &nbsp;&nbsp;&nbsp;&nbsp; double BigArray[99999999];
};
void main() {
 &nbsp; BigClass * q = new BigClass;
 &nbsp; if ( q == NULL )
 &nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Returned a NULL pointer" &lt;&lt; endl;
}
</code></pre>
<p>
includes these header files, you get the noted results.</p>
<pre><code>#include &lt;iostream.h&gt;
// No Errors.
#include &lt;iostream.h&gt;
#include &lt;new&gt;
// No errors - returns a NULL.
#include &lt;new&gt;
#include &lt;iostream.h&gt;
// No errors - returns a NULL.
#include &lt;new&gt;
#include &lt;iostream&gt;
// Throws an exception instead of returning NULL.
#include &lt;iostream&gt;
// Throws an exception instead of returning NULL.
</code></pre>
<p>
If you are using the newer forms of the operator <b>new</b> such as:</p>
<pre><code>class BigClass {
public:
 &nbsp; BigClass() {};
 &nbsp; ~BigClass(){}
 &nbsp;&nbsp;&nbsp;&nbsp; double BigArray[99999999];
};
void main() {
 &nbsp; try {
 &nbsp; BigClass * p = new BigClass;
 &nbsp; }
 &nbsp; catch( bad_alloc a) {
 &nbsp;&nbsp;&nbsp;&nbsp; const char * temp = a.what();
 &nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; temp &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Threw a bad_alloc exception" &lt;&lt; endl;
 &nbsp; }
 &nbsp; BigClass * q = new(nothrow) BigClass;
 &nbsp; if ( q == NULL )
 &nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Returned a NULL pointer" &lt;&lt; endl;
}
</code></pre>
<p>
and include the following header files, you will get the noted results.</p>
<pre><code>#include &lt;new&gt;
#include &lt;iostream&gt;
// No Errors.
#include &lt;iostream&gt;
#include &lt;new&gt;
// No Errors.
 #include &lt;iostream&gt;
// No Errors.
#include &lt;new&gt;
//C:\MSDEV\Projects\defcon\Text5.cpp(40) : error C2065: 'cout' : undeclared identifier
//C:\MSDEV\Projects\defcon\Text5.cpp(40) : error C2297: '&lt;&lt;' : bad right operand
//C:\MSDEV\Projects\defcon\Text5.cpp(40) : error C2065: 'endl' : undeclared identifier
//C:\MSDEV\Projects\defcon\Text5.cpp(41) : error C2297: '&lt;&lt;' : bad right operand
//C:\MSDEV\Projects\defcon\Text5.cpp(45) : error C2297: '&lt;&lt;' : bad right operand
#include &lt;new&gt;
#include &lt;iostream.h&gt;
// ext5.obj : error LNK2001: unresolved external symbol "void * __cdecl operator new(unsigned int,struct nothrow_t const &amp;)"(??2@YAPAXIABUnothrow_t@@@Z)
// Debug/defcon.exe : fatal error LNK1120: 1 unresolved externals
#include &lt;iostream.h&gt;
#include &lt;new&gt;
// Text5.obj : error LNK2001: unresolved external symbol "void * __cdecl operator new(unsigned int,struct nothrow_t const &amp;)"(??2@YAPAXIABUnothrow_t@@@Z)
// Debug/defcon.exe : fatal error LNK1120: 1 unresolved external
#include &lt;iostream.h&gt;
//C:\MSDEV\Projects\defcon\Text5.cpp(47) : error C2061: syntax error : identifier 'bad_alloc'
//C:\MSDEV\Projects\defcon\Text5.cpp(47) : error C2310: catch handlers must specify one type
//C:\MSDEV\Projects\defcon\Text5.cpp(48) : error C2065: 'a' : undeclared identifier
//C:\MSDEV\Projects\defcon\Text5.cpp(48) : error C2228: left of '.what' must hav class/struct/union type
//C:\MSDEV\Projects\defcon\Text5.cpp(52) : error C2317: 'try' block starting on line '44' has no catch handlers
//C:\MSDEV\Projects\defcon\Text5.cpp(52) : error C2065: 'nothrow' : undeclared identifier
//C:\MSDEV\Projects\defcon\Text5.cpp(52) : error C2660: 'new' : function does not take 2 parameters
</code></pre>
<h3>12.9 Type Identification: typeinfo</h3>
<p>
The <i>&lt;</i>typeinfo<i>&gt;</i> header defines a type associated with the type information generated by the implementation (<b>type_info</b>). It also defines two types for reporting dynamic type identification errors (<b>bad_cast and bad_typeid</b>).</p>
<p>
The <b>type_info</b> class is defined with a <b>raw_name</b> member in the help and header files (in both Visual C++ and the library). However, in the current version of the C++ Library Standard, there is no <b>raw_name</b> member. The <b>raw_name</b> member function returns a <b>const char*</b> to a null-terminated string representing the decorated name of the object type.</p>
<pre><code>class type_info {
public:
 &nbsp; virtual ~type_info();
 &nbsp; int operator==(const type_info&amp; rhs) const;
 &nbsp; int operator!=(const type_info&amp; rhs) const;
 &nbsp; int before(const type_info&amp; rhs) const;
 &nbsp; const char* name() const;
 &nbsp; const char* raw_name() const;
private:
 &nbsp; ...
};
</code></pre>
<h3>12.10 Exception Handling: exception</h3>
<p>
The exception class defines the base class for the types of objects thrown as exceptions by the C++ Standard Library components. The exception header file defines the exception class that is the base class for all exceptions thrown by the C++ Standard Library. The following code would catch any exception thrown by classes and functions in the Standard C++ Library:</p>
<pre><code>try {
 &nbsp; // code
}
catch ( const exception &amp;ex)
{
 &nbsp; cout &lt;&lt; "exception: " &lt;&lt; ex.what();
}
</code></pre>
<p>
The exception class is defined in the header file exception, as follows:</p>
<pre><code>class exception {
public:
 &nbsp;&nbsp; exception() throw();
 &nbsp;&nbsp; exception(const exception&amp; rhs) throw();
 &nbsp;&nbsp; exception&amp; operator<b>=</b>(const exception&amp; rhs) throw();
 &nbsp;&nbsp; virtual <b>~</b>exception() throw();
 &nbsp;&nbsp; virtual const char *what() const throw();
private:
…
};
</code></pre>
<p>
See <a href="#stlexhandle">Exception Handling</a> and <a href="#stllibdiag">Standard C++ Library Diagnostics</a> for further details. </p>
<h3>12.11 Other Run-Time Support: cstdarg, csetjmp, ctime, csignal, cstdlib</h3>
<p>
With Visual C++ 4.2, each of these headers files includes the corresponding C header file, stdarg.h, setjmp.h, time.h, signal.h, and stdlib.h. Macros, types, and functions listed for each of these in the Standard C++ Library are as follows:</p>
<pre><code>cstdarg&nbsp; 
Macros:&nbsp;&nbsp;&nbsp; va_arg&nbsp;&nbsp;&nbsp; va_end&nbsp;&nbsp; va_start&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Types:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 csetjmp&nbsp; 
Macro:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setjmp&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Types:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp_buf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Function:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longjmp 
 ctime&nbsp;&nbsp; 
Macros:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOCKS_PER_SEC 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Types:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Functions:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 csignal&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Macros:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIGABRT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIGILL&nbsp;&nbsp; SIGSEGV&nbsp;&nbsp; SIG_DFL 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIG_IGN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIGFPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIGINT&nbsp;&nbsp; SIGTERM&nbsp;&nbsp; SIG_ERR
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Types:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sig_atomic_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Functions:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
cstdlib
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Functions:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getenv&nbsp;&nbsp; system 
</code></pre>
<h2><a name="stlexhandle"></a>13. Exception Handling</h2>
<h3>13.1 Introduction</h3>
<p>
There was always a need to write robust and powerful programs that are resistant to run time errors, logic errors, and all other unexpected events. Exception handling is a relatively new and powerful tool that can be used for better and safer programming. As in many other areas, a good intention can lead to disastrous results. So, if you are not sure why and how to use exception handling, you are better off not using it at all.</p>
<h3>13.2 C++ Exception Handling</h3>
<p>
C++ exception handling uses three statements (<b>try</b>, <b>catch</b>, and <b>throw</b>) added to the C++ language. With C++ exception handling, your program can propagate unexpected events to a higher execution context that is better able to recover from such abnormal events. These exceptions are handled by code outside the normal flow of control. The Microsoft C++ compiler implements the C++ exception-handling model based on the ISO WG21/ANSI X3J16 working papers toward the evolving standard for C++.</p>
<h3>13.3 Structured Exception Handling</h3>
<p>
Structured exception handling is an extension to Microsoft C/C++ that can be used in either C or C++. Structured exception handling uses two constructs: <b>try-except</b>, known as exception handling, and <b>try-finally</b>, known as termination handling. The <b>try-except</b> statement enables applications to gain control of a program when events that normally terminate execution occur. The <b>try-finally</b> statement enables applications to guarantee execution of cleanup code when execution of a block of code is interrupted.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Structured exception handling works with Microsoft Win32® for both C and C++ source files. However, it is not specifically designed for C++. Your code is more portable when using C++ exception handling and is also more flexible because it can handle exceptions of any type. For C++ programs, it is recommended that you use the new C++ exception-handling mechanism (<b>try</b>, <b>catch</b>, and <b>throw</b> statements).</p>
<h3>13.4 Exception Handling Differences</h3>
<p>
The major difference between structured exception handling and C++ exception handling is that the C++ exception-handling model uses any data type, while the C structured exception-handling model uses type; unsigned int. That is, C exceptions are identified by an unsigned integer value, whereas C++ exceptions are identified by data type. When an exception is raised in C, each possible handler executes a filter, which examines the C exception context and determines whether to accept the exception, pass it to some other handler, or ignore it. When an exception is thrown in C++, it may be of any type.</p>
<p>
A second difference is that the C structured exception handling model is referred to as asynchronous because exceptions occur secondary to the normal flow of control. The C++ exception handling mechanism is fully synchronous, which means that exceptions occur only when they are thrown.</p>
<p>
If a C exception is raised in a C++ program, it can be handled by a structured exception handler with its associated filter or by a C++ catch handler, whichever is dynamically nearest to the exception context. </p>
<h4>13.4.1 Using different exception handling mechanisms</h4>
<p>
The following example demonstrates how to use different exception handling mechanisms:</p>
<pre><code>// Compile Options /GX
 &nbsp;&nbsp;&nbsp;&nbsp; /**************************************************************
 &nbsp;&nbsp;&nbsp;&nbsp; This simple program demonstrates how the asynchronous exceptions
 &nbsp;&nbsp;&nbsp;&nbsp; could be caught by C++ exceptions handling mechanism 
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; ************************************************************/
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;
 &nbsp;&nbsp;&nbsp;&nbsp; int *p = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pointer used to generate an AV
 &nbsp;&nbsp;&nbsp;&nbsp; class CMyObject {
 &nbsp;&nbsp;&nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; ~CMyObject () {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ("Here is the destructor for CMyObject\n");
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; void function1()
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMyObject ob;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *p=3;&nbsp;&nbsp; // causes an Access Violation exception
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; void function2()
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function1();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (...) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Caught an exception in function2()\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int main (void) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function2 ();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; Program Output:
 &nbsp; Here is the destructor for CMyObject
 &nbsp; Caught an exception in function1()
 &nbsp; Caught an exception in function2()
</code></pre>
<h4>13.4.2 The synchronous-exception handling model</h4>
<p>
Synchronous exceptions are objects thrown in C++ with a <b>throw()</b> statement. The synchronous exception-handling model is designed for catching synchronous exceptions only. The asynchronous exception-handling model is designed to catch synchronous exceptions and structured exception-handling type exceptions such as access violation and divides by zero.</p>
<p>
The compiler can assume exception can only happen at function calls. This makes it a lot easier to optimize the code and allows the removal of exception handling tracking code for local unwindable objects whose scope doesn't span across a function call (or where all calls are inlined).</p>
<h4>13.4.3 The asynchronous exception handling model</h4>
<p>
The synchronous exception-handling model is just an optimized version of the asynchronous exception-handling model. So the two models can be intermixed. The asynchronous exceptions can still be caught by the synchronous model with minor gotchas. The state tracking may not be quite up-to-date in the function where the exception occurs. This means that some of the local unwindable objects in the function that cause access violation may not get destructed, or an access violation in a function that has a <b>try</b>/<b>catch</b> may not get caught by this function. </p>
<h4>13.4.4 _declspec(nothrow)</h4>
<p>
You can also tune your code by telling the compiler that a particular function never throws an exception by using <b>_declspec(nothrow)</b> on the function declaration, or by using the new C++ nothrow specification.</p>
<h3>13.5 Major Points from the C++ Working Paper</h3>
<ul type=disc>
<li>
Exception handling provides a way of transferring control and information from a point in the execution of a program to an exception handler associated with a point previously passed by the execution.<br><br></li>
<li>
A <b>goto</b>, <b>break</b>, <b>return</b>, or <b>continue</b> statement can be used to transfer control out of a try block or handler, but not into one. When this happens, each variable declared in the try block will be destroyed in the context that directly contains its declaration. <br><br></li>
<li>
A function try block associates a handler seq with the ctor initializer, if present, and the function body. An exception thrown during the execution of the initializer expressions in the ctor initializer or during the execution of the function body transfers control to a handler in a function try block in the same way as an exception thrown during the execution of a try block transfers control to other handlers. <pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Example:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int f(int);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class C {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double d;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C(int, double);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C::C(int ii, double id)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i(f(ii)), d(id)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Constructor function body
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (...)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handles exceptions thrown from the ctor-initializer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and from the constructor function body.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
</li>
</ul>
<h3>13.6 Throwing an Exception </h3>
<p>
Throwing an exception transfers control to a handler. An object is passed and the type of that object determines which handlers can catch it. </p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Example:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw "Help!";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; can be caught by a handler of some char* type:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(const char* p) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle character string exceptions here.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class Overflow {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Overflow(char,double,double);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f(double x)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw Overflow('+',x,3.45e107);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
This can be caught by a handler for exceptions of type <b>Overflow</b>, as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f(1.2);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(Overflow&amp; oo) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle exceptions of type Overflow here
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
When an exception is thrown, control is transferred to the nearest handler with an appropriate type. The <i>nearest</i> handler is the handler whose try block the thread of control most recently entered but has not yet exited. </p>
<p>
A throw expression initializes a temporary object of the static type of the operand of throw and uses that temporary object to initialize the appropriately typed variable named in the handler.</p>
<p>
The memory for the temporary copy of the exception being thrown is allocated in an implementation-defined way. The temporary persists as long as there is a handler being executed for that exception. </p>
<p>
A throw expression with no operand rethrows the exception being handled without copying it. For example, code that must be executed because of an exception, yet cannot completely handle the exception, can be written as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Example:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (...) {&nbsp; // catch all exceptions
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // respond (partially) to exception
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw;&nbsp;&nbsp;&nbsp;&nbsp; // pass the exception to some
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // other handler
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
If no exception is presently being handled, executing a throw expression with no operand calls <b>terminate()</b>.</p>
<h3>13.7 Constructors and Destructors</h3>
<p>
As control passes from a throw point to a handler, destructors are invoked for all automatic objects constructed since the try block was entered. The automatic objects are destroyed in the reverse order of the completion of their construction.</p>
<p>
An object that is partially constructed will have destructors executed only for its fully constructed subobjects. If a constructor for an element of an automatic array throw an exception, only the constructed elements of that array will be destroyed. </p>
<p>
The process of calling destructors for automatic objects constructed on the path from a try block to a throw expression is called stack unwinding.</p>
<h3>13.8 Handling an Exception</h3>
<p>
The exception declaration in a handler describes the type(s) of exceptions that can cause that handler to be entered. The exception declaration shall not denote an incomplete type. Types shall not be defined in an exception declaration.</p>
<p>
The handlers for a try block are tried in order of appearance. That makes it possible to write handlers that can never be executed—for example, by placing a handler for a derived class after a handler for a corresponding base class.</p>
<p>
A <b>...</b> in a handler exception declaration functions similarly to <b>... </b>in a function parameter declaration; it specifies a match for any exception. If present, a <b>...</b> handler shall be the last handler for its try block.</p>
<p>
If no match is found among the handlers for a try block, the search for a matching handler continues in a dynamically surrounding try block.</p>
<p>
An exception is considered handled upon entry to a handler. (Note: the stack will have been unwound at that point.)</p>
<p>
If no matching handler is found in a program, the function <b>terminate()</b> is called. Whether or not the stack is unwound before calling, <b>terminate()</b> is implementation defined.</p>
<p>
Referring to any nonstatic member or base class of an object in the function try block handler of a constructor or destructor for that object results in undefined behavior.</p>
<p>
The fully constructed base classes and members of an object shall be destroyed before entering the function try block handler of a constructor or destructor for that object.</p>
<p>
The scope and lifetime of the parameters of a function or constructor extend into the handlers of a function try block.</p>
<p>
If the handlers of a function try block contain a jump into the body of a constructor or destructor, the program is ill-formed.</p>
<p>
If a return statement appears in a handler of function try block of a constructor, the program is ill-formed.</p>
<p>
The exception being handled is rethrown if control reaches the end of a handler of the function try block of a constructor or destructor. Otherwise, a function returns when control reaches the end of a handler for the function try block.</p>
<p>
When the catch handler specifies a class object, a copy constructor is used to initialize a temporary object that is bound to the optionally specified name in the exception declaration for the catch handler. The object shall not have an abstract class type, because objects of those types shall not be created. That object is destroyed when the handler is exited, after the destruction of any automatic objects initialized within the handler. The copy constructor and destructor shall be accessible in the context of the catch handler. If the copy constructor and destructor are implicitly declared, such a use in the catch handler causes these functions to be implicitly defined; otherwise, the program shall provide a definition for these functions. If the use of a temporary object can be eliminated without changing the meaning of the program (except for execution of constructors and destructors associated with the use of the temporary object), the optional name can be bound directly to the temporary (or original) object specified in a throw expression that causes the catch handler to be executed. The copy constructor and destructor associated with the object shall be accessible even when the temporary object is eliminated.</p>
<p>
When the catch handler specifies a nonconstant object, any changes to the object that are effected before the handler has exited are changes to the temporary copy for the handler. These changes will not affect the temporary (or original) object that was initialized by execution of the throw expression. When the catch handler specifies a reference to a nonconstant object, any changes to the referenced object are changes to the temporary (or original) object initialized when the throw expression was executed. These changes will have effect if that object is rethrown.</p>
<h3>13.9 Exception Specifications </h3>
<p>
By using an exception specification as a suffix of its declarator, a function declaration lists exceptions that its function may directly or indirectly throw.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exception-specification:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw ( type-id-listopt )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type-id-list:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type-id
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type-id-list ,&nbsp; type-id
</code></pre>
<p>
An exception specification shall appear only on a function declarator in a function, pointer declaration, or pointer definition. An exception specification shall not appear in a <b>typedef</b> declaration.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Example:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f() throw(int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*fp)() throw (int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void g(void pfa() throw(int));&nbsp;&nbsp; // OK
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef int (*pf)() throw(int);&nbsp; // Ill-formed
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Exception specification is optional and the absence of one does not impose restrictions on the possible function exceptions. </p>
<p>
If any declaration of a function has an exception specification, all declarations, including the definition, of that function shall have an exception specification with the same set of type IDs. If a virtual function has an exception specification, all declarations, including the definition, of any function that override that virtual function in any derived class shall only allow exceptions that are allowed by the exception specification of the base-class virtual function.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Example:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct B {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() throw (int, double);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void g();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct D: B {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ill-formed
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void g() throw (int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
</code></pre>
<p>
The declaration of <b>D::f</b> is ill-formed because it allows all exceptions, whereas <b>B::f</b> allows only int and double. Similarly, any function or pointer-to-function assigned to, or initializing, a pointer-to-function shall only allow exceptions that are allowed by the pointer or function being assigned or initialized. </p>
<pre><code>//Example:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*pf1)();&nbsp;&nbsp;&nbsp; // no exception specification
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*pf2)() throw(A);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pf1 = pf2;&nbsp; // ok: pf1 is less restrictive
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pf2 = pf1;&nbsp; // error: pf2 is more restrictive
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
In such an assignment or initialization, exception specifications on return types and parameter types shall match exactly.</p>
<p>
Calling a function through a declaration whose exception specification allows exceptions other than those allowed by the exception specification of the function definition is ill-formed. No diagnostic is required.</p>
<p>
Types shall not be defined in exception specifications.</p>
<p>
An exception specification can include the same class more than once and can include classes related by inheritance even though doing so is redundant. An exception specification can include identifiers that represent incomplete types. An exception specification can also include the name of the predefined class <b>bad_exception</b>.</p>
<p>
If a class <b><i>X</i></b> is in the <b>type-id-list</b> of the exception specification of a function, that function is said to allow exception objects of class <b><i>X </i></b>or any class publicly and unambiguously derived from <b><i>X</i></b>. Similarly, if a pointer type <b><i>Y*</i></b> is in the <b>type-id-list</b> of the exception specification of a function, the function allows exceptions of type <b><i>Y*</i></b> or exceptions that are pointers to any type publicly and unambiguously derived from <i>Y.</i> Otherwise, a function only allows exceptions that have the same type as the types specified in the type-id-list of its exception specification.</p>
<p>
Whenever an exception is thrown and the search for a handler encounters the outermost block of a function with an exception specification, the <b>unexpected()</b> function is called if the exception specification does not allow the exception. </p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class X { };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class Y { };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class Z: public X { };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class W { };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f() throw (X, Y)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int n = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (n) throw X();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (n) throw Z();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // also OK
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw W();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // will call unexpected()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
The <b>unexpected()</b> function may throw an exception that will satisfy the exception specification for which it was invoked (in this case, the search for another handler will continue at the call of the function with this exception specification) or it may call terminate.</p>
<p>
An implementation shall not reject an expression simply because when it is executed it throws or might throw an exception that the containing function does not allow.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern void f() throw(X, Y);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void g() throw(X)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f();&nbsp;&nbsp; // OK
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
The call to <i>f</i> is well formed even though when called, <i>f</i> may throw exception <i>Y</i> that <i>g</i> does not allow. </p>
<p>
A function with no exception specification allows all exceptions. A function with an empty exception specification, <b>throw()</b>, does not allow any exceptions.</p>
<p>
An exception specification is not considered part of a function type.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;There is no compile-time checking of function exception specification. It would be too complicated and too costly. For example, in order to check the exception propagation, the compiler would need to check the code of the called function, any function it calls, and so on. </p>
<h3>13.10 Special Functions </h3>
<p>
The exception handling mechanism relies on two functions,<b> terminate()</b> and <b>unexpected()</b>, for coping with errors related to the exception handling mechanism itself.</p>
<h4>13.10.1 The terminate() function </h4>
<p>
Exception handling must be abandoned for less subtle error handling techniques:
<ul type=disc>
<li>
When a exception handling mechanism, after completing evaluation of the object to be thrown but before completing the initialization of the exception declaration in the matching handler; (1) calls an existing user function via an uncaught exception or (2) cannot find a handler for a thrown exception.<br><br></li>
<li>
When the destruction of an object during stack unwinding exits using an exception. <br><br></li>
<li>
When construction or destruction of a nonlocal object with static storage duration exits using an exception. <br><br></li>
<li>
When execution of a function registered with <b>atexit</b> exits using an exception. <br><br></li>
<li>
When a throw expression with no operand attempts to rethrow an exception and no exception is being handled. <br><br></li>
<li>
When <b>unexpected</b> throws an exception that is not allowed by the previously violated exception specification and<b> bad_exception</b> is not included in that exception specification.<br><br></li>
<li>
When the implementation's default <b>unexpected_handler</b> is called<br><br></li>
<li>
When the implementation's exception handling mechanism encounters some internal error.</li>
</ul>
<p>
In such cases, <b>void terminate()</b>; is called.</p>
<h4>13.10.2 The unexpected() function</h4>
<p>
If a function with an exception specification throws an exception that is not listed in the exception specification, the <b>unexpected()</b> function is called.</p>
<p>
The <b>unexpected()</b> function shall not return, but it can throw (or rethrow) an exception. If it throws a new exception that is allowed by the previously violated exception specification, the search for another handler will continue at the call of the function whose exception specification was violated. If it throws or rethrows an exception that the exception specification does not allow, one of two things can happen. If the exception specification does not include the name of the predefined exception <b>bad_exception</b>, the <b>terminate()</b> function is called; otherwise, the thrown exception is replaced by an implementation-defined object of the type <b>bad_exception</b> and the search for another handler will continue at the call of the function whose exception specification was violated.</p>
<p>
An exception specification guarantees that only the listed exceptions will be thrown. If the exception specification includes the name <b>bad_exception</b>, any exception not on the list may be replaced by <b>bad_exception</b> within the function <b>unexpected()</b>.</p>
<h4>13.10.3 The uncaught_exception() function</h4>
<p>
The following predicate returns true after completing evaluation of the object to be thrown until the exception declaration in the matching handle completes initialization. (This includes stack unwinding.)</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool uncaught_exception();
</code></pre>
<h3>13.11 Exceptions and Access </h3>
<p>
If the exception declaration in a catch clause has class type and the function in which the catch clause occurs does not have access to the destructor of that class, the program is ill-formed.</p>
<p>
An object can be thrown if it can be copied and destroyed in the context of the function in which the throw expression occurs.</p>
<h2><a name="stllibdiag"></a>14. Standard C++ Library Diagnostics</h2>
<h3>14.1 Introduction</h3>
<p>
The Diagnostics Library contains new components that C++ programs may use to detect and report error conditions.</p>
<p>
The following header files contain components for reporting several kinds of exceptional conditions, documenting program assertions, and a global variable for error number codes:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=57%>Exception classes</td>
<td width=43%>&lt;stdexcept&gt;</td>
</tr>
<tr valign=top>
<td width=57%>Assertions</td>
<td width=43%>&lt;cassert&gt;  </td>
</tr>
<tr valign=top>
<td width=57%>Error numbers</td>
<td width=43%>&lt;cerrno&gt; </td>
</tr>
</table><br>
<h3>14.2 Exception Class Hierarchies</h3>
<p>
Using a common base class allows the use of one handler for many related exceptions. For example, a set of exception objects for memory allocation problems could be derived from the <b>MemoryException</b> base class such as out memory or <b>ZeroAlloc</b>. A single catch (<b>MemoryException</b>) handler would catch all memory exceptions including new ones. Virtual functions allow derived exception classes to use internal information that doesn’t exist in the base class. </p>
<h4>14.2.1 Using class hierarchy to define your own exception classes</h4>
<p>
The following example demonstrates how to use class hierarchies to define your own exception classes.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;// Compile Options. /GX
 &nbsp;&nbsp;&nbsp;&nbsp; /**************************************************************
 &nbsp;&nbsp;&nbsp;&nbsp; This program demonstrates how to use Class Hierarchies to define 
 &nbsp;&nbsp;&nbsp;&nbsp; your own exception classes. 
 &nbsp;&nbsp;&nbsp;&nbsp; It does not use a new new operator function from the Standard 
 &nbsp;&nbsp;&nbsp;&nbsp; Template Library. The intention is to demonstrate how to use
 &nbsp;&nbsp;&nbsp;&nbsp; class hierarchies to define your own exception classes.
 &nbsp;&nbsp;&nbsp;&nbsp; **************************************************************/
 &nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream&gt;
 &nbsp;&nbsp;&nbsp;&nbsp; class MemoryException 
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void DisplayMessage() = 0;
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; class OutOfMemory : public MemoryException 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void DisplayMessage();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; void OutOfMemory::DisplayMessage()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;  " Out of Memory!" &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp; class BadPointer : public MemoryException
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void * p;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void DisplayMessage();
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; void BadPointer :: DisplayMessage ()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Invalid pointer: " &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; const size_t szBuf = 99999999;
 &nbsp;&nbsp;&nbsp;&nbsp; int* iBuf;
 &nbsp;&nbsp;&nbsp;&nbsp; char* cBuf;
 &nbsp;&nbsp;&nbsp;&nbsp; void InitApp();
 &nbsp;&nbsp;&nbsp;&nbsp; void main ()
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitApp();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (MemoryException &amp; ex)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ex.DisplayMessage();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; void InitApp()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iBuf = new int [szBuf];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cBuf = new char [szBuf];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (...) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw OutOfMemory();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
The program output is:</p>
<pre><code>Out of Memory!
</code></pre>
<h3>14.3 Templates and Exceptions</h3>
<p>
Exceptions defined within a template class can be specific to each generated class. Given the following:</p>
<pre><code>template &lt;class T&gt; class Vector
{
 &nbsp; public:
 &nbsp; class ExceptionRange { }; //exception class 
};
</code></pre>
<p>
A catch block would need to specify the type of vector that it is handling, as follows:</p>
<pre><code>catch (Vector&lt;int&gt;:: ExceptionRange )
{
 &nbsp; //
}
</code></pre>
<h4>14.3.1 Using exception classes with templates</h4>
<p>
The following example demonstrates how to use exception classes with templates.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Compile Options /GX
 &nbsp;&nbsp;&nbsp;&nbsp; /**************************************************************
 &nbsp;&nbsp;&nbsp;&nbsp; This program demonstrates how to use Exception classes with 
 &nbsp;&nbsp;&nbsp;&nbsp; templates. The template class vector is user defined. 
 &nbsp;&nbsp;&nbsp;&nbsp; Each vector type needs to have a handler defined or the exception
 &nbsp;&nbsp;&nbsp;&nbsp; will be handled by function terminate ().
 &nbsp;&nbsp;&nbsp;&nbsp; **************************************************************/
 &nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream&gt;
 &nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;
 &nbsp;&nbsp;&nbsp;&nbsp; class Vector {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T* pT;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sz;
 &nbsp;&nbsp;&nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector (int s=1);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~Vector();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class ExceptionRange {};&nbsp; //Exception class
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T&amp; operator [] (int i);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int size () const { return sz;}
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T&gt;
 &nbsp;&nbsp;&nbsp;&nbsp; inline Vector&lt;T&gt;::Vector(int s)&nbsp; { pT = new T[sz=s];}
 &nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T&gt;
 &nbsp;&nbsp;&nbsp;&nbsp; inline Vector&lt;T&gt;::~Vector() { delete [] pT;}
 &nbsp;&nbsp;&nbsp;&nbsp; void range_error (Vector&lt;int&gt; &amp; v)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v[v.size()+10]; // trigger range error
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T&amp; Vector&lt;T&gt;::operator [] (int i)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0&lt;=i &amp;&amp; i &lt;sz) return pT[i];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw ExceptionRange ();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pT[0];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; void Do_Vector (Vector&lt;int&gt;&amp; v)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range_error(v);
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp; void main (void) 
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector &lt;int&gt; v(10);
 &nbsp;&nbsp;&nbsp;&nbsp; try
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; Do_Vector (v);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; // Catch (Vector&lt;class int&gt;::ExceptionRange)
 &nbsp;&nbsp;&nbsp;&nbsp; catch (Vector &lt;int&gt;::ExceptionRange)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handler for vector range exception
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Exception: Vector out of range" &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; Program Output:
 &nbsp;&nbsp;&nbsp;&nbsp; Exception: Vector out of range
</code></pre>
<p>
You would need to define handlers for each excepted type of vector; otherwise, the types not listed will be handled by <b>terminate ()</b> function. The exception could be defined outside of the <b>Vector</b> class as a global to all vector types. </p>
<p>
Exceptions defined within a class follow the standard access rules. If a class only handles an exception internally, the exception class should be private or protected. If you want the exception to be handled externally, make it public or define it outside of the error-producing class.</p>
<h4>14.3.2 Using exception classes with STL containers</h4>
<p>
The following is an example of how to use exception classes with STL containers.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Compile Options /GX
 &nbsp;&nbsp;&nbsp;&nbsp; /**************************************************************
 &nbsp;&nbsp;&nbsp;&nbsp; This is a header file for the derived template class MyVector. 
 &nbsp;&nbsp;&nbsp;&nbsp; MyVector is a derived from Vector template class. It contains 
 &nbsp;&nbsp;&nbsp;&nbsp; the exception class ExceptionRange. The operator [] is overloaded
 &nbsp;&nbsp;&nbsp;&nbsp; and throws the ExceptionRange when there is an attempt to
 &nbsp;&nbsp;&nbsp;&nbsp; access an out of range vector object. 
 &nbsp;&nbsp;&nbsp;&nbsp; **************************************************************/
// MyVector.h
 &nbsp;&nbsp;&nbsp;&nbsp; #ifndef MY_VECTOR_DEFINED
 &nbsp;&nbsp;&nbsp;&nbsp; #define MY_VECTOR_DEFINED
 &nbsp;&nbsp;&nbsp;&nbsp; #include &lt;vector&gt;
 &nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream&gt;
 &nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T&gt; class MyVector : public vector&lt;T,allocator&lt;T&gt; &gt;
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; typedef allocator&lt;T&gt; A;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explicit MyVector(const A&amp; al = A()) : vector&lt;T,A&gt;(al) {};
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explicit MyVector(size_type n, const T&amp; v = T(), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const A&amp; al = A()) : vector&lt;T,A&gt;(n, v, al) {}
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyVector(const MyVector&amp; x) : vector&lt;T,A&gt;(x) {}
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyVector(const_iterator first, const_iterator last, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const A&amp; al = A()) : vector&lt;T,A&gt;(first, last, al) {} 

 &nbsp;&nbsp;&nbsp;&nbsp; class ExceptionRange 
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; ExceptionRange (size_type _P) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;"An attempt was made to access an element out of 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range"&lt;&lt;endl;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Element for index: " &lt;&lt; _P &lt;&lt; " doesn't exist." 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; const_reference operator[](size_type _P) const throw 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ExceptionRange)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( _P &gt; ((end()-1) - begin()))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw ExceptionRange(_P);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(*(end()));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (*(begin() + _P));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reference operator[](size_type _P) throw (ExceptionRange)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( _P &gt; ((end()-1) - begin()))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw ExceptionRange(_P);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(*(end()));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (*(begin() + _P));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; #endif
// VectorMain.cpp 
/**************************************************************
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Compile Options /GX
 &nbsp;&nbsp;&nbsp;&nbsp; /**************************************************************
 &nbsp;&nbsp;&nbsp;&nbsp; This program demonstrates how to use Exception classes with 
 &nbsp;&nbsp;&nbsp;&nbsp; STL. 
 &nbsp;&nbsp;&nbsp;&nbsp; MyVector is a derived from Vector template class.
 &nbsp;&nbsp;&nbsp;&nbsp; This is just one method to make the use of STL library more safe.
 &nbsp;&nbsp;&nbsp;&nbsp; **************************************************************/
 &nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream&gt;
 &nbsp;&nbsp;&nbsp;&nbsp; #include "MyVector.h"
 &nbsp;&nbsp;&nbsp;&nbsp; void main()
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; MyVector&lt;int&gt; intVect;
 &nbsp;&nbsp;&nbsp;&nbsp; MyVector&lt;int&gt;::iterator intVectPtr;
 &nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; 20; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intVect.push_back(i*2);
 &nbsp;&nbsp;&nbsp;&nbsp; for(intVectPtr = intVect.begin(); intVectPtr != intVect.end();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intVectPtr++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *intVectPtr &lt;&lt; ", ";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;endl&lt;&lt;endl;

 &nbsp;&nbsp;&nbsp;&nbsp; try 
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt; 30 ;k++ )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; intVect[k] &lt;&lt;", ";
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; catch (MyVector &lt;int&gt;::ExceptionRange)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;endl;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Exception: Vector out of range" &lt;&lt; endl;
 &nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; 
</code></pre>
<p>
Program Output:</p>
<pre><code>0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
An attempt was made to access an element out of range.
Element for index: 20 doesn't exist.
Exception: Vector out of range.
</code></pre>
<h3>14.4 Exception Classes</h3>
<p>
The Standard C++ Library defines a base class exception as follows:</p>
<pre><code>class exception {
public:
 &nbsp;&nbsp; exception() throw();
 &nbsp;&nbsp; exception(const exception&amp; rhs) throw();
 &nbsp;&nbsp; exception&amp; operator=(const exception&amp; rhs) throw();
 &nbsp;&nbsp; virtual ~exception() throw();
 &nbsp;&nbsp; virtual const char *what() const throw();
 &nbsp;&nbsp; };
</code></pre>
<p>
The class serves as the base class for all exceptions thrown by certain expressions and by the Standard C++ Library. The C-string value returned by <b>what()</b> is left unspecified by the default constructor, but may be defined by the constructors for certain derived classes. None of the member functions throws any exceptions.
<ul type=disc>
<li>
The Standard C++ Library provides classes to be used to report certain errors in C++ programs. In the error model reflected in these classes, errors are divided into two broad categories: logic errors and run-time errors.<br><br></li>
<li>
The distinguishing characteristic of logic errors is that they are due to errors in the internal logic of the program. In theory, they are preventable.<br><br></li>
<li>
By contrast, run-time errors are due to events beyond the scope of the program. They cannot be easily predicted in advance. The header &lt;stdexcept&gt; defines several types of predefined exceptions for reporting errors in a C++ program. These exceptions are related via inheritance.</li>
</ul>
<h4>14.4.1 Header &lt;stdexcept&gt; synopsis</h4>
<pre><code>&nbsp;&nbsp;#include &lt;exception&gt;
  #include &lt;string&gt;
  namespace std {
 &nbsp;&nbsp; class logic_error;
 &nbsp;&nbsp;&nbsp;&nbsp; class domain_error;
 &nbsp;&nbsp;&nbsp;&nbsp; class invalid_argument;
 &nbsp;&nbsp;&nbsp;&nbsp; class length_error;
 &nbsp;&nbsp;&nbsp;&nbsp; class out_of_range;
 &nbsp;&nbsp; class runtime_error;
 &nbsp;&nbsp;&nbsp;&nbsp; class range_error;
 &nbsp;&nbsp;&nbsp;&nbsp; class overflow_error;
 &nbsp;&nbsp;&nbsp;&nbsp; class underflow_error;
  }

<b>class logic_error </b>

  namespace std {
 &nbsp;&nbsp; class logic_error : public exception {
 &nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; logic_error(const string&amp; what_arg);
 &nbsp;&nbsp; };
  }
</code></pre>
<p>
The class LOGIC_ERROR defines the type of objects thrown as exceptions to report errors that are, presumably, detectable before the program executes, such as violations of logical preconditions or class invariants.</p>
<pre><code>&nbsp;&nbsp;logic_error(const string&amp; what_arg);
  Effects:
 &nbsp;&nbsp; Constructs an object of class logic_error.
  Postcondition:
 &nbsp;&nbsp; what() == what_arg.data().

<b>class domain_error</b>

  namespace std {
 &nbsp;&nbsp; class domain_error : public logic_error {
 &nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; domain_error(const string&amp; what_arg);
 &nbsp;&nbsp; };
  }
</code></pre>
<p>
The class DOMAIN_ERROR defines the type of objects thrown as exceptions, by the implementation, to report domain errors.</p>
<pre><code>&nbsp;&nbsp;domain_error(const string&amp; what_arg);
  Effects:
 &nbsp;&nbsp; Constructs an object of class domain_error.
  Postcondition:
 &nbsp;&nbsp; what() == what_arg.data().
Class invalid_argument 
  namespace std {
 &nbsp;&nbsp; class invalid_argument : public logic_error {
 &nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; invalid_argument(const string&amp; what_arg);
 &nbsp;&nbsp; };
  }
</code></pre>
<p>
The class INVALID_ARGUMENT defines the type of objects thrown as exceptions to report an invalid argument.</p>
<pre><code>&nbsp;invalid_argument(const string&amp; what_arg);
 Effects:
 &nbsp;&nbsp; Constructs an object of class invalid_argument.
  Postcondition:
 &nbsp;&nbsp; what() == what_arg.data().

<b>class length_error </b>

  namespace std {
 &nbsp;&nbsp; class length_error : public logic_error {
 &nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; length_error(const string&amp; what_arg);
 &nbsp;&nbsp; };
  }
</code></pre>
<p>
The class LENGTH_ERROR defines the type of objects thrown as exceptions to report an attempt to produce an object whose length exceeds its maximum allowable size.</p>
<pre><code>&nbsp;&nbsp;length_error(const string&amp; what_arg);
  Effects:
 &nbsp;&nbsp; Constructs an object of class length_error.
  Postcondition:
 &nbsp;&nbsp; what() == what_arg.data().
Class out_of_range
  namespace std {
 &nbsp;&nbsp; class out_of_range : public logic_error {
 &nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; out_of_range(const string&amp; what_arg);
 &nbsp;&nbsp; };
  }
</code></pre>
<p>
The class OUT_OF_RANGE defines the type of objects thrown as exceptions to report an argument value not in its expected range.</p>
<pre><code>&nbsp;&nbsp;out_of_range(const string&amp; what_arg);
  Effects:
 &nbsp;&nbsp; Constructs an object of class out_of_range.
  Postcondition:
 &nbsp;&nbsp; what() == what_arg.data().

<b>class runtime_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>

  namespace std {
 &nbsp;&nbsp; class runtime_error : public exception {
 &nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; runtime_error(const string&amp; what_arg);
 &nbsp;&nbsp; };
  }
</code></pre>
<p>
The class RUNTIME_ERROR defines the type of objects thrown as exceptions to report errors presumably detectable only when the program executes.</p>
<pre><code>&nbsp;&nbsp;runtime_error(const string&amp; what_arg);
  Effects:
 &nbsp;&nbsp; Constructs an object of class runtime_error.
  Postcondition:
 &nbsp;&nbsp; what() == what_arg.data().

<b>class range_error </b>

  namespae std {
 &nbsp;&nbsp; class range_error : public runtime_error {
 &nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; range_error(const string&amp; what_arg);
 &nbsp;&nbsp; };
  }
</code></pre>
<p>
The class RANGE_ERROR defines the type of objects thrown as exceptions to report range errors in internal computations.</p>
<pre><code>&nbsp;&nbsp;range_error(const string&amp; what_arg);
  Effects:
 &nbsp;&nbsp; Constructs an object of class range_error.
  Postcondition:
 &nbsp;&nbsp; what() == what_arg.data().

<b>class overflow_error</b>

  namespace std {
 &nbsp;&nbsp; class overflow_error : public runtime_error {
 &nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; overflow_error(const string&amp; what_arg);
 &nbsp;&nbsp; };
  }
</code></pre>
<p>
The class OVERFLOW_ERROR defines the type of objects thrown as exceptions to report an arithmetic overflow error.</p>
<pre><code>&nbsp;&nbsp;overflow_error(const string&amp; what_arg);
  Effects:
 &nbsp;&nbsp; Constructs an object of class overflow_error.
  Postcondition:
 &nbsp;&nbsp; what() == what_arg.data().

<b>class underflow_error </b>

  namespace std {
 &nbsp;&nbsp; class underflow_error : public runtime_error {
 &nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; underflow_error(const string&amp; what_arg);
 &nbsp;&nbsp; };
  }
</code></pre>
<p>
The class UNDERFLOW_ERROR defines the type of objects thrown as exceptions to report an arithmetic underflow error.</p>
<pre><code>&nbsp;&nbsp;underflow_error(const string&amp; what_arg);
  Effects:
 &nbsp;&nbsp; Constructs an object of class underflow_error.
  Postcondition:
 &nbsp;&nbsp; what() == what_arg.data().
</code></pre>
<h4>14.4.2 Assertions </h4>
<p>
This provides macros for documenting C++ program assertions, and for disabling the assertion checks.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=31%><b>Header</b></td>
<td width=69%>&lt;cassert&gt; </td>
</tr>
<tr valign=top>
<td width=31%><b>Type</b></td>
<td width=69%>Name(s) </td>
</tr>
<tr valign=top>
<td width=31%><b>Macro</b></td>
<td width=69%>assert </td>
</tr>
</table><br>
<p>
The contents are the same as the Standard C library.</p>
<h4>14.4.3 Error numbers</h4>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=31%><b>Header</b></td>
<td width=69%>&lt;cerrno&gt; :</td>
</tr>
<tr valign=top>
<td width=31%><b>Type</b></td>
<td width=69%>Name(s)&nbsp;&nbsp;&nbsp; </td>
</tr>
<tr valign=top>
<td width=31%><b>Macros</b></td>
<td width=69%>EDOM ERANGE&nbsp; errno</td>
</tr>
</table><br>
<p>
The contents are the same as the Standard C library.</p>
<h4>14.4.4 Floating-point exception class sample</h4>
<p>
The following example demonstrates how to implement a floating-point exception class.</p>
<pre><code>// Floating-point exception class sample
// Compile Options /GX
/*******************************************************************
 &nbsp;&nbsp; This program demonstrates how to use the exception classes 
 &nbsp;&nbsp; from the diagnostics library to handle floating point exceptions;
 &nbsp;&nbsp; float_error class is derived from logic_error base class.
********************************************************************/
 &nbsp; #include &lt;exception&gt;
 &nbsp; #include &lt;iostream&gt;
 &nbsp; #include &lt;complex&gt;
 &nbsp; //floating-point exception class
 &nbsp; class float_error : public logic_error&nbsp;&nbsp;&nbsp; 
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_error (char buffer[]) : logic_error (buffer)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;"Floating point math error occurred in 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; your program ";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;"More details below:"&lt;&lt;endl;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; };
 &nbsp; //Math error handler
 &nbsp; int _matherr (struct _exception * ex)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; char buffer [128];
 &nbsp;&nbsp;&nbsp;&nbsp; const char * ErrorType;

 &nbsp; //Determine type of error.
 &nbsp;&nbsp;&nbsp;&nbsp; switch (ex-&gt;type)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _DOMAIN:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorType = "Domain Error: ";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _SING:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorType = "Singularity Error:";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _OVERFLOW:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorType = "Overflow Error:";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _UNDERFLOW:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorType = "Underflow Error:";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _PLOSS:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorType = "Partial Loss of significance:";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _TLOSS:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorType = "Total loss of significance:";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorType = "Some other math error:";
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; //Construct error string.
 &nbsp;&nbsp;&nbsp;&nbsp; sprintf (buffer, "%s: %s(%g,%g) returns %g",ErrorType,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ex-&gt;name,ex-&gt;arg1,ex-&gt;arg2,ex-&gt;retval);
 &nbsp; //Throw an exception.
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; throw float_error(buffer);
 &nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp; }&nbsp;&nbsp;&nbsp; 
 &nbsp; void&nbsp; TestMathErrors(double (*fp) (double), double arg)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; //Next text
 &nbsp;&nbsp;&nbsp;&nbsp; bool caught = false;
 &nbsp;&nbsp;&nbsp;&nbsp; //Generate a floating-point error.
 &nbsp;&nbsp;&nbsp;&nbsp; try {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x = fp (arg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; catch (exception &amp; ex)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; ex.what() &lt;&lt; endl&lt;&lt;endl;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; caught = true;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; if (!caught) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "didn't catch exception through materr\r\n";
 &nbsp; }
 &nbsp; int main (void) 
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; typedef double (*fp) (double);
 &nbsp;&nbsp;&nbsp;&nbsp; //Array to the several functions
 &nbsp;&nbsp;&nbsp;&nbsp; fp math_function [] = { &amp;sqrt, &amp;log, &amp;sin, &amp;tan, &amp;acos };&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; double arg []= { -1.0, 0.0, 1.5e25, 1.5e25, 2&nbsp; };

 &nbsp;&nbsp;&nbsp;&nbsp; for (int n=0;&nbsp; n &lt; 5;n++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TestMathErrors(math_function[n],arg[n]);
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp; }
</code></pre>
<p>
Program output is:</p>
<pre><code>Floating point math error occurred in your program. More details below:
Domain Error: : sqrt(-1,-3.10504e+231) returns -1.#IND
Floating point math error occurred in your program. More details below:
Singularity Error:: log(0,-3.10504e+231) returns -1.#INF
Floating point math error occurred in your program. More details below:
Total loss of significance:: sin(1.5e+025,-3.10504e+231) returns -1.#IND
Floating point math error occurred in your program. More details below:
Total loss of significance:: tan(1.5e+025,-3.10504e+231) returns -1.#IND
Floating point math error occurred in your program. More details below:
Domain Error: : acos(2,-3.10504e+231) returns -1.#IND
</code></pre>
<h2><a name="stlappendixa"></a>15. Appendix A: STL References and Further Reading</h2>
<p>
ANSII C++ Working Paper. May 1996.</p>
<p>
Glass, Graham and Brett Schuchert. <i>The STL Primer</i>. Prentice Hall. 1996</p>
<p>
Ladd, Scott Robert. <i>C++ I/O Streams, Containers, and Standard Classes</i>. M&amp;T Books. 1996</p>
<p>
Musser, David R. and Atul Saini. <i>STL Tutorial and Reference Guide</i>. Addison-Wesley</p>
<p>
Plauger, P.J. <i>The Draft Standard C++ Library</i>. Prentice Hall.</p>
<p>
Plauger, P.J. <i>C++ User’s Journal. </i>Series of articles beginning June, 1996.</p>
<p>
Stroustrup, Bjarne. <i>The C++ Programming Language, Second Edition</i>. AT&amp;T. 1993</p>
<h2><a name="stlappendixb"></a>16. Appendix B: STL Container Class Definitions</h2>
<p>
All the definitions provided below are for STL Container classes provided in Microsoft Visual C++ 4.2.</p>
<h3>16.1 deque</h3>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In the definition below, the template parameter <i>Type</i> represents the type of data the deque will store (for example, int). The template parameter <i>A</i> represents the allocator object the deque will use for memory allocation.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &nbsp; // TEMPLATE CLASS deque
template&lt;class TYPE, class A&gt;
 &nbsp; class deque {
public:
 &nbsp; typedef deque&lt;TYPE, A&gt; Myt;
 &nbsp; typedef A allocatorTYPE;
 &nbsp; typedef A::sizeTYPE sizeTYPE;
 &nbsp; typedef A::differenceTYPE differenceTYPE;
 &nbsp; typedef A::pointer Tptr;
 &nbsp; typedef A::const_pointer Ctptr;
 &nbsp; typedef POINTER_X(Tptr, A) Mapptr;
 &nbsp; typedef A::reference reference;
 &nbsp; typedef A::const_reference const_reference;
 &nbsp; typedef A::valueTYPE valueTYPE;
 &nbsp;&nbsp;&nbsp;&nbsp; // CLASS iterator
 &nbsp; class iterator : public Ranit&lt;TYPE, differenceTYPE&gt; {
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; friend class deque&lt;TYPE, A&gt;;
 &nbsp;&nbsp;&nbsp;&nbsp; iterator();
 &nbsp;&nbsp;&nbsp;&nbsp; iterator(Tptr P, Mapptr M);
 &nbsp;&nbsp;&nbsp;&nbsp; reference operator*() const;
 &nbsp;&nbsp;&nbsp;&nbsp; iterator&amp; operator++();
 &nbsp;&nbsp;&nbsp;&nbsp; iterator operator++(int);
 &nbsp;&nbsp;&nbsp;&nbsp; iterator&amp; operator--();
 &nbsp;&nbsp;&nbsp;&nbsp; iterator operator--(int);
 &nbsp;&nbsp;&nbsp;&nbsp; iterator&amp; operator+=(differenceTYPE N);
 &nbsp;&nbsp;&nbsp;&nbsp; iterator&amp; operator-=(differenceTYPE N);
 &nbsp;&nbsp;&nbsp;&nbsp; iterator operator+(differenceTYPE N) const;
 &nbsp;&nbsp;&nbsp;&nbsp; iterator operator-(differenceTYPE N) const;
 &nbsp;&nbsp;&nbsp;&nbsp; differenceTYPE operator-(const iterator&amp; X) const;
 &nbsp;&nbsp;&nbsp;&nbsp; reference operator[](differenceTYPE N) const;
 &nbsp;&nbsp;&nbsp;&nbsp; bool operator==(const iterator&amp; X) const;
 &nbsp;&nbsp;&nbsp;&nbsp; bool operator&lt;(const iterator&amp; X) const;
 &nbsp; protected:
 &nbsp;&nbsp;&nbsp;&nbsp; void Add(differenceTYPE N);
 &nbsp; protected:
 &nbsp;&nbsp;&nbsp;&nbsp; Tptr First, Last, Next;
 &nbsp;&nbsp;&nbsp;&nbsp; _Mapptr Map;
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; // CLASS const_iterator
 &nbsp; class const_iterator : public iterator {
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator();
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator(Tptr P, Mapptr M);
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator(const iterator&amp; X);
 &nbsp;&nbsp;&nbsp;&nbsp; const_reference operator*() const;
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator&amp; operator++();
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator operator++(int);
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator&amp; operator--();
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator operator--(int);
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator&amp; operator+=(differenceTYPE N);
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator&amp; operator-=(differenceTYPE N);
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator operator+(differenceTYPE N) const;
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator operator-(differenceTYPE N) const;
 &nbsp;&nbsp;&nbsp;&nbsp; differenceTYPE operator-(const const_iterator&amp; X) const;
 &nbsp;&nbsp;&nbsp;&nbsp; const_reference operator[](differenceTYPE N) const;
 &nbsp;&nbsp;&nbsp;&nbsp; bool operator==(const const_iterator&amp; X) const;
 &nbsp;&nbsp;&nbsp;&nbsp; bool operator&lt;(const const_iterator&amp; X) const;
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp; typedef reverse_bidirectional_iterator&lt;iterator, valueTYPE, reference,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tptr, differenceTYPE&gt; reverse_iterator;
 &nbsp; typedef reverse_bidirectional_iterator&lt;const_iterator, valueTYPE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const_reference, Ctptr, differenceTYPE&gt; const_reverse_iterator;
 &nbsp; explicit deque(const A&amp; Al = A());
 &nbsp; explicit deque(sizeTYPE N, const TYPE&amp; V = TYPE(),const A&amp; Al = A());
 &nbsp; deque(const Myt&amp; X);
 &nbsp; typedef const_iterator It;
 &nbsp; deque(It F, It L, const A&amp; Al = A());
 &nbsp; ~deque();
 &nbsp; Myt&amp; operator=(const Myt&amp; X);
 &nbsp; iterator begin();
 &nbsp; const_iterator begin() const;
 &nbsp; iterator end();
 &nbsp; const_iterator end() const;
 &nbsp; reverse_iterator rbegin();
 &nbsp; const_reverse_iterator rbegin() const;
 &nbsp; reverse_iterator rend();
 &nbsp; const_reverse_iterator rend() const;
 &nbsp; void resize(sizeTYPE N, TYPE X = TYPE());
 &nbsp; sizeTYPE size() const;
 &nbsp; sizeTYPE max_size() const;
 &nbsp; bool empty() const;
 &nbsp; A getAllocator() const;
 &nbsp; const_reference at(sizeTYPE P) const;
 &nbsp; reference at(sizeTYPE P);
 &nbsp; const_reference operator[](sizeTYPE P) const;
 &nbsp; reference operator[](sizeTYPE P);
 &nbsp; reference front();
 &nbsp; const_reference front() const;
 &nbsp; reference back();
 &nbsp; const_reference back() const;
 &nbsp; void push_front(const TYPE&amp; X);
 &nbsp; void pop_front();
 &nbsp; void push_back(const TYPE&amp; X);
 &nbsp; void pop_back();
 &nbsp; void assign(It F, It L);
 &nbsp; void assign(sizeTYPE N, const TYPE&amp; X = TYPE());
 &nbsp; iterator insert(iterator P, const TYPE&amp; X = TYPE());
 &nbsp; void insert(iterator P, sizeTYPE M, const TYPE&amp; X);
 &nbsp; void insert(iterator P, It F, It L);
 &nbsp; iterator erase(iterator P);
 &nbsp; iterator erase(iterator F, iterator L);
 &nbsp; void clear();
 &nbsp; void swap(Myt&amp; X);
 &nbsp; friend void swap(Myt&amp; X, Myt&amp; Y);
protected:
 &nbsp; void Buyback();
 &nbsp; void Buyfront();
 &nbsp; void Freeback();
 &nbsp; void Freefront();
 &nbsp; void Xran() const;
 &nbsp; A allocator;
 &nbsp; iterator First, Last;
 &nbsp; Mapptr Map;
 &nbsp; sizeTYPE Mapsize, Size;
 &nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; // deque TEMPLATE OPERATORS
template&lt;class TYPE, class A&gt; inline bool operator==(const deque&lt;TYPE, A&gt;&amp; X, 
 &nbsp;&nbsp;&nbsp;&nbsp; const deque&lt;TYPE, A&gt;&amp; Y);
template&lt;class TYPE, class A&gt; inline bool operator&lt;(const deque&lt;TYPE, A&gt;&amp; X,
 &nbsp;&nbsp;&nbsp;&nbsp; const deque&lt;TYPE, A&gt;&amp; Y);
</code></pre>
<h3>16.2 list</h3>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In the definition below, the template parameter <i>Type</i> represents the type of data the list will store (for example, int). The template parameter <i>A</i> represents the allocator object the list will use for memory allocation.</p>
<p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></p>
<pre><code>// TEMPLATE CLASS list
template&lt;class TYPE, class A&gt;
 &nbsp; class list {
protected:
 &nbsp; typedef POINTER_X(void, A) Genptr;
 &nbsp; struct Node;
 &nbsp; friend struct Node;
 &nbsp; struct Node {
 &nbsp;&nbsp;&nbsp;&nbsp; Genptr Next, Prev;
 &nbsp;&nbsp;&nbsp;&nbsp; TYPE Value;
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp; typedef POINTER_X(Node, A) Nodeptr;
 &nbsp; struct Acc;
 &nbsp; friend struct Acc;
 &nbsp; struct Acc {
 &nbsp;&nbsp;&nbsp;&nbsp; typedef REFERENCE_X(Nodeptr, A) Nodepref;
 &nbsp;&nbsp;&nbsp;&nbsp; typedef A::reference Vref;
 &nbsp;&nbsp;&nbsp;&nbsp; static Nodepref Next(Nodeptr P)
 &nbsp;&nbsp;&nbsp;&nbsp; static Nodepref Prev(Nodeptr P)
 &nbsp;&nbsp;&nbsp;&nbsp; static Vref Value(Nodeptr P)
 &nbsp;&nbsp;&nbsp;&nbsp; };
public:
 &nbsp; typedef list&lt;TYPE, A&gt; Myt;
 &nbsp; typedef A allocator_type;
 &nbsp; typedef A::size_type size_type;
 &nbsp; typedef A::difference_type difference_type;
 &nbsp; typedef A::pointer Tptr;
 &nbsp; typedef A::const_pointer Ctptr;
 &nbsp; typedef A::reference reference;
 &nbsp; typedef A::const_reference const_reference;
 &nbsp; typedef A::value_type value_type;
 &nbsp;&nbsp;&nbsp;&nbsp; // CLASS iterator
 &nbsp; class iterator;
 &nbsp; friend class iterator;
 &nbsp; class iterator : public Bidit&lt;TYPE, difference_type&gt; {
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; iterator()
 &nbsp;&nbsp;&nbsp;&nbsp; iterator(Nodeptr P)
 &nbsp;&nbsp;&nbsp;&nbsp; reference operator*() const
 &nbsp;&nbsp;&nbsp;&nbsp; iterator&amp; operator++()
 &nbsp;&nbsp;&nbsp;&nbsp; iterator operator++(int)
 &nbsp;&nbsp;&nbsp;&nbsp; iterator&amp; operator--()
 &nbsp;&nbsp;&nbsp;&nbsp; iterator operator--(int)
 &nbsp;&nbsp;&nbsp;&nbsp; bool operator==(const iterator&amp; X) const
 &nbsp;&nbsp;&nbsp;&nbsp; Nodeptr Mynode() const
 &nbsp; protected:
 &nbsp;&nbsp;&nbsp;&nbsp; Nodeptr Ptr;
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; // CLASS const_iterator
 &nbsp; class const_iterator;
 &nbsp; friend class const_iterator;
 &nbsp; class const_iterator : public iterator {
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator()
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator(Nodeptr P)
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator(const iterator&amp; X)
 &nbsp;&nbsp;&nbsp;&nbsp; const_reference operator*() const
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator&amp; operator++()
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator operator++(int)
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator&amp; operator--()
 &nbsp;&nbsp;&nbsp;&nbsp; const_iterator operator--(int)
 &nbsp;&nbsp;&nbsp;&nbsp; bool operator==(const const_iterator&amp; X) const
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp; typedef reverse_bidirectional_iterator&lt;iterator,
 &nbsp;&nbsp;&nbsp;&nbsp; value_type, reference, Tptr, difference_type&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse_iterator;
 &nbsp; typedef reverse_bidirectional_iterator&lt;const_iterator,
 &nbsp;&nbsp;&nbsp;&nbsp; value_type, const_reference, Ctptr, difference_type&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const_reverse_iterator;
 &nbsp; explicit list(const A&amp; Al = A())
 &nbsp; explicit list(size_type N, const TYPE&amp; V = TYPE(),
 &nbsp;&nbsp;&nbsp;&nbsp; const A&amp; Al = A())
 &nbsp; list(const Myt&amp; X)
 &nbsp; typedef const_iterator It;
 &nbsp; list(It F, It L, const A&amp; Al = A())
 &nbsp; ~list()
 &nbsp; Myt&amp; operator=(const Myt&amp; X)
 &nbsp; iterator begin()
 &nbsp; const_iterator begin() const
 &nbsp; iterator end()
 &nbsp; const_iterator end() const
 &nbsp; reverse_iterator rbegin()
 &nbsp; const_reverse_iterator rbegin() const
 &nbsp; reverse_iterator rend()
 &nbsp; const_reverse_iterator rend() const
 &nbsp; void resize(size_type N, TYPE X = TYPE())
 &nbsp; size_type size() const
 &nbsp; size_type max_size() const
 &nbsp; bool empty() const
 &nbsp; A get_allocator() const
 &nbsp; reference front()
 &nbsp; const_reference front() const
 &nbsp; reference back()
 &nbsp; const_reference back() const
 &nbsp; void push_front(const TYPE&amp; X)
 &nbsp; void pop_front()
 &nbsp; void push_back(const TYPE&amp; X)
 &nbsp; void pop_back()
 &nbsp; void assign(It F, It L)
 &nbsp; void assign(size_type N, const TYPE&amp; X = TYPE())
 &nbsp; iterator insert(iterator P, const TYPE&amp; X = TYPE())
 &nbsp; void insert(iterator P, size_type M, const TYPE&amp; X)
 &nbsp; void insert(iterator P, const TYPE *F, const TYPE *L)
 &nbsp; void insert(iterator P, It F, It L)
 &nbsp; iterator erase(iterator P)
 &nbsp; iterator erase(iterator F, iterator L)
 &nbsp; void clear()
 &nbsp; void swap(Myt&amp; X)
 &nbsp; friend void swap(Myt&amp; X, Myt&amp; Y)
 &nbsp; void splice(iterator P, Myt&amp; X)
 &nbsp; void splice(iterator P, Myt&amp; X, iterator F)
 &nbsp; void splice(iterator P, Myt&amp; X, iterator F, iterator L)
 &nbsp; void remove(const TYPE&amp; V)
 &nbsp; typedef binder2nd&lt;not_equal_to&lt;TYPE&gt; &gt; Pr1;
 &nbsp; void remove_if(Pr1 Pr)
 &nbsp; void unique()
 &nbsp; typedef not_equal_to&lt;TYPE&gt; Pr2;
 &nbsp; void unique(Pr2 Pr)
 &nbsp; void merge(Myt&amp; X)
 &nbsp; typedef greater&lt;TYPE&gt; Pr3;
 &nbsp; void merge(Myt&amp; X, Pr3 Pr)
 &nbsp; void sort()
 &nbsp; void sort(Pr3 Pr)
 &nbsp; void reverse()
protected:
 &nbsp; Nodeptr Buynode(Nodeptr Narg = 0, Nodeptr Parg = 0)
 &nbsp; void Freenode(Nodeptr S)
 &nbsp; void Splice(iterator P, Myt&amp; X, iterator F, iterator L)
 &nbsp; void Xran() const
 &nbsp; A allocator;
 &nbsp; Nodeptr Head;
 &nbsp; size_type Size;
 &nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; // list TEMPLATE OPERATORS
template&lt;class TYPE, class A&gt; inline
 &nbsp; bool operator==(const list&lt;TYPE, A&gt;&amp; X,
 &nbsp;&nbsp;&nbsp;&nbsp; const list&lt;TYPE, A&gt;&amp; Y)
template&lt;class TYPE, class A&gt; inline
 &nbsp; bool operator&lt;(const list&lt;TYPE, A&gt;&amp; X,
 &nbsp;&nbsp;&nbsp;&nbsp; const list&lt;TYPE, A&gt;&amp; Y)
</code></pre>
<h3>16.3 map and multimap </h3>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In the definitions below, the template parameter <i>K</i> represents the type of data the map will store (for example, int). The template parameter <i>Pr </i>represents the user-defined comparator object (for example, <b>less&lt;K&gt;</b>). The template parameter <i>A</i> represents the allocator object the map will use for memory allocation.</p>
<p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></p>
<pre><code>// TEMPLATE CLASS map
template&lt;class K, class TYPE, class Pr, class A&gt;
 &nbsp; class map {
public:
 &nbsp; typedef map&lt;K, TYPE, Pr, A&gt; Myt;
 &nbsp; typedef pair&lt;const K, TYPE&gt; value_type;
 &nbsp; struct Kfn : public unary_function&lt;value_type, K&gt; {
 &nbsp;&nbsp;&nbsp;&nbsp; const K&amp; operator()(const value_type&amp; X) const
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp; class value_compare
 &nbsp;&nbsp;&nbsp;&nbsp; : public binary_function&lt;value_type, value_type, bool&gt; {
 &nbsp;&nbsp;&nbsp;&nbsp; friend class map&lt;K, TYPE, Pr, A&gt;;
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; bool operator()(const value_type&amp; X,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const value_type&amp; Y) const
 &nbsp; protected:
 &nbsp;&nbsp;&nbsp;&nbsp; value_compare(Pr Pred)
 &nbsp;&nbsp;&nbsp;&nbsp; Pr comp;
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp; typedef K key_type;
 &nbsp; typedef TYPE referent_type;
 &nbsp; typedef Pr key_compare;
 &nbsp; typedef A allocator_type;
 &nbsp; typedef A::reference Tref;
 &nbsp; typedef Tree&lt;K, value_type, Kfn, Pr, A&gt; Imp;
 &nbsp; typedef Imp::size_type size_type;
 &nbsp; typedef Imp::difference_type difference_type;
 &nbsp; typedef Imp::reference reference;
 &nbsp; typedef Imp::const_reference const_reference;
 &nbsp; typedef Imp::iterator iterator;
 &nbsp; typedef Imp::const_iterator const_iterator;
 &nbsp; typedef Imp::reverse_iterator reverse_iterator;
 &nbsp; typedef Imp::const_reverse_iterator const_reverse_iterator;
 &nbsp; typedef pair&lt;iterator, bool&gt; Pairib;
 &nbsp; typedef pair&lt;iterator, iterator&gt; Pairii;
 &nbsp; typedef pair&lt;const_iterator, const_iterator&gt; Paircc;
 &nbsp; explicit map(const Pr&amp; Pred = Pr(), const A&amp; Al = A())
 &nbsp; typedef const value_type *It;
 &nbsp; map(It F, It L, const Pr&amp; Pred = Pr(),
 &nbsp; iterator begin()
 &nbsp; const_iterator begin() const
 &nbsp; iterator end()
 &nbsp; const_iterator end() const
 &nbsp; reverse_iterator rbegin()
 &nbsp; const_reverse_iterator rbegin() const
 &nbsp; reverse_iterator rend()
 &nbsp; const_reverse_iterator rend() const
 &nbsp; size_type size() const
 &nbsp; size_type max_size() const
 &nbsp; bool empty() const
 &nbsp; A get_allocator() const
 &nbsp; Tref operator[](const key_type&amp; Kv)
 &nbsp; Pairib insert(const value_type&amp; X)
 &nbsp; iterator insert(iterator P, const value_type&amp; X)
 &nbsp; void insert(It F, It L)
 &nbsp; iterator erase(iterator P)
 &nbsp; iterator erase(iterator F, iterator L)
 &nbsp; size_type erase(const K&amp; Kv)
 &nbsp; void clear()
 &nbsp; void swap(Myt&amp; X)
 &nbsp; friend void swap(Myt&amp; X, Myt&amp; Y)
 &nbsp; key_compare key_comp() const
 &nbsp; value_compare value_comp() const
 &nbsp; iterator find(const K&amp; Kv)
 &nbsp; const_iterator find(const K&amp; Kv) const
 &nbsp; size_type count(const K&amp; Kv) const
 &nbsp; iterator lower_bound(const K&amp; Kv)
 &nbsp; const_iterator lower_bound(const K&amp; Kv) const
 &nbsp; iterator upper_bound(const K&amp; Kv)
 &nbsp; const_iterator upper_bound(const K&amp; Kv) const
 &nbsp; Pairii equal_range(const K&amp; Kv)
 &nbsp; Paircc equal_range(const K&amp; Kv) const
protected:
 &nbsp; Imp Tr;
 &nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; // map TEMPLATE OPERATORS
template&lt;class K, class TYPE, class Pr, class A&gt; inline
 &nbsp; bool operator==(const map&lt;K, TYPE, Pr, A&gt;&amp; X,
 &nbsp;&nbsp;&nbsp;&nbsp; const map&lt;K, TYPE, Pr, A&gt;&amp; Y)
template&lt;class K, class TYPE, class Pr, class A&gt; inline
 &nbsp; bool operator&lt;(const map&lt;K, TYPE, Pr, A&gt;&amp; X,
 &nbsp;&nbsp;&nbsp;&nbsp; const map&lt;K, TYPE, Pr, A&gt;&amp; Y)
 &nbsp;&nbsp;&nbsp;&nbsp; // TEMPLATE CLASS multimap
template&lt;class K, class TYPE, class Pr, class A&gt;
 &nbsp; class multimap {
public:
 &nbsp; typedef multimap&lt;K, TYPE, Pr, A&gt; Myt;
 &nbsp; typedef pair&lt;const K, TYPE&gt; value_type;
 &nbsp; struct Kfn : public unary_function&lt;value_type, K&gt; {
 &nbsp;&nbsp;&nbsp;&nbsp; const K&amp; operator()(const value_type&amp; X) const
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp; class value_compare
 &nbsp;&nbsp;&nbsp;&nbsp; : public binary_function&lt;value_type, value_type, bool&gt; {
 &nbsp;&nbsp;&nbsp;&nbsp; friend class Myt;
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; bool operator()(const value_type&amp; X,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const value_type&amp; Y) const
 &nbsp; protected:
 &nbsp;&nbsp;&nbsp;&nbsp; value_compare(Pr Pred)
 &nbsp;&nbsp;&nbsp;&nbsp; Pr comp;
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp; typedef K key_type;
 &nbsp; typedef TYPE referent_type;
 &nbsp; typedef Pr key_compare;
 &nbsp; typedef A allocator_type;
 &nbsp; typedef Tree&lt;K, value_type, Kfn, Pr, A&gt; Imp;
 &nbsp; typedef Imp::size_type size_type;
 &nbsp; typedef Imp::difference_type difference_type;
 &nbsp; typedef Imp::reference reference;
 &nbsp; typedef Imp::const_reference const_reference;
 &nbsp; typedef Imp::iterator iterator;
 &nbsp; typedef Imp::const_iterator const_iterator;
 &nbsp; typedef Imp::reverse_iterator reverse_iterator;
 &nbsp; typedef Imp::const_reverse_iterator const_reverse_iterator;
 &nbsp; typedef pair&lt;iterator, iterator&gt; Pairii;
 &nbsp; typedef pair&lt;const_iterator, const_iterator&gt; Paircc;
 &nbsp; explicit multimap(const Pr&amp; Pred = Pr(),
 &nbsp; typedef const value_type *It;
 &nbsp; multimap(It F, It L, const Pr&amp; Pred = Pr(), const A&amp; Al = A())
 &nbsp; iterator begin()
 &nbsp; const_iterator begin() const
 &nbsp; iterator end()
 &nbsp; const_iterator end() const
 &nbsp; reverse_iterator rbegin()
 &nbsp; const_reverse_iterator rbegin() const
 &nbsp; reverse_iterator rend()
 &nbsp; const_reverse_iterator rend() const
 &nbsp; size_type size() const
 &nbsp; size_type max_size() const
 &nbsp; bool empty() const
 &nbsp; A get_allocator() const
 &nbsp; iterator insert(const value_type&amp; X)
 &nbsp; iterator insert(iterator P, const value_type&amp; X)
 &nbsp; void insert(It F, It L)
 &nbsp; iterator erase(iterator P)
 &nbsp; iterator erase(iterator F, iterator L)
 &nbsp; size_type erase(const K&amp; Kv = K())
 &nbsp; void clear()
 &nbsp; void swap(Myt&amp; X)
 &nbsp; friend void swap(Myt&amp; X, Myt&amp; Y)
 &nbsp; key_compare key_comp() const
 &nbsp; value_compare value_comp() const
 &nbsp; iterator find(const K&amp; Kv)
 &nbsp; const_iterator find(const K&amp; Kv) const
 &nbsp; size_type count(const K&amp; Kv) const
 &nbsp; iterator lower_bound(const K&amp; Kv)
 &nbsp; const_iterator lower_bound(const K&amp; Kv) const
 &nbsp; iterator upper_bound(const K&amp; Kv)
 &nbsp; const_iterator upper_bound(const K&amp; Kv) const
 &nbsp; Pairii equal_range(const K&amp; Kv)
 &nbsp; Paircc equal_range(const K&amp; Kv) const
protected:
 &nbsp; Imp Tr;
 &nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; // multimap TEMPLATE OPERATORS
template&lt;class K, class TYPE, class Pr, class A&gt; inline bool operator==(const multimap&lt;K, TYPE, Pr, A&gt;&amp; X,
 &nbsp;&nbsp;&nbsp;&nbsp; const multimap&lt;K, TYPE, Pr, A&gt;&amp; Y)
template&lt;class K, class TYPE, class Pr, class A&gt; inline
 &nbsp; bool operator&lt;(const multimap&lt;K, TYPE, Pr, A&gt;&amp; X,
 &nbsp;&nbsp;&nbsp;&nbsp; const multimap&lt;K, TYPE, Pr, A&gt;&amp; Y)
</code></pre>
<h3>16.4 set and multiset</h3>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In the definitions below, the template parameter <i>K</i> represents the type of data the set will store (for example, int). The template parameter <i>Pr</i> represents the user-defined comparator object (for example, <b>less&lt;K&gt;</b>). The template parameter <i>A</i> represents the allocator object the set will use for memory allocation.</p>
<p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></p>
<pre><code>// TEMPLATE CLASS set
template&lt;class K, class Pr,
 &nbsp; class A&gt;
 &nbsp; class set {
public:
 &nbsp; typedef set&lt;K, Pr, A&gt; Myt;
 &nbsp; typedef K TYPE;
 &nbsp; typedef TYPE value_type;
 &nbsp; struct Kfn : public unary_function&lt;value_type, K&gt; {
 &nbsp;&nbsp;&nbsp;&nbsp; const K&amp; operator()(const value_type&amp; X) const
 &nbsp; typedef Pr value_compare;
 &nbsp; typedef K key_type;
 &nbsp; typedef Pr key_compare;
 &nbsp; typedef A allocator_type;
 &nbsp; typedef Tree&lt;K, value_type, Kfn, Pr, A&gt; Imp;
 &nbsp; typedef Imp::size_type size_type;
 &nbsp; typedef Imp::difference_type difference_type;
 &nbsp; typedef Imp::const_reference reference;
 &nbsp; typedef Imp::const_reference const_reference;
 &nbsp; typedef Imp::const_iterator iterator;
 &nbsp; typedef Imp::const_iterator const_iterator;
 &nbsp; typedef Imp::const_reverse_iterator reverse_iterator;
 &nbsp; typedef Imp::const_reverse_iterator const_reverse_iterator;
 &nbsp; typedef pair&lt;iterator, bool&gt; Pairib;
 &nbsp; typedef pair&lt;const_iterator, const_iterator&gt; Paircc;
 &nbsp; explicit set(const Pr&amp; Pred = Pr(), const A&amp; Al = A())
 &nbsp; typedef const value_type *_It;
 &nbsp; set(_It F, It L, const Pr&amp; Pred = Pr(), const A&amp; Al = A())
 &nbsp; const_iterator begin() const
 &nbsp; const_iterator end() const
 &nbsp; const_reverse_iterator rbegin() const
 &nbsp; const_reverse_iterator rend() const
 &nbsp; size_type size() const
 &nbsp; size_type max_size() const
 &nbsp; bool empty() const
 &nbsp; A getAllocator() const
 &nbsp; _Pairib insert(const value_type&amp; X)
 &nbsp; iterator insert(iterator P, const value_type&amp; X)
 &nbsp; void insert(_It F, It L)
 &nbsp; iterator erase(iterator P)
 &nbsp; iterator erase(iterator F, iterator L)
 &nbsp; size_type erase(const K&amp; Kv)
 &nbsp; void clear()
 &nbsp; void swap(_Myt&amp; X)
 &nbsp; friend void swap(_Myt&amp; X, Myt&amp; Y)
 &nbsp; key_compare key_comp() const
 &nbsp; value_compare value_comp() const
 &nbsp; const_iterator find(const K&amp; Kv) const
 &nbsp; size_type count(const K&amp; Kv) const
 &nbsp; const_iterator lower_bound(const K&amp; Kv) const
 &nbsp; const_iterator upper_bound(const K&amp; Kv) const
 &nbsp; Paircc equal_range(const K&amp; Kv) const
protected:
 &nbsp; Imp Tr;
 &nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; // set TEMPLATE OPERATORS
template&lt;class K, class Pr, class A&gt; inline
 &nbsp;&nbsp;&nbsp; bool operator==(const set&lt;K, Pr, A&gt;&amp; X, const set&lt;K, Pr, A&gt;&amp; Y)
template&lt;class K, class Pr, class A&gt; inline
 &nbsp; bool operator&lt;(const set&lt;K, Pr, A&gt;&amp; X, const set&lt;K, Pr, A&gt;&amp; Y)
 &nbsp;&nbsp;&nbsp;&nbsp; // TEMPLATE CLASS multiset
template&lt;class K, class Pr,
 &nbsp; class A&gt;
 &nbsp; class multiset {
public:
 &nbsp; typedef multiset&lt;K, Pr, A&gt; Myt;
 &nbsp; typedef K TYPE;
 &nbsp; typedef TYPE value_type;
 &nbsp; struct Kfn : public unary_function&lt;value_type, K&gt; {
 &nbsp;&nbsp;&nbsp;&nbsp; const K&amp; operator()(const value_type&amp; X) const
 &nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp; typedef Pr value_compare;
 &nbsp; typedef K key_type;
 &nbsp; typedef Pr key_compare;
 &nbsp; typedef A allocator_type;
 &nbsp; typedef Tree&lt;K, value_type, Kfn, Pr, A&gt; Imp;
 &nbsp; typedef Imp::size_type size_type;
 &nbsp; typedef Imp::difference_type difference_type;
 &nbsp; typedef Imp::const_reference reference;
 &nbsp; typedef Imp::const_reference const_reference;
 &nbsp; typedef Imp::const_iterator iterator;
 &nbsp; typedef Imp::const_iterator const_iterator;
 &nbsp; typedef Imp::const_reverse_iterator reverse_iterator;
 &nbsp; typedef Imp::const_reverse_iterator const_reverse_iterator;
 &nbsp; typedef pair&lt;const_iterator, const_iterator&gt; Paircc;
 &nbsp; explicit multiset(const Pr&amp; Pred = Pr(), const A&amp; Al = A())
 &nbsp; typedef const value_type *_It;
 &nbsp; multiset(_It F, It L, const Pr&amp; Pred = Pr(),
 &nbsp; const_iterator begin() const
 &nbsp; const_iterator end() const
 &nbsp; const_reverse_iterator rbegin() const
 &nbsp; const_reverse_iterator rend() const
 &nbsp; size_type size() const
 &nbsp; size_type max_size() const
 &nbsp; bool empty() const
 &nbsp; A getAllocator() const
 &nbsp; iterator insert(const value_type&amp; X)
 &nbsp; iterator insert(iterator P, const value_type&amp; X)
 &nbsp; void insert(_It F, It L)
 &nbsp; iterator erase(iterator P)
 &nbsp; iterator erase(iterator F, iterator L)
 &nbsp; size_type erase(const K&amp; Kv)
 &nbsp; void clear()
 &nbsp; void swap(_Myt&amp; X)
 &nbsp; friend void swap(_Myt&amp; X, Myt&amp; Y)
 &nbsp; key_compare key_comp() const
 &nbsp; value_compare value_comp() const
 &nbsp; const_iterator find(const K&amp; Kv) const
 &nbsp; size_type count(const K&amp; Kv) const
 &nbsp; const_iterator lower_bound(const K&amp; Kv) const
 &nbsp; const_iterator upper_bound(const K&amp; Kv) const
 &nbsp; _Paircc equal_range(const K&amp; Kv) const
protected:
 &nbsp; _Imp Tr;
 &nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp; // multiset TEMPLATE OPERATORS
template&lt;class K, class Pr, class A&gt; inline
 &nbsp;&nbsp;&nbsp; bool operator==(const multiset&lt;K, Pr, A&gt;&amp; X, const multiset&lt;K, Pr, A&gt;&amp; Y)
template&lt;class K, class Pr, class A&gt; inline
 &nbsp;&nbsp;&nbsp; bool operator&lt;(const multiset&lt;K, Pr, A&gt;&amp; X, const multiset&lt;K, Pr, A&gt;&amp; Y)
</code></pre>
<h3>16.5 vector</h3>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In the definition below, the template parameter <i>Type</i> represents the type of data the vector will store (for example, int). The template parameter <i>A</i> represents the allocator object the vector will use for memory allocation.</p>
<p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></p>
<pre><code>// TEMPLATE CLASS vector
template&lt;class TYPE, class A&gt;
 &nbsp;&nbsp;&nbsp; class vector {
public:
 &nbsp;&nbsp;&nbsp; typedef vector&lt;TYPE, A&gt; Myt;
 &nbsp;&nbsp;&nbsp; typedef A allocatorTYPE;
 &nbsp;&nbsp;&nbsp; typedef A::sizeTYPE sizeTYPE;
 &nbsp;&nbsp;&nbsp; typedef A::differenceTYPE differenceTYPE;
 &nbsp;&nbsp;&nbsp; typedef A::pointer Tptr;
 &nbsp;&nbsp;&nbsp; typedef A::const_pointer Ctptr;
 &nbsp;&nbsp;&nbsp; typedef A::reference reference;
 &nbsp;&nbsp;&nbsp; typedef A::const_reference const_reference;
 &nbsp;&nbsp;&nbsp; typedef A::valueTYPE valueTYPE;
 &nbsp;&nbsp;&nbsp; typedef Tptr iterator;
 &nbsp;&nbsp;&nbsp; typedef Ctptr const_iterator;
 &nbsp;&nbsp;&nbsp; typedef reverse_iterator&lt;const_iterator, valueTYPE, const_reference,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ctptr, differenceTYPE&gt; const_reverse_iterator;
 &nbsp;&nbsp;&nbsp; typedef reverse_iterator&lt;iterator, valueTYPE, reference, Tptr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; differenceTYPE&gt; reverse_iterator;
 &nbsp;&nbsp;&nbsp; explicit vector(const A&amp; Al = A());
 &nbsp;&nbsp;&nbsp; explicit vector(sizeTYPE N, const TYPE&amp; V = TYPE(), const A&amp; Al = A());
 &nbsp;&nbsp;&nbsp; vector(const Myt&amp; X);
 &nbsp;&nbsp;&nbsp; typedef const_iterator _It;
 &nbsp;&nbsp;&nbsp; vector(It F, It L, const A&amp; Al = A());
 &nbsp;&nbsp;&nbsp; ~vector();
 &nbsp;&nbsp;&nbsp; Myt&amp; operator=(const Myt&amp; X);
 &nbsp;&nbsp;&nbsp; void reserve(sizeTYPE N);
 &nbsp;&nbsp;&nbsp; sizeTYPE capacity() const;
 &nbsp;&nbsp;&nbsp; iterator begin();
 &nbsp;&nbsp;&nbsp; const_iterator begin() const;
 &nbsp;&nbsp;&nbsp; iterator end();
 &nbsp;&nbsp;&nbsp; const_iterator end() const;
 &nbsp;&nbsp;&nbsp; reverse_iterator rbegin();
 &nbsp;&nbsp;&nbsp; const_reverse_iterator rbegin() const;
 &nbsp;&nbsp;&nbsp; reverse_iterator rend();
 &nbsp;&nbsp;&nbsp; const_reverse_iterator rend() const;
 &nbsp;&nbsp;&nbsp; void resize(sizeTYPE N, TYPE X = TYPE());
 &nbsp;&nbsp;&nbsp; sizeTYPE size() const;
 &nbsp;&nbsp;&nbsp; sizeTYPE max_size() const;
 &nbsp;&nbsp;&nbsp; bool empty() const;
 &nbsp;&nbsp;&nbsp; A getAllocator() const;
 &nbsp;&nbsp;&nbsp; const_reference at(sizeTYPE P) const;
 &nbsp;&nbsp;&nbsp; reference at(sizeTYPE P);
 &nbsp;&nbsp;&nbsp; const_reference operator[](sizeTYPE P) const;
 &nbsp;&nbsp;&nbsp; reference operator[](sizeTYPE P);
 &nbsp;&nbsp;&nbsp; reference front();
 &nbsp;&nbsp;&nbsp; const_reference front() const;
 &nbsp;&nbsp;&nbsp; reference back();
 &nbsp;&nbsp;&nbsp; const_reference back() const;
 &nbsp;&nbsp;&nbsp; void push_back(const TYPE&amp; X);
 &nbsp;&nbsp;&nbsp; void pop_back();
 &nbsp;&nbsp;&nbsp; void assign(It F, It L);
 &nbsp;&nbsp;&nbsp; void assign(sizeTYPE N, const TYPE&amp; X = TYPE());
 &nbsp;&nbsp;&nbsp; iterator insert(iterator P, const TYPE&amp; X = TYPE());
 &nbsp;&nbsp;&nbsp; void insert(iterator P, sizeTYPE M, const TYPE&amp; X);
 &nbsp;&nbsp;&nbsp; void insert(iterator P, It F, It L);
 &nbsp;&nbsp;&nbsp; iterator erase(iterator P);
 &nbsp;&nbsp;&nbsp; iterator erase(iterator F, iterator L);
 &nbsp;&nbsp;&nbsp; void clear();
 &nbsp;&nbsp;&nbsp; void swap(Myt&amp; X);
 &nbsp;&nbsp;&nbsp; friend void swap(Myt&amp; X, Myt&amp; Y);
protected:
 &nbsp;&nbsp;&nbsp; void _Destroy(iterator F, iterator L);
 &nbsp;&nbsp;&nbsp; void _Xran() const;
 &nbsp;&nbsp;&nbsp; A allocator;
 &nbsp;&nbsp;&nbsp; iterator First, Last, End;
 &nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // vector TEMPLATE OPERATORS
template&lt;class TYPE, class A&gt; inline bool operator==(const vector&lt;TYPE, A&gt;&amp; X,
 &nbsp;&nbsp;&nbsp; const vector&lt;TYPE, A&gt;&amp; Y);
template&lt;class TYPE, class A&gt; inline bool operator&lt;(const vector&lt;TYPE, A&gt;&amp; X,
 &nbsp;&nbsp;&nbsp; const vector&lt;TYPE, A&gt;&amp; Y);
</code></pre>
<h3>16.6 stack </h3>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In the definition below, the template parameter <i>Type</i> represents the type of data the stack will store (for example, int). The template parameter <i>C</i> represents the container the stack is adapting (for example, deque). The template parameter <i>A</i> represents the allocator object the stack will use for memory allocation.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &nbsp; // TEMPLATE CLASS stack
template&lt;class TYPE, class C, class A&gt;
 &nbsp; class stack {
public:
 &nbsp; typedef A allocator_type;
 &nbsp; typedef C::value_type value_type;
 &nbsp; typedef C::size_type size_type;
 &nbsp; explicit stack(const A&amp; Al = A());
 &nbsp; A get_allocator() const:
bool empty() const;
 &nbsp; size_type size() const;
 &nbsp; value_type&amp; top();
 &nbsp; const value_type&amp; top() const;
 &nbsp; void push(const value_type&amp; X);
 &nbsp; void pop();
 &nbsp; bool operator==(const stack&lt;TYPE, C, A&gt;&amp; X) const;
 &nbsp; bool operator&lt;(const stack&lt;TYPE, C, A&gt;&amp; X) const;
protected:
 &nbsp; C c;
};
</code></pre>
<h3>16.7 priority_queue </h3>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In the definition below, the template parameter <i>Type</i> represents the type of data the <b>priority_queue</b> will store (for example, int). The template parameter <i>C</i> represents the container the priority_queue is adapting (for example, deque). The template parameter <i>Pr</i> represents the user-defined comparator object to order the sequence (for example, <b>less&lt;TYPE&gt;</b>). The template parameter <i>A</i> represents the allocator object the <b>priority_queue</b> will use for memory allocation (for example, <b>allocator&lt;TYPE&gt;</b>).</p>
<p>
&nbsp;&nbsp;&nbsp;<code> &nbsp; </code></p>
<pre><code>// TEMPLATE CLASS priority_queue
template&lt;class TYPE, class C,
 &nbsp; class Pr,
 &nbsp; class A&gt;
 &nbsp; class priority_queue {
public:
 &nbsp; typedef A allocatorTYPE;
 &nbsp; typedef C::valueTYPE valueTYPE;
 &nbsp; typedef C::sizeTYPE sizeTYPE;
 &nbsp; explicit priority_queue(const Pr&amp; X = Pr(), const A&amp; Al = A());
 &nbsp; typedef const valueTYPE *It;
 &nbsp; priority_queue(It F, It L, const Pr&amp; X = Pr(), const A&amp; Al = A()):
 &nbsp; A getAllocator() const;
 &nbsp; bool empty() const;
 &nbsp; sizeTYPE size() const;
 &nbsp; valueTYPE&amp; top();
 &nbsp; const valueTYPE&amp; top() const;
 &nbsp; void push(const valueTYPE&amp; X);
 &nbsp; void pop();
protected:
 &nbsp; C c;
 &nbsp; Pr comp;
};
</code></pre>
<h3>16.8 queue </h3>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The template parameter <i>Type</i> in the definition below represents the type of data the queue will store (for example, int). The template parameter <i>C</i> represents the container the queue is adapting (for example, deque). The template parameter <i>A</i> represents the allocator object the queue will use for memory allocation.</p>
<pre><code>// TEMPLATE CLASS queue
template&lt;class TYPE, class C, class A&gt;
 &nbsp; class queue {
public:
 &nbsp; typedef A allocatorTYPE;
 &nbsp; typedef C::valueTYPE valueTYPE;
 &nbsp; typedef C::sizeTYPE sizeTYPE;
 &nbsp; explicit queue(const A&amp; Al = A());
 &nbsp; A getAllocator() const;
 &nbsp; bool empty() const;
 &nbsp; sizeTYPE size() const;
 &nbsp; valueTYPE&amp; front();
 &nbsp; const valueTYPE&amp; front() const;
 &nbsp; valueTYPE&amp; back();
 &nbsp; const valueTYPE&amp; back() const;
 &nbsp; void push(const valueTYPE&amp; X);
 &nbsp; void pop();
 &nbsp; bool operator==(const queue&lt;TYPE, C, A&gt;&amp; X) const;
 &nbsp; bool operator&lt;(const queue&lt;TYPE, C, A&gt;&amp; X) const;
protected:
 &nbsp; C c;
};
</code></pre>
<h2><a name="stlappendixc"></a>17. Appendix C: STL Container Class Methods</h2>
<p>
All the STL container class methods listed apply to STL containers provided with Microsoft Visual C++ 4.2.</p>
<h3>17.1 deque</h3>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Member</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=50%><b>typedef A allocator_type</b></td>
<td width=50%><b>deque::allocator_type</b> describes the stored allocator object (same as the second template argument).</td>
</tr>
<tr valign=top>
<td width=50%><b>void assign(const_iterator first,const_iterator<br>
</b> . . .<b> last)void assign(size_type n, const T&amp; x = T())</b></td>
<td width=50%>The first version of <b>deque::assign</b> replaces the sequence controlled by <i>*this</i> with the sequence [first, last). The second version replaces the sequence controlled by <i>*this</i> with a repetition of <i>n</i> elements of value<i> x</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_reference at(size_type pos) constreference&nbsp; </b>. . .<b> at(size_type pos)</b></td>
<td width=50%><b>deque::at</b> returns a reference to the element of the deque at position pos. If that position is invalid, the function throws an object of class <b>out_of_range</b> (throws an exception).</td>
</tr>
<tr valign=top>
<td width=50%><b>reference back()<br>
const_reference back() const</b></td>
<td width=50%><b>deque::back</b> returns a reference to the last element of the deque, which must be nonempty.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_iterator begin() const<br>
iterator begin()</b></td>
<td width=50%><b>deque::begin</b> returns a random-access iterator that points at the first element of the sequence (or just beyond the end of an empty sequence).</td>
</tr>
<tr valign=top>
<td width=50%><b>void clear() const</b></td>
<td width=50%><b>deque::clear</b> calls <b>erase( begin(), end())</b>.</td>
</tr>
<tr valign=top>
<td width=50%><b>typedef A::const_iterator const_iterator</b></td>
<td width=50%><b>deque::const_iterator</b> describes an object that can serve as a constant random-access iterator for the deque. It is described here as a synonym for the <b>const_iterator</b> member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=50%><b>Typedef A::const_reference const_reference</b></td>
<td width=50%><b>deque::const_reference</b> describes an object that can serve as a constant reference to an element of the deque.</td>
</tr>
<tr valign=top>
<td width=50%><b>typedef reverse_iterator&lt;const_iterator,<br>
 &nbsp;&nbsp;&nbsp; value_type,const_reference, A::const_pointer,<br>
 &nbsp;&nbsp;&nbsp; difference_type&gt; const_reverse_iterator</b></td>
<td width=50%><b>deque::const_reverse_iterator</b> describes an object that can serve as a constant reverse iterator for the deque.</td>
</tr>
<tr valign=top>
<td width=50%><b>explicit deque(const A&amp; al = A())<br>
explicit deque(size_type n, const T&amp; v = T(),<br>
 &nbsp;&nbsp;&nbsp; const A&amp; al = A())<br>
deque(const deque&amp; x)<br>
deque(const_iterator first, const_iterator last,<br>
 &nbsp;&nbsp;&nbsp; const A&amp; al = A())</b></td>
<td width=50%>All constructors store the allocator object <b>al</b> (or, for the copy constructor, <b>x.get_allocator()</b>) in allocator and initialize the controlled sequence. The first constructor specifies an empty initial controlled sequence. The second constructor specifies a repetition of <i>n</i> elements of value <i>x</i>. The third constructor specifies a copy of the sequence controlled by <i>x</i>. The last constructor specifies the sequence[first, last).</td>
</tr>
<tr valign=top>
<td width=50%><b>typedef A::difference_type difference_type</b></td>
<td width=50%><b>deque::difference_type</b> is a signed integer type that describes an object that can represent the difference between the addresses of any two elements in the deque.</td>
</tr>
<tr valign=top>
<td width=50%><b>bool empty() const</b></td>
<td width=50%><b>deque::empty</b> returns true if the deque is empty.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_iterator end() const<br>
iterator end()</b></td>
<td width=50%><b>deque::end</b> returns a random-access iterator that points just beyond the end of the sequence.</td>
</tr>
<tr valign=top>
<td width=50%><b>iterator erase(iterator it)<br>
iterator erase(iterator first, iterator last)</b></td>
<td width=50%>The first version of <b>deque::erase</b> removes the element of the controlled sequence pointed to by it. The second version removes the elements of the controlled sequence in the range [first, last). Both return an iterator that designates the first element remaining beyond any elements removed, or <b>end()</b> if no such element exists.<br>
Erasing <i>N</i> elements causes <i>N</i> destructor calls and an assignment (<b>operator=</b>) for each of the elements between the insertion point and the nearer end of the sequence. Removing an element at either end invalidates only iterators and references that designate the erased elements. Otherwise, erasing an element invalidates all iterators and references.</td>
</tr>
<tr valign=top>
<td width=50%><b>reference front()<br>
const_reference front() const</b></td>
<td width=50%><b>deque::front</b> returns a reference to the first element of the controlled sequence, which must be nonempty.</td>
</tr>
<tr valign=top>
<td width=50%><b>A get_allocator() const</b></td>
<td width=50%>The member function returns allocator.</td>
</tr>
<tr valign=top>
<td width=50%><b>iterator insert(iterator it, const T&amp; x = T())<br>
void insert(iterator it, size_type n, const T&amp; x)<br>
void insert(iterator it, const_iterator first,<br>
 &nbsp;&nbsp;&nbsp; const_iterator last)</b></td>
<td width=50%>Each version of <b>deque::insert</b> inserts, after the element pointed to by it in the controlled sequence, a sequence specified by the remaining operands. The first version inserts a single element with value <b>x&gt;</b> and returns an iterator that points to the newly inserted element. The second version inserts a repetition of <i>n</i> elements of value <i>x</i>. The third version inserts the sequence [first, last).<br>
When inserting a single element, the number of element copies is linear in the number of elements between the insertion point and the nearer end of the sequence. When inserting a single element at either end of the sequence, the amortized number of element copies is constant. When inserting <i>N</i> elements, the number of element copies is linear in <i>N</i> plus the number of elements between the insertion point and the nearer end of the sequence. Inserting an element at either end invalidates all iterators, but no references, that designate existing elements. Otherwise, inserting an element invalidates all iterators and references.</td>
</tr>
<tr valign=top>
<td width=50%><b>typedef A::pointer iterator</b></td>
<td width=50%><i>Iterator</i> describes an object that can serve as a random-access iterator for the controlled sequence. It is described here as a synonym for the pointer member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type max_size() const</b></td>
<td width=50%><b>deque::max_size</b> returns the length of the longest sequence that the object can control.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_reference operator[](size_type pos) const<br>
reference operator[](size_type pos)</b></td>
<td width=50%><b>operator[]</b> returns a reference to the element of the controlled sequence at position pos. If that position is invalid, the behavior is undefined.</td>
</tr>
<tr valign=top>
<td width=50%><b>void pop_back()</b></td>
<td width=50%><b>deque::pop_back</b> removes the last element of the controlled sequence, which must be nonempty. Removing the element invalidates only iterators and references that designate the erased element.</td>
</tr>
<tr valign=top>
<td width=50%><b>void pop_front()</b></td>
<td width=50%><b>deque::pop_front</b> removes the first element of the controlled sequence, which must be nonempty. Removing the element invalidates only iterators and references that designate the erased element.</td>
</tr>
<tr valign=top>
<td width=50%><b>void push_back(const T&amp; x)</b></td>
<td width=50%><b>deque::push_back</b> inserts an element with value <i>x</i> at the end of the controlled sequence. Inserting the element invalidates all iterators, but no references, to existing elements.</td>
</tr>
<tr valign=top>
<td width=50%><b>void push_front(const T&amp; x)</b></td>
<td width=50%><b>deque::push_front</b> inserts an element with value <i>x</i> at the beginning of the controlled sequence. Inserting the element invalidates all iterators, but no references, to existing elements.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_reverse_iterator rbegin() const<br>
reverse_iterator rbegin()</b></td>
<td width=50%><b>deque::rbegin</b> returns a reverse iterator that points just beyond the end of the controlled sequence. Hence, it designates the beginning of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=50%><b>typedef A::reference reference</b></td>
<td width=50%><b>deque::reference</b> describes an object that can be used as a reference to an element of the controlled sequence. It is described here as a synonym for the reference member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=50%><b>const_reverse_iterator rend() const<br>
reverse_iterator rend()</b></td>
<td width=50%><b>deque::rend</b> returns a reverse iterator that points at the first element of the sequence (or just beyond the end of an empty sequence). Hence, it designates the end of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=50%><b>void resize(size_type n, T x = T())</b></td>
<td width=50%><b>deque::resize</b> ensures that size() henceforth returns n. If it must make the controlled sequence longer, it appends elements with value <i>x</i>.</td>
</tr>
<tr valign=top>
<td width=50%><b>typedef reverse_iterator&lt;iterator, value_type,<br>
 &nbsp;&nbsp;&nbsp; reference, A::types&lt;T&gt;::pointer,<br>
 &nbsp;&nbsp;&nbsp; difference_type&gt; reverse_iterator</b></td>
<td width=50%>The type describes an object that can serve as a reverse iterator for the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=50%><b>size_type size() const</b></td>
<td width=50%><b>deque::size</b> returns the length of the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=50%><b>typedef A::size_type size_type</b></td>
<td width=50%><b>size_type</b> is an unsigned integer type that describes an object that can represent the length of any controlled sequence.</td>
</tr>
<tr valign=top>
<td width=50%><b>void swap(deque&amp; str)</b></td>
<td width=50%><b>deque::swap</b> swaps the controlled sequences between <i>*this</i> and <i>str</i>. If <b>allocator == str.allocator</b>, it does so in constant time. Otherwise, it performs a number of element assignments and constructor calls proportional to the number of elements in the two controlled sequences.</td>
</tr>
<tr valign=top>
<td width=50%><b>typedef A::types&lt;T&gt;::value_type value_type</b></td>
<td width=50%>The type describes an element of the controlled sequence (same as the template parameter T).</td>
</tr>
</table><br>
<h3>17.2 list</h3>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=54%><b>Member</b></td>
<td class=label width=46%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=54%><b>typedef A allocator_type</b></td>
<td width=46%><b>list::allocator_type</b> describes the stored allocator object (same as the second template argument).</td>
</tr>
<tr valign=top>
<td width=54%><b>void assign(const_iterator first,const_iterator last)<br>
void assign(size_type n, const T&amp; x = T())</b></td>
<td width=46%>The first version of <b>list::assign</b> replaces the sequence controlled by <i>*this</i> with the sequence [first, last). The second version replaces the sequence controlled by <i>*this</i> with a repetition of <i>n</i> elements of value <i>x</i>.</td>
</tr>
<tr valign=top>
<td width=54%><b>reference back()<br>
const_reference back() const</b></td>
<td width=46%><b>list::back</b> returns a reference to the last element of the list, which must be nonempty.</td>
</tr>
<tr valign=top>
<td width=54%><b>const_iterator begin() const<br>
iterator begin()</b></td>
<td width=46%><b>list::begin</b> returns a random-access iterator that points at the first element of the sequence (or just beyond the end of an empty sequence).</td>
</tr>
<tr valign=top>
<td width=54%><b>void clear() const</b></td>
<td width=46%><b>list::clear</b> calls <b>erase( begin(), end())</b>.</td>
</tr>
<tr valign=top>
<td width=54%><b>typedef A::const_iterator const_iterator</b></td>
<td width=46%><b>list::const_iterator</b> describes an object that can serve as a constant random-access iterator for the list. It is described here as a synonym for the <b>const_iterator</b> member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=54%><b>typedef A::const_reference const_reference</b></td>
<td width=46%><b>list::const_reference</b> describes an object that can serve as a constant reference to an element of the list.</td>
</tr>
<tr valign=top>
<td width=54%><b>typedef reverse_iterator&lt;const_iterator,<br>
 &nbsp;&nbsp;&nbsp; value_type,const_reference, A::const_pointer,<br>
 &nbsp;&nbsp;&nbsp; difference_type&gt; const_reverse_iterator</b></td>
<td width=46%><b>list::const_reverse_iterator</b> describes an object that can serve as a constant reverse iterator for the list.</td>
</tr>
<tr valign=top>
<td width=54%><b>typedef A::difference_type difference_type</b></td>
<td width=46%><b>list::difference_type</b> is a signed integer type that describes an object that can represent the difference between the addresses of any two elements in the list.</td>
</tr>
<tr valign=top>
<td width=54%><b>bool empty() const</b></td>
<td width=46%><b>list::empty</b> returns true if the list is empty</td>
</tr>
<tr valign=top>
<td width=54%><b>const_iterator end() const<br>
iterator end()</b></td>
<td width=46%><b>list::end</b> returns a random-access iterator that points just beyond the end of the sequence.</td>
</tr>
<tr valign=top>
<td width=54%><b>iterator erase(iterator it)<br>
iterator erase(iterator first, iterator last)</b></td>
<td width=46%>The first version of <b>list::erase</b> removes the element of the controlled sequence pointed to by it. The second version removes the elements of the controlled sequence in the range [first, last). Both return an iterator that designates the first element remaining beyond any elements removed, or <b>end()</b> if no such element exists.<br>
Erasing <i>N</i> elements causes <i>N </i>destructor calls. No reallocation occurs, so iterators and references become invalid only for the erased elements.</td>
</tr>
<tr valign=top>
<td width=54%><b>reference front()<br>
const_reference front() const</b></td>
<td width=46%><b>list::front</b> returns a reference to the first element of the controlled sequence, which must be nonempty.</td>
</tr>
<tr valign=top>
<td width=54%><b>A get_allocator() const</b></td>
<td width=46%>The member function returns allocator.</td>
</tr>
<tr valign=top>
<td width=54%><b>iterator insert(iterator it, const T&amp; x = T())<br>
void insert(iterator it, size_type n,const T&amp; x)<br>
void insert(iterator it, const_iterator first,<br>
 &nbsp;&nbsp;&nbsp; const_iterator last)</b></td>
<td width=46%>Each version of <b>list::insert</b> inserts, after the element pointed to by it in the controlled sequence, a sequence specified by the remaining operands. The first version inserts a single element with value <i>x</i>&gt; and returns an iterator that points to the newly inserted element. The second version inserts a repetition of <i>n</i> elements of value <i>x</i>. The third version inserts the sequence [first, last).<br>
Inserting <i>N</i> elements causes <i>N </i>copies. No reallocation occurs, so no iterators or references become invalid.</td>
</tr>
<tr valign=top>
<td width=54%><b>typedef A::pointer iterator</b></td>
<td width=46%>Iterator describes an object that can serve as a random-access iterator for the controlled sequence. It is described here as a synonym for the pointer member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=54%><b>explicit list(const A&amp; al = A())<br>
explicit list(size_type n, const T&amp; v = T(),<br>
 &nbsp;&nbsp;&nbsp; const A&amp; al = A())<br>
list(const list&amp; x)<br>
list(const_iterator first, const_iterator last,<br>
 &nbsp;&nbsp;&nbsp; const A&amp; al = A())</b></td>
<td width=46%>All constructors store the allocator object <b>al</b> (or, for the copy constructor, <b>x.get_allocator()</b>) in allocator and initialize the controlled sequence. The first constructor specifies an empty initial controlled sequence. The second constructor specifies a repetition of <i>n</i> elements of value <i>x</i>. The third constructor specifies a copy of the sequence controlled by <i>x</i>. The last constructor specifies the sequence [first, last). None of the constructors perform any interim reallocations.</td>
</tr>
<tr valign=top>
<td width=54%><b>size_type max_size() const</b></td>
<td width=46%><b>list::max_size</b> returns the length of the longest sequence that the object can control.</td>
</tr>
<tr valign=top>
<td width=54%><b>void merge(list&amp; x)<br>
void merge(list&amp; x, greater&lt;TYPE&gt; pr)</b></td>
<td width=46%>Both versions of <b>list::merge</b> remove all elements from the sequence controlled by <i>x</i> and insert them in the controlled sequence. Both sequences must be ordered by the same predicate, described below. The resulting sequence is also ordered by that predicate. For the iterators <i>Pi</i> and <i>Pj</i><b> </b>designating elements at positions<i> i</i> and<i> j</i>, the first member function imposes the order <b>!(*Pj &lt; *Pi) whenever i &lt; j</b>. The second version imposes the order <b>!pr(*Pj, *Pi)</b> whenever <i>i </i>&lt; <i>j</i>. No pairs of elements in the original controlled sequence are reversed in the resulting controlled sequence. If a pair of elements in the resulting controlled sequence compares equal <b>(!(*Pi &lt; *Pj) &amp;&amp; !(*Pj &lt; *Pi))</b>, an element from the original controlled sequence appears before an element from the sequence controlled by <i>x</i>.</td>
</tr>
<tr valign=top>
<td width=54%><b>void pop_back()</b></td>
<td width=46%><b>list::pop_back</b> removes the last element of the controlled sequence, which must be nonempty.</td>
</tr>
<tr valign=top>
<td width=54%><b>void pop_front()</b></td>
<td width=46%><b>list::pop_front</b> removes the first element of the controlled sequence, which must be nonempty.</td>
</tr>
<tr valign=top>
<td width=54%><b>void push_back(const T&amp; x)</b></td>
<td width=46%><b>list::push_back</b> inserts an element with value <i>x</i> at the end of the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=54%><b>void push_front(const T&amp; x)</b></td>
<td width=46%><b>list::push_front</b> inserts an element with value <i>x</i> at the beginning of the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=54%><b>const_reverse_iterator rbegin() const<br>
reverse_iterator rbegin()</b></td>
<td width=46%><b>list::rbegin</b> returns a reverse iterator that points just beyond the end of the controlled sequence. Hence, it designates the beginning of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=54%><b>typedef A::reference reference</b></td>
<td width=46%><b>list::reference</b> describes an object that can be used as a reference to an element of the controlled sequence. It is described here as a synonym for the reference member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=54%><b>void remove(const T&amp; x)</b></td>
<td width=46%><b>list::remove</b> removes from the controlled sequence all elements, designated by the iterator <i>P</i>, for which <b>*P == x</b>.</td>
</tr>
<tr valign=top>
<td width=54%><b>void remove_if(<br>
 &nbsp;&nbsp;&nbsp; binder2nd&lt;not_equal_to&lt;TYPE&gt; &gt; pr)</b></td>
<td width=46%><b>list::remove_if</b> removes from the controlled sequence all elements, designated by the iterator <i>P</i>, for which <b>pr(*P)</b> is true.</td>
</tr>
<tr valign=top>
<td width=54%><b>const_reverse_iterator rend() const<br>
reverse_iterator rend()</b></td>
<td width=46%><b>list::rend</b> returns a reverse iterator that points at the first element of the sequence (or just beyond the end of an empty sequence). Hence, it designates the end of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=54%><b>void resize(size_type n, T x = T())</b></td>
<td width=46%><b>list::resize</b> ensures that <b>size()</b> henceforth returns <i>n</i>. If it must make the controlled sequence longer, it appends elements with value <i>x</i>.</td>
</tr>
<tr valign=top>
<td width=54%><b>void reverse()</b></td>
<td width=46%><b>list::reverse</b> reverses the order in which elements appear in the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=54%><b>typedef reverse_iterator&lt;iterator, value_type,<br>
 &nbsp;&nbsp;&nbsp; reference, A::types&lt;T&gt;::pointer,<br>
 &nbsp;&nbsp;&nbsp; difference_type&gt; reverse_iterator</b></td>
<td width=46%>The type describes an object that can serve as a reverse iterator for the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=54%><b>size_type size() const</b></td>
<td width=46%><b>list::size</b> returns the length of the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=54%><b>typedef A::size_type size_type</b></td>
<td width=46%><b>size_type </b>is an unsigned integer type that describes an object that can represent the length of any controlled sequence.</td>
</tr>
<tr valign=top>
<td width=54%><b>void sort() <br>
void sort(greater&lt;TYPE&gt; pr)</b></td>
<td width=46%>Both versions of <b>list::sort</b> order the elements in the controlled sequence by a predicate. For the iterators <i>Pi </i>and <i>Pj</i> designating elements at positions <i>i </i>and <i>j</i>, the first member function imposes the order <b>!(*Pj &lt; *Pi)</b> whenever <i>i</i> &lt; <i>j</i>. The second version imposes the order <b>!pr(*Pj, *Pi)</b> whenever <i>i</i> &lt; <i>j</i>. No pairs of elements in the original controlled sequence are reversed in the resulting controlled sequence. "void splice(iterator it, list&amp; x)"</td>
</tr>
<tr valign=top>
<td width=54%><b>void splice(iterator it, list&amp; x, iterator first)<br>
void splice(iterator it,iterator first,iterator last)</b></td>
<td width=46%>The first version of <b>list::splice</b> inserts the sequence controlled by <i>x</i> after the element in the controlled sequence pointed to by it. It also removes all elements from <i>x</i>. (<i>&amp;x</i> must not equal this). The second version removes the element pointed to by the first in the sequence controlled by <i>x</i> and inserts it after the element in the controlled sequence pointed to by it. (If <b>it == first || it == ++first</b>, no change occurs). The third version function inserts the subrange designated by [first, last) from the sequence controlled by <i>x</i> after the element in the controlled sequence pointed to by it. It also removes the original subrange from the sequence controlled by <i>x</i>. (If <b>&amp;x == this</b>, the range [first, last) must not include the element pointed to by it). If the third version inserts <i>N </i>elements, and <b>&amp;x != this</b>, an object of class iterator is incremented <i>N</i> times. In no case do any copies or destructor calls occur for any elements.</td>
</tr>
<tr valign=top>
<td width=54%><b>void swap(list&amp; str)</b></td>
<td width=46%><b>list::swap</b> swaps the controlled sequences between <i>*this</i> and <i>str</i>. If <b>allocator == str.allocator</b>, it does so in constant time. Otherwise, it performs a number of element assignments and constructor calls proportional to the number of elements in the two controlled sequences.</td>
</tr>
<tr valign=top>
<td width=54%><b>void unique()<br>
void unique(not_equal_to&lt;TYPE&gt;pr)</b></td>
<td width=46%>The first version of <b>list::unique</b> removes from the controlled sequence every element that compares equal to its preceding element. For the iterators <i>Pi</i> and <i>Pj<b> </b></i>designating elements at positions <i>i </i>and <i>j</i>, the second version removes every element for which <b>i + 1 == j &amp;&amp; pr(*Pi, *Pj)</b>. For a list of length <i>N</i> (&gt; 0), the predicate <b>pr(*Pi, *Pj)</b> is evaluated <i>N</i> - 1 times.</td>
</tr>
<tr valign=top>
<td width=54%><b>typedef A::types&lt;T&gt;::value_type value_type</b></td>
<td width=46%>The type describes an element of the controlled sequence (same as the template parameter <i>T</i>).</td>
</tr>
</table><br>
<h3>17.3 map and multimap</h3>
<p>
Each element listed here is a member of both map and multimap, with exceptions noted explicitly.</p>
<p>
References to <b>map::[symbol]</b> imply the existence of <b>multimap::[symbol]</b> with similar behavior.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Member:</b></td>
<td class=label width=51%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=49%><b>typedef A allocator_type</b></td>
<td width=51%><b>map::allocator_type</b> describes the stored allocator object (same as the fourth template argument).</td>
</tr>
<tr valign=top>
<td width=49%><b>const_iterator begin() const<br>
iterator begin()</b></td>
<td width=51%><b>map::begin</b> returns a bidirectional iterator that points at the first element of the sequence (or just beyond the end of an empty sequence).</td>
</tr>
<tr valign=top>
<td width=49%><b>void clear() const</b></td>
<td width=51%><b>map::clear</b> calls <b>erase( begin(), end())</b>.</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef A::const_iterator const_iterator</b></td>
<td width=51%><b>map::const_iterator</b> describes an object that can serve as a constant bidirectional iterator for the map. It is described here as a synonym for the <b>const_iterator</b> member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef A::const_reference<br>
 &nbsp;&nbsp;&nbsp; const_reference</b></td>
<td width=51%><b>map::const_reference</b> describes an object that can serve as a constant reference to an element of the map.</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef reverse_iterator&lt;const_iterator,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
 &nbsp;&nbsp;&nbsp; value_type, const_reference,<br>
 &nbsp;&nbsp;&nbsp; A::const_pointer, difference_type&gt;<br>
 &nbsp;&nbsp;&nbsp; const_reverse_iterator</b></td>
<td width=51%><b>map::const_reverse_iterator</b> describes an object that can serve as a constant reverse bidirectional iterator for the map.</td>
</tr>
<tr valign=top>
<td width=49%><b>size_type count(const Key&amp; key) const</b></td>
<td width=51%><b>map::count</b> returns the number of elements <i>x</i> in the range [lower_bound(key), upper_bound(key)).</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef A::difference_type difference_type</b></td>
<td width=51%><b>map::difference_type</b> is a signed integer type that describes an object that can represent the difference between the addresses of any two elements in the map. Note that such differences are not meaningful within the context of the map.</td>
</tr>
<tr valign=top>
<td width=49%><b>bool empty() const</b></td>
<td width=51%><b>map::empty</b> returns true if the map is empty.</td>
</tr>
<tr valign=top>
<td width=49%><b>const_iterator end() const<br>
iterator end()</b></td>
<td width=51%><b>map::end</b> returns a bidirectional iterator that points just beyond the end of the sequence.</td>
</tr>
<tr valign=top>
<td width=49%><b>pair&lt;const_iterator, const_iterator&gt; <br>
 &nbsp;&nbsp;&nbsp; equal_range(const Key&amp; key) const</b></td>
<td width=51%><b>map::equal_range</b> returns a pair of iterators <i>x</i> such that <b>x.first == lower_bound(key)</b> and <b>x.second == upper_bound(key)</b>.</td>
</tr>
<tr valign=top>
<td width=49%><b>iterator erase(iterator it)<br>
iterator erase(iterator first, iterator last)<br>
size_type erase(const Key&amp; key)</b></td>
<td width=51%>The first version of <b>map::erase</b> removes the element of the controlled sequence pointed to by it. The second version removes the elements in the range [first, last). Both return an iterator that designates the first element remaining beyond any elements removed, or <b>end()</b> if no such element exists. The third version removes the elements with sort keys in the range [lower_bound(key), upper_bound(key)), and returns the number of elements it removes.</td>
</tr>
<tr valign=top>
<td width=49%><b>const_iterator find(const Key&amp; key) const</b></td>
<td width=51%><b>map::find</b> returns an iterator that designates the earliest element in the controlled sequence whose sort key equals key. If no such element exists, the iterator equals <b>end()</b>.</td>
</tr>
<tr valign=top>
<td width=49%><b>A get_allocator() const</b></td>
<td width=51%>The member function returns allocator.</td>
</tr>
<tr valign=top>
<td width=49%><b>pair&lt;iterator, bool&gt;<br>
 &nbsp;&nbsp;&nbsp; insert(const value_type&amp; x)<br>
iterator insert(iterator obptr, <br>
 &nbsp;&nbsp;&nbsp; const value_type&amp; x)<br>
void insert(const value_type *first, <br>
 &nbsp;&nbsp;&nbsp; const value_type *last)</b></td>
<td width=51%>The first version of <b>map::insert</b> determines whether an element<i> y</i> exists in the sequence whose key matches that of <i>x</i>. (The keys match if <b>! key_comp()(x, y) &amp;&amp; !key_comp()(y, x)</b>.) If not, it creates such an element <i>y</i> and initializes it with <i>x</i>. The function then determines the iterator obptr that designates <i>y</i>. If an insertion occurred, the function returns <b>pair(obptr, true)</b>. Otherwise, it returns <b>pair(obptr, false)</b>. The second version returns <b>insert(x)</b>, using <b>obptr</b> as a starting place within the controlled sequence to search for the insertion point. (Insertion can occur in amortized constant time, instead of logarithmic time, if the insertion point immediately follows obptr.) The third version inserts the sequence of element values in the range [first, last).</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef A::pointer iterator</b></td>
<td width=51%><i>Iterator</i> describes an object that can serve as a bidirectional iterator for the controlled sequence. It is described here as a synonym for the pointer member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=49%><b>key_compare key_comp() const</b></td>
<td width=51%><b>map::key_comp</b> returns the stored function object that determines the order of elements in the controlled sequence. The stored object defines the member function <b>bool operator(const Key&amp; x, const Key&amp; y)</b> which returns true if <i>x</i> strictly precedes <i>y</i> in the sort order.</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef Pred key_compare</b></td>
<td width=51%><b>map::key_compare</b> describes a function object that can compare two sort keys to determine the relative order of any two elements in the controlled sequence. It is described here in terms of the user-defined comparator object (second template parameter).</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef Key key_type</b></td>
<td width=51%><b>map::key_type</b> describes the sort key object stored in each element of the map.</td>
</tr>
<tr valign=top>
<td width=49%><b>const_iterator lower_bound<br>
 &nbsp;&nbsp;&nbsp; (const Key&amp; key) const</b></td>
<td width=51%><b>map::lower_bound</b> returns an iterator that designates the earliest element <i>x</i> in the controlled sequence for which <b>key_comp()(x, key)</b> is <b>False</b>. If no such element exists, the function returns <b>end()</b>.</td>
</tr>
<tr valign=top>
<td width=49%><b>explicit map(const Pred&amp; comp = Pred(),<br>
 &nbsp;&nbsp;&nbsp; const A&amp; al=A())<br>
map(const map&amp; x)<br>
map(const value_type *first,const value_type *last, <br>
 &nbsp;&nbsp;&nbsp; const Pred&amp; comp=Pred(), const A&amp; al=A())</b></td>
<td width=51%>The constructors with an argument named comp store the function object so that it can be later returned by calling <b>key_comp()</b>. All constructors also store the allocator object <b>al</b> (or, for the copy constructor, <b>x. get_allocator()</b>) in allocator and initialize the controlled sequence. The first constructor specifies an empty initial controlled sequence. The second constructor specifies a copy of the sequence controlled by <i>x</i>. The third constructor specifies the sequence of element values [first, last).<br>
This method is a member of map only.</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef TYPE mapped_type</b></td>
<td width=51%><b>map::mapped_type</b> describes the value object stored in each element of the map. It is described here in terms of the second template parameter.</td>
</tr>
<tr valign=top>
<td width=49%><b>size_type max_size() const</b></td>
<td width=51%><b>map::max_size</b> returns the length of the longest sequence that the object can control.</td>
</tr>
<tr valign=top>
<td width=49%><b>explicit multimap(const Pred&amp; comp = Pred(), <br>
 &nbsp;&nbsp;&nbsp;&nbsp; const A&amp; al=A())<br>
multimap(const multimap&amp; x)<br>
multimap(const value_type *first,<br>
 &nbsp;&nbsp;&nbsp; const value_type *last,<br>
 &nbsp;&nbsp;&nbsp; const Pred&amp; comp=Pred(), const A&amp; al=A())</b></td>
<td width=51%>The constructors with an argument named comp store the function object so that it can be later returned by calling <b>key_comp()</b>. All constructors also store the allocator object <b>al</b> (or, for the copy constructor, <b>x. get_allocator()</b>) in allocator and initialize the controlled sequence. The first constructor specifies an empty initial controlled sequence. The second constructor specifies a copy of the sequence controlled by <i>x</i>. The third constructor specifies the sequence of element values [first, last).<br>
This method is a member of multimap only.</td>
</tr>
<tr valign=top>
<td width=49%><b>A::types&lt;TYPE&gt;::reference <br>
 &nbsp;&nbsp;&nbsp; operator[](const Key&amp; key);</b></td>
<td width=51%><b>map::operator[]</b> determines the iterator<b> it</b> as the return value of <b>insert( value_type(key, T())</b>. (It inserts an element with the specified key if no such element exists.) It then returns a reference to (<b>*it</b>). second. <br>
This method is a member of map only.</td>
</tr>
<tr valign=top>
<td width=49%><b>const_reverse_iterator rbegin() const<br>
reverse_iterator rbegin()</b></td>
<td width=51%><b>map::rbegin</b> returns a reverse iterator that points just beyond the end of the controlled sequence. Hence, it designates the beginning of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef A::reference reference</b></td>
<td width=51%><b>map::reference</b> describes an object that can be used as a reference to an element of the controlled sequence. It is described here as a synonym for the reference member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=49%><b>const_reverse_iterator rend() const<br>
reverse_iterator rend()</b></td>
<td width=51%><b>map::rend</b> returns a reverse iterator that points at the first element of the sequence (or just beyond the end of an empty sequence). Hence, it designates the end of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef reverse_bidirectional_iterator <br>
 &nbsp;&nbsp;&nbsp; &lt;iterator, value_type,&nbsp; reference,<br>
 &nbsp;&nbsp;&nbsp; A::types&lt;Key&gt;::pointer,&nbsp;&nbsp; <br>
 &nbsp;&nbsp;&nbsp; difference_type&gt; reverse_iterator</b></td>
<td width=51%><b>map::reverse_iterator</b> describes an object that can serve as a reverse bidirectional iterator for the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=49%><b>explicit map(const Pred&amp; comp=Pred(),<br>
 &nbsp;&nbsp;&nbsp; const A&amp; al=A())<br>
map(const map&amp; x)<br>
map(const value_type *first,const value_type *last,<br>
 &nbsp;&nbsp;&nbsp; const Pred&amp; comp = Pred(), const A&amp; al = A())</b></td>
<td width=51%>The constructors with an argument named <i>comp</i> store the function object so that it can be later returned by calling <b>key_comp()</b>. All constructors also store the allocator object <b>al</b> (or, for the copy constructor, <b>x.get_allocator()</b>) in allocator and initialize the controlled sequence. The first constructor specifies an empty initial controlled sequence. The second constructor specifies a copy of the sequence controlled by <i>x</i>. The third constructor specifies the sequence of element values [first, last).<br>
This method is a member of map only.</td>
</tr>
<tr valign=top>
<td width=49%><b>size_type size() const</b></td>
<td width=51%><b>map::size</b> returns the length of the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef A::size_type size_type</b></td>
<td width=51%><b>size_type</b> is an unsigned integer type that describes an object that can represent the length of any controlled sequence.</td>
</tr>
<tr valign=top>
<td width=49%><b>void swap(map&amp; str)</b></td>
<td width=51%><b>map::swap </b>swaps the controlled sequences between <i>*this </i>and <i>str</i>. If <b>allocator == str.allocator</b>, it does so in constant time. Otherwise, it performs a number of element assignments and constructor calls proportional to the number of elements in the two controlled sequences.</td>
</tr>
<tr valign=top>
<td width=49%><b>const_iterator upper_bound(const Key&amp; key) const</b></td>
<td width=51%><b>map::upper_bound</b> returns an iterator that designates the earliest element <i>x</i> in the controlled sequence for which <b>key_comp()(key, x)</b> is true. If no such element exists, the function returns <b>end()</b>.</td>
</tr>
<tr valign=top>
<td width=49%><b>value_compare value_comp() const</b></td>
<td width=51%><b>map::valuecomp</b> returns a function object that determines the order of elements in the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=49%><b>class value_compare<br>
 &nbsp;&nbsp; : public binary_function&lt;value_type, value_type, bool&gt; {<br>
 &nbsp;&nbsp; friend class map;<br>
public:<br>
 &nbsp;&nbsp; bool operator()(const value_type&amp; x, const value_type&amp; y)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {return (comp(x.first, x.second)); }<br>
protected:<br>
 &nbsp;&nbsp; value_compare(key_compare pr)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : comp(pr) {}<br>
 &nbsp;&nbsp; key_compare comp;<br>
 &nbsp;&nbsp; };</b></td>
<td width=51%><b>map::value_compare</b> describes a function object that can compare the sort keys in two elements to determine their relative order in the controlled sequence. The function object stores an object comp of <b>type key_type</b>. The member function <b>operator()</b> uses this object to compare the sort-key components of two elements.</td>
</tr>
<tr valign=top>
<td width=49%><b>typedef pair&lt;const Key, T&gt; value_type;</b></td>
<td width=51%>The type describes an element of the controlled sequence (a key/data pair).</td>
</tr>
</table><br>
<h3>17.4 set and multiset</h3>
<p>
Each element listed here is a member of both set and multiset, with exceptions noted explicitly. References to <b>set::[symbol] </b>imply the existence of <b>multiset::[symbol]</b> with similar behavior.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=51%><b>Member</b></td>
<td class=label width=49%><b>Function</b></td>
</tr>
<tr valign=top>
<td width=51%><b>typedef A allocator_type</b></td>
<td width=49%><b>set::allocator_type</b> describes the stored allocator object (same as the second template argument).</td>
</tr>
<tr valign=top>
<td width=51%><b>const_iterator begin() const<br>
iterator begin()</b></td>
<td width=49%><b>set::begin</b> returns a bidirectional iterator that points at the first element of the sequence (or just beyond the end of an empty sequence).</td>
</tr>
<tr valign=top>
<td width=51%><b>void clear() const</b></td>
<td width=49%><b>set::clear</b> calls <b>erase( begin(), end())</b>.</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef A::const_iterator const_iterator</b></td>
<td width=49%><b>set::const_iterator</b> describes an object that can serve as a constant bidirectional iterator for the set. It is described here as a synonym for the <b>const_iterator</b> member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef A::const_reference const_reference</b></td>
<td width=49%><b>set::const_reference</b> describes an object that can serve as a constant reference to an element of the set.</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef reverse_iterator&lt;const_iterator,<br>
 &nbsp;&nbsp;&nbsp;&nbsp; value_type,const_reference, A::const_pointer,<br>
 &nbsp;&nbsp;&nbsp;&nbsp; difference_type&gt; const_reverse_iterator</b></td>
<td width=49%><b>set::const_reverse_iterator</b> describes an object that can serve as a constant reverse bidirectional iterator for the set.</td>
</tr>
<tr valign=top>
<td width=51%><b>size_type count(const Key&amp; key) const</b></td>
<td width=49%><b>set::count</b> returns the number of elements <i>x</i> in the range [lower_bound(key), upper_bound(key)).</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef A::difference_type difference_type</b></td>
<td width=49%><b>set::difference_type</b> is a signed integer type that describes an object that can represent the difference between the addresses of any two elements in the set. Note that such differences are not meaningful within the context of the set.</td>
</tr>
<tr valign=top>
<td width=51%><b>bool empty() const</b></td>
<td width=49%><b>set::empty</b> returns true if the set is empty</td>
</tr>
<tr valign=top>
<td width=51%><b>const_iterator end() const<br>
iterator end()</b></td>
<td width=49%><b>set::end</b> returns a bidirectional iterator that points just beyond the end of the sequence.</td>
</tr>
<tr valign=top>
<td width=51%><b>pair&lt;const_iterator, const_iterator&gt;<br>
 &nbsp;&nbsp;&nbsp; equal_range(const Key&amp; key) const</b></td>
<td width=49%><b>set::equal</b>_range returns a pair of iterators x such that <b>x.first == lower_bound(key)</b> and <b>x.second == upper_bound(key)</b>.</td>
</tr>
<tr valign=top>
<td width=51%><b>iterator erase(iterator it)<br>
iterator erase(iterator first, iterator last)<br>
size_type erase(const Key&amp; key)</b></td>
<td width=49%>The first version of <b>set::erase</b> removes the element of the controlled sequence pointed to by it. The second version removes the elements in the range [first, last). Both return an iterator that designates the first element remaining beyond any elements removed, or <b>end()</b> if no such element exists. The third version removes the elements with sort keys in the range [lower_bound(key), upper_bound(key)), and returns the number of elements it removes.</td>
</tr>
<tr valign=top>
<td width=51%><b>const_iterator find(const Key&amp; key) const</b></td>
<td width=49%><b>set::find</b> returns an iterator that designates the earliest element in the controlled sequence whose sort key equals key. If no such element exists, the iterator equals <b>end()</b>.</td>
</tr>
<tr valign=top>
<td width=51%><b>A get_allocator() const</b></td>
<td width=49%>The member function returns allocator.</td>
</tr>
<tr valign=top>
<td width=51%><b>pair&lt;iterator, bool&gt;<br>
 &nbsp;&nbsp;&nbsp; insert(const value_type&amp; x)<br>
iterator insert(iterator obptr, const value_type&amp; x)<br>
void insert(const value_type *first,<br>
 &nbsp;&nbsp;&nbsp; const value_type *last)</b></td>
<td width=49%>The first version of <b>set::insert</b> determines whether an element <i>y</i> exists in the sequence whose key matches that of <i>x</i>. (The keys match if <b>! key_comp()(x, y) &amp;&amp; !key_comp()(y, x)</b>.) If not, it creates such an element <i>y</i> and initializes it with <i>x</i>. The function then determines the iterator obptr that designates <i>y</i>. If an insertion occurred, the function returns <b>pair(obptr, true)</b>. Otherwise, it returns <b>pair(obptr, false)</b>. The second version returns <b>insert(x)</b>, using obptr as a starting place within the controlled sequence to search for the insertion point. (Insertion can occur in amortized constant time, instead of logarithmic time, if the insertion point immediately follows obptr.) The third version inserts the sequence of element values in the range [first, last).</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef A::pointer iterator</b></td>
<td width=49%><i>Iterator</i> describes an object that can serve as a bidirectional iterator for the controlled sequence. It is described here as a synonym for the pointer member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=51%><b>key_compare key_comp() const</b></td>
<td width=49%><b>map::key_comp</b> returns the stored function object that determines the order of elements in the controlled sequence. The stored object defines the member function <b>bool operator(const Key&amp; x, const Key&amp; y)</b>, which returns true if <i>x</i> strictly precedes <i>y</i> in the sort order.</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef Pred key_compare</b></td>
<td width=49%><b>map::key_compare</b> describes a function object that can compare two sort keys to determine the relative order of any two elements in the controlled sequence. It is described here in terms of the user-defined comparator object (second template parameter).</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef Key key_type</b></td>
<td width=49%><b>map::key_type</b> describes the sort key object that constitutes each element of the controlled sequence. It is described here in terms of the data type of the objects the set contains (first template parameter).</td>
</tr>
<tr valign=top>
<td width=51%><b>const_iterator lower_bound(const Key&amp; key) <br>
 &nbsp;&nbsp;&nbsp; const</b></td>
<td width=49%><b>set::lower_bound</b> returns an iterator that designates the earliest element <i>x</i> in the controlled sequence for which <b>key_comp()(x, key)</b> is <b>False</b>. If no such element exists, the function returns <b>end()</b>.</td>
</tr>
<tr valign=top>
<td width=51%><b>size_type max_size() const</b></td>
<td width=49%><b>set::max_size</b> returns the length of the longest sequence that the object can control.</td>
</tr>
<tr valign=top>
<td width=51%><b>explicit multiset(const Pred&amp; comp = Pred(),<br>
 &nbsp;&nbsp;&nbsp; const A&amp; al=A())<br>
multiset(const multiset&amp; x)<br>
multiset(const value_type *first,<br>
 &nbsp;&nbsp;&nbsp; const value_type *last,<br>
 &nbsp;&nbsp;&nbsp; const Pred&amp; comp=Pred(), const A&amp; al=A())</b></td>
<td width=49%>The constructors with an argument named comp store the function object so that it can be later returned by calling <b>key_comp()</b>. All constructors also store the allocator object <b>al</b> (or, for the copy constructor, <b>x. get_allocator()</b>) in allocator and initialize the controlled sequence. The first constructor specifies an empty initial controlled sequence. The second constructor specifies a copy of the sequence controlled by <i>x</i>. The third constructor specifies the sequence of element values [first, last).<br>
This method is a member of multiset only</td>
</tr>
<tr valign=top>
<td width=51%><b>const_reverse_iterator rbegin() const<br>
reverse_iterator rbegin()</b></td>
<td width=49%><b>set::rbegin</b> returns a reverse iterator that points just beyond the end of the controlled sequence. Hence, it designates the beginning of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef A::reference reference</b></td>
<td width=49%><b>set::reference</b> describes an object that can be used as a reference to an element of the controlled sequence. It is described here as a synonym for the reference member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=51%><b>const_reverse_iterator rend() const<br>
reverse_iterator rend()</b></td>
<td width=49%><b>set::rend</b> returns a reverse iterator that points at the first element of the sequence (or just beyond the end of an empty sequence). Hence, it designates the end of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef reverse_bidirectional_iterator&lt;iterator,<br>
 &nbsp;&nbsp;&nbsp; value_type, reference, A::types&lt;Key&gt;::pointer,<br>
 &nbsp;&nbsp;&nbsp; difference_type&gt; reverse_iterator</b></td>
<td width=49%><b>set::reverse_iterator</b> describes an object that can serve as a reverse bidirectional iterator for the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=51%><b>explicit set(const Pred&amp; comp=Pred(),<br>
 &nbsp;&nbsp;&nbsp; const A&amp; al=A())<br>
set(const set&amp; x)<br>
set(const value_type *first, const value_type *last,<br>
 &nbsp;&nbsp;&nbsp; const Pred&amp; comp = Pred(),<br>
 &nbsp;&nbsp;&nbsp; const A&amp; al = A())</b></td>
<td width=49%>The constructors with an argument named <b>comp</b> store the function object so that it can be later returned by calling <b>key_comp()</b>. All constructors also store the allocator object <b>al</b> (or, for the copy constructor, <b>x.get_allocator()</b>) in allocator and initialize the controlled sequence. The first constructor specifies an empty initial controlled sequence. The second constructor specifies a copy of the sequence controlled by <i>x</i>. The third constructor specifies the sequence of element values [first, last).<br>
This method is a member of set only.</td>
</tr>
<tr valign=top>
<td width=51%><b>size_type size() const</b></td>
<td width=49%><b>set::size</b> returns the length of the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef A::size_type size_type</b></td>
<td width=49%><b>size_type</b> is an unsigned integer type that describes an object that can represent the length of any controlled sequence.</td>
</tr>
<tr valign=top>
<td width=51%><b>void swap(set&amp; str)</b></td>
<td width=49%><b>set::swap </b>swaps the controlled sequences between *<i>this</i> and <i>str</i>. If <b>allocator == str.allocator</b>, it does so in constant time. Otherwise, it performs a number of element assignments and constructor calls proportional to the number of elements in the two controlled sequences.</td>
</tr>
<tr valign=top>
<td width=51%><b>const_iterator upper_bound(const Key&amp; key) const</b></td>
<td width=49%><b>set::upper_bound</b> returns an iterator that designates the earliest element <i>x</i> in the controlled sequence for which <b>key_comp()(key, x)</b> is true. If no such element exists, the function returns <b>end()</b>.</td>
</tr>
<tr valign=top>
<td width=51%><b>value_compare value_comp() const</b></td>
<td width=49%><b>set::valuecomp</b> returns a function object that determines the order of elements in the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef Pred value_compare</b></td>
<td width=49%><b>set::value_compare</b> describes a function object that can compare two elements as sort keys to determine their relative order in the controlled sequence. It is described herein as the user-defined comparator object (second template parameter).</td>
</tr>
<tr valign=top>
<td width=51%><b>typedef A::types&lt;T&gt;::value_type value_type</b></td>
<td width=49%>The type describes an element of the controlled sequence (same as the template parameter <i>T</i>).</td>
</tr>
</table><br>
<h3>17.5 vector</h3>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=52%><b>Member</b></td>
<td class=label width=48%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=52%><b>typedef A allocator_type</b></td>
<td width=48%><b>vector::allocator_type</b> describes the stored allocator object (same as the second template argument).</td>
</tr>
<tr valign=top>
<td width=52%><b>void assign(const_iterator first, const_iterator last)<br>
void assign(size_type n, const T&amp; x = T())</b></td>
<td width=48%>The first version of <b>vector::assign</b> replaces the sequence controlled by <i>*this</i> with the sequence [first, last). The second version replaces the sequence controlled by <i>*this</i> with a repetition of <i>n</i> elements of value <i>x</i>.</td>
</tr>
<tr valign=top>
<td width=52%><b>const_reference at(size_type pos) const<br>
reference at(size_type pos)</b></td>
<td width=48%><b>vector::at</b> returns a reference to the element of the vector at position pos. If that position is invalid, the function throws an object of class <b>out_of_range</b> (throws an exception).</td>
</tr>
<tr valign=top>
<td width=52%><b>reference back()<br>
const_reference back() const</b></td>
<td width=48%><b>vector::back</b> returns a reference to the last element of the vector, which must be nonempty.</td>
</tr>
<tr valign=top>
<td width=52%><b>const_iterator begin() const<br>
iterator begin()</b></td>
<td width=48%><b>vector::begin</b> returns a random-access iterator that points at the first element of the sequence (or just beyond the end of an empty sequence).</td>
</tr>
<tr valign=top>
<td width=52%><b>size_type capacity() const</b></td>
<td width=48%><b>vector::capacity</b> returns the storage currently allocated to hold the vector, a value at least as large as <b>vector::size()</b>.</td>
</tr>
<tr valign=top>
<td width=52%><b>void clear() const</b></td>
<td width=48%><b>vector::clear</b> calls <b>erase( begin(), end())</b>.</td>
</tr>
<tr valign=top>
<td width=52%><b>typedef A::const_iterator const_iterator</b></td>
<td width=48%><b>vector::const_iterator</b> describes an object that can serve as a constant random-access iterator for the vector. It is described here as a synonym for the <b>const_iterator</b> member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=52%><b>typedef A::const_reference const_reference</b></td>
<td width=48%><b>vector::const_reference</b> describes an object that can serve as a constant reference to an element of the vector.</td>
</tr>
<tr valign=top>
<td width=52%><b>typedef reverse_iterator&lt;const_iterator,<br>
 &nbsp;&nbsp;&nbsp; value_type, const_reference,&nbsp; A::const_pointer,<br>
 &nbsp;&nbsp;&nbsp; difference_type&gt; const_reverse_iterator</b></td>
<td width=48%><b>vector::const_reverse_iterator</b> describes an object that can serve as a constant reverse iterator for the vector.</td>
</tr>
<tr valign=top>
<td width=52%><b>typedef A::difference_type difference_type</b></td>
<td width=48%><b>vector::difference_type</b> is a signed integer type that describes an object that can represent the difference between the addresses of any two elements in the vector.</td>
</tr>
<tr valign=top>
<td width=52%><b>bool empty() const</b></td>
<td width=48%><b>vector::empty</b> returns true if the vector is empty</td>
</tr>
<tr valign=top>
<td width=52%><b>const_iterator end() const<br>
iterator end()</b></td>
<td width=48%><b>vector::end</b> returns a random-access iterator that points just beyond the end of the sequence.</td>
</tr>
<tr valign=top>
<td width=52%><b>iterator erase(iterator it)<br>
iterator erase(iterator first, iterator last)</b></td>
<td width=48%>The first version of <b>vector::erase</b> removes the element of the controlled sequence pointed to by it. The second version removes the elements of the controlled sequence in the range [first, last). Both return an iterator that designates the first element remaining beyond any elements removed, or <b>end()</b> if no such element exists.<br>
Erasing <i>N </i>elements causes <i>N</i> destructor calls and an assignment (<b>operator=</b>) for each of the elements between the insertion point and the end of the sequence. No reallocation occurs, so iterators and references become invalid only from the first element erased through the end of the sequence.</td>
</tr>
<tr valign=top>
<td width=52%><b>reference front()<br>
const_reference front() const</b></td>
<td width=48%><b>vector::front</b> returns a reference to the first element of the controlled sequence, which must be nonempty.</td>
</tr>
<tr valign=top>
<td width=52%><b>A get_allocator() const</b></td>
<td width=48%>The member function returns allocator.</td>
</tr>
<tr valign=top>
<td width=52%><b>iterator insert(iterator it, const T&amp; x = T())<br>
void insert(iterator it, size_type n, const T&amp; x)<br>
void insert(iterator it, const_iterator first,<br>
 &nbsp;&nbsp;&nbsp; const_iterator last)</b></td>
<td width=48%>Each version of <b>vector::insert</b> inserts, after the element pointed to by it in the controlled sequence, a sequence specified by the remaining operands. The first version inserts a single element with value <i>x</i>&gt; and returns an iterator that points to the newly inserted element. The second version inserts a repetition of <i>n</i> elements of value <i>x</i>. The third version inserts the sequence [first, last).<br>
When inserting a single element, the number of element copies is linear in the number of elements between the insertion point and the end of the sequence. When inserting a single element at the end of the sequence, the amortized number of element copies is constant. When inserting <i>N</i> elements, the number of element copies is linear in <i>N </i>plus the number of elements between the insertion point and the end of the sequence.<br>
If reallocation occurs, the size of the controlled sequence at least doubles, and all iterators and references become invalid. If no reallocation occurs, iterators become invalid only from the point of insertion through the end of the sequence.</td>
</tr>
<tr valign=top>
<td width=52%><b>typedef A::pointer iterator</b></td>
<td width=48%><i>Iterator</i> describes an object that can serve as a random-access iterator for the controlled sequence. It is described here as a synonym for the pointer member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=52%><b>size_type max_size() const</b></td>
<td width=48%><b>vector::max_size</b> returns the length of the longest sequence that the object can control.</td>
</tr>
<tr valign=top>
<td width=52%><b>const_reference operator[](size_type pos) const<br>
reference operator[](size_type pos)</b></td>
<td width=48%><b>operator[]</b> returns a reference to the element of the controlled sequence at position pos. If that position is invalid, the behavior is undefined.</td>
</tr>
<tr valign=top>
<td width=52%><b>void pop_back()</b></td>
<td width=48%><b>vector::pop_back</b> removes the last element of the controlled sequence, which must be nonempty.</td>
</tr>
<tr valign=top>
<td width=52%><b>void push_back(const T&amp; x)</b></td>
<td width=48%><b>vector::push_back</b> inserts an element with value <i>x</i> at the end of the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=52%><b>const_reverse_iterator rbegin() const<br>
reverse_iterator rbegin()</b></td>
<td width=48%><b>vector::rbegin</b> returns a reverse iterator that points just beyond the end of the controlled sequence. Hence, it designates the beginning of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=52%><b>typedef A::reference reference</b></td>
<td width=48%><b>vector::reference</b> describes an object that can be used as a reference to an element of the controlled sequence. It is described here as a synonym for the reference member of the allocator object.</td>
</tr>
<tr valign=top>
<td width=52%><b>const_reverse_iterator rend() const<br>
reverse_iterator rend()</b></td>
<td width=48%><b>vector::rend</b> returns a reverse iterator that points at the first element of the sequence (or just beyond the end of an empty sequence). Hence, it designates the end of the reverse sequence.</td>
</tr>
<tr valign=top>
<td width=52%><b>void reserve(size_type n)</b></td>
<td width=48%><b>vector::reserve</b> ensures that <b>capacity()</b> henceforth returns at least <i>n</i>.</td>
</tr>
<tr valign=top>
<td width=52%><b>void resize(size_type n, T x = T())</b></td>
<td width=48%><b>vector::resize</b> ensures that<b> size()</b> henceforth returns <i>n</i>. If it must make the controlled sequence longer, it appends elements with value <i>x</i>.</td>
</tr>
<tr valign=top>
<td width=52%><b>typedef reverse_iterator&lt;iterator, value_type,</b><p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reference, A::types&lt;T&gt;::pointer,<br>
 &nbsp;&nbsp;&nbsp;&nbsp; difference_type&gt; reverse_iterator</b></p>
</td>
<td width=48%>The type describes an object that can serve as a reverse iterator for the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=52%><b>size_type size() const</b></td>
<td width=48%><b>vector::size</b> returns the length of the controlled sequence.</td>
</tr>
<tr valign=top>
<td width=52%><b>typedef A::size_type size_type</b></td>
<td width=48%><b>size_type</b> is an unsigned integer type that describes an object that can represent the length of any controlled sequence.</td>
</tr>
<tr valign=top>
<td width=52%><b>void swap(vector&amp; str)</b></td>
<td width=48%><b>vector::swap</b> swaps the controlled sequences between <i>*this</i> and <i>str</i>. If <b>allocator == str.allocator</b>, it does so in constant time. Otherwise, it performs a number of element assignments and constructor calls proportional to the number of elements in the two controlled sequences.</td>
</tr>
<tr valign=top>
<td width=52%><b>typedef A::types&lt;T&gt;::value_type value_type</b></td>
<td width=48%>The type describes an element of the controlled sequence (same as the template parameter <i>T</i>).</td>
</tr>
<tr valign=top>
<td width=52%><b>explicit vector(const A&amp; al = A())<br>
explicit vector(size_type n, const T&amp; v = T(),<br>
 &nbsp;&nbsp;&nbsp; const A&amp; al = A())<br>
vector(const vector&amp; x)<br>
vector(const_iterator first, const_iterator last,<br>
 &nbsp;&nbsp;&nbsp; const A&amp; al = A())</b></td>
<td width=48%>All constructors store the allocator object al (or, for the copy constructor, <b>x.get_allocator())</b> in allocator and initialize the controlled sequence. The first constructor specifies an empty initial controlled sequence. The second constructor specifies a repetition of n elements of value <i>x</i>. The third constructor specifies a copy of the sequence controlled by <i>x</i>. The last constructor specifies the sequence [first, last).<br>
Constructors copy <i>N</i> elements and perform no interim reallocation.</td>
</tr>
</table><br>
<h3>17.6 priority_queue </h3>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Member</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=48%><b>typedef A allocator_type</b></td>
<td width=52%><b>priority_queue::allocator</b> describes the allocator object used to construct the stored container object (specified by the second template parameter). The allocator is specified by the third template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>bool empty() const</b></td>
<td width=52%><b>priority_queue::empty</b> returns true if the <b>priority_queue</b> is empty. Returns <b>C.empty()</b>, where <i>C</i> is the stored container object specified by <b>priority_queue</b>’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>A get_allocator() const;</b></td>
<td width=52%><b>priority_queue::get_allocator</b> returns <b>C.get_allocator()</b>, where <i>C</i> is the stored container object specified by <b>priority_queue</b>’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>void pop();</b></td>
<td width=52%><b>priority_queue::pop</b> removes the first element of the controlled sequence, which must be nonempty, then reorders it.</td>
</tr>
<tr valign=top>
<td width=48%><b>explicit priority_queue(const Pred&amp; pr=Pred(),<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const A&amp; al = A());<br>
priority_queue(const value_type *first, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const value_type *last, const Pred&amp; pr = <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pred(), const A&amp; al = A());</b></td>
<td width=52%>Both constructors store <i>pr</i> in comp and effectively initialize the stored object with <b>c(al)</b>, to specify an empty initial controlled sequence. The second constructor then calls <b>push(x)</b> where <i>x</i> is an iterator of class <b>InIt</b> in the range [first, last).</td>
</tr>
<tr valign=top>
<td width=48%><b>void push(const T&amp; x);</b></td>
<td width=52%><b>priority_queue::push</b> inserts an element with value <i>x</i> at the end of the controlled sequence, then reorders it.</td>
</tr>
<tr valign=top>
<td width=48%><b>size_type size() const;</b></td>
<td width=52%><b>priority_queue::size</b> returns the number of items on the <b>priority_queue</b>. Calls <b>C.size</b>, where <i>C</i> is the stored container object specified by <b>priority_queue</b>’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>typedef C::size_type size_type;</b></td>
<td width=52%><b>priority_queue::size_type</b> describes an unsigned integer type describes an object that can represent the length of any controlled sequence. It is defined here in terms of the <b>size_type</b> defined for the stored container object specified by <b>priority_queue</b>’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>value_type&amp; top();<br>
const value_type&amp; top() const;</b></td>
<td width=52%><b>priority_queue::top</b> returns a reference to the last element of the <b>priority_queue</b>, which must be nonempty. Calls <b>C.back()</b>, where <i>C</i> is the stored container object specified by the second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>typedef Cont::value_type value_type;</b></td>
<td width=52%><b>priority_queue::value_type</b> describes an element of the controlled sequence. In this context, it is the same as <b>priority_queue</b>’s first template parameter. </td>
</tr>
</table><br>
<h3>17.7 queue </h3>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Member</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=48%><b>typedef A allocator_type</b></td>
<td width=52%><b>queue::allocator</b> describes the allocator object used to construct the stored container object (specified by the second template parameter). The allocator is specified by the third template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>bool empty() const</b></td>
<td width=52%><b>queue::empty</b> returns true if the queue is empty. Returns <b>C.empty()</b>, where <i>C</i> is the stored container object specified by queue’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>value_type&amp; front();<br>
const value_type&amp; front() const;</b></td>
<td width=52%><b>queue::front</b> returns a reference to the first element of the queue, which must be nonempty. Calls <b>C.back()</b>, where <i>C</i> is the stored container object specified by the second template parameter. (see note at the bottom of this table)</td>
</tr>
<tr valign=top>
<td width=48%><b>A get_allocator() const;</b></td>
<td width=52%><b>queue::get_allocator</b> returns <b>C.get_allocator()</b>, where <i>C</i> is the stored container object specified by queue’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>void pop();</b></td>
<td width=52%><b>queue::pop</b> removes the first element from the queue, which must be nonempty. Calls <b>C.pop_front</b>, where <i>C</i> is the stored container object specified by queue’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>void push(const T&amp; x);</b></td>
<td width=52%><b>queue::push(x)</b> pushes an item with value <i>x</i> onto the queue. Calls <b>C.push_back(x)</b>, where <i>C</i> is the stored container object specified by queue’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>explicit queue(const A&amp; al = A());</b></td>
<td width=52%>The constructor initializes the stored container object <i>C</i>, by calling <b>C.C(al)</b>, to specify an empty initial controlled sequence.</td>
</tr>
<tr valign=top>
<td width=48%><b>size_type size() const;</b></td>
<td width=52%><b>queue::size</b> returns the number of items on the queue. Calls <b>C.size</b>, where <i>C</i> is the stored container object specified by queue’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>typedef C::size_type size_type;</b></td>
<td width=52%><b>queue::size_type</b> describes an unsigned integer type that describes an object that can represent the length of any controlled sequence. It is defined here in terms of the <b>size_type</b> defined for the stored container object specified by queue’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>typedef Cont::value_type value_type;</b></td>
<td width=52%><b>queue::value_type</b> describes an element of the controlled sequence. In this context, it is the same as queue’s first template parameter. </td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Books online for Visual C++ 4.2 says that the queue class has a top member function (like a stack). This is an error in books online. The ANSII working papers specify that queue has a front (and not a top) member function.</p>
<h3>17.8 stack </h3>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Member</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=48%><b>typedef A allocator_type</b></td>
<td width=52%><b>stack::allocator</b> describes the allocator object used to construct the stored container object (specified by the second template parameter). The allocator is specified by the third template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>bool empty() const</b></td>
<td width=52%><b>stack::empty</b> returns true if the stack is empty. Returns <b>C.empty()</b>, where <i>C</i> is the stored container object specified by stack’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>A get_allocator() const;</b></td>
<td width=52%><b>stack::get_allocator</b> returns <b>C.get_allocator()</b>, where <i>C</i> is the stored container object specified by stack’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>void pop();</b></td>
<td width=52%><b>stack::pop</b> removes the last element pushed onto the stack, which must be nonempty. Calls <b>C.pop_back</b>, where <i>C</i> is the stored container object specified by stack’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>void push(const T&amp; x);</b></td>
<td width=52%><b>stack::push(x)</b> pushes an item with value <i>x</i> onto the stack. Calls <b>C.push_back(x)</b>, where <i>C</i> is the stored container object specified by stack’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>size_type size() const;</b></td>
<td width=52%><b>stack::size</b> returns the number of items on the stack. Calls <b>C.size</b>, where <i>C</i> is the stored container object specified by stack’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>typedef C::size_type size_type;</b></td>
<td width=52%><b>stack::size_type</b> describes an unsigned integer type that describes an object that can represent the length of any controlled sequence. It is defined here in terms of the <b>size_type</b> defined for the stored container object specified by stack’s second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>explicit stack(const A&amp; al = A());</b></td>
<td width=52%>The constructor initializes the stored container object <i>C</i>, by calling <b>C.C(al)</b>, to specify an empty initial controlled sequence.</td>
</tr>
<tr valign=top>
<td width=48%><b>value_type&amp; top();<br>
const value_type&amp; top() const;</b></td>
<td width=52%><b>stack::top</b> returns a reference to the last element of the stack, which must be nonempty. Calls <b>C.back()</b>, where <i>C</i> is the stored container object specified by the second template parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>typedef Cont::value_type value_type;</b></td>
<td width=52%><b>stack::value_type</b> describes an element of the controlled sequence. In this context, it is the same as stack’s first template parameter. </td>
</tr>
</table><br>
<h2><a name="stlappendixd"></a>18. Appendix D: Allocator Class</h2>
<p>
Several STL components use Default Template Arguments. The ANSII draft specification for the STL container classes (such as vector) dictates that the template parameter that specifies the allocator must have a default value of "allocator", as follows:</p>
<pre><code>template&lt;class T, class Allocator = allocator&gt; class vector;
</code></pre>
<p>
The class allocator as specified by the ANSII draft standard utilizes member templates. Visual C++ version 4.2 does not support the use of member templates. (The term <i>member template</i> refers to one or more methods of a (possibly nontemplated) class that are defined as templated functions. It can also be used to describe a class that has an embedded template class.) </p>
<p>
Since it is not possible to implement the class allocator directly, allocator has been implemented as a template class in the current implementation of the STL. The problem lies in attempting to use the templated allocator class as a default template argument. Consider the following:</p>
<pre><code>template&lt;class T, class Allocator = allocator&lt;T&gt; &gt; class vector;
</code></pre>
<p>
This new construct with the template allocator class creates a circular reference, because it relies on the unknown data type <i>T</i> to instantiate the allocator class. This makes it necessary, in the case of STL containers, to remove the default template argument for the allocator. The definition of vector now becomes: </p>
<pre><code>template&lt;class T, class Allocator&gt; class vector;
</code></pre>
<p>
Therefore, declaring a container will now require that you explicitly specify the allocator class as a template argument, as the following declaration of an int vector illustrates:</p>
<pre><code>vector&lt;int&gt; myVector; 
</code></pre>
<p>
This declaration will cause the following compiler error:</p>
<pre><code>Compiler error C2976 : 'vector' : too few template parameters
</code></pre>
<p>
To correct the error, the declaration must be changed to:</p>
<pre><code>vector&lt;int, allocator&lt;int&gt; &gt; myVector; 
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The STL is an emerging technology. The definition of the allocator class as a templated class will undoubtedly change in a future release of Visual C++. You should always use <b>typedefs</b> when using any component of the STL—this will make it relatively painless to update your code if and when the templates change.</p>
</BODY>
</HTML>
