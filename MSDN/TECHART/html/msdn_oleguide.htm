<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE Controls and Control Containers Guidelines, Version 1.1</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_oleguide"></a></sup>OLE Controls and Control Containers Guidelines, Version 1.1</h1>
<p>
Microsoft Corporation</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4535">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the Verification Software files.</a></p>
<p>
For information on how to use the Verification Software, see the README.TXT file in the project directory.</p>
<p class=indent>
<b>This tool is not supported by Microsoft Corporation. It is provided "as is" because we believe it may be useful to you. We regret that Microsoft is unable to support or assist you should you have problems using this tool.</b></p>
<h2>Overview</h2>
<p>
The purpose of this document is to provide guidelines for implementing OLE controls and control containers that will interoperate well with other controls and control containers. Specifically, this document defines the minimum set of functionality in terms of interfaces, methods, and features that are required of OLE controls and control containers to accomplish seamless and useful interoperability. Optional features that may provide enhanced capabilities for a control or a container (categorized into "function groups") are discussed as well.</p>
<p>
These guidelines define the minimum set of functionality that is required of a control and container; it therefore also describes the minimum set of functionality that a control can expect of a container, and vice versa. This enables controls and container developers to assume a standard set of functionality, and to reasonably rely on the existence of that functionality.</p>
<p>
Those features, interfaces, methods, properties, and function groups that are mandatory for OLE controls and control containers are explicitly defined here—those not explicitly stated as mandatory in these guidelines should be considered optional.</p>
<h3>Why Are OLE Control and Control Container Guidelines Important?</h3>
<p>
OLE Controls have become the primary architecture for developing programmable software components for use in a variety of different containers, ranging from software development tools to end-user productivity tools. In order for a control to operate well in a variety of containers, the control must be able to assume some minimum level of functionality—some set of features that it can rely on in all containers. Likewise, a container should be able to expect some minimum standard feature set from all the controls that it contains. Controls and containers will most certainly implement features above this minimal set; these guidelines define the minimum common set of features.</p>
<p>
By following these guidelines, control and container developers make their controls and containers more reliable and interoperable, and ultimately better and more usable components for building component-based solutions.</p>
<p>
The rest of this document is divided into three sections. The first discusses control guidelines, the second discusses container guidelines, and the third discusses general guidelines, relevant to both OLE control and control container developers.</p>
<h3>What to Do When an Interface You Need Is Not Available</h3>
<p>
Although these guidelines will help ensure that required functionality will be present, there will always be instances in which a control does not support a feature requested by the container, or vice versa. It is important for all OLE applications to be written to handle these situations. More specifically, OLE applications must use <b>IUnknown::QueryInterface</b> to acquire interface pointers (see Note 1 at the end of Table 1), and applications must <i>always</i> follow the standard OLE return-checking conventions required of all OLE applications—it cannot be safely assumed that <b>IUnknown::QueryInterface</b> will always succeed.</p>
<p>
If the requested interface is not available (for example, <b>IUnknown::QueryInterface</b> returns E_NOINTERFACE), the control or container must degrade gracefully, even if it means that it must shut down.</p>
<h3>What's New in Version 1.1?</h3>
<p>
This is the second release of the guidelines, and we've called it version 1.1 because only a small number of things have changed and a few "bug fixes" have been made. These are primarily interfaces or methods that in version 1.0 were marked as mandatory but that are now better expressed as optional. Items that are new or changed in this version are marked accordingly.</p>
<h2>Controls</h2>
<p>
An OLE control is an embeddable OLE object that has additional support for OLE controls interfaces. </p>
<p>
This section describes the specific interfaces, methods, and other features that are required of OLE Controls. Required interfaces, optional methods, properties, property pages, ambient properties, automation methods, events, and self registration are addressed in the following subsections.</p>
<h3>Required Interfaces</h3>
<p>
Table 1 (below) lists the OLE Control interfaces. It denotes which interfaces are mandatory and must be implemented by controls, and which are optional.</p>
<p class=label>
<b>Table 1.</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b><br>
Interface</b></td>
<td class=label width=14%><b>Support<br>
Mandatory?</b></td>
<td class=label width=59%><b><br>
Comments</b></td>
</tr>
<tr valign=top>
<td width=27%><b>IOleObject</b></td>
<td width=14%>Yes</td>
<td width=59%></td>
</tr>
<tr valign=top>
<td width=27%><b>IOleInPlaceObject</b></td>
<td width=14%>Yes</td>
<td width=59%></td>
</tr>
<tr valign=top>
<td width=27%><b>IOleInPlaceActiveObject</b></td>
<td width=14%>No</td>
<td width=59%>Mandatory for controls with user interface (UI).</td>
</tr>
<tr valign=top>
<td width=27%><b>IOleControl</b></td>
<td width=14%>No</td>
<td width=59%>Mandatory for controls with mnemonics and/or controls that use ambient properties.</td>
</tr>
<tr valign=top>
<td width=27%><b>IDataObject</b></td>
<td width=14%>Yes</td>
<td width=59%>Mandatory for controls with property sets. Support for CF_METAFILE format is mandatory.</td>
</tr>
<tr valign=top>
<td width=27%><b>IViewObject2</b></td>
<td width=14%>Yes</td>
<td width=59%></td>
</tr>
<tr valign=top>
<td width=27%><b>IExternalConnection</b></td>
<td width=14%>No</td>
<td width=59%>Mandatory for a controls that supports external links to itself, other than from its immediate container.</td>
</tr>
<tr valign=top>
<td width=27%><b>IDispatch</b></td>
<td width=14%>Yes</td>
<td width=59%>Not mandatory for controls that have no methods or properties. See Note 1.</td>
</tr>
<tr valign=top>
<td width=27%><b>IConnectionPointContainer</b></td>
<td width=14%>No</td>
<td width=59%>Mandatory for controls with events or property notifications.</td>
</tr>
<tr valign=top>
<td width=27%><b>IConnectionPoint</b></td>
<td width=14%>No</td>
<td width=59%>See note for <b>IConnectionPointContainer</b>.</td>
</tr>
<tr valign=top>
<td width=27%><b>IProvideClassInfo</b></td>
<td width=14%>Yes</td>
<td width=59%></td>
</tr>
<tr valign=top>
<td width=27%><b>ISpecifyPropertyPages</b></td>
<td width=14%>No</td>
<td width=59%>Mandatory for controls with property pages.</td>
</tr>
<tr valign=top>
<td width=27%><b>IPersistStream</b></td>
<td width=14%>No</td>
<td width=59%>See "Storage Interfaces" section.</td>
</tr>
<tr valign=top>
<td width=27%><b>IPersistStreamInit</b></td>
<td width=14%>No</td>
<td width=59%>See "Storage Interfaces" section.</td>
</tr>
<tr valign=top>
<td width=27%><b>IPersistStorage</b></td>
<td width=14%>Yes</td>
<td width=59%>See "Storage Interfaces" section.</td>
</tr>
<tr valign=top>
<td width=27%><b>IClassFactory</b></td>
<td width=14%>Yes</td>
<td width=59%></td>
</tr>
<tr valign=top>
<td width=27%><b>IClassFactory2</b></td>
<td width=14%>No</td>
<td width=59%>Mandatory for controls with licensing support.</td>
</tr>
<tr valign=top>
<td width=27%><b>IPropertyNotifySink</b> <br>
(source)</td>
<td width=14%>No</td>
<td width=59%>Mandatory for controls that provide property change notifications.</td>
</tr>
<tr valign=top>
<td width=27%><b>IPersistPropertyBag</b></td>
<td width=14%>No</td>
<td width=59%>Strongly recommended (see Note 2).</td>
</tr>
<tr valign=top>
<td width=27%><b>IOleCache</b></td>
<td width=14%>No</td>
<td width=59%></td>
</tr>
<tr valign=top>
<td width=27%><b>IOleCache2</b></td>
<td width=14%>No</td>
<td width=59%></td>
</tr>
<tr valign=top>
<td width=27%><b>IOleCacheControl</b></td>
<td width=14%>No</td>
<td width=59%></td>
</tr>
<tr valign=top>
<td width=27%><b>IRunnableObject</b></td>
<td width=14%>No</td>
<td width=59%></td>
</tr>
</table><br>
<p>
<b>Notes:</b>
<ol>
<li>
Dual interface support is optional but strongly recommended.<br><br></li>
<li>
Support for <b>IPersistPropertyBag</b> is optional but strongly recommended. <b>IPersistPropertyBag</b> is an optimization for containers that implement a "save as text" feature. For more information, see the <b>IPersistPropertyBag</b> section under "General Guidelines."</li>
</ol>
<h3>Optional Methods</h3>
<p>
An OLE component can implement an interface without implementing all the semantics of every method in the interface, instead returning E_NOTIMPL or S_OK as appropriate. Table 2 describes those methods that a control is not required to implement (that is, the control can return E_NOTIMPL).</p>
<p>
Table 2 (below) describes optional methods. Note that the method must still exist, but can simply return E_NOTIMPL instead of implementing "real" semantics. Any method from a mandatory interface that is not listed below must be considered mandatory and may not return E_NOTIMPL.</p>
<p class=label>
<b>Table 2.</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=35%><b>Method</b></td>
<td class=label width=65%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=35%><b>IOleControl</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetControlInfo</b></td>
<td width=65%>Mandatory for controls with mnemonics.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>OnMnemonic</b></td>
<td width=65%>Mandatory for controls with mnemonics.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>OnAmbientPropertyChange</b></td>
<td width=65%>Mandatory for controls that use ambient properties.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>FreezeEvents</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%><b>IOleObject</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>SetMoniker</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetMoniker</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>InitFromData</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetClipboardData</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>SetExtent</b></td>
<td width=65%>Mandatory only for DVASPECT_CONTENT.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetExtent</b></td>
<td width=65%>Mandatory only for DVASPECT_CONTENT.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>SetColorScheme</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>DoVerb</b></td>
<td width=65%>See Note 1.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>EnumAdvise</b></td>
<td width=65%><b>New for version 1.1</b>.</td>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%><b>IOleInPlaceObject</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>ContextSensitiveHelp</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>ReactivateAndUndo</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%><b>IOleInPlaceActiveObject</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>ContextSensitiveHelp</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>TranslateAccelerator</b></td>
<td width=65%><b>New for version 1.1</b>. Mandatory for controls that process accelerator keys.</td>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%><b>IViewObject2</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>Freeze</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>Unfreeze</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>Draw</b></td>
<td width=65%><b>New for version 1.1</b>. Mandatory for controls visible at run time.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetColorSet</b></td>
<td width=65%><b>New for version 1.1</b>.</td>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%><b>IPersistStreamInit</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetSizeMax</b></td>
<td width=65%>See Note 2.</td>
</tr>
</table><br>
<p>
<b>Notes:</b>
<ol>
<li>
A control with property pages must support <b>IOleObject::DoVerbs</b> for the OLEIVERB_PROPERTIES and OLEIVERB_PRIMARY verbs. A control that can be active must support <b>IOleObject::DoVerbs</b> for the OLEIVERB_INPLACEACTIVATE verb. A control that can be UI-active must also support <b>IOleObject::DoVerbs</b> for the OLEIVERB_UIACTIVATE verb.<br><br></li>
<li>
If a control supports <b>IPersistStream</b> and can return an accurate value, then it should do so.</li>
</ol>
<h3>Interface Method Semantics</h3>
<p>
Just as OLE controls must implement certain interfaces, and provide non-trivial implementations for most interface methods, there are some interface methods that require specific action. This section lists those methods and the required functionality. (There is currently only one method listed.)</p>
<p>
<b>IOleControl::FreezeEvents</b>  See "Event Freezing" in the "General Guidelines" section.</p>
<h3>Properties</h3>
<p>
Although most controls do have properties, controls are not required to expose any properties, and there are no guidelines for which properties a control should expose.</p>
<h3>Property Pages</h3>
<p>
Support for property pages and per-property browsing is strongly recommended, but not required. <b>New for version 1.1:</b> If a control <i>does</i> implement property pages, those pages should conform to one of the standard sizes: 250 x 62 or 250 x 110 dialog units (DLUs).</p>
<h3>Ambient Properties</h3>
<p>
OLE Controls must use the following ambient properties, if they are available from the control site.</p>
<p class=label>
<b>Table 3.</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=23%><b>Ambient Property</b></td>
<td class=label width=77%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=23%><b>LocaleID</b></td>
<td width=77%>If locale is significant to the control (for example, for text output).</td>
</tr>
<tr valign=top>
<td width=23%><b>UserMode </b></td>
<td width=77%>If the control behaves differently in user (design) mode and run mode.</td>
</tr>
<tr valign=top>
<td width=23%><b>UIDead</b></td>
<td width=77%>If the control reacts to UI events, it should honor this ambient property.</td>
</tr>
<tr valign=top>
<td width=23%><b>ShowHatching</b></td>
<td width=77%></td>
</tr>
<tr valign=top>
<td width=23%><b>ShowGrabHandles</b></td>
<td width=77%></td>
</tr>
<tr valign=top>
<td width=23%><b>DisplayAsDefault</b></td>
<td width=77%>Only if the control is marked OLEMISC_ACTSLIKEBUTTON.</td>
</tr>
</table><br>
<h3>Methods (via OLE Automation)</h3>
<p>
Although most controls do expose and support several methods, controls are not required to expose or support any methods, and there are no guidelines for which methods a control should expose.</p>
<h3>Events</h3>
<p>
Although most controls do expose and fire several events, they are not <i>required</i> to do so, and there are no guidelines for which events a control should expose.</p>
<h3>Self-Registration</h3>
<p>
OLE controls must support self-registration by implementing the <b>DllRegisterServer</b> and <b>DllUnregisterServer</b> functions. OLE controls must register all of the standard registry entries for embeddable objects and automation servers. OLE controls should also register the following three registry keys, which are strongly recommended, but not mandatory:
<ul type=disc>
<li>
ToolBoxBitmap32<br><br></li>
<li>
Insertable<br><br></li>
<li>
Control</li>
</ul>
<h2>Containers</h2>
<p>
An OLE control container is an OLE container that supports the following additional features:
<ul type=disc>
<li>
Embedded objects from in-process servers<br><br></li>
<li>
In-place activation<br><br></li>
<li>
Inside-out activation<br><br></li>
<li>
OLEMISC_ACTIVATEWHENVISIBLE</li>
</ul>
<p>
OLE Control Containers must provide support for all of these features.</p>
<p>
Note that support for local servers is currently not required, because OLE controls are currently only implemented in-process.</p>
<p>
This section describes the specific interfaces, methods, and other features that are required of OLE Control Containers. Required interfaces, optional methods, miscellaneous status bits support, keyboard handling, storage interfaces, ambient properties, extended properties, events, methods, message reflection, and automatic clipping are addressed in the following sections.</p>
<h3>Required Interfaces</h3>
<p>
Table 4 (below) lists the OLE Control Container interfaces, and denotes which interfaces are mandatory and must be implemented by control containers, and which are optional.</p>
<p class=label>
<b>Table 4.</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=32%><b><br>
Interface</b></td>
<td class=label width=14%><b>Support <br>
Mandatory?</b></td>
<td class=label width=54%><b><br>
Comments</b></td>
</tr>
<tr valign=top>
<td width=32%><b>IOleClientSite</b></td>
<td width=14%>Yes</td>
<td width=54%></td>
</tr>
<tr valign=top>
<td width=32%><b>IAdviseSink</b></td>
<td width=14%>Yes</td>
<td width=54%>Except where it is not needed, such as where controls are always active.</td>
</tr>
<tr valign=top>
<td width=32%><b>IOleInPlaceSite</b></td>
<td width=14%>Yes</td>
<td width=54%></td>
</tr>
<tr valign=top>
<td width=32%><b>IOleControlSite</b></td>
<td width=14%>Yes</td>
<td width=54%></td>
</tr>
<tr valign=top>
<td width=32%><b>IOleInPlaceFrame</b></td>
<td width=14%>Yes</td>
<td width=54%></td>
</tr>
<tr valign=top>
<td width=32%><b>IOleContainer</b></td>
<td width=14%>Yes</td>
<td width=54%>See Note 1.</td>
</tr>
<tr valign=top>
<td width=32%><b>IDispatch</b> for ambient properties</td>
<td width=14%>Yes</td>
<td width=54%>See Note 2 and "Ambient Properties" section.</td>
</tr>
<tr valign=top>
<td width=32%><b>IDispatch</b> for events</td>
<td width=14%>Yes</td>
<td width=54%>See Note 2.</td>
</tr>
<tr valign=top>
<td width=32%><b>ISimpleFrameSite</b></td>
<td width=14%>No</td>
<td width=54%><b>ISimpleFrameSite</b> and support for nested simple frames are optional.</td>
</tr>
<tr valign=top>
<td width=32%><b>IPropertyNotifySink</b></td>
<td width=14%>No</td>
<td width=54%></td>
</tr>
<tr valign=top>
<td width=32%><b>IErrorInfo</b></td>
<td width=14%>Yes</td>
<td width=54%>Mandatory if container supports dual interfaces.</td>
</tr>
<tr valign=top>
<td width=32%><b>IClassFactory2</b></td>
<td width=14%>Yes</td>
<td width=54%><b>New for version 1.1</b>. Needs to be supported so that a container can honor a control's licensing scheme.</td>
</tr>
</table><br>
<p>
<b>Notes:</b>
<ol>
<li>
<b>IOleContainer</b> is implemented on the document or form object (or appropriate analog) that holds the container sites. Controls use <b>IOleContainer</b> to navigate to other controls in the same document or form.<br><br></li>
<li>
Support for dual interfaces is not mandatory, but is strongly recommended. The OLE Controls Developers Kit does not currently support dual interfaces. However, writing your OLE Control Containers to take advantage of dual interfaces will afford you better performance now with controls that have expressly added dual interface support, and with controls that explicitly add dual interface support.</li>
</ol>
<p>
OLE control containers must support OLE Automation exceptions. If a control container supports dual interfaces, it must capture automation exceptions through <b>IErrorInfo</b>.</p>
<h3>Optional Methods</h3>
<p>
An OLE component can implement an interface without implementing all the semantics of every method in the interface, instead returning E_NOTIMPL or S_OK as appropriate. The following table describes those methods that an OLE control container is <i>not</i> required to implement (that is, the control container can return E_NOTIMPL).</p>
<p>
Table 5 (below) describes optional methods; note that the method must still exist, but can simply return E_NOTIMPL instead of implementing "real" semantics. Note also that any method from a mandatory interface that is not listed below must be considered mandatory and may <i>not</i> return E_NOTIMPL.</p>
<p class=label>
<b>Table 5.</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=35%><b>Method</b></td>
<td class=label width=65%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=35%><b>IOleClientSite</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>SaveObject</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetMoniker</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>RequestNewObjectLayout</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%><b>IOleInPlaceSite</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>ContextSensitiveHelp</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>Scroll</b></td>
<td width=65%>May return S_FALSE with no action.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>DiscardUndoState</b></td>
<td width=65%>Can return S_OK with no action.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>DeactivateAndUndo</b></td>
<td width=65%>Deactivation is mandatory; Undo is optional.</td>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%><b>IOleControlSite</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetExtendedControl</b></td>
<td width=65%>Mandatory for containers that support extended controls.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>ShowPropertyFrame</b></td>
<td width=65%>A control calls this method to display property pages.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>TranslateAccelerator</b></td>
<td width=65%><b>New for version 1.1</b>. </td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>LockInPlaceActive</b></td>
<td width=65%><b>New for version 1.1.</b> Very difficult to implement in native language containers (for example, C++) because the developer has complete control.</td>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%><b>IDispatch</b> (Ambient properties)</td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetTypeInfoCount</b></td>
<td width=65%>Mandatory for containers that support non-standard ambient properties.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetTypeInfo</b></td>
<td width=65%>Mandatory for containers that support non-standard ambient properties.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetIDsOfNames</b></td>
<td width=65%>Mandatory for containers that support non-standard ambient properties.</td>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%><b>IDispatch</b> (Event sink)</td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetTypeInfoCount</b></td>
<td width=65%>The control knows its own type information, so it has no need to call this.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetTypeInfo</b></td>
<td width=65%>The control knows its own type information, so it has no need to call this.</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetIDsOfNames</b></td>
<td width=65%>The control knows its own type information, so it has no need to call this.</td>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%><b>IOleInPlaceFrame</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>ContextSensitiveHelp</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>GetBorder</b></td>
<td width=65%>Mandatory for controls with toolbar UI (which is optional).</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>RequestBorderSpace</b></td>
<td width=65%>Mandatory for controls with toolbar UI (which is optional).</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>SetBorderSpace</b></td>
<td width=65%>Mandatory for controls with toolbar UI (which is optional).</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>InsertMenus</b></td>
<td width=65%>Mandatory for controls with menu UI (which is optional).</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>SetMenu</b></td>
<td width=65%>Mandatory for controls with menu UI (which is optional).</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>RemoveMenus</b></td>
<td width=65%>Mandatory for controls with menu UI (which is optional).</td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>SetStatusText</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>EnableModeless</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>TranslateAccelerator</b></td>
<td width=65%><b>New for version 1.1. </b></td>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%><b>IOleContainer</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>ParseDisplayName</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>LockContainer</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>EnumObjects</b></td>
<td width=65%>Mandatory, returns all OLE Controls, but not necessarily all objects. (Because there's no guarantee that all objects are OLE controls; some may be regular Windows controls.)</td>
</tr>
<tr valign=top>
<td width=35%><b>IAdviseSink</b></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%> &nbsp; <b>OnDataChange</b></td>
<td width=65%><b>OnDataChange</b> returns void instead of an HRESULT. </td>
</tr>
</table><br>
<h3>Miscellaneous Status Bits Support</h3>
<p>
OLE Control Containers must recognize and support the following OLEMISCSTATUS bits (Table 6).</p>
<p class=label>
<b>Table 6.</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b><br>
Status Bit</b></td>
<td class=label width=16%><b>Support <br>
Mandatory?</b></td>
<td class=label width=55%><b><br>
Comments</b></td>
</tr>
<tr valign=top>
<td width=29%>ACTIVATEWHENVISIBLE</td>
<td width=16%>Yes</td>
<td width=55%>Mandatory only at run time. There may be other times when a container will not activate controls, such as during design time. This is dependent on the container.</td>
</tr>
<tr valign=top>
<td width=29%>INSIDEOUT</td>
<td width=16%>Yes</td>
<td width=55%></td>
</tr>
<tr valign=top>
<td width=29%>INVISIBLEATRUNTIME</td>
<td width=16%>Yes</td>
<td width=55%>Designates a control that should be visible at design time, but invisible at run time.</td>
</tr>
<tr valign=top>
<td width=29%>ALWAYSRUN</td>
<td width=16%>Yes</td>
<td width=55%></td>
</tr>
<tr valign=top>
<td width=29%>ACTSLIKEBUTTON</td>
<td width=16%>Yes</td>
<td width=55%>Designates a control that behaves as a button. The control can identify itself as the default button. (Container support for default button functionality is optional.)</td>
</tr>
<tr valign=top>
<td width=29%>ACTSLIKELABEL</td>
<td width=16%>Yes</td>
<td width=55%>Designates that a control behaves like a label, indicating that it should not become UI-active, and should never receive the focus. (Focus should bypass labels, and continue to the next control in the tabbing order.)</td>
</tr>
<tr valign=top>
<td width=29%>NOUIACTIVATE</td>
<td width=16%>Yes</td>
<td width=55%></td>
</tr>
<tr valign=top>
<td width=29%>ALIGNABLE</td>
<td width=16%>No</td>
<td width=55%></td>
</tr>
<tr valign=top>
<td width=29%>SIMPLEFRAME</td>
<td width=16%>No</td>
<td width=55%>See "Container Controls" under "General Guidelines" below.</td>
</tr>
<tr valign=top>
<td width=29%>SETCLIENTSITEFIRST</td>
<td width=16%>Yes</td>
<td width=55%></td>
</tr>
<tr valign=top>
<td width=29%>IMEMODE</td>
<td width=16%>No</td>
<td width=55%></td>
</tr>
</table><br>
<h3>Keyboard Handling</h3>
<p>
OLE Control Containers implement keyboard handling by calling the controls' <b>IOleControl</b> interfaces. OLE control containers must support the following:
<ul type=disc>
<li>
Default button handling<br><br></li>
<li>
Mnemonic handling<br><br></li>
<li>
Tab handling, including tab order</li>
</ul>
<p>
Optionally, an OLE control container can allow a developer to designate an OLE control to act as the cancel button. In this case, the container treats the Escape key as a click on the designated control.</p>
<h3>Storage Interfaces</h3>
<p>
OLE controls must support <b>IPersistStorage</b>, and any container can rely on support for this interface. Additionally, controls can optionally implement stream persistence using <i>either</i> <b>IPersistStream</b> <i>or</i> <b>IPersistStreamInit</b>. Support for <b>IPersistStreamInit</b> is strongly recommended.</p>
<p>
Once an OLE Control Container has chosen a storage interface to use (either <b>IPersistStorage</b>, <b>IPersistStream</b>, or <b>IPersistStreamInit</b>), the control container must use the same interface for the lifetime of the control.</p>
<p>
OLE Control Containers do not need to support a "save as text" mechanism.</p>
<h3>Ambient Properties</h3>
<p>
At a minimum, OLE control containers must support the following ambient properties (Table 7).</p>
<p class=label>
<b>Table 7.</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Ambient Property</b></td>
<td class=label width=73%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=27%><b>LocaleID</b></td>
<td width=73%></td>
</tr>
<tr valign=top>
<td width=27%><b>UserMode</b></td>
<td width=73%>For containers that have different user and run environments.</td>
</tr>
<tr valign=top>
<td width=27%><b>SupportsMnemonics</b></td>
<td width=73%>Which must always be TRUE, according to the "Keyboard Handling" section.</td>
</tr>
<tr valign=top>
<td width=27%><b>DisplayAsDefault </b></td>
<td width=73%>For those containers where a default button makes sense.</td>
</tr>
</table><br>
<h3>Extended Properties, Events, and Methods</h3>
<p>
OLE Control Containers are not required to support extended controls. However, if the control container does support extended properties, then it must support the following minimal set:
<ul type=disc>
<li>
Visible<br><br></li>
<li>
Parent<br><br></li>
<li>
Default<br><br></li>
<li>
Cancel</li>
</ul>
<p>
OLE Control Containers are not required to support extended events or methods. Currently, extended properties, events, and methods do not have standard Dispatch IDs.</p>
<h3>Message Reflection</h3>
<p>
It is strongly recommended that an OLE control container support message reflection; this will result in more efficient operation for subclassed controls. If message reflection is supported, the <b>MessageReflect</b> ambient property must be supported and have a value of TRUE. If a container does <i>not</i> implement message reflection, the OLE Control Developer's Kit (CDK) creates <i>two</i> windows for <i>every</i> subclassed control, to provide message reflection on behalf of the control container.</p>
<h3>Automatic Clipping</h3>
<p>
It is strongly recommended that an OLE control container support automatic clipping of its controls. This will result in more efficient operation for most controls. If automatic clipping is supported, the <b>AutoClip</b> ambient property must be supported and have a value of TRUE.</p>
<p>
Automatic clipping is the ability of a container to ensure that a control's drawn output goes only to the container's current clipping region. In a container that supports automatic clipping, a control can paint without regard to its clipping region, because the container will automatically clip any painting that occurs outside the control's area. If a container does not support automatic clipping, CDK-generated controls will create an extra parent window if a non-null clipping region is passed.</p>
<h2>General Guidelines</h2>
<p>
This section describes various features, hints, and tips for developers of OLE controls and OLE control containers.</p>
<h3>Function Groups</h3>
<p>
There are many optional features that OLE controls and OLE control containers can implement, in addition to the minimal set defined by these guidelines. These optional features may or may not be essential to correct operation of the control or container. Some optional features are grouped into "function groups." A control or a control container can implement any of these function groups. Function groups are not cumulative, so a control or container can support one function group without necessarily supporting another. It is important for a control or container to degrade gracefully if a feature or function group it uses is not available. If an optional feature that is essential for correct operation is not available, then the control or container should alert the user and/or should not instantiate itself. </p>
<p>
It is important for controls and containers that require optional features, or features specific to a certain container, to be marketed and packaged as such. For example, a control that requires the Visual Basic® data-bound list box should be marketed as a Visual Basic–specific control, because it cannot run in other containers.</p>
<p>
Currently, the following two function groups have been defined:
<ul type=disc>
<li>
Data binding<br><br></li>
<li>
"Simple frame" container controls</li>
</ul>
<h4>Data Binding</h4>
<p>
The OLE Controls architecture defines a <i>data binding</i> mechanism, whereby an OLE Control can specify that one or more of its properties is bindable. In most cases, a data-bound control should not absolutely require data binding, so that it could be inserted into a container that does not support data binding. Obviously, in such a situation, the functionality of the control may be reduced.</p>
<h4>"Simple Frame" Container Controls</h4>
<p>
A <i>container control</i> is an OLE control that visually contains (not using standard OLE control containment) other controls. A group box that contains a collection of radio buttons is an example of a container control. Container controls should set the OLEMISC_SIMPLEFRAME status bit, and should call its container's <b>ISimpleFrameSite</b> implementation. An OLE control container that supports container controls must implement <b>ISimpleFrameSite</b>.</p>
<h3>Overloading IPropertyNotifySink</h3>
<p>
Many OLE control containers implement a modeless property browsing window. If a control's properties are altered through the control's property pages, the control's properties can get out of sync with the container's view of those properties (the control is always right, of course). To ensure that it always has the current values for a control's properties, an OLE control container can implement the <b>IPropertyNotifySink</b> interface (data binding) and use it also to be notified that a control property has changed. This technique is optional, and is not required of OLE control containers or OLE controls.</p>
<p>
Note that a control should use <b>IPropertyNotifySink::OnRequestEdit</b> only for data binding; it is free to use <b>OnChanged</b> for either or both purposes.</p>
<h3>Container-Specific Private Interfaces</h3>
<p>
Some containers provide container-specific private interfaces for additional functionality or improved performance. Controls that rely on those container-specific interfaces must either only instantiate themselves in that container, or work without those container-specific interfaces in different containers. For example, Microsoft® Visual Basic® implements private interfaces that provide string formatting functionality to controls. If a control requires Visual Basic's private interfaces to run, it should destroy itself gracefully when the private interfaces are not available. If the control can function without the private interfaces, it should take appropriate action (such as warning the user of reduced functionality) but should continue to work.</p>
<h3>Multithreading Issues</h3>
<p>
Starting with Microsoft Windows® 95 and Windows NT™ version 3.51, OLE provides support for multithreading applications, allowing applications to make OLE calls from multiple threads. This multithreaded support is called the "apartment model." The apartment model requires that interface pointers be marshalled (using <b>CoMarshallInterface</b>, and <b>CoUnmarshallInterface</b>) when passed between threads. For more information about apartment-model threading, refer to the Microsoft Win32® Software Development Kit (SDK) documentation, and the OLEAPT sample in the Win32 SDK.</p>
<h3>Event Freezing</h3>
<p>
A container can notify a control that it is not ready to respond to events by calling <b>IOleControl::FreezeEvents(TRUE)</b>. It can unfreeze the events by calling <b>IOleControl::FreezeEvents(FALSE)</b>. When a container freezes events, it is freezing <i>event processing</i>, not <i>event receiving</i>; that is, a container can still receive events while events are frozen. If a container receives an event notification while its events are frozen, the container should ignore the event. No other action is appropriate.</p>
<p>
A control should always honor a container's call to <b>IOleControl::FreezeEvents(TRUE)</b>, and not fire events until the container calls <b>IOleControl::FreezeEvents(FALSE)</b>. While a container's event processing is frozen, a control should implement one of the following techniques:
<ul type=disc>
<li>
Discard all events that the control would have fired.<br><br></li>
<li>
Queue up all pending events and fire them after the container has called <b>IOleControl::FreezeEvents(FALSE)</b>.<br><br></li>
<li>
Queue up only relevant or important events and fire them after the container has called <b>IOleControl::FreezeEvents(FALSE)</b>.</li>
</ul>
<p>
Each technique is accepted and appropriate in different circumstances. The control developer is responsible for determining and implementing the appropriate technique.</p>
<h3>Container Controls</h3>
<p>
As described above, container controls are OLE Controls that visually contain other controls. The OLE Controls Architecture specifies the <b>ISimpleFrameSite</b> interface to enable container controls. Containers can also support container controls without supporting <b>ISimpleFrameSite</b>.</p>
<p>
In order to support container controls without implementing <b>ISimpleFrameSite</b>, an OLE control container must:
<ul type=disc>
<li>
Activate all controls at all times.<br><br></li>
<li>
Re-parent the contained controls to the hWnd of the containing control.<br><br></li>
<li>
Remain the parent of the container control.</li>
</ul>
<h3>WS_GROUP and WS_TABSTOP Flags in Controls</h3>
<p>
A control should not use the WS_GROUP and WS_TABSTOP flags internally; some containers rely on these flags to manage keyboard handling.</p>
<h3>Multiple Controls in One DLL</h3>
<p>
A single .OCX dynamic-link library (DLL) can contain any number of OLE controls, thus simplifying the distribution and use of a set of related controls.</p>
<p>
If you ship multiple controls in a single DLL, be sure to include the vendor name in <i>each</i> control name in the package. Including the vendors' names in each control name will enable users to easily identify controls within a package. For example, if you ship a DLL that implements three controls, Con1, Con2 and Con3, the control names should be:
<ul type=disc>
<li>
&lt;Your company name&gt; Con1 Control<br><br></li>
<li>
&lt;Your company name&gt; Con2 Control<br><br></li>
<li>
&lt;Your company name&gt; Con3 Control</li>
</ul>
<h3>IOleContainer::EnumObjects</h3>
<p>
This method is enumerated over all the OLE objects contained in a document or form, returning an interface pointer for each OLE object. The container must return pointers to each OLE object that shares the same container. Nested forms or nested controls must also be enumerated.</p>
<p>
Some containers implement "extender controls," which wrap non-OLE controls and then return pointers to these extender controls as a form is enumerated. This behavior enables OLE controls and OLE control containers to integrate well with non-OLE controls, and is thus recommended, but not required.</p>
<h3>Enhanced Metafiles</h3>
<p>
Not surprisingly, enhanced metafiles provide more functionality than standard metafiles, and using enhanced metafiles generally simplifies rendering code. An enhanced metafile device context (DC) is used in exactly the same way as a standard metafile DC. Enhanced metafiles are not available in 16-bit OLE. OLE supports enhanced metafiles, and includes backwards compatibility with standard metafiles and 16-bit applications.</p>
<p>
32-bit OLE control containers should use enhanced metafiles instead of standard metafiles.</p>
<h3>Licensing</h3>
<p>
In order to embed licensed controls successfully, OLE control containers must use <b>IClassFactory2</b> instead of <b>IClassFactory</b>. Several OLE creation and loading helper functions (for example, <b>OleLoad</b> and <b>CoCreateInsteance</b>) explicitly call <b>IClassFactory</b> and not <b>IClassFactory2</b>, and therefore cannot be used to create or load licensed OLE controls. OLE control containers should explicitly create and load OLE controls using <b>IClassFactory2</b>. In the future, Microsoft will update these standard APIs to use both <b>IClassFactory</b> and <b>IClassFactory2</b>, as appropriate.</p>
<h3>Dual Interfaces</h3>
<p>
OLE Automation enables an object to expose a set of methods in two ways: via the <b>IDispatch</b> interface, and through direct OLE vtable (pronounced vee-table) binding. <b>IDispatch</b> is used by most tools available today, and offers support for late binding to properties and methods. Vtable binding offers much higher performance because method is called directly instead of through <b>IDispatch::Invoke</b>. <b>IDispatch</b> offers late binding support; direct vtable binding offers a significant performance gain; both techniques are valuable and important in different scenarios. By labeling an interface as "dual" in the type library, an OLE Automation interface can either be used via <b>IDispatch</b>, or it can be bound to directly. Containers can thus choose the most appropriate technique. Support for dual interfaces is strongly recommended for both controls and containers.</p>
<h3>IPropertyBag and IPersistPropertyBag</h3>
<p>
<b>IPropertyBag</b> and <b>IPersistPropertyBag</b> optimize "save as text" mechanisms, and therefore are recommended for OLE control containers that implement a "save as text" mechanism. <b>IPropertyBag</b> is implemented by a container and is roughly analogous to <b>IStream</b>. <b>IPersistPropertyBag</b> is implemented by controls and is roughly analogous to <b>IPersistStream</b>.</p>
<h3>Guideline Relaxation for "Document-Style" Use of OLE Controls</h3>
<p>
Some containers will use OLE controls in traditional compound document scenarios. For example, a spreadsheet may allow a user to embed an OLE control into a worksheet. In such scenarios, the container would do keyboard handling differently, because the keyboard interface should remain consistent with the user's expectations of a spreadsheet. Consequently, OLE control containers that use OLE controls in compound document scenarios may relax the keyboard handling requirements described previously, according the following guidelines:
<ul type=disc>
<li>
Support for OLEMISC_ACTSLIKELABEL and OLEMISC_ACTSLIKEBUTTON is not required.<br><br></li>
<li>
Implementing the <b>DisplayAsDefault</b> ambient property is not required. (If it exists, it can return FALSE.)<br><br></li>
<li>
Implementing tab handling for buttons is not required.</li>
</ul>
<p>
Documentation for such products should inform users of differences in control handling in these different scenarios.</p>
</BODY>
</HTML>
