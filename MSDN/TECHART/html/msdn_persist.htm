<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Discardable Properties for Your Web Pages in Internet Explorer 4.0</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_persist"></a>Discardable Properties for Your Web Pages in Internet Explorer 4.0</h1>
<p>
Matt Oshry, Developer<br>
Michael Edwards, Developer Technology Engineer<br>
Microsoft Corporation</p>
<p>
November 1997<br>
Updated December 30, 1997<br>
(including a new discussion of security issues and code signing)</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5174">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the sample files associated with this technical article.</a></p>
<h4>Contents</h4>
<p>
<a href="#persist_intro">Introduction</a><br>
<a href="#persist_work">How Does It Work?</a><br>
<a href="#persist_use">How Do I Use It?</a><br>
<a href="#persist_cache">How Do I Make My COM Object Cacheable?</a><br>
<a href="#persist_samp">How Does the PropertyCache Sample Work?</a><br>
<a href="#persist_hey">Hey, I'm No C++ Programmer, Just Show Me How to Script It</a><br>
<a href="#persist_just">Just Give Me the Samples Already!</a><br>
<a href="#persist_summ">Summary</a></p>
<h3><a name="persist_intro"></a>Introduction</h3>
<p>
Microsoft® Internet Explorer version 4.0 includes a new feature to save temporary data from one Web page, and access it from any other page, within the same browser window. Multipage processes (such as registration or online shopping) often require information that was entered by the user on previous pages, but doesn't need to be available longer than one browser session. The new <b>IDiscardableBrowserProperty</b> interface allows data to be contained in a very lightweight object that is automatically discarded when the browser window is closed, or when the object has not been accessed for over ten minutes.</p>
<p>
This article begins by describing how the <b>IDiscardableBrowserProperty </b>interface works, then goes on to explain how you can enhance an existing COM object to support it. After that, for C++ developers we describe some important implementation details for the PropertyCache control we've provided. If you aren't the COM type, and just want to use this new feature from script, don't despair. After reading the next section on how this feature works, skip that scary COM stuff and learn how to cache data in Hypertext Markup Language (HTML) scripts.</p>
<h3><a name="persist_work"></a>How Does It Work?</h3>
<p>
If you have read the Internet Client Software Development Kit (SDK) documentation (see the MSDN™ Library, SDK Documentation bin for the Internet Client documentation) on the WebBrowser Control, you know that Internet Explorer 4.0 includes the new <b>IWebBrowser2 </b>interface for adding Internet browsing functionality to your application. And, if you've been around the block a couple of times, you might remember the old Internet Explorer 3.<i>x</i> <b>IWebBrowserApp</b> interface was replaced by <b>IWebBrowser2</b>. <b>IWebBrowserApp</b> included the <b>PutProperty</b> method to cache a property that can be retrieved later with <b>GetProperty</b>. You can read more about these methods in the Internet Client SDK, but let's look at their function prototypes right here:</p>
<pre><code>HRESULT PutProperty(BSTR szProperty, VARIANT vtValue);
HRESULT GetProperty(BSTR szProperty, VARIANT FAR* pvtValue);
// szProperty is a caller-allocated buffer with a unique property name.
// vtValue is a VARIANT value associated with the given property.
</code></pre>
<p>
As you can see, since Internet Explorer 3.0 you've had the ability to store arbitrary data (VARIANT objects) as properties of a browser window. But you may not know (unless you have a pretty good testing staff) that this mechanism is not very useful for Microsoft ActiveX® controls or documents, because the Internet Explorer 3.0 browser does not have the capability to void these properties after a period of time. Therefore, stored properties hang around until the browser window is closed, which might be a long time (while the client's available memory slowly dissipates).</p>
<p>
The <b>IWebBrowser2</b> implementation for <b>GetProperty</b> and <b>PutProperty</b> fixes this problem by making the stored property discardable. All properties that are associated with a browser window are regularly scanned for discarding. A property is considered discardable if the page that stored it has been unloaded, and more than 10 minutes have elapsed since the property was last accessed. Properties associated with a given browser window are not applied to other windows. Of course, all the properties associated with a given browser window are discarded when the window is closed.</p>
<p>
To take advantage of this enhanced property cache feature, you need to package the data into a COM object that supports the <b>IDiscardableBrowserProperty</b> interface. That's because <b>IWebBrowser2::PutProperty</b> calls <b>QueryInterface</b> on the passed VARIANT object for an <b>IID_IDiscardableBrowserProperty</b> interface. If the call is successful (the interface is supported), the browser will consider the object to be discardable.</p>
<h3><a name="persist_use"></a>How Do I Use It?</h3>
<p>
If you want to do something as simple as remembering whether the user has logged on, or whether they clicked something on a previous page, then some scripting examples are probably what you're most interested in seeing. However, if you have something more complicated in mind, then you may need to incorporate discardable functionality directly into objects you want to cache for other pages. So, let's consider both perspectives, starting with the person who is just aching to store data for later retrieval.</p>
<h3><a name="persist_cache"></a>How Do I Make My COM Object Cacheable?</h3>
<p>
Storing any COM object as a discardable property of the browser window is easy. The object needs only to update its implementation of <b>IUnknown</b> to respond to a <b>QueryInterface</b> for <b>IID_IDiscardableBrowserProperty</b> by returning its <b>IUnknown</b> pointer.</p>
<p>
We're going to explain how to do this by using Active Template Library (ATL) code examples. If you are not familiar with ATL, that's OK, the explanation will still make sense to you as long as you have some familiarity with COM. However, if you get confused (or you are just the anal type), there's an MSDN Library article called "The Active Template Library Makes Building COM Objects a Joy" (MSDN Library, Periodicals) by Don Box, that will introduce you to ATL (the "Implementing <b>IUnknown</b>" section is most relevant to the following discussion).</p>
<p>
If you create a simple COM object using ATL, the interface map in your class declaration (which specifies how ATL should implement your <b>QueryInterface</b> method) looks like this:</p>
<pre><code>BEGIN_COM_MAP(CYourData)
COM_INTERFACE_ENTRY(IYourData)
END_COM_MAP( )
</code></pre>
<p>
If you want to be able to store an instance of CYourData as a discardable property of the browser window, all you have to do is modify the interface map to handle queries for the <b>IID_IDiscardableBrowserProperty</b> interface:</p>
<pre><code>// shlguid.h defines the <b>IID_IDiscardableBrowserProperty</b> GUID.
#include &lt;shlguid.h&gt;

BEGIN_COM_MAP(CYourData)
COM_INTERFACE_ENTRY(IYourData)
// tell ATL to return our <b>IUnknown</b> when asked for the discardable interface
COM_INTERFACE_ENTRY(IID_IDiscardableBrowserProperty, CYourData)
END_COM_MAP( )
</code></pre>
<p>
Then, to cache an instance of CYourData, you just need to create a VARIANT object to point to your object, give it a unique property name, and store it:</p>
<pre><code>#include "stdafx.h"&nbsp;&nbsp; // VARIANT, V_* and other "standard" OLE goodies.
#include &lt;exdisp.h&gt; &nbsp; // IWebBrowserXXX

static BSTR szName = "some GUID generated exclusively for this property";

HRESULT SaveIt(IYourData * pData, IWebBrowser2 * pWebBrowser) {

 &nbsp; VARIANT vCache;
 &nbsp; LPUNKNOWN pUnknown;

// Set the VARIANT's type to an <b>IUnknown</b> pointer.
 &nbsp; V_VT(&amp;vCache) = VT_UNKNOWN;
 &nbsp; // Make the VARIANT point at our object.
 &nbsp; pData-&gt;QueryInterface(IID_IUnknown, (LPVOID*)&amp;pUnknown);
 &nbsp; V_UNKNOWN(&amp;vCache) = pUnknown;

 &nbsp; // <b>IWebBrowser2</b> will QI vCache for the discardable interface,
 &nbsp; // and if successful, automatically retire it if it's not accessed
 &nbsp; // for a while.
 &nbsp; return pWebBrowser-&gt;PutProperty(szName, vCache);
}
</code></pre>
<p>
To get the object back later:</p>
<pre><code>HRESULT GetItBack(IYourData * pData, IWebBrowser2 * pWebBrowser) {

 &nbsp; VARIANT vCache;
 &nbsp; HRESULT hr;

 &nbsp; // Retrieve the VARIANT we stashed.
 &nbsp; hr = pWebBrowser-&gt;GetProperty(szName, &amp;vCache);

 &nbsp; // Get our object out of it.
 &nbsp; if (SUCCEEDED(hr) &amp;&amp; V_VT(&amp;vCache) == VT_UNKNOWN)
 &nbsp; hr = V_UNKNOWN(&amp;vCache)-&gt;QueryInterface(IID_IYourData, (LPVOID*)&amp;pData);

VariantClear(&amp;vCache);

 &nbsp; return hr;
}&nbsp;&nbsp; 
</code></pre>
<p>
OK, we're cheating just a bit here. You cynical types are wondering how the heck you're supposed to come up with a pointer to the <b>IWebBrowser2</b> object for your browser window. That's a good question. There's an easy answer, too, and we'll use ATL to demonstrate.</p>
<p>
In addition to providing objects with their implementation for <b>IUnknown</b>, ATL provides a default implementation of the <b>IObjectWithSite</b> interface, <b>IObjectWithSiteImpl</b>, which provides an object with a pointer to its activation site (in this case, the browser window). To use ATL's built-in implementation of <b>IObjectWithSiteImpl</b>, you simply add the implementation to the base class list for your object, and add an entry to the interface map to expose the implementation's interface via <b>QueryInterface</b>.</p>
<p>
For example, if CYourObject is an object that you are loading on your Web page via an &lt;OBJECT&gt; tag, and you want to be able to get a pointer to the <b>IWebBrowser2</b> object, do the following in your class declaration:</p>
<pre><code>class CYourObject :
 &nbsp; // Other base classes for CYourObject go here.
 &nbsp; public IObjectWithSiteImpl&lt;CYourObject&gt;
{
...
BEGIN_COM_MAP(CYourObject)
COM_INTERFACE_ENTRY(IYourObject)
// Interfaces for other base classes in CYourObject go here.
COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
 END_COM_MAP( )
...
};
</code></pre>
<p>
After the browser loads your object, <b>IObjectWithSiteImpl</b> provides the <i>m_spUnkSite</i> member variable, which can be used to obtain a pointer to the <b>IWebBrowser2</b> interface for your browser window:</p>
<pre><code>#include &lt;servprov.h&gt; // <b>IServiceProvider</b>

HRESULT GetWebBrowser(CWebBrowser2 * pWebBrowser2)
{
 &nbsp; if (!m_spUnkSite)
 &nbsp;&nbsp;&nbsp;&nbsp; return S_FALSE;

 &nbsp; // CComQIPtr is an ATL helper macro that declares spSP as a pointer to
 &nbsp; // <b>IServiceProvider</b>. (And takes care of reference counting for us too!)
 &nbsp; // http://www.microsoft.com/msdn/sdk/inetsdk/help/compdev/comobj/comobj.htm
 &nbsp; // for IServiceProvider documentation.
 &nbsp; CComQIPtr&lt;IServiceProvider, &amp;IID_IServiceProvider&gt; spSP(m_spUnkSite);

 &nbsp; return spSP-&gt;QueryService(IID_IWebBrowserApp, IID_IWebBrowser2, (LPVOID*)&amp; pWebBrowser2);
 }
</code></pre>
<p>
Typically, <b>SaveIt</b>, <b>GetItBack</b>, and <b>GetWebBrowser</b> would all be methods in the CYourObject class, and CYourObject would create the instance of CYourData that encapsulated the data you wanted to cache. You could then use scripting events for page exit (<b>onbeforeunload</b>) to save your object, and page enter (<b>onload</b>) to reload the object on a subsequent page that needed the saved information.</p>
<p>
For information on how to do the scripting, and to learn about the simple PropertyCache ATL sample that Matt put together, read on.</p>
<h3><a name="persist_samp"></a>How Does the PropertyCache Sample Work?</h3>
<p>
There's nothing like decent sample code to help you get something working, so we included the source code for the PropertyCache control with this article. But before you go off and start changing the code, let's go over some important caveats.</p>
<p>
First, to build this project you need the Internet Client SDK installed on your computer. Also, make sure the libs and includes from the Internet Client SDK are searched in front of those supplied elsewhere (in Microsoft Developer Studio® you can do this from the <b>Tools</b> menu by choosing <b>Options</b>, and <b>Directories</b>).</p>
<p>
If you read the above section on how to modify an ATL object to masquerade as a discardable browser object, then the source code in the PropertyCache project will look very familiar. There are two classes in PropertyCache. CDiscardable is a bare-bones COM object, an implementation of <b>IUnknown</b> that supports the <b>IID_IDiscardableBrowserProperty</b> interface and a single VARIANT property (similar to the CYourData class from the above example code). CPropertyCache is also a bare-bones COM object with methods that accept and return a VARIANT. Since CPropertyCache inherits from <b>IObjectWithSiteImpl</b>, it goes on your Web page (and thus is similar to the <b>CYourObject</b> class from the above example code).</p>
<p>
The PropertyCache project builds a COM server named PCACHE.DLL. When PropertyCache is loaded on your Web page (via an &lt;OBJECT&gt; tag), the browser creates a CPropertyCache object. You can invoke its <b>CacheData</b> method to save script data, and <b>RetrieveCachedData</b> to get the data back later. When your script calls <b>CacheData</b>, the control dynamically creates a CDiscardable object, sticks the passed VARIANT item into it, and hands it off to the browser window (via <b>PutProperty</b> on the <b>IWebBrowser2</b> object). The browser window increments the reference count for the discardable object, so when the PropertyCache control releases its own reference, the browser window is left with the only remaining reference. The browser window keeps track of when the object is accessed (via <b>GetProperty</b> on the <b>IWebBrowser2</b> object called by <b>RetrieveCachedData</b>), and every time a page completes loading it checks whether any objects can be discarded. If a discardable object has not been accessed for 10 minutes it is discarded. This means that if your script caches some data from one page when it unloads, and accesses it from another page, you'll just need to finish loading the second page within 10 minutes of leaving the first page. You can't modify the 10-minute parameter.</p>
<h4>What if I need to modify the PropertyCache sample?</h4>
<p>
If you plan to modify the PropertyCache source code in order to use a variation of it on your own pages, you will need to make three easy but important changes to make sure your control is unique and secure.</p>
<p>
First, you'll need to create your own Globally Unique Identifier (GUID) for the property name. Why? Security. If you don't change the GUID, anyone who reads this article and wants to hack your data will be able to by stripping off my GUID identifier. The GUID for the property name is defined in the file PageAcc.CPP:</p>
<pre><code>// The gc_szKey string provides a unique property name. This GUID is
// concatenated to the property name passed to the <b>CacheData</b> method
// to ensure that property names are secure.
// Naturally, anybody reusing this sample code will want to change
// this GUID by generating one of their own(use the GUIDGEN.exe
// utility that ships with Developer Studio).
const OLECHAR gc_szKey[] = OLESTR("{your_GUID}");
</code></pre>
<p>
Note this isn't the actual GUID for gc_szKey used in the downloadable, code-signed PropertyCache control included with this article. Using a secret value for that GUID ensures that the property names used in your script can't be viewed by a hacker intent on stealing cached data.</p>
<p>
Second, you need to change the GUIDs used to identify the classes, interfaces, and type library for the PropertyCache control. Why? The browser distinguishes between these control elements by their IDs. If your control uses the same IDs as some other control that is already on the local computer, the browser will get confused. These five GUIDs are identified by the uiid() macros in the pcache.IDL file, such as this one for the <b>IPropertyCache</b> interface ID:</p>
<pre><code>[
 object,
 uuid(4F157AE1-3F9A-11D1-9E78-00AA00BBF119),
 dual,
 helpstring("IPropertyCache Interface"),
 pointer_default(unique)
]
interface IPropertyCache : IDispatch
{
 [id(1), helpstring("Cache some arbitrary data")]
 HRESULT CacheData([in] BSTR bstrPropName, [in] VARIANT vData, \
 [in, optional] long lSecurityLevel);
 [id(2), helpstring("Retrieve some arbitrary data")]
 HRESULT RetrieveCachedData([in] BSTR bstrPropName, \
 [out, retval] VARIANT* pvData);
};
</code></pre>
<h4>What if I want to use the PropertyCache control from C++?</h4>
<p>
If you want to write C++ code to use the PropertyCache object as is, then you'll need to include the PCACHE.H header file and link with the pcache.LIB import library included with the sample files for this article. The pcache.DLL file will be a dependent DLL to your code, so you will have to make sure the library is part of your download package.</p>
<p>
The following ATL code will create a PropertyCache object and store a property with the default security setting:</p>
<pre><code>#include "stdafx.h"
#include "pcache.h"
...
VARIANT vCache;
// Fill vCache with something.
CComObject* pCache = new CComObject;
if (pCache)
{
 &nbsp; pCache-&gt;CacheData(L"aUniquePropertyName", vCache);
 &nbsp; pCache-&gt;Release();
}
// <b>CacheData()</b> makes a copy of vCache, so you need to free it.
...
</code></pre>
<p>
Then, to retrieve the property later, do this:</p>
<pre><code>#include "stdafx.h"
#include "pcache.h"
...
CComObject* pCache = new CComObject;
if (pCache)
{
 &nbsp; VARIANT vCache;
 &nbsp; pCache-&gt;RetrieveCachedData(L"aUniquePropertyName", &amp;vCache);
 &nbsp; pCache-&gt;Release();
}
// <b>RetrieveCachedData()</b> copies the data into vCache
// (so free it when you're done).
...
</code></pre>
<h3><a name="persist_hey"></a>Hey, I'm no C++ Programmer, Just Show Me How to Script It</h3>
<p>
If you're like many Web authors, you like to do as much as you can with HTML and script (especially when somebody is offering free sample code). In that case, you'll really appreciate the PropertyCache sample we wrote to give away with this article. With this sample, you can save data stored in script variables on your Web page, and access the data from another page in that browser window. We included the source code for the PropertyCache sample for you C++ programmers, but the rest of you (who just want to script it), can use the version we already built and code-signed. To use the PropertyCache control insert this HTML in the body of your HTML document:</p>
<p>
<code>&lt;!-- The data caching and retrieving control --&gt; &lt;OBJECT CLASSID="clsid:68A12882-7584-11d1-A259-00C04FD97350" CODEBASE=pcache.cab#Version=1,0,0,1 HEIGHT=0 WIDTH=0 ID=oCacher&gt;</code></p>
<p>
Note the CODEBASE parameter refers to a CABinet (.CAB) file. We code-signed the PropertyCache control with a Microsoft digital signature, so the control is actually <i>inside</i> pcache.CAB. (If you want to know what a CAB file is, go to the Microsoft Site Builder Network Web site at <a href="http://www.microsoft.com/workshop/prog/cab/">http://www.microsoft.com/workshop/prog/cab/</a>.) Since Microsoft is code-signing the PropertyCache control, when your viewers are asked whether they should download it, they'll know the control was developed by Microsoft. Hopefully, knowing this will give your customers a profound sense of reassurance! The pcache.CAB file is included in the HTML sample downloads below.</p>
<p>
While we are on the subject of security, let's talk about why this control is very secure. First, the PropertyCache control doesn't access any resources on the customer's local computer. Thus, there is no way that a malicious Web author can misuse this control to illegally access your local resources. But in addition to protecting your customer's local resources from hackers, you also need to protect the data that you cache using the PropertyCache control. For example, if you are going to use this control to implement a shopping cart on a commerce page, you probably don't want some other page to be able to peek into that shopping cart and see what items somebody is purchasing. For this reason, you must include a security parameter when you cache data using the PropertyCache control. This parameter indicates how strictly you want to limit access to the data, including whether you will allow the data to be accessed by any page in your domain, by any page in your virtual root, or only by the page that cached the data in the first place (this last, most restrictive setting, is the default). Under no circumstances will a page that is not on your domain be able to access the data.</p>
<p>
From a performance standpoint, it is more efficient to add a single property to the browser than it is to write many properties. So, if you have a lot of stuff to save, you should put it all in an array variable and cache the array (although you can also cache any JavaScript variable or object). Typically, your script will accumulate data from user interaction with the page, and then cache it on page exit:</p>
<pre><code>&lt;SCRIPT for=window event=onbeforeunload language=javascript
 // Security == 1 // Allow any page on your domain to read the data.
 // Security == 2 // Allow any page in your vroot to read the data.
 // Security == 3 // Allow only this page to read the data.
 var Security = 2;
 aList = new Array();
 populate(aList);
 oCacher.CacheData("aUniquePropertyName", aList, Security);
&lt;/SCRIPT&gt;
</code></pre>
<p>
A subsequent page that needs previously cached data would then access it while the page is loading:</p>
<pre><code>&lt;SCRIPT for=window event=onload language=javascript
 var aList = oCacher.RetrieveCachedData("aUniquePropertyName");
 if (aList == null) {
 // Must've been greater than 10 minutes since the data was stored
 // or last accessed.
 }
&lt;/SCRIPT&gt;
</code></pre>
<p>
<b>CacheData()</b> and <b>RetrieveCachedData()</b> are the only methods for this control, and there are no events or properties. Pretty simple, huh?</p>
<h3><a name="persist_just"></a>Just Give Me the Samples Already!</h3>
<p>
If you copy the samples associated with this article, you can play with a sample that keeps track of whether a user has already logged in to your Web site, or you can play with a sample that uses an array variable to keep track of products a user wants to buy from your store. This sample also uses the Tabular Data Control to manipulate and present shopping items from a comma-delimited list. Remember that you need to be using Internet Explorer 4.0 for the samples to work!</p>
<h3><a name="persist_summ"></a>Summary</h3>
<p>
Even though today's Web pages are often offered in the context of a larger site, they tend to be pretty stand-alone views of information. That is, what a user does on one page in a given site doesn't impact what they see or do in other pages on that site. However, in cutting-edge sites like Microsoft Expedia (<a href="http://expedia.com/daily/home/default.hts?">http://expedia.com/daily/home/default.hts?</a>), you are beginning to see multiple Web pages offered as a single unit that share important information and events. In this context, what a user does on one page has very much to do with what they see and do on other pages in that site. Thus, with the discardable browser property feature, Internet Explorer 4.0 introduces the next generation in data-sharing functionality that is needed to turn an unconnected set of Web pages into something more akin to an integrated application.</p>
<p>
So get busy!</p>
</BODY>
</HTML>
