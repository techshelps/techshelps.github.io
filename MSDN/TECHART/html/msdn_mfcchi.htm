<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Mix and Match C with C++ and MFC</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_mfcchi"></a></sup>Mix and Match C with C++ and MFC</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: July 12, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="2885">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the MFCPROPS sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
The Microsoft® Foundation Class (MFC) library provides a set of C++ classes that encapsulate the functionality of applications written for the Microsoft Windows® operating system. The tools that accompany Microsoft Visual C++™ provide developers with a working application skeleton containing a main window, menus, toolbars, status bars, and other items. This functionality alone is tempting for developers who would like to let the tool do the grunt work for them. However, for various reasons, an application may contain areas that need to remain in C rather than being ported to C++ or MFC. This article discusses the steps required to port a simple application from C to C++, and explains how to mix and match C code with C++ and MFC code to take advantage of MFC’s built-in functionality.</p>
<h2>Introduction</h2>
<p>
Just having finished a long series of articles covering the new common controls in the next version of the Microsoft® Windows® operating system (called Windows 95), I was looking for an interesting topic to cover in my next article. I decided to take a walk down the hall to Kyle Marsh’s office and ask his opinion. This was my first mistake. You see, Kyle is known for figuring out and suggesting exactly what you have been dreading to do. He reminded me that I had promised to learn and use C++ and the Microsoft Foundation Class (MFC) library in my samples. He suggested that I make good on that promise and start porting my samples from C to C++ and MFC. Because many developers will want to write MFC Windows 95–based applications, he advised me to learn how to use the new Windows 95 common controls, such as property sheets and toolbars, by mixing C, C++, and MFC. </p>
<h2>Overview of MFC</h2>
<p>
This section gives a brief overview of MFC, for those of you who haven’t taken the time to read up on it. Those of you who are already familiar with MFC should feel free to skip this section.</p>
<p>
The classes in MFC create an <i>application framework</i>. A developer uses this framework as the basis for building an application for Windows. This framework defines the skeleton of an application and implements standard user-interface components such as toolbars, status bars, and dialog boxes to be placed on the skeleton. The developer then only needs to fill in the rest of the skeleton with code that is specific to the application’s functionality. AppWizard, which is a major time-saver that is built into Visual C++™, creates the files for a fully functional starter application. You can use the resource editor, which is also built into Visual C++, to design dialog boxes, and the ClassWizard tool to create classes for those dialog boxes.</p>
<p>
Version 3.0 of the MFC framework supports 32-bit programming for Win32® platforms, including Microsoft Windows NT™ version 3.5 and later. MFC’s Win32 support also includes multithreading, which can be used to create applications that run under Windows 95.</p>
<p>
Aside from the fact that MFC 3.0 and Visual C++ offer major time savings in the creation of a Windows-based application, MFC also makes it much easier to write applications that specifically use OLE. You can make your application an OLE Visual Editing container, an OLE Visual Editing server, or both, and you can add OLE Automation so that other applications can use objects from your application or even drive it remotely.</p>
<p>
MFC 3.0 also supplies a set of database classes that simplify writing data access applications. This allows an application developer to use the database classes to connect to databases through an open database connectivity (ODBC) driver, select records from tables, and display record information in an on-screen format.</p>
<p>
Lastly, MFC 3.0 is fully enabled for writing applications that use Unicode™ and multibyte character sets (MBCS), specifically double-byte character sets (DBCS). </p>
<h2>Porting a Property Sheet</h2>
<p>
I decided that the first sample I would port would be my new property sheet sample that accompanies the <a href="msdn_commctl6.htm">“Win32 Common Controls, Part 6: Tab Controls and Property Sheets”</a> technical article in the Microsoft Development Library. A property sheet is a special tabbed dialog box that an application can implement to logically group dialog functions together. The Windows 95 shell uses property sheets to view and set the properties of objects within the system. OLE custom controls also use property sheets to set control properties, and Visual C++ version 2.0 uses a property sheet for project settings. Property sheets contain tabs that allow the user to move from one dialog box (<i>page</i>) within the property sheet to another without fully dismissing the dialogs. The figure below illustrates a simple property sheet that sets the properties of a slider control.</p>
<p>
<img src="mfcchi_1.gif" border=0></p>
<p class=label>
<b>A Simple Property Sheet</b></p>
<h3>My Property Sheet Has No Class</h3>
<p>
The first thing I discovered was that no special classes currently exist for the new Windows 95 controls. (A version of MFC to be released after Windows 95 will contain these classes, so do not despair.) MFC has several new classes for MFC property sheets, toolbars, and status bars, but I wanted to use the new Windows 95 property sheet and its new controls. This left me with two choices: 
<ul type=disc>
<li>
Write my own class library or wrapper (which may not match the class library that will be released with a future version of MFC); or<br><br></li>
<li>
Mix C code with C++ and MFC code.</li>
</ul>
<p>
I decided to take the mix-and-match approach. The remainder of this article explains the steps I took to port, mix, and match code. You can, of course, change the order—this is just the way I decided to do it.</p>
<h2>Step One: Generate a Project with AppWizard</h2>
<p>
When I started this project, I knew I wanted to use the tools that are included with Visual C++ 2.0 as much as possible. Why? Because I knew how much code the tools would generate automatically, and I wanted to use the same tools as other developers. So, the first step was to create a new project by selecting File New and choosing Project from the list box. I was prompted for the type and name of the project that I wanted to create. I also decided not to add any new features at the current time. I figured that there was plenty of time for this later on, once I was comfortable with C++ and MFC. I entered the project name <b>MFCPROPS</b> and selected the following options (dubbed the “Just Say No” options):
<ol>
<li>
Single-document interface (SDI)<br><br></li>
<li>
No database support<br><br></li>
<li>
No OLE Compound Document support<br><br></li>
<li>
No OLE Automation<br><br></li>
<li>
No toolbar, no status bar, no printing, no context-sensitive help, and no 3-D controls<br><br></li>
<li>
Yes for comments<br><br></li>
<li>
Use a Visual C++ make file<br><br></li>
<li>
Use MFC in a static library</li>
</ol>
<p>
When I clicked Finish, AppWizard displayed a list of the files it would create. A brief explanation of the files that AppWizard creates is also provided in the README.TXT file, which you will find in the same directory as the project files. Here’s a list of the files that AppWizard created for me:
<ul type=disc>
<li>
MFCPROPS.MAK: This project file is compatible with the Visual C++ development environment. It is also compatible with the NMAKE program provided with Visual C++.<br><br></li>
<li>
MFCPROPS.H: This is the main header file for the application. It includes other project-specific headers (including RESOURCE.H) and declares the <b>CMfcpropsApp</b> application class.<br><br></li>
<li>
MFCPROPS.CPP: This is the main application source file that contains the <b>CMfcpropsApp</b> application class.<br><br></li>
<li>
MFCPROPS.RC: This is a listing of all of the Microsoft Windows resources the program uses. These resources are stored in the RES subdirectory. This file can be edited directly in the Visual C++ development environment.<br><br></li>
<li>
RES\MFCPROPS.ICO: This is a default icon file that is used as the application's icon. It is included by the main resource file MFCPROPS.RC.<br><br></li>
<li>
RES\MFCPROPS.RC2: This file contains resources that are not edited by the Visual C++ development environment. You should place all resources that the resource editor cannot edit in this file.<br><br></li>
<li>
MFCPROPS.CLW: This file contains information that ClassWizard uses to edit existing classes or add new classes. ClassWizard also uses this file to store information needed to create and edit message maps and dialog data maps, and to create prototype member functions.<br><br></li>
<li>
MAINFRM.H, MAINFRM.CPP: These files contain the <b>CMainFrame</b> frame class, which is derived from <b>CFrameWnd</b> and controls all SDI frame features.<br><br></li>
<li>
MFCPRDOC.H, MFCPRDOC.CPP: These files contain the code that manages the document, including your <b>CMfcpropsDoc</b> class. Edit these files to add your special document data and to implement file saving and loading (using <b>CMfcpropsDoc::Serialize</b>).<br><br></li>
<li>
MFCPRVW.H, MFCPRVW.CPP: These files contain the code that manages the view of the document, including your <b>CMfcpropsView</b> class. <b>CMfcpropsView</b> objects are used to view <b>CMfcpropsDoc</b> objects.<br><br></li>
<li>
STDAFX.H, STDAFX.CPP: These files are used to build a precompiled header (.PCH) file named MFCPROPS.PCH and a precompiled types file named STDAFX.OBJ. <br><br></li>
<li>
RESOURCE.H: This is the standard header file that defines new resource identifiers. Visual C++ reads and updates this file.</li>
</ul>
<p>
If you look at the files AppWizard creates for you, you’ll see lots of areas with the "TODO" tag. These tags indicate the parts of the source code that you should customize for your own use. At this point, you have a complete application skeleton that you can build and run. The application does not do much, but you will notice that it does contain a main window with standard menus. Just think of all the time you can save by having this code generated for you, rather than having to plow through the dependencies and name changes yourself.</p>
<h2>Step Two: Make Resource Changes</h2>
<p>
AppWizard automatically generates several menu items that I did not use in my sample, so the first thing I did was to remove all the items I did not support. I removed all the File menu items, with the exception of the Exit command, and I removed the Edit and View menus entirely. I then changed the name of the File menu to Options and added in the one item I wanted to support: Slider properties with the identifier equal to IDM_PROPERTIES. This gave me the menu configuration I wanted.</p>
<p>
Next, I removed the accelerator table entirely. I could have removed only the accelerators for the commands that I eliminated, and added accelerators for my new menu items, but I wasn’t going to add any functionality yet, so I didn’t.</p>
<h3>Dialog Changes</h3>
<p>
I had to decide what to do about the dialog boxes I needed. Because I was porting a property sheet sample that I had already built, I had a choice between simply including the old dialog boxes in the MFCPROPS.RC2 file and the definitions in RESOURCE.H, or using the dialog editor that comes with Visual C++ to generate the property-sheet pages. I wanted to become as familiar as possible with the new tools, so I went ahead and regenerated the pages using the dialog editor. </p>
<p>
Regenerating the pages was a fairly simple task, but I had to undo a few things that the dialog editor did automatically. Because I was creating pages, I deleted the OK and Cancel buttons from the default dialog box, then created my dialog box in the standard way. The Visual C++ 2.0 tools do not support Windows 95 fully yet, so I made one manual change to my dialog boxes: I added the DS_3DLOOK style to each page definition to get that neat new 3-D look that all the new Windows 95 controls have.</p>
<h3>Gotcha! Check Your Link Options</h3>
<p>
The last thing I did before compiling my code was to change the Link options for my project. I chose the Settings from the Project menu, clicked the Link tab, then selected <i>Win32 Debug</i> in the Settings For box. The Project Options box contains the following line: </p>
<pre><code>/SUBSYSTEM:Windows
</code></pre>
<p>
I changed this line as follows, to mark my executable as a Windows 95 executable:</p>
<pre><code>/SUBSYSTEM:Windows,4.0
</code></pre>
<p>
I made the same change for the Win32 release version of my project. Why? In the current version of Visual C++ 2.0, the default executable is marked as a Windows 3.<i>x</i> executable. This is simply marvelous for an executable that will run under Windows 3.<i>x</i> or Windows NT, but if you try to run this executable under Windows 95, the operating system will assume that your executable does not know how to handle some of the new Windows 95 messages such as WM_NOTIFY (a key new message used in the Windows 95 shell). As a result, although your application will build, it will not receive WM_NOTIFY messages, and you’ll think you did something wrong. This problem made me bang my head against the wall until I figured out what was going on and marked my executable properly.</p>
<h3>Recompile and Run</h3>
<p>
That just about says it all. At this point, I built the project and ran it. All of my changes were now in place. Of course, I still hadn’t added my property-sheet page manipulation, but I did have something that was incredibly fast and easy to put together.</p>
<h2>Step Three: Add My C Code</h2>
<p>
I took my original sample files and copied them over to my working directory and renamed the .C file to .CPP. Then I ripped out the initialization code (the code AppWizard created for me already took care of initialization) and removed my window procedure. This left me with the functions that support the property-sheet creation and manage the property-sheet pages. I also had to write a function that would create my slider because this code was originally in my main window’s window procedure. I wrapped the code within a declaration that indicated this was C code, and I was nearly done. Here is the C code I used:</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;commctrl.h&gt;
#include &lt;prsht.h&gt;
#include "resource.h"

extern "C"{

BOOL APIENTRY Range(HWND, UINT, UINT, LONG);
BOOL APIENTRY PageSize(HWND, UINT, UINT, LONG);&nbsp; 
VOID CreateSlider(HWND, HINSTANCE);
int CreatePropertySheet(HWND, HINSTANCE);

HWND hWndSlider;

// Create the slider control.
VOID CreateSlider(HWND hWnd, HINSTANCE hInst)
{
  // Ensure that the common control library has been loaded.
  InitCommonControls();

  // Create the slider control.
  hWndSlider&nbsp; = CreateWindow(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACKBAR_CLASS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_CHILD | WS_VISIBLE | TBS_AUTOTICKS | TBS_TOP | TBS_ENABLESELRANGE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10,100,200,20,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hWnd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (HMENU)ID_SLIDER,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInst,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);
  if (hWndSlider == NULL)
 &nbsp;&nbsp; MessageBox (NULL, "Slider not created!", NULL, MB_OK );

  // Set the default range.
  SendMessage( hWndSlider, TBM_SETRANGE, TRUE, MAKELONG(1,10));

  // Set the selection. 
  SendMessage( hWndSlider, TBM_SETSEL, TRUE, MAKELONG(3,5));

  return;
}
// Function that handles the Range tab.
BOOL APIENTRY Range(HWND hDlg, UINT message, UINT wParam,
  LONG lParam)
{
  BOOL bErr;
  static UINT uMin, uMax, uMinSave, uMaxSave;

  switch (message)
  {
 &nbsp;&nbsp;&nbsp; case WM_NOTIFY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (((NMHDR FAR *) lParam)-&gt;code) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case PSN_HASHELP:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Indicate that the Help button is not supported.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case PSN_SETACTIVE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Initialize the controls.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMinSave = SendMessage( hWndSlider, TBM_GETRANGEMIN, 0L, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMaxSave = SendMessage( hWndSlider, TBM_GETRANGEMAX, 0L, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetDlgItemInt(hDlg, IDE_MIN, uMinSave, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetDlgItemInt(hDlg, IDE_MAX, uMaxSave, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case PSN_APPLY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMin = GetDlgItemInt(hDlg, IDE_MIN, &amp;bErr, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMax = GetDlgItemInt(hDlg, IDE_MAX, &amp;bErr, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage( hWndSlider, TBM_SETRANGE, TRUE, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAKELONG(uMin, uMax));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case PSN_KILLACTIVE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowLong(hDlg,&nbsp; DWL_MSGRESULT, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case PSN_RESET:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reset to the original values.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage( hWndSlider, TBM_SETRANGE, TRUE, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAKELONG(uMinSave, uMaxSave));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; }
  }
  return (FALSE);&nbsp;&nbsp; 

}
// Function for handling Page Size tab.
BOOL APIENTRY PageSize(HWND hDlg, UINT message, UINT wParam,
  LONG lParam)
{
  BOOL bErr;
  static UINT uPage, uPageSave;
  static UINT uLine, uLineSave;
  static PROPSHEETPAGE * ps;

  switch (message)
  {
 &nbsp;&nbsp; case WM_NOTIFY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (((NMHDR FAR *) lParam)-&gt;code) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case PSN_HASHELP:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Indicate that the Help button is not supported.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case PSN_SETACTIVE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Initialize the controls.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uPageSave = SendMessage( hWndSlider, TBM_GETPAGESIZE, 0L, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uLineSave = SendMessage( hWndSlider, TBM_GETLINESIZE, 0L, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetDlgItemInt(hDlg, IDE_LINE, uLineSave, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetDlgItemInt(hDlg, IDE_PAGE, uPageSave, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case PSN_APPLY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reset the items to the desired values.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uPage = GetDlgItemInt(hDlg, IDE_PAGE, &amp;bErr, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostMessage( hWndSlider, TBM_SETPAGESIZE, 0L, uPage);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uLine = GetDlgItemInt(hDlg, IDE_LINE, &amp;bErr, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostMessage( hWndSlider, TBM_SETLINESIZE, 0L, uLine);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowLong(hDlg,&nbsp; DWL_MSGRESULT, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case PSN_KILLACTIVE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case PSN_RESET:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reset to the original values.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostMessage(hWndSlider, TBM_SETPAGESIZE, 0L, uPageSave);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostMessage( hWndSlider, TBM_SETLINESIZE, 0L, uLineSave);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; }
  }
  return (FALSE);&nbsp;&nbsp; 
}

/****************************************************************************
*&nbsp;&nbsp;&nbsp; FUNCTION: CreatePropertySheet(HWND)
*
*&nbsp;&nbsp;&nbsp; PURPOSE:&nbsp; Creates a property sheet
*
****************************************************************************/
int CreatePropertySheet(HWND hwndOwner, HINSTANCE hInst)
{
 &nbsp;&nbsp; PROPSHEETPAGE psp[2];
 &nbsp;&nbsp; PROPSHEETHEADER psh;

 &nbsp;&nbsp; psp[0].dwSize = sizeof(PROPSHEETPAGE);
 &nbsp;&nbsp; psp[0].dwFlags = PSP_USETITLE;
 &nbsp;&nbsp; psp[0].hInstance = hInst;
 &nbsp;&nbsp; psp[0].pszTemplate = MAKEINTRESOURCE(IDD_RANGE);
 &nbsp;&nbsp; psp[0].pszIcon = NULL;
 &nbsp;&nbsp; psp[0].pfnDlgProc = (DLGPROC)Range;
 &nbsp;&nbsp; psp[0].pszTitle = "Slider Range";
 &nbsp;&nbsp; psp[0].lParam = 0;

 &nbsp;&nbsp; psp[1].dwSize = sizeof(PROPSHEETPAGE);
 &nbsp;&nbsp; psp[1].dwFlags = PSP_USETITLE;
 &nbsp;&nbsp; psp[1].hInstance = hInst;
 &nbsp;&nbsp; psp[1].pszTemplate = MAKEINTRESOURCE(IDD_PROPS);
 &nbsp;&nbsp; psp[1].pszIcon = NULL;
 &nbsp;&nbsp; psp[1].pfnDlgProc = (DLGPROC)PageSize;
 &nbsp;&nbsp; psp[1].pszTitle = "Slider Page and Line&nbsp; Size";
 &nbsp;&nbsp; psp[1].lParam = 0;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; psh.dwSize = sizeof(PROPSHEETHEADER);
 &nbsp;&nbsp; psh.dwFlags = PSH_PROPSHEETPAGE;
 &nbsp;&nbsp; psh.hwndParent = hwndOwner;
 &nbsp;&nbsp; psh.hInstance = hInst;
 &nbsp;&nbsp; psh.pszIcon = NULL;
 &nbsp;&nbsp; psh.pszCaption = (LPSTR) "Slider Properties";
 &nbsp;&nbsp; psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
 &nbsp;&nbsp; psh.ppsp = (LPCPROPSHEETPAGE) &amp;psp;

 &nbsp;&nbsp; return (PropertySheet(&amp;psh));
}
} // End of extern "C" bracket.
</code></pre>
<h2>Step Four: Integrate My C Code with MFC</h2>
<p>
Just because I added my C code doesn’t mean that MFC knows to call it. I mean, MFC is definitely very smart, but it can't read minds yet.</p>
<p>
To call my C function, I had to alter the code that AppWizard created for me. I opened the MFCPRVW.CPP file that handles the view, and ran ClassWizard from the Project menu. I selected the view and the <b>OnInitialUpdate</b> message, clicked the Add Function button, then clicked the Edit Code button to edit the code. I used the following code to create the slider:</p>
<pre><code>void CMfcpropsView::OnInitialUpdate() 
{
 &nbsp; // TODO: Add your specialized code here and/or call the base class.
 &nbsp; CreateSlider(GetSafeHwnd() , AfxGetInstanceHandle());
 &nbsp; CView::OnInitialUpdate();
}
</code></pre>
<p>
Because my C function needed a handle to a window and the handle to the current instance, I had to call two MFC functions: <b>GetSafeHwnd</b> and <b>AfxGetInstanceHandle</b>. Adding this code was all I needed to do to have my slider function correctly. Now I had to get that property sheet working.</p>
<p>
In my original design, the property sheet is displayed when the window procedure receives an IDM_PROPERTIES command. In MFC, we no longer have a window procedure; instead, the system has a message map that dispatches the appropriate messages to the appropriate windows. To add a handler for a new command, I once again used ClassWizard on my view class, but this time I selected IDM_PROPERTIES and COMMAND in the message box, then clicked Add Function. This action displayed a prompt for the function name. I accepted the default (which was "OnProperties") and clicked the Edit Code button. These actions added a line to my message map that directed MFC to call the <b>OnProperties</b> function when the view received the IDM_PROPERTIES command. The following code demonstrates the final changes I made to my view code. Note that I added prototypes for the C functions I called and bracketed the prototypes with the extern “C” directive.</p>
<pre><code>extern "C" {
extern VOID CreateSlider(HWND, HINSTANCE);
extern int CreatePropertySheet(HWND, HINSTANCE);
}

BEGIN_MESSAGE_MAP(CMfcpropsView, CView)
 &nbsp; //{{AFX_MSG_MAP(CMfcpropsView)
 &nbsp; ON_COMMAND(IDM_PROPERTIES, OnProperties)
 &nbsp; //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMfcpropsView::OnProperties() 
{
 &nbsp; // TODO: Add your command handler code here.
 &nbsp; CreatePropertySheet(GetSafeHwnd(), AfxGetInstanceHandle());
}
</code></pre>
<p>
Next, I did a quick scan for all dependencies, and compiled and linked the code. I ran into one small problem, and had to remove the precompiled header option from PROPS.CPP (the file containing all of my C source code) as a workaround. In PROPS.CPP, I did not include the stdafx.h file at the beginning of my source listing, so I had to ensure that the project was built without presuming that I would be using precompiled headers for this file. I did this by using the Project Settings property sheet. I chose PROPS.CPP from the list of source files, and clicked the C/C++ tab. From the Category drop-down combo box, I selected Precompiled Headers. To disable the use of stdafx.h, I clicked the check box labeled "Use .PCH File". Choosing this check box adds the string</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Project settings, and not /Yu"stdafx.h"</p>
<p>
to the Source File Options edit box at the bottom of the page.</p>
<p>
I attempted another build, only to find another small problem—I needed to include COMCTL32.LIB in my Object/Library Link Modules list by clicking the Link tab in the Project Settings property sheet. At this point, my application ran just like the original application. I had successfully used MFC for items that MFC supports, and C for the common controls that MFC does not yet support.</p>
<h2>Can I Use MFC Controls with Windows 95 Controls?</h2>
<p>
You may be wondering if you can use MFC’s built-in controls (such as the toolbar, status bar, and property sheet) in conjunction with the Windows 95 common controls. Well, you can. Use the built-in controls as usual, and keep the Windows 95–specific, non-MFC code in a separate C file. The separate file is a personal choice. I like to separate the C code from the C++ code so I will quickly know what needs to be done when I port my application in its entirety to MFC. </p>
<p>
Just to prove to you that anybody can do this (and to keep Nigel Thompson from telling me that I really didn’t use enough MFC to consider myself a convert), I decided to modify my sample to use the property sheet included in MFC.</p>
<p>
Here’s what you do to create an MFC property sheet:
<ol>
<li>
Create a dialog template resource for each property page, using the dialog editor. The first page you add to the property sheet determines how much space to allocate for the property pages in the property sheet. Set the following dialog properties for each page:<ul type=disc>
<li>
Set the Style list box in the Styles page to <i>Child</i>.<br><br></li>
<li>
Set the Border list box in the Styles page to <i>None</i>.<br><br></li>
<li>
Clear the Disabled and Titlebar check boxes in the Styles page.<br><br></li>
<li>
In the Caption edit box in the General page, type the text for the tab for that page.</li>
</ul>
</li>
<li>
Use ClassWizard to create a <b>CPropertyPage</b>-derived class for each page. I had to do this for two pages: the Line And Size page and the Range page. To create the class, select the dialog resource, choose ClassWizard from the Project menu, then choose <b>CPropertyPage</b> as the base class in ClassWizard.<br><br></li>
<li>
Using ClassWizard, create member variables to hold the values for each property page. In the sample I wrote, I created member variables to hold the minimum and maximum range values, and the line size and page size for the slider.<br><br></li>
<li>
Create a <b>CPropertySheet</b> object in the view source code. I created this object in response to the IDM_PROPERTIES command, <b>OnProperties</b>.<br><br></li>
<li>
Call <b>::AddPage</b> for each page to be added to the property sheet. <br><br></li>
<li>
Call <b>::DoModal</b> to display the property sheet.</li>
</ol>
<p>
Remember the code in the "Step Three: Add My C Code" section that implemented the Windows 95 property sheet? A lot of code, wasn't it? Well, take a look at the code below that I wrote to use the MFC-supported property sheet:</p>
<pre><code>void CMfcpropsView::OnProperties() 
{
 &nbsp; // Create a property sheet object.
 &nbsp;&nbsp; CPropertySheet dlgPropertySheet(AFX_IDS_APP_TITLE,this);
 &nbsp; CLineAndPageSize sizePage;
 &nbsp; CRange rangePage;

 &nbsp; dlgPropertySheet.AddPage(&amp;sizePage);
 &nbsp; dlgPropertySheet.AddPage(&amp;rangePage);

 &nbsp; if (dlgPropertySheet.DoModal() == IDOK)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; UpdateSlider(rangePage.m_MinRange, rangePage.m_MaxRange, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizePage.m_PageSize, sizePage.m_LineSize);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDocument()-&gt;SetModifiedFlag();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDocument()-&gt;UpdateAllViews(NULL);
 &nbsp; }
}
</code></pre>
<p>
If the simplicity of the code above doesn’t inspire you to learn C++ and MFC, I don’t know what will. After seeing the time I could have saved with MFC, I could kick myself for not migrating to MFC earlier.</p>
<h2>Summary</h2>
<p>
I migrated to C++ and MFC kicking and screaming, but once I finally sat down and got to work, I spent less time porting my code than I spent complaining about how difficult it was going to be. To prepare myself for this migration, I took classes in C++ and MFC and read everything I could get my hands on. The Library contains useful information—for example, be sure to read Herman Rodent's article "Using MFC to Create Simple Windows-Based Applications” (MSDN Library Archive, Technical Articles, C++ 1.0 [16-bit] Articles). Of course, having a Visual C++/MFC guru down your hall doesn't hurt either. I hope the information in this article will inspire you to take the leap.</p>
<p>
Come on in—the water’s fine!</p>
</BODY>
</HTML>
