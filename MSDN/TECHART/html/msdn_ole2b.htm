<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE for Idiots: B Is for Beginning</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_ole2b"></a></sup>OLE for Idiots: B Is for Beginning</h1>
<p>
Herman Rodent<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: June 22, 1993</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="1443">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the TBSS sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article is one of a series of articles that discuss implementing Object Linking and Embedding (OLE) version 2.0 in Microsoft® Windows™-based applications. This article looks at the structured storage facility in OLE and shows how an application can be simply converted from using MS-DOS® files for its storage to OLE's structured storage system. Using structured storage is the first step toward creating an OLE container application.</p>
<h2>Introduction</h2>
<p>
Any application that you want to become a container for OLE objects must provide a means for the OLE objects it contains to store themselves. The OLE architecture requires that the application provide a pointer to an OLE storage object for this purpose. So before we can really get anywhere with adding OLE container support to an application, we need to learn something about OLE's structured storage system.</p>
<p>
You can take two approaches to adding the structured storage necessary for container support in your application. You can take the easy way and create an OLE structured storage object on a chunk of global memory. You can then save the global memory block in your own file any way you like, or you can modify your application to use structured storage instead of regular MS-DOS® files.</p>
<p>
My own first response was to immediately opt for the global memory block idea: I didn't want to mess with my file format, and I already understood how to allocate global memory and write it to one of my files. The idea of going for a whole new file architecture seemed a tremendous amount of work, and for what purpose? After reading the OLE documentation and the chapters in Kraig Brockschmidt's unpublished book, <i>Inside OLE 2,</i> that discuss structured storage, I saw that there might be some advantage in converting to this new technology, and consequently, I changed my view and decided to try the idea of porting my application to the new file format instead.</p>
<p>
This article is not an in-depth study of OLE's structured storage architecture or features, neither is it a comprehensive account of how you should alter your own application. This is an account of how I modified my own simple TEXTBOX application, and it serves to show just how easy and straightforward modification can be. The TBSS (Text Box with Structured Storage) application is the result of these efforts.</p>
<p>
Almost all current OLE discussion centers around objects, methods, and so on. I've tried to avoid too much of this type of discussion by dealing with OLE in much the same way I'd deal with any other Microsoft Windows™ subject—that is, by referring to data structures and the functions that manipulate those structures. It's just a matter of terminology, of course, but what I'm trying to make clear is that there's nothing weird, difficult, or strange about implementing OLE. After all, it's just code.</p>
<h2>So What Is Structured Storage?</h2>
<p>
For those of you who really can't be bothered to dive into the OLE documents, I'll try to sum up what structured storage is all about in as few words as possible.</p>
<p>
A single structured storage object is like an entire disk. It has a file allocation table (FAT), one or more directories and subdirectories, and one or more files contained within the directories. In the simplest case, this entire structure can live inside one MS-DOS file. It can also live inside a New Technology File System (NTFS) file in Windows NT™, a chunk of memory, a database record, a Coke® can, a small cardboard box, or, in fact, any storage mechanism you can provide with a simple interface called <b>ILockBytes</b>. The OLE implementation provides a default implementation of <b>ILockBytes</b> for MS-DOS files, which means we get to use structured storage for free.</p>
<p>
As for why you might want to use it? That's easy. If your application currently uses more than one file to represent its data, you can put all those files together in one structured storage object, which is itself contained in a single MS-DOS file. Think how easy that would be to distribute and how difficult it would be for a user to accidentally nuke one of the files without noticing it.</p>
<p>
The OLE implementation of structured storage provides functions for everything you would normally need when dealing with directories and files within a file system. The directories in a file system are similar to the storage objects in the structured storage system. Files are similar to streams in structured storage. You can create nested storage objects (effectively subdirectories); create, read, write, and delete streams (files); and so on. Each stream supports a single seek pointer. If you want to know more, read the documentation, but be assured that it's all there—all the functions you need to replace your existing multifile storage mechanism with a single structured storage file have been implemented.</p>
<h2>Where to Start?</h2>
<p>
Having read some of the documentation, I found that I had a good idea of what I might be able to do with the structured storage functions, but no real idea about where to start. In particular, I really couldn't see how to call the functions that are described in the manual as C++ methods. As I found out, this is all really quite simple. The following sections show how I did it and what the code looks like.</p>
<h3>Headers and Libraries</h3>
<p>
Your code will need to include the OLE2.H header file to get the function definitions, macros, structures, and so on that we are going to use, and you will need to link the OLE2 and STORAGE libraries when building the .EXE file. The TBSS sample includes OLE2.H in GLOBAL.H, thus providing the OLE functions to all its modules. This isn't very efficient in terms of compilation time, but it keeps the code clutter to a minimum.</p>
<h3>Initialization and Termination</h3>
<p>
The OLE libraries require that they be initialized by a simple call and subsequently shut down when your application has finished with them. The documentation shows that there are two ways to go about this. You can call the <b>OleInitialize</b>/<b>OleUninitialize</b> pair or the <b>CoInitialize</b>/<b>CoUninitialize</b> pair. The difference is that the <b>OleInitialize</b> function initializes the entire OLE library set and the <b>CoInitialize</b> function deals only with the lower-level component object library. Because we are going to use only the structured storage facility, which depends solely on the component object library, we can use the <b>CoInitialize</b>/<b>CoUninitialize</b> functions to achieve what we need. We'll worry about the <b>OleInitialize</b>/<b>OleUninitialize</b> functions as we need them.</p>
<p>
The OLE 2.0 documentation suggests that, in addition to the initialization functions, you check the version of OLE present on the machine at run time. The general rule to follow when checking versions is that your code should run on any machine with the same or higher major version number as the version you used to develop the application.</p>
<p>
Let's look at the code in the TBSS sample that deals with the startup/shutdown stuff. This code is in the INIT.C module in the <b>InitCurrentInstance</b> function:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;dwOleVer = CoBuildVersion();
 &nbsp;&nbsp; if (HIWORD(dwOleVer) &lt; 20) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message(0, "This application requires OLE Version 2.x");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; }
</code></pre>
<p>
A call is made to <b>CoBuildVersion</b> to get the current run-time version. Note that this is the <i>only</i> API you can call before initialization of the libraries. The current version is tested to make sure it's at least version 2.0, and if not, the application exits.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;if (CoInitialize(NULL) != S_OK) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message(0, "Failed to initialize the OLE libraries");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; bOleInit = TRUE;
</code></pre>
<p>
If the version is okay, we go on to call <b>CoInitialize</b> and check the return code. If the initialization succeeds, the <b>bOleInit</b> variable is set to TRUE so that, when it's time to terminate the application, we will know that the OLE libraries were initialized and need to be shut down. According to the documentation, it's important <i>not</i> to call the OLE uninitialization functions if initialization of the libraries wasn't done or failed.</p>
<p>
So that's all we need to get started. Two calls. All that reading, worry, note taking, and coffee just to make two calls! Really, it doesn't get much worse than this.</p>
<p>
When the application terminates, we must be sure to shut down the OLE libraries. The following code takes care of that and can be found in the <b>Terminate</b> function in the INIT.C module:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;if (bOleInit) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CoUninitialize();
 &nbsp;&nbsp; }
</code></pre>
<p>
There's a lot of other stuff in the INIT.C module, but it was all there in the original TEXTBOX application. Only the few lines of code shown here have been added to support the OLE functions we are going to use.</p>
<h2>Designing for Structured Storage</h2>
<p>
I really wanted to do the absolute minimum that I could get away with in converting my application to use structured storage. In the end, things turned out a little bit more complicated because I decided that I should at least try out some of the OLE 2.0 features to satisfy myself that they did, in fact, work! I also wanted the TBSS application to be able to read the files written by the earlier TEXTBOX application.</p>
<p>
The original TEXTBOX application file format is discussed in "OLE for Idiots: A is for Attitude." The file format layout is reproduced here in Figure 1.</p>
<p>
<img src="ole2b_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The structure of a TEXTBOX (.TBX) file containing two text rectangle objects</b></p>
<p>
All the code that deals with file I/O is contained in the FILE.C module. Modifying the application to use structured storage involves changes to only this source file. In the following description, remember that a stream is rather like an MS-DOS file and a storage object is like an MS-DOS directory. I use the term <i>substorage</i> to mean a storage object created as the child of another storage object just as subdirectories work in the MS-DOS file system.</p>
<p>
The code in FILE.C provides two basic functions: to read a file and create a list of objects, and to write the current list of objects out to a file. The file also contains information about the application's main window size and a tag marking it as one of our files. In adapting the application to use structured storage, I considered splitting the information into two separate streams. The data originally contained in the <b>FILEHEADER</b> structure would be written to one stream and the object list to another. I considered writing each object to its own stream and keeping all these object streams in an objects directory. Although this is reasonably easy to do, I decided that this would only make for more code and not improve anything much, so I stuck to the simple approach, leaving the creation of substorages for later.</p>
<p>
The final design, then, consists of two streams contained within the storage object as shown in Figure 2.</p>
<p>
<img src="ole2b_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The structured storage system used by TBSS</b></p>
<h3>Writing a File</h3>
<p>
Let's begin by looking at how to create one of these structured storage objects contained in an MS-DOS file. We will be able to test our work with the DocFile Viewer (DFVIEW) application that is shipped with the OLE 2.0 Software Development Kit.</p>
<p>
The TEXTBOX application opens an MS-DOS file, writes the header, and then loops, writing object header and data pairs. It then closes the file. In order to save the same information in our structured storage format, we will take these steps:
<ol>
<li>
Create a structured storage object (STORAGE).<br><br></li>
<li>
Create the INFO stream.<br><br></li>
<li>
Write the contents of the INFO stream.<br><br></li>
<li>
Close the INFO stream.<br><br></li>
<li>
Create the TEXTOBJECTS stream.<br><br></li>
<li>
Write all the rectangle headers and data to the TEXTOBJECTS stream.<br><br></li>
<li>
Close the TEXTOBJECTS stream.<br><br></li>
<li>
Close the structured storage object.</li>
</ol>
<p>
I use the word <i>close</i> here as an analogy with what we would be doing with real files. In practical terms, we will be using a function called <b>Release</b> to perform this action. Let's look at the code that implements these steps in the <b>FileSave</b> function in FILE.C. I have omitted comments and some error handling for clarity.</p>
<pre><code>LPSTORAGE pStorage;

hResult = StgCreateDocfile(gachFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_CREATE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, &amp;pStorage);
</code></pre>
<p>
The <b>StgCreateDocfile</b> function creates a new storage object or (with the flags used here) truncates an existing one to zero. The name is a hangover from the OLE 1.0 days. This is much the same as creating an MS-DOS file. We supply the name and some option flags and, in this case, the address of where the result is to be placed (<b>&amp;pStorage</b>). The flags used in this case give us read/write access, don't let any other process access it, turn off transaction processing, and create the file if it doesn't already exist.</p>
<p>
I didn't mention the transaction processing before. OLE's structured storage is a bit more than just a file system in a file. It also has a complete transaction processing option for producing extremely robust applications. This can greatly facilitate undo operations if the system is used wisely. If you're all turned on by the idea of using this, read the discussion of structured storage in Chapter 3, "Architectural Overview," and Chapter 11, "Persistent Storage Interfaces and Functions," of the <i>Object Linking and Embedding Programmer's Reference, Version 2</i> and also Chapter 5, "Structured Storage and Compound Files," in Kraig Brockschmidt's book, <i>Inside OLE 2, </i>when it is published.</p>
<p>
Having created the storage object, we now need to create the INFO stream. In looking for a C function to accomplish this, I found the C++ method <b>IStorage::CreateStream</b> in the OLE documentation. Here is what we need to do to call this method from C:</p>
<pre><code>hResult = pStorage-&gt;lpVtbl-&gt;CreateStream(pStorage, INFO_STREAM,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_CREATE, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, NULL, &amp;pInfoStream);
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The way that OLE 2.0 is implemented means that it can be used equally well from C or C++. The C++ usage is generally a little cleaner than C and requires one less parameter in the calls because of the way in which a C++ call always supplies a pointer to the object whose method is being invoked. In C++, the pointer is called the <b>this</b> pointer because it refers to the current object. When calling these object methods as C functions, we need to explicitly provide the <b>this</b> pointer as the first parameter. If you're not a C++ programmer (and I'm not), you really don't need to know much more than this. Just remember that every function you see documented as <b><i>Class::Method</i></b> will require you to supply the object pointer as the first parameter, so your C call will have one more parameter than is listed in <i>Object Linking and Embedding Programmer's Reference, Version 2</i>.</p>
<p>
You can see that we are not calling a function directly by its name, which is normal C practice, but instead we are dereferencing the object pointer through a table of pointers to functions. The OLE implementation always generates the <b>lpVtbl</b> field in every object, so you will always call these method functions in exactly this way.</p>
<p>
The first parameter is the object pointer. The second is the name of the stream. I have used the INFO_STREAM constant here, which is defined in GLOBAL.H as the string "INFO". The third parameter is a set of option flags. The set used here is the same as we used to create the storage object earlier. The final parameter supplies the address to return the stream object pointer.</p>
<p>
Here's the definition of the <b>IStorage::CreateStream</b> method from <i>Object Linking and Embedding Programmer's Reference, Version 2</i>:</p>
<pre><code>HRESULT IStorage::CreateStream(pwcsName, grfMode, res1, res2, ppstm)
const char FAR * pwcsName
DWORD grfMode
DWORD res1
DWORD res2
LPSTREAM FAR * ppstm
</code></pre>
<p>
Please notice that the <b>this</b> pointer is <i>not</i> shown.</p>
<p>
In my own implementation, this was the biggest step. I struggled for ages to find out how to call these C++ methods in C. This is all there is to it. Once I had this figured out, the rest was simply a matter of finding the names of the functions I needed.</p>
<p>
Moving right along, let's look at how the INFO stream data is written out and how we close the stream:</p>
<pre><code>hResult = pInfoStream-&gt;lpVtbl-&gt;Write(pInfoStream, &amp;FileHead,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(FileHead), &amp;cb);

pInfoStream-&gt;lpVtbl-&gt;Release(pInfoStream);
</code></pre>
<p>
As you can see, writing data to a stream is exactly like writing to an MS-DOS file. We get the function pointer by using the same dereferencing technique we used to get the <b>CreateStream</b> function pointer. The object pointer is passed as the first parameter, followed by a pointer to the information we want to write, the length of the data, and a pointer to where we want the result count to be written. The OLE functions guarantee to always return exactly the count of bytes read or written even if an error occurs—this is sooo much better!</p>
<p>
Finally, I close the stream by calling the <b>Release</b> function.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Having lots of storage structures and streams open in your application doesn't affect the MS-DOS file handle count. Remember, the entire storage object is contained in one file, so you only have one MS-DOS file handle in use at any time. If you're not getting enthusiastic about using structured storage by now, go back and read about it again. Structured storage is a tremendous improvement over dealing with the file system directly.</p>
<p>
Writing out the text information to the TEXTOBJECTS stream follows the same technique as used for the INFO stream:</p>
<pre><code>hResult = pStorage-&gt;lpVtbl-&gt;CreateStream(pStorage, OBJECT_STREAM,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_CREATE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, NULL, &amp;pObjStream);

pObj = gpObjList;
while (pObj) {

 &nbsp;&nbsp; hResult = pObjStream-&gt;lpVtbl-&gt;Write(pObjStream, pObj, sizeof(OBJECT),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;cb);

 &nbsp;&nbsp; hResult = pObjStream-&gt;lpVtbl-&gt;Write(pObjStream, pObj-&gt;pInfo,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pObj-&gt;uiSize, &amp;cb);

 &nbsp;&nbsp; pObj = pObj-&gt;pNext;
}

pInfoStream-&gt;lpVtbl-&gt;Release(pInfoStream);
</code></pre>
<p>
Once the code was written and compiled, I ran it and checked the result by saving a file containing just one object, and then I viewed the result with the DocFile Viewer. Figure 3 shows a screen shot of the DocFile Viewer with the file open. The DocFile Viewer is one of many applications that come with the OLE 2.0 Software Development Kit. The DocFile Viewer allows you to view the structure and contents (in hex) of a structured storage file.</p>
<p>
<img src="ole2b_3.gif" border=0></p>
<p class=label>
<b>Figure 3. A Docfile Viewer look at a structured storage file</b></p>
<h3>Reading a File</h3>
<p>
If you've been following the story so far, I'm sure you can guess that reading the structured storage object back in as the two streams we wrote out is fairly trivial. There is one additional thing to do here, though. I wanted the TBSS application to be able to read the files written by itself and also by the older TEXTBOX application. I was going to use the file extension as an indicator of which sort of file was being opened until I came across the <b>StgIsStorageFile</b> function, which tests a file to see if it is a structured storage file. (Isn't it nice to have obvious API names for a change?) I used this function to make a first test and, if it failed, used the old TEXTBOX code to try to read it as an MS-DOS file. If the test went okay, the file was opened as a structured storage file and new code executed to read it that way. Here's the call to test the file type:</p>
<pre><code>if (StgIsStorageFile(gachFileName) != S_OK) {
...
</code></pre>
<p>
Once we find it is a storage file, the code goes on to open the storage, open the INFO stream, read it, and close it:</p>
<pre><code>hResult = StgOpenStorage(gachFileName, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | STGM_DIRECT, NULL, NULL, &amp;pStorage);

hResult = pStorage-&gt;lpVtbl-&gt;OpenStream(pStorage, INFO_STREAM, NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STGM_READ | STGM_SHARE_EXCLUSIVE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | STGM_DIRECT, NULL, &amp;pInfoStream);

hResult = pInfoStream-&gt;lpVtbl-&gt;Read(pInfoStream, &amp;FileHead,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(FileHead), &amp;cb);

pInfoStream-&gt;lpVtbl-&gt;Release(pInfoStream);
</code></pre>
<p>
Just as you suspected, this code is pretty much a copy of the write code, but it uses the <b>Read</b> method function to retrieve the stream data. The code for reading the text objects is so similar that I'll omit it.</p>
<h2>What's Next?</h2>
<p>
As you can see, there really isn't anything difficult here. We used a couple of functions to perform initialization and another handful to do all the storage and stream manipulation in almost exactly the same way we would normally deal with directories and files.</p>
<p>
The OLE 2.0 documentation includes many more functions. Check out creating substorages, experiment with creating fascinating data structures, and verify them with the DocFile Viewer.</p>
<p>
If you're looking for something to show the boss, this is going to be a hard sell because there's not much that looks different so far in the application. But we've made a start. In the next article, we'll go on to add basic container support to the application and make use of the storage work we did here, so we can store objects embedded in our application by the user.</p>
<p>
One point to note here is that we have used structured storage in the same way we use MS-DOS file handles: open, access, close. As we'll see when we come to creating an OLE container application, the application needs to provide a structured storage object for each OLE object at creation time. This means that the OLE application generally has to have an open storage object all the time, which involves changing the way the application deals with the whole open/close scenario. Just to make things a little more complex, each OLE object needs to have its own storage object in which it can save itself. This means that we will be providing a set of substorages from the root storage, one for each object, and we are going to have to manage this list of substorages. This is a little more complicated than the simple approach in this article, but rest assured that the final code is really not much more complicated than that shown here.</p>
</BODY>
</HTML>
