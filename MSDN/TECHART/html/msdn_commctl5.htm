<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Win32 Common Controls, Part 5: Image Lists and Tree View Windows</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_commctl5"></a>Win32 Common Controls, Part 5: Image Lists and Tree View Windows</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
April 25, 1994</p>
<p>
Revised: August 1994 (updated to reflect Windows 95 M7 changes: the ILD_OVERLAYMASK style and the ImageList_DragShow function were removed; the code now allows only four overlay masks)<br>
December 1994 (changes: addition of ImageList_DragEnter, ImageList_DragLeave, ImageList_DrawEx, ImageList_GetIcon, and ImageList_SetDragCursorImage functions; name change of ImageList_StartDrag function to ImageList_BeginDrag; change in ImageList_Create function; addition to drawing styles in Table 1; deletion of ImageList_AddFromImageList, ImageList_CopyDitherImage, ImageList_GetImageRect, and ImageList_SetObjectOwner functions)<br>
June 1995 (no longer a limitation on number of overlay masks)</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="2329">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the TreeView sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
The next release of the Microsoft® Windows® operating system (called Windows 95) presents a new set of common controls to developers of Windows-based applications. These controls are provided in a new dynamic-link library (DLL) called COMCTL32.DLL. The controls allow developers to integrate existing applications into the new Windows 95 shell more thoroughly and seamlessly. COMCTL32.DLL is included with Windows 95 and will also be supported in Win32s® (running on Windows version 3.1) and in Windows NT™. Note that these controls are 32-bit only—they will not be supported in 16-bit Windows environments.</p>
<p>
This article describes two new common controls: image lists and tree view controls. It is the fifth in a series of articles introducing the new common controls. The other articles in the series cover the following topics:
<ul type=disc>
<li>
<a href="msdn_commctl1.htm">Part 1: The basics</a><br><br></li>
<li>
<a href="msdn_commctl2.htm">Part 2: Status bars and toolbars</a><br><br></li>
<li>
<a href="msdn_commctl3.htm">Part 3: Trackbars, progress bars, and up-down controls</a><br><br></li>
<li>
<a href="msdn_commctl4.htm">Part 4: Header windows and list view windows</a><br><br></li>
<li>
<a href="msdn_commctl6.htm">Part 6: Tab controls and property sheets</a></li>
</ul>
<p>
Parts 2–6 of the series have associated code samples that demonstrate the use of the Win32® common controls.</p>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;The TreeView executable file associated with this article was built and tested using the Windows 95 Preliminary Development Kit. The executable will run only on Windows 95; it will not run under Windows 3.1 or Windows NT. If you have Windows 95 installed on your machine, but you have problems running this sample, copy the project files to your system using the button above, rebuild the project, and run the executable.</p>
<p>
Please note that this article is based on preliminary information that is subject to change before the final version of Windows 95.</p>
<h2>Image Lists</h2>
<p>
The next release of the Microsoft® Windows® operating system (called Windows 95) has implemented image lists to help you manage a collection of images of the same size, such as bitmaps or icons. You can use image lists when working with list view windows and tree view windows. A single wide bitmap contains the images within an image list. If you've worked with the toolbar in the Microsoft Foundation Class Library (MFC), you should be familiar with this type of bitmap. To reference a specific image in the bitmap, you use the index of the image within the image list. In addition to the bitmaps and icons that you normally consider images, you may also include a monochrome bitmap containing masks. These masks allow you to draw an icon transparently. You can create, destroy, add to, mask, and merge image lists.</p>
<p>
There are two types of image lists: nonmasked and masked.
<ul type=disc>
<li>
A nonmasked image list includes a color bitmap that contains one or more images. This is just a wide bitmap containing small bitmaps, similar to the bitmap I used in the TreeView sample associated with this article. When a nonmasked image is drawn, it is simply copied into the target device context (DC); no special processing occurs.<br><br></li>
<li>
A masked image list contains two wide bitmaps. The first bitmap is a color bitmap containing the images, and the second bitmap is a monochrome bitmap that contains a series of masks (one for each image in the first bitmap). When a masked image is drawn, the mask that is specified for the image is combined with the image. This combination produces transparent areas in the bitmap where the background color of the target DC shows through.</li>
</ul>
<h3>Overlay Images</h3>
<p>
Have you ever wondered what the system uses to display the image for a shared directory—you know, the image with the hand holding a folder? It uses an overlay image. An overlay image is an image from the default image list that is drawn transparently over another image. You specify overlay images in the image list by adding the index of an image to the list of overlay masks and calling the <b>ImageList_SetOverlayImage</b> function. Note that the indexes for the overlay masks are one-based, not zero-based.</p>
<h3>Creating Image Lists</h3>
<p>
Creating an image list is easy: just call the <b>ImageList_Create</b> function. For a nonmasked image list, the function creates a single bitmap large enough to hold the specified number of images with the given dimensions. Next, it creates a screen-compatible DC and selects the bitmap into it. For a masked image list, the <b>ImageList_Create</b> function creates two bitmaps and two screen-compatible DCs. It selects the image bitmap into one DC and the mask bitmap into the other. Once the image list is created, its initial size is set based on the size values that you specified in your call to <b>ImageList_Create</b>. Adding more images than you specified automatically increases the size of the image list to accommodate the additional images by the amount, in images, that you specified your image list can grow. The <b>CreateTreeView</b> function that I wrote (see the "Creating a Tree View Control" section later in this article) demonstrates how to create an image list.</p>
<h3>Adding Images to an Image List</h3>
<p>
Now that you have a handle to your image list (provided by the call to <b>ImageList_Create</b>), you can add bitmapped images, icons, or cursors to the image list. The <b>ImageList_Add</b> function allows you to add images by passing the handles of two bitmaps. The first bitmap contains one or more images to add to the image bitmap, and the second bitmap contains the masks to add to the mask bitmap (this is NULL for nonmasked image lists).</p>
<p>
Another way to add bitmapped images is to call the <b>ImageList_AddMasked</b> function. This function is similar to <b>ImageList_Add</b>, except that you specify a color to be combined with the image bitmap to generate the masks instead of specifying a mask bitmap. When you do this, each pixel of the specified color in the image bitmap is changed to black, and the corresponding bit in the mask is set to one. This results in transparency for any pixel in the image that matches the specified color when the image is drawn. </p>
<p>
There are actually several more functions (specific to certain types of images such as icons or dithered images) that you can use to add images to an image list. These are explained in detail in the "Image List Functions" section later in this article.</p>
<h3>Dragging an Image</h3>
<p>
Windows 95 provides dragging functions that enable you to move an image (masked or unmasked) smoothly and in color, as object linking and embedding (OLE) does, without any flashing of the cursor. Isn't that cool? I thought so. Dragging an object is fairly simple. You use three basic functions:
<ul type=disc>
<li>
The <b>ImageList_BeginDrag</b> function to begin a drag operation.<br><br></li>
<li>
The <b>ImageList_DragMove</b> function to move the image to a new location.<br><br></li>
<li>
The <b>ImageList_EndDrag</b> function to end the drag operation.</li>
</ul>
<p>
The dragging functions draw the image in the DC associated with the given window. The coordinates that specify the position of the image during a drag operation are relative to the window's upper-left corner, not the client area. This means that you must compensate for the width of window elements such as the title bar and menu bar when specifying the coordinates.</p>
<p>
The <b>ImageList_BeginDrag</b> function locks all other updates to the screen, so if you need to do any drawing during a drag operation (such as highlighting the target of a drag-and-drop operation), you can use the <b>GetDCEx</b> function with the DCX_LOCKWINDOWUPDATE flag to get a DC that allows you to draw. In this case, you must be careful not to obliterate the dragged image. The "Drag-and-Drop Operations for a Tree View Item" section later in this article includes code that demonstrates how to do this.</p>
<p>
Note that the dragging functions use the new image during a drag operation, so you should use the <b>ShowCursor</b> function to hide the actual mouse cursor after calling <b>ImageList_BeginDrag</b>. If you don't, the system may appear to have two mouse cursors for the duration of the drag operation. This would be bad.</p>
<h3>Image List Structures and Macros</h3>
<p>
By now, you've gotten used to the sections in this series containing descriptions of functions, structures, macros, groceries to buy, and so on. Well, I didn't want to disappoint anyone, so here is yet another list section on structures and macros, followed by a section that describes the image list functions. I have tried to make these sections a little more interesting by including additional details about each structure, macro, or function. If you find these sections tiresome, you have my permission to skip them entirely and move on to the section entitled "Tree View Windows." When you get to a point in your development where you need to know about a particular function or structure, come back to these sections and look it up.</p>
<p>
Because image lists are part of the new dynamic-link library (DLL) for common controls (COMCTL32.DLL), you must include the common-control header file in your source code files and link with the common-control export library to use the image list functions, structures, and macros. It is a good idea to call the <b>InitCommonControls</b> function to ensure that the common-control DLL has been loaded before calling any image list function or using one of its structures.</p>
<h4>IMAGEINFO</h4>
<pre><code>typedef struct _IMAGEINFO {
 &nbsp;&nbsp; HBITMAP hbmImage;&nbsp;&nbsp;&nbsp; \\ handle of the bitmap containing the images
 &nbsp;&nbsp; HBITMAP hbmMask;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the mask bitmap
 &nbsp;&nbsp; int Unused;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
 &nbsp;&nbsp; int Unused;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
 &nbsp;&nbsp; RECT rclImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ bounding rectangle of the image
} IMAGEINFO;
</code></pre>
<p>
The <b>IMAGEINFO</b> structure contains information about an image in an image list. This structure is used with the <b>ImageList_GetImageInfo</b> function. <b>IMAGEINFO</b> contains the following members:
<ul type=disc>
<li>
<b>HBITMAP</b> <i>hbmImage</i>: Handle of a bitmap containing the images.<br><br></li>
<li>
<b>HBITMAP</b> <i>hbmMask</i>: Handle of a monochrome bitmap containing the masks for the images. This member is NULL if the image list does not contain a mask.<br><br></li>
<li>
<b>RECT</b> <i>rclImage</i>: Bounding rectangle of the image within the bitmap specified by the <i>hbmImage </i>member.</li>
</ul>
<h4>INDEXTOOVERLAYMASK</h4>
<p>
<b>UINT INDEXTOOVERLAYMASK(UINT <i>i</i>)</b></p>
<p>
The <b>INDEXTOOVERLAYMASK</b> macro prepares the one-based index of an overlay mask so the <b>ImageList_Draw</b> function can use it. The <i>i</i> parameter is the index of an overlay mask. The macro is defined as follows:</p>
<pre><code>#define INDEXTOOVERLAYMASK(i) ((i) &lt;&lt; 8)
</code></pre>
<h3>Image List Functions</h3>
<h4>ImageList_Add</h4>
<pre><code>int WINAPI ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_Add</b> function adds one or more images to an image list. You can add bitmapped images, icons, or cursors. The first bitmap contains one or more images to add to the image bitmap, and the second bitmap contains the masks to add to the mask bitmap. For nonmasked image lists, the second bitmap handle is ignored; you can set it to NULL.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i>: Handle of the image list.<br><br></li>
<li>
<i>hbmImage</i>: Handle of the bitmap containing the image or images. The number of images is inferred from the width of the bitmap.<br><br></li>
<li>
<i>hbmMask</i>: Handle of the bitmap containing the mask. This parameter is ignored if no mask is used with the image list.</li>
</ul>
<p>
<b>Return value:</b> The zero-based index of the first new image if successful; –1 otherwise.</p>
<h4>ImageList_AddIcon</h4>
<pre><code>int&nbsp; WINAPI ImageList_AddIcon(HIMAGELIST himl, HICON hicon);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_AddIcon</b> function adds an icon to an image list. Since the system does not the save the <i>hicon</i> that is passed in, you can destroy the <i>hicon</i> after the function returns.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i>: Handle of the image list. If <i>himl</i> identifies a masked image list, the function copies both the image bitmap and the mask bitmap of the icon. If <i>himl</i> identifies a nonmasked image list, the function copies only the image bitmap.<br><br></li>
<li>
<i>hicon</i>: Handle of the icon that contains the bitmap and mask for the new image.</li>
</ul>
<p>
<b>Return value:</b> The zero-based index of the new image if successful; –1 otherwise.</p>
<h4>ImageList_AddMasked</h4>
<pre><code>int WINAPI ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF 
 &nbsp; crMask);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_AddMasked</b> function adds one or more images to an image list, generating a mask from the given bitmap.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i>: Handle of the image list.<br><br></li>
<li>
<i>hbmImage</i>: Handle of the bitmap containing the image or images. The number of images is inferred from the width of the bitmap.<br><br></li>
<li>
<i>crMask</i>: Color used to generate the mask. Each pixel of this color in the given bitmap is changed to black, and the corresponding bit in the mask is set to one.</li>
</ul>
<p>
<b>Return value:</b> The zero-based index of the first new image if successful; –1 otherwise.</p>
<h4>ImageList_BeginDrag</h4>
<pre><code>BOOL WINAPI ImageList_BeginDrag(HIMAGELIST himlTrack, int iTrack, int dxHotspot, 
 &nbsp; int dyHotspot);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_BeginDrag</b> function begins dragging an image and creates a temporary image list that is used for dragging. The drag image combines the specified image and its mask with the current cursor. The drag image can be moved using the <b>ImageList_DragMove</b> function.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himlTrack</i> and <i>iTrack</i>: Handle of the image list and index of the image to drag.<br><br></li>
<li>
<i>dxHotSpot</i> and <i>dyHotSpot</i>: Location of the drag position relative to the upper-left corner of the image.</li>
</ul>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>ImageList_Create</h4>
<pre><code>HIMAGELIST WINAPI ImageList_Create(int cx, int cy, UINT fFlags, int cInitial, 
 &nbsp; int cGrow);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_Create</b> function creates a new image list. For a nonmasked image list, it creates a single bitmap large enough to hold the number of images.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>cx</i> and <i>cy</i>: Dimensions of each image, in pixels.<br><br></li>
<li>
<i>fFlags</i>: Value specifying how to create the image list. This can be one of the following flags:<p class=tl>
ILC_MASK: The image list has a mask.</P><p class=tl>
ILC_COLOR: The bit depth of the image list.</P><p class=tl>
ILC_COLORDDB: Use device-dependent bitmap.</P><p class=tl>
ILC_COLOR4: Use 4-bpp (bits-per-pixel) DIBSection.</P><p class=tl>
ILC_COLOR8: Use 8-bpp DIBSection.</P><p class=tl>
ILC_COLOR16: Use 16-bpp DIBSection.</P><p class=tl>
ILC_COLOR24: Use 24-bpp DIBSection.</P><p class=tl>
ILC_COLOR32: Use 32-bpp DIBSection.</P><p class=tl>
ILC_PALETTE: Use palette with image list.</P></li>
<li>
<i>cInitial</i>: Initial size of the bitmaps used by the image list. This parameter represents the number of images the initial bitmaps can contain.<br><br></li>
<li>
<i>cGrow</i>: Amount by which you wish to increase the size of the bitmaps to make room for new images. This parameter represents the number of new images the resized bitmaps can contain.</li>
</ul>
<p>
<b>Return value:</b> The handle of the image list if successful; NULL otherwise.</p>
<h4>ImageList_Destroy</h4>
<pre><code>BOOL WINAPI ImageList_Destroy(HIMAGELIST himl);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_Destroy</b> function destroys an image list.</p>
<p>
<b>Parameters:</b> <i>himl</i> is the handle of the image list to destroy.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>ImageList_DragEnter</h4>
<pre><code>BOOL WINAPI ImageList_DragEnter(HWND hwndLock, int x, int y);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_DragEnter</b> function locks the specified area of the screen from other updates. This function is called during a drag operation.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>hwndLock</i>: Handle of the window containing the image.<br><br></li>
<li>
<i>x </i>and<i> y</i>: The coordinates of the image.</li>
</ul>
<p>
<b>Return value:</b> TRUE if successful; NULL otherwise.</p>
<h4>ImageList_DragLeave</h4>
<pre><code>BOOL WINAPI ImageList_DragLeave(HWND hwndLock);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_DragLeave</b> function removes any locks on the lcoked area of the screen via a call to <b>ImageList_DragEnter</b>.</p>
<p>
<b>Parameters: </b><i>hwndLock</i> is the handle of the window containing the image.</p>
<p>
<b>Return value:</b> TRUE if successful; NULL otherwise.</p>
<h4>ImageList_DragMove</h4>
<pre><code>BOOL WINAPI ImageList_DragMove(int x, int y);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_DragMove</b> function moves the drag image. This function is typically called in response to a WM_MOUSEMOVE message during a dragging operation.</p>
<p>
<b>Parameters:</b> <i>x</i> and <i>y</i> represent the new drag position.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>ImageList_Draw</h4>
<pre><code>BOOL WINAPI ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, 
 &nbsp; int y, UINT fStyle);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_Draw</b> function draws an image list item in the specified DC. The drawing styles listed in Table 1 below have no effect on the appearance of a nonmasked image. A nonmasked image is copied to the destination DC using the SRCCOPY raster operation. The colors in the image appear the same regardless of the background color of the DC.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i> and <i>i</i>: Handle of the image list and index of the image to draw.<br><br></li>
<li>
<i>hdcDst</i>: Handle of the device context to draw in.<br><br></li>
<li>
<i>x</i> and <i>y</i>: Where to draw.<br><br></li>
<li>
<i>fStyle</i>: The drawing style. This can be one or more of the values listed in Table 1 below.</li>
</ul>
<p class=label>
<b>Table 1. Image List Drawing Styles</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=23%><b>Style</b></td>
<td class=label width=77%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=23%>ILD_MASK</td>
<td width=77%>Draws the mask.</td>
</tr>
<tr valign=top>
<td width=23%>ILD_IMAGE</td>
<td width=77%>Draws the image.</td>
</tr>
<tr valign=top>
<td width=23%>ILD_BLEND</td>
<td width=77%>Blends the image with the color passed.</td>
</tr>
<tr valign=top>
<td width=23%>ILD_BLEND25</td>
<td width=77%>Blends the image with 25 percent of the color passed.</td>
</tr>
<tr valign=top>
<td width=23%>ILD_BLEND50</td>
<td width=77%>Blends the image with 50 percent of the color passed.</td>
</tr>
<tr valign=top>
<td width=23%>ILD_FOCUS</td>
<td width=77%>Draws the image striped with the highlight color to indicate that it has the focus. This flag has no effect if ILD_SELECTED is not also specified or the image list does not contain a mask.</td>
</tr>
<tr valign=top>
<td width=23%>ILD_NORMAL</td>
<td width=77%>Draws the image using the background color for the image list. If the background color is CLR_NONE, the image is drawn transparently using the mask.</td>
</tr>
<tr valign=top>
<td width=23%>ILD_OVERLAYMASK</td>
<td width=77%>Uses these as indexes to special image items.</td>
</tr>
<tr valign=top>
<td width=23%>ILD_SELECTED</td>
<td width=77%>Draws the image dithered with the highlight color to indicate that it is selected. This flag has no effect if the image list does not contain a mask.</td>
</tr>
<tr valign=top>
<td width=23%>ILD_TRANSPARENT</td>
<td width=77%>Draws the image transparently using the mask, regardless of the background color. This flag has no effect if the image list does not contain a mask. The function uses a two-step process to draw the masked image. First, it performs a logical AND operation between the bits of the image and the bits of the mask. Next, it performs a logical XOR operation between the results of the first operation and the background bits of the destination DC. This creates transparent areas in the resulting image (that is, each white bit in the mask causes the corresponding bit in the resulting image to be transparent).</td>
</tr>
</table><br>
<h4>ImageList_DrawEx</h4>
<pre><code>BOOL WINAPI ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst,
 &nbsp; int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, 
 &nbsp; UINT fStyle);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_DrawEx</b> function draws an image based on the flags and colors passed into the function.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i> and <i>i</i>: Handle of the image list and index of the image to draw.<br><br></li>
<li>
<i>hdcDest</i>: Handle to the device context that the image is to be drawn to.<br><br></li>
<li>
<i>x</i> ,<i>y, dx, dy</i>: Coordinates of the image relative to the upper-left corner of the display.<br><br></li>
<li>
<i>rgbBk and rgbFg</i>: Background and foreground colors to use for the image.<br><br></li>
<li>
<i>fStyle</i>: The style to use when drawing the image. The valid styles can be any combination of the flags listed in Table 1.</li>
</ul>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>ImageList_EndDrag</h4>
<pre><code>HIMAGELIST WINAPI ImageList_EndDrag(VOID);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_EndDrag</b> function ends a drag operation. Although this function returns the handle of the temporary image list that is used for dragging, the temporary image list is destroyed, so the handle returned by this function is invalid.</p>
<p>
<b>Parameters:</b> None.</p>
<p>
<b>Return value:</b> The handle of the temporary image list used for dragging, if successful; NULL otherwise.</p>
<h4>ImageList_ExtractIcon</h4>
<pre><code>HICON WINAPI ImageList_ExtractIcon(HINSTANCE hAppInst, HIMAGELIST himl, int i);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_ExtractIcon</b> function creates an icon based on an image and mask in an image list.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>hAppInst</i>: Handle of the application instance that will own the icon.<br><br></li>
<li>
<i>himl</i> and <i>i</i>: Handle of the image list and index of the image.</li>
</ul>
<p>
<b>Return value:</b> The handle of the new icon if successful; NULL otherwise.</p>
<h4>ImageList_GetBkColor</h4>
<pre><code>COLORREF WINAPI ImageList_GetBkColor(HIMAGELIST himl);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_GetBkColor</b> function gets the current background color for an image list.</p>
<p>
<b>Parameters:</b> <i>himl</i> is the handle of the image list.</p>
<p>
<b>Return value:</b> Current background color.</p>
<h4>ImageList_GetIcon</h4>
<pre><code>HICON WINAPI ImageList_GetIcon(HIMAGELIST himl, int I, UINT flags);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_GetIcon</b> function gets the specified icon in the image list.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i> and <i>i</i>: Handle of the image list and index of the image to get.<br><br></li>
<li>
<i>flags</i>: How the icon should be created. The valid styles can be any combination of the flags listed in Table 1.</li>
</ul>
<p>
<b>Return value:</b> The handle of the icon if successful; FALSE otherwise.</p>
<h4>ImageList_GetIconSize</h4>
<pre><code>BOOL WINAPI ImageList_GetIconSize(IMAGELIST himl, int FAR *cx, int FAR *cy);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_GetIconSize</b> function gets the dimensions of each image in an image list.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i>: Handle of the image list.<br><br></li>
<li>
<i>cx</i> and <i>cy</i>: Addresses of integer variables that receive the width and height, in pixels, of each image.</li>
</ul>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>ImageList_GetImageCount</h4>
<pre><code>int WINAPI ImageList_GetImageCount(HIMAGELIST himl);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_GetImageCount</b> function gets the number of images in an image list.</p>
<p>
<b>Parameters: </b><i>himl</i> is the handle of the image list.</p>
<p>
<b>Return value:</b> The number of images in the list.</p>
<h4>ImageList_GetImageInfo</h4>
<pre><code>BOOL WINAPI ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO FAR* 
 &nbsp; pImageInfo);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_GetImageInfo</b> function gets information about an image and fills an <b>IMAGEINFO</b> structure with information about a single image. You can use this information to manipulate the bitmaps for the image directly.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i> and <i>i</i>: Handle of the image list and index of the image.<br><br></li>
<li>
<i>pImageInfo</i>: Address of an <b>IMAGEINFO</b> structure that receives information about the image.</li>
</ul>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>ImageList_LoadBitmap</h4>
<pre><code>HIMAGELIST WINAPI ImageList_LoadBitmap(HINSTANCE hi, LPCSTR lpbmp, int cx, 
 &nbsp; int cGrow, COLORREF crMask);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_LoadBitmap</b> function creates an image list from the given bitmap resource.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>hi</i> and <i>lpbmp</i>: Handle of the instance containing the bitmap resource, and the name of the resource.<br><br></li>
<li>
Width of each image. The height of each image and the initial number of images are inferred by the dimensions of the given bitmap.<br><br></li>
<li>
<i>cGrow</i>: Amount by which you wish to increase the size of bitmaps to make room for new images. This parameter represents the number of new images the resized bitmaps can contain.<br><br></li>
<li>
<i>crMask</i>: Color used to generate a mask. Each pixel of this color in the given bitmap is changed to black, and the corresponding bit in the mask is set to one. If this parameter is CLR_NONE, no mask is generated.</li>
</ul>
<p>
<b>Return value:</b> The handle of the image list if successful; NULL otherwise.</p>
<h4>ImageList_Merge</h4>
<pre><code>HIMAGELIST WINAPI ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, 
 &nbsp; int i2, int dx, int dy);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_Merge</b> function merges two existing images, creating a new image list to store the image. The second image is drawn transparently over the first image, and the mask for the new image is the result of performing a logical OR operation between the masks for the two images.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl1</i> and <i>i1</i>: Handle of the first image list and the index of the first existing image.<br><br></li>
<li>
<i>himl2</i> and <i>i2</i>: Handle of the second image list and the index of the second existing image.<br><br></li>
<li>
<i>dx</i> and <i>dy</i>: Offset of the second image relative to the first image.</li>
</ul>
<p>
<b>Return value:</b> The handle of the new image list if successful; NULL otherwise.</p>
<h4>ImageList_Remove</h4>
<pre><code>BOOL WINAPI ImageList_Remove(HIMAGELIST himl, int i);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_Remove</b> function removes an image from an image list.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i>: Handle of the image list.<br><br></li>
<li>
Index of the image to remove.</li>
</ul>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>ImageList_Replace</h4>
<pre><code>BOOL WINAPI ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, 
 &nbsp; HBITMAP hbmMask);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_Replace</b> function replaces an image in an image list.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i> and <i>i</i>: Handle of the image list and index of the image to replace.<br><br></li>
<li>
<i>hbmImage</i>: Handle of the bitmap containing the image.<br><br></li>
<li>
<i>hbmMask</i>: Handle of the bitmap containing the mask. This parameter is ignored if no mask is used with the image list.</li>
</ul>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>ImageList_ReplaceIcon</h4>
<pre><code>int WINAPI ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_ReplaceIcon</b> function replaces an image in an image list, using an icon.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i> and <i>i</i>: Handle of the image list and index of the image to replace.<br><br></li>
<li>
<i>hicon</i>: Handle of the icon that contains the bitmap and mask for the new image.</li>
</ul>
<p>
<b>Return value:</b> The index of the image if successful; –1 otherwise.</p>
<h4>ImageList_SetBkColor</h4>
<pre><code>COLORREF WINAPI ImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_SetBkColor</b> function sets the background color for an image list.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i>: Handle of the image list.<br><br></li>
<li>
<i>clrBk</i>: Background color to set. Can be CLR_NONE, in which case images are drawn transparently using the mask.</li>
</ul>
<p>
<b>Return value:</b> The previous background color if successful; CLR_NONE otherwise.</p>
<h4>ImageList_SetDragCursorImage</h4>
<pre><code>BOOL WINAPI ImageList_SetDragCursorImage(HIMAGELIST himlDrag,
  int iDrag, int dxHotSpot, int dyHotSpot);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_SetDragCursorImage</b> function sets the image of the dragged item.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himlDrag</i> and <i>iDrag</i>: Handle of the image list and index of the image.<br><br></li>
<li>
d<i>xHotSpot </i>and<i> dyHotSpot</i>: The coordinates of the image’s hot spot.</li>
</ul>
<p>
<b>Return value:</b> TRUE if successful; NULL otherwise.</p>
<h4>ImageList_SetOverlayImage</h4>
<pre><code>BOOL WINAPI ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, 
 &nbsp; int iOverlay);
</code></pre>
<p>
<b>Description:</b> The <b>ImageList_SetOverlayImage</b> function adds the index of an image to the list of images to be used as overlay masks. The index must be specified using the <b>INDEXTOOVERLAYMASK</b> macro described above.</p>
<p>
<b>Parameters:</b>
<ul type=disc>
<li>
<i>himl</i> and <i>iImage</i>: Handle of the image list and index of the image to use as an overlay mask.<br><br></li>
<li>
<i>iOverlay</i>: One-based index of the overlay mask. </li>
</ul>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h2>Tree View Windows</h2>
<p class=indent>
<i>You thought that you would never see<br>
A built-in control that supported a tree</i></p>
<p>
Like that one? Have you heard this one:</p>
<p class=indent>
<i>There was a programmer named Dale<br>
Whose knees were exceedingly pale.<br>
He used MFC,<br>
OLE 2, and VB<br>
To write great new code that won't fail.</i></p>
<p>
Well, Dale and many other developers suggested that we support tree structures in the Windows operating environment, so we decided to include them in Windows 95.</p>
<p>
The tree view control gives you a way to display a hierarchical list of items. Each item has a label and can optionally have a bitmap associated with it. You've seen these hierarchies before in File Manager (displaying directory information) and in Microsoft Mail (displaying mail folders). The top item in the hierarchy is called the <i>root</i> <i>item</i>. The root item has no parent. An item that is below the root item in the hierarchy is called a <i>child item</i> of the root. An item that has child items is called a <i>parent item</i>. Child items are displayed in indented form below their parent item. The items can be connected by lines if you specify the TVS_HASLINES style. Figure 1 shows a tree view window that lists houses for sale in various cities in the beautiful Pacific Northwest. (The addresses are fictional—the houses really aren't for sale.)</p>
<p>
<img src="commctl5_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Anatomy of a tree view window</b></p>
<h3>Tree View Window Styles</h3>
<p>
You can use four styles to control the appearance and behavior of a tree view window. These styles are initially set when you create the tree view by calling the <b>CreateWindow</b> or <b>CreateWindowEx</b> function. You can query and change the styles later by using the <b>GetWindowLong</b> and <b>SetWindowLong</b> functions. Table 2 below lists the currently supported window styles that are unique to tree view windows.</p>
<p class=label>
<b>Table 2. Tree View Window Styles</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Style</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%>TVS_EDITLABELS</td>
<td width=75%>Allows the user to edit the labels of list view items. </td>
</tr>
<tr valign=top>
<td width=25%>TVS_HASBUTTONS</td>
<td width=75%>Displays plus (+) and minus (–) buttons next to parent items to expand or collapse the parent item's list of child items. This style does not add buttons to items at the root of the hierarchy. To do that, combine the TVS_HASLINES, TVS_LINESATROOT, and TVS_HASBUTTONS styles.</td>
</tr>
<tr valign=top>
<td width=25%>TVS_HASLINES</td>
<td width=75%>Uses lines to show the hierarchy of items. The lines are drawn to link the parent and child items. This style does not link items at the root of the hierarchy.</td>
</tr>
<tr valign=top>
<td width=25%>TVS_LINESATROOT</td>
<td width=75%>Uses lines to link items at the root of the list view.</td>
</tr>
</table><br>
<h3>Tree View Text Operations</h3>
<p>
A tree view window allocates memory for storing each item in a tree. Having the tree view allocate memory for an item's label can take up quite a bit of memory. If your application is already maintaining a copy of the strings, you may want to avoid this extra allocation. Instead, you can specify that a callback function (LPSTR_TEXTCALLBACK) be used whenever the tree view window needs some text. A TVN_GETDISPINFO notification is then sent to the parent window with the address of a <b>TV_DISPINFO</b> structure. The parent fills in the text for the label when it receives this notification.</p>
<p>
You can allow a user to edit item labels directly in a tree view window by specifying the TVS_EDITLABELS style when creating the tree view window. When the user clicks the label of an item that has the focus, you can assume that label editing should begin. An application sends a TVM_EDITLABEL message to the tree view window to begin editing. The tree view window then notifies the parent window that editing has begun by sending the TVN_BEGINLABLEEDIT notification. When label editing is complete or has been cancelled, a TVN_ENDLABLEEDIT notification is sent to the parent window, and the parent window updates the item's label. You can allow the user to edit some labels and prevent the user from editing others by processing the TVN_BEGINLABELEDIT notification and returning zero to allow editing, or a nonzero value to prevent editing. When label editing is cancelled or completed, the<i> lParam</i> parameter is the address of a <b>TV_DISPINFO</b> structure that identifies the item being edited and the edited text. The item value is –1 if editing was cancelled.</p>
<p>
During label editing, you can get the handle of the edit control by using the TVM_GETEDITCONTROL message. This way, you can limit the amount of text the user can enter (EM_LIMITTEXT) and you can even subclass the edit control to do some dynamic data validation. Since the edit control is created after the TVN_BEGINLABELEDIT notification is sent, you will need to wait until the notification is sent before attempting to get the handle to the edit control.</p>
<h3>Tree View Item Bitmaps</h3>
<p>
Each item in a tree view control can have a pair of bitmaps that appear on the left side of its label. One bitmap is displayed when the item is selected, and the other is displayed when the item is not selected. To use item bitmaps, you must create an image list, add the bitmaps to it, and associate the image list with the tree view control by using the TVM_SETIMAGELIST message. By default, all items display the first image in the image list as both the selected and nonselected bitmaps. You can change this behavior for a particular item by specifying the indexes of the selected and nonselected images when adding the item to the tree view with the TVM_INSERTITEM message.</p>
<h3>Tree View Item States</h3>
<p>
Each item in a tree view control has a current state indicating, for example, whether the item is selected, disabled, or expanded. Most of the time, some type of user action sets the state. For example, when a user clicks an item, the state is set to "selected" in response to the action. However, the item state can also be set programmatically by sending the TVM_SETITEM message or using its corresponding <b>TreeView_SetItem</b> macro. Table 3 lists the currently supported states for tree view items.</p>
<p class=label>
<b>Table 3. Tree View Item States</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Item State</b></td>
<td class=label width=74%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=26%>TVIS_CUT</td>
<td width=74%>The item is marked.</td>
</tr>
<tr valign=top>
<td width=26%>TVIS_DISABLED</td>
<td width=74%>The item is disabled and is drawn using the standard disabled style and color.</td>
</tr>
<tr valign=top>
<td width=26%>TVIS_DROPHILITED</td>
<td width=74%>The item is highlighted as a drag-and-drop target.</td>
</tr>
<tr valign=top>
<td width=26%>TVIS_EXPANDED</td>
<td width=74%>The item's list of child items is currently expanded.</td>
</tr>
<tr valign=top>
<td width=26%>TVIS_EXPANDEDONCE</td>
<td width=74%>The item's list of child items has been expanded at least once.</td>
</tr>
<tr valign=top>
<td width=26%>TVIS_FOCUSED</td>
<td width=74%>The item has the focus and is drawn with the standard focus rectangle.</td>
</tr>
<tr valign=top>
<td width=26%>TVIS_OVERLAYMASK</td>
<td width=74%>An overlay image is used as a mask with the item image.</td>
</tr>
<tr valign=top>
<td width=26%>TVIS_SELECTED</td>
<td width=74%>The item is selected.</td>
</tr>
<tr valign=top>
<td width=26%>TVIS_USERMASK</td>
<td width=74%>A user-defined mask is set. If you set the image to be a state image list, this mask will specify the indexes into the state image list and draw another image next to the normal item image. For example, you can use this state to put a check mark next to a tree view item image.</td>
</tr>
</table><br>
<p>
At any given time, the parent item can be either expanded or collapsed. When a parent item is expanded, the child items are displayed and indented below the parent item. You can set the indentation programmatically by sending the TVM_SETINDENT message. When a parent item is in the collapsed state, the child items are not displayed. When a user double-clicks a parent item or the plus (+) button next to a parent item, the state of the parent item toggles between expanded and collapsed. An application can expand or collapse the parent item programmatically by using the TVM_EXPAND message. A TVN_ITEMEXPANDING notification is then sent. Trapping this notification allows you to prevent the change, or set any attributes of the parent item that depend on the expanded or collapsed state. After changing the state of the parent, the tree view sends the parent window a TVN_ITEMEXPANDED notification.</p>
<h3>Tree View Notification Messages</h3>
<p>
Table 4 contains the list of notifications that are sent to the parent window of a tree view control. <i>lParam</i> sent along with the notification contains a pointer to an <b>NM_TREEVIEW</b> structure for all notifications except TV_GETDISPINFO and TVN_SETDISPINFO. These notifications pass a <b>TV_DISPINFO</b> structure in <i>lParam</i>.</p>
<p class=label>
<b>Table 4. Tree View Notification Messages</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Message</b></td>
<td class=label width=74%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=26%>TVN_BEGINDRAG</td>
<td width=74%>A drag-and-drop operation has begun.</td>
</tr>
<tr valign=top>
<td width=26%>TVN_BEGINLABELEDIT</td>
<td width=74%>In-place label editing has begun.</td>
</tr>
<tr valign=top>
<td width=26%>TVN_BEGINRDRAG</td>
<td width=74%>A drag-and-drop operation using the right mouse button has begun.</td>
</tr>
<tr valign=top>
<td width=26%>TVN_DELETEITEM</td>
<td width=74%>An item has been deleted.</td>
</tr>
<tr valign=top>
<td width=26%>TVN_ENDLABELEDIT</td>
<td width=74%>Label editing has ended.</td>
</tr>
<tr valign=top>
<td width=26%>TVN_GETDISPINFO</td>
<td width=74%>The tree view control needs information (such as item text) to display an item.</td>
</tr>
<tr valign=top>
<td width=26%>TVN_ITEMEXPANDED</td>
<td width=74%>A parent item's list of child items was expanded or collapsed.</td>
</tr>
<tr valign=top>
<td width=26%>TVN_ITEMEXPANDING</td>
<td width=74%>A parent item's list of child items is about to be expanded or collapsed.</td>
</tr>
<tr valign=top>
<td width=26%>TVN_KEYDOWN</td>
<td width=74%>A keyboard event has occurred.</td>
</tr>
<tr valign=top>
<td width=26%>TVN_SELCHANGED</td>
<td width=74%>The item selection has changed. The <i>.action</i> member of the <b>NM_TREEVIEW</b> structure can be one of the following: TVC_UNKNOWN (unknown reason), TVC_BYMOUSE (the selection changed due to a mouse click), or TVC_BYKEYBOARD (the selection changed due to a keyboard event).</td>
</tr>
<tr valign=top>
<td width=26%>TVN_SELCHANGING</td>
<td width=74%>The item selection is about to change. See TVN_SELCHANGED above for more information.</td>
</tr>
<tr valign=top>
<td width=26%>TVN_SETDISPINFO</td>
<td width=74%>The parent window must update the item information.</td>
</tr>
</table><br>
<h3>Creating a Tree View Control</h3>
<p>
To create a tree view control, use the <b>CreateWindow</b> or <b>CreateWindowEx</b> function, and specify the WC_TREEVIEW style for the window class. Remember that the tree view window class is part of the new DLL for common controls (COMCTL32.DLL), so you should call the <b>InitCommonControls</b> function to ensure that COMCTL32.DLL has been loaded. The following example creates a tree view control that is sized to fit the client area of the parent window. It uses the image list functions to create an image list that it associates with the tree view.</p>
<pre><code>HWND CreateTreeView (HWND hWndParent)
{
  HWND hwndTree;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The handle to the tree view window.
  RECT rcl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A rectangle for setting the size of the window.
  HBITMAP hBmp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The handle to a bitmap.
  HIMAGELIST hIml;&nbsp;&nbsp;&nbsp; // The handle to the image list.

  // Ensure that the common-control DLL is loaded.
  InitCommonControls();

  // Get the size and position of the parent window.
  GetClientRect(hWndParent, &amp;rcl);

  // Create the tree view window.
  hwndTree = CreateWindowEx( 0L,
 &nbsp;&nbsp; WC_TREEVIEW,
 &nbsp;&nbsp; "",
 &nbsp;&nbsp; WS_VISIBLE | WS_CHILD | WS_BORDER | TVS_HASLINES | TVS_HASBUTTONS | 
 &nbsp;&nbsp;&nbsp;&nbsp; TVS_LINESATROOT,
 &nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp; rcl.right - rcl.left, rcl.bottom - rcl.top,
 &nbsp;&nbsp; hWndParent,
 &nbsp;&nbsp; (HMENU) ID_TREEVIEW,
 &nbsp;&nbsp; hInst,
 &nbsp;&nbsp; NULL );

  if (hwndTree == NULL )
 &nbsp;&nbsp; return NULL;

  // Initialize the tree view window.
  // First, create the image list we will need.
  hIml = ImageList_Create( BITMAP_WIDTH, BITMAP_HEIGHT,
 &nbsp;&nbsp; FALSE, NUM_BITMAPS, 0 );

  // Load the bitmaps and add them to the image lists.
  hBmp = LoadBitmap(hInst, MAKEINTRESOURCE(FORSALE));
  idxForSale = ImageList_Add(hIml, hBmp, NULL);

  hBmp = LoadBitmap(hInst, MAKEINTRESOURCE(REDMOND));
  idxRedmond = ImageList_Add(hIml, hBmp, NULL);

  hBmp = LoadBitmap(hInst, MAKEINTRESOURCE(BELLEVUE));
  idxBellevue = ImageList_Add(hIml, hBmp, NULL);

  hBmp = LoadBitmap(hInst, MAKEINTRESOURCE(SEATTLE));
  idxSeattle = ImageList_Add(hIml, hBmp, NULL);

  // Make sure that all of the bitmaps were added.
  if (ImageList_GetImageCount(hIml) &lt; NUM_BITMAPS)
 &nbsp;&nbsp; return FALSE;

  // Associate the image list with the tree.
  TreeView_SetImageList(hwndTree, hIml, idxForSale);

  return (hwndTree);
}
</code></pre>
<h3>Adding Tree View Items</h3>
<p>
Now that our tree view window has been created, it is time to add items to it. You can add items to a tree view by sending the TVM_INSERTITEM message or by calling the associated <b>TreeView_InsertItem</b> macro. For each item that you want to insert, you fill out the <b>TV_ITEM</b> and <b>TV_INSERTSTRUCT</b> structures. When adding an item, you must specify the handle of the new item's parent item. If you specify NULL or TVI_ROOT instead of an item handle, the item is added as a root item.</p>
<p>
The example below demonstrates how to add items to a tree view window. This sample handles a real-estate listing for three cities, with three houses listed for each city. A global structure keeps track of the handle to the parent item and its image.</p>
<pre><code>typedef struct tagHOUSEINFO {
 &nbsp; char szAddress[MAX_ADDRESS];
 &nbsp; int iImage;
 &nbsp; HTREEITEM hParent;
}

BOOL AddTreeViewItems( HWND hwndTree )
{
  static HTREEITEM hTRoot, hTRed, hTBel, hTSea, hPrev;
  char szText[MAX_LEN];
  int index;

  // First, add the root item "Houses for Sale".
  LoadString(hInst, IDS_FORSALE, szText, MAX_LEN);
  hTRoot = AddOneItem((HTREEITEM)NULL, szText, (HTREEITEM)TVI_ROOT, idxForSale,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwndTree);

  // Now add the cities.
  LoadString(hInst, IDS_REDMOND, szText, MAX_LEN);
  hTRed = AddOneItem(hTRoot, szText, (HTREEITEM)TVI_FIRST, idxRedmond, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwndTree);

  LoadString(hInst, IDS_BELLEVUE, szText, MAX_LEN);
  hTBel = AddOneItem(hTRoot, szText, hTRed, idxBellevue, hwndTree);

  LoadString(hInst, IDS_SEATTLE, szText, MAX_LEN);
  hTSea = AddOneItem(hTRoot, szText, hTBel, idxSeattle, hwndTree);

  // Fill in the structure for each house.
  FillInStruct(hTRed, idxRedmond, 0, 3);
  FillInStruct(hTBel, idxBellevue, 3, 6);
  FillInStruct(hTSea, idxSeattle, 6, 9);

  // Add the houses for each city.
  hPrev = hTSea;
  for (index = 0; index &lt; NUM_HOUSES; index++)
 &nbsp;&nbsp; hPrev = AddOneItem(rgHouseInfo[index].hParent, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgHouseInfo[index].szAddress,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hPrev,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgHouseInfo[index].iImage,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwndTree);
  return TRUE;
}

// This function saves the current image and handle to the
// parent of the tree view item.
VOID FillInStruct(HTREEITEM hParent, int iImage, int index, int iMax)
{
  for (;index &lt; iMax; index++)
  {
 &nbsp;&nbsp; rgHouseInfo[index].iImage = iImage;
 &nbsp;&nbsp; rgHouseInfo[index].hParent = hParent;
  }
}

// This function fills in the TV_ITEM and TV_INSERTSTRUCT structures and 
// adds the item to the tree view.
HTREEITEM AddOneItem( HTREEITEM hParent, LPSTR szText, HTREEITEM hInsAfter, 
  int iImage, HWND hwndTree)
{
  HTREEITEM hItem;
  TV_ITEM tvI;
  TV_INSERTSTRUCT tvIns;

  // The .pszText, .iImage, and .iSelectedImage are filled in.
  tvI.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
  tvI.pszText = szText;
  tvI.cchTextMax = lstrlen(szText);
  tvI.iImage = iImage;
  tvI.iSelectedImage = iImage;

  tvIns.item = tvI;
  tvIns.hInsertAfter = hInsAfter;
  tvIns.hParent = hParent;
  
  // Insert the item into the tree.
  hItem = (HTREEITEM)SendMessage(hwndTree, TVM_INSERTITEM, 0, 
 &nbsp;&nbsp; (LPARAM)(LPTV_INSERTSTRUCT)&amp;tvIns);

  return (hItem);

}
</code></pre>
<h3>Drag-and-Drop Operations for a Tree View Item</h3>
<p>
Now that you have a tree view that can be expanded and collapsed, you may be thinking how neat it would be if the user could just pick up one of the items and drag it to a new location. The tree view window has some built-in functions that facilitate dragging and dropping of tree view items. When processing the drag operation for a tree view item, an application typically does three things:
<ul type=disc>
<li>
Processes the start of the drag (picking up the item) via the TVN_BEGINDRAG (user is using the left mouse button for dragging) or TVNBEGINRDRAG (user is using the right mouse button for dragging) notification in the parent window's window procedure. These notifications are sent via a WM_NOTIFY message.<br><br></li>
<li>
Processes the dragging operation by capturing the mouse and monitoring the WM_MOUSEMOVE messages. In a typical drag-and-drop scenario, the image appears to be dragged because the cursor is changed to the image of the item being dragged. This is done by using the image list functions and is shown in the code example below.<br><br></li>
<li>
Processes the drop. When the user is finished dragging the item, an application can look for the WM_LBUTTONUP message. At this point, the currently selected item is recorded, the mouse is released, and the cursor is restored to the previous state. This is also the place where you would want to reset the parentage of the item and reset any internal structures you might have that are keeping track of your tree items. Remember to reset the drop highlight item. During the drag operation, the current item is selected as the drop highlight. When the item is dropped, you need to set the drop highlight back to NULL or you will end up with two items that appear selected, because selected items and drop highlight items are painted the same way. This is remedied by another call to <b>TreeView_SelectItem</b> passing NULL for the <i>hItem</i> parameter.</li>
</ul>
<p>
The following example demonstrates how to handle a simple drag-and-drop operation in a tree view window.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;case WM_NOTIFY:
 &nbsp;&nbsp;&nbsp;&nbsp; switch( ((LPNMHDR)lParam)-&gt;code)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case TVN_BEGINDRAG:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The user wants to drag an item. Call the drag handler.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BeginDrag(hWndTreeView, (NM_TREEVIEW *)lParam);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Save off the dragged item information.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tvI = ((NM_TREEVIEW *)lParam)-&gt;iItemNew;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case WM_MOUSEMOVE:
 &nbsp;&nbsp;&nbsp;&nbsp; // If dragging, move the image.
 &nbsp;&nbsp;&nbsp;&nbsp; if (g_fDragging)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Drag the item to the current mouse position.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImageList_DragMove(LOWORD(lParam),HIWORD(lParam));
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the cursor is on an item, highlight it as the drop target.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tvHit.pt.x = LOWORD(lParam);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tvHit.pt.y = HIWORD(lParam);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((hTarget = TreeView_HitTest(hWndTreeView, &amp;tvHit)) != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TreeView_SelectDropTarget(hWndTreeView, hTarget);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case WM_LBUTTONUP:
 &nbsp;&nbsp;&nbsp;&nbsp; // If dragging, stop it.
 &nbsp;&nbsp;&nbsp;&nbsp; if (g_fDragging)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Process item drop.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DropItem(hDragItem, hWndTreeView);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Inform image list that dragging has stopped.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImageList_EndDrag();

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Release the mouse capture.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReleaseCapture();

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Show the cursor.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowCursor(TRUE);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reset the global Boolean flag to a non-dragging state.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_fDragging = FALSE;

 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; break;
.
.
.
VOID BeginDrag(HWND hwndTree, NM_TREEVIEW *lItem)
{
  HIMAGELIST hIml;
  RECT rcl;
  DWORD dwLevel;
  DWORD dwIndent;

  // Create an image to use for dragging.
  hIml = TreeView_CreateDragImage(hwndTree, lItem-&gt;itemNew.hItem);

  // Get the bounding rectangle of the item being dragged.
  TreeView_GetItemRect(hwndTree, lItem-&gt;itemNew.hItem, &amp;rcl, TRUE);

  // Start dragging the image.
  ImageList_BeginDrag(hIml, 0, lItem-&gt;ptDrag.x, lItem-&gt;ptDrag.y);

  // Show the cursor.
  ShowCursor(FALSE);

  // Capture the mouse.
  SetCapture(GetParent(hwndTree));

  // Set a global flag that tells whether dragging is happening.
  g_fDragging = TRUE;
}

// Function that processes the item drop.
VOID DropItem(HTREEITEM hDragItem, HWND hwnd)
{
 &nbsp; HTREEITEM hParent, hNewItem, hTarget;
 &nbsp; TV_ITEM tvTarget;
 &nbsp; int index;

 &nbsp; // Get the handle to the drop target.
 &nbsp; hTarget = TreeView_GetDropHilight(hwnd);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; // Get the parent of the drop target.
 &nbsp; hParent = TreeView_GetParent(hwnd, hTarget);

 &nbsp; // Get the image information.
 &nbsp; tvTarget.hItem = hTarget;
 &nbsp; tvTarget.mask = TVIF_IMAGE;
 &nbsp; TreeView_GetItem(hwnd, &amp;tvTarget);

 &nbsp; // Get the index into the structure maintained containing
 &nbsp; // the text for the items.
 &nbsp; for (index = 0; index &lt; NUM_HOUSES; index++)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (rgHouseInfo[index].hItem == hDragItem)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; }

 &nbsp; if (index == NUM_HOUSES)
 &nbsp;&nbsp;&nbsp;&nbsp; index--;

 &nbsp; // Insert the new item back in.
 &nbsp; hNewItem = AddOneItem( hParent, rgHouseInfo[index].szAddress, hTarget, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tvTarget.iImage, hwnd);

 &nbsp; // Delete the "dragged" item.
 &nbsp; TreeView_DeleteItem(hwnd, hDragItem);

 &nbsp; // Reset the drop target to NULL.
 &nbsp; TreeView_SelectDropTarget(hwnd, (HTREEITEM)NULL);
}
</code></pre>
<h3>Tree View Structures</h3>
<p>
This section describes the structures that are unique to tree view windows. If you have been following this series of articles closely, you will know that this is one of the sections that you can skip if you really hate to read lists. So go ahead. Skip this section. See if it hurts my feelings. Don't even think about how much time and effort it took me to write this.</p>
<h4>NM_TREEVIEW</h4>
<pre><code>typedef struct _NM_TREEVIEW {
 &nbsp;&nbsp; NMHDR hdr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ common control notification structure
 &nbsp;&nbsp; UINT action;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ notification-specific action flag
 &nbsp;&nbsp; TV_ITEM itemOld;&nbsp; \\ old item state
 &nbsp;&nbsp; TV_ITEM itemNew;&nbsp; \\ new item state
 &nbsp;&nbsp; POINT ptDrag;&nbsp;&nbsp;&nbsp;&nbsp; \\ location where event occurred
} NM_TREEVIEW;
</code></pre>
<p>
The <b>NM_TREEVIEW</b> structure contains information about a tree view notification. The address of this structure is specified as the <i>lParam</i> parameter of the WM_NOTIFY message for several tree view notifications. The structure includes the following members:
<ul type=disc>
<li>
<b>NMHDR</b> <i>hdr</i>: Required for all WM_NOTIFY messages.<br><br></li>
<li>
<b>UINT</b> <i>action</i>: Notification-specific action flag.<br><br></li>
<li>
<b>TV_ITEM</b> <i>itemOld</i>: Address of a <b>TV_ITEM</b> structure containing information about the old item states.<br><br></li>
<li>
<b>TV_ITEM</b> <i>itemNew</i>: Address of a <b>TV_ITEM</b> structure containing information about the new item states.<br><br></li>
<li>
<b>POINT</b> <i>ptDrag</i>: A <b>POINT</b> structure that contains the client coordinates of the mouse at the time the event that caused the notification to be sent occurred.</li>
</ul>
<h4>TV_DISPINFO</h4>
<pre><code>typedef struct _TV_DISPINFO {
 &nbsp;&nbsp; NMHDR hdr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ common control notification structure
 &nbsp;&nbsp; TV_ITEM item;&nbsp;&nbsp; \\ tree view item information
} TV_DISPINFO;
</code></pre>
<p>
The <b>TV_DISPINFO</b> structure contains information about the display of tree view items. The structure includes the following members:
<ul type=disc>
<li>
<b>NMHDR</b> <i>hdr</i>: Required for all WM_NOTIFY messages.<br><br></li>
<li>
<b>TV_ITEM</b> <i>item</i>: Contains information about the tree view item. The <i>mask</i> member identifies the information being set or queried; it can be one or more of these values: TVIF_IMAGE, TVIF_STATE, or TVIF_TEXT. See the <b>TV_ITEM</b> structure description below for more information.</li>
</ul>
<h4>TV_HITTESTINFO</h4>
<pre><code>typedef struct _TV_HITTESTINFO {
 &nbsp;&nbsp; POINT pt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ coordinates of point to test
 &nbsp;&nbsp; UINT flags;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ receives hit test information
 &nbsp;&nbsp; HTREEITEM hitem;&nbsp; \\ item that occupies the hit point
} TV_HITTESTINFO;
</code></pre>
<p>
The <b>TV_HITTESTINFO</b> structure contains information used to determine the location of a point relative to a tree view control. This structure is used with the TVM_HITTEST message. <b>TV_HITTESTINFO</b> includes the following members:
<ul type=disc>
<li>
<b>POINT</b> <i>pt</i>: The client coordinates of the point to test.<br><br></li>
<li>
<b>UINT</b> <i>flags</i>: Variable that receives information about the results of a hit test. It can be one or more of these values: <p class=tl>
TVHT_ABOVE: Above the client area.</P><p class=tl>
TVHT_BELOW: Below the client area.</P><p class=tl>
TVHT_NOWHERE: In the client area, but below the last item.</P><p class=tl>
TVHT_ONITEM: On the bitmap or label associated with an item.</P><p class=tl>
TVHT_ONITEMBUTTON: On the button associated with an item.</P><p class=tl>
TVHT_ONITEMICON: On the bitmap associated with an item.</P><p class=tl>
TVHT_ONITEMINDENT: In the indentation associated with an item.</P><p class=tl>
TVHT_ONITEMLABEL: On the text label associated with an item.</P><p class=tl>
TVHT_ONITEMRIGHT: In the area to the right of an item.</P><p class=tl>
TVHT_ONITEMSTATEICON: On the state image icon.</P><p class=tl>
TVHT_TOLEFT: To the right of the client area.</P><p class=tl>
TVHT_TORIGHT: To the left of the client area.</P></li>
<li>
<b>HTREEITEM</b> <i>hItem</i>: The handle of the item that occupies the point.</li>
</ul>
<h4>TV_INSERTSTRUCT</h4>
<pre><code>typedef struct _TV_INSERTSTRUCT {
 &nbsp;&nbsp; HTREEITEM hParent;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the parent item
 &nbsp;&nbsp; HTREEITEM hInsertAfter;&nbsp;&nbsp; \\ handle of item after which to insert this item
 &nbsp;&nbsp; TV_ITEM item;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ item to insert
} TV_INSERTSTRUCT;
</code></pre>
<p>
The <b>TV_INSERTSTRUCT</b> structure contains information used to add a new item to a tree view control. This structure is used with the TVM_INSERTITEM message. <b>TV_INSERTSTRUCT</b> includes the following members:
<ul type=disc>
<li>
<b>HTREEITEM</b> <i>hParent</i>: Handle of the parent item. If this parameter is TVI_ROOT or NULL, the item is inserted at the root of the tree view control.<br><br></li>
<li>
<b>HTREEITEM</b> <i>hInsertAfter</i>: Handle of the item after which the new item is to be inserted, or one of the following values:<p class=tl>
TVI_ROOT: Inserts the item at the root of the tree.</P><p class=tl>
TVI_FIRST: Inserts the item at the beginning of the list.</P><p class=tl>
TVI_LAST: Inserts the item at the end of the list.</P><p class=tl>
TVI_SORT: Inserts the item into the list in alphabetical order.</P></li>
<li>
<b>TV_ITEM</b> <i>item</i>: A structure containing information about the item to add (described below).</li>
</ul>
<h4>TV_ITEM</h4>
<pre><code>typedef struct _TV_ITEM {
 &nbsp;&nbsp; UINT mask;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ specifies which members are valid
 &nbsp;&nbsp; HTREEITEM hItem;&nbsp;&nbsp;&nbsp;&nbsp; \\ the item that this structure refers to
 &nbsp;&nbsp; UINT state;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ current state of the item
 &nbsp;&nbsp; UINT stateMask;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ current state of the item mask
 &nbsp;&nbsp; LPSTR pszText;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ text for the item
 &nbsp;&nbsp; int cchTextMax;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ size of the buffer containing the item text
 &nbsp;&nbsp; int iImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the image for this item
 &nbsp;&nbsp; int iSelectedImage;&nbsp; \\ index of the selected image
 &nbsp;&nbsp; int cChildren;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ number of child nodes
 &nbsp;&nbsp; LPARAM lParam;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ application-defined item data
} TV_ITEM;
</code></pre>
<p>
The <b>TV_ITEM</b> structure contains the attributes of a tree view item. When this structure is used in conjunction with a function or message that gets item information, only the structure members specified in the <i>mask</i> member contain valid data, and all other members are invalid. When this structure is used in conjunction with a function that sets item information, the <i>mask </i>member specifies which of the attributes are valid and should be set. The <b>TV_ITEM</b> structure includes the following members:
<ul type=disc>
<li>
<b>UINT</b> <i>mask</i>: This is an array of flags that identify the other structure members that contain valid data or those that should be filled in. It can be a combination of the following values:<p class=tl>
TVIF_CHILDREN: The <i>cChildren</i> member is valid.</P><p class=tl>
TVIF_HANDLE: The <i>hItem</i> member is valid.</P><p class=tl>
TVIF_IMAGE: The <i>iImage</i> member is valid.</P><p class=tl>
TVIF_PARAM: The<i> lParam</i> member is valid.</P><p class=tl>
TVIF_SELECTEDIMAGE: The <i>iSelectedImage</i> member is valid.</P><p class=tl>
TVIF_STATE: The <i>state</i> and <i>stateMask</i> members are valid.</P><p class=tl>
TVIF_TEXT: The<i> pszText</i> an <i>cchTextMax </i>members are valid.</P></li>
<li>
<b>HTREEITEM</b> <i>hItem</i>: The item that this structure refers to.<br><br></li>
<li>
<b>UINT</b> <i>state</i> and <i>stateMask</i>: These members contain values specifying the current state of the item and the valid states of the item. They can be any valid combination of state values listed in Table 3 previously in this article.<br><br></li>
<li>
<b>LPSTR</b> <i>pszText</i>: The address of a null-terminated string containing the item text, if the structure specifies item attributes. If this member is LPSTR_TEXTCALLBACK, the parent window is responsible for storing the name, and the tree view sends the parent window a TVN_GETDISPINFO notification when it needs the item text for displaying, sorting, or editing. The tree view sends a TVN_SETDISPINFO notification when the item text changes. If the structure is receiving item attributes, this member is the address of the buffer that receives the item text.<br><br></li>
<li>
<b>int</b> <i>cchTextMax</i>: The size of the buffer that the <i>pszText </i>member points to, if the structure is receiving item attributes.<br><br></li>
<li>
<b>int</b> <i>iImage</i> and <i>iSelectedImage</i>: The indexes of the icon image and selected icon image within the image list. If either member is I_IMAGECALLBACK, the parent window is responsible for storing the corresponding images, and the tree view sends the parent a TVN_GETDISPINFO notification when it needs to display the images and a TVN_SETDISPINFO notification when the images change.<br><br></li>
<li>
<b>int</b> <i>cChildren</i>: The number of child items associated with the item. If this member is I_CHILDRENCALLBACK, the parent window is responsible for drawing the child items, and the tree view control sends the parent a TVN_GETDISPINFO notification when it needs to display the child items and a TVN_SETDISPINFO notification when the attributes of a child item change.<br><br></li>
<li>
<b>LPARAM</b> <i>lParam</i>: This is application-defined data.</li>
</ul>
<h4>TV_KEYDOWN</h4>
<pre><code>typedef struct _TV_KEYDOWN {
 &nbsp;&nbsp; NMHDR hdr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ common control notification structure
 &nbsp;&nbsp; WORD wVKey;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ virtual key code
 &nbsp;&nbsp; UINT flags;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used; always set to zero
} TV_KEYDOWN;
</code></pre>
<p>
The <b>TV_KEYDOWN</b> structure contains information about a keyboard event in a tree view control. This structure is used with the TVN_KEYDOWN notification. <b>TV_KEYDOWN</b> includes the following members:
<ul type=disc>
<li>
<b>NMHDR</b> <i>hdr</i>: Notification header that is required for all WM_NOTIFY messages.<br><br></li>
<li>
<b>WORD</b> <i>wVKey</i>: The virtual key code.<br><br></li>
<li>
<b>UINT</b> <i>flags</i>: Currently unused (always set to zero).</li>
</ul>
<h4>TV_SORTCB</h4>
<pre><code>typedef struct _TV_SORTCB {
 &nbsp;&nbsp; HTREEITEM hParent;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the parent item
 &nbsp;&nbsp; PFNTVCOMPARE lpfnCompare;&nbsp;&nbsp;&nbsp; \\ comparison function
 &nbsp;&nbsp; LPARAM lParam;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ application-defined sort data
</code></pre>
<p>
The <b>TV_SORTCB</b> structure contains information for sorting child items in a tree view control. The TVM_SORTCHILDRENCB message uses this structure. The comparison function must return a negative value if the first item should precede the second, a positive value if the first item should follow the second, or zero if the two items are equivalent. The <i>lParam1</i> and <i>lParam2</i> parameters correspond to the <i>lParam</i> member of the <b>TV_ITEM</b> structure for the two items being compared. The <i>lParamSort</i> parameter corresponds to the <i>lParam</i> member of the <b>TV_SORTCB</b> structure that was passed with the TVM_SORTCHILDRENCB message. The comparison function has the following form:</p>
<pre><code>int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
</code></pre>
<p>
The <b>TV_SORTCB</b> structure includes the following members:
<ul type=disc>
<li>
<b>HTREEITEM</b> <i>hParent</i>: The handle of the parent item.<br><br></li>
<li>
<b>PFNTVCOMPARE</b> <i>lpfnCompare</i>: Address of an application-defined comparison function. This function is called during a sort operation, whenever the relative order of two list items needs to be compared.<br><br></li>
<li>
<b>LPARAM</b> <i>lParam</i>: An application-defined 32-bit value.</li>
</ul>
<h3>Tree View Messages and Macros</h3>
<p>
An application sends messages to add items and to control the appearance and behavior of a tree view window. Each message has a corresponding macro that you can use instead of sending the message explicitly. This section describes the messages that Windows 95 currently supports for tree view windows.</p>
<h4>TVM_CREATEDRAGIMAGE</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (HTREEITEM)hitem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the tree view item
</code></pre>
<p>
<b>Description:</b> The TVM_CREATEDRAGIMAGE message creates a dragging bitmap for the given item in a tree view.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>HTREEITEM</b> <i>hitem</i>) is the handle of the tree view item for which a dragging bitmap will be created.</p>
<p>
<b>Return value:</b> The handle of the image list to which the dragging bitmap was added (<b>HIMAGELIST</b>) if successful; otherwise NULL.</p>
<p>
<b>Macro:</b> <b>HIMAGELIST</b> <b>TreeView_CreateDragImage</b>(<i>hwnd</i>, <i>hitem</i>);</p>
<h4>TVM_DELETEITEM</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (HTREEITEM)hitem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the tree view item
</code></pre>
<p>
<b>Description:</b> The TVM_DELETEITEM message deletes a specified item from a tree view window. This message has two macros, <b>TreeView_DeleteItem</b> and <b>TreeView_DeleteAllItems</b>, which you can use to delete either one item or all of the items from a tree view window. If the item label is being edited when this message is sent, the edit operation is cancelled and the parent window receives a TVN_ENDLABELEDIT notification. After that notification, a TVN_DELEITEM notification is sent to the parent window. If <i>hitem</i> is TVI_ROOT, all of the items are deleted from the control.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>HTREEITEM</b> <i>hitem</i>) is the handle of the tree view item to be deleted.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macros:</b>
<ul type=disc>
<li>
<b>BOOL TreeView_DeleteItem</b>(<i>hwnd</i>, <i>hitem</i>);<br><br></li>
<li>
<b>BOOL TreeView_DeleteAllItems</b>(<i>hwnd</i>);</li>
</ul>
<h4>TVM_EDITLABEL</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (HTREEITEM)hitem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the tree view item
</code></pre>
<p>
<b>Description:</b> The TVM_EDITLABEL message begins in-place editing of the specified item's text. The item text is replaced by a single-line edit control containing the original text in a selected and focused state. A TVN_BEGINLABELEDIT notification is sent to the parent window of the tree view control. You can safely subclass the edit control, but you must not destroy it. When the user has finished editing the label or has cancelled, the handle to the edit window becomes invalid.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>HTREEITEM</b> <i>hitem</i>) is the handle of the tree view item whose text will be edited.</p>
<p>
<b>Return value:</b> The handle of the edit control used to edit the item text if successful; NULL otherwise.</p>
<p>
<b>Macro:</b> <b>HWND</b> <b>TreeView_EditLabel</b>(<i>hwnd</i>, <i>hitem</i>);</p>
<h4>TVM_ENSUREVISIBLE</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (HTREEITEM)hitem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the tree view item
</code></pre>
<p>
<b>Description:</b> The TVM_ENSUREVISIBLE message ensures that the tree view item is visible, and expands the parent item or scrolls the tree view window if necessary. If the message expands the parent item, TVN_ITEMEXPANDING and TVN_ITEMEXPANDED notifications will be sent to the parent window of the tree view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>HTREEITEM</b> <i>hitem</i>) is the handle of the tree view item to be checked for visibility.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>TreeView_EnsureVisible</b>(<i>hwnd</i>, <i>hitem</i>);</p>
<h4>TVM_EXPAND</h4>
<pre><code>wParam = (UINT)code;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ the action to take place
lParam = (HTREEITEM)hitem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the tree view item
</code></pre>
<p>
<b>Description:</b> The TVM_EXPAND message expands or collapses the list of child items associated with the specified parent item. This message sends TVN_ITEMEXPANDING and TVN_ITEMEXPANDED notifications to the parent window.</p>
<p>
<b>Parameters:</b> <i>lParam</i> (<b>HTREEITEM</b> <i>hitem</i>) is the handle of the parent item to be expanded or collapsed. <i>wParam</i> (<b>WPARAM</b> <b>UNIT</b> <i>code</i>) identifies the action to take place. This can be one of the following values:
<ul type=disc>
<li>
TVE_COLLAPSE: Collapses the list.<br><br></li>
<li>
TVE_COLLAPSERESET: Collapses the list and removes the child items.<br><br></li>
<li>
TVE_EXPAND: Expands the list.<br><br></li>
<li>
TVE_TOGGLE: If the list is currently expanded, collapses it. If the list is currently collapsed, expands it.</li>
</ul>
<p>
<b>Return value:</b> TRUE if anything changed; FALSE otherwise.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>TreeView_Expand</b>(<i>hwnd</i>, <i>hitem</i>, <i>code</i>);</p>
<h4>TVM_GETCOUNT</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TVM_GETCOUNT message returns the number of items in the tree view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The number of items in the tree view window.</p>
<p>
<b>Macro:</b> <b>UINT</b> <b>TreeView_GetCount</b>(<i>hwnd</i>);</p>
<h4>TVM_GETEDITCONTROL</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TVM_GETEDITCONTROL message gets the handle of the edit control being used for in-place item text editing.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The handle to the edit control.</p>
<p>
<b>Macro:</b> <b>HWND</b> <b>TreeView_GetEditControl</b>(<i>hwnd</i>);</p>
<h4>TVM_GETIMAGELIST</h4>
<pre><code>wParam = iImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the tree item
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TVM_GETIMAGELIST message gets the handle of the image list associated with the tree view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the index of the tree item. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> The handle to the image list.</p>
<p>
<b>Macro:</b> <b>HIMAGELIST</b> <b>TreeView_GetImageList</b>(<i>hwnd</i>, <i>iImage</i>);</p>
<h4>TVM_GETINDENT</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TVM_GETINDENT message gets the amount, in pixels, that child items are indented relative to their parent items.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The amount of indentation.</p>
<p>
<b>Macro:</b> <b>UINT</b> <b>TreeView_GetIndent</b>(<i>hwnd</i>);</p>
<h4>TVM_GETITEM</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (TV_ITEM FAR *)pitem;&nbsp;&nbsp;&nbsp; \\ structure that receives item information
</code></pre>
<p>
<b>Description:</b> The TVM_GETITEM message gets information about the specified tree view item depending on the <i>mask</i> member in the <b>TV_ITEM</b> structure passed in.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>TV_ITEM</b> <i>FAR *pitem</i>) is a pointer to the <b>TV_ITEM</b> structure to fill in.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>TreeView_GetItem</b>(<i>hwnd</i>, <i>pitem</i>);</p>
<h4>TVM_GETITEMRECT</h4>
<pre><code>wParam = code;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ visibility state of the item
lParam = (RECT FAR *)prc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ bounding rectangle of the item
</code></pre>
<p>
<b>Description:</b> The TVM_GETITEMRECT message gets the bounding rectangle and visibility state of the specified item.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>WPARAM</b> <i>code</i>) is the visibility state of the item (TRUE for shown, FALSE for hidden). <i>lParam</i> (<b>LPARAM</b> <b>RECT</b> <i>FAR * prc</i>) is the bounding rectangle of the item.</p>
<p>
<b>Return value:</b> TRUE if visible; otherwise, returns FALSE and does not fill in the rectangle.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>TreeView_GetItemRect</b>(<i>hwnd</i>, <i>hitem</i>, <i>prc</i>, <i>code</i>);</p>
<h4>TVM_GETNEXTITEM</h4>
<pre><code>wParam = (UINT)code;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ which item to retrieve
lParam = (HTREEITEM)hitem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the tree view item
</code></pre>
<p>
<b>Description:</b> The TVM_GETNEXTITEM message gets the next tree view item based on the specified code. You can use macros instead of sending this message explicitly. There is one macro for each code you can specify and one general-purpose macro that allows you to specify the code. Table 5 below lists the possible codes and their meanings.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>WPARAM</b> <b>UINT</b> <i>code</i>) identifies the item to retrieve. <i>lParam</i> (<b>HTREEITEM</b> <i>hitem</i>) is the handle of the tree view item. </p>
<p>
<b>Return value:</b> The handle of the item if successful; NULL otherwise.</p>
<p>
<b>Macros:</b>
<ul type=disc>
<li>
HTREEITEM TreeView_GetNextItem(<i>hwnd</i>, <i>hitem</i>, <i>code</i>);<br><br></li>
<li>
HTREEITEM TreeView_GetChild(<i>hwnd</i>, <i>hitem</i>);<br><br></li>
<li>
HTREEITEM TreeView_GetDropHilight(<i>hwnd</i>);<br><br></li>
<li>
HTREEITEM TreeView_GetFirstVisible(<i>hwnd</i>);<br><br></li>
<li>
HTREEITEM TreeView_GetNextSibling(<i>hwnd</i>, <i>hitem</i>);<br><br></li>
<li>
HTREEITEM TreeView_GetNextVisible(<i>hwnd</i>, <i>hitem</i>);<br><br></li>
<li>
HTREEITEM TreeView_GetParent(<i>hwnd</i>, <i>hitem</i>);<br><br></li>
<li>
HTREEITEM TreeView_GetPrevSibling(<i>hwnd</i>, <i>hitem</i>);<br><br></li>
<li>
HTREEITEM TreeView_GetPrevVisible(<i>hwnd</i>, <i>hitem</i>);<br><br></li>
<li>
HTREEITEM TreeView_GetRoot(<i>hwnd</i>);<br><br></li>
<li>
HTREEITEM TreeView_GetSelection(<i>hwnd</i>);</li>
</ul>
<p class=label>
<b>Table 5. Tree View Get Item Codes</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=31%><b>Code</b></td>
<td class=label width=69%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=31%>TVGN_CARET</td>
<td width=69%>Gets the currently selected item.</td>
</tr>
<tr valign=top>
<td width=31%>TVGN_CHILD</td>
<td width=69%>Gets the first child item.</td>
</tr>
<tr valign=top>
<td width=31%>TVGN_DROPHILITE</td>
<td width=69%>Gets the item that is the target of a drag-and-drop operation.</td>
</tr>
<tr valign=top>
<td width=31%>TVGN_FIRSTVISIBLE</td>
<td width=69%>Gets the first visible item.</td>
</tr>
<tr valign=top>
<td width=31%>TVGN_NEXT</td>
<td width=69%>Gets the next sibling item.</td>
</tr>
<tr valign=top>
<td width=31%>TVGN_NEXTVISIBLE</td>
<td width=69%>Gets the next visible item.</td>
</tr>
<tr valign=top>
<td width=31%>TVGN_PARENT</td>
<td width=69%>Gets the parent of the item.</td>
</tr>
<tr valign=top>
<td width=31%>TVGN_PREVIOUS</td>
<td width=69%>Gets the previous item.</td>
</tr>
<tr valign=top>
<td width=31%>TVGN_PREVIOUSVISIBLE</td>
<td width=69%>Gets the first visible item that precedes the given item.</td>
</tr>
<tr valign=top>
<td width=31%>TVGN_ROOT</td>
<td width=69%>Gets the first child item of the root item.</td>
</tr>
</table><br>
<h4>TVM_GETVISIBLECOUNT</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TVM_GETVISIBLECOUNT message gets the count of items that will fit into the client window of the tree window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The count of items.</p>
<p>
<b>Macro:</b> <b>UINT</b> <b>TreeView_GetVisibleCount</b>(<i>hwnd</i>);</p>
<h4>TVM_HITTEST</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (LPTV_HITTESTINFO)lpht;&nbsp; \\ the point to hit test
</code></pre>
<p>
<b>Description:</b> The TVM_HITTEST message gets the point relative to the client area of the tree view window of the specified point. This message is generally used for drag-and-drop operations.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>LPARAM</b> <b>LPTV_HITTESTINFO</b> <i>lpht</i>) is the point to hit test.</p>
<p>
<b>Return value:</b> The handle of the tree view item that is occupying the specified point, or NULL if no items occupy the point.</p>
<p>
<b>Macro: HTREEITEM</b> <b>TreeView_HitTest</b>(<i>hwnd</i>, <i>lpht</i>);</p>
<h4>TVM_INSERTITEM</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (LPTV_INSERTSTRUCT)lpis; \\ structure containing item attributes
</code></pre>
<p>
<b>Description:</b> The TVM_INSERTITEM message inserts a new item in a tree view window. If the item is being edited, the edit operation is cancelled and the parent window receives a TVN_ENDLABELEDIT notification.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>LPARAM</b> <b>LPTV_INSERTSTRUCT</b> <i>lpis</i>) is the address of a <b>TV_INSERTSTRUCT</b> structure specifying the attributes of the tree view item.</p>
<p>
<b>Return value:</b> The handle of the new item if successful; NULL otherwise.</p>
<p>
<b>Macro:</b> <b>HTREEITEM</b> <b>TreeView_InsertItem</b>(<i>hwnd</i>, <i>lpis</i>);</p>
<h4>TVM_SELECTITEM</h4>
<pre><code>wParam = code;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ how to select the item
lParam = (HTREEITEM)hitem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the tree view item
</code></pre>
<p>
<b>Description:</b> The TVM_SELECTITEM message selects the given tree view item, scrolls it into view, and redraws it. This message has three corresponding macros described below.</p>
<p>
<b>Parameters:</b> <i>lParam</i> (<b>HTREEITEM</b> <i>hitem</i>) is the handle of the tree view item to redraw. <i>wParam</i> (<b>WPARAM</b> <i>code</i>) identifies the action the selection should take:
<ul type=disc>
<li>
TVGN_CARET: Sets the selection to the given item. The parent window receives the TVN_SELCHANGING and TVN_SELCHANGED notifications. If the item is a child of a collapsed parent item, the parent's list is expanded to reveal the item, and the TVN_ITEMEXPANDING and TVN_ITEMEXPANDED notifications are sent.<br><br></li>
<li>
TVGN_DROPHILITE: Redraws the given item in the style used to indicate the target of a drag-and-drop operation.<br><br></li>
<li>
TVGN_FIRSTVISIBLE: Scrolls the tree view vertically so that the given item is the first visible item.</li>
</ul>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macros:</b>
<ul type=disc>
<li>
<b>BOOL</b> <b>TreeView_Select</b>(<i>hwnd</i>, <i>hitem</i>, <i>code</i>); (the developer sets the code explicitly, based on the list given for <i>wParam</i>)<br><br></li>
<li>
<b>BOOL</b> <b>TreeView_SelectItem</b>(<i>hwnd</i>, <i>hitem</i>); (selects with <i>code</i> = TVGN_CARET)<br><br></li>
<li>
<b>BOOL</b> <b>TreeView_SelectDropTarget</b>(<i>hwnd</i>, <i>hitem</i>); (selects with <i>code </i>= TVGN_DROPHILITE)</li>
</ul>
<h4>TVM_SETIMAGELIST</h4>
<pre><code>wParam = iImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ new image list
lParam = (HIMAGELIST)himl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the image list
</code></pre>
<p>
<b>Description:</b> The TVM_SETIMAGELIST message sets the image list for a tree view window and redraws it.</p>
<p>
<b>Parameters:</b> <b>wParam</b> (<b>int</b> <i>iImage</i>) is the new image list. <i>lParam</i> (<b>LPARAM</b> <b>HIMAGELIST</b> <i>himl</i>) is the handle of the image list. If NULL is passed, all of the images are removed from the tree view window.</p>
<p>
<b>Return value:</b> Handle of the previous image list if successful; NULL otherwise.</p>
<p>
<b>Macro:</b> <b>HIMAGELIST</b> <b>TreeView_SetImageList</b>(<i>hwnd</i>, <i>himl</i>, <i>iImage</i>);</p>
<h4>TVM_SETINDENT</h4>
<pre><code>wParam = indent;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ amount of indentation in pixels
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TVM_SETINDENT message sets the amount of indentation for a child item.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>WPARAM</b> <i>indent</i>) is the amount, in pixels, of indentation. There is a system-defined minimum indentation (five). If <i>indent</i> is less than this value, the new width will be the system-defined minimum. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> None.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>TreeView_SetIndent</b>(<i>hwnd</i>, <i>indent</i>);</p>
<h4>TVM_SETITEM</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (const TV_ITEM FAR *)pitem;&nbsp;&nbsp; \\ item attributes to set
</code></pre>
<p>
<b>Description:</b> The TVM_SETITEM message sets the attributes of a tree view item based on the <i>mask </i>member of the <b>TV_ITEM</b> structure passed in.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>LPARAM</b> <b>const</b> <b>TV_ITEM</b> <i>FAR * pitem</i>) identifies the item attributes to set.</p>
<p>
<b>Return value:</b> 0 if successful; –1 otherwise.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>TreeView_SetItem</b>(<i>hwnd</i>, <i>pitem</i>);</p>
<h4>TVM_SORTCHILDREN</h4>
<pre><code>wParam = (BOOL)fRecurse;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ TRUE to sort recursively
lParam = (HTREEITEM)hitem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the tree view item
</code></pre>
<p>
<b>Description:</b> The TVM_SORTCHILDREN message sorts the child items of the given parent item.</p>
<p>
<b>Parameters:</b> If <i>wParam</i> (<b>WPARAM</b> <i>fRecurse</i>) is TRUE, all levels of child items descending from the given parent item are sorted. Otherwise, only immediate child items are sorted. <i>lParam</i> (<b>HTREEITEM</b> <i>hitem</i>) is the handle of the parent tree view item.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>TreeView_SortChildren</b>(<i>hwnd</i>, <i>hitem</i>, <i>fRecurse</i>);</p>
<h4>TVM_SORTCHILDRENCB</h4>
<pre><code>wParam = (BOOL)fRecurse;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ TRUE to sort recursively
lParam = (LPTV_SORTCB)psort;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ address of a TV_SORTCB structure
</code></pre>
<p>
<b>Description:</b> The TVM_SORTCHILDRENCB message sorts tree view items using an application-defined comparison function.</p>
<p>
<b>Parameters:</b> If <i>wParam</i> (<b>WPARAM</b> <i>fRecurse</i>) is TRUE, all levels of child items descending from the given parent item are sorted. Otherwise, only immediate child items are sorted. <i>lParam</i> (<b>LPARAM</b> <b>LPTV_SORTCB</b> <i>psort</i>) is the address of a <b>TV_SORTCB</b> structure specifying the address of the application-defined comparison function. This function is called during the sort operation whenever the relative order of two list items needs to be compared.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>TreeView_SortChildrenCB</b>(<i>hwnd</i>, <i>psort</i>, <i>fRecurse</i>);</p>
<h2>Summary</h2>
<p>
Here we are, once again, at the end of yet another article in the Win32 common control series. My final article (Part 6 of the series) covers the new tab controls and property sheets. Although property sheets are not part of the common control library, tab controls are. Since tabs are used extensively with property sheets, I decided to add information about property sheets as an extra bonus for you. Stay tuned for upcoming Windows 95 articles in the MSDN Library: Same Bat Time, Same Bat Channel.</p>
</BODY>
</HTML>
