<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Allocating Memory the Newfangled Way: The new Operator</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_fangle"></a></sup>Allocating Memory the Newfangled Way: The <i>new</i> Operator</h1>
<p>
Dale E. Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: August 6, 1992<br>
Revised: January 21, 1993</p>
<p class=indent>
<i>"The business side is easy—easy! ...if you're any good at math at all, you understand business. It's not its own deep, deep subject. It's not like C++." </i></p>
<p class=indent>
William Gates, <i>Upside Magazine</i>, April 1992</p>
<p>
There are two sample applications associated with this technical article.</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="100">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files for the OWNER sample application.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="101">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files for the NEWOPR sample application.</a></p>
<h2>Abstract</h2>
<p>
Many developers ask the question, "Do I need to overload the <b>new</b> operator for Windows™–based applications?" when they start programming in C++ with the Microsoft® C/C++ version 7.0 compiler. These developers want to conserve selectors while allocating memory from the global heap. Fortunately, the C/C++ version 7.0 run-time library allows developers to reduce selector consumption without overloading the <b>new</b> operator.</p>
<p>
This article examines the behavior of the <b>new</b> operator in a Windows-based program. It provides an overview of <b>new</b>, discusses whether you should overload <b>new</b>, examines the C++ ambient memory model, and discusses large-model C++ programming and dynamic-link library (DLL) ownership issues.</p>
<p>
Two sample applications, newopr and owner, illustrate the concepts in this technical article. A bibliography of suggested reading material is included at the end of the article.</p>
<h2>Overview</h2>
<p>
This section provides an overview of the <b>new</b> operator, the <b>_fmalloc</b> function, and the <b>_nmalloc</b> function.</p>
<h3>new</h3>
<p>
The <b>new</b> operator calls <b>malloc</b> directly. In small or medium model, it calls the near version of <b>malloc</b>, which is <b>_nmalloc</b>. In large model, it calls <b>_fmalloc</b>.</p>
<p>
Alarms are probably ringing in the heads of experienced programmers. In the past, Microsoft has recommended against using <b>malloc</b> because it was incompatible with Windows real mode. In C/C++ version 7.0, <b>malloc</b> is designed for Windows protected-mode programming, and real mode is no longer a concern in Microsoft® Windows™ version 3.1. In most cases, calling <b>_fmalloc</b> is now better than calling <b>GlobalAlloc</b> directly.</p>
<h3>_fmalloc</h3>
<p>
<b>_fmalloc </b>is better than <b>GlobalAlloc</b> because of <i>subsegment allocation</i>. Instead of calling <b>GlobalAlloc</b> directly for each memory request, <b>_fmalloc</b> tries to satisfy as many requests as possible with only one <b>GlobalAlloc</b> call, and uses <b>GlobalReAlloc</b> to increase the size of a segment. Reducing the calls to <b>GlobalAlloc</b> cuts down on the overhead, time, and selectors required by an application.</p>
<p>
Reducing selectors is particularly important for C++ programs. Most programs allocate lots of small objects on the heap. If <b>new</b> called <b>GlobalAlloc</b> directly, each small object would use a selector, and the program would reach the system limit of 8192 selectors (4096 in standard mode) too quickly.</p>
<h3>_nmalloc</h3>
<p>
Although <b>_fmalloc</b> is fine and dandy, <b>_nmalloc</b> is not nearly (no pun intended) as sophisticated. <b>_nmalloc</b> allocates fixed memory with <b>LocalAlloc</b> directly, which may result in memory fragmentation in the local heap. <b>_nmalloc</b> performs no subsegment allocation scheme, and the local heap must share a maximum of 64K with the stack and static data.</p>
<p>
Here's another gotcha: <b>_nmalloc</b> is the default for the <b>new </b>operator in the medium and small models. <b>_nmalloc</b> allocates its memory from the local heap and must share the heap with the static data and stack—so a lot of things compete for only 64K of space. It is rather easy to run out of memory in the local heap. For example, a simple phone book that requires 200 bytes of data per entry would be able to store a maximum of only 330 names.</p>
<p>
Heap Walker can help you determine the source of memory allocation. Memory allocated with <b>LocalAlloc</b> (through <b>_nmalloc</b>) expands the segment labeled <b>DGroup</b>. Memory allocated with <b>GlobalAlloc</b> (through <b>_fmalloc</b>) is labeled as a private segment.</p>
<p>
For more information on <b>_fmalloc</b>, see the "Allocating Memory the Old-Fashioned Way: _fmalloc and Applications for Windows" technical article on the Microsoft Developer Network CD (Technical Articles, C/C++ Articles).</p>
<h2>Overloading the <i>new</i> Operator</h2>
<p>
Many developers want to overload the <b>new </b>operator as soon as they learn that <b>new </b>calls <b>_nmalloc</b>. You can overload the <b>new </b>operator to perform specialized memory management, but overloading <b>new</b> to call <b>_fmalloc</b> instead of <b>_nmalloc</b> will not work.</p>
<p>
The <b>new</b> operator has four versions. In this article, we are concerned only with the following two:</p>
<pre><code>void __near *operator new( size_t size );
void __far *operator new( size_t size ) ;
</code></pre>
<p>
In small and medium models, the compiler calls the near version of the <b>new </b>operator, and this version then calls <b>_nmalloc</b>. If we try to overload this function by calling <b>_fmalloc</b>, we would get a far-to-near pointer conversion error:</p>
<pre><code>void __near *operator new( size_t size )
{
 &nbsp; return _fmalloc(size); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //ERROR: Lost segment in far/near conversion.
}
</code></pre>
<p>
A memory management scheme that overloads the near version of the <b>new</b> operator can return only near pointers, so using <b>GlobalAlloc</b> or <b>GlobalAllocPtr</b> will not work either.</p>
<p>
Overloading the <b>new</b> operator to call <b>_fmalloc</b> instead of <b>_nmalloc </b>is obviously not the answer.</p>
<h2>Ambient Memory Models</h2>
<p>
Asking the proper question will lead to a useful solution. The proper question is: "How do I get the far version of the <b>new </b>operator compiled in my code?" There are three ways to do this: 
<ul type=disc>
<li>
Specify an ambient memory model.<br><br></li>
<li>
Override the ambient memory model.<br><br></li>
<li>
Use the large memory model.</li>
</ul>
<p>
The following sections describe each method in turn.</p>
<h3>Specifying an Ambient Memory Model</h3>
<p>
You can think of the <i>ambient memory model </i>as the default memory model. Normally, the ambient memory model of a class is identical to the data model you specify at compilation time. If the data model is near (for example, in small or medium models), the ambient memory model is near. You can specify the ambient memory model for a class explicitly by using <b>__near</b> or <b>__far</b>; for example:</p>
<pre><code>class __far CFoo {
};
</code></pre>
<p>
Using the <b>new</b> operator on the CFoo class, as defined above, allocates the <b>CFoo</b> object on the global heap using <b>_fmalloc</b>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The ambient memory model of a class must be identical to the memory model of all of its base classes. For example, if your class inherits from a Microsoft Foundation class, your class must have the same memory model as the Foundation class. If you use small and medium memory models, the ambient memory model of a Foundation class is near. We discuss the large model in the "Large-Model Programs" section.</p>
<h3>Overriding the Ambient Memory Model</h3>
<p>
You can override the ambient memory model on a per-object-instance basis:</p>
<pre><code>class CBar{
};

void main()
{
 &nbsp; CBar __far *pBar = new __far CBar ;
}
</code></pre>
<p>
At first glance, the code above looks very straightforward. However, nonstatic member functions have a hidden parameter called the <b>this</b> pointer. It is through the <b>this</b> pointer that an object instance references its data. If the member function is near, it expects the <b>this</b> pointer to be near. A far <b>this</b> pointer results in an error because a far pointer cannot be converted to a near pointer.</p>
<p>
The following code generates an error because it cannot find a default constructor that returns a far <b>this</b> pointer:</p>
<pre><code>class CBar{
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; CBar();
};

CBar::CBar()
{
}

void main()
{
 &nbsp; CBar __far *pBar = new __far CBar ; 
 &nbsp; // ERROR C2512: 'CBar': An appropriate 
 &nbsp; // default constructor is not available.
}
</code></pre>
<p>
To compile the code above, you must override the constructor based on the addressing type. This results in the following correct code:</p>
<pre><code>class CBar{
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; CBar();
 &nbsp;&nbsp;&nbsp;&nbsp; CBar() __far ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Overload the constructor to take far this pointers.
};

CBar::CBar()
{
}

// Overloaded constructor.
CBar::CBar() __far
{
}

void main()
{
 &nbsp; CBar __far *pBar = new __far CBar ;
}
</code></pre>
<p>
Only functions that are actually called through a far pointer need to be overridden.</p>
<pre><code>class CBar{
 &nbsp; private:
 &nbsp;&nbsp;&nbsp;&nbsp; int value;
 &nbsp;&nbsp;&nbsp;&nbsp; buildIt() __far {}; // Must be far: CBar() __far calls it.
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; CBar();
 &nbsp;&nbsp;&nbsp;&nbsp; CBar() __far ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Overload the constructor to take far this pointers.

 &nbsp;&nbsp;&nbsp;&nbsp; // inc is called through a far pointer.
 &nbsp;&nbsp;&nbsp;&nbsp; void inc() __far { value++; } ;

 &nbsp;&nbsp;&nbsp;&nbsp; // dec is not called through a far pointer.
 &nbsp;&nbsp;&nbsp;&nbsp; void dec() { value--; } ;
};

CBar::CBar()
{
 &nbsp; buildIt() ;
}

// Overloaded constructor.
CBar::CBar() __far
{
 &nbsp; buildIt() ;
}

void main()
{
 &nbsp; CBar *npBar = new CBar ; // Allocated in default data segment.

 &nbsp; CBar __far *pBar = new __far CBar ; // Allocated in global heap.

 &nbsp; pBar-&gt;inc() ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Far addressing.

 &nbsp; npBar-&gt;dec() ;&nbsp;&nbsp;&nbsp;&nbsp; // Near addressing.
 &nbsp; npBar-&gt;inc() ;&nbsp;&nbsp;&nbsp;&nbsp; // Converts near pointer to a far pointer.
}
</code></pre>
<h3>Confusion Is Nothing New</h3>
<p>
The use of the <b>__far</b> modifier can make programs very difficult to understand and debug. For example, let's assume that the following code is compiled in the small or medium memory models:</p>
<pre><code>class __far CFoo {
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; CFoo() ;
 &nbsp;&nbsp;&nbsp;&nbsp; ~CFoo() ;
...
};

class CBar {
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; CBar() ;
 &nbsp;&nbsp;&nbsp;&nbsp; ~CBar() ;
...
};

CFoo aFoo;&nbsp; // Allocated in a far data segment.
CBar aBar&nbsp;&nbsp; // Allocated in default data segment.

CFoo *pFoo&nbsp; // Far pointer.
CBar *pBar&nbsp; // Near pointer.

CFoo <b>__</b>near *npFoo ;&nbsp; // Near pointer.
CBar <b>__</b>far *fpBar ;&nbsp;&nbsp; // Far pointer.

main()
{
 &nbsp; CFoo anotherFoo;&nbsp;&nbsp; // Allocated on stack
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (default data segment).

 &nbsp; pFoo = new CFoo;&nbsp;&nbsp; // Allocated in global heap.
 &nbsp; pBar = new CBar;&nbsp;&nbsp; // Allocated in default data segment.

 &nbsp; fpBar2 = new <b>__</b>far CBar; 
 &nbsp; // Error: No appropriate default constructor.


 &nbsp; npFoo = new CFoo; 
 &nbsp; // Error: Cannot convert from a far pointer to a near pointer.

 &nbsp; npFoo = new <b>__</b>near CFoo ;
 &nbsp; // Error: Cannot convert from a far class to a near class.

 &nbsp; npFoo = &amp;aFoo;
 &nbsp; // Error : Cannot convert from a far pointer to a near pointer.
}
</code></pre>
<p>
You can see how complex an application can get when it mixes near objects and far objects.</p>
<p>
Again, Heap Walker can help you determine whether memory is being allocated in the default data segment or in the global heap.</p>
<p>
For additional information on the <b>new</b> operator, see Chapter 5 of the Microsoft C/C++ version 7.0 <i>Programming Techniques</i> manual on the Microsoft Developer Network CD.</p>
<h2>Large-Model Programs</h2>
<p>
As we discussed in the previous section, mixing near and far addressing is even more of a nightmare in C++ than it is in C and can offset many C++ benefits such as ease of maintenance and readability. The solution is to use the large model.</p>
<p>
Although the large model has not been recommended in the past, the combination of Microsoft C/C++ version 7.0 and Windows version 3.1 now makes large model the memory model of choice.</p>
<p>
When a C or C++ program is compiled with the large memory model, <b>malloc</b> is mapped to its model-independent or far version known as <b>_fmalloc</b>. Because the <b>new</b> operator calls <b>malloc</b>, heap objects are allocated in global memory.</p>
<p>
The two issues associated with using the large model involve speed and creating multiple instances. The time you save by not worrying whether an object is near or far can be used to run a profiler and to optimize the application, thus compensating for any speed losses caused by the large model.</p>
<h3>Multiple Instances</h3>
<p>
The new <b>/Gx</b> option in C/C++ version 7.0 simplifies the creation of multiple-instance, large-model applications. Make sure to use the following compiler options:</p>
<p>
/Gt65500 /Gx</p>
<p>
Programs with multiple read/write data segments cannot have multiple instances. By default, the Microsoft C compiler places initialized and uninitialized static data in two separate segments. The compiler places each static object that is larger than or equal to 32,767 bytes into its own segment. The /<b>Gx</b> and /<b>Gt</b> options override this behavior.</p>
<p>
The /<b>Gx</b> option forces all initialized and uninitialized static data into the same segment. The <b>/Gt</b>[<i>n</i>] option places any object larger than <i>n</i> bytes in a new segment. (<i>n</i> is optional, as indicated by the square brackets.) If <i>n</i> is not specified, it defaults to 256 bytes. If <i>n</i> is large (for example, 65,500 bytes), most objects remain in the default data segment.</p>
<p>
Because a multiple-instance application can have only one read/write data segment, the application is limited to 64K for all statics, the local heap, and the stack. However, C++ promotes the use of the heap through the <b>new</b> operator, which allocates memory from the global heap instead of the local heap in the large model, so the 64K local heap limit should not be a problem. Moreover, multiple-instance, small-model and medium-model applications also have only one read/write data segment.</p>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;A bug in Microsoft C/C++ version 7.0 causes the compiler to place uninitialized global instances of classes and structures in a far data segment (FAR_DATA) when the <b>/Gx</b> option is used, resulting in two data segments. For this reason, you must declare global class objects and structures as near.</p>
<p>
To illustrate, most Microsoft Foundation Class Library programs have a global object declared as follows:</p>
<pre><code>CTheApp theApp;
</code></pre>
<p>
To get multiple instances of this program, you must change the line to:</p>
<pre><code>CTheApp __near theApp;
</code></pre>
<p>
We recommend that you use the NEAR define:</p>
<pre><code>CTheApp NEAR theApp;
</code></pre>
<p>
The EXEHDR utility determines the number of data segments a program contains. In the sample EXEHDR output below, the lines that detail the number of segments are underlined and appear in bold.</p>
<pre><code>Microsoft (R) EXE File Header Utility&nbsp; Version 3.00
Copyright (C) Microsoft Corp 1985-1992.&nbsp; All rights reserved.

Module:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEWOPR
Description:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newopr - demonstrates new operator in 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; medium v. large model
Data:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NONSHARED
Initial CS:IP:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg&nbsp;&nbsp; 1 offset e392
Initial SS:SP:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg&nbsp;&nbsp; 4 offset 0000
Extra stack allocation:&nbsp;&nbsp; 1000 bytes
DGROUP:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg&nbsp;&nbsp; 4
Heap allocation:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0400 bytes
Application type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WINDOWAPI
Runs in protected mode only

no. type address&nbsp; file&nbsp; mem&nbsp;&nbsp; flags
  1 CODE 00000600 0ff8f 0ff8f PRELOAD, (movable), (discardable)
  2 CODE 00010a00 013b0 013b1 PRELOAD, (movable), (discardable)
 <b> <u>3 DATA 00000000 00000 00038 PRELOAD, (movable)</u></b>

<b>  <u>4 DATA 00012000 0159f 01fee PRELOAD, (movable)</u></b>

Exports:
ord seg offset name
  1&nbsp;&nbsp; 1&nbsp; e358&nbsp; _AFX_VERSION exported
  2&nbsp;&nbsp; 1&nbsp; f718&nbsp; ___EXPORTEDSTUB exported
</code></pre>
<p>
The MAP file helps determine the data that is placed in the FAR_DATA segment instead of the default data segment. To get a MAP file, be sure to specify a MAP filename and the <b>/MAP</b> option on the link line. In the sample MAP file below, lines of interest are underlined and shown in bold.</p>
<pre><code>&nbsp;Start&nbsp;&nbsp;&nbsp;&nbsp; Length&nbsp;&nbsp;&nbsp;&nbsp; Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class
 0001:0000 004CFH&nbsp;&nbsp;&nbsp;&nbsp; NEWOPR_TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CODE
 .
 .
 .
 0001:E378 01C17H&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CODE
 0002:0000 013B1H&nbsp;&nbsp;&nbsp;&nbsp; COMDAT_SEG1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CODE

<b> <u>0003:0000 00038H&nbsp;&nbsp;&nbsp;&nbsp; NEWOPR1_DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FAR_DATA</u></b>
 0004:0000 00010H&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BEGDATA
 0004:0010 011E0H&nbsp;&nbsp;&nbsp;&nbsp; _DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA
 0004:11F0 00000H&nbsp;&nbsp;&nbsp;&nbsp; XIFCB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA
 .
 .
 .
 0004:140E 0000CH&nbsp;&nbsp;&nbsp;&nbsp; IOB2E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA
 0004:141A 00004H&nbsp;&nbsp;&nbsp;&nbsp; CONST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST
 0004:141E 00008H&nbsp;&nbsp;&nbsp;&nbsp; HDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSG
 0004:1426 00163H&nbsp;&nbsp;&nbsp;&nbsp; MSG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSG
 0004:1589 00015H&nbsp;&nbsp;&nbsp;&nbsp; PAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSG
 0004:159E 00001H&nbsp;&nbsp;&nbsp;&nbsp; EPAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSG
 0004:15A0 009B6H&nbsp;&nbsp;&nbsp;&nbsp; _BSS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BSS
 .
 .
 .
 Origin&nbsp;&nbsp; Group
 0004:0&nbsp;&nbsp; DGROUP

 Address&nbsp;&nbsp; Export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Alias

 0001:E358 _AFX_VERSION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _AFX_VERSION
 0001:F718 ___ExportedStub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ___ExportedStub

  Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Publics by Name

 0001:7C52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??0CArchive@@REC@PEVCFile@@IHPEX@Z
 .
 .
 .

<b> <u>0003:0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?spaceholder@@3VCObArray@@E</u></b>
 0001:7BF2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?Store@CRuntimeClass@@RECXAEVCArchive@@@Z
 0002:01F0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?TextOut@CDC@@RECHHHPFDH@Z

<b> <u>0003:000E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?theApp@@3VCTheApp@@E</u></b>
 .
 .
 .
 &nbsp; Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Publics by Value
 .
 .
 .
 0002:1380&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?GetStartPosition@CMapPtrToWord@@RFCPEXXZ

<b> <u>0003:0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?spaceholder@@3VCObArray@@E</u></b>

<b> <u>0003:000E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?theApp@@3VCTheApp@@E</u></b>
 0004:0004&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsrvptrs
 .
 .
 .
 0004:1FEE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __end
 0004:1FEE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _end

Program entry point at 0001:E392
</code></pre>
<h3>Multiple-Instance, Large-Model Foundation Class Programs</h3>
<p>
Multiple-instance, large-model programs that use the Microsoft Foundation classes must build special versions of the Microsoft Foundation Class Library using the <b>/Gt</b> and <b>/Gx</b> options. Use the following command line:</p>
<p>
nmake MODEL=L TARGET=W DEBUG=1 OPT="/Gt65500 /Gx"</p>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;This variant of the Microsoft Foundation Class Library has not been tested extensively by Microsoft.</p>
<p>
For additional information on using large-model programs with Windows, see the "Programming at Large" technical article on the Microsoft Developer Network CD (Technical Articles, C/C++ Articles).</p>
<h2>The NEWOPR Sample</h2>
<p>
newopr is a rather simple application that demonstrates some of the issues presented in this technical article. newopr tries to allocate 128 blocks of memory, 1024 bytes per block. When newopr is compiled as a medium-model program, it cannot allocate 128 blocks because it runs out of memory in the default data segment. In fact, the Microsoft Foundation Class Library raises an exception when the <b>new </b>operator fails, and newopr handles this exception gracefully.</p>
<p>
When newopr is compiled as a large-model program, it can allocate all 128 blocks because the memory is allocated from the global heap instead of the local heap.</p>
<p>
The best way to use newopr is to compile it medium model, run it, and examine the heap with Heap Walker. Run NMAKE with the CLEAN option, and then compile large model. Run the large-model version, and re-examine the heap with Heap Walker.</p>
<p>
The following parameters control how newopr gets built:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=19%>DEBUG=[0|1]</td>
<td width=81%>Setting of 1 enables debugging information.</td>
</tr>
<tr valign=top>
<td width=19%>LARGE=[0|1]</td>
<td width=81%>Setting of 1 compiles newopr as a large-model program.</td>
</tr>
<tr valign=top>
<td width=19%>MINST=[0|1]</td>
<td width=81%>Setting of 1 compiles with <b>/Gt</b> and <b>/Gx</b> options to allow multiple instances. LARGE must be set to 1.</td>
</tr>
<tr valign=top>
<td width=19%>CLEAN</td>
<td width=81%>Deletes .exe, .res, and .obj files.</td>
</tr>
</table><br>
<p>
Sample nmake command lines are shown below:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Command Line</b></td>
<td class=label width=50%><b>Makes</b></td>
</tr>
<tr valign=top>
<td width=50%>nmake</td>
<td width=50%>Medium-model version.</td>
</tr>
<tr valign=top>
<td width=50%>nmake DEBUG=1</td>
<td width=50%>Medium-model debug version.</td>
</tr>
<tr valign=top>
<td width=50%>nmake LARGE=1</td>
<td width=50%>Large-model version.</td>
</tr>
<tr valign=top>
<td width=50%>nmake MINST=1</td>
<td width=50%>Medium-model version. MINST is ignored.</td>
</tr>
<tr valign=top>
<td width=50%>nmake LARGE=1 MINST=1</td>
<td width=50%>Multi-instance, large-model version. Foundation class large-model library must be compiled with /Gx and /Gt for this to work.</td>
</tr>
<tr valign=top>
<td width=50%>nmake DEBUG=1 LARGE=1 MINST=1</td>
<td width=50%>Same as above, but enables debugging.</td>
</tr>
</table><br>
<h2>DLLs and Memory Ownership</h2>
<p>
As discussed in the "Allocating Memory the Old-Fashioned Way: _fmalloc and Applications for Windows" technical article on the Microsoft Developer Network CD, <b>_fmalloc</b> called from a DLL behaves differently than <b>_fmalloc</b> called from an application. If you call <b>_fmalloc</b> from a DLL, it calls <b>GlobalAlloc </b>with the GMEM_SHARE flag, which changes the ownership of the allocated memory from the calling application to the DLL.</p>
<p>
Ownership determines when the system will clean up the memory:
<ul type=disc>
<li>
If the application owns the memory, exiting the application releases the memory.<br><br></li>
<li>
If the DLL owns the memory, unloading the DLL from memory releases the memory.<br><br></li>
<li>
If multiple applications or multiple instances of an application use a DLL, the DLL is unloaded only after all applications that use it are unloaded.</li>
</ul>
<p>
The key point here is that memory owned by a DLL (for example, GMEM_SHARE) can exist even after your application exits. The Smart Alloc sample application, which accompanies "Allocating Memory the Old-Fashioned Way: _fmalloc and Applications for Windows," illustrates this issue.</p>
<h3>Ambiguous Memory Ownership</h3>
<p>
A DLL owns the memory allocated as GMEM_SHARE from within the DLL (in C++ or C). A DLL also owns the memory allocated by <b>new</b> in the DLL. Determining when and where memory is allocated can become very confusing in C++.</p>
<p>
The code samples below are from the owner sample application and its associated OWNERDLL.DLL.</p>
<p>
The DLL contains the following class:</p>
<pre><code>&nbsp;class __export CContainedClass{
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; char aMessage[1024] ;
 };

 class __export CFooInDLL{
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; CFooInDLL () ;
 &nbsp;&nbsp;&nbsp;&nbsp; void yourString() ;
 &nbsp;&nbsp;&nbsp;&nbsp; void myString();

 &nbsp;&nbsp;&nbsp;&nbsp; CContainedClass aContainedClass ;
 &nbsp;&nbsp;&nbsp;&nbsp; char aBuffer[1024] ;
 &nbsp;&nbsp;&nbsp;&nbsp; char *aString ;
 } ;

 CFooInDLL::CFooInDLL()
 {
 &nbsp;&nbsp;&nbsp;&nbsp; aString = new char[1024] ;
 } 

 /////// INLINE FUNCTION ////////
 inline
 void CFooInDLL::yourString()
 {
 &nbsp; if (aString)
 &nbsp;&nbsp;&nbsp;&nbsp; delete aString ;
 &nbsp; aString = new char[1024] ;
 }

 /////// OUTLINE FUNCTION ///////
 void CFooInDLL::myString()
 {
 &nbsp; if (aString)
 &nbsp;&nbsp;&nbsp;&nbsp; delete aString ;
 &nbsp; aString = new char[1024] ;
 }
</code></pre>
<p>
The .EXE for the program contains the following code fragment:</p>
<pre><code>// Code in .EXE
CFooInDLL&nbsp; aFoo;

void somefunc()
{
 &nbsp; aFoo.yourString() ;&nbsp; // Now application owns aString.
 &nbsp; aFoo.myString() ;&nbsp;&nbsp;&nbsp; // Now DLL owns aString.
 &nbsp; aFoo.yourString() ;&nbsp; // Now application owns aString.
}
</code></pre>
<p>
Given these code fragments (where the object is defined in a DLL and declared in an application), the following rules apply:
<ul type=disc>
<li>
The application owns the memory for objects declared in the application.<p class=tl>
Therefore, the application owns the memory for <i>aFoo</i>.</P></li>
<li>
Space for an object and its contained objects is allocated where the object is declared.<p class=tl>
Therefore, during the construction of the <i>aFoo</i> object, memory for <i>aContainedClass</i> is allocated, and <i>aContainedClass</i> is also located in the application's memory space.</P></li>
<li>
The process that executes the <b>new </b>operator owns the memory for the object (see figure below).<ul type=disc>
<li>
The <b>CFooInDLL</b> constructor calls the <b>new</b> operator to allocate space for <i>aString</i>; therefore, the DLL owns the memory for <i>aString</i>.<br><br></li>
<li>
<b>yourString</b> is an inline function and executes inside the application; therefore, the application owns the memory allocated by <b>yourString</b>.<br><br></li>
<li>
<b>myString</b> executes inside the DLL; therefore, the DLL owns memory allocated by <b>myString</b>.</li>
</ul>
</li>
<li>
The debug versions of Foundation classes track the allocation of memory. An assertion in the Microsoft Foundation Class Library MEmory.cpp source file will fail when <b>yourString</b> tries to free memory allocated by the DLL. Therefore, the retail versions of owner and OWNERDLL run fine, but the debug versions fail.</li>
</ul>
<p>
In most cases, it is best to design classes exported from a DLL so that memory ownership will not bounce between the application and the DLL. Using the debug versions of the Foundation class libraries helps track this problem.</p>
<p>
<img src="fangle_1.gif" border=0></p>
<p class=label>
<b>Memory ownership for CFooInDLL object</b></p>
<p>
The problem of determining memory ownership is just one more reason not to export C++ class interfaces from a DLL. In most cases, it is much better to export a C interface from a DLL.</p>
<h2>Conclusion</h2>
<p>
There is no need to override the <b>new</b> operator to make it compatible with the Windows environment. The <b>new</b> operator calls <b>malloc</b>. The model-independent version of <b>malloc</b>, <b>_fmalloc</b>, is designed to manage subsegment allocation under Windows.</p>
<p>
However, in medium or small memory models, <b>malloc</b> calls <b>_nmalloc</b> instead of <b>_fmalloc</b>. <b>_nmalloc</b> allocates memory through <b>LocalAlloc</b>. The best way to get the <b>new</b> operator to call <b>_fmalloc</b> is to use the large memory model. The ambient memory model for a class can be specified or overridden for a class instance, but both of these methods can quickly lead to confusing and complex code.</p>
<h2>Bibliography</h2>
<p>
The following technical articles on the Microsoft Developer Network CD (Technical Articles, C/C++ Articles) are good sources of information on memory management in C++:
<ul type=disc>
<li>
"Allocating Memory the Old-Fashioned Way: fmalloc and Applications for Windows"<br><br></li>
<li>
"Programming at Large"<br><br></li>
<li>
"Exporting with Class"</li>
</ul>
<p>
We also recommend the Microsoft C/C++ version 7.0 <i>Programming Techniques</i> manual, also available on the Microsoft Developer Network CD. Chapter 5 of this manual discusses memory management in C++.</p>
</BODY>
</HTML>
