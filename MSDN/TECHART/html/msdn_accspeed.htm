<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Optimizing Microsoft Access for Speed</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_accspeed"></a>Optimizing Microsoft Access for Speed</h1>
<p>
Less P. Wright, Jr.<br>
SQL-Win Database Solutions</p>
<p>
Created: September 23, 1993</p>
<h2>Abstract</h2>
<p>
This article presents a compilation of various items to keep in mind while designing, coding, and implementing your Microsoft Access® database application to ensure maximum speed.</p>
<h2>Introduction</h2>
<p>
As a database developer, your primary mission is to enable your clients to efficiently collect, manage, and access the information they need. All other things being constant, the faster your database application can perform its activities, the more efficient a database application can be said to be. The purpose of this article is to highlight various tips and tricks to help you make your Microsoft Access® database applications as "efficient" as possible by optimizing it for speed, and thus hopefully assisting you in your primary mission as a database developer. </p>
<h2>Hardware</h2>
<p>
<b>Laying the foundation for speed.</b> We'll start from the ground up in terms of approaching the various sectors you'll want to look at for optimizing the speed of your database. The single most determining factor in your quest to improve your database's performance will be the hardware platform that you are implementing the database on. Obviously, the first rule to realize is that faster hardware = faster databases, with the CPU and RAM being the heart of the whole equation. Be sure that your clients are aware that Microsoft Access strongly recommends at least 8 MB RAM, and an 80486 for satisfactory performance. Normally you can take this for granted, but I have seen clients distressed about the speed of their Microsoft Access applications, and when asked about what hardware they were running on, I was informed that they were running 80386s with the actual MSACCESS.EXE running on the server. So just be sure that your clients are aware that while following the methods below will certainly improve performance, in the end their hardware will be the single most determining factor in terms of Microsoft Access performance.</p>
<p>
<b>Efficient disk access.</b> Given a satisfactory hardware configuration, let’s move on to how you can tweak the speed of Microsoft Access on that platform. What may be the second most limiting factor for your database is disk access. Physical disk access will always be a bottleneck in terms of performance (compared with accessing the same data stored in RAM), so you will want to minimize disk access as much as possible. However, given that your application will almost always have some disk or physical media interaction, your goal should be to ensure that all disk access is as efficient as possible. The way to do that is to defragment the drive(s) on which your database resides and any other drives that it will be interacting with when you initially implement your database, and have the client periodically defragment the drive(s) thereafter to ensure that disk access is kept at top efficiency. This will minimize the time spent during the inevitable write/reads to the physical disk, and thus optimize the performance for this area.</p>
<p>
<b>Maximize RAM / minimize disk access frequency.</b> The next topic is to minimize the frequency with which your database must interact with the physical drive. The key to doing this is to free up as much RAM memory as possible for use by your application. There are several steps you can take to do this. 
<ul type=disc>
<li>
<b>Increase</b> <b>MaxBufferSize:</b> The first involves your settings for the MaxBufferSize. MaxBufferSize refers to the amount of RAM memory Microsoft Access sets aside for its use as an internal storage space. The larger the storage space, the higher are the odds that the data necessary for a user request can be found in RAM and will not require physical disk access. The default setting for Microsoft Access is 512K. Assuming that your hardware has more than 4 MB RAM, you can have Microsoft Access allocate more RAM for its own use (and thus increase performance) by increasing the MaxBufferSize settings in the MSACCESS.INI file (in your Windows™ directory). Open the file with a text editor such as Notepad, scan for the [<b>Options</b>] section, and underneath it place the following:<p class=tl>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>MaxBufferSize = <i>xxxxx</i></b></P><p class=tl>
where <i>xxxxx</i> is your new setting for memory allocation by your application. (For example, MaxBufferSize = 2048 will allocate 2 MB for the Microsoft Access buffer.) How much should you allocate? Besides the pat "as much as possible" response, it is difficult to say. You will need to hand-tune this setting and try to ascertain the most your hardware platform can afford (1) without interfering with other applications that your users are likely to be using simultaneously, and/or (2) without disrupting the efficiency of the underlying operating system itself. (You will want to note that Microsoft Access configures itself according to the .INI file at startup; hence any modifications made to the MSACCESS.INI file will only be implemented upon the next startup of Microsoft Access, and will have no effect upon a currently running instance of Microsoft Access.)</P></li>
<li>
<b>Avoid loading the wizards:</b> Another step you can take to free up more memory for use by Microsoft Access is to avoid loading the wizards if they are not going to be used. You can prevent the wizards from automatically loading by placing a semicolon in front of the "Wizards.mdb =ro" statement in the [<b>Libraries</b>] section of the MSACCESS.INI file. Not loading the wizards will free up 315K RAM that Microsoft Access can use for its own purposes, with the benefit of not only increasing run-time performance, but also reducing application load-time by an average of ten seconds. <br><br></li>
<li>
<b>Remove wallpaper/background bitmaps:</b> Removing a standard window's wallpaper background can free up anywhere from 25K to 350K of RAM, and removing complicated bitmaps can free up even more.<br><br></li>
<li>
<b>Utilize a permanent swap file:</b> Creating a permanent swap file (as opposed to a temporary one) will give you an additional performance increase. See your Windows documentation for directions on how to set this up on the machine that will be running the database application.</li>
</ul>
<p>
Now that we've ensured a solid hardware platform, maximized disk access efficiency, and increased the RAM memory available for your application to use, let’s turn to optimizing the application itself: </p>
<h2>The Microsoft Access Database Itself</h2>
<p>
<b>Compact, compact. </b>Be sure to compact your application frequently. When you are developing and using a Microsoft Access database, you are frequently adding and deleting data, code, and so on. The problem is that Microsoft Access does not effectively remove the space that was previously allocated for deleted objects, meaning that even though you deleted it, it is still occupying space in your database. Compacting the database will force Microsoft Access to remove the space that the deleted objects formerly occupied, resulting in a smaller database size and a much more efficient database. Don't overlook the importance of compacting in terms of performance—I've literally cut average query times by 30–50% merely by compacting database applications that had become bloated over time due to frequent use and lack of compacting. Just as you periodically defragment hard drives, you or your client should periodically compact the database to ensure that it is operating at peak efficiency. </p>
<p>
<b>Code only, please. </b>While you may wish to prototype an application via macro automation, once you set out to optimize performance of your final application, be sure to rewrite all macros into code. The bottom line is that Access Basic code runs faster than macros. Unfortunately, there are three macro actions you will be prevented from rewriting into code: these are the Autokeys, Autoexec, and Addmenu actions, which have no Access Basic equivalent—hence you will be forced to use them. However, you can overcome the Autoexec limitation by having the Autoexec macro action be a one-line Runcode macro that calls your Access Basic <b>Autoexec</b> function. </p>
<p>
<b>Optimize datatype declarations. </b>You should try to be as specific as possible when declaring datatypes within your code. While the variant datatype (the default unless otherwise specified) is extremely flexible, it also the most memory-expensive of any of the datatypes. Thus, if you know that the <i>CheckBalance</i> variable will not need precision beyond four decimal places and will never contain a null value, declare it as currency and not as a variant. You'll want to do the same for your procedure declarations (for example, Function PostCredits() as integer, instead of Function PostCredits()). Please make note of the fact that you <b>will</b> need to use the variant datatype (rather than a more efficient but stricter datatype) if you expect that the variable will ever be asked to handle a null value (otherwise you will receive an error). Along similar lines, be aware of the differences between integer division and floating-point division. </p>
<p>
<b>Always use Form/Report variables.</b> Within your procedures, you want to ensure that you resolve as much of any given reference as possible in advance. What does that mean? Take the following example: If you wanted to refer to the text box called [Net Price] in code, you would use the following:</p>
<pre><code>Mytempvariable = Forms![Customer Invoice]![Net Price]
</code></pre>
<p>
For this command, Microsoft Access will first search the Forms object for the form named [Customer Invoice]. Once it locates the [Customer Invoice] form, Microsoft Access looks for the control named [Net Price] and takes the appropriate action. With the above statement, Microsoft Access went through two references to ascertain the final control we were specifying. If you plan on referencing any control on the [Customer Invoice] form again within that same procedure (function or subroutine), you can eliminate the redundant referencing that would occur the next time by using the following:</p>
<pre><code>Dim F as form
Set F = Forms![Customer Invoice]
</code></pre>
<p>
Now, your form variable <i>F</i> automatically refers to the form [Customer Invoice], allowing Microsoft Access to avoid searching through all of the forms in the database’s Forms object each time you </p>
<p>
reference any object on the [Customer Invoice] form. To reference the control [Net Price], you would now simply use the following:</p>
<pre><code>Mytempvariable = F![Net Price]
</code></pre>
<p>
You can also do the same with the Reports object (for example, Set R = Reports![My Report]). While you won't get any speed gains if you access a form or report only once in a function, you will see significant time savings as soon as you start to access controls on the same form or report more than once. Thus, by saving Microsoft Access from having to do redundant referencing, you will greatly enhance the speed at which your procedures will execute.</p>
<p>
<b>Use Windows functions where applicable.</b> Whenever relevant, use a Windows function call instead of performing the same action in Access Basic code. You will save development time because the function calls are already coded and optimized and because they are written in C (resulting in machine language executables)—whereas Access Basic code is compiled into a p-code format and interpreted line by line when executing. The most common example is custom .INI settings. You could use the Access Basic file functions to obtain a free file handle, open the file, read/write the file, and then close it, but why bother when you can simply use the <b>GetPrivateProfileString</b> and <b>WritePrivateProfileString</b> functions, which are faster, already coded, and waiting for you? (See <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_abwinapi">
</object><a href=JavaScript:alink_1.Click()>“Enhanced Microsoft Access: Using the Win16 API”</a>.)</p>
<p>
The faster your Microsoft Access database application can accomplish its responsibilities, the better you will have achieved your mission of providing your clients with the ability to effectively collect, manage, and retrieve their data. I hope the above tips will help you achieve this goal.</p>
</BODY>
</HTML>
