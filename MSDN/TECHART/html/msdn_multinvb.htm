<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Performance of Visual Basic Multithreaded ActiveX Servers</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_multinvb"></a></sup>Performance of Visual Basic Multithreaded ActiveX Servers</h1>
<p>
Brian Haslam<br>
Microsoft Corporation</p>
<p>
February 1997</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5048">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the ThrdCode sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
Since the advent of the Microsoft® Win32® application programming interface (API), multithreading has been widely available and used by C/C++ developers writing applications for the Windows® operating system. Now this technology can be employed to produce scalable programs using Microsoft Visual Basic® version 5.0.</p>
<p>
This article discusses the following issues:
<ul type=disc>
<li>
The benefits of using multiple threads in Visual Basic server components.<br><br></li>
<li>
A method for improving performance on a multiprocessor machine using a multithreaded Visual Basic ActiveX™ EXE server.<br><br></li>
<li>
Increasing performance on two- and three-tier architecture systems by replacing single-threaded components with their multithreaded equivalents. </li>
</ul>
<h2>Introduction</h2>
<p>
This article is principally of interest to Visual Basic developers who want to learn more about potential performance gains that can be possible by implementing multithreaded Visual Basic software components instead of their single-threaded counterparts.</p>
<p>
This article also fills a gap in the available multithreading literature, which deals largely with synchronization issues coupled with thread safety. These articles almost exclusively use sample code written in C/C++. While synchronization issues cannot be entirely dismissed in Visual Basic, many of these topics are often simply not relevant. Therefore this article provides useful information on ways the Visual Basic developer can employ multithreaded components. The article takes into account the limitations and benefits of multithreaded components in Visual Basic, and all code presented is written solely with Visual Basic version 5.0.</p>
<h3>The Benefits of Multiple Threads</h3>
<p>
It is possible to classify at least three separate categories of improvements that multithreaded components may introduce, and these all fit under the umbrella of improved <i>performance</i>.</p>
<h4>1. Improved Computation Speed</h4>
<p>
Increases in computation speed largely depend on the type of problem being solved and the type of computer on which those problems are tackled. In his technical article <a href="msdn_threadli.htm">“Win32 Multithreading Performance,”</a> Ruediger Asche divides programming problems into CPU-bound and I/O-bound categories. CPU-bound calculations use up most of the available processor cycles to perform a computation (for example, sorting an array or multiplying matrices). I/O-bound programs typically wait for a request to finish (for example, waiting for a serial port event or waiting for data to travel across a network). Asche notes that any substantial programming task will most probably contain elements of both CPU-bound and I/O-bound problems, but these two extreme categories serve to bound the range of programming tasks.</p>
<p>
The classification of these computations is important because any CPU-bound computation will generally take longer in a multithreaded case on a single-processor machine than the same computation in a single thread of execution. The multithreaded case takes longer than the single-threaded case because the machine must perform the same work for the calculation in both cases, but the multithreaded program must also deal with the overhead of extra instructions for thread context switches.</p>
<p>
In contrast, a series of I/O-bound requests in a program could benefit substantially from conversion to a multithreaded architecture even on a single-processor machine. If each of the requests do not have to rely on the results of former requests, then the results can be processed on individual threads as soon as they are received.</p>
<h4>2. Improved Scalability</h4>
<p>
Assuming computations lend themselves to being broken up and performed in parallel, each can run on a different thread and be performed concurrently. In these cases, it is often possible to significantly increase program speed by running the programs on multiprocessor machines instead of single-processor machines of the same speed. Multithreaded programs therefore have more potential to be scaled to increase the <i>throughput</i> when placed on symmetric multiprocessor machines. The obvious corollary of increasing the throughput is that the response time of requests by multiple client machines will be less—that is, better performance.</p>
<h4>3. Improved User Interface "Responsiveness"</h4>
<p>
Traditionally, to keep the user interface lively on a single-processor machine during a CPU-bound calculation, a developer interlaced <b>DoEvents</b> statements within the commands for the calculation—especially in nested loops. This method remains valid in Visual Basic, and it is easy to implement. However, two drawbacks with the method are listed below:
<ul type=disc>
<li>
If the user interface is idle, then no input messages are pending and the calls to <b>DoEvents</b> are probably wasted.<br><br></li>
<li>
The method is not scalable—that is, if the same single-threaded program is put on a symmetric multiprocessor machine, it will not enjoy any noticeable speed gains.</li>
</ul>
<p>
In a client/server application where synchronous function calls are being made to an ActiveX server, a Visual Basic client application may seem unresponsive while making the function calls. The cause for this sluggishness may be that the client program has no easy way to achieve concurrent background processing. Shelling out multiple processes to do the work is one solution, but management of processes carries a high performance penalty. In this case, a multithreaded server could be employed to perform the work of calculations while the client concentrates on keeping the user interface responsive. </p>
<p>
Remember that if you are going to write both the client and multithreaded server in Visual Basic, the multithreaded server will have to be an ActiveX EXE in order to gain the benefits of multiple threads. You have to use an ActiveX EXE because only the client application can create and control threads of a multithreaded DLL, and Visual Basic 5.0 programs cannot explicitly create new threads.</p>
<h3>A Method for Improving Speed of CPU-bound Computations with Concurrent Processing on a Symmetric Multiprocessor Machine</h3>
<p>
Executing computational work in parallel can lead to better performance of programs on symmetric multiprocessor machines (SMPs). Although it is not possible to explicitly create new threads in Visual Basic, it is possible to perform work in parallel using multithreaded servers. By coupling multithreaded servers with events (also a new feature to Visual Basic version 5.0), the servers can perform synchronous tasks concurrently on multiple threads. A Visual Basic client can call an asynchronous method in a server component many times in succession using multiple objects. If the server is on a “thread-per-object” model, then each call will consequently be executed on a different thread. This is the technique introduced here to get multiple threads working at the same time, even though in this case we only have a single-threaded Visual Basic client application.</p>
<p>
To illustrate this technique, a program was developed using a Visual Basic ActiveX EXE server to concurrently sort arrays of data. Although a sorting computation is studied here, this method can clearly be applied to any general programming problem where it would be advantageous to perform background work on multiple threads. The server project is attached as MultSort.vbp, and the sample client project is attached as TrdTest.vbp. This scenario involves several new features to Visual Basic version 5.0: 
<ul type=disc>
<li>
<b>Multithreading:</b> To allow the server to sort multiple arrays concurrently, the server must be multithreaded.<br><br></li>
<li>
<b>Callback APIs:</b> To allow the sort function in the server to be asynchronous, a timer needs to be set so that we can fire the worker function after a set amount of time. The callback API solves a specific issue: in Visual Basic a multithreaded server cannot have a user interface. Since there can be no forms, we cannot use the Timer control in the server. However, Visual Basic 5.0 now allows callback API functions in modules, so you can call the <b>SetTimer</b> API function directly. <br><br></li>
<li>
<b>Events:</b> To notify the clients when the sort function is finished, an event is fired from the server. The resulting sorted array is passed as a Variant type parameter to the event.</li>
</ul>
<p>
In order to perform the sorting tasks asynchronously, the server caches the unsorted data array and the instance of the client object in variables declared at the module level. The Asynchronous sort routine then enables a timer, and returns from the method. The code in clsSort of the server is shown below:</p>
<pre><code>‘This is the event raised when the sort computation is complete.
Public Event SortComplete(vntSortedData As Variant)

‘Below is the method called by the client to perform the asynchronous sort.
Public Sub Asynchronous_SelectionSort(vntUnsortedData As Variant)
 &nbsp;&nbsp; 'Cache the array to be sorted.
 &nbsp;&nbsp; g_vntUnsortedData = vntUnsortedData

 &nbsp;&nbsp; 'Cache the instance of this object.
 &nbsp;&nbsp; Set g_objSort = Me
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Enable the Timer to fire in 100 ms – in the Timer event we do the work.
 &nbsp;&nbsp; EnableOneShot 100
End Sub

‘This function will be called by a module-level function where
‘the sort actually takes place.
Friend Sub FireSortComplete(vntSortedData As Variant)
 &nbsp;&nbsp; RaiseEvent SortComplete(vntSortedData)
End Sub
</code></pre>
<p>
The code in the server relies on an important facet of Visual Basic multithreaded components—each thread maintains its own module-declared data. In this multithreaded server, the <i>thread-per-object</i> model is used, so each object essentially has its own thread and, therefore, it has its own module-declared data. In contrast, the asynchronous call implementation used here does not work for a single threaded server for the following reason: if a client called the <b>Asynchronous_SelectionSort</b> method twice in succession, the second call would cause the server to throw away the reference to the first client, and only the second call would have a resulting event fired with the result.</p>
<p>
After enabling the timer, and returning from the <b>Asynchronous_SelectionSort</b> routine, the Visual Basic client thread will regain control, and it can continue servicing other user interface requests or carry on with further code in the procedure. In this case, code in the client asks the server to sort a different array of data using a different object (and therefore a different thread). Meanwhile, in the server, the timer fires and starts to perform the work that the client asked it to do. When the work for that data is finished, the server raises an event, and passes the resulting sorted array as a parameter in the SortComplete event. The code in the module of the server is shown below:</p>
<pre><code>Public g_vntUnsortedData As Variant
Public g_objSort As clsSort
Public g_TimerID As Long

Public Sub EnableOneShot(ByVal ulTime As Long)
 &nbsp;&nbsp; g_TimerID = SetTimer(0, 0, ulTime, AddressOf TimerCallback)
End Sub

Public Sub TimerCallback(ByVal hWnd As Long, ByVal uMsg As Long, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal idEvent As Long, ByVal dwTime As Long)
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Kill the timer - we do not need it any more.
 &nbsp;&nbsp; KillTimer 0, g_TimerID
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Use selection sort to sort the Global array.
 &nbsp;&nbsp; SelectionSort g_vntUnsortedData
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Raise the event to indicate sort is finished.
 &nbsp;&nbsp; g_objSort.FireSortComplete g_vntUnsortedData
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Cleanup and exit.
 &nbsp;&nbsp; Set g_objSort = Nothing
 &nbsp;&nbsp; 
End Sub
</code></pre>
<p>
One of the principal benefits of this server implementation is that it should be very scalable—that is, if the server is ported over to a multiprocessor machine, the work of sorting multiple arrays can take place concurrently, and therefore the results can be obtained faster. A second benefit is that the work is being performed on different threads than the thread that maintains the user interface of the client. Using a multithreaded server to perform background work allows the user interface to be more responsive.</p>
<p>
To test the performance of this program, the time to sort four arrays of random numbers (longs) using one object (and therefore one thread) was compared to the case with four objects on four different threads. Each case was tested on both a single-processor and a symmetric multiprocessor machine. The first machine used was a single-processor Pentium 166 MHz with 32 megabytes (MB) RAM, and the second machine was a quad-processor Pentium 166 MHz with 320 MB RAM. Since both programs were small relative to the amount of free RAM (the EXE client and server together were less than 30 KB, the Visual Basic run time is about 1.3 MB), and since they both performed very similarly with similar single-threaded programming tasks, the comparisons seem valid. In any case, results for the single-thread and multithread cases on any one type of machine can be compared to each other.</p>
<p>
Both machines were running Microsoft Windows NT® 4.0 with Service Pack 2. The tests called the Windows API <b>GetWindowTicks</b> function to measure how long the computation ran, and the computation was run one hundred times. The mean average time of the one hundred trials was calculated using Microsoft Excel 97. </p>
<p>
The results of running the tests with the Visual Basic client and EXE server on the single-processor and multi-processor machines are shown in Figure 1.</p>
<p>
<img src="multinvb_1.gif" border=0></p>
<p class=label>
<b>Figure 1: Mean Average Time to complete the sorting of four arrays</b></p>
<p>
It is interesting to note that multiple threads for the same calculation on a single processor machine caused a small slowdown, most likely due to the added thread management instructions as described earlier. The single thread on the multiprocessor machine case was only slightly faster, as expected, probably due to the fact that operating system instructions could be performed by other processors while the sorting operations in the Visual Basic server took place. However, the significant result is that the multithreaded component completed the sorts significantly faster on the multiprocessor machine than the single-threaded case on the same machine.</p>
<p>
A ratio, appropriately named Speedup (see Christopher Lazou, <i>Supercomputers and their Use,</i> Oxford Science Publications, 1988), is defined as:</p>
<p class=indent>
Speedup = S = (Execution Time for Uniprocessor / Execution Time for P Processors) </p>
<p>
In this case, the Speedup factor was therefore measured at ~3.6.</p>
<p>
The results of this case were expected because the number of arrays to be sorted was equal to the number of processors. The case clearly illustrates a specific design goal—<i>for CPU-bound calculations, the number of optimal threads for maximum performance is approximately equal to the number of processors on the machine</i>. It shows the improvements you can gain by porting a program to an SMP machine, if that program contains CPU-intensive operations, and if the calculations lend themselves to being calculated in parallel in a multithreaded architecture.</p>
<p>
However, this case also shows that the user should be especially cautious when considering whether or not to introduce multithreading in a CPU-bound computation. If it is likely that the program would never be run on a multiprocessor machine, multithreading will probably not improve the speed of these computations. </p>
<h3>Increasing Performance on a Two-Tier Architecture with Multithreaded Visual Basic Components</h3>
<p>
If a single-threaded component is interacting with other multithreaded components on a server machine, all requests to the single-threaded component have to be queued—a process that could cost a severe performance penalty and become the <i>throughput</i> bottleneck for this and similar architectures. The problem of a single-threaded component being a throughput bottleneck is one of the reasons why multithreading in Visual Basic servers can be considered important for enterprise-level solutions.</p>
<p>
In order to study the potential for performance gains in these scenarios, the following case was designed. A single-threaded and multithreaded Visual Basic DLL server were compared for performance in conjunction with Active Server Pages and Microsoft Internet Information Server (IIS) 3.0. A case involving IIS 3.0 was chosen because IIS makes full use of multithreading to allow concurrent processing of client requests. Thus, by introducing multithreaded versus single-threaded components to interact with scripts run by IIS, you could potentially see large speed gains, particularly when run on multiprocessor machines.</p>
<p>
This scenario also has real-world relevance since there are several reasons why using ActiveX components in conjunction with Visual Basic Scripting Edition (VBScript) makes sense. </p>
<p>
Since Visual Basic 5.0 can compile native code, it seems reasonable that any intensive calculations are likely to run faster than equivalent code in VBScript. </p>
<p>
By encapsulating common routines into servers, the code is in a much more reusable format. </p>
<p>
Balanced against these reasons, it should also be remembered that there will be a performance cost of launching the server components and overhead associated with making calls into the server. Therefore, these components will most likely only pay dividends when the time to perform methods of the components is significantly larger than the time to instantiate an object from the server.</p>
<p>
<img src="multinvb_2.gif" border=0></p>
<p class=label>
<b>Figure 2: A schematic architecture of a typical arrangement of clients making requests to a server. Having a multithreaded server component allows IIS to create objects on different threads in order to increase the "throughput" of Web pages delivered (and therefore decrease the response time when multiple clients are making requests from the server).</b></p>
<p>
For this case, a Visual Basic DLL (see the attached project CPUTest.vbp) was created containing code to make a call into a database, retrieve a result set, and then perform an intensive CPU-bound nested loop calculation on that result set. A DLL was used for this case because the calls to in-process servers are known to give better performance than EXE servers—OLE does not have to marshal the data across process boundaries. Some of the VBScript (embedded in the ASP page) is shown below. This code instantiates and then calls methods of the Visual Basic component.</p>
<pre><code>&nbsp;&lt;% 

 &nbsp; Dim objServer
 &nbsp; Dim vntResultSetArray
 &nbsp; Dim vntAverage&nbsp; 

 &nbsp; 'Create the Object.
 &nbsp;&nbsp; Set objServer = Server.CreateObject("DBTest.clsDatabaseOp")

 &nbsp; 'Retrieve the data from the Access database into an array.
 &nbsp;&nbsp; vntResultSetArray = objServer.GetData("Select UnitPrice, Quantity From [Order Details]") 
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Have the server calculate an average in a CPU-bound loop.
 &nbsp;&nbsp; vntAverage = objServer.CalculatePriceQuantityAverage(vntResultSetArray)

 &nbsp;&nbsp; 'Let go of the server reference.
 &nbsp;&nbsp; Set objServer = Nothing

%&gt;
</code></pre>
<p>
In this instance, the <b>CalculatePriceQuantityAverage</b> function contained in the Visual Basic server component is CPU-intensive—it loops through a 2,000-row result set about 20 times. By calling this function, the calculation was deliberately made CPU-bound. Admittedly, the numerical result calculated in this example does not have a practical use. However, it does serve to demonstrate a typical type of CPU-bound computation—one where a custom result must be calculated from the fields of a database, and where SQL alone does not provide sufficient syntax to achieve the results.</p>
<p>
To measure performance, a Visual Basic client program (attached as WebTest.vbp) was constructed to continually hit the information server with requests for the ASP Web page. It uses the Microsoft Internet Transfer control (msinet.ocx). The time before the request to receive the Web page was taken with the <b>GetWindowTicks</b> API, and the time immediately after the call was also measured. These times were then sent in subsequent requests to the ASP page, which passed the results to the Visual Basic component. The Visual Basic component logged them to a Microsoft Access database. The time taken to log the result was small relative to the time taken for the operations performed by the component, but the CPU-bound operations did involve database access, which was part of the issues being studied for this case.</p>
<p>
The server applications (consisting of IIS combined with the ASP page and the Visual Basic component) were run on the multiprocessor machine described earlier, and client machines were all Pentium 200s and Pentium 166s with 32 MB of RAM. The speed difference of these client machines did not appear to affect response time measured in any significant way. The response time versus a varying number of client machines for both the single and multithreaded DLL component cases are shown in Figure 3.</p>
<p>
<img src="multinvb_3.gif" border=0></p>
<p class=label>
<b>Figure 3: Mean Average Time for returning Web pages versus number of clients with Visual Basic DLLs performing intensive CPU-bound calculations</b></p>
<p>
The results indicate that for this case, replacing the single-threaded Visual Basic DLL with a multithreaded one caused the throughput to increase on the multiprocessor machine. Another way of stating this is that the <i>response time</i> was proportionally smaller with the multithreaded DLL, instead of the single-threaded DLL component, when adding more client machines. The single-threaded component case exhibited a near linear relationship between response time and number of client machines. In the multithreaded component case, <i>step</i> behavior can be seen for small numbers of clients (&lt;5), but the multithreaded case line seemed to approximate linear behavior as more client machines were added. In this case, the step behavior is most probably related to the fact that the server was a quad-processor machine. </p>
<p>
In this computation, there was not a huge gain in throughput, although it must be remembered that the calculation was made CPU-bound. In a CPU-bound computation, the maximum gain possible would be four (when all four processors are working on the problem in parallel). Since the operating system still had to run, and the IIS service needed CPU cycles to deal with pending requests, the gain could only be less than this theoretical maximum.</p>
<h3>Increasing Performance on a Three-Tier Architecture with Multithreaded Visual Basic Components</h3>
<p>
The problem with CPU-bound calculations being performed on the server machine that is accepting and processing requests is that the server can be bogged down with calculations, and therefore is delayed from processing further requests from clients. A better architecture is often to have a third tier perform the work required for calculations, thus leaving the second tier free to deal with incoming requests. A third-tier architecture will give better performance in the sense of being more scalable, thus reducing response time (increasing throughput) for more client machines. This concept hinges on the second tier not being a bottleneck for incoming requests, and, in turn, that may hinge on all components in the second tier being fully multithreaded.</p>
<p>
It is important to note that this is only going to give better performance if the third tier is more capable of performing the work in parallel. In the case of CPU-bound calculations, it may be reasonable to use COM in a distributed environment (DCOM) or Remote OLE to have the work distributed by a series of servers. (For more information in the area of load balancing, see “Use Visual Basic 4.0 to Distribute the Load with Remote Automation” in the MSDN Library (<i>Developer Network News</i>, Volume 4, Number 6.) A three-tier architecture can transform the CPU-bound calculations on the second-tier server into I/O requests for the work to be done somewhere else, and could mean that much better gains may be expected if the work is spread out.</p>
<p>
To study the performance benefits of employing a multithreaded component in a three-tier architecture, a similar arrangement to the two-tier architecture case studied was designed. Again a solution employing Internet Information Server 3.0 was used, but the principles should extend to any solution which involves multithreaded server components interacting with multithreaded server software.</p>
<p>
A Visual Basic DLL server (see the attached project IOTest.vbp) was created, and it contained a method which simulated an I/O-bound request to the third tier by calling the <b>Sleep</b> API function. In practice, the methods in the software component would really be of the form of I/O request(s) to a third-tier machine(s) to perform work, perhaps via Remote OLE or DCOM, or perhaps more commonly as requests to a SQL server. In all these cases, the work is not performed by the second tier, so while waiting for a request to return the results, the server can be setting up more requests. </p>
<p>
<img src="multinvb_4.gif" border=0></p>
<p class=label>
<b>Figure 4 : Schematic of a three-tier architecture that uses Active Server Pages, which make calls into a Visual Basic component </b></p>
<p>
Since the machine running IIS is not performing the back-end work, it is left free to deal with pending requests. This is where having a multithreaded component becomes pivotal to increasing performance. If the Visual Basic component being called on the second-tier machine were single-threaded, the requests for the objects would be serially queued. The wait time in this single-threaded queue will define the performance penalty. If you make the Visual Basic component multithreaded, each object can wait for the request in its own thread. Since these objects are not doing any work, but rather waiting for work to be done on another machine(s), the CPU is free to give time slices to the process that accepts more pending requests from clients. </p>
<p>
Using the same Web client application described in the two-tier case (WebTest.vbp), the effect of multiple clients was measured on the server response time. The case was performed with a single-threaded and a multithreaded Visual Basic component. The performance results are shown in Figure 5.</p>
<p>
<img src="multinvb_5.gif" border=0></p>
<p class=label>
<b>Figure 5: Mean Average Time for Web page request versus number of client machines making requests. The Visual Basic DLL component simulates an I/O-bound request by sleeping for 2 seconds in a method called by Active Server Pages.</b></p>
<p>
These results show that use of the multithreaded component instead of the equivalent single-threaded component caused the throughput to be almost three times larger in the multithreaded case, even though the server components were all on a single-processor machine. It must be remembered that the full speed increase would only be realized if the backend server which performs the actual work of the requests showed no slowdown with multiple requests—something that could probably only be realized with a large multiprocessor machine, or perhaps via DCOM/Remote OLE and multiple third-tier servers. Figure 5 also shows interesting non-linear behavior for small numbers of clients. For only two or three clients in the multithreaded component case, there was no noticeable slowdown in the throughput compared to the one client case.</p>
<h2>Conclusions</h2>
<p>
Visual Basic version 5.0 has introduced the capability of having multithreaded ActiveX servers. Intelligent use of multithreaded servers in place of single-threaded ones can yield significant performance gains by increasing the speed of computations, enhancing scalability of applications (that is, keeping response time low when more clients make requests to a server), and improving user interface “responsiveness.”</p>
<p>
In this article I have presented a method of using multiple threads to perform work when using a Visual Basic client and EXE server. On a multiprocessor machine, CPU-bound computations can be increased in speed with a factor approaching the number of processors on that machine. However, CPU-bound computation can only reasonably be expected to increase in speed when ported over to a multiprocessor machine.</p>
<p>
I have also shown that multithreaded Visual Basic ActiveX servers can function as faster back-end components than their single-threaded counterparts in two-tier and three-tier architectures. This is most true when these components serve in conjunction with other multithreaded software (such as Microsoft Internet Information Server). Employing multithreaded components versus single-threaded servers in a three-tier architecture can achieve large decreases in response time when multiple clients are making requests, even when the second-tier consists of a single-processor machine. </p>
<p>
The cases studied in this article involve use of Visual Basic components in conjunction with Microsoft Internet Information Server 3.0 and server-side VBScript. However, the principles discussed in this article can be extended to programs that use DCOM in conjunction with, or instead of, the Intranet applications studied here.</p>
<h2>Acknowledgements</h2>
<p>
Special thanks go to Pete Dussin, Ivo Salmre, and Mark Chace for advice. I am also grateful to Mike Willard for advice and time on the symmetric multiprocessor machine (the “Heater,” as it is known locally).</p>
</BODY>
</HTML>
