<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tips to Ensure Your Windows 95 Application Runs Under Windows NT 4.0</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_testnt40"></a></sup>Tips to Ensure Your Windows 95 Application Runs Under Windows NT 4.0</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
May 1996</p>
<h2>Abstract</h2>
<p>
Now that you've written your application for Microsoft® Windows® 95, you'd probably like to get the "Designed for Microsoft Windows 95" logo. One of the requirements for the Windows 95 logo is that your application must run under Microsoft Windows NT®. Any features that are not supported in your application under Windows NT must fail gracefully. This means that you should, at the very least, put up a dialog box informing the user that the functionality is not supported instead of making the function call and letting the chips fall where they may. (For complete information on the Windows 95 logo requirements, see <a href="http://www.microsoft.com/windows/thirdparty/">http://www.microsoft.com/windows/thirdparty/.</a>) Since Windows NT version 4.0 has the updated shell, you probably figure that your application will run with no problems. Chances are it will. This article is based on a presentation created by Noel Nyman, Windows NT 32-bit Applications Test Lead, and it contains some tips for testing your Windows 95 application under Windows NT version 4.0. Many thanks to Noel for the screen shots and source material.</p>
<h2>Why Test?</h2>
<p>
We all write bug-free code, right? Well, maybe <i>sometimes</i>, when the moon is full or you're suffering from the latest flu, some errant bug might just sneak into your code. Or you might not think of all of the things that you need to test in order to ensure that your code never fails. This is true of all code whether the target is an application or an operating system. </p>
<p>
The Systems group here at Microsoft tests loads of applications with Microsoft® Windows®, applications written by Microsoft and by third parties. Doing this helps us find bugs in Windows and helps us make sure that as many applications as possible run on Windows. Third-party application testing is especially useful because the code is written outside of the context of our walls; third-party developers code differently and use the API in ways that we have not yet even dreamed of.</p>
<p>
The bottom line is this: The more applications that run under Windows, the more valuable Windows is to our customers. As a result, we test applications to help vendors make as many applications as possible work under Windows.</p>
<p>
The issues discussed in this article are meant to illustrate problems you might encounter and scenarios you may want to test when running your Windows 95 application under Windows NT® version 4.0. I have provided screen shots to clarify these issues. Bear in mind that the use of these images is not meant to reflect badly on the coding practices used for any particular application. Rather, they illustrate problems you might encounter but that have not yet appeared. Where possible, the name of the application used in the image has been removed. I'm not trying to point fingers—I just want to help you to not make the same mistakes.</p>
<h2>Tip 1: Check for the Correct Version</h2>
<p>
One frequent problem in software design is caused by the necessity to support several different versions of the same operating system. If you check the version and misinterpret the information, your code may fail or may produce unexpected results, such as showing the wrong dialog box or adding incorrect items to a context menu. The application below has not checked for the operating system version correctly and detects Windows NT as the operating system. It assumes that TAPI is not available because TAPI was not supported in Windows NT 3.51. In version 4.0 of Windows NT, however, TAPI <i>is</i> supported. </p>
<p>
<img src="testnt40_1.gif" border=0></p>
<p class=label>
<b>Figure 1. This application misinterpreted information received from GetVersion.</b></p>
<p>
The application below also misinterpreted the information returned by <b>GetVersion</b> and assumes it's running under Windows 95, making specific calls into Kernel32.dll that are unavailable in the Windows NT version of the DLL.</p>
<p>
<img src="testnt40_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The wrong operating system has been detected. </b></p>
<p>
You can solve this problem by using the <b>GetVersion</b> or <b>GetVersionEx</b> function to check the version of the operating system. These functions can be used to determine many interesting pieces of information including the build number, the major version (for example, 3), the minor version (for example, 1), whether the machine is running Win32s®, and whether the operating system is Windows 95. </p>
<p>
Sounds great, doesn't it? The problem occurs when a developer wrongly assumes that he can check only certain pieces of this information, such as the build number, to determine which system is running. It is important to check <i>all</i> of the pieces of information culled by the version-checking functions. The article "To SUR With Love" on the Win32 Web site (<a href="http://www.microsoft.com/win32dev/">http://www.microsoft.com/win32dev/</a>) covers this problem in detail.</p>
<p>
The application in Figure 3 doesn't recognize that Windows NT version 4.0 is a newer version of the operating system than version 3.51. The application is most likely looking only at the minor version number, 0, and ignoring the major version number, 4. </p>
<p>
<img src="testnt40_3.gif" border=0></p>
<p class=label>
<b>Figure 3. An application that believes 4 is not greater than 3.51.</b></p>
<p>
This application does not open the common dialog boxes when menu options such as File Save As... are chosen. The application correctly determines that it's running under Windows NT and initializes itself to use the common dialog box template in the style of Windows NT 3.51. It also sees version "4.0," assumes that it means the Windows 95 type of Explorer is available, and sets the OFN_EXPLORER bit. Windows NT checks for the OFN_EXPLORER bit, notices that it is being used with the wrong style template, and does not open a common dialog box.</p>
<p>
<img src="testnt40_4.gif" border=0></p>
<p class=label>
<b>Figure 4. This application used the wrong combination of common dialog box styles.</b></p>
<h2>Tip 2: Install the Correct MFC DLLs</h2>
<p>
This might sound like an obvious tip, so it is meant for someone other than you. In a nutshell, if you have written an MFC-based application, be sure to install the correct version of the MFC DLLs that are used by your application in your setup program. Do not assume that the DLLs are already installed. Depending upon the system, they may not be installed. </p>
<p>
The MFC30 DLLs are the most common redistributable files not installed by Windows 95 applications, but they're not the only ones. If your application requires <i>any</i> redistributable DLLs, your installation routine should:
<ul type=disc>
<li>
Include the DLLs as part of your distribution media.<br><br></li>
<li>
Verify the presence of the DLLs you require and replace existing DLLs <i>only</i> if they are older than the current redistribution versions you ship. (Prompt the user before replacing any files, please.) This is a pet peeve of mine. I must have had the same version of VBRUN installed about 100 times on my machine. This is no fun when I'm using a remote machine. It takes a lot of time to copy that big DLL. So, do me favor and check. I would appreciate it greatly.<br><br></li>
<li>
Install any DLLs you need that are not installed on the user's machine. </li>
</ul>
<h2>Tip 3: Check for Large Hard Drives</h2>
<p>
I remember my first computer. It was a VIC 20. It had a cassette tape drive. Then, a few years later, I was able to afford a machine with a hard drive. It held a whopping 40 MB. Wow! Windows NT can support drives larger than—be still my beating heart—4 GB. If your application uses variables to check for free disk space or total disk space that doesn't have the capacity to store numbers that large, you and your user may get incorrect results. Check out what happens in Figures 5, 6, and 7 below when you don't check for a large enough drive. </p>
<p>
<img src="testnt40_5.gif" border=0></p>
<p class=label>
<b>Figure 5. I've really got lots more space than this.</b></p>
<p>
<img src="testnt40_6.gif" border=0></p>
<p class=label>
<b>Figure 6. Who stole my gigs?!</b></p>
<p>
<img src="testnt40_7.gif" border=0></p>
<p class=label>
<b>Figure 7. I guess I won't be able to install this program.</b></p>
<p>
A hard drive with more than 8 GB of free space was used with Windows NT 4.0 to install and run several applications (this wasn't my machine, sniffle, sniffle). The three gray boxes above are screen captures from three different installation programs. All reported substantially less than 8 GB of free space. In fact, 25 percent of the applications we tested, including some from Microsoft, underreported free drive space. A few even gave the user a negative value. The user only sees this dialog box during installation and may not even notice a problem. Or the user will be savvy enough to know that she has more space than what is shown and will think that some bozo wrote the installation code.</p>
<p>
<img src="testnt40_8.gif" border=0></p>
<p class=label>
<b>Figure 8. Tsk, tsk. This application shows an incorrect value for free space.</b></p>
<p>
Figure 8 shows a screen capture from a CMD session using a Windows NT-specific shell extension that replaces the DIR command. This application gives the user incorrect information as part of its operation, not just at install time. Oops! </p>
<h2>Tip 4: Windows NT Functions Require Unicode Strings</h2>
<p>
Everyone enjoys seeing an example of a mistake we've made at Microsoft, so here's an example to make you grin. Check out the Figure 9 below.</p>
<p>
<img src="testnt40_9.gif" border=0></p>
<p class=label>
<b>Figure 9. An application that doesn't support Unicode running on Windows NT.</b></p>
<p>
The AutoRun.exe application shown in Figure 9, running on the Windows 95 CD-ROM, passes file names as ANSI strings to functions in SHELL32.DLL. This works fine when running under Windows 95; however, under Windows NT, the functions called require Unicode™ strings. As a result, the file name search fails, and Windows NT assumes that the required CD-ROM is no longer available and prompts the user to reinsert the CD-ROM.</p>
<p>
Windows NT is a Unicode operating system. If you call a function that returns Unicode and converts the string to ANSI using <b>WideCharToMultiByte</b>, be sure to pass the correct flags. The application shown below got the correct drive names from Windows NT but passed incorrect flags to <b>WideCharToMultiByte</b>, which caused the function to fail. The application then used the residual data already in the buffer for each drive icon name. In this case, the buffer contained the path to the \System32 folder on the local machine.</p>
<p>
<img src="testnt40_10.gif" border=0></p>
<p class=label>
<b>Figure 10. This application did not use the correct flags with WideCharToMultiByte.</b></p>
<h2>Tip 5: Be Aware of NTFS Compression</h2>
<p>
Windows NT supports the NTFS file system (okay, so that was redundant: NTFS == NT File System). NTFS supplies compression (among other things), and this compression should be transparent to applications. Some applications, like the one below, detect NTFS compression and wrongly think they can't create folders and files. </p>
<p>
<img src="testnt40_11.gif" border=0></p>
<p class=label>
<b>Figure 11. e:\foo is a compressed NTFS folder.</b></p>
<p>
When testing your applications, a good rule of thumb is to test installation and file I/O using the following devices:
<ul type=disc>
<li>
Local floppy (file I/O only)<br><br></li>
<li>
Local FAT hard drive<br><br></li>
<li>
Local NTFS hard drive<br><br></li>
<li>
Local compressed NTFS hard drive<br><br></li>
<li>
Local CD-ROM (installation only)<br><br></li>
<li>
Shared FAT hard drive<br><br></li>
<li>
Shared NTFS hard drive<br><br></li>
<li>
Shared compressed NTFS hard drive<br><br></li>
<li>
Shared CD-ROM (installation only)<br><br></li>
<li>
Shared Novell® Netware® hard drive</li>
</ul>
<h2>Tip 6: The Printer/Document Properties Dialog Is Different</h2>
<p>
Under Windows 95, the functionality of <b>PrinterProperties</b> and <b>DocumentProperties</b> are combined. Under Windows NT, however, these two functions are separate. In the screen shots below, the application called <b>PrinterProperties</b> and the Properties dialog box (Figure 13) appeared instead of the Document Properties dialog box (Figure 12), which the user expected.</p>
<p>
<img src="testnt40_12.gif" border=0></p>
<p class=label>
<b>Figure 12. The user expected to see this dialog box: Document Properties.</b></p>
<p>
<img src="testnt40_13.gif" border=0></p>
<p class=label>
<b>Figure 13. But the Printer Properties dialog box appeared instead.</b></p>
<h2>Tip 7: Check for Long Printer Names</h2>
<p>
Some applications assume that printer names will always be short (that is, 16 or 32 characters in length). Under Windows NT, printers can have long names. </p>
<p>
This application used <b>GetProfileString</b> to get the printer name. This function returned a string with the printer name, printer port, and other information. The application then parsed the string for the printer name, but stopped after 32 characters. It passed the partial name to the <b>CreateDC</b> function. <b>CreateDC</b> failed and displayed the message box shown in Figure 14. The moral of the story: Use MAX_PATH when you allocate buffers for printer names.</p>
<p>
<img src="testnt40_14.gif" border=0></p>
<p class=label>
<b>Figure 14. This system has a printer installed with a long file name.</b></p>
<h2>Tip 8: Long File Names Can Include Spaces</h2>
<p>
Both Windows NT and Windows 95 support long file names. If your application assumes that short (8.3 format) file names are used, then it will not gracefully deal with the long file names (in other words, your application will fail).</p>
<p>
Okay, back on my soapbox. One of the things I love about Windows NT and Windows 95 is the ability to create files and folders with names that contain spaces. This allows me to name a folder "Win32 Web Site Docs" instead of "Win32WebSiteDocs". The first is readable; the second looks like a function name. Unfortunately, <i>some</i> applications (which shall remain nameless here) don't support embedded spaces, and my editor has to rename all of the files I give her. (I stoically refuse to give up my spaces. Aren't you glad you aren't my editor?) </p>
<p>
Since Windows NT, and your application, may be used outside the United States, be sure to test foreign language characters and Unicode in file names and folder names, as well as testing using ASCII. In addition to testing for spaces (you <i>will</i> be doing that now, <i>won't</i> you?), test using the characters below that are not legal for DOS file names and folder names but are acceptable under Windows NT. Remember, even if you don't want to support these characters, other applications <i>will</i>, and your user will want to open her other files with your application. Be sure to test using several "." (dots) in file names; more than one is allowed.</p>
<p class=label>
<b>Illegal characters in DOS</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=36%><b>+</b></td>
<td width=64%>Plus sign</td>
</tr>
<tr valign=top>
<td width=36%><b>,</b></td>
<td width=64%>Comma</td>
</tr>
<tr valign=top>
<td width=36%><b>.</b></td>
<td width=64%>Period</td>
</tr>
<tr valign=top>
<td width=36%><b>;</b></td>
<td width=64%>Semicolon</td>
</tr>
<tr valign=top>
<td width=36%><b>=</b></td>
<td width=64%>Equal sign</td>
</tr>
<tr valign=top>
<td width=36%><b>[ ]</b></td>
<td width=64%>Brackets</td>
</tr>
</table><br>
<h2>Tip 9: Short File Names Are Not Created Equal</h2>
<p>
Since you gracefully support long file names, Unicode, and spaces (wink, wink), you probably feel like you are home free. Let's talk.</p>
<p>
Both Windows 95 and Windows NT save not only the long version of the file name, but also save a short version of the file name. Short file names are not created equal under Windows 95 and Windows NT. Windows 95 uses a consecutive number algorithm when creating short file names, while Windows NT uses a combination of consecutive numbers and random characters when creating short file names. Windows NT does this to speed file searches, not to make it harder on the developer. You'll probably never need to know, or care, what the "real" short file name is. Windows NT takes care of all that. On the other hand, if your application validates short file names based on the Windows 95 algorithm or modifies the directory structure, it may not perform as expected under Windows NT. Table 1 shows you the short file names that are produced by Windows 95 and Windows NT for the same three files.</p>
<p class=label>
<b>Table 1. Short File Names Produced by Windows 95 and Windows NT</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=33%><b>Long File Name</b></td>
<td class=label width=33%><b>Windows 95 Short File Name</b></td>
<td class=label width=34%><b>Windows NT Short File Name</b></td>
</tr>
<tr valign=top>
<td width=33%>Maps of Africa.vss</td>
<td width=33%>mapsof~1.vss</td>
<td width=34%>mapsof~1.vss</td>
</tr>
<tr valign=top>
<td width=33%>Maps of Europe.vss</td>
<td width=33%>mapsof~2.vss</td>
<td width=34%>mapsof~2.vss</td>
</tr>
<tr valign=top>
<td width=33%>Maps of England.vss</td>
<td width=33%>mapsof~3.vss</td>
<td width=34%>macebf~1.vss</td>
</tr>
</table><br>
<h2>Tip 10: Beware of Hard-Coded Paths</h2>
<p>
Don't assume that all system executables are stored in the \System directory. Windows NT may store system executables in different locations from Windows 95 or use different names for them. You should supply the file name to the <b>CreateProcess</b> function to launch executables. The file will run regardless of its location so long as the file is located in a directory that is included in the system path.</p>
<p>
In the example below, the application has hard-coded the path to WinHelp.exe in the %windir% folder. Under Windows NT, that's the 16-bit Help engine. But this is a 32-bit application and all of the application's .hlp files are version 2.0 (the 32-bit version), which the 16-bit version of WinHelp can't open. The error dialog box pops up, and a minimized WinHelp appears on the task bar each time the user chooses a Help option or clicks a Help button.</p>
<p>
<img src="testnt40_15.gif" border=0></p>
<p class=label>
<b>Figure 15. Hard-coded path to WinHelp causes the File Open command to fail.</b></p>
<h2>Tip 11: Registry Keys Differ</h2>
<p>
Windows 95 and Windows NT do not use the same registry keys for all objects in the system, such as printers. The application below was written for Windows 95 and looks for the default printer by enumerating the subkeys of the HKEY_LOCAL_MACHINE:System\CurrentControlSet\Control\Print\Printers key. </p>
<p>
<img src="testnt40_16.gif" border=0></p>
<p class=label>
<b>Figure 16. This application is using the registry key to enumerate printers.</b></p>
<p>
This works fine for Windows 95, but under Windows NT this information is stored in a different part of the registry. Instead, use <b>GetProfileString</b> to find the name of the default printer, and use <b>EnumPrinters</b> to get information about the installed printers. These functions work on both platforms. </p>
<h2>Tip 12: The HIWORD on 32-bit Handles Isn't Bogus</h2>
<p>
Windows NT and Windows 95 use 32-bit handles; however, under Windows 95, the high 16 bits are zero. Windows NT 3.51 accepted a handle with all zeroes in the high 16 bits by using that for a "wild card" match. That's why some code that passes only the low 16-bits of a handle still succeeds on version 3.51. Windows NT 4.0 enforces the full 32-bit rule. (We all must correct our bad habits sometimes!) Under Windows NT, the high 16 bits are usually nonzero. The application below is assuming that the high 16 bits are zero, so it strips off the high 16 bits and uses only the low 16 bits as the handle to the dialog box. The dialog box appears, but when the application subsequently uses the 16-bit version it created to send messages to the dialog box, the messages do not get to the dialog box. As a result, the dialog box never gets its Destroy message and remains forever. </p>
<p>
<img src="testnt40_17.gif" border=0></p>
<p class=label>
<b>Figure 17. You can click the button, but the dialog box will not go away.</b></p>
<h2>Tip 13: Direct Access to Hardware Is a No-No</h2>
<p>
Although the example in Figure 18 comes from a 16-bit application, 32-bit applications might also attempt direct hardware access. Windows NT will display an error dialog box, and your application may fail.</p>
<p>
<img src="testnt40_18.gif" border=0></p>
<p class=label>
<b>Figure 18. This application attempted to directly access the hard disk.</b></p>
<p>
The moral of the story: Don't use private 16-bit drivers. Even if they appear to function in test situations, they're likely to fail in the more complex environments your users will create. Play by the rules, and no one gets hurt.</p>
<h2>Tip 14: Check for Supported Parameters</h2>
<p>
Under Windows 95 and Windows NT, you cannot assume that all functions support all of the same parameters. This is because of different functionality of the operating systems. For example, the refresh rate parameter of <b>ChangeDisplaySettings</b> is ignored by Windows 95, but is supported by Windows NT. Using an inappropriate refresh rate value when setting the display settings won't matter on Windows 95. But, it may cause your display to go into the "let's-create-some-modern-art" mode on Windows NT. This problem can be avoided by checking for the operating system and using the appropriate parameters. Or, better yet, make sure all of your parameters are valid, even if one of the operating systems doesn't use all of them. What's the best way to make sure everything is valid? I did mention testing, didn't I?</p>
<h2>Tip 15: Large Fonts Versus Small Fonts</h2>
<p>
This problem occurs on Windows 95 as well as Windows NT. Some splash screens appear with a border on the right and lower margins when the machine is using large fonts. If this screen is just for display purposes, there's no harm done. It just looks funny. Figure 19 shows the screen using small fonts, and Figure 20 shows the same screen using large fonts. The gray background shows at the right and lower margins on Figure 20.</p>
<p>
<img src="testnt40_19.gif" border=0></p>
<p class=label>
<b>Figure 19. System using small fonts</b></p>
<p>
<img src="testnt40_20.gif" border=0> </p>
<p class=label>
<b>Figure 20. System using large fonts</b></p>
<p>
The problem occurs when the bitmap is a static control on a dialog box. The dialog box resizes along with the font size, even if there are no text controls in it, and the static bitmap does not resize. This makes the dialog box background color become visible. This is ugly, but it doesn't change the functionality of the dialog box.</p>
<p>
Some applications, however, can run into functional problems. In the simulated screen shot above, the splash screen is used as an index to a catalog of products. The user can click on one of the language names to get a short description of the product. The user closes the dialog box by clicking on the words "exit (TRUE)." When the machine is using large fonts, the dialog box resizes and the "hot spots" associated with the mouse clicks move along with it. The bitmap, however, does not resize, and the hot spots no longer coincide with the language names or the exit text. In other words, the application doesn't work as expected, and the user is challenged trying to figure out how to get rid of the dialog box. The developer could have avoided this particular problem by creating a static window with SS_BITMAP and SS_CENTERIMAGE flags instead of using a dialog box window.</p>
<p>
If you've created text windows that are too small to hold it, you may also see clipping of large font text in any dialog box. The bottom line is this: Test applications at different font sizes. </p>
<h2>Tip 16: Make Sure You Have the Right Rights</h2>
<p>
Your user may not have some rights or permissions your program needs to install or execute an application. Document any special rights your user needs (such as Administrator and Backup Operator). The error message below appeared when the user attempted to copy a file on a machine where he had only guest rights (that is, no ability to write to the disk).</p>
<p>
<img src="testnt40_21.gif" border=0></p>
<p class=label>
<b>Figure 21. Make sure you have permissions set correctly.</b></p>
<h2>Other Areas to Test</h2>
<ul type=disc>
<li>
The OLE, TAPI, MAPI, and WinSock code bases are substantially different in Windows 95 and Windows NT. Carefully test any application features that use them.<br><br></li>
<li>
Windows NT supports multiple processor machines. Some applications have problems in this environment. Test to ensure that this isn't a problem with your application. It's a great excuse to get the boss to buy you a cool MP machine.<br><br></li>
<li>
Use long duration tests (stress tests), multiple launch/close scenarios, and multiple file loads (if your application supports them) to test for memory leaks. The Microsoft Win32® SDK contains tools to help you find leaks. Other tools are available from outside vendors.<br><br></li>
<li>
Evaluate your potential RISC market and consider RISC platform-specific versions of your application. Your users may try to run your Intel version on an emulator you haven't tested whether there is no RISC version. You won't know whether that will work well unless you test it. The native RISC version will be faster and easier for you to test.<br><br></li>
<li>
Windows NT provides empty Autoexec.bat and Config.sys files for backward compatibility. If your application writes to those files, verify that it correctly deals with the Windows NT versions. Use the registry as an alternative to Autoexec.bat and Config.sys, unless your application must also provide backward compatibility on other platforms.</li>
</ul>
<h2>More Helpful Testing Hints from Our Test Group</h2>
<ul type=disc>
<li>
Create modular automated tests. When you find bugs with automated tests, you may still need to run the rest of the tests in the test suite. Breaking up tests into separate modules allows you to drop one test and keep the rest in the test script until the bug is fixed. Another good alternative is to design tests that can "recover" and allow the remaining tests to run.<br><br></li>
<li>
Descriptive error messages usually pay back the time need to create them. It's much easier to read an error message than to examine the underlying test code to analyze errors.<br><br></li>
<li>
Plan ahead for localization. Windows NT is an international operating system. The world is a potential market for your application, and some day soon your marketing people will want to tap that market and you will need to localize your application. For more details on developing and testing localized applications, see <i>Developing International Applications for windows 95 and Windows NT</i> by Nadine Kano (Microsoft Press, 1995).<br><br></li>
<li>
Gather application automation from your customers. When you create automated tests for your application, please share them with us (noeln@microsoft.com). Your tests show us what you feel are the most important features in your application. We'll add your tests to our own tests and run them on the newest builds. If we find problems, we will let you know about them right away, long before you get the next beta or shipping version of the operating system. <br><br></li>
<li>
Check for technical articles, hints, and tips from the Microsoft Developer Network elsewhere on the Library CD and at the Win32 Web site (<a href="http://www.microsoft.com/win32dev/">http://www.microsoft.com/win32dev/</a>). Following the guidelines and examples provided helps ensure that your code will work with current and future versions of Microsoft operating systems.</li>
</ul>
</BODY>
</HTML>
