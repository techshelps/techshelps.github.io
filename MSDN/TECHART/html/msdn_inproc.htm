<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Local vs. InProc Objects in OLE</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_inproc"></a></sup>Local vs. InProc Objects in OLE</h1>
<p>
Charlie Kindel<br>
Program Manager/OLE Evangelist, Microsoft Developer Relations Group</p>
<p>
Created: March 10, 1994<br>
Revised: October 18, 1994</p>
<h2>Abstract</h2>
<p>
The Component Object Model (COM) provides a single programming model for interacting with objects that live within the calling program's address space, in the address space of a process on the same machine, and in the address space of a process running on a different computer. While the programming model is identical for each of these three situations, there are obviously differences in performance. This article discusses some of the differences and provides techniques for designing objects so the impact of these differences is minimized.</p>
<h2>Introduction</h2>
<p>
A Component Object Model (COM) object that is executing in the same process space as the user of that object is called an <i>In Process</i> object (<i>InProc</i> for short). Interface method invocations on the object by the user are just as fast as a standard C++ virtual function call.</p>
<p>
<img src="inproc_1.gif" border=0></p>
<p class=label>
<b>Figure 1. InProc interface method invocations do not cross process boundaries.</b></p>
<p>
In the case where the user code is executing in the process space of Application A, and the COM object is executing in the process space of Application B, interface method invocations by A on interfaces implemented on B clearly must cross process boundaries. In this case, the COM objects in Application B are cross-process objects, or in OLE 2.0 terms, <i>Local</i> objects.</p>
<p>
<img src="inproc_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Local interface method invocations do cross process boundaries.</b></p>
<p>
Future versions of OLE will provide support for accessing objects running on a different machine. Objects that are running on a different machine from the user of the object's interfaces are called <i>Remote</i> objects. This is illustrated in Figure 3 below. (Because OLE with distributed services is not generally available, this article focuses on Local and InProc issues only.)</p>
<p>
<b><img src="inproc_3.gif" border=0></b></p>
<p class=label>
<b>Figure 3. Remote interface method invocations cross process and machine boundaries.</b></p>
<p>
As mentioned above, the Component Object Model provides the exact same programming model for accessing objects that are in the same process, local to the current machine but out of process, and running remotely on another machine. The only difference is where the object physically runs and how it registers itself.</p>
<p>
In a perfect world, calling a method on a COM interface would be as fast as a function call. In many cases, objects <i>can </i>be implemented as InProc objects, and method invocations <i>will </i>be as fast as direct function calls. However, because of real-world requirements, objects often must be implemented as .EXE applications and thus live in separate process spaces. Here are some of the reasons why objects might be implemented in Local servers today:
<ul type=disc>
<li>
<b>Legacy code.</b> There are cases where extending an existing code base that is implemented in an .EXE to support COM interfaces is a compelling short-term solution.<br><br></li>
<li>
<b>Multitasking.</b> When dealing with accessing external data, it can be advantageous to have complete control over your execution space. An object implemented in a Local server has its own message loop, data segment, and stack segment.<br><br></li>
<li>
<b>Security.</b> A dynamic-link library (DLL) that is dynamically linked to an application has complete access to all of that application's internal data. By implementing objects in Local servers, this potential security breach can be avoided.<br><br></li>
<li>
<b>Robustness.</b> For the same reason as security, robustness is also a reason for implementing objects in Local servers. If a DLL causes a general-protection fault, it causes the process in which it is currently running to crash. However, similar faults in one .EXE are unlikely to do damage to other processes on the system (this is particularly true on Win32® platforms).</li>
</ul>
<p>
Developers have a choice between developing their objects in Local servers or InProc servers. The points listed above argue for implementing Local servers. Performance is the primary argument for implementing InProc servers. The following section details a technique that allows the advantages of both Local and InProc servers in certain scenarios.</p>
<h2>Data Transfer vs. User Interface</h2>
<p>
The <a href="msdn_comdsgn.htm">"OLE Component Design Issues"</a> article illustrates a potential design for real-time market data applications. In that design (shown below in Figure 4), one or more "container applications" serve as "frames" for one or more "service objects." The containers are relatively dumb and exist primarily to provide unified screen real estate to the service objects. The service objects do useful user interface things such as drawing graphs and allow for the manipulation of data. The service objects get their data from "Data Source objects," which, in turn, get their data from some external source. The following technique assumes that it is more important to have high-performance data transfer between the Data Source objects and the service objects than between the service objects and the container. </p>
<p>
<img src="inproc_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Container embeds service objects, which get data from data source objects.</b></p>
<p>
In the scenario above, an instance of a service object is a consumer or user of interfaces from both the container and the Data Source. In the same vein, both the container and the Data Source are users of interfaces supplied by a given instance of a service object. An <i>instance</i> of an object must always live within the process space of only one process. This fact comes from the basic truth about Microsoft® Windows® DLLs: A DLL's code and local heap may be shared between processes, but the code in the DLL always executes using the stack of the caller. Thus, there <i>must</i> be a process boundary either between the container and the service object, or between the service object and the Data Source object.</p>
<p>
The interfaces used between the container and service objects are used for client site interactions, while the interfaces between the service objects and the Data Source object are for data transfer. In most real-time data access designs, it is more important to have high-performance data transfer than client site interactions, particularly if the container is really just a "dumb" container of "smart" objects.</p>
<p>
<img src="inproc_5.gif" border=0></p>
<p class=label>
<b>Figure 5. Service object running in container's process space</b></p>
<p>
Figure 6 shows the scenario where the service objects live in the container application's address space. In this case, the container application creates an instance of the service object via standard OLE 2.0 "Insert Object" mechanisms, which really boil down to the container calling <b>CoGetClassObject</b> on the service object's CLSID. Upon returning from the <b>CoGetClassObject</b> call, the container will have a pointer to the service object's <b>IClassFactory</b> interface. (Once the service object has been created via <b>IClassFactory::CreateInstance</b>, it obtains a pointer to an interface supplied by the Data Source via some well-known mechanism. There are many ways it can do this, including looking in the running object table.) Because the service object is implemented in an InProc server (that is, in a DLL), the pointer to the <b>IClassFactory</b> interface does not cross any process boundaries. The same is true for the interface pointers the container retrieves by calling <b>IClassFactory::CreateInstance</b>. Therefore, in Figure 6, the client site interactions are fast, but the performance of the data transfer may suffer.</p>
<p>
<img src="inproc_6.gif" border=0></p>
<p class=label>
<b>Figure 6. Service object running in data source's process space</b></p>
<p>
Figure 6 shows the scenario where the service objects are actually implemented as InProc servers but are exposed to containers as though they were Local servers. From this picture, it is clear that interface method invocations between the Data Source and the service object will not require marshaling and those between the service object and the container will. Thus, data transfer calls can be made as fast as direct function calls, but client site interactions require the relatively slower marshaled calls.</p>
<p>
To ensure that the service objects live in the Data Source's process space, the Data Source application loads each of the service objects into its address space when it starts, then registers their class factory objects as Local.</p>
<p>
As described in the OLE 2.0 Software Development Kit, local servers register their class factory objects by calling the <b>CoRegisterClassObject</b> function. InProc servers do not call this function, but instead they export a function named <b>DllGetClassObject</b>. OLE 2.0 provides a core function, <b>CoGetClassObject</b>, for accessing the class factory interface of a given object class. When this function is called, the following happens:
<ol>
<li>
An internal table of registered class objects is consulted to see if the requested class has been registered. If the class has been registered, its class factory interface is returned.<br><br></li>
<li>
If Step 1 failed, the registry is consulted to determine if there is an entry for this class and the LocalServer and InProcServer keys are used to retrieve the name of the EXE or DLL that implements the class.<br><br></li>
<li>
(a) If the class is implemented in an InProc server, the OLE libraries load the named DLL into memory and call its exported <b>DllGetClassObject</b> function. If this call succeeds, <b>CoGetClassObject</b> returns the <b>IClassFactory</b> interface returned by <b>DllGetClassObject</b>.<p class=tl>
If the class is implemented by a Local server, the OLE libraries cause the named EXE to be executed. </P></li>
<li>
As part of its startup code, the EXE that implements the Local server calls the <b>CoRegisterClassObject</b> function to register its class object, passing a pointer to its <b>IClassFactory</b>.<br><br></li>
<li>
Once the Local server yields, the OLE libraries note that the class that was requested by <b>CoGetClassObject</b> has been registered. <b>CoGetClassObject</b> returns the appropriate <b>IClassFactory</b> pointer.</li>
</ol>
<p>
The steps above provide a simplistic description of what happens. In reality, the procedure used by <b>CoGetClassObject</b> is more complex. In particular, the procedure given here assumes that <b>CoGetClassObject</b> was called with the <i>dwClsContext</i> parameter equal to CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER, which is the most common case for container applications. The net result of this procedure reaffirms the statement made at the beginning of this article: Users of objects do not know whether the interface pointers they have to those objects are Local, InProc, or Remote. The <b>CoGetClassObject</b> function makes the distinction opaque to callers.</p>
<p>
The process described above provides some insight into how a set of InProc objects can be made to appear "Local" to some users and "InProc" to others. A user who requires that the objects be InProc (for example, a Data Source object) should call <b>CoGetClassObject</b> for each service object it is interested in when it starts up. It should then call <b>CoRegisterClassObject</b> for each of the <b>IClassFactory</b> interfaces returned by the calls to <b>CoGetClassObject</b>, but should specify the CLSCTX_LOCAL_SERVER flag. </p>
<p>
Because the Data Source uses the CLSCTX_LOCAL_SERVER flag when calling <b>CoRegisterClassObject</b> for each service object, any container that calls <b>CoGetClassObject</b> will get back a marshaled (cross-process) <b>IClassFactory</b> pointer to the service object's class object. When the container calls <b>IClassFactory::CreateInstance</b> to actually create an instance of the service object, it is returned a marshaled interface pointer.</p>
</BODY>
</HTML>
