<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The ADO Object Model</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1><a name="adosql_object"></a>The ADO Object Model</h1>
<p>
The ADO object model defines a collection of programmable objects that can be used in Visual Basic, Visual C++, VBScript, Java, and any platform that supports both COM and OLE Automation. The ADO object model is designed to expose the most commonly used features of OLE DB.</p>
<p>
The ADO object model contains seven objects: 
<ul type=disc>
<li>
Connection<br><br></li>
<li>
Command<br><br></li>
<li>
Parameter<br><br></li>
<li>
Recordset<br><br></li>
<li>
Field<br><br></li>
<li>
Property<br><br></li>
<li>
Error</li>
</ul>
<p>
And four collections:
<ul type=disc>
<li>
Fields<br><br></li>
<li>
Properties<br><br></li>
<li>
Parameters<br><br></li>
<li>
Errors</li>
</ul>
<p>
Figure 1 shows their relationships.</p>
<p>
<img src="adosql01.gif" border=0></p>
<p class=label>
<b>Figure 1. The ADO object model</b></p>
<p>
The Properties collection and Property object that are not shown in the illustration are available through the Connection, Recordset, and Command objects. The Properties collection and Property object contain provider properties that can be read-only or read/write. </p>
<p>
The Connection, Recordset, and Command objects are the centerpieces of the ADO object model. An ADO application can use the Connection object to establish connections with the database server, the Command object to issue commands, such as queries, updates, and so on to the database, and the Recordset object to view and manipulate the returned data. The command language used with the Command object is dependent on the underlying provider for the database. In the case of relational databases, the command language is generally SQL.</p>
<p>
The Command object may be optional if the underlining OLE DB provider does not implement the <b>ICommand</b> interface. Because OLE DB providers can exist on top of relational or nonrelational databases, the traditional SQL statements may not be available in a nonrelational database to query data; therefore, the Command object is not required. If the Command object contains parameters, the parameter information can be viewed or specified through the Parameters collection and the Parameter object. The Parameter object describes parameter information for the Command object.</p>
<p>
In ADO versions 1.0 and 1.5, all objects can be created except the Error, Field, and Property objects. The Error collections and Error object can be accessed through the Connection object after a provider error occurs. The Field collections and Field object can be accessed through the Recordset object after data exists in the Recordset object. The metadata information of the Recordset object can be viewed through the Field collections and the Field objects.</p>
<h3>The Connection Object </h3>
<p>
The Connection object allows you to establish connection sessions with data sources. The Connection object provides a mechanism for initializing and establishing the connection, executing queries, and using transactions.</p>
<p>
The underlying OLE DB provider used for connecting is not limited to the ODBC Provider; other providers can also be used for connecting. A provider can be specified through the <b>Provider</b> property. If none is specified, MSDASQL is the default ODBC provider used for the connection.</p>
<p>
The <b>Open </b>method of the Connection object is used to establish a connection. With the ODBC Provider, an ADO application can use the ODBC connection mechanism to connect to a database server. ODBC allows applications to establish a connection through the ODBC data sources, or by explicitly specifying the data source information (commonly referred to as DSN-Less connection). For more information about DSN-Less connections with databases, such as SQL Server, see "Using ODBC with SQL Server" in the <i>Microsoft SQL Server Developer's Resource Kit.</i></p>
<p>
Before establishing connections, applications can set up a connection string, connection time-out, default database, and connection attributes. The Connection object also allows you to set up the <b>CommandTimeout</b> property for all the command objects associated with this connection. Query strings can be issued through the <b>Execute</b> method.</p>
<p>
Transactions can be controlled through the Connection object. The <b>BeginTrans</b>, <b>CommitTrans</b>, and <b>RollbackTrans</b> methods are provided for using transactions. </p>
<p>
The example shows using the ODBC Provider, the default OLE DB provider in ADO, to connect to SQL Server:</p>
<pre><code>Dim Cn As New ADODB.Connection
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Cn.ConnectionTimeout = 100
' DSN connection
#Cn.Open "pubs", "sa"
' DSN-Less connection for SQL Server
' Cn.Open "Driver={SQL Server};Server=Server1;Uid=sa;Pwd=;Database=pubs"
 &nbsp;&nbsp; 
Cn.Close
</code></pre>
<p>
The example first sets the connection time-out value to 100 seconds, and then opens a connection using the pubs ODBC data source that points to a SQL Server. A user ID is required for the SQL Server specified in the pubs data source; therefore, the sa user ID is provided as the second parameter of the <b>Open</b> method. There is no password, so the third parameter is omitted. </p>
<p>
In addition to using an ODBC data source, this example also provides a commented line that shows how to connect to SQL Server without an ODBC data source. The SQL Server ODBC driver, {SQL Server}, is used to connect to a SQL Server called Server1. The user ID to connect to Server1 is sa, and there is no password for sa. The default database for this connection is the<b> </b>pubs database.</p>
<p>
The example shows using the <b>Provider</b> property to specify an alternative OLE DB provider:</p>
<pre><code>Dim Cn As New ADODB.Connection
Dim rs As ADODB.Recordset

Cn.Provider = "sampprov"
Cn.Open "data source=c:\sdks\oledbsdk\samples\sampclnt\"
Set rs = Cn.Execute("customer.csv")
</code></pre>
<p>
An OLE DB provider, sampprov, is specified in this example. In addition to the ODBC Provider, OLE DB SDK shipped a sample text provider. The text provider allows an application to retrieve data from a text file. In this example, a connection is established by specifying the data source directory c:\sdks\oledbsdk\samples\sampleclnt\, and the data in the customer.csv file is returned as the result of the <b>Execute</b> method.</p>
<p>
The example shows using the <b>BeginTrans </b>and the <b>CommitTrans</b> or <b>RollbackTrans</b> methods:</p>
<pre><code>Dim Cn As New ADODB.Connection
Dim rs As New ADODB.Recordset

' Open connection.
Cn.Open "pubs", "sa"

' Open titles table.
rs.Open "select * from titles", Cn, adOpenDynamic, adLockPessimistic
Cn.BeginTrans
' &lt;&lt;make changes&gt;&gt;
Cn.CommitTrans
' or rollback
' cn.RollbackTrans
Cn.Close
</code></pre>
<p>
After the connection is established, this example begins a transaction. The data changed in this transaction can be committed or rolled back.</p>
<h4>The Errors collection and the Error object </h4>
<p>
The Errors collection and Error object allow you to retrieve provider error information when an error occurs. Errors can be generated by a method call or property of the Connection, Command, or Recordset objects, but are always retrieved from the Connection object. The Errors collection does not exist by itself. It depends on the Connection object and errors from below ADO (OLE DB providers, ODBC drivers, and data sources) to go to the Errors collection. Invalid property values or use of the ADO interfaces do not add an Error object to the collection.</p>
<p>
The Errors collection also stores warnings. A warning does not stop code execution, and a warning's positive number values differentiate it from a real error. The Error object allows you to retrieve the error description and source of the error. The SQLSTATE and database-native error information is also available from the Error object when working with the ODBC Provider.</p>
<p>
The example shows retrieving SQLSTATE, native-error, and error descriptions from the Error object when using the ODBC Provider:</p>
<pre><code>Dim Cn As New ADODB.Connection
Dim Errs1 As ADODB.Errors
Dim rs As New ADODB.Recordset
Dim i As Integer
Dim StrTmp

On Error GoTo AdoError
Cn.Open "pubs", "sa"
Set rs = Cn.Execute("select * from TableDoesnotExist")
Done:
 &nbsp;&nbsp;&nbsp;&nbsp; ' Close all open objects.
 &nbsp;&nbsp;&nbsp;&nbsp; Cn.Close
 &nbsp;&nbsp;&nbsp;&nbsp; ' Destroy anything not destroyed yet.
 &nbsp;&nbsp;&nbsp;&nbsp; Set Cn = Nothing
 &nbsp;&nbsp;&nbsp;&nbsp; ' We're outta here.
 &nbsp;&nbsp;&nbsp;&nbsp; Exit Sub

AdoError:
 &nbsp;&nbsp;&nbsp;&nbsp; Dim errLoop As Error
 &nbsp;&nbsp;&nbsp;&nbsp; Dim strError As String

 &nbsp;&nbsp;&nbsp;&nbsp; ' Enumerate Errors collection and display properties of
 &nbsp;&nbsp;&nbsp;&nbsp; ' each Error object.
 &nbsp;&nbsp;&nbsp;&nbsp; Set Errs1 = Cn.Errors
 &nbsp;&nbsp;&nbsp;&nbsp; For Each errLoop In Errs1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug.Print errLoop.SQLState
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug.Print errLoop.NativeError
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug.Print errLoop.Description
 &nbsp;&nbsp;&nbsp;&nbsp; Next

 &nbsp;&nbsp;&nbsp;&nbsp; GoTo Done
</code></pre>
<p>
A SQL Server connection is established through the pubs data source. The select * from TableDoesnotExist query string is issued with the <b>Execute</b> method of the Connection object. An error occurs as the result of executing the query string because it attempts to select data from a nonexisting table.</p>
<p>
After the error occurs, program execution jumps to AdoError. The Errors collection is retrieved from the Connection object and assigned to the Errs1 Errors collection. The example then loops through the Errs1 Errors collection to retrieve the SQL Server native error, ODBC SQLSTATE mapped by the SQL Server ODBC driver, and the error message.</p>
<h3>The Command Object</h3>
<p>
The Command object allows you to issue commands to the database. These commands can be, but are not limited to query strings, prepare query strings, and associate parameters with query strings. The actual command language and features that are supported are dependent on the underlying provider for the database. The information and examples contained here focus on the Microsoft ODBC Provider that supports a wide variety of relational databases. For more information about OLE DB and OLE DB providers, see the OLE DB area at the Microsoft Universal Data Access Web site (<a href="http://www.microsoft.com/data/">http://www.microsoft.com/data/</a>).</p>
<p>
The Command object can either open a new connection or use an existing connection to perform queries, depending on what is specified in the <b>ActiveConnection</b> property. If the <b>ActiveConnection</b> property is set with a reference to a Connection object, the Command object uses the existing connection from the Connection object. If the <b>ActiveConnection</b> property is specified with a connection string, a new connection is established for the Command object. More than one Command object can use the connection from the same Connection object.</p>
<p>
Executing query strings can generate a record set, multiple record sets, or no record set at all. For example, executing data definition language queries does not generate a record set. Executing a single SELECT statement may generate a record set, and executing a batch of SELECT statements or a stored procedure may generate more than one record set.</p>
<p>
A query string can be specified in the <b>CommandText</b> property. A query string can be a standard SQL data manipulation language, such as SELECT, INSERT, DELETE, or UPDATE, or any data definition language, such as CREATE or DROP. A query string can also be the name of a stored procedure or table. </p>
<p>
The type of a query string can be specified in the <b>CommandType</b> property. There are adCmdText, adCmdTable, adCmdStoreProc, and adCmdUnknown values for the <b>CommandType</b> property. When a query string is a SQL statement, the adCmdText value should be specified for the <b>CommandType</b> property. The adCmdStoreProc or adCmdTable values should be specified if the query string is the name of a stored procedure or table name.</p>
<p>
If the adCmdStoredProc value is specified, the Command object executes the query string with the {call procedure=name} ODBC escape function syntax. If the adCmdTable value is specified, the Command object executes the query string with the <i>select * from tablename</i> syntax. If the adCmdUnknown value is specified, the Command object must perform extra steps to determine the type of query string, thereby degrading performance.</p>
<p>
You can also specify whether or not to prepare query strings with the <b>Prepared</b> property. Setting the <b>Prepared</b> property allows a query plan to be created at the first execution. The query plan is then used for subsequent executions to enhance performance. A query string should be prepared only when executed more than once, because it may take more time to create a query plan than to execute the query string directly. The performance is enhanced only when you execute the query string the second, third, or <i>n</i>th time.</p>
<p>
The <b>Prepared</b> property can also be useful when repeatedly executing a parameterized query string. Different parameter values can be substituted at each execution instead of reconstructing the query string. The Parameter object can be created through the <b>CreateParameter</b> method. For more information, see the "Using Prepared Statements" section later in this paper.</p>
<p>
The example shows executing a SELECT statement that returns a Recordset object:</p>
<pre><code>Dim Cmd As New ADODB.Command
Dim rs As New ADODB.Recordset

' Use a connection string or a Connection object.
Cmd.ActiveConnection = "DSN=pubs;UID=sa"
Cmd.CommandText = "select * from titles"
Cmd.CommandTimeout = 15
Cmd.CommandType = adCmdText

Set rs = Cmd.Execute()
rs.Close
</code></pre>
<p>
The DSN=pubs;UID=sa ODBC connection string is specified in the <b>ActiveConnection</b> property. The select * from titles statement is specified in the <b>CommandText</b> property, and because it is a SQL statement, the <b>CommandType</b> property is set to adCmdText. The <b>CommandTimeout</b> is set to 15 seconds. Executing the select * from titles SQL statement may return a Recordset object, which is assigned to the rs Recordset object.</p>
<p>
The following examples show executing a stored procedure that does not return a Recordset object.</p>
<p>
The stored procedure syntax is:</p>
<pre><code>drop proc myADOProc
go
create proc myADOProc as
create table #tmpADO (id int not NULL, name char(10) NOT NULL)
insert into #tmpADO values(1, 'test')
</code></pre>
<p>
The <b>myADOProc</b> stored procedure creates the tmpADO temporary table and inserts a row into this table. Both the CREATE and INSERT SQL statements do not generate any result sets; therefore, no result sets are returned by executing the <b>myADOProc</b> stored procedure.</p>
<p>
The Visual Basic code is:</p>
<pre><code>Dim Cmd As New ADODB.Command

' Use a connection string or a Connection object.
Cmd.ActiveConnection = "DSN=pubs;UID=sa"
Cmd.CommandText = "myADOProc"
Cmd.CommandTimeout = 15
Cmd.CommandType = adCmdStoredProc

Cmd.Execute
</code></pre>
<p>
The <b>myADOProc</b> stored procedure is specified in the <b>CommandText</b> property. The <b>CommandType</b> property is set to adCmdStoredProc to reflect the type of object executed, and the {call myADOProc} SQL statement is generated as a result. Because there are no result sets generated from executing this stored procedure, no Recordset object is assigned.</p>
<h4>The Parameters collection and the Parameter object</h4>
<p>
The Parameters collection provides parameter information and data for the Command object. The Parameters collection consists of Parameter objects. Both the Parameters collection and Parameter object are needed only when the query string in the Command object requires parameters.</p>
<p>
Individual parameter information (for example, size, data type, direction, and value) can be read or written through each Parameter object. There are four types of parameter directions: input, output, both input and output, and return value. A Parameter object can serve as an input parameter, an output parameter that holds data, or a stored procedure return value. The <b>Refresh</b> method on the Parameters collection can force providers to update parameter information; however, this can be time consuming.</p>
<p>
When dealing with long data types, the <b>AppendChunk</b> method can be use to write data in chunks. For more information, see the "Using Long Data Types" section later in this paper.</p>
<p>
The following examples show creating parameters for a stored procedure.</p>
<p>
The stored procedure syntax is:</p>
<pre><code>drop proc myADOParaProc 
go
create proc myADOParaProc 
@type char(12) 
as 
select * from titles where type = @type
</code></pre>
<p>
The <b>myADOParaProc</b> takes one <i>@type</i> input parameter and returns data that match the specified type. The data type for the <i>@type</i> parameter is <i>character</i>, and the size is 12.</p>
<p>
The Visual Basic code is:</p>
<pre><code>Dim cmd As New ADODB.Command
Dim rs As New ADODB.Recordset
Dim prm As ADODB.Parameter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
' Define a Command object for a stored procedure.
cmd.ActiveConnection = "DSN=pubs;uid=sa"
cmd.CommandText = "myADOParaProc"
cmd.CommandType = adCmdStoredProc
cmd.CommandTimeout = 15
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
' Set up new parameter for the stored procedure.
Set prm = Cmd.CreateParameter("Type", adChar, adParamInput, 12, "Business")
Cmd.Parameters.Append prm

' Create a record set by executing the command.
Set rs = Cmd.Execute
While (Not rs.EOF)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug.Print rs(0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.MoveNext
Wend
</code></pre>
<p>
The <b>ActiveConnection</b>, <b>CommandText</b>, <b>CommandType</b>, and <b>CommandTimeout</b> are specified with the same values as used in the previous example. The <b>myADOParaPro</b> stored procedures expects an input parameter whose data type is <b>character</b> and size is 12. The <b>CreateParameter</b> method is used to create a Parameter object with the corresponding characteristics: The data type is adChar for character, parameter type is <i>adParamInput</i> for input parameter, and data length is 12. This Parameter object is also given the name Type, and because it's an input parameter, the data value Business is specified. </p>
<p>
After a parameter is specified, the <b>Append</b> method is used to append the Parameter object to the Parameters collection. The <b>myADOParaProc</b> stored procedure is executed, and a Recordset object is created.</p>
<h3>The Recordset Object</h3>
<p>
The Recordset object provides methods for manipulating result sets. The Recordset object allows you to add, update, delete, and scroll through records in the record set. Each record can be retrieved and updated using the Fields collection and the Field objects. Updates on the Recordset object can be in an immediate or batch mode. When a Recordset object is created, a cursor is automatically opened.</p>
<p>
The Recordset object allows you to specify the cursor type and cursor location for fetching the result set. With the <b>CursorType</b> property, you can specify whether the cursor is forward-only, static, keyset-driven, or dynamic. The cursor type determines whether a Recordset object can be scrolled forward/backward or updated. The cursor type also affects the visibility of changed records.</p>
<p>
By default, the cursor type is read and forwarded only. If you only need to read the data once in a forward fashion, you do not have to change the default cursor type. Otherwise, you can choose one of the cursors to suit your need.</p>
<p>
You can also specify whether to use the server or client cursor with the <b>CursorLocation</b> property. The cursor location plays a big role in disconnected record sets. For more information, see the "Using Server Cursors" section later in this paper. A Recordset object can be created through the <b>Execute</b> method of the Connection or Command object.</p>
<p>
The example shows using the Recordset object to open a connection and retrieve a result set:</p>
<pre><code>Dim rs As New ADODB.Recordset
rs.Open "select * from titles", "DSN=pubs;UID=sa"
While (Not rs.EOF)
 &nbsp;&nbsp; Debug.Print rs(0)
 &nbsp;&nbsp; rs.MoveNext
Wend
rs.Close
</code></pre>
<p>
The example opens a connection, creates a record set, then loops through the record set to print the data in the first field for each row in this record set.</p>
<h4>The Fields collection and the Field object</h4>
<p>
The Fields collection and Field object allow you to access each data column of the current record. The Fields collection can be accessed through the Recordset object and the Field object can be accessed through the Fields collection using the default indexing method. You can use the Field object to compose a new record or change existing data, and use the <b>AddNew</b>, <b>Update</b>, or <b>UpdateBatch</b> method of the Recordset object to apply the new or changed data. </p>
<p>
Unlike RDO, there is no explicit <b>Edit</b> method that must be specified. Updating on the Field object is as simple as changing the data; no explicit update method is required.</p>
<p>
The example shows using the Field object to retrieve the name, type, and values of each data field of the current record:</p>
<pre><code>Dim rs As New ADODB.Recordset
Dim fld As ADODB.Field

rs.Open "select * from titles", "DSN=pubs;UID=sa"
Set Flds = rs.Fields
Dim TotalCount As Integer
TotalCount = Flds.Count
i = 0
For Each fld In Flds
 &nbsp;&nbsp; Debug.Print fld.Name
 &nbsp;&nbsp; Debug.Print fld.Type
 &nbsp;&nbsp; Debug.Print fld.Value
Next
rs.Close
</code></pre>
<p>
After the Recordset object is created for the select * from titles query string, the Fields collection can be retrieved. The example loops through the Fields collection to retrieve each Field object. The <b>Name</b>, <b>Type</b>, and <b>Value</b> property of each Field object are printed.</p>
<h4>The Properties collection and the Property object</h4>
<p>
The Properties collection and Property object provide information about the characteristics of the Connection, Command, Recordset, and Field object. The Properties collection can be accessed through the Connection, Command, Recordset, and Field object, and the Property object can be accessed through the Properties collection using the default indexing method.</p>
<p>
The Properties collection consists of Property objects. In addition to returning the value and type for a property, the Property object provides attributes of a property. Attributes describe things such as whether or not the specific property of an object is supported, required, or can be read or written. For example, there is <b>ConnectionTimeout</b>, a property that provides information on the number of seconds to wait for establishing connection before returning a time-out error. There is a <b>CommandTimeout</b> property for the Command object, <b>Updatability</b> property for the Recordset and DEFAULTVALUE for the Field object.</p>
<p>
The example shows retrieving <b>ConnectionTimeout</b>, <b>CommandTimeout</b> and <b>Updatability</b> properties:</p>
<pre><code>Dim Cn As New ADODB.Connection
Dim Cmd As New ADODB.Command
Dim rs As New ADODB.Recordset
 &nbsp;&nbsp; 
Cn.Open "pubs", "sa"
' Find out ConnectionTimeout property.
Debug.Print Cn.Properties("Connect Timeout")
 &nbsp;&nbsp; 
Set Cmd.ActiveConnection = Cn
Cmd.CommandText = "titles"
Cmd.CommandType = adCmdTable
Set rs = Cmd.Execute()
 &nbsp;&nbsp; 
' find out CommandTimeout property.
Debug.Print Cmd.Properties("Command Time out")
 &nbsp;&nbsp; 
Debug.Print rs.Properties("Updatability")
</code></pre>
<p>
The Properties collection is retrieved through the Connection, Command, and Recordset objects in this example. The <b>ConnectionTimeout</b> property of the Connection object is printed. The same steps are performed for the Command and Recordset objects.</p>
</BODY>
</HTML>
