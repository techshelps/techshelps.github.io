<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating a Windows 95 Explorer-like Application</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_chicoapp"></a>Creating a Windows 95 Explorer-like Application</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
July 1994</p>
<p>
Revised: June 1995 (removed "Fun with Rectangles" section because functionality no longer exists)</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="2911">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the CHICOAPP sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
If you have been reading the trade magazines lately, you undoubtedly know that the next version of the Microsoft® Windows® operating system (called Windows 95) sports a new shell. The new shell looks quite a bit different from the current shell used by Windows version 3.1 and Windows NT™. This new shell includes the Explorer, which integrates the functionality of the Windows 3.1 File Manager and Program Manager. The Explorer uses many of the new Windows 95 common controls and follows the guidelines specified in the <i>User Interface Design Guide</i> for Windows 95. (For a preliminary version of this guide, see Product Documentation, SDKs, in the MSDN Library.)</p>
<p>
Because the Explorer follows the <i>User Interface Design Guide</i> so closely and uses many of the new Windows 95 controls, many developers will want to use it as a model for their new Windows 95–based applications. This article explains how a developer can create an Explorer-like application that displays real-estate listings for houses, as demonstrated by the CHICOAPP sample application that accompanies this article.</p>
<p>
This article is based on preliminary information that is subject to change before the final version of Windows 95.</p>
<h2>What Does the Explorer Look Like?</h2>
<p>
The Explorer includes some cool new interface objects, such as a toolbar, a status bar, a tree view control, and a list view control. These controls work together to provide a usable and intuitive interface to the objects contained in the system. For more information on these new controls, see my six-part series of articles titled "Win32 Common Controls" in the Microsoft® Development Network (MSDN) Library (under Technical Articles). These controls are provided in a new dynamic-link library (DLL) called COMCTL32.DLL. COMCTL32.DLL is included with Windows® 95 and will also be supported in Win32s® (running on Windows version 3.1) and in Windows NT™. Note that these controls are 32-bit only—they will not be supported in 16-bit Windows environments.</p>
<p>
The figure below shows the new Explorer. It will give you an idea of how our Windows 95–based application will look when we finish it.</p>
<p>
<img src="chicoapp_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The Windows 95 Explorer</b></p>
<h2>Designing CHICOAPP</h2>
<p>
I began my work by using the samples that I had written for my Win32® common controls series, which demonstrate the toolbar, status bar, tree view, and list view common controls. I decided that the toolbar would be at the top of the screen and that the status bar would be at the bottom of the screen (how creative!). I did not know how much time it would take to simply integrate my samples, so I thought I would get a head start. Having no real life to speak of, I brought my Windows 95 machine home on the weekend and started working on my Windows 95–based application in earnest. I was amazed at the amount of work I was able to accomplish in two days. Over the weekend, I was able to get the major user interface components displaying, working, and sizing in an orderly fashion. It did, however, take me more time to add all the features you see in the final version of CHICOAPP.</p>
<p>
I decided to create an application that would display a real-estate listing with the following functionality:
<ul type=disc>
<li>
A toolbar with ToolTips for easy access to commands.<br><br></li>
<li>
A status bar displaying the currently selected city and the number of houses listed for that city.<br><br></li>
<li>
A tree view control displaying the cities that have houses for sale.<br><br></li>
<li>
A list view control displaying the houses for sale.<br><br></li>
<li>
Pop-up context menus displayed with right mouse clicks.<br><br></li>
<li>
Property sheets for viewing and changing house properties.<br><br></li>
<li>
Long filename support for saving and opening house listing files.</li>
</ul>
<p>
Figure 2 gives you a sneak peek at the finished application. It displays the main screen with an open listing for the city of Seattle. Let me point out that the listings you see in my application's text files and screen shots are purely fictitious—if you are shopping for a house, don't rely on this information.</p>
<p>
<img src="chicoapp_2.gif" border=0></p>
<p class=label>
<b>Figure 2. CHICOAPP main screen</b></p>
<h2>Creating the Windows</h2>
<p>
To create the basic windows I needed for my application, I wrote a function that would call worker functions that actually created the windows. Because these windows are part of the new Windows 95 common-control library, I had to call <b>InitCommonControls</b> to ensure that COMCTL32.DLL was loaded before I called any functions that used the new common controls.</p>
<p>
The status bar has two parts: The left part displays the currently selected city, and the right part displays the number of houses listed for that city. The code below demonstrates how the status bar was implemented:</p>
<pre><code>g_Listing.hWndStatus = CreateStatusWindow( 
 &nbsp;&nbsp;&nbsp;&nbsp; WS_CHILD | WS_BORDER | WS_VISIBLE,&nbsp; // window styles
 &nbsp;&nbsp;&nbsp;&nbsp; "",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // default window text
 &nbsp;&nbsp;&nbsp;&nbsp; hwndParent,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parent window
 &nbsp;&nbsp;&nbsp;&nbsp; ID_STATUS);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ID

// Make the status bar multiple parts.
lpSBParts[0] = (rcl.right - rcl.left) / 2;
lpSBParts[1] = -1;
SendMessage( g_Listing.hWndStatus, SB_SETPARTS, (WPARAM)2, 
 &nbsp;&nbsp;&nbsp;&nbsp; (LPARAM)(LPINT)&amp;lpSBParts);
</code></pre>
<p>
Next, I created the toolbar by calling the <b>CreateToolbarEx</b> function. Simple enough. The third step was to create the list view and tree view windows. I used helper functions to create these. I made the tree view control one-fourth the width of the window's client area and accounted vertically for the toolbar and status bar. The code below demonstrates how I created the tree view window. Note that for this sample, I hard-coded the values that determined the size of the controls. If I were writing an application for general consumption, I would obtain these values by calling <b>GetSystemMetrics</b> instead.</p>
<pre><code>HWND TV_CreateTreeView (HWND hWndParent, HINSTANCE hInst, int NumCities, 
 &nbsp;&nbsp; CITYINFO *pCity)
{
 HWND hwndTree;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The handle to the tree view window.
 RECT rcl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A rectangle for setting the size of the window.
 HBITMAP hBmp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A handle to a bitmap.
 HIMAGELIST hIml;&nbsp;&nbsp;&nbsp; // A handle to the image list.

 // Get the size and position of the parent window.
 GetClientRect(hWndParent, &amp;rcl);

 // Create the tree view window, make it 1/4 the width of the parent
 // window, and take the status bar and toolbar into account.
 hwndTree = CreateWindow (
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WC_TREEVIEW,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // window class
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no default text
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_VISIBLE | WS_CHILD | WS_BORDER | TVS_HASLINES | 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TVS_HASBUTTONS | TVS_LINESATROOT,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 27,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // x,y
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (rcl.right - rcl.left)/4,&nbsp;&nbsp; // cx
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcl.bottom - rcl.top - 45,&nbsp; // cy 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hWndParent,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parent
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (HMENU) ID_TREEVIEW,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // identifier
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInst,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // instance
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL );
if (hWndTree == NULL)
  return NULL;
// First, create the image list we will need.
hIml = ImageList_Create( BITMAP_WIDTH, BITMAP_HEIGHT,FALSE, 2, 10 );

// Load the bitmaps and add them to the image lists.
hBmp = LoadBitmap(hInst, MAKEINTRESOURCE(FORSALE_BMP));
idxForSale = ImageList_Add(hIml, hBmp, NULL);
hBmp = LoadBitmap(hInst, MAKEINTRESOURCE(CITY_BMP));
idxCity = ImageList_Add(hIml, hBmp, NULL);
hBmp = LoadBitmap(hInst, MAKEINTRESOURCE(SELCITY_BMP));
idxSelect = ImageList_Add(hIml, hBmp, NULL);

// Make sure that all of the bitmaps were added.
if (ImageList_GetImageCount(hIml) != 3)
  return FALSE;
 
// Associate the image list with the tree.
TreeView_SetImageList(hwndTree, hIml, idxForSale);

// Initialize the tree view by adding "Houses For Sale".
TV_InitTreeView(hInst, hwndTree);

return (hwndTree);
}
</code></pre>
<p>
I created the list view window, made it three-fourths the width of the parent window's client area, placed it on the right side, and accounted vertically for the toolbar and status bar, using the code below:</p>
<pre><code>HWND LV_CreateListView (HWND hWndParent, HINSTANCE hInst, int NumHouses,
 &nbsp;&nbsp; HOUSEINFO *pHouse)
{
 HWND hWndList;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle to the list view window
 RECT rcl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // rectangle for setting the size of the window
 HICON hIcon;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle to an icon
 int index;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // index used in FOR loops
 HIMAGELIST hSmall, hLarge; // handles to image lists
 LV_COLUMN lvC;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // list view column structure
 char szText[64];&nbsp;&nbsp;&nbsp; // place to store some text
 int iWidth;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // column width

 // Get the size and position of the parent window.
 GetClientRect(hWndParent, &amp;rcl);

 // Create the list view window, make it 3/4 the size of the
 // parent window, and take the status bar and toolbar into account.
 iWidth = (rcl.right - rcl.left) - ((rcl.right - rcl.left)/4);
 hWndList = CreateWindowEx( 0L,
 &nbsp;&nbsp;&nbsp; WC_LISTVIEW,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // list view class
 &nbsp;&nbsp;&nbsp; "",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no default text
 &nbsp;&nbsp;&nbsp; WS_VISIBLE | WS_CHILD | WS_BORDER | LVS_REPORT,&nbsp; // styles
 &nbsp;&nbsp;&nbsp; (rcl.right - rcl.left)/4, 27,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // x, y
 &nbsp;&nbsp;&nbsp; iWidth, rcl.bottom - rcl.top - 42,&nbsp; // cx, cy
 &nbsp;&nbsp;&nbsp; hWndParent,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parent
 &nbsp;&nbsp;&nbsp; (HMENU) ID_LISTVIEW,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // identifier
 &nbsp;&nbsp;&nbsp; hInst,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // instance
 &nbsp;&nbsp;&nbsp; NULL );

 if (hWndList == NULL )
  return NULL;

 // First, initialize the image lists we will need.
 // Create an image list for the small and large icons.
 // FALSE specifies large icons--TRUE specifies small icons.
 hSmall = ImageList_Create( 16, 16, TRUE, 1, 0 );
 hLarge = ImageList_Create( 32, 32, FALSE, 1, 0 );

 // Load the icons and add them to the image lists.
 hIcon = LoadIcon ( hInst, MAKEINTRESOURCE(HOUSE_ICON));
 if ((ImageList_AddIcon(hSmall, hIcon) == -1) ||
 &nbsp;&nbsp;&nbsp; (ImageList_AddIcon(hLarge, hIcon) == -1))
 &nbsp;&nbsp;&nbsp; return NULL;

 // Associate the image list with the list view.
 ListView_SetImageList(hWndList, hSmall, LVSIL_SMALL);
 ListView_SetImageList(hWndList, hLarge, LVSIL_NORMAL);

 // Initialize the LV_COLUMN structure.
 // The mask specifies that the .fmt, .ex, width, and .subitem members 
 // of the structure are valid.
 lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
 lvC.fmt = LVCFMT_LEFT;&nbsp; // left-align the column
 lvC.cx = iWidth / NUM_COLUMNS + 1; // width of the column, in pixels
 lvC.pszText = szText;

 // Add the columns.
 for (index = 0; index &lt; NUM_COLUMNS; index++)
 {
  lvC.iSubItem = index;
  LoadString( hInst, 
 &nbsp;&nbsp;&nbsp; IDS_ADDRESS + index,
 &nbsp;&nbsp;&nbsp; szText,
 &nbsp;&nbsp;&nbsp; sizeof(szText));
  if (ListView_InsertColumn(hWndList, index, &amp;lvC) == -1)
 &nbsp;&nbsp;&nbsp; return NULL;
 }
return (hWndList);
}
</code></pre>
<h2>Sizing Issues</h2>
<p>
When I finished creating my windows, I had to find an easy way to resize my application's main window. I used the handy <b>DeferWindowPos</b> function to resize all of the windows at the same time. For those of you who are new to Win32, <b>DeferWindowPos</b> updates a structure that contains multiple window positions. You use this function as you would use the window enumeration functions—that is, you begin, defer, and end. The following code illustrates how I resized all of my windows:</p>
<pre><code>BOOL ResizeWindows(HWND hwnd)
{
 &nbsp;&nbsp; RECT rcl;
 &nbsp;&nbsp; HDWP hdwp;

 &nbsp;&nbsp; // Get the client area of the parent window.
 &nbsp;&nbsp; GetClientRect(hwnd, &amp;rcl);

 &nbsp;&nbsp; // We will be deferring four windows.
 &nbsp;&nbsp; hdwp = BeginDeferWindowPos(4);

 &nbsp;&nbsp; // First, reset the status bar size.
 &nbsp;&nbsp; DeferWindowPos(hdwp, g_Listing.hWndStatus, NULL, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcl.right - rcl.left, 20, SWP_NOZORDER | SWP_NOMOVE);

 &nbsp;&nbsp; // Next, reset the toolbar size.
 &nbsp;&nbsp; DeferWindowPos(hdwp, g_Listing.hWndToolBar, NULL, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcl.right - rcl.left, 20, SWP_NOZORDER | SWP_NOMOVE);

 &nbsp;&nbsp; // Next, reset the tree view size.
 &nbsp;&nbsp; DeferWindowPos(hdwp, g_Listing.hWndTreeView, NULL, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (rcl.right - rcl.left ) / 4, rcl.bottom - rcl.top - 45,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SWP_NOZORDER | SWP_NOMOVE);

 &nbsp;&nbsp; // Last, reset the list view size.
 &nbsp;&nbsp; DeferWindowPos(hdwp, g_Listing.hWndListView, NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (rcl.right - rcl.left ) / 4, 25,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (rcl.right - rcl.left) - ((rcl.right - rcl.left)/4),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcl.bottom - rcl.top - 42,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SWP_NOZORDER );

 &nbsp;&nbsp; return (EndDeferWindowPos(hdwp));
}
</code></pre>
<h2>Parsing and Storing the Data</h2>
<p>
Now that my windows are created and resized, I had to come up with a method for reading in, and storing, the house-listing data. In my original samples, I used static arrays that were filled with dummy information. This technique is great if you plan to never change the information you are displaying, but if you want to show a reasonable facsimile of an application, it makes sense to provide for dynamic data changes.</p>
<p>
The easiest way to store the house-listing data was to save it out to a file. I decided to use an ASCII file because it was easy to test and easy to alter. The file contained the following information:
<ul type=disc>
<li>
Number of cities<br><br></li>
<li>
City name (one name per line)<br><br></li>
<li>
Number of houses<br><br></li>
<li>
Information on each house (one house per line, with each item of information separated by commas)</li>
</ul>
<p>
Here's what the ASCII file looked like:</p>
<pre><code>3
Bellevue
Redmond
Seattle
9
 100 Main Street,Redmond,175000,3,2,Joan Smith,555-1212
 523 Pine Lake Road,Redmond,125000,4,2,Ed Jones,555-1111
 1212 112th Place SE,Redmond,200000,4,3,Mary Wilson,555-2222
 22 Lake Washington Blvd,Bellevue,2500000,4,4,Joan Smith,555-1212
 33542 116th Ave. NE,Bellevue,180000,3,2,Ed Jones,555-1111
 64134 Nicholas Lane,Bellevue,250000,4,3,Mary Wilson,555-2222
 33 Queen Anne Hill,Seattle,350000,3,2,Joan Smith,555-1212
 555 SE Fifth St,Seattle,140000,3,2,Ed Jones,555-1111
 446 Mariners Way,Seattle,225000,4,3,Mary Wilson,555-2222
</code></pre>
<p>
Parsing the file was simply a matter of using <b>sscanf</b>, converting some of the strings to integers, copying the data to my data structure, and updating my file pointer. The data structures I used contained information about the houses, the cities, and the current state of the application. I filled out a <b>CITYINFO</b> structure for each city listed, and a <b>HOUSEINFO</b> structure for each house listed. When saving the information out to a file, I reversed the procedure. The structures are listed below.</p>
<pre><code>typedef struct tagCITYINFO
{
 &nbsp;&nbsp; char szCity[MAX_CITY];&nbsp; // city name
 &nbsp;&nbsp; int NumHouses;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number of houses listed in this city
 &nbsp;&nbsp; HTREEITEM hItem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle to tree view item
} CITYINFO;

typedef struct tagHOUSEINFO
{
 &nbsp;&nbsp; char szAddress[MAX_ADDRESS];&nbsp; // address
 &nbsp;&nbsp; char szCity[MAX_CITY];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // city
 &nbsp;&nbsp; int iPrice;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // price
 &nbsp;&nbsp; int iBeds;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number of bedrooms
 &nbsp;&nbsp; int iBaths;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number of bathrooms
 &nbsp;&nbsp; int iImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bitmap index for this house
 &nbsp;&nbsp; char szAgent[MAX_CITY];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // listing agent
 &nbsp;&nbsp; char szNumber[MAX_CITY];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // listing agent's phone number

} HOUSEINFO;
</code></pre>
<h2>Using the Common Dialogs</h2>
<p>
To support long filenames (and to save myself some time), I used the new common dialogs to open and save the house-listing information. I was actually able to use some of the code I had written for the Windows 3.1 common dialogs. When I recompiled, the application displayed the new dialog boxes. I had to strip off the file extension (.TXT, in this case) before I set the caption text for the main window. As you can see in the figure below, the new File Open common dialog box has no problem with long filenames such as "Listing for the Puget Sound" or "Another saved listing".</p>
<p>
<img src="chicoapp_3.gif" border=0></p>
<p class=label>
<b>Figure 3. The File Open common dialog box</b></p>
<h2>Handling Notifications</h2>
<p>
As I mentioned in my articles on the Win32 common controls, notifications are used extensively to manipulate the behavior and appearance of the controls. Because status bars, toolbars, list views, and tree views all expect notifications, I had to ensure that each control was getting the notifications it needed. In the main window procedure for my application, I simply trapped the WM_NOTIFY message and either handled the toolbar notifications directly, or passed the notifications to the handlers I wrote. (If you are writing a Microsoft Foundation Class Library [MFC] application, you would use an <b>OnNotify</b> function instead.)</p>
<p>
For the toolbar, I was interested only in the TTN_NEEDTEXT notification, which is sent whenever the system needs to display a ToolTip associated with a toolbar button. In response to this notification, the application must load the appropriate text string into the <b>lpszText</b> member of the <b>LPTOOLTIPTEXT</b> structure.</p>
<p>
My tree view window had a very simple notification handler (see the "Fun with Rectangles" section later in this article) that only handled the TVN_SELCHANGED notification. This notification is sent to the tree view window whenever the selection changes. In response, I needed to update the list view and status bar to reflect the house listings for the newly selected city. I used the following code to update the list view:</p>
<pre><code>VOID UpdateListView( HWND hwndLV, int iSelected )
{
  int count, index;
  
  // Remove the previous items.
  LV_RemoveAllItems(hwndLV);

  // Loop through the house listings.
  for (index = 0, count = 0; count &lt; g_Listing.NumHouses; count++)
  {
 &nbsp; // If the house is listed for the new city, then...
 &nbsp; if (strcmp(rgHouses[count].szCity, rgCities[iSelected].szCity) == 0)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add the house to the list view.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!LV_AddItem(hwndLV, index, &amp;rgHouses[count]))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(NULL, "LV_AddItem failed!", NULL, MB_OK);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index++;
 &nbsp; }
  }
}
</code></pre>
<p>
Handling notifications for the list view window was a bit more complicated. I implemented my list view using a callback that received the text for each item, so the notification handler needed to trap the LVN_GETDISPINFO notification and fill in the <b>pszText</b> member of the <b>LV_ITEM</b> structure with the appropriate text, depending on the column. I also had to process the LVN_COLUMNCLICK notification in my list view notification handler. This notification is sent whenever the user clicks a column heading in the list view. In response, the application must sort the items in the list view based on the criteria presented in the selected column. For example, if the user clicks the Bedrooms column, my application sorts the list in ascending order by the number of bedrooms for the item (the house). I provided a simple callback procedure that is called through the <b>ListView_SortItems</b> function. My callback procedure then sorted the data using simple math (returning the greater of two values) for the columns that had integer sort criteria, and using the <b>strcmp</b> function for the columns that had string sort criteria.</p>
<h2>Adding Right-Click Pop-Up Context Menus</h2>
<p>
At this point, my application was functional, but I still needed to add the pop-up menu that is displayed when the user clicks the right mouse button. This required handling one more notification, NM_RCLICK, in my list view window. NM_RCLICK is sent whenever the user clicks the right mouse button in the list view window. The notification handler uses the <b>ListView_HitTest</b> function as shown below to determine which item (if any) the user has clicked:</p>
<pre><code>LV_HITTESTINFO lvH;
NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;

case NM_RCLICK:
 &nbsp; lvH.pt.x = pNm-&gt;ptAction.x;
 &nbsp; lvH.pt.y = pNm-&gt;ptAction.y;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; idx = ListView_HitTest(hWnd, &amp;lvH);
 &nbsp; if ( idx != -1)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; GetCursorPos(&amp;pt);
 &nbsp;&nbsp;&nbsp;&nbsp; ListViewPopUpMenu(hWnd, pt, hInst);
 &nbsp;&nbsp;&nbsp;&nbsp; return idx;
 &nbsp; }
 &nbsp; break;
</code></pre>
<p>
Once I knew that the cursor was on a list view item, I needed to display a context menu for that item. This is straightforward: Basically, you load the menu and call <b>TrackPopupMenu</b>, as you would in a 16-bit Windows-based application. When the user chooses an item from the menu, the appropriate command is generated and sent to the window procedure in the form of a WM_COMMAND message.</p>
<h2>Incorporating Property Sheets</h2>
<p>
One of the design goals for my Windows 95–based application was to add at least one property sheet to the application. Property sheets (also known as tabbed dialogs) allow users to view and change the properties of an item. In this case, the item is a house listing. Each property sheet contains one or more overlapping windows (called <i>pages</i>) that contain a logical grouping of properties. The user switches between pages by clicking tabs that label each property page. I implemented two property sheet pages: One allows the user to view and change the properties for a particular house listing (for example, address and city), and the other displays information about the listing agent (for example, name and phone number). The figure below shows the House Listing property sheet page. (See Figure 5 for a screen illustration of the Listing Agent page.)</p>
<p>
<img src="chicoapp_4.gif" border=0></p>
<p class=label>
<b>Figure 4. The House Listing property sheet page</b></p>
<p>
Processing a property sheet page is similar to processing a dialog box, with one major difference: When you process a property sheet page, you handle notifications instead of the commands generated for the OK and Cancel buttons. I processed my property sheet pages as follows:
<ul type=disc>
<li>
Save the original values for the item in response to the WM_INITDIALOG message.<br><br></li>
<li>
Reset the values of the item in response to the PSN_APPLY and PSN_KILLACTIVE notifications.<br><br></li>
<li>
Reset the values of the item in response to a PSN_RESET notification.<br><br></li>
<li>
Set the edit fields in the page for the item in response to the PSN_SETACTIVE notification.<br><br></li>
<li>
Respond negatively to the PSN_HASHELP notification by calling <b>SetWindowLong(hDlg, DWL_MSGRESULT, FALSE)</b>.</li>
</ul>
<p>
To initialize my property sheet pages, I had to determine which house was currently selected and save that information for future reference. The first property sheet page displayed is the House Listing page. Responding to the WM_INITDIALOG message gave me the first chance to determine the currently selected house. I used the following code to determine the index of the selected house within my global array of houses:</p>
<pre><code>char szTemp[MAX_ADDRESS];
static char szAddSave[MAX_ADDRESS];
static char szCitySave[MAX_CITY];
static int iPrice, iBeds, iBaths;
BOOL bErr;
int index, count;
LV_ITEM lvItem;
.
.
.
  case WM_INITDIALOG:&nbsp; 
 &nbsp;&nbsp; // Fill in the list box with the cities. 
 &nbsp;&nbsp; for (index = 0; index &lt; g_Listing.NumCities; index++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendDlgItemMessage( hDlg, IDE_CITY, CB_INSERTSTRING, (WPARAM)(-1),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPARAM)(rgCities[index].szCity));

 &nbsp;&nbsp; // Get the index to the selected list view item.
 &nbsp;&nbsp; index = ListView_GetNextItem(g_Listing.hWndListView,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1, MAKELPARAM(LVNI_SELECTED, 0));

 &nbsp;&nbsp; // Get the house address.
 &nbsp;&nbsp; lvItem.iItem = index;
 &nbsp;&nbsp; lvItem.iSubItem = 0;
 &nbsp;&nbsp; lvItem.mask = LVIF_TEXT;
 &nbsp;&nbsp; lvItem.cchTextMax = sizeof(szAddSave);
 &nbsp;&nbsp; lvItem.pszText = szAddSave;
 &nbsp;&nbsp; ListView_GetItem(g_Listing.hWndListView,&amp;lvItem);

 &nbsp;&nbsp; // Find the house in the list.
 &nbsp;&nbsp; for (count=0; count &lt; g_Listing.NumHouses; count++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (strcmp(lvItem.pszText, rgHouses[count].szAddress) == 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; g_Listing.iSelHouse = count;
.
.
.
</code></pre>
<p>
My other property sheet page, Listing Agent, allows the user to view and change the name and phone number of the listing agent associated with the selected house. The code that I used to handle this page was quite similar to the code I used for the House Listing page, except that I modified the <b>szAgent</b> and <b>szNumber</b> members of my array of <b>HOUSEINFO</b> structures instead of altering the other house-specific fields. Figure 5 shows the Listing Agent property sheet page.</p>
<p>
<img src="chicoapp_5.gif" border=0></p>
<p class=label>
<b>Figure 5. The Listing Agent property sheet page</b></p>
<h2>Summary</h2>
<p>
The CHICOAPP sample described in this article demonstrates some of the things that a developer must do to create an Explorer-like application. When you build and run CHICOAPP, you will notice that it is a fairly minimal application, although it does more than most sample applications. For example, although this application demonstrates many new Windows 95 components and follows the requirements of the new style guide, it does not qualify for the new Windows logo detailed in Tammy Steele's article, "How to Adapt an App for Chicago," in the July 1994 issue of the <i>Microsoft Developer Network News</i> (in the MSDN Library Archive CD, see Books and Periodicals, Microsoft Developer Network News, July 1994 Number 4, July Features).</p>
<p>
To make CHICOAPP qualify for the new Microsoft Windows logo, I need to make a few changes and add some features to the application. The most noteworthy feature to add is OLE container and/or object support and OLE Drag and Drop support. The best way to add OLE support is to rewrite CHICOAPP using C++ and MFC, because OLE development is much easier in these two development environments. Of course, rewriting an application (even a simple one) is a lot of work. MFC does not currently support the new Windows 95 common controls, although a future version of MFC (after the final release of Windows 95) will provide this support.</p>
<p>
Qualifying for the new Windows logo also requires support for the common messaging call (CMC) API, so I need to add minimal support for the Send or Send Mail command from CHICOAPP's File menu. Making this change would allow the user to mail a house listing to another person or listing agent.</p>
<p>
Even without these changes, CHICOAPP is a good head start if you want to create an Explorer-like application. At the very least, you now know how to integrate the new Windows 95 controls into one application. If you have read this article and are wondering about support in MFC and Visual C++ for the new controls, let me assure you that the work is under way, but you will have to wait for it. If you want to be on the cutting edge now, you will need to do the extra work that I have demonstrated in this article.</p>
</BODY>
</HTML>
