<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Vision Builder to Build Components Declaratively</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Using Vision Builder to Build Components Declaratively</h1>
<p>
<img src="sql_mts_18.gif" border=0></p>
<p>
Application components for application logic (presentation, business, and data logic) can be built and maintained by specifying declarative rules and using application flow diagrams. Changing business and application rules results in new and/or modified source code. One product that can build such applications is Vision Builder from Vision Software. A complimentary tool for Visual&nbsp;Studio 97, Vision Builder enables declarative construction and maintenance of Visual&nbsp;Basic and Java components. Also, Vision Software has optimized their tools for Microsoft Transaction Server and SQL&nbsp;Server. The Vision Software Web site is at http://www.vision-soft.com.</p>
<h3>Designing a Data Model</h3>
<p>
Before creating Microsoft Transaction Server components with Vision Builder, it is first helpful to see how to build business rules. The first stage of building an application with Vision Builder is to create a data model or work from an object model. There are two ways to build this model:
<ul type=disc>
<li>
Use the Visual&nbsp;Studio Visual Modeler, Microsoft&nbsp;Access, or a modeling tool from a vendor, such as LogicWorks, Platinum technology, Rational Software, or Texas Instruments. <br><br></li>
<li>
Initialize a Vision Builder repository by reverse engineering an existing database by using the Vision Builder Reengineering manager. The Reengineering Manager is part of the Vision Builder design environment and provides an interface for importing existing databases; this aids in creation of Microsoft Transaction Server components.</li>
</ul>
<p>
<img src="sql_mts_19.gif" border=0></p>
<h3>Capturing Business Rules</h3>
<p>
The next stage of building Microsoft Transaction Server components is to capture the business rules of the application. Business rules automate complex multitable transactions. Business rules can range from simple (constraints on object values and referential integrity), to complex (multitable rules involving external objects, such as mail and workflow servers). Business rules are closely aligned with business policies and practices and are captured graphically using Business Rules Designer. Business rules allow full automation of business logic into Microsoft Transaction Server components. An example of a business rule is: The aggregate of an order is all Order Line Item amounts combined with their freight, taxation and handling charges.</p>
<p>
This business-logic automation uses a process called <i>application targeting</i> that produces optimized components for Microsoft Transaction Server and SQL&nbsp;Server. Business rules can also be converted into objects, such as SQL&nbsp;Server stored procedures. With application targeting, developers can choose and implement the ideal deployment architecture for each application without having to rewrite the entire application. </p>
<p>
To begin setting rules, the user only needs to specify a name, the deviation, and how to validate the deviation. A derivation rule can aggregate values spanning multiple objects. When you instantiate this rule in relevant Microsoft Transaction Server packages, it is automatically reused across all relevant transactions and processes. The deviation can be anything, even an external OLE object to perform a previously defined computation.</p>
<p>
Vision Builder can also capture business rules. It can automatically manage the dependencies between the objects and rules. </p>
<p>
<img src="sql_mts_20.gif" border=0></p>
<p>
While setting the rules, the developer can embed workflow rules. This can be very simple, such as sending an e-mail message to a specific manager based on a transaction, or more complex, such as a multitable constraint that restricts the number of transactions allowed in the system. The rules can also involve calling external COM/DCOM objects, which allows integration of other sources of data and reuse of existing objects by an organization. To change your application at any time, you only have to change these business rules. </p>
<p>
<img src="sql_mts_21.gif" border=0></p>
<h3>Beyond Declarative Business Rules </h3>
<p>
The third stage is to handle special cases. There are cases when declarative business rules may not be sufficient to capture all the business logic of the application. As a result, Vision Builder's declarative applications are designed to be extensible and customizable. This means you can extend any of the rules in the objects by including custom procedural or object code. This code can be written in any language and encapsulated as ActiveX objects, which are then invoked from Business Rules Designer. Alternatively, you can capture custom code in Business Rules Designer that can be written in Visual&nbsp;Basic.</p>
<h3>Constructing MTS Components</h3>
<p>
An advantage of the declarative approach to development is that you don't have to wait until the end to see how your system behaves. Vision Builder includes a Server Manager Wizard for constructing Microsoft Transaction Server components with correct interfaces and partitioned business logic. The actual network and data I/O is more easily optimized by the system because it has a comprehensive view of the entire business logic and can do global optimization. </p>
<p>
Server Manager detects any objects that have changed since the last deployment and only rebuilds those objects. This removes the overhead of rebuilding all components at each deployment. In addition to creating server-side components, you can use Vision Builder Application Designer to create client-side application components that can be used to test and debug the Microsoft Transaction Server components. Rule-tracing code is also embedded in the components for easy debugging of the business logic at a business-rules level.
<ul type=disc>
<li>
Start by opening the Server Manager Wizard and choosing the option of creating components for Microsoft SQL&nbsp;Server. Click <b>MS SQL&nbsp;Server</b> for the DBMS type.<p>
<img src="sql_mts_22.gif" border=0></P></li>
<li>
Next, click the option to let Server Manager automatically select the objects that have changed since the last deployment.<p>
<img src="sql_mts_23.gif" border=0></P></li>
<li>
Examine the set of selected objects and alter the selection to regenerate objects other than those automatically selected. Only those data objects relevant to the component you are building should be selected.<p>
<img src="sql_mts_24.gif" border=0></P></li>
<li>
To generate the scripts, you can deploy directly to the server or build SQL scripts that can be executed manually, later, to the servers.<p>
<img src="sql_mts_25.gif" border=0></P></li>
<li>
Choose to deploy the business rules, the data model, or both. For a new component or model, it is a good idea to generate both. Vision Builder will maintain the data model with the rules automatically.<p>
<img src="sql_mts_26.gif" border=0></P></li>
<li>
Select to deploy rules as Transaction Server components or as triggers and stored procedures.<p>
<img src="sql_mts_27.gif" border=0></P></li>
<li>
Specify how the components are packaged and how they interact with SQL&nbsp;Server. You can choose to generate components into multiple packages by altering the property on this screen. You can also set security component by component or generally. You will still need to use Microsoft Transaction Server Explorer to register the components. <p>
<img src="sql_mts_28.gif" border=0></P></li>
<li>
Click <b>Finish</b> to execute the parameters specified. <p class=tl>
Vision Builder displays a message telling you if the process was successful or if not, what you need to change to correct the problem. During deployment, Microsoft Transaction Server components are generated as Visual&nbsp;Basic .vbp, .bas, and .cls files in a folder called <i>repository_name</i>_SQLSERVER_SCRIPTS (where the .mdb file is located).</P><p>
<img src="sql_mts_29.gif" border=0></P><p class=tl>
At this point, the necessary files exist for Visual&nbsp;Basic 5.0 to compile these components into ActiveX objects that can then be registered with Microsoft Transaction Server. These components are optimized for Microsoft SQL&nbsp;Server and RDO version 2.0. Before you can use them, use Explorer to register the components with Microsoft Transaction Server.</P></li>
</ul>
<h3>Microsoft Transaction Server Explorer</h3>
<p>
A Microsoft Transaction Server component&nbsp;is a reusable piece of code and data in binary form that is built following the rules defined in the Component Object Model. Components provide specific functions within a business process. For example, a Sales package&nbsp;might include a component that determines if customers are within their credit limit. Explorer assembles components into packages and registers them with the Microsoft Transaction Server run-time environment. Developers use Explorer to: 
<ul type=disc>
<li>
Test components in the Transaction Server environment.<br><br></li>
<li>
Assemble components into prebuilt packages. <br><br></li>
<li>
Deploy components and packages to meet specific business objectives. </li>
</ul>
<p>
<img src="sql_mts_30.gif" border=0></p>
<p>
The Explorer interface depicts how the items in the run-time environment are organized. Packages are installed on computers, contain components, and define roles. Components define interfaces&nbsp;and methods. Folders contain items that have been added to the run-time environment. You can use special purpose windows to view transaction and trace message&nbsp;information.</p>
<p>
To navigate the hierarchy, double-click an item in the right pane to expose its contents. You can also expand an item in the left pane to display the contents in the right pane. </p>
<p>
A <i>package</i> is a set of components that perform related application functions. All components in a package run in the same MTS server process. A package is a trust boundary that defines when security credentials are verified. It's also a deployment unit for a set of components. You create packages with Transaction Server Explorer. </p>
<p>
A <i>component</i><b> </b>is a discrete unit of code built on ActiveX technologies that delivers a well-specified set of services through well-specified interfaces. Components provide the objects that clients request at run time.</p>
<p>
An <i>interface</i> is a group of logically related operations or methods that provides access to a component object.</p>
<p>
A <i>role</i> is a symbolic name that defines a class of users for a set of components. Each role defines which users are allowed to invoke interfaces on a component.</p>
<p>
A <i>user</i> is a Windows&nbsp;NT domain account. It can be a domain user or group. Each user has a unique security identifier (SID) that identifies the user and can be used for security purposes.</p>
<h3>Creating a Package</h3>
<ol>
<li>
On the <b>Start</b>&nbsp;menu, point to <b>Programs</b>, point to <b>Microsoft Transaction&nbsp;Server</b>, and then click <b>Transaction&nbsp;Server Explorer</b>. In the left pane, the main level contains servers and workstations. If your workstation is running Windows&nbsp;NT, it is automatically added under Computers. <br><br></li>
<li>
To add computers, click <b>Computers</b>, and then on the <b>File</b> menu, click <b>New</b>.<p>
<img src="sql_mts_31.gif" border=0></P><p class=tl>
Select the computer (server or Windows&nbsp;NT workstation), where you want to deploy the component; it will be part of a package. By grouping components into packages, you define the boundaries for a server process&nbsp;running on a server computer. For example, if you have two components, one for purchasing and one for sales, you can separate these functions by installing these components into separate packages. </P><p class=tl>
You create packages by adding them to the Packages Installed folder of a computer in the Explorer hierarchy. You can build an empty package and then add components, or you can install a prebuilt package. A prebuilt package consists of a package file&nbsp;and the component files (.dll&nbsp;and .tlb) associated with the package. You can add packages by using the Package Wizard or by dragging a package file (.pak) from Windows&nbsp;NT Explorer and dropping it into the right pane of Transaction Server Explorer. </P></li>
</ol>
<h4>To create a package:</h4>
<ol>
<li>
Click the Packages Installed folder for that computer. <br><br></li>
<li>
On the <b>File</b>&nbsp;menu, click <b>New</b>.<p class=tl>
Add components and associate security roles to make the package functional. </P></li>
<li>
Click <b>Create an empty package</b> and set the package identity.<p>
<img src="sql_mts_32.gif" border=0></P><p class=tl>
The default selection is <b>Interactive user - the current logged on user</b>. The interactive user is the current Windows&nbsp;NT user on the computer running a package. To select a different user, click <b>This user </b>and type the user and password for a specific Windows&nbsp;NT user or group. </P><p class=tl>
The password you enter is not validated until the package starts in a server process.</P><p>
<img src="sql_mts_33.gif" border=0></P></li>
<li>
After creating a package, you can set additional options in the property sheet. The information displayed in a property sheet is determined by the item. For example, the property sheet for a computer item contains the computer name, log-file path, and update settings, whereas a property sheet for a package contains information regarding security and other process-specific settings. Click <b>Finish</b> to complete the package setup.<br><br></li>
<li>
To set the package security level, right-click the package to display the property sheet, and then click the <b>Security</b> tab. The <b>Authentication level for calls</b> is the level of authentication for clients calling the package.<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=23%><b>Level</b></td>
<td class=label width=77%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=23%>Default</td>
<td width=77%>Use for the Windows&nbsp;NT Server Authentication service, which is Connect.</td>
</tr>
<tr valign=top>
<td width=23%>None </td>
<td width=77%>No security checking occurs on communication between this package and another package or a client application.</td>
</tr>
<tr valign=top>
<td width=23%>Connect</td>
<td width=77%>Security checking occurs only for the initial connection.</td>
</tr>
<tr valign=top>
<td width=23%>Call</td>
<td width=77%>Security checking occurs on every call for the duration of the connection.</td>
</tr>
<tr valign=top>
<td width=23%>Packet</td>
<td width=77%>The sender's identity is encrypted to ensure the authenticity of the sender.</td>
</tr>
<tr valign=top>
<td width=23%>Packet integrity </td>
<td width=77%>The sender's identity and signature are encrypted to ensure the authenticity of the sender and to ensure that packets haven't been changed in transit. </td>
</tr>
<tr valign=top>
<td width=23%>Packet privacy</td>
<td width=77%>The entire packet, including the data and the sender identity and signature, is encrypted for maximum security.</td>
</tr>
</table><br>
</li>
</ol>
<h3>Installation Component(s)</h3>
<p>
With the package now installed, you can add components by dragging a DLL from Windows&nbsp;NT Explorer to the right pane of Transaction Explorer while the Components folder is open. Installing in this way has the same effect as clicking <b>Install new component(s)</b>. 
<ol>
<li>
Click the component to change transaction settings.<p>
<img src="sql_mts_34.gif" border=0></P></li>
<li>
To register the component by using Explorer, double-click the package, and then click the Components folder. Next, on the <b>File</b> menu, click <b>New</b>. Click<b> Install new components </b>to run the Component Wizard. (Note that installing a component allows you to also view the interfaces and methods on that component.)<br><br></li>
<li>
To add DLLs and type libraries that comprise the components for the package, click <b>Add files</b>.<p>
<img src="sql_mts_35.gif" border=0></P></li>
<li>
Select the file(s) you want to add, and then click <b>Open</b>. You can display all available files, just DLLs, or just type libraries by clicking the appropriate option in the <b>Files of type</b> box. <br><br></li>
<li>
The <b>Install Components</b> dialog box displays the added files and their associated components. To see more information about file contents and the components that were found, select <b>Details</b>. Microsoft Transaction Server requires that components have a type library. If a component type library isn't found, the component is not shown.<br><br></li>
<li>
To install the component, click <b>Finish</b>.<br><br></li>
<li>
To set additional properties after the component is created, right-click the component and select the properties. </li>
</ol>
<p>
This is the property sheet for a component:</p>
<p>
<img src="sql_mts_36.gif" border=0></p>
<p>
The <b>General </b>tab displays general information about the selected package, such as the name, description, and ID of a package. The ID is a unique number generated when you create the package. </p>
<p>
The <b>Transaction </b>tab contains the transaction-attribute setting for the component. Transaction Server uses this attribute during object creation to determine whether the object should be created to execute within a transaction and whether a transaction is required or optional. The transaction attribute can have one of the following values: 
<ul type=disc>
<li>
<b>Requires a transaction</b>. Component objects&nbsp;must execute within the scope of a transaction. When an object is created, its object context&nbsp;inherits the transaction from the context of the client. If the client doesn't have a transaction, Transaction Server automatically creates a transaction for the object. <br><br></li>
<li>
<b>Requires&nbsp;a new transaction</b>.&nbsp; Component objects must execute within their own transactions. When an object is created, Transaction Server creates a new transaction for the object, regardless of whether its client has a transaction. <br><br></li>
<li>
<b>Supports transactions</b>. Component objects can execute within the scope of their client transactions. When an object is created, its object context inherits the transaction from the context of the client. If the client doesn't have a transaction, the new context is also created without one. <br><br></li>
<li>
<b>Does not support transactions</b>.&nbsp; Component objects shouldn't run within the scope of transactions. When an object is created, its object context is created without a transaction, regardless of whether the client has a transaction. </li>
</ul>
<p>
Most Transaction Server components are declared as either <b>Supports transactions&nbsp;</b>or<b> Requires a transaction</b>. These values allow an object to execute within the scope of its client transaction. The difference between these occurs when an object is created from a context that doesn't have a transaction. If the component transaction attribute is <b>Supports transactions</b>, the new object runs without a transaction. If it's declared as <b>Requires a transaction</b>, Transaction Server automatically initiates a transaction for the new object. </p>
<p>
Declaring a component as <b>Requires a new transaction</b> is similar to using <b>Requires a transaction</b> in that the component objects are guaranteed to execute within transactions. However, when you declare the transaction attribute this way, an object will never run inside the scope of its client transaction. Instead, the system creates independent transactions for new objects. For example, you can use this for auditing components that record work done on behalf of another transaction regardless of whether the original transaction commits or aborts. </p>
<p>
Specifying <b>Does not support transactions</b>&nbsp;ensures that an object context will not contain a transaction. This is the default setting and is primarily intended for use with COM components that predate Transaction Server. </p>
<p>
You can also set a transaction attribute at development time using Visual&nbsp;Studio values defined in Mtxattr.h. You can specify these values in an .odl file to encode them into the component type library—the standard descriptions of data types, modules, and interfaces that can be used to fully expose objects with ActiveX technology. Visual&nbsp;Basic automatically generates a type library and developers must use Microsoft Transaction Server Explorer to set the transaction attribute.</p>
<p>
After the component is built, Microsoft Transaction Server Explorer builds the package file to deploy the components. The package contains information about the components and roles (security) of a package. When you create a prebuilt package, the associated component files (DLLs, type libraries, and proxy-stub DLLs, if implemented) are copied to the same directory where the package file was created.</p>
<p>
Components that make updates to multiple transactional resources (for example, database records) can ensure that their objects are always created within a transaction. If the object is created from a context that has a transaction, the new context inherits that transaction; otherwise, the system automatically initiates a transaction. An object context is similar in concept to the process context that an operating system maintains for an executing program. The Microsoft Transaction Server run-time environment manages a context for each object.</p>
<p>
Components that only do a single transactional update can be declared to support, but not require, transactions. If the object is created from a context that has a transaction, the new context inherits that transaction. This allows the work of multiple objects to be composed into a single atomic transaction. If the object is created from a context that doesn't have a transaction, the object can rely on the resource manager to ensure that the single update is atomic.</p>
<p>
The <b>Activation </b>tab<b> </b>allows the developer to set attributes at run time. The default is to allow the component to be managed by Transaction Server. You can also set location parameters:
<ul type=disc>
<li>
<b>In the creator's process</b>. Click this option to run the component in the same process as the client that called it. This option is only available for clients on the specified computer.<br><br></li>
<li>
<b>In a server process on this computer</b>. Click this option to run this component in its own process on this computer. The component will run in the same process with other components in the same package. You must enable this option to allow remote clients to run this component.<br><br></li>
<li>
<b>In a remote server process on the computer</b>. Click this option to run this component in its own process on the specified remote computer. Type the name of the remote computer where you want to run this component. This option only affects client components on the same computer.</li>
</ul>
<p>
The <b>Security </b>tab contains the security setting. You can enable or disable checking of security credentials of any client. Set security for all components in a package here.</p>
<p>
You can also use Explorer to tune and debug components. For information, see Microsoft Transaction Server Explorer Help. While the debuggers for Visual&nbsp;Basic and Visual&nbsp;C++ can help, Explorer provides the developer with valuable information for ensuring transaction integrity and performance.</p>
<p>
<img src="sql_mts_37.gif" border=0></p>
</BODY>
</HTML>
