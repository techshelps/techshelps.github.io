<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Appendix</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Appendix</h1>
<p>
The appendix first defines all of the driver-specific options defined in Odbcss.h and then has two sample applications that illustrate processing text and image data.</p>
<h3>Odbcss.h</h3>
<p>
Odbcss.h is a header file containing the definitions used for all of the driver-specific options in the SQL&nbsp;Server ODBC driver. Odbcss.h is distributed with SQL&nbsp;Server Workstation and with SQL&nbsp;Server 6.5 SP2. The version distributed with SP2 has a few extra connection options related to controlling the ANSI options used by the driver. The list below relates to the 6.5 SP2 version of Odbcss.h.</p>
<h4>SQLSetConnectOption</h4>
<p>
The following options can be set on using <b>SQLSetConnectOption</b>. The bulleted literals are specified as the <i>fOption</i> parameter; the literals grouped under each bulleted <i>fOption</i> are specified as <i>vParam</i>.</p>
<pre><code>SQL_COPT_SS_REMOTE_PWD 
</code></pre>
<p class=indent>
(replaces SQL_REMOTE_PWD)</p>
<pre><code>SQL_COPT_SS_USE_PROC_FOR_PREP 
</code></pre>
<p class=indent>
(replaces SQL_USE_PROCEDURE_FOR_PREPARE)</p>
<p class=indent>
Controls generation of stored procedures on <b>SQLPrepare</b>.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=43%><b>vParam value</b></td>
<td class=label width=57%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=43%>SQL_UP_OFF</td>
<td width=57%>Do not generate procedures on <b>SQLPrepare</b>.</td>
</tr>
<tr valign=top>
<td width=43%>SQL_UP_ON</td>
<td width=57%>Generate procedures for <b>SQLPrepare</b>; do not drop until <b>SQLDisconnect</b>.</td>
</tr>
<tr valign=top>
<td width=43%>SQL_UP_ON_DROP</td>
<td width=57%>Generate procedures for <b>SQLPrepare</b>; drop on <b>SQLFreeStmt </b>(SQL_DROP), <b>SQLDisconnect</b>, or next <b>SQLPrepare</b>.</td>
</tr>
<tr valign=top>
<td width=43%>SQL_UP_DEFAULT = SQL_UP_ON</td>
<td width=57%></td>
</tr>
</table><br>
<pre><code>SQL_COPT_SS_INTEGRATED_SECURITY 
</code></pre>
<p class=indent>
(replaces SQL_INTEGRATED_SECURITY)</p>
<p class=indent>
Controls use of integrated security when connecting to SQL&nbsp;Server.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_IS_OFF</td>
<td width=58%>Integrated security isn't used.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_IS_ON</td>
<td width=58%>Integrated security is used.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_IS_DEFAULT = SQL_IS_OFF</td>
<td width=58%></td>
</tr>
</table><br>
<pre><code>SQL_COPT_SS_PRESERVE_CURSORS 
</code></pre>
<p class=indent>
(replaces SQL_PRESERVE_CURSORS)</p>
<p class=indent>
Controls whether cursors are dropped at the end of a transaction.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_PC_OFF</td>
<td width=58%>Cursors are closed on SQLTransact.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_PC_ON</td>
<td width=58%>Cursors remain open on SQLTransact.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_PC_DEFAULT= SQL_PC_OFF</td>
<td width=58%></td>
</tr>
</table><br>
<pre><code>SQL_COPT_SS_USER_DAT
A
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_UD_NOTSET</td>
<td width=58%>No user-data pointer set.</td>
</tr>
</table><br>
<pre><code>SQL_COPT_SS_ANSI_OEM
</code></pre>
<p class=indent>
Controls ANSI to EOM conversion of data. </p>
<p class=indent>
SQL_AO_DEFAULT = SQL_AO_OFF, unless DSN<b> OEM/ANSI</b> checkbox is selected.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_AO_OFF ANSI/OEM</td>
<td width=58%>Translation is not performed.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_AO_ON ANSI/OEM</td>
<td width=58%>Translation is performed.</td>
</tr>
</table><br>
<pre><code>SQL_COPT_SS_ENLIST_IN_DTC
</code></pre>
<p class=indent>
Controls enlistment in a distributed transaction managed by the Microsoft Distributed Transaction Coordinator.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_DTC_DONE</td>
<td width=58%>Delimits end of distributed transaction.</td>
</tr>
</table><br>
<pre><code>SQL_COPT_SS_ENLIST_IN_XA
</code></pre>
<p class=indent>
Enlists in a distributed transaction managed by a transaction manager that complies with the X/Open XA standard.</p>
<p class=indent>
The <i>vParam</i> value is a pointer to a variable defined using the structure:</p>
<p class=indent>
<code>typedef struct SQLXaTranTAG<br>
{<br>
 &nbsp;&nbsp; void FAR *transManager;<br>
 &nbsp;&nbsp; void FAR *xaTransID;<br>
 &nbsp;&nbsp; ULONGxaTransIDLength;<br>
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; dwErrorInfo;<br>
} SQLXaTran;<br>
</code></p>
<pre><code>SQL_COPT_SS_CONNECTION_DEAD
</code></pre>
<p class=indent>
Used to see if connection is still active.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_CD_FALSE</td>
<td width=58%>Connection is open/available.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_CD_TRUE</td>
<td width=58%>Connection is closed/dead.</td>
</tr>
</table><br>
<pre><code>SQL_COPT_SS_FALLBACK_CONNECT
</code></pre>
<p class=indent>
Controls the use of SQL&nbsp;Server Fallback Connections.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_FB_OFF</td>
<td width=58%>Fallback connections are disabled.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_FB_ON</td>
<td width=58%>Fallback connections are enabled.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_FB_DEFAULT = SQL_FB_OFF</td>
<td width=58%></td>
</tr>
</table><br>
<pre><code>SQL_COPT_SS_PERF_DATA
</code></pre>
<p class=indent>
Controls the logging of driver performance data.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_PERF_START</td>
<td width=58%>Starts the driver sampling performance data.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_PERF_STOP</td>
<td width=58%>Stops the counters from sampling performance data.</td>
</tr>
</table><br>
<pre><code>SQL_COPT_SS_PERF_DATA_LOG
</code></pre>
<p class=indent>
Specifies the file in which to log performance data.</p>
<p class=indent>
The <i>vParam</i> value is a pointer to a null-terminated string that contains the file name.</p>
<pre><code>SQL_COPT_SS_PERF_QUERY_INTERVAL
</code></pre>
<p class=indent>
Specifies the interval for the trigger point to log a long-running query.</p>
<p class=indent>
The <i>vParam</i> value is an integer specifying the interval in seconds.</p>
<pre><code>SQL_COPT_SS_PERF_QUERY_LOG
</code></pre>
<p class=indent>
Specifies the file in which to log long running queries. </p>
<p class=indent>
The <i>vParam</i> value is a pointer to a null-terminated string that contains the file name.</p>
<pre><code>SQL_COPT_SS_PERF_QUERY
</code></pre>
<p class=indent>
Controls the logging of long running queries.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_PERF_START</td>
<td width=58%>Starts the driver logging long-running queries.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_PERF_STOP</td>
<td width=58%>Stops the counters from logging long-running queries.</td>
</tr>
</table><br>
<pre><code>SQL_COPT_SS_PERF_DATA_LOG_NOW
</code></pre>
<p class=indent>
Instructs the driver to write a performance statistics record to the log.</p>
<p class=indent>
The <i>vParam</i> value is NULL.</p>
<pre><code>SQL_COPT_SS_QUOTED_IDENT
</code></pre>
<p class=indent>
Controls setting of QUOTED_IDENTIFIER (can only be set before connecting).</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_QI_OFF</td>
<td width=58%>Quoted identifiers are not supported.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_QI_ON</td>
<td width=58%>Quoted identifiers are supported.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_QI_DEFAULT = SQL_QI_ON</td>
<td width=58%></td>
</tr>
</table><br>
<pre><code>SQL_COPT_SS_ANSI_NPW
</code></pre>
<p class=indent>
Controls setting of ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS (can only be set before connecting).</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_AD_OFF</td>
<td width=58%>The ANSI options are not set on.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_AD_ON</td>
<td width=58%>The ANSI options are set on.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_AD_DEFAULT = SQL_AD_ON</td>
<td width=58%></td>
</tr>
</table><br>
<h4>SQLSetStmtOption</h4>
<p>
The following options can be set on using <b>SQLSetStmtOption</b>. The bulleted literals are specified as the <i>fOption</i> parameter, the literals grouped under each bulleted <i>fOption</i> are specified as <i>vParam</i>.</p>
<pre><code>SQL_SOPT_SS_TEXTPTR_LOGGING 
</code></pre>
<p class=indent>
(replaces SQL_TEXTPTR_LOGGING)</p>
<p class=indent>
Controls logging of text/image operations.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_TL_OFF</td>
<td width=58%>No logging on text-pointer operations.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_TL_ON</td>
<td width=58%>Logging occurs on text-pointer operations.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_TL_DEFAULT = SQL_TL_ON</td>
<td width=58%></td>
</tr>
</table><br>
<pre><code>SQL_SOPT_SS_HIDDEN_COLUMNS
</code></pre>
<p class=indent>
Expose FOR BROWSE hidden columns.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_HC_OFF</td>
<td width=58%>BROWSE columns are hidden.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_HC_ON</td>
<td width=58%>BROWSE columns are exposed.</td>
</tr>
</table><br>
<pre><code>SQL_SOPT_SS_NOBROWSETABLE
</code></pre>
<p class=indent>
SET NOBROWSETABLE option.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>vParam value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=42%>SQL_NB_OFF</td>
<td width=58%>NO_BROWSETABLE is off.</td>
</tr>
<tr valign=top>
<td width=42%>SQL_NB_ON</td>
<td width=58%>NO_BROWSETABLE is on.</td>
</tr>
</table><br>
<h4>SQLGetStmtOption</h4>
<p>
If <b>SQLGetStmtOption</b> is called with <i>fOption</i> = SQL_SOPT_SS_CURRENT_COMMAND, the driver returns an integer to <i>pvParam</i> indicating which command in the batch is the one whose results are being processed. The first command in the batch is 1.</p>
<h4>SQLColAttributes</h4>
<p>
The following options can be set on using <b>SQLColAttributes</b>. The bulleted literals are specified as the <i>fDescType</i> parameter; the literals grouped under each bulleted <i>fDescType</i> are the values returned as <i>pfDesc</i>.</p>
<pre><code>SQL_CA_SS_COLUMN_SSTYPE
</code></pre>
<p class=indent>
The base data type of a SQL&nbsp;Server result column.<br>
<i>pfDesc</i> values:<br>
SQLBINARY, SQLBIT, SQLCHAR, SQLDATETIME, SQLDATETIM4, SQLDATETIMN, SQLDECIMAL, SQLDECIMALN, SQLFLT4, SQLFLT8, SQLFLTN, SQLIMAGE, SQLINT1, SQLINT2, SQLINT4, SQLINTN, SQLMONEY, SQLMONEY4, SQLMONEYN, SQLNUMERIC, SQLNUMERICN SQLTEXT, SQLVARBINARY, SQLVARCHAR&nbsp; </p>
<pre><code>SQL_CA_SS_COLUMN_UTYPE
</code></pre>
<p class=indent>
The user-defined data type of a SQL&nbsp;Server result column.<br>
<i>pfDesc</i> values:<br>
SQLudtBINARY, SQLudtBIT, SQLudtCHAR, SQLudtDATETIME, SQLudtDATETIM4, SQLudtDATETIMN, SQLudtDECML, SQLudtDECMLN, SQLudtFLTN, SQLudtFLT4, SQLudtFLT8, SQLudtIMAGE, SQLudtINT1, SQLudtINT2, SQLudtINT4, SQLudtINTN, SQLudtMONEY, SQLudtMONEY4, SQLudtMONEYN, SQLudtNUM, SQLudtNUMN SQLudtSYSNAME, SQLudtTEXT, SQLudtTIMESTAMP, SQLudtVARBINARY, SQLudtVARCHAR, </p>
<pre><code>SQL_CA_SS_NUM_ORDERS
</code></pre>
<p class=indent>
<i>pfDesc</i> returns the number of columns in an ORDER BY clause.</p>
<pre><code>SQL_CA_SS_COLUMN_ORDER
</code></pre>
<p class=indent>
The SELECT list column ID of a column that appears in the SQL statement ORDER BY clause.</p>
<p class=indent>
<i>pfDesc</i> returns the column ID.</p>
<pre><code>SQL_CA_SS_COLUMN_VARYLEN
</code></pre>
<p class=indent>
<i>pfDesc</i> is TRUE if the column's data can vary in length, otherwise FALSE.</p>
<pre><code>SQL_CA_SS_NUM_COMPUTES
</code></pre>
<p class=indent>
<i>pfDesc</i> returns the number of compute clauses in the current result set.</p>
<pre><code>SQL_CA_SS_COMPUTE_ID
</code></pre>
<p class=indent>
<i>pfDesc</i> returns the compute ID of a compute row.</p>
<pre><code>SQL_CA_SS_COMPUTE_BYLIST
</code></pre>
<p class=indent>
Returns a bylist: an array of the column IDs of the columns participating in a Transact-SQL COMPUTE BY clause.</p>
<p class=indent>
<i>pfDesc</i> returns a pointer to the bylist for a compute row.</p>
<pre><code>SQL_CA_SS_COLUMN_ID
</code></pre>
<p class=indent>
<i>pfDesc</i> returns the SELECT list column ID to which a COMPUTE BY aggregate refers.</p>
<pre><code>SQL_CA_SS_COLUMN_OP
</code></pre>
<p class=indent>
Identifies the aggregate operation the COMPUTE BY applied to a column.</p>
<p class=indent>
<i>pfDesc</i> returns:<br>
<br>
<code>SQLAOPANY<br>
SQLAOPAVG (AVG())<br>
SQLAOPCNT (COUNT())<br>
SQLAOPMIN (MIN())<br>
SQLAOPMAX (MAX())<br>
SQLAOPNOOP<br>
SQLAOPSUM (SUM())</code></p>
<pre><code>SQL_CA_SS_COLUMN_SIZE
</code></pre>
<p class=indent>
The maximum length of data for a column.</p>
<pre><code>SQL_CA_SS_COLUMN_HIDDEN
</code></pre>
<p class=indent>
The column is hidden. Applies only if the SELECT was FOR BROWSE and the driver-specific statement option SQL_SOPT_SS_HIDDEN_COLUMNS is set to SQL_HC_ON.</p>
<pre><code>SQL_CA_SS_COLUMN_KEY
</code></pre>
<p class=indent>
The column is a key column.</p>
<pre><code>SQL_CA_SS_BASE_COLUMN_NAME
</code></pre>
<p class=indent>
The base column name.</p>
<h4>SQLGetInfo</h4>
<p>
If <b>SQLGetInfo</b> is called with <i>fInfoType</i> set to SQL_INFO_SS_NETLIB_NAME, <i>rgbInfoValue</i> returns the name of the Net-Library used to connect to SQL&nbsp;Server.</p>
<h3>SQLPerf Structure</h3>
<p>
The meaning of the variables defined in the <b>sqlperf</b> structure are given in this section. These descriptions also apply to the statistics recorded in the performance log file. For a description of how to gather these statistics, see "Diagnosing and Profiling Applications."</p>
<h4>Application Profile Statistics</h4>
<p>
The following variables profile the processing that occurs in the Microsoft SQL&nbsp;Server ODBC driver.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Application profile statistics</b></td>
<td class=label width=71%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=29%>TimerResolution</td>
<td width=71%>The minimum resolution of the server's clock time in milliseconds. This is usually reported as 0 (zero). The only time this statistic should be considered is if the number reported is large. If the minimum resolution of the server clock is larger than the likely interval for some of the timer-based statistics, those statistics may be inflated.</td>
</tr>
<tr valign=top>
<td width=29%>SQLidu</td>
<td width=71%>The number of INSERT, DELETE, or UPDATE statements processed since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>SQLiduRows</td>
<td width=71%>The number of rows affected by INSERT, DELETE, or UPDATE statements processed since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>SQLSelects</td>
<td width=71%>The number of SELECT statements processed since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>SQLSelectRows</td>
<td width=71%>The number of rows selected since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>Transactions</td>
<td width=71%>The number of user transactions since SQL_PERF_START. For example, suppose an application had run the following statements:<p>
SQLSetConnectOption(hdbc,<br>
SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_ON);</p>
<p>
SQLTransact(henv, hbdc,SQL_COMMIT);</p>
<p>
SQLTransact(henv, hdbc, SQL_ROLLBACK);</p>
<p>
This constitutes two user transactions. Even though the second transaction was rolled back, it still counted as a transaction. Also, when an ODBC application is running with SQL_AUTOCOMMIT_ON, each individual command is considered a transaction.</p>
</td>
</tr>
<tr valign=top>
<td width=29%>SQLPrepares</td>
<td width=71%>The number of <b>SQLPrepare</b> functions executed since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>ExecDirects</td>
<td width=71%>The number of <b>SQLExecDirect</b> functions executed since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>SQLExecutes</td>
<td width=71%>The number of <b>SQLExecute</b> functions executed since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>CursorOpens</td>
<td width=71%>The number of times the driver has opened a server cursor since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>CursorSize</td>
<td width=71%>The number of rows in the result sets opened by cursors since SQL_PERF_START.</td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Application profile statistics</b></td>
<td class=label width=71%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=29%>CursorUsed</td>
<td width=71%>The number of rows actually retrieved through the driver from cursors since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>PercentCursorUsed</td>
<td width=71%>Here is the equation used to figure the percentage of cursor used:<p>
<b>PercentCursorUsed</b> = <b>CursorUsed</b>/<b>CursorSize</b></p>
<p>
For example, if an application causes the driver to open a server cursor to do "select count(*) from authors," 23 rows are in the result set for the select. If the application then only fetches three of these rows, <b>CursorUsed</b>/<b>CursorSize</b> is 3/23, so <b>PercentCursorUsed</b> is 13.043478.</p>
</td>
</tr>
<tr valign=top>
<td width=29%>AvgFetchTime</td>
<td width=71%>Here is the equation used to figure the average fetch time:<p>
<b>AvgFetchTime</b> = <b>SQLFetchTime</b>/<b>SQLFetchCount</b></p>
</td>
</tr>
<tr valign=top>
<td width=29%>AvgCursorSize</td>
<td width=71%>Here is the equation used to figure average cursor size:<p>
<b>AvgCursorSize</b> = <b>CursorSize</b>/<b>CursorOpens</b></p>
</td>
</tr>
<tr valign=top>
<td width=29%>AvgCursorUsed</td>
<td width=71%>Here is the equation used to figure average number of cursors used:<p>
<b>AvgCursorUsed</b> = <b>CursorUsed</b>/<b>CursorOpens</b></p>
</td>
</tr>
<tr valign=top>
<td width=29%>SQLFetchTime</td>
<td width=71%>The cumulative amount of time it took fetches against server cursors to complete.</td>
</tr>
<tr valign=top>
<td width=29%>SQLFetchCount</td>
<td width=71%>The number of fetches done against server cursors since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>CurrentStmtCount</td>
<td width=71%>The number of statement handles currently open on all connections open in the driver.</td>
</tr>
<tr valign=top>
<td width=29%>MaxOpenStmt</td>
<td width=71%>The maximum number of concurrently opened statement handles since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>SumOpenStmt</td>
<td width=71%>The number of statement handles that have been opened since SQL_PERF_START.</td>
</tr>
</table><br>
<h4>Connection Statistics</h4>
<p>
These variables profile the connections to SQL&nbsp;Server opened by the application.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Connection statistics</b></td>
<td class=label width=71%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=29%>CurrentConnectionCount</td>
<td width=71%>The current number of active connection handles the application has open to the server.</td>
</tr>
<tr valign=top>
<td width=29%>MaxConnectionsOpened</td>
<td width=71%>The maximum number of concurrent connection handles opened since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>SumConnectionsOpened</td>
<td width=71%>The sum of the number of connection handles that have been opened since SQL_PERF_START.</td>
</tr>
<tr valign=top>
<td width=29%>SumConnectionTime</td>
<td width=71%>The sum of the amount of time for which all of the connections have been opened since SQL_PERF_START. For example, if an application opened 10 connections and maintained each connection for 5 seconds, then <b>SumConnectionTime</b> would be 50 seconds.</td>
</tr>
<tr valign=top>
<td width=29%>AvgTimeOpened</td>
<td width=71%>Here is the equation used to figure average time connections are open:<p>
<b>AvgTimeOpened</b> = <b>SumConnectionsOpened</b>/ <b>SumConnectionTime</b></p>
</td>
</tr>
</table><br>
<h4>Network Statistics</h4>
<p>
The network packet statistics reported by the driver relate to the TDS packets (for more information about TDS, see "Architecture"). The size of a TDS packet is either the server's default setting specified in <b>sp_configure 'network packet size'</b> or what the ODBC client might request through:</p>
<pre><code>SQLSetConnectOption(hdbc, SQL_PACKET_SIZE, NNNN) 
</code></pre>
<p>
These packets may be larger than the size of the network packets actually sent by the underlying protocol stack (such as TCP/IP or SPX/IPX). The SQL&nbsp;Server Net-Library DLLs and the underlying protocol stack are the components that map the TDS packets onto the network packets, but this is hidden from both the SQL&nbsp;Server ODBC driver and the DB-Library DLL.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Network statistics</b></td>
<td class=label width=74%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=26%>ServerRndTrips</td>
<td width=74%>The number of times the driver sent commands to the server and got a reply back.</td>
</tr>
<tr valign=top>
<td width=26%>BuffersSent</td>
<td width=74%>The number of TDS packets sent to SQL&nbsp;Server by the driver since SQL_PERF_START. Large commands may take multiple buffers, so if a large command is sent to the server that filled six packets, <b>ServerRndTrips</b> would be incremented by one, <b>BuffersSent</b> by six.</td>
</tr>
<tr valign=top>
<td width=26%>BuffersRec</td>
<td width=74%>The number of TDS packets received by the driver from SQL&nbsp;Server since the application started using the driver.</td>
</tr>
<tr valign=top>
<td width=26%>BytesSent</td>
<td width=74%>The number of bytes of data sent to SQL&nbsp;Server in TDS packets since the application started using the driver.</td>
</tr>
<tr valign=top>
<td width=26%>BytesRec</td>
<td width=74%>The number of bytes of data in TDS packets received by the driver from SQL&nbsp;Server since the application started using the driver.</td>
</tr>
</table><br>
<h4>Time Statistics</h4>
<p>
These are the time statistics.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Time statistics</b></td>
<td class=label width=74%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=26%>MsExecutionTime</td>
<td width=74%>The cumulative amount of time the driver spent doing its processing since SQL_PERF_START, including the time it spent waiting for replies from the server.</td>
</tr>
<tr valign=top>
<td width=26%>MsNetworkServerTime</td>
<td width=74%>The cumulative amount of time the driver spent waiting for replies from the server.</td>
</tr>
</table><br>
<h3>Putimage.c and Getimage.c</h3>
<p>
The following sample programs are discussed in "Data-At-Execution and Text and Image Columns." Both depend on a table having been created as follows:</p>
<pre><code>CREATE TABLE emp2 (name CHAR(30), age FLOAT, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; birthday DATETIME, BigBin IMAGE)
</code></pre>
<p>
If Putimage is compiled and run first, then Getimage can be used to read the data. To confirm that all 300,000 bytes of image data has been entered by Putimage, run the following from ISQL/w:</p>
<pre><code>SELECT name, age, birthday, BinLen = datalength(BigBin)
FROM emp2
</code></pre>
<p>
Note: Some of the error checking has been removed for clarity. Also, both programs use the same function, ProcessLogMessages, whose source code has been deleted from Getimage.c to save space.</p>
<h4>Putimage.c</h4>
<pre><code>// Sample application to write SQL_LONGVARBINARY data using SQLPutData.
// Assumes DSN has table:
//&nbsp; CREATE TABLE EMP2 (NAME CHAR(30), AGE FLOAT, 
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BigBin IMAGE)
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;
#include &lt;sql.h&gt;
#include &lt;sqlext.h&gt;
#define MAXDSN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 25
#define MAXUID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 25
#define MAXAUTHSTR&nbsp;&nbsp; 25
#define MAXBUFLEN&nbsp;&nbsp;&nbsp; 255
#define SIZEOFTEXT&nbsp;&nbsp; 300000
HENV&nbsp;&nbsp; henv = SQL_NULL_HENV;
HDBC&nbsp;&nbsp; hdbc1 = SQL_NULL_HDBC;
HSTMT&nbsp;&nbsp; hstmt1 = SQL_NULL_HSTMT;
char&nbsp;&nbsp; logstring[MAXBUFLEN] = "";
void&nbsp;&nbsp; ProcessLogMessages(HENV plm_henv, HDBC plm_hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HSTMT plm_hstmt, char *logstring);
int main()
{
 &nbsp; RETCODE retcode;
 &nbsp; UCHAR&nbsp;&nbsp; szDSN[MAXDSN+1] = "ab65def",
 &nbsp;&nbsp;&nbsp;&nbsp; szUID[MAXUID+1] = "sa",
 &nbsp;&nbsp;&nbsp;&nbsp; szAuthStr[MAXAUTHSTR+1] = "password";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; // SQLBindParameter variables.
 &nbsp; SDWORD&nbsp;&nbsp; cbTextSize, lbytes;
 &nbsp; //SQLParamData variable.
 &nbsp; PTR&nbsp;&nbsp; pParmID;
 &nbsp; //SQLPutData variables.
 &nbsp; UCHAR&nbsp;&nbsp; Data[] = 
 &nbsp; "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
 &nbsp; "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
 &nbsp; "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
 &nbsp; "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
 &nbsp; "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
 &nbsp; "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
 &nbsp; "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
 &nbsp; "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
 &nbsp; "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "abcdefghijklmnopqrstuvwxyz";
 &nbsp; SDWORD&nbsp;&nbsp; cbBatch = (SDWORD)sizeof(Data)-1;
 &nbsp;&nbsp; // Allocate the ODBC environment and save handle.
 &nbsp; retcode = SQLAllocEnv (&amp;henv);
 &nbsp; // Allocate ODBC connection and connect.
 &nbsp; retcode = SQLAllocConnect(henv, &amp;hdbc1);
 &nbsp; retcode = SQLConnect(hdbc1, szDSN, (SWORD)strlen(szDSN),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szUID, (SWORD)strlen(szUID),szAuthStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SWORD)strlen(szAuthStr));
 &nbsp; // Print info messages returned.
 &nbsp; if ( (retcode != SQL_SUCCESS) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (retcode != SQL_SUCCESS_WITH_INFO) ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessLogMessages(henv,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hdbc1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SQLConnect() Failed\n\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(9);
 &nbsp; }
 &nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp; ProcessLogMessages(henv,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hdbc1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\nConnect Successful\n\n");
 &nbsp; }&nbsp;&nbsp; 
 &nbsp; // Allocate a statement handle.
 &nbsp; retcode = SQLAllocStmt(hdbc1,&amp;hstmt1);
 &nbsp; // Let ODBC know total length of data to send.
 &nbsp; lbytes = (SDWORD)SIZEOFTEXT;
 &nbsp; cbTextSize = SQL_LEN_DATA_AT_EXEC(lbytes);

 &nbsp; // Bind the parameter.
 &nbsp; retcode = SQLBindParameter(hstmt1,&nbsp;&nbsp; // hstmt
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ipar
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_PARAM_INPUT,&nbsp;&nbsp; // fParamType
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_C_BINARY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fCType
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_LONGVARBINARY,&nbsp;&nbsp; // FSqlType
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lbytes,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cbColDef
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ibScale
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (VOID *)1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // rgbValue
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cbValueMax
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;cbTextSize);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pcbValue
 &nbsp; if ( (retcode != SQL_SUCCESS) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp; (retcode != SQL_SUCCESS_WITH_INFO) ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessLogMessages(henv, hdbc1, hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SQLBindParam hstmt1 Failed\n\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(9);
 &nbsp; }
 &nbsp; retcode = SQLExecDirect(hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp; "INSERT INTO EMP2 VALUES('JOHN SMITH', 27.3, ?)",
 &nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS);
 &nbsp; if ( (retcode != SQL_SUCCESS) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (retcode != SQL_SUCCESS_WITH_INFO) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (retcode != SQL_NEED_DATA) ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessLogMessages(henv, hdbc1, hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SQLExecute Failed\n\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(9);
 &nbsp; }
 &nbsp; // Get ID of parameter that needs data.
 &nbsp; retcode = SQLParamData(hstmt1, &amp;pParmID);
 &nbsp; // If data is needed for the Data-At-Execution parameter:
 &nbsp; if (retcode == SQL_NEED_DATA) {
 &nbsp;&nbsp;&nbsp;&nbsp; // Send all but the final batch.
 &nbsp;&nbsp;&nbsp;&nbsp; while (lbytes &gt; cbBatch) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQLPutData(hstmt1, Data, cbBatch);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lbytes -= cbBatch;
 &nbsp;&nbsp;&nbsp;&nbsp; }&nbsp; // End while.
 &nbsp;&nbsp;&nbsp;&nbsp; // Put final batch.
 &nbsp;&nbsp;&nbsp;&nbsp; SQLPutData(hstmt1, Data, lbytes); 
 &nbsp; }
 &nbsp; else { // If not SQL_NEED_DATA, is some error.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessLogMessages(henv, hdbc1, hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SQLPutData Failed\n\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(9);
 &nbsp; }&nbsp; // end if
 &nbsp; // Make final SQLParamData call to signal end of data.
 &nbsp; retcode = SQLParamData(hstmt1, &amp;pParmID);
 &nbsp; if ( (retcode != SQL_SUCCESS) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (retcode != SQL_SUCCESS_WITH_INFO) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (retcode != SQL_NEED_DATA) ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessLogMessages(henv, hdbc1, hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SQLParamData Failed\n\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(9);
 &nbsp; }
 &nbsp; /* Clean up. */
 &nbsp; SQLFreeStmt(hstmt1, SQL_DROP);
 &nbsp; SQLDisconnect(hdbc1);
 &nbsp; SQLFreeConnect(hdbc1);
 &nbsp; SQLFreeEnv(henv);
 &nbsp; return(0);
}
void ProcessLogMessages(HENV plm_henv, HDBC plm_hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HSTMT plm_hstmt, char *logstring)
{
 &nbsp; RETCODE&nbsp;&nbsp; plm_retcode = SQL_SUCCESS;
 &nbsp; UCHAR&nbsp;&nbsp; plm_szSqlState[MAXBUFLEN] = "",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plm_szErrorMsg[MAXBUFLEN] = "";
 &nbsp; SDWORD&nbsp;&nbsp; plm_pfNativeError = 0L;
 &nbsp; SWORD&nbsp;&nbsp; plm_pcbErrorMsg = 0;

 &nbsp; printf(logstring);
 &nbsp; while (plm_retcode != SQL_NO_DATA_FOUND) {
 &nbsp;&nbsp;&nbsp;&nbsp; plm_retcode = SQLError(plm_henv, plm_hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plm_hstmt, plm_szSqlState,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;plm_pfNativeError,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plm_szErrorMsg, MAXBUFLEN - 1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;plm_pcbErrorMsg);
 &nbsp;&nbsp;&nbsp;&nbsp; if (plm_retcode != SQL_NO_DATA_FOUND){
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("szSqlState = %s\n", plm_szSqlState);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("pfNativeError = %d\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plm_pfNativeError);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("szErrorMsg = %s\n", plm_szErrorMsg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("pcbErrorMsg = %d\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plm_pcbErrorMsg);
 &nbsp;&nbsp;&nbsp;&nbsp; } //end if
 &nbsp; } // end while
}
</code></pre>
<h4>Getimage.c</h4>
<pre><code>// Sample reading SQL_LONGVARBINARY using SQLGetData.
// Tested with SQL&nbsp;Server 6.5 and 2.65 drivers.
// Assumes DSN has table:
//&nbsp; CREATE TABLE EMP2 (NAME CHAR(30), AGE FLOAT, 
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BigBin IMAGE)
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;
#include &lt;sql.h&gt;
#include &lt;sqlext.h&gt;
#define MAXDSN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 25
#define MAXUID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 25
#define MAXAUTHSTR&nbsp;&nbsp; 25
#define MAXBUFLEN&nbsp;&nbsp; 255
#define BUFFERSIZE&nbsp;&nbsp; 450
HENV&nbsp;&nbsp; henv = SQL_NULL_HENV;
HDBC&nbsp;&nbsp; hdbc1 = SQL_NULL_HDBC;
HSTMT&nbsp;&nbsp; hstmt1 = SQL_NULL_HSTMT;
char&nbsp;&nbsp; logstring[MAXBUFLEN] = "";
void&nbsp;&nbsp; ProcessLogMessages(HENV plm_henv, HDBC plm_hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HSTMT plm_hstmt, char *logstring);
int main()
{
 &nbsp; RETCODE retcode;
 &nbsp; // Authorization strings.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UCHAR&nbsp;&nbsp; szDSN[MAXDSN+1] = "ab65def",
 &nbsp;&nbsp;&nbsp;&nbsp; szUID[MAXUID+1] = "sa",
 &nbsp;&nbsp;&nbsp;&nbsp; szAuthStr[MAXAUTHSTR+1] = "password";
 &nbsp; SWORD&nbsp;&nbsp; cntr;
 &nbsp; //SQLGetData variables.
 &nbsp; UCHAR&nbsp;&nbsp; Data[BUFFERSIZE];
 &nbsp; SDWORD&nbsp;&nbsp; cbBatch = (SDWORD)sizeof(Data)-1;
 &nbsp; SDWORD&nbsp;&nbsp; cbBinSize;
 &nbsp; // Clear data array.
 &nbsp; for(cntr = 0; cntr &lt; BUFFERSIZE; cntr++)
 &nbsp;&nbsp;&nbsp;&nbsp; Data[cntr] = 0x00;
 &nbsp;&nbsp; // Allocate the ODBC environment and save handle.
 &nbsp; retcode = SQLAllocEnv (&amp;henv);

 &nbsp; // Allocate ODBC connection and connect.
 &nbsp; retcode = SQLAllocConnect(henv, &amp;hdbc1);
 &nbsp; // Make the connection, then print the information messages.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retcode = SQLConnect(hdbc1, szDSN, (SWORD)strlen(szDSN),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szUID, (SWORD)strlen(szUID),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szAuthStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SWORD)strlen(szAuthStr));
 &nbsp; if ( (retcode != SQL_SUCCESS) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (retcode != SQL_SUCCESS_WITH_INFO) ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessLogMessages(henv, hdbc1, hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SQLConnect() Failed\n\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(9);
 &nbsp; }
 &nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessLogMessages(henv, hdbc1, hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\nConnect Successful\n\n");
 &nbsp; }
 &nbsp; // Allocate the statement handle.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retcode = SQLAllocStmt(hdbc1,&amp;hstmt1);
 &nbsp; // Execute the SELECT statement.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retcode = SQLExecDirect(hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SELECT BigBin FROM emp2", SQL_NTS);
 &nbsp; if ( (retcode != SQL_SUCCESS) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (retcode != SQL_SUCCESS_WITH_INFO) ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessLogMessages(henv, hdbc1, hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SQLExecDirect hstmt1 Failed\n\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(9);
 &nbsp; }
 &nbsp; // Get first row.
 &nbsp; retcode = SQLFetch(hstmt1);
 &nbsp; if ( (retcode != SQL_SUCCESS) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (retcode != SQL_SUCCESS_WITH_INFO) ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessLogMessages(henv, hdbc1, hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SQLFetch hstmt1 Failed\n\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(9);
 &nbsp; }
 &nbsp; // Get the SQL_LONG column. CbBatch has size of data chunk
 &nbsp; // the buffer can handle. Call SQLGetData until
 &nbsp; // SQL_NO_DATA_FOUND.&nbsp; cbBinSize on each call has the
 &nbsp; // amount of data left to transfer.
 &nbsp; cntr = 1;
 &nbsp; do {
 &nbsp;&nbsp;&nbsp;&nbsp; retcode = SQLGetData(hstmt1,&nbsp;&nbsp; // hstmt
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ipar
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_C_BINARY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fCType
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // rgbValue
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbBatch,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cbValueMax
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;cbBinSize);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pcbValue
 &nbsp;&nbsp;&nbsp;&nbsp; printf("GetData iteration %d, pcbValue = %d\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cntr++, cbBinSize);
 &nbsp;&nbsp;&nbsp;&nbsp; if ( (retcode != SQL_SUCCESS) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (retcode != SQL_SUCCESS_WITH_INFO) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retcode != SQL_NO_DATA_FOUND ){
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessLogMessages(henv, hdbc1, hstmt1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SQLGetData hstmt1 Failed\n\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(9);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; } while (retcode != SQL_NO_DATA_FOUND);
 &nbsp; /* Clean up. */
 &nbsp; SQLFreeStmt(hstmt1, SQL_DROP);
 &nbsp; SQLDisconnect(hdbc1);
 &nbsp; SQLFreeConnect (hdbc1);
 &nbsp; SQLFreeEnv(henv);
 &nbsp; return(0);
}</code></pre>
</BODY>
</HTML>
