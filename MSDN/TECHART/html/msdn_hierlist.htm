<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Displaying a Hierarchy in a List Box</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_hierlist"></a></sup>Displaying a Hierarchy in a List Box</h1>
<p>
Kyle Marsh<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: December 22, 1992</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="167">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the HierList sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article explains how to create a hierarchical list box that includes icon bitmaps and connecting lines. It describes what an application must do to display the hierarchy and discusses some helper functions I developed specifically to make the process easier for the application developer. HierList, the sample application included with this article, implements a hierarchical list box with these helper functions.</p>
<h2>Introduction</h2>
<p>
Many applications need to display information to a user in a hierarchical, or outline, format. In the Microsoft® Windows™ operating system, the best-known example is the list of directories in the File Manager. The directory structure of a disk is a hierarchical data structure. Databases often contain hierarchical data as well; for example, the relationship between managers and the people they manage is a hierarchical relationship.</p>
<p>
A common way to display a hierarchy is with a tree diagram, as in Figure 1.</p>
<p>
<img src="hierlist_1.gif" border=0></p>
<p class=label>
<b>Figure 1. A tree diagram</b></p>
<p>
Unfortunately this display requires a lot of work to program, especially when a level changes. Each box, line, and text string must be placed and drawn. When a change occurs to the data (for example, a new vice president is added), the entire display must be recalculated and displayed. Tree diagrams also take up a lot of screen space and, when there is a lot of data to display, the individual boxes become so small that the writing inside becomes unreadable.</p>
<p>
An alternate way to display the data is to turn the tree diagram on its side, as in Figure 2.</p>
<p>
<img src="hierlist_2.gif" border=0></p>
<p class=label>
<b>Figure 2. A turned tree diagram</b></p>
<p>
This technique requires less space. It is a little easier to program than the tree diagram, but it still requires quite a bit of development effort. Text and lines must still be placed and drawn, but calculating the positions is simpler because you don't have to worry about centering the boxes and lines as in Figure 1.</p>
<p>
Another option is to display the data in a list, as in Figure 3.</p>
<p>
<img src="hierlist_3.gif" border=0></p>
<p class=label>
<b>Figure 3. A hierarchical list</b></p>
<p>
This version is not quite as easy to read as the tree diagram, or even the tree diagram turned on its side, but it has one big advantage: It can be programmed using an owner-drawn list box. If you capitalize on some easily used features of Windows-based programming, you can implement a hierarchical data structure that looks like the one in Figure 4.</p>
<p>
<img src="hierlist_4.gif" border=0></p>
<p class=label>
<b>Figure 4. A list box displaying a hierarchical list</b></p>
<p>
With the addition of the icons, lines, and color, the list box display becomes almost as visually appealing as the tree diagram, but it requires a lot less programming effort. The display uses a standard list box control, so it can be easily added to a dialog box or other window—an additional advantage.</p>
<h2>Displaying a Hierarchy</h2>
<p>
Let's go through the steps involved in displaying a hierarchy in a list box. To make things easier I wrote some helper functions that any application can use. These functions are described in "The Helper Functions" section later in this article.</p>
<p>
Here are the steps needed to display a hierarchy using the helper functions:
<ul type=disc>
<li>
Design the hierarchy<br><br></li>
<li>
Create and initialize an owner-drawn list box<br><br></li>
<li>
Add items to the list box<br><br></li>
<li>
Handle the WM_DRAWITEM message<br><br></li>
<li>
Handle the WM_SYSCOLORCHANGE message<br><br></li>
<li>
Handle the WM_SETFONT message<br><br></li>
<li>
Handle opening and closing an item</li>
</ul>
<h3>Designing the Hierarchy</h3>
<p>
An application developer must first design the appearance of the hierarchy. The developer determines what types of items are in the hierarchy and how the icons that represent these items should look. A hierarchical display usually needs at least two icons:
<ul type=disc>
<li>
An icon for items that have children or are able to have children, but the children are not currently displayed. For example, the Windows File Manager uses a closed folder to indicate directories that are not expanded.<br><br></li>
<li>
An icon for items that have children, and the children are currently displayed. The File Manager uses an open folder to indicate directories that are expanded.</li>
</ul>
<p>
The display may use additional icons, and they may vary. The File Manager can display plain open and closed folders or, at the user's option, it can indicate which directories have subdirectories by displaying a closed folder with a "+" on it. The color of the icon can also vary. The Microsoft Developer Network CD's index window uses color to add visual variety to the index display. When choosing color combinations for a hierarchy, be sure to consider that many laptop and palmtop computers do not have color capability. Pick combinations that look good in monochrome and shades of gray.</p>
<p>
Once a developer knows which types of items will be displayed and establishes the corresponding icons and their variations, he or she can create a bitmap that contains the icons. Using one bitmap that contains all the icons (an icon bitmap) improves performance of the owner-drawn functions. The icons should be arranged in rows and columns within the bitmap; therefore, all icons must be the same size.</p>
<p>
There should be a column for each icon type and a row for each variation. This is not a hard and fast rule, however, because the application will designate the row and column numbers to determine which icon the drawing helper function will use to draw a particular item. Figure 5 shows the bitmap used in the sample application.</p>
<p>
<img src="hierlist_5.gif" border=0></p>
<p class=label>
<b>Figure 5. A sample icon bitmap</b></p>
<p>
The helper functions require the following:
<ul type=disc>
<li>
The bitmap must be a 16-color bitmap.<br><br></li>
<li>
The pixel at the lower-left corner of the bitmap must be in the background color. The initialization helper function uses this pixel to change the background color for the icons to the background color of the window (the helper function calls <b>GetSysColor</b>(COLOR_WINDOW) to obtain the background color of the window). Thus, the drawing routines do not need to do transparent bitblts when drawing each item, which greatly improves performance.</li>
</ul>
<p>
Once the bitmap is assembled, it must be linked into the application as a bitmap resource. For example, you could include the following line in the application's .RC file:</p>
<pre><code>IDR_HIERICONS bitmap Hiericon.bmp
</code></pre>
<h3>Creating and Initializing an Owner-Drawn List Box</h3>
<p>
The application must create a list box with the LBS_OWNERDRAWFIXED style and without the LBS_HASSTRINGS and LBS_SORT styles, either by using a dialog box or by calling <b>CreateWindow</b> (or <b>CreateWindowEx</b>) directly. For example, you could use the following statement in a .DLG file:</p>
<pre><code>LISTBOX&nbsp;&nbsp;&nbsp; IDLIST, 14, 10, 165, 195, LBS_OWNERDRAWFIXED |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LBS_WANTKEYBOARDINPUT | WS_VSCROLL
</code></pre>
<p>
Or you could use this call to <b>CreateWindow</b>:</p>
<pre><code>CreateWindow("LISTBOX", NULL, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LBS_OWNERDRAWFIXED | LBS_WANTKEYBOARDINPUT | 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_VSCROLL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14, 10, 165, 195,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwndParent, NULL, _hInstance, NULL);
</code></pre>
<p>
If you use the dialog box method, the application calls the <b>HierDraw_DrawInit</b> helper function to initialize the list box. A dialog procedure's WM_INITDIALOG handler cannot call this function because Windows sends a WM_MEASUREITEM message to a list box with the LBS_OWNERDRAWFIXED style before the dialog manager sends a WM_INITDIALOG message to the dialog procedure. The item height, which must be returned in response to the WM_MEASUREITEM message, is either the height of the text or the height of the bitmap, whichever is greater. Calling the initialization function before creating the dialog box provides a value (the bitmap height) that the list box can return with the WM_MEASUREITEM message. If the list box uses an alternate font, the dialog procedure can send a WM_MEASUREITEM message to the list box to adjust the item height when the dialog manager sends a WM_SETFONT message to the dialog procedure.</p>
<p>
The application must tell <b>HierDraw_DrawInit</b> the ID of the bitmap resource and how many rows and columns of icons there are in the bitmap. The helper functions also need the following information from the application:
<ul type=disc>
<li>
Whether the application wants the helper functions to draw connecting lines between items.<br><br></li>
<li>
A pointer to a <b>HIERDRAWSTRUCT</b> structure that the helper functions will use to store the data they need. The application must obtain the memory for this structure.<br><br></li>
<li>
Whether the application is calling <b>HierDraw_DrawInit</b> to initialize the list box or simply in response to a WM_SYSCOLORCHANGE message.</li>
</ul>
<p>
The following code shows how you can use <b>HierDraw_DrawInit</b> and other helper functions to initialize a list box within a dialog box:</p>
<pre><code>HIERDRAWSTRUCT HierDrawStruct;

int HLDialog_Do(HWND hwndOwner)
{
 &nbsp;&nbsp; int result;
 &nbsp;&nbsp; DLGPROC lpfndp;

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Initialize the HierDraw stuff.
 &nbsp;&nbsp; // Need to do this here so we have a value for WM_MEASUREITEM,
 &nbsp;&nbsp; // which is sent before the WM_INITDIALOG message.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; HierDraw_DrawInit(_hInstance,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDR_LISTICONS,&nbsp;&nbsp;&nbsp;&nbsp; // Bitmap resource ID.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rows in the bitmap.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Columns in the bitmap.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw connecting lines
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // between items?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;HierDrawStruct,&nbsp;&nbsp; // HierDrawStruct.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Initialize the list box.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );

 &nbsp;&nbsp; lpfndp = (DLGPROC)MakeProcInstance((FARPROC)HLDialog_DlgProc, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _hInstance);

 &nbsp;&nbsp; result = DialogBox(_hInstance,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAKEINTRESOURCE(IDHIERDLG),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwndOwner, lpfndp);

 &nbsp;&nbsp; FreeProcInstance((FARPROC)lpfndp);
 &nbsp;&nbsp; HierDraw_DrawTerm(&amp;HierDrawStruct);

 &nbsp;&nbsp; return result;
}
</code></pre>
<h3>Adding Items to the List Box</h3>
<p>
The application must store or access the hierarchical data and identify an item in the hierarchy with a 32-bit data value. This value can be a pointer to where the item is stored in memory, a record identifier for a database, an offset in a file, or any other value that the application can use to uniquely identify an item. The 32-bit data value is added to the list box with an LB_INSERTSTRING message. Use the application-supplied 32-bit data value in the <i>lParam</i> parameter in the <b>SendMessage</b> call instead of a far pointer to a string.</p>
<h3>Handling the WM_DRAWITEM Message</h3>
<p>
The <b>HierDraw_OnDrawItem</b> helper function does the drawing work for the application. The application calls this function whenever Windows sends the application a WM_DRAWITEM message. The application must pass these arguments to <b>HierDraw_OnDrawItem</b>:
<ul type=disc>
<li>
The list box's window handle.<br><br></li>
<li>
The <b>LPDRAWITEMSTRUCT</b> that Windows passed to the application.<br><br></li>
<li>
The level number for the item. The top of the hierarchy is level 0, the next level down is level 1, and so on.<br><br></li>
<li>
A <b>DWORD</b> that indicates the levels for which this item needs connecting lines. If the application does not want the helper functions to draw connecting lines, it ignores this parameter. Let's look at our hierarchical list box again.<p>
<img src="hierlist_6.gif" border=0></P><p class=tl>
Connecting lines link siblings. If a given item is the last child of its parent, it does not connect to a sibling below itself. For example, item 3129 above is the last child of item 3120 and therefore does not connect to the item below (item 3130).</P><p class=tl>
If an item's parent is a last child, this item does not have a connecting line for the parent level. This continues until the top of the hierarchy is reached.</P><p class=tl>
To indicate that an item needs a connecting line at a particular level, the application sets a bit in the <b>DWORD</b> argument. For children of level 0 items (items at level 1), bit 0 is set. For children of level 1 (items at level 2), bit 1 is set. This continues to the current item's level. The <b>DWORD</b> argument for item 3129 is 0x00000003, while the <b>DWORD</b> argument for item 3128 is 0x00000007.</P></li>
<li>
The text for the item.<br><br></li>
<li>
The row and column numbers for item's icon in the icon bitmap.<br><br></li>
<li>
A pointer to the HierDraw structure for the list box.</li>
</ul>
<p>
Here is the procedure that handles drawing an item for the HierList sample application, which displays the hierarchy of numbers shown in the above figure:</p>
<pre><code>void HLDialog_OnDrawItem(HWND hwnd, DRAWITEMSTRUCT FAR* lpDrawItem)
{
 &nbsp; char&nbsp; szText[128];
 &nbsp; DWORD dwData;
 &nbsp; int&nbsp;&nbsp; nLevel;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The level of the item.
 &nbsp; int&nbsp;&nbsp; nTempLevel;
 &nbsp; int&nbsp;&nbsp; nRow;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The row in the bitmap 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for the item's icon.
 &nbsp; int&nbsp;&nbsp; nColumn;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The column in the bitmap 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for the item's icon.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; DWORD dwConnectLevel = 0L;
 &nbsp; DWORD dwMask;
 &nbsp; DWORD dwLevelMask;
 &nbsp; DWORD dwLevelAdd;

 &nbsp; dwData = lpDrawItem-&gt;itemData;
 &nbsp; wsprintf(szText,"Item Number: %ld",dwData);

 &nbsp; //
 &nbsp; // Select the correct icon, open folder, closed folder, or 
 &nbsp; // document.
 &nbsp; //
 &nbsp; // Can this item be opened?
 &nbsp; //
 &nbsp; if ( dwData % 10 == 0 ) {
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // Is it open?
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; if ( HierDraw_IsOpened(&amp;HierDrawStruct, dwData) ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nColumn = 1;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nColumn = 0;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
 &nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp; nColumn = 2;
 &nbsp; }

 &nbsp; //
 &nbsp; // Select the correct level/color.
 &nbsp; // This sample changes the row of the bitmap (color) 
 &nbsp; // just because it can.
 &nbsp; //
 &nbsp; if ( dwData % 1000 == 0 ) {
 &nbsp;&nbsp;&nbsp;&nbsp; nLevel = 0;
 &nbsp;&nbsp;&nbsp;&nbsp; nRow = 0;
 &nbsp; }
 &nbsp; else if ( dwData % 100 == 0 ) {
 &nbsp;&nbsp;&nbsp;&nbsp; nLevel = 1;
 &nbsp;&nbsp;&nbsp;&nbsp; nRow = 1;
 &nbsp; }
 &nbsp; else if ( dwData % 10 == 0 ) {
 &nbsp;&nbsp;&nbsp;&nbsp; nLevel = 2;
 &nbsp;&nbsp;&nbsp;&nbsp; nRow = 2;
 &nbsp; }
 &nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp; nLevel = 3;
 &nbsp;&nbsp;&nbsp;&nbsp; nRow = 3;
 &nbsp; }

 &nbsp; //
 &nbsp; // Now build dwConnectLevel, which tells the helper function
 &nbsp; // the levels for this item that need connecting lines.
 &nbsp; // If this item is the last child or one of its parents
 &nbsp; // is a last child, it does not need a connector at that level.
 &nbsp; //
 &nbsp; if ( nLevel == 0 ) {
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // Level 0 items never have connectors.
 &nbsp;&nbsp;&nbsp;&nbsp; dwConnectLevel = 0L;
 &nbsp; }
 &nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // Check parents (grand, great, ...) to see it they are last 
 &nbsp;&nbsp;&nbsp;&nbsp; // children.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // Start at parent (one level up from here).
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; nTempLevel = nLevel-1;
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // First bit to set (or not).
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; dwMask = (DWORD) pow(2,nLevel-1);
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; dwLevelMask = (DWORD) pow(10,4-nLevel);
 &nbsp;&nbsp;&nbsp;&nbsp; dwLevelAdd&nbsp; = dwLevelMask / 10;

 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // While we are not at level 0.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; while ( nTempLevel &gt;= 0 ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Last child at this level?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( ((dwData+dwLevelAdd)%dwLevelMask) == 0 ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Last kid, so no connection at this level.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwConnectLevel &amp;= ~dwMask;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // NOT last kid, so connection at this level.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwConnectLevel |= dwMask;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Stuff for this sample, figure out next parent.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwLevelAdd&nbsp; *= 10;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwLevelMask *= 10;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwData = dwData-(dwData%dwLevelAdd);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Move mask bit over.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwMask /= 2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Move up one level.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nTempLevel--;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
 &nbsp; 
 &nbsp; //
 &nbsp; // All set to call drawing function.
 &nbsp; // 
 &nbsp; HierDraw_OnDrawItem(hwnd,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpDrawItem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nLevel,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwConnectLevel,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szText,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nRow,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nColumn,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;HierDrawStruct);
 &nbsp; return;
}
</code></pre>
<h3>Handling the WM_SYSCOLORCHANGE Message</h3>
<p>
The helper functions change the background of the icon bitmaps to the current window background color (COLOR_WINDOW). If the user changes the color of the window background, the icon bitmap background colors must also change. The application calls the <b>HierDraw_DrawInit</b> function with the last argument set to FALSE to change the icon bitmap backgrounds to the new window background color. For example, the application's main window procedure could handle the WM_SYSCOLORCHANGE message as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case WM_SYSCOLORCHANGE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HierDraw_DrawInit(_hInstance,&nbsp;&nbsp;&nbsp;&nbsp; // Instance.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDR_LISTICONS,&nbsp;&nbsp;&nbsp; // Bitmap ID.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROWS,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rows.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COLS,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Columns.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Loins.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;HierDrawStruct,&nbsp; // HierDrawStruct.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DON'T initialize open 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // folders.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
</code></pre>
<h3>Handling the WM_SETFONT Message</h3>
<p>
If the list box or dialog box receives a WM_SETFONT message specifying the font for drawing text, the application must call the <b>HierDraw_DrawSetTextHeight</b> helper function:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case WM_SETFONT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set the text height.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HierDraw_DrawSetTextHeight(hwndDlg,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDLIST,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (HFONT) wParam,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;HierDrawStruct);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
</code></pre>
<h3>Handling Opening and Closing an Item</h3>
<p>
The usual behavior for a hierarchical list box is:
<ul type=disc>
<li>
When the user double-clicks an item that has children but the children are not displayed, the list box "opens" the item by changing its icon and displaying the item's children. For example, File Manager changes the closed folder to an open folder and displays the contents of the folders.<br><br></li>
<li>
When the user double-clicks an item whose children are displayed, the list box "closes" the item by changing its icon and removing the item's children from the display. For example, File Manager changes the open folder to a closed folder, and the item's children are no longer displayed.<br><br></li>
<li>
When the user double-clicks an item that cannot have children, the application may display information about the item. The HierList sample application displays a message box when a nonparent item is double-clicked.</li>
</ul>
<p>
Four helper functions aid an application in opening and closing items:
<ul type=disc>
<li>
<b>HierDraw_OpenItem</b> adds a data value to a list of open items stored as 32-bit data values.<br><br></li>
<li>
<b>HierDraw_CloseItem</b> removes a 32-bit data value from the list of open items.<br><br></li>
<li>
<b>HierDraw_IsOpened</b> searches the list of open items for a data value that matches a specified value.<br><br></li>
<li>
<b>HierDraw_ShowKids</b> ensures that as many children as possible are visible when the application opens an item and adds the item's children to the display. This function also scrolls the list upward if necessary.</li>
</ul>
<p>
Here is the HierList sample application's open item and close item function:</p>
<pre><code>void ActionItem(HWND hWndList, DWORD dwData, WORD wItemNum)
{
 &nbsp; DWORD dwAddItem;
 &nbsp; DWORD dwIncr;
 &nbsp; WORD&nbsp; wCount;
 &nbsp; WORD&nbsp; wItem;

 &nbsp; //
 &nbsp; // Is this an item or a folder?
 &nbsp; //
 &nbsp; if ( (dwData % 10) ) {
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // Not a folder, just pop a box.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; MessageBox(hWndList, "Do something with this", 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Simon Says", MB_OK);
 &nbsp; }
 &nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp; // 
 &nbsp;&nbsp;&nbsp;&nbsp; // It's a folder, set up some junk for this sample app.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; if ( dwData % 1000 == 0 ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwIncr = 100;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else if ( dwData % 100 == 0 ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwIncr = 10;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else if ( dwData % 10 == 0 ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwIncr = 1;
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp; // 
 &nbsp;&nbsp;&nbsp;&nbsp; // Is it open?
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; if ( HierDraw_IsOpened(&amp;HierDrawStruct, dwData) ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // It's open ... close it.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HierDraw_CloseItem(&amp;HierDrawStruct, dwData);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Remove the child items. Close any children that are 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // open on the way.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No need for recursion. We just close everything along 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the way and remove items until we reach the next sibling 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the current item.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wItemNum++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwIncr = SendMessage(hWndList, LB_GETITEMDATA, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wItemNum, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( dwIncr &lt; dwAddItem ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( (dwIncr % 10) == 0 &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HierDraw_IsOpened(&amp;HierDrawStruct, dwIncr)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HierDraw_CloseItem(&amp;HierDrawStruct, dwIncr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage(hWndList, LB_DELETESTRING, wItemNum, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwIncr = SendMessage(hWndList, LB_GETITEMDATA, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wItemNum, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // It's closed ... open it.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HierDraw_OpenItem(&amp;HierDrawStruct, dwData);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Disable redrawing.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage(hWndList, WM_SETREDRAW, FALSE, 0L);&nbsp;&nbsp; 

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( wItem = wItemNum, dwAddItem = dwData+dwIncr, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wCount = 0, wItem++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wCount &lt; 9; wItem++, wCount++, dwAddItem+=dwIncr ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage(hWndList, LB_INSERTSTRING, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wItem, dwAddItem);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Make sure as many child items as possible are showing.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HierDraw_ShowKids(&amp;HierDrawStruct, hWndList, wItemNum, 9 );

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Enable, and force, redrawing.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage(hWndList, WM_SETREDRAW, TRUE, 0L);&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InvalidateRect(hWndList, NULL, TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
}
</code></pre>
<h2>The Helper Functions</h2>
<p>
This section describes the HierDraw structure and the helper functions that make it easier to display a hierarchy.</p>
<h3>The HierDraw Structure</h3>
<p>
An application needs a structure that communicates information between calls to the helper functions. HIERDRAW.H, included in the HierList sample application, defines the HierDraw structure, which communicates this information. The application needs to declare a static or global <b>HIERDRAWSTRUCT</b> variable.</p>
<h4>Syntax</h4>
<pre><code>typedef struct _HierDrawStruct {
 &nbsp;&nbsp; HDC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hdcMem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; HBITMAP&nbsp;&nbsp; hbmIcons;
 &nbsp;&nbsp; HBITMAP&nbsp;&nbsp; hbmMem;
 &nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nBitmapHeight;
 &nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nBitmapWidth;
 &nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nTextHeight;
 &nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nLineHeight;
 &nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bLines;
 &nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumOpened;
 &nbsp;&nbsp; DWORD FAR *Opened;
} HIERDRAWSTRUCT;

typedef HIERDRAWSTRUCT FAR *&nbsp; LPHIERDRAWSTRUCT ;
</code></pre>
<h4>Parameters</h4>
<p class=dt>
hdcMem</p>
<p class=indent>
Handle to the memory device context (DC) that contains the icon bitmaps.</p>
<p class=dt>
hbmIcons</p>
<p class=indent>
Handle to the device-independent icon bitmap.</p>
<p class=dt>
hbmMem</p>
<p class=indent>
Handle to the memory icon bitmap.</p>
<p class=dt>
nBitmapHeight</p>
<p class=indent>
Height of an icon in the icon bitmap.</p>
<p class=dt>
nBitmapWidth</p>
<p class=indent>
Width of an icon in the icon bitmap.</p>
<p class=dt>
nTextHeight</p>
<p class=indent>
Height of the text used in the list box.</p>
<p class=dt>
NLineHeight</p>
<p class=indent>
Height of the item lines in the list box. This is either the bitmap height (<i>nBitmapHeight</i>) or the text height (<i>nTextHeight</i>), whichever is greater.</p>
<p class=dt>
bLines</p>
<p class=indent>
Flag that designates whether the helper functions should draw connecting lines between items in the list box.</p>
<p class=dt>
NumOpened</p>
<p class=indent>
Number of open items in the list box.</p>
<p class=dt>
Opened</p>
<p class=indent>
Pointer to a list of open items.</p>
<h3>HierDraw_DrawInit</h3>
<p>
This function is responsible for:
<ul type=disc>
<li>
Loading the icon bitmap resource.<br><br></li>
<li>
Creating and initializing the memory DC containing the icon bitmap.<br><br></li>
<li>
Setting the number of rows and columns of icons in the bitmap.<br><br></li>
<li>
Selecting the line-drawing options.<br><br></li>
<li>
Optionally, initializing the data values needed by the helper functions.</li>
</ul>
<p>
The application must call <b>HierDraw_DrawInit</b> either before the application creates the dialog box that contains the list box or before it creates a child list box.</p>
<h4>Syntax</h4>
<pre><code>BOOL HierDraw_DrawInit(HINSTANCE hInstance,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; nBitmap,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; nRows,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; nColumns,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL bLines,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPHIERDRAWSTRUCT lpHierDrawStruct,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL bInit);
</code></pre>
<h4>Parameters</h4>
<p class=dt>
hInstance</p>
<p class=indent>
Application's instance handle.</p>
<p class=dt>
nBitmap</p>
<p class=indent>
Integer identifier for the bitmap resource that contains the icon bitmap.</p>
<p class=dt>
nRows</p>
<p class=indent>
Number of rows in the icon bitmap.</p>
<p class=dt>
nColumns</p>
<p class=indent>
Number of columns in the icon bitmap.</p>
<p class=dt>
bLines</p>
<p class=indent>
Flag that specifies whether the list box should have connecting lines between items. If this parameter is TRUE, the list box will have connecting lines. If this parameter is FALSE, no lines will be drawn.</p>
<p class=dt>
lpHierDrawStruct</p>
<p class=indent>
Pointer to the HierDraw structure for this list box, which is filled in by <b>HierDraw_DrawInit</b>.</p>
<p class=dt>
bInit</p>
<p class=indent>
Flag that indicates whether to reload the icon bitmap or to initialize the HierDraw structure's data fields. If this parameter is TRUE, the data fields are initialized; otherwise, they are not. <b>HierDraw_DrawInit</b> should also be called with the <i>bInit</i> parameter set to FALSE in response to a WM_SYSCOLORCHANGE message.</p>
<p>
This function returns TRUE if successful. Otherwise, it returns FALSE.</p>
<h3>HierDraw_DrawTerm</h3>
<p>
This function cleans up any "leftovers" from the helper functions. It should be called when the list box or dialog box is destroyed.</p>
<h4>Syntax</h4>
<pre><code>VOID HierDraw_DrawTerm(LPHIERDRAWSTRUCT lpHierDrawStruct);
</code></pre>
<h4>Parameter</h4>
<p class=dt>
lpHierDrawStruct</p>
<p class=indent>
Pointer to the HierDraw structure for this list box.</p>
<h3>HierDraw_DrawSetTextHeight</h3>
<p>
This function sets the text height of the items in the list box. If necessary, <b>HierDraw_DrawSetTextHeight</b> will adjust the height of the items in the list box by sending a WM_MEASUREITEM message to the list box.</p>
<h4>Syntax</h4>
<pre><code>VOID HierDraw_DrawSetTextHeight (HWND hwnd, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; nTextHeight, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPHIERDRAWSTRUCT lpHierDrawStruct);
</code></pre>
<h4>Parameters</h4>
<p class=dt>
hwnd</p>
<p class=indent>
Window handle to the list box.</p>
<p class=dt>
nTextHeight</p>
<p class=indent>
Height of the text used in the list box.</p>
<p class=dt>
lpHierDrawStruct</p>
<p class=indent>
Pointer to the HierDraw structure for this list box.</p>
<h3>HierDraw_OnDrawItem</h3>
<p>
This function does the actual drawing of an item in the list box. The application calls <b>HierDraw_OnDrawItem</b> when Windows sends it a WM_DRAWITEM message.</p>
<h4>Syntax</h4>
<pre><code>VOID HierDraw_OnDrawItem(HWND&nbsp; hwnd,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const DRAWITEMSTRUCT FAR* lpDrawItem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; nLevel,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwConnectLevel,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp; *szText,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; nRow,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; nColumn,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPHIERDRAWSTRUCT lpHierDrawStruct);
</code></pre>
<h4>Parameters</h4>
<p class=dt>
hwnd</p>
<p class=indent>
Window handle to the list box.</p>
<p class=dt>
lpDrawItem</p>
<p class=indent>
Pointer to a <b>DRAWITEMSTRUCT</b> that the application received from Windows.</p>
<p class=dt>
nLevel</p>
<p class=indent>
Level of the current item.</p>
<p class=dt>
dwConnectLevel</p>
<p class=indent>
Contains bits that indicate the levels for which the current item needs connecting lines. Bit 0 designates whether the current item requires a connecting line for the children of level 0; bit 1 designates whether the current item requires a connecting line for the children of level 1; and so on.</p>
<p class=dt>
szText</p>
<p class=indent>
Text for the current item.</p>
<p class=dt>
nRow</p>
<p class=indent>
Row number for the current item's icon in the icon bitmap.</p>
<p class=dt>
nColumn</p>
<p class=indent>
Column number for the current item's icon in the icon bitmap.</p>
<p class=dt>
lpHierDrawStruct</p>
<p class=indent>
Pointer to the HierDraw structure for this list box.</p>
<h3>HierDraw_OnMeasureItem</h3>
<p>
This function processes a WM_MEASUREITEM message for the list box. The application calls <b>HierDraw_OnMeasureItem</b> when Windows sends it a WM_MEASUREITEM message.</p>
<h4>Syntax</h4>
<pre><code>VOID HierDraw_OnMeasureItem(HWND hwnd, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEASUREITEMSTRUCT FAR* lpMeasureItem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPHIERDRAWSTRUCT lpHierDrawStruct);
</code></pre>
<h4>Parameters</h4>
<p class=dt>
hwnd</p>
<p class=indent>
Window handle to the list box.</p>
<p class=dt>
lpMeasureItem</p>
<p class=indent>
Pointer to a <b>MEASUREITEMSTRUCT</b> that Windows sent to the application.</p>
<p class=dt>
lpHierDrawStruct</p>
<p class=indent>
Pointer to the HierDraw structure for this list box.</p>
<h3>HierDraw_IsOpened</h3>
<p>
The application calls this function to determine if the specified item is in the list of open items.</p>
<h4>Syntax</h4>
<pre><code>BOOL HierDraw_IsOpened(LPHIERDRAWSTRUCT lpHierDrawStruct, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwData);
</code></pre>
<h4>Parameters</h4>
<p class=dt>
lpHierDrawStruct</p>
<p class=indent>
Pointer to the HierDraw structure for this list box.</p>
<p class=dt>
dwData</p>
<p class=indent>
32-bit data value of the item.</p>
<p>
This function returns TRUE if the item is in the open item list. Otherwise, it returns FALSE.</p>
<h3>HierDraw_OpenItem</h3>
<p>
The application calls this function to add a value to the list of open item values.</p>
<h4>Syntax</h4>
<pre><code>VOID HierDraw_OpenItem(LPHIERDRAWSTRUCT lpHierDrawStruct, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwData);
</code></pre>
<h4>Parameters</h4>
<p class=dt>
lpHierDrawStruct</p>
<p class=indent>
Pointer to the HierDraw structure for this list box.</p>
<p class=dt>
dwData</p>
<p class=indent>
32-bit data value to be added.</p>
<h3>HierDraw_CloseItem</h3>
<p>
The application calls this function to remove a value from the list of open item values.</p>
<h4>Syntax</h4>
<pre><code>VOID HierDraw_CloseItem(LPHIERDRAWSTRUCT lpHierDrawStruct, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwData);
</code></pre>
<h4>Parameters</h4>
<p class=dt>
lpHierDrawStruct</p>
<p class=indent>
Pointer to the HierDraw structure for this list box.</p>
<p class=dt>
dwData</p>
<p class=indent>
32-bit data value to be removed.</p>
<h3>HierDraw_ShowKids</h3>
<p>
The application calls this function when it opens an item to ensure that as many children as possible are visible.</p>
<h4>Syntax</h4>
<pre><code>VOID HierDraw_ShowKids(LPHIERDRAWSTRUCT lpHierDrawStruct,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hwndList, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD wCurrentSelection, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD wKids);
</code></pre>
<h4>Parameters</h4>
<p class=dt>
lpHierDrawStruct</p>
<p class=indent>
Pointer to the HierDraw structure for this list box.</p>
<p class=dt>
hwndList</p>
<p class=indent>
Window handle to the list box.</p>
<p class=dt>
wCurrentSelection</p>
<p class=indent>
Index number of the current item.</p>
<p class=dt>
wKids</p>
<p class=indent>
Number of children of the current item.</p>
<h3>HierDraw_DrawCloseAll</h3>
<p>
The application calls this function to remove all the values from the list of open items.</p>
<h4>Syntax</h4>
<pre><code>VOID HierDraw_DrawCloseAll(LPHIERDRAWSTRUCT lpHierDrawStruct );
</code></pre>
<h4>Parameter</h4>
<p class=dt>
lpHierDrawStruct</p>
<p class=indent>
Pointer to the HierDraw structure for this list box.</p>
<h2>So How Does It Work?</h2>
<p>
The <b>HierDraw_DrawInit</b>, <b>HierDraw_OnDrawItem</b>, and <b>FastRect</b> functions contain the interesting part of displaying a hierarchy (most of the other code is boring). Let's take a look at these functions.</p>
<h3>HierDraw_DrawInit</h3>
<p>
The <b>HierDraw_DrawInit</b> function creates a memory DC that is compatible with the screen to hold the list's bitmap. It loads the bitmap using the <b>FindResource</b>, <b>LoadResource</b>, and <b>LockResource</b> functions, and receives a pointer to the <b>BITMAPINFOHEADER</b> structure for the bitmap. <b>HierDraw_DrawInit</b> then adjusts the background color of the bitmap by reading the color code for the bitmap's lower-left pixel and adjusting the bitmap's color table entry for that pixel to the current window background color. The lower-left pixel is located right after the bitmap's color table, which comes right after the bitmap's <b>BITMAPINFOHEADER</b> structure. <b>HierDraw_DrawInit</b> assumes that the bitmap is a 16-color bitmap, so the lower-left pixel is easily determined.</p>
<p>
Here is the source for <b>HierDraw_DrawInit</b>:</p>
<pre><code>BOOL HierDraw_DrawInit(HINSTANCE hInstance,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; nBitmap,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; nRows,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; nColumns,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL bLines,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPHIERDRAWSTRUCT lpHierDrawStruct,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL bInit)
{
 &nbsp;&nbsp; HANDLE hRes;
 &nbsp;&nbsp; HANDLE hResMem;
 &nbsp;&nbsp; LPBITMAPINFOHEADER lpbi;
 &nbsp;&nbsp; DWORD FAR * lpColorTable;
 &nbsp;&nbsp; LPSTR lpBits;
 &nbsp;&nbsp; int bc;
 &nbsp;&nbsp; HDC hDC;

 &nbsp;&nbsp; if ( bInit ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpHierDrawStruct-&gt;NumOpened = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpHierDrawStruct-&gt;Opened = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpHierDrawStruct-&gt;bLines = bLines;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // If the memory DC is not created yet, do that first.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (!lpHierDrawStruct-&gt;hdcMem) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get a screen DC.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDC = GetDC(NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a memory DC compatible with the screen.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpHierDrawStruct-&gt;hdcMem = CreateCompatibleDC(hDC);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Release the screen DC.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReleaseDC(NULL,hDC);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!lpHierDrawStruct-&gt;hdcMem)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpHierDrawStruct-&gt;hbmMem = NULL;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // (Re)Load the bitmap (original from disk).
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Use the FindResource, LoadResource, and LockResource 
 &nbsp;&nbsp; // functions since it makes it easy to get the pointer to the 
 &nbsp;&nbsp; // BITMAPINFOHEADER we need.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //
 &nbsp;&nbsp; hRes = FindResource(hInstance, MAKEINTRESOURCE(nBitmap), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RT_BITMAP);
 &nbsp;&nbsp; if (!hRes)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp;&nbsp; hResMem = LoadResource(hInstance, hRes);
 &nbsp;&nbsp; if (!hResMem)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Now figure out the bitmap's background color.
 &nbsp;&nbsp; // This code assumes these are 16-color bitmaps
 &nbsp;&nbsp; // and that the lower-left corner is a bit in the background
 &nbsp;&nbsp; // color.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //
 &nbsp;&nbsp; lpbi = (LPBITMAPINFOHEADER)LockResource(hResMem);
 &nbsp;&nbsp; if (!lpbi)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp;&nbsp; lpColorTable = (DWORD FAR *)(lpbi + 1);

 &nbsp;&nbsp; lpBits = (LPSTR)(lpColorTable + 16);&nbsp;&nbsp; // Assumes 16 color.

 &nbsp;&nbsp; bc = (lpBits[0] &amp; 0xF0) &gt;&gt; 4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Assumes 16 color.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Also assumes lower-
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // left corner is 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // background color!!!

 &nbsp;&nbsp; lpColorTable[bc] = RGB2BGR(GetSysColor(COLOR_WINDOW));

 &nbsp;&nbsp; hDC = GetDC(NULL);

 &nbsp;&nbsp; lpHierDrawStruct-&gt;hbmIcons = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateDIBitmap(hDC,lpbi,(DWORD)CBM_INIT,lpBits, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPBITMAPINFO)lpbi,DIB_RGB_COLORS);
 &nbsp;&nbsp; ReleaseDC(NULL,hDC);

 &nbsp;&nbsp; lpHierDrawStruct-&gt;nBitmapHeight = (WORD)lpbi-&gt;biHeight / nRows;
 &nbsp;&nbsp; lpHierDrawStruct-&gt;nBitmapWidth = (WORD)lpbi-&gt;biWidth / nColumns;

 &nbsp;&nbsp; lpHierDrawStruct-&gt;nLineHeight =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max(lpHierDrawStruct-&gt;nBitmapHeight, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpHierDrawStruct-&gt;nTextHeight);

 &nbsp;&nbsp; UnlockResource(hResMem);
 &nbsp;&nbsp; FreeResource(hResMem);

 &nbsp;&nbsp; if (!lpHierDrawStruct-&gt;hbmIcons)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp;&nbsp; lpHierDrawStruct-&gt;hbmMem = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SelectObject(lpHierDrawStruct-&gt;hdcMem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpHierDrawStruct-&gt;hbmIcons);
 &nbsp;&nbsp; if (!lpHierDrawStruct-&gt;hbmMem)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<h3>HierDraw_OnDrawItem</h3>
<p>
The <b>HierDraw_OnDrawItem</b> function is a straightforward drawing routine for an owner-drawn list box. It calculates the offsets within the item's rectangle, which Windows supplies in <b>DRAWITEMSTRUCT</b>, for the item's indent, bitmap, and text, based on the level of the item.</p>
<p>
If the hierarchy wants lines drawn to connect items, <b>HierDraw_OnDrawItem</b> checks the corresponding bit in the <b>dwConnectLevel</b> field for the item's level and each of its parent levels. If the corresponding bit is set in <b>dwConnectLevel</b>, <b>HierDraw_OnDrawItem</b> draws a vertical connecting line. At the item's level and for each parent level, <b>HierDraw_OnDrawItem</b> draws a horizontal line connecting the vertical line to the item's text.</p>
<p>
<b>HierDraw_OnDrawItem</b> draws an icon for each item by calling <b>BitBlt</b> to copy the bitmap from the memory device context to the list box's device context.</p>
<p>
If the item is selected, <b>HierDraw_OnDrawItem</b> draws the text with the current highlight colors; otherwise, it uses the current window and text colors to draw the text.</p>
<p>
If the item has the focus and is not selected, <b>HierDraw_OnDrawItem</b> draws a focus rectangle by calling <b>DrawFocusRect</b>.</p>
<p>
Here is the source for <b>HierDraw_OnDrawItem</b>:</p>
<pre><code>VOID HierDraw_OnDrawItem(HWND&nbsp; hwnd,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const DRAWITEMSTRUCT FAR* lpDrawItem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; nLevel,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwConnectLevel,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp; *szText,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; nRow,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; nColumn,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPHIERDRAWSTRUCT lpHierDrawStruct)
{
 &nbsp;&nbsp; HDC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hDC;
 &nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wIndent, wTopBitmap, wTopText;
 &nbsp;&nbsp; RECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcTemp;

 &nbsp;&nbsp; if ( lpDrawItem-&gt;itemID == (UINT)-1 )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ;

 &nbsp;&nbsp; hDC = lpDrawItem-&gt;hDC;
 &nbsp;&nbsp; CopyRect(&amp;rcTemp, &amp;lpDrawItem-&gt;rcItem);

 &nbsp;&nbsp; wIndent = rcTemp.left + ((int)(nLevel) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * lpHierDrawStruct-&gt;nBitmapWidth) + XBMPOFFSET;

 &nbsp;&nbsp; rcTemp.left = wIndent + lpHierDrawStruct-&gt;nBitmapWidth;

 &nbsp;&nbsp; wTopText = rcTemp.top + ((rcTemp.bottom - rcTemp.top) / 2) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - (lpHierDrawStruct-&gt;nTextHeight / 2);

 &nbsp;&nbsp; wTopBitmap = rcTemp.top + ((rcTemp.bottom - rcTemp.top) / 2) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - (lpHierDrawStruct-&gt;nBitmapHeight / 2);

 &nbsp;&nbsp; if (lpDrawItem-&gt;itemAction == ODA_FOCUS)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto DealWithFocus;
 &nbsp;&nbsp; else if (lpDrawItem-&gt;itemAction == ODA_SELECT)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto DealWithSelection;

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Draw some lions, if we like lions.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; if (lpHierDrawStruct-&gt;bLines &amp;&amp; nLevel)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; dwMask = 1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nTempLevel;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x,y;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw lines in text color.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetBkColor(hDC,GetSysColor(COLOR_WINDOWTEXT));

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw a series of vertical lines (|) for outer levels.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = lpHierDrawStruct-&gt;nBitmapWidth/2 + XBMPOFFSET;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( nTempLevel = 0; nTempLevel &lt; nLevel ; nTempLevel++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( dwConnectLevel &amp; dwMask )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FastRect(hDC,x,rcTemp.top,1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcTemp.bottom - rcTemp.top);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += lpHierDrawStruct-&gt;nBitmapWidth;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwMask *= 2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw the short vertical line up toward the parent.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nTempLevel = nLevel-1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwMask *= 2;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = nTempLevel * lpHierDrawStruct-&gt;nBitmapWidth 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + lpHierDrawStruct-&gt;nBitmapWidth / 2 + XBMPOFFSET;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( dwConnectLevel &amp; dwMask )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = rcTemp.bottom;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = rcTemp.bottom - lpHierDrawStruct-&gt;nLineHeight / 2;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FastRect(hDC,x,rcTemp.top,1,y-rcTemp.top);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw a short horizontal bar to the right.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FastRect(hDC,x,rcTemp.bottom-lpHierDrawStruct-&gt;nLineHeight/2 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,lpHierDrawStruct-&gt;nBitmapWidth/2,1);
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Draw the selected bitmap.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; BitBlt(hDC,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wIndent,wTopBitmap,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpHierDrawStruct-&gt;nBitmapWidth,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpHierDrawStruct-&gt;nBitmapHeight,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpHierDrawStruct-&gt;hdcMem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nColumn*lpHierDrawStruct-&gt;nBitmapWidth,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nRow*lpHierDrawStruct-&gt;nBitmapHeight,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SRCCOPY);

DealWithSelection:

 &nbsp;&nbsp; if (lpDrawItem-&gt;itemState &amp; ODS_SELECTED)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetBkColor(hDC,GetSysColor(COLOR_HIGHLIGHT));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTextColor(hDC,GetSysColor(COLOR_HIGHLIGHTTEXT));
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetBkColor(hDC,GetSysColor(COLOR_WINDOW));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTextColor(hDC,GetSysColor(COLOR_WINDOWTEXT));
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; ExtTextOut(hDC, rcTemp.left + 1, wTopText, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ETO_CLIPPED|ETO_OPAQUE,&amp;rcTemp, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szText,lstrlen(szText), NULL);

 &nbsp;&nbsp; if (lpDrawItem-&gt;itemState &amp; ODS_FOCUS &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpDrawItem-&gt;itemAction != ODA_SELECT) {
DealWithFocus:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawFocusRect(hDC, &amp;rcTemp);
 &nbsp;&nbsp; }

}
</code></pre>
<h3>FastRect</h3>
<p>
So what's the fastest way to draw a rectangle? Use <b>ExtTextOut </b>without a text string to improve drawing performance.</p>
<pre><code>static VOID near FastRect(HDC hDC, int x, int y, int cx, int cy)
{
 &nbsp;&nbsp; RECT rc;

 &nbsp;&nbsp; rc.left = x;
 &nbsp;&nbsp; rc.right = x+cx;
 &nbsp;&nbsp; rc.top = y;
 &nbsp;&nbsp; rc.bottom = y+cy;
 &nbsp;&nbsp; ExtTextOut(hDC,x,y,ETO_OPAQUE,&amp;rc,NULL,0,NULL);
}
</code></pre>
<p>
<b>FastRect</b>, an internal function in the helper functions, is just a little tidbit to improve drawing performance. And using the helper functions is an easy way to add hierarchical list boxes to your application.</p>
</BODY>
</HTML>
