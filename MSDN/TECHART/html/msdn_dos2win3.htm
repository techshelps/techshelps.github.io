<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Moving Your Game to Windows, Part III:  Sound, Graphics, Installation, and Documentation</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_dos2win3"></a></sup>Moving Your Game to Windows, Part III: <br>
Sound, Graphics, Installation, and Documentation</h1>
<p>
Peter Donnelly<br>
Microsoft Corporation</p>
<p>
November 25, 1996</p>
<p>
<i>Peter Donnelly has been a game designer since 1972 and a programmer since 1984. He has authored four "paper" games with historical and fantasy themes, and his computer design credits include three interactive comic-book adventures and one full-scale adventure game. He has also developed shareware games and game editors for MS-DOS and Windows.</i></p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5038">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the Moby 3 sample application.</a></p>
<h2>Abstract</h2>
<p>
This third, and last, in my series of articles on converting MS-DOS® games to the Microsoft Win32® environment introduces digitized sound effects, MIDI music, TrueType text, and animation with DirectDraw®. I’ll also touch on the subjects of installation and online documentation.</p>
<p>
It is assumed that you have a general understanding of game design, along with MS-DOS programming skills with C or C++, and are familiar with the basics of Windows-based programming.</p>
<h2>Moby Dick—The Chase Continues</h2>
<p>
In Parts I and II of this series I introduced a simple MS-DOS game called Moby Dick and took it through the first stages of development for the Win32 environment.&nbsp; For this article, I’ve added more features to the version for the Windows platform: stereo sound effects, MIDI music, TrueType fonts, and DirectDraw graphics with transparent sprites. To keep the source files from getting too big, I’ve stripped out some of the code that was meant to illustrate specific issues covered in the first two articles.</p>
<p>
As you know if you have been reading this series, Moby Dick is not intended as a serious game or even as an example of sophisticated game programming. It is merely a vehicle for some examples of implementing specific features. The latest version is more sophisticated than its predecessors, but it lacks some obvious refinements like in-between animation (that is, smooth movement of sprites).</p>
<p>
The interface hasn’t changed from version 2. If you have a joystick attached to your computer, it is automatically enabled except when mouse movement is turned on. You can control the ship’s speed with the joystick throttle. To implement mouse-controlled movement, you have to click <b>Mouse Movement</b> on the <b>Settings</b> menu.</p>
<p>
I haven’t made any enhancements to the MS-DOS version of the game, so this time it’s not included with the sample files. It’s still in the packages that come with <a href="msdn_dos2win.htm">"Moving Your Game to Windows, Part I: Tools, Game Loop, Keyboard Input, and Timing"</a> and <a href="msdn_dos2win2.htm">"Moving Your Game to Windows, Part II: Mouse and Joystick Input."</a></p>
<p>
Moby Dick is written for Windows® 95 only, not Windows NT®. Because the game now uses DirectDraw for the graphics routines, you must have DirectX™ installed on your system in order to run it. Since the runtime files required for a proper installation of DirectX amount to more than 15 megabytes, I thought it best not to include them with the sample code.</p>
<p>
The supplied executable file uses DirectSound®. To build the program without DirectSound support, comment out the “#define USE_DIRECTSOUND” line in MOBY.CPP. I’ve provided this option so you can compare DirectSound with the old way of playing sounds in Windows.</p>
<p>
I’ve made one small but important change to the code for the main program loop. I talked about the advantages of using <b>PeekMessage</b> in real-time games in Part I. However, I did not take into account the fact that the <b>PeekMessage</b> loop gobbles up CPU time even when the application is in the background and theoretically not doing anything. So I’ve added a call to <b>WaitMessage</b> when Moby Dick is paused. This function suspends the thread until there is a message in the queue.</p>
<h2>Sound</h2>
<h3>.VOC-to-.WAV Conversion</h3>
<p>
If you're converting an MS-DOS game to Windows, chances are your sound files are in .VOC format. You will want to convert these to .WAV format, the standard for Windows.</p>
<p>
Many freeware and shareware utilities are available for converting 8-bit VOC files to .WAV files; check the Windows AV forum (WINAV) on CompuServe or the vast programming-related archive at ftp://x2ftp.oulu.fi/pub/msdos/programming. You may already have a utility that came with your sound card; for instance, the Sound Blaster comes with VOC2WAV.EXE.</p>
<h3>Playing Waves with PlaySound</h3>
<p>
The benefits of Windows are nowhere more obvious than in playing digitized sound, as my own experience illustrates. For this article, I meant to develop some routines for the MS-DOS version of Moby Dick that would at least work with Sound Blaster and Sound Blaster–compatible cards. After spending a day tracking down and unsuccessfully tinkering with code samples (most of them generously sprinkled with inline assembler), I finally gave up and turned to the Windows-based version of my project. Within minutes, I had a .WAV file compiled into the executable and playing loud and clear—and I knew it would work with <i>any</i> sound card installed in Windows.</p>
<p>
My first step was to play the sound directly from a .WAV file. This is all I needed to do to get Moby to “blow” audibly:</p>
<pre><code>PlaySound("blow.wav", NULL, SND_ASYNC | SND_FILENAME);
</code></pre>
<p>
The arguments are: (1) the name of the file; (2) NULL for the handle of the executable containing the resource because we’re not using a compiled resource; and (3) flags to ensure that the function returns as soon as possible, rather than waiting for the sound to finish, and that the first argument is interpreted as a file name.</p>
<p>
Later I decided to make the sound data a resource that would be compiled into the executable. That meant adding this line to the resource (.RC) file:</p>
<pre><code>IDR_WAVE_BLOW&nbsp; WAVE&nbsp; "blow.wav"
</code></pre>
<p>
IDR_WAVE_BLOW is a numerical ID that I have defined in the RESOURCE.H include file. WAVE is my own application-defined (and arbitrarily named) resource type. Waves are not standard resources like icons and bitmaps, so a type name must be assigned.</p>
<p>
When it comes time to play the sound from the resource, this line of code does the trick:</p>
<pre><code>PlaySound(MAKEINTRESOURCE(IDR_WAVE_BLOW), hTheInstance, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SND_ASYNC | SND_RESOURCE);
</code></pre>
<p>
Here, the first argument is the resource name (supplied by the macro <b>MAKEINTRESOURCE</b> from the numerical identifier). The second argument is the handle of the module that contains the resource (in the case of Moby, the main program instance). The last flag has been changed to indicate that the first argument is a resource name rather than a file name.</p>
<h3>Playing Waves with DirectSound</h3>
<p>
<b>PlaySound</b> is adequate for playing simple waves at discrete points in a game, but it doesn't allow on-the-fly mixing or any other effects. There is a group of functions in the multimedia extensions to the Windows application programming interface (API), most of whose names begin with <b>wave</b>, that allow more advanced tinkering, but these have been superseded by DirectSound, a component of the DirectX Software Development Kit (SDK). DirectSound 3 has several advanced features, including automatic mixing, 3D sound (the illusion of "surround sound" on a two-speaker system), and stereo panning. I won't go into the finer points here, but I'll give you a glimpse of the benefits—and the extra overhead—that come with DirectSound.</p>
<p>
First the bad news. DirectSound doesn't provide the behind-the-scenes loading and parsing capabilities of <b>PlaySound</b>. It's your responsibility to parse the .WAV file and copy the data into a DirectSound secondary buffer. (<i>Secondary buffers</i> hold the wave data in the background. When the sounds are played, they're streamed into a <i>primary buffer</i>. You don't have to concern yourself with the primary buffer, which is maintained by DirectSound.) My sample project does the loading and parsing in WAVE.CPP, where the sound data is loaded from a resource. The code is quite lengthy, so I won't quote it here. Similar code for reading directly from .WAV files is found in Dave Edson's article "Get World-Class Noise and Total Joy from Your Games with DirectSound and DirectInput," (MSDN Library, <i>Microsoft Systems Journal</i>, 1996, volume 11) from which most of WAVE.CPP has been borrowed.</p>
<p>
Now the good news: once the DirectSound secondary buffer has been set up, things get simple again. To play the sound, just call the <b>Play</b> method of the DIRECTSOUNDBUFFER object:</p>
<pre><code>lpDSB_Blow-&gt;Play(0, 0, 0);
</code></pre>
<p>
The first two arguments are always zero in current versions of DirectSound. The third argument can be set to DSBPLAY_LOOPING if you want to keep repeating the sound.</p>
<p>
Moby Dick for Windows illustrates how to loop a sound and shows the different results of <b>PlaySound</b> and DirectSound's <b>Play</b> method when two .WAV files are vying for attention. Turn the sound on through the <b>Settings</b> menu and click the left button to start a “boing” sound. (This is the sound of Queequeg’s harpoon, which is on a bungee cord.) Stop the sound with the right mouse button. If you compiled the program with USE_DIRECTSOUND defined (or are using the supplied executable), the "boing" and Moby's heavy breathing are mixed by DirectSound and play simultaneously. If you didn't define USE_DIRECTSOUND, Moby will be silenced by the looping sound, because <b>PlaySound</b> can only do one thing at a time.</p>
<p>
I think you'll agree that the automatic mixing feature is reason enough to use DirectSound in your game, without even considering its many other capabilities. However, before leaving the topic of DirectSound I'll show you how to implement a simple stereo effect, just to demonstrate how easy it is to enhance the sound effects in your game when you convert to Windows.</p>
<p>
Presuming you have a stereo sound card, when playing the DirectSound version of Moby you will notice that the whale's audible blow moves in space depending on whether the spout is toward the right or the left of the game screen. Each time Moby takes a breath, the program simply calculates his relative east-west position on a scale of -10,000 to 10,000. Then it passes this integer value to the <b>SetPan</b> method for the buffer, thus:</p>
<pre><code>lpDSB_Blow-&gt;SetPan(pan);
</code></pre>
<p>
This is done just before <b>Play</b> is called. DirectSound automatically attenuates the playback on one channel or the other in proportion to the deviation of <b>pan</b> from zero. While the first channel is attenuated, the other remains at full volume. In other words, both channels are at full volume when Moby Dick is at dead center in his world; one channel is silent when he is fully to the west or east.</p>
<h3>Playing MIDI Files</h3>
<p>
Through its multimedia API, Windows provides both high-level and low-level support for playback of MIDI files. The high-level support is in the form of media control interface (MCI) functions. These will work with MIDI formats 0 and 1, but not with 2.</p>
<p>
The MCI functions can actually be called in two different ways. The <b>mciSendString</b> function lets you control the MIDI sequencer (or any media player) with string commands that hardly look like computer code. Here’s an example that opens the sequencer and readies a file for playback:</p>
<pre><code>mciSendString(
 &nbsp;&nbsp; "open song.mid type sequencer alias aria", 
 &nbsp;&nbsp; lpszReturnString, lstrlen(lpszReturnString), NULL);
</code></pre>
<p>
The call defines the file name, the device type, and an alias (“aria” in the example) which can be used in subsequent calls that will play, pause, or otherwise control the playback of the data.</p>
<p>
More familiar looking to C++ programmers are the equivalent orders issued through <b>mciSendCommand</b>:</p>
<pre><code>MCI_OPEN_PARMS&nbsp; mciOpenParms;
MCI_PLAY_PARMS&nbsp; mciPlayParms;
DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwReturn;

mciOpenParms.lpstrDeviceType = "sequencer";
mciOpenParms.lpstrElementName = "song.mid";
dwReturn = mciSendCommand(NULL, MCI_OPEN,
 &nbsp;&nbsp;&nbsp;&nbsp; MCI_OPEN_TYPE | MCI_OPEN_ELEMENT,
 &nbsp;&nbsp;&nbsp; (DWORD)(LPVOID) &amp;mciOpenParms));
</code></pre>
<p>
You can see a simple implementation of <b>mciSendCommand</b> in MOBY.CPP. The program simply plays a tune from beginning to end, at which time the Windows operating system sends a message to the application. The program’s response to the message is to play the tune again.</p>
<p>
A lower-level approach to playing MIDI files is illustrated in CGMIDI.CPP, which can be found among the source files for the “Immortal Klowns” sample in the DirectX SDK. This example does not use MCI but loads the music file into memory and streams it to the MIDI sequencer using the Windows MIDI stream services—not quite as efficient as custom-built sequencing code but more efficient than MCI. Preloading the data is the preferred method if you don't want your program accessing the hard drive—or, worse, the CD—during game play.</p>
<p>
You may be able to salvage much of your existing code for streaming to the sequencer under MS-DOS (allowing for the difference in implementing timers under Windows). You are, however, welcome to use the routines in CGMIDI.CPP with or without modification—Microsoft has granted a royalty-free license for this code.</p>
<p>
As for sound effects, by now it's probably safe to assume that game players running Windows 95 have sound cards capable of playing digitized sound. However, if you want to use General MIDI to create some simple sound effects such as trumpet calls, you have many happy hours in front of you studying the API reference for the low-level MIDI functions. A good place to start is <b>midiOutShortMessage</b>.</p>
<h2>Graphics</h2>
<p>
Here we are, halfway through the third article in the series, and at last we reach the subject of graphics. I’m not going to attempt a short course in animation techniques in Windows 95; for that I refer you to the many books on the topic. (New titles are appearing in quick succession as I write this. Check out the Microsoft DirectX Web site at <a href="http://www.microsoft.com/directx/default.asp">http://www.microsoft.com/directx/</a> as well as the shelves of your bookstore.) What I will do is touch on some key areas where programming for Windows differs from programming in the MS-DOS environment.</p>
<h3>Palettes</h3>
<p>
In this brief discussion I will presume you’re designing for 256-color modes. Two key palette issues have to be considered when porting the graphics from your MS-DOS game to Windows.</p>
<p>
First, if your game is not going to run full screen, it will need to live with other programs that have their own palettes. Say your program displays a bitmap that uses 150 colors. In the background there is another application or perhaps desktop wallpaper that uses 200 colors, and Windows itself is reserving 20 colors for the caption bars, menus, and other items. That makes for a total of 370 colors that need to be displayed simultaneously in a 256-color mode.</p>
<p>
How does Windows handle this demand? Essentially, it mediates among different applications by making minor adjustments to colors—in other words, by reducing those 370 colors to 256. Nigel Thompson has explained the process more lucidly than I can, so I’ll simply quote from Chapter 3 of his <i>Animation Techniques in Win32</i>:</p>
<p class=indent>
<i>The application currently in the foreground gets first choice in choosing the set of colors in the actual physical hardware palette. By giving the foreground application first choice of the palette colors, the system keeps the user happy most of the time because the application that is getting most of the user’s attention is the one that gets to select the color set. Applications in the background have to make do with the colors they’re given, but Windows helps the background applications out a bit by trying to accommodate their color needs too. If the foreground application hasn’t used all the free hardware palette color entries, the background applications get to use the remaining entries on a first-come-first-served basis. When all the free slots are used up, Windows tries to map the colors requested by the background applications to those currently set in the hardware. This accommodation results in a recognizable, if not wonderful, rendition of the background application’s images.</i></p>
<p>
Now, what is the practical effect of all this on the game developer? If your application uses DirectDraw in full-screen mode, none at all. But for a game in a window, your choice of colors may have side effects.</p>
<p>
Some years ago, there was a wonderful adventure game called Loom that was written for the Extended Graphics Adapter (EGA). (For you youngsters, the EGA could display 16 colors at a time out of a total palette of 64.) The designers of this game overcame the limitations of 16 colors by creating story locales in thematic hues—for instance, an emerald city that used all the greens available in the 64-color palette while discarding other colors that were not needed for the persistent elements of the interface.</p>
<p>
If you did something like this in a Windows-based game—say, created a wonderful, realistic forest scene using 150 shades of green—then Windows might have a very hard time trying to map background colors to the available palette, and the photo of a red sunset being used for desktop wallpaper could suddenly look like Junior’s first attempt at paint-by-numbers. By the same token, your forest scene might be reduced to mud when it was in the background. Not a huge problem, perhaps, but a side effect that you may want to consider.</p>
<p>
Consideration number two—and this <i>is</i> a big one—is the 20 system or “static” colors that Windows reserves unto itself. It guards these jealously, and if your game uses 256 different colors, it’s too bad for you—20 of those colors will be mapped to the reserved colors, with results that may or may not be pleasing to the eye. So you have to either restrict your artists to 236 colors or ensure that the static colors are present in the palette for every scene. For maximum performance you also want to ensure that the static colors are in the palette slots where Windows expects to find them. See Chapter 6 of <i>Animation Techniques in Win32</i> for details on how to create an “identity palette” that has the static colors in the correct positions.</p>
<p>
There’s a lot more to palette management on the Windows platform, and I recommend that you read up on the subject if you are porting a graphics-intensive game. Thompson’s book is an excellent place to start.</p>
<h3>Fonts</h3>
<h4>Graphical fonts vs. TrueType fonts</h4>
<p>
For display text in your MS-DOS game, you no doubt created one or more alphabets as large bitmaps and used an algorithm for finding characters in the font and displaying them with the correct proportional spacing. This technique will still work in Windows, of course, where you could put each font in its own DirectDraw surface buffer for quick blitting to the offscreen display buffer.</p>
<p>
The alternative is TrueType, the scalable font technology built right into Windows. You will probably be using TrueType fonts in standard dialog boxes, but you can use them as part of your graphical screens as well. The benefits are ready-made fonts and scalability; the disadvantage is that you’re restricted to the standard typefaces that come with Windows 95 plus any others that you’re willing to license and distribute with your game.</p>
<p>
Moby Dick contains a very simple example of placing TrueType text directly on a bitmap. Any DirectDraw surface can be treated as a drawing surface for the graphical device interface (GDI), which is the set of functions used to display text and graphics in conventional programming for Windows. When the Moby Dick graphics are initialized, some text is put into the DirectDraw surface that holds the master copy of the ocean chart. The text becomes part of the bitmap. Whenever this image is blitted into the back buffer, or from the back buffer to the primary surface, the text goes along with it.</p>
<p>
Here’s the code that sets up the ocean chart and writes the text to it:</p>
<pre><code>// create the chart surface
lpDDS_Map =
 &nbsp;&nbsp; DDLoadBitmap(lpDD, MAKEINTRESOURCE(IDB_MAP), 0, 0);&nbsp;&nbsp;&nbsp; 
// get a device context for it. This also locks the surface.
lpDDS_Map-&gt;GetDC(&amp;hdc);
// set transparent mode so text won’t wipe out whole rectangle
SetBkMode(hdc, TRANSPARENT);
// "create" (i.e. choose) the desired font
hFont = EzCreateFont(hdc, "Times New Roman", 150, 0, EZ_ATTR_ITALIC, 0);
// select it into the device context
SelectObject(hdc, hFont);
// write the text
TextOut(hdc, 50, 50, "Here be Whales", 14);
// delete the font object.
DeleteObject(SelectObject(hdc, GetStockObject(SYSTEM_FONT)));
// release the device context and unlock the surface
lpDDS_Map-&gt;ReleaseDC(hdc);
</code></pre>
<p>
Looks pretty simple, right? Actually, much of the functionality is hidden in the call to <b>EzCreateFont</b> (in TTFONT.CPP), a function lifted pretty much intact from Charles Petzold’s <i>Programming Windows 95.</i> I refer you to pages 217-37 of that excellent book for a full treatment of selecting TrueType fonts and formatting text output.</p>
<h4>Large and small system fonts</h4>
<p>
When you use the standard system font under MS-DOS, you can design the screen confident that an end user will see the same thing you see on your development machine. Not so in Windows. Quite apart from the fact that your game will be played in different screen resolutions, a user may choose large or small system fonts for the higher resolutions and any system fonts in your program will be scaled accordingly. I have seen computer games that overlook this fact, with the result that text is not properly aligned or it simply doesn’t fit in its window when displayed on a system using large fonts.</p>
<p>
With the certainty that at least the standard TrueType fonts are going to be available on any Win32 system, there really isn’t much reason to use system fonts in your game. But if you do, be sure to design and test for both the large and small sizes.</p>
<h3>Animation with DirectDraw</h3>
<p>
In the first of these articles I promised that I would eventually implement a DirectDraw graphics system for Moby Dick. I’ve made good on my promise, but I’m not going to go into DirectDraw in depth. For one thing, it’s a big subject; for another, there’s no shortage of articles and books on it.</p>
<p>
Is it necessary to use DirectDraw? If your game has heavy animation, don’t even think of the alternatives. DirectDraw provides a huge gain in performance over the GDI or WinG—performance equal to or even exceeding that possible under MS-DOS, depending on which hardware features are available on the user’s machine. As I said at the beginning of this article, however, the runtime files take up a lot of real estate, so DirectX is not yet a practical tool for shareware game developers.</p>
<p>
From the standpoint of conversion of existing MS-DOS graphics code to DirectDraw, here are a couple of things to keep in mind.
<ul type=disc>
<li>
You don’t need any special code to blit with transparency. Not only does DirectDraw handle this automatically, but, if you choose, it will even figure out the color key (that is, transparent color) by checking the upper-left pixel of the sprite. See DRAW.CPP in the Moby Dick files for an example.<br><br></li>
<li>
Memory management is a different kettle of fish under Windows and DirectDraw. You can forget about expanded memory, extended memory, high memory, low memory, and all that. But you will want to get up to speed on the way DirectDraw takes advantage of memory on the graphics card. You can optimize performance by making sure frequently used images get stored on the card rather than in system memory.</li>
</ul>
<p>
One unusual characteristic of Moby Dick for Windows as a DirectDraw application is that it is not full screen. Since most DirectDraw tutorials focus on full-screen games, I’ll point out a few things that are different here:
<ul type=disc>
<li>
You can’t flip surfaces in a windowed application. (DirectDraw flipping is similar to video-page flipping under MS-DOS.) Bitmaps have to be copied from one surface to another.<br><br></li>
<li>
It follows from the point above that there can’t be any background (that is, flipping) surfaces attached to the primary surface. You can’t use the DDSD_BACKBUFFERCOUNT flag when creating the primary surface.<br><br></li>
<li>
The primary surface doesn’t know anything about the client area of your application. The <b>Blt</b> method writes to screen coordinates, so it’s up to you to get the client area’s location and size with <b>GetClientRect</b> and <b>ClientToScreen</b>.<br><br></li>
<li>
To keep anything from being drawn outside the client area, you need to create a clipper object and attach it to both your window and the DirectDraw primary surface.</li>
</ul>
<h2>Installation</h2>
<p>
Installation of any software under Windows is a bit trickier than under MS-DOS because of the way resources are shared. A well-mannered Windows-based game will also register itself and provide an uninstall utility to clean up after itself in the event that (heaven forbid!) users want to kick it off the hard drive. (See Teri Schiele’s article listed in the bibliography for an overview of the requirements for installing a program in Windows.)</p>
<p>
It’s not a good use of your development time to create an installation program from scratch or attempt to port over your old one when there are so many alternatives available, mostly involving small changes to sample code. To begin with, if you’re using DirectX, you will almost certainly want to take advantage of DirectSetup, which comes free with the DirectX SDK; this is the most bulletproof way of making sure that the DirectX runtime files are properly installed along with your own files. If you’re not using DirectX, you may already have another installation utility that shipped with your development system.</p>
<p>
If you don’t have an installation system or simply want to see what others are available, you can check out the <a href="http://www.yahoo.com/Business_and_Economy/Companies/Computers/Software/System_Utilities/Utilities/Installers/">Yahoo! listings</a>.</p>
<h2>Online Documentation</h2>
<p>
I’m a little hesitant about plunging into this section, because I don’t want to be seen as encouraging game publishers not to supply printed documentation. Personally, when I buy a game I like find something in the box besides a CD and a registration card. Give me a substantial printed booklet—preferably with lots of tables, photos, diagrams, background information, and designer’s notes—that I can carry around and study at odd moments. Sure, put the last-minute information into a readme file, but don’t leave me feeling like I bought the cake without the icing.</p>
<p>
Despite my own feelings, it’s a fact of life that publishers are ruled by “cost of goods,” and it’s becoming more and more common to see only the basics of game play covered in a printed manual (if one is provided at all), while the finer points are covered in readme files or some other form of documentation on a CD. This trend is bound to gather momentum in the Windows environment, where online information can easily be presented with rich formatting and graphics.</p>
<p>
In this section I’ll suggest a few alternatives for documentation that are not readily available in the MS-DOS world.</p>
<h3>Windows Help</h3>
<p>
You can produce Windows Help files in Microsoft Word or any other word processor that provides full support for Rich Text Format (RTF); this does not include WordPad, which does not allow page breaks or hidden text, both of which are necessary in Help source files. You also need a Help compiler, usually included with Windows development tools; in the case of Microsoft Visual C++®, it is the Help Workshop (HCW.EXE) that also simplifies the creation of graphical hot spots and tables of contents.</p>
<h3>RTF</h3>
<p>
Your game is for Windows 95. Every copy of Windows 95 comes with WordPad. WordPad reads Rich Text Format (.RTF) files. Therefore your on-disk documentation can be in .RTF format.</p>
<p>
The concept is simple, but for some reason—perhaps WordPad’s limited support for .RTF?—it hasn’t caught on and developers keep using plain ASCII text for their readme files. In doing so, they lose the benefits of varied font sizes and styles, paragraph spacing, and other formatting that can make the text both easier to understand and more attractive.</p>
<p>
You can use Microsoft Word or WordPad to create RTF files. Remember, though, that any page breaks and margins you create in Word will be lost when the file is displayed in WordPad.</p>
<h3>HTML</h3>
<p>
The Hypertext Markup Language (HTML) is rapidly becoming much more than a World Wide Web formatting tool. Microsoft is moving the Windows Help system to HTML, and as Internet Explorer becomes more tightly integrated with the Windows desktop, the day is probably not far off when HTML becomes the dominant tool for online documentation.</p>
<p>
Using the HTML Help tools from Microsoft, you can provide documentation in HTML format without worrying about whether the user has a Web browser. The latest information is available in the "Authoring" section of the <i>Microsoft SiteBuilder Workshop </i>at <a href="http://www.microsoft.com/workshop/default.asp">http://www.microsoft.com/workshop/</a>.</p>
<p>
If you want to convert files from another format to HTML, or vice versa, check out the list of filters at <a href="http://www.utoronto.ca/webdocs/">http://www.utoronto.ca/webdocs/</a>. This site also links to lists of HTML editors and other utilities.</p>
<h3>PDF </h3>
<p>
Another alternative for richly formatted online documentation is the Portable Document Format (PDF) supported by the Adobe family of Acrobat products. The format is very much oriented toward display and printing. One advantage of .PDF files is that they will look the same on different platforms. However, you’ll have to install Acrobat Reader along with your game in order to ensure that users can view the documents. </p>
<p>
In the future, Internet browsers may have the ability to read .PDF files directly, which will make this format a more attractive alternative for all types of online documentation. For now, though, it is best suited for documents with a lot of graphics and a need for precise layout.</p>
<p>
You can get more information about Acrobat at <a href="http://www.adobe.com/acrobat/">http://www.adobe.com/acrobat/</a>.</p>
<h2>Acknowledgments</h2>
<p>
The supplied music is the “Sacred Dance of the Priestesses” from Giuseppe Verdi’s <i>Aida</i> and is used with the permission of Rajat Mathur, the transcriber. The file was obtained from <a href="http://www.prs.net/midi.html">http://www.prs.net/midi.html</a>, a wonderful source of classical music in MIDI format.</p>
<h2>Bibliography </h2>
<p>
Edson, Dave. "Get World-Class Noise and Total Joy from Your Games with DirectSound and DirectInput." <i>Microsoft Systems Journal </i>11 (February 1996) (MSDN Library, Periodicals). It only covers version 1 of DirectSound, but it is still a useful introduction.</p>
<p>
Gery, Ron. <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_palette">
</object><a href=JavaScript:alink_1.Click()>"The Palette Manager: How and Why."</a>(MSDN Library, Technical articles)</p>
<p>
Klopfenstein, Doug. <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_directd5">
</object><a href=JavaScript:alink_2.Click()>"Basics of DirectDraw Game Programming."</a>(MSDN Library, Technical articles)</p>
<p>
Norton, Michael J. <i>Spells of Fury: Building Windows 95 Games Using DirectX 2</i>. Waite Group Press, 1996.</p>
<p>
Petzold, Charles. <i>Programming Windows 95</i>. Microsoft Press, 1996.</p>
<p>
Schiele, Teri. <object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_setup">
</object><a href=JavaScript:alink_3.Click()>"Windows 95 Application Setup Guidelines for Independent Software Vendors."</a> (MSDN Library, Technical articles)</p>
<p>
Thompson, Nigel. <i>Animation Techniques in Win32</i>. Microsoft Press, 1995. Covers sounds (CD audio, waveform, and MIDI) as well as animation and palettes.</p>
</BODY>
</HTML>
