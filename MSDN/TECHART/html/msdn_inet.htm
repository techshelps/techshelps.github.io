<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Building an Internet Browser Using the Win32 Internet Functions</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1></h1>

<h1><sup><a name="msdn_inet"></a></sup>Building an Internet Browser Using the Win32 Internet Functions</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
April 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4894">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the SurfBear sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This technical article discusses how to build an Internet browser using the Microsoft® Win32® Internet functions. The purpose of this article is to give the reader some idea of the use, power, and scope of the Win32 Internet functions, not to provide exhaustive documentation for these functions. The SurfBear sample application accompanying this article uses the Win32 Internet functions to read HTML files from an Internet server and to display them as raw, unformatted text.</p>
<h2>Introduction</h2>
<p>
To paraphrase a friend of mine, you can't swing a squid without hitting the Internet. Computer magazines have devoted issues, and local newspapers have dedicated entire sections to the Internet. In fact, many newspapers are going online. Everyone seems to have a personal home page; even some homeless people have home pages. While much of the information printed about the Internet is hype, it's obvious that the Internet is becoming an integral part of computing.</p>
<p>
Microsoft has introduced the Microsoft® Win32® Internet functions to assist developers in making the Internet an integral part of their applications. These new functions simplify accessing the Internet using FTP (File Transfer Protocol), Gopher, and HTTP (HyperText Transfer Protocol). Developers who use the Win32 Internet functions do not need to be familiar with TCP/IP or Windows® Sockets. For many common operations, developers need not know the details of the particular protocol they are using.</p>
<p>
Eventually, the Win32 Internet functions will become part of the Win32 application programming interface (API) and ship with the various Windows-based platforms. Initially, the Win32 Internet functions will ship in a redistributable dynamic-link library called WININET.DLL (available from the Microsoft Internet SDK site at <a href="http://www.microsoft.com/intdev/sdk/">http://www.microsoft.com/intdev/sdk/</a>) section of the Internet Development Toolbox Web site).</p>
<p>
This article explains how to use the Win32 Internet functions to build a simple Internet browser. The article does not discuss the functions in intimate detail, but it does give a preview of their use and operation. Please refer to the Microsoft Win32 Internet Functions site at <a href="http://www.microsoft.com/intdev/sdk/docs/wininet/">http://www.microsoft.com/intdev/sdk/docs/wininet/</a> topic for complete details.</p>
<p>
This article is accompanied by the SurfBear sample application that I wrote. SurfBear takes an HTTP address for an HTML file, connects to the server, downloads the HTML file, and displays the raw HTML file in an edit control. The article covers the Internet-specific portions of this process. It does not cover the display or manipulation of HTML files or the user interface issues involved in this process.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This article is based on a very early version of WININET.DLL. It is very likely that the names of parameters, flags, and functions will change. However, the scope and intent of the functions should remain the same, as presented in this article.</p>
<h2>The Internet Functions</h2>
<p>
The best way to approach the Win32 Internet functions is to jump right into the code. The code below is sample code, with error handling removed for readability.</p>
<pre><code>HINTERNET hNet = ::InternetOpen("MSDN SurfBear",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRE_CONFIG_INTERNET_ACCESS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_INVALID_PORT_NUMBER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0) ;

HINTERNET hUrlFile = ::InternetOpenUrl(hNet,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "http://www.microsoft.com",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_FLAG_RELOAD,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0) ;

char buffer[10*1024] ;
DWORD dwBytesRead = 0;
BOOL bRead = ::InternetReadFile(hUrlFile,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(buffer),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwBytesRead);

::InternetCloseHandle(hUrlFile) ;

::InternetCloseHandle(hNet) ;
</code></pre>
<p>
The code listing above contains four Internet functions: <b>InternetOpen</b>, <b>InternetOpenUrl</b>, <b>InternetReadFile</b>, and <b>InternetCloseHandle</b>. Let's examine each of these functions in turn.</p>
<h3>InternetOpen</h3>
<p>
<b>InternetOpen </b>initializes WININET.DLL. It is called before any other Win32 Internet function.</p>
<pre><code>HINTERNET hNet = ::InternetOpen(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "MSDN SurfBear",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1 LPCTSTR lpszCallerName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRE_CONFIG_INTERNET_ACCESS,&nbsp;&nbsp; // 2 DWORD dwAccessType
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3 LPCTSTR lpszProxyName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_INVALID_PORT_NUMBER, // 4 INTERNET_PORT nProxyPort
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 5 DWORD dwFlags
) ;
</code></pre>
<p>
<b>InternetOpen </b>returns a handle of type <b>HINTERNET</b>. Other Win32 Internet functions take this handle as a parameter. Currently, you cannot use an <b>HINTERNET</b> handle with other Win32 functions such as <b>ReadFile</b>. This may change in the future, as Internet support is moved into the Microsoft Windows® and Microsoft Windows NT® operating systems.</p>
<p>
When you are finished using the Win32 Internet functions, you should call <b>InternetCloseHandle</b> to free the resources allocated by <b>InternetOpen</b>. Applications that use the Microsoft Foundation Class Library (MFC) will typically call <b>InternetOpen</b> from the document's constructor. Most applications will call <b>InternetOpen</b> once per process.</p>
<p>
The first parameter to <b>InternetOpen</b>, <i>lpszCallerName</i>, identifies the application that is using the Internet functions. This name becomes the user agent when the HTTP protocol is used.</p>
<p>
The second parameter, <i>dwAccessType</i>, specifies the access type. In the example above, the PRE_CONFIG_INTERNET_ACCESS access type instructs the Win32 Internet functions to use registry information to find a server. Using PRE_CONFIG_INTERNET_ACCESS requires the registry to be set up properly. I cheated here and let Internet Explorer set the registry up for me. If you don't want to cheat, you need to set up the registry as shown in Figure 1.</p>
<p>
<img src="inet_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Setting up the registry</b></p>
<p>
In the registry, setting <b>AccessType</b> to 1 means "go directly to the net." Setting <b>AccessType</b> to 2 means "use a gateway." Setting <b>DisableServiceLocation</b> to 1 causes it to use one of the named servers; otherwise, a server is found using the Registration and Name Resolution (RNR) APIs, which are part of Windows Sockets.</p>
<p>
Additional access types include the following:
<ul type=disc>
<li>
LOCAL_INTERNET_ACCESS connects exclusively to local internet sites. For example, if I use this flag with SurfBear, I can only access the Microsoft internal internet sites.<br><br></li>
<li>
GATEWAY_INTERNET_ACCESS allows connections to the World Wide Web. I can use this access type to access any site on the Web.<br><br></li>
<li>
CERN_PROXY_INTERNET_ACCESS uses a CERN proxy to access the Web. A CERN proxy is a Web server that acts as a gateway and can forward HTTP requests to the intended server.</li>
</ul>
<p>
The GATEWAY_INTERNET_ACCESS and CERN_PROXY_INTERNET_ACCESS access types require the third parameter to <b>InternetOpen</b>: the server name (<i>lpszProxyName</i>). PRE_CONFIG_INTERNET_ACCESS doesn't require a server name because it looks in the registry for the server.</p>
<p>
The <i>nProxyPort</i> parameter is used for CERN_PROXY_INTERNET_ACCESS and specifies the port number to use. Using INTERNET_INVALID_PORT_NUMBER is the same as supplying the default port number.</p>
<p>
The last parameter, <i>dwFlags</i>, sets additional options. You can use the INTERNET_FLAG_ASYNC flag to indicate that future Internet functions using the returned handle will send status information to a callback function, which is set using <b>InternetSetStatusCallback</b>.</p>
<h3>InternetOpenUrl</h3>
<p>
Once you initialize the Win32 Internet functions, you can use other Internet functions. The next Internet function to call is <b>InternetOpenUrl</b>. This function connects to an Internet server and prepares for reading data from the server. <b>InternetOpenUrl</b> can work with FTP, Gopher, or HTTP protocols. In this article, we are concerned only with the HTTP protocol.</p>
<pre><code>HINTERNET hUrlFile = ::InternetOpenUrl(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hNet,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1 HINTERNET hInternetSession
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "http://www.microsoft.com", // 2 LPCTSTR lpszUrl
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3 LPCTSTR lpszHeaders
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4 DWORD dwHeadersLength
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_FLAG_RELOAD,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 5 DWORD dwFlags
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 6 DWORD dwContext
) ;
</code></pre>
<p>
<b>InternetOpenUrl</b> also returns an <b>HINTERNET</b>, which is passed to functions operating on this URL. You should use <b>InternetCloseHandle</b> to close this handle.</p>
<p>
The first parameter to <b>InternetOpenUrl</b>, <i>hInternetSession</i>, is the handle returned from <b>InternetOpen</b>. The second parameter, <i>lpszUrl</i>, is the URL of the resource that we want. In the example above, we would like to get Microsoft's Web page. The next two parameters, <i>lpszHeaders</i> and <i>dwHeadersLength</i>, are used to send additional information to the server. These parameters require knowledge of the particular protocol being used.</p>
<p>
<i>dwFlags</i> is a flag that can modify the behavior of <b>InternetOpenUrl</b> in several ways, including turning off caching, enabling raw data, and using existing connections instead of opening new connections.</p>
<p>
The last parameter, <i>dwContext</i>, is a <b>DWORD</b> context value that will be sent to the status callback function if one is specified. If this value is zero, information will not be sent to the status callback function.</p>
<h3>InternetReadFile</h3>
<p>
You read a file after opening it, so it's only logical that the next function should be <b>InternetReadFile</b>:</p>
<pre><code>char buffer[10*1024] ;
DWORD dwBytesRead = 0;
BOOL bRead = ::InternetReadFile(
 &nbsp;&nbsp;&nbsp; hUrlFile,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1 HINTERNET hFile
 &nbsp;&nbsp;&nbsp; buffer,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2 LPVOID lpBuffer
 &nbsp;&nbsp;&nbsp; sizeof(buffer),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3 DWORD dwNumberOfBytesToRead
 &nbsp;&nbsp;&nbsp; &amp;dwBytesRead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4 LPDWORD lpdwNumberOfBytesRead
);

buffer[dwBytesRead] = 0 ;
pEditCtrl-&gt;SetWindowText(buffer) ;
</code></pre>
<p>
<b>InternetReadFile</b> takes the handle returned by <b>InternetOpenUrl</b>. It also works with the handles returned by other Win32 Internet functions, such as <b>FtpOpenFile</b>, <b>GopherOpenFile</b>, and <b>HttpOpenRequest</b>.</p>
<p>
The remaining three parameters to <b>InternetReadFile</b> are also very straightforward. <i>lpBuffer</i> is a void pointer to a buffer that will hold the data, and <i>dwNumberOfBytesToRead</i> specifies the buffer size in bytes. The final parameter, <i>lpdwNumberOfBytesRead</i>, is a pointer to a variable that will contain the number of bytes read into the buffer. If the return value is True and <i>lpdwNumberOfBytesRead </i>points to a zero, the file has read to the end of the file. This behavior is identical to that of the Win32 <b>ReadFile</b> function. A real Web browser would loop on <b>InternetReadFile</b>, reading in blocks of data from the Internet.</p>
<p>
To display the buffer, append a zero to the buffer and send it to an edit control.</p>
<p>
Together, <b>InternetOpen</b>, <b>InternetOpenUrl</b>, and <b>InternetReadFile</b> build the foundation of an Internet browser. They make reading files off the Internet as easy as reading them off your local hard drive.</p>
<h2>The HTTP Functions</h2>
<p>
In some instances, <b>InternetOpenUrl</b> is too generic, so you will need other Win32 Internet functions. <b>InternetOpenUrl </b>is a wrapper for various FTP, Gopher, and HTTP functions. When using HTTP, <b>InternetOpenUrl </b>calls <b>InternetConnect</b>, <b>HttpOpenRequest</b>, and <b>HttpSendRequest</b>. Let's say that we want to get the size of the HTML page before downloading it so that we can allocate a buffer in the exact size. <b>HttpQueryInfo</b> will get the size of the Web page.</p>
<p>
A word of caution: Not all Web pages support getting the page size. (For example, www.toystory.com and www.movielink.com don't support this functionality.) Also, TCP/IP can send less data than requested. Therefore, your application should handle both of these cases and loop around <b>InternetReadFile</b> until the result is True and <b>*</b><i>lpdwNumberOfBytesRead</i> is 0.</p>
<p>
The code to open the file http://www.microsoft.com/msdn/msdninfo/ using <b>HttpOpenRequest</b>, <b>HttpSendRequest</b>, and <b>HttpQueryInfo</b> is shown below. The error checking has been removed.</p>
<pre><code>// Open Internet session.
HINTERNET hSession = ::InternetOpen("MSDN SurfBear",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRE_CONFIG_INTERNET_ACCESS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_INVALID_PORT_NUMBER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0) ;

// Connect to www.microsoft.com.
HINTERNET hConnect = ::InternetConnect(hSession,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "www.microsoft.com",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_INVALID_PORT_NUMBER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_SERVICE_HTTP,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0) ;

// Request the file /MSDN/MSDNINFO/ from the server.
HINTERNET hHttpFile = ::HttpOpenRequest(hConnect,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "GET",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "/MSDN/MSDNINFO/",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HTTP_VERSION,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_FLAG_DONT_CACHE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0) ;

// Send the request.
BOOL bSendRequest = ::HttpSendRequest(hHttpFile, NULL, 0, 0, 0);

// Get the length of the file.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
char bufQuery[32] ;
DWORD dwLengthBufQuery = sizeof(bufQuery);
BOOL bQuery = ::HttpQueryInfo(hHttpFile,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HTTP_QUERY_CONTENT_LENGTH, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bufQuery, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwLengthBufQuery) ;

// Convert length from ASCII string to a DWORD.
DWORD dwFileSize = (DWORD)atol(bufQuery) ;

// Allocate a buffer for the file.&nbsp;&nbsp; 
char* buffer = new char[dwFileSize+1] ;

// Read the file into the buffer. 
DWORD dwBytesRead ;
BOOL bRead = ::InternetReadFile(hHttpFile,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwFileSize+1, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwBytesRead);
// Put a zero on the end of the buffer.
buffer[dwBytesRead] = 0 ;

// Close all of the Internet handles.
::InternetCloseHandle(hHttpFile); 
::InternetCloseHandle(hConnect) ;
::InternetCloseHandle(hSession) ;

// Display the file in an edit control.
pEditCtrl-&gt;SetWindowText(buffer) ;
</code></pre>
<h3>InternetConnect</h3>
<p>
The <b>InternetConnect</b> function connects to an HTTP, FTP, or Gopher server:</p>
<pre><code>HINTERNET hConnect = ::InternetConnect(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hSession,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //1 HINTERNET hInternetSession
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "www.microsoft.com",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //2 LPCTSTR lpszServerName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_INVALID_PORT_NUMBER, //3 INTERNET_PORT nServerPort
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //4 LPCTSTR lpszUsername
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //5 LPCTSTR lpszPassword
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_SERVICE_HTTP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //6 DWORD dwService
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //7 DWORD dwFlags
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //8 DWORD dwContext
) ;
</code></pre>
<p>
The sixth parameter, <i>dwService</i>, determines the service type (HTTP, FTP, or Gopher). In the example above, <b>InternetConnect</b> connects to an HTTP server because <i>dwService </i>is set to INTERNET_SERVICE_HTTP. The second parameter (set to www.microsoft.com) provides the address of the server. Notice that the HTTP address must be parsed for the server name; <b>InternetOpenUrl</b> parses it for us. The first parameter, <i>hInternetSession</i>, is the handle returned from <b>InternetOpen</b>. The fourth and fifth parameters supply a username and password. None of the flags controlled by the seventh parameter affect HTTP operations. The last parameter supplies contextual information to the status callback function.</p>
<h3>HttpOpenRequest</h3>
<p>
Once a connection has been established with a server, we open the desired file. The <b>HttpOpenRequest</b> and <b>HttpSendRequest</b> functions work together to open the file. <b>HttpOpenRequest</b> creates a request handle and stores the parameters in the handle. <b>HttpOpenRequest</b> sends the request parameters to the HTTP service.</p>
<pre><code>HINTERNET hHttpFile = ::HttpOpenRequest(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hConnect,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1 HINTERNET hHttpSession
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "GET",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2 LPCTSTR lpszVerb
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "/MSDN/MSDNINFO/",&nbsp;&nbsp;&nbsp;&nbsp; // 3 LPCTSTR lpszObjectName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HTTP_VERSION,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4 LPCTSTR lpszVersion
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 5 LPCTSTR lpszReferer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 6 LPCTSTR FAR * lplpszAcceptTypes
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_FLAG_DONT_CACHE,&nbsp; // 7 DWORD dwFlags
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 8 DWORD dwContext
) ;
</code></pre>
<p>
By now, many of the parameters to the Internet functions will look familiar. The first parameter to <b>HttpOpenResult</b> is the <b>HINTERNET</b> returned by <b>InternetConnect</b>. The seventh and eighth parameters to <b>HttpOpenRequest</b> perform the same functions as the <b>InternetConnect</b> parameters that share these names.</p>
<p>
The second parameter ("GET") specifies that we want to get the object named by the third parameter ("/MSDN/MSDNINFO/"). The HTTP version is passed to the fourth parameter; currently, this must be HTTP_VERSION. Because "GET" is the most popular verb type, <b>HttpOpenRequest</b> will take a NULL pointer for this parameter.</p>
<p>
The fifth parameter, <i>lpszReferer</i>, is the address of the site where we found the URL we now want to see. In other words, if you're on www.home.com and you click a link that jumps to www.microsoft.com, the fifth parameter is "www.home.com," because it refers you to the target URL. This value can be NULL. The sixth parameter points to a list of content types that our program accepts. Passing null to <b>HttpOpenRequest</b> informs the server that only text documents are accepted.</p>
<h3>HttpSendRequest</h3>
<p>
In addition to sending the request, <b>HttpSendRequest</b> allows you to send additional HTTP headers to the server. Information about HTTP headers can be found in the latest HTTP spec on <a href="http://www.w3.org/">http://www.w3.org/.</a> In this example, <b>HttpSendRequest </b>is passed defaults for all the parameters: </p>
<pre><code>BOOL bSendRequest = ::HttpSendRequest(
 &nbsp;&nbsp;&nbsp; hHttpFile, // 1 HINTERNET hHttpRequest
 &nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2 LPCTSTR lpszHeaders
 &nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3 DWORD dwHeadersLength
 &nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4 LPVOID lpOptional
 &nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 5 DWORD dwOptionalLength
);
</code></pre>
<h3>HttpQueryInfo</h3>
<p>
To get information about the file, use the <b>HttpQueryInfo</b> function after calling <b>HttpSendRequest</b>:</p>
<pre><code>BOOL bQuery = ::HttpQueryInfo(
 &nbsp;&nbsp;&nbsp; hHttpFile,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1 HINTERNET hHttpRequest
 &nbsp;&nbsp;&nbsp; HTTP_QUERY_CONTENT_LENGTH, // 2 DWORD dwInfoLevel
 &nbsp;&nbsp;&nbsp; bufQuery,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3 LPVOID lpvBuffer
 &nbsp;&nbsp;&nbsp; &amp;dwLengthBufQuery&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4 LPDWORD lpdwBufferLength
) ;
</code></pre>
<p>
The results of the query are strings or lists of strings placed in <i>lpvBuffer</i>. The HTTP_QUERY_CONTENT_LENGTH query gets the length of the file. You can query for a broad range of information using <b>HttpQueryInfo</b>; see the Microsoft Win32 Internet Functions site at <a href="http://www.microsoft.com/intdev/sdk/docs/wininet/">http://www.microsoft.com/intdev/sdk/docs/wininet/</a> topic for details.</p>
<h2>SurfBear Sample Application</h2>
<p>
The SurfBear sample application uses the Win32 Internet functions to get files off the Internet and display the raw HTML in an edit control. SurfBear uses <b>HttpOpenRequest</b> and <b>HttpSendRequest</b> instead of <b>InternetOpenUrl</b>, purely for demonstration purposes.</p>
<p>
<img src="inet_2.gif" border=0></p>
<p class=label>
<b>Figure 2. SurfBear screen</b></p>
<p>
SurfBear is an MFC version 4.0 dialog application. All of its Internet-related functionality is in the InternetThread.h and InternetThread.cpp files.</p>
<p>
Reading files from the Internet can take a significant amount of time, so calling the Internet functions from a worker thread is a wise idea. This way, the application's window can be resized and moved while the system is waiting to get the data.</p>
<p>
Figure 3 shows the flow of control for SurfBear.</p>
<p>
<img src="inet_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Control flow in SurfBear</b></p>
<p>
When the user presses the Goto button, <b>CSurfBearDlg::OnBtnGoto</b> calls <b>CInternetThread::GetWebPage</b>, passing the HTTP address of the desired Web page. <b>GetWebPage</b> parses the HTTP address into a server name and object name, which are stored in the member variables of <b>CInternetThread</b>. <b>GetWebPage</b> then calls <b>AfxBeginThread</b>, which creates a thread running the static member function <b>GetWebPageWorkerThread</b>. If the Internet functions have not been initialized, <b>GetWebPageWorkerThread</b> calls <b>InternetOpen</b>. It then attempts to read the desired Web page. When <b>GetWebPageWorkerThread</b> finishes, it posts a user-defined WM_READFILECOMPLETED message to the SurfBear dialog box. <b>OnReadFileCompleted</b> handles this message and copies the Web page into an edit control.</p>
<h2>Conclusion</h2>
<p>
The Win32 Internet functions make reading information from FTP, Gopher, and HTTP servers as easy as reading files from your hard drive. Using only four functions—<b>InternetOpen</b>, <b>InternetOpenUrl</b>, <b>InternetReadFile</b>, and <b>InternetCloseHandle</b>—and very little knowledge of HTTP, you can write a simple Internet browser.</p>
<p>
Turning this simple browser into an industrial-strength browser will take a lot of work, including knowledge of HTTP, displaying HTML files, and using multiple threads for progressive rendering of these files. The Win32 Internet functions isolate the developer from most of the grunge work involved in TCP/IP, Windows Sockets, and HTTP programming.</p>
</BODY>
</HTML>
