<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EMFDCODE.EXE: An Enhanced Metafile Decoding Utility</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_emfdcode"></a></sup>EMFDCODE.EXE: An Enhanced Metafile Decoding Utility</h1>
<p>
Dennis Crain<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: July 20, 1993</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="1619">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the EMFDCODE sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes the process of porting WMFDCODE, the metafile decoding utility in the Microsoft® Windows™ Software Development Kit (SDK), to EMFDCODE, the Win32™ enhanced metafile utility. Issues encountered during the port from WMFDCODE to EMFDCODE and the incorporation of enhanced metafile capabilities into EMFDCODE are discussed. The code for EMFDCODE is also provided. This article assumes that the reader has a good understanding of Win32 enhanced metafiles. For a detailed description of enhanced metafiles, see the <a href="msdn_enhmeta.htm">"Enhanced Metafiles in Win32"</a> article by Dennis Crain on the Microsoft Developer Network CD.</p>
<h2>Introduction</h2>
<p>
WMFDCODE is a sample application provided with the Microsoft® Windows™ version 3.1 Software Development Kit (SDK) and Microsoft Visual C++™ version 1.0. It permits the viewing of headers or records and the enumeration of Windows metafiles (.WMF files), Windows version 3.<i>x</i> Clipboard files containing Windows metafiles, and placeable metafiles. With the introduction of the Win32™ enhanced metafile (.EMF files), WMFDCODE became less than useful for developers for Win32 simply because it does not support enhanced metafiles. To address this inadequacy, I ported WMFDCODE to Win32 and renamed it EMFDCODE. EMFDCODE permits the viewing of headers or records and the enumeration of enhanced metafiles in addition to those metafiles supported by WMFDCODE. This article describes general issues related to the porting of the sample code from Windows version 3.1 to Win32 and the incorporation of enhanced metafile capabilities.</p>
<h2>Porting Issues</h2>
<p>
Porting the 16-bit WMFDCODE to the 32-bit EMFDCODE was very straightforward. Many of the issues are the same ones that anyone would encounter porting an application from Windows 3.<i>x</i> to Win32, such as differences in message packing, differences in the alignment of data structures, and updating graphics device interface (GDI) functions in Windows 3.<i>x </i>to the widened Win32 GDI functions. For an in-depth discussion of porting, see the <u>"</u>Porting 16-Bit Windows-Based Applications to Win32” article by Randy Kath in the MSDN Library Archive Edition.</p>
<h3>Messages</h3>
<p>
The widening of <i>wParam</i> from 16 bits to 32 bits and changes in the packing of <i>wParam</i> and <i>lParam</i> in Win32 obliged me to make a few changes in the way the WM_COMMAND message and the BN_CLICKED and EN_CHANGED notification codes were handled in EMFDCODE. The low-order word of <i>wParam</i> contains the identifiers for menu items, controls, and accelerators. The high-order word contains the notification code if the message is from a control. The following callback illustrates the changes required to correctly obtain messages and notification codes:</p>
<pre><code>BOOL CALLBACK PlayFromListDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
  switch (message) 
  {
 &nbsp;&nbsp; case WM_INITDIALOG:
 &nbsp;&nbsp;&nbsp;&nbsp; //The default is to play the selected records. 
 &nbsp;&nbsp;&nbsp;&nbsp; SendDlgItemMessage(hDlg, IDCB_SEL, BM_SETCHECK, 1, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp; return (TRUE);

 &nbsp;&nbsp; case WM_COMMAND:
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; //NOTE CHANGE: The low-order word of wParam contains the identifier for
 &nbsp;&nbsp;&nbsp;&nbsp; //menu items, controls and accelerators.&nbsp; In Windows 3.x this would
 &nbsp;&nbsp;&nbsp;&nbsp; //have been "switch(wParam)".
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; switch (LOWORD(wParam))
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case IDOK:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Was the 'play selected' or 'play unselected' button checked? 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (IsDlgButtonChecked(hDlg, IDCB_SEL))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bPlaySelList = TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bPlaySelList = FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EndDialog(hDlg, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (TRUE);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case IDCB_SEL:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //NOTE CHANGE : The high-order word of wParam contains notification 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //codes if the message is from a control.&nbsp; In Windows 3.1 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //this would have been "if (lParam == BN_CLICKED)".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HIWORD(wParam) == BN_CLICKED)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendDlgItemMessage(hDlg, IDCB_UNSEL, BM_SETCHECK, 0, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case IDCB_UNSEL:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //NOTE CHANGE : The high-order word of wParam contains notification 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //codes if the message is from a control.&nbsp; In Windows 3.1 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //this would have been "if (lParam == BN_CLICKED)".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HIWORD(wParam) == BN_CLICKED)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendDlgItemMessage(hDlg, IDCB_SEL, BM_SETCHECK, 0, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; break;
  }
  return (FALSE);
}
</code></pre>
<h3>Data Structures</h3>
<p>
During the porting of WMFDCODE to EMFDCODE, I had to deal with two issues related to data structures: one was the alignment of structures in memory and the other was the obsolescence of data structures previously used in Windows 3.<i>x</i>.</p>
<p>
Regarding the alignment of structures in memory, I found myself scratching my head as I tried to figure out why I was moving the file pointer too far into a Windows 3.1 placeable metafile after having read <code>sizeof(ALDUSMFHEADER)</code> bytes into the file. Thinking that <code>sizeof(ALDUSMFHEADER)</code> was 22 bytes, I was chagrined to find that when I set a watchpoint on the return value, it was 24 bytes. It didn't take too long to deduce that this was a structure packing alignment problem: The structure was being packed on a 4-byte boundary. To resolve this problem in EMFDCODE, all of the structures used for Windows metafiles were packed on 2-byte boundaries by use of <code>#pragma pack(2)</code>.</p>
<p>
Many of the data structures previously used in Windows 3.<i>x</i> were changed in Win32 to accommodate 32 bits. The three structures used by WMFDCODE that were changed in Win32 were the Windows 3.<i>x</i> Clipboard format header, <b>METAFILEPICT</b>, and the Windows 3.<i>x</i> <b>RECT</b> structure.</p>
<p>
Data structures requiring packing included the Windows 3.<i>x</i> Clipboard format header, <b>METAFILEPICT</b>, <b>RECT</b>, and the placeable metafile header. The Windows 3.<i>x</i> metafile header, <b>METAHEADER</b>, is already packed on a 2-byte boundary in the Win32 include file WINGDI.H. These four structures are listed below. Note that the comments to the right of each structure member describe the change to the structure in Win32.</p>
<pre><code>//
//Win 3.x Clipboard format header 
//
typedef struct {
  WORD&nbsp; FormatID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //DWORD in Win32
  DWORD DataLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //no change in Win32
  DWORD DataOffset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //no change in Win32;
  char&nbsp; Name[CLPMETANAMEMAX];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //no change in Win32
} CLIPFILEFORMAT, FAR *LPCLIPFILEFORMAT;
//
//Win 3.x metafilepict structure 
//
typedef struct tagOLDMETAFILEPICT {
  short&nbsp;&nbsp;&nbsp; mm;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //LONG in Win32
  short&nbsp;&nbsp;&nbsp; xExt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //LONG in Win32
  short&nbsp;&nbsp;&nbsp; yExt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //LONG in Win32
  WORD&nbsp;&nbsp;&nbsp;&nbsp; hMF;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //HMETAFILE in Win32
} OLDMETAFILEPICT, FAR *LPOLDMETAFILEPICT;
//
//Win 3.x rectangle structure
//
typedef struct tagOLDRECT
{
  short&nbsp;&nbsp; left;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //LONG in Win32
  short&nbsp;&nbsp; top;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //LONG in Win32
  short&nbsp;&nbsp; right;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //LONG in Win32
  short&nbsp;&nbsp; bottom;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //LONG in Win32
} OLDRECT;
//
//Placeable metafile header. No changes in Win32 other
//than structure packing alignment of 2 bytes required.
//
typedef struct {
  DWORD&nbsp;&nbsp;&nbsp; key;
  WORD&nbsp;&nbsp;&nbsp;&nbsp; hmf;
  OLDRECT&nbsp; bbox;
  WORD&nbsp;&nbsp;&nbsp;&nbsp; inch;
  DWORD&nbsp;&nbsp;&nbsp; reserved;
  WORD&nbsp;&nbsp;&nbsp;&nbsp; checksum;
}ALDUSMFHEADER;
</code></pre>
<h3>GDI Functions</h3>
<p>
Several Windows 3.<i>x</i> GDI functions required modification to work correctly in the Win32 environment. Those functions neatly fall into two categories: coordinate space transformation functions and metafile functions.</p>
<h4>Coordinate space transformations</h4>
<p>
<b>SetWindowOrg</b>, <b>SetWindowExt</b>, <b>SetViewportOrg</b>, and <b>SetViewportExt</b> were deleted in Win32. They were replaced with <b>SetWindowOrgEx</b>, <b>SetWindowExtEx</b>, <b>SetViewportOrgEx</b>, and <b>SetViewportExtEx</b> respectively in the Win32 environment. In the Windows 3.<i>x</i> functions, the coordinates were signed, 16-bit integers. In Win32, these coordinates are signed, 32-bit integers. The new Win32 functions take an additional pointer to a <b>POINT</b> or a <b>SIZE</b> structure in which the old coordinate values are returned. This is in contrast to the packed DWORD return value of the previous Windows 3.<i>x</i> functions. The code below illustrates the differences between the Windows 3.<i>x</i> <b>SetViewportExt</b> and the new Win32 <b>SetViewportExtEx</b>:</p>
<pre><code>//
//Example of Windows 3.x use of SetViewportExt.
//nNewXExt and nNewYExt are 16-bit signed ints.
//
DWORD dwOldVPExt;
char&nbsp; szBuf[80];
//
//Set the viewport extent and save the old extents. Note 
//that the return value contains the old viewport extents.
//
dwOldVPExt = SetViewportExt(hDC, nNewXExt, nNewYExt);
//
//Format the old extents in a character string.
//
if (dwOldVPExt)
  wsprintf((LPSTR)szBuf, (LPSTR)"old VXExt %d&nbsp; old VYExt %d",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOWORD(dwOldVPExt), HIWORD(dwOldVPExt));

//
//Example of Win32 use of SetViewportExtEx.
//nNewXExt and nNewYExt are 32-bit signed ints.
//
SIZE&nbsp; sizOldVPExt;
char&nbsp; szBuf[80];
//
//Set the viewport extent and save the old extents. Note that the 
//return value is a BOOL.&nbsp; The old viewport extents are placed 
//in the SIZE structure pointed to by (LPSIZE)&amp;sizOldVPExt.
//
if (SetViewportExtEx(hDC, nNewXExt, nNewYExt, (LPSIZE)&amp;sizOldVPExt))
  wsprintf((LPSTR)szBuf, (LPSTR)"old VXExt %l&nbsp; old VYExt %l",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizOldVPExt.cx, sizOldVPExt.cy);
</code></pre>
<p>
Needless to say, all instances of the old Windows 3.<i>x</i> functions occurring in WMFDCODE were replaced with the new Win32 functions in EMFDCODE.</p>
<h4>Windows metafile functions</h4>
<p>
After I ported WMFDCODE to EMFDCODE, I sought to ensure that EMFDCODE would deal with metafiles, Clipboard metafiles, and placeable metafiles from Windows 3.<i>x</i> just as WMFDCODE did in Windows 3.<i>x</i>. Luckily, almost all of the Windows 3.<i>x</i> metafile functions are provided in Win32 for reasons of compatibility. This significantly eased the porting process simply because I did not have to rewrite very much of the code required to support Windows metafiles. However, two of the functions did change: <b>SetMetaFileBits</b> and <b>GetMetaFileBits</b>. The equivalents in Windows 3.<i>x </i>to these functions required a handle to a metafile as the sole parameter. GDI took care of the rest. The metafile bits were placed in global memory allocated by the <b>GetMetaFileBits</b> or <b>SetMetaFileBits</b> functions. In Win32, the caller supplies the memory for the metafile bits by providing a handle to the memory and the size of the metafile bits. The following code illustrates the differences between the Windows 3.<i>x</i> <b>GetMetaFileBits</b>/<b>SetMetaFileBits</b> and the Win32 <b>GetMetaFileBitsEx</b>/<b>SetMetaFileBitsEx</b>:</p>
<pre><code>//
//Example of Windows 3.x SetMetaFileBits.&nbsp; The handle
//hNewMF is the handle to the memory metafile created 
//by SetMetaFileBits. hMF should not use used thereafter.
//
HMETAFILE hWMF;
HGLOBAL&nbsp;&nbsp; hMFBits;

hMFBits = GetMetaFileBits(hMF);
if (hMFBits)
{
  hWMF = SetMetaFileBits(hMFBits);
  GlobalFree(hMFBits);
}

//
//Example of Win32 SetMetaFileBitsEx
//
LPBYTE&nbsp;&nbsp;&nbsp; lpWinMFBits;
UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uiSizeBuf;
HMETAFILE hWMF;
//
//Obtain the size of the metafile bits.
//
uiSizeBuf = GetMetaFileBitsEx(hMF, 0, NULL);
//
//Allocate memory to hold bits.
//
if ((lpWinMFBits = (LPBYTE)GlobalAllocPtr(GHND, uiSizeBuf)));
{
  //
  //Get the metafile bits.
  //
  if (GetMetaFileBitsEx(hMF, uiSizeBuf, (LPVOID)lpWinMFBits))
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //Set the metafile bits.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; hWMF = SetMetaFileBitsEx(uiSizeBuf, (LPBYTE)lpWinMFBits);
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //Free memory in which bits were stored.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; GlobalFreePtr(lpWinMFBits);
}
</code></pre>
<p>
The WMFMETA.C and MFDCOD32.C modules originally contained calls to <b>GetMetaFileBits</b> and <b>SetMetaFileBits</b>. In Win32 these calls are replaced with calls to the Win32 functions <b>GetMetaFileBitsEx</b> and <b>SetMetaFileBitsEx</b>, respectively.</p>
<h3>Dialog Boxes</h3>
<p>
The great news about dialog boxes has to do with the exported callback associated with them. There is no need to call <b>MakeProcInstance</b> and <b>FreeProcInstance</b> for exported functions. Win32-based applications do not share the concept of multiple instances as found in Windows 3.<i>x</i>. Win32-based applications exist as their own modules and cannot share information among other similar modules. So, the concept of binding an instance data segment to an exported function has no meaning in Win32. Goodbye, <b>MakeProcInstance</b> and <b>FreeProcInstance</b>! These functions are obsolete in Win32. I don't know about you, but I didn't enjoy typing these long function names! Look at the following examples and decide which makes more sense:</p>
<pre><code>//
//Example of MakeProcInstance and FreeProcInstance in Windows 3.x
//
if ((lpEnumRangeDlg = MakeProcInstance(EnumRangeDlgProc, hInst)))
{
  iDlgRet = DialogBox(hInst, "ENUMRANGE", hWnd, lpEnumRangeDlg);
  FreeProcInstance(lpEnumRangeDlg);
}

//
//Example of Win32's lack of MakeProcInstance and FreeProcInstance.
//Is this nice or what?
//
iDlgRet = DialogBox(hInst,"ENUMRANGE",hWnd,EnumRangeDlgProc);
</code></pre>
<h2>Incorporating Enhanced Metafile Features</h2>
<p>
Having ported the basic functionality of WMFDCODE to EMFDCODE, I then added enhanced metafile functionality to the application. When I wrote WMFDCODE three years ago, I was three years less experienced than I am now. So when I reviewed the design of WMFDCODE, I had a great laugh! This quickly deteriorated into serious chin scratching as I wrestled with incorporating the enhanced metafile functionality into an application designed by my ignorant twin.</p>
<p>
I finally decided to stray as little as possible from the original design of WMFDCODE. This meant that the application would make use of global flags for control of program flow and a global handle to the current metafile. I also decided to consolidate functions where it seemed possible. The biggest effect of that effort resulted in the consolidation of some of the content of the enumeration procedures and Clipboard metafile rendering. I also added some functionality to EMFDCODE that did not exist in WMFDCODE. Converting between Windows metafile format and enhanced metafile format is possible largely due to some great conversion functions provided by Win32. More on that later. First, let's look at some of the basic things required to use the enhanced metafile format. Although I discuss these in the context of EMFDCODE, they are things that must take place in any application that uses enhanced metafiles.</p>
<h3>Obtaining the Enhanced Metafile Header</h3>
<p>
To obtain the header of a Windows metafile, the application must take action and read the file at the appropriate location. This is complicated by the fact that the location of the metafile header varies between Windows metafiles and placeable metafiles. For enhanced metafiles, Win32 eases this burden by providing the <b>GetEnhMetaFileHeader</b> function. Before the header can be retrieved, an appropriate amount of memory must be allocated to hold the contents of the header. Unfortunately, the amount of memory required can vary from one metafile to another because the description string (discussed below), which has a variable length, is appended to the header. So how do you determine how much memory to allocate? The header size is obtained by a call to <b>GetEnhMetaFileHeader</b> while specifying the pointer to memory as NULL. The value returned from <b>GetEnhMetaFileHeader</b> is the size of the header, which is the amount of memory that you must allocate. At this point, simply call <b>GetEnhMetaFileHeader</b> once again with a pointer to that memory. The code below in "Obtaining the Metafile Palette" demonstrates obtaining a pointer to memory containing the enhanced metafile header. The definition of the enhanced metafile header is contained in the include file WINGDI.H.</p>
<h3>Obtaining the Description String</h3>
<p>
Enhanced metafiles may contain a string containing a description of the metafile. The description is stored in the metafile as a Unicode™ string. The easiest way to extract the description string is by use of the Win32 function <b>GetEnhMetaFileDescription</b>. Similar to <b>GetEnhMetaFileHeader</b>, <b>GetEnhMetaFileDescription</b> returns the size of the description string if the pointer to the memory buffer for the string is specified as NULL. The technique for using this function is illustrated in the code below in the next section.</p>
<h3>Obtaining the Metafile Palette</h3>
<p>
Palettes exist in enhanced metafiles in the end-of-file record known as <b>EMR_EOF</b>. As enhanced metafiles are recorded, any calls to <b>CreatePalette</b> or <b>SetPaletteEntries</b> cause GDI to add the specified palette entries to the common palette in <b>EMR_EOF</b>. The best method for retrieving these palette entries is to use the Win32 function <b>GetEnhMetaFilePaletteEntries</b>. A pointer to a memory block sufficiently large enough to store the palette must be supplied to <b>GetEnhMetaFilePaletteEntries</b>. As with the <b>GetEnhMetaFileHeader </b>and<b> GetEnhMetaFileDescription</b>, the appropriate size is obtained by specifying the pointer to that memory as NULL. Having allocated memory of that size, <b>GetEnhMetaFilePaletteEntries</b> is called again using the pointer to that memory, thereby placing the palette entries in that memory. The code below illustrates the technique for using all three of these functions: <b>GetEnhMetaFileHeader</b>, <b>GetEnhMetaFileDescription</b>, and <b>GetEnhMetaFilePaletteEntries</b>.</p>
<pre><code>//
//Demonstrates techniques for obtaining the metafile header, 
//description string, and metafile palette.&nbsp; This is similar to
//the function GetEMFCoolStuff in the EMFDCODE module WMFMETA.C
//but has been modified for illustrative purposes.
//
BOOL GetEMFCoolStuff(HMETAFILE hemf)
{
 &nbsp; LPENHMETAHEADER&nbsp; lpEMFHdr&nbsp; = NULL;
 &nbsp; LPTSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpDescStr = NULL;
 &nbsp; LPPALETTEENTRY&nbsp;&nbsp; pPal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
  //
  //If this is a valid handle
  //
  if (hemf)
  {
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //Obtain the sizes of the emf header, description string, and palette.
 &nbsp;&nbsp; //Note that the last parameter of each is NULL. This instructs each of 
 &nbsp;&nbsp; //these functions to return the size of the metafile component being sought.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; UINT uiHdrSize = GetEnhMetaFileHeader(hemf, 0, NULL);
 &nbsp;&nbsp; UINT uiDescStrSize = GetEnhMetaFileDescription(hemf, 0, NULL);
 &nbsp;&nbsp; UINT uiPalEntries = GetEnhMetaFilePaletteEntries(hemf, 0, NULL);
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //If these sizes are greater than 0, allocate memory of that size.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (uiHdrSize)
 &nbsp;&nbsp;&nbsp;&nbsp; lpEMFHdr = (LPENHMETAHEADER)GlobalAllocPtr(GHND, uiHdrSize);
 &nbsp;&nbsp; if (uiDescStrSize)
 &nbsp;&nbsp;&nbsp;&nbsp; lpDescStr = (LPTSTR)GlobalAllocPtr(GHND, uiDescStrSize);
 &nbsp;&nbsp; if (uiPalEntries)
 &nbsp;&nbsp;&nbsp;&nbsp; lpPal = (LPPALETTEENTRY)GlobalAllocPtr(GHND, uiPalEntries *
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(PALETTEENTRY));
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //So far, so good. If the header size was greater than 0, we 
 &nbsp;&nbsp; //should continue.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (uiHdrSize)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; //Get the emf header. If the function fails, then bail out.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; if (!GetEnhMetaFileHeader(hemf, uiHdrSize, lpEMFHdr))
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Failed
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox(hWndMain, "Unable to read enhanced metafile header", NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_OK | MB_ICONEXCLAMATION);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bValidFile = FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get the description string if it exists.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (uiDescStrSize)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetEnhMetaFileDescription(hemf, uiDescStrSize, lpDescStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get the palette entries if they exist.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (uiPalEntries)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetEnhMetaFilePaletteEntries(hemf, uiPalEntries, lpPal);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; } 
 &nbsp;&nbsp; //
 &nbsp;&nbsp; //The header size was reported as 0, so fail.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; return (FALSE);
  }
  // 
  //Apparent success
  //
  return (TRUE);
}
</code></pre>
<h3>Enumerating an Enhanced Metafile</h3>
<p>
There is less need to enumerate enhanced metafiles than there is with Windows metafiles because of the improved design of the enhanced metafile, the improved recording of metafiles, and the improved playback of metafiles. However, some applications may need to enumerate metafiles if they are editing the metafiles. EMFDCODE enumerates metafiles to enable the user to view the individual metafile records. The enumeration of enhanced metafiles is similar to enumeration of Windows metafiles. The only significant difference is that a pointer to an enhanced metafile record is passed to the enumeration callback in Win32 as opposed to a pointer to a Windows metafile record in Windows 3.<i>x</i>. Much of the code in the enumeration callback in EMFDCODE is the same for all types of metafiles. Because of the differences between parameters for enhanced metafiles and Windows metafiles, the common code was placed in a function named <b>EnumMFIndirect</b>. The following enumeration callbacks illustrate how EMFDCODE calls the common enumeration code:</p>
<pre><code>//
//Enumeration callback for Win32 enhanced metafiles
//
int CALLBACK EnhMetaFileEnumProc(HDC hDC, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPHANDLETABLE lpHTable, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPENHMETARECORD lpEMFR, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nObj, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPARAM lpData)
{
  //
  //Pass lpEMFR to the common enumeration code. Specify the pointer
  //to the Windows metafile record as NULL.
  //
  return EnumMFIndirect(hDC, lpHTable, NULL, lpEMFR, nObj, lpData);
}

//
//Enumeration callback for Windows 3.x metafiles.
//
int CALLBACK MetaEnumProc(HDC hDC,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPHANDLETABLE lpHTable,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPMETARECORD&nbsp; lpMFR,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nObj,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPARAM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpClientData,

{
  //
  //Pass lpMFR to the common enumeration code. Specify the pointer
  //to the enhanced metafile record as NULL.
  //
  return EnumMFIndirect(hDC, lpHTable, lpMFR, NULL, nObj, lpClientData);
}
</code></pre>
<h3>Converting Metafiles Between WMF and EMF</h3>
<p>
Given that thousands of Windows metafiles exist, two functions are provided in Win32 that enable conversion between the Windows metafile and the enhanced metafile formats: <b>SetWinMetaFileBits</b> and <b>GetWinMetaFileBits</b>. <b>SetWinMetaFileBits</b> converts the bits of a Windows metafile to an enhanced metafile. <b>GetWinMetaFileBits</b> converts the bits of an enhanced metafile into a Windows metafile. <b>SetWinMetaFileBits</b> takes a handle to a previously opened Windows metafile, converts those bits to the enhanced metafile format, and places the bits in memory allocated by the application. The following code demonstrates the use of <b>SetWinMetaFileBits</b> to create an enhanced metafile from a Windows metafile. This code is part of the <b>ConvertWMFtoEMF</b> function, found in the EMFDCODE module WMFMETA.C. Error checking has been removed for the sake of clarity.</p>
<pre><code>&nbsp;&nbsp;//
  //Example of the use of SetWinMetaFileBits. This function is used to 
  //convert the bits of a Windows metafile to those of an enhanced metafile.
  //
  LPSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpWinMFBits;
  UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uiSizeBuf;
  HENHMETAFILE hEnhMF;
  //
  //Get the size of the Windows metafile associated with hMF.
  //
  uiSizeBuf = GetMetaFileBitsEx(hMF, 0, NULL);
  //
  //Allocate enough memory to hold metafile bits.
  //
  lpWinMFBits = GlobalAllocPtr(GHND, uiSizeBuf);
  //
  //Get the bits of the Windows metafile associated with hMF.
  //
  GetMetaFileBitsEx(hMF, uiSizeBuf, (LPVOID)lpWinMFBits);
  //
  //Copy the bits of the Windows metafile into a memory-based enhanced metafile.
  //
  hEnhMF = SetWinMetaFileBits(uiSizeBuf, (LPBYTE)lpWinMFBits, NULL, NULL);
  //
  //Copy the memory-based enhanced metafile to a disk-based enhanced metafile.
  //
  CopyEnhMetaFile(hEnhMF, lpszFileName);
  //
  //Done with the memory-based enhanced metafile, so get rid of it.
  //
  DeleteEnhMetaFile(hEnhMF);
  //
  //Done with the actual memory used to store bits, so nuke it.
  //
  GlobalFreePtr(lpWinMFBits);
</code></pre>
<p>
<b>GetWinMetaFileBits</b> takes a handle to a previously opened enhanced metafile and converts the bits of that metafile into the Windows metafile format. Those bits are placed into memory allocated by the application. The following code demonstrates the use of this function. Once again, error checking has been removed for the sake of clarity. The code is part of the <b>ConvertEMFtoWMF</b> function, which is found in the module WMFMETA.C.</p>
<pre><code>&nbsp;&nbsp;//
  //Example of the use of GetWinMetaFileBits. This function is used to 
  //convert the bits of an enhanced metafile to those of a Windows metafile.
  //
  LPSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpEMFBits;
  UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uiSizeBuf;
  HMETAFILE&nbsp;&nbsp;&nbsp; hWMF;
  //
  //Get the size of the Windows metafile associated with hMF.
  //
  uiSizeBuf = GetWinMetaFileBits(hemf, 0, NULL, MM_TEXT, hrefDC);
  //
  //Allocate enough memory to hold metafile bits.
  //
  lpEMFBits = GlobalAllocPtr(GHND, uiSizeBuf);
  //
  //Get the bits of the enhanced metafile associated with hEMF.
  //
  GetWinMetaFileBits(hEMF, uiSizeBuf,(LPBYTE)lpEMFBits, MM_TEXT, hrefDC);
  //
  //Copy the bits into a memory-based Windows metafile.
  //
  hWMF = SetMetaFileBitsEx(uiSizeBuf, (LPBYTE)lpEMFBits);
  //
  //Copy the Windows metafile to a disk-based Windows metafile.
  //
  CopyMetaFile(hWMF, lpszFileName);
  //
  //Done with the memory-based enhanced metafile, so get rid of it.
  //
  DeleteMetaFile(hMF);
  //
  //Done with the actual memory used to store bits, so nuke it.
  //
  GlobalFreePtr(lpEMFBits);
</code></pre>
<h2>Summary</h2>
<p>
The porting of WMFDCODE to EMFDCODE was a fairly easy and straightforward process. Incorporation of the enhanced metafile functions into EMFDCODE illustrated how easy it is to deal with enhanced metafiles. A number of Win32 functions are provided that obtain components of the enhanced metafile, while in Windows 3.<i>x</i>, your application had to provide that functionality. Functions to obtain the header, description string, and palette ensure that the underlying structure of enhanced metafiles can be changed and improved with little effect on the applications that use these functions.</p>
<p>
As a debugging utility for enhanced metafiles, EMFDCODE does not take advantage of all of the features of enhanced metafiles. The clipping region is not explicitly set in EMFDCODE. If it were, the GDI metafile player would clip the metafile appropriately. EMFDCODE does not permit the user to set the world-to-page transformation values. However, this could easily be added to EMFDCODE. The metafile player queries the world-to-page transformation values of the destination upon which the metafile is drawn before actually playing the metafile, and accommodates them as it plays.</p>
</BODY>
</HTML>
