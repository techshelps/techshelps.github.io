<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Extending DirectInput's Joystick Subsystem Services</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_extdirect"></a></sup>Extending DirectInput's Joystick Subsystem Services</h1>
<p>
Microsoft Corporation<br>
June 24, 1996 (updated August 15, 1996)</p>
<h2>Introduction</h2>
<p>
Microsoft® DirectInput™, the joystick driver subsystem for Windows® 95, is the much-needed new standard for game developers working with input devices such as joysticks and game pads. The new digital joystick devices, such Microsoft SideWinder™ 3D Pro, support multiple devices on a single port and provide discrete button and position information. DirectInput provides support for multiple joysticks, and it supports the latest in gaming-device technology, without the developer having to know the intricacies of the device. </p>
<p>
This article describes how to extend the joystick services and how to fully utilize DirectInput to take advantage of the latest technology in gaming devices. Use this document in combination with the joystick documentation, which can be found on the MSDN Library as a subset of the Platform Software Development Kit (SDK).</p>
<h2>Determining What Joystick Device Capabilities Exist</h2>
<p>
When you start Windows 95, joystick services are loaded. The services are used to monitor up to sixteen joysticks. Joystick functions are used to determine the joysticks' capabilities. You can process a joystick's position and button information by querying the joystick directly or by capturing the joystick and processing messages from it. </p>
<p>
Each gaming device (joystick, game pad, flight yoke, and so on) has several capabilities that are available to your application. You can retrieve the capabilities of a device using the <b>joyGetDevCaps</b> function to fill a JOYCAPS structure with joystick capabilities. Such capabilities include: 
<ul type=disc>
<li>
The maximum and minimum values for its coordinate system. <br><br></li>
<li>
The number of buttons on the joystick.<br><br></li>
<li>
The number and type of axes.<br><br></li>
<li>
The maximum and minimum polling frequencies. </li>
</ul>
<p>
The following JOYCAPS structure contains information about the joystick capabilities:</p>
<pre><code>typedef struct 
{ 
  WORD wMid;&nbsp;&nbsp; // manufacturer identifier
  WORD wPid;&nbsp;&nbsp; // product identifier
 CHAR szPname[MAXPNAMELEN];&nbsp; // see below
  UINT wXmin;&nbsp; // min. x coordinate
  UINT wXmax;&nbsp; // max. x coordinate
  UINT wYmin;&nbsp; // min. y coordinate
 UINT wYmax;&nbsp; // max. y coordinate
  UINT wZmin;&nbsp; // min. z coordinate
  UINT wZmax;&nbsp; // max. z coordinate
  UINT wNumButtons;&nbsp; // number of joystick buttons
 UINT wPeriodMin;&nbsp; // see below
  UINT wPeriodMax;&nbsp; // see below
// The following members are not in previous versions of Windows. 
 UINT wRmin;&nbsp; // see below
  UINT wRmax;&nbsp; // see below
  UINT wUmin;&nbsp; // see below
  UINT wUmax;&nbsp; // see below
  UINT wVmin;&nbsp; // see below
  UINT wVmax;&nbsp; // see below
  UINT wCaps;&nbsp; // see below
  UINT wMaxAxes;&nbsp; // see below
  UINT wNumAxes;&nbsp; // see below
  UINT wMaxButtons;&nbsp; // see below
  CHAR szRegKey[MAXPNAMELEN];&nbsp; // see below
  CHAR szOEMVxD[MAXOEMVXD];&nbsp; // see below
} JOYCAPS; 
</code></pre>
<p class=label>
<b>JOYCAPS Structure </b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=22%><b>Element</b></td>
<td class=label width=78%><b>Descriptions</b></td>
</tr>
<tr valign=top>
<td width=22%><b>zOEMVxD</b></td>
<td width=78%>Null-terminated string identifying the OEM joystick minidriver. </td>
</tr>
<tr valign=top>
<td width=22%><b>SzPname</b></td>
<td width=78%>Null-terminated string containing the joystick product name (in the case of Vjoyd.vxd, this field is always "Microsoft PC-joystick driver"). </td>
</tr>
<tr valign=top>
<td width=22%><b>SzRegKey</b></td>
<td width=78%>Null-terminated string containing the registry key for the joystick. </td>
</tr>
<tr valign=top>
<td width=22%><b>Wcaps</b></td>
<td width=78%>Joystick capabilities (see flags in the following table, which defines individual joystick capabilities). </td>
</tr>
</table><br>
<p class=label>
<b>Flags Defining Joystick Capabilities </b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Flag</b></td>
<td class=label width=76%><b>Joystick Capability</b></td>
</tr>
<tr valign=top>
<td width=24%><b>JOYCAPS_HASZ</b></td>
<td width=76%>Z-coordinate information. </td>
</tr>
<tr valign=top>
<td width=24%><b>JOYCAPS_HASR</b></td>
<td width=76%>Rudder (fourth-axis) information. </td>
</tr>
<tr valign=top>
<td width=24%><b>JOYCAPS_HASU</b></td>
<td width=76%>U-coordinate (fifth-axis) information. </td>
</tr>
<tr valign=top>
<td width=24%><b>JOYCAPS_HASV</b></td>
<td width=76%>V-coordinate (sixth-axis) information. </td>
</tr>
<tr valign=top>
<td width=24%><b>JOYCAPS_HASPOV</b></td>
<td width=76%>Point-of-view information. </td>
</tr>
<tr valign=top>
<td width=24%><b>JOYCAPS_POV4DIR</b></td>
<td width=76%>Point of view supports discrete values (centered, forward, backward, left, and right). </td>
</tr>
<tr valign=top>
<td width=24%><b>JOYCAPS_POVCTS</b></td>
<td width=76%>Point of view supports continuous degree bearings. </td>
</tr>
<tr valign=top>
<td width=24%><b>wMaxAxes</b></td>
<td width=76%>Maximum number of axes supported. </td>
</tr>
<tr valign=top>
<td width=24%><b>wMaxButtons</b></td>
<td width=76%>Maximum number of buttons supported. </td>
</tr>
<tr valign=top>
<td width=24%><b>wNumAxes</b></td>
<td width=76%>Number of axes currently in use. </td>
</tr>
<tr valign=top>
<td width=24%><b>wPeriodMax</b></td>
<td width=76%>Largest polling frequency supported when captured by the <b>joySetCapture</b> function (in milliseconds). </td>
</tr>
<tr valign=top>
<td width=24%><b>wPeriodMin</b></td>
<td width=76%>Smallest polling frequency supported when captured by the <b>joySetCapture</b> function (in milliseconds). </td>
</tr>
<tr valign=top>
<td width=24%><b>wRmax</b> and <b>wRmin</b></td>
<td width=76%>Maximum and minimum rudder values (rudder is the fourth axis of movement). </td>
</tr>
<tr valign=top>
<td width=24%><b>wUmax</b> and <b>wUmin</b></td>
<td width=76%>Maximum and minimum u-coordinate (fifth-axis) values. </td>
</tr>
<tr valign=top>
<td width=24%><b>wVmax</b> and <b>wVmin</b></td>
<td width=76%>Maximum and minimum v-coordinate (sixth-axis) values. </td>
</tr>
</table><br>
<p>
The following code fragment demonstrates how to determine if a device supports a rudder.</p>
<pre><code>/************************************************************
** BOOL joyHasRudder(UINT joyid)
**
** Description:&nbsp; Determine if a given joystick has a rudder.
**
** Parameters: UINT joyid - Joystick id.
**
** Returns:&nbsp; TRUE - YES the joystick has a rudder.
**&nbsp;&nbsp;&nbsp;&nbsp; FALSE - NO the joystick has no rudder.
*****************************************************************/
BOOL joyHasRudder(UINT joyid)
{
 JOYCAPS jc;
 if(joyGetDevCaps(joyid,(LPJOYCAPS)&amp;jc,sizeof(JOYCAPS)==JOYERR_NOERROR)
 {
  if(jc.wCaps &amp; JOYCAPS_HASR) 
 &nbsp; return TRUE;
 }
 return FALSE;
}
</code></pre>
<h2>Determining the OEM Joystick's Product Name</h2>
<p>
DirectInput stores all device-specific information in the registry. Some of this information, including the OEM product's name, is not available through the multimedia-joystick API calls. The OEM product name, as well as other device-specific information, is stored in the registry. To retrieve joystick information, use the registry information of three primary keys: <b>CurrentJoystickSettings,</b> <b>OEM Joysticks,</b> and <b>JoystickSettings.</b></p>
<h2>CurrentJoystickSettings Key</h2>
<p>
The <b>CurrentJoystickSettings</b> key contains configuration information about all joysticks installed (or configured). The installed joysticks may not be connected properly, but this key reflects what the driver system is configured for. The following illustration describes this key's registry hierarchy: </p>
<pre><code>HKEY_LOCAL_MACHINE
 System
  &nbsp;CurrentControlSet
 &nbsp; &nbsp;&nbsp;Control
 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;MediaResources
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;Joystick
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(JOYCAPS.szRegKey) (Note: obtained by joyGetDevCaps.)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CurrentJoystickSettings
</code></pre>
<p>
If an OEM joystick is present, the <b>JoysticknOEMName</b> field—the registry key of the OEM joystick—will be present. The <i>n</i> in <b>JoysticknOEMName</b> represents the joystick ID. For example:</p>
<pre><code>Joystick1OEMName = "SideWinder 3D Pro"
</code></pre>
<p>
specifies that the registry key for Joystick ID1 is assigned to SideWinder 3D Pro. For details, see the next section.</p>
<h2>OEM Joysticks Key</h2>
<p>
The OEM Joysticks key is the parent to all available OEM joysticks, whether or not the joysticks are attached. The following illustration describes this key's registry hierarchy. </p>
<pre><code>&nbsp;HKEY_LOCAL_MACHINE
 System
  &nbsp;CurrentControlSet
 &nbsp; &nbsp;&nbsp;Control
 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;MediaProperties
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;PrivateProperties
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Joystick
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OEM
</code></pre>
<p>
The OEM Joysticks key contains one or more child keys that can be enumerated to determine which OEM joysticks may be available. Each child key has at least two fields: </p>
<p class=label>
<b>Child Key Fields </b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Child Key Field</b></td>
<td class=label width=71%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=29%>OEMName</td>
<td width=71%>OEM product name</td>
</tr>
<tr valign=top>
<td width=29%>OEMData</td>
<td width=71%>Hardware-specific settings and the number of buttons</td>
</tr>
</table><br>
<h2>JoystickSettings Key</h2>
<p>
The <b>JoystickSettings</b> key contains configuration information about the last state of the joystick. It is used primarily by the Control Panel when a joystick is removed and then reattached to the system. You can use this key to reestablish information (primarily regarding calibration) about the state of the joystick when it was last properly connected. The following illustration describes this key's registry hierarchy:</p>
<pre><code>&nbsp;HKEY_LOCAL_MACHINE
 System
  &nbsp;CurrentControlSet
 &nbsp; &nbsp;&nbsp;Control
 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;MediaResources
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;Joystick
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(JOYCAPS.szRegKey) (Note: obtained by joyGetDevCaps.)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JoystickSettings
</code></pre>
<p>
The following fragment demonstrates how to obtain the OEM product name of a specific joystick (by ID):</p>
<pre><code>#include &lt;regstr.h&gt;
. . .
/**********************************************************
**
**LRESULT joyGetOEMProductName(UINT id, PSTR szName)
**
** Description: Retrieve the OEM product name for a 
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; given joystick ID.
**
** Parameters: UINT id&nbsp;&nbsp; - Joystick ID number.
**&nbsp;&nbsp;&nbsp;&nbsp; PSTR szName&nbsp; - Joystick OEM product name.
**
** Returns: ERROR_SUCCESS =&nbsp; OK , szName will be 
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filled with joystick OEM product name.
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else an error code from registry call.
**
**************************************************************/ 
#define ERROR_NOTOEM -1
MMRESULT joyGetOEMProductName(UINT id, TCHAR * pszName)
{
 JOYCAPS JoyCaps;
 TCHAR szKey[256];
 TCHAR szValue[256];
 UCHAR szOEMKey[256];
 HKEY hKey;
 DWORD dwcb;
 LONG lr;
// Note: JOYSTICKID1-16 is zero-based; registry entries for VJOYD are 1-based.
 id++;&nbsp; 
 if (id &gt; joyGetNumDevs() ) return JOYERR_NOCANDO;
// Open .. MediaResources\CurentJoystickSettings.
 joyGetDevCaps((id-1), &amp;JoyCaps, sizeof(JoyCaps));
 sprintf(szKey,
 &nbsp; "%s\\%s\\%s",
 &nbsp; REGSTR_PATH_JOYCONFIG,
 &nbsp; JoyCaps.szRegKey,
 &nbsp; REGSTR_KEY_JOYCURR);
 lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPTSTR) &amp;szKey, 0, KEY_ALL_ACCESS, &amp;hKey);
 if (lr != ERROR_SUCCESS) return JOYERR_NOCANDO;
// Get OEM Key name.
 dwcb = sizeof(szOEMKey);
  sprintf(szValue, "Joystick%d%s", id, REGSTR_VAL_JOYOEMNAME);
 lr = RegQueryValueEx(hKey, szValue, 0, 0, (LPBYTE) &amp;szOEMKey, (LPDWORD) &amp;dwcb);
 RegCloseKey(hKey);
 if (lr != ERROR_SUCCESS)
 {
  *pszName = 0;
  return JOYERR_NOCANDO;
 }
// Open OEM Key from ...MediaProperties.
 sprintf(szKey, "%s\\%s", REGSTR_PATH_JOYOEM, szOEMKey);
 lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_ALL_ACCESS, &amp;hKey);
 if (lr != ERROR_SUCCESS) return JOYERR_NOCANDO;
// Get OEM Name.
 dwcb = sizeof(szValue);
 lr = RegQueryValueEx( hKey,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGSTR_VAL_JOYOEMNAME,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPBYTE) pszName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPDWORD) &amp;dwcb);
 RegCloseKey(hKey);
 if (lr != ERROR_SUCCESS)
  return JOYERR_NOCANDO;
 else
  return JOYERR_NOERROR;
}
</code></pre>
<h2>Determining the Number of Gaming Devices Connected</h2>
<p>
The Windows 95 joystick services support up to 16 different devices connected to the system at once, although it's unlikely that so many devices would be connected at a time.</p>
<p>
To determine the number of gaming devices connected, walk through all 16 JOYSTICK IDS and poll each device with the <b>joyGetPosEx</b> service. The <b>joyGetPosEx</b> service returns the JOYERR_NOERROR message if the joystick is working properly. The following demonstrates how to obtain the number of devices connected.</p>
<p>
Note that the <b>joyGetNumDevs</b> service returns the number of possible joysticks the system supports (currently 16); it does not return the number of connected joysticks.</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;mmsystem.h&gt;
. . .
/****************************************************************
**
** UINT joyGetNumDevicesConnected(void)
**
** Description: Determine the number of joysticks connected.
**
** Parameters: None.
**
** Returns: UINT - Number of devices connected.
**
*****************************************************************/
UINT joyGetNumDevicesConnected(void)
{
 UINT JoyID;
 UINT nDevicesConnected=0;
 JOYINFOEX ji;
 ji.dwSize = sizeof(JOYINFOEX);
 for (JoyID=JOYSTICKID1; JoyID&lt;joyGetNumDevs(); JoyID++)
 {
  if (joyGetPosEx(JoyID, &amp;ji)==JOYERR_NOERROR)
  {
 &nbsp; nDevicesConnected++;
  }
 }
 return nDevicesConnected;
}
</code></pre>
<h2>Detecting When Joystick Settings Are Changed</h2>
<p>
When the user or Setup changes the joystick settings, a notification message is posted to all top-level windows, including disabled or invisible windows. This notification can be used to do one of the following: 
<ul type=disc>
<li>
Dynamically change the context of the device or devices that are being used in game play. <br><br></li>
<li>
Inform the user that the game was notified of the changes the user made. </li>
</ul>
<p>
To be notified of changes in joystick settings, the application must first retrieve the message ID of the notification event posted by the DirectInput driver subsystem. To retrieve the message ID, use the <b>RegisterWindowMessage</b> Windows API call, which passes "MSJSTICK_VJOYD_MSGSTR" as its argument:</p>
<pre><code>uMsgId = RegisterWindowMessage("MSJSTICK_VJOYD_MSGSTR");
</code></pre>
<p>
With the message ID retrieved, you can use the application's windows message queue to check for the occurrence of this notification, as shown in the following example.</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;mmsystem.h&gt;
. . .
UINT uMsgId;
int WinMain(…)
{
 // Retrieve message ID that joystick driver subsystem posts.
 uMsgId = RegisterWindowMessage("MSJSTICK_VJOYD_MSGSTR");
 
 // Init Instance, Register Classes, Create Window etc..
 . . .
 // Acquire messages from queue and dispatch messages until a WM_QUIT 
 // message is received. 
  while (GetMessage(&amp;msg,NULL, NULL, NULL)) 
 {
 &nbsp; TranslateMessage(&amp;msg);&nbsp; // Translates virtual key codes.
 &nbsp; DispatchMessage(&amp;msg);&nbsp; // Dispatches message to window.
  }
 return (msg.wParam);&nbsp;&nbsp; // Returns the value from PostQuitMessage.
}
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
 // Did the joystick configuration change?
 if(msg == uMsgId)
 {
  // Yes.
  // Here we can inform the user of the changes in joystick
  // configuration and/or update our joystick device context.
  . . .
  return (DefWindowProc(hWnd, msg, wParam, lParam));
 }
 // Perform normal message processing. . . .
 switch (msg)
  {
  . . .
 }
 return (NULL);
}
</code></pre>
<h2>Supporting Multiple Joystick Devices</h2>
<p>
All of the Windows 95 joystick services except for <b>joyGetNumDevs</b> require a joystick ID. The DirectInput driver subsystem (Msjstick.drv and Vjoyd.vxd) uses the joystick ID to coordinate which device should be called to retrieve the information requested. Up to 16 joysticks are supported.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The multimedia reference mentions only JOYSTICKID1 and JOYSTICKID2 as valid joystick IDs, and the Mmsystem.h file defines only these two IDs. The multimedia reference and Mmsystem.h file together imply that only two joysticks can be connected at a time. However, newer gaming devices, digital technology, and the joystick driver model of Windows 95 (which supports a minidriver model) all make it possible for these devices to "daisy chain" themselves to the port and appear as multiple devices to the joystick subsystem. Therefore, the game developer can take advantage of full device support for two or more gaming devices.</p>
<p>
The following code fragment demonstrates how to maintain multiple device contexts and to detect what device is attached and what its capabilities are.</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;mmsystem.h&gt;
. . .
typedef struct _CONTEXTINFO
{
 UINT id;&nbsp;&nbsp;&nbsp; // Keep the joystick ID here.
 char szOEMProductName[128]; // OEM product name.
 JOYCAPS JoyCaps;&nbsp; // Joystick capabilities.
} CONTEXTINFO;
typedef struct _JOYCONTEXT
{
 UINT nDevices;&nbsp;&nbsp; // Number of joysticks connected (number of CONTEXTINFO)
 CONTEXTINFO ContextInfo[16]; // Up to 16 joystick device contexts.
} JOYCONTEXT, *PJOYCONTEXT;
/****************************************************************
** void joyGetContext(PJOYCONTEXT pjc)
**
** Description :&nbsp; Get the current joystick devices' context.
**
** Parameters : PJOYCONTEXT pjc - pointer to JOYCONTEXT structure 
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; containing the current state of the
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connected joystick devices (see above
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; declaration).
**
** Returns&nbsp; : None.
**
*****************************************************************/
void joyGetContext(PJOYCONTEXT pjc)
{
 UINT JoyID;
 UINT i=0;
 JOYINFOEX ji;
 ji.dwSize = sizeof(JOYINFOEX);
 for (JoyID=JOYSTICKID1; JoyID&lt;joyGetNumDevs(); JoyID++)
 {
  if (joyGetPosEx(JoyID, &amp;ji)==JOYERR_NOERROR)
  {
 &nbsp; pjc-&gt;ContextInfo[i].id = JoyID;
 &nbsp; joyGetOEMProductName(JoyID, pjc-&gt;ContextInfo[i].szOEMProductName);
 &nbsp; joyGetDevCaps(JoyID, &amp;pjc-&gt;ContextInfo[i].JoyCaps,sizeof(JOYCAPS));
 &nbsp; i++;
  }
 }
 pjc-&gt;nDevices= i;
}
</code></pre>
</BODY>
</HTML>
