<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft Access Basic Tips, Tricks, and Traps</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_abcttt"></a>Microsoft Access Basic Tips, Tricks, and Traps</h1>
<p>
Brian C. Blackman<br>
Systems Support Engineer, Microsoft Access</p>
<p>
Created: July 6, 1993</p>
<h2>Abstract</h2>
<p>
This article outlines techniques that when applied to Microsoft® Access®, using Access Basic, can increase application execution speed, decrease code size, and reduce common pitfalls in application development when programming for the Microsoft Windows™ APIs (application programming interfaces). Prudent use of variables and the memory space those variables occupy can significantly reduce the resources an application consumes and increase its overall performance.</p>
<p>
Incorrect calling of Windows APIs will have undesirable side effects and potentially corrupt an application's code or data segment. Correct use of a Null 32-bit (far) pointer in Microsoft Access is imperative.</p>
<p>
Microsoft Access has an undocumented feature that can be used when working with forms and reports. This feature allows you to make a procedure call from the design view Property Sheet window by pressing the SHIFT + F2 key combination.</p>
<h2>Introduction</h2>
<p>
Microsoft® Access® Basic provides a rich development environment that gives you the flexibility and control of Microsoft Windows™ APIs while shielding you from many of the frustrations associated with using high- and low-level language development environments. However, many aspects of optimization and efficient data and code modeling can only be applied by the application designer. The developer should rely on prudent use of efficient algorithms. In addition to general programming concepts, there are specific memory management techniques that when correctly used can increase the application's execution speed and decrease the memory resource the application consumes.</p>
<h2>Increasing the Speed and Decreasing the Size of Your Code</h2>
<p>
You can use several tricks to increase the speed of your code, but there's no substitute for efficient algorithms. Following are several suggestions to increase the speed of your code and decrease the memory your application consumes.</p>
<h3>Use Integer Data Types for Mathematical Calculations</h3>
<p>
Even though Access will use a coprocessor for floating-point math, integer math is always faster. Use Integer or <b>Long</b> data types in place of <b>Variant</b> or <b>Double</b> data types when your calculations don't include fractional values. <b>Integer</b> division <b>(\)</b> is faster than floating-point division <b>(/)</b>. A warning in using more efficient data types: The code will be less forgiving. Remember, there's no substitute for efficient algorithms.</p>
<h3>Use In-Line Code in Place of Procedure Calls</h3>
<p>
Avoid the use of Sub or Function calls in loops. Each call adds to the code's overhead by involving additional work and time. Each call requires that the function's local variables and arguments be placed on the stack. The stack size is fixed, cannot be increased, and is shared with Microsoft Access.</p>
<h3>Use the Variant Data Type Judiciously</h3>
<p>
The <b>Variant</b> provides greater flexibility, such as allowing proper handling of Nulls and automatic handling of overflows. Yet this data type is larger and consumes more memory for storage than conventional data types. As previously mentioned, <b>Variant</b> variables are slower in mathematical calculations.</p>
<h3>Use Variables to Store Frequently Used Properties</h3>
<p>
You can reference and set <b>Variables</b> faster than properties. If you are getting or referring to the value of a property many times, your code will run faster if you assign the property to a variable and use the variable instead. For example, in a loop you refer to a property of a control on a form; it is faster to assign the property to a variable outside the loop and then reference the variable in the loop instead of the property.</p>
<h3>Preload Forms</h3>
<p>
The performance of your application can be perceived as fast if you load all your forms when your application starts and set their visible property to False. When you need to show a form you just set the visible property to True—which is faster than loading the form. Remember that you will be consuming memory from the application's global heap for every form you load.</p>
<h2>Traps in Access Basic</h2>
<p>
A frequently encountered trap in Access Basic is the use of external procedures in dynamic-link libraries (DLLs). When you supply your customers and clients with solutions, use caution when calling external DLLs; otherwise expect to get the error message "Tried to load module with duplicate procedure definition."</p>
<h3>Use Unique Alias Names</h3>
<p>
In Access Basic you can call external procedures in DLLs when you know the entry point (the name of the function in the DLL). However, the caveat is that you can only declare the external procedure once. If you load a library that calls the same Windows API that your module calls, you will get the infamous error, "Tried to load module with duplicate procedure definition."</p>
<p>
You tried to load a module that either contains duplicate procedure names or contains procedure names that are in use by procedures in existing modules. To remove these procedures, use the Find command on the Edit menu to find the duplicate procedure names. To work around this problem you need to use a technique called <i>aliasing </i>that will allow you to give your procedure an unique name. There's always a chance that the alias you chose is not unique. So, to make your alias unique, you can precede all your declared procedures from DLLs with your initials and an underscore. For example, declare <b>GetActiveWindow</b> as:</p>
<pre><code>Declare bcb_GetActiveWindow Lib "Kernel" Alias "GetActiveWindow" () As Integer
</code></pre>
<h3>How to Pass 32-Bit Null Pointers to DLLs</h3>
<p>
A null 32-bit (far) pointer is a valid or required parameter for some dynamic-link libraries (DLLs). To specify a null value, use 0&amp;. When your function calls a procedure and passes the expression <b>0&amp;</b>, the ampersand (&amp;) specifies a 32-bit (far) null pointer. In a function declaration, an <b>As Any</b> parameter instructs Access Basic to omit type checking for that parameter and to pass the value to the called function.</p>
<p>
The following code demonstrates the correct method to declare an Access Basic function that passes a null parameter to a procedure in a DLL. This code declares the <b>WriteProfileString</b> API function from the external Windows dynamic-link library "kernel."</p>
<pre><code>Declare Function WriteProfileString Lib "Kernel" (ByVal lpApplicationName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Any, ByVal lpKeyName As Any, ByVal lpString As Any)
</code></pre>
<p>
The following function calls the external procedure, specifying null for each argument. This causes <b>WriteProfileString</b> to flush its internal cache and writes to disk any changes to WIN.INI.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Incorrect use of this function can cause a general protection fault or modify your WIN.INI file.</p>
<pre><code>Function nFlushIniCache()
 &nbsp; nFlushIniCache = WriteProfileString (0&amp;, 0&amp;, 0&amp;)
End Function
</code></pre>
<h3>How to Pass and Receive Unsigned Integers from DLLs</h3>
<p>
There are situations in which calling procedures from external DLLs returns a 2-byte unsigned integer. Access Basic doesn't support this data type. Correctly evaluating this data type requires converting it from an unsigned integer to an Access Basic long data type.</p>
<p>
The Access Basic integer data type has a range of -32,768 to 32,767. An unsigned integer has a range of 0 to 65,536. Access Basic uses the most significant bit to set the sign of the value. Therefore, when a value exceeds 32,767, bit 16 is set to reflect a negative number. To evaluate an unsigned integer, you must manually adjust bit 16.</p>
<p>
There are two methods you can use to convert to and from the unsigned integer type to the Access Basic long data type. The first method uses basic arithmetic (65,536 is subtracted or added to the unsigned integer). The second uses bitwise operators. The <b>Arithmetic </b>method works as well as the <b>Bitwise </b>method; however, the arithmetic method may be more readable, and the bitwise method may be faster when executed repetitively.</p>
<h4>Arithmetic method</h4>
<p>
The following lArithUintToInt (nUint) and lArithIntToUnint(lBytes) procedures demonstrate using the <b>Arithmetic</b> method of converting unsigned integers. This first function reads in an unsigned integer and returns the converted value as a long. The second function reads in a long and returns an unsigned integer.</p>
<pre><code>Function lArithUintToInt (nUint As Integer)
 &nbsp; If nUint &lt; 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp; lArithUintToInt = nUint + 65536
 &nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp; lArithUintToInt = nUint
 &nbsp; End If
End Function

Function nArithIntToUnint (lBytes As Long)
 &nbsp; If lBytes &gt; 32767 Then
 &nbsp;&nbsp;&nbsp;&nbsp; nArithIntToUnint = lBytes - 65536
 &nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp; nArithIntToUnint = lBytes
 &nbsp; End If
End Function
</code></pre>
<h4>Bitwise method</h4>
<p>
The following nBWUintToInt(lBytes) and lBWIntToUint(nUint) procedures demonstrate using the <b>Bitwise</b> method of converting unsigned integers. The first function reads in an unsigned integer and returns the converted value as a long. The second function reads in a long and returns an unsigned integer. The message box statement in the second function is used to prevent an overflow message when the value passed to the function is greater than 64 kB.</p>
<p>
To illustrate what is taking place in the first bitwise function, nUint equals -23584, a value returned from an external DLL that is an unsigned integer and needs to be converted to a long:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1010001111100000 (-23584)
 &nbsp;&nbsp;&nbsp; AND 1111111111111111 (FFFF&amp;)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------------
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1010001111100000 (41952)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</code></pre>
<p>
The functions follow:</p>
<pre><code>Function lBWIntToUint(nUint As Integer)
 &nbsp; lBWIntToUint = nUint And &amp;HFFFF&amp;
End Function

Function nBWUintToInt(lBytes As Long)
 &nbsp; Dim nTemp As Integer
 &nbsp; If lBytes &gt; 65535 Then
 &nbsp;&nbsp;&nbsp;&nbsp; MsgBox "You passed a value larger than 65535"
 &nbsp;&nbsp;&nbsp;&nbsp; Exit Function
 &nbsp; End If

 &nbsp; nTemp = lBytes And &amp;H7FFF
 &nbsp; nBWUintToInt = nTemp Or -(lBytes And &amp;H8000)
End Function
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The &amp;HFFFF&amp; requires the "&amp;" at the end of the hex number. This qualifies the hex number as 32-bit versus 16-bit value.</p>
<h2>Tricks in Access Basic</h2>
<p>
There is a previously undocumented feature in Microsoft Access that allows you to specify procedures that are called from the Property Sheet window of a form or report when you press the key stroke combination for Zoom View, shift + f2.</p>
<h3>BuilderForm Functions</h3>
<p>
If a function identifier in a module begins with "BuilderForm" and contains a property or event identifier such as <b>OnClose</b>, pressing the key combination shift + f2 will call this procedure. For example, when you're in design view of a form and the cursor location is in the edit control of the OnClose event in the Property Sheet window, pressing shift + f2 will call the <b>BuilderFormOnClose</b> function. This applies to most properties and all events of both forms and reports. The format of the function is demonstrated in the following code:</p>
<pre><code>Function BuilderFormOnClose (szFormName As String, szControlName As String,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szCurrentValue As String, szReserved As String)

 &nbsp; If szCurrentValue = "" Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DoCmd SelectObject A_MACRO, "", True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendKeys "%n%fs" &amp; "New Macro" &amp; "{Enter}"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Forms(szFormName).OnClose = "New Macro"
 &nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp; DoCmd SelectObject A_MACRO, szCurrentValue, True
 &nbsp;&nbsp;&nbsp;&nbsp; SendKeys "%d"
 &nbsp; End If
 &nbsp;&nbsp; 
End Function
</code></pre>
<p>
The arguments <i>szFormName</i>, <i>szControlName</i>, <i>szCurrentValue</i>, and <i>szReserved</i> must be declared even if you never use them. When your function is called, these arguments are always passed. If they're not declared then Microsoft Access doesn't call your function. The preceding procedure opens a macro if one is assigned to the OnClose event; if the edit control is empty the code creates a new macro called "New Macro" and sets the edit control value to "New Macro". Granted, the preceding example is not very elegant, but it does demonstrate the necessary components to create elegant and efficient database solutions.</p>
</BODY>
</HTML>
