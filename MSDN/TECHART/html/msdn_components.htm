<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMponents</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_components"></a>COMponents</h1>
<p>
Written and developed by Steve Robinson and Alex Krassel<br>
Panther Software (http://www.panthersoft.com/)</p>
<p>
August 8, 1997 </p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5161">
</OBJECT><a href="javascript:sample1.Click()">Click here to copy the COMponent sample files associated with this technical article.</a></p>
<h4>Contents </h4>
<p>
<a href="#components_over">Overview</a></p>
<p>
&nbsp;&nbsp;&nbsp;<a href="#components_purpose">Purpose</a></p>
<p>
&nbsp;&nbsp;&nbsp;<a href="#components_need">What You Will Need</a></p>
<p>
<a href="#components_part1">Part 1: Duplicating Interfaces</a></p>
<p>
<a href="#components_part2">Part 2: Mixing Class Inheritance with Interfaces Inheritance</a></p>
<h2><a name="components_over"></a>Overview</h2>
<p>
Traditional software development requires application executables to be compiled and linked with their dependencies. Every time a developer wants to use a different processing logic or new capabilities, he or she needs to modify and recompile the primary application to support them. </p>
<p>
In manufacturing, this limitation would never be allowed. Can you imagine if you had to rebuild your car engine if you wanted to change your tires from the ones the manufacturer issued to high-performance tires? While this might appear to be a windfall for mechanics, the excessive maintenance costs would actually diminish demand for automobiles, and everyone—consumers, automobile manufacturers, mechanics, and parts manufacturers alike—would suffer. In fact, one of the keys to the success of the industrial revolution was the ability to "interchange machine parts," that is, the use of components. Today, we change components and plug new accessories into our cars without even giving it a second thought.</p>
<p>
Cars know nothing about the tires they use. Tires have properties (wheel width, diameter, and so forth). If their properties are consistent, two (or more) tires can be interchangeable. Lighting fixtures know nothing about the light bulbs they use. If the properties of the light bulbs (such as the diameter of the base that screws into the socket) meet the requirements of the fixture manufacturer, they are interchangeable. Isn't it about time the software industry catches up with the rest of the world and builds components that require no knowledge of how they will be used? For an industry that thinks it is so far advanced, we are actually way behind.</p>
<p>
At first glance, dynamic-link libraries (DLLs) seem to provide a solution for the problems listed above. The following fictitious story will demonstrate why this is not so.</p>
<p>
You need to develop an application for <i>CompanyX</i> Gas Tanks. The application will display the level of gasoline in <i>CompanyX</i>'s new prestigious 1,000-gallon fuel tank. First, you create an ActiveX™ gauge control that shows three data points: the tank's current level, the lowest possible safe level, and the highest possible safe level. You write a DLL called GasTankLevelGetterDLL, which exports the following functions:
<ul type=disc>
<li>
long <b>GetLowestPossibleSafeLevel()</b>;<br><br></li>
<li>
long <b>GetHighestPossibleSafeLevel()</b>;<br><br></li>
<li>
long <b>GetCurrentLevel()</b>;</li>
</ul>
<p>
Internally, GasTankLevelGetterDLL supports the device capability to read data continuously from the new 1,000-gallon <i>CompanyX</i> gas tank. Your application works like a charm and ships "bugless."</p>
<p>
A couple weeks later, Ricky Rich calls you up and says your ActiveX gauge control is the prettiest thing he has ever seen in his life. Ricky says he wants to use it to monitor the level of his 5,000-gallon fish tank. He says the gauge needs to show the same three levels as your gas control. You tell him you will get back to him tomorrow while you think it over.</p>
<p>
The next day, you conclude that you are going to name every DLL the same—LevelGetterDLL. LevelGetterDLL will export the same three functions with different internal processing. Ricky's fish tank monitoring problem is solved. He uses your application 24 hours a day to be sure his fish are safe and secure. You ship a new LevelGetterDLL to <i>CompanyX</i> as well. Other companies contact you about using your ActiveX gauge control. You respond by saying, "No problem. Export these three functions, name your DLL LevelGetterDLL, and you are ready to go." You had to recompile your application once to support the new LevelGetterDLL—but as long as everyone in the world names their DLL the same (LevelGetterDLL), and uses the same three <i>immutable</i> methods, everything will work perfectly and you will never have to recompile your application again. You go home that night feeling very smart.</p>
<p>
The next day you open <i>The Wall Street Journal</i> to find that Ricky Rich has died in a helicopter accident. While en route to Rich Inc. headquarters, Ricky's helicopter ran out of gas. It seems that Ricky was an <i>CompanyX</i> client, and he ran two applications on his PC simultaneously. Application 1 was the fish tank monitor you developed for him using the LevelGetterDLL. Application 2 was <i>CompanyX</i>'s fuel tank monitoring application that also used a version of LevelGetterDLL, the one shipped with Ricky's helicopter. Although Ricky ran both applications, Application 2, <i>CompanyX</i>'s fuel tank monitoring application, used the fish tank's LevelGetterDLL and reported the levels in the fish tank instead of <i>CompanyX</i>'s 1,000-gallon gas tank, because the version for the fish tank was copied to the computer last. Ricky never knew that his helicopter was about to run out of gas. The Rich estate sues <i>CompanyX</i> who, in turn, sues you. The other companies you advised decide to sue you as well. Had you used COM, Ricky Rich would be alive today, and you would not be in the courthouse.</p>
<p class=indent>
<b><B>Rule</B>&nbsp;&nbsp;&nbsp;</b>If two or more DLLs export the same functions (immutability), you can link either. However, a single application cannot use both DLLs, nor can they both reside on the same computer. The Component Object Model (COM) solves this problem. Two COM servers with identical interfaces (and therefore methods) can be used by two different applications and can reside on the same computer, because they have different class IDs (CLSIDs) and therefore are different binaries. Further, the two COM servers are technically interchangeable.</p>
<p>
The inability to interchange parts (components) has been tolerated in software development because of the youth of our industry. Now, however, COM provides that ability for software components. By understanding CLSIDs and interface immutability, one can write a complete plug-in without any knowledge of the client. This means Application1 can run using either Plug-In1 or Plug-In2. Better yet, Application1 can dynamically switch between Plug-In1 and Plug-In2. Designing applications to use dynamically interchangeable plug-ins will do for software development what machine parts did for the industrial revolution. </p>
<p>
With all the excitement over the ActiveX Template Library (ATL) and Distributed COM (DCOM), we tend to forget the primary reason COM was developed. DCOM's ability to leverage remote procedure calls (RPC) and marshal data is a very popular perk (and may be the reason why COM has grown in popularity during the past year), but it is not the main reason COM was developed. COM was developed so that software manufacturers could plug new accessories into existing applications without requiring a rebuild of the existing application. COM components should be designed as interchangeable plug-ins whether the COM component is a local in-process DLL or a remote server executable.</p>
<h2><a name="components_purpose"></a>Purpose</h2>
<p>
This article will demonstrate COM plug-in components that allow reuse in ways analogous to automobile tires. Using COM allows software product lines to be developed in significantly less time. Knowing how to create COM objects and interfaces is the key to building interchangeable plug-ins. </p>
<p>
Through the course of this article, we will develop a series of interchangeable COM plug-ins:
<ul type=disc>
<li>
In Part 1 of this article, we will create a new COM object whose interface duplicates an existing COM object.&nbsp; Then we will create an application that dynamically switches between the two COM objects, demonstrating the importance of immutability.&nbsp; We will create these samples using the ActiveX Template Library (ATL).<br><br></li>
<li>
Part 2 of this article will use Microsoft® Foundation Classes (MFC). We will develop COM components that provide interface implementation through class inheritance and that do not require interface declarations in their derivatives.&nbsp; This technique allows you to create new COM components that support immutability without necessarily implementing every interface—an entirely new concept that one day may be at the core of COM. This is an extremely powerful use of object-oriented programming, and it makes software development even more "componentized."</li>
</ul>
<h2><a name="components_need"></a>What You Will Need</h2>
<p>
To build the samples, you will need Microsoft Visual C++® 5.0. While you do not need 10 years of experience developing for the Microsoft Windows® platform and with the C language, you do need to have some experience with Visual C++, MFC, inheritance, and polymorphism. The samples will build and run under either Windows NT® or Windows 95. We will use the OLE/COM Object Viewer, a handy utility that ships with Visual C++ 5.0 and Microsoft Visual Basic® 5.0.</p>
<h2><a name="components_part1"></a>Part 1: Duplicating Interfaces</h2>
<p>
In the Ricky Rich story, we saw how the fish tank DLL and the gas tank DLL could not reside on the same computer, because neither the client application nor the two DLLs were COM components. Whichever DLL was copied to the computer last would be the one utilized by the client application. As we have seen, using the incorrect DLL could to lead to disastrous results. We suggested that the software developer could have used COM and had both DLLs on the machine. Because the two DLLs would be distinguishable by their CLSIDs, they could be used within one single application. With COM, both DLLs would expose identical methods, through interfaces, and would be interchangeable. </p>
<p>
To prove this point, we are going to create a single GUI application that uses and displays information taken from two different COM servers, GasTankLevelGetter.dll and GasTankLevelGetter.dll. We will also create one application that will get information from each COM DLL and display the data. Requests to each COM DLL will be toggled intermittently by a four-second timer. To emphasize immutable interfaces and that COM is a binary standard, we are going to write the GUI application and the FishTankLevelGetter.dll entirely based on information in the GasTankLevelGetter.dll. However, we are not going to give you the source code to the GasTankLevelGetter.dll. If you download the sample code, you will find the GasTankLevelGetter.dll in the binaries folder. We are not even going to tell you whether GasTankLevelGetter<b> </b>was built with Delphi, Visual C++, Java™, COBOL, Turbo Pascal, or Visual Basic. You will, however, have to register the GasTankLevelGetter.dll with RegSvr32.</p>
<p>
Once you have registered GasTankLevelGetter.dll with RegSvr32, you are ready to start with the OLE/COM Object Viewer. You can launch the OLE/COM Object Viewer from the Visual C++ 5.0 program group located in the Programs menu of the Windows Start button. </p>
<p>
Once you have started the OLE/COM Object Viewer, click <b>Expert</b> <b>Mode</b> on the <b>View</b> menu to view Type Libraries. Scroll down the tree and open the folder titled Type Libraries. Scroll down this folder until you find GasTankLevelGetter 1.0 TypeLibrary (Ver 1.0). When this item is selected (single click), the type library ID and the path to the server will be displayed, as seen in Figure 1. </p>
<p>
<img src="components1.gif" border=0></p>
<p class=label>
<b>Figure 1. Viewing type library information in the OLE/COM Object Viewer</b></p>
<p>
Double-clicking the GasTankLevelGetter entry brings up a window showing the complete type library. This information is generated from registry entries that were created when you registered the DLL. Type library information is kept under HKEY_CLASSES_ROOT\TypeLib.</p>
<p>
<img src="components2.gif" border=0></p>
<p class=label>
<b>Figure 2. Viewing a complete type library in the OLE/COM Object Viewer</b></p>
<p>
The <b>coclass</b> statement provides a list of the supported interfaces for a component object. An object can have any number of interfaces listed in its body, specifying the full set of interfaces that the object implements, both incoming and outgoing. A quick look at the coclass entry shows the COM object's CLSID (8A544DC6-F531-11D0-A980-0020182A7050) and interface (<b>ILevelGetter</b>):</p>
<pre><code>[
 &nbsp;&nbsp;&nbsp;&nbsp; uuid(8A544DC6-F531-11D0-A980-0020182A7050),
 &nbsp;&nbsp;&nbsp;&nbsp; helpstring("LevelGetter Class")
]
 &nbsp;&nbsp;&nbsp;&nbsp; coclass LevelGetter {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [default] interface ILevelGetter;
 &nbsp;&nbsp;&nbsp;&nbsp; };
</code></pre>
<p>
By extracting the interface information just below the coclass, we can determine:
<ul type=disc>
<li>
The interface ID is 8A544DC5-F531-11D0-A980-0020182A7050.<br><br></li>
<li>
The interface is derived from <b>IUnknown</b>.<br><br></li>
<li>
The interface supports four methods. The first three methods return a long value, and the fourth method return a pointer to a BSTR.</li>
</ul>
<pre><code>&nbsp;[
 &nbsp;&nbsp;&nbsp;&nbsp; odl,
 &nbsp;&nbsp;&nbsp;&nbsp; uuid(8A544DC5-F531-11D0-A980-0020182A7050),
 &nbsp;&nbsp;&nbsp;&nbsp; helpstring("ILevelGetter Interface")
]
 &nbsp;&nbsp; interface ILevelGetter : IUnknown {
 &nbsp;&nbsp; HRESULT _stdcall GetLowestPossibleSafeLevel([out, retval] long*&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plLowestSafeLevel);
 &nbsp;&nbsp; HRESULT _stdcall GetHighestPossibleSafeLevel([out, retval]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long* plHighestSafeLevel);
 &nbsp;&nbsp; HRESULT _stdcall GetCurrentLevel([out, retval] long* 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plCurrentLevel);
 &nbsp;&nbsp; HRESULT _stdcall GetTextMessage([out, retval] BSTR* 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ppbstrMessage);
 &nbsp;&nbsp; };
</code></pre>
<p>
A more detailed look at the items in the type library verifies the methods and our interface IDs (Figure 3).</p>
<p>
<img src="components3.gif" border=0></p>
<p>
<img src="components4.gif" border=0></p>
<p class=label>
<b>Figure 3. Viewing the interface ID and methods of ILevelGetter</b></p>
<p>
Now that we know how to construct the <b>ILevelGetter</b> interface, let's create our own COM component with this information. If you desire to work with the existing sample, all source code is located in the LevelViewer folder. Start Visual C++ 5.0 and create a new project. Specify <b>ATL Com AppWizard</b> as the project type and "FishTankLevelGetter" as the project name. We suggest you create a new project folder. The <b>Projects</b> tab of the <b>New</b> dialog box should look like Figure 4.</p>
<p>
<img src="components5.gif" border=0></p>
<p class=label>
<b>Figure 4. The Projects tab of the New dialog box</b></p>
<p>
In Step 1 of 1 in the AppWizard (Figure 5), choose <b>Dynamic Link Library (DLL)</b> as the <b>Server Type</b>. Check both <b>Allow merging of proxy/stub code</b> and <b>Support MFC</b>.</p>
<p>
<img src="components6.gif" border=0></p>
<p class=label>
<b>Figure 5. The ATL COM AppWizard</b></p>
<p>
Once you have created the new FishTankLevelGetter<b> </b>project, choose <b>New Class</b> from the <b>Insert</b> menu to create a new ATL class. You can specify anything you desire as the class name but be sure the interface is named <b>ILevelGetter</b> and the interface type is <b>Custom</b>, which implies that <b>ILevelGetter</b> will be derived from <b>IUnknown</b>. Had <b>ILevelGetter</b> in the GasTankLevelGetter.dll been derived from <b>IDispatch</b>, we would have selected interface type <b>Dual</b>, which would cause the new interface to be derived from <b>IDispatch</b>. If your <b>New Class</b> dialog box looks like Figure 6, click <b>OK</b> to create the new class.</p>
<p>
<img src="components7.gif" border=0></p>
<p class=label>
<b>Figure 6. Creating your new ATL class</b></p>
<p>
The next step is to edit the FishTankLevelGetter.idl file. In the IDL file, you should have the new <b>ILevelGetter</b> interface derived from <b>IUnknown</b>. If you are working with the samples, you will see the following code, which contains the four identical immutable methods of <b>ILevelGetter</b> that appeared in the GasTankLevelGetter <b>ILevelGetter </b>interface. </p>
<pre><code>[
 &nbsp; object,
 &nbsp; uuid(7F0DFAA2-F56D-11D0-A980-0020182A7050),
 &nbsp; helpstring("ILevelGetter Interface"),
 &nbsp; pointer_default(unique)
]
interface ILevelGetter : IUnknown
{
 &nbsp; HRESULT GetLowestPossibleSafeLevel([out, retval] long* plLowestSafeLevel);
 &nbsp; HRESULT GetHighestPossibleSafeLevel([out, retval] long* plHighestSafeLevel);
 &nbsp; HRESULT GetCurrentLevel([out, retval] long* plCurrentLevel);
 &nbsp; HRESULT GetTextMessage([out, retval] BSTR* ppbstrMessage);
};
</code></pre>
<p>
If you are writing the code as we go along, you will want to add the code above so that your interface implements the four identical immutable methods. The easy way to add the code is to copy and paste directly from the <b>ITypeLib </b>viewer. Your code should look the same as the sample, with the exception of the interface ID (uuid entry). </p>
<p>
Open LevelGetter.h and declare the four methods in the class. Your class declaration should appear like the code that follows, which adds the four new methods:</p>
<pre><code>class LevelGetter : 
 &nbsp; public ILevelGetter,
 &nbsp; public CComObjectRoot,
 &nbsp; public CComCoClass&lt;LevelGetter,&amp;CLSID_LevelGetter&gt;
{
public:
 &nbsp; LevelGetter(){}

BEGIN_COM_MAP(LevelGetter)
 &nbsp; COM_INTERFACE_ENTRY(ILevelGetter)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(LevelGetter) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_LevelGetter)

// ILevelGetter
public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //THE FOUR NEW METHODS
 &nbsp; STDMETHOD (GetLowestPossibleSafeLevel)&nbsp; (long* plLowestSafeLevel);
 &nbsp; STDMETHOD (GetHighestPossibleSafeLevel) (long* plHighestSafeLevel);
 &nbsp; STDMETHOD (GetCurrentLevel) (long* plCurrentLevel);
 &nbsp; STDMETHOD (GetTextMessage) (BSTR* ppbstrMessage);
};
</code></pre>
<p>
You now need to implement the four methods. For demonstration purposes, let's keep the methods simple. Implement them any way you desire, or copy the following code from the samples.</p>
<pre><code>//---------------------------------------------------------
STDMETHODIMP LevelGetter::GetLowestPossibleSafeLevel(long* plLowestSafeLevel)
{
 &nbsp; *plLowestSafeLevel = 70;
 &nbsp; return S_OK;
}

//---------------------------------------------------------
STDMETHODIMP LevelGetter::GetHighestPossibleSafeLevel(long* plHighestSafeLevel)
{
 &nbsp; *plHighestSafeLevel = 98;
 &nbsp; return S_OK;
}

//---------------------------------------------------------
STDMETHODIMP LevelGetter::GetCurrentLevel(long* plCurrentLevel)
{
 &nbsp; *plCurrentLevel = 94;
 &nbsp; return S_OK;
}

//---------------------------------------------------------
STDMETHODIMP LevelGetter::GetTextMessage(BSTR* ppbstrMessage)
{
 &nbsp; *ppbstrMessage = ::SysAllocString(L"All clear, water level is fine");
 &nbsp; return S_OK;
}
</code></pre>
<p>
When you have implemented the methods, compile and link your COM DLL. Then we can begin to create a client application.</p>
<h2>Creating a Client for Both COM Objects</h2>
<p>
We are going to create a client application that simultaneously supports the two COM objects—<b>GasTankLevelGetter</b> and <b>FishTankLevelGetter</b>. Using AppWizard, create an MFC dialog-based application that supports both Automation and ActiveX controls (check box options during the AppWizard process). </p>
<p>
Once you have created your application, edit your main dialog box in the resource editor, so it resembles Figure7. </p>
<p>
<img src="components8.gif" border=0></p>
<p class=label>
<b>Figure 7. The main dialog box for your application</b></p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You may want to review the control IDs in the sample code, because we are going to change the values of the entries.</p>
<p>
The next step is to add message handlers for the two new buttons, Gas Tank Level and Fish Tank Level. In the sample code, these methods are called <b>OnGas</b> and <b>OnFish</b>, respectively.</p>
<p>
Once you have created the dialog class and added the message handlers for the buttons, you need to open the class and add a few additional members and methods. The first thing we do is forward declare the <b>ILevelGetter</b> interface so that we can have a class member of this interface type. The second step is to add the two additional class methods, <b>ClearMembers </b>and<b> SetNewData</b>,<b> </b>and class members <b>m_pILevelGetter </b>and <b>m_sLastCalled</b> methods. Then, use Class Wizard to add the <b>OnDestroy</b> and <b>OnTimer</b> methods. Once this is complete, your class declaration should be similar to the following class declaration shipped as sample code:</p>
<pre><code>//forward declaration so for our class member
interface ILevelGetter;

class CLevelViewerDlg : public CDialog
{
 &nbsp; DECLARE_DYNAMIC(CLevelViewerDlg);
 &nbsp; friend class CLevelViewerDlgAutoProxy;

public:
 &nbsp; CLevelViewerDlg(CWnd* pParent = NULL);&nbsp;&nbsp; // standard constructor
 &nbsp; virtual ~CLevelViewerDlg();

 &nbsp; //{{AFX_DATA(CLevelViewerDlg)
 &nbsp; enum { IDD = IDD_LEVELVIEWER_DIALOG };
 &nbsp; //}}AFX_DATA

 &nbsp; //{{AFX_VIRTUAL(CLevelViewerDlg)
 &nbsp; protected:
 &nbsp; virtual void DoDataExchange(CDataExchange* pDX);&nbsp;&nbsp; // DDX/DDV support
 &nbsp; //}}AFX_VIRTUAL

// Implementation
protected:
 &nbsp; CLevelViewerDlgAutoProxy* m_pAutoProxy;
 &nbsp; HICON m_hIcon;

 &nbsp; BOOL CanExit();

//added by manually typing these into the class
 &nbsp; void ClearMembers();
 &nbsp; void SetNewData(const CLSID&amp; clsid, const IID&amp; iid);

 &nbsp; ILevelGetter* m_pILevelGetter;
 &nbsp; CString m_sLastCalled;

 &nbsp; // Generated message map functions
 &nbsp; //{{AFX_MSG(CLevelViewerDlg)
 &nbsp; virtual BOOL OnInitDialog();
 &nbsp; afx_msg void OnPaint();
 &nbsp; afx_msg HCURSOR OnQueryDragIcon();
 &nbsp; afx_msg void OnClose();
 &nbsp; virtual void OnOK();
 &nbsp; virtual void OnCancel();

//added by the Class Wizard
 &nbsp; afx_msg void OnFish();
 &nbsp; afx_msg void OnGas();
 &nbsp; afx_msg void OnDestroy();
 &nbsp; afx_msg void OnTimer(UINT nIDEvent);
 &nbsp; //}}AFX_MSG
 &nbsp; DECLARE_MESSAGE_MAP()
};
</code></pre>
<p>
The next step is to modify the implementation file. In the class constructor, initialize the member variables so the constructor appears as follows:</p>
<pre><code>CLevelViewerDlg::CLevelViewerDlg(CWnd* pParent /*=NULL*/)
 &nbsp; : CDialog(CLevelViewerDlg::IDD, pParent)
{
 &nbsp; //{{AFX_DATA_INIT(CLevelViewerDlg)
 &nbsp; //}}AFX_DATA_INIT
 &nbsp; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);
 &nbsp; m_pAutoProxy = NULL;

 &nbsp; m_pILevelGetter = NULL;
 &nbsp; m_sLastCalled = _T("CheckedGas");
}
</code></pre>
<p>
Implement the <b>ClearMembers</b> method as noted below. This function clears the dialog-box controls. (Note that we could have used dialog data exchange with class members.)</p>
<pre><code>void CLevelViewerDlg::ClearMembers()
{
 &nbsp; CWnd* pWnd = GetDlgItem(IDC_TANK_TYPE);
 &nbsp; if(pWnd != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; pWnd-&gt;SetWindowText("");

 &nbsp; pWnd = GetDlgItem(IDC_LOWEST_SAFE);
 &nbsp; if(pWnd != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; pWnd-&gt;SetWindowText("");

 &nbsp; pWnd = GetDlgItem(IDC_HIGHEST_SAFE);
 &nbsp; if(pWnd != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; pWnd-&gt;SetWindowText("");

 &nbsp; pWnd = GetDlgItem(IDC_CURRENT);
 &nbsp; if(pWnd != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; pWnd-&gt;SetWindowText("");

 &nbsp; pWnd = GetDlgItem(IDC_MESSAGE);
 &nbsp; if(pWnd != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; pWnd-&gt;SetWindowText("");
}
</code></pre>
<p>
<b>OnDestroy</b>, which follows, is used to clean up when the dialog box is destroyed:</p>
<pre><code>void CLevelViewerDlg::OnDestroy() 
{
 &nbsp; CDialog::OnDestroy();
 &nbsp; KillTimer(1);
}
</code></pre>
<p>
The class uses <b>OnTimer</b> to call the two button methods, <b>OnFish</b> and <b>OnGas</b>, so that data is updated without the user having to click a push button. </p>
<pre><code>void CLevelViewerDlg::OnTimer(UINT nIDEvent) 
{
 &nbsp; if(m_sLastCalled == _T("CheckedFish"))
 &nbsp;&nbsp;&nbsp;&nbsp; OnGas();
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; OnFish();
}
</code></pre>
<p class=indent>
<b>Note</b>&nbsp;&nbsp;&nbsp;In the real world, it would be more appropriate to use push technology and the <b>IConnectionPoint</b> interface. </p>
<p>
The virtual function <b>OnInitDialog</b> is used primarily for starting the timer, although it also retrieves data from the GasTankLevelGetter.dll.</p>
<pre><code>//--------------------------------------------------------------------
BOOL CLevelViewerDlg::OnInitDialog()
{
 &nbsp; CDialog::OnInitDialog();

 &nbsp; SetIcon(m_hIcon, TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set big icon
 &nbsp; SetIcon(m_hIcon, FALSE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set small icon

 &nbsp; OnGas();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //obtain data
 &nbsp; SetTimer(1, 4000, NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //set timer for 4 seconds

 &nbsp; return TRUE;&nbsp; // return TRUE&nbsp; unless you set the focus to a control
}
</code></pre>
<p>
Now we are ready to implement our two button methods, <b>OnFish</b> and <b>OnGas</b>, which are called intermittently every four seconds. Both of these functions are identical in procedure; they pass a CLSID and interface ID (IID) to <b>SetNewData</b>. The only difference is that the CLSID and IID passed by <b>OnGas</b> are for GasTankLevelGetter, and the CLSID and IID passed by <b>OnFish</b> are for FishTankLevelGetter. </p>
<p>
<b>OnGas</b> retrieves the CLSID based on the string globally unique identifier (GUID) that appeared with the coclass in the TypeLib information. The IID is retrieved in a similar manner based on the interface entry in the TypeLib information also shown in the OLE/COM Object Viewer. Once the GUIDs are retrieved, <b>SetNewData</b> is called.</p>
<pre><code>void CLevelViewerDlg::OnGas() 
{
 &nbsp;&nbsp;&nbsp;&nbsp; m_sLastCalled = _T("CheckedGas");
 &nbsp; CLSID clsid;
 &nbsp; IID&nbsp;&nbsp; iid;&nbsp;&nbsp; 
 &nbsp; HRESULT hRes;
 &nbsp;&nbsp;&nbsp;&nbsp; hRes = AfxGetClassIDFromString(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "{8A544DC6-F531-11D0-A980-0020182A7050}", 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;clsid);
 &nbsp; 
 &nbsp; if(SUCCEEDED(hRes))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hRes = AfxGetClassIDFromString(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "{8A544DC5-F531-11D0-A980-0020182A7050}", &amp;iid);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(SUCCEEDED(hRes))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetNewData(clsid, iid); 
 &nbsp; }
}
</code></pre>
<p>
The following code shows the <b>SetNewData</b> method, which creates an instance of either the <b>GasTankLevelGetter</b> COM object or the <b>FishTankLevelGetter</b> COM object, depending on the CLSID used. Once the COM object is instantiated, <b>SetNewData</b> calls methods in the <b>ILevelGetter</b> interface to obtain data. </p>
<pre><code>void CLevelViewerDlg::SetNewData(const CLSID&amp; clsid, const IID&amp; iid)
{
 &nbsp; ClearMembers();

 &nbsp; ASSERT(m_pILevelGetter == NULL);

 &nbsp; HRESULT hRes = CoCreateInstance(clsid, NULL, CLSCTX_ALL, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iid, (void**)&amp;m_pILevelGetter);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!SUCCEEDED(hRes))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; m_pILevelGetter = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp; }

 &nbsp; long lLowestSafeLevel, lHighestSafeLevel, lCurrentLevel;
 &nbsp; BSTR bstrMessage = NULL;

 &nbsp; m_pILevelGetter-&gt;GetLowestPossibleSafeLevel(&amp;lLowestSafeLevel);
 &nbsp; m_pILevelGetter-&gt;GetHighestPossibleSafeLevel(&amp;lHighestSafeLevel);
 &nbsp; m_pILevelGetter-&gt;GetCurrentLevel(&amp;lCurrentLevel);
 &nbsp; m_pILevelGetter-&gt;GetTextMessage(&amp;bstrMessage);

 &nbsp; m_pILevelGetter-&gt;Release();
 &nbsp; m_pILevelGetter = NULL;

 &nbsp; CString sLowest, sHighest, sCurrent, sMessage;
 &nbsp; sLowest.Format("%d",lLowestSafeLevel);
 &nbsp; sHighest.Format("%d",lHighestSafeLevel);
 &nbsp; sCurrent.Format("%d",lCurrentLevel);
 &nbsp; sMessage = bstrMessage;
 &nbsp; ::SysFreeString(bstrMessage);

 &nbsp; CString sItem;
 &nbsp; if(m_sLastCalled == _T("CheckedFish"))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; //We are checking the fish tank now.
 &nbsp;&nbsp;&nbsp;&nbsp; sItem = _T("Fish Tank");
 &nbsp; }
 &nbsp; else //m_sLastCalled == _T("CheckedGas")
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; //We are checking the fish tank now.
 &nbsp;&nbsp;&nbsp;&nbsp; sItem = _T("Gas Tank");
 &nbsp; }

 &nbsp; CWnd* pWnd = GetDlgItem(IDC_TANK_TYPE);
 &nbsp; if(pWnd != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; pWnd-&gt;SetWindowText(sItem);

 &nbsp; pWnd = GetDlgItem(IDC_LOWEST_SAFE);
 &nbsp; if(pWnd != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; pWnd-&gt;SetWindowText(sLowest);

 &nbsp; pWnd = GetDlgItem(IDC_HIGHEST_SAFE);
 &nbsp; if(pWnd != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; pWnd-&gt;SetWindowText(sHighest);

 &nbsp; pWnd = GetDlgItem(IDC_CURRENT);
 &nbsp; if(pWnd != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; pWnd-&gt;SetWindowText(sCurrent);

 &nbsp; pWnd = GetDlgItem(IDC_MESSAGE);
 &nbsp; if(pWnd != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; pWnd-&gt;SetWindowText(sMessage);
}
</code></pre>
<p>
Because the interfaces are the same, we are assured that the methods will work with both COM objects. The final two steps are to implement <b>OnFish</b> and to include an interface definition. </p>
<pre><code>void CLevelViewerDlg::OnFish() 
{
 &nbsp; m_sLastCalled = _T("CheckedFish");
 &nbsp; CLSID clsid;
 &nbsp; IID&nbsp;&nbsp; iid;&nbsp;&nbsp; 
 &nbsp; HRESULT hRes = AfxGetClassIDFromString(
 &nbsp;&nbsp;&nbsp;&nbsp; "{7F0DFAA3-F56D-11D0-A980-0020182A7050}", &amp;clsid);
 &nbsp; 
 &nbsp; if(SUCCEEDED(hRes))
 &nbsp;&nbsp;&nbsp;&nbsp; hRes = AfxGetClassIDFromString(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "{7F0DFAA2-F56D-11D0-A980-0020182A7050}", &amp;iid);

 &nbsp; if(SUCCEEDED(hRes))
 &nbsp;&nbsp;&nbsp;&nbsp; SetNewData(clsid, iid);
}
</code></pre>
<p>
The interface definition, made up of pure virtual members, is included at the top of our implementation file (although it can also be in the class declaration file or a separate .h file) so that our class member <b>m_pILevelGetter</b> of type <b>ILevelGetter*</b> knows its methods. The interface declaration follows:</p>
<pre><code>interface ILevelGetter : public IUnknown
{
public:
virtual HRESULT STDMETHODCALLTYPE GetLowestPossibleSafeLevel(long* 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plLowestSafeLevel) = 0;
virtual HRESULT STDMETHODCALLTYPE GetHighestPossibleSafeLevel(long* 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plLowestSafeLevel) = 0;
virtual HRESULT STDMETHODCALLTYPE GetCurrentLevel(long* plLowestSafeLevel) = 0;
virtual HRESULT STDMETHODCALLTYPE GetTextMessage(BSTR* pbstrMessage) = 0;
};
</code></pre>
<p>
We are now ready to compile, link, and run the application. When you run the application, you have the option of clicking the buttons to swap the COM components, or allowing the timer to change them every four seconds. You are now dynamically interchanging components. Now Ricky Rich can fly his helicopter and monitor his fish tank without worries.</p>
<h2><a name="components_part2"></a>Part 2: Mixing Class Inheritance with Interfaces Inheritance</h2>
<p>
In Part 1 of the article, we showed the importance of interface immutability and demonstrated how a developer can build applications that can easily interchange components once an interface is developed. What if the interface of the existing COM server had hundreds of methods? In the sample in Part 1, we made it easy to clone the <b>ILevelGetter </b>interface because it had only four methods. Using the OLE/COM Object Viewer, take a quick look at some of the other type libraries on your computer. As you can see, many components have interfaces with a significant number of methods. Cloning an interface that implemented hundreds of methods would be quite a burden if you needed to override only a few methods.</p>
<p>
The rules of COM specify that if you derive an interface from an existing interface, you need to implement all its methods, because interface declarations contain pure virtual functions. The same rule that guarantees interchangeable "machine parts" might also create laborious, unnecessary implementation burdens for developers!</p>
<p>
But what if you could inherit interfaces without having to reimplement all the methods? What if you could create a component, inherit interfaces and functionality, and override functionality as you saw fit? Today, it is impossible to do this with COM objects developed outside your organization. However, if the developers within your enterprise use a programming language that supports inheritance and polymorphism, such as Visual C++, you can do exactly this. In fact, MFC makes it extremely easy to do, as we will demonstrate.</p>
<p>
At the root of MFC is <b>CCmdTarget</b>. <b>CCmdTarget</b> is not only the base class for the message-map architecture, but it also contains dispatch maps that expose interfaces such as <b>IDispatch</b> and <b>IUnknown.</b> Every direct descendant of <b>CCmdTarget</b> created with Class Wizard contains these interfaces and its own CLSID. <b>CCmdTarget</b> is a key framework class and a base class for MFC classes used every day, such as <b>CView</b>, <b>CWinApp</b>, <b>CDocument</b>, <b>CWnd</b>, and <b>CFrameWnd</b>. Accordingly, every class derived from <b>CCmdTarget</b> can implement its own CLSID and interfaces. </p>
<p>
The sample code we are going to review will show inheritance of interfaces by deriving new C++ classes from classes derived from a <b>CCmdTarget</b>. In our base class, we will implement an interface with methods that call virtual member functions in the C++ class. Our derived class will override some of the selected virtual functions. Most importantly, instead of implementing the derived class in the same DLL, we will create a distinct DLL with its own CLSID. The effective result will be inheritance of interface implementation from one binary to another without reimplementing the original interface.</p>
<p>
Let's start by reviewing the code in project BaseLevelGetterDLL. BaseLevelGetterDLL is a typical MFC DLL. It was created with AppWizard as a "regular DLL using the shared MFC DLL." It also supports Automation. Once the AppWizard process was complete, the file BaseLevelGetterExport.h was created, and BASE_LEVEL_GETTER_DLL was included as a preprocessor definition in the C++ tab of the <b>Project Settings</b> dialog box (click on the <b>Project</b> tab and then click <b>Project</b>). The BaseLevelGetterExport.h code follows and the <b>Project Settings</b> dialog box is shown in Figure 8.</p>
<pre><code>//BaseLevelGetterExport.h
#ifndef BASE_LEVEL_GETTER_EXPORT_DLL_H
#define BASE_LEVEL_GETTER_EXPORT_DLL_H

#if defined(BASE_LEVEL_GETTER_DLL)
 &nbsp; #define BASE_LEVEL_GETTER_EXPORT __declspec(dllexport)
#else
 &nbsp; #define BASE_LEVEL_GETTER_EXPORT __declspec(dllimport)
#endif

#endif //BASE_LEVEL_GETTER_EXPORT_DLL_H
</code></pre>
<p>
<img src="components9.gif" border=0></p>
<p class=label>
<b>Figure 8. The Project Settings dialog box</b></p>
<p>
With BASE_LEVEL_GETTER_DLL defined, we can create classes and export them from our DLL.</p>
<p>
The next step is to create the C++ class that will contain our interface. Using Class Wizard, we will create a class derived from <b>CCmdTarget</b> with just a few mouse clicks. By selecting <b>Createable by type ID</b> in Class Wizard's New Class dialog, our new class will be created with the <b>IMPLEMENT_OLECREATE</b> macro, giving the class its own CLSID and <b>IDispatch</b> interface.</p>
<p>
<img src="components10.gif" border=0></p>
<p class=label>
<b>Figure 9. Creating a class derived from CCmdTarget</b></p>
<p>
Glancing at BaseLevelGetter.cpp, we see the CLSID: </p>
<pre><code>//Here is our CLSID
// {C20EA055-F61C-11D0-A25F-000000000000}
IMPLEMENT_OLECREATE(BaseLevelGetter, "BaseLevelGetterDLL.BaseLevelGetter", 0xc20ea055, 0xf61c, 0x11d0, 0xa2, 0x5f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)
and an interface called <b>IBaseLevelGetter</b>, which is of type <b>IDispatch</b>:
// {C20EA054-F61C-11D0-A25F-000000000000}
static const IID IID_IBaseLevelGetter =
{ 0xc20ea054, 0xf61c, 0x11d0, { 0xa2, 0x5f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 } };

BEGIN_INTERFACE_MAP(BaseLevelGetter, CCmdTarget)
 &nbsp; INTERFACE_PART(BaseLevelGetter, IID_IBaseLevelGetter, Dispatch)
END_INTERFACE_MAP()
</code></pre>
<p>
Rather than working with the default interface provided by Class Wizard, we are going to add our own custom interface to demonstrate how easy it is to add interfaces to <b>CCmdTarget</b>-derived classes. The first thing we need to do is to define our interface. Defining an interface is always the same. Every interface must have an IID and have <b>IUnknown</b> as a base interface somewhere in its hierarchy. And it needs to implement the three methods of <b>IUnknown</b>. In ILevelGetter.h, we used guidgen.exe (located in \Program Files\DevStudio\VC\Bin) to generate a unique IID for our interface and the derived interface from <b>IUnknown</b>. In addition to the three pure virtual functions of<b> IUnknown</b>, we added four more pure virtual functions that will be implemented in our COM object. Below is the exact code from ILevelGetter.h.</p>
<pre><code>#ifndef ILEVELGETTER_H
#define ILEVELGETTER_H

// {BCB53641-F630-11d0-A25F-000000000000}
static const IID IID_ILevelGetter = 
{ 0xbcb53641, 0xf630, 0x11d0, { 0xa2, 0x5f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 } };

interface ILevelGetter : public IUnknown
{
//first add the three always required methods
 &nbsp; virtual HRESULT STDMETHODCALLTYPE 
 &nbsp;&nbsp;&nbsp;&nbsp; QueryInterface(REFIID riid, LPVOID* ppvObj) = 0;
 &nbsp; virtual ULONG STDMETHODCALLTYPE AddRef()&nbsp; = 0;
 &nbsp; virtual ULONG STDMETHODCALLTYPE Release() = 0;
//now add methods for this custom interface
 &nbsp; virtual HRESULT STDMETHODCALLTYPE 
 &nbsp;&nbsp;&nbsp;&nbsp; GetCurrentLevel(long* plCurrentLevel) = 0;
 &nbsp; virtual HRESULT STDMETHODCALLTYPE
 &nbsp;&nbsp;&nbsp;&nbsp; GetHighestPossibleSafeLevel(long* plHighestSafeLevel) = 0;
 &nbsp; virtual HRESULT STDMETHODCALLTYPE
 &nbsp;&nbsp;&nbsp;&nbsp; GetLowestPossibleSafeLevel(long* plLowestSafeLevel) = 0;
 &nbsp; virtual HRESULT STDMETHODCALLTYPE
 &nbsp;&nbsp;&nbsp;&nbsp; GetTextMessage(BSTR* ppbstrMessage) = 0;
};
</code></pre>
<p>
The next step is to declare our interface methods in BaseLevelGetter.h. At the top of BaseLevelGetter.h, add an include directive for our interface declaration as follows:</p>
<pre><code>#include "ILevelGetter.h"
</code></pre>
<p>
Once we include ILevelGetter.h, we can add our interface methods using the <b>BEGIN_INTERFACE_PART</b> macro. In summary, the <b>BEGIN_INTERFACE_MACRO </b>creates a nested class of type <b>XLevelGetter</b> and a class member <b>m_xLevelGetter</b> in BaseLevelGetter. (For a thorough description of the <b>BEGIN_INTERFACE_PART</b> macro, see MFC Technical Note 38 <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_MFCNOTES_TN038">
</object><a href=JavaScript:alink_1.Click()>"MFC/OLE IUnknown Implementation."</a>) Each method in the interface is declared in the macro in the same manner as if there were no macro wrapper. A quick review shows that the method declarations in ILevelGetter.h are exactly the same as the method declarations declared in the ATL version.</p>
<pre><code>BEGIN_INTERFACE_PART(LevelGetter, ILevelGetter)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; STDMETHOD(GetCurrentLevel)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (long* plCurrentLevel);
 &nbsp; STDMETHOD(GetHighestPossibleSafeLevel)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (long* plHighestSafeLevel);
 &nbsp; STDMETHOD(GetLowestPossibleSafeLevel)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (long* plLowestSafeLevel);
 &nbsp; STDMETHOD(GetTextMessage)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (BSTR* ppbstrMessage);
END_INTERFACE_PART(LevelGetter)
</code></pre>
<p>
Because our goal is to inherit interfaces from one binary to another without having to reimplement all the methods, we are going to add four virtual functions to our class. Each virtual function will correspond to a method in the <b>ILevelGetter</b> interface. In the sample code, these methods are defined at the bottom of the class declaration, immediately after the <b>BEGIN_INTERFACE_PART</b> macro, as follows.</p>
<pre><code>//since the class can be dynamically created
//these virtual functions cannot be pure
virtual long GetCurrentLevel();
virtual long GetHighestSafeLevel();
virtual long GetLowestSafeLevel();
virtual CString GetMessage();
</code></pre>
<p>
One thing to note is that because our <b>CCmdTarget</b>-derived class uses <b>DECLARE_DYNCREATE</b>, these functions cannot be pure virtual functions. </p>
<p>
The last task is to declare the class as "exportable." To do this, we need only to include our export definition in the class definition. The lines appear as:</p>
<pre><code>#include "BaseLevelGetterExport.h"
class BASE_LEVEL_GETTER_EXPORT BaseLevelGetter : public CCmdTarget
{&nbsp;&nbsp; 
</code></pre>
<p>
Implementation of our interface is equally easy. The first thing we need to do is to add support for the new <b>ILevelGetter</b> interface. The general rule is to add an <b>INTERFACE_PART</b> macro between <b>BEGIN_INTERFACE_PART</b> and <b>END_INTERFACE_PART</b> for every interface supported. In BaseLevelGetter.cpp, this is accomplished by adding the following line:</p>
<pre><code>INTERFACE_PART(BaseLevelGetter, IID_ILevelGetter, LevelGetter)
</code></pre>
<p>
So that the entire <b>INTERFACE_PART</b> appears as:</p>
<pre><code>BEGIN_INTERFACE_MAP(BaseLevelGetter, CCmdTarget)
 &nbsp; INTERFACE_PART(BaseLevelGetter, IID_IBaseLevelGetter, Dispatch)
 &nbsp; INTERFACE_PART(BaseLevelGetter, IID_ILevelGetter, LevelGetter)
END_INTERFACE_MAP()
</code></pre>
<p>
The next step is to implement the <b>ILevelGetter </b>methods. The first three methods that should be implemented are from <b>IUnknown</b>: <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b>. These methods are shown below: </p>
<pre><code>//------------------------------------------------------------------------
HRESULT FAR EXPORT BaseLevelGetter::XLevelGetter::QueryInterface
(
 &nbsp; REFIID&nbsp; iid, 
 &nbsp; LPVOID* ppvObj
)
{
 &nbsp; METHOD_PROLOGUE_EX_(BaseLevelGetter, LevelGetter)
 &nbsp; return (HRESULT) pThis-&gt;ExternalQueryInterface(&amp;iid, ppvObj);
}

//-------------------------------------------------------------------------
ULONG FAR EXPORT BaseLevelGetter::XLevelGetter::AddRef()
{
 &nbsp; METHOD_PROLOGUE_EX_(BaseLevelGetter, LevelGetter)
 &nbsp; return (ULONG) pThis-&gt;ExternalAddRef();
}

//-------------------------------------------------------------------------
ULONG FAR EXPORT BaseLevelGetter::XLevelGetter::Release()
{
 &nbsp; METHOD_PROLOGUE_EX_(BaseLevelGetter, LevelGetter)
 &nbsp; return (ULONG) pThis-&gt;ExternalRelease();
}
</code></pre>
<p>
The four <b>ILevelGetter</b> methods are implemented in a very similar fashion. Rather than performing actual processing, each method calls its associated function through the pointer pThis. This actually requires some additional explanation. If you look at the definition of the <b>BEGIN_INTERFACE_PART(</b>. . .<b>) </b>macro (file located at …\MFC\include\afxdisp.h), you will notice that this macro is a nested class declaration. The macro forces the nested class (in our case, <b>XLevelGetter</b>) to be derived from the interface (<b>ILevelGetter</b>, in our example) and to be declared within the existing class (<b>BaseLevelGetter</b>). </p>
<p>
The <b>END_INTERFACE_PART(</b>. . .<b>)</b> macro completes the "inner" <b>XLevelGetter</b> class definition and declares a member variable of that class called <b>m_xLevelGetter</b>. Because <b>m_xLevelGetter</b> is a member of the <b>BaseLevelGetter</b> class, we could implement some complicated pointer arithmetic to get from <i>X</i> of the <b>XLevelGetter</b> object to <i>Y</i> of the containing <b>BaseLevelGetter</b> object. However, MFC provides another macro that does just that. This macro is called <b>METHOD_PROLOGUE_EX_</b>, and in our particular case it will generate the variable<i> BaseLevelGetter* pThis. </i>You can use pThis to access public members and methods of the "outer" <b>BaseLevelGetter<i> </i></b>class, including virtual (polymorphic) functions, as we do in the samples. Calling virtual functions in the "outer" class will, in effect, cause interface inheritance. Notice that the <b>BaseLevelGetter</b> virtual functions return meaningless values and have comments to remind developers creating derived classes to override these functions. </p>
<p>
Another way to show the virtual relationship, and perhaps much easier to read, is to "set an owner object" in the <b>XLevelGetter</b> class (the class created by the <b>BEGIN_INTERFACE_PART </b>macro). Inside the BaseLevelGetter.h <b>BEGIN_INTERFACE_PART</b> macro, we add two functions and a class member as follows:</p>
<pre><code>XLevelGetter() { m_pOwner = NULL; }&nbsp; //constructor sets member to NULL
void SetOwner( BaseLevelGetter* pOwner ) { m_pOwner = pOwner; } //set the member
BaseLevelGetter* m_pOwner; //class member
</code></pre>
<p>
Inside the <b>BaseLevelGetter</b> constructor, we call <b>XLevelGetter::SetOwner</b>. As noted earlier, the <b>BEGIN_INTER</b>F<b>ACE_PART </b>macro adds a class member to <b>BaseLevelGetter</b>,<b> </b>called <b>m_xLevelGetter</b>, that represents the <b>LevelGetter</b>. In the <b>BaseLevelGetter</b> constructor we call: </p>
<pre><code>m_xLevelGetter.SetOwner( this );
</code></pre>
<p>
which sets <b>m_pOnwer</b> to a valid object.</p>
<p>
Below is the implementation of the four <b>ILevelGetter</b> methods and the four <b>BaseLevelGetter</b> associated virtual functions. The latter two methods, <b>GetLowestPossibleSafeLevel</b> and <b>GetTextMessage</b> use the "owner object" implementation style.</p>
<pre><code>//----------------------------------------------------------
STDMETHODIMP BaseLevelGetter::XLevelGetter::GetCurrentLevel
(
 &nbsp; long* plCurrentLevel
)
{
 &nbsp; METHOD_PROLOGUE_EX_(BaseLevelGetter, LevelGetter)
 &nbsp; //call outer object's GetCurrentLevel
 &nbsp; //whether this class or a derived class
 &nbsp; *plCurrentLevel = pThis-&gt;GetCurrentLevel();
 &nbsp;&nbsp;&nbsp;&nbsp; return S_OK;
}

//-----------------------------------------------------------
STDMETHODIMP BaseLevelGetter::XLevelGetter::GetHighestPossibleSafeLevel
(
 &nbsp; long* plHighestSafeLevel
)
{
 &nbsp; METHOD_PROLOGUE_EX_(BaseLevelGetter, LevelGetter)
 &nbsp; //call outer object's GetHighestSafeLevel
 &nbsp; //whether this class or a derived class
 &nbsp; *plHighestSafeLevel = pThis-&gt;GetHighestSafeLevel();
 &nbsp;&nbsp;&nbsp;&nbsp; return S_OK;
}

//-----------------------------------------------------------
STDMETHODIMP BaseLevelGetter::XLevelGetter::GetLowestPossibleSafeLevel
(
 &nbsp; long* plLowestSafeLevel
)
{
 &nbsp; METHOD_PROLOGUE_EX_(BaseLevelGetter, LevelGetter)
 &nbsp; //call outer object's GetLowestSafeLevel
 &nbsp; //whether this class or a derived class
 &nbsp;&nbsp;&nbsp;&nbsp; if( m_pOnwer != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *plLowestSafeLevel = m_pOwner-&gt;GetHighestSafeLevel();
 &nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; return S_OK;
}

//-----------------------------------------------------------
STDMETHODIMP BaseLevelGetter::XLevelGetter::GetTextMessage
(
 &nbsp; BSTR* ppbstrMessage
)
{
 &nbsp; METHOD_PROLOGUE_EX_(BaseLevelGetter, LevelGetter)
 &nbsp; //call outer object's GetMessage
 &nbsp; //whether this class or a derived class
 &nbsp; CString sMessage;
 &nbsp;&nbsp;&nbsp;&nbsp; If( m_pOwner != NULL ) 
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sMessage = m_pOwner-&gt;GetMessage();
 &nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; *ppbstrMessage = sMessage.AllocSysString();
 &nbsp;&nbsp;&nbsp;&nbsp; return S_OK;
}

//-----------------------------------------------------------
long BaseLevelGetter::GetCurrentLevel()
{
 &nbsp; TRACE("Derived classes should override!");
 &nbsp; return -1;
}

//-----------------------------------------------------------
long BaseLevelGetter::GetHighestSafeLevel()
{
 &nbsp; TRACE("Derived classes should override!");
 &nbsp; return -1;
}

//-----------------------------------------------------------
long BaseLevelGetter::GetLowestSafeLevel()
{
 &nbsp; TRACE("Derived classes should override!");
 &nbsp; return -1;
}

//-----------------------------------------------------------
CString BaseLevelGetter::GetMessage()
{
 &nbsp; TRACE("Derived classes should override!");
 &nbsp; return "BaseLevelGetter";
}
</code></pre>
<p>
Compile and link the application. Once the DLL is built, copy it to the Windows\System directory (\WINNT\System32 on Windows NT). </p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Because we will be using the <b>ILevelGetter</b> interface from<b> BaseLevelGetter</b>, remember to register it with RegSvr32 once it is copied to the appropriate system directory. If we were using <b>BaseLevelGetter</b> as an abstract base class (for example, if the <b>BaseLevelGetter</b> virtual functions had to be overridden) and their implementation perhaps threw assertion errors, there would be no need to register the COM object with RegSvr32. </p>
<p>
To build a COM object that implements the <b>ILevelGetter </b>interface but does not have to re-implement all the methods, we create a COM DLL in the same manner as we created BaseLevelGetterDLL: We create an MFC AppWizard DLL that supports automation, and we add a class derived from <b>CCmdTarget</b>. The samples contain a project called HotTubLevelGetterDLL with a <b>CmdTarget</b>-derived class, <b>HotTubLevelGetter</b>, which was created in the Class Wizard <b>New Class</b> dialog box, as shown in Figure 10. </p>
<p>
<img src="components11.gif" border=0></p>
<p class=label>
<b>Figure 10. Creating the HotTubLevelGetter class</b></p>
<p>
The next step is to add BaseLevelGetterDLL to the include path by setting it as an Additional include directory in the C/C<b>++ </b>tab of the Project Settings dialog box, as shown in Figure 11.</p>
<p>
<img src="components12.gif" border=0></p>
<p class=label>
<b>Figure 11.Adding BaseLevelGetterDLL to the include path</b></p>
<p>
And link BaseLevelGetterDLL.lib by adding it as a Library Module in the <b>Link</b> tab of the <b>Project Settings</b> dialog box, as shown in Figure 12.</p>
<p>
<img src="components13.gif" border=0></p>
<p class=label>
<b>Figure 12. Linking BaseLevelGetterDLL.lib</b></p>
<p>
Once our project settings are complete, we follow five simple steps to complete the plug-in COM DLL.
<ol>
<li>
Open HotTubLevelGetter.h and replace all instances of <b>CCmdTarget</b> with <b>BaseLevelGetter </b>(there is only one instance of <b>CCmdTarget</b> in HotTubLevelGetter.h).<p>
<img src="components14.gif" border=0></P></li>
<li>
Add BaseLevelGetter.h as an include to the file, as shown below:<pre><code>#include &lt;BaseLevelGetter.h&gt;

class HotTubLevelGetter : public BaseLevelGetter
{
</code></pre>
</li>
<li>
Override virtual functions of <b>BaseLevelGetter</b> as desired.&nbsp; In the sample code, the following two virtual functions are declared:<pre><code>virtual CString GetMessage( ) { return "HotTubLevelGetter"; }
virtual long GetCurrentLevel( ) { return -2; }
</code></pre>
</li>
<li>
Open HotTubLevelGetter.cpp and replace all instances of <b>CCmdTarget</b> with <b>BaseLevelGetter </b>(there are five instances of <b>CCmdTarget</b> in HotTubLevelGetter.cpp).<br><br></li>
<li>
Compile and link.&nbsp; Remember to register your COM DLL with RegSvr32.</li>
</ol>
<p>
Before we demonstrate the COM plug-in in a client, let's take a look at what we have built. Classes <b>BaseLevelGetter</b> and <b>HotTubLevelGetter </b>both derive from <b>CCmdTarget</b>. When we created <b>HotTubLevelGetter</b>, we told Class Wizard to derive it from <b>CCmdTarget</b>. Recall that every class created with Class Wizard as a direct descendant of <b>CCmdTarget</b> is supplied with its own CLSID and <b>IDispatch</b> interface. When we changed the base class of <b>HotTubLevelGetter</b> from <b>CCmdTarget</b> to <b>BaseLevelGetter</b>, <b>HotTubLevelGetter</b> inherited the <b>BaseLevelGetter</b> virtual methods. </p>
<p>
When a client needs to access <b>HotTubLevelGetter</b>, it does the typical <b>CoCreateInstance(</b>. . .<b>)</b>—passing the CLSID of <b>HotTubLevelGetter</b> and <b>IID_ILevelGetter</b>, and calling the <b>LevelGetter</b> methods. When a method is executed such as <b>GetCurrentLevel</b>, <b>METHOD_PROLOGUE_EX_</b> sets pThis from an offset table, and pThis actually points to an instance of <b>HotTubLevelGetter</b>. The same thing occurs when we use <b>m_pOwner</b> (it also points to an instance of <b>HotTubLevelGetter</b>); but it is a little easier to understand, because we can watch the <b>m_xLevelGetter.SetOwner(this)</b> method execute. Let's look at the client and set some break points.</p>
<p>
In the sample code, open LevelViewer in the LevelViewer2 folder. This project is almost identical to the first LevelViewer. <b>OnFish</b> is mapped to <b>BaseLevelGetter</b>, and <b>OnGas</b> is mapped to <b>HotTubLevelGetter</b>, as shown in the following code.</p>
<pre><code>//-----------------------------------------------------------
void CLevelViewerDlg::OnFish()&nbsp;&nbsp;&nbsp; //mapped to BaseLevelGetter
{
 &nbsp; m_sLastCalled = _T("CheckedFish");
 &nbsp; CLSID clsid;
 &nbsp; HRESULT hRes = AfxGetClassIDFromString("BaseLevelGetterDLL.BaseLevelGetter", &amp;clsid);
 &nbsp; if(SUCCEEDED(hRes))
 &nbsp;&nbsp;&nbsp;&nbsp; SetNewData(clsid, IID_ILevelGetter);
}

//------------------------------------------------------------
void CLevelViewerDlg::OnGas()&nbsp; //mapped to HotTubLevelGetter
{
 &nbsp; m_sLastCalled = _T("CheckedGas");
 &nbsp; CLSID clsid;
 &nbsp; HRESULT hRes = AfxGetClassIDFromString("HotTubLevelGetterDLL.HotTubLevelGetter", &amp;clsid);
 &nbsp; if(SUCCEEDED(hRes))
 &nbsp;&nbsp;&nbsp;&nbsp; SetNewData(clsid, IID_ILevelGetter);
}
</code></pre>
<p>
Both functions call <b>SetNewData</b>, passing the CLSID created by Class Wizard and <b>IID_ILevelGetter</b> declared in ILevelGetter.h and included in LevelViewerDlg.h. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Under the <b>C++</b> tab, add \BaseLevelGetterDLL as an additional include directory.</p>
<p>
<b>SetNewData</b> works in the same manner as before. Build and link the code—but before running the application, set breakpoints at any or all of the interface methods, as shown in Figure 13.</p>
<p>
<img src="components15.gif" border=0></p>
<p class=label>
<b>Figure 13. Setting breakpoints of interface methods</b></p>
<p>
When execution stops at the breakpoint, step into the method (using either the F8 or F11 function key—depending on how your system is set up) and single step (F10 key) until you are on a line with either the pThis or the <b>m_pOwner</b> object. Examine the value. Depending on whether the timer has fired for <b>HotTubLevelGetter</b> or <b>BaseLevelGetter</b>,<b> </b>pThis (or <b>m_pOnwer</b>) will point to the correct object (Figure 14).</p>
<p>
<img src="components17.gif" border=0></p>
<p class=label>
<b>Figure 14. Stepping through a method</b></p>
<p>
As you have seen, COM plug-ins are an extremely powerful software architecture technique that can be used in real situations. </p>
<p>
For example, a health insurance company, whose business is developing and maintaining custom insurance plans for large companies, comes to you for design advice regarding a new Windows-based system. Every time they add a new plan, they have to develop new processing logic or add a slight twist to the processing logic for an existing plan, but do not have to reinvent every piece of functionality. But, as they add more plans to their system, modifying, reimplementing, or copying and pasting proven source code is impractical, because it risks integrity of proven code no matter how careful the programmers are.</p>
<p>
As a C++ COM programmer, you recognize the need for interchangeable components that support polymorphism. Consider the following: the <b>IBasePlan </b>interface nested in the <b>BasePlan</b> class implements 100 interface methods. Plan ABC's requirements involve implementation modifications to 50 methods in the <b>IBasePlan</b> interface. Plan XYZ's requirements involve implementation modifications to 51 methods in the <b>IBasePlan</b> interface, but 50 of the implementation modifications are exactly the same as those for plan ABC. Rather than implementing complete interfaces for every COM object, you associate 100 C++ class member virtual functions in <b>BasePlan</b>, one for every method in interface <b>IBasePlan</b> , as in the previous example.</p>
<p>
Because you have associated virtual functions in the <b>BasePlan</b> class, the class hierarchy for plan XYZ appears as follows:
<ol>
<li>
class BASE_PLAN_EXPORT BasePlan : public CCmdTarget<p class=tl>
Implements <b>IBasePlan</b>, 100 interface methods and 100 associated C++ class member virtual functions.</P></li>
<li>
class ABC_PLAN_EXPORT ABCPlan : public BasePlan <p class=tl>
Derives from <b>BasePlan</b>, uses 50 C++ class member virtual functions in <b>BasePlan</b> and overrides 50 virtual functions of <b>BasePlan</b>.</P></li>
<li>
class XYZPlan : public ABCPlan<p class=tl>
Derives from <b>ABCPlan</b>, uses 49 C++ class member virtual functions in <b>BasePlan</b>, uses 50 C++ class member virtual functions in <b>ABCPlan</b>, and overrides 1 C++ class member virtual function of <b>BasePlan</b>.</P></li>
</ol>
<p>
Each component is created as a separate binary and COM object. Each has its own distinct CLSID and, because of the inheritance structure, implements <b>IBasePlan</b>. Using AppWizard and Class Wizard, you can complete the implementation of plan XYZ in minutes, without ever touching the base class COM components. All COM DLLs reside on the same computer, and if you use component categories or another similar technique in the registry, a client application will find plan XYZ as soon as it is registered with RegSvr32. </p>
<p>
WELCOME TO OOP (object-oriented programming) NIRVANA AND THE WORLD OF COMPONENTS!</p>
<p>
<i>Panther Software is a software development consulting company based in Hermosa Beach, California. The company specializes in developing software for other software companies, using technologies such as DCOM, COM, and ActiveX control development on Win32 platforms, and can be reached at </i>http://www.panthersoft.com<i>.</i></p>
</BODY>
</HTML>
