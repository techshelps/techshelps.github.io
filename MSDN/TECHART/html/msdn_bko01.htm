<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Building Three-Tier Client/Server Applications with Visual FoxPro</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_bko01"></a></sup>Building Three-Tier Client/Server Applications with Visual FoxPro</h1>
<p>
Robert Green<br>
Microsoft Corporation</p>
<p>
January 1997</p>
<h2>Introduction</h2>
<p>
Your good friends on the Visual FoxPro™ team at Microsoft spent a great deal of time to make Visual FoxPro a robust and powerful front-end for client/server applications. Remote views and SQL pass-through provide powerful tools to take advantage of SQL back-ends such as Oracle and SQL Server via ODBC (Open Database Connectivity).</p>
<p>
One of the great truisms of application development is that there are many ways to do everything. One of the hardest things to do when building an application is to decide on an approach and to know if it is better than the other approaches. In client/server development this is compounded by the fact that you are dealing with two database engines, Visual FoxPro on the front-end and a very powerful SQL database engine on the back-end. </p>
<p>
A companion article to this one, <a href="msdn_bko02.htm">"Integrating SQL Server with Visual FoxPro,"</a> explores building two-tier client/server applications using SQL pass-through. In this article, an OLE server built with Visual FoxPro is used to create three-tier client/server applications. Adding a middle layer gives you an additional place to put code and perform validations. </p>
<h2>The Fat Client Problem</h2>
<p>
The client/server application developer's dilemma lies in knowing how to split up the work between the front and back-ends. Visual FoxPro and SQL Server both have very powerful database engines. Both have powerful programming languages and are capable of validating data and enforcing business rules. </p>
<p>
Lately there has been much talk in the industry about fat clients and thin clients and the effect they have on your client/server development efforts. As the available front-end tools have grown in power there has been a tendency to rely on them more. This does ease the burden on the back-end, but it can also lead to problems. </p>
<p>
The first problem with loading up the front-end is that it requires a more powerful computer. Certainly if you are using Visual FoxPro as the front-end you would want at least a 486 with 12 MB of RAM. This issue is what spawned the phrase "fat client." The girth of the front-end is certainly a consideration if you are trying to choose which front-end to use. You would weigh the strengths and weaknesses and resource requirements of Visual FoxPro, Visual Basic, Microsoft® Access, Delphi, PowerBuilder, Java™, and all of the others. Java is exciting because it holds out the promise of a truly thin client that has enough power to be a robust front-end. Visual FoxPro 5.0 is significantly less fat than version 3.0.</p>
<p>
The second problem with having the front-end do a lot of the work is that if your validations and business rules change you have to change the code in the front-end. This may or may not be a problem. Suppose you are developing the Visual FoxPro front-end and you also happen to be in charge of the SQL Server back-end. If you are the one who writes the validation and business rule code, you will presumably write it once, either in Visual FoxPro or as SQL Server stored procedures, or perhaps as some combination of the two. If some logic has to be changed and you are the one who changes it, how much of an issue is it where the code is located?</p>
<p>
On the other hand, you may be writing the front-end and not have any say on the back-end. You may not be allowed to write your own Selects, Inserts, Updates, and Deletes. The keepers of the back-end may limit you to using only stored procedures. The beauty of that approach is that they are guaranteed that the front-end does things right. If your only access to the data is through the stored procedures, you would be forced to do things in the correct order and not leave out any steps. For instance, if you were deleting a member you could not forget to remove the member's reservations. If you were adding a new member you would not forget to put the new ID into the Adult table. </p>
<p>
What if your front-end is just one of several front-ends all accessing the same back-end data? In that case you might want all logic to be on the back-end. That way, if any of it needs to change, it only needs to be changed in one place.</p>
<h2>Three-Tier Architecture</h2>
<p>
A recent advance in client/server development is the three-tier architecture scheme. Traditional client/server is two-tier, consisting of a client and a server. As discussed above, this can potentially lead to problems if too much work is concentrated in either the client or the server. The three-tier architecture introduces a middle layer, which serves to ease the processing burden of the two ends. </p>
<p>
In a classic three-tier architecture, shown in Figure 1, each tier is responsible for providing a service. The client provides user services, consisting mainly of the user interface. The server provides data services, consisting of the data and the means of accessing and maintaining it. The middle layer provides business services, consisting of data validations and enforcement of business rules. </p>
<p>
<img src="bko01_1.gif" border=0></p>
<p class=label>
<b>Figure 1. A layered application architecture</b></p>
<p>
To fully realize the potential of this architecture, you should make the middle layer easily accessible to multiple front-ends. If it is enforcing your business rules, then all clients need to be able to talk to it. This is true whether the clients are written in Visual FoxPro, Visual Basic® or some other language.</p>
<p>
The middle tier should be running on a separate machine. This allows it to be accessible to multiple clients and it provides for the maximum performance. Remember, the problem with fat clients is that the client machine is overburdened. In a two-tier architecture you might have to provide each of the clients with at least a 16 MB (or more) Pentium machine. In a three-tier architecture you might locate the middle layer on a 32 MB dual processor Pentium machine and be happy with 12 MB 486s as the clients. </p>
<p>
There are at least a couple of ways you could set up the middle layer. One approach would be to use a SQL Server machine as both the middle layer and server. The approach taken in this session uses an OLE server created in Visual FoxPro as the middle layer. The OLE server is called from Visual FoxPro, or for that matter any OLE controller, using the CreateObject() function, in the same manner as you would call Excel or Word as OLE Automation servers. </p>
<h2>Creating a Visual FoxPro OLE Server</h2>
<p>
If you don't yet know how to create an OLE server in Visual FoxPro, check out the Visual FoxPro Online Documentation (Chapter 16 of the Visual FoxPro Developers Guide).</p>
<p>
The OLE server can be created as an InProc or OutOfProc server. In the Win32 world (Windows® 95 and Windows NT®), a process is a running application and can address up to 4 GB of memory, half of which is used to store the processes code and data and half of which is used by the system. An InProc server is compiled as a DLL and runs in the same address space as the process that called it. An OutOfProc server is compiled as an EXE and runs as a separate process. An InProc server offers better performance because <i>inter</i>-process communication is slower than <i>intra</i>-process communication. On the other hand, since an OutOfProc server runs in a separate process, you can take advantage of a multiprocessor environment. </p>
<p>
The OLE server can also be run locally or remotely. Typically a remote OLE server is created as an OutOfProc server and sits on a powerful computer. That allows it to be accessed by any number of client machines. The Remote Automation Connection Manager can be used to configure the server and client machines to allow for remote automation.</p>
<h2>The Sample Data</h2>
<p>
The data used in this session's examples is from a SQL Server 6.5 based library application. The library wants to keep track of its members, its books and its loans. The library database schema is shown in Figure 2.</p>
<p>
<img src="bko01_2.gif" border=0></p>
<p class=label>
<b>Figure 2. library database schema</b></p>
<h3>Table Structures</h3>
<p>
One of the central tables in the Library application is the Member table, which contains one row for every member of the library. An interesting twist here is that juveniles can only be members of the library if they have a sponsoring adult. Since a juvenile lives, presumably, in the same place as the adult, there are separate tables for Adult and Juvenile. This saves disk space because all of a juvenile's address information is redundant once you know who the adult is. Also, the juvenile's expiration date is the same as the adult's. Further, you don't care about the adult's birth date, although you do care about a juvenile's birth date, but only because on their 18th birthday he or she becomes an adult (at least as far as the tables are concerned!). </p>
<p>
The following code shows the SQL Server statements used to create the Member, Adult, and Juvenile tables:</p>
<pre><code>CREATE TABLE member

  ( member_no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member_no&nbsp;&nbsp;&nbsp; NOT NULL IDENTITY(1,1),

 &nbsp;&nbsp; lastname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shortstring&nbsp; NOT NULL ,

 &nbsp;&nbsp; firstname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shortstring&nbsp; NOT NULL ,

 &nbsp;&nbsp; middleinitial&nbsp;&nbsp;&nbsp; letter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL ,

 &nbsp;&nbsp; photograph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL )


CREATE TABLE adult

  ( member_no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member_no&nbsp;&nbsp;&nbsp; NOT NULL ,

 &nbsp;&nbsp; street&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shortstring&nbsp; NOT NULL ,

 &nbsp;&nbsp; city&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shortstring&nbsp; NOT NULL ,

 &nbsp;&nbsp; state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statecode&nbsp;&nbsp;&nbsp; NOT NULL ,

 &nbsp;&nbsp; zip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zipcode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOT NULL ,

 &nbsp;&nbsp; phone_no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phonenumber&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL ,

 &nbsp;&nbsp; expr_date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datetime&nbsp;&nbsp;&nbsp;&nbsp; NOT NULL )


CREATE TABLE juvenile

  ( member_no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member_no&nbsp;&nbsp;&nbsp; NOT NULL ,

 &nbsp;&nbsp; adult_member_no&nbsp; member_no&nbsp;&nbsp;&nbsp; NOT NULL ,

 &nbsp;&nbsp; birth_date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datetime&nbsp;&nbsp;&nbsp;&nbsp; NOT NULL )
</code></pre>
<p>
The member_no field in the Member table is automatically generated by SQL Server when a new row is added. This field is an Identity column. The seed value of 1 and the increment value of 1 specify that the first row entered into the table should have a member_no of 1. For every row inserted after that, the member_no is incremented by 1. When adding a row, the client does not specify the member_no. SQL Server takes care of it automatically and the client can ask what number was used.</p>
<p>
The member_no field in the Adult and Juvenile tables is not an Identity column. The value in that column has to match the member_no of the corresponding row in the Member table. When a new member is added to the library, a row is first added to the Member table. The SQL Server global variable @@Identity contains the automatically generated member_no. A row is then added to the Adult or Juvenile table and the value for the member_no will be whatever is in @@Identity.</p>
<h3>Declarative Referential Integrity</h3>
<p>
In prior versions of SQL Server, referential integrity was enforced through the use of triggers, which is the same way Visual FoxPro enforces referential integrity. SQL Server 6.0 added declarative referential integrity, which allows you to define your RI rules as part of the data structure. The first step is to create a Primary Key constraint in each table, as shown in the following code:</p>
<pre><code>ALTER TABLE member

  ADD CONSTRAINT member_ident PRIMARY KEY CLUSTERED 

 &nbsp;&nbsp; (member_no) 

ALTER TABLE adult

  ADD CONSTRAINT adult_ident PRIMARY KEY CLUSTERED

 &nbsp;&nbsp; (member_no) 

ALTER TABLE juvenile

  ADD CONSTRAINT juvenile_ident PRIMARY KEY CLUSTERED 

 &nbsp;&nbsp;&nbsp;&nbsp; (member_no) 
</code></pre>
<p>
The Primary Key constraint creates a Unique index, which enforces the uniqueness of the member_no. In the examples here a clustered index, which physically sorts the data, is created. </p>
<p>
The second step in defining declarative referential integrity is to create Foreign Key constraints between related tables, as shown in the following code:</p>
<pre><code>ALTER TABLE adult

  ADD CONSTRAINT adult_member_link FOREIGN KEY (member_no) 

 &nbsp;&nbsp;&nbsp;&nbsp; REFERENCES member (member_no)

ALTER TABLE juvenile

  ADD CONSTRAINT juvenile_member_link FOREIGN KEY

 &nbsp;&nbsp;&nbsp; (member_no) REFERENCES member (member_no)

ALTER TABLE juvenile

  ADD CONSTRAINT juvenile_adult_link FOREIGN KEY 

 &nbsp;&nbsp; (adult_member_no) REFERENCES adult (member_no)
</code></pre>
<p>
The first Alter Table defines a relationship between the Member and Adult tables. This is a one-to-one relationship, although there is nothing in the code to indicate or enforce that aspect of the relationship. The second Alter Table defines a relationship between the Member and Juvenile tables. The final Alter Table defines a relationship between the Adult and Juvenile tables. This is a one-to-many relationship.</p>
<p>
Be aware that SQL Server currently does not support cascading updates or deletes. If you wanted those you would use triggers instead of constraints.</p>
<h2>The Library OLE Server</h2>
<p>
The Library OLE Server uses SQL pass-through to talk to the SQL Server Library database. The server will contain methods to take actions such as retrieving information for a member, adding a new member, changing a member's information, and deleting a member. The server exposes a few properties, including properties to determine what errors have occurred. </p>
<p>
The OLE Server project is the file LIBRARYSERVER.PJX. The project contains a custom class called Members. The class has been identified as OLE Public by checking the appropriate box in the Class Info dialog.</p>
<p>
The methods and properties of the Members class, and hence the OLE Server, are listed in Table 1 and Table 2, respectively.</p>
<p class=label>
<b>Table 1. Library OLE Server Methods</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Method</b></td>
<td class=label width=21%><b>Visibility</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=27%>InitConnection</td>
<td width=21%>Public</td>
<td width=52%>Initiate a connection to SQL Server</td>
</tr>
<tr valign=top>
<td width=27%>CloseConnection</td>
<td width=21%>Public</td>
<td width=52%>Close the connection to SQL Server</td>
</tr>
<tr valign=top>
<td width=27%>GetMember</td>
<td width=21%>Public</td>
<td width=52%>Retrieve information for a member</td>
</tr>
<tr valign=top>
<td width=27%>AddMember</td>
<td width=21%>Public</td>
<td width=52%>Add a new member</td>
</tr>
<tr valign=top>
<td width=27%>UpdateMember</td>
<td width=21%>Public</td>
<td width=52%>Update a member's information</td>
</tr>
<tr valign=top>
<td width=27%>RemoveMember</td>
<td width=21%>Public</td>
<td width=52%>Remove a member</td>
</tr>
<tr valign=top>
<td width=27%>SetError</td>
<td width=21%>Protected</td>
<td width=52%>Store the SQL Server error</td>
</tr>
<tr valign=top>
<td width=27%>Convert</td>
<td width=21%>Protected</td>
<td width=52%>Convert values to strings</td>
</tr>
</table><br>
<p class=label>
<b>Table 2. Library OLE Server Properties</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Property</b></td>
<td class=label width=21%><b>Visibility</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=27%>nHandle</td>
<td width=21%>Public</td>
<td width=52%>Connection handle</td>
</tr>
<tr valign=top>
<td width=27%>NewID</td>
<td width=21%>Public</td>
<td width=52%>ID of newly added member</td>
</tr>
<tr valign=top>
<td width=27%>LastErrDesc</td>
<td width=21%>Public</td>
<td width=52%>Description of the last error that occurred</td>
</tr>
</table><br>
<p>
In the Project Information dialog box, shown in Figure 3, the project has been given the name VFPLibraryOLEServer. This, combined with the class name Members, yields the registered OLE name of VFPLibraryOLEServer.Members. This can be found in the HKEY_CLASSES_ROOT hive in the Registry, as shown in Figure 4.</p>
<p>
<img src="bko01_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Libraryserver Project Information dialog box</b></p>
<p>
The OLE server is automatically registered on the machine that built it. If you move it to another machine you can register it by running REGSVR32.EXE, found in the System directory under Windows 95 and in the System32 directory under Windows NT.</p>
<p>
<img src="bko01_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Windows Registry showing OLE server </b></p>
<p>
To use the OLE server a client application would use something like the following line of code:</p>
<pre><code>oLibrary = CreateObject("VFPLibraryOLEServer.Members")
</code></pre>
<p>
When Visual FoxPro comes across this code, it first checks to see if the object name is a Visual FoxPro class. It isn't, so the Registry is checked. The object name is found and the CLSID, the object's unique identifier, is noted. </p>
<p>
Also in the Registry's HKEY_CLASSES_ROOT hive is a key named CLSID, which contains an entry for all objects that have CLSIDs. As you can see in Figure 5, the Registry stores the executable file associated with each CLSID. That is how Windows knows to start the OLE Server when Visual FoxPro executes its CreateObject command.</p>
<p>
<img src="bko01_5.gif" border=0></p>
<p class=label>
<b>Figure 5. Registry CLSID entries for Library OLE server</b></p>
<h2>Using the Library OLE Server</h2>
<p>
The form MEMBOLEFP.SCX uses the Visual FoxPro Library OLE server as the middle layer to talk to the SQL Server Library database. After calling the server the form invokes methods to retrieve member information, delete and update members, and so on.</p>
<h3>Loading the Form</h3>
<p>
To call the OLE server, the form uses the same CreateObject() function that would be used to call Excel or Word. The official registered name of the OLE server as it appears in the Windows Registry is vfpLibraryOLEServer.Members. The following code is located in the Load event of the form.</p>
<pre><code>This.oLibrary = CreateObject("vfpLibraryOLEServer.Members")


If Type("This.oLibrary") # "O" Or IsNull(This.oLibrary)

  = MessageBox("Couldn't set up the OLE Server.", MB_ICONINFORMATION)

  This.lConnected = .F.

  Return

Else

  If This.oLibrary.InitConnection("robertg","vfpguru")

 &nbsp;&nbsp; = MessageBox("Welcome to the library", MB_ICONINFORMATION)

 &nbsp;&nbsp; ThisForm.lConnected = .T.

  Else

 &nbsp;&nbsp; = MessageBox("Access to the library denied", MB_ICONINFORMATION)

 &nbsp;&nbsp; This.lConnected = .F.

 &nbsp;&nbsp; Return

  Endif&nbsp; 

Endif 
</code></pre>
<p>
The code here tries to create a reference to the OLE server. If it works, the form property oLibrary will contain a reference to the OLE server. If the reference can't be created, then there is nothing left to do. If the object can be created, the form will invoke the InitConnection method of the OLE server in an attempt to login to SQL Server. If that doesn't work, there is nothing to do.</p>
<p>
If the connection is made successfully, the form creates a cursor and then sets optimistic row buffering. The cursor will be used for adding and editing and allows you to use familiar data entry functions such as GetFldState() and OldVal(), as you will see later.</p>
<pre><code>Set Multilocks On

Create Cursor c_member ;

  ( member_no I, firstname C(50), middleinitial C(1), ;

 &nbsp;&nbsp; lastname C(50), street C(50), city C(50), state C(10), ;

 &nbsp;&nbsp; zip C(10), phone_no C(20), expr_date T, ;

 &nbsp;&nbsp; birth_date T, adult_member_no I )

= CursorSetProp("Buffering", DB_BUFOPTRECORD, 'c_member')
</code></pre>
<h3>Connecting to SQL Server</h3>
<p>
The InitConnection method of the OLE server takes the user ID and password as parameters and then uses SQLConnect() to connect to SQL Server. The method returns true if the connection worked and false if it didn't.</p>
<pre><code>lParameters cUserID, cPassword

This.nHandle = SQLConnect('Library', cUserID, cPassword)

Return Iif(This.nHandle &lt; 0, .F., .T.)
</code></pre>
<h3>Locating a Member</h3>
<p>
The GetMember method of the OLE server is used to retrieve information for a member. In the SQL pass-through examples from <a href="msdn_bko02.htm">"Integrating SQL Server with Visual FoxPro,"</a> the sample forms used SQLExec() to either run a Select statement or to execute a stored procedure. In either case the results were returned in a cursor, which was then used to populate the form. </p>
<p>
Life is not so simple with the OLE server, which is specifically designed to be used with any client, including Microsoft Access and Visual Basic. So it cannot simply return results in a Visual FoxPro cursor. </p>
<p>
The OLE server's GetMember method takes three parameters: a string that will hold a delimited list of the retrieved data, the character you want to use as the delimiter, and the ID of the member you want retrieved. The Click event of the form's Locate button calls the GetMember method of the OLE server. </p>
<p>
The string is passed by reference because the GetMember method will fill it with the member's information. The delimiter character will be used to separate the columns of information. If GetMember returns 0, there is no member with the supplied ID. If it returns a negative number, there was an error, which will be stored in the OLE server's LastErrDesc property.</p>
<pre><code>nRetVal = ThisForm.oLibrary.GetMember(@lcMemberInfo, "|", ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ThisForm.txtMemberID.Value)


If nRetVal &lt; 0

  lcMessage = ThisForm.oLibrary.LastErrDesc

  = MessageBox(Substr(lcMessage, RAt(']',lcMessage)+1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_ICONINFORMATION) 

&lt;code intentionally left out&gt;

If nRetVal = 0

  = MessageBox("There is no member with this ID.", ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_ICONINFORMATION)

&lt;code intentionally left out&gt;
</code></pre>
<p>
If the member's information is found, the string needs to be parsed to read the individual columns of information. The cursor created in the form's Load method is populated with the information and the form is refreshed.</p>
<pre><code>For i = 1 To 10

  j = AllTrim(Str(i))

  nPipe&amp;j = At("|", lcMemberInfo, i)

Next&nbsp; 

nPipe11 = Len(lcMemberInfo)


Select c_member

Append Blank

Replace firstname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With Substr(lcMemberInfo, 1, nPipe1 - 1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; middleinitial&nbsp;&nbsp; With Substr(lcMemberInfo, nPipe1 + 1, ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPipe2 - nPipe1 - 1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With Substr(lcMemberInfo, nPipe2 + 1, ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPipe3 - nPipe2 - 1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; street&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With Substr(lcMemberInfo, nPipe3 + 1, ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPipe4 - nPipe3 - 1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; city&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With Substr(lcMemberInfo, nPipe4 + 1, ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPipe5 - nPipe4 - 1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With Substr(lcMemberInfo, nPipe5 + 1, ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPipe6 - nPipe5 - 1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With Substr(lcMemberInfo, nPipe6 + 1, ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPipe7 - nPipe6 - 1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phone_no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With Substr(lcMemberInfo, nPipe7 + 1, ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPipe8 - nPipe7 - 1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expr_date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With Ctot(Substr(lcMemberInfo, nPipe8 + 1, ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPipe9 - nPipe8 - 1)), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; birth_date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With Ctot(Substr(lcMemberInfo, nPipe9 + 1, ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPipe10 - nPipe9 - 1)), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adult_member_no With Val(Substr(lcMemberInfo, nPipe10 + 1, ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPipe11 - nPipe10 - 1))

&lt;code intentionally left out&gt;

ThisForm.Refresh

&lt;code intentionally left out&gt;
</code></pre>
<p>
The code in the For loop determines the location of each pipe delimiter. Everything up to the first delimiter is the member's first name. Everything between the first delimiter and the second is the member's middle initial. Everything between the second delimiter and the third is the member's last name. And so on.</p>
<h3>The OLE Server's GetMember Method</h3>
<p>
As mentioned above, the <b>GetMember</b> method of the OLE server takes three parameters, a string that will contain a delimited list of the member's information, the delimiter, and the member ID of the desired member. A Select statement is constructed and sent to SQL Server to retrieve the information. If the member is found, the string is constructed. Since the string was passed by reference it will be sent back to the form. The <b>GetMember</b> method itself returns 0 if the member was not found and 1 if the member was found.</p>
<pre><code>LParameters cMemberInfo, cDelimiter, cSearchID

lcSQL = "Select firstname, middleinitial, lastname, street, " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp; city, state, zip, phone_no, expr_date, " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " birth_date = null, adult_member_no = null " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "From member, adult " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Where member.member_no = adult.member_no " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp; And member.member_no = " + AllTrim(cSearchID) + " " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Union " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Select firstname, middleinitial, lastname, street, " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp; city, state, zip, phone_no, expr_date, " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp; birth_date, adult_member_no " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "From member, adult, juvenile " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Where member.member_no = juvenile.member_no " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp; And adult.member_no = juvenile.adult_member_no " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp; And member.member_no = " + AllTrim(cSearchID)

&lt;code intentionally left out&gt;

If RecCount("c_member") = 0

  Return 0

Else

  cMemberInfo = AllTrim(This.Convert(c_member.firstname)) + ; + 

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDelimiter + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(This.Convert(c_member.middleinitial)) + ; 

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDelimiter + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(This.Convert(c_member.lastname)) + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDelimiter + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(This.Convert(c_member.street)) + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDelimiter + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(This.Convert(c_member.city)) + cDelimiter + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(This.Convert(c_member.state)) + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDelimiter + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(This.Convert(c_member.zip)) + cDelimiter + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(This.Convert(c_member.phone_no)) + ; 

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDelimiter + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(This.Convert(c_member.expr_date)) + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDelimiter + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(This.Convert(c_member.birth_date)) + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDelimiter + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(This.Convert(c_member.adult_member_no)) + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDelimiter

  Return RecCount("c_member") 

Endif
</code></pre>
<h3>Adding an Adult</h3>
<p>
The AddMember method of the OLE server is used to add a member to the library. For ease of use, the method takes as a parameter a two-dimensional array. The first column contains field names and the second column contains the associated information. The form's AddMember method is called from the Click event of the Save button and in turn calls the GetMember method of the OLE server.</p>
<pre><code>Dimension laMember[11,2]

laMember[1,1] = "firstname"

laMember[2,1] = "middleinitial"

laMember[3,1] = "lastname"

laMember[4,1] = "street"

laMember[5,1] = "city"

laMember[6,1] = "state"

laMember[7,1] = "zip"

laMember[8,1] = "phone_no"

laMember[9,1] = "expr_date"

laMember[10,1] = "birth_date"

laMember[11,1] = "adult_member_no"


* Some of the data is either left empty or supplied by the server

laMember[1,2] = AllTrim(ThisForm.txtFirstName.Value)

laMember[2,2] = AllTrim(ThisForm.txtMiddleInitial.Value)

laMember[3,2] = AllTrim(ThisForm.txtLastName.Value)

laMember[4,2] = AllTrim(ThisForm.txtStreet.Value)

laMember[5,2] = AllTrim(ThisForm.txtCity.Value)

laMember[6,2] = AllTrim(ThisForm.txtState.Value)

laMember[7,2] = AllTrim(ThisForm.txtZip.Value)

laMember[8,2] = AllTrim(ThisForm.txtPhoneNumber.Value)


If ThisForm.oLibrary.AddMember(@laMember) &lt; 0

  lcMessage = ThisForm.oLibrary.LastErrDesc

  = MessageBox(Substr(lcMessage, RAt(']',lcMessage)+1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_ICONINFORMATION)

Else

  = MessageBox("This member has been added.", MB_ICONINFORMATION)

  * Find out the member_no of the new member

  ThisForm.txtMemberID.Value = AllTrim(Str(ThisForm.oLibrary.NewID))

&lt;code intentionally left out&gt;
</code></pre>
<p>
The first column of the array laMember contains the names of the fields. The second contains the actual data, which is taken from the controls on the form. The array is passed, by reference to ensure it all goes, to the AddMember method, which returns 1 if the member was added and -1 if he or she wasn't. The LastErrDesc property of the OLE server contains the error message if the addition was unsuccessful.</p>
<h3>The OLE Server's AddMember Method</h3>
<p>
As mentioned above, the AddMember method of the OLE server takes one parameter, an array of field names, and values.</p>
<pre><code>LParameters aMemberInfo
</code></pre>
<p>
Adding a member to the Library is a two-step procedure. First, a new row is added to the Member table, which contains the member's name. The member_no field in that table has been assigned the Identity property and SQL Server automatically determines the next value to use. The second step is to add a corresponding row to the Adult table, which contains the member's address. The same member_no must be used in both tables to maintain the one-to-one relationship.</p>
<p>
The two steps need to be part of a transaction so that either both rows go in correctly or neither goes in.</p>
<pre><code>= SQLSetProp(This.nHandle, "Transactions", 2)
</code></pre>
<p>
Next, an Insert statement for the Member table is constructed and sent to SQL Server. If the Insert fails, the transaction is rolled back and the AddMember method returns -1, alerting the client that the Insert failed. </p>
<pre><code>cSQL = "Insert member (firstname, middleinitial, lastname, " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "photograph) " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Values ('" + AllTrim(aMemberInfo[1,2]) + "', " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "'" + AllTrim(aMemberInfo[2,2]) + "', " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "'" + AllTrim(aMemberInfo[3,2]) + "', " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "NULL)"

If SQLExec(This.nHandle, cSQL) &lt; 0

  This.SetError

  * Rollback the transaction

  = SQLRollback(This.nHandle)

  Return -1

Endif
</code></pre>
<p>
The SQL Server global variable @@Identity stores the most recent value inserted into an Identity column. In this case it contains the new user's member_no. That number is stored in the NewID property of the OLE server.</p>
<pre><code>If SQLExec(This.nHandle, "Select @@identity") &lt; 0

  This.SetError

  * Rollback the transaction

  = SQLRollback(This.nHandle)

  Return -1

Endif

This.NewID = sqlresult.exp
</code></pre>
<p>
Next, the corresponding row in the Adult table is added. The value for member_no comes from the value of @@Identity. As before, if this Insert fails, the whole transaction is rolled back and AddMember returns -1.</p>
<pre><code>cSQL = "Insert adult (member_no, street, city, state, zip, " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "phone_no, expr_date) " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Values (" + AllTrim(Str(This.NewID)) + ", " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "'" + AllTrim(aMemberInfo[4,2]) + "', " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "'" + AllTrim(aMemberInfo[5,2]) + "', " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "'" + AllTrim(aMemberInfo[6,2]) + "', " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "'" + AllTrim(aMemberInfo[7,2]) + "', " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "'" + AllTrim(aMemberInfo[8,2]) + "', " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "'" + TToC(DToT(GoMonth(Date(),12))) + "' )"

If SQLExec(This.nHandle, cSQL) &lt; 0

  This.SetError

  * Rollback the transaction

  = SQLRollback(This.nHandle)

  Return -1

Endif
</code></pre>
<p>
The last step is to try to commit the transaction. If that fails, everything is rolled back. If the Commit works, the new member has been added and AddMember returns 1, indicating success. </p>
<pre><code>If SQLCommit(This.nHandle) &lt; 0

  This.SetError

  * Rollback the transaction

  = SQLRollback(This.nHandle)

  Return -1

Else

  Return 1

Endif
</code></pre>
<h3>Saving Changes</h3>
<p>
The UpdateMember method of the form calls the UpdateMember method of the OLE server. The form passes to the OLE server a two dimensional array and the ID of the member. As with the AddMember method above, the first column of the array contains the names of fields to be updated, while the second column contains the new information for a particular member.</p>
<p>
When a member was added, the array contained a row for each field. In this case however, it should contain a row for only those fields whose value has changed. There is no point in making SQL Server update information that hasn't changed. </p>
<p>
The form looks at each control to see if its value has changed. If so, a row is added to the array. Notice the use of OldVal() to see if the field changed. The use of the buffered cursor makes this possible.</p>
<pre><code>i = 0

If c_member.firstname &lt;&gt; OldVal("c_member.firstname")

  i = i + 1

  Dimension laMember[i, 2]

  laMember[i,1] = "firstname"

  laMember[i,2] = AllTrim(ThisForm.txtFirstName.Value)

Endif

If c_member.lastname &lt;&gt; OldVal("c_member.lastname")

  i = i + 1

  Dimension laMember[i, 2]

  laMember[i,1] = "lastname"

  laMember[i,2] = AllTrim(ThisForm.txtLastName.Value)

Endif

&lt;code intentionally left out&gt;
</code></pre>
<p>
If no fields were changed, there is nothing to do and therefore no point in bothering SQL Server.</p>
<pre><code>If i = 0

  = MessageBox("There is nothing to save.", MB_ICONINFORMATION)

  Return

Endif&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</code></pre>
<p>
If any fields have been changed, the form invokes the UpdateMember method of the OLE server. The array is passed, as well as the member's ID. If UpdateMember returns -1, the update failed and the reason is displayed to the user.</p>
<pre><code>If ThisForm.oLibrary.UpdateMember(@laMember, ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ThisForm.txtMemberID.Value) &lt; 0

  lcMessage = ThisForm.oLibrary.LastErrDesc

  = MessageBox(Substr(lcMessage, RAt(']',lcMessage)+1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_ICONINFORMATION)

Else

  = MessageBox("This member's information has been saved.", ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_ICONINFORMATION)

&lt;code intentionally left out&gt;
</code></pre>
<h3>The OLE Server's UpdateMember Method</h3>
<p>
As mentioned above, the OLE server UpdateMember method takes two parameters, the array of field names and data, and the ID of the member to update.</p>
<pre><code>LParameters aMemberInfo, cSearchID
</code></pre>
<p>
Just as adding a member required two Inserts wrapped in a transaction, updating a member requires two Updates wrapped in a transaction. To build each Update statement, UpdateMember searches each array for each field. For instance, if the string "firstname" is found in the array and if it is in the first column, the firstname field should be updated in the Member table. Two strings, cSQL1 and cSQL2 are constructed, each containing part of an Update statement.</p>
<pre><code>cSQL1 = ""

nPos = AScan(aMemberInfo, "firstname")

If Mod(nPos, 2) = 1

  cSQL1 = cSQL1 + "firstname = '" + aMemberInfo[nPos + 1] + "', "

Endif

nPos = AScan(aMemberInfo, "lastname")

If Mod(nPos, 2) = 1

  cSQL1 = cSQL1 + "lastname = '" + aMemberInfo[nPos + 1] + "', "

Endif

&lt;code intentionally left out&gt;

cSQL2 = ""

nPos = AScan(aMemberInfo, "street")

If Mod(nPos, 2) = 1

  cSQL2 = cSQL2 + "street = '" + aMemberInfo[nPos + 1] + "', "

Endif

nPos = AScan(aMemberInfo, "city")

If Mod(nPos, 2) = 1

  cSQL2 = cSQL2 + "city = '" + aMemberInfo[nPos + 1] + "', "

Endif
</code></pre>
<p>
A transaction is then begun.</p>
<pre><code>= SQLSetProp(This.nHandle, "Transactions", 2)
</code></pre>
<p>
If anything has been stored to the cSQL1 variable, the rest of the Update statement for the Member table is constructed and passed to SQL Server. If it fails, the transaction is rolled back.</p>
<pre><code>If Len(cSQL1) &gt; 0

  * Add the Update, strip off the last comma, add a Where clause

  cSQL1 = "Update member Set " + Left(cSQL1, Len(cSQL1) - 2) + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Where member_no = " + AllTrim(cSearchID)

  If SQLExec(This.nHandle, cSQL1) &lt; 0

 &nbsp;&nbsp; This.SetError

 &nbsp;&nbsp; * Rollback the transaction

 &nbsp;&nbsp; = SQLRollback(This.nHandle)

 &nbsp;&nbsp; Return -1

  Endif

Endif
</code></pre>
<p>
Similarly, if anything has been stored to the cSQL2 variable, the rest of the Update statement for the Adult table is constructed and passed to SQL Server. If it fails, the transaction is rolled back.</p>
<pre><code>If Len(cSQL2) &gt; 0

  * Add the Update, strip off the last comma, add a Where clause

  cSQL2 = "Update adult Set " + Left(cSQL2, Len(cSQL2) - 2) + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Where member_no = " + AllTrim(cSearchID)

  If SQLExec(This.nHandle, cSQL2) &lt; 0

 &nbsp;&nbsp; This.SetError

 &nbsp;&nbsp; * Rollback the transaction

 &nbsp;&nbsp; = SQLRollback(This.nHandle)

 &nbsp;&nbsp; Return -1

  Endif

Endif
</code></pre>
<p>
The last step is to commit the transaction. If the Commit fails, the transaction is rolled back.</p>
<pre><code>If SQLCommit(This.nHandle) &lt; 0

  This.SetError

  * Rollback the transaction

  = SQLRollback(This.nHandle)

  Return -1

Else

  Return 1

Endif

</code></pre>
<h3>Deleting a Member</h3>
<p>
The OLE Server's RemoveMember method is used to delete a member. The method takes as a parameter the ID of the member to delete. RemoveMember returns 1 if the member was deleted and -1 otherwise. If the deletion fails, the OLE server property LastErrDesc contains the reason. The deletion could fail because referential integrity is violated; for instance, a member with outstanding loans or active juveniles cannot be deleted. It could also fail because a SQLExec() failed. Either way, the form code assumes the reason will be contained in oLibrary.LastErrDesc and can also be displayed to the user.</p>
<pre><code>If ThisForm.oLibrary.RemoveMember(ThisForm.txtMemberID.Value) &lt; 0

  lcMessage = ThisForm.oLibrary.LastErrDesc

  = MessageBox(Substr(lcMessage, RAt(']',lcMessage)+1), ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_ICONINFORMATION)

Else

  = MessageBox("This member has been deleted.", MB_ICONINFORMATION)

&lt;code intentionally left out&gt;
</code></pre>
<h3>The OLE Server's RemoveMember Method</h3>
<p>
The OLE server's RemoveMember method takes one parameter, the member ID of the member that the user is attempted to delete.</p>
<pre><code>LParameters cSearchID
</code></pre>
<p>
There are several reasons a delete attempt might fail. With the data used here, the two most frequent are that the member has outstanding loans or is an adult sponsoring active juveniles. If either of those is true the Delete will fail. </p>
<p>
The RemoveMember method code could have been written to try the deletion and then monitor failures to see if either of these is the reason. But this is inefficient, especially compared to the alternative of checking these two conditions first. If the member has active loans or is sponsoring juveniles, then the Delete won't even be tried. This makes it easier to trap for the error and also spares processing on the SQL Server.</p>
<pre><code>* First check to see if this member has active loans

cSQL = "Select member_no From loan Where member_no = " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(cSearchID)

If SQLExec(This.nHandle, cSQL) &lt; 0

  This.SetError

  Return -1

Else

  If RecCount("sqlresult") &lt;&gt; 0&nbsp; 

 &nbsp;&nbsp; This.LastErrDesc = "This member can not be deleted. " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "He/she has active loans."

 &nbsp;&nbsp; Return -1

  Endif&nbsp; 

Endif


* Now check to see if this is an adult with active juveniles

cSQL = "Select member_no From juvenile Where adult_member_no = " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllTrim(cSearchID)

If SQLExec(This.nHandle, cSQL) &lt; 0

  This.SetError

  Return -1

Else

  If RecCount("sqlresult") &lt;&gt; 0&nbsp; 

 &nbsp;&nbsp; This.LastErrDesc = "This member can not be deleted. " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "He/she is an adult with active juveniles."

 &nbsp;&nbsp; Return -1

  Endif&nbsp; 

Endif
</code></pre>
<p>
If there are other things to check, the code for them could follow the lines above. If none of the obvious problems is present, a transaction is started and the deletion proceeds.</p>
<pre><code>= SQLSetProp(This.nHandle, "Transactions", 2)
</code></pre>
<p>
A member may have related records in the Loanhist table, which contains a row for every borrowed book that was returned, or in the Reservation table, which contains a row for every book on reserve. These related rows are deleted first. If not, referential integrity would be violated when the member was deleted. If either of these Deletes fails the transaction is rolled back.</p>
<pre><code>* Delete the loan history records for this member.

cSQL = "Delete loanhist Where member_no = " + AllTrim(cSearchID)

If SQLExec(This.nHandle, cSQL) &lt; 0

  This.SetError

  * Rollback the transaction

  = SQLRollback(This.nHandle)

  Return -1

Endif


* Delete the loan reservation records for this member.

cSQL = "Delete reservation Where member_no = " + AllTrim(cSearchID)

If SQLExec(This.nHandle, cSQL) &lt; 0

  This.SetError

  * Rollback the transaction

  = SQLRollback(This.nHandle)

  Return -1

Endif
</code></pre>
<p>
Any other related records would also be deleted at this point. After all the related rows are gone, the member can be deleted, first from the Adult table and then from the Member table. The Deletes must be in this order to preserve referential integrity. Again, if either of these Deletes fails, the transaction is rolled back.</p>
<pre><code>* Delete the member's row in the Adult table.

cSQL = "Delete adult Where member_no = " + AllTrim(cSearchID)

If SQLExec(This.nHandle, cSQL) &lt; 0

  This.SetError

  * Rollback the transaction

  = SQLRollback(This.nHandle)

  Return -1

Endif


* Delete the member's row in the Member table.

cSQL = "Delete member Where member_no = " + AllTrim(cSearchID)

If SQLExec(This.nHandle, cSQL) &lt; 0

  This.SetError

  * Rollback the transaction

  = SQLRollback(This.nHandle)

  Return -1

Endif
</code></pre>
<p>
If the next part is not familiar, you either didn't read the preceding parts of these notes or you slept through them. Commit if go, rollback if no. The RemoveMember method returns -1 if the delete failed and 1 if it succeeded.</p>
<pre><code>If SQLCommit(This.nHandle) &lt; 0

  This.SetError

  * Rollback the transaction

  = SQLRollback(This.nHandle)

  Return -1

Else

  Return 1

Endif
</code></pre>
<h3>Storing SQL Server Errors</h3>
<p>
The SetError method of the OLE server stores the SQL Server error to the LastErrDesc property, which is then available to the client.</p>
<pre><code>lnError = AError(laError)

This.LastErrDesc = Substr(laError[3], RAt(']',laError[3]) + 1)
</code></pre>
<h2>Black Box Programming with OLE Servers</h2>
<p>
See <a href="msdn_bko02.htm">"Integrating SQL Server with Visual FoxPro"</a> for an explanation of how to use views and SQL pass-through to create two-tier client/server applications. One of the examples used SQL Server stored procedures to add, update, and delete members. A benefit to that technique was that processing occurred on the server and not the client. This not only avoided the fat client problem but also made it unlikely that developers would mess up the data. For instance, you couldn't forget to remove the member's related loan history records if all you did was invoke a stored procedure. </p>
<p>
Using a three-tier architecture is very similar to using stored procedures in terms of coding difficulty (low) and the level of control you retain (also low). For instance, the code to invoke the stored procedure to delete a member is </p>
<pre><code>If SQLExec(ThisForm.nHandle, "Execute RemoveMember " + ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ThisForm.txtMemberID.Value) &lt; 0
</code></pre>
<p>
while the code to invoke the equivalent OLE server method is</p>
<pre><code>If ThisForm.oLibrary.RemoveMember(ThisForm.txtMemberID.Value) &lt; 0
</code></pre>
<p>
In both of these cases, all the developer needs to know is the name of the method or procedure, what parameters it takes, and what it returns. Both the SQL Server stored procedures and the OLE server methods become black boxes. </p>
<p>
Someone who is in charge only of the front-end doesn't need to know or care what is in the middle layer as opposed to what is in the back-end. He or she may just want to know how to call the methods and how to tell whether they succeeded. This puts the rapid back in rapid development.</p>
<h2>Where Is the Fat?</h2>
<p>
In one of the examples from <a href="msdn_bko02.htm">"Integrating SQL Server with Visual FoxPro,"</a> SQLExec() was used from the client form to handle all communications with SQL Server. Selects, Inserts, Updates, and Deletes were sent and the results were manipulated as necessary. Most of the work other than the actual physical managing of data was done in the client. The risk there was that you might wind up with a fat client.</p>
<p>
In another example from <a href="msdn_bko02.htm">"Integrating SQL Server with Visual FoxPro,"</a> SQLExec() was used to call stored procedures sitting on SQL Server. No work was done in the client, other than managing a local cursor filled with one row at a time. Both data manipulation and validation were performed on the server. The risk there was that you might wind up with a fat server.</p>
<p>
In the example used in this article, the front-end does nothing but invoke methods of the OLE server. In fact, in this example, which is admittedly rather simple, the middle layer looks strikingly like the first SQLExec() example. In fact, much of the code for the OLE server was taken from the form MEMBEXEC.SCX.</p>
<p>
If all the data validations and business rule checking are put into the middle layer, does this lead to a problem of fat middles? Has the fat problem merely been moved up the hierarchy? To be sure, it would be possible to overload the OLE server to the point where it can't perform its role satisfactorily. However, since it runs on one machine it would be easier to solve the fat issue by throwing hardware at it than if the problem were fat clients. For a relatively small amount of money you could stick one or two more processors and 16 or 32 MB more RAM in the middle-tier machine and, conceivably, see any performance problems disappear. Of course, that works only if the processing power of the machine is the bottleneck.</p>
<p>
The important point is that because Visual FoxPro and SQL Server, and for that matter Oracle and others, have both powerful data engines and powerful languages, you can fine tune the fat. You can decide where to place code and where to put the processing burden, and you can tweak it and adjust it until performance is acceptable.</p>
<h2>When Do You Need This?</h2>
<p>
It is not difficult to create a Visual FoxPro OLE server. It is also not difficult to call an OLE server's methods from a form or other code. Setting up remote automation is not difficult either. So, writing a client/server application using a three-tier architecture is only mildly more difficult than using a two-tier architecture.</p>
<p>
So why would you do it? When do you need to move up to a three-tier architecture? Certainly performance is a reason. Do it if your client machines are underpowered and if, by moving large chunks of code to a more powerful middle-tier box, you can significantly improve performance. </p>
<p>
How likely is this? While it is true that the resource requirements for Visual FoxPro have fallen with version 5.0, you still want at least a 486 with 12 MB of RAM. Pentiums with 32 MB cost $2,000 these days. Consider a company that is moving an application off the mainframe and rewriting it using Visual FoxPro and SQL Server. They buy 100 brand new machines and have a fairly speedy network. In that situation, they may not realize a large performance gain by using a three-tier, as opposed to two-tier, architecture. Note that <i>might</i> is the operative word here. </p>
<p>
Perhaps a more compelling reason to consider three-tier is the fact that you can move your data validation and business rules code into one location. Suppose there is a rule that no new orders can be placed if a customer has more than $20,000 60 days past due. In a two-tier architecture you can easily code this into the Click event of the Add button and immediately put up a message telling the user he or she can't place the order. The users love it and everyone is happy. </p>
<p>
Suppose the rule changes and the limit is raised to $30,000. How many client machines have to be upgraded? Do you have to regenerate the APP or EXE file and redistribute it? This can be quite a burden and a large cost. You may have designed the system so that business rules are stored in a metatable somewhere. If so, good for you. If not, there is a lot of work to do for what seems like a simple change.</p>
<p>
If the business rule were in an OLE server, however, the change is fairly simple. You would change the code and recompile the one EXE. None of the client machines would have to change. The rule would go into effect as soon as the EXE was done and the maintenance burden would be a fraction of what it could have been.</p>
<p>
Even if a remote OLE server decreased overall performance slightly, you might still use it to take advantage of the decreased maintenance burden. </p>
<h2>Conclusion</h2>
<p>
The OLE server middle layer approach provides several enticing benefits. The fact that it runs on a separate machine allows you to run your validations and business rules on a powerful machine without breaking your budget. You can purchase one ultra-powerful machine instead of having to beef up every client. </p>
<p>
When it comes time to change the validations or business rules, you would only need to change the middle layer. You would change the Visual FoxPro code and remake the OLE server. Every client would automatically use the new rules because they would be located in a single location. This dramatically simplifies the problem of distributing changes and also guarantees that all clients are using the same, and updated, rules.</p>
</BODY>
</HTML>
