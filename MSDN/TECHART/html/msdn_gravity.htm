<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sprites Make the World Go Round</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_gravity"></a></sup>Sprites Make the World Go Round</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: April 29, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="2531">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the Gravity sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
In his article titled <a href="msdn_anim32.htm">"Animation in Win32"</a> in the Microsoft® Development Library, Mr. Herman Rodent shows how to implement sprite-based animation in Win32® environments such as Windows NT, Windows 95 (the next version of the Windows® operating system, formerly called "Chicago"), and Windows 3.1 (under Win32s™) using the Microsoft Foundation classes (MFC). While Mr. Rodent's article discusses the technical issues involved in implementing sprite-based animation, this article describes how to use Mr. Rodent's code for something worthwhile: to simulate the gravitational interactions of heavenly bodies (that is, planets). The Gravity sample application implements the concepts described in this article.</p>
<h2>Introduction</h2>
<p>
Let's go way back with Mr. Peabody to my college days. A friend of one of my roommates was getting a doctorate degree in mathematics. He claimed to have this wonderful algorithm for simulating Newton's Law of Gravitation. For some strange reason, he thought that this simulation would make a fun shareware program that he wanted me to help him write. I thought that this would be very boring, so I kept putting him off until he finally went back to Europe.</p>
<p>
About a year later, the school put together a Macintosh® lab. One day, I went to the lab to play with the Mac®. One of the programs on the Mac was a two-dimensional Newton's Law of Gravitation simulation. This had to be one of the most enjoyable computer programs I had ever encountered!</p>
<p>
I ran home and coded up a quick version of the simulation program for my Radio Shack TRS-80® Model III. Boy, was that a slow simulation. . . . It was so slow, it practically ran in real time. It represented the earth with the letter "E" and the moon with the letter "m", and it was still slow.</p>
<p>
Because my TRS-80 was so slow, I put aside my gravitational simulator project until the September 1989 issue of <i>Dr. Dobb's Journal</i> published an article titled "Force-based Simulations" by Todd King. I converted the C++ code published in the article to Turbo Pascal® (yes, a Borland product) and ran it on a Tandy® 1000. It was still slow, and the earth was still represented by an "E", so I shelved the project once again and turned to more pressing tasks.</p>
<p>
One day, all the pieces fell together. I got a new Pentium™ system at work, installed Windows NT™ 3.5, and Herman Rodent finished his article on sprite animation in Win32®. Until Herman evangelized the implementation of sprites for 32-bit Windows™ environments, book and magazine writers had been avoiding the subject or providing poor solutions.</p>
<p>
Thus, with an arsenal of really cool tools and code, I once again went forth to move the world.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;After I finished developing the Gravity application, someone pointed me to Appendix A ("A Personal View of the C++ Language") in David J. Kruglinski's book <i>Inside Visual C++</i> (Kruglinski 1993, 529). Mr. Kruglinski uses space simulation to demonstrate many of the features of the C++ language. This appendix is great for beginning and intermediate C++ users; it explains the intricacies of the C++ language very clearly. Mr. Kruglinski does, however, leave the sprite animation as an exercise for the reader.</p>
<h2>Gravity</h2>
<p>
The Gravity sample application is fairly easy to use. Choose the Load command from the File menu to load the EM.GVY (earth–moon) simulation. After loading, the screen should display a bitmap of space (sorry, I drew this myself—I couldn't find a cool space picture), the planet earth (close enough), and the moon (a gray object that looks like a bowling ball). Clicking the green button on the toolbar starts a simulation of the moon rotating around the earth. Clicking the red button on the toolbar stops the simulation. Clicking the button labeled <b><i>X</i>i</b> sets the planets back to their initial position and velocity.</p>
<p>
Double-clicking a planet brings up a dialog box from which you can set the initial position, velocity, and the mass of the planets. You can use this dialog box to see how different masses and velocities affect the simulation. Take a look at emc.bmp—it's fun to see the interactions of three planets.</p>
<p>
If you want to create your own simulation, select the New command from the File menu. Load a background (such as space.bmp) with the Load Background command from the File menu. Use the Load Sprite command from the File menu to load the planets that you want in your simulation. Double-click the sprites to set their parameters.</p>
<h2>In the Beginning</h2>
<p>
Like most programmers, I want to avoid writing (or rewriting) as much code as possible, so I like to start a program either by using another program as the base or by asking AppWizard to generate an application for me. To build Gravity, I used a combination of AppWizard and code from Herman Rodent's anim32 sample application. I believe Newton built real gravity from apples. 
<ol>
<li>
Ask AppWizard to create a single-document interface (SDI) application called Gravity with toolbars but no print preview. <br><br></li>
<li>
Copy the following files from ANIM32 to Gravity:<p class=tl>
ANIMVW.H<br>
ANIMVW.CPP<br>
ANIMDOC.H<br>
ANIMVW.CPP<br>
DIB.H<br>
DIB.CPP<br>
DIBPAL.H<br>
DIBPAL.CPP<br>
OSDIBVW.H<br>
OSDIBVW.CPP<br>
PHSPRITE.H<br>
PHSPRITE.CPP<br>
RECTLS.H<br>
RECTLS.CPP<br>
SPLSNO.H<br>
SPLSNO.CPP<br>
SPRITE.H<br>
SPRITE.CPP<br>
SPRITEDL.H<br>
SPRITEDL.CPP<br>
SPRITELS.H<br>
SPRITELS.CPP<br>
SPRITENO.H</P></li>
<li>
Edit the project file. Remove the gravidoc.h document class and the gravivw.h view class, and add the .CPP files listed above.<br><br></li>
<li>
Edit <b>CGravityApp::InitInstance</b> in the GRAVITY.CPP file. Change:<pre><code>AddDocTemplate(new CSingleDocTemplate(IDR_MAINFRAME,
RUNTIME_CLASS(CGravityDoc),
RUNTIME_CLASS(CMainFrame),
RUNTIME_CLASS(CGravityView)));
</code></pre>
<p class=tl>
to:</P><pre><code>AddDocTemplate(new CSingleDocTemplate(IDR_MAINFRAME,
RUNTIME_CLASS(CAnimDoc),
RUNTIME_CLASS(CMainFrame),
RUNTIME_CLASS(CAnimView)));
</code></pre>
<p class=tl>
You have just modified Gravity so that it uses the <b>CAnimView</b> and <b>CAnimDoc</b> classes (which are part of ANIM32) instead of the <b>CGravityView</b> and <b>CGravityDoc</b> classes.</P></li>
<li>
Use AppStudio to copy the resources from Anim32 to your new application. Make sure to copy the toolbar buttons, dialogs, icons, and menus that you want.<br><br></li>
<li>
Modify mainfrm.cpp to add the toolbar button ids.<br><br></li>
<li>
Change the references to the following include files:<ul type=disc>
<li>
Replace anim32.h with gravity.h.<br><br></li>
<li>
Replace gravidoc.h with animdoc.h.<br><br></li>
<li>
Replace gravivw.h with animvw.h.</li>
</ul>
</li>
<li>
If you do not want to use the ANIM32 debug window, comment out all references to <b>dprintf*</b>, <b>dgbGetTime</b>, and <b>dgbShowElapsedTime</b>. Use the Find In Files command from the Edit menu to find the occurrences of these functions. If you do want to include the debug window, look at ANIM32.H and ANIM32.CPP for the required statements.<br><br></li>
<li>
Change the <b>CDIBPal::SetSysPalColors</b> function. Modify the line:<pre><code>HWND hwndActive = ::GetActiveWindow() ;
</code></pre>
<p class=tl>
to:</P><pre><code>HWND hwndActive = NULL ;
</code></pre>
<p class=tl>
Remove the following <b>ASSERT</b> statement:</P><pre><code>ASSERT(hwndActive) ;
</code></pre>
</li>
</ol>
<p>
Now that we've made the necessary changes to the ANIM32 code, we are ready to code Gravity's own features.</p>
<h2>Replacing CAnimSprite</h2>
<p>
I wanted to see planets rotating as soon as possible, so I started by replacing the <b>CAnimSprite</b> class with my own class, <b>CBody</b>, which would control the planetary bodies. The use of the <b>CSprite </b>class is similar to <b>CView</b> in the Microsoft® Foundation classes. Instead of using a <b>CView</b> object directly, you usually create your own view object, which inherits from <b>CView </b>but has its own special routines. Similarly, you don't use a <b>CSprite </b>object directly, but instead create your own sprite class, which inherits from <b>CSprite</b>. The figure below compares the view hierarchy with the sprite hierarchies in ANIM32 and Gravity.</p>
<p>
<img src="gravity_1.gif" border=0></p>
<p class=label>
<b>Class hierarchies</b></p>
<p>
I removed <b>CAnimSprite</b> from the project and created the body.h and body.cpp files to hold the code I needed for my <b>CBody </b>objects. <b>CAnimDoc </b>and <b>CAnimView </b>refer to the <b>CAnimSprite </b>class explicitly, so I had to change all the <b>CAnimSprite</b> references to <b>CBody</b>. The browser in Visual C++™ allowed me to make these changes easily. I did have to choose the Include Local Variables check box in the C/C++ Compiler Options dialog box to find all occurrences of <b>CAnimSprite</b>. (To get to this dialog box, select the Project command from the Options menu, click the Compiler button, and select Listing Files from the Category list on the left.)</p>
<p>
I modeled <b>CBody </b>after <b>CAnimSprite</b>, so the two classes share a number of features. They both:
<ul type=disc>
<li>
Inherit from <b>CPhasedSprite</b>. <br><br></li>
<li>
Have similar serialization code. <br><br></li>
<li>
Have a <b>DoDialog</b> function that is called when the user double-clicks a sprite.<br><br></li>
<li>
Have member functions for setting the velocity and position of the planets.</li>
</ul>
<p>
Of course, there are some differences between <b>CBody</b> and <b>CAnimSprite</b>. (Why else would I bother writing <b>CBody</b>?) <b>CBody</b> positions the planets in a 108-by-108 universe, while <b>CAnimSprite</b> places the sprites on the screen. Therefore, <b>CAnimSprite </b>stores position and velocity with integers while <b>CBody </b>uses double-precision floating-points. As a result, I had to modify <b>CAnimSprite::DoDialog</b> to create <b>CBody::DoDialog</b>. I also had to munge the <b>CSpriteDlg </b>class to work with <b>CBody</b>. Munging was faster than recreating all of the code.</p>
<h2>Apply Some Force</h2>
<p>
The real difference between <b>CBody</b> and <b>CAnimSprite</b> is what happens each time we update the sprites. A <b>CAnimSprite</b> object has a velocity, and moves each time it is updated. A <b>CBody</b> object also has a velocity, but its velocity is affected by other <b>CBody </b>objects in the universe. To determine what we need to change, let's start at the beginning. </p>
<p>
In Gravity, the Big Bang is in <b>CAnimApp::OnIdle</b>. Digging through the volumes of code required to find the document object, we find that <b>OnIdle </b>calls <b>CAnimDoc::UpdateSpritePositions</b>, which is listed below. (I've removed all <b>ASSERT</b> statements for clarity.)</p>
<pre><code>// Update the positions of all the sprites.
BOOL CAnimDoc::UpdateSpritePositions()
{
 &nbsp;&nbsp; int i = 0;
 &nbsp;&nbsp; POSITION pos;
 &nbsp;&nbsp; CAnimSprite *pSprite;

 &nbsp;&nbsp; if (m_spList.IsEmpty()) return FALSE; // no sprites
 &nbsp;&nbsp; for (pos = m_spList.GetHeadPosition(); pos != NULL;) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSprite = (CAnimSprite *)m_spList.GetNext(pos);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += pSprite-&gt;UpdatePosition(this);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; if (i) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw the changes.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateAllViews(NULL, HINT_DIRTYLIST, 0);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
The code above loops through the sprites and updates each sprite position by calling <b>CAnimSprite::UpdatePosition</b>. We need to modify <b>UpdateSpritePosition</b> to apply Newton's Law of Universal Gravitation to each <b>CBody </b>object before the function updates the sprite positions. The <b>UpdateSpritePosition </b>function used in Gravity is listed below. (I've removed all <b>ASSERT</b> statements for clarity.)</p>
<pre><code>BOOL CAnimDoc::UpdateSpritePositions()
{
 &nbsp; CBody* pBodyI ;
 &nbsp; CBody* pBodyJ ;
 &nbsp; POSITION i,j ;
 &nbsp; if (m_spList.IsEmpty()) return FALSE; // no sprites

 &nbsp; i = m_spList.GetHeadPosition();
 &nbsp; while(i != NULL )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; pBodyI = (CBody *)m_spList.GetNext(i); 
 &nbsp;&nbsp;&nbsp;&nbsp; j = m_spList.GetHeadPosition() ; 
 &nbsp;&nbsp;&nbsp;&nbsp; while(j != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBodyJ = (CBody *)m_spList.GetNext(j); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( j != i)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBodyI-&gt;ApplyForce(pBodyJ);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; 
 &nbsp; }

 &nbsp; i = m_spList.GetHeadPosition();
 &nbsp; while (i != NULL)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; pBodyI = (CBody *)m_spList.GetNext(i);
 &nbsp;&nbsp;&nbsp;&nbsp; pBodyI-&gt;Update() ;
 &nbsp; }

 &nbsp; UpdateAllViews(NULL, HINT_DIRTYLIST, 0);
 &nbsp; return TRUE;
}
</code></pre>
<p>
The code above shows that <b>CBody </b>needs two new member functions: <b>CBody::ApplyForce</b> and <b>CBody::Update</b>. <b>CBody::ApplyForce </b>applies Newton's Law of Universal Gravitation:</p>
<pre><code>void CBody::ApplyForce(CBody* pbody)
{
 &nbsp; CVector d ;
 &nbsp; double rs, r, v, vr ;

 &nbsp; d.x = m_position.x - pbody-&gt;m_position.x ;
 &nbsp; d.y = m_position.y - pbody-&gt;m_position.y ;

 &nbsp; rs = (d.x * d.x) + (d.y * d.y) ;
 &nbsp; if (rs != 0.0)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; r = sqrt(rs) ;
 &nbsp;&nbsp;&nbsp;&nbsp; v = (pbody-&gt;m_gmass / rs) * CUniverse::SECS_PER_TICK ; 
 &nbsp;&nbsp;&nbsp;&nbsp; vr = v / r ;
 &nbsp;&nbsp;&nbsp;&nbsp; m_velocity.x += vr * d.x ;
 &nbsp;&nbsp;&nbsp;&nbsp; m_velocity.y += vr * d.y ;
 &nbsp; }
}
</code></pre>
<p>
<b>CBody::Update </b>updates the position and velocity of each <b>CBody </b>object. It is equivalent to <b>CAnimSprite::UpdatePosition</b>. The code for <b>CBody::Update</b> is listed below:</p>
<pre><code>void CBody::Update()
{
 &nbsp; m_position.x += m_velocity.x * CUniverse::SECS_PER_TICK ; 
 &nbsp; m_position.y += m_velocity.y * CUniverse::SECS_PER_TICK ;

 &nbsp; // Cycle through the phases.
 &nbsp; if (GetNumPhases() &gt; 1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetPhase((GetPhase()+1)%GetNumPhases());

 &nbsp; // Set the sprite screen position...
 &nbsp; SetSPosition() ;
}

void CBody::SetSPosition()
{
 &nbsp; int x = (int)(m_position.x * s_scale.x) ;
 &nbsp; int y = (int)(m_position.y * s_scale.y) ;
 &nbsp; CPhasedSprite::SetPosition(x,y) ;
}
</code></pre>
<p>
You may remember that <b>CBody</b> inherits from <b>CPhasedSprite</b>. If we want the user to see phases, we must write some code to cycle through the phases. Luckily, Herman Rodent has already figured out some clever code to do this for us, so we simply copy:</p>
<pre><code>if (GetNumPhases() &gt; 1)
 &nbsp; SetPhase((GetPhase()+1)%GetNumPhases());
</code></pre>
<p>
from <b>CAnimSprite</b> and put it in our own code. (In your code, you may want to encapsulate these lines in a <b>NextPhase</b> function.) </p>
<h2>Bitmaps</h2>
<p>
I used bitedit, which is available in the Microsoft Development Library as an unsupported tool (under Unsupported Tools and Utilities, Windows Tools), to build the images that I used in Gravity. If you remember from reading <a href="msdn_anim32.htm">"Animation in Win32"</a>, we need to make sure that the palettes for our planets are the same as the background palette. To ensure that the palettes were the same for all of my images, I used bitedit to make the palette an "identity" palette. (This is really a misnomer because you can generate a true identity palette only at run time; it's not something that you can pass from one system to another.) All of my bitmaps use only the 20 system colors. Third-party tools such as PhotoStyler might make this process easier.</p>
<p>
I also used bitedit to build the phased earth bitmap (earth-p.bmp). I first rotated the earth bitmap (EARTH.BMP), and then combined the rotated earth images into one bitmap. This was a real pain. If you plan on using this approach for creating phased sprites, you should write a tool to build a phased sprite bitmap from separate bitmaps. Don't plan on using the Toolbar Editor in AppStudio to build the phased bitmap—AppStudio works only with 16-color bitmaps.</p>
<h2>Ripping Out Code</h2>
<p>
anim32 had many features that I didn't want to use, so I ripped them out. One of these features was the ability to drag the sprites with the mouse. I removed all of the mouse handlers except <b>OnLButtonDblClk</b>, so <b>CBody </b>does not need the <b>IsSelectable</b> member function that <b>CAnimSprite</b> contained.</p>
<p>
<b>CBody </b>also does not override the <b>CPhasedSprite::InitFromDib</b> function because it does not need to initialize anything after a file load. <b>CAnimSprite </b>implemented <b>CPhasedSprite::InitFromDib</b>, but the function didn't do anything that the <b>CPhasedSprite </b>implementation didn't already handle.</p>
<h2>Using the Timer</h2>
<p>
You don't need a timer to do simulations; you can use <b>CMainFrame::OnIdle </b>as ANIM32 does. However, I wanted to use a timer so that I could have a little more control over my simulation. I added two functions to start and stop the timer: <b>CAnimView::OnSimulateGo </b>and <b>CAnimView::OnSimulateStop</b>. </p>
<pre><code>void CAnimView::OnSimulateGo()
{
 &nbsp; CAnimDoc*pDoc = GetDocument() ;
 &nbsp; if (pDoc-&gt;AnySprites())
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (pDoc-&gt;m_bSimulate == FALSE)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_timer = SetTimer(G_TIMER,CUniverse::TIME,NULL) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_timer != 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDoc-&gt;m_bSimulate = TRUE ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
 &nbsp; MessageBeep(0) ;
}

void CAnimView::OnSimulateStop()
{
 &nbsp; CAnimDoc*pDoc = GetDocument() ;
 &nbsp; if (pDoc-&gt;m_bSimulate == TRUE)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; KillTimer(m_timer) ;
 &nbsp;&nbsp;&nbsp;&nbsp; m_timer = NULL ;
 &nbsp;&nbsp;&nbsp;&nbsp; pDoc-&gt;m_bSimulate = FALSE ;
 &nbsp; }
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; MessageBeep(0) ;
 &nbsp; }
</code></pre>
<p>
I nuked the <b>CAnimApp::OnIdle</b> function and replaced it with <b>CAnimView::OnTimer</b>:</p>
<pre><code>void CAnimView::OnTimer(UINT nIDEvent)
{
 &nbsp; COffScreenDIBView::OnTimer(nIDEvent);
 &nbsp; CAnimDoc *pDoc = GetDocument();
 &nbsp; ASSERT(pDoc-&gt;m_bSimulate == TRUE) ;
 &nbsp; pDoc-&gt;UpdateSpritePositions();
}
</code></pre>
<p>
The Boolean variable, <b>CAnimDoc::m_bSimulate</b>, tracks the simulation and enables or disables menu commands such as the Simulate menu Reset command, which is handled by <b>CAnimDoc::OnUpdateSimulateReset</b>:</p>
<pre><code>void CAnimDoc::OnUpdateSimulateReset(CCmdUI* pCmdUI)
{
 &nbsp; // Allow a reset only if we are not simulating.
 &nbsp; pCmdUI-&gt;Enable(!m_bSimulate) ;
}
</code></pre>
<p>
Note that <b>CAnimDoc</b> has handlers to disable the File Save and File Save As commands although the MFC framework still handles the functions themselves.</p>
<h3>SDI Applications Don't Delete Views</h3>
<p>
Single-document interface (SDI) applications are different from multiple-document interface (MDI) applications in many ways. The difference that concerns us here is that the view object in an SDI application is not destroyed until the SDI application is closed. If the user chooses the File New command, we cannot depend on the code in the view class destructor or in the <b>OnDestroy</b> message handler to clean up for us.</p>
<p>
Instead, we need to make sure that we clean things up in <b>OnInitialUpdate</b>. What I am particularly worried about is the timer. I don't want the timer to be running after the user has selected the File New command, so I kill the timer in <b>CAnimView::OnInitialUpdate</b>:</p>
<pre><code>void CAnimView::OnInitialUpdate()
{
 &nbsp; if (m_timer)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; VERIFY(KillTimer(m_timer)) ;
 &nbsp;&nbsp;&nbsp;&nbsp; m_timer = NULL ;
 &nbsp; }
}
</code></pre>
<p>
The File New command does not destroy and reconstruct the document class either, so we cannot rely on the destructor to reset the <b>m_bSimulate</b> variable. Instead, I used <b>DeleteContents</b> to reset this variable:</p>
<pre><code>void CAnimDoc::DeleteContents()
{
...
 &nbsp; m_bSimulate = FALSE ;
...
}
</code></pre>
<h2>Conclusion</h2>
<p>
So there you have an (unbiased) testimonial proving how easy it is to build sprite-based applications with MFC and Herman Rodent's sprite class. Herman Rodent's anim32 sample application is a good starting point for building your own sprite-based application. </p>
<p>
This is a long way from the old "E" and "m" simulations I used to play with—we now have full 256 color images, rotating planets, and file loading. Great stuff. If anyone comes up with some cool simulations or better bitmaps for the planets, send them my way. Maybe that old friend of mine will be happy that I finally wrote the simulation program.</p>
<h2>Bibliography</h2>
<p>
King, Todd. "Forced-based Simulations," <i>Dr. Dobb's Journal</i> (September 1989): 40-42.</p>
<p>
Kruglinski, David J. <i>Inside Visual C++</i>. Redmond, WA: Microsoft Press, 1993.</p>
<p>
Rodent, Herman. <a href="msdn_anim32.htm">"Animation in Win32."</a> February 1994.</p>
<p>
Stanford, A.L., and J.M. Tanner. <i>Physics for Students of Science and Engineering</i>. Orlando, FL: Academic Press, 1985.</p>
</BODY>
</HTML>
