<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Designing the HelpDesk Transaction-Processing Object Model</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_hdobj"></a>Designing the HelpDesk Transaction-Processing Object Model</h1>
<p>
Fred Pace<br>
MSDN Content Development Group</p>
<p>
September 1997<br>
Updated: February 2, 1998</p>
<p class=indent>
<B><b>Update details</b></B>&nbsp;&nbsp;&nbsp;The HelpDesk object model code was revised during development to meet the changing needs of the project. The source code now available with this article accurately reflects the object model for the final HelpDesk sample application. (For example, <b>ExecBoolean()</b> has been renamed <b>ExecQuery()</b>).</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5165">
</OBJECT><a href="javascript:sample1.Click()">Click to copy the HelpDeskOM sample files.</a></p>
<h2>Introduction</h2>
<p>
Designing transaction-processing object models is a task that should never be taken on without proper planning. If you have read any of my articles in the past, you know that I am always preaching the "spend time on your design" mantra. In this article, I will take you through the design of a transaction-processing object model for the MSDN HelpDesk Site sample. (For an introduction to the HelpDesk Site sample, see Robert Coleridge's article <a href="msdn_hlpdskov.htm">"The HelpDesk Site Sample: Overview of an Automated Solution."</a>) Along the way, I hope to impart to you some design and development techniques that will be helpful in your own client/server development pursuits. In particular, I'd like to illustrate generic components and how to plan an object model with Microsoft® Transaction Server (MTS) in mind.</p>
<p>
Included with this article is HelpDeskOM, the HelpDesk sample object model and source code. To work with these objects you will need the Microsoft Windows NT® 4.0 or Windows® 95 operating system, the Microsoft Visual Basic® version 5.0 programming system, and ActiveX™ Data Objects (ADO) version 1.1 or higher. ADO can be found on the Microsoft Web site at <a href="http://www.microsoft.com/ado/">http://www.microsoft.com/ado/</a>.</p>
<h2>Generic Components</h2>
<p>
It is sometimes said that the best programmers are lazy programmers. To protect my reputation I won't say whether that statement fits me or not. I will say that I am a big believer in reusing code. In fact, large portions of code in most of the applications that we build here in MSDN are cut and pasted from other applications. All the transaction-processing applications that have been built in my tenure at MSDN have included two basic components. If any of you have ever read my article, <a href="msdn_palette1.htm">"Designing Intelligent Control Palettes in Visual Basic 5.0,"</a> then you already know what code I'm talking about: the data access services, <b>ExecFillArray() </b>and<b> ExecBoolean()</b>, which we have renamed <b>ExecQuery()</b>.These data-access services essentially provide functionality in which data can be written to and extracted from a particular type of a database.</p>
<p>
In my construction of the HelpDesk object model, it dawned on me that I could have saved myself even more time if I didn't have to cut and paste the code in at all. If I could compile those two methods into a Component Object Model (COM) dynamic-link library (DLL), then I could just reference them in all future applications that need to operate on a Microsoft SQL Server™ database. Does this sound pretty simple? Well, maybe it is—as long as you have thought it all the way through. Let's examine a few issues.</p>
<p>
First of all, <b>ExecQuery()</b> and <b>ExecFillArray()</b> are stateful and require that a constant variable, <i>scConnect</i>, is defined so that the methods know data-source and connection information. Since stateful methods can degrade performance and scalability (you'll find out why later in this article), these methods need to be made stateless. This can be done simply by adding a parameter to each method. For example, the original <b>ExecQuery()</b> declaration, <b>ExecQuery(ByVal sQry as String)</b>, becomes <b>ExecQuery(ByVal sConnect as String, ByVal sQry as String)</b>. By including the <i>sConnect</i> parameter for the data-source connection information, the function now can be passed everything it needs to operate independently. Now that the methods are stateless, they can be encapsulated into a component (that is, a Visual Basic class file) and compiled. As you'll see later in this article, when planning a design that will operate within the Microsoft Transaction Server environment, stateless methods are the only way to go.</p>
<p>
Now let's consider the advantages and ramifications of this data-access component. Let's first respond to all the folks who think that I just killed their data-access performance by removing the data-access methods from a more monolithic code base. Have I really? After all, the new component (CExec) is compiled into an ActiveX DLL (DBExec.DLL) and will be executed in-process, dramatically reducing (if not eliminating) any possible performance penalty. Now let's look at what I have gained: a component—which any other component can reference—that can perform data-access services on any SQL Server database (Figure 1).</p>
<p>
<img src="hdobj1.gif" border=0></p>
<p class=label>
<b>Figure 1. Centralized data access</b></p>
<p>
This component centralizes all SQL Server connections—data access is done through the component rather than through random connections to SQL Server. It can also be integrated into Microsoft Transaction Server should scalability become an issue. I've also gained an easily maintainable code base. Since the code isn't pasted into several different transaction processing objects, if I ever need to make a change (such as MTS transaction semantics), I can easily locate the code. Does the gain outweigh the cost? I would have to say yes.</p>
<h2>Planning for Microsoft Transaction Server</h2>
<p>
Microsoft Transaction Server brings a wealth of scalability features to the mix, including object-instance management, transaction monitoring, and resource management (connections and threads). If you are building something that could potentially be rolled out to numerous clients, you should investigate the MTS offerings. Let's discuss two of the most important aspects of components that run under MTS—they're stateless and they're specific in functionality.</p>
<h3>Stateless Components</h3>
<p>
As I mentioned earlier in this article, stateless components are fully encapsulated, self-sufficient pieces of functionality. That is, they don't require any bits of global data in order to get their work done. As I explained with the <b>ExecQuery()</b> and <b>ExecFillArray()</b> methods, when a stateless method is called, everything that is required for that method to do its work is included in the method parameter list. Let's find out why this is so important.</p>
<p>
Microsoft Transaction Server has the ability to share a component among several different clients by using techniques known as just-in-time (JIT) object activation and as-soon-as-possible (ASAP) deactivation. These abilities allow MTS to enable and sustain component references for as long as they are in use by the client. Notice that I said "in use" rather than "referenced by." MTS may shuffle a single instance of a component among several different clients, each with references. If MTS has to manage a component's stateful data, the component can't be efficiently deactivated and shared. Because of this, stateless components are a necessity.</p>
<p>
The following code illustrates a simplified look at one of the HelpDesk components, CTrans, that is designed to be operated from within MTS. Notice that the class declaration includes no globally modifiable (stateful) data. Each method requires (as parameters) all the data that is required for it to do its job.</p>
<pre><code>Option Explicit

Private Const scConnect = "helpdesk"

Public Function ClaimRequest(lTechId As Long, lReqId As Long) As Boolean
. . .
Public Function GetDomain(iDomain As icHDDomains, sData() As String) As Boolean
. . .
Public Function GetRequest(lReqId As Long, sData() As String) As Boolean
. . .
</code></pre>
<p>
The objects that interact directly with a user interface do not need to be managed by MTS as they sit directly on the client machine. The following code illustrates the header of a stateful client-side component, CAdmin:</p>
<pre><code>Option Explicit

. . .
Private m_cLocs&nbsp;&nbsp;&nbsp;&nbsp; As Collection
Private m_cReqs&nbsp;&nbsp;&nbsp;&nbsp; As Collection
Private m_cSkills&nbsp;&nbsp; As Collection
Private m_cTechs&nbsp;&nbsp;&nbsp; As Collection
Private m_lTechId&nbsp;&nbsp; As Long

. . .
 </code></pre>
<p>
Notice all the variables prefaced with an <i>m_</i>. These are module-level variables that store stateful data that is shared among the component's methods. This component should never be operated from within MTS.</p>
<p>
Figure 2 illustrates the components of HelpDesk that <i>are</i> designed to be managed by MTS.</p>
<p>
<img src="hdobj2.gif" border=0></p>
<p class=label>
<b>Figure 2. MTS-designed components</b></p>
<h3>Encapsulating Transactions</h3>
<p>
A transaction that performs a single task is said to be granular. (Within the four-tier architectural model used by HelpDesk, a granular transaction can also be considered a business rule. For a description of the HelpDesk's adaptation of the four-tier model, see "The HelpDesk Site Sample: Overview of an Automated Solution.") For example, placing an order is generally not considered to be a granular unit of work. Placing an order generally consists of checking availability, decrementing inventory, incrementing (if needed) back orders, and so on. Each of these transactions may in turn need to be broken down further. Transactions should be made as granular as possible (while maintaining acceptable performance) and then encapsulated within workflow methods. The HelpDesk object model doesn't currently require any multistep workflow (but the design is in place should the need arise), so I'll have to demonstrate this with the order-processing example. <b>ProcessOrder()</b> would be a workflow method that encapsulates the granular transactions required to actually process the order. The encapsulated workflow method may look something like the following:</p>
<pre><code>Public Sub ProcessOrder
CheckAvailability()
If DecrementInventory() Then
 &nbsp;&nbsp; 'Do more stuff
Else
 &nbsp;&nbsp; IncrementBackOrder()
End If
End Sub
</code></pre>
<p>
Creating granular transactions improves both scalability and code reuse. Consider the <b>ProcessOrder()</b> example again. Since the transactional code has been isolated into granular business rules, those rules can be executed across several machines if necessary. Also, the business rules can easily be reused in other workflow methods if necessary. Had <b>ProcessOrder()</b> been written as a monolithic, single-function piece of code, neither of these benefits could be realized.</p>
<p>
HelpDesk is designed with granularity in mind. Transactions are designed as single-function stored procedures in the SQL database and then wrapped by business methods in Visual Basic. These business methods are in turn encapsulated by workflow methods. </p>
<h2>The HelpDesk Object Model</h2>
<p>
Okay, so what does the whole enchilada look like? Figure 3 depicts the HelpDesk sample object model.</p>
<p>
<img src="hdobj3.gif" border=0></p>
<p class=label>
<b>Figure 3. The HelpDesk object model</b></p>
<p>
As you can see, on the server side of this diagram two physical components exist, DBExec and HDServer. The client side has one component, HDClient.</p>
<h4>DBExec.dll</h4>
<p>
DBExec contains the data-access services that I described earlier in this article. This component is generic, has no specific knowledge of the HelpDesk SQL database, and is capable of interacting with any SQL Server database. DBExec is used by the component in HDServer.</p>
<h4>HDServer.dll</h4>
<p>
HDServer contains HelpDesk business methods and its functionality is specific to the needs of the HelpDesk sample. This DLL provides the CTrans component, which supports the client-side components in HDClient. Table 1 is a partial list of the methods of CTrans. For a complete list, see the <a href="msdn_hdapiref.htm">"HelpDesk API Reference"</a>.</p>
<p class=label>
<b>Table 1. CTrans Methods</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=24%><b>ClaimRequest</b></td>
<td width=76%>Marks a specified request as claimed by a specified technician</td>
</tr>
<tr valign=top>
<td width=24%><b>GetDomain</b></td>
<td width=76%>Gets a domain from the database</td>
</tr>
<tr valign=top>
<td width=24%><b>GetRequest</b></td>
<td width=76%>Gets a specified request</td>
</tr>
<tr valign=top>
<td width=24%><b>GetRequests</b></td>
<td width=76%>Gets a collection of all requests for a specified technician</td>
</tr>
<tr valign=top>
<td width=24%><b>GetReqDetail</b></td>
<td width=76%>Gets the details of a specified request detail record</td>
</tr>
<tr valign=top>
<td width=24%><b>GetReqDetails</b></td>
<td width=76%>Gets all the request details for a specified request</td>
</tr>
<tr valign=top>
<td width=24%><b>GetTech</b></td>
<td width=76%>Gets a specified technician</td>
</tr>
<tr valign=top>
<td width=24%><b>GetTechs</b></td>
<td width=76%>Gets all specified technicians</td>
</tr>
<tr valign=top>
<td width=24%><b>ReAssignReq</b></td>
<td width=76%>Reassigns a request from one technician to another</td>
</tr>
<tr valign=top>
<td width=24%><b>ResolveRequest</b></td>
<td width=76%>Sets a specified request as resolved</td>
</tr>
<tr valign=top>
<td width=24%><b>UnclaimRequest</b></td>
<td width=76%>Unclaims a previously claimed request</td>
</tr>
<tr valign=top>
<td width=24%><b>WorkRequest</b></td>
<td width=76%>Tags a request as work in progress</td>
</tr>
</table><br>
<h4>HDClient.dll</h4>
<p>
The client-side DLL, HDClient, provides the administrative object (CAdmin) and three data objects (CReqDetail, CRequest, CTech), as well as workflow to client interfaces. Its functionality is specific to the needs of the sample HelpDesk user interfaces. Table 2 is a partial list of the methods of CAdmin. For a complete list, see the <a href="msdn_hdapiref.htm">"HelpDesk API Reference"</a>.</p>
<p class=label>
<b>Table 2. CAdmin Methods</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=31%><b>Init </b></td>
<td width=69%> Initializes the administrative object</td>
</tr>
<tr valign=top>
<td width=31%><b>FillListLocs </b></td>
<td width=69%> Returns a list of locations</td>
</tr>
<tr valign=top>
<td width=31%><b>FillListSkills </b></td>
<td width=69%> Returns a list of skills</td>
</tr>
<tr valign=top>
<td width=31%><b>FillListReqs </b></td>
<td width=69%> Returns a list of requests</td>
</tr>
<tr valign=top>
<td width=31%><b>FillListTechs </b></td>
<td width=69%> Returns a list of technicians</td>
</tr>
<tr valign=top>
<td width=31%><b>GetNewReq </b></td>
<td width=69%> Obtains a new CRequest object</td>
</tr>
<tr valign=top>
<td width=31%><b>GetNewReqDet </b></td>
<td width=69%> Obtains a new CReqDet object</td>
</tr>
<tr valign=top>
<td width=31%><b>GetNewTech </b></td>
<td width=69%> Obtains a new CTech object</td>
</tr>
<tr valign=top>
<td width=31%><b>GetTechByAlias </b></td>
<td width=69%> Returns a technician object by e-mail alias</td>
</tr>
<tr valign=top>
<td width=31%><b>ReAssignReq </b></td>
<td width=69%> Reassigns a specified request</td>
</tr>
<tr valign=top>
<td width=31%><b>ResolveRequest </b></td>
<td width=69%> Resolves a request</td>
</tr>
<tr valign=top>
<td width=31%><b>UnclaimRequest </b></td>
<td width=69%> Unclaims a previously claimed request</td>
</tr>
<tr valign=top>
<td width=31%><b>WorkRequest </b></td>
<td width=69%> Flags a request as work in progress</td>
</tr>
<tr valign=top>
<td width=31%><b>Term </b></td>
<td width=69%> Called to terminate usage of object</td>
</tr>
<tr valign=top>
<td width=31%><b>ClaimRequest </b></td>
<td width=69%> Claims a request for resolution</td>
</tr>
</table><br>
<p>
After spending some time on the HelpDesk object model's architecture, the actual implementation was really pretty straightforward. The only noteworthy functionality is the means by which rows of data are moved between components, particularly between the client machine and the server machines.</p>
<p>
To efficiently move sets of data, I chose to implement data packaging. When a data set is requested by the client, the request is handled by the <b>ExecFillArray()</b> method in the DBExec.dll. <b>ExecFillArray()</b> executes a SQL Server stored procedure that returns a cursor. <b>ExecFillArray()</b> then walks the cursor and fills an array with the cursor data. Moving sets of data around as an array is much more efficient than moving around collections of objects or recordsets. However, because of the complexities of working with arrays and offsets, they aren't exactly the friendliest data structure to present to clients. Enter the data packager . . .</p>
<p>
The array is passed to the client-side component and processed by a data packager. The packager's mission in life is to take an array of data and turn it into a easy-to-use collection of data objects. The following is the packager code for Technician data:</p>
<pre><code>Public Sub FillListTechs()
. . .
Dim sData() As String

On Error Resume Next
Set oTrans = New HDServer.CTrans
Set m_cLocs = Nothing
If oTrans.GetTechs(icWorkingTechs, sData) Then
 &nbsp;&nbsp; For iIndex = LBound(sData, 2) To UBound(sData, 2)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set oTech = New CTech
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With oTech
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Admin = Me
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .PKId = CLng(sData(icTechPkId, iIndex))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .SkillId = CLng(sData(icTechSkillId, iIndex))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .LocationId = CLng(sData(icTechLocId, iIndex))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End With
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_cLocs.Add oTech, "Id=" &amp; CStr(oTech.PKId)
 &nbsp;&nbsp; Next iIndex
End If
Set oTrans = Nothing
End Sub
</code></pre>
<p>
Now, the developer can work with neat collections of data objects instead of arrays and offsets that are more prone to errors. If you want to read more about packager interfaces and other useful server interface techniques, be sure to check out Ken Bergmann's excellent article, <a href="msdn_pubint.htm">"Three Useful Server Interface Techniques."</a></p>
<h2>Conclusion</h2>
<p>
Well, now you should have a pretty good idea of how the HelpDesk object model works. Hopefully, you have also garnered some useful insights that will help you in your multitiered client/server development. If I leave you with anything at all, I hope that it is with an understanding of how important it is to spend time on your design and architecture up front. Too often, developers dive into coding a project without having a proper architecture. Unfortunately, this only becomes apparent when their application won't scale or easily adapt to some unforeseen business needs.</p>
<p>
The MSDN Library is full of articles that can be of tremendous benefit when architecting a client/server system. Along with the articles I've already mentioned, check out Ken Bergmann's fantastic <i>Client/Server Solutions</i> series of articles starting with <a href="msdn_csarctop.htm">"Client/Server Solutions: The Architecture Process."</a> Also, Steve Kirk's article <a href="msdn_taskdist.htm">"Task Distribution in a Customer Service System"</a> covers task distribution in the HelpDesk Site sample. So be sure to check it out as well. Read and practice, folks. Read through sample code and study designs. Perhaps you can improve on the techniques used. You'll never know until you try.</p>
</BODY>
</HTML>
