<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OpenGL VII: Scratching the Surface of Texture Mapping</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_gl7"></a></sup>OpenGL VII: Scratching the Surface of Texture Mapping</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
May 12, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4241">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the EasyTex sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4244">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the PicCube sample application for this technical article.</a></p>
<p>
<OBJECT id=sample3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4242">
</OBJECT><a href="javascript:sample3.Click()">Click to open or copy the files in the GLlib DLL for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article explains how to apply bitmaps to OpenGL™ surfaces to give them a realistic appearance. The bitmaps are known as <i>textures</i> and can resemble wood, marble, or any other interesting material or pattern. The process of applying or mapping a texture to a surface is known as <i>texture mapping</i>. The EasyTex and PicCube sample applications demonstrate the concepts discussed in this article.</p>
<h2>Stamps and Boxes</h2>
<p>
One Christmas, back when I was not only mentally but legally a kid, my parents gave me a Guns of Navarone play set, consisting of a 3-foot plastic mountain with large yellow artillery guns. A World War II play set is an odd gift for Christmas, but I was happy with the present. I was also pleased to see that the play set came in a large box. I loved playing in the large box—it became a tank, a plane, or a fox hole at the whim of my imagination. However, that's not all I did with the large box. I also texture-mapped it.</p>
<p>
Back then, music companies had subscription music services (as they do now), which offered 10 records for a penny. (Of course, after your first order, you had to buy several records at the inflated club prices.) The club catalog included stamps representing each album cover. You would order the records you wanted by sticking the stamps on the order form. I didn't have a penny, so I couldn't get the 10 records. So, instead of putting the stamps on the order form, I put them on my large box. Eventually, the entire box became textured with these stamps, as illustrated in Figure 1.</p>
<p>
<img src="gl7_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Texturing a box with stamps</b></p>
<p>
OpenGL™ contains a feature called <i>texture mapping</i>, which is similar to sticking stamps on a box. Texture mapping is the application (or mapping) of an image (or texture) to the surface of a polygon or other graphics primitive, as illustrated in Figure 2.</p>
<p>
<img src="gl7_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Mapping a texture to a polygon</b></p>
<p>
Let's say you want an OpenGL representation of your living room. If your living room has a wood table, you could scan a piece of wood to use as a texture and map the wood texture to the polygons that make up your table. You could also apply textures to the wallpaper and carpet. For example, you could use a scanned image of your mother to texture-map a picture frame on the wall. The Doom video game almost exclusively uses texture mapping (but not through OpenGL) to create the feeling of being in scary places.</p>
<p>
This article is only going to scratch the surface of using OpenGL texture mapping. We will cover the following topics:
<ul type=disc>
<li>
What the EasyTex sample application demonstrates<br><br></li>
<li>
What the PicCube sample application demonstrates<br><br></li>
<li>
How to translate a Windows® device-independent bitmap (DIB) into an OpenGL texture<br><br></li>
<li>
How to enable texture mapping<br><br></li>
<li>
How to specify texture coordinates when mapping a texture to a surface</li>
</ul>
<p>
Texture mapping is more of an art than a science. Texture-mapping complicated shapes requires lots of experimentation, experience, and patience. See Chapter 9 in the <i>OpenGL Programming Guide</i> (also called the Red Book; see the bibliography at the end of this article) for additional information on texture mapping.</p>
<h2>The EasyTex Sample Application</h2>
<p>
The EasyTex sample application demonstrates the concepts of texture mapping presented in this article. EasyTex is based on the EasyGL sample application, which has been the basis for all my articles in this OpenGL article series.</p>
<p>
EasyTex adds support for texture-mapping the box displayed in the window's client area. Figure 3 is a simulated screen shot of EasyTex. (As in previous articles, I didn't use a real screen shot because the Microsoft® Development Library software doesn't display 256-color images.)</p>
<p>
<img src="gl7_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Simulated screen shot of EasyTex</b></p>
<p>
Initially, the box is textured with three wallpaper bitmaps (HONEY.BMP, BRICK.BMP, and EGYPT.BMP) and the Microsoft Developer Network logo. Bitmaps that are smaller than 128 pixels in width or height are repeated on the surface of the box. Bitmaps that are larger than 128 pixels in width or height are not repeated. The Microsoft Developer Network logo is not repeated.</p>
<p>
The EasyTex Texture menu (Figure 4) provides control over how the box is texture-mapped.</p>
<p>
<img src="gl7_4.gif" border=0></p>
<p class=label>
<b>Figure 4. EasyTex Texture menu</b></p>
<p>
The Texture menu contains the following options:
<ul type=disc>
<li>
The Enable command turns texture mapping on and off.<br><br></li>
<li>
The Decal command determines whether the texture will be applied like a decal, covering the underlying surface. When this option is enabled, the colors of the texture cover the colors of the object. <br><br></li>
<li>
The Modulate command determines whether the texture will modify the underlying surface. When this option is enabled, the colors of the texture modify the colors of the object. <p class=tl>
The "Choosing the Texturing Mode" section later in this article explains the differences between the Decal and Modulate options in more detail.</P></li>
<li>
The Open DIB command allows the user to load a DIB or bitmap (through a File Open dialog box) and use it as a texture map. The DIB replaces the face of the cube, as illustrated earlier in Figure 3. You can load any Windows DIB for use as a texture. Try images with at least 256 colors for fun results.</li>
</ul>
<h2>PicCube Sample Screen Saver</h2>
<p>
I wrote another sample application, PicCube, to demonstrate texture mapping. PicCube is a Windows screen saver that displays a rotating, floating cube with six texture-mapped sides. You can pick a different bitmap to use as a texture for each side of the cube. </p>
<p>
The screen saver part of PicCube comes from Nigel Thompson's article, <a href="msdn_scrnsave.htm">"Creating 32-Bit Screen Savers with Visual C++ and MFC"</a> in the MSDN Library.</p>
<p>
To use PicCube as a screen saver, copy the piccube.scr file to your Windows NT™ \SYSTEM32 directory. Choose Desktop from the Control Panel to select the file as the screen saver, choose Setup, and use the Setup dialog box to pick the bitmaps for texturing the sides of the cube.</p>
<p>
PicCube uses a statically linked version of GLlib, which contains a class library for OpenGL. Make sure that when you build PicCube, GLlib, and Nigel Thompson's animation libraries, you link statically to the Microsoft Foundation Class Library (MFC) instead of linking to the shared library. I decided that PicCube should use statically linked versions of GLlib and MFC to facilitate installation.</p>
<h2>Translating DIBs into Textures</h2>
<p>
The first step for texture-mapping an object is getting the texture. You can generate textures at run time, but in most cases you will use DIBs stored as files or resources. We covered loading and translating Windows DIBs into OpenGL images in the technical article <a href="msdn_gl5.htm">"OpenGL V: Translating Windows DIBs"</a> in the MSDN Library.</p>
<p>
Once the Windows DIB has been loaded and translated into an OpenGL image, we have to modify the image once more before we use it as a texture. The OpenGL <b>glTexImage2D</b> command defines the image to be used for texture mapping. This command requires both the width and the height of the image to be a power of two, so we must resize the image if its dimensions are different.</p>
<p>
I added a new member function to <b>CGLImage </b>to handle resizing images: <b>CGLImage::TexMapScalePow2</b> resizes the image using <b>gluScaleImage</b>. The <b>StretchDIBits </b>function in the Windows graphics device interface (GDI) is faster than the <b>gluScaleImage</b> utility function in OpenGL. However, <b>gluScaleImage</b> generates higher-quality images.</p>
<p>
The code for <b>CGLImage::TexMapScalePow2</b> is shown below. I based this code on the code used in the OpenGL screen savers, which are included with Windows NT version 3.5.</p>
<pre><code>//
// TexMapScalePow2 - Scale image to power of 2 in height and width.
//
BOOL CGLImage::TexMapScalePow2(CGL* pGL)
{
 &nbsp; GLint glMaxTexDim ;
 &nbsp; double xPow2, yPow2;
 &nbsp; int ixPow2, iyPow2;
 &nbsp; int xSize2, ySize2;

 &nbsp; glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;glMaxTexDim);
 &nbsp; glMaxTexDim = min(128, glMaxTexDim);

 &nbsp; if (m_iWidth &lt;= glMaxTexDim)
 &nbsp;&nbsp;&nbsp;&nbsp; xPow2 = log((double)m_iWidth) / log(2.0);
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; xPow2 = log((double)glMaxTexDim) / log(2.0);

 &nbsp; if (m_iHeight &lt;= glMaxTexDim)
 &nbsp;&nbsp;&nbsp;&nbsp; yPow2 = log((double)m_iHeight) / log(2.0);
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; yPow2 = log((double)glMaxTexDim) / log(2.0);

 &nbsp; ixPow2 = (int)xPow2;
 &nbsp; iyPow2 = (int)yPow2;

 &nbsp; if (xPow2 != (double)ixPow2)
 &nbsp;&nbsp;&nbsp;&nbsp; ixPow2++;
 &nbsp; if (yPow2 != (double)iyPow2)
 &nbsp;&nbsp;&nbsp;&nbsp; iyPow2++;

 &nbsp; xSize2 = 1 &lt;&lt; ixPow2;
 &nbsp; ySize2 = 1 &lt;&lt; iyPow2;

 &nbsp; BYTE *pData = (BYTE*)malloc(xSize2 * ySize2 * 3 * sizeof(BYTE));
 &nbsp; if (!pData) return FALSE;

 &nbsp; pGL-&gt;MakeCurrent() ;
 &nbsp; gluScaleImage(GL_RGB, m_iWidth, m_iHeight,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GL_UNSIGNED_BYTE, m_pBits,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xSize2, ySize2, GL_UNSIGNED_BYTE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData);

 &nbsp; free(m_pBits);
 &nbsp; m_pBits = pData; 
 &nbsp; m_iWidth = xSize2 ;
 &nbsp; m_iHeight = ySize2 ;

 &nbsp; return TRUE ;
}
</code></pre>
<p>
I won't go into much detail on how <b>TexMapScalePow2</b> works, but I do want to explain the following two lines in the code:</p>
<pre><code>glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;glMaxTexDim);
glMaxTexDim = min(128, glMaxTexDim);
</code></pre>
<p>
The first line gets the maximum allowable size for an image to be used as an OpenGL texture map. On my system, this value happens to be 1024. This size may vary, depending on your system, especially if you have an OpenGL-accelerated video card.</p>
<p>
The second line results in <b>TexMapScalePow2 </b>generating an image that is no larger than 128 x 128 pixels. For the generic OpenGL implementation on Windows NT, the smaller the texture, the faster OpenGL works. Graphics cards accelerated for OpenGL may implement texture mapping in hardware, resulting in little performance degradation when using large bitmaps. For EasyTex, I picked 128 pixels because it provided decent speed with reasonable detail. A more generic version of <b>TexMapScalePow2</b> would take this value as a parameter. The OpenGL screen savers also limit the size of textures for the same reason.</p>
<h2>Initializing Texture Mapping</h2>
<p>
Before we can see our textures mapped to the screen, we have to initialize texture mapping. In EasyTex, these initializations are called from the <b>CScene::OnInit</b> member function.</p>
<h3>Enabling Texture Mapping</h3>
<p>
In EasyTex, I used the <b>glEnable </b>function to enable texture mapping:</p>
<pre><code>glEnable(GL_TEXTURE_2D);
</code></pre>
<h3>Setting Pixel Alignment</h3>
<p>
The pixel alignment must be set. The image pixel data stored by <b>CGLImage</b> is aligned on a byte boundary. The following command tells OpenGL what the pixel alignment is:</p>
<pre><code>glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
</code></pre>
<p>
See the article <a href="msdn_gl5.htm">"OpenGL V: Translating Windows DIBs"</a> in the MSDN Library for more information on pixel alignment.</p>
<h3>Specifying Repeating Textures</h3>
<p>
If you want to repeat the texture over the surface, use the GL_REPEAT option:</p>
<pre><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
</code></pre>
<p>
If you set the correct texture coordinates, OpenGL will repeat the texture over the surface instead of displaying a single copy of the texture.</p>
<p>
Another option is GL_CLAMP, which displays one copy of the texture on the surface. EasyTex and PicCube use GL_REPEAT, and we'll continue our discussion of repeating textures in the next section on texture coordinates. For information on GL_CLAMP, see the "Repeating and Clamping Textures" section in Chapter 9 of the Red Book. </p>
<h3>Picking the Filtering Method</h3>
<p>
When OpenGL maps the texture to the surface, rarely does one pixel in the texture (a <i>texel</i>) map to one pixel on the screen. A single texel may map to several screen pixels (magnification) or to only a part of one screen pixel (minification). You can control how OpenGL magnifies or minifies a texel. The following two lines use the easiest and fastest method for specifying the filtering method:</p>
<pre><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
</code></pre>
<p>
Notice that you can specify the magnification and minification methods separately. The following table shows the allowable values for the above OpenGL parameters:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=44%><b>OpenGL Parameter</b></td>
<td class=label width=56%><b>Values</b></td>
</tr>
<tr valign=top>
<td width=44%>GL_TEXTURE_MAG_FILTER</td>
<td width=56%>GL_NEAREST<p>
GL_LINEAR</p>
</td>
</tr>
<tr valign=top>
<td width=44%>GL_TEXTURE_MIN_FILTER</td>
<td width=56%>GL_NEAREST<p>
GL_LINEAR</p>
<p>
GL_NEAREST_MIPMAP_NEAREST</p>
<p>
GL_NEAREST_MIPMAP_LINEAR</p>
<p>
GL_LINEAR_MIPMAP_NEAREST</p>
<p>
GL_LINEAR_MIPMAP_LINEAR</p>
</td>
</tr>
</table><br>
<p>
The OpenGL screen savers define the output quality of the magnification and minification, as shown below.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=13%><b>Quality</b></td>
<td class=label width=43%><b>OpenGL Parameter</b></td>
<td class=label width=44%><b>Value</b></td>
</tr>
<tr valign=top>
<td width=13%>High</td>
<td width=43%>GL_TEXTURE_MAG_FILTER<p>
GL_TEXTURE_MIN_FILTER</p>
</td>
<td width=44%>GL_LINEAR<p>
GL_LINEAR_MIPMAP_NEAREST</p>
</td>
</tr>
<tr valign=top>
<td width=13%>Medium</td>
<td width=43%>GL_TEXTURE_MAG_FILTER<p>
GL_TEXTURE_MIN_FILTER</p>
</td>
<td width=44%>GL_LINEAR<p>
GL_LINEAR</p>
</td>
</tr>
<tr valign=top>
<td width=13%>Low</td>
<td width=43%>GL_TEXTURE_MAG_FILTER<p>
GL_TEXTURE_MIN_FILTER</p>
</td>
<td width=44%>GL_NEAREST<p>
GL_NEAREST</p>
</td>
</tr>
</table><br>
<p>
The screen savers do not actually use the high-quality setting, because it is much slower than the medium- and low-quality settings. The Red Book discusses these parameters in detail.</p>
<h3>Choosing the Texturing Mode</h3>
<p>
Next, we need to decide which texturing mode we want to use. OpenGL has two modes—decal and modulate:</p>
<pre><code>glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
</code></pre>
<p>
and</p>
<pre><code>glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
</code></pre>
<p>
When the texture mode is GL_DECAL, the texture covers the object below it, as shown in Figure 5. Notice that the mapped texture is the same color as the original texture.</p>
<p>
<img src="gl7_5.gif" border=0></p>
<p class=label>
<b>Figure 5. Texture mapping using the GL_DECAL mapping mode</b></p>
<p>
When the texture mode is GL_MODULATE, the color values in the texture modify the intensity of the colors in the object instead of replacing the colors. Notice in Figure 6 below that the mapped texture is the same color as the original object. The lines in the texture turn dark blue when they are mapped to the object.</p>
<p>
<img src="gl7_6.gif" border=0></p>
<p class=label>
<b>Figure 6. Texture mapping using the GL_MODULATE mapping mode</b></p>
<p>
If you use GL_MODULATE with dark textures, the mapped surface may end up black. For example, the REDBRICK.BMP bitmap I use for the face of the cube becomes black when it modulates the surface. To retain the color of a texture, I recommend that you use a white surface.</p>
<p>
The Decal and Modulate commands in the EasyTex Texture menu allow you to change the texture mapping mode.</p>
<h3>Specifying the Texture</h3>
<p>
Before OpenGL can texture-map a surface, it needs a texture to use. The OpenGL command for specifying the two-dimensional texture is <b>glTexImage2D</b>. The <b>glTexImage2D</b> parameters are very similar to <b>glDrawPixels</b> parameters, which are discussed in <a href="msdn_gl5.htm">"OpenGL V: Translating Windows DIBs."</a></p>
<p>
I added a new member function, <b>TexImage2D</b>, to <b>CGLImage</b> to encapsulate the call to <b>glTexImage2D</b>. The code for <b>CGLImage::TexImage2D</b> is listed below.</p>
<pre><code>void CGLImage::TexImage2D(CGL* pGL)
{
 &nbsp; ASSERT((m_iWidth != 0) &amp;&amp; (m_iHeight !=0)) ;
 &nbsp; ASSERT(m_pBits) ;

 &nbsp; // m_iWidth and m_iHeight must be power of 2.
 &nbsp; pGL-&gt;MakeCurrent() ;
 &nbsp; glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

 &nbsp; glTexImage2D( GL_TEXTURE_2D,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Detail level
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Components used for modulating 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and blending
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_iWidth, m_iHeight,&nbsp;&nbsp; // Width and height
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Border size
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_PixelFormat,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // GL_RGB or GL_RGBA
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GL_UNSIGNED_BYTE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Data type of pixel values
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pBits&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pixel values
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );&nbsp;&nbsp;&nbsp; 
 &nbsp; pGL-&gt;OutputGlError("CGLImage::TexImage2D") ;
}
</code></pre>
<p>
The first parameter to <b>glTexImage2D</b> is reserved for future use and must be GL_TEXTURE_2D. The final six parameters (width, height, border size, pixel format, data type, and pixel values) are the same as the <b>glDrawPixels</b> parameters we discussed in <a href="msdn_gl5.htm">"OpenGL V: Translating Windows DIBs."</a> This leaves two interesting parameters: the second (detail level) and third (components for modulating and blending). </p>
<h3>Multiple Levels of Detail</h3>
<p>
The second parameter to <b>glTexImage2D </b>sets the level of detail for the image. You can specify multiple images in different resolutions for the same texture—OpenGL will then use the smaller images to texture-map the smaller areas, and the bigger images to texture-map the larger areas. Using multiple levels of detail can prevent strange artifacts in moving shapes. </p>
<p>
Using multiple levels of detail makes sense. When you get closer to an object, the object gets bigger and you can see more detail. When you are farther away, the object is smaller and you see fewer details. If you select intelligently, using different resolution images for the texture can result in more realistic scenes and animation.</p>
<p>
For example, when you are far away from a stop sign, you see only a red circle. When you get closer, you see a red shape with some letters. Finally, you see the entire stop sign (Figure 7).</p>
<p>
<img src="gl7_7.gif" border=0></p>
<p class=label>
<b>Figure 7. Multiple levels of detail for a stop sign</b></p>
<p>
Instead of using different detail levels, what if OpenGL took the large bitmap and tried to squish it into the small bitmap? In the squishing process, the white letters and the black border would be combined with the red color, resulting in a small approximation of the original—a pink blob instead of a red, round stop sign. </p>
<p>
The OpenGL utility library includes the <b>gluBuild2DMipmaps</b> function, which builds all the detail levels when given the largest image. For more information on this function, see the Red Book.</p>
<p>
By the way, I didn't have time to add multiple levels of detail to EasyTex. The OpenGL screen savers don't use multiple-resolution textures either, because it takes too long to build them.</p>
<h3>Components for Modulating and Blending</h3>
<p>
The third parameter to <b>glTexImage2D </b>specifies how many of the R, G, B, and A components of each pixel in the texture make up a texel. If you specify a value of 1, a single component is used. PicCube and EasyTex specify a value of 3 for this parameter, so they use the entire RGB triple to make a texel. For more information on this parameter, see the "Modulating and Blending" section (p. 274) of the Red Book.</p>
<h2>Specifying Texture Coordinates</h2>
<p>
Not only must OpenGL know what texture to use, it must also know where to map the texture and how to orient the texture before mapping it. The OpenGL <b>glTexCoord</b> command specifies the mapping between texture coordinates and polygon vertexes. The coordinate passed to <b>glTexCoord </b>is associated with the vertex specified in the next <b>glVertex</b> call. An example is given below.</p>
<pre><code>&nbsp;&nbsp;&nbsp;glBegin(GL_QUADS);
 &nbsp;&nbsp;&nbsp;&nbsp; glNormal3d(-s,&nbsp; 0.0,&nbsp; 0.0);

 &nbsp;&nbsp;&nbsp;&nbsp; glTexCoord2d(0.0, 0.0);
 &nbsp;&nbsp;&nbsp;&nbsp; glVertex3d(-s, -s, -s);

 &nbsp;&nbsp;&nbsp;&nbsp; glTexCoord2d(1.0, 0.0);
 &nbsp;&nbsp;&nbsp;&nbsp; glVertex3d(-s, -s, s);

 &nbsp;&nbsp;&nbsp;&nbsp; glTexCoord2d(1.0, 1.0);
 &nbsp;&nbsp;&nbsp;&nbsp; glVertex3d(-s, s, s);

 &nbsp;&nbsp;&nbsp;&nbsp; glTexCoord2d(0.0, 1.0);
 &nbsp;&nbsp;&nbsp;&nbsp; glVertex3d(-s, s, -s);
 &nbsp; glEnd();
</code></pre>
<p>
Therefore, the texture coordinate (0, 0) is mapped to the object vertex (–s, –s, –s), as illustrated in Figure 8.</p>
<p>
<img src="gl7_8.gif" border=0></p>
<p class=label>
<b>Figure 8. Specifying texture coordinates</b></p>
<p>
If you pick your texture coordinates carefully, you can flip the texture, as shown in Figure 9. You can also flip the texture accidentally if you are not careful. My first version of PicCube flipped the image on three cube faces. I caught the error when I used a bitmap with text. </p>
<p>
<img src="gl7_9.gif" border=0></p>
<p class=label>
<b>Figure 9. Flipping a texture</b></p>
<h3>Repeating Textures</h3>
<p>
To make a square look like a brick wall, you can repeat the brick texture over the surface of the square. To repeat a texture, use texture coordinates greater than 1.0 (EasyTex and PicCube use 5.0).</p>
<pre><code>glBegin(GL_QUADS);
 &nbsp;&nbsp;&nbsp;&nbsp; glNormal3d(-s,&nbsp; 0.0,&nbsp; 0.0);

 &nbsp;&nbsp;&nbsp;&nbsp; glTexCoord2d(0.0, 0.0);
 &nbsp;&nbsp;&nbsp;&nbsp; glVertex3d(-s, -s, -s);

 &nbsp;&nbsp;&nbsp;&nbsp; glTexCoord2d(<b>5.0</b>, 0.0);
 &nbsp;&nbsp;&nbsp;&nbsp; glVertex3d(-s, -s, s);

 &nbsp;&nbsp;&nbsp;&nbsp; glTexCoord2d(<b>5.0</b>, <b>5.0</b>);
 &nbsp;&nbsp;&nbsp;&nbsp; glVertex3d(-s, s, s);

 &nbsp;&nbsp;&nbsp;&nbsp; glTexCoord2d(0.0, <b>5.0</b>);
 &nbsp;&nbsp;&nbsp;&nbsp; glVertex3d(-s, s, -s);
 &nbsp; glEnd();
</code></pre>
<p>
Figures 10 and 11 illustrate the effects of the two values (5.0 and 1.0).</p>
<p>
<img src="gl7_10.gif" border=0></p>
<p class=label>
<b>Figure 10. Specifying texture coordinates &gt; 1.0</b></p>
<p>
<img src="gl7_11.gif" border=0></p>
<p class=label>
<b>Figure 11. Specifying texture coordinates &lt; 1.0 (or = 1.0)</b></p>
<p>
To repeat textures, you must set the following two texture parameters, as we discussed previously:</p>
<pre><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
</code></pre>
<h2>Conclusion</h2>
<p>
Texture mapping is one of the best ways to make a 3-D scene appear more realistic. Adding textures for grass, trees, wood, marble, and other surfaces can make a scene come alive. OpenGL provides a powerful set of primitives that facilitates the process of texture-mapping simple objects. Texture-mapping complicated shapes can still be very difficult—at least more so than licking stamps and sticking them on a box.</p>
<h2>Bibliography</h2>
<h3>Sources of Information on OpenGL</h3>
<p>
Crain, Dennis. <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started."</a> April 1994. (MSDN Library, Technical Articles)</p>
<p>
Neider, Jackie, Tom Davis, and Mason Woo. <i>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1993. ISBN 0-201-63274-8. (This book is also known as the "Red Book".)</p>
<p>
OpenGL Architecture Review Board. <i>OpenGL Reference Manual: The Official Reference Document for OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1992. ISBN 0-201-63276-4. (This book is also known as the "Blue Book".)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: Introducing the OpenGL Interface, Part I." <i>Microsoft Systems Journal</i> 9 (October 1994). (MSDN Library Archive Edition, Library, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: The OpenGL Interface, Part II." <i>Microsoft Systems Journal</i> 9 (November 1994). (MSDN Library Archive Edition, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Understanding Modelview Transformations in OpenGL for Windows NT." <i>Microsoft Systems Journal</i> 10 (February 1995).</p>
<p>
Rogerson, Dale. <a href="msdn_gl1.htm">"OpenGL I: Quick Start."</a> December 1994. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode."</a> December 1994. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl3.htm">"OpenGL III: Building an OpenGL C++ Class."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl4.htm">"OpenGL IV: Color Index Mode."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl5.htm">"OpenGL V: Translating Windows DIBs."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl6.htm">"OpenGL VI: Rendering on DIBs with PFD_DRAW_TO_BITMAP."</a> April 1995. (MSDN Library, Technical Articles)</p>
<p>
Microsoft Win32 Software Development Kit (SDK) for Windows NT 3.5 <i>OpenGL Programmer's Reference</i>. </p>
<h3>Sources of Information on DIBs</h3>
<p>
Gery, Ron. <a href="msdn_dibs2.htm">"DIBs and Their Use."</a> March 1992. (MSDN Library, Technical Articles) </p>
<p>
Gery, Ron. <a href="msdn_dibpal.htm">"Using DIBs with Palettes."</a> March 1992. (MSDN Library, Technical Articles)</p>
<p>
Microsoft Win32 Software Development Kit (SDK) for Windows NT 3.5 <i>Video for Windows</i> </p>
<p>
Rodent, Herman. "16- and 32-Bit-Per-Pixel DIB Formats for Windows: The Color of Things to Come." January 1993. (MSDN Library Archive, Technical Articles)</p>
<p>
Thompson, Nigel. <i>Animation Techniques for Win32</i>. Redmond, WA: Microsoft Press, 1995.</p>
<p>
Thompson, Nigel. <a href="msdn_markpnt.htm">"Creating Programs Without a Standard Windows User Interface Using Visual C++ and MFC."</a> September 1994. (MSDN Library, Technical Articles)</p>
<p>
Thompson, Nigel. <a href="msdn_custctl.htm">"Simple Custom Controls for 32-Bit Visual C++ Applications."</a> November 1994. (MSDN Library, Technical Articles)</p>
</BODY>
</HTML>
