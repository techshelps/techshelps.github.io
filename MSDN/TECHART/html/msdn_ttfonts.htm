<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Linear and Nonlinear Scaling in Digital Typography</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_ttfonts"></a></sup>Linear and Nonlinear Scaling in Digital Typography</h1>
<p>
George Moore</p>
<p>
Created: April 20, 1992</p>
<h2>Abstract</h2>
<p>
This article outlines the problems inherent in the linear scaling of fonts and how existing digital typographies have tried to solve them. Against this background, the nonlinear scaling solution found in TrueType® in Microsoft® Windows™ version 3.1 has clear advantages.</p>
<h2>Introduction</h2>
<p>
Nonlinear scaling is one of the great typographic strengths of TrueType® in Microsoft® Windows™ version 3.1 that cannot be matched by other font-scaling solutions. This feature results in higher-quality text that is more legible on low-resolution devices like computer screens and 300-dpi laser printers. Nonlinear scaling is not some vague promise for the future—it is implemented today in the TrueType fonts we ship with Windows version 3.1.</p>
<h2>Round-Off Errors</h2>
<p>
To understand why nonlinear scaling is important, we have to look at one of the more fundamental problems that occurs in digital typography. As you may recall from the article "An Introduction to Digital Typography Using TrueType," all digital typographic systems store extremely high-resolution outlines in the font itself; those outlines are scaled to the proper size for the target device. The outlines are then "hinted" to adjust the outline to better fit the pixel grid on the screen or printer. The introductory article does not discuss round-off errors during the scaling process. Such errors can be a major problem. Let's say you have a lowercase letter <i>m</i> outline that you are attempting to make legible at a small size on a 96-dpi (VGA-resolution) PC screen. The outline was originally stored as a series of quadratic B-splines in the high-resolution Cartesian em square space of the font file. In the following crude illustration, the asterisks (*) are used to denote on-curve control points in the original theoretical outline. The numbers beside an asterisk are the coordinates of the individual control points in the high-resolution space.</p>
<p>
<img src="ttfonts_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Outline of Lowercase Letter <i>m</i></b></p>
<p>
The plus signs (+) denote the starting and stopping points for the character, which includes the glyph shape and the space around it. The gap from coordinate location (0,0) to (6,0) is known as the <i>left sidebearing</i>. Likewise, the gap from (246,0) to (252,0) is called the <i>right sidebearing</i>. These gaps keep the character from running into the other characters on the line of text. In this case, both sidebearings are defined as 6 units in the em square space. As you can also see, the entire character occupies 252 units in the horizontal direction (known as the <i>advance width</i>) and 200 units in the vertical direction. Finally, each vertical stem is exactly 36 units wide (42 – 6 = 36 and 144 – 108 = 36) with a gap of exactly 66 units between each vertical stem (108 – 42 = 66 and 210 – 144 = 66).</p>
<p>
Now, given these measurements, let's assume we have a scaling factor of 10 to 1, meaning that we have to scale the outline for a point size that is exactly one-tenth the size of the original outline. Therefore, the advance width (total character width) becomes 25.2 rather than 252. Likewise, the width of each stem becomes 3.6 rather than 36, and the gap between the stems becomes 6.6 rather than 66. This looks like an easy problem to solve because you just divide all the numbers by 10. But there's a danger in that. Physical display devices (screens and printers) cannot display anything smaller than a pixel, so you have to round all of the values to the nearest whole number. A pixel, by definition, is the smallest element that is used to display information. It's like a binary bit—it's either on or it's off. So the 3.6 pixel widths of the stems are rounded to 4 pixels and the 6.6 pixel widths of the gaps are rounded to 7 pixels. Likewise, each sidebearing of .6 pixels rounds up to 1 pixel.</p>
<p>
<img src="ttfonts_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Pixel Round-offs</b></p>
<p>
Now we've got a real problem. If you add up the high-resolution widths in this character (6 + 36 + 66 + 36 + 66 + 36 + 6), the correct width of the character is 252 pixels, which rounds to 25 pixels after you apply the 10:1 scaling factor. The character <i>should</i> be 25 pixels wide; however, the character <i>ends up</i> being 28 pixels wide because, if you add up the individual rounded values (1 + 4 + 7 + 4 + 7 + 4 + 1), you get 28. The character grew by 12 percent because of round-off errors.</p>
<p>
The 25-pixel answer is the linearly scaled value for that character. The 28-pixel answer is the nonlinearly scaled value for the character, sometimes called its "hinted" width because the hints are used to make the character wider at certain sizes. If you assume simple linear scaling, you have to somehow fit 28 pixels into a space reserved for 25 pixels. So what do you do with those extra 3 pixels? You could remove a pixel from the width of each stem, making each vertical stem only 3 pixels wide (instead of 4 as it should be according to nonlinear scaling). If each stem is 3 pixels wide, though, your letter <i>m</i> will not match the other letters in the same font at the same size. (The <i>i</i>, <i>t</i>, <i>j</i>, and others will still be 4 pixels wide because they don't have this rounding problem.) You could remove a pixel from the gap between each stem, making each gap only 6 pixels wide, but what do you do with the third pixel? You can't remove a single pixel from only one of the vertical stems because then they wouldn't match. You can't remove a pixel from one of the sidebearings because then the character would collide with the next one in the line. In short, you are stuck with a weird-looking, asymmetrical character if you try to base all of your calculations on the original width as stored in the high-resolution em square space of the font. </p>
<p>
But the problem is even worse than I just described. At very small point sizes on low-resolution displays, there are sometimes not enough pixels to represent the character with any fidelity. Because of cumulative round-off error in the scaling process, you might need 7 pixels to represent a letter <i>m</i> that has a linearly scaled width of only 6 pixels. What do you do? You have the choice of the following shapes.</p>
<p>
<img src="ttfonts_3.gif" border=0></p>
<p class=label>
<b>Figure 3.</b></p>
<p>
In Figure 3, there is a 1-pixel space for the left sidebearing, but no right sidebearing at all, meaning the letter would run into the next one to the right of it.</p>
<p>
<img src="ttfonts_4.gif" border=0></p>
<p class=label>
<b>Figure 4.</b></p>
<p>
Figure 4 shows that you could fix the problem in Figure 3 by deleting a single pixel from the center of the <i>m</i>, but now it is no longer recognizable as an <i>m</i>. In this case, you are trading legibility for correct spacing.</p>
<p>
And these two examples involve only sans-serif faces. Imagine trying to squeeze serifs in there also! But this problem is not limited to computer screens. In reality, any font that you are trying to represent on a monitor screen or on paper below approximately 60 ppem (pixels per em) can have this problem with certain characters. And if you do the math from the ppem formula in Step 2 of "An Introduction to Digital Typography Using TrueType," you will realize that 60 ppem corresponds to around 14 points at 300 dpi. This means it is impossible to produce high-quality text at sizes of 14 points and below at 300 dpi if you base all of your calculations on simple linear scaling. </p>
<p>
You'll notice that if you take this same letter <i>m</i> and try to render it on a reasonably high-resolution device, this rounding problem goes away. (To render high-quality text at sizes of 7 points and larger, you would need at least a 600-dpi printer; for text at sizes of 3.5 points and larger, you'd need at least a 1200-dpi printer.) If you have at least 252 pixels across, as in the example given above, there is absolutely no problem because the character will scale linearly. Now you've got two different devices (the screen and the printer), each with the same character at the same point size, and each reporting different widths. Both widths are right, but both are also wrong.</p>
<h2>Existing Digital Typography Systems</h2>
<p>
Under existing digital typography systems, such as the Intellifont format from AGFA (found in the HP® LaserJet® III printer and others) and the Type-1 format from Adobe (found in PostScript® printers), this problem of having two "correct" answers for the width of each character depending on its output device is an incredibly difficult engineering problem to solve. In fact, it's an impossible problem to solve. Remember, both of these systems were designed for printers. It took several years before Adobe Type Manager® (ATM) was made available for rendering type for the computer screen in Windows and on the Apple® Macintosh®. Because the font rasterizers originally existed only within the printer, there was no way to communicate the width of each character back to the host application. If you do the typographically correct thing and allow nonlinear scaling, the width of each character will depend upon both the point size you are trying to render <i>and</i> the resolution of your target device. The ideal width (that is, the nonlinearly scaled value) of a particular character may be one value at 5 points but an entirely different value at 6 points, yet another at 7 points, and so forth. And none of these may match the easily calculated linearly scaled values. If you allow nonlinear scaling, you cannot successfully predict the exact character widths until you actually try to render each character by applying the hints.</p>
<p>
Historically, applications running on a host computer system connected to stand-alone printers attempted to determine line breaks and page breaks based on the widths of those characters. The application can calculate these various widths only by assuming that all characters at all point sizes will scale linearly. For linear scaling, the host application needs a list of the high-resolution widths for each character. It can then do the simple integer math itself to figure out how wide a character will be at a certain size without having to communicate with the printer.</p>
<p>
These font-scaling solutions were later ported to Windows and the Macintosh. The primary output device for the Windows or Macintosh version of the rasterizer would be a computer monitor with a resolution of 96 dpi, a VGA-resolution screen. A large percentage of the time in these environments the text would be below 60 ppem (45 points at 96 dpi), so if you assume linear scaling, these characters would have to be wedged into a space smaller than they should normally fit. If those font-scaling programs allowed nonlinear scaling for the screen, they would break all existing applications and the millions of fonts already distributed. In the Windows and Macintosh environments, then, screen quality had to suffer because the quality of printed output, combined with backwards compatibility, was more important than good-looking screen fonts.</p>
<h2>TrueType and Nonlinearity</h2>
<p>
This scaling conflict between different output devices does not occur with TrueType because it was designed from the very beginning to reside within the operating system of the host computer, not the printer. This way it could produce high-quality text for both devices, without having either device suffer because of the limitations of the other.</p>
<p>
Most major applications care about providing WYSIWYG (what you see is what you get) line breaks and page breaks that appear the same on the screen as on the printer. When you start an application such as PageMaker®, Ami Pro™, Word for Windows, or WordPerfect® for Windows, one of the first things the application does is ask the operating system to provide a list of the widths of each character at the point size you are using. By building this list, the application can figure out how wide each word will be and, therefore, how wide each line will be. In Windows version 3.0 with the old-style bitmapped screen fonts, it was easy to calculate these line endings because the width information for each character was simply stored in the font itself, and no calculations were necessary. But with nonlinearly scaling outline fonts, determining line endings becomes a more complex problem.</p>
<p>
The only way to figure out how wide each character will be after pixel rounding is to execute the hints for each character, because you cannot anticipate what the hints will do to the outline. But even on a reasonably fast 80386-based machine, the executing of all the hints for all of the characters in the font can take almost one full second. This is an unacceptable delay for most people, who are used to dealing with applications that don't have graphical interfaces. For this reason, each TrueType font contains a table called the HDMX (Horizontal Device Metrics), with precomputed widths for each character at some of the more popular sizes. In the Microsoft-distributed TrueType fonts for Windows version 3.1, we store these precomputed values from 9 to 24 ppem and then for 15 other popular larger sizes. When the application asks Windows for the widths of each character at 13 ppem, Windows pulls these precomputed values out of the HDMX table as necessary. The HDMX table in each font is not large, so the trade-off between disk space and execution speed is an advantageous one. The HDMX table is built by font vendors when they compile the TrueType font for distribution.</p>
<p>
The addition of the HDMX table solves one problem, but it creates a new, smaller one. The font vendor includes only a limited number of ppem values in the HDMX table for the more popular sizes, but it's entirely possible that the font will scale nonlinearly outside the range of HDMX values. However, at a certain point the font will scale linearly because the resolution is high enough to provide the necessary pixels to faithfully reproduce the shape of the characters. When the font reaches linearity, the width calculations become easy. A "grey area," then, exists between the top of the HDMX table range and the bottom of the linear range. It would be unacceptable to take the time to execute the hints simply to find out the advance width for the sizes that aren't covered in the HDMX table. If an application asks for the widths of the characters at 75 ppem, they may be scaling linearly at that point, but the only way to be sure is to execute the hints. For this reason, we have defined another table in the font file called the LTSH (Linear Threshold) table. The LTSH table defines the point at which it is reasonable to assume linearly scaled advance widths on a character-by-character basis. Between the HDMX and the LTSH tables, the fonts appear on the screen fairly fast and with good typographic quality.</p>
<h2>Existing Applications and Nonlinearity</h2>
<p>
How do Windows or Macintosh applications cope with nonlinearly scaling fonts? How do they handle the fact that the scaled width of the letter <i>W</i> is different on the screen than on the printer? As it turns out, this is not a big problem. In Windows version 3.0, applications had to go to great lengths to make the widths of the old-style bitmapped screen fonts match the widths of the printer fonts. Applications would always calculate the widths for the printer and then try to make the screen display match. This was not as easy as it sounds because the character widths, as well as the character shapes, might be vastly different from the printer to the screen. For example, if the user selected the Avant Garde Gothic printer font, Windows might select the Helv screen font as the closest match—even though the two fonts share little in common. Applications used a number of tricks to accomplish this alignment feat. The most common algorithm used was to simply add or delete extra pixels between words so that the spacing of the characters within the words looked right, but the spacing between the words was off just a little. In this way, the line breaks would appear correct.</p>
<p>
When using TrueType fonts on the screen and printer, Windows can now match the shapes of the characters better than before. Applications continue to do exactly the same thing as in the past, except now there is much more typographically correct font information available for the screen. The extra 1 or 2 pixels taken up by the <i>W</i> are simply absorbed in the interword spacing. However, if the typographer hinting the font made all, or most, of the characters take up extra space on the line, the words might start to run together because there are only a finite number of pixels between each word. For this reason, when Monotype produced the base 13 TrueType fonts included in Microsoft Windows version 3.1, they looked carefully at the history of fonts.</p>
<p>
Monotype has been in business since 1897 and has almost 100 years of experience in designing and selling type—real type, the kind made of lead. Since Monotype had to make separate pieces of lead for each letter of the alphabet, they have created precise charts that give the distribution patterns of each letter of the alphabet. The letter <i>A</i>, for example, is used far more often than the letter <i>X</i>, so they would naturally make more <i>A</i>'s for any given font. As it turns out, about 70 percent of all documents are composed of only 13 characters: <i>a</i>, <i>c</i>, <i>d</i>, <i>e</i>, <i>h</i>, <i>i</i>, <i>l</i>, <i>n</i>, <i>o</i>, <i>r</i>, <i>s</i>, <i>t</i>, and <i>u</i>. Anyone who has watched "Wheel of Fortune" can verify this. So when Monotype hinted our base Windows fonts, they were very careful to make sure that none of those 13 characters exceeded the linearly scaled advance width. This makes it much easier for applications to produce correctly justified text. Happily, the characters that are most likely to exceed their linear values, such as <i>m</i> and <i>w</i>, are not in the above list. This 70 percent figure holds up across all Western and Eastern European languages. In reality, the distribution pattern for the uppercase letters is slightly different from the lowercase letters, but we decided to use the same rules for both so that lines in all uppercase letters will not break differently from the same lines in lowercase letters.</p>
<h2>The End Result</h2>
<p>
So what does this mean for the end user? This technology has one purpose: to produce the highest quality text, given the physical restrictions of the output device. Take, for example, the Arial® Bold <i>w</i> in TrueType format. Because the letter <i>w</i> tends to have more round-off errors than other letters, Monotype allowed its hinted advance width to exceed the linear width on several occasions.</p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Pixels per em</b></td>
<td class=label width=22%><b>Point size at 96 dpi</b></td>
<td class=label width=20%><b>Linear width</b></td>
<td class=label width=20%><b>Hinted width</b></td>
<td class=label width=18%><b>Difference</b></td>
</tr>
<tr valign=top>
<td width=20%>11</td>
<td width=22%>8</td>
<td width=20%>8.6</td>
<td width=20%>10</td>
<td width=18%>1</td>
</tr>
<tr valign=top>
<td width=20%>12</td>
<td width=22%>9</td>
<td width=20%>9.3</td>
<td width=20%>10</td>
<td width=18%>1</td>
</tr>
<tr valign=top>
<td width=20%>13</td>
<td width=22%>10</td>
<td width=20%>10.1</td>
<td width=20%>11</td>
<td width=18%>1</td>
</tr>
<tr valign=top>
<td width=20%>14</td>
<td width=22%>11</td>
<td width=20%>11.4</td>
<td width=20%>11</td>
<td width=18%>0</td>
</tr>
<tr valign=top>
<td width=20%>*15</td>
<td width=22%></td>
<td width=20%>(not used)</td>
<td width=20%></td>
<td width=18%></td>
</tr>
<tr valign=top>
<td width=20%>16</td>
<td width=22%>12</td>
<td width=20%>12.4</td>
<td width=20%>13</td>
<td width=18%>1</td>
</tr>
<tr valign=top>
<td width=20%>17</td>
<td width=22%>13</td>
<td width=20%>13.5</td>
<td width=20%>14</td>
<td width=18%>0</td>
</tr>
<tr valign=top>
<td width=20%>18</td>
<td width=22%>14</td>
<td width=20%>14.0</td>
<td width=20%>15</td>
<td width=18%>1</td>
</tr>
</table><br>
<p>
* If you do the math using the ppem formula mentioned earlier, you will notice that both the 14 and 15 ppem values round to 11 points at 96 dpi. Since you can have only one point size for any given ppem value, the 15 ppem value is not used and, hence, not shown on this chart.</p>
<p>
As you can see, for 8, 9, 10, 12, and 14 points at VGA resolution, Monotype allowed the Arial Bold <i>w</i> to be slightly wider than it should be for legibility purposes. </p>
<p>
If you have a copy of the ZOOMIN tool from the Microsoft Windows version 3.1 Software Development Kit (SDK), you can enlarge areas of the screen to see what pixel patterns are formed by the various letters in a particular font. For an example of the asymmetries caused by forcing a character to be linearly scaled, I have reproduced the pixel patterns formed by the letter <i>M</i> in Helvetica® (with ATM for Windows version 2.0) and Arial (with TrueType in Windows version 3.1) at the same point size on the same screen.</p>
<p>
<img src="ttfonts_5.gif" border=0></p>
<p class=label>
<b>Figure 5. ATM: Helvetica at 13 pixels/em (or 10 points on VGA)</b></p>
<p>
<img src="ttfonts_6.gif" border=0></p>
<p class=label>
<b>Figure 6. TrueType: Arial at 13 pixels/em (or 10 points on VGA)</b></p>
<p>
As you can see, when ATM forces the letter to be only 8 pixels wide, the <i>M</i> looks a little attenuated. TrueType allows the character to be 9 pixels wide; thus, it regains the symmetry of a reasonable-looking character. If you wish to see this for yourself, make sure you turn off Bitmap Substitution in ATM under Windows; otherwise, you'll get the old-style Helv bitmap.</p>
<p>
When you compare many letters (and spacing) at different point sizes, you'll notice that the base Monotype® TrueType fonts produce more legible, easy-to-read characters than ATM. Even if you leave Bitmap Substitution on under ATM, it doesn't help for those fonts for which no bitmaps are available. Windows does not distribute the bold or italic bitmapped versions of the Helv or Tms Rmn fonts, nor does bitmap substitution help in the case of fonts beyond the base 13 TrueType fonts included in Windows version 3.1.</p>
<p>
The TrueType format is capable of producing the best-looking digital fonts in the world at every resolution. I have used Monotype to show how this happens with the Windows version 3.1 base fonts. The caveat to keep in mind is that it's possible to create TrueType fonts that do not yield these results. Some third-party vendors may create fonts that employ hinting algorithms that distort characters under some circumstances. There can be bad-looking TrueType fonts, created by people who don't know any better, just as there are bad-looking Type-1 fonts created by people who don't know any better. (Type-1 fonts are used by Adobe PostScript printers and by Adobe Type Manager for Windows.) The big difference, however, is that TrueType fonts do not need to be distorted; it is possible to create scaling fonts in TrueType that are very close to hand-tuned bitmaps.</p>
</BODY>
</HTML>
