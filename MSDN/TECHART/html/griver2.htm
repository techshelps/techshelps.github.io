<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Developing Reusable Objects</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Developing Reusable Objects</h1>
<p>
Yair Alan Griver<br>
Flash Creative Management Inc.</p>
<h2>Abstract</h2>
<p>
Writing reusable code is one of the biggest opportunities for developers to increase productivity and quality for new and existing development efforts. This article will focus on how to write reusable objects in Microsoft® FoxPro® version 2.0, paying particular attention to the use of the power tools in the development process. We will cover the maintenance issues raised by FoxPro's environment handling commands, and discuss how the management and use of reusable code affects the development life cycle.</p>
<h2>Coding Issues</h2>
<p>
One of the keys to creating reusable objects is that they must not affect the procedure that is calling them. This leads to a few design decisions that must be made.</p>
<h3>Calling Your Code</h3>
<p>
Any variables from a higher-level procedure must be passed. Do not assume that what you need will be there. Remember, we are writing black-box objects. You pass information to them, and they return information <b>without affecting the calling procedure</b>.</p>
<p>
For instance, if you need a routine that squares a number for an application, you can code it specifically for the <b>current</b> application:</p>
<pre><code>lnSquareMe = 9
lnSquared = sqr()
FUNCTION sqr
RETURN lnSquareMe * lnSquareMe
</code></pre>
<p>
The above routine will work for the current application, but if you have to use it again in a future application, you'd better be sure to have a variable called lnSquareMe. It's much better to write the application this way:</p>
<pre><code>lnSquareMe = 9
lnSquared = sqr2(lnSquareMe)
FUNCTION sqr2
PARAMETER lnValue
RETURN lnValue * lnValue
</code></pre>
<p>
You now have a routine that will work in any application, for any value that is passed.</p>
<h3>The PRIVATE Trap</h3>
<p>
When writing reusable code, you must be sure that you don't affect the higher procedure. This means that you must be sure that any variables you use in the current procedure aren't used in a higher procedure. This can seem very difficult—you never know what may call this piece of code!</p>
<p>
The solution is to be very careful about naming every variable PRIVATE. This will hide any instance of the variable that may have been created in a higher procedure.</p>
<p class=indent>
<B><b>Note</b></B> &nbsp;&nbsp;&nbsp; I can't emphasize this one enough. Debugging an application that fails because a variable in a black box is changing a higher variable is one of the toughest things to do. Take the time to go back into the code for the object and <b>make sure that every variable is declared PRIVATE</b>.</p>
<h3>SETting Your Environment</h3>
<p>
Microsoft® FoxPro®'s environment handling commands are very powerful. However, with power comes responsibility. For instance, you can't assume that an application will always have EXACT set ON. If your reusable object requires that one of the SET or ON commands be set a certain way, do it yourself. When you do so, save the previous setting, and restore it on exit. For instance, if your routine requires that EXACT be ON for an ASCAN() on an array, do this:</p>
<pre><code>PROCEDURE LookArry
*-- This procedure takes 3 parameters:
*--&nbsp; laPassed = An array
*--&nbsp; lcFind&nbsp;&nbsp; = An expression to search for
*--&nbsp; lnCol&nbsp;&nbsp;&nbsp; = The column to return
*--
*-- Note:&nbsp; After this proc, you must test for EMPTY(value)
*--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to see if it was found.
PROCEDURE laPassed, lcFind, lnCol
PRIVATE lcOldExact, lnFound, lnRow, lcRetVal

lcOldExact = SET("EXACT")
lcRetVal = ""

lnFound = ASCAN(laPassed, lcFind)
IF lnFound # 0
  lnRow = ASUBSCRIPT(laPassed,lnFound,1)
  lcRetVal = laPassed[lnRow,lnCol]
ENDIF

SET EXACT &amp;lcOldExact
RETURN lcRetVal
</code></pre>
<h3>The Screen Builder and Reusable Code</h3>
<p>
The screen builder makes it much easier to develop more complex reusable objects than ever. You can focus on what the object should do, rather than how it looks.</p>
<p>
Here are a few rules to follow when writing a reusable screen:
<ul type=disc>
<li>
Put your PRIVATEs in the SETUP snippet.<br><br></li>
<li>
Save your SET and ON values in the SETUP snippet.<br><br></li>
<li>
Reset your SET and ON values in the CLEANUP snippet.<br><br></li>
<li>
Any RETURNed values have to go in the CLEANUP snippet.</li>
</ul>
<p>
We've found that screen design goes much more quickly if you design in the following manner:
<ol>
<li>
Draw your screen. Decide what it will look like before adding any code.<br><br></li>
<li>
Ask yourself what your user should see when the screen first appears. Whatever code has to run before the screen appears goes in your SETUP.<br><br></li>
<li>
Click on each screen object and decide what should happen when the user does so. Put that code in the VALID/WHEN snippets for the object.<br><br></li>
<li>
Decide what has to happen when the screen goes away. Put that in the CLEANUP snippet.<br><br></li>
<li>
Congratulate yourself on how easy it was to create the screen.</li>
</ol>
<h3>The Project Builder and Reusable Code</h3>
<p>
One of the key issues to remember when using reusable objects is that they may call other reusable objects. The project builder will automatically search for any referenced screens, procedures, and so on, and will include the items in the project for you. This makes the use of reusable objects much easier—you don't have to worry about forgetting a necessary object. Just call it—if you're using the project builder (and you <b>should be</b>), it will be there when you need it.</p>
<h3>Parameter Usage</h3>
<p>
Parameters in FoxPro provide a hidden boost in modifying and maintaining reusable code. FoxPro allows you to pass fewer parameters than are called for in the routine. The <b>PARAMETER()</b> function lets you test for the number of parameters actually passed. Using this ability, you can add new functions to existing objects <b>without changing their original purpose</b>.</p>
<p>
In other words, if you have been using the LOOKARRY() routine that is listed above, and suddenly need to be able to (occasionally) force it to <b>not</b> change the EXACT setting, you can simply add a fourth parameter, <i>llNoExact</i>. If it's .F., don't change a thing. If it's .T., ignore the SET EXACT line. The beauty of this is that by adding the fourth parameter, and making its default (.F.) the same as things were, you don't have to change any of the calling lines in all of the applications that used LOOKARRY().</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This is another maxim of writing reusable code. Don't break anything with your "enhancements."</p>
<h2>Data-Driven Reusable Objects</h2>
<p>
Data-driven reusable objects are more complex and more useful forms of reusable code. These typically perform a function that is used in multiple applications, but vary the data that they act upon based on information in .DBF files.</p>
<p>
For instance, you can store report information in a DBF, allowing you to create a generic reporting function that works in every application. Reporting is a common task in applications—only the reports themselves differ. Therefore, create a reusable reporting module, and have the information that changes (for example, the report names, filters, and so on) change by storing that separately.</p>
<h3>A Practical Example</h3>
<p>
Let's look a little more closely at another example of a data-driven portion of code. One typical case would be a routine that creates any DBFs that don't exist. In this manner, if the program is just being installed, or you forget to give your user a DBF, your routine can create it for you. It would be nice if we could write the code once, and simply fill a DBF for each application. This way, we don't have to worry about bugs creeping into our code.</p>
<p>
To create this routine, let's look at the data file that is needed:</p>
<pre><code>Structure for database: C:\BOOK\CD\DBFS\DATADICT.DBF
Number of data records:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17
Date of last update&nbsp;&nbsp; : 07/11/91
Memo file block size&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64
Field&nbsp;&nbsp;&nbsp;&nbsp; Field Name&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp; Width&nbsp;&nbsp;&nbsp;&nbsp; Dec&nbsp;&nbsp;&nbsp;&nbsp; Index
1&nbsp;&nbsp;&nbsp;&nbsp; FIELD_NAME&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Asc
2&nbsp;&nbsp;&nbsp;&nbsp; FIELD_TYPE&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Asc
3&nbsp;&nbsp;&nbsp;&nbsp; FIELD_LEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Numeric&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3
4&nbsp;&nbsp;&nbsp;&nbsp; FIELD_DEC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Numeric&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3
5&nbsp;&nbsp;&nbsp;&nbsp; DBF_NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Asc
** Total **&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 26
</code></pre>
<p>
The first four fields can be quickly created through the COPY STRUCTURE EXTENDED or AFIELDS commands. The fifth field contains the name of the DBF for the current FIELD_NAME. Note that with only these five fields, we can write a program that creates all of our DBFs on the fly if they don't exist:</p>
<pre><code>PROCEDURE CreaDBF
*--
*-- Routine to create any missing dbfs
PRIVATE lnArryCnt, lcDBF
SELECT DISTINCT datadict.dbf_name ;
  FROM datadict ;
  INTO ARRAY laDbfList

FOR lnArryCnt = 1 TO ALEN(laDbfList)
 &nbsp;&nbsp; lcDBF = laDbfList[lnArryCnt] - '.DBF'
  IF NOT FILE(lcDBF)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; DBF doesn't exist
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT * ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM Datadict ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE Datadict.dbf_name = laDBFList[lnArryCnt] ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTO ARRAY laFields
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CREATE TABLE laDBFList[lnArryCnt] ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM ARRAY laFields
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RELEASE laFields
  ENDIF
ENDFOR
</code></pre>
<p>
We can, of course, expand on this model, adding fields that store indexing information, and full field names. Using this additional information, we can create automatic re-indexing routines, a window that allows the user to change the active index on the fly, and a simple query builder that allows the user to select fields for a query. This shows the power of data-driven design and reusable objects: one DATADICT.DBF could be created, automatically enabling all four of the above functions.</p>
<p class=indent>
<B><b>Hint</b></B>&nbsp;&nbsp;&nbsp;When creating reusable objects that use data-driven design techniques, assign a default action to the object. In other words, write it so that it will work even without the data file. Even if it simply exits with a WAIT WINDOW "No data file found", at least it will not crash if called when you are originally prototyping an application.</p>
<h2>Managing Reusable Code</h2>
<p>
Committing yourself or your company to utilizing reusable code requires a commitment to "managing that code." Having a reusable reporting engine is not very useful if only <i>you</i> know about it. You need a way to disseminate information about these procedures to others in your group or company. It is also useful to have a set location for this reusable code.</p>
<h3>A Directory Structure</h3>
<p>
We set up a COMMON directory on our network. Underneath that directory are a number of other directories: SCREENS, MENUS, REPORTS, and so on. This lets us compartmentalize the location of our reusable code. We can back it up quickly and easily. We have also mapped one of our network drives to this COMMON directory, allowing us to access it quickly when necessary.</p>
<h3>An Object Manager</h3>
<p>
An object manager is a focal point for your reusable code tracking. It can be as simple as a DBF that contains the name of the object, what it does, some key words for searches, calling conventions, and return value. It should also contain a field that tracks the changes to the object over time.</p>
<p>
Here again, putting some structures in place can ease development. Using the COMMON directory structure described above, you can easily write a routine that automatically moves information into the object manager. If you standardize a commenting convention for the header, your routine can even fill in most of the information for you.</p>
<h2>Summary</h2>
<p>
Writing reusable code affects the entire development organization. It increases productivity and decreases maintenance efforts. Using the techniques outlined above will help you show a marked gain in the quality and quantity of applications your organization can develop.</p>
</BODY>
</HTML>
