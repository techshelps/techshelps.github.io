<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Moving Unix Applications to Windows NT</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_unix2nt"></a>Moving Unix Applications to Windows NT</h1>
<p>
<i>Do you have suggestions on how to make this paper better? Please send them to brianmo@microsoft.com.</i></p>
<p>
Preliminary draft:&nbsp; March 6, 1994 (0.9)</p>
<p>
Copyright 1993, 1994 Microsoft Corporation. All rights reserved. The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.<br>
This document is for informational purposes only. Microsoft makes no warranties, express or implied, in this document<b>.</b></p>
<h2>Abstract</h2>
<p>
This paper is provided for the Unix® developer who is interested in learning about some of the aspects of moving Unix source code to the Microsoft® Windows NT™ operating system. Moving Unix applications to Windows NT is not only a process of potentially changing source code, but it's also one of learning about the tools, resources, information sources, and so forth. that have grown around the Windows™ and Windows NT phenomena.</p>
<p>
"Unix" is a set of diverse, varied operating systems, with a rich cultural history. Many UNIphiles become so immersed in the Unix culture that they are not aware of other existing operating system cultures, nor do they tolerate "heretics" who dare suggest that there is innovation occurring outside of the Unix sphere. Similar cultures, though not as old, exist around Macintosh®, IBM® PCs, and perhaps strongest of all, Amiga. What is particularly interesting about discussions in which culture clashes do occur is that in general those people that are familiar with the operating system concepts in high-end (compared to PC) operating systems like Unix are the best positioned for exploiting the full power of Windows NT.</p>
<p>
Putting religion aside for the duration of this discussion, this paper will focus on two main areas: a comparison of programmatic constructs and usages in the Unix environment (mainly centered around system services, deftly ignoring the specific issues of graphical programming), and how to best exploit Windows NT for those features, as well as the programming and information sources that developers for Windows and Windows NT find useful.</p>
<h2>Overview of Windows NT</h2>
<p>
An overview of the features and functionality of Microsoft® Windows NT™ may be in order, both from the architectural as well as the lexical standpoint. Often in the comparison of Windows NT and Unix®, nearly identical concepts have dissimilar names!</p>
<p>
Windows NT is a preemptive, multitasking, multi-user, portable (how many adjectives can be crammed in?) operating system designed around a modern micro-kernel architecture. The initial goals for Windows NT are:
<ul type=disc>
<li>
A 32-bit operating system incorporating proven advanced OS concepts<br><br></li>
<li>
Compatibility with existing applications for MS-DOS® and Windows™ operating systems, with ability to support POSIX, OS/2® and other programming interfaces<br><br></li>
<li>
Portability to multiple computer architectures<br><br></li>
<li>
The core technology for future Microsoft operating systems<br><br></li>
<li>
Flexibility to adapt to incredible diversity now and in the future<br><br></li>
<li>
Capability of supplying high-end computing resources<br><br></li>
<li>
Designed to meet C2 and higher security levels<br><br></li>
<li>
Exploitive of multiprocessing hardware for scalability<br><br></li>
<li>
Provide support for multilingual applications built into the operating system through use of Unicode™<br><br></li>
<li>
Built-in networking for use in heterogenous environments with support for popular protocols (TCP/IP, IPX/SPX, NetBEUI, SNA connectivity, and so forth.)</li>
</ul>
<p>
Some of the operating system facilities in the first Windows NT product will be very familiar to a typical Unix developer, including:
<ul type=disc>
<li>
Multi-User programming model<br><br></li>
<li>
Process/Thread programming model with 32 priority levels<br><br></li>
<li>
RPC facilities (DCE-compliant connection-oriented RPC-IDL compiler, and so forth)<br><br></li>
<li>
Sockets TCP/IP programming interface (Windows Sockets interface)<br><br></li>
<li>
File systems with long file names, case preserving, 64-bit file pointers<br><br></li>
<li>
Flat 32-bit memory space<br><br></li>
<li>
Support for virtual/heap memory usage<br><br></li>
<li>
Rich process synchronization and IPC facilities<br><br></li>
<li>
Non-blocking (asynchronous) I/O model</li>
</ul>
<p>
Windows NT is able to host multiple programming interfaces, <i>as well as support the semantics of those interfaces</i>, through the use of subsystems layered on top of the Windows NT executive. In the first release, Windows NT provides a 32-bit Windows subsystem, a POSIX subsystem, and an OS/2 character mode subsystem. The subsystems are responsible for supplying both the APIs (system calls) as well as the state required for that particular environment.</p>
<p>
Application vendors need only be concerned (for the most part) with the services and semantics of the subsystem for which they are programming. In Windows NT, due to the overwhelming acceptance of Windows by both the development community, the 40 million (as of November 1994) installed base, and the more than 1 million new users of Windows each month, the Win32 programming interface (Win32 is the name given to the set of 32-bit system calls that supports the semantics of Windows) is the most fully featured. This means that innovations and extensions will be seen in this programming interface first, and that programming tools will emphasize this interface. Of the 80,000 copies of the Windows NT software kit that have been purchased, nearly all of those are being used to develop applications for Windows using the Win32 interface.</p>
<p>
(For an excellent treatment of the architecture of Windows NT in general, and the Windows NT executive in specific, please refer to the book <i>Inside Windows NT</i> by Helen Custer)</p>
<h2>Windows 3.1 Programming</h2>
<p>
There are large numbers of very good texts, programming examples, magazine articles, and on-line information messages that provide an excellent introduction to Windows-based programming in general. Most information on Windows NT is written with the experience of the Windows developer in mind. It behooves any Unix developer interested in working with the Win32 API to take advantage of these resources.</p>
<p>
Concepts that would likely be unfamiliar to a Unix developer include Windows message loops, interapplication communication using dynamic data exchange (DDE), the richness of the clipboard interface, object linking and embedding (OLE), Windows resources, and window function callbacks.</p>
<p>
For these reasons, the books listed in Appendix B are highly recommended reading for someone unfamiliar with programming for Windows.</p>
<h2>Character Applications on Windows NT</h2>
<p>
In addition to a graphical user interface, Windows NT supports a rich set of character-oriented APIs (see the glossary for a definition of API and other terms) that enable and encourage character-oriented applications. Sometimes it's just not necessary or cost-effective to provide a graphical user interface for an application (although the latest development tools are turning this into an incremental effort). In these cases, regular "stdio" calls can be used for terminal (Windows NT parlance is "console") I/O. </p>
<p>
Due to the relative standardization among C run-time libraries (usually encompassing section 2 and section 3 system calls in the Unix programmer's manual), in many cases character applications that don't have dependencies on Unix-specific facilities (for example, termio) can be moved with a simple recompile—most "section 2" system calls have equivalents in the C run-time libraries provided with your C or C++ compiler for Windows NT. We'll discuss some of the changes that might be required to additional code under the general discussion of porting issues.</p>
<p>
For developers who rely on "curses" functionality, there has recently been posted to CompuServe® (MSWIN32 Forum) and the Internet (ftp.microsoft.com) a subroutine library that provides this functionality, based on the Win32 console API functions.</p>
<p>
Support for "dumb terminals" is something that has been demonstrated by third parties such as PanData (see the Resources section). The Microsoft view is that computers are going to continue to become more and more powerful, at lower and lower costs. It will be more effective from the cost and ease-of-use standpoints to use a computer running an application for Windows or Windows NT, communicating via RPC to an application server, than a similarly priced, less functional terminal. </p>
<h2>Graphical Applications on Windows NT</h2>
<p>
Windows NT supports the GDI (Graphics Device Interface) and model for graphical programming. This portion of the Win32 API, which includes graphical object management as well as window management, was first popularized by the hordes of Windows 3.x developers. In the next release of Windows NT (currently code-named <i>Daytona;</i> due in the first half of 1994), OpenGL 3-D graphics are also added to the Windows NT APIs.</p>
<p>
The Win32 GDI interface is different from Xlib, Xt, Motif, and any other programmatic interface for graphics (the bad news). The good news is that developers moving to Windows NT from Unix have noted that GDI provides a superset of X windows functionality, and that there are a wealth of tools for creating Microsoft Windows interfaces. For Unix source code that has been written with portability (to other UNIXs) in mind, such GUI tools can be used to develop all of the user interface (with little regard for learning the intricacies of Windows-based programming), and the non-graphical code can be plugged in. This code quilting process has been quite successful for a number of previously Unix-only developers. Many commercial Unix developers have come to view Windows NT as another port, albeit their highest-volume one. </p>
<p>
For those who are looking for a stepping-stone approach to moving code quickly, sources to an "Xlib" (ntxlib.zip), which resolves to calls to the Win32 API, have been uploaded to CompuServe (MSWIN32 forum) and placed in the archives on ftp.uu.net (directory: vendor/microsoft/winnt-progs/xlib/ntxlib.zip). For in-house applications, this is often satisfactory; however, Windows users of commercial software using this method of porting will likely be disappointed in the user interface differences and lack of support for required Windows functionality such as the Clipboard and DDE.</p>
<p>
Some software developers are using third-party tools (from vendors like XVT, Zinc, and others) to maintain a single set of source code for multiple Unix environments, as well as Windows NT. Most software vendors who expect to be successful with a commercial product for Windows NT are employing native Win32 calls for window and graphical operations; again, this is to take advantage of functionality unique to Windows and Windows NT operating systems, yet required by customer expectations—object linking and embedding (OLE), for example.</p>
<p>
Of course, it's also possible to use an X server (to date, DEC®, Hummingbird, NCD, and others have demonstrated this functionality on Windows NT) to provide a graphical front end to an X client running on a network server—however, a typical user of Windows may be less than satisfied with differing semantics for manipulating the interface, and lack of interoperability (in most implementations) for such features as Clipboard, OLE, and so forth.</p>
<p>
For those who must, there are X client libraries supported on Windows NT from companies such as Congruent, DEC, Hummingbird, and others. Again, these applications are NOT Windows NT applications, and require the use of an X server "terminal application" on the Windows NT desktop. </p>
<p>
Many traditional Unix software vendors are moving their primary development to Windows NT, and "back porting" to Unix using Windows API layers such as those provided by Bristol Technologies, Mainsoft, or others. This enables them to exploit many of the Windows NT interapplication communication mechanisms, and add those features to Unix versions of their product if/when the underlying version of Unix gains the capability.</p>
<h2>General Porting Issues</h2>
<p>
The Win32 API evolved from the Win16 API of Windows 3.x on MS-DOS®. The Win32 programming interface provides all of the functionality available for applications programming on Windows NT. In fact, the C (and other language) run-time libraries provided with compiler products for Windows NT eventually call the Win32 API. Consequently, there are many instances where the C run-time library call is subordinated by the function of a Win32 API—file I/O for example. The C run-time function <code>fopen()</code> eventually calls the Win32 <code>CreateFile()</code> interface.</p>
<p>
For a developer, this means that "standard" C code will in general compile and run on Windows NT. However to utilize the full functionality provided by Windows NT (for example, for file mapping), or to implement functionality not provided for in the C run-time libraries, the specific Win32 calls should be used.</p>
<p>
Always check the C run-time reference for your compiler first, to see if the system calls used in your application are supported. Your job may be easier than you think.</p>
<p>
For most people moving code to Windows NT, the initial step is to get their application "barely" working, and then add Win32 enhancements. Changes will likely need to be made in makefiles, and some <code>#include</code> statements will probably have to be changed.</p>
<p>
In the following sections we'll discuss the difference between the "Unix way" and the "Win32 way" of doing things as they might affect code being moved to Windows NT. Anecdotal information collected from a broad range of Unix software vendors who have moved their applications to Windows NT shows that those applications that are easiest to move are designed with "proper" coding methodologies in mind—separation of program flow into logical modules, isolation of dependencies on particular operating systems, flavors, or versions of operating systems, separation of graphical code and "business" code, and so on.</p>
<p>
It may be most helpful to start out learning about the architecture of Windows NT from books such as <i>Inside Windows NT</i>, by Helen Custer. From this point forward, it is assumed that the reader has Unix programming experience, as well as the rudiments of Windows and Windows NT understanding.</p>
<h2>The Windows NT Process Model</h2>
<p>
The Windows NT process model differs from that of Unix in a number of aspects, including process groups, terminal groups, <code>setuid</code>, memory layout, and so forth. For some programs, such as shells, a redesign of certain portions of the code is inevitable. Fortunately, most applications don't inherently rely on the specific semantics of Unix processes, since even this differs between Unix versions.</p>
<p>
Quoting from the on-line help provided with the Windows NT SDK:</p>
<p class=indent>
<i>Win32 exposes processes and threads of execution within a process as objects. Functions exist to create, manipulate, and delete these objects.</i></p>
<p class=indent>
<i>A process object represents a virtual address space, a security profile, a set of threads that execute in the address space of the process, and a set of resources or objects visible to all threads executing in the process. A thread object is the agent that executes program code (and has its own stack and machine state). Each thread is associated with a process object which specifies the virtual address space mapping for the thread. Several thread objects can be associated with a single process object which enables the concurrent execution of multiple threads in a single address space (possible simultaneous execution in a multiprocessor system running Windows NT). On multiprocessor systems running Windows NT, multiple threads may execute at the same time but on different processors. </i></p>
<p class=indent>
<i>In order to support the process structure of Windows NT, APIs include: </i>
<ul type=disc>
<li>
<i>Support for process and thread creation and manipulation.</i><br><br></li>
<li>
<i>Support for synchronization between threads within a process and synchronization objects that can be shared by multiple processes to allow synchronization between threads whose processes have access to the synchronization objects. </i><br><br></li>
<li>
<i>A uniform sharing mechanism that provides security features that limit/control the sharing of objects between processes. </i></li>
</ul>
<p>
Windows NT provides the ability to create new processes (<code>CreateProcess()</code>) and threads (<code>CreateThread()</code>). Rather than "inherit" everything always, as is done in Unix with the <code>fork()</code> call, <code>CreateProcess()</code> accepts explicit arguments that control aspects of process creation such as file handle inheritance, security attributes, debugging of the child process, environment, default directory, and so on. It is through the explicit creation of a thread or process with appropriate security descriptors that credentials are granted to the created entity. </p>
<p>
Win32 does not provide the capability to "clone" a running process (and its associated in-memory contents). This is not such a hardship, since most Unix code <code>fork()</code>s and then immediately calls <code>exec()</code>. Applications that depend on the cloning semantics of <code>fork()</code> may have to be redesigned a bit to use threads (especially where large amounts of data sharing between parent and child occurs), or in some cases, to use IPC mechanisms to copy the relevant data between two distinct processes after the <code>CreateProcess()</code> call is executed.</p>
<p>
If a child process is to inherit the handles of the creator process, the <code>bInherit</code> flag of the <code>CreateProcess()</code> call can be set. In this case, the child's handle table is filled in with handles valid in the context of the child process. If this flag is not specified, handles must be given away by using the <code>DuplicateHandle()</code>call.</p>
<p>
Windows NT was not designed to support "dumb terminals" as a primary emphasis, so the concept of terminal process groups and associated semantics are not implemented. Applications making assumptions about groups of applications (for example, killing the parent process kills all child processes), will have to investigate the <code>GenerateConsoleCtrlEvent()</code> API, which provides a mechanism to signal groups of applications controlled by a parent process using the <code>CREATE_NEW_PROCESS_GROUP</code> flag in the <code>CreateProcess()</code> API. The on-line documentation (API32WH.HLP) provides the gory details under the Console API functions overview.</p>
<p>
Programs making assumptions about the layout of processes in memory (for example, Gnu EMACS, which executes, then "dumps" the image of variables in memory to disk, which is subsequently "overlaid" on startup to reduce initialization time), especially the relationship of code segments to data and stack, will likely require modification. Generally, practices such as these are used to get around some operating system limitation or restriction. At this level, a rethinking of the structure of that part of the application is generally in order, to examine supported alternatives to the "hack" that was used (perhaps memory mapped files for particular cases like this). For those who must deal with an application's pages on this level, there is a mechanism by which a process may be opened (<code>OpenProcess()</code>), and individual memory pages, threads, and stacks examined or modified.</p>
<p>
There is no direct equivalent of the Unix <code>setuid()</code>. There are, however, a number of Windows NT alternatives to use depending on the task to be accomplished. If the task at hand is a daemon that runs with a fixed user context, it would be best to use a Windows NT service (again, the on-line help is invaluable for this information). A Windows NT service is equivalent to a "daemon" running with fixed user credentials, with the added benefit of being locally or remotely administrated through standard Windows NT administration facilities. For instances when a process must "impersonate" a particular user, it's suggested that a server program be written that communicates through a named pipe to the client application. When a connection to the named pipe occurs, the <code>ImpersonateNamedPipeClient()</code> API can be used to assume the security context of the calling client (validated by the underlying Windows NT network authentication), to perform the required operation in the client's context.</p>
<p>
In Windows NT, processes and threads are referred to by their handles as well as their unique numerical IDs. Windows NT is a multithreading operating system; consequently, the concept of a "unit of execution" is dissociated from the "context of execution". Multiple units of execution (threads) can exist simultaneously in the overall process context, and each thread also has its own stack and thread local storage. A rich set of functions is provided to manipulate both processes and threads. The <code>CreateProcess()</code> API provides the ability to start a process with the thread of execution suspended. <code>CreateProcess()</code> returns a structure containing a handle to both the created process and the suspended thread (as well as other information).</p>
<p>
Unlike Unix, Windows NT only returns a status for child processes that have exited if a handle is open to that thread and process. There is no such thing as a zombie process in Windows NT—if all handles to that process and thread are closed, the process does not return any information, and no information is kept by the OS upon termination. If a child's exit code is required, the handle returned by <code>CreateProcess()</code> can be waited on for the exit code. The following example creates a process, waits for the return status, does nothing with it, and terminates:</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#define MAXNAMELEN&nbsp;&nbsp;&nbsp; 255
#define CMDLINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "/c dir"
#define IMAGENAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\\nt\\bin\\cmd.exe"
#define WINTITLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CreateProcess DEMO"

main(){
BOOL&nbsp;&nbsp;&nbsp; fSuccess,fExit;
DWORD&nbsp;&nbsp;&nbsp; dwExitCode,dw;
STARTUPINFO&nbsp;&nbsp;&nbsp; SI;
PROCESS_INFORMATION&nbsp;&nbsp;&nbsp; pi;
HANDLE&nbsp;&nbsp;&nbsp;&nbsp; hProcess,hThread;
SI.cb =sizeof(STARTUPINFO); SI.lpReserved = NULL;SI.lpDesktop=NULL;
SI.lpTitle="CreateProcess DEMO";SI.cbReserved2=0;SI.lpReserved2=NULL;
fSuccess = CreateProcess((LPTSTR)IMAGENAME, (LPTSTR)CMDLINE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSECURITY_ATTRIBUTES)NULL, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSECURITY_ATTRIBUTES)NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (BOOL)TRUE,(DWORD)0,NULL,NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTARTUPINFO)&amp;SI,(LPPROCESS_INFORMATION)&amp;pi); 
if (fSuccess) {&nbsp; 
 &nbsp;&nbsp; hProcess = pi.hProcess;&nbsp;&nbsp;&nbsp; hThread = pi.hThread;
 &nbsp;&nbsp; printf("Process Id = %d\nThread Id = %d\n",pi.dwProcessId,pi.dwThreadId);
 &nbsp;&nbsp; dw = WaitForSingleObject(hProcess, INFINITE) ;
 &nbsp;&nbsp; if (dw != 0xFFFFFFFF) { /* if we saw success ... */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* pick up an exit code for the process */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fExit = GetExitCodeProcess(hProcess, &amp;dwExitCode) ;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; /* close the process and thread object handles */
 &nbsp;&nbsp; CloseHandle(hThread) ;&nbsp;&nbsp;&nbsp; CloseHandle(hProcess) ;
 &nbsp;&nbsp; printf("COMPLETED!\n");
}
else&nbsp;&nbsp;&nbsp; printf("Failed to CreateProcess\n"); }
</code></pre>
<p>
Various other interfaces are provided to examine and change aspects of both the process and thread. The <code>OpenProcess()</code> API could be used in combination with the debugging APIs <code>ReadProcessMemory()</code> and <code>WriteProcessMemory()</code> to examine/set memory segments (given appropriate security permission), and <code>Get/SetThreadContext()</code> could be used to manipulate the thread program characteristics (such as program counter and other information).</p>
<p>
To kill the executing process, <code>ExitProcess()</code> can be used. For graphical applications this should be a method of "last resort," however, since most Windows-based applications will respond to a <code>WM_QUERYENDSESSION</code> Windows message and exit more gracefully. This is usually preferable, since the <code>WM_QUERYENDSESSION</code> message processing usually involves giving application users an opportunity to save their information. </p>
<h2>Priority Classes</h2>
<p>
Windows NT provides a very flexible priority hierarchy, with four priority classes (of five levels each) to use when <code>CreateProcess()</code> or <code>SetPriorityClass()</code> APIs are used: <code>IDLE</code>, <code>NORMAL</code>, <code>HIGH PRIORITY</code>, and <code>REALTIME</code>. Within each class, plus or minus 2 priority levels are possible through the <code>SetThreadPriority()</code> API. With responsible use of priority classes and selective boosting of individual thread priorities, it's possible to perform soft real-time processing with Windows NT. In cases such as these, a +2 REALTIME priority thread will be waiting to be signaled, at which time it will accomplish its task and wait again. If a high-priority thread runs too long, it can affect the performance of the system (such as mouse movement, disk cache flushes, and so on). For this reason, the highest priority levels are restricted to processes executing in the Administrator security context.</p>
<p>
For a discussion of priority classes and their effect on the system, please refer to the "Process and Threads Overview" section, "Scheduling priorities" topic in the on-line help in the Windows NT SDK.</p>
<h2>Signals</h2>
<p>
The C run-time libraries provided with the Windows NT SDK provide support for the following signals: <code>SIGFPE</code>, <code>SIGILL</code>, <code>SIGSEGV</code>, <code>SIGINT</code>, <code>SIGBREAK</code>, <code>SIGABRT</code>, and <code>SIGTERM</code>. Additionally, <code>SIGABRT</code> and <code>SIGTERM</code> can be signaled by <code>raise()</code>. Signals generated or <code>raise()</code>d by a thread are always handled by that thread—signals can't be used for interthread or interprocess communication.</p>
<p>
Typical use of signals in Unix applications occurs where nonblocking I/O occurs, and the application is signaled upon completion. Here's some typical Unix code for doing nonblocking file I/O:</p>
<pre><code>{ ... }
set_fl(STDOUT_FILENO, O_NONBLOCK);&nbsp;&nbsp; /* set stdout to do nonblocking file i/o */
bytes_written = write(STDOUT_FILENO, buffptr, numbytes);
{ ... maybe do some other stuff here ... }
/* turn off non-blocking file i/o */
clr_fl(STDOUT_FILENO,O_NONBLOCK);
{ ... }
</code></pre>
<p>
In Windows NT, the preferred method of handling I/O completion or time-out is through an <code>OVERLAPPED</code> I/O structure, provided as a parameter to the <code>ReadFile()</code> or <code>WriteFile()</code> call. Usually an <b>event object</b> is created, which is used to indicate the status of the pending I/O. An example of event creation, usage in a file operation, and waiting on the completion of the I/O is provided in this code fragment (extracted from PDC.C in the samples provided with the Windows NT SDK). Note that this fragment actually consists of only eight calls; however, the formatting for expository purposes makes it verbose:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoCompletedEvent = CreateEvent( NULL,&nbsp;&nbsp; // Not inherited
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE,&nbsp;&nbsp; // Manual reset
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE,&nbsp; // Initially reset
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; // No name
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
/* do other setup required */
 do_setup_routine();
/*&nbsp; */
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Open the file using the fully qualified path. Specify the
 &nbsp;&nbsp; // sequential scan hint to the cache manager and if asynchronous
 &nbsp;&nbsp; // I/O will be used, specify the overlapped flag as well.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; File = CreateFile( Path,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GENERIC_READ,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE_SHARE_READ,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN_EXISTING,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE_FLAG_SEQUENTIAL_SCAN |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ASyncIO ? FILE_FLAG_OVERLAPPED : 0),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Since NULL might be a valid file object handle, failure
 &nbsp;&nbsp; // is indicated by a special return value.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (File == INVALID_HANDLE_VALUE) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, "%s(0) : error %u: Unable to open file.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Path,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetLastError()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // We use an alertable wait in a loop, as I/O completion
 &nbsp;&nbsp;&nbsp; // will terminate the wait, even through the event we
 &nbsp;&nbsp;&nbsp; // are waiting on is not signalled.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Using asynchronous I/O, so queue the read operation. The file 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle must remain open while the read operation is pending.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!ReadFileEx( File,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileData,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileSize,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;SearchRequest-&gt;OverlappedIO,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPOVERLAPPED_COMPLETION_ROUTINE) <b>ProcessReadFileCompletion</b>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, "%s(0) : error %u: Unable to queue read of file.\n,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Path,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetLastError();
 &nbsp;&nbsp; /* other cleanup goes here */
 &nbsp;&nbsp;&nbsp;&nbsp; .... 
 &nbsp;&nbsp; }
/*&nbsp;&nbsp;&nbsp; Now do something else, eventually dropping into :

*/
 &nbsp;&nbsp; /* Other stuff occurs here */ { }
 &nbsp;&nbsp; /* NOTE that the ReadFileEx is scheduled, and will */
 &nbsp;&nbsp; /* likely execute during this subsequent wait operation! */
 &nbsp;&nbsp;&nbsp; while (WaitForSingleObjectEx( IoCompletedEvent,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xFFFFFFFF,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) == WAIT_IO_COMPLETION
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
</code></pre>
<p>
This example shows how a completion routine can be used to process data that is read asynchronously. The source for the data could be a disk file, pipe, communications port, and so forth.</p>
<p>
Note that the asynchronous I/O operation is scheduled as a deferred procedure call, and is not executed until the scheduling process Waits or Sleeps. </p>
<p>
In other instances of signal use, Structured Exception Handling can generally be used instead of signals.</p>
<p>
Some Unix applications use signals for interprocess communication (for example, <code>SIGUSR2</code>). With Windows NT, a signal is only raised on the thread that caused it, so signals cannot be used for IPC. Code that attempts to do this should use another IPC mechanism such as events or semaphores.</p>
<h2>File I/O</h2>
<p>
A typical Unix application will use standard C run-time library calls for file I/O (that is, <code>fopen()</code>, <code>fread()</code>, <code>fwrite()</code>, <code>fprint()</code>, <code>fclose()</code>). For operations on files and most devices, these will work just fine. For character Windows NT applications, these calls can also be used for access to console input and output. Low level I/O (for example, <code>creat()</code>, <code>read()</code>, <code>write()</code>), although usable, should be avoided. Additionally, when using the Win32 API it is a bad idea to make assumptions regarding the file descriptor ordinals of <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>.</p>
<p>
To take advantage of 64-bit file access, asynchronous (overlapped) I/O, signaling of I/O completion, and so on, the Win32 APIs of <code>CreateFile()</code>, <code>ReadFile()</code>, and <code>WriteFile()</code> must be used. Note that the file handles used between these "levels" of I/O functionality are not interchangeable—don't try to use ReadFile to read information from an "<code>fopen()</code>-ed" file.</p>
<p>
For concurrent access to a single file (either over the network, or on the same machine), to ensure exclusive access to certain records in a file, use the <code>LockFile()</code> API when using Windows NT file handles, and the <code>locking()</code> API when using the C run-time libraries.</p>
<p>
Windows NT file systems may not be based on an "i-node" representation. The meaning of certain <code>st</code> structure members returned by the <code>stat()</code> call (for example, <code>st.ino</code>), although provided for compatibility, is meaningless. In general, it will always return zero. Code that uses the i-node number to test for file linking won't work as anticipated. You may wish instead to use the Win32 <code>GetFileInformationByHandle() </code>API<code>,</code> which returns a structure containing a 64-bit quantity guaranteed unique and constant for an open file on a given volume. Please refer to the API reference for more information on this call.</p>
<p>
Since Windows NT can accommodate multiple file systems, with different file name characteristics, you may need to check whether the underlying file system can support the type of file names that your application expects. Windows NT ships with support for FAT file systems, HPFS file systems, NTFS file systems, network file systems, and CD-ROM file systems. See the discussion of File Systems for more information.</p>
<h2>Binary vs. Text File I/O Using the C Run-Time Libraries</h2>
<p>
The C run-time libraries that are provided with the Windows NT SDK are derived from the Windows 3.1 C run-time libraries. As such, they differ from typical Unix C run times, since there is a distinction between text and binary file I/O. (Note that this is true for the <code>fopen()</code>, <code>fclose()</code>, and other functions, and NOT the Windows NT <code>CreateFile()</code>, <code>ReadFile()</code>, and <code>WriteFile() </code>functions.)</p>
<p>
When a file is <code>fopen</code>ed using the "r" mode attribute, the C run-time libraries default to assume that text-mode file I/O is to be used. In text mode, CR-LF pairs denote end-of-line, and control-Z denotes end-of-file. A line read will silently ignore CR-LF, positioning the file pointer at the subsequent non-EOL character. On <code>printf()</code>s, all "\n"s will be translated to CR-LF.</p>
<p>
To read with files in untranslated (binary) mode, the file mode "<code>rb</code>" should be used in the <code>fopen()</code> call. The analog for writing files is the "<code>wb</code>" file mode.</p>
<h2>File Systems</h2>
<p>
A file system means many things to Windows NT. Network redirectors, file system drivers using magnetic media or optical media, object stores, and so on, all provide "file system" characteristics to Windows NT. Windows NT was designed to be able to work with these many different models, while providing a consistent access mechanism (<code>CreateFile()</code>, <code>ReadFile()</code>, <code>WriteFile()</code>). Windows NT also exposes the notion of "volumes," originating from "drives" as found in the more than one hundred million copies of MS-DOS in use.</p>
<p>
Before an application generates a filename to be used on a given volume, <code>GetVolumeInformation()</code> should be used to determine the characteristics of the file system that influence the name—the maximum length of the filename, whether case is preserved, case is sensitive, or is Unicode-enabled. <code>GetVolumeInformation()</code> works on any file system that can be described by the root directory name, including network file systems, and special layered file systems. </p>
<p>
In general, names for Windows NT should follow the following conventions (from the on-line Win32 API help file in the Windows NT software development kit):</p>
<p class=indent>
<i>Filename Conventions</i></p>
<p class=indent>
<i>Although each file system can have specific rules about the formation of individual components in a directory or filename, all file systems follow the same general conventions for combining components. For example, the FAT file system requires file and directory names to have the 8.3-character filename format; the HPFS file system allows names to be up to 254 characters; and the NTFS file system allows names to be up to 255 characters. All three file systems use the backslash (\) character to separate directory names and the filename when forming a path. </i></p>
<p class=indent>
<i>General rules for applications creating names for directories and files or processing names supplied by the user include the following: </i>
<ul type=disc>
<li>
<i>Use any character in the current code page for a name, but do not use a path separator, a character in the range 0 through 31, or any character explicitly disallowed by the file system. A name can contain characters in the extended character set (128-255). </i><br><br></li>
<li>
<i>Use the backslash (\), the forward slash (/), or both to separate components in a path. No other character is acceptable as a path separator. </i><br><br></li>
<li>
<i>Use a period (.) as a directory component in a path to represent the current directory. </i><br><br></li>
<li>
<i>Use two consecutive periods (..) as a directory component in a path to represent the parent of the current directory. </i><br><br></li>
<li>
<i>Use a period (.) to separate components in a directory name or filename. </i><br><br></li>
<li>
<i>Do not use the following characters in directory names or filenames, because they are reserved for Windows:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; &gt; : " / \ | </i><br><br></li>
<li>
<i>Do not use reserved words, such as aux, con, and prn, as filenames or directory names. </i><br><br></li>
<li>
<i>Process a path as a null-terminated string. The maximum length for a path is given by MAX_PATH. </i><br><br></li>
<li>
<i>Do not assume case sensitivity. Consider names such as OSCAR, Oscar, and oscar to be the same. </i></li>
</ul>
<p class=indent>
<i>By following the rules listed in this section, an application can create valid names for files and directories regardless of the file system in use. </i></p>
<h2>Terminal Handling</h2>
<p>
As discussed previously, Windows NT does not provide dumb terminal support. It is a relatively simple process to move character applications to Windows NT using the Console functions provided by Win32 (see the on-line help or SDK manuals for more information), since functionality to support character deletion, insertion, cursor movement, and others, is provided.</p>
<p>
A good mechanism for moving character applications to Windows NT would be to create a "virtual terminal" environment using Windows functions to paint text, scroll, position characters, and so on, in a graphical window. This solution would provide limited, although better, integration of Windows features such as Clipboard cut and paste, and would provide a solid foundation for addition of other Windows NT features that users have come to expect. </p>
<h2>Security</h2>
<p>
The Windows NT security model is very different from that of Unix. Designed to be initially certifiable at the C2 level, and in subsequent releases eventually able to support B level security, security is pervasive throughout all aspects of the system. At the kernel level, security attributes, in the form of access control lists (ACLs), are kept on kernel objects. Threads and processes have Security IDs (SIDs) associated with them, which are validated against object ACLs. </p>
<p>
This type of model does not translate directly to the User/Group/Permission model of Unix, and code that handles Unix security will likely need to be modified for Windows NT security. </p>
<p>
The most common operations involve checking access to files, and changing the context of the executing process. The former functionality is provided by <code>AccessCheck()</code> APIs (for files, processes, threads, events, mutexes, semaphores, and so on), the latter provided by Impersonation.</p>
<p>
A example of a service (provided in the appendix) illustrates the concept of impersonation. <code>Service.c</code> accepts a connection from a named pipe, assumes the user's context, gets some information, writes the information back to the named pipe, and reverts to the service's own security level.</p>
<p>
For more information on security in Windows NT, please refer to the on-line Win32 API reference, or the documentation accompanying the Win32 SDK.</p>
<h2>Memory Management</h2>
<p>
Windows NT provides a flat 32-bit address space, half of which is reserved for the OS, and half available to the process. This provides a separate 2 gigabytes of demand paged virtual memory per process. This memory is accessible to the software developer through the usual <code>malloc()</code> and <code>free()</code> memory allocation and deallocation routines, as well as some advanced Windows NT–specific mechanisms.</p>
<p>
For a programmer desiring greater functionality for memory control, Windows NT also provides Virtual and Heap memory management APIs.</p>
<p>
The advantage of using the virtual memory programming interface (<code>VirtualAlloc()</code>, <code>VirtualLock()</code>,<code> VirtualQuery()</code>, and others) is that the developer has much more control over whether backing store (memory committed in the paging [swap] file to handle physical memory overcommitment) is explicitly marked, and removed from the available pool of free blocks. With <code>malloc()</code>, every call is assumed to require the memory to be available upon return from the function call to be used. With <code>VirtualAlloc()</code> and related functions, the memory is reserved, but not committed, until the page on which an access occurs is touched. By allowing the application to control the commitment policy through access, fewer system resources are used. The tradeoff is that the application must also be able to handle the condition (presumably with structured exception handling) of an actual memory access forcing commitment; examples are provided in the SDK to illustrate this situation.</p>
<p>
Heap APIs are provided to make life easier for applications that make use of memory using stack discipline. Multiple heaps can be initialized, each growing/shrinking with subsequent accesses. Synchronization of access to allocated heaps can be done either explicitly through Windows NT synchronization objects, or by using an appropriate parameter at the creation of a heap, all access to memory in that particular heap is synchronized between threads in the process.</p>
<p>
Memory mapped files are also provided in Windows NT. This provides a convenient way to access disk data as memory, with the Windows NT kernel managing paging. This memory may be shared between processes by using <code>CreateFileMapping()</code> followed by <code>MapViewOfFile()</code>.</p>
<p>
Windows NT provides thread local storage (TLS) to accommodate the needs of multithreaded applications. Each thread of a subprocess has its own stack, and may have its own memory to store various information. For more information on TLS, please refer to the <i>Windows NT Programming Reference.</i></p>
<h2>Threading</h2>
<p>
Windows NT is the first operating system to provide a consistent multithreading API across multiple platforms. A thread is a unit of execution in a process context that shares global memory state with other threads in that context (if any). When a process is created in Windows NT, memory is allocated for it, state is set up in the system, and a thread object is created. To start an additional thread in a currently executing process, the <code>CreateThread()</code>call is used with a pointer to executable code passed as one of the parameters. </p>
<p>
Windows NT supports a number of different types of multiprocessing hardware. On these designs, it's possible for different processors to be running different threads of an application simultaneously. Care must be taken in using threads in an application to synchronize access to common resources between threads. Fortunately, Windows NT has very rich synchronization facilities.</p>
<p>
Most Unix developers don't use threads in their applications, since support is not consistent between Unix platforms. For more information on thread usage, please refer to the Windows NT SDK documentation.</p>
<h2>Handles</h2>
<p>
Handles don't have a direct mapping from Unix, however they're very important to Win32-based applications, and deserve discussion. When kernel objects (that is, threads, processes, files, semaphores, mutexes, events, pipes, mailslots, and communications devices) are created or opened using the Win32 API, a <code>HANDLE</code> is returned. This handle is a 32-bit quantity that is an index into a handle table specific to that process. Handles have associated ACLs, or Access Control Lists, that Windows NT uses to check against the security credentials of the process. Handles can be obtained by explicitly creating them (usually when an object is created), as the result of an open operation (for example, <code>OpenEvent()</code>) on a named object in the system, inherited as the result of a <code>CreateProcess()</code> operation (a child process inherits an open handle from its parent process if inheritance was specified when the original handle was created and if the child process was created with the "inherit handles" flag set), or "given away" by <code>DuplicateHandle()</code>. It is important to note that unless one of these mechanisms is used, a handle will be meaningless in the context of a process.</p>
<p>
For example, suppose process 1 calls <code>CreateEvent()</code> to return a handle that happens to have the ordinal value 0x1FFE. This event will be used to coordinate an operation between different processes. Process 2 must somehow get a handle to the event that process 1 created. If process 1 somehow "conjures" that the right value to use is 0x1FFE, it still will not have access to the event created by process 1, since that handle value means nothing in the context of process 2. If, instead, process 1 calls <code>DuplicateHandle()</code>with the handle of process 2 (acquired through calling <code>OpenProcess()</code> with the integral ID of process 2), a handle that can be used by process 2 is created. This handle value can be communicated back to process 1 through some IPC mechanism.</p>
<p>
Handles that are used for synchronization (semaphores, mutexes, events) as well as those that may be involved in asynchronous I/O (named pipes, files, communications) may be used with <code>WaitForObject()</code> and <code>WaitForMultipleObject()</code>, which are functionally similar to the <code>select()</code> call in Unix.</p>
<h2>Networking—IPC</h2>
<p>
For those familiar with Unix networking, which is primarily TCP/IP-based, Windows NT provides a "Berkeley-flavored" socket interface through the Windows Sockets API. Windows Socket handles can be used as Windows NT file handles can be in the <code>ReadFile()</code> and <code>WriteFile()</code> functions, as well as inherited by child threads/processes (see preceding paragraphs). Windows NT socket handles are also waitable. All port numbers are available for use by application programs—there are no restrictions on range. The details of the Windows sockets interface are detailed in the specification available from <code>ftp.microdyne.com</code>, or <code>vax.ftp.com</code>. The Windows sockets API is also included in the form of an on-line help file (see subsequent section on on-line help) in the Windows NT SDK.</p>
<p>
The file sharing protocol built into Windows NT is based on SMB (Server Message Block). NFS file systems are supplied by third parties, such as Sun, NetManage, and FTP Software. A public domain NFS server (SOSSNTR*.ZIP) exists on many well-known Internet sites (try ftp.cica.indiana.edu).</p>
<p>
Other types of IPC include named pipes (LAN Manager and MS-DOS–based applications use these), NetBIOS, Windows sockets for IPX/SPX (Novell networking), and mailslots. Windows NT provides connection-oriented DCE RPC, which can be used with other DCE-compatible RPC clients and servers.</p>
<h2>Development Roadmap</h2>
<p>
The Windows NT Software Development Kit (SDK) includes all of the libraries, include files, sample source code, help files, and tools to develop 32-bit applications for Windows NT and Windows 3.1.</p>
<p>
The Windows NT Device Driver Kit (DDK) contains everything necessary to write device drivers for Windows NT, including sample source code for most of the drivers in the prerelease. The SDK is a prerequisite for the DDK.</p>
<p>
Languages available for Windows NT from Microsoft include C, C++, and FORTRAN; other companies provide these languages and more.</p>
<p>
Most Unix developers are accustomed to a rich set of "Unix tools" (for example, awk, sed, lex, grep, and so on). Fortunately, many of the initial developers moved tools to Windows NT, and in many cases made these tools available in source form on various well-known Internet sites. Commercial vendors (for example, Congruent, MKS, Hamilton) have filled the void with tools, shells, and libraries that are available now. Please see the appendix on resources.</p>
<h2>WinHelp as a Resource</h2>
<p>
The Windows NT SDK provides a number of useful resources for the developer, one of which is on-line help (WinHelp). To access this facility, start the WinHelp application through one of the "question mark" icons, or launch "winhlp32" from the Program Manager. WinHelp files (generally located in the \mstools\bin directory) exist in the SDK for topics such as the Win32 programming interface (API32WH.HLP), Microsoft C run-time library (MSC.HLP), as well as for some of the other programming tools such as the Dialog Editor (dlgedit.hlp), and Resource Compiler (rc.hlp). Since many of the help files include sample source code and helpful hints, you should consult these frequently. Winhelp provides the ability to search by keywords, do hypertext jumping to related topics, print the viewed information, or even paste text and code samples to the Clipboard.</p>
<p>
<img src="unix2nt_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Typical Windows help screen</b></p>
<h2>Appendix A. Service Sample Source Code</h2>
<p>
This appendix contains code from the Windows NT Software Development kit for a simple service. In Windows NT, a service is the equivalent of a Unix Daemon. This code illustrates:
<ul type=disc>
<li>
The mechanism for writing a service<br><br></li>
<li>
An example makefile that you should use as a pattern for your own makefiles<br><br></li>
<li>
Named pipe programming<br><br></li>
<li>
Character application for Windows NT</li>
</ul>
<h3>The Makefile</h3>
<p>
When moving code from Unix to Windows NT, you'll need to modify your makefiles to include the following line:</p>
<pre><code>!include &lt;ntwin32.mak&gt;
</code></pre>
<p>
This line sets up the processor variables, library files, and so on. It cannot be stressed enough that you should use the sample makefiles as templates for your code moving from Unix. Here is the makefile in its entirety:</p>
<pre><code>.
# Nmake macros for building Windows 32-Bit apps
!include &lt;ntwin32.mak&gt;
all: simple.exe instsrv.exe client.exe
# Update the object file if necessary
.c.obj:
 &nbsp;&nbsp; $(cc) $(cdebug) $(cflags) $(cvarsmt) $*.c
simple.exe: simple.obj
 &nbsp;&nbsp; $(link) $(linkdebug) $(conflags) -out:simple.exe simple.obj
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(conlibsmt) advapi32.lib
instsrv.exe: instsrv.obj
 &nbsp;&nbsp; $(link) $(linkdebug) $(conflags) -out:instsrv.exe instsrv.obj
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(conlibsmt) advapi32.lib
client.exe: client.obj
 &nbsp;&nbsp; $(link) $(linkdebug) $(conflags) -out:client.exe client.obj
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(conlibsmt)
</code></pre>
<p>
Note that the $(conflags) variables take care of most of the declarations you'll need to make for a console application.</p>
<h3>Service Sample Source Code—README.TXT</h3>
<p>
The following is the README.TXT file from the Simple Service example. Please note that to install the service, you must be logged on as Administrator on your Windows NT machine.</p>
<p>
Sample: Simple Service</p>
<p>
Summary:</p>
<p>
The Simple Service sample demonstrates how to create and install a service.</p>
<p>
In this particular case, the service merely opens a named pipe of the name \\.\pipe\simple, and waits for traffic. If it receives anything, it surrounds the input with:</p>
<p class=indent>
Hello! [&lt;input goes here&gt;]</p>
<p>
and sends it back down the pipe to the client.</p>
<p>
The service can be Started, Stopped, Paused, and Continued.</p>
<p>
To install the service, first compile everything, and then user INSTSRV to install SimpleService as follows:</p>
<pre><code>&nbsp;instsrv SimpleService &lt;location of simple.exe&gt;
</code></pre>
<p>
Now all you have to do is start it, either using the "net start" method or via the control panel Services applet.</p>
<p>
Once the service has been started, you can use the CLIENT program to verify that it really is working, using the syntax:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;client \\.\pipe\simple Hello
</code></pre>
<p>
which should return the response:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;Hello! [Hello]
</code></pre>
<p>
If, after playing with the sample you wish to remove the service, simple say:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;instsrv SimpleService remove
</code></pre>
<p>
Note that INSTSRV can be a little dangerous—it'll install and remove any service you tell it to, so be careful.</p>
<p>
Additional reference words:</p>
<p>
CloseServiceHandle, InitializeSecurityDescriptor, SetSecurityDescriptorDacl, SetServiceStatus, OpenSCManager, StartServiceCtrlDispatcher, RegisterEventSource, DeregisterEventSource, RegisterServiceCtrlHandler</p>
<h3>Service Sample Source Code—SERVICE.C</h3>
<pre><code>/******************************************************************************\
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is a part of the Microsoft Source Code Samples.
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1993 Microsoft Corporation.
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All rights reserved.
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This source code is only intended as a supplement to
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Microsoft Development Tools and/or WinHelp documentation.
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See these sources for detailed information regarding the
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Microsoft samples programs.
\******************************************************************************/
///////////////////////////////////////////////////////
//
//&nbsp; Service.c --
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main program for Service sample.
//
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This service simply opens a named pipe
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (called \\.\pipe\simple), and reads from it.
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It then mangles the data passed in and writes
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the result back out to the pipe.
//
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The simple service will respond to the basic
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service controller functions, i.e. Start, Stop, and Pause.
//
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;process.h&gt;
// this event is signaled when the worker thread ends
HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hServDoneEvent = NULL;
SERVICE_STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssStatus;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // current status of the service
SERVICE_STATUS_HANDLE&nbsp;&nbsp; sshStatusHandle;
DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwGlobalErr;
DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TID = 0;
HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; threadHandle = NULL;
HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pipeHandle;

//&nbsp; declare the service threads:
//
VOID&nbsp;&nbsp;&nbsp; service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID&nbsp;&nbsp;&nbsp; service_ctrl(DWORD dwCtrlCode);
BOOL&nbsp;&nbsp;&nbsp; ReportStatusToSCMgr(DWORD dwCurrentState,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwWin32ExitCode,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwCheckPoint,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwWaitHint);
VOID&nbsp;&nbsp;&nbsp; StopSampleService(LPTSTR lpszMsg);
VOID&nbsp;&nbsp;&nbsp; die(char *reason);
VOID&nbsp;&nbsp;&nbsp; worker_thread(VOID *notUsed);
VOID&nbsp;&nbsp;&nbsp; StopSimpleService(LPTSTR lpszMsg);

//&nbsp; main() --
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All main does is call StartServiceCtrlDispatcher
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to register the main service thread. When the
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; API returns, the service has stopped, so exit.
//
VOID
main()
{
 &nbsp;&nbsp; SERVICE_TABLE_ENTRY dispatchTable[] = {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { TEXT("SimpleService"), (LPSERVICE_MAIN_FUNCTION)service_main },
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { NULL, NULL }
 &nbsp;&nbsp; };
 &nbsp;&nbsp; if (!StartServiceCtrlDispatcher(dispatchTable)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StopSimpleService("StartServiceCtrlDispatcher failed.");
 &nbsp;&nbsp; }
}

//&nbsp; service_main() --
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This function takes care of actually starting the service,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; informing the service controller at each step along the way.
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; After launching the worker thread, it waits on the event
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that the worker thread will signal at its termination.
//
VOID
service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwWait;
 &nbsp;&nbsp; PSECURITY_DESCRIPTOR&nbsp;&nbsp;&nbsp; pSD;
 &nbsp;&nbsp; SECURITY_ATTRIBUTES&nbsp;&nbsp;&nbsp;&nbsp; sa;
 &nbsp;&nbsp; // register our service control handler:
 &nbsp;&nbsp; //
 &nbsp;&nbsp; sshStatusHandle = RegisterServiceCtrlHandler(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT("SimpleService"),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_ctrl);
 &nbsp;&nbsp; if (!sshStatusHandle)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp; // SERVICE_STATUS members that don't change in example
 &nbsp;&nbsp; //
 &nbsp;&nbsp; ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
 &nbsp;&nbsp; ssStatus.dwServiceSpecificExitCode = 0;

 &nbsp;&nbsp; // Report the status to Service Control Manager.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (!ReportStatusToSCMgr(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE_START_PENDING, // service state
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NO_ERROR,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exit code
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // checkpoint
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3000))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wait hint
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp; // Create the event object. The control handler function signals
 &nbsp;&nbsp; // this event when it receives the "stop" control code.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; hServDoneEvent = CreateEvent(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp; // no security attributes
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE,&nbsp;&nbsp;&nbsp; // manual reset event
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE,&nbsp;&nbsp; // not-signalled
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);&nbsp;&nbsp; // no name
 &nbsp;&nbsp; if (hServDoneEvent == (HANDLE)NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp; // Report the status to the service control manager.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (!ReportStatusToSCMgr(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE_START_PENDING, // service state
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NO_ERROR,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exit code
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // checkpoint
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3000))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wait hint
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp; // Create a security descriptor that allows anyone to write to the pipe...
 &nbsp;&nbsp; //
 &nbsp;&nbsp; pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECURITY_DESCRIPTOR_MIN_LENGTH);
 &nbsp;&nbsp; if (pSD == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StopSimpleService("LocalAlloc pSD failed");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StopSimpleService("InitializeSecurityDescriptor failed");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalFree((HLOCAL)pSD);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; // Add a NULL disc. ACL to the security descriptor.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StopSimpleService("SetSecurityDescriptorDacl failed");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalFree((HLOCAL)pSD);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; sa.nLength = sizeof(sa);
 &nbsp;&nbsp; sa.lpSecurityDescriptor = pSD;
 &nbsp;&nbsp; sa.bInheritHandle = TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // why not...
 &nbsp;&nbsp; // Open our named pipe...
 &nbsp;&nbsp; //
 &nbsp;&nbsp; pipeHandle = CreateNamedPipe(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\\\\.\\pipe\\simple",&nbsp; // name of pipe
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PIPE_ACCESS_DUPLEX,&nbsp;&nbsp;&nbsp;&nbsp; // pipe open mode
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PIPE_TYPE_MESSAGE |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PIPE_READMODE_MESSAGE |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PIPE_WAIT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pipe IO type
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number of instances
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // size of outbuf (0 == allocate as necessary)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // size of inbuf
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1000,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // default time-out value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;sa);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // security attributes
 &nbsp;&nbsp; if (!pipeHandle) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StopSimpleService("CreateNamedPipe");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalFree((HLOCAL)pSD);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; // Start the thread that performs the work of the service.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; threadHandle = (HANDLE)_beginthread(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worker_thread,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // stack size
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // argument to thread
 &nbsp;&nbsp; if (!threadHandle)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp; // Report the status to the service control manager.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (!ReportStatusToSCMgr(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE_RUNNING, // service state
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NO_ERROR,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exit code
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // checkpoint
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wait hint
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp; // Wait indefinitely until hServDoneEvent is signaled.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; dwWait = WaitForSingleObject(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hServDoneEvent,&nbsp; // event object
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INFINITE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wait indefinitely
cleanup:
 &nbsp;&nbsp; if (hServDoneEvent != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle(hServDoneEvent);

 &nbsp;&nbsp; // Try to report the stopped status to the service control manager.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (sshStatusHandle != 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (VOID)ReportStatusToSCMgr(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE_STOPPED,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwGlobalErr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);
 &nbsp;&nbsp; // When SERVICE MAIN FUNCTION returns in a single service
 &nbsp;&nbsp; // process, the StartServiceCtrlDispatcher function in
 &nbsp;&nbsp; // the main thread returns, terminating the process.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; return;
}

//&nbsp; service_ctrl() --
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This function is called by the Service Controller whenever
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; someone calls ControlService in reference to our service.
//
VOID
service_ctrl(DWORD dwCtrlCode)
{
 &nbsp;&nbsp; DWORD&nbsp; dwState = SERVICE_RUNNING;
 &nbsp;&nbsp; // Handle the requested control code.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; switch(dwCtrlCode) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pause the service if it is running.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case SERVICE_CONTROL_PAUSE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ssStatus.dwCurrentState == SERVICE_RUNNING) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SuspendThread(threadHandle);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwState = SERVICE_PAUSED;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Resume the paused service.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case SERVICE_CONTROL_CONTINUE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ssStatus.dwCurrentState == SERVICE_PAUSED) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResumeThread(threadHandle);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwState = SERVICE_RUNNING;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Stop the service.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case SERVICE_CONTROL_STOP:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwState = SERVICE_STOP_PENDING;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Report the status, specifying the checkpoint and waithint,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; before setting the termination event.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReportStatusToSCMgr(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE_STOP_PENDING, // current state
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NO_ERROR,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exit code
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // checkpoint
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3000);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // waithint
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetEvent(hServDoneEvent);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Update the service status.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case SERVICE_CONTROL_INTERROGATE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // invalid control code
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; // Send a status response.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; ReportStatusToSCMgr(dwState, NO_ERROR, 0, 0);
}

//&nbsp; worker_thread() --
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This function does the actual nuts and bolts work that
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the service requires. It will also Pause or Stop when
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asked by the service_ctrl function.
//
VOID
worker_thread(VOID *notUsed)
{
 &nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inbuf[80];
 &nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outbuf[80];
 &nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret;
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bytesRead;
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bytesWritten;
 &nbsp;&nbsp; // Okay, our pipe has been creating, let's enter the simple
 &nbsp;&nbsp; //&nbsp; processing loop...
 &nbsp;&nbsp; //
 &nbsp;&nbsp; while (1) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Wait for a connection...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConnectNamedPipe(pipeHandle, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Grab whatever's coming through the pipe...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = ReadFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pipeHandle,&nbsp;&nbsp;&nbsp;&nbsp; // file to read from
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inbuf,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // address of input buffer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(inbuf),&nbsp; // number of bytes to read
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;bytesRead,&nbsp;&nbsp;&nbsp;&nbsp; // number of bytes read
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overlapped stuff, not needed
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!ret)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pipe's broken... go back and reconnect
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Assume the security credentials of the connected client
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImpersonateNamedPipeClient(pipeHandle);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Now we're using the security credentials of the attached client. 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // this is a good place to do some processing, but we're not going to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do much at all:

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // munge the string
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(outbuf, "Hello! [%s]", inbuf);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Now we'll revert back to the security context of the service;
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RevertToSelf();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // send it back out...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = WriteFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pipeHandle,&nbsp;&nbsp;&nbsp;&nbsp; // file to write to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outbuf,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // address of output buffer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(outbuf), // number of bytes to write
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;bytesWritten,&nbsp; // number of bytes written
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overlapped stuff, not needed
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!ret)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pipe's broken... go back and reconnect
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Drop the connection...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisconnectNamedPipe(pipeHandle);
 &nbsp;&nbsp; }
}

// utility functions...

// ReportStatusToSCMgr() --
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This function is called by the ServMainFunc() and
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ServCtrlHandler() functions to update the service's status
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to the service control manager.
//
BOOL
ReportStatusToSCMgr(DWORD dwCurrentState,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwWin32ExitCode,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwCheckPoint,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwWaitHint)
{
 &nbsp;&nbsp; BOOL fResult;
 &nbsp;&nbsp; // Disable control requests until the service is started.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (dwCurrentState == SERVICE_START_PENDING)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssStatus.dwControlsAccepted = 0;
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE_ACCEPT_PAUSE_CONTINUE;
 &nbsp;&nbsp; // These SERVICE_STATUS members are set from parameters.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; ssStatus.dwCurrentState = dwCurrentState;
 &nbsp;&nbsp; ssStatus.dwWin32ExitCode = dwWin32ExitCode;
 &nbsp;&nbsp; ssStatus.dwCheckPoint = dwCheckPoint;
 &nbsp;&nbsp; ssStatus.dwWaitHint = dwWaitHint;
 &nbsp;&nbsp; // Report the status of the service to the service control manager.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; if (!(fResult = SetServiceStatus(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sshStatusHandle,&nbsp;&nbsp;&nbsp; // service reference handle
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;ssStatus))) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SERVICE_STATUS structure
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If an error occurs, stop the service.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StopSimpleService("SetServiceStatus");
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return fResult;
}

// The StopSimpleService function can be used by any thread to report an
//&nbsp; error, or stop the service.
//
VOID
StopSimpleService(LPTSTR lpszMsg)
{
 &nbsp;&nbsp; CHAR&nbsp;&nbsp;&nbsp; chMsg[256];
 &nbsp;&nbsp; HANDLE&nbsp; hEventSource;
 &nbsp;&nbsp; LPTSTR&nbsp; lpszStrings[2];
 &nbsp;&nbsp; dwGlobalErr = GetLastError();
 &nbsp;&nbsp; // Use event logging to log the error.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; hEventSource = RegisterEventSource(NULL, TEXT("SimpleService"));
 &nbsp;&nbsp; sprintf(chMsg, "SimpleService error: %d", dwGlobalErr);
 &nbsp;&nbsp; lpszStrings[0] = chMsg;
 &nbsp;&nbsp; lpszStrings[1] = lpszMsg;
 &nbsp;&nbsp; if (hEventSource != NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReportEvent(hEventSource, // handle of event source
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EVENTLOG_ERROR_TYPE,&nbsp; // event type
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // event category
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // event ID
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // current user's SID
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // strings in lpszStrings
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no bytes of raw data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszStrings,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // array of error strings
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no raw data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (VOID) DeregisterEventSource(hEventSource);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; // Set a termination event to stop SERVICE MAIN FUNCTION.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; SetEvent(hServDoneEvent);
}
</code></pre>
<h3>Service Sample Source Code—INSTSRV.C</h3>
<pre><code>/******************************************************************************\
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is a part of the Microsoft Source Code Samples. 
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1993 Microsoft Corporation.
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All rights reserved. 
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This source code is only intended as a supplement to 
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Microsoft Development Tools and/or WinHelp documentation.
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See these sources for detailed information regarding the 
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Microsoft samples programs.
\******************************************************************************/
///////////////////////////////////////////////////////
//
//&nbsp; InstSrv.c --
//
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This program demonstrates the use of the OpenSCManager and
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateService APIs to install the Simple service sample.
//
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
SC_HANDLE&nbsp;&nbsp; schService;
SC_HANDLE&nbsp;&nbsp; schSCManager;
VOID
InstallService(LPCTSTR serviceName, LPCTSTR serviceExe)
{
 &nbsp;&nbsp; LPCTSTR lpszBinaryPathName = serviceExe;
 &nbsp;&nbsp; schService = CreateService(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schSCManager,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SCManager database
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serviceName,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // name of service
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serviceName,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // name to display (new parameter after October beta)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE_ALL_ACCESS,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // desired access
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE_WIN32_OWN_PROCESS,&nbsp; // service type
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE_DEMAND_START,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // start type
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE_ERROR_NORMAL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error control type
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszBinaryPathName,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // service's binary
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no load ordering group
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no tag identifier
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no dependencies
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // LocalSystem account
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no password
 &nbsp;&nbsp; if (schService == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("failure: CreateService (0x%02x)\n", GetLastError());
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; } else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("CreateService SUCCESS\n");
 &nbsp;&nbsp; CloseServiceHandle(schService);
}
VOID
RemoveService(LPCTSTR serviceName)
{
 &nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp; ret;
 &nbsp;&nbsp; schService = OpenService(schSCManager, serviceName, SERVICE_ALL_ACCESS);
 &nbsp;&nbsp; if (schService == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("failure: OpenService (0x%02x)\n", GetLastError());
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; ret = DeleteService(schService);
 &nbsp;&nbsp; if (ret)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("DeleteService SUCCESS\n");
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("failure: DeleteService (0x%02x)\n", GetLastError());
}
VOID
main(int argc, char *argv[])
{
 &nbsp;&nbsp; if (argc != 3) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("usage: instsrv &lt;service name&gt; &lt;exe location&gt;\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to install a service, or:\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instsrv &lt;service name&gt; remove\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to remove a service\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; schSCManager = OpenSCManager(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // machine (NULL == local)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // database (NULL == default)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SC_MANAGER_ALL_ACCESS&nbsp;&nbsp; // access required
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp; if (!stricmp(argv[2], "remove"))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RemoveService(argv[1]);
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstallService(argv[1], argv[2]);
 &nbsp;&nbsp; CloseServiceHandle(schSCManager);
}
</code></pre>
<h3>Service Sample Source Code—CLIENT.C</h3>
<pre><code>/******************************************************************************\
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is a part of the Microsoft Source Code Samples. 
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1993 Microsoft Corporation.
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All rights reserved. 
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This source code is only intended as a supplement to 
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Microsoft Development Tools and/or WinHelp documentation.
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See these sources for detailed information regarding the 
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Microsoft samples programs.
\******************************************************************************/
////////////////////////////////////////////////////////
//
//&nbsp; Client.c --
//
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This program is a command line-oriented demonstration 
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of the Simple service sample.
//
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copyright 1993, Microsoft Corp. All Rights Reserved
//
//&nbsp; History:
//
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; who&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; davidbro&nbsp;&nbsp;&nbsp; 2/3/93&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; creation
//
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
VOID
main(int argc, char *argv[])
{
 &nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; inbuf[80];
 &nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; outbuf[80];
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; bytesRead;
 &nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp; ret;
 &nbsp;&nbsp; if (argc != 3) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("usage: client &lt;pipename&gt; &lt;string&gt;\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; strcpy(outbuf, argv[2]);
 &nbsp;&nbsp; ret = CallNamedPipe(argv[1], outbuf, sizeof(outbuf),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inbuf, sizeof(inbuf),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;bytesRead, NMPWAIT_WAIT_FOREVER);
 &nbsp;&nbsp; if (!ret) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("client: CallNamedPipe failed, GetLastError = %d\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetLastError());
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; printf("client: received: %s\n", inbuf);
}
</code></pre>
<h2>Appendix B. Recommended Reading for First-Time Programmers</h2>
<p>
<i>Programming Windows 3.1, </i>by Charles Petzold; Microsoft Press</p>
<p>
<i>Inside Windows NT, </i>by Helen Custer; Microsoft Press</p>
<h2>Appendix C. More Resources</h2>
<p>
<b>Newsgroups:</b></p>
<p>
comp.os.ms-windows.programmer.win32<br>
comp.os.ms-windows.nt.setup<br>
comp.os.ms-windows.nt.misc<br>
comp.os.ms-windows.announce</p>
<p>
This paper, as well as the following appendix ("UNIX Support for Windows NT") is available from <i>ftp.microsoft.com</i> in the DRG/Unix-to-Windows directory. The NFS_XWIN.DOC file, which is reproduced in Appendix D, is a good place to look for the most up-to-date information. Please send updates or information on products that you find useful to <b>brianmo@microsoft.com.</b></p>
<h2>Appendix D (NFS_XWIN.DOC from ftp.microsoft.com). UNIX Support for Windows NT</h2>
<p>
Draft: November 2, 1993</p>
<h3>NFS Clients and Servers</h3>
<p>
<i>Beame &amp; Whiteside<br>
</i>Products: NFS client and server<br>
Main: 416-765-0822</p>
<p>
<i>FTP Software, Inc.<br>
</i>Products: NFS client and server<br>
Main:&nbsp; 800-282-4387; 508-685-4000<br>
Direct Sales: 508-685-3300<br>
Fax: 508-794-4477</p>
<p>
<i>NetManage<br>
</i>Product: Chameleon NFS32<br>
·NFS client and server<br>
Main: 408.973.7171<br>
Fax: 408.257.6405</p>
<p>
<i>SunSelect<br>
</i>Product: PC NFS for Windows NT<br>
·NFS client, no announced server support<br>
Main:&nbsp; 800-24SELECT; 508-442-0000<br>
Fax:&nbsp; 508-250-5070</p>
<h3>X Windows Servers and Clients</h3>
<p>
<i>Congruent Corporation</i><br>
Product: NtNiX - X Client Support for Windows NT (Intel or MIPS)<br>
·all standard X libraries, X-terminal support, X clients<br>
·development tools: imake, GNU make, sed, cpp, gawk, ...<br>
·Motif support<br>
·multi-user NT facility<br>
Main:&nbsp; 212-431-5100<br>
Fax:&nbsp; 212-219-1532<br>
E-Mail: info@congruent.com</p>
<p>
<i>Digital Equipment Corp (DEC)<br>
</i>Products: eXcursion for Windows NT (X-Windows Server)<br>
·call for other products and support for Windows NT<br>
Main: 1-800-DEC-INFO xNT<br>
Fax: 508-486-2311</p>
<p>
<i>AGE Logic, Inc.<br>
</i>Products: Xoftware for Windows <br>
·provides full 32-bit X11R5 server support<br>
Main:&nbsp; 619-455-8600<br>
Fax: 619-597-6030</p>
<p>
<i>Network Computing Devices, Inc. (PC-X Division)<br>
</i>Products: PC-Xware for Windows NT (X-Windows Server)<br>
Main: 503-641-2200<br>
Direct Sales: 800-793-7638<br>
Fax: 503-643-8642</p>
<p>
<i>Hummingbird Communications, Ltd.<br>
</i>Products: HCL-eXceed for Windows NT<br>
Main:&nbsp; 416-470-1203<br>
Fax: 416-470-1207</p>
<p>
<i>JSB Corp.<br>
</i>Product: Multiview/X<br>
Main:&nbsp; 800-359-3408; 408-438-8300<br>
Fax: 408-438-8360</p>
<h3>Unix Tools and Utilities</h3>
<p>
<i>Windows NT Product<br>
</i>Windows NT includes several UNIX utilities including TELNET, FTP, FTPD, and RSH.</p>
<p>
<i>Congruent Corporation<br>
</i>Products: Toolbuster - CD-ROM loaded with GNU Utilities for Windows NT <br>
·GNU toolset, compilers. libraries, debuggers, editors, and utilities<br>
·on-line documentation<br>
·executables for Intel, Alpha, and MIPS<br>
·RCS component<br>
Main:&nbsp; 212-431-5100<br>
Fax:&nbsp; 212-219-1532<br>
E-Mail: info@congruent.com</p>
<p>
<i>Mortice Kern Systems (MKS), Inc.<br>
</i>Products: MKS Toolkit for Windows NT<br>
Main:&nbsp; 519-884-2251<br>
Direct Sales: 800-265-2797<br>
Fax: 519-884-8861</p>
<p>
<i>Hippo Software<br>
</i>Products: HIPPIX<br>
·provides a library that supports over 90% of the functions of the POSIX 1003.1 API working with the Win32 subsystem<br>
·provides a suite of over 100 UNIX utilities including: SH, VI, AWK, GREP, MAKE, LEX, YACC, RCS<br>
E-Mail: CompuServe: 72360,2675; Internet: hippix-info@hippo.com</p>
<p>
<i>Hamilton Laboratories<br>
</i>Products: C Shell for Windows NT<br>
Main:&nbsp; 508-358-5715<br>
Fax: 508-358-1113</p>
<p>
<i>Software Innovations<br>
</i>·All products available for Intel, MIPS, and Alpha.<br>
Product: The Connectivity Kit for Windows NT<br>
·TELNETD host service, FINGERD, UNIX talk daemon and client<br>
·Supports all of the Berkeley remote commands to Windows NT (RLOGIN, REXEC, RSH, RCP)<br>
·Serial port logon to Windows NT command line<br>
Product: The LPR/LPD kit for Windows NT<br>
·Allows you to use all Windows NT hosted printers from a UNIX machine, and also all UNIX hosted printers from Windows NT and Windows for Workgroups which show up as regular Print Manager printers.<br>
Product: Full feature NNTP news server for Windows NT<br>
Product: Threaded News Reader for Windows NT<br>
Product: Full SMTP/POP/UUCP/X.400 Gateway for Microsoft Mail for Windows NT <br>
Product: SLIP and PPP kit for Windows NT (in beta - expected to ship in January '94)<br>
Main: 1-800-946-6688<br>
Fax: 1-515-232-7382<br>
E-Mail: winnt@innov.com</p>
<h3>Unix Source Code Control Systems </h3>
<p>
<i>Mortice Kern Systems (MKS), Inc.<br>
</i>Products: MKS Toolkit for Windows NT<br>
Main:&nbsp; 519-884-2251<br>
Direct Sales: 800-265-2797<br>
Fax: 519-884-8861</p>
<p>
<i>Congruent Corporation<br>
</i>Product: Toolbuster - CD-ROM loaded with GNU Utilities for Windows NT<br>
·GNU toolset, compilers. libraries, debuggers, editors, and utilities<br>
·on-line documentation<br>
·executables for Intel, Alpha, and MIPS<br>
·RCS component<br>
Main:&nbsp; 212-431-5100<br>
Fax:&nbsp; 212-219-1532<br>
E-Mail: info@congruent.com</p>
<p>
<i>Hippo Software<br>
</i>Products: HIPPIX <br>
·provides a library that supports over 90% of the functions of the POSIX 1003.1 API working with the Win32 subsystem<br>
·provides a suite of over 100 UNIX utilities including: SH, VI, AWK, GREP, MAKE, LEX, YACC, RCS, ...<br>
E-Mail: CompuServe: 72360,2675; Internet: hippix-info@hippo.com</p>
<h3>Microsoft Windows API Support on UNIX</h3>
<p>
<i>Bristol Technology<br>
</i>Product: Wind/U 1.3<br>
·provides source code level support for MFC 2.0 and the Windows 16-bit API on UNIX Motif/X<br>
Main: Jean Blackwell at 203-438-6969<br>
E-Mail: jean@bristol.com</p>
<h3>RPC Support</h3>
<p>
Windows 3.1 RPC client support and Windows NT RPC client and server support are included in the Windows NT SDK.</p>
<h3>TCP/IP Support</h3>
<p>
A TCP/IP stack is included with Windows NT. The Windows NT SDK includes support for streams and the Windows Sockets interface.</p>
<h3>Mail Support</h3>
<p>
You can connect from a Microsoft Mail server to UNIX mail using Microsoft Mail's SMTP gateway product. To connect from a Windows for Workgroups Post Office to UNIX mail using the SMTP gateway, you need to first upgrade your Windows for Workgroups™ Post Office using the Windows for Workgroups Microsoft Mail &amp; Schedule+ Extensions Kit.</p>
<h3>Dumb Terminal Support</h3>
<p>
Several third parties are working on various forms of dumb terminal support.</p>
<h3>Multi-User Remote Access Services</h3>
<p>
Multiple users can log on remotely to a Windows NT Advanced Server machine using the Remote Access Services (RAS) software provided with that product. This software allows users to remotely connect to files stored on a Windows NT Advanced Server.</p>
<h3>Windows NT SDK and Documentation Kit</h3>
<p>
The Windows NT SDK is available as part of the Microsoft Developer Network (MSDN) Level 2 CD-ROM subscription service. Included on the CD-ROM is on-line documentation, sample source code, includes all Microsoft Windows systems, all SDKs and all DDKs shipping worldwide, in one place. Call 800-759-5474 to order.</p>
<h3>Developer Services and Beta Programs</h3>
<p>
To get development kits for a Microsoft Systems technology such as OLE 2.0, you should get the MSDN Level 2 CD-ROM subscription (see above). The ODBC SDK and many other developer materials can also be found on CompuServe's WINEXT forum. Microsoft Developer Services also has developer white papers and other support materials. To be considered for a Microsoft beta program you should call 206-936-BETA.</p>
<h3>Books</h3>
<p>
<i>Distributing Applications Across DCE and Windows NT </i>by O'Reilly &amp; Associates, Inc.<br>
Main: 707.829.0515<br>
Fax: 707.829.0104<br>
E-Mail: order@ora.com</p>
<p>
<i>Windows NT Answer Book </i>by Jim Groves, Microsoft Press</p>
<p>
<i>The Windows NT Resource Kit </i>(3-volume set), Microsoft Press</p>
<p>
<i>Migrating to Windows NT </i>by Randall C. Kennedy; Brady Publishing</p>
<h3>Technical Support</h3>
<p>
CompuServe is the preferred vehicle for getting technical support for Windows NT and other Microsoft Systems technologies. CompuServe's MSWin32 has a section for porting from UNIX to Win32. Microsoft also offers fee-based technical support, including Premier Developer Support, Professional Support, and Electronic Technical Service Requests Packages. For more information, or to order support services, call Microsoft Developer Services at 800-227-4679, extension 11771.</p>
<h3>Electronic Technical Service Requests</h3>
<p>
Electronic Technical Service Requests (SRs) packages give users the convenience of incremental information delivery and private responses from a Microsoft support engineer. SRs may be submitted 7 days a week, 24 hours a day, including holidays. Product Support Services (PSS) responds to SRs from Monday through Friday, 6 <small>a.m</small>. to 6 <small>p.m.</small>, Pacific Time, excluding holidays.</p>
<h3>Anonymous FTP Sites</h3>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=23%><i>ftp.microsoft.com</i></td>
<td width=77%>Microsoft support files, patches, drivers, and other developer information.</td>
</tr>
<tr valign=top>
<td width=23%><i>rhino.microsoft.com</i></td>
<td width=77%>Microsoft Windows NT TCP/IP applications and information.</td>
</tr>
<tr valign=top>
<td width=23%><i>ftp.cica.indiana.edu</i></td>
<td width=77%>Shareware and free software for Microsoft Windows NT.</td>
</tr>
<tr valign=top>
<td width=23%><i>sunsite.unc.edu</i></td>
<td width=77%>Shareware and free software for Microsoft Windows NT.</td>
</tr>
<tr valign=top>
<td width=23%><i>ftp.uu.net</i></td>
<td width=77%>Developer code samples and information in the directory /vendor/microsoft.</td>
</tr>
<tr valign=top>
<td width=23%><i>ftp.iastate.edu</i></td>
<td width=77%>FTPD, miscellaneous utilities as /pub/nt/[cpu-type]/ftpdserv.zip and other files. Also available on CompuServe forum MSWIN32 library 1 (New Uploads) files iftpd.zip and mftpd.zip.</td>
</tr>
</table><br>
<h3>Microsoft Resources</h3>
<p>
Microsoft Product Information: 800-227-4679 or 206-936-8661</p>
<p>
Microsoft Developer Services: 800-227-4679, ext. 11771 [technical support packages, developer materials]</p>
<p>
Microsoft Windows NT automated fax information: 800-936-4400</p>
<p>
Microsoft Download Service Bulletin Board: 206-637-9009 (1200/2400/9600 bps modem–technical notes and support software)</p>
<p>
Microsoft Developer Network CD-ROM subscription service: 800-759-5474 to order.</p>
</BODY>
</HTML>
