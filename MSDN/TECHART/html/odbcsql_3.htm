<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Updates and Transactions</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Updates and Transactions</h1>
<p>
This section discusses how an ODBC application can optimize its data modifications and transaction management.</p>
<h3>SQLRowCount</h3>
<p>
If an ODBC application needs to know how many rows were affected by a data modification (UPDATE, INSERT, DELETE), it can call the <b>SQLRowCount</b> function after the modification completes. <b>SQLRowCount</b> is generally not filled after a SELECT statement, although it may be if the application is using server cursors. For more information, see <i>Microsoft SQL&nbsp;Server Programming ODBC for Microsoft SQL&nbsp;Server</i>.</p>
<h3>Batching Procedure Calls</h3>
<p>
<b>SQLParamOptions</b> can be used to efficiently call a stored procedure multiple times with different parameters. <b>SQLBindParameter</b> normally binds a single variable to a parameter, and <b>SQLParamOptions</b> is used to extend this binding so that it binds an array of variables to a parameter.</p>
<p>
For example, to have five calls of a procedure that takes a single parameter, do the following:
<ol>
<li>
Allocate an array of five variables.<br><br></li>
<li>
Use <b>SQLBindParameter</b> to bind the parameter to the lead element of the array.<br><br></li>
<li>
Use <b>SQLParamOptions</b> to tell the driver that the parameter is bound to an array with five elements.</li>
</ol>
<p>
When you issue <b>SQLExecDirect</b>, the driver builds a single batch calling the procedure five times, with a different element from the array associated with each procedure call. This is more efficient than sending five separate batches to the server.</p>
<p>
This process also works with procedures that take multiple parameters. Allocate an array for each parameter with the same number of elements in each array, then call <b>SQLParamOptions</b> specifying the number of elements.</p>
<h3>Autocommit vs. ANSI Transaction Management</h3>
<p>
ODBC has two ways in which applications manage transactions. The application controls the autocommit mode by calling:</p>
<pre><code>SQL_AUTOCOMMIT_ON
SQLSetConnectOption(hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_AUTOCOMMIT,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_AUTOCOMMIT_ON);
</code></pre>
<p class=indent>
When autocommit is on, each statement is a separate transaction and is automatically committed when it completes successfully.</p>
<pre><code>SQL_AUTOCOMMIT_OFF
SQLSetConnectOption(hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_AUTOCOMMIT,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_AUTOCOMMIT_OFF);
</code></pre>
<p class=indent>
When autocommit is turned off, the next statement sent to the database starts a transaction. The transaction remains in effect until the application calls <b>SQLTransact</b> with either the SQL_COMMIT or SQL_ROLLBACK options. The statement sent to the database after<b> SQLTransact</b> starts the next transaction.</p>
<p>
ODBC applications should not mix managing transactions through the ODBC autocommit options with calling the Transact-SQL transaction statements. If an application does this, it could generate undetermined results. The application should manage transactions in one of the following ways:
<ul type=disc>
<li>
Use <b>SQLSetConnectOption</b> to set the ODBC autocommit modes.<br><br></li>
<li>
Use Transact-SQL statements, such as BEGIN TRANSACTION. (The <b>SQLSetConnectOption</b> should be left at its default setting of autocommit on.)</li>
</ul>
<p>
Applications should keep transactions as short as possible by not requiring user input while in a transaction. User input can take a long time, and all that time, the application is holding locks that may adversely impact other tasks needing the same data. </p>
<p>
An application should do all required queries and user interaction needed to determine the scope of the updates before starting the transaction. The application should then begin the transaction, do the updates, and immediately commit or rollback the transaction without user interaction.</p>
<h3>Using Transactions to Optimize Logging</h3>
<p>
Applications doing several data modifications (INSERT, UPDATE, or DELETE) at one time should do these within one transaction (autocommit off). When autocommit is on, each individual statement is committed by the server. Commits cause the server to flush out the modified log records. To improve performance, do all updates within one transaction and issue a single commit when all the changes have been made. Care must be taken to not include too many updates within one transaction, however. Performing many updates causes the transaction to be open longer and more pages to be locked with exclusive locks, which increases the probability that other users will be blocked by the transaction. Grouping modifications into a single transaction must be done in a way that balances multiuser concurrency with single-user performance.</p>
<p>
For applications that do not require a high degree of data accuracy, consider using the SQL_TXN_READ_UNCOMMITED transaction isolation level to minimize the locking overhead on the server.</p>
</BODY>
</HTML>
