<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Client/Server Solutions: The Architecture Process</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_csarctop"></a></sup>Client/Server Solutions: The Architecture Process</h1>
<p>
Ken Bergmann<br>
Microsoft Developer Network Technology Group</p>
<p>
September 29, 1995</p>
<h2>Abstract</h2>
<p>
This technical article illustrates some fundamental concepts that should be considered when architecting client/server solutions in Visual Basic®. It is geared toward developers who are providing client/server business solutions using the Visual Basic development environment. The concepts in this article are particularly useful for developers with an understanding of transaction processing systems.</p>
<h2>The Layered Paradigm: A Technical Overview</h2>
<p>
The standard paradigm recommended in Visual Basic® client/server applications is that of a series of layers. In this section, I will explain why I recommend the <i>Layered Paradigm</i> as a standard, what its strengths are, and where it breaks down.</p>
<p>
The Layered Paradigm divides the <i>component operations</i> of an application into several component pieces. The component operation becomes the component level worker, as opposed to a <i>core function</i>. Before I talk about why this is best, here are some definitions for the terms I am using:
<ul type=disc>
<li>
<i>Core function</i>. For purposes of this article, this is the smallest unit of code. It encompasses object methods, subroutines, and functions. These functions are called by any element of the application that needs to use them. They are not restricted to a certain component area. This is the smallest unit that can be dealt with in a self-contained fashion (loaded, unloaded, modified, executed, and so on).<br><br></li>
<li>
<i>Component operation</i>. This is next lowest unit of code and includes any core functions called to complete a defined objective. <i>A component operation </i>directly supports a component area (<b>LoadProducts</b>, <b>SaveCustomer</b>, and so on).<br><br></li>
<li>
<i>Component area</i>. A component area can be composed of either component operations or core functions, or possibly both. It only denotes a specific division of labor. The main rule is that a component area must be modularly segmentable. In other words, it must be loaded and unloaded on deman; it must allow modifications to be made internally with no effect on the calling code; and it must have some concept of its own memory space.<p class=tl>
Another subdivision that will be used is that of <i>component module</i>. A component module is simply a component area that is organized so all supporting code exists in the same code .BAS file.</P></li>
</ul>
<p>
Developing an application built of components—object-oriented programming (OOP), Component Object Model (COM), and so forth—is a popular thing to do, but within the constraints of the Visual Basic programming arena, it can be exceedingly difficult. The performance and memory limitations of Visual Basic often stand in the way of developing successful applications based on component pieces. The Layered Paradigm works around this by providing a threshold that allows you to divide components into groups by their relative "atomicity." The Visual Basic programming arena requires a higher threshold when dividing component operations into a component's core functions, as opposed to the C or C++ programming arenas, where the construction of a component's core functions can be very atomic. By moving the threshold from an atomic core function to an atomic component operation, the application receives the benefits of component design while staying within the constraints of the Visual Basic programming arena.</p>
<h3>Real-World Application</h3>
<p>
The smallest unit in Visual Basic that meets the above definition is the <i>module</i>. A module consists of code that is loaded and unloaded at the same time, can include the same scoping, and is modular in its interface. An OLE object instantiated from within Visual Basic code has similar characteristics. All the code in the object is loaded and unloaded with the instantiation of the object. It has its own scoping and has a modular interface.</p>
<p>
Interfaces like these items, which are the lowest atomic units in the Visual Basic programming arena, can (and, under a true component model, would) be broken down into their functional pieces. For example, the <b>ExecSQLBool</b> function is unwrapped, so that the <b>SaveCustomer</b> method becomes a series of database transport function calls that together constitute the functionality of executing structured query language [SQL] statements to retrieve a Boolean result.</p>
<p>
However, doing this isn't always an optimization. Often the application architecture will degrade in other areas (for example, every piece of the application that used <b>ExecSQLBool</b> now has to do its own database transport function calls). And what happens when the architecture changes—for example, if the database transport functions are now instantiated as methods on an OLE object? There would then be significant overhead involved with repeated instantiations of the SQL OLE object, compared to creating one instantiation and then passing everything through to that one instantiation.</p>
<p>
When modifications are made to implement this new approach, it takes much longer because the database transport code is spread out through the application-specific code. When the modification is finally finished, there is only one instantiation. That object is passed around to all the components of the application, so they can use it directly. There is still substantial overhead involved with dereferencing the object with each pass to a different piece of the application, so performance is still not acceptable, and memory usage soars.</p>
<p>
The Layered Paradigm, however, evens this scenario out nicely. Because there is only one instantiation, no other component has to spend time in dereferencing pointers, crossing application space, or other costly maneuvers. All the code for a component operation (for example, the <b>ExecSQLBool</b> function, which is simply the making of a series of database transport function calls) is in one place, so any modifications are easy and localized. Memory is optimized because all the code for this component operation is unloaded when not being used. The Layered Paradigm provides all the benefits of a component design while side-stepping the unwanted frustrations that come from Visual Basic's limitations.</p>
<h2>Pros and Cons</h2>
<p>
The Layered Paradigm has many benefits that help meet useful objectives in the changing world of client/server application development. Recognizable, measurable benefits include the following.
<ul type=disc>
<li>
<i>Maintainability</i>. Code modules in separate applications are organized in a recognizable manner. Component operation-oriented code is centrally located.<br><br></li>
<li>
<i>Reusability</i>. Component operation-oriented code is easily developed for reuse, specifically, component operations that cross application boundaries. The core functions that support a component operation are also good candidates for reuse.<br><br></li>
<li>
<i>Simplicity</i>. Modular design removes the use of "spaghetti code." It fosters elegance, not hacks.<br><br></li>
<li>
<i>Testability</i>. Modules can be tested easily. Modularization breaks up code tasks into smaller, more manageable units.<br><br></li>
<li>
<i>Size</i>. The memory footprint can be significantly reduced. Also, code size optimizations are much easier to implement and localize in a modular design.<br><br></li>
<li>
<i>Speed</i>. Modular code can be safely optimized without affecting the calling procedures.</li>
</ul>
<p>
As with any paradigm, there are also limitations. Some potential dangers are:
<ul type=disc>
<li>
<i>Functionalizing component operations</i>. This happens when component operations become so small that they are core functions in disguise. This leads to the same pitfalls as the functional component design we discussed previously.<br><br></li>
<li>
<i>Module overload</i>. This happens when the number of module component operations becomes too great to easily keep track of. This can be combated by grouping modular component operations that support the same component area into the same module. For example, rather than using 14 types of inserts, updates, and deletes, it would be preferable to move the component operations for a product into the same modular grouping. So the operations for an insert, update, and delete on a product will all go into a single product maintenance module. This would become a component module.<br><br></li>
<li>
<i>Mixing layer approaches</i>. This problem occurs when layers are mixed in some areas and not in others. For example, in the data interface for implementing product maintenance, the code might reference a window object. Conversely, in the data interface for implementing customer maintenance, the code does not. This inconsistency can be confusing and is not very maintainable. Consistency is the key to overcoming this, and a great many other programming trouble spots.</li>
</ul>
<h2>The Layers of a Visual Basic Application</h2>
<p>
The standard layers of a Visual Basic application are:
<ul type=disc>
<li>
<i>User interface</i>. This layer is the topmost layer and is where all user interaction is completed. This layer supports no dependents and is directly dependent on the data interface. This layer is almost entirely nonreusable and is completely contained within the application boundary.<br><br></li>
<li>
<i>Data interface</i>. This layer is where all data is contained, or manipulated, in memory. This layer directly supports the user interface and is directly dependent on the transaction interface. This layer is mostly nonreusable and is usually contained completely within the application boundary. However in the case of distributed reusable component areas, the component might manage its own data.<br><br></li>
<li>
<i>Transaction interface</i>. This layer is where all transaction-based processing of data occurs. This layer coordinates all permanent storage of data, either through file or database access. This layer supports the data interface and is dependent on the external access interface. This layer may be reusable and may extend past the application boundary in the same way as the data interface.<br><br></li>
<li>
<i>External access interface</i>. This layer is responsible for all the communication of an application with external data sources. External data sources may be in the form of files, databases, or hardware. This layer supports the transaction interface and in most cases should be completely reusable. This layer might also be managed strictly by a component area that falls outside the component boundary.</li>
</ul>
<p>
A graphical representation of these layers follows (Figure 1).</p>
<p>
<img src="csarctop_1.gif" border=0></p>
<p class=label>
<b>Figure 1. An example of a layered architecture</b></p>
<p>
The following coding example outlines how an update to a customer record is processed from the front end all the way through the database. This example is intended to show how the control of a process can be subdivided into the four (4) layers of the application.
<ul type=disc>
<li>
User Interface<pre><code>Sub btUpdCustomer_Click ()
 &nbsp;&nbsp; 'Begin the process of updating a customer
 &nbsp;&nbsp; btUpdCustomer.Enabled = False
 &nbsp;&nbsp; pnlStatus.Caption = Saving Customer...
 &nbsp;&nbsp; UpdateCustomer
 &nbsp;&nbsp; pnlStatus.Caption = "Ready"
 &nbsp;&nbsp; btUpdCustomer.Enabled = True
End Sub
</code></pre>
</li>
<li>
Data Interface<pre><code>'This function verifies the data in the UI meets certain preliminary
' criteria for an update. Then it calls the update transaction.
Sub UpdateCustomer ()
Dim sMatchcode As String
Dim sCustName As String
...
 &nbsp;&nbsp; 'Matchcodes must be = gicLenMC chars in length
 &nbsp;&nbsp; If Len(Trim$(txtMatchcode.Text)) &lt;&gt; gicLenMC Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Call the error display module
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrDisplay "Matchcodes must be " &amp; Str$(gicLenMC) &amp; " chars in length."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Sub
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; sMatchcode = Trim$(txtMatchcode.Text)
 &nbsp;&nbsp; ...
 &nbsp;&nbsp; if DoCustomerUpd (sMatchcode, sCustName, ...) then
 &nbsp;&nbsp; ...
End Sub
</code></pre>
</li>
<li>
Transaction Interface<pre><code>'This function does the update of a customer.
Function DoCustomerUpd (ByVal sMatchcode As String, ...)
Dim sParam As String
DoCustomerUpd = False
'Build customer record as parameter list
sParam = "'" &amp; Trim$( sMatchcode)
sParam = sParam &amp; "' , '" &amp; Trim$( sCustName)
...
'Validate the customer attributes
If ExecSQLBool(gscCustomerVal &amp; sParam) Then
 &nbsp;&nbsp; 'The customer record attributes are valid so...
 &nbsp;&nbsp; If ExecSQLBool(gscCustomerUpd &amp; sParam) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'The update was successful
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DoCustomerUpd = True
 &nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'The update was NOT successful
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Call the error display module
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrDisplay "The update to '" &amp; sCustName &amp; "' was NOT successful."
 &nbsp;&nbsp; End If
Else
 &nbsp;&nbsp; 'The validation was NOT successful
 &nbsp;&nbsp; 'Call the error display module
 &nbsp;&nbsp; ErrDisplay "The update to '" &amp; sCustName &amp; "' was NOT successful."
End If
...
</code></pre>
</li>
<li>
External Access Interface<pre><code>Function ExecSQLBool (ByVal sQry As String) As Integer
 &nbsp;&nbsp; 'Set the default
 &nbsp;&nbsp; ExecSQLBool = False
 &nbsp;&nbsp; 'Check the connection
 &nbsp;&nbsp; If SQLDead(giSQLConn) = NUM_ERR_DEADCONN Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; ...
 &nbsp;&nbsp; iRes = SQLCmd(giSQLConn, sQry)
 &nbsp;&nbsp; iRes = SQLExec(giSQLConn)
 &nbsp;&nbsp; Do Until (SQLResults(giSQLConn) = NOMORERESULTS)
 &nbsp;&nbsp; Do Until (SqlNextRow(giSQLConn) = NOMOREROWS)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Val(SQLData(giSQLConn, 1)) = NUM_EXEC_SUCCESS Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExecSQLBool = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExecSQLBool = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Error data could be in column 2
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Loop
 &nbsp;&nbsp; Loop
End Function
</code></pre>
</li>
</ul>
<h3>User Interface</h3>
<p>
The user interface is the only portion of the application that is responsive to user interaction. The user interface is where all data is presented to the user by means of window objects. The user interface is also where all inputs or modifications to data are made by means of window objects. The user interface should be one of two layers that references window objects (controls, forms, and so forth). In the best case scenario, the user interface would be the only layer that references window objects. However, in reality, allowing the data interface to reference the window objects directly can significantly reduce the amount of code and the simplicity of code paths. Since there are many aspects of a design that must all balance out (maintainability, reusability, performance, and simplicity), tradeoffs such as this are often considered.</p>
<h4>What should the user interface include?</h4>
<p>
The user interface includes all event handlers or events. These subroutines are called in response to some user action (a click, a mouse move), to a change in status of a window object (<b>Form_Resize</b>, <b>Lost_Focus</b>), or to callback procedures (<b>VBSQL_Error</b>, <b>Timer</b>). It also includes procedures that either fill controls with data or retrieve data from controls. As stated above, the line between the user interface and the data interface is often very fine when discussing the issues of filling controls or retrieving data from controls. The responsibilities of the user interface include operations such as:
<ul type=disc>
<li>
Displaying application data or information via window objects.<br><br></li>
<li>
Responding to the changing states of window objects.<br><br></li>
<li>
Initiating user requests.</li>
</ul>
<h4>What should the user interface not include?</h4>
<p>
The user interface should not be responsible for operations such as:
<ul type=disc>
<li>
Interfacing with external data sources such as files, databases, and OLE objects.<br><br></li>
<li>
Performing lengthy data manipulations—for example, sorting arrays and writing registry entries.<br><br></li>
<li>
Enforcing business rules—for example, validating data and verifying logins.<br><br></li>
<li>
Enforcing business processes.<br><br></li>
<li>
Controlling flow of transactional logic.</li>
</ul>
<h3>Data Interface</h3>
<p>
The data interface is where an application completes all its in-memory data manipulation. The data interface is responsible for validating and manipulating all an application's data. The data interface supplies all data to the user interface for display in window objects. The data interface supplies all data to the transaction interface for use when supervising the external access interface. This would include SQL strings and parameters. The data interface may use <i>locally</i> stored data sources such as registry entries or caches to store operational parameters and data. However, all <i>external</i> access should be done through the transaction interface.</p>
<h4>What should the data interface include?</h4>
<p>
The data interface includes any routines that will perform operations on the data of an application. The responsibilities of the data interface should include such operations as:
<ul type=disc>
<li>
Loading locally stored operational parameters (registry entries, .MDB file records).<br><br></li>
<li>
Sorting the data in arrays or structures.<br><br></li>
<li>
Validating the data in the structures.<br><br></li>
<li>
Overseeing the setting, or resetting, of operational parameters and work variables such as counters and flags.<br><br></li>
<li>
Formatting data for display in the user interface, including localization and masks.<br><br></li>
<li>
Formatting data for use in the transaction interface.<br><br></li>
<li>
Enforcing data interface business rules, such as the verification of data existence.</li>
</ul>
<h4>What should the data interface not include?</h4>
<p>
The data interface should not be responsible for such operations as:
<ul type=disc>
<li>
Displaying application data or information via window objects.<br><br></li>
<li>
Interfacing with external data sources such as files, databases, and OLE objects.<br><br></li>
<li>
Enforcing business processes.<br><br></li>
<li>
Controlling flow of transactional logic.</li>
</ul>
<h3>Transaction Interface</h3>
<p>
The transaction interface is part of the working internals of a client/server application. The transaction interface controls all data accessed by the application from an external data source. In addition, the transaction interface controls <i>all</i> updates to the data in the external data source that are initiated by the application. The transaction interface uses the external access interface to process its communication with the external data source and uses the data interface as its application data repository.</p>
<h4>What should the transaction interface include?</h4>
<p>
The transaction interface oversees the external access interface in the transfer or manipulation of all data to and from an external data source. The responsibilities of the transaction interface should include such operations as:
<ul type=disc>
<li>
Initiating or building queries.<br><br></li>
<li>
Requesting information from the external access interface (<b>GetCustomer</b>, <b>InitLog</b>, and so on).<br><br></li>
<li>
Enforcing business processes.<br><br></li>
<li>
Handling violations of external access business rules, such as triggers firing or no write permissions.<br><br></li>
<li>
Controlling all transactional logic.</li>
</ul>
<h4>What should the transaction interface not include?</h4>
<p>
The transaction interface should not be responsible for such operations as:
<ul type=disc>
<li>
Displaying application data or information via window objects.<br><br></li>
<li>
Performing data manipulation operations such as sorting arrays or formatting data.<br><br></li>
<li>
Setting or resetting operational parameters and work variables such as counters and flags.</li>
</ul>
<h3>External Access Interface</h3>
<p>
The external access interface embodies the communication of an application with an external data source. The external access interface is the specific transport or transports that the application uses to communicate with an external data source. Some common transports are DB-Library, Remote Data Objects (RDO), and Open Database Connectivity (ODBC). These transports require different code to complete specific functions. By encapsulating a series of external function calls or methods within modular functions, you can build reusable code that reliably completes certain component operations. For example, the component operation of logging into a database can be encapsulated in some general fashion. This same code can be used without modification in every application that uses an identical transport. The architecture used to call this function can be used even in applications that use a different transport. This preserves the consistency of a code base and allows for enhanced reusability and extensible architectures.</p>
<p>
There are several benefits to coding a specific external access interface, the first of which is the demonstrated benefit of reusability. A second benefit derives from an application having a central pipe where all its external communication is completed. The ability to tap into a central location for logging and error handling can be a tremendous time saver.</p>
<p>
A third major benefit is that encapsulating transport-specific code makes it extremely easy to replace an existing transport's code with code for a different transport. This method also allows an application to make modifications to the implementation of a transport without modifications to the application-specific code.</p>
<h4>What should the external access interface include?</h4>
<p>
The external access interface directly handles <i>all</i> communication with an external data source. The responsibilities of the external access interface should include such operations as:
<ul type=disc>
<li>
Executing all queries.<br><br></li>
<li>
Retrieving all information from the external access interface such as <b>GetNextRecord</b> and <b>FilePositionSeek</b>.<br><br></li>
<li>
Passing along all external data source messages, errors, and so forth.<br><br></li>
<li>
Opening and closing files or databases—for example, <b>OpenFile</b> and <b>DBConnect</b>.<br><br></li>
<li>
Communicating with hardware, such as communication ports.</li>
</ul>
<h4>What should the external access interface not include?</h4>
<p>
The external access interface should not be responsible for such operations as:
<ul type=disc>
<li>
Displaying application data or information via window objects.<br><br></li>
<li>
Performing data manipulation operations such as sorting arrays or formatting data.<br><br></li>
<li>
Setting or resetting operational parameters and work variables such as counters and flags.<br><br></li>
<li>
Controlling flow of transactional logic.</li>
</ul>
<h3>External Component Interfaces</h3>
<p>
External component interfaces are components that exist outside an application boundary and provide some service to those applications that instantiate them. External component interfaces are becoming much more common with the onset of OCX controls and OLE Server functionality in Visual Basic.</p>
<h4>Where do external component interfaces fit into the Layered Paradigm?</h4>
<p>
With so much functionality being encapsulated and reused in these external component interfaces, the need to position these within the Layered Paradigm is very real. Fortunately, the Layered Paradigm facilitates the use of such components with remarkable ease. External component interfaces are positioned entirely based upon how much ownership they exert over their own display mechanisms, data storage and manipulation, transactional logic, and external data access. If an external component interface is responsible for its own data (for example, an object encapsulating customers), it might require an application's data interface to interface with its data. If it only manipulates data (for example, calculates tax for a purchase in a certain state), it might not require the data interface to interface with it at all. It might, however, require the transaction interface to interface with it (for example, generate a match code) or the external access interface to interface with it (for example, SQL OLE connection).</p>
<p>
As should be obvious at this point, external component interfaces fit in smoothly with the Layered Paradigm. The only point that deserves special consideration is that of consistency. When you use an external component interface, I would recommend that your application implement a standard, reusable set of core functions if at all possible. This consistency throughout the application will add significant value when code bases are compared, code reused, and complex applications debugged.</p>
<h2>A Note to C++ Developers</h2>
<p>
As a C++ developer, you might find yourself initially at a loss when you begin to think about object-oriented design in Visual Basic. Since Visual Basic is not a true object-oriented language, how can you use it to implement a true object-oriented design? Furthermore, as Visual Basic becomes more object-oriented in future versions, how do you make sure that your implementation today doesn't preclude a safe and easy transition to the future versions of Visual Basic? The answer to these questions lies in the Layered Paradigm that I've presented here. </p>
<p>
Of all the aspects of an object-oriented language, only data encapsulation has relevance in Visual Basic. (For example, Visual Basic classes have no ability to inherit functionality from one class to another. However, you can still provide an object-like interface by doing strong data encapsulation. Visual Basic has the ability to scope variables at a module level and allow private functions in a module. This enables you to define private data and methods that can help to encapsulate data from the rest of the application.</p>
<p>
This approach fits well in a layered architecture, since the data interface of an application can be divided into separate components, each of which deals with a particular type of real-world data. In C++, objects encapsulate their data completely and often do not service user-interface commands—like filling a list box with a set of results. However, in Visual Basic, every time a function is called in a module, that module is loaded into memory, and when the function is finished, the module is unloaded. The overhead in calling a function is much greater than in C++, so tradeoffs must be made for performance reasons. The data interface can still strongly encapsulate its data, but it also should be able to accept list boxes and other user-interface controls to populate or to be able to pass entire structures to and from the user interface.</p>
<p>
The Layered Paradigm uses three terms that may seem confusing to a C++ developer: <i>component</i>, <i>component operation</i>, and <i>core function</i>. These terms are intentionally different from common object-oriented terms because Visual Basic isn't as flexible as an object-oriented language, and design must be done in a slightly different way. However, they are fairly analogous to object-oriented concepts, and for the purposes of discussion, we will think of them in C++ terms as <i>object</i>, <i>object method</i>, and <i>nonspecific method</i>.</p>
<p>
A component can be compared to a C++ object in the sense that it contains data (some private and some public) and methods to manipulate that data. However, it differs in that a component may be a single .BAS file and, in addition, has no ability to be instantiated as multiple objects, each of which contains its own copy of the object's data. Instead, a component contains just one copy of data or can contain an array of data structures, but it is entirely the responsibility of the component to maintain that data.</p>
<p>
Component operations can be compared to C++ methods, but it is important to note that in Visual Basic they do not carry an implicit "this" pointer. Since that is the case, there is no reference to a specific instance of data. It, therefore, falls within the responsibility of the client code to let the component operation know which data to operate on. If a component is designed to support only one instantiation of its data, this construct is fairly simple, but if this component needs to have many instantiations of its data, then instantiations of data structures can serve to keep the data separate.</p>
<p>
A core function can be compared to an unattached method in C++. This is a function that has no object reference and is independent of any particular data. It merely does a job and does not encapsulate any data. A C++ example of this would be a Windows API function. Though you could argue that all methods should belong to an object, there are times in Visual Basic where this approach is both unnecessary and improper.</p>
<p>
In the end, at whatever level the Visual Basic application is designed, the architecture should always strive to encapsulate data and abstract complexity from the user interface. Using this approach will also decouple the user interface from the actual data format and will provide a scalable and maintainable design.</p>
</BODY>
</HTML>
