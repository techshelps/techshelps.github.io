<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFC: I'll Never Use It!</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_mfcexp"></a></sup>MFC: I'll Never Use It!</h1>
<p>
Dennis Crain<br>
Microsoft Developer Network Technology Group</p>
<p>
<i>Happy Birthday Annie!</i></p>
<p>
May 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3310">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the METAVIEW sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes the experiences of a technical writer in the Microsoft Developer Network as he finally bites the bullet and writes his first application based on the document/view framework provided by the Microsoft® Foundation Class Library (MFC). Not really understanding why he would ever want to use MFC, his heart slowly softens to the prospect of never writing an application in C—ever again. The document used in the sample application is the Win32® enhanced metafile.</p>
<h2>Why Me?</h2>
<p>
I have always enjoyed programming. That is, programming in C. Who can argue that C can't give you everything you need to get the job done. It seemed to me that this C++ and MFC (Microsoft® Foundation Class Library) hype was nothing more than marketing weasels trying to justify their salaries. After all, I could write procedures for Windows® in my sleep. I loved the graceful, flowing indents of massive switch statements that could handle everything, plus more, that a Windows-based application could ever think of. I was bound and determined not to get sucked into the vortex. The black hole of abstraction wasn't going to get me. No way. No siree.</p>
<p>
But I began to feel as though I was alone. I tried to start an interest group for C programmers, and I was the only one who showed up! My colleagues were all wearing C++ suits with MFC ties to work. I began hearing voices as I was programming: "MFC would make that easier." But I was not interested in "easy." I was interested in "control." The C++/MFC combination only took me further away from an already abstracted Windows world a la C. I became depressed. I began to question my worth. (Is this getting deep enough?)</p>
<p>
It was then that my friend Nigel intervened. He challenged me to write an MFC application that used the document/view architecture. Reluctantly, I said okay. Mind you, I quickly qualified this response with, "But why do I want to do this boring thing?"</p>
<p>
What follows is an account of this process. More accurately, it is a discussion of those areas where I had to do some research to get the functionality that I needed in the application. Consider it a testimony to the power of MFC to free programmers from the mundane and repetitive garbage that we have had to deal with since Windows version 1.0. Am I coming around late? Probably. But I am confident that some of you are late-comers as well.</p>
<h2>The Challenge</h2>
<p>
As I noted above, Nigel challenged me to write an application using the document/view architecture of MFC. The purpose of this challenge was to get me fully involved and immersed into MFC. As a base specification, the Win32-based application was to use enhanced metafiles as the document (see the <a href="msdn_enhmeta.htm">"Enhanced Metafiles in Win32"</a> technical article in the MSDN Library for more information on this type of metafile) and display multiple views of the document as either the rendered picture or the metafile header displayed as text. Furthermore, the application would handle printing along with print preview. So with this in mind, I took the challenge. As you will see, there were a few detours that evolved along the way. Although they were not essential to the application, they helped the functionality. Consider these as useful tips.</p>
<h2>Creating the Project: Metafile Viewer</h2>
<p>
No rocket science here. I simply used the Microsoft Visual C++™ version 2.0 AppWizard. I selected the multiple-document interface (MDI), toolbar, status bar, and print preview options. The resultant project created the document and view classes. But wait, did I say view versus views? Why didn't AppWizard create the second view? As you recall, the application must provide two different views of the same document. However, AppWizard creates only a single view class. "Bummer," I thought. I would need to add the second view myself. Oh well, the print preview was free. More on that second view later.</p>
<h2>Opening the Document</h2>
<p>
So just where do you open a document in an architecture such as this? I incorrectly assumed that it would be in response to the user selecting the Open command from the File menu. Silly me. That was too obvious. I went down this path for a while and soon realized that I was doing all the work. I thought that MFC was supposed to give me a hand! "No matter," I thought. "I will just take a trip down to Nigel's office and ask him." Sure enough, I needed to open the document in the <b>Serialize</b> function provided by MFC in the document class (METAVDOC.CPP). The following code illustrates my first attempt at this.</p>
<pre><code>void CMetavw1Doc::Serialize(CArchive&amp; ar)
{
  if (ar.IsStoring())
  {
  }

<b>else</b>

<b>  {</b>

<b> &nbsp;&nbsp; UINT uiSig;</b>

<b> &nbsp;&nbsp; ar.Read(&amp;uiSize, sizeof(UINT));</b>

<b> &nbsp;&nbsp; if (uiSiz == EMR_HEADER) {</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp; m_hemf = GetEnhMetaFile(m_szPathName);</b>

<b> &nbsp;&nbsp; }</b>

  }
}
</code></pre>
<p>
The code of interest is in the <b>else</b> block (shown in bold, above). This code simply reads the first <b>sizeof</b>(UINT) bytes to see if they are the signature for an enhanced metafile. If they are, the metafile bits are retrieved by way of <b>GetEnhMetaFile</b>. Because I do not save any documents, there is no code in response to <b>IsStoring</b>.</p>
<p>
Now, wouldn't it be nice if I were to simply call something like <b>Load</b>(<i>m_szPathName</i>) to do this? Aha! The first little detour! I decided to write a class to handle the enhanced metafile "things" such as loading and playback (more on this soon). Use of this class reduced the above code to the following:</p>
<pre><code>void CMetavw1Doc::Serialize(CArchive&amp; ar)
{
  if (ar.IsStoring())
  {
  }

<b>else </b>

<b>  {</b>

<b> &nbsp;&nbsp; cemf.Load(m_szPathName);</b>

<b>  }</b>

}
</code></pre>
<p>
Notice that in both code fragments I used the <i>m_szPathName</i> member variable as an argument while calling the <b>GetEnhMetaFile</b> and <b>Load</b> functions. Initially, I thought that I could get the fully qualified filename from the <i>CArchive</i> parameter in the <b>Serialize</b> function. After all, <i>CArchive</i> contains the <i>m_pDocument</i> member variable that points to the <b>CDocument</b> object being serialized. Great! <b>CDocument</b> has a convenient member variable that sounded just like what I wanted, <i>m_strPathName</i>. Unfortunately, <i>m_pDocument-&gt;strPathName</i> is initialized to NULL when loading a file. So, I decided to grab the filename and path by overriding the <b>OnOpenDocument</b> function. The path is passed to <b>OnOpenDocument</b>, so I simply made a copy of it within the <b>CMetavw1Doc</b> class as shown below. Note that this copy of the path is stored in the <b>CString</b> <i>m_szPathName</i> member variable, which, by no coincidence, is the same variable passed to <b>GetEnhMetaFile</b> and <b>Load</b> in the code above.</p>
<pre><code>BOOL CMetavw1Doc::OnOpenDocument(LPCTSTR lpszPathName)
{
  m_szPathName = lpszPathName;

  if (!CDocument::OnOpenDocument(lpszPathName))
 &nbsp;&nbsp; return FALSE;
  return TRUE;
}
</code></pre>
<p>
So, what did I get for free? That's an easy one to answer. Everything in the list below (plus more that I am sure I don't have an appreciation for yet) is provided by the MFC framework:
<ul type=disc>
<li>
Open File common dialog box<br><br></li>
<li>
Most recently used file list in the File menu<br><br></li>
<li>
Ability to drag files from File Manager into my application (they even open!)<br><br></li>
<li>
Incredible sense of ease</li>
</ul>
<h2>Detour #1: Enhanced Metafile Class: CEMF</h2>
<p>
After filling my view class (METAVVW.CPP) with code specific to successfully render an enhanced metafile, it became clear that I was reverting to some of my unorganized tendencies when coding in C. So I decided to get this code out of the view class by writing a class to handle the loading and playback of the metafiles.</p>
<p>
For the purpose of this small application, <b>Load</b> and <b>Draw</b> were the most important member functions of the class. In the spirit of C++, I provided some additional functions to access various attributes of the metafile, such as the handle, the description string, and a pointer to the metafile header. The following code (taken from CEMF.H) gives you a good idea where I am going with this class. Note that I derived the class from <b>CObject</b> versus <b>CDC</b> or <b>CMetaFileDC</b>. <b>CDC</b> includes the <b>PlayMetaFile</b> and <b>AddMetaFileComment</b> metafile member functions. In retrospect, it might have been more convenient to derive the class from <b>CDC</b>. Deriving the class from <b>CMetaFileDC</b> just didn't seem right, because I was not creating a metafile but rather simply viewing existing metafiles. However, a sensible, fully functional metafile class could be derived from <b>CMetaFileDC</b>. Yes, there are many ways to skin a cat (sorry to all of you cat lovers!).</p>
<pre><code>class CEMF : public CObject
{
// Operations
public:
  CEMF();
  ~CEMF();
  BOOL Load(const char *szFileName);
  BOOL Draw(CDC* pDC, RECT* pRect);
  LPENHMETAHEADER GetEMFHeader(){return ((m_pEMFHdr) ? m_pEMFHdr : NULL);};
  LPTSTR GetEMFDescString(){return ((m_pDescStr) ? m_pDescStr : NULL);};
  HENHMETAFILE GetEMFHandle(){return ((m_hemf) ? m_hemf : NULL);};

protected:
  BOOL GetEMFCoolStuff();
  BOOL LoadPalette();

// Data members
protected:
  CString m_szPathName;
  HENHMETAFILE m_hemf;
  LPENHMETAHEADER m_pEMFHdr;
  LPTSTR m_pDescStr;
  LPPALETTEENTRY m_pPal;
  UINT m_palNumEntries;
  LPLOGPALETTE m_pLogPal;
  LOGPALETTE m_LogPal;
  HPALETTE m_hPal;
};
</code></pre>
<p>
The <b>Load</b> function looks suspiciously like my first go at opening the file in the first <b>Serialize</b> code fragment above. However, this time there is no <b>CArchive</b> object to take advantage of. No problem. Using a <b>CFile</b> object permits reading of the file signature. The <b>GetEMFCoolStuff </b>and <b>LoadPalette</b> functions are taken directly from a previous sample of mine (see the EMFDCODE sample, available in the MSDN Library). They obtain copies of the metafile header, description string, and palette embedded within the metafile. Of course they are now in the CEMF class.</p>
<pre><code>BOOL CEMF::Load(const char *szFileName)
{
  UINT uiSig;

  // Save the filename.
  m_szPathName = szFileName;

  // Check the file signature to see if this is an enhanced metafile.
  CFile cfEMF;
  cfEMF.Open(m_szPathName, CFile::modeRead | CFile::shareDenyWrite);
  cfEMF.Read(&amp;uiSig, sizeof(UINT));
  cfEMF.Close();

  // If this is an EMF, then obtain a handle to it.
  if (uiSig == EMR_HEADER)
  {
 &nbsp;&nbsp; m_hemf = GetEnhMetaFile(m_szPathName);
 &nbsp;&nbsp; GetEMFCoolStuff();
 &nbsp;&nbsp; LoadPalette();
  }
  else
 &nbsp;&nbsp; m_hemf = NULL;

  // Return success.
  return ((m_hemf) ? TRUE : FALSE);
}
</code></pre>
<p>
The <b>Draw</b> function is called by the <b>OnDraw</b> function in the view class (METAVVW.CPP). There is not much going on here. If there is a palette, indicated by a non-NULL value in the<i> m_hPal</i> member variable, the palette is selected and realized into the device context (DC). I was a little bummed when I realized that <b>CDC::SelectPalette</b> required a pointer to a <b>CPalette</b> object. But I was equally thrilled to find the <b>CPalette::FromHandle</b> function. I was able to easily convert a handle to a palette to a <b>CPalette</b> object. From here it was just a simple matter of playing the metafile a la <b>CDC::PlayMetaFile</b>.</p>
<pre><code>BOOL CEMF::Draw(CDC *pdc, RECT *pRect)
{
  ASSERT(m_hemf);

  BOOL fRet = FALSE;
  CRect crect;
  CPalette cpalOld = NULL;

  if (m_hemf)
  {
 &nbsp;&nbsp; if (m_hPal)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CPalette cpal;
 &nbsp;&nbsp;&nbsp;&nbsp; if ((cpalOld = pdc-&gt;SelectPalette(cpal.FromHandle(m_hPal), FALSE)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;RealizePalette();
 &nbsp;&nbsp; }
 &nbsp;&nbsp; fRet = pdc-&gt;PlayMetaFile(m_hemf, pRect);
 &nbsp;&nbsp; if (cpalOld)
 &nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;SelectPalette(cpalOld, FALSE);
  }
  return (fRet);
}
</code></pre>
<p>
So what else is in the CEMF class? As I mentioned above, there are two private member functions that handle metafile palette and header issues. I won't discuss those in this article, other than to say read the <a href="msdn_enhmeta.htm">"Enhanced Metafiles in Win32"</a> and <a href="msdn_emfdcode.htm">"EMFDCODE.EXE: An Enhanced Metafile Decoding Utility"</a> technical articles, both available in the MSDN Library. Of course, you will probably want to take a peek at CEMF.CPP and CEMF.H in the sample application included with this article! If you intend to do something serious with this class, I suggest that you add additional functionality to the class. This would include the ability to enumerate the metafile and to handle metafiles contained within clipboard files. Again, these issues are addressed in the above-mentioned articles.</p>
<h2>Rendering the Document</h2>
<p>
If I heard Nigel correctly, the challenge was to show the document in three different ways. The document was to be viewed as a rendered picture in a child window, as text describing the metafile header in a child window, and as a rendered picture in print preview. In addition, the two views in child windows were to be built around the MDI architecture provided by the MFC framework. Let's take a look at each of these individually.</p>
<h3>Rendered Picture in a Child Window</h3>
<p>
No problem here. Just a matter of calling the <b>Draw</b> function in the CEMF class. Take a closer look at the <b>OnDraw</b> function in METAVVW.CPP.</p>
<pre><code>void CMetavw1View::OnDraw(CDC* pDC)
{
 &nbsp; CMetavw1Doc* pDoc = GetDocument();

 &nbsp; // Flag to prevent drawing in response to full-drag sizing.
 &nbsp; // See OnSize() and FullDragOn() in this module.
 &nbsp; if (m_fDraw) 
 &nbsp; {
 &nbsp;&nbsp;&nbsp; // If either printing or print previewing, the rect is
 &nbsp;&nbsp;&nbsp; // provided by CPrintInfo in OnPreparePrinting.
 &nbsp;&nbsp;&nbsp; if (pDC-&gt;IsPrinting()) 
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDoc-&gt;m_cemf.Draw(pDC, &amp;m_rectDraw);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; else 
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetClientRect(&amp;m_rectDraw);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDoc-&gt;m_cemf.Draw(pDC, &amp;m_rectDraw);
 &nbsp;&nbsp;&nbsp; }
 &nbsp; }
}
</code></pre>
<p>
This code is organized around two conditional statements that are worth noting. The first condition is an "all-or-nothing" test. If <i>m_fDraw</i> is false, no attempt is made to draw. So what is <i>m_fDraw</i> all about? Well, this is detour #2, and I will address it shortly. The second condition tests if the drawing is taking place on the printer (or print preview) or within the view (child) window. The <b>IsPrinting</b> member function of the <b>CDC</b> class is an inline function that returns the <i>CDC::m_bPrinting</i> public member variable. Prior to using this function, I was testing <i>m_bPrinting</i> directly. Upon finding the <b>IsPrinting</b> function, I became somewhat puzzled. After all, <i>m_bPrinting</i> was simply returned by <b>IsPrinting</b>. The <b>IsPrinting</b> function seems more in the spirit of C++. If they were to change the spelling of <i>m_bPrinting</i>, my code would not work. But this still disturbs me a bit. After all, I was creative enough to debug the application, watch a few variables, and then figure out a way to getting what I wanted. This leads me to my first (and probably last) hypothesis: encapsulation and data hiding can exact revenge against enthusiasm.</p>
<p>
So much for hypothesizing. Back to the code. As we are discussing the rendering of the document within the view child window, the client area is obtained by way of <b>GetClientRect</b> and placed in <i>m_rectDraw</i>.</p>
<pre><code><b>if (pDC-&gt;IsPrinting())

</b> &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDoc-&gt;m_cemf.Draw(pDC, &amp;m_rectDraw);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; else 

<b> &nbsp;&nbsp;&nbsp; {</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetClientRect(&amp;m_rectDraw);</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDoc-&gt;m_cemf.Draw(pDC, &amp;m_rectDraw);</b>

<b> &nbsp;&nbsp;&nbsp; }</b>
</code></pre>
<p>
The <b>Draw</b> function is then called and poof! The picture appears.</p>
<h3>Rendered Picture in Print Preview or on a Printer</h3>
<p>
Yes I cheated. I am addressing two methods here, print preview and rendering on a printer. But I am only doing this because the MFC framework makes very little distinction between the two.</p>
<p>
If <b>IsPrinting</b> returns True, the <b>Draw</b> function is called with what initially appears to be an uninitialized <i>m_rectDraw</i>.</p>
<pre><code><b>if (pDC-&gt;IsPrinting())

 &nbsp;&nbsp;&nbsp; {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDoc-&gt;m_cemf.Draw(pDC, &amp;m_rectDraw);

 &nbsp;&nbsp;&nbsp; }

</b> &nbsp;&nbsp;&nbsp; else 
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetClientRect(&amp;m_rectDraw);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDoc-&gt;m_cemf.Draw(pDC, &amp;m_rectDraw);
 &nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
Fortunately, this is not the case. The framework comes to the rescue again. When printing or print previewing, several functions are called prior to <b>OnDraw</b>. These functions are overrideable. In this case I overrode the <b>OnPrint</b> function (which ultimately calls <b>OnDraw</b>). A pointer to a <b>CPrintInfo</b> object is passed to the <b>OnPrint</b> function. One data member of this class is a <b>CRect</b> object defining the usable page area. This rectangle is merely copied into <i>m_rectDraw</i> prior to calling <b>OnDraw</b>.</p>
<pre><code>void CMetavw1View::OnPrint(CDC* pDC, CPrintInfo* pInfo) 
{
  m_rectDraw = pInfo-&gt;m_rectDraw;
  OnDraw(pDC);
}
</code></pre>
<p>
The rest is history. Call <b>Draw</b> and you are done!</p>
<p>
One additional note on print preview. I spent a bit of time trying to get the dimensions of the print preview "page." I kept scratching my head trying to figure out how I was going to grab the origin and extents of the preview page centered in the preview window. I even went so far as to make a copy of the <b>CPreviewDC</b> object (private to AFX) just to grab the origins. But I was still faced with obtaining the extents. Thank goodness I remembered my hypothesis-now-turned-axiom: encapsulation and data hiding can exact revenge against enthusiasm. So after grunging around a bit in MFC, I realized that the print preview code was going to do all of the scaling automatically. After watching <b>CPrintInfo::m_rectDraw</b> while zooming, I realized that it was always the same. Just what I wanted! Chalk another one up to MFC.</p>
<h3>What Could Be Easier?</h3>
<p>
I don't know about you, but my painting code is generally fairly extensive. I am really impressed with handling print preview, normal drawing, and printing in 19 lines of code (including comments). True, I did write the CEMF class. But hey, I get to use it whenever I want in future projects! True, MFC handled all of the print preview and printing. But guess what? Microsoft gets to maintain that code for me!</p>
<h2>Detour #2: Dealing with the Pesky Full-Drag Option</h2>
<p>
So what was that <i>m_fDraw</i> flag all about in the <b>OnDraw</b> function? Recall that it was an "all-or-nothing" test. If <i>m_fDraw</i> is False, no attempt is made to draw. I darted down this detour when I began playing large metafiles in the client area of a view window in response to resizing the window. In the Windows NT™ operating system, there is an option (set by the user in the Desktop applet in Control Panel) that permits drawing as a window is resized. This option is called full-drag. In Windows 3.1 and Windows 95 this option does not exist (yeah!). I am here to tell you that if you are rendering a large metafile that does lots of complex things, you will absolutely detest this full-drag option. So how do you turn it off? You don't! Remember, the user set this mode. You don't really want to reset it. You might say, "This never stopped me in the past!" Well, there really isn't a convenient way of resetting it. I chose to use a one-shot timer to deal with the problem.</p>
<p>
So what is a one-shot timer? Simply put, it is a timer that is used once and then destroyed. The basic implementation, in the case of resizing the window, is to start a timer when WM_SIZE messages are encountered. If a timer already exists (as in the case of consecutive WM_SIZE messages), kill it and restart another one. When a WM_TIMER message finally sneaks through the message queue, kill the timer. Remember, you will not get a WM_TIMER message until you stop resizing the window. WM_TIMER messages have very low priority. The following two functions, <b>OnSize</b> and <b>OnTimer</b>, illustrate how I dealt with the timer in this application. In addition to setting and killing timers, these functions also set the value of the <i>m_fDraw</i> data member.</p>
<pre><code>void CMetavw1View::OnSize(UINT nType, int cx, int cy) 
{
  CView::OnSize(nType, cx, cy);
  // Only do this if full-drag is enabled.
  if (m_fFullDragOn)
  {
 &nbsp;&nbsp; if (!m_uiTimer)
 &nbsp;&nbsp;&nbsp;&nbsp; KillTimer(1);
 &nbsp;&nbsp; m_uiTimer = SetTimer(1, 100, NULL);
 &nbsp;&nbsp; m_fDraw = FALSE;
  }
}
</code></pre>
<p>
When the WM_TIMER message is finally dealt with, the <b>OnTimer</b> function sets <i>m_fDraw</i> to zero, kills the timer, and repaints the client area of the view window.</p>
<pre><code>void CMetavw1View::OnTimer(UINT nIDEvent) 
{
  m_fDraw = TRUE;
  m_uiTimer = 0;
  KillTimer(1);
  InvalidateRect(NULL);
}
</code></pre>
<p>
The <i>m_fFullDragOn</i> data member referred to in the <b>OnSize</b> function is set by a call to the <b>FullDragOn</b> function in the constructor for the view. The function simply queries the registration database to determine the value of <b>DragFullWindows</b> in the Control Panel\Desktop subkey of HKEY_CURRENT_USER. If the value of <b>DragFullWindows</b> is 1, the function returns True; otherwise it returns False.</p>
<pre><code>BOOL CMetavw1View::FullDragOn()
{
  HKEY hkey = NULL;
  DWORD dwType;
  long lResult;
  LPSTR lpszDataBuf;
  DWORD cbData = 0;

  lResult = RegOpenKeyEx(HKEY_CURRENT_USER, "Control Panel\\Desktop", 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KEY_READ, &amp;hkey);
  if (hkey)
  {
 &nbsp;&nbsp; // Obtain size of key.
 &nbsp;&nbsp; lResult = RegQueryValueEx(hkey, "DragFullWindows", NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwType, NULL, &amp;cbData);
 &nbsp;&nbsp; // Alloc sufficient memory for key value.
 &nbsp;&nbsp; lpszDataBuf = (LPSTR)malloc(cbData * sizeof(char));
 &nbsp;&nbsp; // Get the key value.
 &nbsp;&nbsp; lResult = RegQueryValueEx(hkey, "DragFullWindows", NULL, &amp;dwType, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPBYTE)lpszDataBuf, &amp;cbData);
 &nbsp;&nbsp; return (*lpszDataBuf == '1');
  }
  return FALSE;
}
</code></pre>
<p>
The net result of all this is that when the window is resized, nothing is redrawn until the resizing stops.</p>
<h2>Adding a Second View</h2>
<p>
You may recall that Nigel's challenge specified that the application would display multiple views of the document as either the rendered picture or the metafile header displayed as text. No problem; there must be a wizard for this. To my shock, there was none! So I took a look at Dale Rogerson's article, "Multiple Views for a Single Document." (MSDN Library Archive, Technical Articles) This was most helpful. However, until you do this two or three times, you can just plain get lost! Believe me, I was lost for a few hours as I bounced back and forth between adding the second view and writing the CEMF class. I would suggest that you focus on nothing but the second view until it is up and going. Nigel added a second view to one of his sample applications ("VIEWDIB: Views Multiple DIBs Simultaneously" <i>Editor's note: We're sorry to say that this sample is no longer available on the MSDN Library</i>) based on Dale's article. He derived the following list based on his experience. Between Dale's article and Nigel's list, I was able to painlessly add a second view. If I can do it, you can as well!
<ol>
<li>
Use ClassWizard to create a new view class; for example, <b>CAppSecondView</b>.<br><br></li>
<li>
Add the new view's header file to all the .CPP files that need it (see step 12).<br><br></li>
<li>
Add the <b>GetDocument</b> command to the view code and header. (Copy it from another view.)<br><br></li>
<li>
Write the <b>OnDraw</b> code for the new view, or at least add a simple stub so you can test it. Ensure the new view code is part of the project, and compile the new module.<br><br></li>
<li>
Create a new resource symbol. Use a name such as IDR_VIEW2TYPE. This symbol will be used for all new resources for the second view.<br><br></li>
<li>
Use App Studio to create an icon for the new view. Use the resource symbol created in step 5.<br><br></li>
<li>
Use App Studio to create a new menu for the view (copy the other one) with the new resource symbol you chose.<br><br></li>
<li>
Add menu items to each view menu to change the view type.<br><br></li>
<li>
Use App Studio to edit the string table. Add a new template string for the new resource symbol of the form:<p class=tl>
<b>\nType\n\n\n\nFileType\nFile Type</b></P></li>
<li>
Edit the APP.H file and add a public variable of the CMultiDocTemplate* class for each view; for example, m_pBasicViewTemplate and m_pNewViewTemplate.<br><br></li>
<li>
Edit APP.H to include a line after the declaration of the application class:<p class=tl>
<b>extern C???App NEAR theApp;</b> (replace ??? with your application name)</P></li>
<li>
Edit the APP.CPP file and add template code so that each template is saved in the template pointer variables; for example:<pre><code>m_pBasicViewTemplate = new CMultiDocTemplate(...);
AddDocTemplate(m_pBasicViewTemplate);
</code></pre>
</li>
<li>
Use ClassWizard to add menu handlers in the mainframe module for your new view menu items. Each handler is of the form:<pre><code>CreateOrActivateFrame(theApp.m_p????ViewTemplate, RUNTIME_CLASS(C???View));
</code></pre>
<p class=tl>
You will need to add the view header files to MAINFRM.CPP.</P></li>
<li>
Add the <b>CreateOrActivateFrame</b> function to MAINFRM.CPP and MAINFRM.H.</li>
</ol>
<h2>Summary</h2>
<p>
Okay, so this is another one of those unadulterated testimonials to MFC. What can I say. But I really was a skeptic before I began. If you haven't made the plunge, I suggest that you give it a try. I remember an acquaintance who once said, "I will never touch a Microsoft product, as they represent everything evil about the software industry." He now works at Microsoft! The point is, never say never. This is the attitude I had taken with C++ and MFC. And say, did you hear that the next version of Visual C++ is going to be called Visual Cobol++? I just might have to retire then!</p>
<h2>Bibliography</h2>
<p>
Crain, Dennis. <a href="msdn_emfdcode.htm">"EMFDCODE.EXE: An Enhanced Metafile Decoding Utility."</a> July 1993. (MSDN Library, Technical Articles)</p>
<p>
Crain, Dennis. <a href="msdn_enhmeta.htm">"Enhanced Metafiles in Win32."</a> June 1993. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. "Multiple Views for a Single Document." August 1993. (MSDN Library Archive, Technical Articles)</p>
<p>
Thompson, Nigel. "VIEWDIB: Views Multiple DIBs Simultaneously." (MSDN Library, Sample Code for Articles and Books)</p>
</BODY>
</HTML>
