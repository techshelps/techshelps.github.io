<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Article 4. The Ultimate Data Type</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1><a name="msdn_article4"></a>Article 4. The Ultimate Data Type</h1>
<p>
Bruce McKinney</p>
<p>
April 18, 1996</p>
<p>
Microsoft® Visual Basic® changed the programming world when it introduced the Variant type. The idea that all types can be contained within a single type is a trade of performance, size, and implementation simplicity for user simplicity. A single type that automatically converts between strings, integers, real numbers, and objects is a compelling feature for macro languages. In fact, variants will be the only type in Microsoft's new internet macro language, Visual Basic Scripting Edition (VBScript). Variants are less compelling for full-featured languages that aspire to high performance. Still, they offer many features that you can't easily get through intrinsic types—named arguments, optional arguments, parameter arrays, and standard collections.</p>
<p>
Variants have been transformed from a proprietary feature of Visual Basic to a standard OLE type. Delphi® 2.0 from Borland® has an intrinsic Variant type, and the Microsoft Foundation Class Library (MFC) has a <b>COleVariant</b> type that encapsulates some of the Variant functionality.</p>
<h2>What Is a VARIANT?</h2>
<p>
We're going to be talking about three different things in this article: variants, VARIANTs, and Variants.
<ul type=disc>
<li>
Lowercase variant is the <i>name of the concept</i> of cramming different subtypes into one supertype.<br><br></li>
<li>
To a C programmer, a VARIANT is something much more specific: It's a <i>structure containing a union</i>. You have to understand how it works to use it.<br><br></li>
<li>
To a Visual Basic programmer, a Variant is a<i> type that can contain another type</i> (you don't have to understand how it works). To a C++ programmer, a Variant is like everything else in C++—it's whatever you want it to be. We want to make it into something as close to an intrinsic Variant type as C++ allows, but to make that happen, we'll have to take an inside look at the VARIANT structure.</li>
</ul>
<h3>VARIANT Insides</h3>
<p>
There's no getting around it. We'll have to look at the VARIANT structure before we can talk about what to do with it. </p>
<pre><code>struct tagVARIANT {
 &nbsp;&nbsp; VARTYPE vt;
 &nbsp;&nbsp; WORD wReserved1;
 &nbsp;&nbsp; WORD wReserved2;
 &nbsp;&nbsp; WORD wReserved3;
 &nbsp;&nbsp; union {
 &nbsp;&nbsp; //&nbsp; C++ Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Union Name&nbsp;&nbsp; Type Tag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Basic Type
 &nbsp;&nbsp; //&nbsp; --------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lVal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // VT_I4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal Long
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char bVal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // VT_UI1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal Byte
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iVal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // VT_I2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal Integer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fltVal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // VT_R4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal Single
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dblVal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // VT_R8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal Double
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VARIANT_BOOL&nbsp; boolVal;&nbsp;&nbsp;&nbsp;&nbsp; // VT_BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal Boolean
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCODE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // VT_ERROR
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cyVal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // VT_CY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal Currency 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // VT_DATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal Date
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bstrVal;&nbsp;&nbsp;&nbsp;&nbsp; // VT_BSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal String
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IUnknown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *punkVal;&nbsp;&nbsp;&nbsp; // VT_UNKNOWN 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDispatch&nbsp;&nbsp;&nbsp;&nbsp; *pdispVal;&nbsp;&nbsp; // VT_DISPATCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal Object
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAFEARRAY&nbsp;&nbsp;&nbsp;&nbsp; *parray;&nbsp;&nbsp;&nbsp;&nbsp; // VT_ARRAY|*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal array
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A bunch of other types that don't matter here...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VARIANT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pvarVal;&nbsp;&nbsp;&nbsp; // VT_BYREF|VT_VARIANT&nbsp; ByRef Variant
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * byref;&nbsp;&nbsp;&nbsp;&nbsp; // Generic ByRef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; };
};
</code></pre>
<p>
The idea is that the union part can contain any one of the supported types. The <b>VARTYPE vt</b><i> </i>field should contain a type tag (and possibly a tag modifier) indicating what the union contains. Technically, that's all you really need to know. Every time you put a variable into a VARIANT, you also insert its type tag. Every time you want extract a variable, you first check its type so that you know what to do with it. Actually, OLE provides a group of system functions that help manage these tasks. We'll get to them soon. </p>
<p>
How big is a VARIANT? The first field is a <b>VARTYPE</b>, which is actually a typedef for an unsigned short. The next three fields are <b>WORD</b>, another typedef for an unsigned short. So VARIANT is 8 bytes plus the size of the union. A union contains enough storage space for its largest member, which in this case is 8 bytes (for a double, currency, or date). So a VARIANT is 16 bytes. That's a healthy chunk of storage if you have an array of variants containing 1 byte each. But of course, you won't be doing that very often. </p>
<p>
The most common size of data is 4 bytes (for a long, an error, or any kind of pointer). In this case, 11 of those 16 bytes are just padding. It's rumored that VARIANTS may get a new internal data type that will use up some of those reserved fields in some future version of OLE and Visual Basic. </p>
<p>
If you look in OLE documentation, you'll sometimes see parameters that look like VARIANTs, but actually have the type VARIANTARG. In fact, VARIANTARG is just a typedef for VARIANT, but just as a BSTR is more than its typedef, a VARIANTARG is more than a VARIANT. To be more exact, a VARIANTARG includes all of a VARIANT, but a VARIANT doesn't include all of a VARIANTARG. Or, to be less confusing, a VARIANTARG is a VARIANT used as an <b>IDispatch</b> argument and it can contain anything in the VARIANT's union, including by-reference arguments. A VARIANT in other contexts isn't supposed to use all those union members marked VT_BYREF in the second part of the union. </p>
<p>
The <b>IDispatch</b> interface is a fine thing, but we won't have get around to it in this series of articles. You can forget about <b>VARIANTARGS</b> and all the by-reference fields of the VARIANT union. We'll only be talking about the standard OLE types introduced in Article 2, and some of them will get short shrift. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The original name for the <b>boolVal</b> field of the VARIANT union was <b>bool</b>, but <b>bool</b><i> </i>is a future C++ keyword and Microsoft Visual C++® 4.1 gives a warning message if you use it. Presumably, a future version will actually implement the new "bool" type. In the meantime, there is a slight discrepancy: Readers on the Visual C++ subscription program who have version 4.1 will see <i>boolVal </i>in their VARIANTS, but those who have version 4.0 or earlier will see <i>bool</i>. I solved this for Visual C++ by changing my code to use <i>boolVal </i>and providing a macro that defines <i>boolVal </i>to <i>bool </i>for earlier versions. You may have to hack further if you have a different compiler.</p>
<h3>The VARIANT System Functions</h3>
<p>
I find the documentation for the VARIANT system functions to be sparse, and somewhat confusing. So here's my version, with a few editorial comments on the side. My function declarations are cleaned up a little from the macro-ized portable versions in the include file. </p>
<p>
But before we get into the individual functions, let's talk for a minute about the HRESULT type. It's actually a typedef to long, but not just any old long. An <b>HRESULT</b> is a bit field in which some bits specify status or severity and other bits contain an error number. For now, zero means no error (it is usually represented by the macro NO_ERROR or S_OK) and anything else means some kind of failure. Technically an HRESULT uses positive numbers to indicate different kinds of success and negative numbers to indicate different kinds of failure, but the VARIANT system functions return only one kind of success—represented by zero. </p>
<h4>void VariantInit(VARIANT * pv);</h4>
<p>
This statement creates a new VARIANT. The <b>vt</b><i> </i>field of the VARIANT structure is set to VT_EMPTY. The OLE documentation states that the <b>wReserved</b><i> </i>field is set to zero. If you step into <b>VariantInit</b> in a debugger, you'll see that it sets the <b>vt</b><i> </i>field to zero and leaves the <b>wReserved1</b>, <b>wReserved2</b>, and <b>wReserved3</b><i> </i>fields untouched.</p>
<p>
<b>Example:</b></p>
<pre><code>// Create a VARIANT and initialize it to a string.
VARIANT varSrc;
VariantInit(&amp;varSrc); 
varSrc.bstrVal = SysAllocString(L"The String To End All Strings")
</code></pre>
<h4>HRESULT VariantClear(VARIANT * pv);</h4>
<p>
This function destroys a VARIANT. It does the same thing as <b>VariantInit</b> and more. If the variant contains allocated data (a BSTR, SAFEARRAY, or <b>IDispatch</b> pointer), it calls the proper functions to free that data. Technically you could call <b>VariantInit</b> instead if you knew your VARIANT didn't contain allocatable data, but this is bad practice and you'll rarely be in a situation where you know the type at destruction time. </p>
<p>
<b>Example:</b></p>
<pre><code>// Destroy an existing VARIANT.
hres = VariantClear(&amp;varSrc); 
</code></pre>
<h4>HRESULT VariantCopy(VARIANT * pvDst, VARIANT * pvSrc);</h4>
<p>
This function copies one VARIANT to another. It frees any allocatable contents of the destination before the copy. It also allocates copies of any allocatable data in the source and copies the data to the other; the result is two identical VARIANTs. If the source contains a BSTR or SAFEARRAY, the destination will have a separate, identical copy. If the source contains an object (<b>IDispatch</b> or <b>IUnknown</b> pointer), the reference count will be incremented to indicate that both VARIANTs have access to the object. If this doesn't make sense, don't worry about it yet.</p>
<p>
<b>Example:</b></p>
<pre><code>// Create a new VARIANT by copying from an existing variant.
VARIANT varDst;
VariantInit(&amp;varDst);
hres = VariantCopy(&amp;varDst, &amp;varSrc); 
</code></pre>
<h4>HRESULT VariantCopyInd(VARIANT * pvDst, VARIANT * pvSrc);</h4>
<p>
This function copies one VARIANT to another, in the same manner as <b>VariantCopy</b>, but makes sure the destination contains a by-value copy of the data even if the source contained by-reference data. Because we won't be dealing with by-reference data, we won't need this function. </p>
<h4>HRESULT VariantChangeType(VARIANT * pvDst, VARIANT * pvSrc, WORD wFlags, VARTYPE vt);</h4>
<p>
This function changes the type of a VARIANT without changing its value (if possible). To change a variable in place, make the destination the same as the source. To copy a variable while changing its type, make the source the VARIANT containing the desired value and the destination the VARIANT to receive the copy. Put the desired type into the <i>vt </i>parameter. The only flag you can pass to the <i>wFlags </i>parameter is VARIANT_NOVALUEPROP, but you should only do that for objects, and the reasons why you might want to are beyond the scope of this article. Just pass zero. Be sure to check the return value, because some type conversions don't make sense and are bound to fail.</p>
<p>
<b>Example:</b></p>
<pre><code>varSrc.dblVal = 3.1416
// Copy varSrc to varDst while changing its type to Long (value 3).
hres = VariantChangeType(&amp;varDst, &amp;varSrc, 0, VT_I4)
if (hres) throw hres;
// Change varSrc to a string (value "3.1416").
hres = VariantChangeType(&amp;varSrc, &amp;varSrc, 0, VT_BSTR)
if (hres) throw hres;
</code></pre>
<h4>HRESULT&nbsp; VariantChangeTypeEx(VARIANT * pvDest, VARIANT * pvSrc, LCID lcid, WORD wFlags, VARTYPE vt); </h4>
<p>
This function (and the OLE documentation for it) is exactly the same as <b>VariantChangeType</b> except that it has an <i>lcid </i>parameter where you can pass a language ID. Apparently passing a different language ID might result in some sort of language translation for strings, dates, and objects, but you won't be able to figure out, from the OLE documentation or from this article, how such a change works. We won't be using this function.</p>
<h4>And Lots More</h4>
<p>
OLE provides 81 additional functions for converting between the various OLE types. If you've seen one, you've seen them all, but as a bonus, I'll show two. </p>
<p>
<b>HRESULT VarI2FromI4(long lIn, short * psOut);<br>
HRESULT VarI4FromI2(short sIn, long * plOut);</b></p>
<p>
You pass the first function a long and it returns the converted short through a reference parameter. The second function will convert that short back to a long. This may look simple, but there are overflow problems that OLE wants to handle itself rather than leaving you to guess the approved way. Besides, some conversions—Boolean from BSTR or dispatch from date—are more difficult. The <b>VariantChangeType</b> function uses a lot of these functions internally, but you can use them directly if you want. </p>
<p>
<b>Example:</b></p>
<pre><code>short i2;
varSrc.lVal = 1234;
// Extract a short from a VARIANT containing a long.
hres = VarI2FromI4(varSrc.lVal, &amp;i2);
// Assign a short to a VARIANT, but make it long.
hres = VarI4FromI2(i2, &amp;varDst.lVal);
</code></pre>
<h2>The Variant Class</h2>
<p>
The Variant class attempts to hide VARIANT details in the same way that the String class hides BSTR details. In many ways, it does a much better job. Because VARIANT is a structure, you can simply inherit a Variant from it. Internally, a Variant has no private members of its own, just the members of VARIANT. But Variant has one thing that VARIANT doesn't have: member functions including contructors, a destructor, and lots of operator functions.</p>
<p>
We'll look briefly at the implementation of Variant later. The important thing here is that Visual Basic can pass a VARIANT to your DLL, but you can receive it as a Variant. Let's take a look.</p>
<h3>A Variant API Example</h3>
<p>
In my book <i>Hardcore Visual Basic </i>I provided a Basic-friendly wrapper function for the <b>SearchPath</b> application programming interface (API) function. My <b>SearchDirs</b> function expected three Long arguments and looked like this: </p>
<pre><code>sFullName = SearchDirs(sEmpty, "vb.exe", sEmpty, iDir, iBase, iExt)
</code></pre>
<p>
The function would return the full path in the return value and the indexes of the directory, base file, and extension through reference variables. The first and third arguments were for the path to search and the extension, but in most cases you would just pass an empty string (the <i>sEmpty </i>constant from my type library). You could use the returned indexes with the <b>Mid$</b> function to extract the parts of the full path. This was nice, but you always had to declare and pass those index variables whether you wanted them or not, and you always had to pass empty variables for the path and extension. </p>
<p>
The version of <b>SearchDirs</b> shown in this article takes optional Variants instead of Longs for the index variables, and optional Variants for the path and extension arguments. You can find the code for it in WIN32.CPP. The event procedure of the Win32 button in the sample program contains code that excercises <b>SearchDirs</b>. The <b>GetFullPath</b> function in the same location is similar: it expands a filename to a full path specification.</p>
<p>
The original <b>SearchDirs</b> tried to maintain a parameter order similar to that of <b>SearchPath</b>. This version orders the arguments logically in order to make it easier to leave off ones that usually aren't needed. Any of the following Basic statements are OK:</p>
<pre><code>sFullName = SearchDirs("vb", ".exe", ".", vBase, vExt, vDir)
sFullName = SearchDirs("vb.exe", , , vBase, vExt)
sFullName = SearchDirs("vb", ".exe", , vBase)
sFullName = SearchDirs("vb.exe")
</code></pre>
<p>
Notice that the directory parameter has been moved to the end because it is the least likely to be used. The filename parameter has been moved to the start of the list because it is required and is often the only argument needed. You could argue about the handiest order for the path and extension parameters. I chose to make the the extension the second parameter and the path the third parameter. </p>
<p>
You can find this sample in the Win32.Cpp module. It is used by the event handler of the Win32 button in the Cpp4VB sample program. </p>
<p>
Let's start by examining the ODL declarations: </p>
<pre><code>[
entry("SearchDirs"),
usesgetlasterror,
helpstring("Searches sPath for sFile with sExt..."),
]
BSTR WINAPI SearchDirs([in] BSTR bsFile,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in, optional] VARIANT vExt,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in, optional] VARIANT vPath,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in, out, optional] VARIANT * pvFilePart,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in, out, optional] VARIANT * pvExtPart,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in, out, optional] VARIANT * pvDirPart);
</code></pre>
<p>
Notice that <b>SearchDirs</b> has two kinds of VARIANT parameters—input parameters that will pass in strings and output Variants that will receive integer indexes. The output Variants are pointers so that they can receive return values. Although the index parameters are only used for output, I chose to make them in/out parameters and overwrite any input. This makes it easier for clients to reuse the same variables for multiple calls.</p>
<p>
Let's take a look at the C++ code that makes this possible. Actually, <b>SearchDirs</b> looks a lot like the <b>GetTempFile</b> function described in Article 3, except that it's a little more complicated and includes optional arguments. I'm going to ignore the String part (interesting though it may be) and concentrate on the Variant features: </p>
<pre><code>BSTR DLLAPI SearchDirs(
 &nbsp;&nbsp; BSTR bsFileName,
 &nbsp;&nbsp; Variant vExt,
 &nbsp;&nbsp; Variant vPath,
 &nbsp;&nbsp; Variant * pvFilePart,
 &nbsp;&nbsp; Variant * pvExtPart,
 &nbsp;&nbsp; Variant * pvDirPart
 &nbsp;&nbsp; )
{
  try {
 &nbsp;&nbsp; LPTSTR ptchFilePart;
 &nbsp;&nbsp; Long ctch;
 &nbsp;&nbsp; String sFileName = bsFileName;
 &nbsp;&nbsp; if (sFileName.IsEmpty()) throw ERROR_INVALID_PARAMETER;

 &nbsp;&nbsp; // Handle missing or invalid extension or path.
 &nbsp;&nbsp; String sExt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Default initialize to empty
 &nbsp;&nbsp; if (!vExt.IsMissing() &amp;&amp; vExt.Type() != VT_EMPTY) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vExt.Type() != VT_BSTR) throw ERROR_INVALID_PARAMETER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sExt = vExt;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; String sPath;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Default initialize to empty.
 &nbsp;&nbsp; if (!vPath.IsMissing() &amp;&amp; vPath.Type() != VT_EMPTY) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vPath.Type() != VT_BSTR) throw ERROR_INVALID_PARAMETER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sPath = vPath;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Get the file (treating empty strings as NULL pointers).
 &nbsp;&nbsp; String sRet(ctchTempMax);
 &nbsp;&nbsp; ctch = SearchPath(sPath.NullIfEmpty(), sFileName, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sExt.NullIfEmpty(), ctchTempMax, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Buffer(sRet), &amp;ptchFilePart);
 &nbsp;&nbsp; ASSERT(ctch &lt;= ctchTempMax);
 &nbsp;&nbsp; Long iDirPart = 0, iFilePart = 0, iExtPart = 0;
 &nbsp;&nbsp; if (ctch == 0) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sRet.Nullify();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not finding a file returns zero, but isn't an error.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Long err = (Long)GetLastError();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (err) throw err;
 &nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Calculate the file part offsets.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iFilePart = ptchFilePart - (LPCTSTR)sRet + 1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetDirExt(sRet, &amp;iDirPart, &amp;iExtPart);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Resize must be after calculation because it may move ANSI buffer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sRet.Resize(ctch);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; // Cram into variants regardless of missing optional arguments.
 &nbsp;&nbsp; *pvDirPart = iDirPart;
 &nbsp;&nbsp; *pvFilePart = iFilePart;
 &nbsp;&nbsp; *pvExtPart = iExtPart;
 &nbsp;&nbsp; return sRet;
  } catch(Long e) {
 &nbsp;&nbsp; ErrorHandler(e);
 &nbsp;&nbsp; return BNULL;
  }
}
</code></pre>
<p>
Visual Basic passes in VARIANTs (as shown in the ODL declaration), but C++ receives Variants. The first two Variants in the parameter list are supposed to contain strings, but it's possible that the user might omit the parameter or pass an empty Variant (using Visual Basic's <b>Empty</b> keyword). If so, we'll just use a null String for the parameter (<i>sExt</i> or <i>sPath</i>). If the user passed a valid BSTR in the Variant, we'll assign it to our String variable. This works because the Variant type has an operator BSTR member that converts a Variant to a BSTR, and the String type has a constructor that takes a BSTR argument. There's a lot going on behind the scenes, as you can tell if you step through this code with a debugger. Finally, if someone passes the floating point number 3.1416 as the file extension, we'll throw the bozo out with an "Invalid Parameter" error. </p>
<p>
There's not much to the output Variant code. You simply calculate the correct values in integers (such as <i>iFilePart</i>) and then cram them into the Variants for return. There's no reason to test whether optional arguments were actually passed. If an argument was omitted, Basic will simply create a temporary Variant with an error setting. You can fill this variable with whatever you like because it's going to be tossed anyway. </p>
<h3>Debugging Variants</h3>
<p>
Before you start developing your own Variant functions (or stepping through mine), users of Microsoft Devopler Studio will probably want to make one more change in AUTOEXP.DAT in the \MSDEV\BIN directory. See Article 3 for a review of how we edited this file to handle output of BSTRs and Strings in Unicode™ format. Handling Variants is a little different. Here's the setting I use: </p>
<pre><code>Variant =vt=&lt;vt,x&gt; short=&lt;iVal&gt; long=&lt;lVal&gt; dbl=&lt;dblVal,g&gt; str=&lt;bstrVal,su&gt;
</code></pre>
<p>
The result isn't exactly is pretty, but it's the best I could do. The debugger shows five of the most common fields of the VARIANT structure and union. You have to look at the value of the <b>vt</b><i> </i>field (after memorizing the VT constant values) to figure out which of the other fields (if any) is meaningful. The alternative is to expand every Variant as it appears in the locals or watch the window—a task that gets old in a hurry. </p>
<p>
In a language such as Visual Basic that supports Variant as an intrinsic type, the debugger can look at the the <b>vt</b><i> </i>field and display the appropriate data in the appropriate format automatically. Will Visual C++ ever get an intrinsic __variant type, and will Microsoft Developer Studio ever display formatted __variant values? It could happen, but don't hold your breath. </p>
<h3>A Variant Workout</h3>
<p>
The goal of the C++ Variant type is to work the same as the Visual Basic Variant type. Because Visual Basic invented Variants, whatever it does is the definition of Variant. Of course, C++ is a different language, and some things won't work quite the same. </p>
<p>
The following tests are located in the <b>TestVariant</b> function in Test.Cpp. The event procedure of the Variant button in the sample program calls this function. It works a lot like the <b>TestString</b> function discussed in Article 3—writing test output to a string that is returned to the Visual Basic program for display.</p>
<h4>Variant Construction</h4>
<p>
Consider these variable initializations: </p>
<pre><code>Variant vInteger = (Integer)6;
Variant vLong = 9L;
Variant vSingle = 7.87f;
Variant vDouble = -89.2;
Variant vBoolean(True, VT_BOOL);
Variant vString = _W("String");&nbsp; 
Variant vError((Long)DISP_E_EXCEPTION, VT_ERROR);
Variant vCurrency = (Currency)78965;
Variant vDate(2.5, VT_DATE);&nbsp;&nbsp;&nbsp; // Noon, January 1, 1900.
</code></pre>
<p>
This isn't the same as Visual Basic because you can't initialize variables in the declarations in Visual Basic. In addition, you'll notice quite a few casts and extra arguments.</p>
<p>
When initializing <i>vInteger</i>, the constant 6 must be cast to Integer (short) so that it will go through the right constructor. The variable <i>vBoolean </i>must have an argument specifying its type because an OLE Boolean is actually the same as a short and so they must share the same constructor. The <i>vError </i>and <i>vDate </i>variables must also have type arguments because they share the long and double types respectively. C++ is a finicky langauge, and you'll have to do a lot of casting to make it understand what you want. </p>
<h4>Variant Assignment</h4>
<p>
Assignments work the same as initialization except that you can't use a type argument with operator=(). Therefore, the <b>Variant</b> class doesn't support direct assignment to the Error, Boolean, and Date types with the assignment operator. Instead, you can use the <b>SetError</b>,&nbsp; <b>SetBoolean</b>, and <b>SetDate</b> methods:</p>
<pre><code>// Assign to types that have no operator=.
vBoolean.SetBoolean(False);
vError.SetError((Long)E_ACCESSDENIED);
vDate.SetDate(3333.125);
</code></pre>
<p>
It's your responsibility to remember to use the method for these types. Alternatively, you can assign to some other type and change with the <b>Type</b> method: </p>
<pre><code>// Assign to nearest type and then change to desired type.
vDate = 3333.125;
vDate.Type(VT_DATE);
</code></pre>
<h4>Variant Type Conversion</h4>
<p>
Variants also have conversion operators so that you can assign a variant to a native type and the conversion will take place automatically:</p>
<pre><code>// Assign double to long (throwing away remainder).
Long i = vDouble;
// Assign a date to a string (appears in date string format).
String s = vDate;
// Assign numeric string a numeric variable.
vString = _W("3.1416");
vSingle = vString.CopyAs(VT_R4);
</code></pre>
<p>
String conversions are particularly convenient because OLE takes care of converting to and from numeric and string arguments. Date variables, for example, come out as strings in the standard date format. The iostream insertion operator (&lt;&lt;) for Variants takes advantage of string conversion to output Variants to an output streams. Here's an example of how the insertion operator displays different Variant types:</p>
<pre><code>vInteger==6
vLong==9
vSingle==7.87
vDouble==-89.2
vBoolean==-1
vString=="String"
vError==Facility:2, Severity:1, Code:9
vCurrency==7.8965
vDate==1/1/00 12:00:00 PM
</code></pre>
<p>
Notice that although the currency type is stored as a 64-bit integer, OLE translates the string output to a fixed-point number with four decimal places. The date type is stored as a double, but OLE translates it to a formatted date and time string. The error type is stored as a long, and OLE doesn't do anything with it. It's my insertion code in the operator&lt;&lt; function that treats it as a special case and breaks it into the standard parts of an OLE HRESULT. OLE translates Booleans to 0 or -1, but you could easily update the insertion code to output them as "True" and "False."</p>
<h4>Variant Arithmetic</h4>
<p>
Of course, any self-respecting <b>Variant</b> class must handle normal arithmetic operations. Here are some addition statements and their output. </p>
<pre><code>vTmp = vInteger + vLong; // 6 + 9 == 15
vTmp += vDouble;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 15 += -89.2 == -74.2
float flt = 3.25;
flt += (float)vTmp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3.25 += -74.2 == -70.95
vTmp += (short)77;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -74.2 += 77 == 2.8
vTmp += vInteger++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2.8 += 6 == 8.8
vTmp += ++vInteger;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 8.8 += 8 == 16.8
vTmp = vString + vLong;&nbsp; // Stuff9 + 9 == Stuff9
vTmp += vDouble;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Stuff9 += -89.2 == Stuff9-89.2
</code></pre>
<p>
I'll leave you to check similar statements (in the <b>TestVariant</b> function) using subtraction, multiplication, division, and even modulus. I confess that I didn't implement the C++ bitwise operators (&amp;,|, and ~), but you could add them in a few minutes by copying the existing operator code. Of course, bitwise operators (like the modulus operator) only make sense for integer types. Or maybe not. If you can figure out a reasonable meaning for bitwise operators on strings or dates, C++ won't stop you from implementing it. </p>
<h4>Variant Comparison</h4>
<p>
The Variant type also has logical operators. </p>
<pre><code>f = (vDouble == vLong);&nbsp; // (9 == 9) == 1
f = (vInteger == vLong); // (6 == 9) == 0
f = (vInteger != vLong); // (6 != 9) == 1
f = (vInteger &lt;= vLong); // (6 &lt;= 9) == 1
f = (vInteger &lt; vLong);&nbsp; // (6 &lt; 9) == 1
f = (vInteger &gt; vLong);&nbsp; // (6 &gt; 9) == 0
f = (vInteger &gt;= vLong); // (6 &gt;= 9) == 0
f = (vTmp == vDate);&nbsp;&nbsp;&nbsp;&nbsp; // (2/14/09 3:00:00 AM == 2/14/09 3:00:00 AM) == 1
f = (vDate == vTmp);&nbsp;&nbsp;&nbsp;&nbsp; // (2/14/09 3:00:00 AM == 2/14/09 3:00:00 AM) == 0
f = (vTmp == vString);&nbsp;&nbsp; // (2/14/09 3:00:00 AM == Stuff9) == 0
f = (vTmp != vString);&nbsp;&nbsp; // (2/14/09 3:00:00 AM != Stuff9) == 1
</code></pre>
<p>
This looks pretty good except for one minor problem—<i>vTmp </i>equals <i>vDate</i>, but <i>vDate </i>doesn't equal <i>vTmp</i>. How can that be? Well, it's kind of a peculiarity of the way OLE works when <i>vTmp </i>is a string variant and <i>vDate </i>is a date. If <i>vTmp </i>comes first, the operator==() code asks OLE to convert <i>vDate </i>to a string and then compares the two strings. Match! If <i>vDate </i>comes first, the code tries to convert <i>vTmp </i>to a date, but unfortunately OLE doesn't know how to convert a date format string to a numeric date. No match! I'm sure you could fix this problem with enough special case code. </p>
<p>
You may notice that some arithmetic and logical expressions require typecasts where you might prefer not to see them. You'd need a lot of operator functions to support every possible combination. Consider addition. I provide this function: </p>
<pre><code>friend Variant operator+(Variant&amp; v1, Variant&amp; v2);
</code></pre>
<p>
To cover all your bases, you'd need these: </p>
<pre><code>friend Variant operator+(Variant&amp; v1, BYTE b2);
friend Variant operator+(BYTE b1, Variant&amp; v2);
friend Variant operator+(Variant&amp; v1, short i2);
friend Variant operator+(short i1, Variant&amp; v2);
</code></pre>
<p>
And so on. Be my guest if you want to add these. Most of them could be implemented as simple inline functions. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The <b>COleVariant</b> class provided by MFC has some nice features (support for <b>COleDateTime</b> and <b>COleCurrency</b>). These were apparently required to meet its primary goal, which I'm told was to fit in with the MFC database classes. I'm not qualified to judge how it fits that goal, but it certainly doesn't meet my goal, which was to match the Visual Basic <b>Variant</b> type. <b>COleVariant</b> has no arithmetic operators and only one logical operator—equality. Unfortunately, its equality operator will indicate that a variant double containing zero is not equal to a variant long containing zero. That's quite a change from Visual Basic. </p>
<h3>One More Variant Example</h3>
<p>
Visual Basic provides the <b>InStr</b> function for searching strings, but it always assumes you want to start at the front of the string and search back. There's no <b>InStrR</b> for searching backward. I needed a reverse string search function in my book <i>Hardcore Visual Basic</i>, so I wrote a crude InStrR in Basic, but noted in a comment that somebody ought to write an efficient version in C++. </p>
<p>
Well, here it is. Check out the code in Tools.Cpp. The String Find button in the sample program tests it. The syntax of <b>InStr</b> is a little unusual, and my InStrR has to jump through hoops to work the same way except better. The first and last parameters are optional, as shown in this syntax: </p>
<pre><code>position = InStr([start,] target, search[, compare])
</code></pre>
<p>
But alas, <b>InStr</b> behavior fails to match this syntax. You can't leave off the first argument if you supply the last argument. The following gives you a syntax error: </p>
<pre><code>i = InStr(sTarget, sFind, 1)
</code></pre>
<p>
Instead, you have to give the default first parameter (1) explicitly. </p>
<pre><code>i = InStr(1, sTarget, sFind, 1)
</code></pre>
<p>
I can't guess how Visual Basic implements this function so that the first argument isn't really optional. It's optional in my InStrR. All the parameters have to be Variants in order to make the optional arguments work. Here's how I do it: </p>
<pre><code>Long DLLAPI InStrR(Variant vStart, Variant vTarget, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variant vFind, Variant vCompare) 
{
  try {

 &nbsp;&nbsp; Long iStart = -1, afCompare = ffReverse;
 &nbsp;&nbsp; String sTarget, sFind;

 &nbsp;&nbsp; // Assign strings depending on whether vStart is given.
 &nbsp;&nbsp; if (vStart.Type() == VT_BSTR) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!vFind.IsMissing()) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; afCompare |= ((Long)vFind ? ffIgnoreCase : 0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sTarget = vStart;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sFind = vTarget;

 &nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iStart = vStart;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iStart &lt; 1) throw ERROR_INVALID_PARAMETER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!vCompare.IsMissing()) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; afCompare |= ((Long)vCompare ? ffIgnoreCase : 0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sTarget = vTarget;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sFind = vFind;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; // Find the string.
 &nbsp;&nbsp; return sTarget.Find(sFind, afCompare, iStart);

  } catch(Long e) {
 &nbsp;&nbsp; ErrorHandler(e);
 &nbsp;&nbsp; return 0;
  }
}
</code></pre>
<p>
Most of the code deals with optional arguments. Once you figure them out, it takes only one line to find the string. </p>
<h3>How Variants Work</h3>
<p>
You don't need to understand how the <b>Variant</b> class works to use it, but you can never know too much. See if you can find the private members where variant data is stored in the <b>Variant</b> class: </p>
<pre><code>class Variant : VARIANT
{
public:
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Constructors
 &nbsp;&nbsp; Variant();
 &nbsp;&nbsp; Variant(const Variant&amp; vSrc);&nbsp;&nbsp; 
 &nbsp;&nbsp; Variant(BYTE bSrc);&nbsp;&nbsp; // VT_UI1
.
.
.
private: 
 &nbsp;&nbsp; // Constructor helper
 &nbsp;&nbsp; void VariantCreate(VARTYPE vt = VT_EMPTY);

 &nbsp;&nbsp; // Destructor helper
 &nbsp;&nbsp; void VariantDestroy();
 &nbsp;&nbsp; Boolean IsConstructed();
 &nbsp;&nbsp; void Constructed(Boolean f);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Look, Ma! No data.
};
</code></pre>
<p>
If you looked in the private section at the end of the class (where any self-respecting class would store data), you'd be out of luck. Instead the data comes at the very start where the Variant class is inherited from OLE's VARIANT structure. The <b>Variant</b> class gets internal access to all the VARIANT members, but because VARIANT is inherited privately, users of <b>Variant</b> can't see them. That's why Visual Basic can pass you a VARIANT and you can receive it as a <b>Variant</b>. They're the same thing—with a different interface. </p>
<h4>Variant Construction and Destruction</h4>
<p>
Let's check out a few constructors. </p>
<pre><code>inline Variant::Variant()
{
 &nbsp;&nbsp; VariantCreate();
}

inline Variant::Variant(const Variant&amp; v)
{
 &nbsp;&nbsp; VariantCreate();
 &nbsp;&nbsp; HRESULT hres = VariantCopy(this, (Variant *)&amp;v);
 &nbsp;&nbsp; if (hres) throw hres;
}

inline Variant::Variant(BYTE nSrc)
{ 
 &nbsp;&nbsp; VariantCreate(VT_UI1); 
 &nbsp;&nbsp; bVal = nSrc; 
}
</code></pre>
<p>
What is this <b>VariantCreate</b> that seems to be doing the real construction work? Let's take a brief look at the destructor before I reveal the answer. </p>
<pre><code>inline Variant::~Variant()
{
 &nbsp;&nbsp; if (IsConstructed()) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VariantDestroy();
 &nbsp;&nbsp; }
}
</code></pre>
<h4>Implementation Choices</h4>
<p>
If the variable was received from the host as a parameter, the host owns it and it shouldn't be destroyed. If we created it with constructor, we need to destroy it. But you can't see how any of this works because I hide the details in the <b>VariantCreate</b>, <b>IsConstructed</b>, and <b>VariantDestroy</b> helper functions. </p>
<p>
You're going to have to check the source code to unravel this mystery. I'm not going to reveal the implementation in print because I might have to change it. One way or another, the class needs a flag (just one bit) indicating whether a given <b>Variant</b> object should be deallocated or not. <b>VariantCreate</b> will set this flag, <b>IsConstructed</b> will test it, and <b>VariantDestroy</b> will clear it. But you can't store the flag as a separate member variable, because that would change the size of the Variant class and make it impossible to receive VARIANTs as Variants. I can think of three ways to implement Variant constructors and destructors: 
<ol>
<li>
Use a bit in one of the <b>wReserved</b><i> </i>fields as a flag. You know better than to use reserved fields of system data. What if they change the VARIANT type? Remember that I mentioned earlier that there are rumors they'll add a new type that uses part of that reserved data. On the other hand, with six bytes of unused data, surely no one would notice if we used just one itty bitty bit. But which one? <br><br></li>
<li>
Use an unused bit in the <b>vt</b><i> </i>field as a flag. Some of those bits are used for some <b>IDispatch</b> purposes that don't matter to our limited version of the VARIANT structure. On the other hand, Variant system functions might not like us to use those bits for unrelated things. We might have to save and restore this bit before calling certain system functions. <br><br></li>
<li>
Keep track of each Variant object in a static array of data structures as suggested at the end of Article 3 for the String class. This is the safest way, but it will be a lot more work to implement and will have a performance cost. </li>
</ol>
<p>
I opted for the easiest choice, method 1, even though it's risky. My code works fine for Visual Basic 4.0, but who can say about future versions? You can check the source file for details, and change the implementation of <b>VariantCreate</b>, <b>IsConstructed</b>, and <b>VariantDestroy</b> if you feel uncomfortable with my choice. </p>
<h4>Variant Operators</h4>
<p>
Just to give you a feel for how operator overloading of Variants works, here's the prefix version of the <b>operator++</b> function:</p>
<pre><code>// Prefix
Variant &amp; Variant::operator++()
{
 &nbsp;&nbsp; switch (vt) {
 &nbsp;&nbsp; case VT_UI1:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++bVal;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; case VT_I2:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++iVal;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; case VT_I4:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++lVal;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; case VT_R4:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++fltVal;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; case VT_R8:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++dblVal;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; case VT_CY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++cyVal.int64;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw DISP_E_TYPEMISMATCH;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return *this;
}
</code></pre>
<h3>Exception Handling Revisited</h3>
<p>
You've seen several examples of functions that throw exceptions. The <b>GetTempFile</b> function in Article 3 and the <b>SearchDirs</b> function in this article throw Win32 error constants as exceptions. But if you look at the <b>operator++</b> example above or at many of the other methods of the <b>String</b>, <b>Variant</b>, and <b>SafeArray</b> classes, you'll see that they throw OLE HRESULT constants. Win32 errors are always positive. HRESULTs can be negative or positive, and contain specific status bits. Mixing these two kinds of errors may seem random, but there's a method in the madness. </p>
<p>
The <b>String</b>, <b>Variant</b>, and <b>SafeArray</b> classes are designed to be used with OLE objects. They happen to also work with the non-object DLLs described in this series. If we were dealing with OLE objects, the <b>ErrorHandler</b> function called in the catch blocks would be raising OLE exceptions and it would be much easier to do so if the errors raised were HRESULT values. The OLE exceptions would be seen in Visual Basic as normal errors, trappable with Basic's <b>On</b> <b>Error</b> statements. This is what you should be doing, and what I originally intended explain before deadline realities set in. </p>
<p>
Unfortunately, you can't generate Basic errors from non-object DLLs. You have to fall back on old-fashioned techniques such as returning error values. The API way of doing this is to use <b>SetLastError</b> to set an error code in the DLL. The DLL client can call <b>GetLastError</b> to get details (although, as mentioned in Article 1, this actually means checking the <b>LastDllError</b> property of the Basic <b>Err</b> object). That's what the <b>ErrorHandler</b> function does in VBUTIL. Here's the code: </p>
<pre><code>void ErrorHandler(Long e)
{
 &nbsp;&nbsp; DWORD err = 0;
 &nbsp;&nbsp; if (e &gt;= 0) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err = (DWORD)e;
 &nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err = HResultToErr(e);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; SetLastError((DWORD)err);
}
</code></pre>
<p>
If the error is an HRESULT, <b>ErrorHandler</b> calls <b>HResultToErr</b> (which is nothing more than a big switch statement) to translate to a Win32 error. It then calls <b>SetLastError</b> to store the error value for any client that wants to check it. Because VBUTIL functions such as <b>SearchDirs</b> are local to this DLL, they won't be used by OLE objects and thus can throw Win32 errors directly to avoid the translation. </p>
<p>
One other point. When you use the OleType static library in your own projects, don’t forget about exceptions. The <b>String</b>, <b>Variant</b>, and <b>SafeArray</b> classes can throw exceptions, and you must be ready to catch them. You have two choices. First, you can make sure you never do anything with a <b>String</b>, <b>Variant</b>, or <b>SafeArray</b> that could throw an exception. This is tough, but you could probably manage it in some projects. Your second, better choice is to catch and handle exceptions. VBUTIL provides a model of one simple technique, but there’s nothing sacred about its <b>ErrorHandler</b> function. You may want to design a better function for handling exceptions, especially if you use the library in OLE servers or controls. </p>
</BODY>
</HTML>
