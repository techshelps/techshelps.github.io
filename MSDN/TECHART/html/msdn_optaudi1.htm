<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Optimizing Audio Performance with DirectX</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_optaudi1"></a>Optimizing Audio Performance with DirectX</h1>
<p>
Mark McCulley<br>
Microsoft Developer Network Technology Group</p>
<p>
August 26, 1996</p>
<h2>Abstract</h2>
<p>
The audio components of Microsoft® DirectX™—DirectSound™ and Direct3DSound™—include powerful tools for games and interactive-media programmers. DirectX takes advantage of sound-accelerator hardware whenever possible to improve performance and minimize CPU usage, but audio can still have a significant impact on system performance. This article describes techniques that will help you use DirectSound and Direct3DSound to minimize the performance impact of audio playback.</p>
<h2>Introduction</h2>
<p>
The Microsoft® DirectX™ wave audio playback services are designed to support the demanding requirements of games and interactive-media applications for Windows® 95 and Windows NT®. DirectSound™ and Direct3DSound™ allow you simultaneously to play multiple wave files and move sound sources within a simulated 3-D space. Whenever possible, DirectX takes advantage of sound-accelerator hardware to improve performance and minimize CPU usage, but this doesn't mean you can go and code your game to blast out a multitude of sounds and move them willy-nilly around your 3-D game space. If you don't pay attention to how you use your computer's sound resources, you'll soon discover that a sizable percentage of your CPU cycles are being spent cranking out those 44.1 kHz 16-bit stereo bird sounds that you added to provide a little background ambiance to your outdoor adventure game.</p>
<p>
The guidelines and techniques in this article will help you optimize audio performance with DirectX. To get the most benefit from this article, you should be familiar at least with the DirectSound application programming interface (API). If you're not yet acquainted with DirectSound, you may want to read a couple other articles first. For a basic introduction to DirectSound, start with "Get World-Class Noise and Total Joy from Your Games with DirectSound and DirectInput" (Library, Periodicals, Microsoft Systems Journal, 1996 Volume 11, February 1996 Number 2). I discuss the technique of streaming (using a relatively small buffer to play a lengthy wave file) in my technical article <a href="msdn_streams3.htm">"Streaming Wave Files with DirectSound."</a></p>
<h2>Tips and Techniques</h2>
<p>
First, a few definitions. Those of you familiar with DirectSound may already be familiar with the following terms:
<ul type=disc>
<li>
<i>Secondary buffers</i> are the buffers applications use to play wave data. Each wave file being played has one secondary buffer, and each of these buffers can have a different format.<br><br></li>
<li>
The <i>primary buffer</i> is the output buffer for DirectSound. Normally, applications do not write wave data directly to the primary buffer. DirectSound mixes the data from secondary buffers into the primary buffer. There is only one primary buffer and its format determines the output format.<br><br></li>
<li>
<i>Static buffers</i> contain a complete sound in memory. They are convenient because you can write the entire sound to the buffer in a single operation. Static buffers can be mixed by sound-card hardware to increase performance.<br><br></li>
<li>
<i>Streaming buffers</i> contain only a portion of a sound and are useful for playing lengthy sounds without using a lot of memory. With streaming buffers, you must periodically write new data into the sound buffer. Streaming buffers cannot be mixed in hardware.</li>
</ul>
<p>
I'll also mention the DirectSound<i> mixer</i>, the component of DirectSound that is responsible for mixing the bits from all of the secondary buffers and performing operations such as volume scaling, panning (left-right balance), frequency shifting, and 3-D processing. While the mixer isn't a discrete component that you have access to through an API (other than by controlling operations like the ones described above), it's the most CPU-intensive part of DirectSound. Many performance issues can be discussed in terms of what's happening with the DirectSound mixer. For all of the visual learners out there, the following diagram illustrates the relationship between the mixer and primary and secondary buffers:</p>
<p>
<img src="optaudi1_1.gif" border=0></p>
<p class=label>
<b>Overly simple diagram showing relationship of buffers to the DirectSound mixer.</b></p>
<p>
The DirectSound development team would throw a fit if they saw this diagram. The mixer is much more sophisticated than this diagram illustrates—I haven't included any components related to hardware mixing, 3-D, or other types of processing.</p>
<p>
Now that I've gotten all of this background information out of the way, I can get on with the useful stuff. Following is a list of techniques that can help you maximize performance with DirectSound:
<ul type=disc>
<li>
Use sounds wisely.<br><br></li>
<li>
Use the same format for secondary and primary buffers.<br><br></li>
<li>
Set the primary buffer format to have the lowest acceptable data rate.<br><br></li>
<li>
Play the primary buffer continuously if you have frequent short intervals of silence.<br><br></li>
<li>
Use hardware mixing as much as possible.<br><br></li>
<li>
Maximize the granularity of control changes.<br><br></li>
<li>
Use deferred processing of 3-D commands.</li>
</ul>
<p>
I explain each of these techniques in the following sections.</p>
<h3>Using Sounds Wisely</h3>
<p>
One of the coolest features of DirectSound is its ability to play and control multiple audio tracks independently. While this is a real boon to sound designers, it doesn't come without cost. The cost is CPU cycles. Each secondary buffer you use consumes CPU cycles. Each processing operation such as frequency scaling consumes additional CPU cycles. Three-dimensional sounds consume more cycles than regular sounds. Get the picture?</p>
<p>
Sit down with your sound designer and discuss the impact of sound use on overall performance. (If you're the programmer <i>and</i> the sound designer, sit down with yourself and mull this over.) Decide which sounds are most important to convey the desired experience to your users. Premix sounds whenever possible to reduce the use of secondary buffers. For example, if you're creating summertime night ambiance with chirping crickets on one track and croaking frogs on another track, combine the two into a single track.</p>
<p>
If you design your application keeping in mind the tradeoffs that you may need to make later when you're tweaking performance, you'll simplify the process considerably. Remember that a relatively small number of properly designed and utilized sounds can go a long way. One of the seminal masterpieces of audio recording, the Beatles' <i>Sgt. Pepper's Lonely Hearts Club Band</i>, was recorded on a four-track tape recorder. By comparison, modern recording studios are equipped to provide at least 48 tracks and can provide a virtually unlimited number of tracks by synchronizing multiple tape decks and using MIDI sequencers. </p>
<h3>Using the Same Format for the Secondary and Primary Buffers</h3>
<p>
The DirectSound mixer converts the data from each secondary buffer into the format of the primary buffer. This is done on the fly as data is mixed into the primary buffer. This format conversion costs CPU cycles. You can eliminate this overhead by ensuring that your secondary buffers (i.e. wave files) and primary buffer have the same format. In fact, due to the way DirectSound does format conversion, you only need to match the sample rate and number of channels—it doesn't matter if there is a difference in sample size (8-bit or 16-bit).</p>
<h3>Reducing Data Rate of Primary Buffer</h3>
<p>
Most of today's sound cards are ISA-bus cards that use DMA (direct memory access) to move sound data from system memory to local buffers. This DMA activity directly affects CPU performance when the processor is forced to wait on a DMA transfer to end before it can access memory. This performance hit is unavoidable on ISA sound cards but is not a problem with the newer 32-bit PCI cards.</p>
<p>
With DirectSound, the impact of DMA overhead is directly related to the data rate of the output, the primary buffer. I've heard anecdotally that if you set the primary format to 44.1 kHz 16-bit stereo on a 90 MHz Pentium, DMA will suck away almost 30 percent of the CPU cycles! DMA overhead could be the biggest single factor affecting the performance of DirectSound. The up side here is that this factor is also very easy to control when you're tweaking performance. Experiment with reducing the data rate requirement by changing the format of the primary buffer. The tradeoff here is obvious: performance versus sound quality. To change the format of the primary buffer, call the <b>lDirectSoundBuffer::SetFormat</b> method. Don't forget that your cooperative level must be set to DSSCL_PRIORITY or DSSCL_EXCLUSIVE to mess around with the primary buffer. </p>
<h3>Playing the Primary Buffer Continuously Through Periodic Silences</h3>
<p>
DMA affects performance in another way. When there are no sounds playing, DirectSound stops the mixer engine and halts DMA activity. If your game has frequent short intervals of silence, the overhead of starting and stopping the mixer each time a sound is played may be worse than the DMA overhead if you kept the mixer active. In this case, you can force the mixer engine to remain active by calling the <b>Play</b> method on the primary buffer. Then the mixer will continue to run (playing silence) even when there are no sounds playing. To resume the default behavior of stopping the mixer engine when there are no sounds playing, call the <b>Stop</b> method on the primary buffer.</p>
<h3>Using Hardware Mixing</h3>
<p>
Most sound cards support some level of hardware mixing if there is a DirectSound driver for the card. The following tips will allow you to make the most of hardware mixing:
<ul type=disc>
<li>
Use static buffers for sounds that you want to be mixed in hardware. DirectSound will attempt to use hardware mixing on static buffers.<br><br></li>
<li>
Create sound buffers first for the sounds you use the most (there's a limit to the number of buffers that can be hardware mixed).<br><br></li>
<li>
At run time, use the <b>IDirectSound::GetCaps</b> method to determine what formats are supported by the sound-accelerator hardware and use only those formats if possible. (Some sound cards can mix only certain formats. For example, the SoundBlaster AWE32 card can mix only mono 16-bit formats.)</li>
</ul>
<p>
To create a static buffer, specify the DSBCAPS_STATIC flag in the <b>dwFlags</b> field of the <b>DSBUFFERDESC</b> structure when you call <b>CreateSoundBuffer</b> to create a secondary buffer. You can also specify the DSBCAPS_LOCHARDWARE flag to force hardware mixing for a buffer; however, <b>CreateSoundBuffer</b> will fail if resources are not available for hardware mixing. </p>
<p>
The<b> IDirectSound::GetCaps</b> method provides a complete description of the acceleration capabilities of a sound card and should prove helpful when assessing performance issues. You can also call <b>GetCaps</b> at launch time and adjust your audio subsystem to best use available hardware resources. Take a look at the <b>DSCAPS</b> structure and flags for <b>DSCAPS.dwFlags</b> in the DirectX documentation to get an idea of exactly what information is available.</p>
<h3>Minimizing Overhead of Control Changes</h3>
<p>
Changing pan, volume, or frequency on a secondary buffer also affects performance. To prevent interruptions in sound output, the DirectSound mixer must mix ahead from 20 to 100 or more milliseconds. Whenever you make a control change, the mixer has to flush its mix-ahead buffer and remix with the changed sound. It's a good idea to minimize the number of control changes you send, especially if you're sending them in streams or in bursts. Try reducing the granularity of routines that call the <b>SetVolume</b>, <b>SetPan</b>, and <b>SetFrequency</b> methods. For example, if you have a frame-sync'd routine that moves a sound from the left to the right speaker, try calling <b>SetPan</b> once per frame instead of twice per frame.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;3-D control changes (orientation, position, velocity, Doppler factor, and so on) also cause the DirectSound mixer to remix its mix-ahead buffer. However, you can group a number of 3-D control changes together and cause only a single remix. Read the following section for details on deferring control changes.</p>
<h3>Using Deferred Processing of 3-D Commands</h3>
<p>
As I said earlier, 3-D sounds are more expensive than regular sounds. That's because on each mixer cycle, additional CPU cycles are spent calculating the 3-D effects. Use as few 3-D sounds as you can, and don't use 3-D on sounds that won't really benefit from the effect. This is another factor you'll have to experiment with when you're tuning your game's performance. To make this task easier, design your application so that it's easy to enable and disable 3-D effects on each sound. You can call the <b>lDirect3DSound::SetMode</b> method with the DS3DMODE_DISABLE flag to disable 3-D processing on any 3-D sound buffer.</p>
<p>
Changes to 3-D sound buffer and listener settings such as position, velocity, and Doppler factor will cause the DirectSound mixer to remix its mix-ahead buffer wasting a few CPU cycles. To minimize the performance impact of changing 3-D settings, you can use a feature that is unique to the 3-D sound component of DirectSound, deferred command processing. To use deferred command processing, specify the DS3D_DEFERRED flag for the <i>dwApply</i> parameter on any of the <b>IDirect3DListener</b> or <b>IDirect3DSoundBuffer</b> methods that change 3-D settings (<b>SetPosition</b>, <b>SetVelocity</b>, and so forth). Make all of the changes for a frame deferred and then call <b>IDirect3DListener::CommitDeferredSettings</b> to execute all of the deferred commands with a single remix of the mix–ahead buffer. I bet you're wishing you had deferred processing for sounds that are not 3-D sounds. Unfortunately, this feature didn't make it into DirectX 3.</p>
<h2>Conclusion</h2>
<p>
I've presented a number of specific techniques for optimizing audio performance with DirectX. The best general advice I can give you is to design your audio subsystem to support performance monitoring and tuning. No doubt you've reserved plenty of time in your schedule to tweak your game's performance! If you've taken performance-tuning into consideration from the beginning, this task will be much easier.</p>
</BODY>
</HTML>
