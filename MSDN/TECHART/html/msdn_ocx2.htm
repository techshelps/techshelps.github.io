<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE Controls: Top Tips</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_ocx2"></a></sup>OLE Controls: Top Tips</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: August 9, 1994</p>
<h2>Abstract</h2>
<p>
This article provides tips for building OLE Controls. Before reading this article, you may find it helpful to review the Scribble tutorial on building OLE servers in the Microsoft® Visual C++™ version 1.5 documentation (in Product Documentation, Languages, Visual C++ 1.5 [16-bit], OLE 2 Classes, Tutorial, Chapter 5). The Circle Sample Tutorial in the Control Development Kit (CDK) is also a good source of basic information on building controls.</p>
<h2>Introduction</h2>
<p>
My initial foray into the development of OLE Controls showed me that OLE Controls are amazingly easy to write, compared to VBXes and other custom controls. However, this new area of custom control development includes pitfalls that I quickly learned to avoid. This article explains the pitfalls and provides tips for building OLE Controls, based on my experience.</p>
<p>
Before we proceed, one note of caution: At the time this article was written, container applications (such as Microsoft® Visual Basic® version 4.0) had not been released. For this reason, I was unable to write a sample application to accompany this article. When container applications become available, I will provide you with some radical custom controls that will illustrate the concepts in this article.</p>
<p>
Here's a quick checklist of tips. I will discuss these in detail in the following sections.
<ol>
<li>
Use TRACE statements at the beginning of functions.<br><br></li>
<li>
Don't assume anything.<br><br></li>
<li>
Don't assume that <i>rcBounds</i> uses the coordinates (0, 0) for the upper-left corner.<br><br></li>
<li>
Use an off-screen buffer<br><br></li>
<li>
Implement <b>OnDrawMetafile</b>.<br><br></li>
<li>
Optimize your drawing code.<br><br></li>
<li>
Use <b>InvalidateControl</b> before drawing on a container.<br><br></li>
<li>
Test with Visual Basic 4.0.<br><br></li>
<li>
Test with lots of other containers.<br><br></li>
<li>
Simplify the control.<br><br></li>
<li>
Put multiple controls together.<br><br></li>
<li>
Make your controls three-dimensional.<br><br></li>
<li>
Make your controls look real.<br><br></li>
<li>
Remember your users.<br><br></li>
<li>
Read the source code to understand and solve problems.<br><br></li>
<li>
Use ambient properties to integrate your control within an application.</li>
</ol>
<h2>Tip 1. Use TRACE Statements</h2>
<p>
OLE servers may appear to be a collection of independent functions that are called at random. However, if you place TRACE statements at the beginning of each function, you can see a pattern in this collection. The TRACE statement also helps you debug your OLE Control when you try your OLE control in a different container and it fails.</p>
<p>
My first OLE Control was painting very slowly, so I put a TRACE statement in my override of the <b>COleControl::OnDraw </b>function. I quickly found out that <b>COleControl::OnDraw</b> was getting called twice. This problem turned out to be a quirk of the alpha container I was using.</p>
<p>
If you're a Windows NT™ user, using the Tools menu to run the Test Container will not display your TRACE output—you must use a debugger instead. If you run the debugger, you will quickly find that you don't have an application to debug, only a dynamic-link library (DLL).</p>
<p>
If you're a Visual C++™ 2.0 user, choose Settings from the Project menu, select the desired settings category on the left, click the Debug tab, and enter the full path to the Test Container application in the Executable for Debug Session box (in my installation, this path was C:\dev\msvc20\cdk32\bin\tstcon32.exe). After you make this change, whenever you click the debug button, Visual C++ will start Test Container. Since Test Container does not have any debug information, you will get a dialog box asking if you want to continue (you do). Note that Test Container will run whenever you choose Execute from the Project menu.</p>
<h2>Tip 2. Don't Assume Anything</h2>
<p>
The Control Development Kit (CDK) <i>Programmer's Guide</i> contains the following note:</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;When painting your control, you should not make assumptions about the state of the device context that is passed as the <i>pdc</i> parameter to your <b>OnDraw</b> function. Because the device context is occasionally supplied by the container application, it will not necessarily be initialized to the default state that a newly created device context would normally have. In particular, you should explicitly select whatever pens, brushes, colors, fonts, and other resources that your drawing code depends upon.</p>
<p>
Don't assume that you have a black pen and a black brush by default—who knows what you might get? The only way to detect an assumption is to place the control in a container that invalidates that assumption. It's a rather tall order for your testing department to build containers that invalidate your assumptions. It's much easier to ensure that you haven't assumed anything. I recommend that you either use a function that explicitly sets up everything the way you need it, or examine each function in your drawing code and determine which device context (DC) settings can affect the output. Either way, it is possible to miss some of the assumptions you've made.</p>
<p>
A good source for information on initial DC settings is Part 4, Chapter 11 of <i>Programming Windows 3.1</i> by Charles Petzold (MSDN Library Archive, Books and Periodicals). The following list identifies some of the items that you should either set or not use at all:
<ul type=disc>
<li>
Mapping mode<br><br></li>
<li>
Window origin<br><br></li>
<li>
Viewport origin<br><br></li>
<li>
Window extents<br><br></li>
<li>
Viewport extents<br><br></li>
<li>
Pen<br><br></li>
<li>
Brush<br><br></li>
<li>
Font<br><br></li>
<li>
Bitmap<br><br></li>
<li>
Current pen position<br><br></li>
<li>
Background mode<br><br></li>
<li>
Background color<br><br></li>
<li>
Text color<br><br></li>
<li>
Drawing mode<br><br></li>
<li>
Stretching mode<br><br></li>
<li>
Polygon filling mode<br><br></li>
<li>
Intercharacter spacing<br><br></li>
<li>
Brush origin<br><br></li>
<li>
Clipping region<br><br></li>
<li>
Bounding rectangle<br><br></li>
<li>
Font mapping<br><br></li>
<li>
Bitmap stretching<br><br></li>
<li>
Text alignment</li>
</ul>
<p>
And for Win32®:
<ul type=disc>
<li>
Arc direction<br><br></li>
<li>
Color adjustment<br><br></li>
<li>
Graphics mode<br><br></li>
<li>
Meta regions<br><br></li>
<li>
Miter limit<br><br></li>
<li>
World transform</li>
</ul>
<p>
Before you write a <b>ResetDC </b>function, note that Microsoft Windows® already has a function by that name. However, <b>ResetDC</b> doesn't set the DC back to its initial state; it is mainly for handling printer issues. So give your function a different name.</p>
<p>
The first DC attribute in the list above is the mapping mode. The container application can pass the <b>COleControl::OnDraw </b>function a pointer to a DC that has changed the mapping mode. This is very important because the other parameters passed to <b>COleControl::OnDraw</b> (<i>rcBounds</i><b> </b>and <i>rcInvalid</i><b>)</b> are in logical units. I decided that the easiest way to deal with this was to convert these parameters to device units and always work from device units, as shown below. I use the suffix "DP" on variable names to remind me that the units are in device points.</p>
<pre><code>void CMyCtrl::OnDraw( CDC* pdc, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcBounds, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcInvalid)
{
 &nbsp; CRect rcBoundsDP(rcBounds) ;
 &nbsp; CRect rcInvalidDP(rcInvalid) ;

 &nbsp; // Convert boundaries to device points.
 &nbsp; pdc-&gt;LPtoDP(&amp;rcBoundsDP) ;
 &nbsp; pdc-&gt;LPtoDP(&amp;rcInvalidDP) ;
 &nbsp; DrawMe(pdc, rcBoundsDP, rcInvalidDP) ;
}

void CMyCtrl::DrawMe( CDC* pdc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcBoundsDP, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcInvalidDP)
{
 &nbsp; SetMapMode(MM_ISOTROPIC) ;
 &nbsp; SetWindowOrg(0,0) ;
 &nbsp; SetWindowExt(1000,1000) ;
 &nbsp; SetViewportOrg(rcBoundsDP.left+rcBounds.Width()/2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBoundsDP.top+rcBounds.Height()/2) ;
 &nbsp; SetViewportExt(rcBoundsDP.Width()/2,-rcBoundsDP.Height()/2) ;
 &nbsp; 
 &nbsp; // Drawing code goes here.

}
</code></pre>
<h2>Tip 3. Don't Assume an Upper-Left Corner of (0, 0) for <i>rcBounds</i></h2>
<p>
Don't assume that the <i>rcBounds</i> parameter passed to <b>COleControl::OnDraw</b> uses the coordinates (0, 0) for the upper-left corner—it may not do so. After years of writing graphics device interface (GDI) code using MM_TEXT and assuming that the upper-left corner was (0, 0), this was a difficult change to make. It is very easy to write code that works great as long as the corner is (0, 0), but fails when <i>rcBounds</i> uses a non-zero.</p>
<p>
In most cases, the program doesn't fail outright, but produces some strange effects. For example, in one case I had set up my mapping mode as follows, where <i>rcBoundsDP</i> is <i>rcBounds</i> converted to device points:</p>
<pre><code>&nbsp;&nbsp;&nbsp;SetMapMode(MM_ISOTROPIC) ;
 &nbsp; SetWindowOrg(0,0) ;
 &nbsp; SetWindowExt(1000,1000) ;
 &nbsp; SetViewportOrg(rcBoundsDP.Width()/2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBoundsDP.Height()/2) ;
 &nbsp; SetViewportExt(rcBoundsDP.Width()/2,-rcBoundsDP.Height()/2) ;
</code></pre>
<p>
I was using this mapping mode to create the following coordinate system:</p>
<p>
<img src="ocx2_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Coordinate system with (0, 0) in the center and positive <i>y</i> axis extending up</b></p>
<p>
However, sometimes the control painted in the upper-left corner of the container's client areas instead of painting inside the control's boundaries. The problem involves setting the viewport origin: When you set the viewport origin to (<i>x</i>, <i>y</i>) and the window origin to (0, 0), the logical point (0, 0) maps to the device point (<i>x</i>, <i>y</i>). Instead, we would like the logical point (0, 0) to map to the center of <i>rcBounds</i>.</p>
<p>
Assume that <i>rcBoundsDP</i> is (0, 0, 50, 200). The center of this is (25, 100), so we would use:</p>
<pre><code>SetViewportOrg(25,100) ;
</code></pre>
<p>
Now, assume that <i>rcBoundsDP</i> is (100, 200, 150, 400). The size of this rectangle is still (25,&nbsp;100), but the center is now (100+25, 200+100), or (125, 300), so I changed the upper-left boundary in the <b>SetViewportOrg</b> call as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;SetMapMode(MM_ISTROPIC) ;
 &nbsp; SetWindowOrg(0,0) ;
 &nbsp; SetWindowExt(1000,1000) ;
 &nbsp; SetViewportOrg(<b>rcBoundsDP.left</b>+rcBounds.Width()/2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>rcBoundsDP.top</b>+rcBounds.Height()/2) ;
 &nbsp; SetViewportExt(rcBoundsDP.Width()/2,-rcBoundsDP.Height()/2) ;
</code></pre>
<h2>Tip 4. Use an Off-Screen Buffer</h2>
<p>
Nigel Thompson sits down the hall from me. One of the things that annoys him (there are billions) is flickering screen updating. As I sit in my office cranking out some code (or hacking away on a Doom monster with a chain saw), a loud string of British expletives will suddenly assault my ears—Nigel has just found another application developed by someone who doesn't know anything about using off-screen buffers.</p>
<p>
It's really simple: If you clear a section of the screen, paint it, then draw on it repeatedly, it will flicker. The trick is to do all of your painting and drawing off-screen, in a memory bitmap, then blt the whole thing to the display at once. This simple fix improves the look and feel of an application dramatically.</p>
<p>
For one of my OLE Controls, my drawing function looked like this:</p>
<pre><code>void CMyCtrl::OnDraw( CDC* pdc, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcBounds, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcInvalid)
{
 &nbsp; DrawMe(pdc, rcBounds) ;
}
</code></pre>
<p>
The <b>CMyCtrl::DrawMe </b>function draws directly on the screen, without using an off-screen buffer. Needless to say, it flickered a little. Instead of waiting for Nigel's wrath, I changed <b>OnDraw </b>as follows:</p>
<pre><code>void CMyCtrl::OnDraw( CDC* pdc, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcBounds, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcInvalid)
{
 &nbsp; DrawMeOffScreen(pdc, rcBounds) ;
}
</code></pre>
<p>
The new <b>CPianoCtrl::DrawMeOffScreen</b> function is a simple wrapper for <b>DrawMe</b> that uses an off-screen buffer. The <b>DrawMeOffScreen</b> code is listed below:</p>
<pre><code>void CMyCtrl::DrawMeOffScreen(CDC* pdc, const CRect&amp; rcBounds)
{

 &nbsp; CDC dcMem;
 &nbsp; CBitmap bitOff;
 &nbsp; CRect rcBoundsDP(rcBounds) ;

 &nbsp; // Convert bounds to device units. 
 &nbsp; pdc-&gt;LPtoDP(&amp;rcBoundsDP) ;

 &nbsp; // The bitmap bounds have 0,0 in the upper-left corner.
 &nbsp; CRect rcBitmapBounds(0,0,rcBoundsDP.Width(),rcBoundsDP.Height()) ;

 &nbsp; // Create a DC that is compatible with the screen.
 &nbsp; dcMem.CreateCompatibleDC(pdc) ;

 &nbsp; // Create a really compatible bitmap.
 &nbsp; bitOff.CreateBitmap(&amp;dcMem, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBitmapBounds.Width(), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBitmapBounds.Height(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;GetDeviceCaps(PLANES),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;GetDeviceCaps(BITSPIXEL),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL) ;

 &nbsp; // Select the bitmap into the memory DC.
 &nbsp; CBitmap* pOldBitmap = dcMem.SelectObject(&amp;bitOff) ;

 &nbsp; // Save the memory DC state, since DrawMe might change it.
 &nbsp; int iSavedDC = dcMem.SaveDC();

 &nbsp; // Draw our control on the memory DC.
 &nbsp; DrawMe(&amp;dcMem, rcBitmapBounds) ;

 &nbsp; // Restore the DC, since DrawMe might have changed mapping modes.
 &nbsp; dcMem.RestoreDC(iSavedDC) ;

 &nbsp; // We don't know what mapping mode pdc is using.
 &nbsp; // BitBlt uses logical coordinates.
 &nbsp; // Easiest thing is to change to MM_TEXT.
 &nbsp; pdc-&gt;SetMapMode(MM_TEXT) ;
 &nbsp; pdc-&gt;SetWindowOrg(0,0) ;
 &nbsp; pdc-&gt;SetViewportOrg(0,0) ;

 &nbsp; // Blt the memory device context to the screen.
 &nbsp; pdc-&gt;BitBlt( rcBoundsDP.left,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBoundsDP.top,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBoundsDP.Width(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBoundsDP.Height(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dcMem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SRCCOPY) ;

 &nbsp; // Clean up.
 &nbsp; dcMem.SelectObject(pOldBitmap) ;
}
</code></pre>
<p>
When developing the drawing code, it is sometimes helpful to watch the code draw. I usually draw directly on the screen until I'm satisfied with the drawing code, then start using an off-screen buffer.</p>
<p>
For more information on flicker-free screen updating, see the <a href="msdn_flicker.htm">"Flicker-Free Displays Using an Off-Screen DC"</a> article in the MSDN Library.</p>
<h2>Tip 5. Implement OnDrawMetafile</h2>
<p>
In the default implementation of <b>COleControl</b>, <b>OnDrawMetafile </b>calls <b>OnDraw</b>. This usually works fine for simple controls. However, for controls that have complicated drawing routines (especially if they change mapping modes or use off-screen bitmaps), it is best to write a separate handler for <b>OnDrawMetafile</b>. To test the metafile with the Test Container, choose Draw Metafile from the Edit menu.</p>
<p>
My first control used an off-screen buffer. It's usually not a good idea to put a bitmap in your metafile because the bitmap won't look very good when the metafile gets stretched. For this reason, I implemented an <b>OnDrawMetafile </b>handler. Instead of calling <b>OnDraw </b>and using an off-screen buffer, <b>OnDrawMetafile</b> simply draws the control directly in the metafile. This will also speed up drawing, although the user will have to watch the metafile build on the screen.</p>
<pre><code>void CMyCtrl::OnDrawMetafile( CDC* pDC, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcBounds)
{
 &nbsp; DrawMe(pDC, rcBounds) ;
}
</code></pre>
<p>
In another control, I set the mapping mode, the viewport origin, and viewport extents in the <b>OnDraw</b> code—these are things that you don't want set in your metafile. I therefore had to implement a separate <b>OnDrawMetafile</b> so these calls would not be present.</p>
<p>
The following are excerpts from my <b>OnDraw</b> code:</p>
<pre><code>&nbsp;&nbsp;&nbsp;// Adjust for different mapping modes.
 &nbsp; CRect rcBoundsDP(rcBounds) ;
 &nbsp; pdc-&gt;LPtoDP(rcBounds) ;

 &nbsp; //Set up the mapping modes.
 &nbsp; pdc-&gt;SetMapMode(MM_ISOTROPIC) ;
 &nbsp; pdc-&gt;SetWindowExt(RADIUS,RADIUS) ;
 &nbsp; pdc-&gt;SetViewportOrg( rcBoundsDP.left+rcBoundsDP.Width()/2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBoundsDP.top+rcBoundsDP.Height()/2) ;
 &nbsp; pdc-&gt;SetViewportExt( rcBoundsDP.Width()/2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -rcBoundsDP.Height()/2) ;

 &nbsp; //Draw.
 &nbsp; CRect rcSquare(RADIUS, RADIUS, -RADIUS, -RADIUS) ;
 &nbsp; CBrush brushFore(COLOR) ;
 &nbsp; CBrush* pOldBrush = pdc-&gt;SelectObject(&amp;brushBack) ;
 &nbsp; CPen* pOldPen = pdc-&gt;SelectStockObject(BLACK_PEN) ;
 &nbsp; pdc-&gt;Ellipse(rcSquare);

 &nbsp; //etc.
</code></pre>
<p>
<b>OnDrawMetafile</b> code:</p>
<pre><code>&nbsp;&nbsp;&nbsp;// Adjust for different mapping modes.
 &nbsp; CRect rcBoundsDP(rcBounds) ;
 &nbsp; pdc-&gt;LPtoDP(rcBounds) ;

 &nbsp; CSize size = rcBoundsDP.Size() ;
 &nbsp; int iShortSide = min(size.cx,size.cy) ;
 &nbsp; CPoint ptCenter(rcBoundsDP.left+size.cx/2,rcBoundsDP.top+size.cy/2) ;   

 &nbsp; // Get the short side and map 2*RADIUS to iShortSide;
 &nbsp; // this way my units should be ISOTROPIC.
 &nbsp; double dbConvert = 2*RADIUS/(double)iShortSide ;
 &nbsp; pdc-&gt;SetWindowOrg( -int(ptCenter.x*dbConvert),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int(ptCenter.y*dbConvert)) ;
 &nbsp; pdc-&gt;SetWindowExt( int(size.cx*dbConvert),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -int(size.cy*dbConvert)) ;

 &nbsp; // etc.
</code></pre>
<h2>Tip 6. Optimize the Drawing Code</h2>
<p>
Optimizing your drawing code speeds the painting of dialogs and saves the user from watching the controls in a dialog paint themselves one by one. Here are two tricks for optimizing drawing operations for your OLE Control: using the <i>rcInvalid</i> parameter for <b>COleControl::Ondraw</b>, and using a bitmap buffer.</p>
<h3>Using the <i>rcInvalid</i> Parameter</h3>
<p>
The <i>rcInvalid</i> parameter to the <b>COleControl::OnDraw</b> function identifies the area of the control that needs to be updated. If your drawing code is time-consuming, redrawing only the invalid area can provide a performance improvement. However, some OLE Control containers don't invalidate controls in the most optimized way. In many cases, the rectangle in <i>rcInvalid</i> may be bigger than it needs to be.</p>
<p>
<i>rcInvalid</i> is very easy to use if you are using an off-screen bitmap buffer. Simply change the parameters to the <b>BitBlt</b> function:</p>
<pre><code>void CMyCtrl::DrawMeOffScreen( CDC* pdc, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcBounds
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Crect&amp; rcInvalid)
{
 &nbsp; CDC dcMem;
 &nbsp; CBitmap bitOff;
 &nbsp; CRect rcBoundsDP(rcBounds) ;

<b> &nbsp; Crect rcInvalidDP(rcInvalid) ;</b>


 &nbsp; // Convert bounds to pixels. 
 &nbsp; pdc-&gt;LPtoDP(&amp;rcBoundsDP) ;

<b> &nbsp; pdc-&gt;LPtoDP(&amp;rcInvalidDP) ;</b>


 &nbsp; // Create a DC that is compatible with the screen.
 &nbsp; dcMem.CreateCompatibleDC(pdc) ;

 &nbsp; // The bitmap bounds have 0,0 in the upper-left corner.
 &nbsp; CRect rcBitmapBounds( 0,0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBoundsDP.Width(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBoundsDP.Height()) ;

 &nbsp; // Create a really compatible bitmap.
 &nbsp; bitOff.CreateBitmap(&amp;dcMem, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBitmapBounds.Width(), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBitmapBounds.Height(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;GetDeviceCaps(PLANES),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;GetDeviceCaps(BITSPIXEL),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL) ;

 &nbsp; // Select the bitmap into the memory DC.
 &nbsp; CBitmap* pOldBitmap = dcMem.SelectObject(&amp;bitOff) ;

 &nbsp; // Save the memory DC state, since DrawMe might change it.
 &nbsp; int iSavedDC = dcMem.SaveDC();

 &nbsp; // Draw our control on the memory DC.
 &nbsp; DrawMe(&amp;dcMem, rcBitmapBounds) ;

 &nbsp; // Restore the DC, since DrawMe might have changed mapping modes.
 &nbsp; dcMem.RestoreDC(iSavedDC) ;

 &nbsp; // We don't know what mapping mode pdc is using.
 &nbsp; // BitBlt uses logical coordinates.
 &nbsp; // Easiest thing is to change to MM_TEXT.
 &nbsp; pdc-&gt;SetMapMode(MM_TEXT) ;
 &nbsp; pdc-&gt;SetWindowOrg(0,0) ;
 &nbsp; pdc-&gt;SetViewportOrg(0,0) ;

 &nbsp; // Blt the memory DC to the screen.
 &nbsp; pdc-&gt;BitBlt( <b>rcInvalidDP.left,</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcInvalidDP.top,</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcInvalidDP.Width(),</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcInvalidDP.Height(),</b>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dcMem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>rcInvalidDP.left - rcBoundsDP.left,</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcInvalidDP.top - rcBoundsDP.top</b>,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SRCCOPY) ;

 &nbsp; // Clean up.
 &nbsp; dcMem.SelectObject(pOldBitmap) ;
}
</code></pre>
<h3>Using a Bitmap Buffer</h3>
<p>
If you draw the control into a bitmap, you simply blt the image onto the screen to satisfy paint requests. If you save this bitmap between <b>OnDraw</b> calls, you may be able to satisfy several paint requests without having to redraw the control with graphics device interface (GDI) calls. Most controls do not change their appearance unless the user clicks or otherwise manipulates them, so many of the <b>OnDraw</b> calls are requests from <b>OnPaint</b> for replacing parts of the screen covered by a window or dialog box. You should make sure that you update the bitmap image when the control's appearance changes.</p>
<pre><code>void CMyCtrl::OnDraw( CDC* pdc, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcBounds, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcInvalid)
{
 &nbsp; CDC dcMem;
 &nbsp; CRect rcBoundsDP(rcBounds) ;
 &nbsp; CRect rcInvalidDP(rcInvalid) ;

 &nbsp; // Convert bounds to pixels. 
 &nbsp; pdc-&gt;LPtoDP(&amp;rcBoundsDP) ;
 &nbsp; pdc-&gt;LPtoDP(&amp;rcInvalidDP) ;

 &nbsp; // Create a DC that is compatible with the screen.
 &nbsp; dcMem.CreateCompatibleDC(pdc) ;

 &nbsp; // The bitmap bounds have 0,0 in the upper-left corner.
 &nbsp; CRect rcBitmapBounds( 0,0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBoundsDP.Width(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBoundsDP.Height()) ;

 &nbsp; // Check if size changed.
 &nbsp; BOOL bIsSizeDifferent = (m_rectLast != rcBitmapBounds) ;

 &nbsp; if ((m_pBitOff == NULL) || (bIsSizeDifferent))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Delete bitmap if it already exists.
 &nbsp;&nbsp;&nbsp;&nbsp; if (m_pBitOff != NULL) delete m_pBitOff ;

 &nbsp;&nbsp;&nbsp;&nbsp; // Create a new bitmap.
 &nbsp;&nbsp;&nbsp;&nbsp; m_pBitOff = new CBitmap ;

 &nbsp;&nbsp;&nbsp;&nbsp; // Create a really compatible bitmap.
 &nbsp;&nbsp;&nbsp;&nbsp; m_pBitOff-&gt;CreateBitmap(&amp;dcMem, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBitmapBounds.Width(), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcBitmapBounds.Height(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;GetDeviceCaps(PLANES),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;GetDeviceCaps(BITSPIXEL),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL) ;

 &nbsp;&nbsp;&nbsp;&nbsp; // Save the size of the bitmap.
 &nbsp;&nbsp;&nbsp;&nbsp; m_rectLast = rcBitmapBounds ;
 &nbsp; }

 &nbsp; // Select the bitmap into the memory DC.
 &nbsp; CBitmap* pOldBitmap = dcMem.SelectObject(m_pBitOff) ;

 &nbsp; if ( (IsModified()) || (bIsSizeDifferent) )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Redraw the image if it has been modified or the size
 &nbsp;&nbsp;&nbsp;&nbsp; // has changed.

 &nbsp;&nbsp;&nbsp;&nbsp; // Save the memory DC state, since DrawMe might change it.
 &nbsp;&nbsp;&nbsp;&nbsp; int iSavedDC = dcMem.SaveDC();

 &nbsp;&nbsp;&nbsp;&nbsp; // Draw our control on the memory DC.
 &nbsp;&nbsp;&nbsp;&nbsp; DrawMe(&amp;dcMem, rcBitmapBounds) ;

 &nbsp;&nbsp;&nbsp;&nbsp; // Restore the DC, since DrawMe might have changed mapping modes.
 &nbsp;&nbsp;&nbsp;&nbsp; dcMem.RestoreDC(iSavedDC) ;
 &nbsp; }

 &nbsp; // We don't know what mapping mode pdc is using.
 &nbsp; // BitBlt uses logical coordinates.
 &nbsp; // Easiest thing is to change to MM_TEXT.
 &nbsp; pdc-&gt;SetMapMode(MM_TEXT) ;
 &nbsp; pdc-&gt;SetWindowOrg(0,0) ;
 &nbsp; pdc-&gt;SetViewportOrg(0,0) ;

 &nbsp; // Blt the memory device context to the screen.
 &nbsp; pdc-&gt;BitBlt( <b>rcInvalidDP.left,</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcInvalidDP.top,</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcInvalidDP.Width(),</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcInvalidDP.Height(),</b>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dcMem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>rcInvalidDP.left - rcBoundsDP.left,</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcInvalidDP.top - rcBoundsDP.top</b>,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SRCCOPY) ;

 &nbsp; // Clean up.
 &nbsp; dcMem.SelectObject(pOldBitmap) ;
}
</code></pre>
<h2>Tip 7. Use InvalidateControl</h2>
<p>
Frequently, a control will need to update itself in response to messages and methods. Messages and methods don't come calling with a convenient DC to draw on. A control should not use:</p>
<pre><code>CClientDC dc(this) ;
OnDraw(&amp;dc, m_rectMyLastRect) ;
</code></pre>
<p>
or similar methods (for example, <b>GetDC</b>).</p>
<p>
The control's container owns the property the control is painting on. Therefore, the control should use <b>COleControl::InvalidateControl</b> to ask permission before drawing on the container.</p>
<p>
When I first read the description of <b>COleControl::InvalidateControl</b>, it reminded me of <b>CWnd::Invalidate</b> and <b>::InvalidateRect</b>. In a standard Windows-based application, these functions change only the invalidated rectangle—the screen is not updated until the next WM_PAINT message. Therefore, if you need to update the client area, you must call <b>UpdateWindow</b> to get the WM_PAINT message on demand. </p>
<p>
However, <b>COleControl::InvalidateControl </b>does not work the same way as <b>::InvalidateRect</b> or <b>CWnd::Invalidate</b>. The only function you need to call is <b>InvalidateControl</b>—not <b>UpdateWindow</b>. My timer handler looked like this:</p>
<pre><code>m_iSecs++ ;
if (m_iSecs == 61)
{
 &nbsp; m_iSecs = 1 ;
 &nbsp; m_bColor = !m_bColor ;
}
InvalidateControl(NULL) ;
</code></pre>
<p>
The source code to <b>COleControl::InvalidateControl </b>can be found in CTLCORE.CPP in the CDK source code directory. It is listed below (notice the <b>SendAdvised</b> calls):</p>
<pre><code>void COleControl::InvalidateControl(LPCRECT lpRect)
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_bInPlaceActive || m_bOpen)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InvalidateRect(lpRect, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendAdvise(OBJECTCODE_VIEWCHANGED);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendAdvise(OBJECTCODE_DATACHANGED);
}
</code></pre>
<h2>Tip 8. Test with Visual Basic 4.0</h2>
<p>
When Visual Basic 4.0 is released, it will become the most popular container for OLE Controls. Both Visual Basic developers and control developers will find OLE Controls very powerful, as easy to use as VBXes, and easier to develop than VBXes, especially with the help of ControlWizard and the Microsoft Foundation Class Library (MFC).</p>
<p>
Because the majority of OLE Control users will be using Visual Basic, you should strive to make your controls work with Visual Basic. If they work with Visual Basic, it is more likely that they will work with MFC when it supports using OLE Controls.</p>
<h2>Tip 9. Test with Lots of Containers</h2>
<p>
Ideally, if your OLE Control works with one container, it should work with others. In reality, however, this is not the case. Developers can create OLE containers and servers that do just about anything. As a result, one OLE container may be very different from another. For example, compare Microsoft Excel with the MFC sample application Contain. Both applications are OLE containers, but you can easily write a server that works with one but not the other. </p>
<p>
The same is true for OLE Controls and their containers. For example, the first control I wrote worked with Test Container, but it did not work with Microsoft Access®. My control was depending on a WM_SIZE message that Microsoft Access never sent. Determining who's at fault—the Test Container, my control, or Microsoft Access—can be very difficult in these situations. However, the more containers you have on your side, the better off you will be. </p>
<p>
Another good test is to insert your OLE Controls into existing OLE containers that do not directly support OLE Controls. Examples of these containers include Microsoft Excel and Microsoft Word. These programs are good OLE containers, but they aren't very good OLE Control containers. What's the difference? Well, the best explanation I've heard is this: To be an OLE Control container, the first thing you need to do is be a great OLE container. Then you need to be a great OLE container that supports inside-out activation and multiple active objects. Finally, you need to implement the event stuff.</p>
<p>
In any event, if you test your control inside Microsoft Excel or Word, your drawing code will be more robust. You might also be able to use your control in these applications without implementing events.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you cannot insert your control into Microsoft Excel or Word, examine the implementation of <b>COleObjectFactoryEx::UpdateRegistry</b>. (For my piano control, ControlWizard implemented this function as <b>CPianoCtrl::CPianoCtrlFactory::UpdateRegistry</b> and placed it in the PIANOCTL.CPP file.) The default implementation calls <b>AfxOleRegisterControlClass</b>. If the sixth parameter of this function is TRUE, the control can be inserted.</p>
<h2>Tip 10. Simplify the Control</h2>
<p>
Is your OLE Control simple to use but not versatile enough, or is it versatile but complicated to use? To phrase it another way: What does your application do, and what does your OLE Control do? This is the dilemma. </p>
<p>
One thing that I really hate about the first spin control I developed was the amount of code I had to write to use it. I had to intercept the mouse events and send them to the proper control. The code wasn't difficult to write, but handling a large number of controls on a dialog box was very tedious. Using the spin controls took so much effort that in many instances I simply left them out. It would have been easier to build a single custom control from an edit control and a spin control, which is what I ended up doing. My combination control was much easier to use, but it was also less versatile—it would only spin numbers.</p>
<p>
I also built a control with a sweeping second hand. As the second hand went around the control, it would fill in the circle. After 15 seconds, the control looked like this:</p>
<p>
<img src="ocx2_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Control with sweeping second hand</b></p>
<p>
When I thought about it, I realized that this control had uses beyond merely tracking time. It was really a pie control—it could be used to track progress during an installation, show the percentage of free space on a drive, or display any other percentage. I pulled out the timer code to make the control more versatile. With proper design, I could still use the control as a sweeping second hand. Visual Basic already has a timer control, which can be programmed to drive my control as the time changes. Since this is easy to do with Visual Basic, I left out the timer code from my control. It pays to test your controls with all containers.</p>
<p>
Even glorified button controls require some thought. For example, I designed the piano control shown in Figure 3 to use in a chord calculator. </p>
<p>
<img src="ocx2_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Piano control</b></p>
<p>
In my original design, if you click the F piano key with the mouse, the key appears pressed (Figure 4).</p>
<p>
<img src="ocx2_4.gif" border=0></p>
<p class=label>
<b>Figure 4. F piano key depressed; left mouse button down</b></p>
<p>
When you release the mouse button, the control sends a <b>NoteOn("F")</b> event and the key stays pressed (Figure 5). </p>
<p>
<img src="ocx2_5.gif" border=0></p>
<p class=label>
<b>Figure 5. F piano key depressed; left mouse button released</b></p>
<p>
When you click the F key a second time with the mouse, the key is released on the mouse button up and sends a <b>NoteOff("F")</b> event. This interface works great for the chord calculator because you want the user to press several piano keys to build a chord. </p>
<p>
However, most of the people who saw the control wanted it to work like a piano. They wanted the key to go down on a mouse button down and up on a mouse button up. For the control developer, this functionality is easier to write and more versatile because the previous chord method can be built from it. However, writing the code to support the chord method can get tedious for developers who use the piano control, so the best solution may be to support two modes for the control: single-key mode and chord-key mode. Having multiple modes is generally preferable to sending out a message for everything under the sun.</p>
<h2>Tip 11. Put Multiple Controls Together</h2>
<p>
Unlike other custom controls, a single OLE Control dynamic-link library (DLL) can contain multiple controls. You can use this capability to your advantage in several ways. Let's say you have an application that teaches people chords. If you want to display chords on a piano keyboard and on a guitar, you can have a OLE Control DLL called CHORDS.OCX that contains a Piano control and a Guitar control.</p>
<p>
You can take advantage of having multiple controls in one DLL in several ways. For example, CHORDS.OCX could contain the following:
<ul type=disc>
<li>
A Piano control and a Guitar control.<br><br></li>
<li>
A Piano control that actually sends musical instrument digital interface (MIDI) note on/off commands.<br><br></li>
<li>
A simple Piano control and a complicated Piano control.<br><br></li>
<li>
A Piano control especially for Visual Basic.</li>
</ul>
<p>
Placing multiple controls in one DLL also reduces the overhead associated with having multiple DLLs supporting each control.</p>
<h2>Tip 12. Make Your Controls 3-D</h2>
<p>
In the next version of the Windows operating system (called Windows 95), all controls appear three-dimensional. Currently, most applications use CTL3D or similar programs to give their controls a 3-D look. You will want to do the same for your OLE Controls so that they will be consistent with other controls when placed in a dialog box. If your control requires Windows 95, you can use the new <b>DrawEdge</b> function provided in Windows 95:</p>
<pre><code>BOOL DrawEdge(
 &nbsp; HDC hdc,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle of device context
 &nbsp; LPRECT lprc,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // address of rectangle coordinates (logical)
 &nbsp; EDGE edgeType,&nbsp;&nbsp;&nbsp;&nbsp; // type of inner and outer edge to draw
 &nbsp; UINT uFlags)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // type of border
</code></pre>
<p>
The <b>DrawEdge</b> function draws a rectangle that appears raised or sunken.</p>
<p>
Until Windows 95 is released, you will need to write your own functions to give your controls a 3-D appearance. Before you start coding, take a look at the <i>User Interface Design Guide</i>. In Chapter 13 ("Visual Design"), read the section on visual communication (dimensionality). (You may also find the "Visual Design of Controls" section useful.) </p>
<p>
Now that you know what the control should look like, read the following articles by Kyle Marsh in the MSDN Library to find out how you can add the 3-D effect:
<ul type=disc>
<li>
"Adding 3-D Effects to Controls" (MSDN Library Archive, Technical Articles)<p class=tl>
This article focuses on using CTL3D, but also includes a nice section on what 3-D controls should look like and a section on creating the 3-D effect. The 3-D drawing code is in the DRAW3D.H and DRAW3D.C files in the CTL3D sample application.</P></li>
<li>
"Creating a Toolbar" (MSDN Library Archive, Technical Articles)<p class=tl>
This article has a short section on drawing 3-D rectangles.</P></li>
</ul>
<p>
Giving arbitrary non-rectangular shapes a 3-D appearance is more difficult. Usually, you need an artist and a palette with lots of grays.</p>
<h2>Tip 13. Make Your Controls Look Real</h2>
<p>
Making your controls look realistic is even better than making them three-dimensional. For example, implement buttons that look like toggle switches; create radio knobs instead of radio buttons. Interesting controls can turn a worthless program into an exciting application. (Well, maybe not.)</p>
<p>
Properly designed custom controls can make an application easier to use. The key phrase is "properly designed." If your control looks or acts completely unlike a standard Windows control, users will get confused. </p>
<p>
When designing realistic-looking controls, you may have to paint the control with scanned images instead of drawing the control with GDI calls. Most OLE Controls can be sized, so you might want to use a different bitmap for each control size. Keep in mind that stretched bitmaps usually look better than squashed bitmaps.</p>
<p>
Your control will probably require 256 colors to look, well, realistic. To get the 256 colors you want, you must use a palette. Palettes are a nightmare to use unless you've read Nigel Thompson's book on animation, which is the best source of information on 256-color bitmaps. Animation is not only for games; you can use the techniques presented in Nigel's book to create animated controls that use several bitmaps to show the change from one state to another. </p>
<h2>Tip 14. Remember Your Users</h2>
<p>
Focus on who your users are so you can anticipate their needs. Your users may include other developers, end-users, and yourself.</p>
<p>
End-users of applications that use OLE Controls are, by definition, OLE Control users. You should take into account how these users will interact with your control. The more your control acts like other Windows controls or controls in the real world, the easier time the user will have.</p>
<p>
Another user group consists of developers who use OLE Controls in their applications. The needs of these developers are different from those of end-users. Developers want an OLE Control that is easy to program and easy to customize for their applications. For example; property sheets that set OLE control features are usually seen only by the developer during design time, and not by the end-user.</p>
<p>
Visual Basic developers, Microsoft Office developers, and MFC developers will eventually all use OLE Controls. Because the programming environments are different, a control that is easy for a C++ programmer to use could challenge a Visual Basic programmer. The reverse could also be true. </p>
<p>
If you are designing OLE controls for your application only—that is, not for general distribution—you don't have to write property sheets or ensure that the OLE control works with MFC. However, if you are planning on selling OLE controls, this extra work will be required.</p>
<h2>Tip 15. Use the Source, Luke</h2>
<p>
Many programmers claim that the best documentation is the source code. I don't know if this is true any longer, considering how complicated software is these days. In any event, Microsoft does ship the source code for MFC and for OLE Control extensions. Use this code to understand and solve problems. For example, I was trying to figure out why my <b>OnDraw</b> function was getting called so many times. By looking through the source code, I was able to determine that <b>OnPaint</b>, <b>DrawContent</b>, and <b>OnDrawMetafile</b> all call <b>OnDraw</b>. </p>
<h2>Tip 16. Use Ambient Properties</h2>
<p>
Your cool button control (which makes funny noises when it's clicked) will look pretty ugly if it displays its caption in Arial in a dialog box full of Times New Roman captions.</p>
<p>
Use ambient properties to integrate your control properly within an application. Ambient properties are properties that a container exposes to its controls. For more information on ambient properties, see the Control Development Kit (CDK) documentation.</p>
<h2>Bibliography</h2>
<p>
Marsh, Kyle. "Adding 3-D Effects to Controls." September 1992 (revised August 1993). (MSDN Library Archive, Technical Articles)</p>
<p>
Marsh, Kyle. "Creating a Toolbar." December 1992. (MSDN Library Archive, Technical Articles)</p>
<p>
Petzold, Charles. <i>Programming Windows 3.1</i>. Redmond, WA: Microsoft Press, 1993. (MSDN Library Archive, Books and Periodicals).</p>
<p>
Rodent, Herman. <a href="msdn_flicker.htm">"Flicker-Free Displays Using an Off-Screen DC."</a> April 1993.</p>
<p>
Rogerson, Dale. <a href="msdn_ocx1.htm">"OLE Controls: State of the Union."</a> October 1994.</p>
<p>
Control Development Kit (CDK) documentation.</p>
</BODY>
</HTML>
