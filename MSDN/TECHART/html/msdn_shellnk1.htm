<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Shell Links in Windows 95</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_shellnk1"></a>Using Shell Links in Windows 95</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
October 1994<br>
Revised: June 1995 (Added "Using MFC" section; added information about per-user profiles; changed second parameter of <b>IPersistFile::Save</b> method from STGM_READ to TRUE)<br>
Revised: July 1996 (Updated section covering creation of shortcuts to support per-user profiles)<br>
Revised: October 1996 (Updated the sample application and its build information)</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3006">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the SHORTCUT sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
The next version of the Microsoft® Windows® operating system, Windows 95, has a new shell and a way to create shell links (also known as shortcuts) to items or objects in the shell. Shell links provide an easy method for users to access and manipulate objects regardless of the location and name of the object. For example, if a shell link is created to a text file, and if the original text file is subsequently renamed, the original shell link is updated by the shell without needing user intervention (that is, the user does not have to recreate the shell link). Creating a shell link from the standpoint of the end user is as easy as clicking the mouse; however, creating such a link from the standpoint of an application takes a bit more work. This is the first of two articles covering shell links. This article contains background information about shell links and discusses the method used to create and resolve them using the built-in menus from the shell and programmatically. The second article, <a href="msdn_shellnk2.htm">"The IShellLink Interface,"</a> covers some of the underpinnings the system has put in place to implement shell links: the <b>IShellLink</b> interface and how the shell preserves links.</p>
<h2>What Are Shell Links?</h2>
<p>
Shell links (also known as shortcuts) are a convenient way to reference objects within the shell name space (the hierarchical structure of objects in the Microsoft® Windows® 95 shell) without having to keep track of the name and the location of the original object. Shell links are referred to as shortcuts in the context menu (the menu that pops up when you click the object with the right mouse button) of shell objects; however, they are implemented internally via the <b>IShellLink</b> interface. As a result, when I refer to shell links I am also referring to shortcuts: They are the same thing. There are many objects to which you can create shell links. Some examples of objects to which you can create shell links within the shell name space are:
<ul type=disc>
<li>
Files<br><br></li>
<li>
Directories<br><br></li>
<li>
Control Panel<br><br></li>
<li>
Printers<br><br></li>
<li>
Mail<br><br></li>
<li>
Your application</li>
</ul>
<p>
When you install the beta release of Windows 95, a shell link is automatically created and placed on the desktop for the README file that comes with the system (as shown in Figure 1). You know you are looking at a shell link by the small arrow in the lower-left corner of the icon. Clicking this icon once brings up WordPad with the Windows 95 Beta Release Notes initially loaded.</p>
<p>
<img src="shellnk1_1.gif" border=0></p>
<p class=label>
<b>Figure 1. A shell link</b></p>
<h2>Some Benefits of Shell Links</h2>
<p>
One benefit of shell links is the inherent transparency to the user of the original object's name and location. For example, if you were to create a shell link for a file and were to place that shell link on the desktop, then when the user clicked that file, the file would be activated (the default action would occur for that file). So, if the file were a Microsoft Word document, clicking the shell link would execute Word with the file specified as the current working document. When you create a shell link to one of the objects that resides in the shell name space, you are creating a reference to that item within the context of the shell name space. Although I suspect that the most common shell objects for which end users and application developers can create shell links are files and folders, you can also create shell links to printers or to Control Panel. If you create a shell link to a printer and then change the network location for the printer, the link will still work (you will still be able to print to that printer using the link) and the user would never know that the server has changed: The location is transparent to the user.</p>
<p>
Shell links are also useful for installation applications. The Windows 95 Setup program uses shell links itself when it places the shell link to its README on the desktop. Another place to use shell links is for a "last opened document." For example, let's say that you have a multiple-document interface (MDI) application and you want to keep track of the last document that was opened for the user. One way to do this is to create a shell link for the user, who can subsequently click that shell link whenever she wants to run your application again in the context of that document.</p>
<h2>How an End User Creates a Shell Link</h2>
<p>
The shell has a built-in mechanism for creating shell links via the right-click context menu it provides for objects within the shell name space. End users may use this mechanism to create shell links of their own. To create a shell link and put it on the desktop, for instance, the user performs the following steps
<ol>
<li>
Find the object (folder, printer, program, computer) that is the target of the shell link.<br><br></li>
<li>
Click the object with the right mouse button and click Create Shortcut on the context menu (or click Create Shortcut on the File menu in Explorer as shown in Figure 2). This creates the shell link.<p>
<img src="shellnk1_2.gif" border=0></P><p class=label>
<b>Figure 2. Create Shortcut menu item</b>
</li>
<li>
Drag the shell link to the desktop and drop it to place the shell link on the desktop.</li>
</ol>
<h2>Some Background About IShellLink</h2>
<p>
Okay, so the shell has this functionality built in. But what if you are writing your own application and want to be able to programmatically create a shell link for the end user? Can this be done?</p>
<p>
Of course it can. Besides, would I even ask the question if the answer were no?</p>
<p>
Because shell links are implemented via the <b>IShellLink</b> interface, it is helpful to understand some of the basic concepts of OLE when programming a shell link; however, it is by no means mandatory to be an OLE guru to do so. If it were, I never would have been able to create a link. The most important area you should read up on to understand and use shell links is the Component Object Model. Reading the first four chapters of<i> Inside OLE </i>by Kraig Brockschmidt (MSDN Library, Books) should give you sufficient background.</p>
<p>
For those of you, though, who aren't going to read those first four chapters (I know who you are, and you should be ashamed of yourselves!), I will give you a <i>very</i> brief overview of the Component Object Model.</p>
<h3>Component Object Model</h3>
<p>
The Component Object Model is a specification that describes the process of communicating through interfaces, acquiring access to interfaces through the <b>QueryInterface</b> method, determining pointer lifetime through reference counting, and reusing objects by extending them.</p>
<p>
An object is an item in the system that exposes interfaces (groups of related functions) to manipulate the data or properties of the object. It is created directly or indirectly by calling the <b>CoCreateInstance</b> function, which creates a new instance of the object and returns a pointer to the interface for the object. When two objects within the system want to communicate with one another, they call functions within the object's interface via a pointer to the interface. This interface pointer is the one that was returned by the call to <b>CoCreateInstance</b>. A typical time when two objects may want to communicate with each other is during a drag-and-drop operation. During this operation, the object to be dropped on the other object calls into the other object's interface to request acceptance of the drop.</p>
<p>
All interfaces used in the Component Object Model, including the one we will use to manipulate shell links (<b>IShellLink</b>), support the base interface, <b>IUnknown</b>. The <b>IUnknown </b>interface supports three methods (or functions): 
<ul type=disc>
<li>
<b>QueryInterface:</b> Determines whether a specific interface is supported for the object.<br><br></li>
<li>
<b>AddRef:</b> Increments the reference count on an interface.<br><br></li>
<li>
<b>Release:</b> Decrements the reference count on an interface. Once an interface's reference count goes to zero, the object deletes itself and the pointer to that interface is no longer valid. If the reference count on all of an object's interfaces is zero, the object can be freed because there are no longer any pointers to the object. </li>
</ul>
<h2>The Tools I Used to Create a Shell Link</h2>
<p>
The sample that accompanies this technical article, SHORTCUT.EXE, is a Microsoft Foundation Class Library (MFC) application that was created with Microsoft Visual C++® version 4.2&nbsp; and the Win32 SDK. </p>
<h2>Initialization</h2>
<p>
There are some OLE basics that you need to do to create and resolve your shell links. The first thing that your application must do upon startup is to initialize the component object library with a call to <b>CoInitialize</b> or<b> OleInitialize</b>. I put this call in my sample code, SHORTCUT.CPP, in my <b>InitInstance</b> handler before I called anything else. Each call to <b>CoInitializ</b>e needs to be balanced with a call to <b>CoUninitialize</b>. <b>CoUninitialize</b> should be called when an application shuts down. It ensures that the application won't quit until it has received all of its pending messages. I put my call to <b>CoUninitialize</b> in my <b>ExitInstance</b> handler.</p>
<h2>Creating a Shell Link to a File</h2>
<p>
To demonstrate how to create a shell link, I created a very simple MFC application that allows the user to choose a file from the current directory to which a shell link is to be created. For example, if you want to create a shell link to a text file named README, you would choose README.TXT from the list. When the user chooses the Create Shortcut menu item, a dialog box displays a list of the files in the current directory (Figure 3).</p>
<p>
<img src="shellnk1_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Dialog box for creating a shortcut in the SHORTCUT sample</b></p>
<p>
The following code makes use of the handy-dandy<b> DlgDirList</b> function to fill my list box in the dialog box.</p>
<pre><code>BOOL CreateShortCut::OnInitDialog() 
{
  DWORD cchCurDir;
  char szCurDir[MAX_PATH];

  CDialog::OnInitDialog();
  
  // Initialize the list box by filling it with files from
  // the current directory.
  GetCurrentDirectory(cchCurDir, szCurDir);
  DlgDirList(szCurDir, ID_LBOX, 0, DDL_READWRITE);
  
  return TRUE;
}
</code></pre>
<p>
After the user chooses a file from the list and clicks the OK button, a check is made to determine whether the link is targeted to the desktop or to the current directory. The user indicates whether to target the shell link to the desktop by checking the "Place shortcut on desktop" option in the dialog box. If it is targeted to the desktop, its default location will be in a subdirectory (called DESKTOP) of the current directory that contains Windows 95. This subdirectory is hidden; you can find it by opening a command prompt and typing <b>attrib</b> <b>desktop</b>.</p>
<p>
If your system is configured to use a different profile per user, the location of the shortcut is different. You can set up a different profile per user by using the Password applet in Control Panel. Click the User Profiles tab, and then check the "Include desktop icons and Network Neighborhood contents in user settings" option. This will cause the desktop icons (and your desktop shortcut) to be stored in the Desktop subdirectory in the registration database under HKEY_CURRENT_USER\Software\Microsoft\Windows\Current Version\Explorer\Shell Folders. The <b>Desktop</b> key will contain the fully qualified path to the desktop icons. So, for example, if I set up my computer to support per-user profiles, the <b>Desktop</b> key will be under C:\WINDOWS\PROFILES\NANCYCL\DESKTOP.</p>
<p>
The link name is completed by retrieving the selected file via a call to <b>DlgDirSelect</b>, stripping off the file extension, and replacing it with the .LNK file extension.</p>
<pre><code>void CreateShortCut::OnOK() 
{
  char szFileSel[MAX_PATH];
  char szFile[MAX_PATH];
  char szDesc[MAX_PATH];
  char szLink[MAX_PATH];
  DWORD cchCurDir;
  char* pDot;

  // First get the path to the link.
  // Should this shortcut be put on the desktop?
  if (IsDlgButtonChecked(IDC_CHECK1))
  {
 &nbsp;&nbsp; // Yes. Get the directory for Windows Desktop. This is
 &nbsp;&nbsp; // stored in the Registry under HKEY_CURRENT_USER\Software\
 &nbsp;&nbsp; // Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\Desktop.
 &nbsp;&nbsp; HKEY hCU;
 &nbsp;&nbsp; DWORD lpType;
 &nbsp;&nbsp; ULONG ulSize = MAX_PATH;

 &nbsp;&nbsp; if (RegOpenKeyEx(HKEY_CURRENT_USER, 
 &nbsp;&nbsp;&nbsp;&nbsp; "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", 
 &nbsp;&nbsp;&nbsp;&nbsp; 0,KEY_QUERY_VALUE,
 &nbsp;&nbsp;&nbsp;&nbsp; &amp;hCU) == ERROR_SUCCESS)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; RegQueryValueEx( hCU,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Desktop",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;lpType,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned char *)&amp;szLink,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;ulSize);

 &nbsp;&nbsp;&nbsp;&nbsp; RegCloseKey(hCU);
 &nbsp;&nbsp; }
  }
else
 &nbsp;&nbsp; // Get the current directory.
 &nbsp;&nbsp; GetCurrentDirectory(cchCurDir, szLink);

  // Get the selected item in the list box.
  DlgDirSelect(szFile, ID_LBOX);

  // Get the description.
  lstrcpy(szDesc, "Shortcut to ");
  lstrcat(szDesc, strupr(szFile));

  // Add the forward slash for the path.
  lstrcat (szLink, "\\");

  // Add the file name.
  lstrcat (szLink, strupr(szFile));

  // Strip off the extension, if any.
  if (pDot = strstr(szLink, "."))
 &nbsp;&nbsp; *pDot = (char)NULL;

  // Add in the .LNK extension.
  lstrcat (szLink, ".LNK");

  // Get the path to the target.
  GetCurrentDirectory(cchCurDir, szFileSel);
  lstrcat(szFileSel, "\\");
  lstrcat(szFileSel, strupr(szFile));

  // Make call to CreateShortcut() here...
  CreateIt(szFileSel, szLink, szDesc);

  // Call the default handler.
  CDialog::OnOK();
}
</code></pre>
<p>
Next, we get down to the "real" work of creating the shell link. The <b>CreateIt</b> function actually does the work and takes three parameters: 
<ul type=disc>
<li>
<i>pszShortcutFile:</i> The file that you want the shell link to point to.<br><br></li>
<li>
<i>pszLink</i>: The shell link that you are creating with a .LNK extension.<br><br></li>
<li>
<i>pszDesc</i>: The description of the file. This is the string "Shortcut to &lt;<i>filename</i>&gt;", where <i>filename</i> is the name of the link target.</li>
</ul>
<p>
Because this function makes a call to <b>CoCreateInstance</b>, it is assumed that <b>CoInitialize</b> has already been called. As you can see by the following code, this function uses both the <b>IPersistFile</b> interface for the actual saving of the shell link in the system and the <b>IShellLink</b> interface for storing the path and description information of the link target.</p>
<pre><code>HRESULT CreateShortCut::CreateIt(LPCSTR pszShortcutFile, LPSTR pszLink, 
  LPSTR pszDesc)
{
 &nbsp;&nbsp; HRESULT hres;
 &nbsp;&nbsp; IShellLink* psl;

 &nbsp;&nbsp; // Get a pointer to the IShellLink interface.
 &nbsp;&nbsp; hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IShellLink, &amp;psl);
 &nbsp;&nbsp; if (SUCCEEDED(hres))
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPersistFile* ppf;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Query IShellLink for the IPersistFile interface for 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // saving the shell link in persistent storage.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hres = psl-&gt;QueryInterface(IID_IPersistFile, &amp;ppf);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hres))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD wsz[MAX_PATH];

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set the path to the shell link target.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hres = psl-&gt;SetPath(pszShortcutFile);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!SUCCEEDED(hres))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox("SetPath failed!");

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set the description of the shell link.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hres = psl-&gt;SetDescription(pszDesc);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!SUCCEEDED(hres))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox("SetDescription failed!");

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ensure string is ANSI.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MultiByteToWideChar(CP_ACP, 0, pszLink, -1, wsz, MAX_PATH);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Save the link via the IPersistFile::Save method.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hres = ppf-&gt;Save(wsz, TRUE);
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Release pointer to IPersistFile.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ppf-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Release pointer to IShellLink.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psl-&gt;Release();
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return hres;
}
</code></pre>
<p>
One thing to bear in mind is that if you create a shell link to another shell link, the system will simply copy the shell link—it won't create a new shell link. This is important if you are assuming that the shell links will remain independent of each other.</p>
<h2>Resolving a Shell Link</h2>
<p>
Once you have created the shell link, you may need to gain access to and manipulate that link programmatically. This is referred to as "resolving" the shortcut. I added a function to my sample that demonstrates how you can resolve a shell link. Being ever so creative, I decided to use the same type of dialog box that I used for creating the shell link. As such, I used almost exactly the same code to fill the dialog box with the names of the files in the current directory and prompt the user for the link to resolve. The only difference was a simple check to ensure that the user actually picked a .LNK file.</p>
<pre><code>void ResolveShortCut::OnOK() 
{
  char szFile[MAX_PATH];
  char szPath[MAX_PATH];

  // Get the current directory.
  GetCurrentDirectory(MAX_PATH, szPath);

  // Get the selected item in the list box.
  DlgDirSelect( szFile, IDC_LIST1);

  // Find out if it is a .LNK file or not.
  if (strstr(szFile, ".lnk") != NULL)
 &nbsp;&nbsp; // Make call to ResolveShortcut here.
 &nbsp;&nbsp; ResolveIt(m_hWnd, szFile, szPath );

  CDialog::OnOK();
}
</code></pre>
<p>
This shortcut resolving function takes three parameters:
<ul type=disc>
<li>
<i>hwnd</i>: The handle to the current focus window. We need this in case the shell needs to display a message box prompting the user to do something. This box will be displayed if the user needs to insert a floppy disk, if the link is on unshared media, or if there are network problems during the resolution of the shell link.<br><br></li>
<li>
<i>SzShortcutFile</i>: The fully qualified path to the shell link.<br><br></li>
<li>
<i>CchPath</i>: The size of the return buffer.</li>
</ul>
<p>
As with my function that created the shell link, this function calls <b>CoCreateInstance</b> and assumes that <b>CoInitialize</b> has been called already. Notice that the code below needs to call into the <b>IPersistFile</b> interface. This interface is implemented by the <b>IShellLink </b>object to store link information. To get the path information that I query later in the code, I need to have the link information loaded first. Failing to load the link information would cause my calls to <b>GetPath</b> and <b>GetDescription</b> to fail.</p>
<pre><code>HRESULT ResolveShortCut::ResolveIt(HWND hwnd, LPCSTR pszShortcutFile, LPSTR 
  pszPath)
{
  HRESULT hres;
  IShellLink* psl;
  char szGotPath[MAX_PATH];
  char szDescription[MAX_PATH];
  WIN32_FIND_DATA wfd;

  *pszPath = 0;&nbsp;&nbsp; // assume failure

  // Get a pointer to the IShellLink interface.
  hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IShellLink, &amp;psl);
  if (SUCCEEDED(hres))
  {
 &nbsp;&nbsp; IPersistFile* ppf;

 &nbsp;&nbsp; // Get a pointer to the IPersistFile interface.
 &nbsp;&nbsp; hres = psl-&gt;QueryInterface(IID_IPersistFile, &amp;ppf);
 &nbsp;&nbsp; if (SUCCEEDED(hres))
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; WORD wsz[MAX_PATH];

 &nbsp;&nbsp;&nbsp;&nbsp; // Ensure string is Unicode.
 &nbsp;&nbsp;&nbsp;&nbsp; MultiByteToWideChar(CP_ACP, 0, pszShortcutFile, -1, wsz,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX_PATH);

 &nbsp;&nbsp;&nbsp; // Load the shell link.
 &nbsp;&nbsp;&nbsp; hres = ppf-&gt;Load(wsz, STGM_READ);
 &nbsp;&nbsp;&nbsp; if (SUCCEEDED(hres))
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Resolve the link.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hres = psl-&gt;Resolve(hwnd, SLR_ANY_MATCH);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hres))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(szGotPath, pszShortcutFile);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the path to the link target.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hres = psl-&gt;GetPath(szGotPath, MAX_PATH, (WIN32_FIND_DATA *)&amp;wfd, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SLGP_SHORTPATH );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!SUCCEEDED(hres)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox("GetPath failed!");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the description of the target.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hres = psl-&gt;GetDescription(szDescription, MAX_PATH);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!SUCCEEDED(hres))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox("GetDescription failed!");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; // Release pointer to IPersistFile interface.
 &nbsp;&nbsp;&nbsp;&nbsp; ppf-&gt;Release();
 &nbsp;&nbsp; }
 &nbsp;&nbsp; // Release pointer to IShellLink interface.
 &nbsp;&nbsp; psl-&gt;Release();
  }
  return hres;
}
</code></pre>
<h2>Creating a Link to Something Other Than a File</h2>
<p>
The above code demonstrates how you can programmatically create a link to a file, but it does not cover the steps that you must take to create a link to something that does not have a filename, such as a printer or Control Panel. From the standpoint of creating the shell link, the major difference lies in the fact that rather than setting the path to the link, you will instead be setting the identification list (ID List) to the printer. This is done by calling the <b>IShellLink::SetIDList</b> method and providing a pointer to an ID List (<i>pidl</i>).</p>
<p>
I know what you are thinking. "What the heck is an ID List?"</p>
<p>
All objects within the shell name space have an item identifier, known as an Item ID. This identifier is a variable-length byte stream containing information that identifies the object within a folder. The shell often concatenates Item IDs together to form a list of IDs, known as ID Lists. These lists may contain one or many Item IDs and are NULL terminated.</p>
<h2>Using MFC</h2>
<p>
If you plan to use the <b>CreateIt</b> function from the SHORTCUT sample in your MFC-based application, you may run into problems with the conversion from multibyte to wide characters. If you do, search for "Technical Note 49: MFC/OLE MBCS to Unicode Translation Layer (MFCANS32)" in the MSDN Library. The MFCANS32 DLL provides ANSI interfaces to 32-bit OLE, which is primarily Unicode. This technical note will show you what you need to do if you experience this problem.</p>
<h2>Summary</h2>
<p>
This article gives you the bare-bones information you need to create and resolve shell links within an application. It is by no means an all-encompassing work, though. If you would like to learn more about the underpinnings of shell links, my advice is to read the next article in the series on shell links, <a href="msdn_shellnk2.htm">"The IShellLink Interface."</a></p>
</BODY>
</HTML>
