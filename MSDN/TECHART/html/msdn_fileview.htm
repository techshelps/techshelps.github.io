<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating File Viewers in Windows 95</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_fileview"></a>Creating File Viewers in Windows 95</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
January 1995</p>
<h2>Abstract</h2>
<p>
File viewers allow the user to view the contents of a file quickly without having to run the original application that created the file. A file viewer provides the user interface for viewing a file, including menu items, a toolbar, and a status bar. A file viewer can also implement additional functionality for further shell integration. This article covers the following topics associated with file viewers:
<ul type=disc>
<li>
What are file viewers<br><br></li>
<li>
How file viewers work<br><br></li>
<li>
Registering file viewers with the system<br><br></li>
<li>
File viewer interfaces<br><br></li>
<li>
The basic steps used to create a file viewer</li>
</ul>
<h2>What Are File Viewers?</h2>
<p>
Let's say that you created a bunch of Microsoft® Word documents on a day that your imagination was impaired, and the files are named STUFF1.DOC, STUFF2.DOC, STUFF3.DOC—you get the picture. Now let's say that you want to give those files to someone who doesn't use Word. You can save those documents as .TXT files or, if that person happens to be running the Microsoft Windows® 95 operating system, that person can instead use a file viewer to view the contents of the files.</p>
<p>
The Windows 95 shell has a new feature called Quick View that allows the user to quickly view the contents of a file without having to run the full application that created it and without even requiring the presence of that application. To view file contents, the user selects a file and chooses the Quick View menu item from the context menu of that selection, as shown in Figure 1 (or, the user can select Quick View from the File menu).</p>
<p>
<img src="fileview_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The context menu containing the Quick View option</b></p>
<p>
Now before you go running off and trying this on your computer, be aware that if no file viewer exists for a particular file type, the Quick View option will not be displayed in the context menu for that file object. Windows 95 provides a default file viewer for many common file types, such as text files.</p>
<p>
When a file viewer is created, it associates itself with file classes and extensions via the system registry. When the user clicks the right mouse button for an object in the file system, the shell checks the registry for a viewer for the object based upon the file class and extension. If no registry entry exists, the Quick View option is not displayed in the context menu.</p>
<p>
A file viewer provides the user interface (menu items, toolbar, status bar, and so on) for viewing a file. The screen shot in Figure 2 shows the default file viewer that the system provides.</p>
<p>
<img src="fileview_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The default file viewer</b></p>
<h2>How File Viewers Work</h2>
<p>
In the above explanation about the Quick View option, I mentioned file classes. File viewers are OLE component objects implemented inside an in-process server DLL (dynamic-link library). When a user clicks the Quick View option, the shell uses the class identifier (an OLE CLSID value) of the file to determine which viewer to use if the file is an OLE compound file. If the file isn't a compound file, the shell uses the extension of the file to determine which viewer to use.</p>
<p>
Since a file viewer is an OLE component object, you can add interfaces and additional functionality to support new features. For example, a file viewer can act as an OLE container application and can perform in-place activation of embedded objects inside the file being viewed. Another file viewer could be beefed up to allow the user to make a selection in a document and copy the selection to the Clipboard or source it in a drag-drop operation.</p>
<h3>QUIKVIEW.EXE</h3>
<p>
The shell doesn't directly call a file viewer; rather, it starts an instance of a program called QUIKVIEW.EXE for each file to be viewed. QUIKVIEW is a small program that directs the system to create a process and a message queue for each file viewer. It then associates a path with a file viewer, instantiates the file viewer object, and instructs the file viewer to load and display the file. QUIKVIEW turns over execution of the process to the file viewer until the file viewer shuts down.</p>
<p>
QUIKVIEW uses three methods to determine a file's type so it can associate the file with the appropriate file viewer:
<ul type=disc>
<li>
If the file is an OLE compound file, it contains a class identifier that identifies the file's type. QUIKVIEW uses this CLSID to determine the type.<br><br></li>
<li>
If the file is not an OLE compound file, but it has a consistent and fairly uncommon byte pattern at the beginning of the file, the application that creates such files can register the byte pattern in the registry and associate the pattern with a class identifier. This class identifier will determine the file type.<br><br></li>
<li>
If the file is not an OLE compound file, or if it is but lacks a class identifier, the filename extension can be used to identify the file type. This is the least accurate method in determining file type, because the user may use the same extension for different types of files.</li>
</ul>
<p>
If there is no extension or if there are no file viewers registered for that extension, the Quick View operation fails and QUIKVIEW displays a message that reads "There are no viewers registered for &lt;type of file&gt; files."</p>
<p>
If there is more than one file viewer possible for a file type listed in the registry, QUIKVIEW displays a dialog box containing a message that reads "Searching for a viewer to display or print the &lt;human-readable document type&gt; in &lt;filename&gt;. Press Cancel to stop the search." If the document type is known, the message reads "Searching for a viewer to display or print &lt;filename&gt;. Press Cancel to stop the search."</p>
<h2>Registering File Viewers with the System</h2>
<p>
Since the shell determines which file viewer to call via a check in the registry, each file viewer must register certain information if it wants to be called. The best time to do this registration is during the installation of the file viewer. A file viewer can register itself for more than one file type if it can handle multiple file formats, but if a file type has more than one registered file viewer, the shell calls the most recently registered viewer for that file type when the user selects Quick View.</p>
<h3>Structure of Registry Entries</h3>
<p>
The following registry structure is required for QUIKVIEW to associate a class identifier or extension with the class identifier of a file viewer:</p>
<pre><code>HKEY_CLASSES_ROOT
 &nbsp;&nbsp; \QuickView
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&lt;extension&gt; = &lt;human-readable document type&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \{&lt;CLSID&gt;} = &lt;human-readable viewer name&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \{&lt;CLSID&gt;} = &lt;human-readable viewer name&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \{&lt;CLSID&gt;} = &lt;human-readable viewer name&gt;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...[More extension entries for additional file types]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...

 &nbsp;&nbsp; \CLSID
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \{&lt;CLSID&gt;} = &lt;human-readable viewer name&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \InprocServer32 = &lt;full path to FileViewer DLL&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ThreadingModel = &lt;Model&gt;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...[More class IDs for file viewers and other object servers]
</code></pre>
<p>
In this registry structure:
<ul type=disc>
<li>
HKEY_CLASSES_ROOT is the root of the registry.<br><br></li>
<li>
The <b>QuickView</b> key is the top-level key where the associations are stored. It can have any number of extension subkeys, each representing a registered file type. Each extension subkey can have one or more class identifier subkeys, each representing a registered file viewer object. The most recently registered file viewer appears first in the list of class identifier subkeys, and is the first one found when QUIKVIEW enumerates the registered file viewers.<br><br></li>
<li>
The <b>CLSID</b> key is a 16-byte OLE class identifier spelled out in hexadecimal digits in the form of 12345678-1234-1234-1234-1234567890AB, with the hyphens included. All class identifiers are surrounded by curly braces ( { } ) when stored in the registry. The file viewer class identifiers should always differ from the file type class identifier because the application that created the file may already be using that class identifier to identify the application as a compound document server.<br><br></li>
<li>
The &lt;<i>extension</i>&gt; key is a three-character file extension with the period (as is consistent with current practice), as in ".WRI".<br><br></li>
<li>
The &lt;<i>human-readable document type</i>&gt; key is a string that describes the file type associated with the class identifier or extension that can be displayed to the user. A file viewer can change this when that file viewer is installed so the name always reflects the preferred viewer. For example, this string might be "Windows Write Document".<br><br></li>
<li>
The &lt;<i>human-readable viewer name</i>&gt; key is a string that describes the vendor of the file viewer as it might be displayed in an About box, such as "Company ABC Write Document Viewer".<br><br></li>
<li>
The &lt;<i>Model</i>&gt; subkey specifies the threading model as it relates to OLE objects.</li>
</ul>
<p>
Each class identifier stored under the file extension subkeys must correspond to an entry of that same class identifier stored under the top-level key, called <b>CLSID</b>. This is the standard location for storing information for OLE object servers. For file viewers, there must be an <b>InprocServer32</b> subkey under the file viewer's class identifier key. The value of the <b>InprocServer32</b> subkey is the full path to the file viewer DLL. <b>InprocServer32</b> is a standard OLE subkey where the path to a component object server is stored. Using this subkey allows the QUIKVIEW program to use standard OLE APIs (application programming interfaces) to access and create objects from file viewer servers.</p>
<h3>Threading Models</h3>
<p>
Under Windows 95, OLE is apartment threaded. "Apartment" is essentially just a way of describing a thread with a message queue that supports OLE/COM (Component Object Model) objects. Objects within an apartment are reentrant in only the traditional Windows sense, identical to single-threaded OLE. Operations that yield to the message queue can cause further messages to be sent to any objects within the apartment. Apartment model threading simply allows there to be more than one "apartment" where previously there was only one: the main application thread. By default, a single-threaded application consists of a single apartment (its single thread). When a process calls <b>CoInitialize</b> or <b>OleInitialize</b> from a thread, a new OLE apartment is created. Thereafter, each time <b>CoInitialize</b> or <b>OleInitialize</b> is called in a thread, a new OLE apartment is created.</p>
<p>
Each OLE object exists within a single apartment or thread, and all calls into an object must occur while running in the object's apartment/thread. All users of the object in other threads must call the object through proxies. It is explicitly forbidden to call this object "directly" from a different apartment/thread. This is the fundamental, unbreakable, explicit rule about apartment model threading. Don't break it! I mean it.</p>
<p>
In-process objects that are apartment-model-aware can be created in any apartment. You mark the DLL as apartment-model-aware via the ThreadingModel=Apartment value of the <b>InprocServer32</b> key. In-process objects that are not apartment-model-aware are created in the main apartment of the application, the main apartment being the first thread that calls <b>CoInitialize</b> or <b>OleInitialize</b>.</p>
<p>
An apartment-model-aware process must have thread-safe entry points because multiple apartments may be calling them to <b>CoCreateInstance</b> or <b>CoGetClassObject</b> simultaneously. In practice, this means that your application should do the following:
<ul type=disc>
<li>
<b>DllGetClassObject</b> must support supplying references to multiple class objects. If you implement your class objects dynamically, this shouldn't be an issue, because any class object you supply will only be called from a single apartment. However, if you implement your class object as a static object, you will have to make sure that your <b>AddRef</b> and <b>Release</b> methods use <b>InterlockedIncrement</b> and <b>InterlockedDecrement</b> rather than the ++/-- operators.<br><br></li>
<li>
In both the static and dynamic class object cases, make sure that global lock-count, as implemented for <b>IClassFactory::LockServer</b>, uses <b>InterlockedIncrement</b> and <b>InterlockedDecrement</b>. If you're not using a global counter for this value now, you should.<br><br></li>
<li>
Carefully implement <b>DllCanUnloadNow</b> by using the global counter from <b>InterlockedIncrement</b> along with a global counter that keeps track of the total number of instances that have been created.</li>
</ul>
<h3>Example of Registering a File Viewer</h3>
<p>
The following example demonstrates the registration of a file viewer for "C++ File" files (.CPL extensions). This sample file viewer, FILEVIEW, is provided in the Windows 95 Software Development Kit (SDK) with the Win32® samples. The file viewer is implemented in an in-process server DLL called FVTEXT.DLL. The DLL has the class identifier of 00021116-0000-0000-C000-000000000046. The actual registry entries appear in a file with the .REG extension. The .REG file is listed below. Note that the first line says "REGEDIT4". This specifies that the form of the registration file uses a new syntax. Also, note the syntax of each entry. There are square brackets ( [ ] ) around each key, and the value is enclosed in quotation marks. Use of this syntax allows the <b>InprocServer32</b> and <b>ThreadingModel</b> subkeys to be specified. The threading model specified below is set to "Apartment". This value specifies that multiple threads in the executable can create OLE objects.</p>
<pre><code>REGEDIT4

[HKEY_CLASSES_ROOT\.CPP]
@="C++ File"
[HKEY_CLASSES_ROOT\C++ File]
@="C++ Source File"
[HKEY_CLASSES_ROOT\C++ File\CLSID]
@="{00021116-0000-0000-C000-000000000046}"

[HKEY_CLASSES_ROOT\QuickView\{00021116-0000-0000-C000-000000000046}]
@="C++ Source File"
[HKEY_CLASSES_ROOT\QuickView\{00021116-0000-0000-C000-000000000046}\{00021117-
 &nbsp; 0000-0000-C000-000000000046}]
@="Sample Text Viewer"
[HKEY_CLASSES_ROOT\QuickView\{00021117-0000-0000-C000-000000000046}]
@="Sample Text Viewer"

[HKEY_CLASSES_ROOT\QuickView\.CPP]
@="C++ Source File"
[HKEY_CLASSES_ROOT\QuickView\.CPP\{00021117-0000-0000-C000-000000000046}]
@="Sample Text Viewer"

[HKEY_CLASSES_ROOT\CLSID\{00021117-0000-0000-C000-000000000046}]
@="Sample Text Viewer"
[HKEY_CLASSES_ROOT\CLSID\{00021117-0000-0000-C000-000000000046}\InprocServer32]
@="c:\\windows\\system\\viewers\\fvtext.dll"
"ThreadingModel"="Apartment"
</code></pre>
<h2>File Viewer Interfaces</h2>
<p>
File viewers use the <b>IPersistFile</b> interface to get the path for a file. From then on, the component that loaded the object can ask it to do any number of things with the file. In the future, the shell may ask the object to perform content indexing, which would then happen through an interface other than <b>IFileViewer</b>. For this reason, the file-loading member functions of <b>IPersistFile</b> are separate from the operations to perform on that file, which is why <b>IFileViewer</b> wasn't simply extended with its own <b>Load</b> member function.</p>
<h3>The IFileViewer Interface</h3>
<p>
The <b>IFileViewer</b> interface allows a registered file viewer to be notified when it must show or print a file. The Windows 95 shell calls this interface when the user selects Quick View from a file's context menu, and the file is a type that the file viewer recognizes. The interface identifier of <b>IFileViewer</b> is defined in the Windows header files by the IID_IFileViewer named constant. Like all OLE interfaces, <b>IFileViewer</b> also includes the <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> methods. The following methods are specific to <b>IFileViewer</b>.</p>
<p>
<b>IFileViewer::ShowInitialize</b></p>
<pre><code>HRESULT STDMETHODCALLTYPE ShowInitialize(LPFILEVIEWERSITE lpfsi);
</code></pre>
<p>
This method allows a file viewer to determine whether it can display a file and, if so, to perform initialization operations before showing a file. The shell calls this method before calling <b>IFileViewer::Show</b>. This method must perform all operations that are prone to failure so that, if this method succeeds, the <b>IFileViewer::Show</b> method will not fail. The shell specifies the name of the file to display by calling the file viewer's <b>IPersistFile::Load</b> method. This method returns NOERROR if successful, an OLE-defined error value otherwise. This method takes the following parameter:
<ul type=disc>
<li>
<i>lpfsi</i>—the address of an <b>IFileViewerSite</b> interface. A file viewer uses this interface to retrieve the handle of the current pinned window or to specify a new pinned window.</li>
</ul>
<h3>The FVSHOWINFO Structure</h3>
<p>
The <b>FVSHOWINFO</b> structure contains information that the <b>IFileView::Show</b> method uses to display a file. The shell uses this structure to pass information to a file viewer, and a file viewer uses it to return information to the shell. It is defined as follows:</p>
<pre><code>FVSHOWINFO
typedef struct {
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp; cbSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // size of this structure, in bytes
 &nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwndOwner;&nbsp;&nbsp; // handle of the owner window
 &nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iShow;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // how to show the file
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp; dwFlags;&nbsp;&nbsp;&nbsp;&nbsp; // flags
 &nbsp;&nbsp; RECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rect;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // size and position of file viewer window
 &nbsp;&nbsp; LPUNKNOWN punkrel;&nbsp;&nbsp;&nbsp;&nbsp; // release interface 
 &nbsp;&nbsp; OLECHAR&nbsp;&nbsp; strNewFile[MAX_PATH];&nbsp;&nbsp; // new file to view
} FVSHOWINFO, *LPFVSHOWINFO;
</code></pre>
<p>
In this structure:
<ul type=disc>
<li>
<i>cbSize</i> is the size of the <b>FVSHOWINFO</b> structure. It is used within Windows to determine which version of the operating system the application was written for.<br><br></li>
<li>
<i>hwndOwner</i> is the handle of the owner window. When a file viewer creates a window to display a file, it should specify <i>hwndOwner</i> as the owner of the window.<br><br></li>
<li>
<i>iShow</i> is the <b>Show</b> command.<br><br></li>
<li>
<i>dwFlags</i> is the file viewer show-information flags. These flags can be a combination of the following values:<p class=tl>
FVSIF_CANVIEWIT: Indicates that the file viewer can display the file.</P><p class=tl>
FVSIF_NEWFAILED: Indicates that the file viewer specified a new file to display, but no viewer could display the file. The file viewer should either exit or continue to display the previous file.</P><p class=tl>
FVSIF_NEWFILE: Indicates that a drag-drop operation has dropped a file on the file viewer window. The file viewer passes the name of the file to the shell by copying the name to <i>strNewFile</i>. The shell attempts to load a file viewer that can display the new file.</P><p class=tl>
FVSIF_PINNED: Indicates that a pinned window exists. A pinned window is a window in which the current file viewer is displaying a file. A file viewer should either use the pinned window to display the file, or set a new pinned window and display the file in it.</P><p class=tl>
FVSIF_RECT: Indicates that <i>rect</i> contains valid data.</P></li>
<li>
<i>rect</i> is the address of a <b>RECT</b> structure that specifies the size and position of the file viewer window. This member is valid only if <i>dwFlags</i> includes FVSIF_RECT.<br><br></li>
<li>
<i>punkrel</i> is the address of an interface whose <b>Release</b> method is called by a new file viewer to release the previous file viewer. This member is used when a drag-drop operation drops a file on a file viewer's window.<br><br></li>
<li>
<i>strNewFile</i> is the address of a string that specifies the name of a new file to display. A file viewer sets this member when a drag-drop operation drops a file on the viewer's window.</li>
</ul>
<p>
<b>IFileViewer::Show</b></p>
<pre><code>HRESULT STDMETHODCALLTYPE Show(LPFVSHOWINFO pvsi);
</code></pre>
<p>
This method is used to display a file. The shell specifies the name of the file to display by calling the file viewer's <b>IPersistFile::Load</b> method. This method returns NOERROR if successful, or E_UNEXPECTED if <b>IFileView::ShowInitialize</b> was not called before <b>IFileView::Show</b>. This member function is similar to the Windows <b>ShowWindow</b> function in that it receives a <b>Show</b> command that indicates how the file viewer should initially display its window. Note that the Windows 95 shell always starts QUIKVIEW with SW_SHOWNORMAL. If a WM_DROPFILES message is processed by the window, the following fields of the <b>FVSHOWINFO</b> structure should be filled in:
<ul type=disc>
<li>
The <i>strNewFile</i> field should contain the name of the new file to be viewed.<br><br></li>
<li>
The <i>rect</i> field should be filled in with rectangle coordinates that indicate where the viewer window is on the screen.<br><br></li>
<li>
The <i>dwFlags</i> field should be set to the appropriate flag(s).<br><br></li>
<li>
The <i>punkRel</i> field should be filled in with a pointer to an interface that the new viewer should release after it has displayed the new file. This allows the previous <b>IFileViewer</b> to clean up (release memory and so on). In the case where the old viewer is the same as the new viewer, the release function won't do anything because the reference count to the interface will still be greater than zero.</li>
</ul>
<p>
This method takes the following parameter:
<ul type=disc>
<li>
<i>pvsi</i>—the address of an <b>FVSHOWINFO</b> structure that contains information that the file viewer uses to display the file. A file viewer can return information to the shell by modifying the members of the structure.</li>
</ul>
<p>
<b>IFileViewer::PrintTo</b></p>
<pre><code>HRESULT STDMETHODCALLTYPE PrintTo(LPSTR pszDriver, BOOL fSuppressUI);
</code></pre>
<p>
This method prints a file. The shell specifies the name of the file to print by calling the file viewer's <b>IPersistFile::Load</b> method. This method returns NOERROR if successful, and an OLE-defined error value otherwise. This member function is like <b>Show</b> in that it does not return until it finishes printing or an error occurs. If there is a problem, the file viewer object is responsible for informing the user of the problem.</p>
<p>
This method takes the following parameters:
<ul type=disc>
<li>
<i>pszDriver</i>—the address of a buffer that contains the name of the printer device driver that should print the file. If this parameter is NULL, the file viewer determines the device driver to use.<br><br></li>
<li>
<i>fSuppressUI</i>—the user interface suppression flag. If TRUE, the file viewer should not display any user interface whatsoever (including error messages) during the print operation. If the flag is FALSE, the file viewer can show Print dialog boxes, and Printer Setup dialog boxes, error messages, and so on.</li>
</ul>
<h3>The IFileViewerSite Interface</h3>
<p>
The <b>IFileViewerSite</b> interface allows a file viewer to retrieve the handle of the current pinned window or to set a new pinned window. The pinned window is the window in which the current file viewer is displaying a file. When the user selects a new file to view, QUIKVIEW uses the pinned window as a way to communicate to the shell where to copy the file contents. The shell directs the file viewer to display the new file in the pinned window rather than create a new window. QUIKVIEW generates a WM_DROPFILES message to communicate with the shell when a file is dropped on the viewer. Only one window can have the pinned state at a time. To clear the pinned state for a window, the application uses the <b>SetPinnedWindow</b> method and passes a NULL for the <b>HWND</b> parameter. Like all OLE interfaces, <b>IFileViewerSite</b> also includes the <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> methods. The following methods are specific to <b>IFileViewerSite</b>.</p>
<p>
<b>IFileViewerSite::GetPinnedWindow</b></p>
<pre><code>HRESULT STDMETHODCALLTYPE GetPinnedWindow(HWND *phwnd);
</code></pre>
<p>
This method retrieves the handle of the current pinned window, if it exists. It returns NOERROR if successful, an OLE-defined error value otherwise.</p>
<p>
This method takes the following parameter:
<ul type=disc>
<li>
<i>phwnd</i>—the address of a window handle of the current pinned window, or NULL if no pinned window exists.</li>
</ul>
<p>
<b>IFileViewerSite::SetPinnedWindow</b></p>
<pre><code>HRESULT STDMETHODCALLTYPE SetPinnedWindow(HWND hwnd);
</code></pre>
<p>
This method sets a new pinned window. When the user selects a new file to view, the shell directs the file viewer to display the new file in the pinned window instead of creating a new window. It returns NOERROR if successful, an OLE-defined error value otherwise.</p>
<p>
This method takes the following parameter:
<ul type=disc>
<li>
<i>hwnd</i>—the handle of the new pinned window, or NULL if there is to be no pinned window.</li>
</ul>
<h2>Basic Steps in Creating a File Viewer</h2>
<p>
Implementing a file viewer to interact appropriately with QUIKVIEW involves approximately eight different steps. The Windows 95 SDK includes a sample, FILEVIEW, that demonstrates how to create a file viewer. This section lists each step and includes some sample code from FILEVIEW.
<ol>
<li>
Define the file viewer object to implement the <b>IPersistFile</b> and <b>IFileViewer</b> interfaces.<br><br></li>
<li>
Implement the <b>GetClassID</b>, <b>Load</b>, and <b>GetCurFile</b> member functions (as well as the <b>IUnknown</b> members) of the <b>IPersistFile</b> interface.<p class=tl>
The <b>IsDirty</b> member function can simply return <b>ResultFromScode(S_FALSE)</b> because a file viewer does not modify the file. The <b>Save</b> and <b>SaveCompleted</b> member functions should return <b>ResultFromScode(E_NOTIMPL)</b>. <b>GetClassID</b> returns the file viewer's class identifier. <b>GetCurFile</b> returns <b>ResultFromScode(E_UNEXPECTED)</b> if <b>Load</b> has not yet been called; otherwise, it copies the path and returns NOERROR. <b>Load</b> stores the filename, but doesn't open the file until the call to <b>ShowInitialize</b>.</P></li>
<li>
Implement the <b>IFileViewer::ShowInitialize</b> and <b>IFileViewer::Show</b> member functions (as well as the <b>IUnknown</b> members of <b>IFileViewer</b>).<p class=tl>
<b>ShowInitialize</b> must perform all operations that are prone to failure such that, if <b>ShowInitialize</b> succeeds, <b>Show</b> will never fail. The following code snippet demonstrates an implementation of the <b>ShowInitialize</b> member. Some error reporting has been removed from this sample to save space.</P><pre><code>STDMETHODIMP CFileViewer::ShowInitialize(LPFILEVIEWERSITE lpfsi)
{
HRESULT hr;
HMENU hMenu;

// Do pre-show initialization here.
if (m_lpfsi != lpfsi)
{
if (NULL!=m_lpfsi)
m_lpfsi-&gt;Release();
m_lpfsi = lpfsi;
lpfsi-&gt;AddRef();
}
//Default error code.
hr=ResultFromScode(E_OUTOFMEMORY);

//Create the main window passing "this" to it.
m_hWndOld = m_hWnd;
m_hWnd=CreateWindow(String(IDS_CLASSFRAME), String(IDS_CAPTION),
WS_MINIMIZEBOX | WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, 
CW_USEDEFAULT , CW_USEDEFAULT, 350, 450, NULL, NULL, m_hInst, 
(LPVOID)this);
if (NULL==m_hWnd)
return hr;

// Let us accept files.
DragAcceptFiles(m_hWnd, TRUE);

if (!FInitFrameControls())
return hr;

// Set initial view menu item checks.
hMenu=GetMenu(m_hWnd);
CheckMenuItem(hMenu, IDM_VIEWTOOLBAR, MF_BYCOMMAND | MF_CHECKED);
CheckMenuItem(hMenu, IDM_VIEWSTATUSBAR, MF_BYCOMMAND | MF_CHECKED);
m_fToolsVisible=TRUE;
m_fStatusVisible=TRUE;
m_pSH-&gt;MessageDisplay(ID_MSGREADY);

// ViewportResize puts the viewport window created here
// in the right location, so we don't have to worry
// about initial position.
m_hWndViewport=CreateWindowEx(WS_EX_CLIENTEDGE, 
String(IDS_CLASSVIEWPORT), "Viewport", 
WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL,
0, 100, 100, m_hWnd, (HMENU)ID_VIEWPORT,
m_hInst, (LPVOID)this);
if (NULL==m_hWndViewport)
return hr;

// Resize the viewport.
ViewportResize();

// Load the file.
hr=FileLoad();
if (FAILED(hr))
return hr;

// Load the accelerators.
m_hAccel=LoadAccelerators(m_hInst, MAKEINTRESOURCE(IDR_ACCELERATORS));

// Tell IFileViewer::Show it's OK to call it.
m_fShowInit=TRUE;
return NOERROR;
}
</code></pre>
<p class=tl>
The <b>Show</b> member displays the contents of that file in the viewport window, shows the top-level file viewer window, and enters a message loop. The following code snippet demonstrates an implementation of the <b>Show</b> method.</P><pre><code>STDMETHODIMP CFileViewer::Show(LPFVSHOWINFO pvsi)
{
MSG msg;

// If ShowInitialize failed, set the hwnd back to the old hwnd.
if ((pvsi-&gt;dwFlags &amp; FVSIF_NEWFAILED) &amp;&amp; (m_hWnd == NULL))
m_hWnd = m_hWndOld;

if (!IsWindow (m_hWnd))
return ResultFromScode(E_UNEXPECTED);

m_pvsi = pvsi;

// If the new failed flag was passed to us we know that we got here
// because we tried to view a file and it failed, so simply go back
// to message loop.
if ((pvsi-&gt;dwFlags &amp; FVSIF_NEWFAILED) == 0)
{
if (pvsi-&gt;dwFlags &amp; FVSIF_RECT)
SetWindowPos(m_hWnd, NULL, pvsi-&gt;rect.left, pvsi-&gt;rect.top,
pvsi-&gt;rect.right - pvsi-&gt;rect.left, pvsi-&gt;rect.bottom - pvsi-&gt;rect.top,
SWP_NOZORDER | SWP_NOACTIVATE);
ShowWindow(m_hWnd, pvsi-&gt;iShow);

if (SW_HIDE!=pvsi-&gt;iShow)
{
SetForegroundWindow(m_hWnd);
UpdateWindow(m_hWnd);
}
// If there is an old window, destroy it now.
if (pvsi-&gt;dwFlags &amp; FVSIF_PINNED)
{
m_lpfsi-&gt;SetPinnedWindow(NULL);
m_lpfsi-&gt;SetPinnedWindow(m_hWnd);

HMENU hMenu=GetMenu(m_hWnd);
CheckMenuItem(hMenu, IDM_VIEWREPLACE, MF_BYCOMMAND|MF_CHECKED);
}

if (SW_HIDE!=pvsi-&gt;iShow)
UpdateWindow(m_hWnd);

if ((NULL!=m_hWndOld) &amp;&amp; IsWindow(m_hWndOld))
{
m_fPostQuitMsg = FALSE;&nbsp;&nbsp; // don't destroy the queue for this one
DestroyWindow(m_hWndOld);
m_hWndOld = NULL;
}
if (NULL!=pvsi-&gt;punkRel)
{
pvsi-&gt;punkRel-&gt;Release();
pvsi-&gt;punkRel = NULL;
}
}
while (GetMessage(&amp;msg, NULL, 0,0 ))
{
if (!TranslateAccelerator(m_hWnd, m_hAccel, &amp;msg))
{
TranslateMessage(&amp;msg);
DispatchMessage(&amp;msg);
}
// If there is a new file, bail out now.
if (m_pvsi-&gt;dwFlags &amp; FVSIF_NEWFILE)
break;
}
// Perform cleanup here.
return NOERROR;
}
</code></pre>
</li>
<li>
Define the class factory object with the <b>IClassFactory</b> interface and implement that interface completely to create a file viewer object.<p class=tl>
The following code is used to instantiate a file viewer object.</P><pre><code>STDMETHODIMP CFVClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
REFIID riid, PPVOID ppvObj)
{
PCFileViewer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pObj;
HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr;

*ppvObj=NULL;
hr=ResultFromScode(E_OUTOFMEMORY);

// Verify that a controlling unknown asks for IUnknown.
if (NULL!=pUnkOuter &amp;&amp; !IsEqualIID(riid, IID_IUnknown))
return ResultFromScode(E_NOINTERFACE);

// Create the object passing function to notify on destruction.
pObj=new CFileViewer(pUnkOuter, g_hInst, ObjectDestroyed);

if (NULL==pObj)
return hr;

hr=pObj-&gt;Init();

if (SUCCEEDED(hr))
{
// Return the requested interface.
hr=pObj-&gt;QueryInterface(riid, ppvObj);

if (SUCCEEDED(hr))
{
g_cObj++;
return NOERROR;
}
}
// Delete the object.
delete pObj;

return hr;
}
</code></pre>
</li>
<li>
Implement the <b>DllGetClassObject</b> function to instantiate the class factory and return a pointer to one of its interfaces.<pre><code>HRESULT PASCAL DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
// Ensure that OLE is initialized.
OleInitialize(NULL);

if (!IsEqualCLSID(rclsid, CLSID_FileViewerText))
return ResultFromScode(E_FAIL);

// Check that we can provide the interface.
if (!IsEqualIID(riid, IID_IUnknown)&amp;&amp; !IsEqualIID(riid, IID_IClassFactory))
return ResultFromScode(E_NOINTERFACE);

// Return our IClassFactory for our viewer objects.
*ppv=new CFVClassFactory();

if (NULL==*ppv)
return ResultFromScode(E_OUTOFMEMORY);

// AddRef the object through any interface we return.
((LPUNKNOWN)*ppv)-&gt;AddRef();

return NOERROR;

}
</code></pre>
</li>
<li>
Implement the <b>DllCanUnloadNow</b> function to return the appropriate code depending on the number of file viewer objects in service and the number of lock counts affected through <b>IClassFactory::LockServer</b>.<pre><code>STDAPI DllCanUnloadNow(void)
{
SCODE&nbsp;&nbsp; sc;

// Our answer is whether there are any objects or locks.
sc=(0L==g_cObj &amp;&amp; 0L==g_cLock) ? S_OK : S_FALSE;
return ResultFromScode(sc);
}
</code></pre>
</li>
<li>
(Optional) Implement the Print To feature by implementing <b>IFileViewer::PrintTo</b>. If this feature is not implemented, this member function must return <b>ResultFromScode(E_NOTIMPL)</b>.<br><br></li>
<li>
Finish the DLL implementation with the <b>DllEntryPoint</b> function as required by any Win32 DLL.<pre><code>extern "C" BOOL WINAPI LibMain(HINSTANCE hInstance, ULONG ulReason,PVOID 
pvReserved)
{
if (DLL_PROCESS_DETACH==ulReason)
return TRUE;
else
if (DLL_PROCESS_ATTACH!=ulReason)
return TRUE;

g_hInst=hInstance;
return TRUE;
}
</code></pre>
</li>
</ol>
<p>
In general, only the implementations of <b>IPersistFile::Load</b> and the <b>IFileViewer</b> member functions are specific to a file viewer. The other steps that deal with creating an OLE component object are standard OLE mechanisms.</p>
<h2>Summary</h2>
<p>
This article is a basic overview of file viewers in Windows 95. There is also information in the Windows 95 SDK under the File Viewer Help topic. After reading this article and taking a look at the FILEVIEW sample, you too should be able to create your own file viewer. Although I talk only about simple file viewer capabilities, there isn't any reason why a file viewer couldn't have more useful features, such as drag-and-drop or Clipboard support. I'm sure that there are also some other useful features that don't come to mind right now, but I've never claimed to have the most active imagination.</p>
</BODY>
</HTML>
