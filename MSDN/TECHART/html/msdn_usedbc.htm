<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Data-Bound Controls with Visual C++ 4.2</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_usedbc"></a>Using Data-Bound Controls with Visual C++ 4.2</h1>
<p>
Microsoft Corporation</p>
<h2>Abstract</h2>
<p>
This article discusses how to use the data-bound controls that are shipped with Microsoft® Visual C++® version 4.2. This information is specific to Visual C++. Additional reference information for these controls can be found in the accompanying help files shipped with these controls. See the section titled "Inserting an RDO Control into Your Application" (below) for instructions on how to access online help within Visual C++ for any of the Remote Data Object (RDO) controls.</p>
<h2>Accessing Databases with the RemoteData Control</h2>
<p>
You can also use the <b>RemoteData</b> control to connect to any database for which you have an ODBC driver installed on your system. However, this RemoteData type has only been designed and tested to work with Microsoft® SQL Server ODBC driver.</p>
<h3>Using the RemoteData Control</h3>
<p>
You can use the <b>RemoteData</b> control to create simple database applications without writing any code at all. You can also use it together with Visual C++® code to create robust applications that give you a high degree of programming control over the behavior of your application's data. This section will first consider the simple "no-code" approach, and then examine more complex programming examples.</p>
<p>
The <b>RemoteData</b> control can perform the following tasks without the use of code:
<ul type=disc>
<li>
Connect to a local or remote database. <br><br></li>
<li>
Open a specified database table or define a set of records based on a Structured Query Language (SQL) query of the tables in that database. <br><br></li>
<li>
Pass data fields to bound controls, where you can display or change the values. <br><br></li>
<li>
Add new records or update a database based on any changes you make to data displayed in the bound controls. <br><br></li>
<li>
Raise exceptions that occur as data is accessed. <br><br></li>
<li>
Close the database. </li>
</ul>
<p>
You add the <b>RemoteData</b> control to your forms just as you would any other Visual C++ control. You can have as many <b>RemoteData</b> controls on your form as you need. As a rule, you will use one <b>RemoteData</b> control for each database table that you need to manipulate.</p>
<h4>Defining an ODBC Data Source</h4>
<p>
Before a <b>RemoteData</b> control can use a data source, you must first create an ODBC data source driver for that data source. </p>
<p>
To use the Microsoft Foundation Class Library (MFC) database classes for targeting a Win32® platform (such as Windows NT®), you must have the 32-bit ODBC driver for your data source. Some drivers are included with Visual C++; others can be obtained from Microsoft and other vendors. For more information, see the Visual C++ online topic titled "ODBC Driver List." Following are the steps to obtain a 32-bit ODBC driver:
<ol>
<li>
Go to the Control Panel. <br><br></li>
<li>
Double-click the ODBC icon. This will display the Data Sources window. <br><br></li>
<li>
Click the Add button. This displays the Add Data Source window. <br><br></li>
<li>
Select the appropriate ODBC driver to use for the data source you are preparing and click OK when done. This will redisplay the Data Sources window. <br><br></li>
<li>
Click the Setup button. This will display an ODBC Setup window. <br><br></li>
<li>
In the ODBC Setup window, specify a description for your data source (this will be the name you choose when defining the property of a <b>RemoteData</b> control). You can also click Select to specify the database you want. </li>
</ol>
<p>
You can now use this data source as input to a <b>RemoteData</b> control in a Visual C++ application. </p>
<h4>Creating Your RDO Application</h4>
<p>
When you use AppWizard to create an application that uses Remote Data Objects (RDO), you must enable OLE Controls. Also in the creation process, you may want to change the base class of the View-derived class to CFormView. CFormView gives you a blank dialog box on which you can place your OLE controls.</p>
<h4>Inserting an RDO Control into Your Application</h4>
<p>
Before you can place an RDO control on a dialog box in your application, you must first insert the control into your project's Controls toolbar, as follows:
<ol>
<li>
On the Insert pull-down menu, click Component. This will display the Component Gallery. <br><br></li>
<li>
Select the OLE Controls tab in Component Gallery. This will display the OLE controls that are available on your system. <br><br></li>
<li>
Select a control that you want to insert into your application or for which you want to see online help. <br><br></li>
<li>
Click the question mark button to get help for the control. <br><br></li>
<li>
Click the Insert button to insert the control into your project. You can now select which wrapper classes to install. If you are planning to programmatically manipulate the control, you must include any wrapper classes that contain functions or attributes that you want to use. You can also rename classes. </li>
</ol>
<p>
Your control will now appear in your project's Controls toolbar.</p>
<h4>Placing a Control in a Dialog Box</h4>
<p>
To create a simple database application, follow these steps:
<ol>
<li>
Add the <b>RemoteData</b> control to a form. <br><br></li>
<li>
Set its properties to indicate the database and table from which you want to get information. <br><br></li>
<li>
Add bound controls such as <b>DBCombo</b>, <b>DBList</b>, <b>DBGrid</b> (also known as the complex data-bound controls) or the <b>Masked Edit</b> control, known as a simple data-bound control. All of these controls have the effect of letting you "bind" to the <b>RemoteData</b> control. <br><br></li>
<li>
Set the properties of the bound controls to indicate the data source and data field to be displayed. <br><br></li>
<li>
When you run the application, these bound controls automatically display fields from the current record in the database. </li>
</ol>
<p>
You can now double-click the control and perform design-time operations.</p>
<h4>A Simple Example </h4>
<p>
The following procedure gives you a brief overview of how to use the RemoteData control in an application. In order to perform this procedure, you must first have followed the instructions in the section above, "Inserting an RDO Control into Your Application."
<ol>
<li>
Select the <b>RemoteData</b> control in the Controls toolbar and draw a <b>RemoteData</b> control on a dialog box. After you draw the control on the dialog box and size it, the caption appears. The default name of the (first) control is rdoCtrl1. <br><br></li>
<li>
Double-click the <b>RemoteData</b> control to display its property sheet. <br><br></li>
<li>
Click the All tab in the property sheet to display properties for the <b>RemoteData</b> control. <br><br></li>
<li>
Select the <b>DataSourceName</b> property, and from the Property value pull-down list select one of the predefined ODBC data sources. (See "Defining an ODBC Data Source," above.)<br><br></li>
<li>
If your data source has user ID and/or password requirements, enter those in the <b>UserName</b> and <b>Password</b> properties. <br><br></li>
<li>
In the <b>SQL</b> property, enter a SQL statement that you want to use to query the database. <br><br></li>
<li>
Insert a <b>Masked Edit</b> control by clicking in the dialog box, clicking the right mouse button, selecting Insert OLE Control, and then selecting Microsoft Masked Edit Control from the selection list.<br><br></li>
<li>
Double-click the <b>Masked Edit</b> control to display its property sheet. <br><br></li>
<li>
Click the All tab to display all properties. <br><br></li>
<li>
Select the <b>DataSource</b> property and then specify the <b>RemoteData</b> control. <br><br></li>
<li>
Select the <b>DataField</b> property and then use the pull-down list to select the field you want to display from the table specified in the <b>RemoteData</b> control's SQL statement. </li>
</ol>
<p>
You now have a sample program that is ready to be run or tested (CTRL-T). No coding was involved.</p>
<h3>Using Bound Controls</h3>
<p>
Bound controls are the data-aware controls through which you access information in a database. When a control is bound to the <b>RemoteData</b> control, Visual C++ applies field values from the current database record to that control. In turn, the control displays data to you and accepts your changes. If you change data in a bound control, those changes can be automatically written to the database as you move to another record.</p>
<p>
Visual C++ supports several built-in controls that you can bind to the <b>RemoteData</b> control. For a complete discussion of bound controls, see the sections "Using DBList and DBCombo" and "Using DBGrid" (below). This section uses the <b>Masked Edit</b> control to illustrate the basic principles of using bound controls.</p>
<p>
The <b>Masked Edit</b> control is characterized by the data-aware properties <b>DataField</b> and <b>DataSource</b>.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=18%><b>Property</b></td>
<td class=label width=82%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=18%><b>DataField</b></td>
<td width=82%>Specifies the name of a field in the result set created by the <b>RemoteData</b> control. </td>
</tr>
<tr valign=top>
<td width=18%><b>DataSource</b></td>
<td width=82%>Specifies the name of the <b>RemoteData</b> control to which the control is bound. </td>
</tr>
</table><br>
<p>
The steps in adding bound controls to your application are as follows:
<ol>
<li>
Draw the bound control on the same form as the <b>RemoteData</b> control to which it will be bound. <br><br></li>
<li>
Set the <b>DataSource</b> property to specify the <b>RemoteData</b> control to which it will be bound. <br><br></li>
<li>
Set the <b>DataField</b> property to a valid field in the <b>RemoteData</b> control's result set. </li>
</ol>
<p>
You can have more than one bound control for a particular field, but you do not need to provide a bound control for each field in the table. Neither the <b>RemoteData</b> control nor the bound controls need to be made visible, so you can incorporate data access capabilities into any form you design, manipulating the data control "behind the scenes" with code.</p>
<p>
When you run your application, the <b>RemoteData</b> control works together with the database to give you access to the current set of records with which you are working. Using the arrow buttons on the <b>RemoteData</b> control, you can move from record to record, and using the bound controls, you can view or edit the data displayed from each field. Whenever you click a button on the <b>RemoteData</b> control, Visual C++ automatically updates any changes you've made to the record.</p>
<p>
<b>Adding a New Record</b></p>
<p>
There are two methods of adding a new record to the database with the <b>RemoteData</b> control.</p>
<p>
<b>Using the EOFAction Property</b></p>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;As of Visual C++ 4.2, using this property does not work as expected.</p>
<p>
<b>EOFAction</b> and <b>BOFAction</b> are properties that determine what happens when you move past the beginning or end of the <b>RemoteData</b> control's result set. The possible settings for the EOFAction property are listed in the following table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=9%><b>Value</b></td>
<td class=label width=91%><b>Action</b></td>
</tr>
<tr valign=top>
<td width=9%>0</td>
<td width=91%>A <b>MoveLast</b> method was used, positioning the current record at the last record in the result set and effectively preventing the user from scrolling past the end of the result set.</td>
</tr>
<tr valign=top>
<td width=9%>1</td>
<td width=91%>Positions the current record to the invalid (EOF) record and disables the MoveNext button on the <b>RemoteData</b> control.</td>
</tr>
<tr valign=top>
<td width=9%>2</td>
<td width=91%>Validates the last record and automatically invokes the <b>AddNew</b> method, then positions the <b>RemoteData</b> control on the new record.</td>
</tr>
</table><br>
<p>
With the EOFAction property set to 2, when the user moves past the last record, the <b>RemoteData</b> control will automatically create a new record and allow the user to enter data. If new data is entered, moving off the current (new) record will automatically trigger an update and save the new record in the database. If the user moves off the new record without adding data, the new record is discarded.</p>
<p>
This method provides a convenient way of entering many new records consecutively. Users simply move to the end of the database and then use the MoveNext button to move one record past the end of the file. They can then begin adding new records, moving the result set forward after each record is entered. The <b>RemoteData</b> control automatically handles the addition and updating of the records.</p>
<p>
<b>Using the AddNew Method</b></p>
<p>
The other method of adding a new record requires the use of code, using the <b>AddNew</b> method of the <b>RemoteData</b> control's object. The syntax is:</p>
<pre><code>RDC1-&gt;GetResultset( )-&gt;AddNew( );
</code></pre>
<p>
When the <b>AddNew</b> method is used, Visual C++ adds a new record to the end of the result set. At this point, all bound controls are cleared, and you can fill in the new record values. After adding a new record, you will need to save the information, either by using the <b>Update</b> method or by clicking one of the <b>RemoteData</b> control arrow buttons to move to another record. The syntax of the <b>Update</b> method is:</p>
<pre><code>RDC1-&gt;GetResultset( )-&gt;Update( );
</code></pre>
<p>
Using the arrow buttons on the <b>RemoteData</b> control or one of the <b>Move</b> methods to move to another record will automatically invoke the <b>Update</b> method and save the new record.</p>
<p>
<b>Updating a Record</b></p>
<p>
After you edit a record, save the changed information to the database by using the Update method on the result set:</p>
<pre><code>RDC1-&gt;GetResultset( )-&gt;Update( );
</code></pre>
<p>
You can also use the Update method after using the AddNew method, instead of clicking one of the arrow buttons on the RemoteData control. Your attempt to add or change a record may fail if:
<ul type=disc>
<li>
Your table has a unique index, and this record is already in the table. <br><br></li>
<li>
One of the index key fields in your record is Null.<br><br></li>
<li>
You do not have permission to write to the table or database. <br><br></li>
<li>
The database, table, or field is not updatable. <br><br></li>
<li>
The record is on a page that is locked. <br><br></li>
<li>
The contents of the bound control do not match the Field definition in the database. <br><br></li>
<li>
The change violates one of the Microsoft Access database integrity rules. <br><br></li>
<li>
The change violates a validation rule you have specified in the Validate event. </li>
</ul>
<p>
Each of these conditions will generate an exception that your application must handle. For example, an error is triggered if the length of the text you supply in your bound text control is too long, or if you define a numeric field and the number is too large. By default, the Error event displays an error message to indicate the problem.</p>
<p>
Unless you end your application or have a pending transaction, any operation that moves the current record pointer to another record will automatically save any pending changes. Transactions are discussed in the section titled "Controlling Transactions, Validation, and Updates" (below).</p>
<p>
If you want to cancel the <b>AddNew</b> method, simply perform another <b>AddNew</b> method and move to another record. You can also perform the <b>RemoteData</b> control's <b>UpdateControls</b> method to restore the previous values of the bound controls.</p>
<p>
<b>Deleting a Record</b></p>
<p>
You can delete a record by using the <b>Delete</b> method. To do this, you first move the <b>RemoteData</b> control to the record you want to delete, and then call the <b>Delete</b> method. There is no need to use the <b>Update</b> method after the <b>Delete</b> method. The <b>Delete</b> method deletes the current record from the database and makes the current record invalid. At this point, you must move to another record in your result set. Any attempt to change the contents of the deleted record will result in an exception. Thus, you would implement a <b>Delete</b> button with code that looks like this:</p>
<pre><code>RDC1-&gt;GetResultset( )-&gt;Delete( );
RDC1-&gt;GetResultset( )-&gt;MoveNext( )
</code></pre>
<h3>Manipulating Records with Code</h3>
<p>
The <b>RemoteData</b> control offers a high degree of functionality that you can use without writing any code at all—simply set and manipulate its properties and incorporate data-bound controls to provide a user interface. There will be occasions, however, when you will want to extend the functionality of the <b>RemoteData</b> control in code that you write yourself. Visual C++ provides this flexibility by allowing you to manipulate the <b>RemoteData</b> control and the <b>CrdoResultset</b> objects it creates.</p>
<p>
For example, if you want to write code to move to the last record in the result set, you can treat the result set as an object, and then apply the <b>MoveLast</b> method:</p>
<pre><code>RDC1-&gt;GetResultset( )-&gt;MoveLast( );
</code></pre>
<p>
Or, if you want to check the value of a specific field in the current record, you could write:</p>
<pre><code>COleVariant MyString;
MyString = RDC1-&gt;GetResultset( )-&gt;GetRdoColumns( 
)-&gt;GetItem(COleVariant("Titles"))-&gt;GetValues( );
</code></pre>
<p>
The syntax used to control data access objects is the same syntax used to manipulate other kinds of objects in Visual C++.</p>
<h4>Navigating Through a Result Set </h4>
<p>
Navigating refers to moving around or changing the current record in a result set. By simply clicking on the forward or back buttons of the <b>RemoteData</b> control, you can traverse through the records in your result set. This section discusses the <b>CrdoResultset</b> methods that you can use to carry out these same actions in code.</p>
<p>
The following table shows which <b>CrdoResultset</b> methods are aligned with actions on the RemoteData control.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=46%><b>To move the current record to:</b></td>
<td class=label width=54%><b>Use this Move method:</b></td>
</tr>
<tr valign=top>
<td width=46%>The first record in the result set</td>
<td width=54%>RDC1-&gt;GetResultset( )-&gt;MoveFirst( )</td>
</tr>
<tr valign=top>
<td width=46%>The previous record in the result set</td>
<td width=54%>RDC1-&gt;GetResultset( )-&gt;MovePrevious( )</td>
</tr>
<tr valign=top>
<td width=46%>The next record in the result set</td>
<td width=54%>RDC1-&gt;GetResultset( )-&gt;MoveNext( )</td>
</tr>
<tr valign=top>
<td width=46%>The last record in the result set </td>
<td width=54%>RDC1-&gt;GetResultset( )-&gt;MoveLast( );</td>
</tr>
</table><br>
<p>
<b>The Current Record</b></p>
<p>
The <b>RemoteData</b> control uses the concept of the current record to determine which record in the result set is currently accessible. At any given time only one record is the current record, and it is this record that is displayed in any controls that are bound to the <b>RemoteData</b> control. As you work with result sets in code, you will need to ensure that the current record is always a valid record. It's possible, for example, to position the current record on a deleted record or to position it beyond either end of the result set, thus making it invalid.</p>
<p>
The <b>BOFAction</b> and <b>EOFAction</b> properties give you some control over this state, but you can also write code to check the <b>BOF</b> and <b>EOF</b> properties. The state of these two properties determines the position of the current record as shown in the following table. (See "Using the EOFAction Property," above, for important information on using this property.)</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Result Set<br>
BOF/EOF Property</b></td>
<td class=label width=71%><b><br>
Meaning</b></td>
</tr>
<tr valign=top>
<td width=29%>BOF and EOF both False</td>
<td width=71%>The current record pointer is valid unless you have not moved after deleting the last record in the result set.</td>
</tr>
<tr valign=top>
<td width=29%>BOF = True</td>
<td width=71%>The current record is positioned ahead of first record of data. Current record pointer is invalid.</td>
</tr>
<tr valign=top>
<td width=29%>EOF = True</td>
<td width=71%>The current record is positioned behind the last record of data. Current record pointer is invalid.</td>
</tr>
<tr valign=top>
<td width=29%>BOF and EOF both True</td>
<td width=71%>There are no rows in the result set. Current record is invalid. </td>
</tr>
</table><br>
<p>
<b>Moving to the First or Last Record</b></p>
<p>
It is often necessary to jump to the first or last record in a result set. For example, you may want to do a sequential search for a record containing a particular field value, and you need to start at one end or the other of the result set.</p>
<p>
To move to the beginning of the result set, use the <b>MoveFirst</b> method:</p>
<pre><code>RDC1-&gt;GetResultset( )-&gt;MoveFirst( );
</code></pre>
<p>
To move to the end of the result set, use the <b>MoveLast</b> method:</p>
<pre><code>RDC1-&gt;GetResultset( )-&gt;MoveLast( );
</code></pre>
<p>
If the <b>RemoteData</b> control is positioned at either the first or last record of the result set, any further movement toward the beginning or end will set the BOF (Beginning of File) or EOF (End of File) flags to True. If the <b>BOFAction</b> and <b>EOFAction</b> properties are set to 1, you will not have a valid current record at this point, and the bound controls will be cleared. If you use a <b>Move</b> method that moves beyond BOF or EOF, Visual C++ generates an exception. Because of this design, you can code the following routine that safely traverses the database from any point to the end:</p>
<pre><code>Do {
RDC1-&gt;GetResultset( )-&gt;MoveNext( )
// Insert your code to work with the current record...
} While (RDC1-&gt;GetResultset( )-&gt;EOF == False);   //Assuming EOFAction = 1
</code></pre>
<p>
At the end of this loop, the current record pointer is invalid, and you must use the <b>MoveLast</b> method to reposition it.</p>
<p>
<b>Moving to the Next Record</b></p>
<p>
The <b>MoveNext</b> method makes the next record in the result set current. Generally, <b>MoveNext</b> is used to step through a result set's rows to extract data on a record-by-record basis.</p>
<p>
For information about the DBGrid, DBCombo, and DBList, see "Using DBGrid" and "Using DBList and DBCombo."</p>
<p>
<b>Moving to the Previous Record</b></p>
<p>
The <b>MovePrevious</b> method makes the previous record current. This method works like the <b>MoveNext</b> method, except that it moves the current record pointer toward the front of the result set.</p>
<p>
<b>Using a Bookmark to Move to a Specific Record</b></p>
<p>
Bookmarks allow you to save a current record pointer and reposition directly to a specific record. The <b>Bookmark</b> property contains a pointer to a record you specify. You can jump to that record by setting the Bookmark equal to the value of that pointer. This value can be saved in a Variant or string variable. The following code repositions the current record to a previously saved Bookmark:</p>
<pre><code>COleVariant MyBookMark;
MyBookMark = RDC1-&gt;GetResultset( )-&gt;GetBookmark( );&nbsp; ' Save current record pointer
RDC1-&gt;GetResultset( )-&gt;MoveFirst( );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Move off the record
RDC1-&gt;GetResultset( )-&gt;SetBookmark( MyBookmark );&nbsp;&nbsp;&nbsp; ' Move back to saved 
location
</code></pre>
<p>
If you don't know the physical order number or bookmark of the record you want to access, you can search for it by starting with the first record and loop through the result set, comparing data from each record with the item you want to find.</p>
<p class=indent>
<B><b>Caution</b></B>&nbsp;&nbsp;&nbsp;If more than one user is accessing the database, the record order can change when you use the <b>Refresh</b> method to rebuild the result set. If you depend on the record number (counting from the top of the result set) to locate records, you will find that this number will not consistently bring you back to the same record. Bookmarks save a pointer to the record that can be used to retrieve a specific record as long as that record remains in the result set and you do not refresh the result set. If you or some other user deletes the record, the bookmark becomes invalid, and Visual C++ generates an exception.</p>
<p>
<b>Other Methods of Moving Through the Result Set</b></p>
<p>
In addition to the <b>Move</b> methods outlined above, you can use the <b>Move</b> method with an integer argument to move a specific number of rows forward or backward from the current record. You can also use the <b>AbsolutePosition</b> and <b>PercentPosition</b> properties of the <b>Resultset</b> object to move through the result set.</p>
<p>
For information about the <b>Move</b> methods and the <b>AbsolutePosition</b> and <b>PercentPosition</b> properties, search Help for the appropriate method or property. See "Inserting an RDO Control into Your Application" for instructions on how to access online help within Visual C++ for any of the RDO controls.</p>
<h4>Updating a Result Set</h4>
<p>
To determine whether the data in a result set can be changed, examine the <b>Updatable</b> property of the result set. If this property is TRUE, the result set will accept changes. For example, to see if a selected table is updatable, you could write the following code:</p>
<pre><code>If (RDC1-&gt;GetResultset( )-&gt;Updatable( ) == True) {
...
}
</code></pre>
<h4>Adding, Editing, and Deleting Records</h4>
<p>
To change the information in a database, you must use a database that is updatable. If you're not sure whether your database can be updated, you can check the following conditions:
<ul type=disc>
<li>
The <b>Updatable</b> properties of the database, result set, and field must be True. If any of the <b>Updatable</b> properties is False, its corresponding data values are read-only. <br><br></li>
<li>
You must open the <b>RemoteData</b> control with the <b>ReadOnly</b> property set to False. </li>
</ul>
<p>
The following code checks to see if a database can be updated:</p>
<pre><code>if (RDC1-&gt;GetReadOnly( ) == TRUE || 
 &nbsp;&nbsp; RDC1-&gt;GetResultset( )-&gt;GetUpdatable( ) == FALSE ||
 &nbsp;&nbsp; RDC1-&gt;GetResultset( )-&gt;Updatable( ) == FALSE) 
 &nbsp; printf("\nThis data cannot be altered");
</code></pre>
<p>
<b>Adding a New Record</b></p>
<p>
Once you have determined that the database and result set can accept changes, you are ready to add records.</p>
<p>
To append new records to your result set:
<ol>
<li>
Create a new (blank) record with the <b>AddNew</b> method. The current record pointer is saved and moved to the new record. <br><br></li>
<li>
Assign new values to the fields in the new record. <br><br></li>
<li>
Save the new record with the <b>Update</b> method. The current record pointer is restored to its original value (the value of the record pointer prior to using the <b>AddNew</b> method). </li>
</ol>
<p>
The following code adds a new record to the Titles table of a bibliographic database.</p>
<pre><code>RDC1-&gt;SetDataSourceName("BIBLIO.MDB");
RDC1-&gt;SetSql("Select * from Titles");
RDC1-&gt;Refresh( );

RDC1-&gt;GetResultset( )-&gt;AddNew( );   ' Create a new record.
CrdoColumns columns=RDC1-&gt;GetResultset( )-&gt;GetrdoColumns( );

columns-&gt;GetItem(COleVariant("Title"))-&gt;SetValue( COleVariant("The Data 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Control")); ' Set the field values.
columns-&gt;GetItem(COleVariant("Year Published"))-&gt;SetValue( COleVariant("1993"));
columns-&gt;GetItem(COleVariant("AU_ID"))-&gt;SetValue( COleVariant(37));
columns-&gt;GetItem(COleVariant("ISBN"))-&gt;SetValue( COleVariant("2344456533"));
columns-&gt;GetItem(COleVariant("PubID"))-&gt;SetValue( COleVariant(43));
RDC1-&gt;GetResultset( )-&gt;Update( );&nbsp;&nbsp; ' Append new record.
</code></pre>
<p>
Note that if you are using a Microsoft Access database or a native Jet database, Visual C++ will validate the accuracy of "foreign" keys according to the restrictions set by the <b>Relation</b> object. Otherwise, you are responsible for verifying referential integrity yourself.</p>
<p>
For example, in the preceding code example, the PubID field refers to the PubID field in the Publishers table. Your code must verify that this is a correct value for you to maintain database referential integrity. The best way to validate fields is by using the <b>RemoteData</b> control's Validation event. There you can check to see if the field values about to be written to the database are correct.</p>
<p>
After using the <b>AddNew</b> method, you must update the result set before using the <b>Close</b> method. When using the <b>RemoteData</b> control, this is fairly easy, because any method that changes the current record pointer, including pressing any <b>RemoteData</b> control arrow button, will save the new (or changed) record before moving the current record pointer. In the preceding example, the following code adds the record to the result set:</p>
<pre><code>RDC1-&gt;GetResultset( )-&gt;Update( );
</code></pre>
<p>
<b>Editing the Current Record</b></p>
<p>
To change data in your database, you must first designate the record you want to edit to be the current record. You can use any of the <b>Move</b> methods or <b>RemoteData</b> control buttons to position the record pointer to the record you want to change. Then make any necessary changes in the bound controls. Remember, the same restrictions apply here as far as updatable fields are concerned—not all fields are updatable. To save your changes, simply move the current record pointer to another record, or use the <b>Update</b> method:</p>
<pre><code>RDC1-&gt;GetResultset( )-&gt;Update( );
</code></pre>
<p>
To edit one or more field values of the current record:
<ol>
<li>
Position the current record to the record you want to edit. <br><br></li>
<li>
Assign new values to the fields you want to change. <br><br></li>
<li>
Use the <b>Update</b> method or any of the <b>Move</b> methods. </li>
</ol>
<p>
Alternatively, you can click one of the arrow buttons on the <b>RemoteData</b> control to save the changes and replace the existing field values.</p>
<p>
The following code shows how to edit the value of the PubID field in the first record. Note that you can change the data in the result set or in the bound control itself.</p>
<pre><code>RDC1-&gt;SetDataSourceName("BIBLIO.MDB");
RDC1-&gt;SetSql("Select * from Titles");
RDC1-&gt;Refresh( );// Open the database.
CrdoColumns columns=RDC1-&gt;GetResultset( )-&gt;GetrdoColumns( );
columns-&gt;GetItem(COleVariant("PubID"))-&gt;SetValue( COleVariant("12345"));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Change the field values.
Text4-&gt;SetText( "New title")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Or the bound control.
RDC1-&gt;GetResultset( )-&gt;Update( ); // Save the changes. 
</code></pre>
<p>
<b>Deleting a Record</b></p>
<p>
To delete an entire record, position the current record pointer to the record you want to remove, and use the <b>Delete</b> method. For example, the following code will delete every record whose "Year Published" field is less than 1889 from a Titles table (in a hypothetical database):</p>
<pre><code>RDC1-&gt;SetDataSourceName("BIBLIO.MDB");
RDC1-&gt;SetSql("Select * from Titles where [Year Published] &lt; 1889");
RDC1-&gt;Refresh( );

Do {
// RDC1-&gt;GetResultset("Title")
TRACE( "Deleting title");
RDC1-&gt;GetResultset( )-&gt;Delete( );
RDC1-&gt;Resultset( )-&gt;MoveNext( );
} while (RDC1-&gt;GetResultset( )-&gt;GetEof( ) == False);
</code></pre>
<p>
In this example, each iteration performs the <b>MoveNext</b> method. You need to use <b>MoveNext</b> to change the current record after a deletion, because a deleted record no longer contains valid data, and an attempt to access this data will result in an error.</p>
<p>
Note that using the <b>Delete</b> and <b>MoveNext</b> methods in a loop, as in the example above, is less efficient than using a SQL DELETE query, such as:</p>
<pre><code>"DELETE from Titles where [Year Published] &lt; #1/1/1889#"
</code></pre>
<h4>Closing a Result Set </h4>
<p>
The <b>Close</b> method closes the result set and frees the resources allocated to it. Attempting to perform a method or access an element of a closed result set causes an exception. For example, the following code closes a result set:</p>
<pre><code>RDC1-&gt;GetResultset( )-&gt;Close( );
</code></pre>
<p>
Databases and their respective result sets are automatically closed when:
<ul type=disc>
<li>
The <b>Close</b> method is used against a specific result set. <br><br></li>
<li>
The form containing the data control is unloaded. <br><br></li>
<li>
The program ends. </li>
</ul>
<p>
The Validate event is triggered when either the <b>Close</b> method is used or the dialog is closed. Validate is not triggered when the program ends. Last-minute cleanup operations can be performed in the Validate event.</p>
<h3>Controlling Transactions, Validation, and Updates</h3>
<p>
A <i>transaction</i> is a recoverable series of changes you make to a result set. You use transactions when you want to verify any changes you make before committing the new information to the database. For example, if you are dealing with a lengthy series of financial transactions, you might want to cancel your changes if the final totals are out of balance.</p>
<p>
You use code to explicitly begin a transaction. While a transaction is open, any changes you make to data can be undone, or "rolled back." When you decide that your work is complete, you can save, or "commit," the changes to the database.</p>
<p>
When you first open a database and no transactions are pending, the transaction state is <i>auto-commit</i>, which means that all changes made to a result set are made immediately to the underlying table and are irreversible. For situations where you do not want changes to take effect automatically, you can use transactions to control when the changes will occur.</p>
<p>
Visual C++ has three statements that support transaction processing: <b>BeginTrans</b>, <b>CommitTrans</b>, and <b>Rollback</b>. However, the database itself must also support transactions or these commands will be ignored. Make sure that the <b>Transactions</b> property of the database is set to True before using these statements.</p>
<p>
Transactions span databases. That is, when you use one of the transaction statements, it applies to all databases in a workspace—even databases opened after the transaction was begun. When you use <b>CommitTrans</b> or <b>Rollback</b>, all pending transactions, regardless of the database, are either committed or rolled back.</p>
<h4>Beginning a Transaction</h4>
<p>
The <b>BeginTrans</b> statement marks the beginning of a transaction and takes the next sequence of operations out of auto-commit mode. Once you begin a transaction, you must use <b>CommitTrans</b> or <b>Rollback</b> before you close the database or end the program. Uncommitted transactions are automatically rolled back when your program ends. If you attempt to close a database while a transaction is in progress, an error will occur.</p>
<h4>Saving Changes to a Table</h4>
<p>
<b>CommitTrans</b> saves all result set changes made since the transaction was opened with the <b>BeginTrans</b> command. When you execute <b>CommitTrans</b>, all changes are made permanent, the current transaction is ended, and the transaction state returns to auto-commit.</p>
<h4>Undoing Changes</h4>
<p>
<b>Rollback</b> reverses, or undoes, all data changed in the current transaction. It also ends the transaction and returns the transaction state to auto-commit.</p>
<h4>Working with Multiple Transactions</h4>
<p>
Transaction commands always apply to all result sets opened in the same workspace. As the preceding code example shows, this allows you to simply state the transaction command you want (such as <b>BeginTrans</b>) without reference to the <b>RemoteData</b> control. If you're working with multiple transactions, however, you'll need to pay attention to the sequence of the transaction commands you issue.</p>
<p>
Once you issue a <b>BeginTrans</b> command, you have a transaction pending, and all further transaction commands apply to that pending transaction. If you then begin a second transaction, without concluding the first, you start to build a series of nested transactions. The model here is much like that of nested control structures, where you need to close the innermost statements (or transactions) before proceeding to the outermost.</p>
<h4>Validating Changes to the Database</h4>
<p>
The <b>RemoteData</b> control's Validate event allows you to check any changes made to the result set before new information is written to the database. It also allows you to specify which record will become current after the Validate event is concluded. Validate is triggered when the current row is changed. This means that Validate can be triggered regardless of whether you have changed data in the bound controls.</p>
<p>
During a Validate event, you will not be able to invoke any method that triggers another Validate event. For example, you will not be able to call <b>AddNew</b> or <b>Move</b> methods.</p>
<p>
The Validate event is invoked just before Visual C++ writes changes from the bound controls to the database and repositions the current record pointer to another row in the database. The following table summarizes the arguments you can use with the Validate event.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=17%><b>Argument</b></td>
<td class=label width=83%><b>Determines</b></td>
</tr>
<tr valign=top>
<td width=17%>Save</td>
<td width=83%>Whether or not the <b>Update</b> method will be performed to save the current changes.</td>
</tr>
<tr valign=top>
<td width=17%>Action</td>
<td width=83%>What action triggered the event; also lets you specify what operation takes place after the Validate event. </td>
</tr>
</table><br>
<p>
<b>The Save Argument</b></p>
<p>
In the Validate event, you can determine if any of the bound controls have changed by examining the Save argument. Visual C++ automatically checks the <b>Changed</b> property of each bound control to see if its value has changed since it was set by the last database action. If any values have changed, Visual C++ sets the Save argument to True.</p>
<p>
If the Save argument is True, Visual C++ will save any bound control changes to the database. If you do not want to save the changes, you can set the Save argument to False.</p>
<p>
<b>The Action Argument</b></p>
<p>
The Action argument tells you what caused the Validate event to be triggered and allows you to reposition the current record pointer after the Validate event is completed. In the Validate event, Visual C++ sets the Action argument with a value that indicates which action initially triggered the event. The following table summarizes the Action argument values and the actions caused by the Validate event.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Value</b></td>
<td class=label width=79%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=21%>0</td>
<td width=79%>Cancels the action that caused the event.</td>
</tr>
<tr valign=top>
<td width=21%>1</td>
<td width=79%><b>MoveFirst</b> method.</td>
</tr>
<tr valign=top>
<td width=21%>2</td>
<td width=79%><b>MovePrevious</b> method.</td>
</tr>
<tr valign=top>
<td width=21%>3</td>
<td width=79%><b>MoveNext</b> method.</td>
</tr>
<tr valign=top>
<td width=21%>4</td>
<td width=79%><b>MoveLast</b> method.</td>
</tr>
<tr valign=top>
<td width=21%>5</td>
<td width=79%><b>AddNew</b> method.</td>
</tr>
<tr valign=top>
<td width=21%>6</td>
<td width=79%><b>Update</b> method.</td>
</tr>
<tr valign=top>
<td width=21%>7</td>
<td width=79%><b>Delete</b> method.</td>
</tr>
<tr valign=top>
<td width=21%>8</td>
<td width=79%><b>Find</b> method.</td>
</tr>
<tr valign=top>
<td width=21%>9</td>
<td width=79%>The <b>Bookmark</b> property has been set.</td>
</tr>
<tr valign=top>
<td width=21%>10</td>
<td width=79%><b>Close</b> method.</td>
</tr>
<tr valign=top>
<td width=21%>11</td>
<td width=79%>The form is unloaded.</td>
</tr>
</table><br>
<p>
In some cases, you can set the Action argument to specify how Visual C++ will reposition the current row pointer after the event is completed. This is possible if the Validate event has been triggered by <b>AddNew</b> or one of the <b>Move</b> methods.</p>
<p>
For example, suppose the Validate event was triggered because you clicked the MoveNext button on the <b>RemoteData</b> control. As Visual C++ then enters the Validate event, it sets the Action argument to 3, indicating <b>MoveNext</b>. After the validation is completed, reposition the current record pointer to the previous record instead of to the next record. To do this, set the Action argument to 2, indicating <b>MovePrevious</b>. The repositioning routine will then use the Action argument you specify to indicate which row to set as the current row after the transaction.</p>
<p>
You can specify any one of the <b>Move</b> or <b>AddNew</b> methods to be performed in place of any other set of <b>Move</b> or <b>AddNew</b> methods. If you attempt to change any action except one of the <b>Move</b> methods or <b>AddNew</b>, Visual C++ ignores your attempt and proceeds with the originally intended operation.</p>
<p>
<b>Canceling the Action</b></p>
<p>
If you do not want the Validate event to reposition the current record pointer to another record, you can set the Action argument to 0. Setting the Action argument to 0 has no impact on whether or not data is saved to the database—it merely cancels the repositioning operation and leaves the current record active. If no repositioning takes place, the values displayed in the bound controls and the current record pointer remain unchanged.</p>
<h4>Updating Your Data</h4>
<p>
You have seen the <b>Update</b> method used to update the information in the result set, based on changes made through bound controls or through code. In this section, you'll learn about two additional methods that you can use to update information: <b>UpdateControls</b> and <b>Refresh</b>. The following table summarizes the actions of these methods.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Method</b></td>
<td class=label width=74%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=26%><b>UpdateControls</b></td>
<td width=74%>Updates database (result set) changes to bound controls.</td>
</tr>
<tr valign=top>
<td width=26%><b>Refresh</b></td>
<td width=74%>Creates a new result set based on data control properties.</td>
</tr>
</table><br>
<p>
The <b>RemoteData</b> control's <b>UpdateControls</b> method updates the bound controls using the values in the result set's current row. You use this method when the current row has changed, but the bound controls have not been automatically updated with data from the current row.</p>
<h3>Understanding Database Design and Structure </h3>
<p>
The <b>RemoteData</b> control provides a relational interface to database files. Basically, a relational database is one that stores data in tables made up of columns and rows of data. In Visual C++, columns are referred to as fields, and rows are referred to as records.</p>
<p>
<b>Tables</b></p>
<p>
A table is a logical grouping of related information arranged in rows and columns, similar to a spreadsheet table. For example, a table might contain a list of information about authors, such as their names, dates of birth, addresses, and pictures.</p>
<p>
<b>Fields</b></p>
<p>
Each column in a database table is called a field. Tables are defined by the fields they contain, with each field describing the data it is to hold. When creating a database, you assign a data type, maximum length, and other attributes to each field. Fields can contain characters, numbers, or even graphics. For example, the Authors table might have fields with the name and address as data type "character," the date of birth as data type "date," and the author's photograph as data type "graphic."</p>
<p>
<b>Records</b></p>
<p>
Information about individual authors is kept in the rows of the table, called records. Generally, database table records are created such that no two rows are the same. That is, you would not have two authors by the same name at the same address and with the same birthday.</p>
<p>
<b>Indexes</b></p>
<p>
To make access to the data faster, most databases use indexes. Database table indexes are sorted lists that are faster to search than the tables. Each index entry points back to the database row it references. If the database (which does all of the searching) can look through an index first when looking for records (performing a query), its job is made easier and your data is returned faster. When you use table-type result sets with the <b>RemoteData</b> control, the table's primary index is used to speed retrieval.</p>
<p>
<b>Structured Query Language (SQL)</b></p>
<p>
Once the data is stored in the database, retrieving it is made easier by using an English-like language called Structured Query Language, or SQL. SQL has evolved into the most widely accepted means to "converse" with a database. Basically, the user asks questions in the SQL language; this is called a "query." The database engine "answers" by returning any database rows that meet the requirements of the query. The query usually contains the names of the tables to search, the names of the columns to return, and other information that sets the scope of the search. For example, an SQL query on our Authors table might look like this:</p>
<p>
"Select Name, Picture from Authors where Date_of_Birth = #2/7/1947# "</p>
<p>
This SQL query would return the name and picture of all authors whose birthday is February 7, 1947. If any rows are returned, you could use bound controls to display the values.</p>
<h2>Using DBCombo and DBList</h2>
<p>
Accessing databases with the <b>Data</b> control shows how the <b>RemoteData</b> control lets you build database applications with little or no code by working with special data-aware controls called <i>bound controls</i>. This section provides an overview of how you can use bound controls to display, edit, and update records in the <b>RemoteData</b> control's database.</p>
<p>
When a control is bound to the <b>RemoteData</b> control, Visual C++ displays field values from the current database record in that control. If you change data in a bound control, those changes can be automatically written to the database as you move to another record.</p>
<h3>Data Binding</h3>
<p>
<b>DBCombo</b> and <b>DBList</b> controls can be automatically filled from a database field via the <b>RemoteData</b> control to which they are bound. In addition, they can optionally pass a selected field to a second <b>RemoteData</b> control, making it ideal for "lookup table" applications.</p>
<p>
<b>DBList</b> and <b>DBCombo</b> boxes have five special properties that determine their data binding. These are listed in the following table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=19%><b>Property</b></td>
<td class=label width=81%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=19%><b>DataSource</b></td>
<td width=81%>The name of the <b>RemoteData</b> control to which the data-bound list box or data-bound list box control is bound.</td>
</tr>
<tr valign=top>
<td width=19%><b>DataField</b></td>
<td width=81%>The name of a field in the result set specified by the <b>DataSource</b> property. This field will be used to determine which element in the list will be highlighted. If a new selection is made, this field will be updated when you move to a new record.</td>
</tr>
<tr valign=top>
<td width=19%><b>RowSource</b></td>
<td width=81%>The name of the <b>RemoteData</b> control that will be used to fill the list. </td>
</tr>
<tr valign=top>
<td width=19%><b>BoundColumn</b></td>
<td width=81%>The name of a field in the result set specified by the <b>RowSource</b> property. This list must be of the same type as the <b>DataField</b> that will be used to update the <b>DataField</b>.</td>
</tr>
<tr valign=top>
<td width=19%><b>ListField</b></td>
<td width=81%>The name of a field in the result set specified by <b>RowSource</b> that will be used to fill the list.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You can also use the data-bound list box and data-bound combo box controls with a single RemoteData control. To do this, set both the <b>DataSource</b> and <b>RowSource</b> properties to the same <b>RemoteData</b> control, and set the <b>DataField</b> and <b>BoundColumn</b> properties to the same field in the <b>RemoteData</b> control's result set. In this case, the list will be filled with <b>ListField</b> values from the same result set that is updated. If a <b>ListField</b> property is specified, but no <b>BoundColumn</b> property is set, <b>BoundColumn</b> will automatically be set to the <b>ListField</b> field.</p>
<p>
A common use of these controls is to build a list of items based on a database query from which a user can select or enter a value or, in the case of data-bound combo box, to edit the selected field. When an item in the list is selected, its associated BoundColumn value is made available to the <b>RemoteData</b> control specified by the <b>DataSource</b> property. Once the <b>RemoteData</b> control moves to another record or is otherwise updated, the result set is updated with the selected or edited text.</p>
<h3>An Example Using DBCombo and DBList</h3>
<p>
The following example uses the <b>DBCombo</b> box control to create a data-entry screen for the Titles table of a sample database. It lets the user enter new titles and assign them to existing publishers by providing a lookup table of all publishers' names. When users get to the Publisher field in the entry form, they can choose a publisher from a list box. When they select a publisher, that publisher's PubID field is copied into the PubID field of the Titles table.</p>
<p>
To create a lookup table with the data-bound <b>DBCombo</b> box control:
<ol>
<li>
Add a <b>DBCombo</b> and two <b>RemoteData</b> controls to your dialog box. <br><br></li>
<li>
Set the first <b>RemoteData</b> control (RDC1) properties to access the Titles table. <br><br></li>
<li>
Set the second <b>RemoteData</b> control (RDC2) properties to access the Publishers table, using the following SQL Query: SELECT PubID, Name FROM Publishers ORDER BY PubID <br><br></li>
<li>
Set the <b>DataSource</b> property for the <b>DBCombo</b> box to the first <b>RemoteData</b> control (RDC1). The <b>DataField</b> property should be set to the PubID field of the Titles table. This binds the <b>DBCombo</b> control to update the Titles result set. <br><br></li>
<li>
Set the <b>RowSource</b> property for the <b>DBCombo</b> box to the second <b>RemoteData</b> control (RDC2). <br><br></li>
<li>
Set the <b>BoundColumn</b> property for the <b>DBCombo</b> box to the PubID field of the Publishers table. This sets the <b>DBCombo</b> box control to use the PubID field of the second <b>RemoteData</b> control's result set (Publishers) when it updates the <b>DataField</b> property of the first <b>RemoteData</b> control's result set (Titles). <br><br></li>
<li>
Set the <b>ListField</b> property to the Name field of the Publishers table. Note that the <b>ListField</b> property pull-down menu is derived from the <b>RemoteData</b> control specified by the <b>RowSource</b> property. This specifies that the Name field will be used to fill the <b>DBCombo</b> box's list. </li>
</ol>
<p>
The DataField and the BoundColumn fields should be identical, but in different tables. That is, the BoundColumn field should be a foreign key into the DataField.</p>
<p>
When you run this program, the <b>DBCombo</b> box control fills with a list of publishers' names. When you select one of the records from the Titles table using the first <b>RemoteData</b> control, you will notice that the name of that title's publisher is displayed in the text box portion of the <b>DBCombo</b> box. Next, change the name by making a new selection from the names in the <b>DBCombo</b> box control. Reposition the first <b>RemoteData</b> control to a different record, and then move back to the original record. Notice that the name displayed has been updated, indicating that the PubID field in the Titles table now contains the PubID field of the publisher selected from the <b>DBCombo</b> box control.</p>
<p>
If you enter a name in the text box that is not in the list, the <b>RemoteData</b> control has no way of knowing which PubID value corresponds to the new name, so the PubID field will be saved as Null.</p>
<h3>Other DBList and DBCombo Properties</h3>
<p>
Some important additional properties of the <b>DBList</b> box and <b>DBCombo</b> box include:
<ul type=disc>
<li>
<b>SelectedItem</b><br><br></li>
<li>
<b>MatchEntry</b><br><br></li>
<li>
<b>IntegralHeight</b><br><br></li>
<li>
<b>VisibleCount</b></li>
</ul>
<p>
For a complete list of properties and methods of these controls, search online Help for "DBList" and "DBCombo." See the section titled "Inserting an RDO Control into an Application" (above) for instructions on accessing online help.
<ul type=disc>
<li>
<b>SelectedItem.</b> Once an item is selected, the <b>SelectedItem</b> property returns a bookmark for that row. The bookmark can subsequently be used in code to reference the result set row that contains the selected item.<br><br></li>
<li>
<b>MatchEntry.</b> The <b>MatchEntry</b> property enables the extended search mode so you can easily locate items in the list generated by the <b>DBCombo</b> box control. This is especially useful for long lists. With <b>MatchEntry</b> set to True, every key the user types will be added to a search argument. For example, if the user types "N," the control highlights the first item in the list beginning with "N." If the user subsequently types "E," the process is repeated and the control moves to the first item beginning with the letters "NE." The search argument is cleared when the control changes focus, or when the user presses <small>backspace</small>.</li>
</ul>
<p>
If <b>MatchEntry</b> is set to False, the search argument is limited to one character.
<ul type=disc>
<li>
<b>IntegralHeight</b> and <b>VisibleCount.</b> If the number of items exceeds what can be displayed, a scroll bar is automatically added to the control. You can prevent partial rows from being displayed by setting the <b>IntegralHeight</b> property, which automatically sizes the <b>DBList</b> box or <b>DBCombo</b> box control to display an exact number of complete rows. You can determine the number of visible items in the list by examining the <b>VisibleCount</b> property.</li>
</ul>
<h2>Using DBGrid</h2>
<p>
The data-bound grid is a new spreadsheet-like bound control that displays a series of rows and columns representing records and fields from a <b>CrdoResultset</b> object. The intersection of a row and column is a cell.</p>
<p>
When you set the <b>DBGrid</b> control's <b>DataSource</b> property to a <b>RemoteData</b> control, the control is automatically filled and its column headers are automatically set from the <b>RemoteData</b> control's result set. This gives you a great deal of "ready-made" functionality that allows your users to browse and edit complete database tables or query results.</p>
<p>
The <b>Row</b> and <b>Col</b> properties specify the current cell in a grid. Each cell of a data-bound grid control can hold either text or picture values. You can specify the current cell in code, or the user can change it at run time using a mouse or the arrow keys. You can read and set the contents of each cell interactively or programmatically. A <b>DBGrid</b> control can have any number of rows, and as many columns as system resources can support.</p>
<p>
Users can set the focus to individual cells and edit data directly in the cell. Users can also select entire rows, or cells on a per-column basis. Each column has its own font, border, word-wrap, color, and other attributes that can be set without regard to other columns. At design time, the column width and row height can be set and you can establish "hidden" columns. Users can be prevented from changing the formatting at run time.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You can search online Help for "DBGrid" to get a full reference listing of the <b>DBGrid</b> control's properties and methods, along with brief examples of usage. See "Inserting an RDO Control into an Application" (above) for instructions on accessing online help.</p>
<h3>A Quick Start</h3>
<p>
The <b>DBGrid</b> control can be highly customized and directly manipulated in code to give you great flexibility in creating custom database applications. </p>
<p>
In many cases, however, you will want to use <b>DBGrid</b> to quickly and easily display and browse through all the records in a database table. This can be accomplished in minutes without writing code.</p>
<p>
Before using the Apex Data Grid, you must add the control to the project. (See "Inserting an RDO Control into an Application.")</p>
<p>
To use DBGrid to display and browse through an existing database table, follow these steps:
<ol>
<li>
Add a <b>RemoteData</b> control to a new dialog box and set its properties to the database and table you want to display. (See "A Simple Example.")<br><br></li>
<li>
Add a <b>DBGrid</b> control to the form, and set its <b>DataSource</b> property to the <b>RemoteData</b> control you just created. <br><br></li>
<li>
To ensure that a connection exists with your <b>RemoteData</b> control, highlight (click on) the <b>DBGrid</b>, click the right mouse button, select Apex Data-Bound Grid Control Object, and then select Retrieve Fields. If you have successfully connected your <b>RemoteData</b> control to a database and if you correctly connected your <b>DBGrid</b> to the <b>RemoteData</b> control, the column headings in your <b>DBGrid</b> will become populated with the table fields. <br><br></li>
<li>
Run the application. </li>
</ol>
<p>
When your program runs, the database table you specified is displayed in the <b>DBGrid</b>, complete with column headers (from the <b>RemoteData</b> control's result set) and scroll bars. You can immediately scroll through all the records and fields of the table. In addition, you can edit any cell in the table, and it will automatically be updated when you move to a new row (assuming that the underlying result set is updatable and the <b>DBGrid's</b> <b>AllowUpdate</b> property is set to True). With the <b>AllowAddNew</b> and <b>AllowDelete</b> properties set to True, you can delete records by selecting and deleting the entire row.</p>
<h3>Design-time Operations</h3>
<p>
When first created, the <b>DBGrid</b> control has a single column and a single row. It also contains an empty row—designated by the asterisk (*)—at run time, which is used to add new records. You can change any of the <b>DBGrid's</b> visible attributes through settings in the Properties window. </p>
<p>
When you set the <b>DataSource</b> property, the <b>DBGrid</b> control binds itself to the result set created by the <b>RemoteData</b> control. It then sets the number of columns and other column properties from the corresponding properties of the <b>RemoteData</b> control's result set.</p>
<p>
The Properties window displays the properties for the entire <b>DBGrid</b> control; the control can be moved and sized. To set properties for the individual <b>Column</b> objects, you must make the <b>DBGrid</b> control UI-active: Select the right mouse button, and click Edit on the control's pop-up menu. Use the pop-up menu to insert or delete columns, or to cut and paste columns to and from the Clipboard.</p>
<p>
Each <b>DBGrid</b> control has a single property page, however, each <b>Column</b> object also has its own page. You can use these property pages to interactively set properties for the <b>DBGrid</b> control as a whole, or for individually selected columns.</p>
<p>
The General property page shows properties that apply to the entire <b>DBGrid</b> control and can be assessed at design time.</p>
<p>
The <b>Columns</b> property page shows properties for an individual column. If multiple columns are selected, the leftmost column in the columns property page is selected. Setting <b>Column</b> object properties doesn't affect overall <b>DBGrid</b> control properties.</p>
<p>
The <b>Colors</b> property page allows selection of overall <b>DBGrid</b> control colors. <b>Column</b> object colors aren't affected by these settings.</p>
<p>
The <b>Fonts</b> property page allows selection of overall <b>DBGrid</b> control and heading fonts. <b>Column</b> object fonts aren't affected by these settings.</p>
<h3>Run-time Operations</h3>
<p>
The <b>DBGrid</b> control displays records from the underlying <b>CrdoResultset</b> object at run time. There is always a single current record in the <b>DBGrid</b> control, even if multiple rows in the control are selected. The current record corresponds to the <b>RemoteData</b> control's current record, and can be set or retrieved with the <b>DBGrid</b> control's <b>Bookmark</b> property.</p>
<p>
As with other data-bound controls, when you change a record (or any field in a record) in the <b>DBGrid</b>, the underlying result set is updated when you move to a new record (row), assuming that it is updatable and the <b>DBGrid's</b> <b>AllowUpdate</b> property is set to True. Otherwise, an exception is raised.</p>
<p>
If the <b>RecordSelectors</b> property is True, the user can select an entire row by clicking the record selector icon for that row.</p>
<h3>Working with Ranges</h3>
<p>
The <b>DBGrid</b> control allows you to select ranges of cells, as in a spreadsheet. However, it does not provide any automatic functionality for working with ranges (such as copying, deleting, or moving entire "blocks" of fields or records). If you wish to implement such capability, you will have to do so in code.</p>
<p>
Information about selected ranges is returned in two ways:
<ul type=disc>
<li>
The <b>DBGrid</b> cells themselves are returned in the <b>SelStartCol</b> and <b>SelEndCol</b>. <br><br></li>
<li>
Bookmarks pointing to the database records that are displayed in the selected range are returned in the <b>SelBookmarks</b> property. </li>
</ul>
<p>
For example, to delete a selected range of records:
<ol>
<li>
Loop through the SelBookmarks collection, using the <b>Count</b> property to detect the limits of the collection. <br><br></li>
<li>
Each time through the loop, set the <b>Bookmark</b> property of the <b>RemoteData</b> control's <b>CrdoResultset</b> object to the Bookmark in the SelBookmarks collection, and delete the record. </li>
</ol>
<p>
These steps are illustrated in the following code example:</p>
<pre><code>void DeleteRows_Click( )&nbsp;&nbsp;&nbsp; my attempt
{
 &nbsp; while ( DBGrid1-&gt;GetSelBookmarks( )-&gt; GetCount( ) != 0 )
 &nbsp; {
 &nbsp; RDC1-&gt;GetResultset( )-&gt;GetBookmark( ) = DBGrid1-&gt;SetBookmarks(COleVariant(0));
 &nbsp; RDC1-&gt;GetResultset-&gt;Delete( );
 &nbsp; } 
}
</code></pre>
<h3>Displaying Calculated Fields</h3>
<p>
It is possible to use <b>DBGrid</b> to display calculated fields; calculated fields do not actually appear in the database, but are calculated from the data in stored fields. An example of a calculated field would be displaying a "sales tax" column when the database contains only a "price" field. If the sales tax in your locality were 7 percent, the calculation for sales tax would be "price x .07."</p>
<p>
To display a calculated field:
<ol>
<li>
Add an unbound field to the <b>DBGrid</b>.<br><br></li>
<li>
On the RowLoaded event, perform the calculation and assign the result to the column's <b>Value</b> property. </li>
</ol>
<p>
For more details on using the Apex Data Grid control, search online Help for "DBGrid".</p>
</BODY>
</HTML>
