<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Porting Your 16-Bit Microsoft Office-Based Solutions to 32-Bit Microsoft Office</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_32bitapi"></a>Porting Your 16-Bit Microsoft Office-Based Solutions to 32-Bit Microsoft Office</h1>
<p>
Microsoft Corporation</p>
<p>
November 4, 1996</p>
<h3>Contents</h3>
<p>
<a href="#32bitintro">Introduction</a></p>
<p>
<a href="#32bithoworg">How This Article Is Organized</a></p>
<p>
<a href="#32bitwhichapi">Which API Should Your Solution Code Call?</a></p>
<p>
<a href="#32bitcallingapi">Calling the Win32 API</a></p>
<p>
<a href="#32bitsinglecode">Writing a Single Code Base for 16-Bit and 32-Bit Office Applications</a></p>
<p>
<a href="#32bitdetermin">Determining Whether a 32-bit Application Is Running</a></p>
<p>
<a href="#32bitrecompil">Recompiling DLLs</a></p>
<p>
<a href="#32bitthunkin">Thunking</a></p>
<p>
<a href="#32bitadvtools">Advanced Programming Topics</a></p>
<p>
Microsoft® Office 97 requires you to port your 16-bit solutions written in Office version 4.<i>x</i> applications to the 32-bit Windows® platforms (Windows 95 and Windows NT®). In general, 16-bit solutions ported to 32-bit Windows are not affected. For example, existing 16-bit Office solutions, 16-bit Microsoft Visual Basic®, and 16-bit Microsoft FoxPro® applications will run just fine on Windows 95 or Windows NT. Changes to your existing code are required only if the following conditions are both true:
<ul type=disc>
<li>
Your 16-bit Office solution (including Microsoft Access or Microsoft Project for Windows 95) calls a 16-bit Windows application programming interface (API) or a 16-bit Windows dynamic-link library (DLL).<br><br></li>
<li>
You are porting that code to a 32-bit Office application (again, including Microsoft Access 95 or Microsoft Project 95).</li>
</ul>
<p>
You must port your solution code because 16-bit API calls and 16-bit DLL calls (referred to in this document simply as API calls) will not execute correctly when the solution code containing those calls is run in an Office 97 application. This document applies to solution code that uses APIs in the following products: Microsoft Excel, Microsoft Project, Microsoft Access, and Microsoft Word for Windows.</p>
<h2><a name="32bitintro"></a>Introduction</h2>
<p>
To ensure that their Microsoft Office-based solutions run successfully under Windows 95 and Windows NT, solution providers and corporate developers must keep the following limitations in mind:
<ul type=disc>
<li>
Neither a 32-bit compiled application nor solution code called from a 32-bit Office application can make direct 16-bit API or DLL calls. In addition, neither a 16-bit compiled application nor solution code called from a 16-bit application can make direct 32-bit API or DLL calls. This inability to make calls back and forth between 16-bit and 32-bit layers occurs in both the Windows 95 and Windows NT environments because of their advanced flat-memory–model management systems, as well as the way in which they load DLLs.<br><br></li>
<li>
To prepare for Office 97, you must change your solution code to make Win32® API calls when the solution code is executed from 32-bit Office applications. If this is not possible (for example, you don't have access to the source code of the DLL), you must change the solution code to thunk through an intermediate DLL to make the 16-bit API call. The good news is that updating solution code to support Win32 API calls is a relatively simple mechanical process. A more significant task is to write code that is operating-system independent (that is, so the solution code will run on both 16-bit and 32-bit Office applications). This document will discuss both of these tasks, as well as other 16- to 32-bit API issues you may need to handle.<p class=tl>
<b>Note:</b> Although you must update API calls when porting solution code to 32-bit operating systems, you do not need to change code that uses automation or dynamic data exchange (DDE). All OLE and DDE code will continue to work regardless of whether the applications are 16-bit or 32-bit. OLE and DDE insulate automation calls, so all combinations of containers (clients) and servers (16/16, 16/32, 32/16, and 32/32) will work under Windows 95 and Windows NT.</P></li>
</ul>
<h2><a name="32bithoworg"></a>How This Article Is Organized</h2>
<p>
What you need to know depends on your situation; therefore, this document is organized in terms of complexity, from the easier issues to the more complex ones.
<ul type=disc>
<li>
“Which API Should Your Solution Code Call?” is a quick overview of which API you should be using, according to your application needs.<br><br></li>
<li>
"Calling the Win32 API" describes what an API is and discusses the issues involved in converting existing 16-bit API calls to Win32 API calls, finding declaration statements, and finding error codes.<br><br></li>
<li>
"Writing a Single Code Base for 16-Bit and 32-Bit Office Applications" supplies code samples for writing solution code that will run on both a 16-bit and a 32-bit Office application.<br><br></li>
<li>
"Determining Whether a 32-Bit Application Is Running" describes how to determine whether your Office application is 16-bit or 32-bit and how to select the appropriate 16-bit or 32-bit API call.<br><br></li>
<li>
"Recompiling DLLs" tells you what you will need to do to make the DLL and solution code work on Windows 95 and Windows NT if your solution code calls a custom DLL.<br><br></li>
<li>
"Thunking" tells you how, if you cannot recompile your DLLs, you can add an intermediate DLL.<br><br></li>
<li>
"Advanced Programming Topics" discusses translating API declarations in C to Visual Basic or Visual Basic for Applications.</li>
</ul>
<h2><a name="32bitwhichapi"></a>Which API Should Your Solution Code Call?</h2>
<p>
When you write solution code for yourself, you write it for the version of the Office application you have and for your operating system. Distributing this solution to others means that you have to make it work on their computers as well, which may use different versions of Windows and Office applications than you used when you wrote it. It happens that the operating system is a moot issue. What is important is whether the Office application is 16-bit or 32-bit. The following table shows that the application, not the operating system, determines which API you use in porting your solution code.</p>
<p class=label>
<b>Table 1. Appropriate Windows API (and DLL) Calls Across Systems and Applications</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=23%><b>Microsoft Product</b></td>
<td class=label width=19%><b>Windows 3.<i>x</i></b></td>
<td class=label width=14%><b>Win32s</b></td>
<td class=label width=18%><b>Windows NT</b></td>
<td class=label width=26%><b>Windows 95</b></td>
</tr>
<tr valign=top>
<td width=23%>16-bit applications</td>
<td width=19%>16-bit API</td>
<td width=14%>16-bit API</td>
<td width=18%>16-bit API</td>
<td width=26%>16-bit API</td>
</tr>
<tr valign=top>
<td width=23%>32-bit applications</td>
<td width=19%>N/A</td>
<td width=14%>32-bit API</td>
<td width=18%>32-bit API</td>
<td width=26%>32-bit API</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Microsoft Office (including 32-bit Microsoft Access and 32-bit Microsoft Project) products do not run on Win32s®, but since Microsoft FoxPro does, the Win32s column was added to show that FoxPro programmers should use the same rules for choosing the API. Also, Win32s, Windows NT, and Windows 95 do not have identical sets of API calls. For more information, see the Compatibility Tables in the <i>Win32 Programmer's Reference</i>, MSDN Library, Win 32 Software Development Kit (SDK).</p>
<h2><a name="32bitcallingapi"></a>Calling the Win32 API</h2>
<p>
Porting code to the 32-bit Windows API consists of four steps.
<ol>
<li>
Understanding Windows API calls.<br><br></li>
<li>
Understanding the differences between 16-bit and 32-bit Windows APIs.<br><br></li>
<li>
Using Win32API.txt to find the correct <b>Declare</b> statement.<br><br></li>
<li>
Testing an API <b>Declare</b> statement.</li>
</ol>
<h3>What Is an API Call?</h3>
<p>
In practical terms, Windows API calls are what applications use to request services (such as screen control, printers, and memory) from the operating system. An API call in C, Visual Basic, or other languages places a series of values (parameters) at a location in memory (the stack) and then requests the operating system or DLL to execute a function (the procedure call) using the values provided. The function reads the values (call stack) and executes its function code using those values or the data that the values point to. If a result is returned, it is placed at another location (return register) for the calling application to use. This is shown Figure 1.</p>
<p>
<img src="32bitapi_1.gif" border=0></p>
<p class=label>
<b>Figure 1. A model of an API call</b></p>
<p>
To ensure accuracy, the number of bytes of data on the stack is verified before and after the procedure is called. The message "Bad DLL calling convention" appears when the wrong number of bytes are on the stack.</p>
<p>
There are approximately 300 API calls in Windows 3.0, over 700 API calls in Windows 3.1, and over 1,000 API calls in Windows 95. These API calls are packaged in application (.exe) files and DLLs found in the Windows folder—User.exe, GDI.exe, and one of the following KERNEL files: Krnl286.exe, Krnl386.exe, or Kernel32.dll.</p>
<p>
To call an API from your solution code:
<ol>
<li>
Identify the file containing the API.<br><br></li>
<li>
Determine the parameters required by the API.<br><br></li>
<li>
Create a <b>Declare</b> statement for the API.<br><br></li>
<li>
Call the function with valid parameters.</li>
</ol>
<p>
The following example shows the <b>GetVersion</b> API call that obtains the version of Windows that is running. The <b>GetVersion</b> API call is located in KERNEL under 16-bit Windows and does not use any parameters (so the <b>Declare</b> statement has empty parentheses). The following <b>Declare</b> statement is written for use by Microsoft Visual Basic for Applications running on 16-bit Windows.</p>
<pre><code>Declare Function GetVersion Lib "KERNEL" () As Long
</code></pre>
<p>
In comparison, here is the same function as it would be used by an Office 97 application running on 32-bit Windows.</p>
<pre><code>Declare Function GetVersion Lib "KERNEL32" () As Long
</code></pre>
<p>
Although the Windows API name stays the same, note that the location of the API has changed to KERNEL32. Since you are calling from a 32-bit application, you must make a 32-bit API call. The parameter data type, on the other hand, did not change (it remained a <b>Long</b>). In general, the function parameters will change more and require more attention than the parameters of the return value. Understanding the differences between 16-bit API calls and 32-bit API calls is essential to porting your solution code to Windows 95.</p>
<h3>What Are the Differences Between a 16-Bit Windows API and a 32-Bit Windows API?</h3>
<p>
Most 32-bit Windows API calls have the same name or a very similar name to the 16-bit API calls. In fact, the documentation may show the same arguments, with the only apparent difference being the library name change from KERNEL to KERNEL32, as shown in the previous example. In addition to name changes, code must handle changes to:
<ul type=disc>
<li>
Case sensitivity. <br><br></li>
<li>
Unicode or ANSI options.<br><br></li>
<li>
Parameter data types.</li>
</ul>
<p>
Such changes can require subtle differences in the <b>Declare</b> statements that are not always easy to identify.</p>
<h4>Case sensitivity</h4>
<p>
API calls under 16-bit Windows are not case sensitive—they work if you enter the function name as GetVERSION, GeTvErSiOn, or getversion. In other words, in 16-bit Windows the following statements are equivalent.</p>
<pre><code>Declare Function GetVersion Lib "KERNEL" () As Long
Declare Function GeTvErSiOn Lib "KERNEL" () As Long
</code></pre>
<p>
API calls under 32-bit Windows are case-sensitive—you must enter the function name correctly in the <b>Declare</b> statement. In other words, in 32-bit Windows the following statements are not equivalent.</p>
<pre><code>Declare Function GetVersion Lib "KERNEL32" () As Long
Declare Function GeTvErSiOn Lib "KERNEL32" () As Long
</code></pre>
<p>
The easiest way to handle this change is to always use the <b>Alias</b> keyword. When you use the <b>Alias</b> keyword, the contents of the <b>Alias</b> string maps to the actual API call name (which is case sensitive), but the function name used in code, which appears between <b>Function</b> and <b>Lib</b>, is not case sensitive and will not change if you type it different ways in your code or use the same name for variables or procedures. </p>
<p>
As long as you spell and type the function name correctly in the <b>Alias</b> string and you spell the function name in code the same as in the <b>Declare</b> statement, the function will be mapped automatically by Visual Basic or Visual Basic for Applications back to the correct <b>Declare</b> function. Using the <b>Alias</b> keyword, you would enter the <b>GetVersion</b> function (for 32-bit Windows) as follows.</p>
<pre><code>Declare Function GetVersion Lib "KERNEL32" Alias "GetVersion" () As Long
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The <b>Alias</b> keyword is the most important thing you can use in preparing to switch to 32-bit Windows because it means you will only have to change the contents of the <b>Declare</b> statement and not every instance of the function being called in your code.</p>
<h4>Unicode or ANSI options</h4>
<p>
Both Windows NT and Windows 95 have two API interfaces. One interface is based on the American National Standards Institute (ANSI) character set, where a single byte represents each character. The other interface was created for the Unicode character set, where two bytes represent each character. All 16-bit Windows operating systems and applications use the ANSI character set. All 32-bit versions of Windows added Unicode so that foreign language characters could be represented because some languages have many more characters than the 26 letters of English. C programmers handle this by setting a flag in their include file (*.H). The flag causes hundreds of macros throughout the C include files to select the correct Unicode or ANSI functions.</p>
<p>
All western language versions of Office products use ANSI for Visual Basic for Applications code. Therefore, programmers using current versions of Visual Basic for Applications or macro languages will always use the ANSI version of the API call. (When using the Win32API.txt file, documented later in this paper, this choice is made for you.)</p>
<p>
You can distinguish the ANSI version from the Unicode version because the ANSI version adds an “A” to the end of the API name and the Unicode version adds a “W.” (“W” is for wide, as in the width of the bytes provided for characters.) Note that the name of an API call adds the characters “A” and “W” at the end of the API name only if the API requires parameters with string (character) data types.</p>
<p>
The Win32 SDK documentation in the MSDN Library does not record the permutations of the name of the API call. The documentation gives only the name of the root function and its library name. The actual name of the API in the MSDN Library may be one of three possibilities:
<ul type=disc>
<li>
<b>MyAPICall</b>, which uses no character strings in the call.<br><br></li>
<li>
<b>MyAPICallA</b>, which uses ANSI character strings in the call.<br><br></li>
<li>
<b>MyAPICallW</b>, which uses Unicode character strings in the call.</li>
</ul>
<p>
A visual picture of the amount of data the API expects to find on the stack may help to illustrate the differences. Figure 2 shows possible call stacks for an example function (the 16-bit version is padded because 16-bit Windows always pads the stack to 16 bits).</p>
<p>
<img src="32bitapi_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The different stacks possible for the same API call</b></p>
<p>
The following example shows the three possible declarations for <b>MyAPICall</b> (formatted to make comparison easier). Note that all of the statements use the <b>Alias</b> keyword so that the function name used in code (<b>MyAPICall</b>) does not have to change even if the name of the function called is appended with an “A” or a “W.”</p>
<pre><code>' 16 bits.
Declare Function MyAPICall Lib "MYDLL.DLL" Alias "MyAPICall" ( _
 &nbsp; ByVal hwndForm As Integer, _
 &nbsp; ByVal lpstrCaption$, _
 &nbsp; ByVal hAccKey As String, _
 &nbsp; ByVal iMagicNumber As Integer _
 &nbsp; ) As Integer
' 32-bit ANSI.
Declare Function MyAPICall Lib "MYDLL32.DLL" Alias "MyAPICallA" ( _
 &nbsp; ByVal hwndForm As Long, _
 &nbsp; ByVal lpstrCaption$, _
 &nbsp; ByVal hAccKey As String, _
 &nbsp; ByVal iMagicNumber As Long _
 &nbsp; ) As Long
' 32-bit UNICODE * For illustration only.
Declare Function MyAPICall Lib "MYDLL32.DLL" Alias "MyAPICallW" ( _
 &nbsp; ByVal hwndForm As Long, _
 &nbsp; ByVal lpstrCaption$, _
 &nbsp; ByVal hAccKey As String, _
 &nbsp; ByVal iMagicNumber As Long _
 &nbsp; ) As Long
</code></pre>
<p>
Any one of these declarations would add the function <b>MyAPICall</b> to your application; you can only have one <b>MyAPICall</b> function.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This code sample uses&nbsp; the <b>ByVal</b> keyword, which enables you to pass Visual Basic parameters to an API function <i>by value</i>. By value is the default for functions written in C and is therefore the default for Windows API calls. You must use <b>ByVal</b> because Visual Basic and Visual Basic for Applications default to <b>ByRef</b> (<i>by reference</i>, which passes a pointer to the value rather than the value itself), which is not what API calls expect. <b>ByVal</b> can also be used to convert a Visual Basic string to a C string (null-terminated). <b>ByVal</b> is included in the <b>Declare</b> statements in Win32API.txt so that you will know when to use it. For more information on <b>ByVal</b>, see the Knowledge Base article Q110219, "How to call Windows API from VB" in the MSDN Library or published references such as <i>The Visual Basic Programmer's Guide to the Windows API</i> by Dan Appleman. </p>
<h4>Parameter data type</h4>
<p>
For your use with this document, Microsoft provides a Visual Basic declaration file, Win32API.txt, which gives the new required parameter data types for 32-bit API functions. This document is available on the Office Developer Forum under Free Software at <a href="http://www.microsoft.com/accessdev/a-free.htm">http://www.microsoft.com/accessdev/a-free.htm</a> as a self-extracting file and in the Microsoft Office 97 Developer Edition. All you will need to do is copy the API <b>Declare</b> statement you want from Win32API.txt into your source code.</p>
<p>
Another source of information is the <i>Win32 Programmer's Reference</i> (MSDN Library, Win32 SDK), which is discussed in <a href="#32bitadvtools">Advanced Programming Topics</a> later in this paper. This reference may occasionally be required to resolve questions about the inclusion or exclusion of the <b>ByVal</b> keyword in the declaration or the need to put parentheses around the actual value passed.</p>
<p>
If you use the <i>Win32 Programmer's Reference</i>, however, you must be careful to properly convert C data types to Visual Basic data types. For example, don't mistake a C <b>int</b> for a Visual Basic for Applications <b>Integer</b>. Many Windows data types and Visual Basic <b>Integer</b> data types are no longer the same size, as shown in the following Table 2. It is critical to remember that the sizes of many API parameters have changed; do not assume they are the same.</p>
<p class=label>
<b>Table 2. Data Type Sizes</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Visual Basic data types</b></td>
<td class=label width=20%><b>Size of variable</b></td>
<td class=label width=27%><b>16-bit Windows data types</b></td>
<td class=label width=28%><b>32-bit Windows data types</b></td>
</tr>
<tr valign=top>
<td width=25%>Integer</td>
<td width=20%>2 bytes</td>
<td width=27%><b>int</b><br>
<b>short</b><br>
<b>WORD<br>
HWND</b><br>
<b>HANDLE</b><br>
<b>WCHAR</b></td>
<td width=28%><b>short</b><br>
<b>WCHAR</b></td>
</tr>
<tr valign=top>
<td width=25%>Long</td>
<td width=20%>4 bytes</td>
<td width=27%><b>long</b><br>
<b>LPSTR</b></td>
<td width=28%><b>int</b><br>
<b>long</b><br>
<b>HANDLE</b><br>
<b>HWND</b><br>
<b>LPSTR</b></td>
</tr>
</table><br>
<p>
Finally, whichever resource you choose, judicious use of the <b>Alias</b> keyword may assist you with changing parameter data types by allowing existing 16-bit <i>code</i> (italicized to point out that <i>code</i> does not include the <b>Declare</b> statement, which must change to point to a 32-bit API) that calls the API to be left unchanged. That is because the <b>ByVal</b> keyword and automatic type conversion in Visual Basic and Visual Basic for Applications will change the size of parameters for you in many cases (for example, <b>Integer</b> to <b>Long</b>). Alternatively, type conversion will extend integers with a sign (+/-), which may lead to incorrect long parameters and cause overflows on conversion from <b>Long</b> to <b>Integer</b>. Again, the best solution is to check the references to get the correct functions.</p>
<h3>What Types of Errors Can Occur with an API Declare Statement?</h3>
<p>
After you create a <b>Declare</b> statement, you may find that it doesn't work. This section describes the common errors made in a <b>Declare</b> statement.</p>
<h4>Error 453: Function is not defined in specified DLL</h4>
<p>
Either the function name is misspelled or it has a problem with case. Remember that the functions are case sensitive in 32-bit Windows; they were not case sensitive in 16-bit Windows.</p>
<h4>Error 48: Error in loading DLL</h4>
<p>
Usually, this error is caused by having the wrong size of arguments, but may also occur for some of the reasons described under Error 53.</p>
<h4>Error 53: File not found</h4>
<p>
The general cause of this error is a mismatch of calls and environment. Windows checks the loaded libraries for matches and, if the DLL is not loaded, it will attempt to load the DLL from disk. Many functions available in the 16-bit Windows on Windows (WOW) layer on a Windows NT system are not available directly from Windows NT. Calling the 16-bit Windows and Win32 <b>GetProfileString</b> function from a 16-bit and a 32-bit solution will give a confusing set of error messages. The 16-bit application call will find KERNEL and fail to find KERNEL32, while the 32-bit application will find KERNEL32 and fail to find KERNEL. To avoid this error, write code that works in both 16-bit and 32-bit environments.</p>
<p>
Assuming that you can now code the API call and call it successfully from solution code, you're ready to attack the next problem.</p>
<h2><a name="32bitsinglecode"></a>Writing a Single Code Base for 16-Bit and 32-Bit Office Applications</h2>
<p>
With 32-bit applications using the same solution code as 16-bit applications, you do not know which API to call in the solution code. Your solution code must determine whether the application is a 16-bit application or a 32-bit application so that it can make the appropriate call.</p>
<p>
<img src="32bitapi_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Flow for determining API calls</b></p>
<p>
To determine whether the application is 16-bit or 32-bit, the code must answer the following questions:
<ul type=disc>
<li>
Microsoft Excel: Is the host application 16-bit Microsoft Excel version 5.0 (make 16-bit API calls) or 32-bit Microsoft Excel 97 (make 32-bit API calls)?<br><br></li>
<li>
Microsoft Access: Is the host application 16-bit Microsoft Access version 2.0 (make 16-bit API calls) or 32-bit Microsoft Access 97 (make 32-bit API calls)?<br><br></li>
<li>
Microsoft Project: Is the host application 16-bit Microsoft Project version 3.0 (make 16-bit API calls) or 32-bit Microsoft Project 95 (make 32-bit API calls)?<br><br></li>
<li>
Word for Windows: Is the host application Microsoft Word version 2.0 or 16-bit Word version 6.0 (make 16-bit API calls) or 32-bit Microsoft Word 97 (make 32-bit API calls)?</li>
</ul>
<p>
Remember, if you make the wrong API call (for example, cross the 16- to 32-bit barrier), an error will occur. </p>
<p>
You can put every API call into a wrapper—a Visual Basic procedure—that checks the "bitness" of the application and selects the appropriate API call. Place these wrappers in class modules so that your code may be easily reused. Some API calls (for example, <b>GetPrinterDriveDirectory</b> and <b>GetWinMetaFileBits</b>) are not available in all 32-bit operating environments, which means that the structure of an API wrapper can become as complex as this:</p>
<pre><code>Function MyAPICall$(ByVal Args)
  If Engine32() Then
 &nbsp;&nbsp;&nbsp;&nbsp; ' Select is rarely needed.
 &nbsp;&nbsp;&nbsp;&nbsp; Select Case OS32() ' Based on GetVersionEx API.
 &nbsp;&nbsp;&nbsp;&nbsp; Case 0 ' Win32s.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....
 &nbsp;&nbsp;&nbsp;&nbsp; Case 1 ' NT 3.1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....
 &nbsp;&nbsp;&nbsp;&nbsp; Case 2 ' NT 3.5.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....
 &nbsp;&nbsp;&nbsp;&nbsp; Case 3 ' Windows 95.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....
 &nbsp;&nbsp;&nbsp;&nbsp; End Select
  Else ' 16-bit.
 &nbsp; ....
  End If
End Function
</code></pre>
<p>
This complexity is the exception and not the rule.</p>
<h3>32-Bit Executables Are Easy</h3>
<p>
Compiled languages, such as Microsoft FoxPro and Microsoft Visual Basic, build 16-bit or 32-bit application executables. The executable targets either 16-bit API calls or 32-bit API calls. You can determine the appropriate API calls while building the application. You can select the calls either by having all the 16-bit declarations in one file and all the 32-bit declarations in another file and manually switch them in a project. Or you can use the <b>#If...#Then...#Else</b> directive and conditional compilation supported by Visual Basic 4.0. If you must support Visual Basic 3.0 and Visual Basic 4.0 applications concurrently, use separate files to reduce code maintenance. If you support FoxPro, you can use 16-bit API calls from compiled 32-bit FoxPro solutions because the <b>RegFN</b> functions will automatically thunk from the 32-bit layer to the 16-bit layer if needed.</p>
<p>
Compiled 32-bit languages may require some minor differences in API calls depending on the 32-bit operating system. For example, developers must program context menus differently for Windows 95 than for Windows NT.</p>
<h2><a name="32bitdetermin"></a>Determining Whether a 32-bit Application Is Running</h2>
<p>
The previous section discussed how to write application-independent code by adding code for both 16- and 32-bit scenarios. However, you still need your source code to determine whether the application is a 32-bit application or a 16-bit application without doing any API calls (you can't do an API call because you don't know if a 16-bit API call or a 32-bit API call will work). The following code determines if the application is a 32-bit application.</p>
<h3>Microsoft Excel 5.0, Microsoft Excel 95, Microsoft Excel 97, Microsoft Word 97, Microsoft Project 4.0, Microsoft Project 95</h3>
<pre><code>Function Engine32%()
 &nbsp; If instr(Application.OperatingSystem,"32") Then Engine32% = True
End Function
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The <b>OperatingSystem</b> property of <b>Application</b> does not return the version of Windows you have installed; it returns the layer of Windows that the application is running on (for example, the 16-bit subsystem in Windows NT).</p>
<h3>Microsoft Word 6.0, Microsoft Word 95</h3>
<pre><code>Function Engine32
 &nbsp; If Val(GetSystemInfo$(23)) &gt; 6.3 Or Len(GetSystemInfo$(23)) = 0 Then Engine32 = - 1 Else Engine32 = 0
End Function
</code></pre>
<h3>Microsoft Access 1.1 or Later</h3>
<pre><code>Function Engine32% ()
 &nbsp; If SysCmd(7) &gt; 2 Then Engine32% = True
End Function
</code></pre>
<p>
The following example uses the <b>GetTickCount</b> function to call the correct API function name.</p>
<pre><code>Declare Function GetTickCount32 Lib "KERNEL32" Alias "GetTickCount" () As Long
Declare Function GetTickCount16 Lib "USER" Alias "GetTickCount" () As Long

Function GetTickCount() As Long
 &nbsp; If Engine32%() Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetTickCount = GetTickCount32()
 &nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetTickCount = GetTickCount16()
 &nbsp; End If
End Function
</code></pre>
<p>
The <b>GetTickCount</b> API function has the same name for both 16-bit Windows and 32-bit Windows, so you must use an <b>Alias</b> keyword to change the function name in at least one of the <b>Declare</b> statements. In the preceding example, the names in both <b>Declare</b> statements were changed (to GetTickCount32 and GetTickCount16). Next, depending on the application's "bitness", the <b>GetTickCount</b> function is mapped to the correct API function name (GetTickCount32 or GetTickCount16) and its associated API call. In this example, the <b>GetTickCount</b> function in your code will be mapped to GetTickCount32 (in the <b>GetTickCount</b> function), which is mapped to <b>GetTickCount</b> in KERNEL32, when Engine32% is <b>True</b>.</p>
<h2><a name="32bitrecompil"></a>Recompiling DLLs</h2>
<p>
So far, this document has focused on updating Windows API calls — but the situation for solution code that calls 16-bit DLLs you have bought, developed, or simply used is exactly the same. The developer must change all 16-bit DLL <b>Declare</b> calls in solution code to 32-bit calls. This requires creating a 32-bit version of the DLL (at least) and possibly changing the <b>Declare</b> statement (in Microsoft Excel version 4.0 macros, the <b>Register</b> function). This also means a separate DLL must exist for both the 16-bit application and the 32-bit application. For file management, the name of the 32-bit DLL should end with 32. The developer must recompile the DLL as a 32-bit ANSI DLL. The parameters passed to the DLL must use the <b>stdcall</b>-passing protocol to talk to 32-bit Visual Basic for Applications (instead of the <b>PASCAL</b>-passing protocol used with 16-bit Windows). Remember to place the calls for the 16-bit and 32-bit versions of the DLL in a wrapper similar to the API wrapper described earlier. For more information on recompiling applications, see "Porting 16-Bit Code to 32-Bit Windows," in the Visual C++ documentation in the MSDN Library, or consult your C compiler vendor's documentation.</p>
<h2><a name="32bitthunkin"></a>Thunking</h2>
<p>
In some cases, you may not have the source code of a DLL. If so, your solution is to use thunking to port your solution to Windows 95. Thunking enables direct 16-bit and 32-bit calls but requires much more work than simply changing the Windows API call. If you cannot change or recompile the 16-bit DLL, you must write a new 32-bit DLL wrapper to access the 16-bit DLL. The 32-bit application calls to this 32-bit wrapper DLL, which then talks to the original 16-bit DLL.</p>
<p>
Thunking allows parameters to be pushed correctly on the stack, enables a DLL of a different "bitness" to load in your process, and converts memory addresses from <b>offset</b> (32-bit) to <b>segment::offset</b> (16-bit). This means, however, that there are some challenges even if you do the thunking work. For example, pointers to pointers to memory locations require additional work in 16-bit and 32-bit scenarios.</p>
<p>
Note that there are different ways to thunk depending on your operating system. Window 95 and Windows NT thunk differently. This section gives an overview of thunking across the Windows platforms and contains pointers to more detailed information on thunking.</p>
<h2><a name="32bitadvtools"></a>Advanced Programming Topics</h2>
<p>
You can use your knowledge of the C programming language to create <b>Declare</b> statements for Visual Basic and Visual Basic for Applications using the tools you already have.</p>
<h3>Working from C Declarations</h3>
<p>
Apart from the API location changing (from KERNEL to KERNEL32), the main issue in moving from 16-bit API calls to 32-bit API calls is the change in the size of parameter data types. Some background information may help you to understand what has changed and why. Windows 3.0 was designed for the Intel 80286 CPU, where the hardware handles data 2 bytes at a time or in 16-bit words. Windows 95 was designed for later CPUs, where the hardware can handle data 4 bytes at a time or in 32-bit words. A look at how Visual Basic represents an <b>Integer</b> versus how Windows represents an <b>int</b> reveal these differences:
<ul type=disc>
<li>
<b>Integer</b> and <b>int</b> are each 2 bytes in the 16-bit Windows operating system and in 16-bit Microsoft Excel, Visual Basic, Microsoft Access, Word for Windows, and Microsoft Project.<br><br></li>
<li>
<b>Integer</b> is 2 bytes in 32-bit Microsoft Excel, Visual Basic, Microsoft Access, Word for Windows, and Microsoft Project, the same as in the 16-bit versions of these products.<br><br></li>
<li>
<b>int</b> is 4 bytes in the 32-bit Windows operating systems, Windows 95 and Windows NT.</li>
</ul>
<p>
To illustrate how this change of size can change a call, recall the fictional <b>MyAPICall</b> API used earlier. The <b>MyAPICall</b> call needs the handle to the application's window (HWND), a string, a character, and an integer to be placed on the stack. In C, the function would be:</p>
<pre><code>int MyAPICall (HWND hwndForm, LPSTR lpstrCaption, TCHAR tchAccKey,int iMagicNumber)
</code></pre>
<p>
Each parameter has two parts: the data type (<b>HWND</b>, <b>LPSTR</b>, <b>TCHAR</b>, <b>int</b>) and the field name (<b>hwndForm</b>, <b>lpstrCaption</b>, <b>tchAccKey</b>, <b>iMagicNumber</b>). Each data type requires a specific number of bytes to represent it. Each field begins with prefix characters (known as Hungarian notation) that indicate the data type, such as <b>int</b> or <b>lpstr</b>.</p>
<p>
Windows has many data types that API calls use as parameters. The following table shows some of the more significant data types used by Windows 95 API calls. Many Windows data types use the C data type <b>int</b>. When <b>int</b> changed from 16-bit to 32-bit, the related Windows data types also changed.</p>
<p class=label>
<b>Table 3. Significant Data Types Used by Windows 95</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=35%><b><br>
<br>
C data type</b></td>
<td class=label width=33%><b>Windows 3.<i>x</i> <br>
and Windows for<br>
Workgroups 3.<i>x</i> (16-bit)</b></td>
<td class=label width=32%><b>Win32s, Windows NT, and Windows 95 <br>
(32-bit)</b></td>
</tr>
<tr valign=top>
<td width=35%><b>unsigned int</b>, <b>UINT</b>, <b>int</b></td>
<td width=33%>2 bytes</td>
<td width=32%>4 bytes</td>
</tr>
<tr valign=top>
<td width=35%><b>short</b></td>
<td width=33%>2 bytes</td>
<td width=32%>2 bytes</td>
</tr>
<tr valign=top>
<td width=35%><b>long</b></td>
<td width=33%>4 bytes</td>
<td width=32%>4 bytes</td>
</tr>
<tr valign=top>
<td width=35%><b>char</b>, <b>CHAR</b></td>
<td width=33%>1 byte</td>
<td width=32%>1 byte</td>
</tr>
<tr valign=top>
<td width=35%><b>WORD</b></td>
<td width=33%>2 bytes</td>
<td width=32%>2 bytes</td>
</tr>
<tr valign=top>
<td width=35%>Handle (<b>hWnd</b>, <b>hDC</b>, <b>hMenu</b>)</td>
<td width=33%>2 bytes</td>
<td width=32%>4 bytes</td>
</tr>
<tr valign=top>
<td width=35%><b>LPSTR</b></td>
<td width=33%>4 bytes</td>
<td width=32%>4 bytes</td>
</tr>
<tr valign=top>
<td width=35%><b>WCHAR</b></td>
<td width=33%>2 bytes</td>
<td width=32%>2 bytes</td>
</tr>
<tr valign=top>
<td width=35%><b>TCHAR</b> (ANSI or Unicode)</td>
<td width=33%>1 byte</td>
<td width=32%>1 or 2 bytes</td>
</tr>
<tr valign=top>
<td width=35%><b>POINT</b></td>
<td width=33%>4 bytes</td>
<td width=32%>8 bytes</td>
</tr>
</table><br>
<p>
Thus, converting our <b>MyAPICall</b> API call from C, the declarations for <b>MyAPICall</b> using Visual Basic for Applications, Access Basic, or WordBasic would be as follows (formatted to make comparison easier):</p>
<pre><code>' 16 bits.
Declare Function MyAPICall Lib "MYDLL.DLL" Alias "MyAPICall" ( _
 &nbsp; ByVal hwndForm As Integer, _
 &nbsp; ByVal lpstrCaption As String, _
 &nbsp; ByVal hAccKey As String, _
 &nbsp; ByVal iMagicNumber As Integer _
 &nbsp; ) As Integer
' 32 bits.
Declare Function MyAPICall Lib "MYDLL32.DLL" Alias "MyAPICall" ( _
 &nbsp; ByVal hwndForm As Long, _
 &nbsp; ByVal lpstrCaption As String, _
 &nbsp; ByVal hAccKey As String, _
 &nbsp; ByVal iMagicNumber As Long _
 &nbsp; ) As Long
</code></pre>
<p>
A final tool you may find useful is Table 4, which maps C language declaration data types to their Visual Basic equivalents. </p>
<p class=label>
<b>Table 4. C-Language Declarations and Their Visual Basic Equivalents</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>C language declaration</b></td>
<td class=label width=27%><b>Visual Basic equivalent</b></td>
<td class=label width=43%><b><br>
Call with</b></td>
</tr>
<tr valign=top>
<td width=30%>Boolean</td>
<td width=27%><b>ByVal</b> B <b>As</b> <b>Boolean</b></td>
<td width=43%>Any <b>Integer</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<td width=30%>Pointer to a string (LPSTR)</td>
<td width=27%><b>By</b> Val S <b>As</b> <b>String</b></td>
<td width=43%>Any <b>String</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<td width=30%>Pointer to an integer (LPINT)</td>
<td width=27%>I <b>As</b> <b>Integer</b></td>
<td width=43%>Any <b>Integer</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<td width=30%>Pointer to a long integer (LPDWORD)</td>
<td width=27%>L <b>As</b> <b>Long</b></td>
<td width=43%>Any <b>Long</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<td width=30%>Pointer to a structure (for example, LPRECT)</td>
<td width=27%>S <b>As</b> <b>Rect</b></td>
<td width=43%>Any variable of that user-defined type</td>
</tr>
<tr valign=top>
<td width=30%>Integer (INT, UINT, WORD, BOOL)</td>
<td width=27%><b>ByVal</b> I <b>As</b> <b>Integer</b></td>
<td width=43%>Any <b>Integer</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<td width=30%>Handle (32 bit, HWND)</td>
<td width=27%><b>ByVal</b> H <b>As</b> <b>Long</b></td>
<td width=43%>Any <b>Long</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<td width=30%>Long (DWORD, LONG)</td>
<td width=27%><b>ByVal</b> L <b>As</b> <b>Long</b></td>
<td width=43%>Any <b>Long</b> or <b>Variant</b> variable</td>
</tr>
<tr valign=top>
<td width=30%>Pointer to an array of integers</td>
<td width=27%>I <b>As</b> <b>Integer</b></td>
<td width=43%>The first element of the array, such as I(0)</td>
</tr>
<tr valign=top>
<td width=30%>Pointer to a void (void*)</td>
<td width=27%>V <b>As</b> <b>Any</b></td>
<td width=43%>Any variable (use <b>ByVal</b> when passing a string)</td>
</tr>
<tr valign=top>
<td width=30%>Void (function return value)</td>
<td width=27%><b>Sub</b> procedure</td>
<td width=43%>n/a</td>
</tr>
<tr valign=top>
<td width=30%>NULL</td>
<td width=27%><b>As</b> <b>Any</b></td>
<td width=43%><b>ByVal 0&amp;</b></td>
</tr>
<tr valign=top>
<td width=30%>Char (TCHAR)</td>
<td width=27%><b>ByVal</b> Ch <b>As</b> <b>String</b></td>
<td width=43%>Any <b>String</b> or <b>Variant</b> variable</td>
</tr>
</table><br>
<h3>Using the Win32 Programmer's Reference</h3>
<p>
As stated earlier, the two primary sources for Win32 API information are the <i>Win32 Programmer's Reference</i> and a list of Microsoft-supplied Win32 Declare statements for Visual Basic, such as Win32API.txt. The <i>Win32 Programmer's Reference</i> (MSDN Library, Win32 SDK) contains a listing, with explanations, of the entire Win32 API set. Figure 4 is an example entry.</p>
<p>
<img src="32bitapi_4.gif" border=0></p>
<p class=label>
<b>Figure 4. C declarations for GetProfileString, taken from the <i>Win32 Programmer's Reference</i></b></p>
<p>
In contrast, the declaration from the Windows 3.1 SDK <i>Programmer's Reference</i>, Volume 2, is:</p>
<pre><code>int GetProfileString(
LPCSTR lpszSection,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // address of section
LPCSTR lpszEntry,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // address of entry
LPCSTR lpszDefault,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // address of default string
LPSTR lpszReturnBuffer,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // address of destination buffer
int cchReturnBuffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // size of destination buffer
);
</code></pre>
<p>
Note that the <i>Win32 Programmer's Reference</i> uses <b>DWORD</b> instead of the 32-bit <b>int</b> for the parameter data type for cchReturnBuffer. </p>
<p>
At the top of almost every function entry in the <i>Win32 Programmer's Reference</i> in the MSDN Library, there is a hot spot, Quick Info, that provides essential information for developers. Figure 5 shows the Quick Info hot spot for <b>GetProfileString</b>.</p>
<p>
<img src="32bitapi_5.gif" border=0></p>
<p class=label>
<b>Figure 5. "Quick Info" for GetProfileString</b></p>
<p>
First, Quick Info identifies the Win32 operating systems where the function is available. Second, it identifies the library containing the function. Third, it indicates whether this function has separate ANSI and Unicode versions.</p>
<p>
The declaration in Visual Basic for Applications is:</p>
<pre><code>Declare Function GetProfileString Lib "KERNEL32" _
 &nbsp; Alias "GetProfileStringA"(ByVal lpAppName As String, _
 &nbsp; ByVal lpKeyName As String, ByVal lpDefault As String, _
 &nbsp; ByVal lpReturnedString As String, ByVal nSize As Long) As Long
</code></pre>
<p>
As noted earlier, the use of the <b>Alias</b> keyword allows any existing 16-bit code calling the API to be left unchanged. The following 16-bit Windows API code pasted into Microsoft Excel, Microsoft Project, Microsoft Access, or Visual Basic 4.0 will work correctly with this 32-bit <b>Declare</b> statement.</p>
<pre><code>rc% = GetProfileString(App$,Key$,Def$,RString$,RLen%)
</code></pre>
<p>
This is because although both rc% and Rlen% (the % denotes an integer data type) are the wrong size (2 bytes instead of 4 bytes), the <b>ByVal</b> keyword and automatic type conversion in Visual Basic, Access Basic, WordBasic, and Visual Basic for Applications will change the size for you. (When any of these languages passes the value to the DLL and gets the results, it will typecast them from <b>Integer</b> to <b>Long</b> or from <b>Long</b> to <b>Integer</b> automatically.) This feature removes many porting issues between 16-bit Windows calls and Win32 API calls but also, as mentioned earlier, may cause an overflow on conversion.</p>
</BODY>
</HTML>
