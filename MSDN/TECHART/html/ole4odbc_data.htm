<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Data Manipulation</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1><a name="ole4odbc_data"></a><sup></sup>Data Manipulation</h1>
<p>
Data manipulation in OLE DB can be executed using SQL queries in commands or using the <b>IRowsetChange</b> interface. </p>
<p>
<b>IRowsetChange</b> allows the consumer to:
<ul type=disc>
<li>
Update columns of a row by calling <b>IRowsetChange::SetData</b>.<br><br></li>
<li>
Delete a row or rows by calling <b>IRowsetChange::DeleteRows</b>.<br><br></li>
<li>
Insert a new row by calling <b>IRowsetChange::InsertRow</b>.</li>
</ul>
<h3><a name="ole4odbc_delayed"></a>Delayed Updates</h3>
<p>
OLE DB supports delayed updates. With delayed updates, changes made to the rowset are not transmitted to the data source until <b>IRowsetUpdate::Update</b> is called.</p>
<p>
A rowset can be in delayed or immediate update mode, depending on whether it exposes the <b>IRowsetUpdate</b> interface. The consumer specifies whether <b>IRowsetUpdate</b> should be supported prior to opening the rowset.</p>
<p>
If the <b>IRowsetUpdate</b> interface is not included on the rowset, then the rowset is said to be in immediate update mode, and the changes are immediately transmitted to the data source. If <b>IRowsetUpdate</b> is present, then the changes are not transmitted to the data source until <b>IRowsetUpdate::Update</b> is called.</p>
<p>
For rowsets in delayed update mode, <b>IRowsetUpdate</b> allows the consumer to:
<ul type=disc>
<li>
Retrieve the initial value read for the row by calling <b>IRowsetUpdate::GetOriginalData</b>.<br><br></li>
<li>
Get a list of pending changes by calling <b>IRowsetUpdate::GetPendingRows</b>.<br><br></li>
<li>
Get the pending status of a given set of rows by calling <b>IRowsetUpdate::GetRowStatus</b>.<br><br></li>
<li>
Undo some, or all, of the pending changes by calling <b>IRowsetUpdate::Undo</b>.<br><br></li>
<li>
Commit some, or all, of the changes to the data source by calling <b>IRowsetUpdate::Update</b>.</li>
</ul>
<h4>Prepared commands</h4>
<p>
If a command is to be executed multiple times, it is often more efficient to prepare it. Command preparation tells the query processor to save the execution plan so that it doesn't have to be rebuilt for each execution.</p>
<p>
The <b>ICommandPrepare</b> interface supports methods for preparing a command. Calling <b>ICommandPrepare::Prepare</b> in OLE DB is equivalent to calling <b>SQLPrepare</b> in ODBC.</p>
<h4>Commands with parameters</h4>
<p>
Parameters are used to insert scalar values into a command at execute time. Parameters are generally used in conjunction with a prepared command so that the command can be executed multiple times, each time with a different value.</p>
<p>
To specify parameters in ODBC, an application uses <b>SQLBindParameter</b> and <b>SQLParamData</b> in the following order:
<ol>
<li>
Calls <b>SQLBindParameter</b> for each parameter to specify the parameter type and bind buffers for the parameters values.<br><br></li>
<li>
Calls <b>SQLSetStmtAttr</b> if multiple values are to be specified for each set of parameters.<br><br></li>
<li>
Places the values in appropriate buffers.<br><br></li>
<li>
Calls <b>SQLExecute</b> or <b>SQLExecDirect</b>.</li>
</ol>
<p>
To specify parameters in OLE DB, an application uses the <b>ICommandWithParameters</b> interface in the following order:
<ol>
<li>
Creates an accessor describing the binding information for the set of parameters.<br><br></li>
<li>
Calls <b>ICommandWithParameters::SetParameterInfo</b> to specify the types of the parameters.<br><br></li>
<li>
Calls <b>ICommand::Execute</b> to execute the command, passing a structure containing the accessor, number of parameter sets, and a pointer to data for the parameters.</li>
</ol>
<h4>Binding parameters</h4>
<p>
The consumer specifies parameter descriptions by setting information in the DBPARAMBINDINFO structure passed to <b>ICommandWithParameters::SetParameterInfo</b>. This is similar to the type, precision, and scale information specified in <b>SQLBindParameter</b> in ODBC. </p>
<p>
The DBPARAMBINDINFO structure is:</p>
<pre><code>typedef struct tagDBPARAMBINDINFO
 &nbsp;&nbsp; {
 &nbsp;&nbsp; LPOLESTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwszDataSourceType;&nbsp;&nbsp;&nbsp; // Data type name (OLESTR)
 &nbsp;&nbsp; LPOLESTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwszName;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Name of the parameter
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ulParamSize;&nbsp;&nbsp;&nbsp; // Maximum length of data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // accepted
 &nbsp;&nbsp; DBPARAMFLAGS&nbsp; dwFlags;&nbsp;&nbsp;&nbsp; // Input/output/signed/nullable/object
 &nbsp;&nbsp; BYTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bPrecision;&nbsp;&nbsp;&nbsp; // Precision for numeric data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // types
 &nbsp;&nbsp; BYTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bScale;&nbsp;&nbsp;&nbsp; // Scale for numeric data types
 &nbsp;&nbsp; } DBPARAMBINDINFO;
</code></pre>
<p>
The <b>ICommand::Execute</b> method takes a pointer to the DBPARAMS structure as an argument. This structure includes a pointer to the data as well as an accessor that describes the layout of the data. Bindings described in the accessor are similar to the bindings specified in <b>SQLBindParameter</b> in ODBC. OLE DB allows the specification of multiple sets of parameters in a single call by specifying the number of sets of parameters in the <i>cParamSets</i> element of the DBPARAMS structure. This is similar to calling <b>SQLSetStmtAttr</b> in ODBC.</p>
<p>
The DBPARAMS structure is:</p>
<pre><code>typedef struct tagDBPARAMS
 &nbsp;&nbsp; {
 &nbsp;&nbsp; void __RPC_FAR*&nbsp; pData;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Data, array containing
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parameter values
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cParamSets;&nbsp;&nbsp;&nbsp; // Count of sets of parameter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // values in the data array
 &nbsp;&nbsp; HACCESSOR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hAccessor;&nbsp;&nbsp;&nbsp; // Handle of parameter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // describing accessor
 &nbsp;&nbsp; } DBPARAMS;
</code></pre>
<p>
The following code example shows parameter passing in OLE DB. For the complete source code listing, see Appendix C. The general flow of control is:
<ol>
<li>
Create bindings describing the parameters.<br><br></li>
<li>
Obtain the <b>IDBCreateSession</b> interface.<br><br></li>
<li>
Call <b>CreateSession</b> to create a session object that scopes the transaction boundaries within the current connection.<br><br></li>
<li>
Call <b>CreateCommand</b> to create a command object within the transaction.<br><br></li>
<li>
Call <b>SetCommandText</b> to set the command text.<br><br></li>
<li>
Obtain the <b>ICommandWithParameters</b> interface on the command object.<br><br></li>
<li>
Call <b>SetParameterInfo</b> to specify the parameter information.<br><br></li>
<li>
Prepare the command.<br><br></li>
<li>
Create a parameter accessor.<br><br></li>
<li>
Build a structure containing the parameter information.<br><br></li>
<li>
Call <b>Execute</b>, providing the parameter accessor and parameter <br><br></li>
<li>
  information, to execute the command.<br><br></li>
<li>
Release the command object.<pre><code>/********************************************************************
*&nbsp; Execute a prepared INSERT statement with parameters.
********************************************************************/
HRESULT myInsertWithParameters
 &nbsp;&nbsp; (
 &nbsp;&nbsp; IDBInitialize*&nbsp; pIDBInitialize
 &nbsp;&nbsp; ) 
 &nbsp;&nbsp; {
 &nbsp;&nbsp; IDBCreateSession*&nbsp;&nbsp; pIDBCreateSession;
 &nbsp;&nbsp; IDBCreateCommand*&nbsp;&nbsp; pIDBCreateCommand;
 &nbsp;&nbsp; ICommandText*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pICommandText;
 &nbsp;&nbsp; ICommandPrepare*&nbsp;&nbsp;&nbsp; pICommandPrepare;
 &nbsp;&nbsp; ICommandWithParameters* pICmdWithParams;
 &nbsp;&nbsp; IAccessor*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIAccessor;
 &nbsp;&nbsp; WCHAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wSQLString[] = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("insert into Customers (CustomerID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CompanyName, ContactName,")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" ContactTitle, Address, City, Region, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostalCode, Country,")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" Phone, Fax)")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR(" values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
 &nbsp;&nbsp; DBPARAMS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Params;
 &nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRowsAffected;
 &nbsp;&nbsp; HACCESSOR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hParamAccessor;

 &nbsp;&nbsp; NEWCUSTOMERDATA&nbsp;&nbsp;&nbsp;&nbsp; aNewCustomers[] =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "YOUME",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "You and Me Grocers",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "William Smith",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "General Manager",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "383 15th Ave. N.",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "New York",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "NY",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "10018",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "USA",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(212) 555-8847",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(212) 555-9988",

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "YORBL",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Yorbalinda's",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Mary Jones",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Owner",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "22 Sunny Vale Rd.",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "San Diego",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CA",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "93122",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "USA",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(605) 555-4322",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(605) 555-4323"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp; NEWCUSTOMER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewCustomer;

 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nParams = 11;
 &nbsp;&nbsp; DBPARAMBINDINFO&nbsp;&nbsp;&nbsp;&nbsp; rgParamBindInfo[] = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("DBTYPE_CHAR"),&nbsp;&nbsp;&nbsp; OLESTR("CustomerID"),&nbsp;&nbsp;&nbsp; 5, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("CompanyName"),&nbsp; 40,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("ContactName"),&nbsp; 30, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("ContactTitle"), 30, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Address"),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 60, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("City"),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Region"),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("PostalCode"),&nbsp;&nbsp; 10, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Country"),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("Phone"),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("DBTYPE_VARCHAR"), OLESTR("FAX"),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMFLAGS_ISINPUT, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgParamOrdinals[] = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {1,2,3,4,5,6,7,8,9,10,11};

 &nbsp;&nbsp; // Get the session.
 &nbsp;&nbsp; pIDBInitialize-&gt;QueryInterface(IID_IDBCreateSession,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;pIDBCreateSession);
 &nbsp;&nbsp; pIDBCreateSession-&gt;CreateSession(NULL, IID_IDBCreateCommand,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (IUnknown**) &amp;pIDBCreateCommand);
 &nbsp;&nbsp; pIDBCreateSession-&gt;Release();

 &nbsp;&nbsp; // Create the command.
 &nbsp;&nbsp; pIDBCreateCommand-&gt;CreateCommand(NULL, IID_ICommandText, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (IUnknown**) &amp;pICommandText);
 &nbsp;&nbsp; pIDBCreateCommand-&gt;Release();

 &nbsp;&nbsp; // The command requires the actual text as well as an indicator 
 &nbsp;&nbsp; // of its language.
 &nbsp;&nbsp; pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wSQLString);

 &nbsp;&nbsp; // Set parameter information.
 &nbsp;&nbsp; pICommandText-&gt;QueryInterface(IID_ICommandWithParameters, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;pICmdWithParams);
 &nbsp;&nbsp; pICmdWithParams-&gt;SetParameterInfo(nParams, rgParamOrdinals, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgParamBindInfo);
 &nbsp;&nbsp; pICmdWithParams-&gt;Release();

 &nbsp;&nbsp; // Prepare the command.
 &nbsp;&nbsp; pICommandText-&gt;QueryInterface(IID_ICommandPrepare, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;pICommandPrepare);
 &nbsp;&nbsp; if (FAILED(pICommandPrepare-&gt;Prepare(0)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pICommandPrepare-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pICommandText-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; pICommandPrepare-&gt;Release();

 &nbsp;&nbsp; // Create parameter accessors.
 &nbsp;&nbsp; if (FAILED(myCreateParamAccessor(pICommandText, &amp;hParamAccessor, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pIAccessor)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pICommandText-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; Params.pData = &amp;NewCustomer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pData is the buffer pointer
 &nbsp;&nbsp; Params.cParamSets = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of sets of parameters
 &nbsp;&nbsp; Params.hAccessor = hParamAccessor;// Accessor to the parameters
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Specify the parameter information.
 &nbsp;&nbsp; for (UINT nCust = 0; nCust &lt; 2; nCust++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(NewCustomer.acCustomerID, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szCustID);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(NewCustomer.acCompanyName, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szCompanyName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(NewCustomer.acContactName, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szContactName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(NewCustomer.acContactTitle, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szContactTitle);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(NewCustomer.acAddress, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szAddress);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(NewCustomer.acCity, aNewCustomers[nCust].szCity);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(NewCustomer.acRegion, aNewCustomers[nCust].szRegion);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(NewCustomer.acPostalCode, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szPostalCode);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(NewCustomer.acCountry, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aNewCustomers[nCust].szCountry);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(NewCustomer.acPhone, aNewCustomers[nCust].szPhone);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(NewCustomer.acFAX, aNewCustomers[nCust].szFAX);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Execute the command.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pICommandText-&gt;Execute(NULL, IID_NULL, &amp;Params, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;cRowsAffected, NULL);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%ld rows inserted.\n", cRowsAffected);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; pIAccessor-&gt;ReleaseAccessor(hParamAccessor, NULL);
 &nbsp;&nbsp; pIAccessor-&gt;Release();
 &nbsp;&nbsp; pICommandText-&gt;Release();

 &nbsp;&nbsp; return (NOERROR);
 &nbsp;&nbsp; }
</code></pre>
</li>
</ol>
<h4>Creating parameter accessors</h4>
<p>
Input parameter data is read from, and output parameter data is written to, the specified locations within <i>Params.pData</i> according to the bindings specified by the accessor. An array of parameter sets can be passed in <i>pParamData</i>. <i>cParamSets</i> indicates the number of elements of the array. </p>
<p>
The following code example shows parameter binding for the <i>NEWCUSTOMER</i> structure used in the previous example. The general flow of control is:
<ol>
<li>
Specify the common binding information for all the parameters.<br><br></li>
<li>
Specify the specific binding information for each parameter.<br><br></li>
<li>
Call <b>CreateAccessor</b> to create the parameter accessor.<br><br></li>
<li>
Return the accessor handle along with the interface used to create it (so that it can be freed later).<pre><code>/********************************************************************
*&nbsp; Create parameter accessor.
********************************************************************/
HRESULT myCreateParamAccessor
 &nbsp;&nbsp; (
 &nbsp;&nbsp; ICommand*&nbsp;&nbsp; pICmd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [in]
 &nbsp;&nbsp; HACCESSOR*&nbsp; phAccessor, // [out]
 &nbsp;&nbsp; IAccessor** ppIAccessor // [out]
 &nbsp;&nbsp; )
 &nbsp;&nbsp; {
 &nbsp;&nbsp; IAccessor*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIAccessor;
 &nbsp;&nbsp; HACCESSOR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hAccessor;
 &nbsp;&nbsp; const ULONG&nbsp;&nbsp;&nbsp;&nbsp; nParams = 11;
 &nbsp;&nbsp; DBBINDING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[nParams];
 &nbsp;&nbsp; DBBINDSTATUS&nbsp;&nbsp;&nbsp; rgStatus[nParams]; // Returns information for 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // individual binding
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // validity.
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr;

 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acbLengths[] = {5, 40, 30, 30, 60, 15, 15, 10, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15, 24, 24};

 &nbsp;&nbsp; for (ULONG i = 0; i &lt; nParams; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].iOrdinal = i + 1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].obLength = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].obStatus = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].pTypeInfo = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].pObject = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].pBindExt = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].dwPart = DBPART_VALUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].eParamIO = DBPARAMIO_INPUT;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].cbMaxLen = acbLengths[i];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].dwFlags = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].wType = DBTYPE_STR;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].bPrecision = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings[i].bScale = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; Bindings[0].obValue = offsetof(NEWCUSTOMER, acCustomerID);
 &nbsp;&nbsp; Bindings[1].obValue = offsetof(NEWCUSTOMER, acCompanyName);
 &nbsp;&nbsp; Bindings[2].obValue = offsetof(NEWCUSTOMER, acContactName);
 &nbsp;&nbsp; Bindings[3].obValue = offsetof(NEWCUSTOMER, acContactTitle);
 &nbsp;&nbsp; Bindings[4].obValue = offsetof(NEWCUSTOMER, acAddress);
 &nbsp;&nbsp; Bindings[5].obValue = offsetof(NEWCUSTOMER, acCity);
 &nbsp;&nbsp; Bindings[6].obValue = offsetof(NEWCUSTOMER, acRegion);
 &nbsp;&nbsp; Bindings[7].obValue = offsetof(NEWCUSTOMER, acPostalCode);
 &nbsp;&nbsp; Bindings[8].obValue = offsetof(NEWCUSTOMER, acCountry);
 &nbsp;&nbsp; Bindings[9].obValue = offsetof(NEWCUSTOMER, acPhone);
 &nbsp;&nbsp; Bindings[10].obValue = offsetof(NEWCUSTOMER, acFAX);

 &nbsp;&nbsp; pICmd-&gt;QueryInterface(IID_IAccessor, (void**)&amp;pIAccessor);

 &nbsp;&nbsp; hr = pIAccessor-&gt;CreateAccessor(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBACCESSOR_PARAMETERDATA,&nbsp;&nbsp;&nbsp; // Accessor that will be used 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to specify parameter data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nParams,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of parameters being
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bound
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bindings,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Structure containing bind
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // information
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(NEWCUSTOMER),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Size of parameter structure
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hAccessor,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Returned accessor handle
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Information about binding
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // validity
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );

 &nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DumpError("Parameter accessor creation failed.");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppIAccessor = pIAccessor;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *phAccessor = hAccessor;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }
</code></pre>
</li>
</ol>
</BODY>
</HTML>
