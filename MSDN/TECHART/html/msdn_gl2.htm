<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OpenGL II: Windows Palettes in RGBA Mode</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_gl2"></a></sup>OpenGL II: Windows Palettes in RGBA Mode</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
December 4, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3196">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the GLEasy sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3197">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the GLpal sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
If a program written for the Microsoft® Windows® operating system needs more than 16 colors and is running on an 8-bits-per-pixel (bpp) display adapter, the program must create and use a palette. OpenGL™ programs running on Windows NT™ or (eventually) Windows 95 are no exception. OpenGL imposes additional requirements on the colors and their locations on the palette in RGBA mode. The articles <a href="msdn_gl1.htm">"OpenGL I: Quick Start"</a> and <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started"</a> in the MSDN Library cover the basics of using OpenGL in a Windows-based program and are required reading for this article. Two sample applications, GLEasy and GLpal, accompany this article.</p>
<h2>Introduction</h2>
<p>
It would be nice to get together a small team of dedicated individuals, outfit them with the latest high-tech equipment, and airdrop them all over the world. These individuals would visit homes and offices everywhere, pull out users' existing unaccelerated 8-bits-per-pixel (bpp) graphics cards, and replace them with accelerated cards capable of at least 1024x768x2^24. This would be a community service paid by your tax dollars. All of this should happen because I hate palettes.</p>
<p>
Palettes are confusing. They complicate software development. Yet for systems that can display only 8 bpp, palettes are a necessary evil. With 8 bpp, you can display only 256 colors. The chances that the 256 colors that you want are the same colors that trueSpace™, Corel® Draw, Mathcad, or some other application wants are pretty remote. In fact, a multiple-document interface (MDI) program that loads multiple 8-bpp device-independent bitmaps (DIBs) needs a different palette for each DIB it shows. Therefore, palettes are necessary until we all get 24-bpp display cards—an event that is at least a few years away. (16-bbp display cards don't have palettes either, but they have other limitations. In many cases, they can't display 200 levels of red, green, or blue, which is possible with an 8-bpp card and the correct palette.)</p>
<p>
The moral of the story is: If a program needs more than the 16 system colors and must run on an 8-bpp display card, the program has to use a palette. Programs that use the OpenGL™ graphics library will require more than the 16 system colors to accurately shade objects for a realistic three-dimensional (3-D) display. Therefore, OpenGL programs that run on 8-bpp devices will need palettes.</p>
<p>
This article examines the issues involved in palette management for OpenGL applications in RGBA mode. (For palette requirements in color index mode, see <a href="msdn_gl4.htm">"OpenGL IV: Color Index Mode"</a> in the MSDN Library.) In RGBA mode, colors are stored as red, green, blue, and alpha color components, and not as color indexes. The alpha color component controls color blending. An alpha value of 1.0 implies complete opacity, while an alpha value of 0.0 implies complete transparency.</p>
<p>
In this article, my focus will be on the palette requirements introduced by the Windows NT™ implementation of OpenGL. This article does not provide a general discussion of palettes. For more information on palettes, please refer to the sources listed in the bibliography.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In this article, the term "OpenGL" refers to the Windows NT implementation of OpenGL. Some limitations presented in this article are limitations of OpenGL, some are limitations of the generic pixel formats, and other limitations are associated with the Windows NT implementation of OpenGL.</p>
<h2>PFD_NEED_PALETTE</h2>
<p>
If you remember <a href="msdn_gl1.htm">"OpenGL I: Quick Start"</a>, I punted on the palette issue and told you to read this article. Here's a quick review of what I explained in that article.</p>
<p>
OpenGL requires an active rendering context (RC). Without an active RC, OpenGL commands do nothing. Before you can create an RC and make it active, you must have a device context (DC) with a valid pixel format selected. Once again, I'll punt on pixel formats and refer you to Dennis Crain's article <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started"</a> in the MSDN Library.</p>
<p>
When you choose a pixel format, you specify the number of color bits per pixel desired. If the user's hardware supports 16, 24, or 32 bpps, a palette is not required. On the other hand, if the user's hardware supports only 8 bpps, you do need a palette. You can verify this by looking at the <b>dwFlags</b> field of the <b>PIXELFORMATDISCRIPTOR</b> structure after choosing or setting the palette. If <b>dwFlags</b> has the PFD_NEED_PALETTE flag set, you will need a palette.</p>
<p>
You can use MYGL, the sample application that accompanies Dennis Crain's article, to enumerate through the available generic pixel formats and see that only the 8-bpp pixel formats have the PFD_NEED_PALETTE flag.</p>
<p>
I'll illustrate this with some code from GLEasy, which I took from the OpenGL sample program GENGL (included in the Win32® SDK for Windows NT 3.5). In GLEasy, <b>CGLEasyView::CreateRGBPalette</b> creates the appropriate palette. Let's take a look at this function:</p>
<pre><code>BOOL CGLEasyView::CreateRGBPalette(HDC hDC)
{
 &nbsp; //
 &nbsp; // Check to see if we need a palette.
 &nbsp; //
 &nbsp; PIXELFORMATDESCRIPTOR pfd;
 &nbsp; int n = GetPixelFormat(hDC);
 &nbsp; DescribePixelFormat(hDC, n, sizeof(PIXELFORMATDESCRIPTOR), &amp;pfd);
 &nbsp; if (!(pfd.dwFlags &amp; PFD_NEED_PALETTE)) return FALSE ; 

 &nbsp; // Allocate a log pal and fill it with the color table info.
 &nbsp; LOGPALETTE* pPal = (LOGPALETTE*) malloc(sizeof(LOGPALETTE) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + 256 * sizeof(PALETTEENTRY));
 &nbsp; pPal-&gt;palVersion = 0x300; // Windows 3.0
 &nbsp; pPal-&gt;palNumEntries = 256; // table size

 &nbsp; //
 &nbsp; // Create palette.
 &nbsp; //
 &nbsp; ASSERT( pfd.cColorBits == 8) ;
 &nbsp; n = 1 &lt;&lt; pfd.cColorBits;
 &nbsp; for (int i=0; i&lt;n; i++)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[i].peRed =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ComponentFromIndex(i, pfd.cRedBits, pfd.cRedShift);
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[i].peGreen =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ComponentFromIndex(i, pfd.cGreenBits, pfd.cGreenShift);
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[i].peBlue =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ComponentFromIndex(i, pfd.cBlueBits, pfd.cBlueShift);
 &nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[i].peFlags = 0;
 &nbsp; }

 &nbsp; if ((pfd.cColorBits == 8)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (pfd.cRedBits&nbsp;&nbsp; == 3) &amp;&amp; (pfd.cRedShift&nbsp;&nbsp; == 0) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (pfd.cGreenBits == 3) &amp;&amp; (pfd.cGreenShift == 3) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (pfd.cBlueBits&nbsp; == 2) &amp;&amp; (pfd.cBlueShift&nbsp; == 6))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; for (int j = 1 ; j &lt;= 12 ; j++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[m_defaultOverride[j]] = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_defaultPalEntry[j];
 &nbsp; }

 &nbsp; if (m_pPal) delete m_pPal ;
 &nbsp; m_pPal = new CPalette ;

 &nbsp; BOOL bResult = m_pPal-&gt;CreatePalette(pPal);
 &nbsp; free (pPal);

 &nbsp; return bResult;
}
</code></pre>
<p>
First, <b>CreateRGBPalette</b> determines whether a palette is needed by calling the new Win32 function <b>DescribePixelFormat</b> to get the current pixel format for the DC. <b>CreateRGBPalette </b>then checks the <b>dwFlags </b>field of the current pixel format to see whether PFD_NEED_PALETTE is set. If it isn't, the function returns without creating a palette.</p>
<p>
Unfortunately, PFD_NEED_PALETTE is sometimes set, which means that we need to create a palette. In this case, we allocate a <b>LOGPALETTE</b> structure, <b>pPal</b>, using good old <b>malloc</b>. We fill in the version number and number of entries in the palette, then fill in the <b>palPalEntry</b> array with the colors. More on filling in the numbers in the next section.</p>
<p>
After we fill in the <b>palPalEntry</b> array with 256 wonderful colors, we use <b>pPal</b> to create a palette. <b>CGLEasy::m_pPal</b>, which is a pointer to a <b>CPalette</b> object, points to this palette.</p>
<h2>3-3-2 Palette</h2>
<p>
<b>GLEasyView::CreateRGBPalette</b> fills the 256 <b>PALETTEENTRY</b> structures. For OpenGL to render a picture correctly, <b>CreateRGBPalette</b> must fill these structures with the right colors. <b>CreateRGBPalette</b> uses the following fields in the <b>PIXELFORMATDESCRIPTOR</b> structure to fill in the palette correctly:
<ul type=disc>
<li>
<b>cRedBits</b><br><br></li>
<li>
<b>cRedShift</b><br><br></li>
<li>
<b>cGreenBits</b><br><br></li>
<li>
<b>cGreenShift</b><br><br></li>
<li>
<b>cBlueBits</b><br><br></li>
<li>
<b>cBlueShift</b></li>
</ul>
<p>
These fields determine how the 8 bits are divided into their red, green, and blue color components. <b>c*Bits</b> determines the number of bits allocated for a particular color. <b>c*Shift</b> specifies the location of that color within the 8 bits.</p>
<p>
If you play with the MYGL sample, you will see that the generic formats supported by OpenGL, as implemented in Windows NT, have the following values for these fields:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=60%><b>Field</b></td>
<td class=label width=40%><b>Value</b></td>
</tr>
<tr valign=top>
<td width=60%><b>cRedBits</b></td>
<td width=40%>3</td>
</tr>
<tr valign=top>
<td width=60%><b>cRedShift</b></td>
<td width=40%>0</td>
</tr>
<tr valign=top>
<td width=60%><b>cGreenBits</b></td>
<td width=40%>3</td>
</tr>
<tr valign=top>
<td width=60%><b>cGreenShift</b></td>
<td width=40%>3</td>
</tr>
<tr valign=top>
<td width=60%><b>cBlueBits</b></td>
<td width=40%>2</td>
</tr>
<tr valign=top>
<td width=60%><b>cBlueShift</b></td>
<td width=40%>6</td>
</tr>
</table><br>
<p>
As a result, the 8 bits are allocated as shown in Figure 1.</p>
<p>
<img src="gl2_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Allocation of color bits</b></p>
<p>
For generic pixel formats that require palettes, the palette will be a 3-3-2 palette, which divides the 8 bits of color information into 3 bits for red, 3 bits for green, and 2 bits for blue. You may find it convenient to think of a 3-3-2 palette as a color cube with red, green, and blue axes, as shown in Figure 2.</p>
<p>
<img src="gl2_2.gif" border=0></p>
<p class=label>
<b>Figure 2. 3-3-2 color cube</b></p>
<p>
In OpenGL, a color can be expressed using almost any numerical type, from an unsigned char (for example, <b>glColor3ub</b>) to a double (for example, <b>glColor3d</b>). Regardless of the units used, OpenGL converts the color to three floating-point numbers between 0.0 and 1.0 for internal use. After OpenGL performs all the calculations, it converts the color from its floating-point representation to a representation that can be displayed on the screen. If the current pixel format is one of the 8-bpp generic pixel formats, OpenGL converts the three floating-point numbers into one 8-bit value in the 3-3-2 format, and writes it to screen or bitmap memory.</p>
<p>
On a palettized device, the value in display memory is the index into the palette. For the scene to be rendered correctly, the color stored in the palette at that index must be equivalent to the 3-3-2 color that its index represents. Let's look at a few examples.</p>
<h4>Example 1.</h4>
<p>
The OpenGL command</p>
<pre><code>glColor3d(1.0, 1.0, 1.0)
</code></pre>
<p>
specifies the color white, which is the maximum amount of all colors. In a 3-3-2 scheme, the maximum amount of red is 111 binary, green is 111 binary, and blue is 11 binary. The color is written to memory as follows: the blue value, followed by the green value and the red value, resulting in 11111111 binary, or 255 decimal. The value written to memory is the index to the palette, so the 255th entry in the palette must store the color white, which would be (255,&nbsp;255,&nbsp;255).</p>
<h4>Example 2.</h4>
<p>
The OpenGL command</p>
<pre><code>glColor3d(1.0, 0.14, 0.6667)
</code></pre>
<p>
specifies a nice purple color. To create this color, we need a maximum of red (111), 14 percent of the green (7 * .14 = 1, or 001 binary), and two-thirds of the available blue (3 * .6667 = 2, or 10 binary), so our 3-3-2 color would be 10001111 binary, or 143 decimal. The 143rd entry in our palette must have the same relative amounts of red, green, and blue. This would result in (255 * 1.0, 255 * 0.14, 255 * 0.6667), or (255, 36, 170). If this value is not in the 143rd palette entry, the wrong color will be displayed.</p>
<p>
This is what the code in <b>CGLEasyView::CreateRGBPalette</b> does. It starts with 0 and iterates to 255, treating each number as an 8-bit, 3-3-2 value and converting the number to an RGB 8-bit triple to place in the palette. Most of this work is actually done by the <b>CGLEasyView::ComponentFromIndex</b> function and its supporting arrays <b>m_threeto8</b>, <b>m_twoto8</b>, and <b>m_oneto8</b>. As their names imply, these arrays convert 3-bit, 2-bit, and 1-bit numbers to 8-bit numbers.</p>
<p>
The <b>m_threeto8</b> array is interesting. It is specified as follows:</p>
<pre><code>unsigned char CGLEasyView::m_threeto8[8] = {
 &nbsp; 0, O111&gt;&gt;1, 0222&gt;&gt;1, 0333&gt;&gt;1, 0444&gt;&gt;1, 0555&gt;&gt;1, 0666&gt;&gt;1, 0377
};
</code></pre>
<p>
In C and C++, a number with a leading zero is considered an octal number, so the above array actually stores the following numbers:</p>
<pre><code>0, 36, 73, 109, 146, 182, 219, 255
</code></pre>
<p>
These numbers are calculated by dividing 255 by the intervals covered by the bits we allocated (2^<b>c*bits</b> – 1). For example, if <b>cRedBits </b>is 3, 255 / (2^3 – 1)= 255/7 = 36.4. Repeatedly adding 36.4 will result in the array above. Notice that if you round 36.4 to an integer before adding it to the array, you get the following <i>different</i> array:</p>
<pre><code>0, 36, 72, 108, 144, 180, 216, 252
</code></pre>
<p>
You'll notice this rounding problem in the article "Advanced 3-D Graphics for Windows NT 3.5: The OpenGL Interface, Part II" by Jeff Prosise (<i>Microsoft Systems Journal</i> 9, November 1994; also in the MSDN Library Archive Edition). (This is a good article, and you should read it anyway.) Instead of using these cumbersome arrays, Jeff replaces the call to <b>ComponentFromIndex</b> with the following code :</p>
<pre><code>byRedMask = (1 &lt;&lt; pfd.cRedBits) - 1 ;
.
.
.
 &nbsp; lpPalette-&gt;palPalEntry[i].peRed =
 &nbsp;&nbsp;&nbsp;&nbsp; (((I &gt;&gt; pfd.cRedShift) &amp; byRedMask) * 255) / byRedMask) ;
</code></pre>
<p>
I like this code better than the arrays (personal bias); however, the integer division causes a rounding error, resulting in almost all of the colors having a component that is off by one. I can't tell the difference by looking at the palette, but it is incorrect. This problem can be fixed with the following change:</p>
<pre><code>lpPalette-&gt;palPalEntry[i].peRed =
 &nbsp;&nbsp;&nbsp;&nbsp; (unsigned char)(((I &gt;&gt; pfd.cRedShift) &amp; byRedMask) 
 &nbsp;&nbsp;&nbsp;&nbsp; * 255) / (double)byRedMask + 0.5) ;
</code></pre>
<h3>For the Sake of Simplicity. . .</h3>
<p>
In this discussion, I have simplified the process of how an OpenGL color appears on the screen. Most OpenGL scenes are rendered with some form of lighting or atmospheric effects that change color. In addition, OpenGL will, by default, dither colors to get a closer approximation of the desired effect. To stop OpenGL from dithering, use <b>glDisable(GL_DITHER)</b>.</p>
<p>
I also did not mention that <b>CreateRGBPalette </b>can create palettes other than the 3-3-2 palette we have been discussing. The current implementation of OpenGL in Windows NT does not require you to create a different palette organization with the generic pixel formats. However, a hardware vendor can set PFD_NEED_PALETTE, <b>c*Bits</b>, and <b>c*Shift</b> to require a different organization. <b>CreateRGBPalette</b> is generic enough to handle these possibilities.</p>
<p>
Yet another step I left out involves Windows® palettes. An application can build only a logical palette. The logical palette constructs a system palette, which the Windows operating system uses. Windows maps the colors in the logical palette to the system palette. In the system palette, the first and last ten colors are reserved for system use.</p>
<h3>System Colors</h3>
<p>
If an application were allowed to use all of the colors in the palette, it could define all 256 colors as shades of red. As a result, all windows, text, menus, buttons, and everything else would be shades of red on red. You would click a red button on a red background, and enter red text with your red mouse cursor that you would be lucky even to see.</p>
<p>
To keep at least the standard system window components looking normal, Windows reserves the first and last ten colors in the palette, as I mentioned earlier. These 20 colors include the 16 standard VGA colors. Most Windows-based applications use the standard 16 system colors instead of tinkering with palettes. This is why so many Windows-based applications look so boring.</p>
<p>
An application can create a 256-color logical palette that does not include any of the 20 system colors; however, at most only 236 of these colors will end up in the system palette. Therefore, it doesn't make sense to request the additional 20 colors that you are not going to get. <b>CGLEasyView::CreateRGBPalette</b> recognizes this situation. After filling the palette entries with the 3-3-2 palette, <b>CreateRGBPalette</b> puts the system colors in, as shown in the code below.</p>
<pre><code>if ((pfd.cColorBits == 8) &amp;&amp;
 &nbsp; (pfd.cRedBits&nbsp;&nbsp; == 3) &amp;&amp; (pfd.cRedShift&nbsp;&nbsp; == 0) &amp;&amp;
 &nbsp; (pfd.cGreenBits == 3) &amp;&amp; (pfd.cGreenShift == 3) &amp;&amp;
 &nbsp; (pfd.cBlueBits&nbsp; == 2) &amp;&amp; (pfd.cBlueShift&nbsp; == 6))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; for (int j = 1 ; j &lt;= 12 ; j++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPal-&gt;palPalEntry[m_defaultOverride[j]] = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_defaultPalEntry[j];
 &nbsp; }
</code></pre>
<p>
The GENGL and GLEasy sample applications use arrays, as shown below:</p>
<pre><code>int CGLEasyView::m_defaultOverride[13] = {
 &nbsp;&nbsp; 0, 3, 24, 27, 64, 67, 88, 173, 181, 236, 247, 164, 91
};

PALETTEENTRY CGLEasyView::m_defaultPalEntry[20] = {
 &nbsp;&nbsp; { 0,&nbsp;&nbsp; 0,&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp; 0 }, //0
 &nbsp;&nbsp; { 0x80,0,&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp; 0 }, 
 &nbsp;&nbsp; { 0,&nbsp;&nbsp; 0x80,0,&nbsp;&nbsp;&nbsp; 0 }, 
 &nbsp;&nbsp; { 0x80,0x80,0,&nbsp;&nbsp;&nbsp; 0 }, 
 &nbsp;&nbsp; { 0,&nbsp;&nbsp; 0,&nbsp;&nbsp; 0x80, 0 },
 &nbsp;&nbsp; { 0x80,0,&nbsp;&nbsp; 0x80, 0 },
 &nbsp;&nbsp; { 0,&nbsp;&nbsp; 0x80,0x80, 0 },
 &nbsp;&nbsp; { 0xC0,0xC0,0xC0, 0 }, //7

 &nbsp;&nbsp; { 192, 220, 192,&nbsp; 0 }, //8
 &nbsp;&nbsp; { 166, 202, 240,&nbsp; 0 },
 &nbsp;&nbsp; { 255, 251, 240,&nbsp; 0 },
 &nbsp;&nbsp; { 160, 160, 164,&nbsp; 0 }, //11

 &nbsp;&nbsp; { 0x80,0x80,0x80, 0 }, //12
 &nbsp;&nbsp; { 0xFF,0,&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp; 0 },
 &nbsp;&nbsp; { 0,&nbsp;&nbsp; 0xFF,0,&nbsp;&nbsp;&nbsp; 0 },
 &nbsp;&nbsp; { 0xFF,0xFF,0,&nbsp;&nbsp;&nbsp; 0 },
 &nbsp;&nbsp; { 0,&nbsp;&nbsp; 0,&nbsp;&nbsp; 0xFF, 0 },
 &nbsp;&nbsp; { 0xFF,0,&nbsp;&nbsp; 0xFF, 0 },
 &nbsp;&nbsp; { 0,&nbsp;&nbsp; 0xFF,0xFF, 0 },
 &nbsp;&nbsp; { 0xFF,0xFF,0xFF, 0 }&nbsp; //19
  };
</code></pre>
<p>
The first array, <b>m_defaultOverride</b>, contains the indexes of the palette entries to be replaced with system colors. The second array, <b>m_defaultPalEntry</b>, contains the RGB values of the system colors to add to the palette. The <b>for</b> loop inserts only 12 of the 20 system colors into the logical palette. The remaining 8 colors are already in the 3-3-2 palette that was created, so there is no need to insert them.</p>
<p>
The palette indexes stored in <b>m_defaultOverride</b> are determined by treating the colors as points in 3-D space and calculating the closest color in the 3-3-2 palette for each system color. The algorithm uses the standard distance formula (known as the <i>least-squares calculation</i>) that you learned in high school. The graphics device interface (GDI) <b>GetNearestPaletteIndex</b> function uses the same algorithm. </p>
<p>
Don't use <b>GetNearestPaletteIndex</b> instead of the <b>m_defaultPalEntry</b> array to insert the system colors, because <b>GetNearestPaletteIndex</b> will replace index 255 instead of index 247 with the system color (255, 251, 240). It will also replace index 164 instead of index 156 with the color (128, 128, 128), although index 164 maps to the system color (160, 160, 164) much better.</p>
<p>
If the 3-3-2 palette is not modified with the system colors, you will lose some of the colors. The system palette can accept only 236 non-system colors. In the 3-3-2 palette, only 8 of the 256 colors match the system colors, leaving 12 colors, which will be mapped either to the system colors or to one of the previous 236 logical colors. The problem is not that you lose 12 colors, but that you lose them at the end of the palette. A better approach is to try to map the system colors intelligently into the 3-3-2 palette, thus getting (we hope) 256 unique colors. (We are trying to have our cake and eat it, too.)</p>
<p>
Again, I've simplified the discussion here. There are ways to gain control of all palette entries except the first entry (black) and the last entry (white), but this is not generally useful. See the sources in the bibliography for more information.</p>
<p>
That covers the basics of building a palette for OpenGL. In the following sections, I would like to discuss a few other issues.</p>
<h2>Identity Palettes</h2>
<p>
If you have read Nigel Thompson's book <i>Animation Techniques for Win32</i> (available from Microsoft Press®), you know that identity palettes are very important for fast blting.</p>
<p>
An identity palette is a logical palette that is identical to the system palette. Not only does an identity palette have the same colors as the system palette, but the colors are in the same index order in the palette. To create an identity palette, Nigel first creates a palette. (He usually uses a 2-2-2 with a gray scale, but this doesn't really matter.) After selecting and realizing his palette, he gets the system palette entries and replaces his logical palette with the system palette. He now has an identity palette that is identical to the system palette. However, the color indexes in the identity palette do not match the indexes in the original logical palette, so he has to remap the colors in his DIBs. If he uses GDI calls, he uses the <b>PALETTERGB</b> macro to specify the colors.</p>
<p>
OpenGL, as implemented in Windows NT, requires palettes in the 3-3-2 format. The identity palette is guaranteed to have system colors in the first and last 10 palette entries, which does not correspond to the 3-3-2 format. Therefore, it is not possible to have an identity palette with OpenGL when using RGBA color mode.</p>
<p>
If you must have an identity palette, you might want to use color index mode instead of RGBA mode. In color index mode, you specify the palette index instead of the RGB values for the color you want. The downside of using color index mode is that some of OpenGL's effects, such as atmosphere, lighting, and blending, don't work very well. However, you can make the rendered scene look brighter and bolder by selecting the colors in the palette carefully. The standard 3-3-2 palette colors can look washed out or pastel. A 24-bpp display can fix all of these problems. (See my article, <a href="msdn_gl4.htm">"OpenGL IV: Color Index Mode,"</a> in the MSDN Library for more information.)</p>
<p>
Another solution is to render on a DIB section and let the DIB handle the color matching. More on this possibility in a later article.</p>
<h2>Gamma Correction</h2>
<p>
When building the 3-3-2 palette, the palette index forms an 8-bit RGB color with the 3-3-2 format. The palette entry for a particular index contains a 24-bit RGB color with an 8-8-8 format. In the previous section, we did a linear conversion from 3 bits to 8 bits, and from 2 bits to 8 bits. Mathematically, this conversion results in the widest selection of colors. Biologically, however, it does not.</p>
<p>
The human visual system (the eye, nervous system, and brain) is not equally sensitive to different color intensities. (This is one of the reasons we get good results with only 2 bits for blue.) The visual system does not interpret a linear increase in light intensity as a linear increase in perceived brightness. In fact, the human eye is more sensitive to the <i>ratios</i> of the intensities than it is to the absolute intensity values. Thus, the perceived difference between 0.1 and 0.11 is the same as the perceived difference between 0.5 and 0.55 (0.11/0.1 = 0.55/0.5 = 1.1). Therefore, using a logarithmic instead of a linear distribution results in better use of the available colors.</p>
<p>
The process of correcting the intensity distribution is known as <i>gamma correction</i>. See the bibliography at the end of this article for more information on gamma correction.</p>
<p>
However, as Gilman Wong of the Window NT OpenGL team pointed out to me, before we can consider perceived intensity, we need to ensure that the monitor will produce a linear intensity. As it turns out, most display-card/monitor combinations will not respond linearly to pixel values. The digital-to-analog converters (DACs) on the cards can also add non-linearities. This is the usual reason for gamma correction. Furthermore, trying to compensate for the human visual system is often impractical because it can vary from person to person. In fact, an array of physical and psychological factors (lighting conditions, fatigue, mood, and so on) can affect the perceived intensities even for a single person. If you use gamma correction only to achieve linear monitor intensity, you're ahead of the game.</p>
<p>
In the Win32 SDK for Windows NT 3.5 <i>OpenGL Programmer's Reference</i>, "Windows NT Extensions to Open GL," "About OpenGL on Windows NT," "OpenGL Color Modes and Windows Palette Management", the section "RGBA Mode and Palette Management" includes code for creating palettes for OpenGL. This code gamma-corrects the <b>m_threeto8 </b>and <b>m_twoto8</b> arrays. The formula for gamma correction is:</p>
<p>
<img src="gl2_3.gif" border=0></p>
<p>
where <i>v</i> is the value to be gamma-corrected, and <i>g</i> is the gamma-correction factor. A gamma of 1.0 provides an uncorrected linear distribution. The program uses a default gamma value of 1.4. The graph below shows the difference between the linear distribution and the gamma-corrected distribution using 1.4 for gamma. The horizontal axis is the index into the <b>m_threeto8</b> array.</p>
<p>
<img src="gl2_4.gif" border=0></p>
<p class=label>
<b>Figure 3. Graph of m_threeto8 array and gamma-corrected array</b></p>
<p>
From the graph in Figure 3, it is evident that gamma correction biases the colors to higher intensities.</p>
<p>
Should you use gamma-corrected colors? I tried it on a few scenes, and I really couldn't tell that much difference. I personally favor the uncorrected 3-3-2 format because the colors are more robust and less pastel. The next section discusses a way you can see palette differences, including differences in the gamma correction.</p>
<h2>Examining the Palette</h2>
<p>
To understand palette interactions with OpenGL, I wrote an application called GLpal, which displays the logical palette using GDI and OpenGL. GLpal also shows the system palette.</p>
<p>
The client area of the GLpal window is divided into four areas. Three of these areas display palettes, while the fourth area displays useful information.</p>
<p>
<img src="gl2_5.gif" border=0></p>
<p class=label>
<b>Figure 4. Simulated GLpal screen</b></p>
<p>
Figure 4 simulates the GLpal screen. The real program displays 256 colors in each palette it displays. The system palette is displayed in the lower-left corner, the logical palette (drawn using OpenGL) is displayed in the upper-right corner, and the logical palette (drawn using GDI) is displayed in the lower-right corner.</p>
<p>
To see the RGB value and the palette index for a color, press the left mouse button over the color, and drag the mouse to see other colors. These values are displayed in the upper-left corner of the window.</p>
<h3>Drawing the Logical Palettes</h3>
<p>
The two logical palettes are drawn simultaneously by the <b>CGLpalView::DrawGlPalette</b> function. <b>GetPaletteEntries</b> fills a <b>PALETTEENTRY</b> array, <b>pal</b>, with the RGB values currently in the logical palette. These are the RGB values that we would like to display on the screen. GLpal displays squares filled with each color in the logical palette. Each square is drawn twice: first with GDI and then with OpenGL. To draw the GDI square, we use a brush that is created with the following command:</p>
<pre><code>CBrush br ;
br.CreateSolidBrush(PALETTERGB(pal[iCurColor].peRed,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal[iCurColor].peGreen,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal[iCurColor].peBlue)) ;
</code></pre>
<p>
<b>CDC::Rectangle</b> draws the square using this brush. Immediately after drawing the square with GDI, OpenGL draws the square (in the same color, we hope). The following OpenGL command sets the color using the RGB value from the <b>pal</b> array:</p>
<pre><code>glColor3ub( pal[iCurColor].peRed,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal[iCurColor].peGreen,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal[iCurColor].peBlue );
</code></pre>
<p>
The OpenGL <b>glColor3ub</b> function (Nigel calls it the "color thrub" command) accepts the color levels as unsigned bytes. (This is convenient because that is what the RGB values in the <b>PALETTEENTRY</b> structure are.) OpenGL internally converts these unsigned byte values to floating-point values.</p>
<p>
<b>DrawGlPalette</b> should use the color <b>RGB(r,g,b)</b> when it executes <b>glColor3ub(r,g,b)</b>.</p>
<p>
If you turn color tracing on (see the "Other GLpal Options" section), GLpal compares the RGB value for the GDI square with the RGB value for the OpenGL square. Colors that do not match are identified by a black dot in the middle of the square.</p>
<h3>Drawing the System Palette</h3>
<p>
The <b>CGlpalView::DrawSysPalette</b> function draws the current system palette. GLpal creates a <b>LOGPALETTE</b> structure and fills the <b>peRed </b>field of each <b>PALETTEENTRY</b> structure with the index of that particular structure. The <b>peFlags</b> field is filled with PC_EXPLICIT. The <b>LOGPALETTE</b> structure creates a palette that contains the current system colors. Drawing the palette is left to GDI. In this case, we use the <b>PALETTEINDEX</b> macro instead of the <b>PALETTERGB</b> macro to specify the colors.</p>
<p>
This is all kind of a joke. We simply wish to draw what is in the hardware palette, but this is not all that easy because GDI thinks only about the logical palette. The punch line to this joke is that we have to select the system palette in the background so that our application does not remap its own palette.</p>
<h3>Changing the Palette</h3>
<p>
The Palette command in the GLpal Options menu allows you to change the palette created by GLpal. The Palette Options dialog box lets you choose between the 3-3-2 palette we have been discussing and the wash palette that Nigel Thompson uses in his book <i>Animation Techniques for Win32</i>. If you select the wash palette, you will see that OpenGL uses the wrong colors.</p>
<p>
The other palette options you can change pertain only to the 3-3-2 palette. You can have the system colors inserted in the palette by checking the Add System Colors check box. Clear the check box and examine the end of the OpenGL palette. You will see several colors repeated. Click the left mouse button and drag to see the RGB values of the colors in the palettes.</p>
<p>
You can also gamma-correct the palette using a gamma factor of 1.4, 1.8, or 2.0. A gamma of 1.0 is the same as not gamma-correcting the palette. As the gamma factor goes up, you will notice that the colors you request increasingly diverge from the colors you get, which is to be expected. The palette also becomes more pastel as the high intensities take over.</p>
<h3>Other GLpal Options</h3>
<p>
Changing the palette is not the only option provided by GLpal; you can also change dithering, trace colors, and the selection of the palette before the <b>wglMakeCurrent</b> call.</p>
<h4>Dither</h4>
<p>
The Dither option turns dithering on and off. To get more realistic shadings, OpenGL dithers the colors. Because dithering makes it difficult to determine the actual color of a square, I turn dithering off by default. Select the Dither command from the Options menu to enable dithering. In OpenGL, dithering is controlled by the following commands:</p>
<pre><code>glEnable(GL_DITHER) ;
glDisable(GL_DITHER) ;
</code></pre>
<h4>Trace Color</h4>
<p>
If you enable the Trace Color option in the Options menu, GLpal marks colors in the OpenGL palette that differ from the GDI palette. The colors are marked in both palettes with a small black dot. This feature is enabled by default. It doesn't make any sense to use the Trace Color option with dithering turned on because Trace Color compares only one pixel in each square. If dithering is on, the pixels within a square will be different colors.</p>
<h4>Select Before wglMakeCurrent</h4>
<p>
You must select the palette in the DC before setting the current rendering context with <b>wglMakeCurrent</b>. To confirm this requirement, disable the Select Before wglMakeCurrent option in the Options menu. The palette will not be selected before the <b>wglMakeCurrent</b> call and will not be drawn correctly. I threw this option in to prove that you must select and realize your palette in the DC before setting the current rendering context.</p>
<h3>Colors That Don't Match</h3>
<p>
Run GLpal. You will see that three colors in the OpenGL palette do not match the corresponding colors in the GDI palette. The colors are the following:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=23%><b>Index</b></td>
<td class=label width=34%><b>GDI RGB Value</b></td>
<td class=label width=43%><b>OpenGL RGB Value</b></td>
</tr>
<tr valign=top>
<td width=23%>164</td>
<td width=34%>(160,160,164)</td>
<td width=43%>(146,146,85)</td>
</tr>
<tr valign=top>
<td width=23%>236</td>
<td width=34%>(166,202,240)</td>
<td width=43%>(164,182,170)</td>
</tr>
<tr valign=top>
<td width=23%>247</td>
<td width=34%>(255,251,240)</td>
<td width=43%>(255,219,170)</td>
</tr>
</table><br>
<p>
These are the three colors that were changed when we added the system colors to the palette. The GDI RGB values are the values of the system colors we placed in the palette. If you clear the Add System Colors check box in the Palette Options dialog box, the system colors will not be added, and none of the colors in the two palettes will differ. However, some colors will be lost.</p>
<p>
The colors differ because of the way the Windows NT implementation of OpenGL quantizes colors to 3-3-2 formatted, 8-bit values when rendering on a palettized device. Internally, OpenGL represents color intensities as floating-point numbers between 0.0 and 1.0. After OpenGL finishes all of its calculations, it must convert these intensities into a format suitable for the display device. If OpenGL is running on a palettized device, it converts each number to a 3-3-2 formatted, 8-bit value.</p>
<p>
To see how the process of quantizing to an 8-bit value leads to the mismatch of colors, let's quantize the RGB value (160, 160, 164):</p>
<pre><code>(int)160*7/255 = 4 or 100 binary, 
(int)160*7/255 = 4 or 100 binary, 
(int)164*3/255 = 2 or&nbsp; 01 binary,
</code></pre>
<p>
The quantized value is (4, 4, 2) or (100, 100, 01). Together, these numbers build the 8-bit value 01100100 binary, or 100 decimal. The color at index 100 is (146, 146, 85), which is the value that OpenGL tried to display for us.</p>
<p>
Let's apply the same process to the other two colors.</p>
<p>
RGB (166, 202, 240):</p>
<pre><code>(int)166*7/255 = 4 or 100
(int)202*7/255 = 5 or 101
(int)240*3/255 = 2 or 10
</code></pre>
<p>
The color in index 10101100 binary, or 172 decimal, is (146, 182, 170).</p>
<p>
RGB (255, 251, 240):</p>
<pre><code>(int)255*7/255 = 7 or 111
(int)251*7/255 = 6 or 110
(int)240*3/255 = 2 or 10
</code></pre>
<p>
The color in index 10110111 binary, or 183 decimal, is (255, 219, 170).</p>
<p>
It is interesting that 251 quantizes to 6 instead of 7, although it is very close to 255.</p>
<h2>Palette Messages</h2>
<p>
To be truly palette-aware, an application should handle and support the WM_QUERYNEWPALETTE and WM_PALETTECHANGED messages. A lot has already been written about these functions, including some wonderful words by Nigel Thompson in his book <i>Animation Techniques for Win32</i>. GLpal and GLEasy copy the code listed in Chapter 4 of Nigel's book. Amazingly enough, it works.</p>
<h3>UpdateColors</h3>
<p>
You can do things a little differently from Nigel. Instead of invalidating the window and redrawing as GLpal does, you can use <b>CDC::UpdateColors</b> to directly update the visible pixels to match the current system palette. In some cases, <b>UpdateColors</b> will be faster than redrawing the whole display. (This is especially true of some complex OpenGL renderings.) However, <b>UpdateColors</b> can lead to a loss of information, so you should redraw the display after you use this function a few times. Ron Gery's article <a href="msdn_palette.htm">"The Palette Manager: How and Why"</a> in the MSDN Library explains <b>UpdateColors</b> in detail.</p>
<h2>Conclusion</h2>
<p>
Palettes have always been a pain. Understanding why you need a certain type of palette for OpenGL may initially be a little confusing, but once you have the code to set the palette up correctly, you never need to worry about it again.</p>
<p>
By now, you should be familiar enough with OpenGL and palettes to copy the code out of GENGL or GLEasy, and get on with some cool 3-D renderings.</p>
<h2>Bibliography</h2>
<h3>Sources of Information on OpenGL</h3>
<p>
Crain, Dennis. <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started."</a> April 1994. (MSDN Library, Technical Articles)</p>
<p>
Neider, Jackie, Tom Davis, and Mason Woo. <i>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1993. ISBN 0-201-63274-8. (This book is also known as the "Red Book".)</p>
<p>
OpenGL Architecture Review Board. <i>OpenGL Reference Manual: The Official Reference Document for OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1992. ISBN 0-201-63276-4. (This book is also known as the "Blue Book".)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: Introducing the OpenGL Interface, Part I." <i>Microsoft Systems Journal</i> 9 (October 1994). (MSDN Library Archive Edition, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: The OpenGL Interface, Part II." <i>Microsoft Systems Journal</i> 9 (November 1994). (MSDN Library Archive Edition, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Understanding Modelview Transformations in OpenGL for Windows NT." <i>Microsoft Systems Journal</i> 10 (February 1995). </p>
<p>
Rogerson, Dale. <a href="msdn_gl1.htm">"OpenGL I: Quick Start."</a>. December 1994. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl3.htm">"OpenGL III: Building an OpenGL C++ Class."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl4.htm">"OpenGL IV: Color Index Mode."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl5.htm">"OpenGL V: Translating Windows DIBs."</a> February 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl6.htm">"OpenGL VI: Rendering on DIBs with PFD_DRAW_TO_BITMAP."</a> April 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl7.htm">"OpenGL VII: Scratching the Surface of Texture Mapping."</a> May 1995. (MSDN Library, Technical Articles)</p>
<p>
Microsoft Win32 Software Development Kit (SDK) for Windows NT 3.5 <i>OpenGL Programmer's Reference</i>. </p>
<h3>Sources of Information on Palettes</h3>
<p>
Gery, Ron. <a href="msdn_palaware.htm">"Palette Awareness."</a> April 1992. (MSDN Library, Technical Articles)</p>
<p>
Gery, Ron. <a href="msdn_palette.htm">"The Palette Manager: How and Why."</a> March 1992. (MSDN Library, Technical Articles)</p>
<p>
Gery, Ron. <a href="msdn_dibpal.htm">"Using DIBs with Palettes."</a> March 1992. (MSDN Library, Technical Articles)</p>
<p>
Rodent, Herman. <a href="msdn_anim32.htm">"Animation in Win32."</a> February 1994. (MSDN Library, Technical Articles)</p>
<p>
Rodent, Herman. <a href="msdn_sprites.htm">"Animation in Windows."</a> April 1993. (MSDN Library, Technical Articles)</p>
<p>
Thompson, Nigel. <i>Animation Techniques for Win32</i>. Redmond, WA: Microsoft Press, 1995. </p>
<h3>Sources of Information on 3-D Graphics</h3>
<p>
Foley, James D., Andries van Dam, Steven K. Feiner, and John F. Hughes. <i>Computer Graphics: Principles and Practice</i>. 2d ed. Reading, MA: Addison-Wesley, 1990. (This is THE book on computer graphics.)</p>
<p>
Hill, F.S. Jr. <i>Computer Graphics</i>. Macmillan Publishing Company, 1990.</p>
<h3>Sources of Information on Gamma Correction</h3>
<p>
Burger, Peter and Duncan Gillies. <i>Interactive Computer Graphics: Functional, Procedural, and Device-Level Methods.</i> Reading, MA: Addison-Wesley, 1989.</p>
<p>
Rogers, David F. <i>Procedural Elements for Computer Graphics.</i> New York, NY: McGraw-Hill, 1985.</p>
</BODY>
</HTML>
