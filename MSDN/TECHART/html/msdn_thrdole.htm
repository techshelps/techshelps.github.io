<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Interacting with Microsoft Excel: A Case Study in OLE Automation</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_thrdole"></a></sup>Interacting with Microsoft Excel: A Case Study in OLE Automation</h1>
<p>
Ruediger R. Asche<br>
Microsoft Developer Network Technology Group</p>
<p>
January 31, 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4561">
</OBJECT><a href="javascript:sample1.Click()">Click to view or copy the files in the THRDPERF project that accompanies this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4583">
</OBJECT><a href="javascript:sample2.Click()">Click to view or copy the XLCLIENT project files.</a></p>
<p>
<OBJECT id=sample3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4586">
</OBJECT><a href="javascript:sample3.Click()">Click to view or copy the XLAUTO project files.</a></p>
<h2>Abstract</h2>
<p>
Following up on the technical article <a href="msdn_threadli.htm">"Win32 Multithreading Performance,"</a> this article discusses how OLE Automation is used in the THRDPERF project to sample multithreading data using Microsoft® Excel. </p>
<h2>Introduction</h2>
<p>
OLE Automation? Sounds weird to a hard-core systems person like me—I'd rather booger down in the guts of an operating system than talk to lousy end-user applications like spreadsheets or word processors. Ditch it.</p>
<p>
That was me a while ago. Then again, I kept away from the Microsoft® Foundation Class Library (MFC) for the longest time, until I discovered that MFC is a great tool that lets you focus on the essentials of an application instead of the user interface. Ever since I became a convert, I haven't used anything but MFC to write my applications.</p>
<p>
My most recent MFC application tests multithreading performance on the Win32® application programming interface (API) (see <a href="msdn_threadli.htm">"Win32 Multithreading Performance"</a> for details). My application generates a whole lot of numbers that are completely incomprehensible unless visualized by some chart generator.</p>
<p>
Oops, there it was. I couldn't escape Microsoft Excel anymore—after all, the last thing I wanted to do was to write my own chart software. The next problem then was how to stuff the numbers into Microsoft Excel? I could have gone the good old way and typed everything into a Microsoft Excel sheet by hand, but we are talking major numbers of numbers here, and repeated test runs. So there was no way around using OLE Automation with Microsoft Excel, and I rolled up my sleeves and prepared for some gory work.</p>
<p>
As was the case with my MFC conversion, I quickly learned to overcome my prejudices. OLE Automation is a breeze to use from an MFC application. This article guides you through the steps you have to take to talk to Microsoft Excel from your MFC application. The first section covers the basics of OLE Automation; the same steps also apply to communications with any OLE Automation server other than OLE. In the second section I talk about Microsoft Excel objects and how to use them.</p>
<p>
Note that there is already a lot of material available in Visual Basic® documentation about using OLE Automation with Microsoft Excel. I do not want to add unnecessary noise, so I will keep the discussion about Microsoft Excel objects short. If you need to know more about how to use the objects, please refer to the material that is out there. One of the interesting things about OLE Automation is that it is really language-independent, so it is sufficient for you to learn just enough Visual Basic to read object access code, and then you can simply transcribe that code to MFC.</p>
<p>
Microsoft Product Support Services (PPS) has provided two sample application projects that demonstrate OLE Automation, XLCLIENT and XLAUTO. The information in these samples complements the information in this article and in my own sample application, THRDPERF.</p>
<h2>OLE Automation from Visual C++</h2>
<p>
There are a couple of steps you need to perform in order to make sure that OLE Automation is available for your application to use:
<ol>
<li>
Install the OLE Automation server properly. <i>Properly</i> means that the system registry must be updated to contain the correct entries in the HKEY_CLASSES_ROOT subtree. Normally, the installation program takes care of this step, but at times your software may be installed without the necessary changes having been made. For example, I have a system that boots both Microsoft Windows NT™ and Windows® 95, and I installed Microsoft Excel under Windows NT. When I shut down and restarted the machine, Windows 95, of course, didn't have any idea about Microsoft Excel OLE Automation, although Microsoft Excel worked just fine. I ended up reinstalling Microsoft Excel into the same directory, but there are ways to import subtrees into the registry, and some registration programs offer separate options to register OLE Automation objects.<br><br></li>
<li>
Your MFC application should call the <b>AfxOLEInit</b> function to initialize OLE properly. When you generate your application from ClassWizard, this code should already be included in your project when you ask for OLE support.</li>
</ol>
<p>
Beginning from here, there are several ways to access OLE Automation. You can either do it the hard way, that is, use OLE without Visual C++® wrappers (which requires that you know quite a bit about class IDs, class factories, dispatch objects, and the whole scary bit), or you can use type libraries, which make the job unbelievably easy. A type library is a little bit like a dynamic header file in that a type library contains information about the objects that are supported by the corresponding OLE Automation server: the methods the objects support, the parameter lists, the values of symbolic constants, and so on. The ClassWizard from Visual C++ uses type libraries to generate C++ classes that encapsulate the OLE objects. Let's see how this works.</p>
<p>
When you have created your application from AppWizard, you can call ClassWizard and add a class from a type library (you get there by clicking the Add Class button). Select the type library that goes with Microsoft Excel—in the version I used, this is XL5EN32.tlb, which normally resides in the directory that Microsoft Excel was installed in. Now ClassWizard will provide you a list of the objects that Microsoft Excel supports as an OLE Automation server. Choose the objects you need, and ClassWizard will generate a prototype and implementation file for all the objects you chose. Now all that's left for you to do is to include the header file(s) that ClassWizard generated into the files of your projects that need to work with the OLE Automation objects, and you're ready to rock 'n roll. Of course, now you are stuck with the problem of how to use the objects, and that's what we will look at next.</p>
<h2>Using Microsoft Excel Objects</h2>
<p>
Several samples show how to control Microsoft Excel from a Visual C++ application. The XLCLIENT sample provided by Microsoft PSS is fairly elementary (just like my code) in that only a few data items are pumped into a Microsoft Excel sheet. XLCLIENT comes in both flavors, using type libraries or addressing OLE directly. The XLAUTO sample does use type libraries, but it is fairly complex in that a lot of objects are used, and the Microsoft Excel sheet is embedded in the application's client area.</p>
<p>
In the code in my sample, THRDPERF, I wanted to do only the minimal work necessary to stuff some data into Microsoft Excel. Note that OLE Automation is very powerful; I could have used OLE Automation not only to pump the data into Microsoft Excel, but also to generate and format the charts, render the charts in the application window, execute macros, or even call a Win32 API routine from inside Microsoft Excel. I was content with having the data in a Microsoft Excel sheet though, so I used macros that I ran from within Microsoft Excel and a little manual work to do the rest.</p>
<p>
Thus, my sample is about as simple as you can get. Using type libraries, using only the objects you minimally need, and using no visual embedding makes the code that communicates with Microsoft Excel very easy to work with. </p>
<p>
Note that OLE Automation servers implement "programming languages" of their own. That means that there is no predefined notion of what an object does and how the objects interact. This was kind of confusing to me because I knew how to access Microsoft Excel, and I had the names of the objects and their respective methods, but I didn't really have a clue about how to use the objects. Would I have to create a <b>Books</b> or <b>Application</b> object to be able to stuff data in a sheet, or is a <b>Worksheet</b> object enough? How would I have to use the methods? Are there any interactions between the methods, or are there side effects that calling one particular method might have on other methods? How would I access properties?</p>
<p>
Fortunately, the Microsoft Excel object model is fairly intuitive, and there do not seem to be many dependencies between the objects. Thus, you use the objects on a "pay as you go" basis, creating and using only the objects you need. </p>
<p>
Let's look at the code to see how Microsoft Excel is controlled from Threadlibtest.exe. All the code is located towards the bottom of Threaddlibtestview.cpp in <b>CThreadLibtestView::StuffIntoExcel</b> and the macros preceding that function.</p>
<p>
First, we create an object of the <b>Worksheet</b> class (the class has been defined by ClassWizard). I use the default constructor, so the object does not have any connection to a real Microsoft Excel object yet. Thus, the next step is to associate the Visual C++ object with a "real" Microsoft Excel worksheet. There are several ways to accomplish this. I use the <b>CreateDispatch</b> member function. The parameter to <b>CreateDispatch</b> is the name of the object that we want to create; I choose <b>Excel.Sheet</b> as the parameter. What happens behind the curtains in the call to <b>CreateDispatch</b> is that the name <b>Excel.Sheet</b> is used to look up a class ID in the registry, and the class ID is used by the OLE run-time system to connect to Microsoft Excel and have Microsoft Excel create an object of type <b>Worksheet</b>:</p>
<pre><code>Worksheet *ws = new Worksheet();&nbsp; 
if (!ws-&gt;CreateDispatch("Excel.Sheet"))
{
 AfxMessageBox("couldn't create sheet object...");
 return;
};&nbsp; 
</code></pre>
<p>
You are probably a little bit confused about this two-step process. Isn't the <b>Worksheet</b> object already a worksheet? Why should we have to explicitly assign a "real" worksheet object when the <b>Worksheet</b> class already encapsulates a Microsoft Excel worksheet?</p>
<p>
Keep in mind that the <b>Worksheet</b> object is first of all a representation of a Microsoft Excel worksheet. (In order to make this distinction clearer in this article, we will use the convention of formatting the Visual C++ objects in bold type and the corresponding OLE object in italic type.) OLE is an operating system extension that manages objects at run time, but Visual C++ requires objects to be known at compile time. The Visual C++ worksheet class is like a promise; it's as if the class were to say, "If you give me a real Microsoft Excel worksheet at run time, I know how to convert your compile-time parameters into something I can pass on to the object." We could have created our <b>Worksheet</b> object with a parameter that would already have specified the run-time <i>worksheet</i> object, but because the overloaded constructors for the <b>COleDispatchDriver</b> class (from which <b>Worksheet</b> is derived) cannot be passed an object name, we would have had to derive the class ID from the object name first before creating the <b>Worksheet</b> object. I think that using <b>CreateDispatch</b> is much easier.</p>
<p>
Now that the worksheet object is created, we can stuff data into it. To do that, we need to know a little bit about Microsoft Excel objects and their meaning. In Microsoft Excel OLE Automation, the object that represents cells is called a <i>range</i>. A <i>range</i> is basically a square of cells, and before we can access the cells, we must create a <i>range</i> object that represents the cells. The macro ALLOCRANGE does that for us:</p>
<pre><code>#define ALLOCRANGE(cell) \
 &nbsp;&nbsp; VariantClear(&amp;v); \
 &nbsp; V_VT(&amp;v) = VT_BSTR; \
 &nbsp; V_BSTR(&amp;v) = SysAllocString(cell); \
 &nbsp; vRet = ws-&gt;Range(v,v); \
 &nbsp; SysFreeString(V_BSTR(&amp;v));
</code></pre>
<p>
Note that in our sample code, we use <i>range</i> objects of only one cell at a time. In an application that requires efficient access to cells, you probably want to access a bigger <i>range</i> object wherever possible in order to avoid transferring the data in little chunks.</p>
<p>
To obtain a range, you call the member function <b>Range</b> from a worksheet object. The arguments to <b>Worksheet::Range</b> are the upper-left and lower-right indices of the cell block you wish to access. Once more, in our case the two are the same. Note that the strings to pass must be Unicode™ strings (hence the OLESTR macro in which the string is wrapped when ALLOCRANGE is called). You must use the <b>SysAllocString</b> and <b>SysFreeString</b> functions from Oleaut32.dll to ensure that the strings are valid in the address spaces of both the OLE Automation server and client.</p>
<p>
After the <b>Range</b> has been allocated, it can be assigned a value using the <b>SetValue</b> member function:</p>
<pre><code>#define PUTINT(cell, ival)&nbsp; \
ALLOCRANGE(cell)&nbsp; \
V_VT(&amp;v) = VT_I4; \
V_I4(&amp;v) = (int)ival; \
ptr = new Range(V_DISPATCH(&amp;vRet)); \
ptr-&gt;SetValue(v); \
delete ptr;
</code></pre>
<p>
This looks a little bit weird, so let me explain what happens here. The important data type for OLE Automation is a VARIANT. A VARIANT is basically a pointer to an arbitrary object, along with an identifier that specifies what type the object has. We need a variant because Visual C++ requires that types be known at compile time, but OLE parameters are passed at run time. Thus, a VARIANT is a type that satisfies Visual C++ (because it is well defined) but can be used in OLE (because OLE can derive and decode the parameter at run time using the type information). </p>
<p>
Note that a VARIANT in Visual C++ is different from a variant in Visual Basic. A Visual Basic variant allocates all the space necessary to fit the largest possible object as a whole, whereas a VARIANT in Visual C++ is pretty much a typed pointer.</p>
<p>
The earlier call to <b>Worksheet::Range</b> returned a VARIANT to satisfy the C compiler. However, we need to know what the "real" return value is so that we can work with it. <b>Worksheet::Range</b> returns a pointer to an OLE dispatch object, which we have not discussed so far. Fortunately, we do not need to know what a dispatch object is; all we need to care about is that now we can use that object to create an object of type <b>Range</b> from. You may recall that when we created the <b>Worksheet</b> object earlier on, we used the default constructor, and therefore we had to use <b>CreateDispatch</b> to associate the Visual C++ object with a "real" OLE object. We create the <b>Range</b> object with the OLE dispatch object as the parameter, so our <b>Range</b> object is now associated with a "real" <i>range</i> object. We could have accomplished the same thing by creating the <b>Range</b> object with the default constructor and then using the <b>CreateDispatch</b> or <b>AttachDispatch</b> method to associate the Visual C++ object with the OLE object.</p>
<p>
We then call the <b>SetValue</b> member of the <b>Range</b> object, and that does it. We are done with the object, and we can simply nuke it. </p>
<p>
If you are familiar with OLE Automation from Visual Basic, you will notice that there is a slight difference here when addressing values. Visual Basic uses the following code to set the value of a cell:</p>
<pre><code>cells(x,y).Value=&lt;value&gt;
</code></pre>
<p>
Visual Basic allows you to access the properties of an object directly using the dot notation. Properties roughly correspond to member variables in Visual C++; a property is a data value associated with an object. Using Visual C++, you cannot directly access properties because, once more, the Visual C++ representation of an object is different from the OLE object itself, so you can't obtain a pointer to the storage location easily. The <b>SetValue</b> member function of the <b>Range</b> object encapsulates code that accesses the <b>Value</b> property implicitly.</p>
<p>
When we are finished stuffing the data into the <i>worksheet</i>, we use the <b>SaveAs</b> member of the <b>Worksheet</b> object to save the sheet to disk:</p>
<pre><code>VARIANT v11,v12,v13,v14,v15,v16;
 &nbsp;&nbsp; V_VT(&amp;v11) = VT_BSTR;
 &nbsp;&nbsp; V_BSTR(&amp;v11)=SysAllocString(SHEETFILELOC);
 &nbsp;&nbsp; V_VT(&amp;v12) = VT_I2;
 &nbsp;&nbsp; V_I2(&amp;v12) = -4143;
 &nbsp;&nbsp; V_VT(&amp;v13) = VT_BSTR;
 &nbsp;&nbsp; V_BSTR(&amp;v13) = NULL;
 &nbsp;&nbsp; V_VT(&amp;v14) = VT_BSTR;
 &nbsp;&nbsp; V_BSTR(&amp;v14) = NULL;
 &nbsp;&nbsp; V_VT(&amp;v15) = VT_BOOL;
 &nbsp;&nbsp; V_BOOL(&amp;v15)=FALSE;
 &nbsp;&nbsp; V_VT(&amp;v16) = VT_BOOL;
 &nbsp;&nbsp; V_BOOL(&amp;v16) = FALSE;
 &nbsp;&nbsp;&nbsp; ws-&gt;SaveAs(v11,v12,v13,v14,v15,v16);
 &nbsp;&nbsp; SysFreeString(V_BSTR(&amp;v11));
 &nbsp;&nbsp; delete ws;
</code></pre>
<p>
The trick here is to know what the parameters to <b>SaveAs</b> are and how to pass them. Unfortunately, the parameter conventions for calling Microsoft Excel objects from Visual C++ are not documented, so you need to look into the Visual Basic documentation that is shipped with Microsoft Excel (see the file VBA_XL.HLP). The documentation for <b>Worksheet::SaveAs</b> reads as follows: </p>
<p>
<b>Syntax</b></p>
<p class=indent>
<i>object</i>.<b>SaveAs(filename, fileFormat, password, writeResPassword, readOnlyRecommended, createBackup)</b></p>
<p>
<b>Elements</b></p>
<p class=indent>
The <b>SaveAs</b> method has the following object qualifier and named arguments: </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=indent width=35%><i>object</i></td>
<td class=indent width=65%>Required. The object to which this method applies.</td>
</tr>
<tr valign=top>
<td class=indent width=35%><b><i>filename</i></b></td>
<td class=indent width=65%>Optional. A string indicating the name of the file to save. You can include a full path; if you do not, Microsoft Excel saves the file in the current directory or folder.</td>
</tr>
<tr valign=top>
<td class=indent width=35%><b><i>fileFormat</i></b></td>
<td class=indent width=65%>Optional. The file format to use when you save the file. See the <b>FileFormat</b> property for a list of valid choices. </td>
</tr>
<tr valign=top>
<td class=indent width=35%><b><i>password</i></b></td>
<td class=indent width=65%>Optional. A case-sensitive string indicating the protection password to be given to the file. Should be no more than 15 characters.</td>
</tr>
<tr valign=top>
<td class=indent width=35%><b><i>writeResPassword</i></b></td>
<td class=indent width=65%>Optional. A string indicating the write-reservation password for this file. If a file is saved with the password and the password is not supplied when the file is opened, the file is opened as read-only.</td>
</tr>
<tr valign=top>
<td class=indent width=35%><b><i>readOnlyRecommended</i></b></td>
<td class=indent width=65%>Optional. If <b>True</b>, when the file is opened, Microsoft Excel displays a message recommending that you open the file as read-only.</td>
</tr>
<tr valign=top>
<td class=indent width=35%><b><i>createBackup</i></b></td>
<td class=indent width=65%>Optional. If <b>True</b>, Microsoft Excel creates a backup file; if <b>False</b>, no backup file is created; if omitted, the status is unchanged.</td>
</tr>
</table><br>
<p>
The first parameter is the name of the file to save the <i>worksheet</i> to. Once more, this needs to be a Unicode string, and the string must be passed to <b>SysAllocString</b>. The second parameter can be one of a number of choices; I chose <b>xlNormal</b>. This is a symbolic constant; how are we supposed to know what its value is?</p>
<p>
Fortunately, the constants are stored in the type library. Thus, we next run a type library viewer such as Ole2vw32.exe on the type library (XL5EN32.tlb) and find that the value that corresponds to <b>xlNormal</b> is –4143. (Open the type library and look into the Constants TypeInfo list.) Note that there is no indication whether the value is supposed to be a short or a long integer; I chose VT_I2 (short or 2-byte integer).</p>
<p>
The remaining parameters I chose to set to NULL. Once more, we need variants for each parameter. It is important not only to set the parameters but also to assign type values to them using the VT_<i>xxx</i> macros. </p>
<p>
After the sheet has been saved, we can simply delete the worksheet object, and we are done. Note that once more, I avoid the icky issue of error handling here. It goes without saying that each OLE call may fail—just like any other call—and in a real-life application you are strongly advised to provide solid error checking.</p>
<h2>Summary</h2>
<p>
OLE Automation from Visual C++ using type libraries is conceptually very easy, as this minimal sample shows. The tricky part is to use the OLE Automation objects properly. </p>
<p>
OLE Automation is the last bastion of software abstraction, because with OLE Automation it is now possible to view an application (or, more generically, every OLE Automation server) as a service provider. Thus, everything that an application makes public through OLE Automation can be accessed from client applications. In my case, I wanted to use charting capabilities programmatically without having to write the software myself; by using OLE Automation, I was able to put existing software to work.</p>
</BODY>
</HTML>
