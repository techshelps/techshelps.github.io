<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFC/COM Objects 8: Revisiting Multiple Inheritance Without MFC</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_micom1"></a></sup>MFC/COM Objects 8: Revisiting Multiple Inheritance Without MFC</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
September 15, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4417">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the MI_Appliances sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4419">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the HOUSE4 sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article is a follow-up to Nigel Thompson's article <a href="msdn_house5.htm">"MFC/COM Objects 5: Using Multiple Inheritance"</a> in the Microsoft Developer Network (MSDN) Library. This article discusses how to implement 32-bit Component Object Model (COM) objects using multiple inheritance instead of class nesting, and without using Microsoft Foundation Class Library (MFC) OLE support. Accompanying this article is MI_Appliances.dll, which contains several COM objects for use with the HOUSE4 sample application (originally provided with the article <a href="msdn_house4.htm">"MFC/COM Objects 4: Aggregation"</a>).</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Before running the sample, you must register the location of MI_Appliances.dll in the registry. See the first article in this series (<a href="msdn_house1.htm">"MFC/COM Objects 1: Creating a Simple Object"</a>) for details on how to do this.</p>
<h2>Introduction</h2>
<p>
In his article <a href="msdn_house5.htm">"MFC/COM Objects 5: Using Multiple Inheritance,"</a> Nigel Thompson explained how to implement Component Object Model (COM) objects using multiple inheritance instead of the nested class approach provided by the Microsoft® Foundation Class Library (MFC). Nigel wanted to use MFC as much as possible, but multiple inheritance and MFC don't mix very well, so he decided not to use multiple inheritance.</p>
<p>
However, after implementing several COM objects using MFC, Nigel realized that using multiple inheritance had to be better, so he put me on a mission to research the implementation of COM objects with multiple inheritance, without using MFC.</p>
<p>
When using MFC, a simple COM interface function looks like this:</p>
<pre><code>STDMETHODIMP CTelevision::<b>XDrawing</b>::GetRect(CRect* pRect)
{

<b> &nbsp;&nbsp; METHOD_PROLOGUE(CTelevision, Drawing);</b>

 &nbsp;&nbsp; if (!pRect) return E_INVALIDARG;
 &nbsp;&nbsp; <b>pThis-&gt;</b>m_dibImage.GetRect(pRect);
 &nbsp;&nbsp; return NOERROR;
}
</code></pre>
<p>
The code shown in boldface above is required when implementing COM objects with embedded interfaces, but is not required when multiple inheritance is used. The same COM object implemented with multiple inheritance looks like this:</p>
<pre><code>STDMETHODIMP CTelevision::GetRect(CRect* pRect)
{
 &nbsp; if (!pRect) return E_INVALIDARG;
 &nbsp; m_dibImage.GetRect(pRect);
 &nbsp; return NOERROR;
}
</code></pre>
<p>
With the multiple inheritance solution, you don't need the <b>METHOD_PROLOGUE</b> macro or the crazy <b>pThis</b> pointer. Building COM objects with MFC feels like programming with C instead of C++.</p>
<p>
Now, OLE Automation is a different story. MFC supports OLE Automation very well, similar to the way it supports menu commands. If you are writing an OLE Automation server instead of a COM object, MFC is the way to go.</p>
<p>
In this article, we will discuss the implementation of COM objects using multiple inheritance. Specifically, I will:
<ul type=disc>
<li>
Provide an overview of the sample COM objects implemented in MI_Appliances.dll. This sample includes the COMBASE.H and COMBASE.CPP files.<br><br></li>
<li>
Review the architecture of a COM object built using multiple inheritance.<br><br></li>
<li>
Discuss the reason for having two <b>IUnknown</b> interfaces.<br><br></li>
<li>
Explain how to use COMBASE.H and COMBASE.CPP from the sample application to build COM objects using multiple inheritance. <br><br></li>
<li>
Trace the program flow from <b>::CoCreateInstance</b> all the way to the first <b>QueryInterface</b>.<br><br></li>
<li>
Follow the path of execution as a COM object aggregates another COM object.</li>
</ul>
<h2>The Sample Code</h2>
<p>
To demonstrate multiple inheritance, I rewrote all of the COM objects in Nigel's Appliances.dll to use multiple inheritance. The new dynamic-link library (DLL), MI_Appliances.dll, completely replaces Nigel's Appliances.dll. </p>
<p>
The only class I changed was <b>CNotifyListObject</b>. In Appliances.dll, a non-<b>CObject</b>-derived pointer was incorrectly being stuffed into a <b>CObList</b>. It's amazing what the compiler will let you get away with when you cast something, and it's even more amazing that this worked. I replaced the <b>CObList</b> with:</p>
<pre><code>CTypedPtrList&lt;CPtrList, CUserInfo*&gt; m_NotifyList;
</code></pre>
<p>
I didn't want to make any changes to the House sample, so the COM objects in MI_Appliances use the same GUIDs as the corresponding objects in Appliances.dll. To use MI_Appliances.dll, change the paths in MI_Appliances.reg to point to MI_Appliances.dll on your system, then double-click MI_Appliances.reg to add these entries to the registry.</p>
<p>
The HOUSE4 sample can work with a mixture of objects from Appliances.dll and MI_Appliances.dll. You can edit the registry to specify which appliance comes from which DLL.</p>
<p>
To use MI_Appliances.dll, you must first install Nigel's HOUSE4 sample application, then install MI_Appliances in the HOUSE4 directory. MI_Appliances uses the common header files in the INCLUDE directory.</p>
<h2>Architecture of a Multiple-Inheritance COM Object</h2>
<p>
Let's say that we wanted a COM object to support the <b>IDrawing</b> and <b>IOutlet</b> interfaces using multiple inheritance:</p>
<pre><code>class IOutlet : public IUnknown {...} ;
class IDrawing : public IUnknown {...} ;

class CLightBulb : public IDrawing,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IOutlet
{
public:
 &nbsp; // IUnknown implementation
 &nbsp; virtual HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) ;
 &nbsp; virtual ULONG&nbsp;&nbsp; __stdcall AddRef() ;
 &nbsp; virtual ULONG&nbsp;&nbsp; __stdcall Release() ;

 &nbsp; // IDrawing interface implementation
 &nbsp; virtual HRESULT __stdcall Draw(CDC* pDC, int x, int y);
 &nbsp; virtual HRESULT __stdcall SetPalette(CPalette* pPal);
 &nbsp; virtual HRESULT __stdcall GetRect(CRect* pRect);

 &nbsp; // IOutlet interface implementation
 &nbsp; virtual HRESULT __stdcall On();
 &nbsp; virtual HRESULT __stdcall Off();
 &nbsp; virtual HRESULT __stdcall GetState(BOOL* pState);
.
.
.
 &nbsp; // Implementation details here.
.
.
.
} ;
</code></pre>
<p>
Notice that we need to define <b>IUnknown</b> only once, although we inherit <b>IUnknown </b>through both <b>IDrawing</b> and <b>IOutlet</b>. If you find this surprising, remember that <b>C::f</b> overrides both <b>A::f</b> and <b>B::f</b> in the following example:</p>
<pre><code>class A 
{
 &nbsp; virtual int f();
} ;

class B 
{
 &nbsp; virtual int f();
} ;

class C : public A, public B 
{
 &nbsp; virtual int f() ; 
} ;
</code></pre>
<p>
Because all interfaces require an <b>IUnknown</b> implementation, reusing a single implementation of <b>IUnknown </b>would be beneficial. Therefore, we define a class called <b>CUnknown</b> to implement <b>IUnknown</b>.</p>
<pre><code>class CUnknown : public IUnknown {...} ;

class CLightBulb : <b>public CUnknown</b>,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IDrawing,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IOutlet
{
} ;
</code></pre>
<p>
However, this doesn't work. <b>CUnknown </b>cannot implement the <b>IUnknown </b>interfaces inherited through <b>IDrawing</b> and <b>IOutlet</b>, because pure virtual functions must be implemented in a derived class. <b>CUnknown</b> can only implement the <b>IUnknown</b> that it inherits. C++ does not allow a base class to implement methods in another base class, so we have to define <b>IUnknown </b>in <b>CLightBulb</b>.</p>
<p>
Figure 1 shows the inheritance graph for <b>CLightBulb</b>, as defined above. Abstract classes are shown in square boxes. </p>
<p>
<img src="micom1_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Inheritance graph for IUnknown implemented in CUnknown</b></p>
<p>
Hope is not completely lost. We could implement two <b>IUnknown</b> interfaces: one in <b>CUnknown </b>and another in <b>CLightBulb</b>. The <b>IUnknown </b>in <b>CUnknown </b>would do the real work, and the <b>IUnknown </b>in <b>CLightBulb </b>would delegate to the real <b>IUnknown</b>. The <b>IUnknown </b>in <b>CUnknown </b>is called the delegating <b>IUnknown</b>, while <b>CUnknown </b>contains the non-delegating <b>IUnknown</b>. Therefore, let's call the <b>IUnknown </b>interface that does the real work, <b>INonDelegatingUnknown</b>:</p>
<pre><code>DECLARE_INTERFACE(INonDelegatingUnknown)
{
  STDMETHOD(NonDelegatingQueryInterface)(THIS_ REFIID, LPVOID *) PURE;
  STDMETHOD_(ULONG, NonDelegatingAddRef)(THIS) PURE;
  STDMETHOD_(ULONG, NonDelegatingRelease)(THIS) PURE;
};

class CUnknown : public INonDelegatingUnknown {...} ;
</code></pre>
<p>
For convienience, we can create a macro, <b>DECLARE_IUNKNOWN</b>, that delegates to the <b>IUnknown</b> defined in <b>CUnknown</b>. Figure 2 shows the class hierarchy.</p>
<p>
<img src="micom1_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Class hierarchy using delegating and non-delegating IUnknowns</b></p>
<p>
Because our object supports more than just the <b>IUnknown</b> interface, we need to override <b>NonDelegatingQueryInterface </b>to handle the other interfaces. Thus, the header file for our <b>CLightBulb</b> class would look like this:</p>
<pre><code>class CLightBulb : <b>public CUnknown</b>,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IDrawing,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IOutlet
{
public:
 &nbsp; <b>// Delegating IUnknown</b>

<b> &nbsp; DECLARE_IUNKNOWN ;</b>


<b> &nbsp; // IUnknown implementation</b>

<b> &nbsp; virtual HRESULT __stdcall </b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NonDelegatingQueryInterface(REFIID riid, void **ppv) ;</b>


 &nbsp; // IDrawing interface implementation
 &nbsp; virtual HRESULT __stdcall Draw(CDC* pDC, int x, int y);
 &nbsp; virtual HRESULT __stdcall SetPalette(CPalette* pPal);
 &nbsp; virtual HRESULT __stdcall GetRect(CRect* pRect);

 &nbsp; // IOutlet interface implementation
 &nbsp; virtual HRESULT __stdcall On();
 &nbsp; virtual HRESULT __stdcall Off();
 &nbsp; virtual HRESULT __stdcall GetState(BOOL* pState);
.
.
.
 &nbsp; // Implementation details here
.
.
.
} ;
</code></pre>
<p>
This discussion covers the basics of implementing a COM object using multiple inheritance. I have skipped the entire subject of class factories and creating COM objects because these topics have nothing to do with multiple inheritance. See <i>Inside OLE 2</i> by Kraig Brockschmidt (MSDN Library, Books) for more information on creating COM objects. </p>
<p>
The MI_Appliance sample application contains two files: COMBASE.H and COMBASE.CPP, which contain the implementation of <b>CUnknown </b>and <b>CClassFactory</b>.</p>
<p>
The astute reader will realize that I haven't shown the implementation of the <b>DECLARE_IUNKNOWN</b> macro. This is intentional. First, let's talk about the second reason for having a delegating <b>IUnknown</b> and a non-delegating <b>IUnknown</b>. That reason is aggregation.</p>
<h2>Delegating vs. Non-Delegating IUnknown</h2>
<p>
The best way to understand why aggregation requires a delegating and a non-delegating <b>IUnknown</b> is to look at the possible ways that <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> are called in the aggregated and non-aggregated cases, and assume that we only have a single <b>IUnknown </b>interface. If the object does not support aggregation, the non-delegating <b>IUnknown </b>is used. When the object is aggregated, the delegating <b>IUnknown</b> is used.</p>
<p>
For this discussion, let's assume we have two objects, Boss and Peon. The Boss object is controlling the Peon object. This relationship is represented as a standard OLE object diagram in Figure 3.</p>
<p>
<img src="micom1_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Boss controls Peon</b></p>
<p>
When Boss creates Peon, it calls <b>CoCreateInstance</b>:</p>
<pre><code>::CoCreateInstance(CLSID_Peon,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pUnkOwner,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IUnknown,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;pUnkPeon);
</code></pre>
<p>
<b>CoCreateInstance </b>returns a pointer to the Peon's <b>IUnknown</b>. If Peon had two <b>IUnknown</b> interfaces, its <b>ClassFactory</b> would return the pointer to the primary (or non-delegating) <b>IUnknown</b>. However, we are attempting to implement Peon with only one <b>IUnknown</b>, so its <b>ClassFactory</b> returns a pointer to the one and only <b>IUnknown </b>interface. Peon should also increment its reference count before returning the <b>IUnknown </b>pointer. All of this can be implemented without using <b>QueryInterface</b> or <b>AddRef</b>, since Peon can implement its own <b>ClassFactory </b>object with its own <b>CreateInstance</b> method.</p>
<p>
If Boss wants to get the <b>IPeon </b>interface, it queries Peon's <b>IUnknown </b>interface:</p>
<pre><code>pUnkPeon-&gt;QueryInterface(IID_IPeon, (void**)pIPeon) ;
</code></pre>
<p>
This call returns a pointer to the <b>IPeon</b> interface in Peon and increments the reference counter on Boss.</p>
<p>
If <b>pIPeon</b> is queried for <b>IUnknown</b>, the COM specification requires <b>QueryInterface</b> to return the <b>IUnknown</b> for Boss instead of the <b>IUnknown</b> for Peon:</p>
<pre><code>pIPeon-&gt;QueryInterface(IID_IUnknown, (void**)pUnk) ;
ASSERT(pUnk == pUnkBoss) ;
ASSERT(pUnk != pUnkPeon) ;
</code></pre>
<p>
This <b>QueryInterface </b>call also increments the reference count on Boss.</p>
<p>
Here's a single <b>QueryInterface </b>that does all of this work:</p>
<pre><code>HRESULT CPeon::QueryInterface(REFIID riid, void** ppv)
{
 &nbsp; if (IID_IUnknown == riid)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (m_pUnkOwner)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Aggregated
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = m_pUnkOwner ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Return IUnknown for Boss.
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Non-aggregated
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IUnknown*)this ; // Return IUnknown for Peon.
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
 &nbsp; else if (IID_IPeon == riid)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; *ppv = (IPeon*)this ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Return IPeon pointer.
 &nbsp; }
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; *ppv = NULL ;
 &nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE ;
 &nbsp; }&nbsp;&nbsp; 

 &nbsp; // AddRef interface
 &nbsp; if (m_pUnkOwner)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Aggregated&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; m_pUnkOwner-&gt;AddRef() ;&nbsp; // AddRef Boss
 &nbsp; }
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp;&nbsp; // Non-aggregated
 &nbsp;&nbsp;&nbsp; AddRef() ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // AddRef Peon
 &nbsp; }
 &nbsp; return NOERROR ;
}
</code></pre>
<p>
Notice that <b>QueryInterface</b> cannot be called from <b>ClassFactory::CreateInstance</b> to get the <b>IUnknown </b>for Peon, unless <b>m_pUnkOwner</b> is set after the call. Otherwise, the reference count for Boss will be incrememented instead of the reference count for Peon.</p>
<p>
So, why have two <b>IUnknown</b> interfaces if only one <b>QueryInterface </b>function is needed? Because it's not possible to implement <b>AddRef </b>and <b>Release </b>functions that work for both the aggregated and non-aggregated cases. </p>
<p>
Using the variables defined above:</p>
<pre><code>pUnkPeon-&gt;AddRef() ;
</code></pre>
<p>
should increment the reference count on Peon, while:</p>
<pre><code>pIPeon-&gt;AddRef() ;
</code></pre>
<p>
should increment the reference count on Boss. <b>CPeon::Release</b> works in the same manner. A first attempt at coding <b>AddRef</b> might be:</p>
<pre><code>CPeon::AddRef()
{
 &nbsp; if (m_pUnkOwner)
 &nbsp;&nbsp;&nbsp;&nbsp; m_pUnkOwner-&gt;AddRef() ;
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; AddRef() ;
}
</code></pre>
<p>
<b>pUnkPeon </b>and <b>pIPoen </b>both point to the same object in which <b>pUnkOwner </b>is non-NULL, so this solution will not work. Somehow, <b>pUnkPeon </b>must invoke a different <b>AddRef</b> method than that invoked by <b>pIPeon</b>. Because both <b>pUnkPeon </b>and <b>pIPeon </b>are pointers to interfaces, the most straightforward solution is to have them point to two different interfaces: One interface will act as the <b>IUnknown </b>for Peon, and the other interface will delegate calls to Boss. </p>
<h3>Using Two IUnknowns</h3>
<p>
To support aggregation with two <b>IUnknown</b> interfaces, <b>CUnknown </b>contains an <b>IUnknown </b>pointer, <b>m_pUnkOwner</b>, which points to the owner of the object. The non-delegating <b>IUnknown</b> is the owner of the object if it is not aggregated. <b>m_pUnkOwner</b> is set in the constructor:</p>
<pre><code>CUnknown::CUnknown(IUnknown* pUnk, HRESULT* phr)
{
 &nbsp; InterlockedIncrement(&amp;m_ObjectCount) ;

 &nbsp; if (pUnk == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; m_pUnkOwner = (IUnknown*)(INonDelegatingUnknown*)this ;   
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; m_pUnkOwner = pUnk ;

 &nbsp; m_RefCount = 0 ;
}
</code></pre>
<p>
The <b>DECLARE_IUNKNOWN</b> macro implements <b>IUnknown </b>by delegating to the <b>IUnknown</b> that <b>m_pUnkOwner</b> points to. Here's the definition of <b>DECLARE_IUNKNOWN</b>:</p>
<pre><code>#define DECLARE_IUNKNOWN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp; STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetOwner()-&gt;QueryInterface(riid,ppv);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp; STDMETHODIMP_(ULONG) AddRef() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetOwner()-&gt;AddRef();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp; STDMETHODIMP_(ULONG) Release() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetOwner()-&gt;Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp; };
</code></pre>
<p>
where <b>GetOwner </b>is defined as follows:</p>
<pre><code>IUnknown* CUnknown::GetOwner() const
{ return m_pUnkOwner; }
</code></pre>
<p>
In <b>CUnknown</b>'s constructor, note that <b>m_pUnkOwner</b> is initialized with the line:</p>
<pre><code>m_pUnkOwner = (IUnknown*)(INonDelegatingUnknown*)this ;
</code></pre>
<p>
in the non-aggregated case. In the non-aggregated case, any call to the delegating <b>IUnknown </b>results in calls to the non-delegating <b>IUnknown</b>. More precisely: </p>
<pre><code>IUnknown* pUnk = this;
pUnk-&gt;AddRef() ;
</code></pre>
<p>
will call the delegating <b>AddRef</b>, while:</p>
<pre><code>IUnknown* pUnk = (IUnknown*)(INonDelegatingUnknown*)this;
pUnk-&gt;AddRef
</code></pre>
<p>
will call the <b>NonDelegatingAddRef</b>.</p>
<p>
Now that we know the architecture of a COM object built using multiple inheritance, it's time to see how we can actually implement the object.</p>
<h2>Implementing a COM Object Using Multiple Inheritance</h2>
<p>
One big drawback to implementing COM objects using multiple inheritance is that you can't use ClassWizard, and AppWizard will help only by building a DLL for you. However, once you have implemented a COM object, implementing other objects is a simple process of cutting and pasting code. In this section, we will explain how to implement a COM object using multiple inheritance and the code I've provided in COMBASE.H and COMBASE.CPP. The implementation consists of two steps: First you create a DLL to hold the COM object, then you write the code for the COM object.</p>
<h3>Creating the DLL</h3>
<p>
A COM object resides either in a .DLL or in an .EXE. In this example, we'll place the COM object in a DLL. This process consists of four steps:
<ol>
<li>
Create an MFC DLL using AppWizard.<br><br></li>
<li>
Remove MFC OLE Automation code.<br><br></li>
<li>
Add the <b>CFactoryTemplate </b>array.<br><br></li>
<li>
Add COMBASE.CPP to the project.</li>
</ol>
<h4>Step 1. Create an AppWizard DLL</h4>
<p>
Use AppWizard to create a DLL that statically links to the MFC library. COM objects cannot use the shared version of the MFC library. Also, select the "OLE Automation" check box. We will replace all of the MFC OLE Automation code with our own code, but it's nice to have AppWizard put in stubs for the functions.</p>
<h4>Step 2. Remove MFC OLE Automation code</h4>
<p>
In this step, we'll replace the MFC OLE code with the code I've provided in COMBASE.H and COMBASE.CPP. Comment out the call to <b>COleObjectFactory::RegisterAll</b> in your DLL's <b>InitInstance</b>. Also comment out the <b>DllRegisterServer </b>function, and remove its entry from the .DEF file. Change the <b>DllGetClassObject</b> and <b>DllCanUnloadNow</b> functions to match the listings below:</p>
<pre><code>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
 &nbsp; // return AfxDllGetClassObject(rclsid, riid, ppv);
 &nbsp; return CClassFactory::GetClassObject(rclsid, riid, ppv);
}

STDAPI DllCanUnloadNow(void)
{
 &nbsp; // return AfxDllCanUnloadNow();
 &nbsp; return CClassFactory::CanUnloadNow();
}
</code></pre>
<p>
<b>CClassFactory::GetClassObject </b>creates the <b>rclsid</b> COM object returning the <b>riid </b>interface in <b>ppv</b>.</p>
<h4>Step 3. Add the CFactoryTemplate array</h4>
<p>
In your DLL's main file, define the <b>CFactoryTemplate</b> array: </p>
<pre><code>CFactoryTemplate g_Templates[] =
{
 &nbsp; // Fill with CLSID and CreateInstance function.

} ;
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]) ;
</code></pre>
<p>
This array is used by <b>CClassFactory</b> to create the COM objects supported by the DLL. The array will be filled later when we actually add a COM object. <b>CClassFactory </b>looks into the array for the CLSID passed to <b>GetClassObject</b>. After finding the CLSID, <b>CClassFactory</b> calls the creation function listed in the <b>CFactoryTemplate </b>structure.</p>
<h4>Step 4. Add COMBASE.CPP to the project</h4>
<p>
Add the COMBASE.CPP and COMBASE.H files (which are part of the MI_Appliances sample application) to the project. These files implement <b>CUnknown</b>, <b>CClassFactory</b>, and <b>CFactoryTemplate</b>.</p>
<h3>Creating the COM Object</h3>
<p>
Now that we have a DLL to hold the COM objects, we can create a COM object following these steps:
<ol>
<li>
Create the C++ class.<br><br></li>
<li>
Implement <b>CreateInstance</b>.<br><br></li>
<li>
Add <b>CreateInstance</b> to the <b>CFactoryTemplate </b>array.<br><br></li>
<li>
Implement the constructor.<br><br></li>
<li>
Implement <b>NonDelegatingQueryInterface</b>.<br><br></li>
<li>
Add <b>DECLARE_IUNKNOWN</b>.<br><br></li>
<li>
Put initialization code in <b>OnInit</b>.<br><br></li>
<li>
Implement the interfaces.<br><br></li>
<li>
Create the GUIDs.<br><br></li>
<li>
Update the registry.</li>
</ol>
<h4>Step 1. Create the C++ class</h4>
<p>
Create a header file and implementation file for the C++ class that implements the COM object. You have to do this on your own; ClassWizard will not help.</p>
<p>
The C++ class should inherit from <b>CUnknown </b>and from any other interfaces that it supports. For example, <b>CLightBulb </b>is defined as follows:</p>
<pre><code>class CLightBulb : public CUnknown,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IDrawing,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IOutlet
{ ... } ;
</code></pre>
<h4>Step 2. Implement CreateInstance</h4>
<p>
<b>CClassFactory</b> calls <b>CreateInstance </b>to create the COM object. <b>CreateInstance</b> is a static member function of our object class. All <b>CreateInstance</b> functions are basically the same and can be built by copying the code from an existing implementation.</p>
<pre><code>CUnknown* CLightBulb::CreateInstance(IUnknown* pUnk, HRESULT* phr)
{
 &nbsp; CLightBulb* pNewObject = new CLightBulb(pUnk, phr) ;
 &nbsp; if (pNewObject == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; *phr = E_OUTOFMEMORY ;

 &nbsp; return pNewObject ;
}
</code></pre>
<p>
It is possible to implement <b>CreateInstance</b> using C++ templates; however, I felt that this would make the source code unnecessarily confusing. If there is enough interest, I can present a version of <b>CFactoryTemplate </b>that uses C++ templates in a future article.</p>
<h4>Step 3. Add the CreateInstance function to the CFactoryTemplate array</h4>
<p>
Add the <b>CreateInstance </b>function for your object to the <b>CFactoryTemplate </b>array so that <b>CClassFactory</b> can create the object.</p>
<pre><code>CFactoryTemplate g_Templates[] =
{
 &nbsp; {&amp;CLSID_LightBulb, CLightBulb::CreateInstance}
}
</code></pre>
<p>
You can put as many objects as you want in this array. <b>CClassFactory</b> supports the creation of any object with a <b>CreateInstance</b> function.</p>
<h4>Step 4. Implement the constructor</h4>
<p>
Implement the constructor for the C++ class. Make sure that you initialize the <b>CUnknown </b>base class. The constructor must take an <b>IUnknown </b>pointer and an <b>HRESULT </b>pointer to pass to the <b>CUnknown</b> base class.</p>
<pre><code>CLightBulb::CLightBulb(IUnknown* pUnk, HRESULT* phr)
 &nbsp; : <b>CUnknown(pUnk, phr) </b>
{
 &nbsp; m_pPal = NULL;
 &nbsp; m_bIsOn = FALSE;
 &nbsp; m_dibImageOn.Load(IDR_DIB_LIGHTBULB_ON);
 &nbsp; m_dibImageOff.Load(IDR_DIB_LIGHTBULB_OFF);
}
</code></pre>
<p>
I like to implement protected constructors, because the COM objects should be constructed only by the <b>CreateInstance </b>function or by a derived class.</p>
<h4>Step 5. Implement NonDelegatingQueryInterface</h4>
<p>
In <b>NonDelegatingQueryInterface</b>, add support for the interfaces that your object handles. <b>CLightBulb</b> supports the <b>IOutlet </b>and <b>IDrawing </b>interfaces:</p>
<pre><code>HRESULT CLightBulb::NonDelegatingQueryInterface(REFIID riid, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void** ppv)
{
 &nbsp; if (riid == IID_IOutlet)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; return GetInterface((IOutlet*)this, ppv) ;
 &nbsp; }
 &nbsp; else if (riid == IID_IDrawing)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; return GetInterface((IDrawing*)this, ppv) ;
 &nbsp; }
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; return CUnknown::NonDelegatingQueryInterface(riid, ppv) ;
}
</code></pre>
<p>
Pass any interface IDs that you don't handle to <b>CUnknown::NonDelegatingQueryInterface</b>.</p>
<p>
<b>CUnknown::GetInterface </b>is a helper function in COMBASE.CPP that sets <b>ppv </b>with the pointer to the desired interface and calls <b>AddRef </b>on that interface. It is implemented as follows:</p>
<pre><code>HRESULT CUnknown::GetInterface(IUnknown* pUnk, void** ppv) 
{
 &nbsp; *ppv = pUnk ;
 &nbsp; ((IUnknown*)pUnk)-&gt;AddRef() ;
 &nbsp; return NOERROR ;
}
</code></pre>
<p>
If a COM object supports interfaces through aggregation, its <b>NonDelegatingQueryInterface </b>should call <b>QueryInterface </b>on the aggregated object. The Radio object in MI_Appliances.dll implements the <b>IBitmap </b>and <b>IDrawing </b>interfaces by aggregating a <b>BitmapObject</b>. <b>CRadio::NonDelegatingQueryInterface </b>forwards all requests for <b>IBitmap </b>and <b>IDrawing </b>to the <b>BitmapObject</b>.</p>
<pre><code>HRESULT __stdcall CRadio::NonDelegatingQueryInterface(REFIID riid, void** ppv)
{
 &nbsp; if (riid == IID_IApplianceUI)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; return GetInterface((IApplianceUI*)this, ppv) ;
 &nbsp; }
 &nbsp; else if ((riid == IID_IBitmap) || (riid == IID_IDrawing))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; return m_punkBitmap-&gt;QueryInterface(riid, ppv);
 &nbsp; }
 &nbsp; else
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; return CUnknown::NonDelegatingQueryInterface(riid, ppv) ;
 &nbsp; }
}
</code></pre>
<h4>Step 6. Add DECLARE_IUNKNOWN</h4>
<p>
Add <b>DECLARE_IUNKNOWN</b> to your header file to declare the delegating <b>IUnknown</b> used in aggregation. This is required even if you aren't using aggregation.</p>
<h4>Step 7. Put Initialization code in OnInit</h4>
<p>
If you have additional initialization code, override <b>CUnknown::OnInit</b>. This member function is mainly used for aggregating with other COM objects. (See the "Aggregation" section later in this article.)</p>
<h4>Step 8. Implement the interfaces</h4>
<p>
Implement the COM interfaces supported by your COM object. The <b>IOutlet </b>interface is implemented as follows for <b>CLightBulb</b>:</p>
<pre><code>HRESULT CLightBulb::On()
{
 &nbsp;&nbsp; m_bIsOn = TRUE;
 &nbsp;&nbsp; return NOERROR;
}

HRESULT CLightBulb::Off()
{
 &nbsp;&nbsp; m_bIsOn = FALSE;
 &nbsp;&nbsp; return NOERROR;
}

HRESULT CLightBulb::GetState(BOOL* pState)
{
 &nbsp;&nbsp; if (!pState) return E_INVALIDARG;
 &nbsp;&nbsp; *pState = m_bIsOn;
 &nbsp;&nbsp; return NOERROR;
}
</code></pre>
<h4>Step 9. Create the GUIDs</h4>
<p>
All COM objects need GUIDs for identification. Refer to Nigel Thompson's article <a href="msdn_house1.htm">"MFC/COM Objects 1: Creating a Simple Object"</a> for more information.</p>
<h4>Step 10. Update the registry</h4>
<p>
Make sure that you add the CLSIDs of your objects to the registry. You will need to make a .reg file for your COM objects. Refer to Nigel Thompson's article <a href="msdn_house1.htm">"MFC/COM Objects 1: Creating a Simple Object"</a> for more information.</p>
<h3>The Finished Product</h3>
<p>
Here is the finished header file for <b>CLightBulb</b>:</p>
<pre><code>#ifndef __CLightBulb_H__
#define __CLightBulb_H__

class CLightBulb : public CUnknown,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IDrawing,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IOutlet
{
public:
 &nbsp; // Delegating IUnknown
 &nbsp; DECLARE_IUNKNOWN ; 

 &nbsp; // Called by ClassFactory
 &nbsp; static CUnknown* CreateInstance(IUnknown* pUnk, HRESULT* phr) ;

 &nbsp; // Overload to support IDrawing and IOutlet
 &nbsp; virtual HRESULT __stdcall NonDelegatingQueryInterface(REFIID riid,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void** ppv) ;

 &nbsp; // IDrawing interface implementation
 &nbsp; virtual HRESULT __stdcall Draw(CDC* pDC, int x, int y);
 &nbsp; virtual HRESULT __stdcall SetPalette(CPalette* pPal);
 &nbsp; virtual HRESULT __stdcall GetRect(CRect* pRect);

 &nbsp; // IOutlet interface implementation
 &nbsp; virtual HRESULT __stdcall On();
 &nbsp; virtual HRESULT __stdcall Off();
 &nbsp; virtual HRESULT __stdcall GetState(BOOL* pState);

protected:
 &nbsp; // Constructor
 &nbsp; CLightBulb(IUnknown* pUnk, HRESULT* phr) ;

 &nbsp; // Destructor
 &nbsp; virtual ~CLightBulb() ;

protected:
 &nbsp; // Member variables
 &nbsp; CDIB m_dibImageOn;
 &nbsp; CDIB m_dibImageOff;
 &nbsp; CPalette* m_pPal;
 &nbsp; BOOL m_bIsOn;
} ;
</code></pre>
<p>
You can use this code as a guide for implementing your own COM objects that use multiple inheritance.</p>
<h2>Path of Execution</h2>
<p>
Now that we have built <b>CLightBulb</b>, let's trace the path of execution as the House sample application creates <b>CLightBulb</b>. If you aren't interested in following the code as it executes, you can skip this section. If you are interested, it would be helpful to follow along in the sample code accompanying this article.</p>
<p>
The House sample executes the following code:</p>
<pre><code>HRESULT hr = ::CoCreateInstance(CLSID_LightBulb,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IUnknown,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID*)ppIUnknown);
</code></pre>
<p>
<b>::CoCreateInstance </b>calls <b>DLLGetClassObject</b> in MI_Appliances.CPP. <b>DLLGetClassObject</b> calls <b>CClassFactory::GetClassObject</b>, which looks in the <b>CFactoryTemplates</b> in the <b>g_Templates</b> array for CLSID_LightBulb. When it finds CLSID_LightBulb, it creates a <b>CClassFactory</b> object using the <b>CFactoryTemplate </b>corresponding to CLSID_LightBulb.</p>
<p>
<b>::CoCreateInstance </b>then calls <b>CClassFactory::CreateInstance</b>, which calls <b>CFactoryTemplate::CreateInstance</b>. This function calls <b>CLightBulb::CreateInstance</b> via a function pointer, which is initialized in the <b>g_Templates</b> array. <b>CLightBulb::CreateInstance </b>finally creates a <b>CLightBulb </b>object using the new operator.</p>
<p>
Boy, that was a lot of work to create a <b>CLightBulb</b> object. The process basically translate a CLSID_LightBulb into:</p>
<pre><code>CLightBulb* pLightBulb = new CLightBulb(pUnk, phr) ;
</code></pre>
<p>
This setup is complex, because <b>CClassFactory </b>is not hardwired to create a single COM object. <b>CClassFactory </b>can create any class that has a <b>CreateInstance</b> function and a <b>CFactoryTemplate</b> object that has been filled in correctly.</p>
<p>
Well, <b>CClassFactory::CreateInstance </b>still has work to do before it can return execution to the House sample. Here is the code for <b>CClassFactory::CreateInstance</b>:</p>
<pre><code>STDMETHODIMP CClassFactory::CreateInstance(IUnknown* pUnkOuter, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID riid, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void** ppv)
{
 &nbsp; if ((pUnkOuter != NULL) &amp;&amp;  
 &nbsp;&nbsp;&nbsp;&nbsp; (riid != IID_IUnknown))
 &nbsp; {
 &nbsp;&nbsp;&nbsp; // Aggregated objects can only query IUnknown.
 &nbsp;&nbsp;&nbsp; return ResultFromScode(CLASS_E_NOAGGREGATION);
 &nbsp; }

 &nbsp; HRESULT hr = NOERROR ;
 &nbsp; CUnknown *pObj = m_pTemplate-&gt;CreateInstance(pUnkOuter, &amp;hr);
 &nbsp; if (pObj == NULL) return hr;
 &nbsp; if (FAILED(hr))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; delete pObj;
 &nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp; }

 &nbsp; if (!pObj-&gt;Init())
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; delete pObj ;
 &nbsp;&nbsp;&nbsp;&nbsp; return E_OUTOFMEMORY ;
 &nbsp; }

 &nbsp; hr = pObj-&gt;NonDelegatingQueryInterface(riid, ppv);
 &nbsp; if (FAILED(hr))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; delete pObj;
 &nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp; }

 &nbsp; ASSERT(*ppv);
 &nbsp; return hr;
}
</code></pre>
<p>
<b>CClassFactory::CreateInstance</b> next calls the object's <b>CUnknown::Init</b> member function, which is discussed in the next section.</p>
<p>
Finally, <b>CClassFactory::CreateInstance </b>calls <b>CLightBulb::NonDelegatingQueryInterface</b>, which returns a pointer to the interface specified by <b>riid</b> and increments the reference count for this instance of a <b>CLightBulb</b> object. Because House requests the <b>IUnknown </b>interface, <b>CLightBulb::NonDelegatingQueryInterface </b>passes control to <b>CUnknown::NonDelegatingQueryInterface</b>, which returns the following pointer for <b>IUnknown</b>:</p>
<pre><code>(IUnknown*)(INonDelegatingUnknown*)this
</code></pre>
<p>
The non-delegating <b>IUnknown </b>is returned whenever an object is created. See the section "Delegating vs. Non-Delegating IUnknown" earlier in this article for more information.</p>
<p>
Now, <b>CClassFactory::CreateInstance </b>returns control back to the House sample, which executes the following line:</p>
<pre><code>(*ppIUnknown)-&gt;QueryInterface(IID_IDrawing, (LPVOID*)&amp;pIDrawing) ;
</code></pre>
<p>
querying the LightBulb object for its <b>IDrawing </b>interface. This results in a call to <b>CLightBulb::NonDelegatingQueryInterface</b>, which returns a pointer to <b>CLightBulb</b>'s <b>IDrawing</b> interface and increments its reference count.</p>
<p>
Here is the control flow (I've presented it like a call stack dump):</p>
<pre><code>CMainFrame::OnCreate [House]
  CMainFrame::CreateAppliance [House]
 &nbsp;&nbsp; ::CoCreateInstance [OLE]
 &nbsp;&nbsp;&nbsp;&nbsp; DLLGetClassObject
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CClassFactory::GetClassObject
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CClassFactory::CClassFactory
 &nbsp;&nbsp;&nbsp;&nbsp; CClassFactory::CreateInstance
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CFactoryTemplate::CreateInstance
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLightBulb::CreateInstance
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLightBulb::CLightBulb
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUnknown::CUnknown
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLightBulb::Init
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLightBulb::OnInit
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLightBulb::NonDelegatingQueryInterface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUnknown::NonDelegatingQueryInterface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUnknown::GetInterface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUnknown::NonDelegatingAddRef
 &nbsp;&nbsp; [House calls QueryInteface for IDrawing]
 &nbsp;&nbsp; CLightBulb::NonDelegatingQueryInteface
 &nbsp;&nbsp;&nbsp;&nbsp; CUnknown::GetInterface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLightBulb::AddRef
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUnknown::NonDelegatingAddRef&nbsp;&nbsp;&nbsp;&nbsp; 
</code></pre>
<p>
Wow, that's a lot of code!</p>
<h2>Aggregation</h2>
<p>
The previous section traced the program flow for the creation of the LightBulb COM object. Now let's look at the program flow when a COM object aggregates itself with another COM object.</p>
<p>
<b>CStandardLamp</b> uses aggregation to implement its <b>INotifySrc</b> interface. <b>CClassFactory::CreateInstance</b> calls <b>CUnknown::Init</b>:</p>
<pre><code>BOOL CUnknown::Init()
{
 &nbsp; m_RefCount++ ;
 &nbsp; BOOL bResult = OnInit() ;
 &nbsp; m_RefCount-- ;
 &nbsp; return bResult ;
}
</code></pre>
<p>
<b>CUnknown::Init </b>calls the <b>CUnknown::OnInit</b> virtual function, which is <b>CStandardLamp</b> overrides. The reference count is artificially incremented before <b>OnInit</b>, because it is zero at this time, and aggregating an object in <b>OnInit </b>could result in the <b>CStandardLamp </b>instance getting deleted.</p>
<p>
<b>CStandardLamp::OnInit</b> is listed below with the error checking removed.</p>
<pre><code>BOOL CStandardLamp::OnInit()
{
 &nbsp; ::CoCreateInstance(CLSID_NotifyListObject,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetOwner(), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IUnknown,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;m_punkNotifyList);

 &nbsp; m_punkNotifyList-&gt;QueryInterface(IID_INotifySrc, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;m_pINotifySrc);
 &nbsp; m_RefCount-- ;
 &nbsp; return TRUE;   
}
</code></pre>
<p>
<b>::CoCreateInstance </b>is used to create a <b>NotifyListObject</b> in much the same manner as the House sample created the <b>StandardLamp</b> object. To aggregate an object, we pass the object its controlling <b>IUnknown</b>. <b>CUnknown::GetOwner </b>returns the controlling <b>IUnknown</b> for <b>CStandardLamp</b>. Because the House sample creates <b>CStandardLamp </b>with a NULL for its controlling <b>IUnknown</b>, <b>GetOwner </b>returns a pointer to <b>CStandardLamp</b>'s non-delegating <b>IUnknown</b>.</p>
<pre><code>IUnknown* GetOwner() const
 &nbsp; { return m_pUnkOwner; }
</code></pre>
<p>
<b>::CoCreateInstance</b> calls <b>CNotifyListObject::CreateInstance</b>, resulting in the construction of a <b>CNotifyListObject</b>. The constructor for <b>CNotifyListObject</b> calls the <b>CUnknown</b> constructor:</p>
<pre><code>CUnknown::CUnknown(IUnknown* pUnk, HRESULT* phr)
{
 &nbsp; InterlockedIncrement(&amp;m_ObjectCount) ;

 &nbsp; if (pUnk == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; m_pUnkOwner = (IUnknown*)(INonDelegatingUnknown*)this ;   
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; m_pUnkOwner = pUnk ;

 &nbsp; m_RefCount = 0 ;
}
</code></pre>
<p>
<b>CUnknown</b>'s constructor sets <b>CNotifyListObject</b>'s owner to be <b>CStandardLamp</b>'s <b>IUnknown</b> instead of its own non-delegating <b>IUnknown</b>. The rest of the construction is the same as discussed in the previous section, until <b>CStandardLamp::OnInit</b> queries <b>CNotifyListObject</b> for its <b>INotifySrc </b>interface:</p>
<pre><code>m_punkNotifyList-&gt;QueryInterface(IID_INotifySrc, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**)&amp;m_pINotifySrc);
</code></pre>
<p>
This code calls <b>CNotifyListObject::NonDelegatingQueryInterface</b>, which executes the equivalent of the following code:</p>
<pre><code>HRESULT CNotifyListObject::NonDelegatingQueryInterface(REFIID riid, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void** ppv)
{
.
.
.
 &nbsp; if (riid == IID_INotifySrc)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; *ppv = (INotifySrc*)this;
 &nbsp;&nbsp;&nbsp;&nbsp; ((IUnknown*)this)-&gt;AddRef() ;
 &nbsp;&nbsp;&nbsp;&nbsp; return NOERROR ;
 &nbsp; }
.
.
.
}
</code></pre>
<p>
The code above calls <b>CNotifyListObject::AddRef</b>, not <b>CNotifyListObject::NonDelegatingAddRef</b>. The <b>DECLARE_IUNKNOWN</b> macro implements <b>CNotifyListObject::AddRef</b> as follows:</p>
<pre><code>STDMETHODIMP_(ULONG) AddRef()
{
 &nbsp; return GetOwner()-&gt;AddRef
};
</code></pre>
<p>
As we saw previously, <b>CNotifyListObject::GetOwner</b> returns a pointer to the non-delegating <b>IUnknown</b> for <b>CStandardLamp</b>, incrementing the reference count for <b>CStandardLamp</b>! Control then passes back to <b>CStandardLamp::OnInit</b>, where the reference count is decremented, because we haven't given this pointer to any outside object.</p>
<p>
Here is the control flow in shorthand:</p>
<pre><code>CStandardLamp::CreateInstance
 &nbsp; CUnknown::Init 
 &nbsp;&nbsp;&nbsp;&nbsp; CStandardLamp::OnInit
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNotifyListObject::CreateInstance
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNotifyListObject::CNotifyListObject
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNotifyListObject::NonDelegatingQueryInteface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUnknown::GetInterface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNotifyListObject::AddRef
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CStandardLamp::AddRef
</code></pre>
<h2>Conclusion</h2>
<p>
Using multiple inheritance instead of MFC to build COM objects results in source code that is much easier to develop and debug. Multiple inheritance makes COM objects more C++-like, whereas using nested classes feels like writing OLE code in C. However, not doing the implementation the "MFC way" means not being able to use AppWizard or ClassWizard. ClassWizard support for OLE Automation is a great benefit to the programmer. However, ClassWizard support for COM objects is inadequate, and not being able to use ClassWizard is no great loss for the COM object developer.</p>
<h2>Bibliography</h2>
<p>
Thompson, Nigel. <a href="msdn_house1.htm">"MFC/COM Objects 1: Creating a Simple Object."</a> March 1995. (MSDN Library, Technical Articles)</p>
<p>
Thompson, Nigel. <a href="msdn_house5.htm">"MFC/COM Objects 5: Using Multiple Inheritance."</a> March 1995. (MSDN Library, Technical Articles)</p>
<p>
Brockschmidt, Kraig. <i>Inside OLE 2</i>. Redmond, WA: Microsoft Press, 1995. (MSDN Library, Books)</p>
<p>
Special thanks to Geraint Davies for letting me look at his source code!</p>
</BODY>
</HTML>
