<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The ABCs of MFC ActiveX Controls</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_abcsmfc"></a>The ABCs of MFC ActiveX Controls</h1>
<p>
Paul Johns<br>
Developer Trainer</p>
<p>
October 22, 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5002">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the StopLite sample application for this technical article.</a></p>
<h2>Introduction</h2>
<p>
ActiveX™ controls (formerly known as OLE controls) are hot stuff, with more than 1,000 controls currently available. They can run in a wide variety of containers—Visual Basic®, Visual C++®, Microsoft® Access, and, as we all know, Microsoft Internet Explorer 3.0. (They also can be used by Delphi and Netscape Navigator—and perhaps other containers.)</p>
<p>
ActiveX controls are also cool because they are what I call "scalable." Their functionality can be very simple, such as a timer control, or very complex, such as a data-bound grid, spreadsheet, or word processor control. Most controls fall somewhere in between.</p>
<p>
This scalability is important because you can use ActiveX controls as reusable software components in bigger applications. For instance, this article shows you how to write a stoplight control. I can hear you thinking now, "Well, that's interesting, I suppose, and cute—but how useful?"</p>
<p>
Okay, what would happen if we wrote a few other controls—say a road control, a vehicle control, and a master controller control? Remember, ActiveX controls feature two-way communication with their containers (in this case a Web page), so the controls can interact with each other via scripting on the page! With those components, how easy would it be to put together traffic simulations of any intersection or set of intersections you wanted?</p>
<p>
One of the cooler Java™ applets out there is a traffic simulation written by Kelly Liu. It's at http://seagal.lanl.gov:8090/~liuke/traffic/traffic.html. It's multithreaded, active, and it runs great, especially with the Internet Explorer 3.0 way fast just-in-time compiler.</p>
<p>
But as cool as the Java applet is, it's limited because it's monolithic. One big happy applet. Even the buttons are part of the applet. And the only way to do something that the programmer didn't plan for is—you guessed it—to modify the source code and recompile.</p>
<p>
Now, back to ActiveX. The stoplight control we're going to write here is only a very small piece of such a simulation. But it is a start—and the stoplight component we write here could be used as-is in a larger simulation. By the same token, all ActiveX controls can be used (and reused) as components in larger applications.</p>
<p>
I hope you'll agree that ActiveX controls are cool. And now I'll bet you're asking, "How can I get a piece of this ActiveX action?"</p>
<h2>Ways to Write an ActiveX Control</h2>
<p>
Right now, there are four ways to write an ActiveX control.
<ul type=disc>
<li>
Microsoft Foundation Classes (MFC)<br><br></li>
<li>
ActiveX Template Library<br><br></li>
<li>
BaseCtrl framework<br><br></li>
<li>
Visual J++™ (COM objects only)</li>
</ul>
<p>
(More ways to write ActiveX controls will be available soon. A later version of Microsoft Visual J++ will support the writing of complex ActiveX controls, as will the next version of Visual Basic. So you'll have tools and frameworks for every taste and need—except perhaps COBOL.)</p>
<p>
Using the ActiveX Template Library requires intimate knowledge of how OLE controls communicate with their containers—and implementation of over a dozen OLE interfaces for controls with user interfaces. The BaseCtrl framework is much simpler, but still requires more knowledge of OLE than does MFC. Visual J++ makes it very easy to write COM objects, but it's best used for pretty simple objects. We'll be doing articles about those other methods for writing controls in the future.</p>
<h2>Using MFC for ActiveX Controls</h2>
<p>
For most folks, we recommend using MFC because MFC controls are easy to write. You focus on your control's behavior, not the intricacies of OLE interfaces. And, with the new features of MFC 4.2, you can write controls that perform better and implement the cool new OCX 96 features. (You may want to stick with version 4.1 though; since the MFC 4.1 DLLs ship with Internet Explorer, all Internet Explorer 3.0 users will already have these DLLs properly installed on their system.)</p>
<p>
But every silver lining has its cloud—and there are two big MFC clouds.</p>
<p>
The first is that MFC controls, while not huge, are not tiny. If you're developing controls that don't need the full functionality of an OLE control, you might want to check out other options—perhaps after prototyping in MFC.</p>
<p>
The second cloud is bigger and darker, but might not be in your sky. To run an ActiveX control written with MFC, the correct version of the MFC and C Runtime DLLs must be installed on the user's system. These DLLs are over a megabyte total—quite large to be downloading at 14.4Kbps! The good news is that Internet Explorer 3.0 ships with version 4.1 of the MFC DLLs, so most users will have them installed already. Even if you use the 4.1 DLLs, be prepared to provide and install the DLLs for users running your control in clients other than Microsoft Internet Explorer. Also, you'll have to provide the MFC 4.2 DLLs to all users if you need MFC 4.2 features in your control.</p>
<h3>What's this Article About?</h3>
<p>
In this article, we're going to show you how to write a simple yet complete ActiveX control using MFC. We're using Visual C++ version 4.1, but the code should work with any compiler that supports MFC version 4.0 or later. Your Wizard support may vary, however. We show all the code that the Wizards generate and modify so you can follow along regardless of your tools.</p>
<p>
We aren't going to go into advanced topics—no discussions of how to asynchronously download video clips over the Internet, nor transparent controls—and only minimal discussion about over-the-Internet installation, code signing, and marking your control as safe for initializing and scripting. For now, just the basics.</p>
<p>
As we mentioned before, this control is a little on-screen stoplight. To keep the filename under eight characters without spaces (do this—it makes your life simpler!), I called the control StopLite. </p>
<p>
When the control is embedded in a Web page, it looks like this:</p>
<p>
<img src="abcsmfc_1.gif" border=0></p>
<p>
I've used JavaScript™ to hook up the buttons and label control to the StopLite control; I could as easily have used Visual Basic® Scripting Edition (VBScript). </p>
<p>
If you're using Internet Explorer 3.0 or another ActiveX-activated browser, you can click the buttons to change the light. The Next Light button invokes the Next method, which changes the light to the next color (in the sequence red, green, yellow, red . . .). The color buttons change the light to the specified color, while the Off and Test buttons turn the lights all off and all on, respectively.</p>
<p>
The StopLite control also fires events as it changes. These events change the label just underneath the button from "Welcome to PaulJo's StopLite page!" to other appropriate messages.</p>
<p>
One great feature of ActiveX controls is that they can be used in containers other than Web pages. Here's a Visual Basic app that uses the StopLite control:</p>
<p>
<img src="abcsmfc_2.gif" border=0></p>
<p>
In both the Visual Basic and the HTML uses of this control, the buttons, control, and label are hooked together using Visual Basic code.</p>
<h3>How Is this Article Organized?</h3>
<p>
We're going to show you how to write this control. But first, I want to give a you a little bit of background about the architecture of MFC controls. Then we'll look at the code that AppWizard generates. Finally, we'll modify that skeleton to create the complete <b>StopLite</b> control.</p>
<h2>What Does an MFC Control Look Like?</h2>
<h3>MFC Classes for a Control</h3>
<p>
MFC controls are considerably simpler than MFC applications. The simplest MFC control has only three classes: a control module class derived from <b>COleControlModule</b> (which in turn is derived from <b>CWinApp</b>), a control window class derived from <b>COleControl</b> (which in turn is derived from <b>CWnd</b>), and a property page class derived from <b>COlePropertyPage</b> (which in turn is derived from <b>CDialog</b>). Assuming that the name of the control is <b>StopLite</b>, the name of the control module class is <b>CStopLiteApp,</b> the name of the control class is <b>CStopLiteCtrl,</b> and the name of the property page class is <b>CStopLitePropPage.</b></p>
<p>
<b>CStopLiteApp</b> is very similar to the <b>CWinApp</b>-derived class that's at the core of your MFC applications. Only one object of this class will be in your control module, no matter how many controls might be in this module.</p>
<p>
<b>CStopLiteCtrl</b> is the class in which you'll do 99.44 percent of your work. It has functions that implement all of the properties and methods, and fire all the events. It also is responsible for drawing the control and responding to Windows messages.</p>
<p>
If your control module (.OCX) contains more than one control, you'll have an additional class for each control. Each class will be named <b>CXxxxCtrl</b>, where <i>Xxxx</i> is the name of the control encapsulated by that class.</p>
<p>
<b>CStopLitePropPage</b> is very similar to a dialog box class. It's used to implement the code needed to connect the dialog box template you'll write for your property page to the properties in your control. </p>
<h2>Creating the Control with AppWizard</h2>
<h3>Which Version of MFC Should I Use?</h3>
<p>
Because ActiveX controls written using MFC require the appropriate MFC DLLs to be present and registered on the user's system, you have to ensure sure that every user has the correct DLLs properly installed.</p>
<p>
In general, you need to provide a setup script that sets up your control and all the DLLs it needs. This setup script should not overwrite DLLs that are of a later version than the ones it installs. It also might need to register some or all of the DLLs it installs. We'll have articles about installation, code signing issues, and marking controls as safe for scripting and initializing soon. For now, check your development environment's documentation for installation requirements and the Site Builder Workshop for information on installations, code signing, and marking controls as safe.</p>
<p>
To reduce the amount of code that needs to be downloaded before your control can be used, you may want develop your control so that it takes advantage of DLLs already present on your users' systems. For instance, Internet Explorer 3.0 installation always installs the version 4.1 MFC DLLs, as does Windows NT 4.0.</p>
<p>
If you don't need any of the new features in later versions of MFC, stick with MFC (and Visual C++) version 4.1 so that most of your users won't have to download those big DLLs. But not all users will have the DLLs, so you'll also have to come up with an optional scheme for users to get them.</p>
<p>
Because the <b>StopLite</b> control doesn't use any version 4.2 features, I stuck with Visual C++ version 4.1 to make life simpler. I had to reinstall Visual C++ version 4.1, but that was better than requiring everyone to download the version 4.2 DLLs. (There are directions included with Visual C++ 4.2 that tell how to install both version 4.1 and version 4.2 on the same system.) If you need 4.2 features, don't despair: you can link a compressed self-installing version of the DLLs you need by following directions at <a href="http://www.microsoft.com/visualc/prodinfo/archives/download/mfc42cab.htm">http://www.microsoft.com/visualc/prodinfo/archives/download/mfc42cab.htm.</a> This file will take your users less than four minutes to download (at 28.8Kbps), so it may be worth using 4.2 in many situations.</p>
<h2>Creating the Skeleton</h2>
<p>
The first step in creating any MFC project, including a control project, is to use Visual C++'s AppWizard to create the skeleton code. I've used Visual C++ 4.1 for this control, but the directions should work with any version 4.0 or later. I've tested these directions with versions 4.1 and 4.2.</p>
<p>
To get started, select "New" on the File menu, then select "Project Workspace." This will allow you to select a type of project. Select "OLE ControlWizard" to create an ActiveX control. Fill in the name of the project and the directory in which you want the control placed. (In case you're following along, I've called this project "StopLite"—note the capitalization and spelling.) Keep the filename eight characters or less. Although Visual C++ generally deals with long filenames correctly, some other tools have trouble with them, especially if the names contain spaces.</p>
<p>
Clicking "Create" will start the OLE ControlWizard. While it looks as though you have two pages of options, there are really three—you access the third page by clicking the "Advanced" button on the second page. We're going to use all the default options, so don't change anything. Just take a look at the options and click "Finish" when you're done. (We'll get into some of these other options, and more, in later articles.)</p>
<p>
After you click "OK" on the summary page, the OLE ControlWizard will generate your new project. For more information on the OLE ControlWizard, look up "OLE ControlWizard" in Visual C++'s Books Online.</p>
<p>
This project is ready to go. You can build it now by selecting "Build StopLite.OCX" from the Build menu or by pressing the F7 key. If you need more assistance with AppWizard, consult Visual C++'s Books Online.</p>
<h2>Running the Skeleton</h2>
<p>
Once you've built the control, it's easy to test it in the OLE Control Test Container that comes with Visual C++. Select "OLE Control Test Container" from the Tools menu, pick "Insert OLE Control" from the Edit menu (or click the Insert button), and select your control ("StopLite") in the list box. Because we haven't modified the drawing code, we get the ControlWizard-provided code, which draws an ellipse that fills the control area. You can see that the control automatically scales the ellipse by resizing the control.</p>
<p>
The control container also allows us to view and change the control's properties (View.Properties—we don't yet have any, but we will . . .), call its methods (Edit.Invoke Methods—ControlWizard wrote an AboutBox method for us. Try it!), and view a log of events fired (View.Event Log—we don't fire any events yet). You can also invoke the control's (blank) property page (Edit.Properties).</p>
<p>
Finally, you can view and change the container's ambient properties (Edit.Set Ambient Properties). However, we don't yet have the code in place to access those ambient properties, so changing them will have no effect on the control. </p>
<p>
There are toolbar buttons for all of these functions.</p>
<p>
For more advanced testing, the control container has a wide variety of options you can use to exercise the control.</p>
<h2>A Tour of the Code</h2>
<p>
Now that we've played with the control a little bit, let's examine the code that the OLE ControlWizard generated for us. To get a copy of the code, you can either run Visual C++'s OLE ControlWizard yourself as described above or click to download the original source. Or, view the code online by shift-clicking to display the index in a new browser window.</p>
<h3>Differences Between Control Wizard 4.1 and 4.2 Code</h3>
<p>
There are two significant differences between code generated by Control Wizard 4.1 and 4.2. Either of these differences will keep your project from building if you're moving 4.2 code back to 4.1. </p>
<p>
The first difference is that 4.2 adds the line</p>
<pre><code>#include &lt;idispids.h&gt;
</code></pre>
<p>
near the beginning of your .ODL file. IDISPIDS.H is only available with Visual C++ version 4.2, so comment this line out if you're moving the code back to 4.1. </p>
<p>
The second difference is in the call to AfxOleUnregisterTypeLib. This difference is described below in the section that talks about CStopLiteApp. </p>
<h3>Files (and Classes)</h3>
<p>
ControlWizard has generated a bunch of files for us—a .RC file, an .ODL file, a .DEF file, and four pairs of .CPP and .H files—the usual STDAFX.H/STDAFX.CPP, plus a pair for each of the classes ControlWizard creates.</p>
<p>
The .RC and .DEF (StopLite.DEF) files are the standard resource and linker definition files. The .ODL (StopLite.ODL) file contains type information for OLE. You can look at this file, but you needn't edit it. ClassWizard will automatically modify it as you add properties, methods, and events.</p>
<p>
The STDAFX.CPP and STDAFX.H files are the usual files Visual C++ generates to enable creation and maintenance of the precompiled header (*.PCH) file. STDAFX.H includes MFC (and, indirectly, Windows) headers; STDAFX.CPP, which contains an #include of STDAFX.H, exists only so the precompiled type information will go to STDAFX.OBJ.</p>
<p>
The control itself consists of three classes: a control module (or application) class called <b>CStopLiteApp, </b>a property page class called <b>CStopLitePropPage, </b>and the main control window class called <b>CStopLiteCtrl.</b> Before continuing, you can print out at least the three major .CPP files so you can look at the code while you read.</p>
<p>
<b>CStopLiteApp</b> (StopLite.H/StopLite.CPP)</p>
<p>
This class is analogous to the <b>CWinApp</b>-derived class that's at the heart of regular MFC applications—it's even derived, via <b>COleControlModule,</b> from <b>CWinApp.</b> There will be only one <b>COleControlModule</b> object in your .OCX, even if your .OCX supports multiple controls. You rarely need to modify this class, and for this example, you won't need to modify it at all. (You might need to modify it if you have multiple controls in the same module that need to communicate with each other.)</p>
<p>
In addition to the <b>InitInstance</b> and <b>ExitInstance</b> member functions for module initialization and cleanup, these files also contain the <b>DllRegisterServer</b> and <b>DllUnregisterServer</b> global functions you need to have in a "self-registering" control and some read-only global variables: two WORDs, which contain the control's major and minor version numbers, and the GUID for the control's type library.</p>
<p>
This file contains the only significant difference between the code generated with Visual C++ version 4.1 and version 4.2. In version 4.1, the <b>DllUnregisterServer</b> function contains the call:</p>
<pre><code>if (!AfxOleUnregisterTypeLib(_tlid))
</code></pre>
<p>
In version 4.2, the function adds the version number to the call, as is supported by an update to the <b>AfxOleUnregisterTypeLib</b> function:</p>
<pre><code>&nbsp;if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
</code></pre>
<p>
If you've generated your project with version 4.2, you'll have to change the line above to the version 4.1 call in order to compile under 4.1.</p>
<h3>CStopLitePropPage (StopLitePpg.H/StopLitePpg.CPP)</h3>
<p>
This class is the code for the property page that we'll use to view and set the control's properties. It's actually the code for an individual property page, not for the property page tabbed container, which is called a property sheet.</p>
<p>
<b>CStopLitePropPage</b> is derived from <b>COlePropertyPage,</b> which is derived from <b>CDialog.</b> Therefore, <b>CStopLitePropPage</b> behaves much like a standard MFC dialog box. It has the usual message map and <b>DoDataExchange</b> function that all MFC dialog boxes use. (Some new data exchange functions for exchanging data with the control's properties that begin with DDP_ are used in addition to the DDX_ functions in regular modal dialog boxes.)</p>
<p>
The control's property page has a few additional pieces that a regular dialog box doesn't have. First, it's declared for dynamic and OLE creation via the IMPLEMENT_DYNCREATE and IMPLEMENT_OLECREATE_EX macros (and their corresponding DECLARE_ variants in the header file). Note that the IMPLEMENT_OLECREATE_EX macro also takes and uses a GUID for the ID of the property page.</p>
<p>
Lastly, the property page has a function called <b>CStopLitePropPage::CStopLitePropPageFactory::UpdateRegistry, </b>which registers and unregisters the property page with OLE. This function will be called by MFC when the control is being initialized and destroyed. As the syntax indicates, this function is a member of a class nested inside of <b>CStopLitePropPage.</b></p>
<h3>CStopLiteCtrl (StopLiteCtl.H/StopLiteCtl.CPP)</h3>
<p>
This class is the most important class in your control. It's where all the action takes place. Except for the property page code, all the code that ClassWizard adds and you edit will go into this class. Note that if this .OCX implemented more than one control, there would be more than one control class. Since this file is large, let's describe the parts of it as they appear in <b>StopLiteCtl.CPP.</b></p>
<p>
First, <b>CStopLiteCtrl</b> has a message map—after all, it's derived from <b>CWnd, </b>which is a command target. In addition, it has a couple of other maps. The dispatch map contains entries for all the properties and methods you implement, while the event map contains entries for all the events you fire. ClassWizard will maintain all of these maps for you.</p>
<p>
Next, we have a data structure that contains information on our property page(s), followed by some macros to implement OLE creation and our type library. After this are GUIDs for the two dispatch interfaces used by this control: <b>IID_DStopLite </b>for its properties and methods, and <b>IID_DStopLiteEvents</b> for the events that will be fired to the container.</p>
<p>
After that is a rather important variable: <i>_dwStopLiteOleMisc.</i> This variable, which is passed to <b>AfxOLERegisterControlClass</b> later on, contains flags that tell OLE how to create this control and what kind of control it is. See the documentation on the OLEMISC enumeration for information about what these flags mean.</p>
<p>
You will need to change<b> CStopLiteCtrl::CStopLiteCtrlFactory::UpdateRegistry,</b> the next function, if you want to mark your control as safe for scripting and/or initialization. (You could also modify <b>DllRegisterServer,</b> but it's a little more convenient to change <b>UpdateRegistry</b> because the control's class ID is readily available.) To mark the control as safe for scripting and initialization, call helper functions that register a component category and register the control as belonging to a category. Because all the of the control's registry entries are deleted when the control is unregistered, you don't have to do anything special to unregister the control. (You should not unregister the categories—other components installed later might need them!) I also added the above-mentioned helper functions (in HELPERS. CPP and HELPERS.H), copied directly from the ActiveX SDK.</p>
<p>
So <b>UpdateRegistry </b>just registers and unregisters the control's OLE class. Be sure to read and heed the warning about writing your code correctly so it can run as a multi-threaded apartment model object. All of the details are in MFC Technote 64; for now, just avoid any non-constant global or static member variables. (We won't be using any—they're not really necessary.) It's very important for controls used in Internet applications to be compatible with the apartment threading model—otherwise, performance will suffer greatly if your Web page has more than one control from your control module.</p>
<p>
Next is a nearly-empty constructor and an empty destructor that you can add to if needed. You do not need to initialize members that correspond to persistent properties; these will be initialized from persistent data (or default values, if the persistent data is not present) when the control is started.</p>
<p>
<b>CStopLiteCtrl</b> is derived from <b>COleControl,</b> which in turn is derived from <b>CWnd.</b> Therefore, it can do basically anything that any window can—draw itself, respond to messages, and so on. However, rather than drawing in an <b>OnPaint</b> function, OLE controls draw in a function called <b>OnDraw.</b> We'll change <b>OnDraw</b> soon to make it draw a stoplight rather than an ellipse. <b>OnDraw</b> differs from <b>CView::OnDraw </b>and from <b>CWnd::OnPaint </b>in two ways. First, you are passed a rectangle representing the extent of the control. You must not draw outside this rectangle. Second, you must erase the control's background in <b>OnDraw</b> rather than relying on a different function to do it for you.</p>
<p>
Another function that will look strange yet familiar is <b>DoPropExchange, </b>which is used when saving the control's properties to the container or loading them from the container. The best analogy to an MFC application is that <b>DoPropExchange</b> acts like the document class's <b>Serialize</b> function; however, <b>DoPropExchange</b> is structured more like a dialog box's <b>DoDataExchange </b>(although the exchange functions start with "PX_" rather than "DDX_").</p>
<p>
Next to last is <b>OnResetState,</b> which is called when the control should reset its state to the default initial state. Since the default implementation sets property values to the values specified in your <b>DoDataExchange</b> function, you often won't need to change this code.</p>
<p>
Last, and perhaps least, is <b>OnAbout,</b> which displays your control's About box.</p>
<h2>Specification of the StopLite Control</h2>
<p>
Next, we'll go through the modifications we made to write this control. Basically, the control will work as follows:</p>
<h3>Properties</h3>
<p>
<b>StopLite</b> implements only one property, Color. Its possible values and their meanings are:</p>
<p>
<b>StopLite</b> also uses the BackColor and ForeColor stock properties and the BackColor ambient (container) property (this is the container's background color).</p>
<h3>Methods</h3>
<p>
<b>StopLite</b> has three methods: AboutBox, which displays the About box; Next, which changes the light to the next state (red, green, yellow, red . . .); and the stock Refresh method.</p>
<h3>Events</h3>
<p>
<b>StopLite</b> fires a bunch of events when the light changes state: Off, Testing, Stop, Go, and Caution. It also fires the stock Click event when either mouse button is clicked.</p>
<h3>Drawing</h3>
<p>
<b>StopLite</b> will draw itself as a vertical row of three lights. Each light will be either on or off; except in test mode, at most one light will be on at a time. The lights will be circular regardless of the width of the control, but the size of the lights will be as large as possible given the height of the control. A bezel will be drawn around the lights.</p>
<h3>Windows Messages</h3>
<p>
<b>StopLite</b> responds to left-button clicks (WM_LBUTTONDOWN) by calling the Next method. This gives you a way to call the Next method even when the control is embedded in a container, such as WORD, that doesn't support calling methods.</p>
<h3>Marked as Safe, Signed</h3>
<p>
<b>StopLite</b> is signed to allow users to install the control, even if their browser security is set to high. It also assures them that the control was actually signed by the entity described in the signing certificate and that the control has not been modified since it was signed.</p>
<p>
<b>StopLite</b> is also marked as safe for scripting and safe for initializing, since there are no scripting commands nor data values that could cause it to damage a user's system. This allows pages that display <b>StopLite</b> controls to come up immediately without warning dialog boxes (if security is set to medium) or failures (if security is set to high).</p>
<h2>How I Wrote StopLite</h2>
<p>
I actually wrote the control in a different order than I'm presenting below. First, I modified <b>OnDraw</b> so that the control drew something besides an ellipse! Next, I implemented the first property, Color. That necessitated modifying the drawing code to draw the lights in the correct color. Once I had that working, I implemented the Next method and the <b>OnLButtonDown</b> mouse handler so I could see the light change without fiddling with a property page in the test container. (Most satisfying!)</p>
<p>
At that point, I created my first Web page for the control using the ActiveX Control Pad, which makes adding controls and your choice of VBScript or JavaScript to Web pages a snap!</p>
<p>
Then I added the remainder of the properties, events, and methods.</p>
<p>
Finally, I got tired of all of the annoying warning dialogs every time I went to a Web page that contained my control, so I signed <b>StopLite</b> and marked it as safe for scripting and safe for initializing. I learned how to do this using the ActiveX SDK documentation.</p>
<p>
But that's a difficult sequence in which to explain the control's code—especially since you don't really want me to blather on about rewriting the <b>OnDraw</b> function fifteen times. So I've captured what I've learned and organized it in a more readable fashion.</p>
<p>
Of all of the files in the project, only the StopLite.DEF file didn't change.</p>
<h2>Properties</h2>
<p>
Think of properties as exposing the variables inside a control. In the <b>StopLite</b> control, we have three properties: the BackColor and ForeColor stock properties, and a custom property called Color, which represents the state of the stoplight (off, red, green, yellow, testing). In addition, <b>StopLite</b> uses the container's background color as an "ambient property."</p>
<p>
Although properties act as if you're exposing a variable, that's just the programming model. Getting and setting a property can do any operations you choose. So one important way for a container to manipulate its controls is by initializing and changing its properties.</p>
<p>
When you insert a control into a container in design mode, you have a chance to set its initial properties. The control passes any changes back to the container, which is responsible for saving the properties the control asks it to. (The control reads and writes its properties in <b>DoPropExchange.</b>) In this way, the state of the control is persistent, and we say that the control "implements persistence." It's the container design program's responsibility to save these properties when it saves the container's representation.</p>
<p>
When the container is run and creates the control, it must provide the control with these initial property values.</p>
<p>
In Visual Basic, the properties are saved as part of the form's .FRM file. In HTML pages, the properties are saved as &lt;PARAM&gt; tags inside the &lt;OBJECT&gt; tag that specifies how to create the control.</p>
<p>
There are several categories and sub-categories of properties. They can either belong to (be implemented by) the control or belong to the container. Control properties are further broken down into custom properties (implemented by you) and stock properties (implemented by MFC). Container properties are called ambient properties; they are further categorized as standard ambient properties, whose meanings are defined by OLE, and extended properties, which are defined by a specific container. Extended properties are more properly thought of as properties of the extended control, which is a control inside the container that encapsulates and extends your control.</p>
<p>
Of the four, custom control properties are most commonly used, so we'll discuss them first.</p>
<h3>Control Properties</h3>
<p>
There are two types of control properties: Custom properties are implemented in code you write, while stock properties are implemented by MFC and accessed with <b>COleControl</b> member functions.</p>
<h4>Custom properties</h4>
<p>
Custom properties are implemented by the code in your control. You will typically have a variable in your control class to hold these properties, although you can implement them via Get/Set methods to work in any way you choose.</p>
<p>
ClassWizard offers two choices when implementing a custom property: as a pair of Get/Set methods, or as a member variable. In general, using a pair of Get/Set methods is more flexible because you can validate changes to the property and because you can represent the data in any way you choose. Also, if you want your property to be either read-only or write-only, it must be implemented with Get/Set methods.</p>
<p>
You can specify that one, and at most one, property in your control is the "default" property. In <b>StopLite, </b>Color is the default property. This means that in your container, you can write:</p>
<pre><code>&nbsp;&nbsp;&nbsp;StopLite1 = 2;
</code></pre>
<p>
rather than:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;StopLite1.Color = 2;
</code></pre>
<p>
It's a minor convenience, but a nice one—most useful when the control is strongly associated with a single value, such as an edit control. The OLE Automation tab in ClassWizard has a checkbox for this. Select the property you want to make the default and check Default Property.</p>
<p>
Note that the default property shows up in the container's property list as <b>_Color.</b> You should not use this property—use Color instead. This extra property is an artifact of the way MFC implements default properties. </p>
<p>
<b>Implemented as Get/Set methods</b></p>
<p>
In general, this is the method I recommend for implementing properties, because it's more flexible. It allows you to store the property in any way you choose, and it allows you to prevent the properties from changing to values you don't allow. It also allows read-only and write-only properties.</p>
<p>
Custom properties implemented using Get/Set methods can be both read and written. When you're using ClassWizard to create the property, it's easy to make it read-only or write-only—just delete the name of the Get method to make it write-only, or delete the name of the Set method to make it read-only. (But don't delete both, okay?)</p>
<p>
The Color property in <b>StopLite</b> is implemented as a pair of Get/Set methods. Use the Add Property button on ClassWizard's OLE Automation tab and type "Color" in the External Name drop-down box. Select short as the type, then click on Get/Set methods. Check the function names, then click OK. To make Color the default property, select it while on the OLE Automation tab and click the Default Property checkbox. If you need more assistance with ClassWizard, consult Visual C++'s Books Online.</p>
<p>
When you've done all this, ClassWizard will modify your dispatch map to include:</p>
<pre><code>&nbsp;&nbsp;&nbsp;DISP_PROPERTY_EX(CStopLiteCtrl, "Color", GetColor, SetColor, VT_I2)
 &nbsp; DISP_DEFVALUE(CStopLiteCtrl, "Color")
</code></pre>
<p>
It will also modify your .ODL file (typelib source) to include the following:</p>
<pre><code>&nbsp;&nbsp;&nbsp;[id(1)] short Color;
 &nbsp; [id(0)] short _Color;
</code></pre>
<p>
The fact that the second of the declarations has an ID of 0 is what makes <b>Color</b> the default property. (MFC takes care of the difference between <b>Color</b> and <b>_Color.</b>)</p>
<p>
ClassWizard also generates skeletons for the <b>GetColor</b> and <b>SetColor</b> methods. I added a member variable <i>m_color </i>(using a right-click on <b>CStopLiteCtrl</b> in ClassView—yea!) and added code to the functions as follows:</p>
<pre><code>short CStopLiteCtrl::GetColor() 
{
 &nbsp; return m_color;
}
void CStopLiteCtrl::SetColor(short nNewValue)
// set color, redraw; throw error if parameter bad
{
 &nbsp; if (nNewValue &gt;= SL_NONE &amp;&amp; nNewValue &lt;= SL_TEST)
 &nbsp;&nbsp;&nbsp;&nbsp; m_color = nNewValue;
 &nbsp; InvalidateControl();
 &nbsp; FireRightEvent();
 &nbsp; SetModifiedFlag();
 &nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp; ThrowError(CTL_E_ILLEGALFUNCTIONCALL, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Color parameter out of range");
 &nbsp; }
}
</code></pre>
<p>
<b>GetColor</b> is simple, but <b>SetColor </b>requires a little explanation. First, we check to see if the value being used is valid. If it is, we set <b>m_color,</b> then update the control. (<b>InvalidateControl</b> redraws, <b>FireRightEvent</b> fires the appropriate event, and <b>SetModifiedFlag</b> lets MFC know that a property has changed.)</p>
<p>
If the value passed is not valid, we throw an error using the <b>ThrowError</b> member function. This function is only used in methods, including Get/Set methods. In other situations, use <b>FireError</b> to fire the stock Error method. (Note that <b>SetColor</b> will not be called when the control is initialized—only when the Color member is changed.) </p>
<p>
<b>Implemented as a member variable</b></p>
<p>
You can also ask ClassWizard to implement a property as a member variable, without Get/Set functions. (Actually, there are Get/Set functions, but they're implemented by MFC so you don't have to write them.)</p>
<p>
Although this is simpler, it has three disadvantages:
<ul type=disc>
<li>
You cannot validate the value being set.<br><br></li>
<li>
Your member variable must be of the exact same type as the property.<br><br></li>
<li>
You cannot make the property read-only or write-only.</li>
</ul>
<p>
If the disadvantages above aren't a problem in your situation, you can implement a property as a member variable. For instance, if the type of a read/write property is <b>BOOL, </b>it makes sense to implement that property as a member variable.</p>
<p>
By default, ClassWizard creates a change notification function, which will be called when the property changes. If we had implemented <b>Color</b> as a member variable, we would have called <b>InvalidateControl, FireRightEvent, </b>and <b>SetModifiedFlag</b> from this function.</p>
<p>
Implementing a property as a member variable is very similar to implementing it as Get/Set methods, except that you click on Member variable in the last step of the procedure above. If you don't want a notification function, clear the name in ClassWizard before you click OK. </p>
<h4>Making custom properties persistent</h4>
<p>
ClassWizard will automatically add the necessary code to <b>DoPropExchange</b> to save your properties at design time so they can be reloaded at run time.</p>
<p>
In <b>StopLite,</b> ClassWizard and I added the following code:</p>
<pre><code>&nbsp;&nbsp;&nbsp;PX_Short(pPX, "Color", m_color, SL_TEST); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // default to test state (all on)
</code></pre>
<p>
The last parameter to<b> PX_Short </b>is the property's default value, which I added, specifying it as <b>SL_TEST.</b></p>
<p>
We also need to validate the initialization data to ensure that we're safe for initializing. Just after the line above, I added:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// check for load of bad value, fix
 &nbsp; if (pPX-&gt;IsLoading()) {
 &nbsp;&nbsp;&nbsp;&nbsp; if (m_color &lt; SL_NONE || m_color &gt; SL_TEST)&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_color = SL_TEST;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
</code></pre>
<p>
It is possible for a container to pass a bad value into the control, so it's important to check it both here and in set functions. </p>
<h3>Stock Properties</h3>
<p>
In addition to custom control properties that you implement, a set of stock properties is implemented by MFC. To use them, just add them to your control with ClassWizard—the code is already there to implement the properties. (MFC automatically provides persistence for stock properties.) Check out the list of stock properties by looking up Stock Methods/Properties in the class member list for <b>COleControl.</b></p>
<p>
To access the stock properties from your control, use predefined functions defined as members of <b>COleControl.</b> Most of the functions have names of the form <b>GetXxxx</b> and <b>SetXxxx, </b>where <i>Xxxx</i> is the name of the stock property. There are also a set of stock property notification change functions with names of the form <b>OnXxxxChanged.</b> These have reasonable default implementations, but you can override them if necessary.</p>
<p>
<b>StopLite</b> uses two stock properties: <b>BackColor</b> and <b>ForeColor.</b> An important thing to remember about stock color properties is that they are stored as an<b> OLE_COLOR,</b> not as a <b>COLORREF.</b> Windows usually uses C<b>OLORREF</b>s, so you'll need to call <b>TranslateColor</b> to translate from an <b>OLE_COLOR</b> to a <b>COLORREF.</b> (There doesn't appear to be a function to perform the inverse translation.)</p>
<p>
To add these stock properties, use the Add Property button on ClassWizard's OLE Automation tab and select <b>BackColor</b> (<b>ForeColor</b> the second time . . .) in the External Name drop-down box.</p>
<p>
When you're done, ClassWizard will modify your dispatch map to include:</p>
<pre><code>&nbsp;&nbsp;&nbsp;DISP_STOCKPROP_BACKCOLOR()
 &nbsp; DISP_STOCKPROP_FORECOLOR()
</code></pre>
<p>
It will also modify your .ODL file (typelib source) to include the following:</p>
<pre><code>&nbsp;&nbsp;&nbsp;[id(DISPID_BACKCOLOR), bindable, requestedit] OLE_COLOR BackColor;
 &nbsp; [id(DISPID_FORECOLOR), bindable, requestedit] OLE_COLOR ForeColor;
</code></pre>
<p>
That's all we need to do. We can now call <b>GetBackColor</b> and <b>GetForeColor</b> to get the colors to paint our control. As mentioned above, these stock properties are automatically persistent. </p>
<h3>Ambient (Container) Properties</h3>
<p>
Ambient properties are properties of the control's container, not the control. They are therefore implemented by the container, not by the control. All ambient properties are read-only. You do not need to do anything to access these properties except call the appropriate functions.</p>
<h4>Standard ambient properties</h4>
<p>
There is a group of ambient properties for which dispatch IDs are predefined by OLE. You can access most of these properties by calling member functions of <b>COleControl.</b> To access the few properties for which there is no function, you can call <b>GetAmbientProperty.</b></p>
<p>
<b>StopLite</b> uses the ambient <b>BackColor</b> property to paint the area outside of the control's bezel so it will blend into the container's background. The code to do this is in <b>OnDraw, </b>and it's very simple:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CBrush brAmbientBack(TranslateColor(AmbientBackColor()));
 &nbsp; pdc-&gt;FillRect(rcBounds, &amp;brAmbientBack);
</code></pre>
<p>
The call to <b>AmbientBackColor</b> reads the ambient background color. Since this is another <b>OLE_COLOR,</b> it needs to be translated before we can create the brush for painting the background.</p>
<p>
Some of the commonly used ambient properties include background and foreground colors, font, locale ID, and various properties associated with activation. Adam Denning's <i>OLE Controls Inside Out</i> (Microsoft Press, 1995) has a wonderful discussion of ambient properties.</p>
<h4>Extended ambient properties</h4>
<p>
Control containers are also free to implement any ambient properties they like. If you know the property's dispatch ID and type, you can access it by calling <b>GetAmbientProperty.</b></p>
<h4>Ambient property change notifications</h4>
<p>
When ambient properties change, the control will be notified. If you want to know about changes, override <b>COleControl::OnAmbientPropertyChange.</b> I did this in <b>StopLite</b> so that I could repaint if the background color changed. I used ClassWizard to write the code by adding a handler for <b>OnAmbientPropertyChange.</b> (This is on the Message Map tab.) The code I wrote to handle the notification checks to see which notification I've received and forces the control to repaint if the ambient background has changed. Note that even if more than one ambient property changes at a time, only one call to <b>OnAmbientPropertyChange</b> will be made. That call will pass <b>DISPID_UNKNOWN </b>as the <b>DISPID. </b>I check for that situation and force a repaint just to be safe.</p>
<pre><code>void CStopLiteCtrl::OnAmbientPropertyChange(DISPID dispid) 
{
 &nbsp; // Repaint if ambient background changed or if several changed
 &nbsp; if (dispid == DISPID_AMBIENT_BACKCOLOR ||
 &nbsp;&nbsp;&nbsp;&nbsp; dispid == DISPID_UNKNOWN)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; InvalidateControl();
 &nbsp; }
 &nbsp; // pass on to base class
 &nbsp; COleControl::OnAmbientPropertyChange(dispid);
}
</code></pre>
<h2>Methods</h2>
<p>
Methods are function calls into the control—how the container tells the control to do something. The <b>StopLite</b> control supports two methods: Next and AboutBox. </p>
<h3>Stock Methods</h3>
<p>
MFC provides implementation for a couple of stock methods, which you can easily add to your project using ClassWizard. You don't even have to write any code. The <b>StopLite</b> control implements the Refresh stock method, which forces the control to redraw itself.</p>
<p>
To add the stock Refresh method to your control, use the Add Method button on ClassWizard's OLE Automation tab and select Refresh in the External Name drop-down box. ClassWizard will modify your dispatch map to include:</p>
<pre><code>DISP_STOCKFUNC_REFRESH( )
It will also modify your .ODL file (typelib source) to include:
 &nbsp; [id(DISPID_REFRESH)] void Refresh();
</code></pre>
<p>
If you execute this method in most containers, you won't see any change in the control; it will simply repaint itself as it was. However, this method can be handy if the container knows it's drawn on top of the control and wants the control to redraw itself.</p>
<p>
In addition to Refresh, MFC supplies the <b>DoClick</b> stock method, which forces the control to act as if it were clicked.</p>
<h3>Custom Methods</h3>
<p>
Most of the methods your control uses will be custom methods. Stock methods are implemented by MFC; custom methods are implemented by you. In addition to <b>AboutBox,</b> which was written by ControlWizard, the <b>StopLite</b> control implements only one custom method, <b>Next</b>. <b>Next</b> causes the stoplight to change to the next state in its cycle (red, green, yellow, red . . .).</p>
<p>
To add the <b>Next</b> method to your control, use the Add Method button on ClassWizard's OLE Automation tab and type <b>Next</b> in the External Name drop-down. ClassWizard will modify your dispatch map to include:</p>
<pre><code>&nbsp;&nbsp;&nbsp;DISP_FUNCTION(CStopLiteCtrl, "Next", Next, VT_EMPTY, VTS_NONE)
</code></pre>
<p>
<b>VT_EMPTY</b> means that the return type of the Next method is void, and <b>VTS_NONE</b> means that the Next method takes no parameters. If the method had a return value, its return type constant (<b>VT_xxx</b>) would replace <b>VT_EMPTY.</b> If it took parameters, the types of the parameters would be represented by a comma-separated list of parameter type constants (<b>VTS_xxx</b>) instead of <b>VTS_NONE.</b> The list of constants is in the MFC documentation for <b>DISP_FUNCTION.</b></p>
<p>
ClassWizard will also modify your .ODL file (typelib source) to include:</p>
<pre><code>&nbsp;&nbsp;&nbsp;[id(2)] void Next();
</code></pre>
<p>
Next, we'll write the code for the method. If the stoplight is currently off, testing, at the end of the cycle, or in some other state, we'll set it to the first state in the cycle, which happens to be red. If it's already in the cycle, we'll set its state to the next in the cycle. Since we've changed the internal state of the stoplight, we must also redraw it by calling <b>InvalidateControl, </b>fire the appropriate event by calling <b>FireRightEvent,</b> and let MFC know that the state has changed by calling <b>SetModifiedFlag.</b></p>
<p>
Here's the code for <b>Next</b>:</p>
<pre><code>void CStopLiteCtrl::Next() 
// changes stoplight to next state, redraws
{
 &nbsp; if (m_color &gt;= SL_LAST || m_color &lt; SL_FIRST)&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; m_color = SL_FIRST;
 &nbsp; }
 &nbsp; else m_color++;
 &nbsp; InvalidateControl();
 &nbsp; FireRightEvent();
 &nbsp; SetModifiedFlag();
}
</code></pre>
<h2>Events</h2>
<p>
Events are the notifications your control sends to its container when something of interest has happened. The control does this by "firing" an event, which the container can handle with its own code. </p>
<h3>Stock Events</h3>
<p>
MFC provides about a dozen stock events, mainly having to do with mouse clicks and key presses. Two events worth noting are the <b>Error</b> event, which we'll discuss in a bit, and the <b>ReadyStateChanged</b> event, which your control can fire to notify the container that its ready state has changed (for instance, from Loading to Interactive to Complete). This can be useful if your control needs to download a lot of data before it's ready to use.</p>
<p>
<b>StopLite</b> implements one stock event, <b>Click</b>. To add this event, click the Add Event button on ClassWizard's OLE Events tab and select <b>Click</b> in the External Name drop-down box.</p>
<p>
When you're done, ClassWizard will modify your event map to include:</p>
<pre><code>&nbsp;&nbsp;&nbsp;EVENT_STOCK_CLICK()
</code></pre>
<p>
It will also modify your .ODL file (typelib source) to include:</p>
<pre><code>&nbsp;&nbsp;&nbsp;[id(DISPID_CLICK)] void Click();
</code></pre>
<p>
No code is added or necessary since MFC implements the <b>FireClick</b> function.</p>
<h3>Custom Events</h3>
<p>
Many of the events your control fires will be custom events. Custom events can pass parameters to provide more information about the situation that caused the event to be fired, although the <b>StopLite</b> control doesn't take advantage of that.</p>
<p>
Rather, the <b>StopLite</b> control implements a separate event for each of its states:<b> Stop, Caution, Go, Testing, </b>and <b>Off.</b> Note that the events are not named for the color of the light, but rather for what I expect that the container might do with the event. For instance, the container could call the <b>Stop</b> method on all the cars on the road when it receives the <b>Stop</b> event from the <b>StopLite</b> control.</p>
<p>
To add these events to your control, use the Add Event button on ClassWizard's OLE Events tab and type the name of each event in the External Name drop-down box. For these events, you won't need any parameters.</p>
<p>
When you're done, ClassWizard will modify your event map to include:</p>
<pre><code>&nbsp;&nbsp;&nbsp;EVENT_CUSTOM("Stop", FireStop, VTS_NONE)
 &nbsp; EVENT_CUSTOM("Caution", FireCaution, VTS_NONE)
 &nbsp; EVENT_CUSTOM("Go", FireGo, VTS_NONE)
 &nbsp; EVENT_CUSTOM("Testing", FireTesting, VTS_NONE)
 &nbsp; EVENT_CUSTOM("Off", FireOff, VTS_NONE)
</code></pre>
<p>
<b>VTS_NONE</b> in the macro invocations above means that the events have no parameters. If the events had parameters, constants describing their types would be listed in order starting after the function name. The list of constants is in the MFC documentation for <b>EVENT_CUSTOM</b>.</p>
<p>
It will also modify your .ODL file (typelib source) to include:</p>
<pre><code>&nbsp;&nbsp;&nbsp;[id(1)] void Stop();
 &nbsp; [id(2)] void Caution();
 &nbsp; [id(3)] void Go();
 &nbsp; [id(4)] void Testing();
 &nbsp; [id(5)] void Off();
</code></pre>
<p>
Finally, ClassWizard also adds the code you need to implement these events to the class' declaration in its header file:</p>
<pre><code>&nbsp;&nbsp;&nbsp;void FireStop()
 &nbsp;&nbsp;&nbsp;&nbsp; {FireEvent(eventidStop,EVENT_PARAM(VTS_NONE));}
 &nbsp; void FireCaution()
 &nbsp;&nbsp;&nbsp;&nbsp; {FireEvent(eventidCaution,EVENT_PARAM(VTS_NONE));}
 &nbsp; void FireGo()
 &nbsp;&nbsp;&nbsp;&nbsp; {FireEvent(eventidGo,EVENT_PARAM(VTS_NONE));}
 &nbsp; void FireTesting()
 &nbsp;&nbsp;&nbsp;&nbsp; {FireEvent(eventidTesting,EVENT_PARAM(VTS_NONE));}
 &nbsp; void FireOff()
 &nbsp;&nbsp;&nbsp;&nbsp; {FireEvent(eventidOff,EVENT_PARAM(VTS_NONE));}
</code></pre>
<p>
To make it easier to fire events, I wrote a helper function called <b>FireRightEvent.</b> Call it after the light changes. It fires the appropriate event based on the stoplight's new state. Here's the code:</p>
<pre><code>void CStopLiteCtrl::FireRightEvent()
// called whenever the stoplight state changes to fire the
//&nbsp;&nbsp; appropriate event—must call AFTER m_color set to new value!
// Use the source browser to make sure you call each time 
//&nbsp;&nbsp; m_color changed!
{
 &nbsp; switch (m_color) {
 &nbsp;&nbsp;&nbsp;&nbsp; case SL_RED: FireStop();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; case SL_YELLOW: FireCaution();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; case SL_GREEN: FireGo();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; case SL_NONE: FireOff();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; case SL_TEST: FireTesting();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; }
}
</code></pre>
<h2>Making the Control Draw</h2>
<p>
Compared with other types of Windows programs, the drawing code for ActiveX controls must meet some special requirements.</p>
<p>
First, your control must draw on demand. Your control will be asked to draw itself whenever the container needs it to. The container will pass it a device context (DC) and two rectangles—a bounding rectangle and a rectangle that encloses all the invalid regions. (If you're new to MFC and/or Windows, read up on device contexts.)</p>
<p>
You must redraw at least the pixels enclosed by the invalid rectangle but may not draw any pixels outside the bounding rectangle. You can optimize your drawing code by not drawing pixels outside the invalid rectangle.</p>
<p>
Note that the bounding rectangle's upper left corner is not guaranteed to be at (0, 0)—it usually will be when drawing a control that's in the active state, but not, for instance, when drawing a control that's in the inactive state.</p>
<p>
Second, you must paint your background. Unlike painting a window or drawing a view, you must paint your background in the control's <b>OnDraw</b> function. Background painting is not done automatically, nor is it done in some other function.</p>
<p>
Third, you may not assume anything about the DC you've been passed, so you should select the pens, brushes, fonts, and colors you need when you draw your control. Some containers will pass your control a metafile DC in some situations, especially when printing. In order to work properly when drawing into a metafile, you must restrict your function calls to those supported in metafiles. See the <i>MFC Encyclopedia</i> article "OLE Controls: Painting and OLE Control" for more information. Finally, you must always select the old drawing objects back into the DC before your drawing function exits.</p>
<p>
Lastly, the container, not the control, determines the control's size and position. Because the control doesn't determine the size and position of your control's visible area, you must either scale your output to fit in the window you're provided or supply scrolling—or both. The <b>StopLite </b>control scales drawing according to the height of the control and centers it across the width. A control such as a grid will always draw using the same scaling but will provide scrolling if the area to be drawn is larger than the area the container gives you.</p>
<p>
The requirements are even more complicated for transparent and other windowless controls, but that's beyond the scope of this article.</p>
<h3>Drawing the StopLite Control</h3>
<p>
The <b>OnDraw</b> function for the <b>StopLite</b> control does three tasks: drawing the background, drawing the stoplight's bezel, and drawing the lights.</p>
<p>
Here's the code for <b>OnDraw:</b></p>
<pre><code>void CStopLiteCtrl::OnDraw(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDC* pdc, const CRect&amp; rcBounds, const CRect&amp; rcInvalid)
{
 &nbsp; // 1. erase background using container's background color
 &nbsp; CBrush brAmbientBack(TranslateColor(AmbientBackColor()));
 &nbsp; pdc-&gt;FillRect(rcBounds, &amp;brAmbientBack);
 &nbsp; 
 &nbsp; // 2. draw bezel using control's stock properties 
 &nbsp; //&nbsp;&nbsp; BackColor and ForeColor
 &nbsp;&nbsp;&nbsp;&nbsp; // calculate size based on 40% of height
 &nbsp; CRect rcBezel(rcBounds);
 &nbsp; int nHeight = rcBounds.Height();
 &nbsp; int nWidth = rcBounds.Width();
 &nbsp; int nBezelWidth = nHeight * 40 / 100;
 &nbsp; if (nBezelWidth &gt; nWidth) 
 &nbsp;&nbsp;&nbsp;&nbsp; nBezelWidth = nWidth;&nbsp;&nbsp; // not more then width!
 &nbsp; int nDeflateBezel = (nWidth - nBezelWidth) / 2;
 &nbsp; rcBezel.DeflateRect(nDeflateBezel, 0);
 &nbsp;&nbsp;&nbsp;&nbsp; // create and select brush and pen
 &nbsp; CBrush brBack(TranslateColor(GetBackColor()));
 &nbsp; CBrush * pbrOld = pdc-&gt;SelectObject(&amp;brBack);
 &nbsp; CPen pnFore(PS_SOLID, 2, TranslateColor(GetForeColor()));
 &nbsp; CPen * ppnOld = pdc-&gt;SelectObject(&amp;pnFore);
 &nbsp;&nbsp;&nbsp;&nbsp; // draw
 &nbsp; pdc-&gt;Rectangle(rcBezel);
 &nbsp;&nbsp;&nbsp;&nbsp; // select old brush, but not old pen
 &nbsp; pdc-&gt;SelectObject(pbrOld);
 &nbsp; // 3. draw lights using stock ForeColor, already selected
 &nbsp;&nbsp;&nbsp;&nbsp; // translate enum code to bits for red, green, yellow
 &nbsp; int nLights = TranslateLights();
 &nbsp;&nbsp;&nbsp;&nbsp; // percentages are percentage of height
 &nbsp;&nbsp;&nbsp;&nbsp; // draw red light on top, 6% down, 27% diameter
 &nbsp; DrawLight(pdc, rcBounds, 6, 27, 
 &nbsp;&nbsp;&nbsp;&nbsp; (nLights &amp; SLBIT_RED) ? SLCOLOR_RED : SLCOLOR_OFF);
 &nbsp;&nbsp;&nbsp;&nbsp; // yellow light in middle, 37% down, 27% diameter
 &nbsp; DrawLight(pdc, rcBounds, 37, 27, 
 &nbsp;&nbsp;&nbsp;&nbsp; (nLights &amp; SLBIT_YELLOW) ? SLCOLOR_YELLOW : SLCOLOR_OFF);
 &nbsp;&nbsp;&nbsp;&nbsp; // green light on bottom, 68% down, 27% diameter
 &nbsp; DrawLight(pdc, rcBounds, 68, 27,
 &nbsp;&nbsp;&nbsp;&nbsp; (nLights &amp; SLBIT_GREEN) ? SLCOLOR_GREEN : SLCOLOR_OFF);
 &nbsp; pdc-&gt;SelectObject(ppnOld);
}
</code></pre>
<h4>1. Drawing the background</h4>
<p>
This is the simplest of the three tasks: all we do is create a brush using the container's ambient background color, then use the <b>FillRect</b> function to draw a rectangle filling the entire control with that brush. <b>FillRect</b> automatically takes care of selecting and deselecting the brush.</p>
<h4>2. Drawing the bezel</h4>
<p>
This is a little trickier because we have to scale the output rather than just paint the entire control. Specifically, we'd like the bezel to be a little wider than the lights, but not the full width of the control. First, we set up a rectangle that will be the size of the bezel (when we're done with it). We calculate the bezel size to be 40 percent of the height and then calculate how much to deflate the left and right sides of the rectangle. (Deflating it keeps it nicely centered.) Note that if the bounding width is less than the bezel width, the bezel width is set to the bounding width. This keeps us from drawing outside the bounding rectangle.</p>
<p>
Once we have a rectangle for the bezel, we create a brush and select it into the DC, saving the pointer to the current brush returned by <b>SelectObject</b> so we can select it back in later. We do the same routine with the pen. In both cases, the color is selected from a stock property. Next, we draw the rectangle and select the old brush (but not the pen—we're still going to use it) back into the DC.</p>
<h4>3. Drawing the lights</h4>
<p>
This is the trickiest of all. To draw the lights, I wrote a couple of helper functions—<b>TranslateLights</b> and <b>DrawLight</b>—which I'll discuss below. Note that I wrote the code for clarity, not top speed. If I were more concerned with speed, I'd be sure to calculate the various intermediate values as infrequently as possible.</p>
<p>
Visual C++ includes a cool feature for adding member functions and member data: Just right-click on the class name in ClassView and select Add Function or Add Variable. When you do this, Visual C++ writes the header and a blank function skeleton for you. It even remembers to include the class name in the function definition. (I never remember this!)</p>
<p>
The main idea is to call <b>TranslateLights</b> to get the bits representing which lights are on into the variable <i>nLights,</i> then call <b>DrawLights</b> for each light, passing the DC, the bounding rectangle, the distance to draw the light from the top (expressed as a percentage of the height), the diameter (as a percentage of the height), and the color to draw the light. SL_RED, SL_GREEN, and SL_YELLOW are defined as the RGB values for each color; SL_OFF is defined as dark gray. I measure drawing distances as percentages to make figuring out where to draw things easier.</p>
<p>
Finally, we select the old brush (saved while drawing the bezel) back into the DC.</p>
<p>
Here are the definitions of the SL_* constants. Note that I've put them inside the StopLiteCtrl class, so they're "local" to the class:</p>
<pre><code>// stoplight state (values of m_color/Color property)
enum { SL_NONE = 0,
 &nbsp;&nbsp;&nbsp;&nbsp; SL_FIRST = 1,&nbsp;&nbsp; // first light in cycle
 &nbsp;&nbsp;&nbsp;&nbsp; SL_RED = 1, SL_GREEN = 2, SL_YELLOW = 3, // cycle order
 &nbsp;&nbsp;&nbsp;&nbsp; SL_LAST = 3,&nbsp;&nbsp; // last light in cycle
 &nbsp;&nbsp;&nbsp;&nbsp; SL_TEST = 4 };&nbsp;&nbsp; // test MUST be last (see SetColor)
 &nbsp; 
// bits corresponding to the three lights; used for drawing
enum { SLBIT_RED = 1, SLBIT_GREEN = 2, SLBIT_YELLOW = 4,&nbsp; };
// possible colors for light: off, red, green, yellow
enum { SLCOLOR_OFF = RGB(63, 63, 63),&nbsp;&nbsp; // dark gray
 &nbsp;&nbsp;&nbsp;&nbsp; SLCOLOR_RED = RGB(255, 0, 0),
 &nbsp;&nbsp;&nbsp;&nbsp; SLCOLOR_GREEN = RGB(0, 255, 0), 
 &nbsp;&nbsp;&nbsp;&nbsp; SLCOLOR_YELLOW = RGB(255, 255, 0) };
</code></pre>
<h4>TranslateLights</h4>
<p>
<b>TranslateLights</b> takes the <b>Color</b> property and sets the appropriate bits of the return value in a switch statement.</p>
<p>
Here's the code for <b>TranslateLights:</b></p>
<pre><code>int CStopLiteCtrl::TranslateLights()
// sets appropriate bits for stoplight state
{
 &nbsp; int nLights = SLBIT_RED;&nbsp;&nbsp; // safe default
 &nbsp; switch (m_color) {
 &nbsp; case SL_NONE: nLights = 0;
 &nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; case SL_RED: nLights = SLBIT_RED;
 &nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; case SL_GREEN: nLights = SLBIT_GREEN;
 &nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; case SL_YELLOW: nLights = SLBIT_YELLOW;
 &nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; case SL_TEST: nLights = SLBIT_RED | SLBIT_YELLOW | SLBIT_GREEN;
 &nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; }
 &nbsp; return nLights;
}
</code></pre>
<h4>DrawLight</h4>
<p>
<b>DrawLight</b> is somewhat complicated. First, we calculate the width and height of the control's bounding rectangle, then the diameter of the light in pixels. If the diameter is larger than the width of the bounding rectangle, we set it to the width of the bounding rectangle to ensure that we don't draw outside of the bounding rectangle.</p>
<p>
We then calculate the left and top edges of the circle's bounding square, and construct a <b>CRect</b> object of that size and position. (We ensure that the <b>CRect</b> is entirely inside the bounding rectangle by using the <b>IntersectRect</b> function.)</p>
<p>
Next, we create a brush of the appropriate color and select it into the DC, then draw the circle using the Ellipse function. Finally, we select the old brush back into the DC.</p>
<p>
Here's the code for <b>DrawLight:</b></p>
<pre><code>void CStopLiteCtrl::DrawLight(
// draws an individual light centered in the control at
//&nbsp;&nbsp; vertical position specified
 &nbsp;&nbsp;&nbsp;&nbsp; CDC* pdc,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DC in which to draw
 &nbsp;&nbsp;&nbsp;&nbsp; const CRect&amp; rcBounds,&nbsp;&nbsp; // control's rectangle
 &nbsp;&nbsp;&nbsp;&nbsp; int nPercentDown,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // top position as % of height
 &nbsp;&nbsp;&nbsp;&nbsp; int nPercentDiameter,&nbsp;&nbsp; // diameter as % of height
 &nbsp;&nbsp;&nbsp;&nbsp; COLORREF crColor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // color to fill light&nbsp;&nbsp; 
 &nbsp; )
{
 &nbsp; // calculate diameter in drawing units
 &nbsp; int nHeight = rcBounds.Height();
 &nbsp; int nWidth = rcBounds.Width();
 &nbsp; int nDiameter = nHeight * nPercentDiameter / 100;
 &nbsp; if (nDiameter &gt; nWidth) 
 &nbsp;&nbsp;&nbsp;&nbsp; nDiameter = nWidth;&nbsp;&nbsp; // but not greater than width!
 &nbsp; // create light's bounding rect
 &nbsp; int nLeftEdge = (rcBounds.left + rcBounds.right - nDiameter) / 2;
 &nbsp; int nTopEdge = rcBounds.top + nHeight * nPercentDown / 100;
 &nbsp; CRect rcLight(&nbsp;&nbsp; nLeftEdge,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nTopEdge,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nLeftEdge + nDiameter,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nTopEdge + nDiameter);
 &nbsp; // make absolutely sure we're within bounds—
 &nbsp; // distort circle if necessary!
 &nbsp; rcLight.IntersectRect(rcLight, rcBounds);
 &nbsp; // create brush, draw, select old brush
 &nbsp; CBrush brColor(crColor);
 &nbsp; CBrush * brOld = pdc-&gt;SelectObject(&amp;brColor);
 &nbsp; pdc-&gt;Ellipse(rcLight);
 &nbsp; pdc-&gt;SelectObject(brOld);
}
</code></pre>
<h2>Responding to Windows Messages</h2>
<p>
Handling Windows messages is very much like handling messages in any MFC application—you just add message handlers to your window, which in this case is derived from <b>COleControl.</b></p>
<p>
The <b>StopLite</b> control doesn't need any keyboard messages, but your control might. If you need to get messages for the enter key or the escape key, or if you need to use accelerators, I highly recommend the section on keyboard issues in Denning's <i>OLE Controls Inside Out</i> or "Developing OLE Custom Controls" by Scott Randall, available on the Library Archive (Conference and Seminar Papers; Tech Ed, March 1994; Visual C++).</p>
<p>
The <b>StopLite</b> control does respond to one Windows message: It selects the next state in sequence when you left-click on it.</p>
<p>
To respond to left button clicks, use ClassWizard to add a handler for the WM_LBUTTONDOWN message, then call the <b>Next</b> function from within that handler before you call the base class' function.</p>
<p>
ClassWizard adds the appropriate declaration to the header, then adds the following entry to the message map:</p>
<pre><code>&nbsp;&nbsp;&nbsp;ON_WM_LBUTTONDOWN()
</code></pre>
<p>
I modified the function it added so that it called the Next method. When I was done, the code looked like this:</p>
<pre><code>void CStopLiteCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
// call Next method on left click, allow Click stock event to be fired
{
 &nbsp; Next();
 &nbsp; 
 &nbsp; COleControl::OnLButtonDown(nFlags, point);
}
</code></pre>
<h2>Property Pages</h2>
<p>
ActiveX controls can support property pages to make modifying the control's properties at design time much easier. The default page generated by AppWizard is blank except for a static text control that contains a message reminding you to finish the property page.</p>
<p>
Doing the property page is even simpler than doing a dialog box in MFC, because ClassWizard will write the code to transfer data between your property page class' members and the properties. First, edit the dialog template (in our case, it's <b>IDD_PROPPAGE_STOPLITE</b>) to create the controls you'd like for your property UI. Our case has only one important property (<b>Color</b>) and the light can have only one <b>Color</b> value at a time, so I used a set of option buttons, or radio buttons, as the UI.</p>
<p>
<img src="abcsmfc_3.gif" border=0></p>
<p>
When using option buttons, you must set the tab order correctly, so the buttons are read properly, and be sure that only the first option button (Off) has the Group checkbox checked on its property page. The screen shot above shows that the tab order is correct.</p>
<p>
It is also important that the buttons be in the same tab order as the values they represent in the <b>Color</b> property. That means I don't have to translate the values going in and out of the control.</p>
<p>
Once I had the dialog box template set up correctly, adding the code was a snap—or, more precisely, a double-click with the control key held down. All I did was Ctrl+double-click on the Off button, and ClassWizard came up ready to add the code I needed to handle this property page. In the Add Member Variable box, all I needed to do was name the member variable (<b>m_color</b> in my case) and tell ClassWizard what property to attach it to (Color). ClassWizard generated all the right code, adding a declaration for the member variable to the header file:</p>
<pre><code>&nbsp;&nbsp;&nbsp;int m_color;
</code></pre>
<p>
initializing it in the constructor:</p>
<pre><code>&nbsp;&nbsp;&nbsp;m_color = 0;
</code></pre>
<p>
and adding lines to the <b>DoDataExchange</b> function so the value in the option buttons would be transferred back and forth correctly to the control's property:</p>
<pre><code>&nbsp;&nbsp;&nbsp;DDP_Radio(pDX, IDC_OFF, m_color, _T("Color") );
 &nbsp; DDX_Radio(pDX, IDC_OFF, m_color);
</code></pre>
<p>
I didn't have to write a line of code. Even if you're not using Visual C++, getting a property page in exchange for four lines of code is a pretty good deal. </p>
<h2>Notifying Your Container of Errors</h2>
<p>
In some situations, you'd like to communicate the errors to the container. There are two ways of notifying the container of errors, depending on whether the code that detected the error is in a method call (including Get/Set methods) or not (such as the code that processes a Windows message).</p>
<h3>From Within a Method Call</h3>
<p>
Within a method, call <b>COleControl::ThrowError.</b> <b>StopLite</b> does this in <b>SetColor</b> if the color requested is invalid:</p>
<pre><code>&nbsp;&nbsp;&nbsp;if (nNewValue &gt;= SL_NONE &amp;&amp; nNewValue &lt;= SL_TEST)&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // ...set color and redraw, etc.
 &nbsp; }
 &nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp; ThrowError(CTL_E_ILLEGALFUNCTIONCALL, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Color parameter out of range");
 &nbsp; }
</code></pre>
<h3>In Other Situations</h3>
<p>
Call <b>COleControl::FireError.</b> To do this, you must add the <b>Error</b> stock event to your control. </p>
<h2>A Brief Note About Security Issues</h2>
<p>
Internet Explorer 3.0 implements two mechanisms to ensure that users can load and run controls without harming their systems. First, it checks the signature of any code it installs. If the signature is missing or invalid, it will refuse to install the code (when security is set to high, the default) or at least notify you and allow you to decide (when security is set to medium). When security is set to none, Internet Explorer 3.0 doesn't check signatures. </p>
<p>
Second, if your Web page attempts to initialize and/or script the control, Internet Explorer 3.0 checks to see if it's marked as safe for initializing and/or safe for scripting. If the control is not marked safe for what Internet Explorer 3.0 wants to do, the browser will ignore the control (when security is set to high) or display a dialog box (when security is set to medium). </p>
<p>
To get around all of the dialog boxes and to run at all on Internet Explorer 3.0 when security is set to high, you have to sign your control and mark it as safe. </p>
<p>
Signing your code only takes about 3.5K, which adds up to one second at 28.8Kbps, so it won't significantly slow Web page download times. </p>
<h2>Code Signing</h2>
<p>
Code signing is the process of adding data to the control so that Internet Explorer 3.0 can ascertain two things:
<ul type=disc>
<li>
The control has not been modified since it was signed.<br><br></li>
<li>
The claimed author is actually the author.</li>
</ul>
<p>
Signing a control requires an electronic "certificate" provided by a "certificate authority" (CA). When you apply for a certificate, the certificate authority does some checking to determine that you are who you say you are, then issues the certificate. You can use this certificate with some utilities in the ActiveX SDK to sign your control. Note that you must guard this certificate and the private key carefully. If someone else obtains them, they can sign their code in your name. </p>
<p>
A simple overview of this process can be found in the article <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_sixsteps">
</object><a href=JavaScript:alink_1.Click()>"Six Steps to Signing Your Code"</a> also on the Library. You can find more information on code signing on the Site Builder Workshop Web site (<a href="http://www.microsoft.com/workshop/prog/default.asp">http://www.microsoft.com/workshop/prog/default.asp</a>) and in the ActiveX SDK. </p>
<p>
I did not sign the <b>StopLite</b> control myself, as Microsoft has a central signing procedure for signing code. I just followed their procedure, and they signed the code for me. If you work for a company of any size, your company will probably have a centralized signing procedure. </p>
<h3>Marking Your Control as Safe</h3>
<p>
Now that we know from whom the control came, how do we know it's safe to use? Remember that ActiveX controls, unlike Java applets, can access the full power of your machine—for good or evil. </p>
<p>
If it's not possible for your control to cause harm to a user's machine no matter what, you can mark it as safe. It is your responsibility to ensure that any control you mark is actually safe—Internet Explorer 3.0 has no way to ensure that a control marked as safe is actually safe. </p>
<p>
There are two categories of safety: safe for scripting and safe for initializing. Safe for scripting means that no matter what scripts do to manipulate your control, it will not harm the user's machine. Safe for initializing means that no matter what data is passed to your control from the Web page, it will not harm the user's machine. <b>StopLite</b> is both safe for scripting and safe for initialization and is marked accordingly. </p>
<p>
There are two methods for letting Internet Explorer 3.0 know that your control is safe:
<ul type=disc>
<li>
Manipulate the registry to include component categories for safety and add an entry saying that your control is safe.<br><br></li>
<li>
Implement the <b>IObjectSafety</b> COM interface. </li>
</ul>
<p>
For more complete information on marking controls as safe, check out my article <a href="msdn_signmark.htm">"Signing and Marking ActiveX Controls."</a></p>
<p>
Unfortunately, there is currently no method for signing Web pages. This would be handy for using potentially unsafe controls because the Web page author could assert that the page doesn't contain scripting or initialization that would cause an otherwise potentially unsafe control to damage a user's machine. Such a scheme would also require a way to ensure that the right controls are installed.</p>
<h3>Manipulating the Registry</h3>
<p>
The simpler method for marking a control safe for scripting and initialization is to add the necessary entries to the registry. I chose this method for <b>StopLite.</b></p>
<p>
Although it is possible to do this by hand or with a .REG file, self-registering controls should do this automatically when they register themselves. This is especially true for controls that will be downloaded over the Internet.</p>
<p>
When the control unregisters itself, it will automatically remove all of its registry entries. Therefore, we don't need to do anything special to unregister the control. (We don't remove the categories because other controls might be using them.)</p>
<p>
Here is the code I wrote to mark the control as safe for scripting and initializing. First I create the component categories, then I mark this particular control as safe in that category. This code might fail if it's being run on a system that doesn't have Internet Explorer 3.0 installed; because such a failure is okay (for instance, the user might be using the control in a Visual Basic application), we don't halt initialization for the control if this code fails.</p>
<pre><code>&nbsp;&nbsp;&nbsp;// mark as safe for scripting—failure OK
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT hr = CreateComponentCategory(CATID_SafeForScripting,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L"Controls that are safely scriptable");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // only register if category exists
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterCLSIDInCategory(m_clsid, CATID_SafeForScripting);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // don't care if this call fails
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // mark as safe for data initialization
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = CreateComponentCategory(CATID_SafeForInitializing,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L"Controls safely initializable from persistent data");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // only register if category exists
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterCLSIDInCategory(m_clsid, CATID_SafeForInitializing);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // don't care if this call fails
</code></pre>
<p>
This code requires that the helper functions <b>CreateComponentCategory</b> and <b>RegisterCLSIDInCategory</b> be defined. I copied definitions from the ActiveX SDK. The definitions are in Helpers.H and Helpers.CPP. (You can use these files as-is in your projects.) In STOPLITECTL.CPP, I also had to include a couple files:</p>
<pre><code>// for marking the StopLite safe for scripting, initializing
#include "helpers.h"
#include &lt;objsafe.h&gt;
</code></pre>
<p>
The file HELPERS.H also includes COMCAT.H which, like OBJSAFE.H, is in the ActiveX SDK. </p>
<p>
If my control were not written using MFC, I'd do the marking in <b>DllRegisterServer</b>. </p>
<h3>Implementing IObjectSafety</h3>
<p>
The other way to "mark" a control as safe is to implement the <b>IObjectSafety</b> COM interface. We won't be covering it in this article, but it is covered in "Signing and Marking ActiveX Controls" and in the ActiveX SDK. </p>
<p>
Although slightly more complicated, implementing <b>IObjectSafety</b> has some advantages in that the interface allows the container either to ask whether the control is safe using <b>GetInterfaceSafetyOptions</b> or to request that it make itself safe using <b>SetInterfaceSafetyOptions.</b> (<b>GetInterfaceSafetyOptions </b>also allows you to ask the control what safety options it supports.) This flexibility allows you to write your control so that it can operate in either safe or unsafe mode. If the container requests that you be safe for scripting and/or initialization, your control can change modes and behave accordingly. If the container doesn't care about safety, your control can run in unsafe mode and exploit the full power of the machine. </p>
<h2>Using Visual C++ and Test Container to Debug the Control</h2>
<p>
At various points in the development process, you might want to be able to examine variables in your control, set breakpoints, and single-step the code. </p>
<p>
This is quite easy. First, build the control for Debug. Then, provide the name of an executable that will host the control while debugging. I usually use the test container, which is at C:\MSDEV\BIN\TSTCON32.EXE in a standard Visual C++ installation. To change the container .EXE, use the "Settings" command on the Build menu and select the Debug tab. (You can debug in any container, although I find the test container most convenient.) </p>
<p>
Once you have things set up, just select Debug.Go from the Build menu. The test container will start. As you insert the control in the test container, you'll get a number of messages you can safely ignore (see below). </p>
<p>
At this point, if you haven't already, you can set breakpoints in your code, examine variables, single-step, and so forth—just as if you were debugging an application. </p>
<p>
If you're using another development system, check your documentation for debugging directions. </p>
<h3>Debugging Output You Can Safely Ignore</h3>
<p>
When you're debugging a control, you may get a series of messages in Visual C++'s debugging window. Although it's not documented anywhere, some of these messages can be safely ignored. For instance, when I debug the <b>StopLite</b> control in the test container using Visual C++ version 4.2, I get the following:</p>
<pre><code>Loaded symbols for 'C:\WINNT35\system32\MFC42.DLL'
LDR: WARNING ! MAJOR PERFORMANCE LOSS in TSTCON32.EXE
LDR: Dll MFC42D.DLL base 5f400000 relocated due to collision with&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C:\WINNT35\System32\MFC42.DLL
Loaded symbols for 'C:\WINNT35\system32\MFC42D.DLL'
Loaded symbols for 'C:\WINNT35\system32\MSVCRTD.DLL'
Loaded symbols for 'C:\WINNT35\system32\MFCO42D.DLL'
Warning: constructing COleException, scode = DISP_E_MEMBERNOTFOUND ($80020003).
First-chance exception in TSTCON32.EXE (MFCO42D.DLL): 0xE06D7363: Microsoft C++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exception.
</code></pre>
<p>
The first line is just notification that the debugging symbols for the release version MFC DLL were loaded when the test container, which uses the release version of the MFC DLL, was loaded.</p>
<p>
The second and third lines (which begin with "LDR:") warn that the debugging version of the MFC DLL (used by the <b>StopLite</b> control) had to be relocated in my address space because it conflicted with the release version of the same DLL (which is being used by the test container). Although this means that it took a little longer to load the MFC DLL, it isn't a big deal because it only happens when you're debugging in the test container. You can ignore these messages. (Since Visual Basic apps don't use the MFC DLL at all, you won't get this message if you use a Visual Basic app as your test container.)</p>
<p>
The next three lines are notifications that debugging symbols have been loaded.</p>
<p>
The last two lines are notification that an exception has been thrown because the test container didn't provide a <b>Color</b> property to be read. This is okay, because we've provided a default value for the property. You won't get this error if you use a container that provides the property, such as a Visual Basic application.</p>
<p>
In Visual C++ version 4.1, the only line I got was a warning about the exception for properties that couldn't be loaded from the container.</p>
<pre><code>First-chance exception in TSTCON32.EXE (MFC40.DLL): 0xE06D7363: Microsoft C++ Exception. 
</code></pre>
<p>
Depending on how your container handles threads, you may also get occasional messages about threads exiting. You don't need to worry about these, either. </p>
<h2>Creating a Web Page Using the ActiveX Control Pad</h2>
<p>
Now that we have a control, let's use it in a Web page! </p>
<p>
The ActiveX Control Pad is the easiest way to create Web pages that contain ActiveX controls and scripting. And the price is right: It's free at <a href="http://www.microsoft.com/workshop/author/cpad/">http://www.microsoft.com/workshop/author/cpad/</a>! The ActiveX Control Pad is mainly intended to create .ALX files for the HTML Layout Control, which allows precise placement and layering of controls. However, the ActiveX Control Pad also works great for authoring Web pages with controls and scripting, so that's how we'll use it. </p>
<h3>Inserting a StopLite Object</h3>
<p>
When you start the ActiveX Control Pad, it brings up an empty page. The first step is to insert a control using the Insert ActiveX Control command on the Edit menu. You can set the size and initial properties using the default property sheet, or call up your custom property sheet by right-clicking on the control and selecting the bottom "Properties . . ." choice. Once you've done this, close the Edit ActiveX Control Window. </p>
<p>
You'll see that the ActiveX Control Pad has inserted an object tag for you—and placed an icon in the margin. Any time you'd like to edit the control's size or properties, just click on that icon. </p>
<h3>Inserting Other Controls</h3>
<p>
Next, we'd like to insert some buttons. I don't want to use an OLE control for the buttons, so I just type an HTML &lt;INPUT&gt; tag in place: specifically, &lt;INPUT TYPE=BUTTON NAME="NEXT" VALUE="Next Light"&gt;. </p>
<p>
On the next line, I'd like an IELabel control, so I insert a paragraph tag (&lt;P&gt;), then use Insert ActiveX Control again to insert the label control ("Label Object" in my control list). </p>
<h2>Scripting with Script Wizard</h2>
<p>
Now, let's do a little scripting. One of the best features of the ActiveX Control Pad is the Script Wizard, which helps you write code in your choice of VBScript or JavaScript. Just click on the Script Wizard toolbar button to start. </p>
<p>
This is really intuitive: just select the event you'd like to handle, select the object you'd like to do something to, and tell it what to do. We'll do two events: the click of the <b>Next</b> button and the <b>Stop</b> event fired by the <b>StopLite</b> control. </p>
<p>
First the <b>Next</b> button. Expand <b>Next</b> in the left pane, then click on OnClick. What we'd like to do is call the StopLite's <b>Next</b> method, so expand StopLite1 in the right pane, then double-click on Next. That's it. You can save your page and load it into Internet Explorer 3.0 now if you like—or handle the Stop event. </p>
<p>
To handle the StopLite's <b>Stop</b> event, follow basically the same procedure: select StopLite1. Stop, double-click on IELabel1. Caption, then type (into the dialog box that pops up) the text you'd like to see. </p>
<h2>Viewing the Page</h2>
<p>
We're done for now. You can duplicate (or better!) my page on your own knowing what you now know. Save your work (I usually save it on my desktop) and test it in Internet Explorer 3.0! </p>
<p>
Note that you'll get warning dialogs if your control isn't signed and/or marked as safe. And, if Internet Explorer's security is set to high, you won't be able to view the control at all. (For development purposes, it's often better to set the security to medium. We don't recommend setting it to none.) </p>
<h2>Conclusion</h2>
<p>
We've created a simple control in MFC and embedded it in a Web page. We've looked at drawing the control, handling Windows messages, and implementing properties, methods, and events. But there are some things we haven't done. </p>
<p>
First, we could add more functionality to the control—the capability for blinking lights (even a blinking green light, as used in Vancouver, Canada), or turn arrows. We could even modify the sequence of lights to include allowing the yellow and red lights to be on at the same time just before the light changes to green, as they do in the United Kingdom. (Note that the drawing code design makes such a modification easy and safe.) Or we could write some of the other controls needed as components in a traffic simulation. </p>
<p>
Then there are OCX 96 enhancements: making the control windowless for improved performance, transparent controls, and so on. Implementing dual-automation interfaces for better performance would be nice. Or we could just set up the control for licensing to users and designers. </p>
<p>
We could also package up the control and its DLLs so that Internet Explorer 3.0 could download and run it automatically. We'll have an article about that subject soon. </p>
<p>
The most important step is to sign the control by attaching a certificate to it so that people who download it will know who wrote it—and so Internet Explorer 3.0 will use it without a dire warning message. Check out "Signing and Marking ActiveX Controls" for more information, as well as the section on Code Signing on the <i>Site Builder Workshop</i> site at <a href=" http://www.microsoft.com/workshop/default.asp"> http://www.microsoft.com/workshop/default.asp</a>.</p>
<h2>Where to Learn More</h2>
<p>
How can you learn more? Good information on new control features can be found in the ActiveX SDK and on the <i>Site Builder Workshop</i> site at <a href=" http://www.microsoft.com/workshop/default.asp">http://www.microsoft.com/workshop/default.asp</a>.</p>
<p>
Another great source, as I've mentioned previously, is Adam Denning's <i>OLE Controls Inside Out.</i> And the Visual C++ 4.2 MFC Encyclopedia is great, as is the rest of the doc set.</p>
<p>
Enjoy! And start writing ActiveX controls for fun and profit!</p>
</BODY>
</HTML>
