<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Multiple Threads in the User Interface</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_winthr"></a></sup>Multiple Threads in the User Interface</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: November 24, 1993</p>
<h2>Abstract</h2>
<p>
The Microsoft® Win32® Application Programming Interface (API) has given us the ability to use multiple threads within applications. Many programmers for Microsoft Windows™ are now looking for ways to add threads to their applications. Although there are some excellent reasons to add threads to an application, there are also times when threads are unnecessary and will only add to the complexity of a program. In this technical article, I will explain the ramifications of adding multiple threads to the user interface, including the following:
<ul type=disc>
<li>
Why and where (and why not and where not) to use multiple threads<br><br></li>
<li>
The cost of adding multiple threads to the user interface<br><br></li>
<li>
How threads affect message routing<br><br></li>
<li>
How multiple user-interface threads affect window management<br><br></li>
<li>
Alternatives to multiple threads<br><br></li>
<li>
How to avoid message deadlocking<br><br></li>
<li>
New functions for handling multiple threads</li>
</ul>
<h2>Introduction</h2>
<p>
So you already have an application written for Microsoft® Windows™ version 3.1 that you have decided to port to Windows NT™. Since Windows NT has these new things called threads that are supposed to make applications faster, you're interested in putting these in your application. The first thing you do is look up the functions that you need to create and use threads, and you jump right in, adding threads to all of the "slow" areas in your application and creating a thread for each new window that you create. After you finally get your application to build (passing NULL as a parameter every time you were asked for a security descriptor), you find to your utter horror that not only is your application <i>not</i> faster, but it doesn't work correctly anymore! At this point you begin to wonder if threads are such a great idea after all.</p>
<p>
Perhaps the problem isn't with the threads, but with where you have decided to add your threads. When threads are used and placed correctly in an application, you can gain some excellent benefits in speed, but when they are placed inappropriately, you may well end up with a complex application that is no faster than it was originally and much harder to debug.</p>
<h2>Why Use Multiple Threads in the User Interface?</h2>
<p>
When you think of multithreading, some tasks immediately come to mind, such as data calculations, database queries, and input gathering. These activities, most often thought of as "background" tasks, do not directly involve the user interface or window management. Does this mean that there are no places that you can incorporate threads in your user interface? Certainly not. In general, if there are places in your application that do not need to be serialized, you can add threads. For instance, it does not make sense to distribute input to threads because all input is implicitly serialized by USER. It also does not make sense to distribute output to threads because output devices, such as a printer, are inherently single-threaded.</p>
<h3>Where?</h3>
<p>
Let's say you have an application that creates one window that displays current stock quotes and another window that allows you to enter requests for buying or selling stock. Within your application, you have two discrete tasks to complete that do not depend upon one another for information: (1) Displaying current stock quotes and (2) Placing a buy or sell order. These tasks do not affect each other in any way. One way to improve the performance of your application would be to create a thread for each window, thereby creating a more modular application.</p>
<p>
Another situation in which multiple threads would benefit the user interface would be in an application in which one window displays a spinning cube and another window receives input from the user on how fast to spin the cube, the coordinates of the cube, and its angle. (Since we're just dreaming this up, let's make it three-dimensional.) You can fairly cleanly break down the tasks each window needs to complete—one window displays the spinning cube while the other window is gathering input. The big difference between this example and the previous one is that here you need to have one thread communicate some information (the new speed, coordinates, or angle) to the other thread. The first thread can continue to display the cube while the second thread is gathering new input. In other words, you use one thread for input and one for output.</p>
<h3>Where Not?</h3>
<p>
Because I like to be as evenhanded as possible, let me give you a couple of examples of situations in which multiple threads would be a detriment to the user interface. Let's say you have an application that relies upon getting some type of input before it can continue processing, such as a dialog box that accepts logon information. Would it be a good idea to create a thread to gather that input? Probably not. If you are creating a thread to accomplish something that needs to be synchronous, you are making things needlessly complex for almost no benefit, plus there are costs to adding threads, which I will discuss in the next section.</p>
<p>
Another poor multithreading candidate is creating a thread for a nonreentrant window or dialog box. If this window has some global data, and if another thread calls it more than once, your global data can become corrupted. You can work around this problem by ensuring that you keep your data on a per-thread basis rather than a per-process basis. For example, let's say you have a dialog box that you use to open a file, but the data you keep in the thread for the pointer to file or the filename is kept in global data, rather than per-thread data. In this case, if the dialog box is called twice, the pointer and the filename will become corrupted and, when you try to access the file via the pointer in the first thread, you will be accessing the wrong file. This is not the functionality you want. Bear in mind that this situation is not specifically a USER issue—it is a general Windows NT multithreading issue. In any Windows NT-based application, you need to take care with data that you use on a per-thread basis.</p>
<h2>Costs of Creating Threads</h2>
<p>
Just as there is no such thing as a free lunch, there is also no such thing as a free thread. Before creating threads, you must keep the costs in mind. In many cases, you may find that the cost is low compared to the benefit. The following list enumerates some of the costs incurred when creating multiple threads in your process.
<ul type=disc>
<li>
Memory is needed for the structures required by threads.<br><br></li>
<li>
An application that has a large number of threads consumes extra CPU time in keeping track of those threads.<br><br></li>
<li>
An application is responsible for synchronizing access to shared resources by multiple threads. This is true for system resources (such as communications ports or disk drives), handles to resources shared by multiple processes (such as file or pipe handles), or the resources of a single process (such as global variables accessed by multiple threads). If you don't synchronize multiple threads properly (in the same or in different processes), you can run into some nasty problems, including the dreaded deadlock and race conditions.<br><br></li>
<li>
Because all threads of a process share the same address space and can access the process's global variables, an application must also synchronize access to these global variables. This means that the developer must decide what data can be process-specific and what data is thread-specific.</li>
</ul>
<h2>How Multiple Threads Affect Window Management</h2>
<p>
A Windows NT-based application can have multiple threads of execution, and each thread can create windows by calling the <b>CreateWindow</b> function. An application must remove and process messages posted to the message queues of its threads. A single-threaded application uses a message loop in its <b>WinMain</b> function to remove and send messages to the appropriate window procedures for processing.</p>
<h3>Changes to the Message Loop</h3>
<p>
Applications with multiple threads must include a message loop in each thread that creates a window. The message loop and window procedure for a window must be processed by the thread that created the window. If the message loop does not reside in the same thread that created the window, the <b>DispatchMessage</b> function will not get messages for the window. As a result, the window will appear but won't show activation and won't repaint, be moved, receive mouse messages, or generally work as you expect it to.</p>
<h3>Enumerating Your Thread's Windows</h3>
<p>
If you have a need in your application to affect all of the windows created by a particular thread, you can use the new <b>EnumThreadWindows</b> function to enumerate the windows created by a particular thread. For example, let's say you have an application that displays all movie times for a movie theater in a window and creates a window for each theater. The windows created are dependent on the general location the user entered, and you spin off a thread to create all of the windows for the theaters for that location. When the user refines the search to a smaller area, you may want to enumerate the windows in your thread to determine whether or not you need to close down one of the windows containing information about theaters outside of the specified area. This saves you from having to search for information you have already displayed.</p>
<p>
The <b>EnumThreadWindows</b> function is much like the <b>EnumChildWindows</b> function in that the application developer can specify enumeration of the windows and provide a callback function to effect the necessary changes. This function passes the handle of each thread's window, in turn, to an application-defined callback function. The <b>GetWindowThreadProcessId</b> function returns the identifier of the thread that created a particular window.</p>
<h3>Finding a Window; or, Am I Here Yet?</h3>
<p>
Another common window management job that is affected by multiple threads is determining whether or not a previous instance of the application is already running. A common method used by applications to determine whether or not their application has started is to use the <b>FindWindow</b> function specifying the class and window name. If <b>FindWindow</b> returns NULL, the application assumes that it has not been started already. Unfortunately, this is not an entirely reliable method. It is possible for a second instance of an application to be started and to execute the <b>FindWindow</b> call before the first instance has created its window.</p>
<p>
An alternative method for determining whether an instance of your application is running is to use any named object (mutex, semaphore, event, named shared memory). That is, when you start your application, check for a particular named semaphore (the name is your choice, so be creative) and, if the semaphore does not exist, go about starting up your application as usual; if the semaphore does exist, task-switch to your application. The following example is a function that checks to see if a unique semaphore was already created. If the semaphore exists, the function calls <b>FindWindow</b> to find the application, and sets that window to foreground. If it does not exist, the function returns FALSE. The function uses the <b>CreateSemaphore</b> function to illustrate a named-object creation operation that fails if the object already exists.</p>
<pre><code>BOOL DoIExist(LPSTR lpszSemName, LPSTR lpszClassName, LPSTR lpszWindowTitle)
{

 &nbsp;&nbsp; HANDLE hSem;
 &nbsp;&nbsp; HWND hWndMe;

 &nbsp;&nbsp; /* Create or open a named semaphore. */
 &nbsp;&nbsp; hSem = CreateSemaphore(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Security attributes */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Initial count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Maximum count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszSemName); /* Semaphore name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */

 &nbsp;&nbsp; /* Close handle, and return NULL if existing semaphore opened. */
 &nbsp;&nbsp; if (hSem != NULL &amp;&amp; GetLastError() == ERROR_ALREADY_EXISTS)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle(hSem);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hWndMe = FindWindow(lpszClassName, lpszWindowName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hWndMe)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetForegroundWindow(hWndMe);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; /* If new semaphore was created, return FALSE. */
 &nbsp;&nbsp; return FALSE;
}
</code></pre>
<h2>The Effects of Multiple Threads on Message Routing</h2>
<p>
Windows uses two methods to route messages to a window procedure: (1) posting messages to a first-in, first-out queue called a <i>message queue</i>, which is a system-defined memory object that temporarily stores messages; and (2) sending messages directly to a window procedure. Messages posted to a message queue are called <i>queued messages</i>. They are primarily the result of user input via the mouse or keyboard, such as WM_MOUSEMOVE, WM_LBUTTONDOWN, WM_KEYDOWN, and WM_CHAR messages. Other queued messages include the timer, paint, and quit messages: WM_TIMER, WM_PAINT, and WM_QUIT. Most other messages are sent directly to a window procedure and are called, surprisingly enough, <i>nonqueued messages</i>.</p>
<h3>Queued Messages</h3>
<p>
Windows NT maintains a single system-message queue and any number of thread-message queues, one for each thread. Whenever the user moves the mouse, clicks the mouse buttons, or types at the keyboard, the device driver for the mouse or keyboard converts the input into messages and places them in the system-message queue. Windows removes the messages, one at a time, from the system-message queue, examines them to determine the destination window, and then posts them to the message queue of the thread that created the destination window. A thread's message queue receives all mouse and keyboard messages for the windows created by the thread. The thread removes messages from its queue and directs Windows NT to send them to the appropriate window procedure for processing. The system posts a message to a thread's message queue by filling an <b>MSG</b> structure and then copying it to the message queue. Information in the <b>MSG</b> structure includes the handle of the window for which the message is intended, the message identifier, the two message parameters, the message time, and the mouse-cursor position. A thread can post a message to its own message queue or to the queue of another thread by using the <b>PostMessage</b> or <b>PostThreadMessage</b> function.</p>
<h3>Nonqueued Messages</h3>
<p>
Nonqueued messages are sent immediately to the destination window procedure, bypassing the system-message queue and thread-message queue. Windows typically sends nonqueued messages to notify a window of events that affect it. For example, when the user activates a new application window, Windows sends the window a series of messages, including WM_ACTIVATE, WM_SETFOCUS, and WM_SETCURSOR. These messages notify the window that it has been activated, that keyboard input is being directed to the window, and that the mouse cursor has been moved within the borders of the window. Certain Windows function calls can prompt nonqueued messages. For example, Windows sends the WM_WINDOWPOSCHANGED message after an application uses the <b>SetWindowPos</b> function to move a window.</p>
<h2>Window Focus and Activation Considerations</h2>
<p>
The addition of multiple windows owned by multiple threads in the system has brought to the forefront some changes in the concept of focus and activation in the system. These changes affect all applications regardless of whether the application is single- or multithreaded. Remember that each application runs in its own process and when that new process is created, a thread is created for that process. Each thread has its own input state that is not shared, by default, with other threads. As a result, when this new process creates its first window, that window will belong to a different thread from any other window in the system. This "separate thread" concept rears its ugly head if your application tries to set the input focus to another application. Because the windows were created in different threads, the call to <b>SetFocus</b> will fail. I will describe a way around this problem and, since we all know that ignorance is not bliss when programming for Windows, I will detail the three concepts of focus, activation, and foreground and background windows in Win32®.</p>
<p>
<img src="winthr_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The focus window, MDI 3</b></p>
<h3>The Focus Window</h3>
<p>
Windows NT posts keyboard messages to the message queue of the thread that created the window with the keyboard focus. The keyboard focus is a temporary property of a window. Windows shares the keyboard among all windows on the display by shifting the keyboard focus, at the user's direction, from one window to another. The window that has the keyboard focus receives (from the message queue of the thread that created it) all keyboard messages until the focus changes to a different window. A thread can call the <b>GetFocus</b> function to determine which of its windows (if any) currently has the keyboard focus. A thread can give the keyboard focus to one of its windows by calling the <b>SetFocus</b> function. When the keyboard focus changes from one window to another, the system sends a WM_KILLFOCUS message to the window that has lost the focus, and then sends a WM_SETFOCUS message to the window that has gained the focus. In Figure 1, the focus window is the window entitled "MDI 3."</p>
<h3>The Active Window</h3>
<p>
The concept of an <i>active window</i> is probably old hat to many of you reading this article, but I am including the information in the spirit of being complete. The concept of <i>keyboard focus</i> is related to that of the active window. The active window is the top-level window the user is currently working with. The window with the keyboard focus is either the active window itself or a child window of the active window. So that the user can easily identify the active window, the system places it at the top of the z-order and highlights its title bar (if it has one) and border. The user can activate a top-level window by clicking it, by selecting it using the ALT+TAB or ALT+ESC key combination, or by selecting it from the Task List. A thread can activate a top-level window by using the <b>SetActiveWindow</b> function. It can determine whether a top-level window it created is active by using the <b>GetActiveWindow</b> function.</p>
<p>
In Figure 1, the active window is the window entitled "MDI Demonstration." You might think that the "MDI 3" window was the active one, but remember, the <i>active</i> window is always a top-level window and the <i>focus</i> window can be either the active window or a child of the active window. Thus, in this case, the focus window is "MDI 3" and the active window is its parent, "MDI Demonstration."</p>
<p>
When one window is deactivated and another activated, Windows sends the WM_ACTIVATE message first to the window being deactivated and then to the window being activated. The low-order word of the <i>wParam</i> parameter is zero if the window is being deactivated and nonzero if it is being activated. When the default window procedure receives the WM_ACTIVATE message, it sets the keyboard focus to the active window.</p>
<p>
Let's say you try to set the focus to a window that resides in another thread by using <b>SetFocus</b> without calling <b>AttachThreadInput</b>. The call will fail, right? Right. But then what happens to the focus and activation states? I'm glad you asked.</p>
<h4>One window can have the focus while another window is active</h4>
<p>
A situation can arise in Windows NT when one window has the input focus while another window is active. This mainly occurs when a console window attempts to set the focus via <b>SetFocus</b> to a GUI window, and the call to <b>SetFocus</b> fails. When this happens, the console window has lost the keyboard focus, but still remains the active window. The window that gains the focus is dependent on which window in the z-order was next to get the focus. When this happens, the user cannot figure out why the proper window is no longer getting the keyboard input he or she is typing in. Luckily, the person running the software will usually have the presence of mind to click the mouse over the window he or she wants to have the input focus, and the focus will then be set to the correct window. To avoid this problem, call <b>SetForegroundWindow</b>, rather than <b>SetFocus</b>, to reset the focus between unattached windows created in different threads.</p>
<h3>Foreground and Background Windows</h3>
<p>
In Windows NT, each process can have multiple threads of execution, and as we saw before, each thread can create windows. The thread that created the window with which the user is currently working is called the foreground thread, and the window is called the foreground window. All other threads are background threads, and the windows created by background threads are called—you guessed it—background windows.</p>
<h4>The foreground thread gets more CPU time</h4>
<p>
Each thread has a priority level that determines the amount of CPU time the thread receives. Although an application can set the priority level of its threads, normally the foreground thread has a slightly higher priority level than the background threads. Because it has a higher priority, the foreground thread receives more CPU time than the background threads. The foreground thread has a normal base priority of 9; a background thread has a normal base priority of 7. The user sets the foreground window by clicking a window or by using the ALT+TAB or ALT+ESC key combination. An application sets the foreground window by using the <b>SetForegroundWindow</b> function. If the new foreground window is a top-level window, Windows activates it; otherwise, Windows activates the associated top-level window. An application retrieves the handle of the foreground window by using the <b>GetForegroundWindow</b> function. One interesting point to note here is that the user can change this behavior somewhat by opening the Tasking dialog box in the System applet found in the Control Panel. This dialog box allows the user to set the relative foreground/background responsiveness to one of the following:
<ul type=disc>
<li>
Best Foreground Application Response Time<br><br></li>
<li>
Foreground Application More Responsive than Background<br><br></li>
<li>
Foreground and Background Applications Equally Responsive</li>
</ul>
<h4>Don't starve your threads!</h4>
<p>
It is important to remember that the priority boost the foreground thread receives from the system can leave you open to starving your other threads or other threads in the system if you are not careful. Some developers incorrectly assume that because Windows NT has multiple threads of execution and asynchronous input queues, they no longer have to worry about their application taking over the system for long periods of time or starving other application's threads in the system. That is not true. Windows NT will not hang—you will still be able to task-switch away from the offending task, and the scheduler will time-slice the foreground thread out every so often; however, "hogging" the input queue will still cause the system to be unresponsive and is considered to be bad programming practice. If you have an unresponsive situation in your application, remember to call <b>PeekMessage</b> or another function that will give up the CPU time to the rest of the system. For instance, let's say that your application needs to populate a list box containing the phone numbers of all persons with the last name Jones. Querying for this will most likely take a very long time, but your application really cannot do anything else because it needs to list those names before it can go on. In this case, if you were to generate this list in response to a sent message, you would need to ensure that you call <b>PeekMessage</b> during your generation so you don't starve the rest of the threads in your application. Kyle Marsh's article <a href="msdn_user32.htm">"The New U: What's New in USER32,"</a> found in the Development Library, describes this thread starvation phenomenon and is accompanied by a sample that demonstrates how this condition can occur.</p>
<h3>Bringing a Window to the Foreground</h3>
<p>
If you have an application that currently uses <b>SetFocus</b> to bring a window created by another thread to the foreground, and you are porting this application to Win32, you have already noticed that <b>SetFocus</b> no longer sets the focus and returns NULL. Luckily, there is no reason to panic; you can still set the focus by using <b>SetForegroundWindow</b> instead. In Figure 1, if you want to programmatically switch the focus from the "MDI Demonstration" window to the Notepad window, you would use <b>SetForegroundWindow</b> to do so rather than <b>SetFocus</b> because the windows were created in different threads.</p>
<p>
By default, each thread has an independent input state (its own active window, its own focus window, and so forth). <b>SetActiveWindow</b> always logically sets a thread's active window state. To force a window to the foreground, however, use <b>SetForegroundWindow</b>. <b>SetForegroundWindow</b> activates a window and forces the window into the foreground. <b>SetActiveWindow</b> brings the active window into the foreground only if the thread is the foreground thread.</p>
<p>
Applications can call <b>AttachThreadInput</b> to allow a set of threads to share the same input state. By sharing input state, the threads share their concept of the active window. By doing this, one thread can always activate another thread's window. This function is also useful for sharing focus state, mouse capture state, keyboard state, and window z-order state among windows created by different threads whose input state is shared.</p>
<h2>Avoiding Message Deadlocking</h2>
<p>
<b>SendMessage</b> works differently under Windows NT than it does under Windows version 3.1. Under Windows version 3.1, <b>SendMessage</b> calls the window procedure corresponding to the window handle that it is passed. Under Windows NT, only the thread that created a window may process the window's messages. A thread that calls the <b>SendMessage</b> function to send a message to another thread cannot continue executing until the window procedure that receives the message returns. If the receiving thread yields control while processing the message, the sending thread cannot continue executing because it is waiting for <b>SendMessage</b> to return. This situation is called a <i>deadlock</i>. So, if a thread sends a message via <b>SendMessage</b> to a window that was created by a different thread, the first thread must wait for the second thread to be in a receiving state and handle the message for it.</p>
<p>
<img src="winthr_2.gif" border=0></p>
<p class=label>
<b>Figure 2. A deadlock condition</b></p>
<p>
In the previous illustration, Mr. Thread-one cannot respond to Mr. Thread-two because Mr. Thread-two has not given Mr. Thread-one the batteries he needs. And Mr. Thread-two cannot send the batteries back to Mr. Thread-one because Mr. Thread-two doesn't know what size batteries to send.</p>
<p>
(Please note: Any resemblance to any company's customer services is purely coincidental.)</p>
<p>
The previous deadlock condition may be prevented by using <b>SendNotifyMessage</b>. <b>SendNotifyMessage</b> behaves much like <b>SendMessage</b> except that it returns immediately. In fact, if you call <b>SendNotifyMessage</b> to communicate between two windows created in the same thread, <b>SendNotifyMessage</b> acts exactly like <b>SendMessage</b>. This may be an advantage if it is not important that the sent message be completed before the sending thread continues. Note that because <b>SendNotifyMessage</b> is asynchronous, pointers to any local variables must not be passed along because they will no longer be valid by the time the receiving thread attempts to look at them. This would result in a general protection (GP) violation when the receiving thread accesses the pointer.</p>
<p>
The following functions can be called by the receiving thread to yield control:
<ul type=disc>
<li>
<b>DialogBox</b><br><br></li>
<li>
<b>DialogBoxIndirect</b><br><br></li>
<li>
<b>DialogBoxIndirectParam</b><br><br></li>
<li>
<b>DialogBoxParam</b><br><br></li>
<li>
<b>GetMessage</b><br><br></li>
<li>
<b>MessageBox</b><br><br></li>
<li>
<b>PeekMessage</b></li>
</ul>
<p>
As mentioned above, if a window procedure yields control when processing a message sent by another thread, a message deadlock may result. To determine whether a message received was sent by another thread, call the <b>InSendMessage</b> function. If it returns TRUE, the window procedure must call the <b>ReplyMessage</b> function. By calling this <b>ReplyMessage</b>, the window procedure that receives the message allows the thread that called <b>SendMessage</b> to continue to run as though the thread receiving the message had returned control. The thread that calls the <b>ReplyMessage</b> function also continues to run. If the message was not sent through the <b>SendMessage</b> function or if the message was sent by the same thread, <b>ReplyMessage</b> has no effect. This is shown in the following example.</p>
<pre><code>case WM_USER + 105:
 &nbsp;&nbsp; // If this was sent by another thread, call ReplyMessage to
 &nbsp;&nbsp; // avoid a deadlock when calling DialogBox.
 &nbsp;&nbsp; if (InSendMessage())
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReplyMessage(TRUE);

 &nbsp;&nbsp; DialogBox(hInst, "MyDialogBox", hwndMain, (DLGPROC) MyDlgProc);
 &nbsp;&nbsp; break;
</code></pre>
<h2>New Functions</h2>
<p>
Windows NT includes some new functions that are designed to manage the changes in functionality and window management when including multiple threads in the user interface. These new functions will help you get around deadlocking problems and will allow you to share different information, such as key state and focus, among threads in the same process. Table 1 lists these functions and indicates whether each is supported in Win32s™. The sections following the table give descriptions of each new function, including any known problems. I have not included the new functions that don't involve window management or basic thread manipulation. For detailed information about general thread management, please refer to the <a href="msdn_threads.htm">"Multithreading for Rookies"</a> technical article by Ruediger Asche in the Development Library.</p>
<p class=label>
<b>Table 1. Win32s Support for New Win32 Functions Used for Window Management or Thread Manipulation</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=61%><b>Function</b></td>
<td class=label width=39%><b>Win32s Support</b></td>
</tr>
<tr valign=top>
<td width=61%><b>SendNotifyMessage</b></td>
<td width=39%>No</td>
</tr>
<tr valign=top>
<td width=61%><b>PostThreadMessage</b></td>
<td width=39%>Yes</td>
</tr>
<tr valign=top>
<td width=61%><b>SendMessageTimeout</b></td>
<td width=39%>No</td>
</tr>
<tr valign=top>
<td width=61%><b>SendMessageCallback</b></td>
<td width=39%>No</td>
</tr>
<tr valign=top>
<td width=61%><b>SendAsyncProc</b></td>
<td width=39%>No</td>
</tr>
<tr valign=top>
<td width=61%><b>EnumThreadWindows</b></td>
<td width=39%>Yes</td>
</tr>
<tr valign=top>
<td width=61%><b>EnumThreadWndProc</b></td>
<td width=39%>Yes</td>
</tr>
<tr valign=top>
<td width=61%><b>GetWindowThreadProcessId</b></td>
<td width=39%>Yes</td>
</tr>
<tr valign=top>
<td width=61%><b>AttachThreadInput</b></td>
<td width=39%>No</td>
</tr>
</table><br>
<h4>SendNotifyMessage</h4>
<p>
As we just saw, the <b>SendNotifyMessage</b> function sends the specified message to the given window. This function is identical to <b>SendMessage</b> if it is used to send a message to a window that was created in the current thread—it sends the message and does not return until the window procedure has processed the message. In the case of an interthread call, the send does not wait for a reply from the receiver; it simply returns a Boolean value indicating success or failure.</p>
<h4>PostThreadMessage</h4>
<p>
The <b>PostThreadMessage</b> function places (posts) a message in the message queue of the given thread and then returns without waiting for the thread to process the message.</p>
<p>
This function replaces the <b>PostAppMessage</b> function. In fact, in Win32, <b>PostAppMessage</b> is prototyped to be <b>PostThreadMessage</b>. New Win32 applications should use <b>PostThreadMessage</b> instead. The thread to which the message is posted retrieves the message by calling the <b>GetMessage</b> or <b>PeekMessage</b> function. The <b>hwnd</b> member of the returned <b>MSG</b> structure is NULL.</p>
<h4>SendMessageTimeout</h4>
<p>
The <b>SendMessageTimeout</b> function synchronously sends the specified message to the given window or windows. The function sends the message to the given window and does not return until the window procedure has processed the message or the specified time-out period has elapsed. If the window receiving the message does not belong to the same message queue as the current thread, the appropriate thread to receive the message is awakened and this function waits for a reply. If the thread does not respond or if the time-out value is exceeded, this function fails. If the window receiving the message belongs to the same message queue as the current thread, the time-out is ignored and the functionality is the same as it would be if <b>SendMessage</b> were called instead.</p>
<p>
In the following example, if the child window procedure (<b>ChildWindowProc</b>) were to execute the <b>SendMessageTimeout</b> and the parent window procedure (<b>ParentWindowProc</b>) called <b>SendMessage</b> to send a message to its child, <b>ChildWindowProc</b> would still be able to process the message because the SMTO_NORMAL flag is specified. The SMTO_NORMAL flag indicates that the calling thread can process other requests while waiting for <b>SendMessageTimeout</b> to return.</p>
<pre><code>ChildWindowProc(HWND hWnd, UINT msg, UINT wParam, LONG lParam)
{
 &nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp;&nbsp;&nbsp; case &lt;xxx&gt;:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessageTimeout( hWndParent,&nbsp;&nbsp; // Window handle
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WM_USER+100, // Message to send
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wParam,&nbsp;&nbsp; // First message parameter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lParam,&nbsp;&nbsp; // Second message parameter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SMTO_NORMAL,&nbsp;&nbsp; // Flag *
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100,&nbsp;&nbsp; // Time-out (in ms)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;ret ); // Return value
 &nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case WM_USER+101:
 &nbsp;&nbsp;&nbsp;&nbsp; &lt;time-consuming procedure&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
}

ParentWindowProc(HWND hWnd, UINT msg, UINT wParam, LONG lParam)
{
 &nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp;&nbsp;&nbsp; case WM_USER+100:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage( hWndChild,&nbsp;&nbsp;&nbsp; // Window handle
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WM_USER+101,&nbsp; // Message to send
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wParam,&nbsp;&nbsp;&nbsp; // First message parameter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lParam );&nbsp; // Second message parameter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AFunction();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
}
</code></pre>
<p>
If the processing of the message sent by <b>SendMessageTimeout</b> is interrupted, the countdown to the time-out will be suspended. Once a message or another system event is received and processed, the time-out will be restarted. In the above example, the receipt of the message WM_USER+101 by <b>ChildWindowProc</b> will cause the time-out to restart after the WM_USER+101 is processed.</p>
<p>
In the above example, if the function executed by <b>ParentWindowProc</b> takes longer than 100 milliseconds to return and awaken the thread that created the child window, the call to <b>SendMessageTimeout</b> will time-out and return. This means that any value that was to be returned to <b>ChildWindowProc</b> will not be returned.</p>
<p>
I should point out that online Help for the Win32 SDK mentions a third flag, SMTO_NORMAL, that is not listed in the printed Microsoft Win32 Software Development Kit (SDK) for Windows NT <i>Programmer's API Reference Volume 4</i>, the version in the Development Library. With SMTO_NORMAL, the calling thread is not prevented from processing other requests while waiting for the function to return.</p>
<h4>SendMessageCallback</h4>
<p>
The <b>SendMessageCallback</b> function sends the specified message to the given window or windows. The function sends the message to the given window and returns immediately. After the window procedure processes the message, the system calls the specified callback function, passing the result of the message processing and an application-defined value to the callback function.</p>
<h4>SendAsyncProc</h4>
<p>
A <b>SendAsyncProc</b> function is an application-defined callback function that the operating system calls when the <b>SendMessageCallback</b> function is called. The system passes the message to the callback function after passing the message to the destination window procedure. A value of type <b>SENDASYNCPROC</b> is a pointer to such a function. <b>SendAsyncProc</b> is a placeholder for an application-defined function name. A <b>SendAsyncProc</b> function is installed for calling by passing a <b>SENDASYNCPROC</b> pointer to the <b>SendMessageCallback </b>function. This callback function does not return a value.</p>
<h4>EnumThreadWindows</h4>
<p>
The <b>EnumThreadWindows</b> function enumerates all windows associated with a thread by passing the handle of each window, in turn, to an application-defined callback function. <b>EnumThreadWindows</b> continues until the last window is enumerated or the callback function returns FALSE.</p>
<p>
Note that the <b>EnumTaskWindows</b> function is now obsolete. It has been replaced by the <b>EnumThreadWindows</b> function. To maintain compatibility for older applications, <b>EnumTaskWindows</b> has been replaced with a macro that calls <b>EnumThreadWindows</b>. Older applications may continue to call <b>EnumTaskWindows</b>, but new applications should use <b>EnumThreadWindows</b>.</p>
<h4>EnumThreadWndProc</h4>
<p>
The <b>EnumThreadWndProc</b> function is an application-defined callback function that receives the window handles associated with a thread as a result of a call to the <b>EnumThreadWindows</b> function. The callback function can carry out any desired task. An application must register this callback function by passing its address to the <b>EnumThreadWindows</b> function. <b>EnumThreadWndProc</b> is a placeholder for the application-defined function name. To continue enumeration, the callback function must return TRUE; to stop enumeration, it must return FALSE.</p>
<h4>GetWindowThreadProcessId</h4>
<p>
The <b>GetWindowThreadProcessId</b> function retrieves the identifier of the thread that created the given window and, optionally, the identifier of the process that created the window. The return value is the identifier of the thread that created the window. The <b>GetWindowTask</b> function is now obsolete. It has been replaced by the <b>GetWindowThreadProcessId</b> function. To maintain compatibility for older applications, <b>GetWindowTask</b> has been replaced with a macro that calls <b>GetWindowThreadProcessId</b>. Older applications may continue to call <b>GetWindowTask</b>, but new applications should use <b>GetWindowThreadProcessId</b>. The macro that maps <b>GetWindowTask</b> to <b>GetWindowThreadProcessId</b> is:</p>
<pre><code>#define GetWindowTask(hwnd) ((HANDLE) GetWindowThreadProcessId(hwnd, NULL))
</code></pre>
<h4>AttachThreadInput</h4>
<p>
The <b>AttachThreadInput</b> function allows a thread to synchronize its input processing with another thread. Normally, windows created in different threads process input independently of each other, and they are not synchronized with the input processing of other threads. By using this function, a thread can attach its input processing to another thread. This allows a thread to share its input states and, for example, to call the <b>SetFocus</b> function to set the keyboard focus to a window of a different thread. In Windows 3.1, this capability is not possible.</p>
<p>
Creating a window can force an implicit <b>AttachThreadInput</b> when the parent windows of the window being created in the second thread were created in the first thread. When windows are created or set with a parent-child relationship between threads, the mouse and keyboard queues are attached.</p>
<p>
Because this function synchronizes input processing, you cannot use <b>AttachThreadInput</b> to attach to the Task Manager. The Task Manager must remain unsynchronized at all times in order to allow the user to bring an application to the foreground and to kill an application. In addition to the Task Manager, shell and system threads cannot be attached.</p>
<p>
As mentioned above, a call to <b>AttachThreadInput</b> allows, among other things, the sharing of key state information between two threads. It is important to note that the key state, which can be ascertained by calls to <b>GetKeyState</b> or <b>GetKeyboardState</b>, is reset after a call to <b>AttachThreadInput</b>. It is also important to note that <b>AttachThreadInput</b> does not take over the input queue from another thread. This means that the two threads still have separate input, and a call to <b>AttachThreadInput</b> will not force all window messages to filter into the same queue. If you need to pass all window messages from one message loop to another message loop, you will need to pass those messages on manually by sending the message yourself.</p>
<p>
<b>Known Problems</b></p>
<p>
Currently, if you start an application that calls <b>AttachThreadInput</b> to a thread in another process and reset the keyboard state via <b>SetKeyboardState</b> after detaching the threads, the call to <b>SetKeyboardState</b> will return TRUE, indicating success, but the key state is not successfully set. If the thread is in the same process, however, the call to <b>SetKeyboardState</b> does succeed and works as expected. This occurs because, when one thread is attached to another thread, the system creates a temporary message queue to keep a copy of the current key state information of the queue to which you are attaching. If you then set the key state, only the temporary queue key state is updated and the function call succeeds. Once you detach input processing, the temporary queue is removed and the key state change information is lost—it reverts to what it was before the attach. To work around this problem, you can either stay attached or use hooks. Microsoft is currently looking into a fix for this problem.</p>
<h2>The Final Word</h2>
<p>
I have created Table 2 as a quick reference to summarize the different methods of sending messages between threads. The first column lists the Win32 function, the second column lists the equivalent (or closely equivalent) Windows 3.1 function, and the third column lists the differences between the Win32 function and the Windows 3.1 function. In cases where no equivalent is applicable, the item is listed as such. In all cases, if you are writing a new application for Win32, you should use the new Win32 function rather than the Windows 3.1 function.</p>
<p class=label>
<b>Table 2. Win32 Messaging Functions and the Windows 3.1 Equivalents</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=32%><b>Win32 Function</b></td>
<td class=label width=24%><b>Windows 3.1 Equivalent</b></td>
<td class=label width=44%><b>Differences/Suggestions</b></td>
</tr>
<tr valign=top>
<td width=32%><b>AttachThreadInput</b></td>
<td width=24%>Not applicable</td>
<td width=44%>Because all windows are created in the same thread under Windows 3.1, input is inherently synchronized, so this function does not have a Windows 3.1 equivalent.</td>
</tr>
<tr valign=top>
<td width=32%><b>EnumThreadWindows</b></td>
<td width=24%><b>EnumTaskWindows</b></td>
<td width=44%>Tasks no longer exist under Win32. Use <b>EnumThreadWindows</b> for Win32 applications. The call will be mapped to <b>EnumTaskWindows</b> if your application is running under Windows 3.1. </td>
</tr>
<tr valign=top>
<td width=32%><b>GetWindowThreadProcessId</b></td>
<td width=24%><b>GetWindowTask</b></td>
<td width=44%>Tasks no longer exist under Win32. Use <b>GetWindowThreadProcessId</b> for Win32 and Win32s applications. The call will be mapped to <b>GetWindowTask</b> if your application is running under Windows 3.1.</td>
</tr>
<tr valign=top>
<td width=32%><b>PostMessage</b></td>
<td width=24%><b>PostMessage</b></td>
<td width=44%>No changes necessary.</td>
</tr>
<tr valign=top>
<td width=32%><b>PostThreadMessage</b></td>
<td width=24%><b>PostAppMessage</b></td>
<td width=44%>Use <b>PostThreadMessage</b> for Win32 and Win32s applications. The call will be mapped to <b>PostAppMessage</b> if your application is running under Windows 3.1.</td>
</tr>
<tr valign=top>
<td width=32%><b>SendMessage</b></td>
<td width=24%><b>SendMessage</b></td>
<td width=44%>No changes necessary.</td>
</tr>
<tr valign=top>
<td width=32%><b>SendMessageCallback</b></td>
<td width=24%><b>PostMessage</b> with the receiving window procedure posting back a reply.</td>
<td width=44%>There is really no exact equivalent to <b>SendMessageCallback</b> in Windows 3.1. <b>SendMessageCallback</b> allows an application to asynchronously send a message and call a callback function when the message is fully processed. </td>
</tr>
<tr valign=top>
<td width=32%><b>SendMessageTimeout</b></td>
<td width=24%><b>SendMessage </b></td>
<td width=44%>There is no exact equivalent to <b>SendMessageTimeout</b> in Windows 3.1. <b>SendMessageTimeout</b> allows an application to synchronously send a message and also to specify a time-out period for the message to be fully processed. This allows the application to be a bit more responsive than if it had to rely on <b>SendMessage</b>.</td>
</tr>
<tr valign=top>
<td width=32%><b>SendNotifyMessage</b></td>
<td width=24%><b>SendMessage</b> for windows in the same thread.<p>
<b>PostMessage</b> for inter-thread messaging.</p>
</td>
<td width=44%>There is no exact equivalent to <b>SendNotifyMessage</b> in Windows 3.1. <b>SendNotifyMessage</b> allows the application to send a message synchronously if the receiving and sending window are in the same thread and to send the message asynchronously if the windows are in different threads. This call is used to avoid a deadlock situation.</td>
</tr>
</table><br>
<p>
Now that you understand the implications of threads on window management, you can make your decision on where threads are appropriate to your application. Remember to weigh the benefits versus the costs of the threads, and remember, too, that adding threads can add complexity to your application. You will find that there may be areas in your application that will really benefit from processing in a thread, while other places may benefit from the use of synchronization objects instead. You may even find that, in looking for appropriate places to use threads, you can speed up execution of your application or make it more responsive by doing a bit of tidying up in your code. (I was going to say "tying up loose threads" instead of "tidying up"—aren't you glad I showed some restraint?)</p>
</BODY>
</HTML>
