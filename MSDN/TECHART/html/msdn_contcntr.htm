<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Notes on Implementing an OLE Control Container</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_contcntr"></a></sup>Notes on Implementing an OLE Control Container</h1>
<p>
Kraig Brockschmidt<br>
Microsoft Developer Relations</p>
<p>
Preliminary Version<br>
Created: September 21, 1994</p>
<p>
<i>Inasmuch as this is a preliminary version, mostly straight from my computer to yours, there will invariably be errors, omissions, inaccuracies, and other problems that a formal review would catch. Please forgive, but do report such problems to my Internet e-mail address: kraigb@microsoft.com. Please also understand that I do not have the resources to answer questions about this material personally. Questions should be handled through other means.</i></p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3183">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the CPATRON sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
Programming container applications that can interact and fully exploit OLE Controls is an important part of the developing component software market centered on OLE. This article, along with the accompanying sample code for CPatron, is intended to help you understand the architecture and technologies in OLE Controls more thoroughly and to provide detailed information on writing OLE Control Containers. The Control Development Kit with beta versions of Microsoft Visual C++™ 2.0 contains the necessary information about writing controls.</p>
<h2>Overview</h2>
<p>
I do assume in this article that you are already conversant in OLE 2 as it exists today, as well as versed in the OLE Controls specification itself. This paper is <i>not</i> a rehash of the specification, although I will extract some information from it to provide context as appropriate.</p>
<p>
The first section, "Control Container Architecture," goes into detail about exactly what a control container looks like from the point of view of a control. While we're at it, we'll also look at how a control looks to a container. This information will draw from the "OLE Control Architecture" paper that is Chapter 1 of the current CDK, but oriented more specifically toward grouping the various interfaces in the OLE Controls specification into subtechnologies. As we'll see, most of what's in the spec is not part of OLE Controls proper, but rather lower-level technologies that can, like any other set of interfaces in OLE, be used outside the context of controls altogether. So this section will look at the groupings of interfaces in both control and container that relate to various subtechnologies. This will lay the groundwork for looking at code.</p>
<p>
The next section, "The CPatron Sample Application," provides some notes about the sample application that is the basis for this document. Specifically, this section will describe how you can spot the differences between the control container and a regular in-place–capable compound document container. It also explains which parts of the consummate OLE Controls functionality were actually implemented and which were, well, punted for lack of time or suitable motivation.</p>
<p>
The final section, "Implementing a Control Container Step by Step," looks like many of the chapters from <i>Inside OLE 2</i>. We're creatures of habit, I suppose, so this section is written to provide a structured sequence for adding various features to a container. At any point you should be able to stop, compile, and run through some of your code to see if it is working the way you expect. At least that's what I hope—because this is a preliminary paper and sample code, I have not had the luxury of time to really test the presented sequence as the best one. So despite all my endeavors to do things right, expect that this section will have the most inaccuracies and errors because the information I'm working from to write this document—and the sample—is sketchy in places.</p>
<p>
So that's the disclaimer—on to the good stuff!</p>
<h2>Control Container Architecture</h2>
<p>
Although the purpose of this article is to describe the implementation of an OLE Control Container application, it helps to know what it is we're trying to contain. That is, what exactly is an OLE Control? To answer that question, we first need to look at what a control is in general, and what mechanisms are required to make it work. From there we can look at the control container side and see what is required of it. Then we can get into the real meat of this section which is to describe the interfaces and mechanisms through which controls and containers function.</p>
<h3>What Is a Control?</h3>
<p>
A control is mostly a collection of information and functionality that may also have a specific and dedicated user interface to allow an end user to manipulate it. Not only that, a control also allows itself to be manipulated programmatically so that another piece of code can use it to perform specific tasks. Controls are therefore self-contained units of information and functionality that are independent of where they actually reside. That is, a control of a specific type in one container behaves like another control of the same type in another container.</p>
<p>
A control describes its "information" through <i>properties</i>—named characteristics or values such as color, text, font, and so on. Properties can include not only visual aspects but also behavioral ones. For example, a button might have a property that indicates whether the button is momentary or push-on/push-off. In any case, a control's properties define its "state," and some or all of these properties may be persistent. Although the control can change its own properties, it is also possible that the container holding the control might change a property, in response to which the control would change its state, user interface, and so on. Note that some controls may wish to support structured information by supplying the appropriate formats through the <i>IDataObject </i>interface. Properties are best for exchanging one piece of information at a time. Data structures are best handled through <i>IDataObject.</i></p>
<p>
A control describes its "functionality" with two mechanisms: <i>methods</i> and <i>events</i>. <i>Methods</i> are simply functions implemented in the control that can be called from the container to perform some action. For example, an edit or other text-oriented control supports methods to allow the control container to retrieve or modify the current text, perhaps performing such operations as copy and paste with that control. In many cases a control uses its own methods to implement other parts of itself—it just exposes those methods to any container of that control as well.</p>
<p>
<i>Events</i>, on the other hand, are external actions that happen to a control that causes the control to call an event handler. The act of calling the event handler is termed "firing an event." Event handlers are nothing more than functions implemented by the container of the control which execute other actions in response to the event. In this way the control transforms mundane actions like keystrokes, mouse clicks, and elapsed timers into more meaningful programmatic events to which the container can attach user-defined code. The trick is writing a container that can handle an arbitrary event set for each contained control.</p>
<p>
Of course, besides just defining information and functions, a control must be able to define how it appears when visible in a container, and a container must communicate to the control when its size and other visual aspects of the control have changed. In the design of OLE Controls, there are five mechanisms, each with its own combination of interfaces and protocols, that control use to fulfill all their responsibilities
<ul type=disc>
<li>
<b>Control Properties. </b>A mechanism through which the container can retrieve and modify properties as well as call methods. The control must expose the names of properties as well as the names and parameters of its methods. This also includes control-supplied user interface to allow end users to manipulate properties.<br><br></li>
<li>
<b>Control Events. </b>A mechanism through which the control notifies the control container of events that occur in the control.<br><br></li>
<li>
<b>Control Visuals. </b>A mechanism through which the control draws itself but gives the container the responsibility to manage the control's position and dimensions.<br><br></li>
<li>
<b>Control Mnemonics. </b>A mechanism through which the control can specify and process its keyboard mnemonics and accelerators, such as alt+ key combinations and arrow keys. In addition, controls such as buttons and labels have special behavior requirements as far as accelerators are concerned.<br><br></li>
<li>
<b>Control Persistence. </b>A mechanism through which the control container can ask the control to save its current information into a storage or stream object.</li>
</ul>
<p>
As we'll see shortly, most of these mechanisms are provided by such current OLE 2 technologies as compound documents and automation, and new technologies defined in the OLE Controls specification fill in the rest.</p>
<h3>What Is a Control Container?</h3>
<p>
Simply said, a control container is an application that provides the necessary "sites" that can contain controls. Typically these sites all exist on the same document or "form." Having sites alone makes only a compound document container capable of embedding of linking objects into the sites. A control container goes further, however, to support the added control mechanisms.</p>
<p>
First of all, a control container exposes some of its own form properties to all the controls in the form. These are known as <i>ambient properties</i> because they define the ambiance of the control's surrounding environment. Using ambient properties, the container can specify the default colors, fonts, alignment, and behavioral suggestions. Controls may choose to retrieve these properties from the container at run time to integrate better into the form as a whole.</p>
<p>
As mentioned in the previous discussion on controls themselves, a container must also implement entry points for the object's events. The container must provide such points for the control's entire event set regardless of whether or not the container will perform any actions for those events. Providing all the entry points means that a control never has to make any special case considerations about whether it should fire an event: It just fires away and lets the container ignore them.</p>
<p>
The container, if it's interested, can also set up a <i>property notification sink</i> that the control calls whenever a property is about to change or has changed. This sink, in some circumstances, allows the container to veto the change of a property in the control.</p>
<p>
Besides dealing with properties and events, the container is also responsible for providing all the other facilities for object layout, ordering, and keyboard processing, because only the container is aware of all the objects in a form and the relationships between objects. It must also facilitate saving the document or form to a file for later reloading. If it so chooses, the container can provide additional user interface features for the registration and creation of controls (such as a dialog to add controls to the registry and a toolbar populated with buttons that represent the registered controls).</p>
<p>
It is also quite possible for the control container itself to be a control, but this article will not cover the additional considerations for such a component.</p>
<p>
All of these requirements together yields a list of six necessary mechanisms to make the container side of controls succeed:
<ul type=disc>
<li>
<b>Container Layout. </b>A mechanism to create, place, size, and order controls.<br><br></li>
<li>
<b>Container Form Persistence. </b>A mechanism through which to save and retrieve the persistent state of controls and the mapping of their events to container actions.<br><br></li>
<li>
<b>Container Ambient Properties. </b>A mechanism to expose ambient properties to all controls.<br><br></li>
<li>
<b>Container Event Handlers. </b>A mechanism to provide and expose event entry points to each specific control.<br><br></li>
<li>
<b>Container Extended Controls. </b>A mechanism for the container to wrap controls into an "extended control" that layers container-managed properties and methods on top of any other controls. This allows the container to treat all controls in a uniform fashion through those properties and methods.<br><br></li>
<li>
<b>Container Keyboard. </b>A mechanism to inform controls of accelerator and other keyboard events, as well as to handle special-purpose buttons and labels.</li>
</ul>
<p>
We're now in position to see which OLE technologies fulfill these requirements and those of controls.</p>
<h3>New Technologies in OLE Controls</h3>
<p>
For the most part, an OLE Control is an inside-out, in-place capable, in-process compound document object, with extra support for the additional control mechanisms. Yikes! If that noun stack in the previous sentence lost you, then let's try saying that a control has the following features:
<ul type=disc>
<li>
Is a compound document object<br><br></li>
<li>
Supports in-place activation<br><br></li>
<li>
Is marked as an inside-out object (usually includes "activate-when-visible" as well)<br><br></li>
<li>
Is usually implemented in a dynamic-link library (DLL) server (in-process servers and local servers are also possible, although the current Visual C++ Control Development Kit doesn’t support controls in local servers because there is no marshaling code for the new interfaces involved)<br><br></li>
<li>
Implements additional interfaces for control requirements<br><br></li>
<li>
Includes a type library to describe the control's properties, methods, and events</li>
</ul>
<p>
Likewise, a control container is also a compound document container—it is capable of working with compound document objects as well as controls. This includes not only all the embedding support and in-place activation support, but also support for events and properties.</p>
<p>
In short, a good portion of implementing controls and control containers is implementing compound document objects and containers. As described in "The CPatron Sample Application" section below, the sample control container accompanying this document began life as a full compound document container.</p>
<p>
You might think, then, that OLE Controls is a bunch of extensions to OLE Documents (the compound document) technology, and that all of OLE Controls builds on compound documents. <i>Au contraire</i>, my liege. The OLE Controls Specification defines a number of new technologies that are down on the COM and OLE Automation levels, as well as some that rest above compound documents. Table 1 describes the new technologies and OLE extensions included with the controls spec (along with the interfaces involved), and Figure 1 illustrates the relationships between these technologies and the core of OLE. You can see that some of the additional technologies, such as Connectable Objects and even Events, can be very useful without controls. It's just that these technologies were created for the purpose of controls, but like a good design for an OLE technology, the OLE Controls design created many more useful subtechnologies.</p>
<p class=label>
<b>Table 1. New Technologies Specified in OLE Controls</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Technology</b></td>
<td class=label width=46%><b>Purpose</b></td>
<td class=label width=30%><b>Interfaces, Functions</b></td>
</tr>
<tr valign=top>
<td width=24%>COM extensions</td>
<td width=46%>Adds self-registering objects, registry entries for toolbar images, versioning rules, and licensing support. (Versioning and licensing are deployment issues rather than mechanism issues, so they are not described further in this document. See the OLE Controls Specification.)</td>
<td width=30%>DllRegisterServer, DllUnregisterServer, IClassFactory2</td>
</tr>
<tr valign=top>
<td width=24%>Storage extensions</td>
<td width=46%>Adds a new persistence interface for initialized streams, rules for objects that serialize only into streams, and rules for saving persistent object data as straight text.</td>
<td width=30%>IPersistStreamInit</td>
</tr>
<tr valign=top>
<td width=24%>Automation extensions</td>
<td width=46%>ODL enhancements, standards for classifying and naming common properties and methods, and a mechanism to retrieve an object's type information.</td>
<td width=30%>IProvideClassInfo</td>
</tr>
<tr valign=top>
<td width=24%>Connectable Objects</td>
<td width=46%>A generalized mechanism through which advisory connections are established between some source object and some sink object.</td>
<td width=30%>IConnectionPoint, IConnectionPointContainer</td>
</tr>
<tr valign=top>
<td width=24%>Events</td>
<td width=46%>Standards for defining the event set of an object and connecting an event sink to the object.</td>
<td width=30%>(none)</td>
</tr>
<tr valign=top>
<td width=24%>Property Change Notification</td>
<td width=46%>A standard property change notification interface.</td>
<td width=30%>IPropertyNotifySink</td>
</tr>
<tr valign=top>
<td width=24%>Property Pages</td>
<td width=46%>Mechanisms to define object-controlled user interface for end-user property manipulation.</td>
<td width=30%>ISpecifyPropertyPages, IPropertyPage[2], OleCreatePropertyFrame-[Indirect], IPerProperty-Browsing</td>
</tr>
<tr valign=top>
<td width=24%>OLE Controls (Proper)</td>
<td width=46%>Extensions to compound documents to fill out the control requirements</td>
<td width=30%>IOleControl, IOleControlSite</td>
</tr>
</table><br>
<p>
<img src="contcntr_1.gif" border=0></p>
<p class=label>
<b>Figure 1.</b> <b>New technologies in OLE Controls extend OLE on all levels.</b></p>
<p>
We can now match up the mechanisms necessary for controls and control containers to their respective OLE technologies, as shown in Table 2. All the requirements are fulfilled using some core OLE technologies, while others depend, of course, on the new technologies. Note that some of the new technologies are not listed here because they are oriented more towards the deployment of controls rather than run-time interaction.</p>
<p class=label>
<b>Table 2. Technologies Used to Address Control and Container Requirements</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=31%><b>Requirement</b></td>
<td class=label width=69%><b>OLE Technologies Applied</b></td>
</tr>
<tr valign=top>
<td width=31%>Control Properties</td>
<td width=69%>Automation, Property Notifications, Property Pages, Connectable Objects</td>
</tr>
<tr valign=top>
<td width=31%>Control Events</td>
<td width=69%>Events, Automation, Connectable Objects</td>
</tr>
<tr valign=top>
<td width=31%>Control Visuals</td>
<td width=69%>Compound Documents</td>
</tr>
<tr valign=top>
<td width=31%>Control Mnemonics</td>
<td width=69%>OLE Controls</td>
</tr>
<tr valign=top>
<td width=31%>Control Persistence</td>
<td width=69%>Structured Storage (plus extensions)</td>
</tr>
<tr valign=top>
<td width=31%>Container Layout</td>
<td width=69%>Compound Documents, Drag &amp; Drop</td>
</tr>
<tr valign=top>
<td width=31%>Container Form Persistence</td>
<td width=69%>Structured Storage</td>
</tr>
<tr valign=top>
<td width=31%>Container Ambient Properties</td>
<td width=69%>Automation, Properties, OLE Controls</td>
</tr>
<tr valign=top>
<td width=31%>Container Event Handlers</td>
<td width=69%>Events, Automation</td>
</tr>
<tr valign=top>
<td width=31%>Container Extended Objects</td>
<td width=69%>OLE Controls, Property Pages [?]</td>
</tr>
<tr valign=top>
<td width=31%>Container Keyboard</td>
<td width=69%>OLE Controls</td>
</tr>
</table><br>
<p>
Combining all these technologies, we get pictures for both controls and container sites as shown. A control, shown in Figure 2, implements a number of additional interfaces besides <i>IOleObject</i>, <i>IDataObject</i>, <i>IViewObject2</i>, <i>IOleCache</i>, <i>IRunnableObject</i>, and <i>IOleInPlaceObject </i>(plus <i>IOleInPlaceActiveObject</i>), as is normal for a compound document object. A control adds either <i>IPersistStorage</i>, <i>IPersistStream</i>, or <i>IPersistStreamInit</i>; an <i>IDispatch</i> interface for methods and properties; <i>IProvideClassInfo </i>and <i>IConnectionPointContainer</i>,<i> </i>through which the container connects to events and property change notification; <i>ISpecifyPropertyPages </i>(optional); and <i>IOleControl </i>to fill out the set<i>. </i>That's a lot of interfaces, but we we'll see they all have their purposes in making controls work completely.</p>
<p>
<img src="contcntr_2.gif" border=0></p>
<p class=label>
<b>Figure 2. A control with new control-related interfaces</b></p>
<p>
A control container, shown in Figure 3, implements interfaces above and beyond what is normal for a compound document container. For compound documents, the container must implement <i>IOleInPlaceFrame</i> on its frame window and <i>IOleInPlaceUIWindow</i> on its document or form windows. OLE Controls doesn't affect these objects much, however, because most of the changes affect site objects. For compound documents, the site implements <i>IAdviseSink, IOleClientSite</i>,<i> </i>and <i>IOleInPlaceSite. </i>For controls the site adds an <i>IDispatch</i> interface for ambient properties, <i>IPropertyNotifySink</i> to detect changes in control properties, and <i>IOleControlSite </i>to complete the set. In addition, the site contains one or more conceptual "event sink" objects that each implement an <i>IDispatch </i>interface for a particular event set. However, as demonstrated in the CPatron sample, you can actually implement the events <i>IDispatch </i>interface on the site itself, provided you play a few games with <i>QueryInterface</i>.</p>
<p>
<img src="contcntr_3.gif" border=0></p>
<p class=label>
<b>Figure 3. A control container with new control-related interfaces</b></p>
<p>
The following sections describe the mechanisms of the new technologies defined in OLE Controls and how these interfaces on both controls and control containers are put to use.</p>
<h4>COM extensions</h4>
<p>
The enhancements to the COM level defined for OLE Controls is generally concerned with the deployment, registration, and creation of objects. Because this article focuses on what happens when we've already created an object (control), this section is intentionally kept minimal. To that end, the versioning and licensing enhancements such as the <i>IClassFactory2 </i>interface are not covered here—they are covered adequately in the OLE Controls Specification.</p>
<p>
One enhancement that is important for control containers is <i>Self-Registering Servers</i>—that is, servers that are able to create their own registry entries on request and therefore not rely on a separate .REG file. This allows even the registry information to be self-contained in the object, and the object can dynamically update the path entries based on where the module (.DLL or .EXE) is found. Because the registry is critical to OLE, self-registration removes the external dependency of a .REG file, without which an object would be useless.</p>
<p>
Did that last paragraph surprise you? Earlier I had mentioned that controls are considered in-process objects. For the most part that's true because the first release of OLE Controls (that is, the first release of the Control Development Kit) does not provide proxies and stubs (marshaling code) for the new control interfaces. So for the time being, a control has to be implemented in a .DLL. However, the COM enhancements for self-registering servers are not limited only to the scope of controls, but rather apply to <i>any</i> object servers whatsoever. Accordingly there are different rules for handling .DLLs and .EXEs, DLLs being the most straightforward.</p>
<p>
The reason that self-registration is important to a control container is that users of the container (typically programmers) will copy OLE Control files (.OCX) to their machines and thus need to have a way to get those controls registered. The control container should provide some user interface (usually something like the File Open dialog with a different caption and a "Register" button) in which these users can locate .OCX files. Once located, the container uses these COM extensions to ask the control to register itself. Furthermore, a control can include information about where the container can find a toolbar/toolbox bitmap for the control.</p>
<p>
Those readers who are familiar with Visual Basic Controls (.VBX) will see some parallels here, of course, because these COM extensions are meant to provide the same functionality while working off existing OLE technology (which means portability to 32-bits) rather than maintaining something separate.</p>
<p>
<b>Self-registering DLL servers</b></p>
<p>
A self-registering DLL server indicates that it supports this capability using the following constructs:
<ul type=disc>
<li>
A new value, "OleSelfRegister", in its version information<br><br></li>
<li>
An exported function: <b>HRESULT DllRegisterServer(void)</b><br><br></li>
<li>
An exported function: <b>HRESULT DllUnregisterServer(void)</b></li>
</ul>
<p>
The added value in the DLL's version information is necessary to allow other control containers to determine if a DLL is a self-registering server without actually loading the DLL (execution of <i>LibMain[32]</i> can potentially have negative side effects). In addition, the version information can allow future operating systems to detect a self-registering component when a file is copied to the system. As described in the OLE Controls spec, the "OleSelfRegister" string is included under the "StringFileInfo" section of a DLL's VS_VERSION_INFO structure. This structure, if you are unfamiliar with versioning APIs in Win32®, is obtained by calling <i>GetFileVersionInfoSize</i> and <i>GetFileVersionInfo</i>. (These are also available under Microsoft Windows version 3.1.)</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This article does not currently include any information about navigating through the version information to locate this key. When available, that information will appear in the last section of the article.</p>
<p>
Once the container has verified that the .DLL is, in fact, self-registering, it can go ahead and load that .DLL with <i>CoLoadLibrary</i>, get a pointer to <i>DllRegisterServer </i>using the Win32 API <i>GetProcAddress</i>, and call the registration function through that pointer. If registration succeeds, all the objects supplied from the server will be available to containers.</p>
<p>
If the container has a reason to unregister an object (for example, if the user decides the control is not worth using anymore), the container can use <i>GetProcAddress</i> to find and call <i>DllUnregisterServer</i>. The server, in response, will remove its registry entries created in <i>DllRegisterServer</i>. This is especially useful for developers to ensure that registry information is clean and consistent—they can unregister a control and re-register it to remove any potential glitches in the registry.</p>
<p>
<b>Self-registering EXE servers</b></p>
<p>
Because you cannot just arbitrarily load an .EXE file and call <i>GetProcAddress </i>to find a function, the simple model for .DLLs doesn't work for .EXE servers. Instead, OLE Controls specifies two command-line flags: /REGSERVER and /UNREGSERVER. If an .EXE is launched with either of these flags it is instructed to perform the registration or unregistration and terminate.</p>
<p>
A container can determine if an .EXE is self-registering using the same version information as .DLLs.</p>
<p>
<b>Registry entries of interest to containers</b></p>
<p>
For the most part, the registry entries for a control are like those of any other embeddable object: The control registers a ProgID key under which it stores its CLSID, and under the CLSID key it stores its "InProcServer[32]" entry along with verbs, MiscStatus, and so on. There are a few keys that are of specific interest to containers.</p>
<p>
First is the "Insertable" key. This may be registered under the control's ProgID, as well as under its CLSID, but is not required for all controls. Existing compound document containers check for the Insertable key in either location in order to populate their Insert Object dialog boxes. If a control includes this key, it indicates that it can be inserted into non-control container applications. Some controls, such as timers (which are practically useless without their events), would not show themselves to regular container applications.</p>
<p>
If a control only wants to appear to control containers, then it does not include the Insertable key, but instead includes a key named "Control" registered only under the CLSID key. Containers can use "Control" to populate an "Insert Control" dialog box that sits alongside "Insert Object." There are some cases for special-purpose controls that do not want to be exposed to any container other than those that have hard-coded the control's CLSID, and in such cases there may be neither Insertable nor Control in the registry. Be prepared for such.</p>
<p>
The other interesting keys added for controls are called "ToolboxBitmap" (Win16) and "ToolboxBitmap32" (Win32), which each have a value of a path to a DLL and a resource identifier. This works on the same order as the "DefaultIcon" entry for compound documents. This new key allows a container to extract a 16-by-16 button face image (16 * 15 in Win16?) for each registered control so that the container can create a toolbar or toolbox populated with controls, such as that from Visual Basic shown in Figure 4. Usually the DLL registered for ToolboxBitmap will be the same as the control DLL itself, and the container need only call <i>FindResource</i> and others to obtain the bitmap.</p>
<p>
<img src="contcntr_4.gif" border=0></p>
<p class=label>
<b>Figure 4. A toolbox with buttons for each registered control. This toolbox, taken from Visual Basic 3.0, uses VBX controls instead of OLE Controls, but the UI for a toolbox in a control container is exactly the same.</b></p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;At this time, this article does not cover implementation details about registering controls or providing user interface to locate or register them. The CPatron sample simply leverages its Insert Object dialog for creating controls, meaning that tools like TSTCON and REGSVR in the CDK are necessary to register them. Please see the CDK for more information about TSTCON and REGSVR.</p>
<h4>Storage extensions</h4>
<p>
Because controls are potentially very lightweight objects with few storage requirements, OLE Controls introduces additional features of persistent storage to handle both objects that persist to streams, as well as the ability for a container to save control information in a straight text stream.</p>
<p>
<b>Objects that persist to streams</b></p>
<p>
In the normal scheme of compound documents, an object implements the <i>IPersistStorage</i> interface for persistent storage purposes, and the object is given an entire <i>IStorage</i> into which it can write its information. Although this works well for heavyweight compound document objects, it is potentially an overkill for simple controls such as labels, which use very little storage space. For this reason OLE Controls allows an object to support persistence to an <i>IStream</i> as well, by implementing <i>IPersistStreamInit</i> instead of <i>IPersistStorage</i>. The object gets to choose which persistence model it would like to use—it is then up to the container to handle all the cases appropriately.</p>
<pre><code>interface IPersistStreamInit : public IPersistStream
 &nbsp;&nbsp; {
 &nbsp;&nbsp; HRESULT&nbsp; InitNew(void);
 &nbsp;&nbsp; }
</code></pre>
<p>
<i>IPersistStreamInit </i>is defined in OLE Controls because although <i>IPersistStorage </i>has an initialization function, <i>IPersistStream </i>does not. <i>IPersistStreamInit</i> is thus a simple extension of <i>IPersistStream</i> to accommodate initialization. If a control implements both interfaces (which it should, to be the most flexible), an <i>InitNew</i> call in one is equivalent to an <i>InitNew </i>call in the other.</p>
<p>
Again, a container should be prepared to handle objects that have <i>IPersistStreamInit</i> as well as those with <i>IPersistStorage</i>. More on this in a moment. First, however, we need a brief look at initialization functions. <i>IPersistStorage::InitNew</i>, <i>IPersistStorage::Load</i>, <i>IPersistStreamInit::InitNew</i>, and <i>IPersistStreamInit::Load </i>are considered "initialization" functions—that is, they must be the first functions called after object creation in order to properly initialize the object.</p>
<p>
For OLE Controls, there is a new MiscStatus bit called OLEMISC_SETCLIENTSITEFIRST. This bit applies only to control (and compound document objects as well) inasmuch as it relates to the <i>IOleObject::SetClientSite </i>function. With this bit set, the object indicates that it would like to use <i>SetClientSite</i> as its initialization function even before <i>IPersist[Storage | StreamInit]::[InitNew | Load]</i> is called. The reason is that a control may want to retrieve some of its container's ambient properties before loading, and the control needs the container's <i>IOleClientSite</i> pointer through which to <i>QueryInterface</i> for the ambient properties <i>IDispatch.</i></p>
<p>
However, this part of the OLE Controls spec is somewhat unclear and is problematic, so do not consider it final at this time. Given what I just said, a container generally will handle new object creation in this manner:</p>
<pre><code>ObjectCreationFunction
 &nbsp;&nbsp; {
 &nbsp;&nbsp; Get CLSID
 &nbsp;&nbsp; Create the object of the CLSID and ask for IUnknown
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (OLEMISC_SETCLIENTSITEFIRST)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QueryInterface(IOleObject)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IOleObject::SetClientSite
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; if (QueryInterface(IPersistStorage))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPersistStorage::InitNew
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create an IStream in the object storage

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (QueryInterface(IPersistStreamInit)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPersistStreamInit::InitNew
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }

SaveObject
 &nbsp;&nbsp; {
 &nbsp;&nbsp; if (QueryInterface(IPersistStorage))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPersistStorage::Save
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPersistStorage::SaveCompleted
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (QueryInterface(IPersistStream))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create stream in the object storage if needed
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPersistStream::Save
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPersistStream::SaveCompleted
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }

LoadObject
 &nbsp;&nbsp; {
 &nbsp;&nbsp; Create object uninitialized

 &nbsp;&nbsp; if (OLEMISC_SETCLIENTSITEFIRST)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QueryInterface(IOleObject)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IOleObject::SetClientSite
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (QueryInterface(IPersistStorage))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPersistStorage::Load
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (QueryInterface(IPersistStream))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Open object stream
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPersistStream::Load
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
</code></pre>
<p>
On the surface this looks good enough: We use the right interfaces for saving and loading the object, taking it upon ourselves as the container to create and manage a stream for the object if it only supports <i>IPersistStream[Init]</i>. However, there are some problems that are not yet resolved as of the writing of this article. A few things, however, can be said. If you have an object that is insertable into non-control containers, then you have to support <i>IPersistStorage</i> anyway, and it's a waste to support <i>IPersistStream</i> (and in fact, you shouldn't support the latter interface). If you use the cache in any way (so your control doesn't end up looking like a gray box when your DLL isn't available), the cache exposes <i>IPersistStorage</i> and the object must support it too. If the control is only insertable into control containers and doesn't use any caching, the control can choose to implement only <i>IPersistStream[Init]. </i>Some of the remaining issues surround the use of OLEMISC_SETCLIENTSITEFIRST, inasmuch as functions such as <i>OleCreate</i> and <i>OleLoad</i> are not sensitive to this flag, and passing an <i>IOleClientSite</i> to them is optional anyway. The internals of these functions are not documented either, so it's difficult for a container to replace its <i>OleCreate </i>and <i>OleLoad </i>calls with <i>CoCreateInstance. </i>A little more work is obviously needed in this area.</p>
<p>
<b>Save As Text</b></p>
<p>
Some control containers may want to save their form description files as straight text, including all the container's positional and state information as well as the object's persistent state. Visual Basic, for example, is just such a container—a .FRM file from VB looks something like the following:</p>
<pre><code>VERSION 2.00
Begin Form ControlDialog
 &nbsp; Caption&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; "Automation Controller"
 &nbsp; ClientHeight&nbsp; =&nbsp; 1665
 &nbsp; ClientLeft&nbsp;&nbsp; =&nbsp; 7035
 &nbsp; ClientTop&nbsp;&nbsp;&nbsp; =&nbsp; 1710
 &nbsp; ClientWidth&nbsp;&nbsp; =&nbsp; 3795
 &nbsp; Height&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 2040
 &nbsp; Left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 6990
 &nbsp; LinkTopic&nbsp;&nbsp;&nbsp; =&nbsp; "Form1"
 &nbsp; ScaleHeight&nbsp;&nbsp; =&nbsp; 1665
 &nbsp; ScaleWidth&nbsp;&nbsp; =&nbsp; 3795
 &nbsp; Top&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 1380
 &nbsp; Width&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 3885
 &nbsp; Begin CommandButton Animate
 &nbsp;&nbsp;&nbsp;&nbsp; Caption&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; "&amp;Animate..."
 &nbsp;&nbsp;&nbsp;&nbsp; Height&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 495
 &nbsp;&nbsp;&nbsp;&nbsp; Left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 240
 &nbsp;&nbsp;&nbsp;&nbsp; TabIndex&nbsp;&nbsp;&nbsp; =&nbsp; 4
 &nbsp;&nbsp;&nbsp;&nbsp; Top&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 960
 &nbsp;&nbsp;&nbsp;&nbsp; Width&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 1095
 &nbsp; End

...
</code></pre>
<p>
For this reason, OLE Controls defines how a control should prepare its persistent data for serialization as text. In short, the control provides, through its <i>IDataObject::GetData</i> function, a <i>property set</i> that the container can convert to text. To reload the control, the container reads the text, parses it into a property set, and calls <i>IDataObject::SetData. </i>Therefore it is the responsibility of the container to determine the actual text representation—the control simply says what data it wants to store.</p>
<p>
Remember that a property set in the context of persistent storage is not the same as properties of the control as handled through automation nor does it have anything to do with property pages. A property set is basically a flexible data structure and is fully documented in Appendix B of the <i>OLE 2.0 Programmer's Reference</i>. There is also an article titled “<a href="msdn_propset.htm">OLE Property Sets Exposed"</a> that is worth reading. The OLE Controls specification has the gory details about what values a control might put into this property set (and there are still some open question in the specs I'm looking at, so this feature is obviously incomplete at this time). The point, though, is that if a container is using a flat text file for its storage instead of a compound file, it needs to be able to handle property sets.</p>
<p>
Because this article is incomplete at this time, we will not discuss it further, nor does the CPatron sample do anything with Save As Text.</p>
<h4>Automation extensions</h4>
<p>
The extensions to OLE Automation found in OLE controls come under two headings: technological and societal. On the technical side, OLE Controls adds one new interface, <i>IProvideClassInfo</i>, through which a client can access an entire object's type information. OLE Controls also adds a few extensions to type libraries themselves, in the form of new Object Definition Language (ODL) attributes. On the social side, OLE Controls defines a number of additional standard methods and properties for objects along with classifications for such items. These additions apply mostly to controls but may be generally applicable to other automation objects—therefore they amend the existing property and method name standards as described in Volume 2 of the <i>OLE 2.0 Programmer's Reference</i>.</p>
<p>
<b>The IProvideClassInfo interface</b></p>
<p>
Normally if a client of an object wishes to retrieve the type information for an object, it has to retrieve the type library from the object's resource. This type information for the entire object describes the <b><i>coclass</i> </b>of the object as opposed to the <b><i>dispinterface</i></b> information available from <i>IDispatch::GetTypeInfo. </i>In other words, if a client has an object's <i>IDispatch</i> pointer it can, at best, retrieve the type information for the dispinterface attached to that <i>IDispatch</i> interface. Through <i>IDispatch</i> there really isn't a way to get at the coclass information for the object as a whole, through which the client could look at all the dispinterfaces implemented by that object.</p>
<p>
To make a client's life easier, because a control container needs the entire object's type information for various purposes, OLE Controls defines the new <i>IProvideClassInfo</i> interface:</p>
<pre><code>interface IProvideClassInfo : public IUnknown
 &nbsp;&nbsp; {
 &nbsp;&nbsp; HRESULT&nbsp; GetClassInfo(ITypeInfo **);
 &nbsp;&nbsp; }
</code></pre>
<p>
When a client calls <i>GetClassInfo</i> it obtains an <i>ITypeInfo</i> pointer for the whole object, as opposed to an <i>ITypeInfo</i> for a single dispinterface. Using this pointer, the client can navigate through the entire type library, looking for specific dispinterfaces with specific attributes (such as the new <b>Source </b>and <b>Default</b>). This may not seem important now, but it is critical in the mechanism through which a container connects to a control's event set, as described in the "Connectable Objects" section.</p>
<p>
You might wonder why the object itself doesn't directly implement <i>ITypeInfo</i>. The reason is that the object will typically have a type library already and the <i>ITypeInfo </i>interface that is needed here is readily available from that library. Second, the type information is conceptually part of a type library, not another interface on an object, so there must be a separation with regard to <i>QueryInterface</i>. Finally, implementing <i>ITypeInfo </i>is nontrivial, so asking objects to do this would make not a few people quite angry.</p>
<p>
<b>ODL extensions</b></p>
<p>
For the purposes of event and property handling, OLE Controls defines a few extensions to the type library technology in OLE Automation. This really doesn't affect automation functionally, but extends the Object Definition Language (ODL) used to create an object's type library. A control uses a type library to describe its properties, methods, and events to willing containers.</p>
<p>
OLE Controls adds a number of attributes to ODL as described in the spec. These are <b>Bindable</b>, <b>RequestEdit</b>, <b>DefaultBind</b>, <b>DisplayBind</b>, <b>Licensed</b>, <b>Source</b>, <b>Restricted</b>, and<b> Default</b>. The first four attributes apply to specific properties; the latter four apply to coclass entries in the type library instead, that is, they apply to dispinterfaces as a whole rather than specific portions of those dispinterfaces.</p>
<p>
Some of these new attributes build a necessary base for the Properties technology described below. <i>Bindable</i> means that the object that implements a property with this attribute will send an "OnChanged" notification (see <i>IPropertyNotifySink</i>) when it changes. <i>RequestEdit</i> means that the object will send a "RequestEdit" notification (again, see <i>IPropertyNotifySink</i>) <i>before </i>changing the property, allowing the property sink to cancel the change. <b>DefaultBind</b> and <b>DisplayBind</b> are important for what are called "data-bound" controls that are tied to some section of a database as a source for their data, and these attributes specify certain characteristics for handling these properties.</p>
<p>
Of more interest to control containers is the <i>Source</i> attribute. Any dispinterface marked as such in an object's type library means that the control doesn't implement this interface itself—rather, it is marking this interface as one that it would like to <i>call </i>in some other <i>sink</i> object. This is called an "outgoing" interface. In other words, the object uses the <i>Source</i><b> </b>attribute to define interfaces it would like to call when, say, events occur. While an object can specify any number of outgoing interfaces it can only mark one as <i>Default</i> as well. The <i>Default Source</i> dispinterface in an object's type information is defined as the object's event set (we'll see this in "Events" below).</p>
<p>
Finally, <i>Restricted</i> is an attribute that a control can assign to an interface to hide it from macro programming languages. That is, restricted interfaces cannot be called from arbitrary automation client code, because a client tool does not expose this interface to the programmer. Sometimes an interface is only to be used internally by clients that know more about the automation object than a generic programming client would, so this attribute allows the object to protect itself.</p>
<p>
<b>Additional property and method standards</b></p>
<p>
First of all, OLE Controls defines a categorization scheme for methods, properties, and even events (event standards are briefly mentioned in the "Event Standards" section, as you might expect). Categorization is done using two qualities: location and variety.
<ul type=disc>
<li>
<b>Location</b> is nothing more than a fancy way of describing where a property or method is implemented. There are three locations: control, extended, and ambient.<ul type=disc>
<li>
<b>Control properties </b>are, as you might have guessed, implemented on the control.<br><br></li>
<li>
<b>Extended properties </b>are those that a container implements on its own "extended controls" that augment the properties from an actual control.<br><br></li>
<li>
<b>Ambient properties </b>are those that the container implements on its own site objects, providing an environmental description to the controls in those sites.</li>
</ul>
</li>
<li>
<b>Variety</b> is a way to describe how strictly an implementor of a property must follow the contract defined for that property.<ul type=disc>
<li>
<b>Standard properties</b> are those that, if you implement them, you absolutely must guarantee a standard behavior. These properties are identified by negative DISPIDs, not by name.<br><br></li>
<li>
<b>Common properties</b> are more lax than standard ones—they have a suggested, but not a strict, behavioral contract.<br><br></li>
<li>
Everything else falls under the <b>other properties </b>category, meaning that they are specific to the implementation of the control or container.</li>
</ul>
</li>
</ul>
<p>
The OLE Controls specification lists a number of standard and common properties for controls, standard extended control properties, and standard ambient properties. It does not define any common extended control or ambient properties, nor does it define any "other" properties whatsoever. Microsoft does reserve the right to define new standard and common properties in the future, but you are free to define any "other" properties you want.</p>
<p>
This article will not repeat the tables of the OLE Controls-defined standards, which are already in the spec.</p>
<h3>Connectable Objects</h3>
<p class=indent>
"While OLE 2 COM defines a general mechanism (<b>IUnknown)</b> for objects to implement and expose functionality in interfaces, it does not define a general method for objects to incorporate external interfaces. That is, COM defines how <i>incoming </i>pointers to objects (pointers to that object's interfaces) are handled, but it does not have an explicit model for <i>outgoing</i> interfaces (pointers the object holds to other objects' interfaces). Instead, ad hoc solutions are invented where needed."</p>
<p>
So begins the section on "Connectable Objects" in the OLE Controls specification. The problem is that the only existing notification mechanisms in the core OLE technologies (referred to as the "ad hoc solutions") are very limited in scope. The only sink interfaces in the core OLE are <i>IAdviseSink</i> and <i>IAdviseSink2</i>,<i> </i>whose members are only applicable to <i>IDataObject</i>, <i>IOleObject</i>, and <i>IViewObject[2]. </i>This is not an extensible architecture; hence the need for Connectable Objects.</p>
<p>
<b>Connection points</b></p>
<p>
A connectable object is one that knows all of the possible outgoing interfaces it would like to expose what is called a "connection point" for each of those outgoing interfaces. Each connection point is conceptually another object with one interface, <i>IConnectionPoint</i> as illustrated in Figure 5. I say “conceptually” because the main object itself doesn’t have to explicitly create separate sub-objects for each connection point. It can easily implement <i>IConnectionPoint</i> once on itself that can handle any outgoing interfaces. Objects that do so, however, must not return <i>IConnectionPoint </i>from its main <i>QueryInterface</i>, and the <i>QueryInterface</i> function in <i>IConnectionPoint</i> should not return any pointers other than <i>IUnknown</i> and <i>IConnectionPoint</i>, thereby making the connection point interface look like a different object. This is something on the same order as handling <i>IOleInPlaceActiveObject</i>.</p>
<pre><code>interface IConnectionPoint : public IUnknown
 &nbsp;&nbsp; {
 &nbsp;&nbsp; HRESULT&nbsp; GetConnectionInterface(IID *);
 &nbsp;&nbsp; HRESULT&nbsp; GetConnectionPointContainer(IConnectionPointContainer *);
 &nbsp;&nbsp; HRESULT&nbsp; Advise(IUnknown *, DWORD *);
 &nbsp;&nbsp; HRESULT&nbsp; Unadvise(DWORD);
 &nbsp;&nbsp; HRESULT&nbsp; EnumConnections(IEnumConnections *);
 &nbsp;&nbsp; }
</code></pre>
<p>
<img src="contcntr_5.gif" border=0></p>
<p class=label>
<b>Figure 5. A connection point object</b></p>
<p>
So, for example, if some object wanted to expose two outgoing interfaces, <i>IOutOne </i>and <i>IOutTwo</i>, it would conceptually contain two separate connection points for those interfaces where each connection point is tied to a single outgoing IID—the one returned from <i>IConnectionPoint::GetConnectionInterface</i>.</p>
<p>
When a client wants to connect to an object's outgoing interface, that client instantiates an object called the "sink," which implements<i> </i>the outgoing interface. The client then locates the appropriate connection point for that interface and calls <i>IConnectionPoint::Advise</i>, passing to it the sink's interface pointer. The connection point holds onto this sink pointer (returning a connection "key" in the DWORD * parameter), and when the right events occur, it calls the appropriate member of that outgoing interface on the sink. Thus the client receives the function call. This relationship is illustrated in Figure 6.</p>
<p>
<img src="contcntr_6.gif" border=0></p>
<p class=label>
<b>Figure 6. A connection point connected to a sink object</b></p>
<p>
Note that a single connection point is capable of "multicasting"— that is, capable of connecting to multiple sinks, as shown in Figure 7. Whenever any function in one sink is called, the same function in every other sink is called as well.</p>
<p>
<img src="contcntr_7.gif" border=0></p>
<p class=label>
<b>Figure 7. A connection point connected to multiple sink objects must "multicast" outgoing calls.</b></p>
<p>
When the client is no longer interested in receiving these calls from the object, it calls <i>IConnectionPoint::Unadvise</i> (with the DWORD connection key from <i>Advise</i>), which terminates the connection. A caller can also learn of all the current connections to the same connection point through <i>EnumConnections</i>, which returns an enumerator that enumerates <i>IUnknown</i> pointers that are each tied to implementations of the outgoing interface.</p>
<p>
The other function,<i> GetConnectionPointContainer</i>, returns a pointer to an interface called <i>IConnectionPointContainer</i> that is implemented on what is called (you guessed it) a "connection point container." This allows navigation from a connection point to the full object that manages it and any other connection points on that same object.</p>
<p>
<b>The "Connection Point Container"</b></p>
<p>
The previous discussion about connection points is all well and good, except for one minor detail that I intentionally glossed over. I said that the client "locates the appropriate connection point for [the outgoing] interface," which begs the question, "How does a client locate the connection point?"</p>
<p>
The answer is the <i>IConnectionPointContainer</i> interface, which an object (also called the "source" in this context) implements alongside all its other interfaces (meaning it is available through <i>QueryInterface</i> from the object’s main <i>IUnknown</i>).</p>
<pre><code>interface IConnectionPointContainer : public IUnknown
 &nbsp;&nbsp; {
 &nbsp;&nbsp; HRESULT&nbsp; EnumConnectionPoints(IEnumConnectionPoints *);
 &nbsp;&nbsp; HRESULT&nbsp; FindConnectionPoint (REFIID, IConnectionPoint **);
 &nbsp;&nbsp; }
</code></pre>
<p>
Figure 8 illustrates the relationship between the <i>IConnectionPointContainer</i> interface on an object and its conceptual connection points.</p>
<p>
<img src="contcntr_8.gif" border=0></p>
<p class=label>
<b>Figure 8. A connection point container internally maintains all the individual connection points that are available through the </b><i>IConnectionPointContainer </i><b>member functions.</b></p>
<p>
With this interface, a caller can either try to locate a specific connection point for a known outgoing interface IID using <i>FindConnectionPoint</i>,<i> </i>or can enumerate all the possible outgoing interfaces for the object using <i>EnumConnectionPoints</i>. This latter function supplies an enumerator with the interface <i>IEnumConnectionPoints</i> which the caller can use to retrieve all the <i>IConnectionPoint</i> interfaces for the object (that is, all the connection points themselves). With each <i>IConnectionPoint</i>, the caller can then use <i>GetConnectionInterface</i> to learn the IID of that connection point.</p>
<p>
You might wonder why there is a conceptual separation of the connection point and the connection point container. It would have been possible to combine the two to eliminate the individual connection points and just put the <i>Advise </i>members in the connection point container. However, this does not allow for extensibility of the connection point itself, which may, in the future, want to implement additional interfaces. OLE is meant to be fully extensible, and this is just another manifestation of that principle.</p>
<p>
The sink interface passed to <i>IConnectionPoint::Advise</i> must have a <i>QueryInterface</i> that responds to the IID of the connection point. This is especially important for connection points that handle dispinterfaces, as <i>QueryInterface</i> must respond not only to <i>IUnknown </i>and <i>IDispatch</i> but also to the connection point IID.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The specifications mention some considerations surrounding aggregate objects and <i>IConnectionPointContainer</i>. This information is buried in the "Implementing Events with Connections" section, but is important mostly to the Connectable Objects, and belongs there.</p>
<p>
This is all well and good again, but begs another question: "How does a client know the IID it wants to connect to?" Excellent question! There are two possible answers:
<ul type=disc>
<li>
The client assumes that the object supports a connection point for an interface known at compile time. For example, control containers assume that controls support the <i>IPropertyNotifySink</i> interface as an outgoing interface, and can pass <i>IID_IPropertyNotifySink</i> directly to <i>FindConnectionPoint</i> (as we'll see in the "Properties" section).<br><br></li>
<li>
The client uses the object's type information to find the IID of an outgoing dispinterface. A control provides the IID of its event set in this fashion.</li>
</ul>
<p>
The first answer is easy to work with—it's like passing an IID to <i>QueryInterface</i>. The second is a little trickier, because as a client you need a mechanism to look for the IID you want, without having to load the object's type library from its DLL or EXE. That mechanism is exactly what the <i>IProvideClassInfo </i>interface was created for, as described earlier under "Automation Extensions."<i> </i>The <i>ITypeInfo</i> interface returned from <i>IProvideClassInfo::GetClassInfo</i> is the interface on the object's entire type library. With this pointer you can call <i>ITypeInfo::GetTypeAttr </i>to look for an interface with the <b>Source</b> attributes and call <i>GetRefTypeOfImplType </i>and <i>GetRefTypeInfo </i>to retrieve the <i>ITypeInfo</i> interface for that particular interface. Outgoing interfaces can be standard COM type interfaces or dispinterfaces. Only one, however, can be marked with the <b>Default</b> attribute that makes it the primary “event set.”</p>
<p>
Confusing? Well, we'll see how this actually works when we look at the control container's implementation later on for connection to an object's event set. The important point here is that once you have an <i>ITypeInfo</i> for a dispinterface, you can call <i>ITypeInfo::GetTypeAttr</i>, which returns a pointer to a TYPEATTR structure, and in that structure is a field called <i>guid</i>, which is the IID of that dispinterface. This is the IID you want to pass to <i>IConnectionPointContainer::FindConnectionPoint</i> to start the process of connecting your sink interface to an object's event set. In fact, we're now in position to fill out our knowledge of the events mechanism.</p>
<h4>Events</h4>
<p>
If you've read the previous sections you already know two key points about events:
<ul type=disc>
<li>
An object's "primary event set" is defined as the interface in the object's type library that is marked with both <b>Default </b>and <b>Source</b> attributes. In the later section on implementing a control container, we'll see exactly how to find this particular interface.<br><br></li>
<li>
A sink connects its implementation of an event set by using connection points, and retrieves the IID of event sets by navigating through <i>ITypeInfo </i>interfaces looking for those marked <b>Source</b> (and <b>Default</b>). Again, in the implementation section we'll see how to do this.</li>
</ul>
<p>
There are some additional points we have not yet seen:
<ul type=disc>
<li>
An object can actually have any number of other event sets or outgoing interfaces. These can be dispinterfaces (where each is marked with the <b>Source</b> attribute in the type library) or other predefined vtable-based interfaces with a known IID and known function signatures. Only one event set, however, can be the default, and thus only one is the primary event set.<br><br></li>
<li>
Outgoing interfaces are not necessarily event sets just because they are outgoing. <i>IPropertyNotifySink</i> is an example of an interface that relates to the Properties technology instead of events. Usually outgoing dispinterfaces are event sets, but other vtable-based interfaces are not.<br><br></li>
<li>
The "sink" object implementing the event set is conceptually a stand-alone object contained inside the sink. For convenience, however, the events dispinterface is readily implemented on the site object itself, but this requires that <i>QueryInterface </i>must be carefully implemented on a sink. For example, a site object in a control container will have an <i>IDispatch </i>for ambient properties; this is the <i>IDispatch </i>pointer that is returned from <i>QueryInterface</i> through, say, <i>IOleClientSite. </i>When the events <i>IDispatch</i> is part of the site object as well, there seems to be a conflict, because there can be only one <i>IDispatch</i> seen through <i>QueryInterface</i>. By definition, the site's <i>QueryInterface </i>handling of <i>IDispatch </i>returns the ambient properties <i>IDispatch</i>. A <i>QueryInterface</i> on the events <i>IDispatch</i> responds only to <i>IID_IUnknown</i>,<i> </i>the events <i>IID_IDispatch</i>, and the event set IID, isolating it from the rest of the site.</li>
</ul>
<p>
Note also that a sophisticated control container should locate all event sets—that is, all "source" interfaces for a control—and allow the end user to attach code to any event in any event set. This allows controls to separate their events into logical groupings instead of forcing them into a single interface. CPatron does not demonstrate this, but you should be able to readily expand the idea of looking for the "default source" interface to all "source" interfaces.</p>
<p>
It is highly convenient for event sets to be dispinterfaces because an arbitrary sink can provide all the necessary <i>IDispatch</i> entry points at compile time. This means that a sink doesn't have to figure out how to dynamically create function entry points in memory with the proper calling conventions and stack handling of parameters in order to use events. Implementing <i>IDispatch</i> is easy, on the other hand, because all the function signatures are known at compile time. So just the presence of the interface allows a source of events to fire those events to the sink, and the sink will receive the <i>IDispatch::Invoke</i> calls. It is here that the interesting work takes place.</p>
<p>
If the sink doesn't want to do anything with events, it can simply ignore all <i>Invoke</i> calls but return NOERROR from <i>Invoke</i>, meaning that it "handled" the event (it just didn't do anything with it). The source is happy because it was able to fire the event, and it really doesn't care what happens with that event—it was "handled." So the sink then has the freedom to pick and choose what events it will assign to some other actions.</p>
<p>
In the realm of controls, the control container (which implements the sink) can present the end-user (a programmer) with the list of events that will come from the control. The user can then write code to attach to those events, where that code can do anything within the scope of the container. CPatron, for example, allows the user to assign a different system beep to each event—mundane, yes, but it illustrates the technique. Whenever CPatron sees a DISPID in its events <i>IDispatch</i>, it looks for an assigned system beep for that ID and generates the sound if one exists. More sophisticated containers will do pretty much the same thing, except that instead of mapping event IDs to beeps, they map the IDs to user-defined code. If code exists, the container executes it. If no code exists, nothing happens. So the whole process is one of the control calling the sink's <i>IDispatch</i>, which then executes user-defined code that is provided through some type of language or other programming facility. This process is what the OLE Controls spec calls "Language Integration."</p>
<p>
<b>Event persistence</b></p>
<p>
As far as a control is concerned, its events have no persistent state, they just exist to be fired when a sink is connected to the events connection point. The only persistent information surrounding events relates to the actions assigned to events by a control container. It is therefore the container's responsibility to save, as part of the form or document, the mappings from event ID to user-defined actions, and the container can do this in any manner it chooses—OLE Controls defines no standards for event mapping serialization.</p>
<p>
One consideration in keeping persistent event information is that a control's event set might change from instantiation to instantiation. This is perfectly legal, and a container must be robust enough to handle such cases. This means that when an event no longer exists for a control it will never be fired, and the container should do something intelligent with whatever actions were assigned to that event. CPatron, for example, just discards the event mapping when the document is next saved. Containers that attach user-defined code to events should take that code and store it as a global function instead of as an event handler, rather than just junking the code. Programmers get very angry if code they spent a long time writing disappears unexpectedly and without explanation. Alternately, a container may warn the user that the event set has changed. In any case, a container must be robust in all circumstances, both when new events appear and when existing ones disappear. (Note that technically a control should not change its event set without changing the interface ID of that outgoing interface. However, a container may not save the IID persistently, especially if it always looks for the “default source” interface. The IID therefore becomes somewhat irrelevant, and the container must handle changes robustly.)</p>
<p>
<b>Event types and standards</b></p>
<p>
The OLE Controls specification contains sections describing types of events—<b>Request</b>, <b>Before</b>, <b>Do</b>, and <b>After</b>—as well as standards for common events that should be the same in all controls that might generate them ("Click" is an example). The specification describes in detail the meaning of the event types and standard events, as well as the mechanism through which a container can control whether or not a control performs default handling of a <b>Do</b> event. In addition, there are some notes about event sequences—situations may arise in which a control ignores changes to properties or calls to methods if they are done in response to an event that is nested in a sequence of related events. A container must be robust in the event (pun only vaguely intended) of failures.</p>
<p>
At this time, this article will not examine these issues any further. I encourage you to study the specs if you are interested.</p>
<h4>Property change notification</h4>
<p>
Although OLE Automation handles properties very well, the one thing it doesn't provide for is a method through which a client of an object is notified of a change in an object's "bindable" properties. This is important for a control container in case it needs to update its own state or some other data when such changes occur—for example, if a "data-bound" control (one whose data is linked to a database query or some such thing) is displaying records from a database and allows the user to change the data in the control. Such a change should trigger a notification to the container so that the container can make an update to the real underlying database.</p>
<p>
An object that includes properties marked with the <b>Bindable </b>attribute in its type library will be capable of generating a change notification for that property. To facilitate this, the object exposes a connection point for the new interface defined in OLE Controls called <i>IPropertyNotifySink</i>:</p>
<pre><code>interface IPropertyNotifySink : public IUnknown
 &nbsp;&nbsp; {
 &nbsp;&nbsp; HRESULT&nbsp; OnChanged(DISPID);
 &nbsp;&nbsp; HRESULT&nbsp; OnRequestEdit(DISPID);
 &nbsp;&nbsp; }
</code></pre>
<p>
This interface has two kinds of notification. The first happens with <i>OnChanged</i>, which informs the sink that the property with the given DISPID has already changed, so that if the object was asked for that property within the implementation of <i>OnChanged</i>, the object would return the new value. As far as the sink is concerned, it doesn't care what caused the change, only that the change occurred—the object should call <i>OnChanged </i>regardless of the reason for the change.</p>
<p>
The second kind of notification handles property changes that the sink (or client, or container) is allowed to cancel before the property is actually changed. When a property is about to change, the object calls <i>OnRequestEdit </i>with the DISPID of the property, to which the sink responds with S_TRUE or S_FALSE (or any other error code). Returning S_TRUE (or S_OK, or NOERROR) means that the sink will allow the change to occur. The change then takes place, which generates an <i>OnChanged</i> call. If S_FALSE or any other error is returned, the sink will <i>not</i> allow the change, and the object must prevent the change from happening altogether. If an object is to implement cancelable property changes, it must guarantee the contract and <i>OnRequestEdit</i> must be called before the change happens. It is not a strict requirement, mind you, that properties be cancelable—if they are not, for whatever reason, the object can just change them and send <i>OnChanged</i>.</p>
<p>
A special parameter to both <i>OnChanged</i> and <i>OnRequestEdit</i> is DISPID_UNKNOWN. This means that a large number of properties may be changing at once, in response to which the sink should iterate through all the properties of interest to it and check for changes.</p>
<p>
Note also that changes are not sent from objects that are being created, initialized, or deserialized—notifications are sent only for changes that occur to fully constructed and initialized objects.</p>
<p>
A note about data validation: You might think that <i>OnRequestEdit </i>could be used for validation in certain controls like a text box or combo box. In other words, it seems that a container might use <i>OnRequestEdit </i>to determine when validation should take place, so that if validation fails, the container can return S_FALSE from <i>OnRequestEdit</i>. Not so! The catch is that when <i>OnRequestEdit </i>is called, the container has no access to the new value; only the old. Therefore this function cannot be used for validation. If a control wants to support validation at all (only a few types will), that control will support relevant events such as "Validate" or "BeforeLoseFocus." The container would allow the user to place validation code in the handlers for these events.</p>
<h4>Property pages</h4>
<p>
[This subject deferred because I have not yet worked on property pages. Please see the OLE Controls spec for details about property pages.]</p>
<h4>OLE Controls</h4>
<p>
The glue that binds together all the OLE technologies, extensions to them, and the new technologies described above, is OLE Controls. As I mentioned before, "OLE Controls" in a strict sense is the set of extensions above compound documents for dealing with control-type objects. "OLE Controls"—the <i>specification</i>—<i> </i>is simply where all this new stuff is defined. My purpose in saying this is to emphasize the fact that you do not need a proper control object to use events, connection points, property pages, and so on. Only when you add the final touches of a few extra interfaces do you enter the realm of OLE Controls proper.</p>
<p>
This section will first look briefly at the control-specific interfaces <i>IOleControl </i>and <i>IOleControlSite</i>. After that, we'll take a look at how specific members of these interfaces provide the needed mechanisms, such as keyboard handling, to make control integration complete. To be perfectly honest, there's not a tremendous amount of content here, no more than some of the other technology sections above. Much of what makes a control involves the COM, Automation, and Properties and Events. Here we wrap it all together into a meaningful unit, leaving some small considerations, such as Z-order of in-place windows, for the implementation section.</p>
<p>
<b>The IOleControl and IOleControlSite interfaces</b></p>
<p>
These two new interfaces extend the communication that normally happens between a container and an object in standard compound document scenarios. A control will implement <i>IOleControl </i>alongside <i>IOleObject</i> and other interfaces, while a container will implement <i>IOleControlSite</i> alongside <i>IOleClientSite</i> and friends:</p>
<pre><code>interface IOleControl : public IUnknown
 &nbsp;&nbsp; {
 &nbsp;&nbsp; HRESULT&nbsp; GetControlInfo(CONTROLINFO *);
 &nbsp;&nbsp; HRESULT&nbsp; OnMnemonic(LPMSG);
 &nbsp;&nbsp; HRESULT&nbsp; OnAmbientPropertyChange(DISPID);
 &nbsp;&nbsp; HRESULT&nbsp; FreezeEvents(BOOL);
 &nbsp;&nbsp; }

interface IOleControlSite : public IUnknown
 &nbsp;&nbsp; {
 &nbsp;&nbsp; HRESULT&nbsp; OnControlInfoChanged(void);
 &nbsp;&nbsp; HRESULT&nbsp; LockInPlaceActive(BOOL);
 &nbsp;&nbsp; HRESULT&nbsp; GetExtendedControl(IDispatch **);
 &nbsp;&nbsp; HRESULT&nbsp; TransformCoords(POINTL *, POINTF *, DWORD);
 &nbsp;&nbsp; HRESULT&nbsp; TranslateAccelerator(LPMSG, DWORD);
 &nbsp;&nbsp; HRESULT&nbsp; OnFocus(BOOL);
 &nbsp;&nbsp; HRESULT&nbsp; ShowPropertyFrame(void);
 &nbsp;&nbsp; }
</code></pre>
<p>
The keyboard-related <i>GetControlInfo</i> and <i>OnMnemonic</i> methods of <i>IOleControl</i>, and the <i>OnControlInfoChanged</i>, <i>TranslateAccelerator</i>,<i> </i>and <i>OnFocus</i> methods of <i>IOleControlSite</i>, are described in the "Keyboard and Mnemonic Handling" section. The <i>GetExtendedControl</i> method of <i>IOleControlSite </i>is described in the "Extended Controls" section.</p>
<p>
That leaves only a few other methods, which we can describe here shortly, inasmuch as the mechanisms in which they are involved are simple. First is <i>IOleControl::OnAmbientPropertyChange</i>, which a container calls whenever it changes an ambient property. DISPID_UNKNOWN is a valid parameter to this function, meaning that an unspecified set of ambient properties has changed. In response, a control will retrieve the new property (or properties) and update its own visual and behavioral state, as appropriate.</p>
<p>
You may wonder why this mechanism is used to notify a control of ambient property changes when there already exists a more complicated mechanism, involving <i>IPropertyNotifySink </i>and connection points, for control properties. The reason is that whereas the properties available on the controls in a form can and will vary widely (especially with "other properties,” which will not be uncommon), the set of ambient properties will not generally change much from container to container. In addition, whereas a container needs notifications from many objects, a control only needs notifications from a single container. Use of the generic property notification scheme is an overkill. This was a conscious decision on the part of the OLE Controls designers for the sake of efficiency and simplicity<i>. </i>This doesn’t in any way preclude a control from implementing <i>IPropertyNotifySink</i> nor does it preclude a container from implementing connection points. There simply has to be a minimal entry point for control support, and instead of using the more costly and complex mechanism, this simple one is provided to minimize the cost of entry for controls.</p>
<p>
The other <i>IOleControl</i> member, <i>FreezeEvents</i>, allows the container to turn off (freeze) and turn on (thaw) a control's events. When frozen, the control will not fire its events—it might queue them or discard them, but it won't fire them. Which ones a control saves in a queue (to be fired upon thawing) and which ones it discards depends on the design of the control and the event, but is entirely up to the control.</p>
<p>
The other two members of <i>IOleControlSite</i> (<i>LockInPlaceActive</i> and <i>TransformCoords</i>) generally have to do with events as well. <i>LockInPlaceActive(TRUE) </i>tells the container that a control would like to stay in the active state until <i>LockInPlaceActive(FALSE) </i>is called, primarily to prevent crashing problems when an in-place window is destroyed and messages are still coming to that window. A control will often call <i>LockInPlaceActive</i> before and after an event is fired if destroying the in-place window would cause problems.</p>
<p>
<i>TransformCoords</i> handles the problem of presenting a uniform coordinate system to the container through all events, methods, and properties, while allowing controls to choose whatever coordinate system they want. For example, if a "MouseDown" event is fired, the container would like to receive the coordinates in a system meaningful to it instead of whatever system the control is using. Programmers for Microsoft Windows have always taken this for granted—any message or event coming from Windows had coordinates expressed in client-area units. But inasmuch as events are no longer coming from one consistent source with OLE Controls, there needs to be a mechanism through which the container still receives coordinates in a uniform coordinate system. For this reason, <i>TransformCoords</i> is exposed to controls for their use in converting between HIMETRIC and whatever system the container is using. Whenever the control receives coordinates from the container, it can convert them to HIMETRIC. Whenever the control wants to send some of its own coordinates to the container, it can convert them to the container's coordinate system first.</p>
<p>
Again, the other functions of these interfaces are described in sections below.</p>
<p>
<b>IOleClientSite::RequestNewObjectLayout</b></p>
<p>
Before moving on I want to mention this function briefly. <i>RequestNewObjectLayout </i>is part of the standard <i>IOleClientSite</i> interface in the core OLE Documents technology. It is not used by compound documents proper, but OLE Controls uses it to let the control tell the container that it would like to change its size. This is a signal for the container to retrieve the control's desired size (<i>IOleObject::GetExtent</i>) and pass it back, when convenient, to <i>IOleInPlaceObject::SetObjectRects</i>.</p>
<p>
<b>Container modes and ambient properties</b></p>
<p>
Container applications such as Microsoft Access, Visual Basic, and even the CPatron sample, differentiate between various "modes" of the container. These applications have a "Design Mode" in which the user, called the "designer" (who is in some cases a programmer), can lay out inactive controls on a form or document and assign actions to control events. They also have a "Run Mode" in which the controls are all active and events are functioning. To express the modality of the container, OLE Controls defines two standard ambient properties that specify how the control should behave in such modes, as opposed to specifying the “mode” itself, which is ambiguous, whereas expressing the desired effect is not.
<ul type=disc>
<li>
<b>UserMode. </b>When TRUE, the container is in a mode in which the end user (not necessarily a designer) is interacting with controls; when FALSE, the user (usually the designer) is laying controls on a form. A control uses this flag to modify its behavior to hide things that may not be appropriate for an end user but are needed by a designer. The OLE Controls spec indicates other uses.<br><br></li>
<li>
<b>UIDead. </b>When TRUE, indicates that controls should be dead as far as user input is concerned. That is, the control should ignore mouse clicks and keystrokes, and not change the mouse cursor even when the mouse is over the control window. A container such as Visual Basic would set this flag to TRUE when the programmer stops the program during execution—the container is not in design mode, yet not in run mode either; it simply wants the controls to be inoperative. When this flag is FALSE, controls act normally.</li>
</ul>
<p>
On a related note are the two ambient properties <b>ShowGrabHandles</b> and <b>ShowHatching</b>. In normal in-place activation, a container is responsible for drawing hatching and handles when an object is inactive; the object is responsible when it is either in-place active or UI active. If you think about it, however, grab handles and hatched borders around controls would look ridiculous in a form with many controls—as you press this or that button or work with this or that control, an annoying hatch border moves around and sizing handles appear where they are really inoperative. In other words, it would violate the way we understand user interface to operate. When a container is in run mode, it really doesn't want the control to be able to resize itself.</p>
<p>
Therefore the container has control over a control's behavior with these two ambient properties. If they are FALSE, the control suppresses its grab handles and hatching when UI active, regardless of all other ambient properties. If they are TRUE, the control is responsible for showing these elements when UI active. Controls check this property whenever they transition to UI active. CPatron, as an example, sets these two to FALSE whenever it is in run mode, and inasmuch as controls are never UI active outside of run mode, this effectively means that the controls never draw either element. In design mode, with inactive objects, CPatron draws its own handles. Other containers that keep objects UI active or in-place active even in design mode may handle these properties differently.</p>
<p>
<b>Miscellaneous status bits, new and used</b></p>
<p>
OLE Controls adds a number of new "MiscStatus" bits to indicate additional behavioral characteristics about controls. Two important flags that exist in the core OLE that are also important for controls are OLEMISC_INSIDEOUT and OLEMISC_ACTIVATEWHENVISIBLE. A control container should honor these flags well even for non-controls, but note that controls are normally marked with both. "Inside-out" simply means that the control can be in-place active without being UI active, which is critical for controls. "Activate-when-visible" means that a control should always be in-place active when it is visible, except in containers where "design mode" means that all controls become inactive. Normal compound document containers always honor activate-when-visible; with their different modes, control containers have conditions under which the flag can be ignored.</p>
<p>
Like OLEMISC_ACTIVATEWHENVISIBLE is the new addition OLEMISC_ALWAYSRUN. This basically tells the container to always call <i>OleRun</i> on the object regardless of its visibility, but doesn't mean the object is active in any way. Having it running, however, means that control code can be loaded to handle events or other necessary actions. Another new related flag is OLEMISC_INVISIBLEATRUNTIME, which means that when a container is in "run time" this control has no visuals whatsoever. For example, a timer control is visible during design-time, but disappears in run time. A container should be sure to not draw anything for such controls.</p>
<p>
The new OLEMISC_NOUIACTIVATE flag goes along with a control marked OLEMISC_INSIDEOUT to indicate that it can only ever become in-place active and doesn't care about UI active. A control that doesn't need menu space or toolbar space is a good example, as it is still quite usable through its own in-place window and its properties and methods.</p>
<p>
Finally there are OLEMISC_ACTSLIKEBUTTON and OLEMISC_ACTSLIKELABEL, which specify a slightly different behavior for keyboard processing with these controls. To explain them accurately we need to look at keyboard handling.</p>
<p>
Others flags include the following:
<ul type=disc>
<li>
OLEMISC_ALIGNABLE—indicates that a control can be aligned on some side of the container, but I'm unclear as to what this means.<br><br></li>
<li>
OLEMISC_IMEMODE—I have no idea what IME mode is, so I won't try to say anything about it.<br><br></li>
<li>
OLEMISC_SIMPLEFRAME—means the control has <i>ISimpleFrameSite</i> but I can't find documentation for this interface, so I won't try to make it up.<br><br></li>
<li>
OLEMISC_SETCLIENTSITEFIRST we've already seen.</li>
</ul>
<p>
<b>Keyboard and mnemonic handling</b></p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The information here is based on marginal guesswork and no real experience in implementing code (this part is not implemented in CPatron at this time), so there are bound to be assumptions or statements that are completely wrong. In addition, the controls spec has some discussion of an improved <i>OleTranslateAccelerator </i>that is used by EXE-based controls so that the container can receive wildcard keystrokes like an alt+ key combination. However, this discussion applies only to in-process objects where <i>OleTranslateAccelerator </i>is irrelevant.</p>
<p>
The keyboard support included with normal in-place activation only provides for handling keystrokes in the currently UI active object. Although this works great for compound documents, where there's usually only one <i>in-place</i> active object at one time (which is also UI active), it doesn't work so well for controls where you have many in-place active objects in the same form or document that would all like certain keystrokes to affect them.</p>
<p>
With normal in-place activation, the container will forward any keyboard message to the currently UI active object via <i>IOleInPlaceActiveObject::TranslateAccelerator</i>. Normally the object will handle whatever accelerators it wants, returning to the container a code that indicates whether processing took place. If the object didn't handle the message, the container gets a shot.</p>
<p>
<b>Modifications to IOleInPlaceActiveObject::TranslateAccelerators</b></p>
<p>
This is where the first modification with OLE Controls enters the scene. Instead of the normal implementation of <i>TranslateAccelerator</i>, the control first processes any keystroke that it wants to override or eat before giving it to either its immediate container (the implementor of <i>IOleControlSite</i>) or the top container frame (the one calling this <i>TranslateAccelerator</i>). If it doesn't handle the keystroke, it then calls <i>IOleControlSite::TranslateAccelerator</i> instead of returning immediately. If the site doesn't handle the keystroke then the control can again choose to handle it (meaning it gives the first shot for some keystrokes to its immediate container) or the control can return with S_FALSE which gives the keystroke to the outer container.</p>
<p>
This mechanism allows controls to give different priorities to different keys. An edit control might always override a ctrl+c (Edit/Copy) to copy text, overriding its immediate container. The immediate container itself could be an edit control which would take the same Edit/Copy command and perhaps copy the nested object. In other cases, the nested edit control might first let its immediate container process the TAB key, and process the key itself only if that container does not. Allowing a fine granularity of prioritization for specific keystrokes allows the control to do what makes the most sense in all circumstances.</p>
<p>
<b>Mnemonic Information for Controls</b></p>
<p>
With normal compound documents the container would not process its own accelerators. With OLE Controls we need to be able to have alt+ key combinations essentially trigger the primary event for controls, and we need the return and esc keys to trigger the "default" and "cancel" buttons appropriately. In addition, we also want to allow controls like text editors to "eat" return and esc if they so choose.</p>
<p>
Objects that have keyboard needs outside of what they get when they're UI active must first implement the function <i>IOleControl</i>::<i>GetControlInfo</i>. A container will call this function to retrieve a CONTROLINFO structure:</p>
<pre><code>struct CONTROLINFO:
 &nbsp;&nbsp; {
 &nbsp;&nbsp; ULONG&nbsp; cb;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Structure size
 &nbsp;&nbsp; HACCEL&nbsp; hAccel;&nbsp;&nbsp; //Mnemonics table for the control
 &nbsp;&nbsp; USHORT&nbsp; cAccel;&nbsp;&nbsp; //Number of mnemonics
 &nbsp;&nbsp; DWORD&nbsp; dwFlags;&nbsp;&nbsp; //CTRLINFO_ flags
 &nbsp;&nbsp; };

#define CTRLINFO_EATS_RETURN&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; //Control processes RETURN key
#define CTRLINFO_EATS_ESCAPE&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; //Control processes ESC key
</code></pre>
<p>
The <i>hAccel</i> member of this structure is a global memory handle to an array of ACCEL structures (see the Windows SDK). Each ACCEL structure contains a virtual key or ASCII key code, some flags (for shift, control, alt, and so on), and the WM_COMMAND ID associated with the accelerator (this is ignored for OLE Controls). With this table the container knows what specific keystrokes are of interest to the control. For example, a button control might have the text "<u>P</u>ress Here" showing, in which case the mnemonic alt-p would press the button. An ASCII "P" along with a flag for the alt- key would then appear in the CONTROLINFO for the button.</p>
<p>
Because a control's mnemonics can change dynamically—as with a button when the user changes the text or placement of the ampersand in the text—a container must know when to reload the CONTROLINFO structure. This is the purpose of <i>IOleControlSite::OnControlInfoChanged</i>. A container will normally load the CONTROLINFO when creating or reloading a control, and when the control calls this function the container must reload the structure over the old one.</p>
<p>
At run time, then, the container must check all the accelerator tables for each control if the UI active object doesn't handle the keystroke. This is essentially the process of looping through the controls and comparing the keystroke message from the container's message loop to the entries in the CONTROLINFO structure for each control. If a match is found, then the container calls that control's <i>IOleControl::OnMnemonic</i> function, and the control does its thing. Note that the container can choose to only support certain mnemonic keys, for instance only alt- keys, instead of arbitrary ones such as ctrl-enter.</p>
<p>
A container that supports this functionality must expose the ambient property <b>SupportsMnemonics</b> with the value of TRUE. If this ambient property is FALSE, a control may choose to not display underline characters.</p>
<p>
The two flags CTRLINFO_EATS_[RETURN | ESCAPE] are important in handling special buttons, as described in the next section.</p>
<p>
<b>Default and Cancel Buttons</b></p>
<p>
In Windows dialog boxes there is the concept of the "Default" button and the "Cancel" button. The "Default" button is the button activated when the return key is pressed, regardless of what control actually has the focus at the time. Normally this is whatever button has the focus at the time, or if no button has the focus it is whatever control is marked as the "Default" (in Windows dialog this is the DEFPUSHBUTTON in a dialog script). The "Cancel" button is the same sort of thing but works off the esc key instead, and is usually just one specific control—that is, it doesn't shift with the focus.</p>
<p>
OLE Controls provides mechanisms to handle these types of controls. First of all, controls that act like buttons (that is, those that may understand "defaultness" and "cancelness") mark themselves with the OLEMISC_ACTSLIKEBUTTON bit . In design mode, a control container then provides the programmer with some menu commands or such to mark one such button as the "default" and one such button as "cancel," if desired. These commands should only be enabled if the selected control is marked with OLEMISC_ACTSLIKEBUTTON. Assigning a default and cancel button is like marking one button as a DEFPUSHBUTTON and giving another the identifier IDCANCEL in a typical Windows dialog.</p>
<p>
What the container now does with this information depends on a number of factors. Let's take the easy one first: the esc key. When this key is pressed, it first goes to the UI active control. If that control is marked CTRLINFO_EATS_ESCAPE, we can be assured that it will process that keystroke. Note, however, that the button marked "cancel" in the container doesn't know that it's the "cancel" button, so it will not process this keystroke even if it is UI active. Anyway, if the UI active control does not eat the esc key, the container checks if it has a button marked as "cancel" and, if so, calls that control's <i>IOleControl::OnMnemonic</i>. Because the control knows it's a button (it's marked as such), it understands any mnemonic to mean "press me" and will fire its primary event, even if the mnemonic isn't in its CONTROLINFO. That's just part of being a button.</p>
<p>
The "default" button is a little more complicated. First of all, there is an added UI element—a thick frame around the button that indicates that it is the default. Second, the "default" button isn't always the one that the programmer marked. Open a normal Windows dialog box, such as File Open, and the initial default button will be the DEFPUSHBUTTON in the template, in this case the OK button. Notice that the OK button doesn't have the focus, but is still the default because it is marked as such. Now hit the tab key until the Cancel button has the focus. Notice that it is now the "default" button because it has the thick frame, so if you press return you cancel the dialog. Well, don't cancel the dialog; instead, take the mouse and click on one of the listboxes. Notice that the focus has gone to the listbox and the default button has reverted to OK.</p>
<p>
This is the behavior OLE Controls allows you to duplicate, and it involves the ambient property <b>DisplayAsDefault</b>. Only one site in any given form or document should have this flag set to TRUE at any one time, for when it is set, and the control in that site is a pushbutton, the control will draw itself with a thick border. Therefore: 
<ol>
<li>
First, you have to change this ambient property in your sites as focus changes between buttons—you detect focus changes with <i>IOleControl::OnFocus</i>.<br><br></li>
<li>
If the control that receives the focus (TRUE passes to <i>OnFocus</i>)<i> </i>is marked with OLEMISC_ACTSLIKEBUTTON, set <b>DisplayAsDefault</b> to TRUE and notify the control with <i>IOleControl::OnAmbientPropertyChange</i>.<br><br></li>
<li>
If the control with the focus is not a button, set <b>DisplayAsDefault</b> to FALSE and notify the control, <i>then </i>set <b>DisplayAsDefault</b> to TRUE for the button that the programmer marked as "Default," again notifying the control.<br><br></li>
<li>
Finally, whenever any button control that is not the default loses focus, be sure to set the sites <b>DisplayAsDefault</b> to FALSE and notify the control.</li>
</ol>
<p>
Handling <i>OnFocus</i> and the <b>DisplayAsDefault </b>ambient in this fashion handles the UI element almost correctly <b><i>[I hope—I haven't tried this in code!]</i></b>. What still remains is how we handle the return key and non-button controls that eat it. As with esc, if the UI active control wants to eat the return key, it will eat it. It marks itself with this behavior using CTRLINFO_EATS_RETURN. What a container must do is check to see if the currently UI active control will eat the keystroke—if it does, then we have to turn <b>DisplayAsDefault</b> completely off for all buttons, even the one marked "Default," because we will never see the return key. If the UI active control does not eat the return key, we call the <i>OnMnemonic</i> function of whatever button has <b>DisplayAsDefault</b> currently set (not the one marked as "Default"). The button will, again by virtue of being a button, understand the <i>OnMnemonic </i>call to mean "press me" and so will fire its primary event.</p>
<p>
In summary, we handle the return key using three pieces of information: (1) which button is marked as "Default", (2) which button has <b>DisplayAsDefault </b>set, and (3) whether or not the UI active button has CTRLINFO_EATS_RETURN set. Using this information we handle any button as follows:
<ol>
<li>
If a button has the focus (<i>IOleControlSite::OnFocus(TRUE)</i> is called), set its <b>DisplayAsDefault </b>to TRUE, otherwise FALSE except in case 3 below. Notify the control with <i>IOleControl::OnAmbientPropertyChange.</i><br><br></li>
<li>
If a button is not marked "Default" and loses the focus (<i>IOleControlSite::OnFocus(FALSE))</i> is called), set its <b>DisplayAsDefault </b>to FALSE and notify the control.<br><br></li>
<li>
If a button is marked "Default" and does not have the focus, AND the control with the focus does not have CTRLINFO_EATS_RETURN, set its <b>DisplayAsDefault</b> to TRUE, otherwise FALSE, and notify the control.<br><br></li>
<li>
Whenever return is pressed and is detected in the container, call the <i>OnMnemonic</i> function of the control with <b>DisplayAsDefault</b> set. If no control has it set, ignore the keystroke.</li>
</ol>
<p>
Steps 1, 2, and 3 handle the thick border of the default control; step 4 handles the keystroke correctly. You can see now why esc key handling was so much easier!</p>
<p>
<b>Labels</b></p>
<p>
Certain controls may be marked with OLEMISC_ACTSLIKELABEL, and these require special keyboard handling. The user interface for a label specifies that a label never has the focus itself, and that pressing a label's mnemonic key sets the focus to whatever control is "next to" or "attached" to the label. Labels are normally used on listboxes because a listbox doesn't have any caption in which to have a mnemonic; thus pressing the mnemonic in the label sets the focus to the listbox.</p>
<p>
A control container must then make a check for OLEMISC_ACTSLIKELABEL before it fires <i>OnMnemonic</i> to a control. If this flag is set, the container should not call <i>OnMnemonic</i> but should instead UI activate (effectively <i>SetFocus</i>) the control associated with the label.</p>
<p>
<b>The TAB Key</b></p>
<p>
This isn't too hard to figure out: When the container sees a tab keystroke, it should move the focus to (UI activate) the next control in the order determined by the layout of the form. Do note that the container should skip any control marked as OLEMISC_ACTSLIKELABEL, OLEMISC_SIMPLEFRAME, OLEMISC_INVISIBLEATRUNTIME, and OLEMISC_NOUIACTIVATE. The latter flag allows the container to determine if a control doesn't understand the idea of UI activation, which is equivalent to focus in OLE Controls. Icons and pictures are good examples of visible, non-label, non-UI active controls.</p>
<p>
<b>Exclusive buttons</b></p>
<p>
Only a brief mention here: A control container should handle groups of what are known as "exclusive buttons," where only one button in the group can be "checked" at any given time—that is, radio buttons. The container is responsible for determining where the group starts and stops, and is responsible for making sure that only one button of the group is checked. The container determines if a control is an exclusive button by looking at the type of the object's "Value" property, DISPID_VALUE. (DISPID_VALUE is defined by OLE Automation because it is not specific to controls.) If the type is OLE_OPTEXCLUSIVE, this control is an exclusive button.</p>
<p>
The explanation of how a container actually checks for the type is rather lengthy. (The OLE Controls spec was designed to use as much of the existing type information as possible. This usually places the burden on the container instead of the control.) Every type in a type library has its own GUID. The type of a property also has a GUID, so you have to extract the GUID for the type for the DISPID_VALUE property from each control and compare it to GUID_OPTIONVALUEEXCLUSIVE (OLECTLID.H). Those controls that match types are exclusive buttons. (The exact sequence of <i>ITypeInfo </i>calls to retrieve these types and perform the comparison is not covered in this article.)</p>
<p>
The container must have UI for assigning the boundaries of the group of exclusive buttons. It then watches for a change in DISPID zero through <i>IPropertyNotifySink </i>in each of these. When one control is checked, it forcibly unchecks whatever control was checked by changing that control's property.</p>
<p>
<b>Extended objects</b></p>
<p>
[This subject deferred for later work. Please see the OLE Controls spec for details about extended objects.]</p>
<h2>The CPatron Sample Application</h2>
<p>
The CPatron sample container is a modification of the Patron example from Chapter 15 of <i>Inside OLE 2</i>. The Chapter 15 sample is an in-place–capable OLE Container application that also supports just about every other feature in OLE, such as Compound Files, Drag &amp; Drop, as well as the various types of compound document objects (embedded, linked), along with conversion/emulation support. Note that there is a lot more source code in this sample than is necessarily pertinent to controls—an OLE Control only requires the container to support embedding and in-place activation as a minimum. Table 3 lists all the important source files in the sample (.CPP, .H, and resource files), their function, and if and how they relate to the control modifications.</p>
<p class=label>
<b>Table 3. CPatron Source Files and Their Contents</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=23%><b><br>
Source File (* = added for controls)</b></td>
<td class=label width=12%><b>Modified for controls?</b></td>
<td class=label width=65%><b><br>
<br>
Purpose</b></td>
</tr>
<tr valign=top>
<td width=23%>ambients.cpp*</td>
<td width=12%>Yes</td>
<td width=65%>Implementation of the <i>IDispatch</i> interface for the control container's ambient properties.</td>
</tr>
<tr valign=top>
<td width=23%>client.cpp</td>
<td width=12%>No</td>
<td width=65%>Client-area handling.</td>
</tr>
<tr valign=top>
<td width=23%>connect.cpp*</td>
<td width=12%>Yes</td>
<td width=65%>Helper functions to work with <i>IConnectionPointContainer</i> and <i>IConnectionPoint</i> interfaces as well as functions to locate type information for a control's event set.</td>
</tr>
<tr valign=top>
<td width=23%>document.cpp</td>
<td width=12%>Yes</td>
<td width=65%>Document window handling; contains a few modifications to pass-through control-related commands from the frame window.</td>
</tr>
<tr valign=top>
<td width=23%>dragdrop.cpp</td>
<td width=12%>No</td>
<td width=65%>Drag and drop helper functions.</td>
</tr>
<tr valign=top>
<td width=23%>events.cpp*</td>
<td width=12%>Yes</td>
<td width=65%>Events dialog procedure, implementation of a class CEventMap for working with events, and the implementation of the container's <i>IDispatch</i> interface for handling events.</td>
</tr>
<tr valign=top>
<td width=23%>events.dlg*</td>
<td width=12%>Yes</td>
<td width=65%>Template for a dialog that CPatron uses to assign actions to events.</td>
</tr>
<tr valign=top>
<td width=23%>iadvsink.cpp</td>
<td width=12%>No</td>
<td width=65%><i>IAdviseSink</i> interface implementation, used for normal compound document features.</td>
</tr>
<tr valign=top>
<td width=23%>iclassf.cpp</td>
<td width=12%>No</td>
<td width=65%>Class factory implementation for linking-to-embedding support, unrelated to controls.</td>
</tr>
<tr valign=top>
<td width=23%>iclisite.cpp</td>
<td width=12%>Yes</td>
<td width=65%><i>IOleClientSite</i> interface implementation, modified slightly for controls, specifically in <i>IOleClientSite::RequestNewObjectLayout.</i></td>
</tr>
<tr valign=top>
<td width=23%>iconsite.cpp*</td>
<td width=12%>Yes</td>
<td width=65%><i>IOleControlSite </i>interface implementation.</td>
</tr>
<tr valign=top>
<td width=23%>idropsrc.cpp</td>
<td width=12%>No</td>
<td width=65%><i>IDropSource</i> interface implementation.</td>
</tr>
<tr valign=top>
<td width=23%>idroptgt.cpp</td>
<td width=12%>No</td>
<td width=65%><i>IDropTarget</i> interface implementation.</td>
</tr>
<tr valign=top>
<td width=23%>iipsite.cpp</td>
<td width=12%>Yes</td>
<td width=65%><i>IOleInPlaceSite </i>interface implementation.</td>
</tr>
<tr valign=top>
<td width=23%>iipuiwin.cpp</td>
<td width=12%>Yes</td>
<td width=65%><i>IOleInPlaceUIWindow</i> interface implementation for document windows.</td>
</tr>
<tr valign=top>
<td width=23%>iolecont.cpp</td>
<td width=12%>No</td>
<td width=65%><i>IOleItemContainer </i>interface implementation used specifically for linking to embeddings.</td>
</tr>
<tr valign=top>
<td width=23%>iperfile.cpp</td>
<td width=12%>No</td>
<td width=65%><i>IPersistFile </i>interface implementation used specifically for linking to embeddings.</td>
</tr>
<tr valign=top>
<td width=23%>ipropnot.cpp*</td>
<td width=12%>Yes</td>
<td width=65%><i>IPropertyNotifySink</i> interface implementation.</td>
</tr>
<tr valign=top>
<td width=23%>iuilink.cpp</td>
<td width=12%>No</td>
<td width=65%><i>IOleUILinkContainer</i> interface implementation, used for linking only.</td>
</tr>
<tr valign=top>
<td width=23%>page.cpp</td>
<td width=12%>Yes</td>
<td width=65%>Code to handle pages within a document. This file contains some modifications for handling controls, such as displaying the Events dialog.</td>
</tr>
<tr valign=top>
<td width=23%>pagemous.cpp</td>
<td width=12%>Yes</td>
<td width=65%>Mouse handling code for pages within a document, modified slightly to add additional menu items to right-button popup menus.</td>
</tr>
<tr valign=top>
<td width=23%>pages.cpp</td>
<td width=12%>Yes</td>
<td width=65%>Code to handle pages within a document, modified slightly to route some control-related commands from the frame window.</td>
</tr>
<tr valign=top>
<td width=23%>pages.h</td>
<td width=12%>Yes</td>
<td width=65%>Header file for page-related structures and classes.</td>
</tr>
<tr valign=top>
<td width=23%>pagewin.cpp</td>
<td width=12%>No</td>
<td width=65%>Page window handling.</td>
</tr>
<tr valign=top>
<td width=23%>patron.cpp</td>
<td width=12%>Yes</td>
<td width=65%>Frame window handling code, modified slightly to route control-related commands from the menu to the current page or object.</td>
</tr>
<tr valign=top>
<td width=23%>patron.h</td>
<td width=12%>Yes</td>
<td width=65%>Frame and document window structures and classes.</td>
</tr>
<tr valign=top>
<td width=23%>patron.rc</td>
<td width=12%>Yes</td>
<td width=65%>Includes events dialog and additional control-related menu items.</td>
</tr>
<tr valign=top>
<td width=23%>precomp.cpp</td>
<td width=12%>No</td>
<td width=65%>Precompiled header file.</td>
</tr>
<tr valign=top>
<td width=23%>resource.h</td>
<td width=12%>Yes</td>
<td width=65%>Additional symbols for events dialog and control-related menu items.</td>
</tr>
<tr valign=top>
<td width=23%>tenant.cpp</td>
<td width=12%>Yes</td>
<td width=65%>Implementation of container sites. Many additions and modifications to handle control creation, initialization, and so forth.</td>
</tr>
<tr valign=top>
<td width=23%>tenant.h</td>
<td width=12%>Yes</td>
<td width=65%>Definitions for added control interfaces and structures.</td>
</tr>
</table><br>
<p>
Besides supporting In-Place Activation, this starting version of Patron also contains support for inside-out objects, which is beneficial, inasmuch as OLE Controls are generally inside-out objects. I do expect that the reader of this document is already familiar with the implementation of compound document containers as well as in-place activation, because that is 70–80 percent of the work involved in making a control container. If you have not looked much into inside-out objects, you can look at the code in the TENANT.CPP source file for the OLEMISC_INSIDEOUT and OLEMISC_ACTIVATEWHENVISIBLE flags. The extra code executed when these flags are set for an object is the code that handles inside-out differences.</p>
<p>
The specific modifications made to Patron to turn it into CPatron are marked in the code with <b>//CONTROLMOD</b> and <b>//End CONTROLMOD</b>. All of the files in Table 3 marked with "Yes" in the "Modified for Controls" column will have some comments like this. I'm pretty sure I have all control-specific modifications marked.</p>
<p>
There are a few things that CPatron doesn't do at all and a few things it doesn't do well. As far as control support is concerned, CPatron does not implement "extended controls," does not handle buttons/labels/exclusive buttons/default buttons/cancel buttons at all, does not provide for registering controls, and does not include any keyboard handling (RETURN/ESC/TAB/CONTROLINFO) over normal in-place activation use. For example, the tab key is ignored because CPatron doesn't currently keep an order of the controls on the form other than Z-order, and Z-order changes as you switch the focus. I simply have not added the code to handle this. I also have to say that I haven't really tested this thing thoroughly, especially with the more specific control features, generally from the lack of having controls that use these features.</p>
<p>
CPatron implements a "design mode" and a "run mode" but it is different from what an application like Visual Basic does. The only difference between the two modes is whether or not controls are allowed to in-place activate and UI activate. In design mode, in-place activation is turned off, giving the container full control over layout, grab handles, and so on. In run mode, all the controls are activated and work like controls, and CPatron turns off the <b>ShowGrabHandles</b> and <b>ShowHatching</b> ambient properties to suppress those UI elements. What is different from an application like Visual Basic is that you can still create new controls in run mode, a feature that you would normally disable in a real forms-based development environment. It would not be hard to disable the UI, but heck, I didn't bother.</p>
<p>
In addition, CPatron has some minor glitches, bugs, or whatever you would like to call them that are more annoying than detrimental to functionality. One such bug regards object extents: calls to <i>IOleObject::SetExtent </i>require HIMETRIC units (not MM_HIMETRIC mapping mode—the scale but not the axis orientation), but calls through <i>IOleInPlaceSite::OnPosRectChange</i> and <i>IOleInPlaceObject::SetObjectRects</i> require pixels in client coordinates. CPatron, furthermore, works internally on MM_LOMETRIC. Somewhere in all the calls to these functions that start in <i>CTenant::RectSet</i> (TENANT.CPP) the coordinates get jumbled and confused to such a degree that a control may not appear in the proper rectangle. This is one of those bugs that you keep looking at and never quite figure out. If you see what’s going wrong and point it out to me, I promise to be really nice to you if I ever meet you in a dark alley somewhere. This happens in the call to <i>CTenant::Select</i> made earlier in <i>CPage::TenantCreate</i>. <i>Select</i> will UI activate the selected object. The reason we want to skip the Show part here is that when we’re in design mode, we disable in-place activation temporarily so a Show verb would pop the control up in a little window! It’s an ugly user interface, so we skip the Show here to suppress it.</p>
<p>
CPatron is also somewhat limited as to what it can actually do with a control's events. As we'll see, it can only perform a fixed set of actions when an event occurs and has no language/programming structure in which you might use an event from one control to call a method or manipulate a property in another. Nevertheless I will attempt to describe something about containers that might work with these things in a more sophisticated manner in the next section.</p>
<p>
Other than that, CPatron does demonstrate most of the responsibilities of a control container, and fragments of its code will be shown in the next section to demonstrate how a particular feature of OLE Controls might be implemented.</p>
<p>
<b>External files need to compile and run CPatron</b></p>
<p>
The .ZIP file that comes with this article should be unzipped with the -d switch. It will create INC, LIB, BUILD, and CONTROL directories in which various files are stored. The CPatron source files will be in CONTROL\CPATRON. The other files you'll have are as follows:
<ul type=disc>
<li>
Include files in INC: BOOKGUID.H, DBGOUT.H, BOOK1632.H, BTTNCUR.H, GIZMOBAR.H, STASTRIP.H, CLASSLIB.H, and CLASSRES.H. These are updates from those found in the <i>Inside OLE 2 </i>samples. You'll need to put these in your INCLUDE environment path.<br><br></li>
<li>
Libraries in LIB: CLASSMDI.LIB, BTTNCUR.LIB, GIMZMOBAR.LIB, STASTRIP.LIB, BOOKUI.LIB, and BOOKUI32.LIB. Put these in your LIB environment path.<br><br></li>
<li>
DLLs in BUILD: BTTNCUR.DLL, GIZMOBAR.DLL, STASTRIP.DLL, DATATRAN.DLL, LNKASSIS.DLL, BOOKUI.DLL (Win16 UI Library), and BOOKUI32.DLL (Win32® Unicode® UI Library).<br><br></li>
<li>
Registry information (root): CPATRON.REG. This registers the necessary information for CPatron along with that needed for DATATRAN.DLL and LNKASSIS.DLL. The paths in this files are hard-codes to assume the directory c:\control\build. Change them to where you place the DLLs and your compile CPatron.<br><br></li>
<li>
Other files in root directory: INOLE2A.MAK, INOLE2B.MAK, and build notes in BUILD.TXT. The .MAK files are generic makefiles used from CPatron's MAKEFILE. Note that INOLE2A.MAK under Win32 refers to the library "crtdll.lib" for linking. This is the Win32 SDK C run-time import library. If you are using Visual C++™, you'll need to change this file to use "msvcrt.lib" instead.</li>
</ul>
<p>
You'll also need the include file OLECTL.H from the CDK besides having the rest of OLE 2 on your system. In addition, depending on your compiler setup, you may need the OLE2UI.H and OLESTD.H files that are also in the INC directory. For example, the files of the same name that come with Visual C++ 2.0 have removed some of the structures and functions in these files, which will cause compilation errors. The include files from the Win32 SDK, however, contain the same information as the copies included with CPatron.</p>
<h2>Implementing a Control Container Step by Step</h2>
<p>
We're now in a position to take a look at some actual code for a control container. The code here is taken from the CPatron sample, so what is not present in the sample will not be shown here unless I have another source for code fragments (I'll indicate such cases).</p>
<p>
The steps presented here are ordered in such a way that I believe you can stop after each step, compile, and test your new code. I find this incremental approach to development much more enjoyable than attempting to implement everything at once. I hope it helps you too.</p>
<p>
I am assuming that readers are starting with an in-place capable container application already, and <i>Inside OLE 2</i> has the information you need to do that work (do note that some of the material in Chapter 15 on in-place containers is sketchy, especially concerning inside-out objects; double-check with the <i>OLE 2.0 Programmer's Reference</i> and the additional notes on in-place activation provided with the SDK).</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;There is one change: controls may not support changing the container's caption bar when activated in place. In particular, you need to make sure your container is prepared for a NULL in the last parameter to <i>IOleInPlaceUIWindow::SetActiveObject </i>(the <i>pszObj </i>string to use in the caption bar) and <i>IOleInPlaceFrame::SetActiveObject</i>. If this parameter is NULL, don't modify the caption bar at all.</p>
<p>
That said, here are the steps we'll discuss:
<ol>
<li>
Add stubs for the site interfaces of <i>IOleControlSite</i>, <i>IDispatch</i>, <i>IDispatch (Events)</i>, and <i>IPropertyNotifySink</i>, and add site variables.<br><br></li>
<li>
Implement control-specific creation cases along with control registration.<br><br></li>
<li>
Initialize controls by obtaining control interfaces, retrieving the object's CONTROLINFO, connecting to the primary event set, and connecting to the property change notification sink.<br><br></li>
<li>
Implement a "Design-Mode" feature.<br><br></li>
<li>
Handle Z-order and MiscStatus bits.<br><br></li>
<li>
Implement the ambient properties <i>IDispatch.</i><br><br></li>
<li>
Implement <i>IPropertyNotifySink</i>.<br><br></li>
<li>
Implement events UI and the events <i>IDispatch</i>.<br><br></li>
<li>
Save and load controls and their event mappings.<br><br></li>
<li>
Implement <i>IOleControlSite</i> and <i>IOleClientSite::RequestNewObjectLayout</i>.<br><br></li>
<li>
Implement keyboard mnemonics.<br><br></li>
<li>
Handle buttons and labels.<br><br></li>
<li>
Implement Extended Controls.</li>
</ol>
<p>
This article only contains material for steps 1 through 10; the last three are not implemented in CPatron. What I know about these I've already included previously (and as you know, my knowledge of Extended Controls is really minimal right now!). I figure that some of these steps might come earlier in the list of steps above, but I have no way to judge well without knowing more about them. Keyboard handling does need to come after you've filled in <i>IOleControlSite</i> because it depends on some of its member functions.</p>
<h3>Add Site Interfaces and Variables</h3>
<p>
The first step in implementing a control container is to extend the container's existing site object with stub implementations of the interfaces needed for controls and with the variables needed for maintain control states. The interfaces are <i>IOleControlSite</i>, <i>IPropertyNotifySink</i>, and two implementations of <i>IDispatch</i>,<i> </i>with the latter interfaces making a special requirement on implementations of <i>QueryInterface.</i></p>
<h4>CTenant variables</h4>
<p>
Before looking at <i>IUnknown</i> implementations in these interfaces, Table 4 contains the list of variables I added to CPatron's site object class, CTenant, in TENANT.H.</p>
<p class=label>
<b>Table 4. List of Variables Added to CPatron's Site Object Class, CTenant</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=36%><b>Variable Name</b></td>
<td class=label width=27%></td>
<td class=label width=37%><b>Comment</b></td>
</tr>
<tr valign=top>
<td width=36%>PIMPIOLECONTROLSITE</td>
<td width=27%>m_pIOleControlSite;</td>
<td width=37%>Implemented</td>
</tr>
<tr valign=top>
<td width=36%>PIMPIDISPATCH</td>
<td width=27%>m_pIDispatch;</td>
<td width=37%>Implemented</td>
</tr>
<tr valign=top>
<td width=36%></td>
<td width=27%></td>
<td width=37%></td>
</tr>
<tr valign=top>
<td width=36%>PIMPIDISPATCHEVENTS</td>
<td width=27%>m_pIDispatchEvents;</td>
<td width=37%>Implemented</td>
</tr>
<tr valign=top>
<td width=36%>DWORD</td>
<td width=27%>m_dwConnEvents;</td>
<td width=37%>Events connection key</td>
</tr>
<tr valign=top>
<td width=36%>IID</td>
<td width=27%>m_iidEvents;</td>
<td width=37%>Event set IID</td>
</tr>
<tr valign=top>
<td width=36%>PCEventMap</td>
<td width=27%>m_pEventMap;</td>
<td width=37%>Event mapping</td>
</tr>
<tr valign=top>
<td width=36%></td>
<td width=27%></td>
<td width=37%></td>
</tr>
<tr valign=top>
<td width=36%>PIMPIPROPERTYNOTIFYSINK</td>
<td width=27%>m_pIPropNoteSink;</td>
<td width=37%>Implemented</td>
</tr>
<tr valign=top>
<td width=36%>DWORD</td>
<td width=27%>m_dwConnProp;</td>
<td width=37%>Prop Notify connection key</td>
</tr>
<tr valign=top>
<td width=36%></td>
<td width=27%></td>
<td width=37%></td>
</tr>
<tr valign=top>
<td width=36%><b>Control interfaces</b></td>
<td width=27%></td>
<td width=37%></td>
</tr>
<tr valign=top>
<td width=36%>LPOLECONTROL</td>
<td width=27%>m_pIOleControl;</td>
<td width=37%>Used</td>
</tr>
<tr valign=top>
<td width=36%>LPDISPATCH</td>
<td width=27%>m_pIDispatchControl;</td>
<td width=37%>Used</td>
</tr>
<tr valign=top>
<td width=36%></td>
<td width=27%></td>
<td width=37%></td>
</tr>
<tr valign=top>
<td width=36%><b>Ambient properties</b></td>
<td width=27%></td>
<td width=37%></td>
</tr>
<tr valign=top>
<td width=36%>OLE_COLOR</td>
<td width=27%>m_clrBack;</td>
<td width=37%>BackColor</td>
</tr>
<tr valign=top>
<td width=36%>OLE_COLOR</td>
<td width=27%>m_clrFore;</td>
<td width=37%>ForeColor</td>
</tr>
<tr valign=top>
<td width=36%>HFONT</td>
<td width=27%>m_hFont;</td>
<td width=37%>Default font</td>
</tr>
<tr valign=top>
<td width=36%>LCID</td>
<td width=27%>m_lcid;</td>
<td width=37%>Locale ID</td>
</tr>
<tr valign=top>
<td width=36%>BOOL</td>
<td width=27%>m_fDesignMode;</td>
<td width=37%>Design mode?</td>
</tr>
<tr valign=top>
<td width=36%></td>
<td width=27%></td>
<td width=37%></td>
</tr>
<tr valign=top>
<td width=36%><b>Other state information</b></td>
<td width=27%></td>
<td width=37%></td>
</tr>
<tr valign=top>
<td width=36%>BOOL</td>
<td width=27%>m_fHaveControlInfo;</td>
<td width=37%>Did we load CONTROLINFO</td>
</tr>
<tr valign=top>
<td width=36%>CONTROLINFO</td>
<td width=27%>m_ctrlInfo;</td>
<td width=37%>Actual CONTROLINFO</td>
</tr>
<tr valign=top>
<td width=36%>ULONG</td>
<td width=27%>m_cLockInPlace;</td>
<td width=37%>LockInPlaceActive count</td>
</tr>
<tr valign=top>
<td width=36%>BOOL</td>
<td width=27%>m_fPendingDeactivate;</td>
<td width=37%>Deactivate prevented by a lock?</td>
</tr>
</table><br>
<p>
Those variables of type PIMP<i>xx </i>are CPatron's "interface implementation" classes, defined earlier in TENANT.H, with one implementation class per interface that singly inherits from that interface. Each class maintains three variables: a reference count, a pointer to the CTenant object in which it is instantiated, and an <i>IUnknown *</i> to which it normally delegates all <i>IUnknown</i> functions (the <i>IUnknown</i> function always delegates to the <i>IUnknown </i>implementation in CTenant).</p>
<p>
The CEventMap class to which CTenant maintains a pointer is a class defined in TENANT.H specifically for handling the mapping between events and actions. (We'll see how this is used later.) The pointer itself is initialized to NULL unless we find an object with an event set in this site. As for initialization of everything else, all the pointers, connection keys, and counts are initialized to NULL and zero in the CTenant constructor, <i>m_iidEvents </i>gets GUID_NULL, and only the ambient properties are initialized with anything interesting:</p>
<pre><code>//0x80000000 in OLE_COLOR indicates low byte is color index.
m_clrBack=0x80000000+COLOR_WINDOW;
m_clrFore=0x80000000+COLOR_WINDOWTEXT;
m_hFont=m_pPG-&gt;m_hFont;
m_lcid=LOCALE_USER_DEFAULT;
m_fDesignMode=m_pPG-&gt;m_fDesignMode;
</code></pre>
<p>
The <i>m_pPG-&gt;m_fDesignMode</i> variable is kept in the CPages class (PAGES.H), a pointer to which is given to the CTenant constructor. The flag here indicates whether we are initially in design mode or run mode when creating the site, and this information affects how the site initializes a newly created object (such as whether it honors OLEMISC_ACTIVATEWHENVISIBLE).</p>
<p>
The variables <i>m_pEventMap</i>,<i> m_pIOleControlSite</i>,<i> m_pIDispatch</i>, and <i>m_pIDispatchEvents</i> are deleted in the CTenant destructor (along with interface implementations that existed before control modifications). The variables that maintain object interface pointers, <i>m_pIOleControl </i>and <i>m_pIDispatchControl</i>, are released (that is, <i>Release</i> is called through them) in <i>CTenant::Close</i>, where all other object pointers are released as well. The <i>m_hFont </i>variable used for the ambient font property is maintained by CPages, so the tenant doesn't need to worry about cleanup.</p>
<p>
For a more complete container implementation that handles those additional features that CPatron does not, you will obviously have more site variables. For example, you'll need to maintain the following: 
<ul type=disc>
<li>
The <b>DisplayAsDefault</b> ambient property (an extra BOOL)<br><br></li>
<li>
Flags that say if the control here is the "Default" or "Cancel" button<br><br></li>
<li>
Flags that say whether or not the control is an exclusive button and what group it belongs to<br><br></li>
<li>
Flags that say if the control is a label<br><br></li>
<li>
Flags that say whether the control is a tab stop or can have the focus<br><br></li>
<li>
Other ambient properties your container finds important (CPatron uses <i>m_fDesignMode</i> to supply things like <b>ShowGrabHandles</b> as described later under "Ambient properties")<br><br></li>
<li>
Anything necessary for extended controls</li>
</ul>
<h4>Interfaces and <i>IUnknown </i>implementations</h4>
<p>
I have found it helpful early on to add stub interface implementations that generally don't contain any functional code except <i>IUnknown</i> members. Then as you add features to the application you can fill in the interface functions as required. Having the interfaces present and instantiated, however, allows an object to obtain those interfaces and attempt to call the members.</p>
<p>
The CTenant class instantiates most of its interface implementations in <i>CTenant::FOpen</i>, which is essentially a small initialization function. As mentioned before, these interfaces are deleted in the destructor.</p>
<p>
Anyway, having interfaces around at this point requires that we fill in their implementations at least enough to return an error code if need be. Table 5 describes the default return code you should put into each interface function right now. In many cases we won't need to change these at all, as they are sufficient for working with controls. (In the "Will Modify" column, those functions marked No are not modified in CPatron because it doesn't yet implement certain features, such as keyboard handling and extended controls. More complete containers would eventually implement these functions to do more than return E_NOTIMPL. Those marked with "No*" are not implemented but NULL any out-parameters sent to the function.)</p>
<p class=label>
<b>Table 5. Initial Implementations of Site Interfaces</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Interface</b></td>
<td class=label width=31%><b>Member Function</b></td>
<td class=label width=26%><b>Default Implementation</b></td>
<td class=label width=17%><b>Will Modify?</b></td>
</tr>
<tr valign=top>
<td width=26%>IPropertyNotifySink</td>
<td width=31%>OnChanged</td>
<td width=26%>NOERROR</td>
<td width=17%>No</td>
</tr>
<tr valign=top>
<td width=26%></td>
<td width=31%>OnRequestEdit</td>
<td width=26%>NOERROR</td>
<td width=17%>No</td>
</tr>
<tr valign=top>
<td width=26%>IDispatch</td>
<td width=31%>GetTypeInfoCount</td>
<td width=26%>E_NOTIMPL</td>
<td width=17%>No*</td>
</tr>
<tr valign=top>
<td width=26%>(Both events and</td>
<td width=31%>GetTypeInfo</td>
<td width=26%>E_NOTIMPL</td>
<td width=17%>No*</td>
</tr>
<tr valign=top>
<td width=26%>ambient properties)</td>
<td width=31%>GetIDOfNames</td>
<td width=26%>E_NOTIMPL</td>
<td width=17%>No*</td>
</tr>
<tr valign=top>
<td width=26%></td>
<td width=31%>Invoke</td>
<td width=26%>E_NOTIMPL</td>
<td width=17%>Yes</td>
</tr>
<tr valign=top>
<td width=26%>IOleControlSite</td>
<td width=31%>OnControlInfoChanged</td>
<td width=26%>E_NOTIMPL</td>
<td width=17%>Yes</td>
</tr>
<tr valign=top>
<td width=26%></td>
<td width=31%>LockInPlaceActive</td>
<td width=26%>E_NOTIMPL</td>
<td width=17%>Yes</td>
</tr>
<tr valign=top>
<td width=26%></td>
<td width=31%>GetExtendedControl</td>
<td width=26%>E_NOTIMPL</td>
<td width=17%>No*</td>
</tr>
<tr valign=top>
<td width=26%></td>
<td width=31%>TransformCoords</td>
<td width=26%>E_NOTIMPL</td>
<td width=17%>Yes</td>
</tr>
<tr valign=top>
<td width=26%></td>
<td width=31%>TranslateAccelerator</td>
<td width=26%>E_NOTIMPL</td>
<td width=17%>No</td>
</tr>
<tr valign=top>
<td width=26%></td>
<td width=31%>OnFocus</td>
<td width=26%>NOERROR</td>
<td width=17%>No</td>
</tr>
<tr valign=top>
<td width=26%></td>
<td width=31%>Show PropertyFrame</td>
<td width=26%>E_NOTIMPL</td>
<td width=17%>No</td>
</tr>
</table><br>
<p>
Note that CPatron, as mentioned before, implements the events <i>IDispatch </i>on the site object alongside all these others. Accordingly we play some games with <i>QueryInterface</i>,<i> </i>as we'll see in a bit.</p>
<p>
We also need to implement the <i>IUnknown</i> behavior of all these interfaces at this time. For all of them, <i>AddRef </i>and <i>Release</i> behave as usual: increment or decrement the site's overall reference count. All of CPatron's interface implementations maintain a reference count for the interface (for debugging) and then call <i>AddRef</i> or <i>Release </i>in CTenant (through <i>m_pUnkOuter</i>, which is sent to the interfaces' constructors)<i> </i>to handle the total object count:</p>
<pre><code>STDMETHODIMP_(ULONG) CImpIOleControlSite::AddRef(void)
 &nbsp; {
 &nbsp; ++m_cRef;
 &nbsp; return m_pUnkOuter-&gt;AddRef();
 &nbsp; }

STDMETHODIMP_(ULONG) CImpIOleControlSite::Release(void)
 &nbsp; {
 &nbsp; --m_cRef;
 &nbsp; return m_pUnkOuter-&gt;Release();
 &nbsp; }

//Same for IPropertyNotifySink, IDispath (ambients), and IDispatch (events)
</code></pre>
<p>
For all the interfaces except the events <i>IDispatch</i>, <i>QueryInterface</i> is implemented in the same delegatory fashion, and <i>CTenant::QueryInterface </i>is augmented to handle the new interfaces:</p>
<pre><code>STDMETHODIMP CImpIOleControlSite::QueryInterface(REFIID riid
 &nbsp; , LPVOID *ppv)
 &nbsp; {
 &nbsp; return m_pUnkOuter-&gt;QueryInterface(riid, ppv);
 &nbsp; }

//Same for IPropertyNotifySink and IDispatch (ambients)

...

STDMETHODIMP CTenant::QueryInterface(REFIID riid, PPVOID ppv)
 &nbsp; {
 &nbsp; *ppv=NULL;

 &nbsp; if (IID_IUnknown==riid)
 &nbsp;&nbsp;&nbsp;&nbsp; *ppv=this;

 &nbsp; if (IID_IOleClientSite==riid)
 &nbsp;&nbsp;&nbsp;&nbsp; *ppv=m_pIOleClientSite;

 &nbsp; if (IID_IAdviseSink2==riid || IID_IAdviseSink==riid)
 &nbsp;&nbsp;&nbsp;&nbsp; *ppv=m_pIAdviseSink;

 &nbsp; if (IID_IOleWindow==riid || IID_IOleInPlaceSite==riid)
 &nbsp;&nbsp;&nbsp;&nbsp; *ppv=m_pIOleIPSite;

 &nbsp; //CONTROLMOD
 &nbsp; if (IID_IOleControlSite==riid)
 &nbsp;&nbsp;&nbsp;&nbsp; *ppv=m_pIOleControlSite;

 &nbsp; if (IID_IPropertyNotifySink==riid)
 &nbsp;&nbsp;&nbsp;&nbsp; *ppv=m_pIPropNoteSink;

 &nbsp; //Queries for IDispatch return the ambient properties interface
 &nbsp; if (IID_IDispatch==riid)
 &nbsp;&nbsp;&nbsp;&nbsp; *ppv=m_pIDispatch;
 &nbsp; //End CONTROLMOD

 &nbsp; if (NULL!=*ppv)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; ((LPUNKNOWN)*ppv)-&gt;AddRef();
 &nbsp;&nbsp;&nbsp;&nbsp; return NOERROR;
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return ResultFromScode(E_NOINTERFACE);
 &nbsp; }
</code></pre>
<p>
<i>CTenant::QueryInterface </i>never returns a pointer to the events <i>IDispatch</i>; instead, any requests for <i>IDispatch</i> return the one for ambient properties. The site still maintains the events <i>IDispatch</i>, but that interface has its own version of <i>QueryInterface</i> to support the idea that it's conceptually contained within and separate from the site:</p>
<pre><code>STDMETHODIMP CImpIDispatchEvents::QueryInterface(REFIID riid, PPVOID ppv)
 &nbsp; {
 &nbsp; *ppv=NULL;

 &nbsp; /*
 &nbsp;&nbsp;&nbsp;&nbsp; * This interface stands alone. Note that it is IUnknown,
 &nbsp;&nbsp;&nbsp;&nbsp; * IDispatch, AND the events IID of the control, so we must
 &nbsp;&nbsp;&nbsp;&nbsp; * respond to all three.
 &nbsp;&nbsp;&nbsp;&nbsp; */
 &nbsp; if (IID_IUnknown==riid || IID_IDispatch==riid
 &nbsp;&nbsp;&nbsp;&nbsp; || m_pTen-&gt;m_iidEvents==riid)
 &nbsp;&nbsp;&nbsp;&nbsp; *ppv=this;

 &nbsp; if (NULL!=*ppv)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; ((LPUNKNOWN)*ppv)-&gt;AddRef();
 &nbsp;&nbsp;&nbsp;&nbsp; return NOERROR;
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return ResultFromScode(E_NOINTERFACE);
 &nbsp; }
</code></pre>
<p>
Besides returning its own pointer for <i>IUnknown </i>and <i>IDispatch</i> requests, the events <i>IDispatch</i> <b>must also return its <i>IDispatch </i>pointer when asked for the IID of the control's event set </b>dispinterface. This is very important because the control will, as part of its connection point implementation, query the events <i>IDispatch </i>for the events IID. The <i>CTenant::m_iidEvents</i> variable is set to the events IID during control initialization, as we'll see later. For now, it's good to have this code in place so that when we do set the IID, this code will begin working properly.</p>
<p>
Now that we have variables and interfaces in place, we can look at control creation.</p>
<h3>Implement Control-Specific Creation Cases</h3>
<p>
At this point we're ready to create controls, but a control container will need a little bit of user interface to facilitate creation. A full control container will generally include the following, although I have not seen any strict requirements for these UI elements:
<ul type=disc>
<li>
A dialog in which the user can add or remove controls from the system. This is typically a dialog that shows the currently registered controls. Pressing an "Add" button opens a file browsing dialog in which the user locates the .OCX file, and when located, the container checks the version information for "OleSelfRegister" and calls <i>DllRegisterServer</i>. A "Remove" button in this dialog would call <i>DllUnregisterServer</i> to remove the control from the registry.<br><br></li>
<li>
The ability to create a toolbox with buttons for each registered control where the button image is taken from the "ToolboxBitmap" entry under the control's CLSID. The container should be robust in case it cannot obtain a bitmap for some reason.<br><br></li>
<li>
The ability to add another option to the standard Insert Object dialog alongside "Create New" and "Create From File" that reads "Create Control." When selected, the listbox in the dialog should show only registered controls (those with the "Control" key in the registry) and not show any other compound document objects. The "Create New" list should show only those controls with the "Insertable" key as is normal for compound documents.</li>
</ul>
<p>
I have to admit that CPatron skimps a great deal on this UI—basically it doesn't implement any of it at this time. In order to do self-registration/unregistration of controls you will have to use the TSTCON or REGSVR apps that come with the controls development kit (VC++ 2.0). CPatron doesn't create any sort of toolbox, so registered bitmaps are ignored. Furthermore, CPatron just uses its normal Insert Object dialog for creating controls—that is, it doesn't look for controls specifically. This means that when you run CPatron to try it out, the Insert Object dialog will not normally have all registered controls showing, because some controls do not include the "Insertable" key. CPatron, however, should handle all the registered controls just fine, <b>so you will need to manually add the "Insertable" key under the ProgID for each control</b>. Otherwise you're going to be confused (as I was for a long time) as to why these controls are not showing up in the list. Do note that marking these controls as Insertable will allow you to stick them into other compound document containers in which bad things can happen—doing this was a hack just because I didn't get around to implementing a control-specific dialog before writing this article.</p>
<p>
In any case, one way or another the container ends up with a CLSID from Insert Object or whatever dialog allows the user to choose a control to create. With this CLSID, CPatron simply goes through its normal creation process (<i>CTenant::UCreate</i>) for compound document objects: call <i>OleCreate</i>, then initialize the object (<i>CTenant::FObjectInitialize</i>)<i> </i>through such interfaces as <i>IPersistStorage </i>and <i>IOleObject</i>. CPatron doesn't make any provision for working with controls marked OLEMISC_SETCLIENTSITEFIRST, nor does it handle objects that use <i>IPersistStream</i> as opposed to <i>IPersistStorage</i>, basically because of the uncertainties surrounding these things as described in the first section of this document. So for now, CPatron simply treats controls as if they were normal embedded objects.</p>
<p>
Although the next section describes extra control initialization, there is one small modification made for controls that's found in the <i>CPage::TenantCreate </i>(PAGE.CPP) function:</p>
<pre><code>if (!m_pTenantCur-&gt;HasControl())
 &nbsp; {
 &nbsp; m_pTenantCur-&gt;Activate(OLEIVERB_SHOW, NULL);
 &nbsp; m_pTenantCur-&gt;Update();
 &nbsp; }
</code></pre>
<p>
This code is executed as the last step in the control creation process. Normally what it does is activate the object immediately, showing it for editing. This is what we want to happen for compound document objects, but "showing" a control, especially in another window, is not necessary and is, in fact, quite pointless. So here CPatron calls <i>CTenant::HasControl </i>(which returns TRUE or FALSE depending on whether the tenant's initialization process found <i>IOleControl</i>), and if we do have a control we skip the activation. Most controls only make sense to activate in place, and if a control was created we've already activated it in place by this time.</p>
<h3>Initialize Controls</h3>
<p>
As mentioned in the previous section, all objects in CPatron are initialized with <i>CTenant::FObjectInitialize</i>. To handle controls, this initialization function also calls <i>CTenant::FControlInitialize</i>,<i> </i>which (as you might guess) handles control-specific steps. Following are the steps executed in <i>FControlInitialize</i>:
<ol>
<li>
Query the object for its <i>IOleControl</i> pointer. If this fails, the object is not a control. CPatron uses this pointer (which is initially NULL) as a flag to determine if the site has a control (as with <i>CTenant::HasControl</i>).<br><br></li>
<li>
Retrieve the control's CONTROLINFO structure for keyboard handling. CPatron retrieves this and saves it, although it doesn't do anything with it. If you successfully retrieve this information, set a flag so you later know whether to use this information when handling keystrokes.<br><br></li>
<li>
Query the object for its <i>IDispatch</i> interface, through which you can access control properties and methods. CPatron retrieves this pointer but never uses it; other containers obviously will.<br><br></li>
<li>
Connect your <i>IPropertyNotifySink</i> to the control using connection points.<br><br></li>
<li>
Connect your events <i>IDispatch</i> to the control and initialize your event mapping structures. This is a rather involved process, which is spelled out in more detail in the "Connect and Initialize Events" section.</li>
</ol>
<p>
We can see these steps implemented in code:</p>
<pre><code>BOOL CTenant::FControlInitialize(void)
 &nbsp; {
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp; hr;
 &nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fEvents;

 &nbsp; if (NULL==m_pObj)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; //1. Check if the object is a control
 &nbsp; hr=m_pObj-&gt;QueryInterface(IID_IOleControl, (PPVOID)&amp;m_pIOleControl);

if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; //2. Get the keyboard information
 &nbsp; m_fHaveControlInfo=SUCCEEDED(m_pIOleControl-&gt;GetControlInfo(&amp;m_ctrlInfo));

 &nbsp; //3. Get the IDispatch for properties and methods
 &nbsp; m_pObj-&gt;QueryInterface(IID_IDispatch, (PPVOID)&amp;m_pIDispatchControl);

 &nbsp; //4. Connect to property notifications
 &nbsp; m_pIPropNoteSink=new CImpIPropertyNotifySink(this, this);
 &nbsp; InterfaceConnect(m_pObj, IID_IPropertyNotifySink, m_pIPropNoteSink, &amp;m_dwConnProp);


 &nbsp; //5. Connect to the control's events
 &nbsp; ObjectEventsIID(m_pObj, &amp;m_iidEvents);

 &nbsp; m_pIDispatchEvents=new CImpIDispatchEvents(this, this);
 &nbsp; fEvents=InterfaceConnect(m_pObj, m_iidEvents, m_pIDispatchEvents, &amp;m_dwConnEvents);

 &nbsp; //Initialize the event map (or load it if saved previously)
 &nbsp; if (fEvents)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; LPTYPEINFO&nbsp;&nbsp; pITypeInfo;
 &nbsp;&nbsp;&nbsp;&nbsp; LPSTREAM&nbsp;&nbsp;&nbsp; pIStream;

 &nbsp;&nbsp;&nbsp;&nbsp; //Get the ITypeInfo specifically for events (connect.cpp)
 &nbsp;&nbsp;&nbsp;&nbsp; fEvents=ObjectTypeInfoEvents(m_pObj, &amp;pITypeInfo);

 &nbsp;&nbsp;&nbsp;&nbsp; if (fEvents)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fEvents=FALSE;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //CEventMap implemented in events.cpp
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pEventMap=new CEventMap(pITypeInfo);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (NULL!=m_pEventMap)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fEvents=m_pEventMap-&gt;Init();

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Check if there's mappings already and load them.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fEvents)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(m_pIStorage-&gt;OpenStream(SZEVENTSSTREAM, NULL, STGM_DIRECT
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pEventMap-&gt;Deserialize(pIStream);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIStream-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pITypeInfo-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp; if (!fEvents)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InterfaceDisconnect(m_pObj, m_iidEvents, &amp;m_dwConnEvents);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReleaseInterface((IUnknown **)&amp;m_pIDispatchEvents);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete m_pEventMap;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pEventMap=NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }

return TRUE;
 &nbsp; }
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This code doesn't match line-for-line with the code in the sample source—for brevity some comments are removed, others shortened, and some of the lines that word-wrap in 80 columns are unwrapped here. It is the same code, however.</p>
<p>
Steps 1, 2, and 3 are trivial: Retrieve the pointers and information you'll need for later use. Step 4 involves the use of connection points, and step 5 is even more complex, so they warrant separate sections.</p>
<h4>Connect property sink notifications</h4>
<p>
The whole point of what we're about to do is connect our <i>IPropertyNotifySink </i>interface to the control so that the control can call us as described earlier in this document. To accomplish this we need to execute the following steps:
<ol>
<li>
Query the object for its <i>IConnectionPointContainer</i>.<br><br></li>
<li>
Call <i>IConnectionPointContainer::FindConnectionPoint</i>, passing to it <i>IID_IPropertyNotifySink</i>. This will return an <i>IConnectionPoint</i> interface for property notifications.<br><br></li>
<li>
Call <i>IConnectionPoint::Advise</i> passing our <i>IPropertyNotifySink</i> pointer (which is cast to an <i>IUnknown</i> for <i>Advise</i>). On return we are given a DWORD key that we later use to disconnect the notifications (see below).<br><br></li>
<li>
Call <i>IConnectionPoint::Release</i> and <i>IConnectionPointContainer::Release </i>to clean up. (Some containers may wish to cache these pointers so as to not have to query for them later to disconnect, which is fine. CPatron does not to reduce the overall number of site variables).</li>
</ol>
<p>
CPatron implements these steps in a generic connection function, <i>InterfaceConnect</i>, that is found in CONNECT.CPP. This function is intended to be generic enough so that you can cut and paste it, unmodified, into your own container code. As shown in the code above, the initialization procedure calls this function with a pointer to the object's <i>IUnknown</i> (<i>IID_IPropertyNotifySink</i>), the site's <i>IPropertyNotifySink</i> pointer (as an <i>IUnknown</i>), and the address of <i>CTenant::m_dwConnProp</i> in which is stored the connection key:</p>
<pre><code>BOOL InterfaceConnect(LPUNKNOWN pObj, REFIID riid
 &nbsp; , LPUNKNOWN pIUnknownSink, LPDWORD pdwConn)
 &nbsp; {
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr;
 &nbsp; LPCONNECTIONPOINTCONTAINER pCPC;
 &nbsp; LPCONNECTIONPOINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCP;

 &nbsp; if (NULL==pObj || NULL==pIUnknownSink || NULL==pdwConn)
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; hr=pObj-&gt;QueryInterface(IID_IConnectionPointContainer
 &nbsp;&nbsp;&nbsp;&nbsp; , (PPVOID)&amp;pCPC);

 &nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; hr=pCPC-&gt;FindConnectionPoint(riid, &amp;pCP);

 &nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; hr=pCP-&gt;Advise(pIUnknownSink, pdwConn);
 &nbsp;&nbsp;&nbsp;&nbsp; pCP-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; pCPC-&gt;Release();
 &nbsp; return SUCCEEDED(hr);
 &nbsp; }
</code></pre>
<p>
You can see that there's nothing fancy going on here, just the straight sequence of using connection points to hand the control an outgoing interface pointer. Once this code is complete (and successful), the control will have a pointer through which to notify us when properties change.</p>
<p>
When we delete the object or otherwise destroy the site, we need to perform similar steps to disconnect the <i>IPropertyNotifySink</i> from the object. Disconnection happens in <i>CTenant::Close</i>:</p>
<pre><code>if (0!=m_dwConnProp)
 &nbsp; {
 &nbsp; InterfaceDisconnect(m_pObj
 &nbsp;&nbsp;&nbsp;&nbsp; , IID_IPropertyNotifySink, &amp;m_dwConnProp);
 &nbsp; }
</code></pre>
<p>
The generic function <i>InterfaceDisconnect</i>, also in CONNECT.CPP and also made to be pastable into your own code, performs the same sequence of calls as <i>InterfaceConnect</i>, except that it calls <i>IConnectionPoint::Unadvise</i> instead of <i>Advise</i> with the DWORD key returned from <i>Advise</i>:</p>
<pre><code>BOOL InterfaceDisconnect(LPUNKNOWN pObj, REFIID riid
 &nbsp; , LPDWORD pdwConn)
 &nbsp; {
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr;
 &nbsp; LPCONNECTIONPOINTCONTAINER pCPC;
 &nbsp; LPCONNECTIONPOINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCP;

 &nbsp; if (NULL==pObj || NULL==pdwConn)
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; if (0==*pdwConn)
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; hr=pObj-&gt;QueryInterface(IID_IConnectionPointContainer
 &nbsp;&nbsp;&nbsp;&nbsp; , (PPVOID)&amp;pCPC);

 &nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; hr=pCPC-&gt;FindConnectionPoint(riid, &amp;pCP);

 &nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; hr=pCP-&gt;Unadvise(*pdwConn);

 &nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pdwConn=0L;

 &nbsp;&nbsp;&nbsp;&nbsp; pCP-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; pCPC-&gt;Release();
 &nbsp; return SUCCEEDED(hr);
 &nbsp; }
</code></pre>
<p>
You'll notice that instead of passing the DWORD key to this function, we pass the address of the key. This is so <i>InterfaceDisconnect</i> can zero the key when it successfully disconnects, allowing us to use the key as a flag that indicates whether or not we're connected.</p>
<h4>Connect and initialize events</h4>
<p>
For the most part, connecting our events <i>IDispatch</i> to the control happens in exactly the same way as with <i>IPropertyNotifySink</i>—the same <i>InterfaceConnect </i>and <i>InterfaceDisconnect</i> functions apply perfectly. However, the main trick in connecting to the control's events is finding the IID for the connection point. As shown in the initialization code above, CPatron calls a function <i>ObjectEventsIID</i> to retrieve the dispinterface IID for events, saving that IID in <i>CTenant::m_iidEvents </i>(which, again, we use in the <i>QueryInterface</i> function for the events <i>IDispatch</i>):</p>
<pre><code>ObjectEventsIID(m_pObj, &amp;m_iidEvents);
</code></pre>
<p>
Let's first see how this magic function works, then we'll look at initializing our event map.</p>
<p>
<b>Finding the events IID</b></p>
<p>
<i>ObjectEventsIID </i>is another generic cut-and-paste function found in CONNECT.CPP that plays a few games with OLE Automation interfaces to find the IID we want:</p>
<pre><code>BOOL ObjectEventsIID(LPUNKNOWN pObj, IID *piid)
 &nbsp; {
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr;
 &nbsp; LPTYPEINFO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pITypeInfo;
 &nbsp; LPTYPEATTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTA;

 &nbsp; *piid=CLSID_NULL;

 &nbsp; if (!ObjectTypeInfoEvents(pObj, &amp;pITypeInfo))
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; hr=pITypeInfo-&gt;GetTypeAttr(&amp;pTA);

 &nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; *piid=pTA-&gt;guid;
 &nbsp;&nbsp;&nbsp;&nbsp; pITypeInfo-&gt;ReleaseTypeAttr(pTA);
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; pITypeInfo-&gt;Release();
 &nbsp; return SUCCEEDED(hr);
 &nbsp; }
</code></pre>
<p>
This function first locates the <i>ITypeInfo</i> interface for the events dispinterface by calling another function in CONNECT.CPP called <i>ObjectTypeInfoEvents</i>. With this pointer we only need to call <i>ITypeInfo::GetTypeAttr</i> to retrieve the TYPEATTR structure in the dispinterface's IID resides (in the <i>guid</i> field). That done, we release the TYPEATTR structure and the <i>ITypeInfo</i> interface, and we're done. Easy enough?</p>
<p>
Well, we still need to know how we get the right <i>ITypeInfo</i> pointer, which is the purpose of the <i>ObjectTypeInfoEvents </i>function. As described earlier, we have to look through the object's entire (coclass) type info to find the dispinterface marked <b>Default </b>and <b>Source</b>. This first requires us to obtain the coclass type info using the new <i>IProvideClassInfo</i> interface. This step is implemented in the <i>ObjectTypeInfo</i> function in CONNECT.CPP:</p>
<pre><code>BOOL ObjectTypeInfo(LPUNKNOWN pObj, LPTYPEINFO *ppITypeInfo)
 &nbsp; {
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr;
 &nbsp; LPPROVIDECLASSINFO pIProvideClassInfo;

 &nbsp; if (NULL==pObj || NULL==ppITypeInfo)
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; *ppITypeInfo=NULL;

 &nbsp; hr=pObj-&gt;QueryInterface(IID_IProvideClassInfo
 &nbsp;&nbsp;&nbsp;&nbsp; , (PPVOID)&amp;pIProvideClassInfo);

 &nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; hr=pIProvideClassInfo-&gt;GetClassInfo(ppITypeInfo);
 &nbsp; pIProvideClassInfo-&gt;Release();

 &nbsp; return SUCCEEDED(hr);
 &nbsp; }
</code></pre>
<p>
With this <i>ITypeInfo</i> pointer we can now look at the process of finding the right dispinterface:</p>
<pre><code>BOOL ObjectTypeInfoEvents(LPUNKNOWN pObj, LPTYPEINFO *ppITypeInfo)
 &nbsp; {
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr;
 &nbsp; LPTYPEINFO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pITypeInfoAll;
 &nbsp; LPTYPEATTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTA;

 &nbsp; if (NULL==pObj || NULL==ppITypeInfo)
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; if (!ObjectTypeInfo(pObj, &amp;pITypeInfoAll))
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; *ppITypeInfo=NULL;

 &nbsp; if (SUCCEEDED(pITypeInfoAll-&gt;GetTypeAttr(&amp;pTA)))
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;
 &nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iFlags;

 &nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i &lt; pTA-&gt;cImplTypes; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get the implementation type for this interface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr=pITypeInfoAll-&gt;GetImplTypeFlags(i, &amp;iFlags);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((iFlags &amp; IMPLTYPEFLAG_FDEFAULT)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (iFlags &amp; IMPLTYPEFLAG_FSOURCE))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HREFTYPE&nbsp;&nbsp; hRefType=NULL;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * This is the interface we want. Get a handle to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the type description from which we can then get
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the ITypeInfo.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pITypeInfoAll-&gt;GetRefTypeOfImplType(i, &amp;hRefType);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr=pITypeInfoAll-&gt;GetRefTypeInfo(hRefType
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , ppITypeInfo);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp; pITypeInfoAll-&gt;ReleaseTypeAttr(pTA);
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; pITypeInfoAll-&gt;Release();
 &nbsp; return (NULL!=*ppITypeInfo);
 &nbsp; }
</code></pre>
<p>
In this code we start with <i>pITypeInfoAll </i>pointing to the coclass type info. Calling its <i>GetTypeAttr </i>function gives us the TYPEATTR structure that contains the number of "types" or dispinterfaces in the class, in the <i>cImplTypes </i>field<i>. </i>We then iterate over all those types, for each calling <i>GetImplTypeFlags</i>, which will return us the attributes for each dispinterface. We're looking for the default source dispinterface, which will have the IMPTYPEFLAG_FDEFAULT and IMPLTYPEFLAG_FSOURCE flags. If both these flags are found, then we have discovered which dispinterface is the one we want. To finish up, then, we need to get the <i>ITypeInfo </i>pointer for that dispinterface with <i>GetRegTypeOfImplType</i> and <i>GetRefTypeInfo</i>. That done, we release the TYPEATTR we retrieved and release the coclass <i>ITypeInfo</i>, and we're done.</p>
<p>
If you have any questions about why this code works as it does, you'll need to read about the <i>ITypeInfo</i> interface in Volume 2 of the OLE <i>Programmer's Reference</i>. All this code is strictly OLE Automation, except for the default and source flags, which are extensions defined in OLE Controls.</p>
<p>
<b>Initializing an event map</b></p>
<p>
Once CPatron has obtained the events IID, it calls <i>InterfaceConnect</i> to link its events <i>IDispatch</i> to the control. What is now left to do is to initialize the structures we use to map events to user-defined actions in the container.</p>
<p>
CPatron uses another class, CEventMap (TENANT.H and EVENTS.CPP), to maintain a mapping from event DISPIDs to actions:</p>
<pre><code>//Event actions
typedef enum
 &nbsp; {
 &nbsp; ACTION_NONE=-1,
 &nbsp; ACTION_BEEPDEFAULT=MB_OK,
 &nbsp; ACTION_BEEPASTERISK=MB_ICONASTERISK,
 &nbsp; ACTION_BEEPEXCLAMATION=MB_ICONEXCLAMATION,
 &nbsp; ACTION_BEEPHAND=MB_ICONHAND,
 &nbsp; ACTION_BEEPQUESTION=MB_ICONQUESTION,
 &nbsp; ACTION_TAILING=-2
 &nbsp; } EVENTACTION;


typedef struct tagEVENTMAP
 &nbsp; {
 &nbsp; DISPID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Event ID
 &nbsp; EVENTACTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iAction;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Action to take
 &nbsp; BSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bstrName;&nbsp;&nbsp;&nbsp;&nbsp; //Event name (function only)
 &nbsp; } EVENTMAP, *PEVENTMAP;


class CEventMap
 &nbsp; {
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_cEvents;
 &nbsp;&nbsp;&nbsp;&nbsp; LPTYPEINFO&nbsp;&nbsp;&nbsp;&nbsp; m_pITypeInfo;
 &nbsp;&nbsp;&nbsp;&nbsp; PEVENTMAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pEventMap;

 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; CEventMap(LPTYPEINFO);
 &nbsp;&nbsp;&nbsp;&nbsp; ~CEventMap(void);

 &nbsp;&nbsp;&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Init(void);
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set(DISPID, EVENTACTION);
 &nbsp;&nbsp;&nbsp;&nbsp; EVENTACTION&nbsp; Get(DISPID);
 &nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serialize(LPSTREAM);
 &nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Deserialize(LPSTREAM);
 &nbsp; };

typedef CEventMap *PCEventMap;

//Events stream in the object storage
#define SZEVENTSSTREAM TEXT("\003Event Mappings")
</code></pre>
<p>
This structure is only instantiated and initialized if the site successfully connected to the control's events. What is of interest to us at this point is how we learn the names and IDs of the events so we can use such information in the event UI that we'll implement later. So here I want to look at the construction and initialization of a CEventMap object, leaving the details about mapping actions and serialization of the mappings to later sections.</p>
<p>
A note about design: CPatron doesn't do much with events and handles them in a very simplistic manner—all it does is map a DISPID to a system beep. It doesn't handle event parameters that are meaningful to more sophisticated containers. Such containers will need a much more complex data structure to maintain event mapping information to make use of event parameters. However, the general idea of maintaining a map of some sort, and how we work with that map in the events <i>IDispatch</i>, is pretty much the same regardless of the complexity of event mapping, so that is what CPatron demonstrates.</p>
<p>
After successfully connecting the control's events, we construct a CEventMap object, passing to it the <i>ITypeInfo </i>of the events dispinterface that we get from <i>ObjectEventsTypeInfo</i>:</p>
<pre><code>m_pEventMap=new CEventMap(pITypeInfo);
</code></pre>
<p>
This does little more than hold onto the <i>ITypeInfo</i> pointer:</p>
<pre><code>CEventMap::CEventMap(LPTYPEINFO pITypeInfo)
 &nbsp; {
 &nbsp; m_cEvents=0;
 &nbsp; m_pITypeInfo=pITypeInfo;

 &nbsp; if (NULL!=m_pITypeInfo)
 &nbsp;&nbsp;&nbsp;&nbsp; m_pITypeInfo-&gt;AddRef();

 &nbsp; m_pEventMap=NULL;
 &nbsp; return;
 &nbsp; }
</code></pre>
<p>
If this creation succeeds, we tell the CEventMap to initialize. Initialization allocates an array of EVENTMAP structures, one for each event in the dispinterface. The EVENTMAP structure saves the DISPID, the text name, and the action (a <i>MessageBeep </i>parameter) associated with the event. The interesting part of initialization is retrieving the name and ID of each:</p>
<pre><code>BOOL CEventMap::Init(void)
 &nbsp; {
 &nbsp; LPTYPEATTR&nbsp;&nbsp;&nbsp; pTA;
 &nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;

 &nbsp; if (NULL==m_pITypeInfo)
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; if (FAILED(m_pITypeInfo-&gt;GetTypeAttr(&amp;pTA)))
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp; m_cEvents=pTA-&gt;cFuncs;
 &nbsp; m_pITypeInfo-&gt;ReleaseTypeAttr(pTA);

 &nbsp; m_pEventMap=new EVENTMAP[m_cEvents];

 &nbsp; if (NULL==m_pEventMap)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; m_cEvents=0;
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; for (i=0; i &lt; m_cEvents; i++)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; LPFUNCDESC&nbsp;&nbsp;&nbsp; pFD;

 &nbsp;&nbsp;&nbsp;&nbsp; m_pEventMap[i].id=0;
 &nbsp;&nbsp;&nbsp;&nbsp; m_pEventMap[i].bstrName=NULL;
 &nbsp;&nbsp;&nbsp;&nbsp; m_pEventMap[i].iAction=ACTION_NONE;

 &nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(m_pITypeInfo-&gt;GetFuncDesc(i, &amp;pFD)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cNames;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; hr;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pEventMap[i].id=pFD-&gt;memid;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr=m_pITypeInfo-&gt;GetNames(pFD-&gt;memid
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , &amp;m_pEventMap[i].bstrName, 1, &amp;cNames);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pITypeInfo-&gt;ReleaseFuncDesc(pFD);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return TRUE;
 &nbsp; }
</code></pre>
<p>
All of this code is straight OLE Automation again. We use <i>ITypeInfo::GetTypeAttr </i>again because the TYPEATTR field <i>cFuncs</i> is the number of functions or members in the dispinterface—that is, the number of events. We use this information to know how many EVENTMAPs to allocate. Once allocated, we loop through each member to retrieve whatever information we're interested in keeping. In CPatron it's the DISPID and name; other containers will want more information about the parameters as well. In any case, you must first retrieve the FUNCDESC structure for the member by calling <i>ITypeInfo::GetFuncDesc</i> passing the index of the member you're looping on at the moment.</p>
<p>
The FUNCDESC structure tells you all sorts of things, such as the number of parameters and so forth. What we're interested in here is the <i>memid </i>(member ID) field, which is the event DISPID. We can then call <i>ITypeInfo::GetNames</i> with this DISPID to retrieve the first name in the member, which is the event name itself. The parameter "1" to <i>GetNames</i> says we're only interested in getting back one name, a pointer to which we store in the <i>bstrName</i> field of our EVENTMAP. If you want parameters' names (and other info) as well, you need to use the <i>FUNCDESC::cParams</i> value, which tells you how many parameters there are to the function. Then allocate an array of BSTRs of size <i>cParams+1 </i>(+1 to include the function name itself) and pass <i>cParams+1</i> to <i>GetNames</i>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;I'm not sure how you retrieve the specific parameter types, I'm not that far into Automation yet. . . .</p>
<p>
After all of this, we'll have a CEventMap that has in it all the names of the events and their DISPIDs. We'll use this in creating an events dialog later on, as well as for serialization and deserialization to the "\003Event Mappings" stream in which CPatron saves this information. But those are topics for later sections; the only other thing to mention here is that the BSTR pointers returned by <i>ITypeInfo::GetNames</i> must be freed using <i>SysFreeString</i> (an Automation API). We can see how this works in the CEventMap destructor:</p>
<pre><code>CEventMap::~CEventMap(void)
 &nbsp; {
 &nbsp; if (NULL!=m_pITypeInfo)
 &nbsp;&nbsp;&nbsp;&nbsp; m_pITypeInfo-&gt;Release();

 &nbsp; if (NULL!=m_pEventMap)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;

 &nbsp;&nbsp;&nbsp;&nbsp; //Be sure to clean up allocated BSTRs
 &nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i &lt; m_cEvents; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SysFreeString(m_pEventMap[i].bstrName);

 &nbsp;&nbsp;&nbsp;&nbsp; delete [] m_pEventMap;
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return;
 &nbsp; }
</code></pre>
<p>
Of course, this also releases the <i>ITypeInfo</i> interface and deletes the EVENTMAP structure.</p>
<h3>Implement "Design-Mode"</h3>
<p>
Once you've completed the creation and initialization steps of your container, you can start creating controls and placing them on your forms or documents. If you started this implementation with a container that handles inside-out objects, you'll be able to create a control and play with it. If you run your application in a debugger you should also see calls made to your <i>IOleControlSite</i> interface, your ambient properties <i>IDispatch</i>, and even your events <i>IDispatch</i>! Unfortunately, we don't do anything with these interfaces yet, and we'll get to that in a moment.</p>
<p>
More pressing, however, is something that I noticed about my container after I started plopping controls onto a document: When a control is in-place active (or UI active), the container's grab handles were not visible. Therefore I had no way to move or resize controls! This is bad—because my container always creates a new object in the upper-left corner of a page (I'm lazy—I didn't put in any logic to place them in empty places on the page), creating multiple controls would basically pile them up in the same place. Not all that useful.</p>
<p>
To remedy this situation I basically needed a way to put the controls into a mode in which I could move and size them. I therefore implemented a "Design Mode" feature. This meant adding a top-level menu item (to the Page menu, see PATRON.RC) that is enabled whenever there's a document available. This command is routed from the frame window (<i>CPatronFrame::OnCommand </i>in PATRON.CPP) to the document (<i>CPatronDoc::FToggleOrQueryDesignMode</i> in DOCUMENT.CPP) to the page manager (<i>CPages::ToggleDesignMode </i>in PAGES.CPP) to the page (<i>CPage::ToggleDesignMode </i>in PAGE.CPP), which loops through all the sites in the page to call <i>CTenant::ToggleDesignMode </i>(TENANT.CPP). I know, going through this many functions for commands like this is pretty ugly; sooner or later I’ll improve this setup, but as you can probably understand, I’ve just never had the time! This function activates or deactivates objects when we change modes:</p>
<pre><code>void CTenant::ToggleDesignMode(BOOL fDesign)
 &nbsp; {
 &nbsp; BOOL&nbsp;&nbsp; fChange=!(m_fDesignMode &amp; fDesign);

 &nbsp; if (fDesign==m_fDesignMode)
 &nbsp;&nbsp;&nbsp;&nbsp; return;

 &nbsp; m_fDesignMode=fDesign;

 &nbsp; /*
 &nbsp;&nbsp; * Inform the control of ambient property changed. A change
 &nbsp;&nbsp; * in design mode changes UserMode, ShowGrabHandles, and
 &nbsp;&nbsp; * ShowHatching (see AMBIENTS.CPP)
 &nbsp;&nbsp; */

 &nbsp; AmbientChange(DISPID_AMBIENT_USERMODE);
 &nbsp; AmbientChange(DISPID_AMBIENT_SHOWGRABHANDLES);
 &nbsp; AmbientChange(DISPID_AMBIENT_SHOWHATCHING);

 &nbsp; if (m_fDesignMode)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; //This even deactivates inside-out objects
 &nbsp;&nbsp;&nbsp;&nbsp; DeactivateInPlaceObject(TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp; Invalidate();
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; //First hide whatever windows might be open
 &nbsp;&nbsp;&nbsp;&nbsp; if (TENANTSTATE_OPEN &amp; m_dwState)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Activate(OLEIVERB_HIDE, NULL);

 &nbsp;&nbsp;&nbsp;&nbsp; //Activate all tenants, UI activate the selected one
 &nbsp;&nbsp;&nbsp;&nbsp; Activate(OLEIVERB_INPLACEACTIVATE, NULL);

 &nbsp;&nbsp;&nbsp;&nbsp; if (TENANTSTATE_SELECTED &amp; m_dwState)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Activate(OLEIVERB_UIACTIVATE, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return;
 &nbsp; }
</code></pre>
<p>
If we enter design mode, we call <i>IOleInPlaceObject::InPlaceDeactivate </i>on every object (followed by a repainting of the site). This removes the object's in-place window and any other UI elements, making the object look like a normal, inactive, embedded object that CPatron can move and size as desired (using mouse tracking and drag-and-drop code in other parts of the application). If we reenter design mode, we basically in-place activate all objects again and UI activate the currently selected tenant, which is the one that has the focus. In this code we also hide any object that happens to be open, just in case—if for some reason an object is showing in a different window (this is known to the site from <i>IOleClientSite::ShowWindow</i>) we want to close that window. Sending the hide verb accomplished just that.</p>
<p>
Switching to and from design mode has another potential side effect: changing ambient properties. In our case, the <b>UserMode</b>, <b>ShowGrabHandles</b>, and <b>ShowHatching</b> ambient properties depend on the <i>CTenant::m_fDesignMode </i>flag (we'll see this when we implement ambient properties). So when the design mode flag changes, these ambient properties will change, and we must notify the control by calling <i>IOleControl::OnAmbientPropertyChange</i>. This is done through <i>CTenant::AmbientChange</i> (which just simplifies other code in CTenant so it doesn't always have to check for a NULL <i>m_pIOleControl </i>pointer):</p>
<pre><code>void CTenant::AmbientChange(DISPID dispID)
 &nbsp; {
 &nbsp; if (NULL!=m_pIOleControl)
 &nbsp;&nbsp;&nbsp;&nbsp; m_pIOleControl-&gt;OnAmbientPropertyChange(dispID);

 &nbsp; return;
 &nbsp; }
</code></pre>
<p>
There are now a few other small considerations and modifications to make concerning design mode:
<ul type=disc>
<li>
First, be sure to tell any new sites you create about the current design mode setting (CTenant copies the <i>CPages::m_fDesignMode </i>flag in its constructor) or else things will start working in very strange ways and you won't know why (can you tell this happened to me?).<br><br></li>
<li>
Second, ignore the OLEMISC_ACTIVATEWHENVISIBLE flag—the purpose of design mode is to deactivate everything so this flag is irrelevant.<br><br></li>
<li>
Third, I added a fragment of code to suppress drawing of handles on objects if they are marked OLEMISC_INVISIBLEATRUNTIME, but I have to add the design mode condition as well.<br><br></li>
<li>
Fourth, my sites have a <i>Select </i>function that normally changes the UI activation of objects as selection changes; activation doesn't occur in design mode.<br><br></li>
<li>
Finally, the <i>IOleInPlaceSite::OnInPlaceActivate</i> function should return S_FALSE if you are in design mode. This will ensure that no object tries to activate in place if for some reason it ends up here (and this is the same reason why you want to send the Hide verb when you go into run mode, in case the control made any popup windows because of non-in-place activation).</li>
</ul>
<p>
Another way that might work to do design mode—which I have not tried, so I cannot guarantee this working—is to set the ambient properties for <i>ShowGrabHandles</i> and <i>ShowHatching</i> to TRUE in design mode and FALSE in run mode, which might allow object movement and resizing. With these ambient properties set to TRUE, a control should show these elements; and if you move or size the control it should call <i>IOleInPlaceSite::OnPosRectChange</i>, in which case you update your site's position in the page. Potential problems are: (1) some controls may not support these UI elements (so you're stuck without them), and (2) a right-mouse click on the control will not generate a popup menu of the container's choosing, because the message will go to the control. To make things consistent, it is best to just deactivate everything.</p>
<h3>Handle Z-Order and MiscStatus Bits</h3>
<p>
Before we get into implementing interfaces and other major features, there are a few snippets of code you should add to work well with controls.</p>
<p>
First of all, you'll need to make sure that the Z-order of the controls matches the layering of controls that overlap each other. Your container may already handle this in some respects. When I started working on CPatron, I had already implemented Z-ordering of my sites so I could determine the order in which to draw them (the first one in the order was drawn last so as to appear on top). With multiple in-place active objects in your container at one time, you will have multiple child windows for those objects, the Z-order of which must match what your container understands to be the ordering.</p>
<p>
In doing an in-place activation implementation, I have a call to <i>SetWindowPos </i>in <i>CPage::SwitchActiveTenant</i>,<i> </i>which places the newly-UI-activated object at the top of the Windows Z-order, so I didn't need any changes to handle controls. I mention this here so you can check that your container handles windowing in the correct way as well. Note also that the order in which you reactivate controls coming out of design mode will determine the Windows Z-order: The first activated control will create its window first, and will therefore be first in the Z-order. CPatron activates controls according to its internal ordering, so this is done automatically as a virtue.</p>
<p>
Now is a good time to think about keeping a separate order list for implementing tab key functionality (CPatron does not do this, mind you). The tab order is different from the Z-order, inasmuch as it does not change as objects are activated. By default the tab order is generally the order in which controls were created, and containers that support this functionality will typically have a dialog box in which the order can be sorted (Microsoft Access does this, for example).</p>
<p>
The other set of considerations that introduce little bits of code are the new OLEMISC_* bits. I've already mentioned ignoring OLEMISC_ACTIVATEWHENVISIBLE if design mode is on. The other two of relevance here are OLEMISC_ALWAYSRUN and OLEMISC_INVISIBLEATRUNTIME. If OLEMISC_ALWAYSRUN is set, you should always call <i>OleRun</i> as soon as you load or create any object (CPatron does this in <i>CTenant::FObjectInitialize</i>). When OLEMISC_INVISIBLEATRUNTIME is set, you should suppress any code that can potentially draw anything for the object in your document or form when run time is active. Invisible controls will generally not even in-place activate, and before I added checks on this flag CPatron's handling of such objects was to draw the object's images from the cache and draw grab handles if it was selected. If this flag is set, CPatron now prevents any calls to <i>OleDraw </i>(<i>IViewObject[2]::Draw</i>) and other functions to draw hatching or grab handles.</p>
<h3>Implement the Ambient Properties <i>IDispatch</i></h3>
<p>
It's time now to fill in the <i>IDispatch </i>implementation for ambient properties, which is not at all complicated. If you are implementing only standard ambient properties, all the functions in this interface except <i>Invoke</i> can be left unimplemented (except small pieces of code to NULL out-parameters, which you must always do, even if you return E_NOTIMPL). Furthermore, you do not need any sort of type library or type information for standard properties because controls make compile-time assumptions about their types.</p>
<p>
If, however, you provide "other" ambient properties specific to your container, you will want to be able to provide the type information for those properties, so you will need to implement the other functions in <i>IDispatch</i>. Other properties are beyond the scope of this article, but filling out the implementation of <i>IDispatch</i> is just standard OLE Automation, so there's plenty of information elsewhere on doing it.</p>
<p>
That leaves us with the implementation of <i>Invoke</i> for ambient properties. In order to implement this function you will need to know which ambient properties you are going to expose and where the values of those properties are stored. In CPatron's case, it maintains a number of variables in the CTenant class for the ambient properties as listed in Table 6.</p>
<p class=label>
<b>Table 6. CPatron's Supported Ambient Properties and Implementing Variables</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=47%><b>Property ID</b></td>
<td class=label width=53%><b>Variable (CTenant unless otherwise stated)</b></td>
</tr>
<tr valign=top>
<td width=47%>DISPID_AMBIENT_BACKCOLOR</td>
<td width=53%><i>m_clrFore</i> (COLOR_WINDOW)</td>
</tr>
<tr valign=top>
<td width=47%>DISPID_AMBIENT_FORECOLOR</td>
<td width=53%><i>m_clrBack</i> (COLOR_WINDOWTEXT)</td>
</tr>
<tr valign=top>
<td width=47%>DISPID_AMBIENT_FONT</td>
<td width=53%><i>m_pPG-&gt;m_hFont</i> (<i>CPages::m_hFont</i>)</td>
</tr>
<tr valign=top>
<td width=47%>DISPID_AMBIENT_LOCALEID</td>
<td width=53%><i>m_lcid</i> (always LOCALE_USER_DEFAULT)</td>
</tr>
<tr valign=top>
<td width=47%>DISPID_AMBIENT_USERMODE</td>
<td width=53%><i>!m_fDesignMode</i></td>
</tr>
<tr valign=top>
<td width=47%>DISPID_AMBIENT_UIDEAD</td>
<td width=53%>FALSE</td>
</tr>
<tr valign=top>
<td width=47%>DISPID_AMBIENT_SUPPORTSMNEMONICS</td>
<td width=53%>TRUE</td>
</tr>
<tr valign=top>
<td width=47%>DISPID_AMBIENT_SHOWGRABHANDLES</td>
<td width=53%><i>!m_fDesignMode</i></td>
</tr>
<tr valign=top>
<td width=47%>DISPID_AMBIENT_SHOWHATCHING</td>
<td width=53%><i>!m_fDesignMode</i></td>
</tr>
</table><br>
<p>
<i>Invoke</i> ends up being little more than a big switch statement to put these values into the result parameter:</p>
<pre><code>STDMETHODIMP CImpIDispatch::Invoke(DISPID dispIDMember, REFIID riid
 &nbsp; , LCID lcid, unsigned short wFlags, DISPPARAMS * pDispParams
 &nbsp; , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
 &nbsp; {
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; hr;
 &nbsp; VARIANT&nbsp;&nbsp;&nbsp; varResult;

 &nbsp; if (IID_NULL!=riid)
 &nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode(E_INVALIDARG);

 &nbsp; if(NULL==pVarResult)
 &nbsp;&nbsp;&nbsp;&nbsp; pVarResult=&amp;varResult;

 &nbsp; VariantInit(pVarResult);

 &nbsp; //The most common case is Boolean; use as an initial type.
 &nbsp; V_VT(pVarResult)=VT_BOOL;

 &nbsp; //Anything but a property get is invalid.
 &nbsp; if (!(DISPATCH_PROPERTYGET &amp; wFlags))
 &nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode(DISP_E_MEMBERNOTFOUND);

 &nbsp; hr=NOERROR;

 &nbsp; switch (dispIDMember)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; case DISPID_AMBIENT_BACKCOLOR:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_I4(pVarResult)=m_pTen-&gt;m_clrBack;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_VT(pVarResult)=VT_I4;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case DISPID_AMBIENT_FORECOLOR:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_I4(pVarResult)=m_pTen-&gt;m_clrFore;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_VT(pVarResult)=VT_I4;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case DISPID_AMBIENT_FONT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_I4(pVarResult)=(LONG)(UINT)m_pTen-&gt;m_hFont;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_VT(pVarResult)=VT_I4;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case DISPID_AMBIENT_LOCALEID:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_I4(pVarResult)=m_pTen-&gt;m_lcid;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_VT(pVarResult)=VT_I4;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case DISPID_AMBIENT_USERMODE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_BOOL(pVarResult)=!m_pTen-&gt;m_fDesignMode;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case DISPID_AMBIENT_UIDEAD:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_BOOL(pVarResult)=FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case DISPID_AMBIENT_SUPPORTSMNEMONICS:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_BOOL(pVarResult)=TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case DISPID_AMBIENT_SHOWGRABHANDLES:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_BOOL(pVarResult)=m_pTen-&gt;m_fDesignMode;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case DISPID_AMBIENT_SHOWHATCHING:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_BOOL(pVarResult)=m_pTen-&gt;m_fDesignMode;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr=ResultFromScode(DISP_E_MEMBERNOTFOUND);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return hr;
 &nbsp; }
</code></pre>
<p>
Two things to notice about this code: First, this doesn't pay any attention to the locale ID. Second, CPatron considers ambient properties to be read-only, so anything other than DISPATCH_PROPERTYGET in <i>wFlags</i> is an error and extra parameters to the invoked member are ignored. The only suitable return code right now is DISP_E_MEMBERNOTFOUND, which really isn't appropriate. In the future there will probably be a DISP_E_ACCESSDENIED or something like that. Do note that ambient properties are not always necessarily read-only—if you want to allow modification, feel free to implement it.</p>
<p>
One other point: CPatron doesn't bother watching for WM_WININICHANGE for changes to the foreground and background colors. It really should, and when they change, the ambient properties change, so CPatron should be calling <i>IOleControl::OnAmbientPropertyChange</i> in all controls for both colors.</p>
<h3>Implement IPropertyNotifySink</h3>
<p>
If implementing <i>IDispatch</i> for ambient properties seemed easy, implementing <i>IPropertyNotifySink</i> is generally easier. Here's what CPatron has for it in IPROPNOT.CPP:</p>
<pre><code>STDMETHODIMP CImpIPropertyNotifySink::OnChanged(DISPID dispID)
 &nbsp; {
 &nbsp; return NOERROR;
 &nbsp; }

STDMETHODIMP CImpIPropertyNotifySink::OnRequestEdit(DISPID dispID)
 &nbsp; {
 &nbsp; return NOERROR;
 &nbsp; }
</code></pre>
<p>
Now this is not, of course, fully appropriate for a more sophisticated container. <i>OnChanged</i> is really an event like any other, but a very standard event. A container can allow the user to write code to attach to specific property changes; that is, the container can get the entire list of all control properties, present that list to the programmer, then allow the programmer to pick any property and attach code to the <i>OnChanged</i> notification. This is especially useful for controls whose Value property is attached to some dynamic data source—users of that control will typically want something else to happen when the value changes, and <i>OnChanged</i> can be used to detect the change instead of depending on the control firing an event (which it might do, but that's not guaranteed).</p>
<p>
<i>OnRequestEdit </i>is a little less commonly used. Microsoft Access uses it for lazy locking of database records, locking those records only when someone starts to change a value (in which case it returns NOERROR anyway). A container might also want a snapshot copy of the old value before it changed, perhaps to compare it to the new value—a container might generate detect events that the control might not otherwise send, such as when a change in a stock price exceeds a certain limit. Another use for <i>OnRequestEdit </i>would be for a container to implement some external read-only feature for object properties, checking the flag in this function to determine whether to allow the change.</p>
<p>
The bottom line is that at least you should return NOERROR from both functions. Whatever else you do with them is really specific to the container and depends upon the end-user features you provide.</p>
<h3>Implement Event UI and the Events IDispatch</h3>
<p>
Now for the fun part: event handling. Events are really what makes a control interesting, for most everything else is either OLE Automation (properties and methods) or mundane but necessary things like Insert Object dialogs and keyboard mnemonics. Implementing event handling in your container can be done in two steps:
<ol>
<li>
Implement UI in which the programmer/end user can assign actions to events.<br><br></li>
<li>
Implement the events <i>IDispatch </i>to respond to those events.</li>
</ol>
<p>
The following sections cover these topics. Before that, however, I want to remind you that now would be a good time to evaluate your possible uses of <i>IOleControl::FreezeEvents</i>. Think about times in your application where you would want to prevent excess calls into your interfaces or otherwise prevent event-handling code to really trash some other operation that's going on in the container. To be truly safe, you'll want to wrap any risky sections of code with <i>FreezeEvents(TRUE) </i>and <i>FreezeEvents(FALSE)</i>.</p>
<h4>Events UI</h4>
<p>
Depending on your container, the UI in which a user programs events can be anywhere from simple to mind-bogglingly complex. CPatron is a simple example: Because it only maps event DISPIDs to one of seven system beeps (none, machine speaker, default, exclamation, hand, question, asterisk) the UI that allows the user to program events is quite simple.</p>
<p>
Other applications like Visual Basic are basically structured around event handling. Most of what Visual Basic does is create a form, plop controls on the form, and assign code to control events. So Visual Basic has a lot of functionality for the purposes of writing code, using event parameters, calling methods in controls, manipulating properties, and so on. I expect that most people reading this article will be working on applications on the same order, but inasmuch as this is your livelihood, I'll leave it to you to work out all the details. CPatron's purpose is to illustrate how a container implements a general event handler for an arbitrary event set.</p>
<p>
We've already seen how CPatron creates an event map using the type information from an event dispinterface (see "Initializing an Event Map," above). By default, CPatron assigns no actions to any events. To allow the user to assign different actions, CPatron supplies the Events dialog shown in Figure 9.</p>
<p>
<img src="contcntr_9.gif" border=0></p>
<p class=label>
<b>Figure 9. CPatron's Events dialog, in which the user can assign actions to events</b></p>
<p>
This dialog is invoked from an "Events. . ." menu item that CPatron adds to both the Edit menu and the right-mouse popup menu for objects. This menu item is only enabled when the currently selected control is activated (whenever you right-mouse click on a control, CPatron selects it). In order to do that, we need a code path from the frame window level (that sees WM_INITMENUPOPUP) down to the site level in order to ask the site if it has not just a control, but a control with events. The path starts in <i>CPatronFrame::UpdateMenus</i> (PATRON.CPP), which calls <i>CPatronDoc:: FQueryEnableEvents</i>, which calls the same named function in CPages, which calls the same in CPage. CPage in turn calls <i>CTenant::HasEvents</i>, which returns TRUE only if the site has instantiated an <i>IDispatch</i> for events. If you look back at the initialization code earlier in this document, you'll see that this pointer is NULL unless we successfully connected an events <i>IDispatch</i> to the control.</p>
<p>
So the command will be enabled for event-capable controls only, and when that command is selected from the menu, CPatron goes through a similar path to invoke the dialog, using the <i>AssignEvents</i> function in CPatronDoc, CPages, and CPage. <i>CPage::AssignEvents</i> does nothing more than invoke the dialog box shown in Figure 9, but passes the current site's CEventMap object to the dialog. The dialog box procedure in EVENTS.CPP then handles selecting an event and an action and storing them in the CEventMap object. When the user closes the dialog, any modifications made in the dialog will be current in the site's <i>m_pEventMap</i>.</p>
<h4>Events IDispatch</h4>
<p>
With an initialized and populated event map structure, such as CPatron's CEventMap, we can now implement the <i>IDispatch</i> interface to handle the calls from the control. If you've created a stub implementation already, the only work to do here will be to implement <i>Invoke</i>—besides storing NULL in output parameters, none of the other functions (<i>IUnknown</i> excluded) need to be implemented at all. A control should never need to ask a container for the type information for its own event set!</p>
<p>
Implementing <i>Invoke </i>is interesting because there is no predefined set of DISPIDs to which this function responds, and having some dynamic mapping is the big trick of implementing events. CPatron implements <i>Invoke</i> by scanning the event map of the appropriate site for DISPID matching the one passed to <i>Invoke</i>. If a match is found, we look up the action associated with the event and execute it; otherwise we return an error:</p>
<pre><code>STDMETHODIMP CImpIDispatchEvents::Invoke(DISPID dispIDMember, REFIID riid
 &nbsp; , LCID lcid, unsigned short wFlags, DISPPARAMS * pDispParams
 &nbsp; , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
 &nbsp; {
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; hr;
 &nbsp; VARIANT&nbsp;&nbsp;&nbsp; varResult;
 &nbsp; EVENTACTION iAction;
 &nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;
 &nbsp; PEVENTMAP pEM;

 &nbsp; if (IID_NULL!=riid)
 &nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode(E_INVALIDARG);

 &nbsp; if(NULL==pVarResult)
 &nbsp;&nbsp; pVarResult=&amp;varResult;

 &nbsp; VariantInit(pVarResult);
 &nbsp; V_VT(pVarResult)=VT_EMPTY;

 &nbsp; //Only method calls are valid.
 &nbsp; if (!(DISPATCH_METHOD &amp; wFlags))
 &nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode(DISP_E_MEMBERNOTFOUND);

 &nbsp; iAction=ACTION_NONE;
 &nbsp; pEM=m_pTen-&gt;m_pEventMap-&gt;m_pEventMap;

 &nbsp; for (i=0; i &lt; m_pTen-&gt;m_pEventMap-&gt;m_cEvents; i++)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (dispIDMember==pEM[i].id)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iAction=pEM[i].iAction;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; if (ACTION_NONE==iAction)
 &nbsp;&nbsp;&nbsp;&nbsp; hr=ResultFromScode(DISP_E_MEMBERNOTFOUND);
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; MessageBeep((UINT)iAction);
 &nbsp;&nbsp;&nbsp;&nbsp; hr=NOERROR;
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return hr;
 &nbsp; }
</code></pre>
<p>
I suspect that most event-handling <i>Invoke</i> code will look a lot like this, except that what you do after you find a matching DISPID and how you then execute the action will be a lot more complicated than this. But this code illustrates the simple technique of working with DISPID mappings.</p>
<p>
A few other notes to make here: This code doesn't handle any event parameters—a real container will generally need to because these in turn become parameters to the user-defined code attached to the event. So you'll have more work to do to parse the <i>pDispParams</i> argument. You will also want to handle events that want return values, which might be the case (check the type information for a non-void return type). With a complete implementation you'll basically allow a user to do anything in response to an event, which is much more interesting (and marketable) than a container that doesn't do anything more than beep, tweak, ding, and frazzle when you twiddle controls.</p>
<h3>Save and Load Control and Event Mappings</h3>
<p>
Once the end user has gone to all the trouble of creating a form with controls and assigning actions to events, setting properties, and so forth, you better make sure you can save all this information persistently and reload it when you load the object.</p>
<h4>Saving controls</h4>
<p>
The first concern is saving the internal state of controls, which includes their properties. As mentioned before, the OLE Controls spec allows controls to implement <i>IPersistStream</i> for this purpose; besides the creation/loading problems for stream-based controls, saving them is easy but requires the container to create a stream for the control before saving. For the purposes of this document we can assume that a control implements <i>IPersistStorage</i> and thus saving its state requires nothing special: Use your existing compound document code, which usually calls <i>OleSave</i> and <i>IPersistStorage::SaveCompleted.</i></p>
<p>
The mapping between events and actions is persistent information of the container that is always attached to a particular control, but the control itself will never be aware of the assignments, nor will it handle persistence of this information for you. Therefore you must implement code that saves the assignments. CPatron handles this through the <i>CEventMap::Serialize</i> (EVENTS.CPP) function in which the event map object will write its mappings to an <i>IStream</i>:</p>
<pre><code>void CEventMap::Serialize(LPSTREAM pIStream)
 &nbsp; {
 &nbsp; EVENTMAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; emTemp;
 &nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbWrite=sizeof(DISPID)+sizeof(EVENTACTION);

 &nbsp; if (NULL==pIStream)
 &nbsp;&nbsp;&nbsp;&nbsp; return;

 &nbsp; if (NULL!=m_pEventMap)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;

 &nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i &lt; m_cEvents; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIStream-&gt;Write(&amp;m_pEventMap[i], cbWrite, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; //Write terminating entry
 &nbsp; emTemp.id=0;
 &nbsp; emTemp.iAction=ACTION_TAILING;
 &nbsp; pIStream-&gt;Write(&amp;emTemp, cbWrite, NULL);

 &nbsp; return;
 &nbsp; }
</code></pre>
<p>
This function loops through the existing events saving the DISPID and the action assigned to it. The name of the event is not saved because it is just another property of the DISPID that we can retrieve when the object is reloaded. <i>Serialize</i> also uses a terminating structure in which a special code is stored for the action. This is so the deserialization code doesn't have to depend on any set number of events. It would be just as effective to write the number of saved events in a short header in the stream.</p>
<p>
The stream into which this information is saved is created under the <i>IStorage</i> given to the control. Because the container owns and manages this stream, we have to prefix the name with an ASCII 3. Therefore the name used for the stream is "\003Event Mappings", which is a constant (defined in TENANT.H) called SZEVENTSTREAM. This stream is created in the <i>CTenant::Update</i> function before <i>CEventMap::Serialize </i>is called, and the STGM_CREATE flag means that we will overwrite any already existing stream:</p>
<pre><code>if (HasEvents())
 &nbsp; {
 &nbsp; LPSTREAM&nbsp;&nbsp; pIStream;
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; hr;

 &nbsp; hr=m_pIStorage-&gt;CreateStream(SZEVENTSSTREAM
 &nbsp;&nbsp;&nbsp;&nbsp; , STGM_CREATE | STGM_DIRECT | STGM_READWRITE
 &nbsp;&nbsp;&nbsp;&nbsp; | STGM_SHARE_EXCLUSIVE, 0, 0, &amp;pIStream);

 &nbsp; if (SUCCEEDED(hr));
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; m_pEventMap-&gt;Serialize(pIStream);
 &nbsp;&nbsp;&nbsp;&nbsp; pIStream-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
</code></pre>
<p>
This code is, of course, only executed if the object in the site is a control with events.</p>
<p>
It is very important in designing your events serialization that the IID of the event set and the functions in that set are not considered persistent. This is because the control may change these the next time you load it. The next section deals with this in more detail.</p>
<h4>Loading controls</h4>
<p>
As with saving controls, there are general concerns right now about controls that serialize into <i>IPersistStream</i>, so again we'll just assume that controls are like other embedded objects in that they work through <i>IPersistStorage</i>. Therefore, loading a control is like loading any other embedded object: Call <i>OleLoad</i> and initialize the object as you normally would. As part of normal in-place activation support you'll have a check in your loading procedure for OLEMISC_ACTIVATEWHENVISIBLE, and if it's set you'll send the verb OLEIVERB_INPLACEACTIVATE right away. As a control container, skip this activation if you're in design mode.</p>
<p>
During the initialization of a control you will need to load any existing event mappings. CPatron does this way down in <i>CTenant::FControlInitialize</i>, as we've seen (but didn't discuss) before:</p>
<pre><code>if (SUCCEEDED(m_pIStorage-&gt;OpenStream
 &nbsp; (SZEVENTSSTREAM, NULL, STGM_DIRECT
 &nbsp; | STGM_READWRITE | STGM_SHARE_EXCLUSIVE
 &nbsp; , 0, &amp;pIStream)))
 &nbsp; {
 &nbsp; m_pEventMap-&gt;Deserialize(pIStream);
 &nbsp; pIStream-&gt;Release();
 &nbsp; }
</code></pre>
<p>
Deserialization of CPatron's event mappings is just the process of loading the DISPID/Action pairs from the stream, checking if the DISPID still exists in the map, and assigning the action to it if it does exist:</p>
<pre><code>void CEventMap::Deserialize(LPSTREAM pIStream)
 &nbsp; {
 &nbsp; if (NULL==pIStream)
 &nbsp;&nbsp;&nbsp;&nbsp; return;

 &nbsp; if (NULL==m_pEventMap)
 &nbsp;&nbsp;&nbsp;&nbsp; return;

 &nbsp; while (TRUE)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbRead=sizeof(DISPID)+sizeof(EVENTACTION);
 &nbsp;&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;
 &nbsp;&nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; hr;
 &nbsp;&nbsp;&nbsp;&nbsp; EVENTMAP&nbsp;&nbsp; em;

 &nbsp;&nbsp;&nbsp;&nbsp; hr=pIStream-&gt;Read(&amp;em, cbRead, NULL);

 &nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; //If we hit the tail, we're done.
 &nbsp;&nbsp;&nbsp;&nbsp; if (ACTION_TAILING==em.iAction)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; //Assign the action to the ID, if it exists.
 &nbsp;&nbsp;&nbsp;&nbsp; Set(em.id, em.iAction);
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return;
 &nbsp; }

...

BOOL CEventMap::Set(DISPID id, EVENTACTION iAction)
 &nbsp; {
 &nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRet=FALSE;

 &nbsp; if (NULL!=m_pEventMap)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;

 &nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i &lt; m_cEvents; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pEventMap[i].id==id)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pEventMap[i].iAction=iAction;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fRet=TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return fRet;
 &nbsp; }
</code></pre>
<p>
There is one major concern with deserialization of an event set: <b>Do not assume that the control still has the same event set as it did before</b>. A control has the right to modify its event set between instantiations, meaning it can add new events and delete old ones. This mostly happens on version changes, but is something your container has to expect every time the control is loaded. Therefore, when you load a single event mapping, you need to see if the DISPID for that event still exists. If it does, reinstate the action mapping. If not, then you'll have to do something else that will not annoy the user. In CPatron's case, the user did virtually no work to assign actions—we just discard the assignment. However, consider the user who wrote code for an event that is no longer available. The container should do something with the code and definitely <b>not </b>discard it. I would be really annoyed if a container up and deleted code I spent hours writing. What an environment like Visual Basic does in such cases, for example, is to copy the code to a global function—it can't keep it attached to a control because the control is invalid, so it makes it global. I expect most sophisticated containers will do something similar.</p>
<h3>Implement IOleControlSite and IOleClientSite::RequestNewObjectLayout</h3>
<p>
The final topic for this article is filling out a few more <i>IOleControlSite</i> functions as well as making one enhancement to <i>IOleClientSite. </i>Let's deal with the latter item first.</p>
<p>
The <i>IOleClientSite </i>interface has always had a function called <i>RequestNewObjectLayout</i>, but nothing in compound document technology uses it. Controls do, however, whenever they would like to get updated positional information. This generally means asking the object for its current extents and calling <i>IOleInPlaceObject::SetObjectRects</i> again (the latter happens in <i>CTenant::UpdateInPlaceObjectRects</i>):</p>
<pre><code>STDMETHODIMP CImpIOleClientSite::RequestNewObjectLayout(void)
 &nbsp; {
 &nbsp; RECT&nbsp;&nbsp; rc, rcT;
 &nbsp; SIZEL&nbsp;&nbsp; szl;
 &nbsp; HRESULT hr;

 &nbsp; //Get the size from the control
 &nbsp; if (NULL!=m_pTen-&gt;m_pIViewObject2)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; hr=m_pTen-&gt;m_pIViewObject2-&gt;GetExtent(m_pTen-&gt;m_fe.dwAspect
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , -1, NULL, &amp;szl);
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp; return hr;

 &nbsp; //Add these extents to the existing tenant position.
 &nbsp; SetRect(&amp;rcT, 0, 0, szl.cx*10, -szl.cy*10);
 &nbsp; RectConvertMappings(&amp;rcT, NULL, TRUE);

 &nbsp; rc=m_pTen-&gt;m_rcPos;
 &nbsp; rc.right=rc.left+rcT.right;
 &nbsp; rc.bottom=rc.top+rcT.bottom;

 &nbsp; m_pTen-&gt;UpdateInPlaceObjectRects(&amp;rc, FALSE);
 &nbsp; return NOERROR;
 &nbsp; }
</code></pre>
<p>
The next function, <i>IOleControlSite::OnControlInfoChanged</i>, instructs the container to reload the CONTROLINFO structure, which is trivial. Be sure to update your "have control info" flag here, if you maintain one.</p>
<pre><code>STDMETHODIMP CImpIOleControlSite::OnControlInfoChanged(void)
 &nbsp; {
 &nbsp; //We also update our "have info" flag here.
 &nbsp; m_pTen-&gt;m_fHaveControlInfo=SUCCEEDED(m_pTen-&gt;m_pIOleControl
 &nbsp;&nbsp;&nbsp;&nbsp; -&gt;GetControlInfo(&amp;m_pTen-&gt;m_ctrlInfo));

 &nbsp; return NOERROR;
 &nbsp; }
</code></pre>
<p>
Next, <i>IOleControlSite::TransformCoords</i> needs an implementation so that coordinates appear to the container in a uniform fashion. CPatron internally uses MM_LOMETRIC, so converting to HIMETRIC means multiplying by 10 and negating the <i>y</i> coordinate. Converting from HIMETRIC means dividing by 10 instead:</p>
<pre><code>STDMETHODIMP CImpIOleControlSite::TransformCoords(POINTL *pptlHiMet
 &nbsp; , POINTF *pptlCont, DWORD dwFlags)
 &nbsp; {
 &nbsp; if (NULL==pptlHiMet || NULL==pptlCont)
 &nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode(E_POINTER);

 &nbsp; if (XFORMCOORDS_HIMETRICTOCONTAINER &amp; dwFlags)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; pptlCont-&gt;x=(float)(pptlHiMet-&gt;x/10);
 &nbsp;&nbsp;&nbsp;&nbsp; pptlCont-&gt;y=(float)-(pptlHiMet-&gt;y/10);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; pptlHiMet-&gt;x=(long)(pptlCont-&gt;x*10);
 &nbsp;&nbsp;&nbsp;&nbsp; pptlHiMet-&gt;y=(long)-(pptlCont-&gt;y*10);
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return NOERROR;
 &nbsp; }
</code></pre>
<p>
With <i>IOleControlSite::LockInPlaceActive</i> you either increment or decrement a lock count for the object. CPatron maintains the count in the <i>CTenant::m_cLockInPlace </i>variable. If this lock count is positive and a deactivation attempt is made, you can mark a deactivation as pending, as is done in <i>CTenant::DeactivateInPlaceObject</i>:</p>
<pre><code>void CTenant::DeactivateInPlaceObject(BOOL fFull)
 &nbsp; {
 &nbsp; if (NULL!=m_pIOleIPObject)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if ((OLEMISC_INSIDEOUT &amp; m_grfMisc) &amp;&amp; !fFull)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pIOleIPObject-&gt;UIDeactivate();
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //CONTROLMOD
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0==m_cLockInPlace)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pIOleIPObject-&gt;InPlaceDeactivate();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_fPendingDeactivate=TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //End CONTROLMOD
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return;
 &nbsp; }
</code></pre>
<p>
The <i>CTenant::m_fPendingDeactivate</i> flag must be cleared back to its initial FALSE state whenever the object is reactivated—either by the container sending an in-place activate or UI activate verb (see <i>CTenant::Activate</i>), or when either <i>IOleInPlaceSite::OnInPlaceActivate</i> or <i>IOleInPlaceSite::OnUIActivate</i> is called. In any case, this flag is used in our implementation of <i>LockInPlaceActive</i> and the lock count is then decremented to zero:</p>
<pre><code>STDMETHODIMP CImpIOleControlSite::LockInPlaceActive(BOOL fLock)
 &nbsp; {
 &nbsp; if (fLock)
 &nbsp;&nbsp;&nbsp;&nbsp; m_pTen-&gt;m_cLockInPlace++;
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (0==--m_pTen-&gt;m_cLockInPlace)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //If there's a pending deactivate, do it now.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pTen-&gt;m_fPendingDeactivate)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pTen-&gt;DeactivateInPlaceObject();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; return NOERROR;
 &nbsp; }
</code></pre>
<p>
Finally, the other functions in <i>IOleControlSite</i> are not implemented in CPatron because it doesn't do the features related to those functions.</p>
<h3>Other Steps</h3>
<p>
Because CPatron does not have keyboard mnemonics, button/label handling, or extended controls implemented, there's not a lot I can say about these features from an implementation standpoint. Pending additional work on the subjects, there's no more material to add here.</p>
</BODY>
</HTML>
