<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft Plus! for Windows 95: Guidelines for Independent Software Vendors</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_sageapi"></a>Microsoft Plus! for Windows 95: Guidelines for Independent Software Vendors</h1>
<p>
May 15, 1995<br>
Version 0.8</p>
<h2>Introduction</h2>
<p>
The System Agent feature of Microsoft® Plus! is a general-purpose scheduler application with which users can schedule programs to run at various times. System Agent can launch any Windows®-based or MS-DOS®-based program, without requiring any modification to the program being scheduled. However, there are things independent software vendors (ISVs) can do in their applications to add value for customers using those programs in conjunction with System Agent. Programs that have been modified to exploit System Agent are referred to as "SAGE-aware." (“SAGE” refers to System Agent’s underlying scheduling engine. SAGE.EXE is run whenever a user logs on; it in turn loads SAGE.DLL, which monitors the system and runs programs at the appointed time and which exposes scheduling services to programs. System Agent’s user interface is provided by a separate program, SYSAGENT.EXE, which uses the API provided by SAGE.DLL to edit the SAGE task data base.)</p>
<p>
SAGE-aware programs have the following characteristics:
<ul type=disc>
<li>
They show up in the drop-down list box in System Agent's "Schedule a new program" dialog.<br><br></li>
<li>
They recognize the /SAGERUN:n command line switch and behave in a fashion suitable for unattended operation.<br><br></li>
<li>
They can optionally provide a Settings dialog that System Agent can display to allow users to specify a set (or multiple sets) of preferences/parameters to be used when the program is run by System Agent.<br><br></li>
<li>
They optionally define a set of exit codes and a corresponding set of strings that System Agent will record in its log, so that users have a record of whether the program ran successfully and what its final result was.</li>
</ul>
<p>
In addition, System Agent exposes an API that applications can use to directly manipulate SAGE's data base of scheduled programs. Using this API, applications can add themselves to SAGE's queue without requiring the user to manually schedule the program using System Agent's user interface. In addition, System Agent exposes APIs that applications can use to detect if System Agent is running, and to suspend System Agent so that it will not start up any programs until the application says so (or until the system is restarted).</p>
<h2>How to Make an Application "SAGE-Aware"</h2>
<p>
SAGE-aware programs declare themselves as such by creating a key in \\HKLM\Software\Microsoft\Plus!\System Agent\SAGE. The name of the key can be anything the program wants, but it should contain the following values:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=21%>Program= </td>
<td width=79%>Name of the program's EXE file. This <i>must</i> be the same name under which the program's PerApp path is registered.</td>
</tr>
<tr valign=top>
<td width=21%>Friendly Name=</td>
<td width=79%>Display name that System Agent will use in populating the drop-down list in its "Schedule a program" dialog.</td>
</tr>
<tr valign=top>
<td width=21%>Settings= </td>
<td width=79%>1-bit binary field indicating whether program has a Settings dialog.</td>
</tr>
<tr valign=top>
<td width=21%>Result Codes</td>
<td width=79%>Optional <i>key</i> containing a set of value pairs mapping an exit code to a string describing the meaning of that exit code. For example, for SCANDSKW, the Result Codes key may contain a value such as:&nbsp; 0="ScanDisk completed successfully; no errors were found.". This is to allow SAGE to keep a human-comprehensible log of the results of the programs it runs. In addition to the value pairs, this key should also contain a String value named "Success", which indicates the highest value for an exit code that designates that the program completed successfully. The value names should be string values, specified in decimal; the allowable range is 0–32767.</td>
</tr>
</table><br>
<p>
In addition, SAGE-aware applications <i>must</i> register a "Per Application Path", as defined by the Windows 95 Setup guidelines. SAGE will use the PerApp path to locate the program's executable, and it will initialize its environment with the path (if any) specified by the Path value of the app's key in the PerApp path section of the registry.</p>
<p>
SAGE-aware applications must also support the /SAGERUN:n command line switch. SAGE will pass this switch on the command line when launching programs that have registered themselves as being SAGE-aware. This is to let the application know that it is being run by SAGE and thus that is should behave in a suitable fashion for unattended operation. The :n suffix allows SAGE to specify a group of application defined settings to be used by this scheduled instance of the program (as described below). If your program does not support multiple saved sets of settings, it may ignore this suffix.</p>
<h3>Settings Dialog</h3>
<p>
SAGE-aware programs also <i>may</i> support a Settings dialog. If so (as indicated by the Settings= value of the program's registry key), they must support the following command line switches:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=18%>SAGESET:n</td>
<td width=82%>This tells the application to display its SAGE settings dialog, rather than just running normally. The application should initialize itself with settings set #n (if it exists). Applications that do not support multiple saved sets of settings may ignore the :n suffix.</td>
</tr>
<tr valign=top>
<td width=18%>SAGERUN:n</td>
<td width=82%>This tells the application to run using settings set #n. If your program does not support multiple saved sets of settings, it may ignore this suffix.</td>
</tr>
</table><br>
<p>
The application saves its SAGE settings in a subkey of the key in which it registers itself as a SAGE-aware program, as follows:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=13%>SetN</td>
<td width=87%>Key(s) containing a set of settings this program can be run with. The contents and format of this key is defined by each application. The allowable range for N is 0–32767.</td>
</tr>
</table><br>
<p>
When System Agent is scheduling a new instance of a SAGE-aware program, it launches it using /SAGESET:n, with a value of n for which a SetN key does not already exist (for that program, at least). If/when the user confirms his or her choices in the settings dialog, the program should save those choices in the key named SetN. If the user cancels out of the settings dialog, the program simply exits without saving those settings. When SAGE runs the program, it passes it the /SAGERUN:n command line switch. If the program supports one or more sets of Save settings, it runs with setting set #n; otherwise it ignores the :n suffix and uses its default settings.</p>
<p class=indent>
<B><b>IMPORTANT</b></B>&nbsp;&nbsp;&nbsp;System Agent <i>may</i> launch programs with <i>both</i> the /SAGERUN and /SAGESET command line switches simultaneously. If this happens, the program should display its SAGE Settings dialog—that is, the /SAGESET switch takes precedence over /SAGERUN.</p>
<p>
Note also that the /SAGERUN:n command line switch implies that the program is being run by SAGE and thus, the program should behave accordingly and not stop for user input. <i>All</i> the settings required to run the program must be derived from what is stored in the registry—that is, when run with SAGERUN:n, the desired behavior of the program (what drive[s] to run on, and other preferences) must be fully specified by the settings stored in the SetN registry key, or the program must provide reasonable defaults so that it runs unattended, unless an unexpected condition arises that requires user input (regardless of whether or not :n is provided). Although the SAGERUN:n switch is intended to fully specify the behavior of a SAGE-aware program, the user is permitted to provide additional command line parameters to the program through the System Agent UI. If an application supports both a Settings dialog and command line parameters, it is up to the application to resolve any conflicts that may arise between the settings the user specifies in the Settings dialog and any command line switches she or he provides.</p>
<h3>Exit Codes</h3>
<p>
SAGE-aware applications should strive to return a meaningful exit code upon exiting from their WinMain function. In the initial release of Microsoft Plus!, these exit codes will be used by SAGE to display a result string in the System Agent user interface (UI) and write it to its log. The mapping between exit codes and result strings will be provided by each SAGE-aware application in its Result Codes registry key. In future versions of Plus!, SAGE may use the exit code to determine whether a program ran successfully or not, in order to determine whether other programs dependent on its outcome should be allowed to proceed or not. All exit codes indicating that the program completed successfully should be equal to or less than the value indicated by "Success", and numerically lower than those indicating failure conditions. For example, for ScanDisk, error code 0 might be defined to mean "No errors found"; error code 2 "Errors were found but all were fixed"; error code 10 might indicate that "Errors were found and only some were fixed"; and 255 might mean "Errors were found and none were fixed." In this example, a value for "Success" equal to 9 would be reasonable, but 1 would not.</p>
<p>
The exit code 0xF9 is distinguished. When a SAGE-aware application is run with /SAGERUN and returns exit code F9 to SAGE, SAGE will try to re-run the application at a later time, possibly repeatedly unless/until its deadline (if any) passes. Essentially, this exit code says to SAGE, "I wasn't able to complete successfully, but try to run me again later." This option could be used, for example, by disk utilities that need to wait for a drive to become unlocked, or backup applets that discover that the destination server is down.</p>
<h3>Error Handling</h3>
<p>
Error handling is handled by each SAGE-aware application. For errors that require user intervention, the application should stop and display a suitable dialog, rather than or in addition to simply exiting with an exit code. Otherwise the user will have no indication that an error occurred, unless she or he checks the SAGE log.</p>
<h3>Termination</h3>
<p>
System Agent provides an option for SAGE to terminate a program if it's not finished by a designated time, or if the user returns to the system and starts using it. SAGE implements this by sending a WM_CLOSE message to the program's top-level window(s). SAGE-aware applications, when run with the SAGERUN:n command line switch, should exit gracefully and silently upon receiving this message. Exceptions to this might occur, however, if the application has unsaved data and must ask for confirmation from the user as to whether to save it, or if the application is in an error state (in which case it may wish to ignore the WM_CLOSE message, so that the user can be made aware of the error).</p>
<h2>SAGE API</h2>
<p>
SAGE.DLL exports the following application programming interfaces (API)s, which applications can use.</p>
<h3>Detecting Whether SAGE Is Running</h3>
<pre><code>int System_Agent_Detect(void)
</code></pre>
<p>
If the System Agent thread exists, the System Agent's version number is returned; otherwise zero is returned.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This function is important because the existence of SAGE.DLL does not mean that the System Agent itself has been started. Note also that it is <i>not</i> necessary to call <b>System_Agent_Initialize()</b> before calling this function.</p>
<h3>Suspending/Resuming SAGE</h3>
<p>
This function allows the client to completely enable and disable the System Agent. This feature should be used sparingly, because presumably the user has scheduled programs for a good reason. If the caller crashes while the System Agent is disabled, the System Agent will not be reenabled until the machine is restarted. Note that it is <i>not</i> necessary to call <b>System_Agent_Initialize()</b> before calling this function.</p>
<pre><code>int <b>System_Agent_Enable</b>(int enablefunc)
</code></pre>
<p>
<b>enablefunc</b> can have 1 of 3 values:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=31%>1 = ENABLE_AGENT</td>
<td width=69%>Enables System Agent scheduling</td>
</tr>
<tr valign=top>
<td width=31%>2 = DISABLE_AGENT</td>
<td width=69%>Disables System Agent scheduling</td>
</tr>
<tr valign=top>
<td width=31%>3 = GET_AGENT_STATUS</td>
<td width=69%>Returns the status of the System Agent without affecting the current state. Returns are ENABLE_AGENT or DISABLE_AGENT.</td>
</tr>
</table><br>
<h4>Suspending/resuming SAGE from 16-bit code</h4>
<p>
16-bit applications can use the following code to suspend System Agent (for example, <b>DisableSystemAgent()</b> remembers the state of the System Agent) and then disable it:</p>
<pre><code>#include &lt;windows.h&gt;
#include "string.h"
static int gSageStatus;
#define SAGE_ENABLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WM_USER + 6
#define SAGE_DISABLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WM_USER + 7
#define SAGE_GETSTATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WM_USER + 8
#define ENABLE_AGENT 1
#define DISABLE_AGENT 2
#define GET_AGENT_STATUS 3
void DisableSystemAgent(void)
{
 &nbsp; HWND h;
 &nbsp; h = FindWindow("SAGEWINDOWCLASS","SYSTEM AGENT COM WINDOW");
 &nbsp; if(!h)
 &nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp; if(h)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; gSageStatus = -1;
 &nbsp;&nbsp;&nbsp;&nbsp; gSageStatus = (int) SendMessage(h,SAGE_GETSTATUS,0,0L);
 &nbsp;&nbsp;&nbsp;&nbsp; if((gSageStatus != ENABLE_AGENT) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gSageStatus != DISABLE_AGENT))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; //something weird is going on
 &nbsp;&nbsp;&nbsp;&nbsp; SendMessage(h,SAGE_DISABLE,0,0L);
 &nbsp; }
}
</code></pre>
<p>
<b>RestoreSystemAgentState()</b> restores the remembered state:</p>
<pre><code>void RestoreSystemAgentState(void)
{
 &nbsp; HWND h;
 &nbsp; h = FindWindow("SAGEWINDOWCLASS","SYSTEM AGENT COM WINDOW");
 &nbsp; if(!h)
 &nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp; if(h)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; switch(gSageStatus)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DISABLE_AGENT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage(h,SAGE_DISABLE,0,0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ENABLE_AGENT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage(h,SAGE_ENABLE,0,0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; //something weird happened
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
}
</code></pre>
<h3>Accessing/Modifying the SAGE Task Database</h3>
<p>
System Agent exports a rich API through SAGE.DLL that programs can use to directly query or modify the SAGE task data base.</p>
<h4>Data structures</h4>
<pre><code>#define MAXPATH 267
#define MAXSETTINGS 256
#define MAXCOMMANDLINE (MAXPATH+MAXSETTINGS)
#define MAXCOMMENT 256
#define CB_RESERVED 33
#pragma Pack(1)
typedef struct TaskInfo
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StructureSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp; Task_Identifier;
 &nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp; Sub_Task_Identifier;
 &nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp; Status;
 &nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp; Result;
 &nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp; Time_Granularity;
 &nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp; StopAfterTime;
 &nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp; ReservedLong;
 &nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp; User_Idle;
 &nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp; Powered;
 &nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreatorId;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEMTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BeginTime;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEMTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EndTime;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEMTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LastRunStart;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEMTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LastRunEndScheduled;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEMTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LastTerminationTime;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEMTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReservedTime1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEMTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LastAlarmTime;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEMTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReservedTime2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEMTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReservedTime3;
 &nbsp;&nbsp;&nbsp; STARTUPINFO&nbsp;&nbsp;&nbsp; StartupInfo;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwProcessId;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwThreadId;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LockingProcess;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LockTime;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fdwCreate;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; taskflags;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SystemTask;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TerminateAtRangeEnd;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StartupTask;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlarmEnabled;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RunNow;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TerminateNoIdle;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Disabled;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TerminateNow;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RestartNoIdle;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CommandLine[MAXCOMMANDLINE];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Comment[MAXCOMMENT];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WorkingDirectory[MAXPATH];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Reserved[CB_RESERVED];
}TaskInfo;
</code></pre>
<p>
<b>StructureSize</b></p>
<p>
This is the size of the TaskInfo structure in bytes. This must be correct for API calls. Failure to fill in this field will lead to an ERROR_TASK_INVALID return code. Value is 0x558.</p>
<p>
<b>Task_Identifier</b></p>
<p>
This is a unique value identifying this task. This value is passed into some of the APIs to identify the task.</p>
<p>
<b>Sub_Task_Identifier</b></p>
<p>
This value is reserved for future use. Clients should leave this value zero.</p>
<p>
<b>Status</b></p>
<p>
This field is set only by the System Agent (see <b>System_Agent_Change_Task</b>). It contains a value indicating status for the task. Currently defined values are:</p>
<pre><code>#define STATUS_NOTRUNNING&nbsp; 0L&nbsp;&nbsp;&nbsp; // Task is not running.
#define STATUS_RUNNING&nbsp;&nbsp;&nbsp;&nbsp; 1L&nbsp;&nbsp;&nbsp; // Task is currently running.
#define STATUS_COMPLETE&nbsp;&nbsp;&nbsp; 2L&nbsp;&nbsp;&nbsp; // Task is not running, but has run in the 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // currently scheduled period.
#define STATUS_QUEUEDEXEC&nbsp; 3L&nbsp;&nbsp;&nbsp; // Task is just about to execute.
</code></pre>
<p>
<b>Result</b></p>
<p>
This is the result code returned from the last execution of the task.</p>
<p>
<b>Time_Granularity</b></p>
<p>
If non-zero, this field indicates that the task should be executed periodically during its scheduled time at an interval of <i>Time_Granularity </i>seconds<i>. </i>If the task is still running when the next <i>Time_Granularity </i>seconds have elapsed, the task is not run; otherwise it is.</p>
<p>
<b>StopAfterTime</b></p>
<p>
If non-zero, this field indicates that the task should be terminated after running for <i>StopAfterTime </i>seconds of execution.</p>
<p>
<b>ReservedLong</b></p>
<p>
This field is reserved for future use and should be set to zero.</p>
<p>
<b>User_Idle</b></p>
<p>
If non-zero, this task indicates that the task should not be executed unless <i>User_Idle </i>seconds have elapsed with no keyboard or mouse activity. Thus, if a task is scheduled to run between 4:00 and 5:00 with User_Idle set to 10 minutes (600 seconds), and the user last moved his mouse at 3:55, the task will execute at 4:05 unless the user interacts with the computer between those times, in which case the time countdown will be restarted at 10 minutes.</p>
<p>
<b>Powered</b></p>
<p>
This field indicates that the task should not be run if the computer is currently being run on batteries. This works only on fully APM-compliant Plug and Play machines. Valid values are zero or one (one indicates the task should not run on batteries).</p>
<p>
<b>CreatorId</b></p>
<p>
This field is reserved for use by the task creator. The task creator is the application that called <b>System_Agent_Add_Task</b>. This can be any value.</p>
<p>
<b>BeginTime</b></p>
<p>
The <i>StartTime </i>and <i>EndTime </i>together define the basic schedule for a task. The <i>StartTime</i> field indicates the beginning of the task's execution period. This can be an exact time (in the case of a run-once task), or it can be a repeating schedule such as <i>Daily</i>,<i> Monthly</i>,<i> Weekly</i>, or<i> Hourly.</i> To specify a repeating schedule, set the units at which you wish to repeat to -1. All fields of higher precedence must also be set to -1. Precedence order is: wYear, wMonth, wDay, wHour, wMinute, wSeconds. The wMillisecond field is not honored when scheduling tasks.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;wDayOfWeek does not have precedence and should be set to -1 unless you are specifically scheduling a task to run on a fixed day of the week.</p>
<p>
Thus, to run daily at 4:30am, set:
<ul type=disc>
<li>
BeginTime.wYear =&nbsp; -1<br><br></li>
<li>
BeginTime.wMonth = -1<br><br></li>
<li>
BeginTime.wDayOfWeek = -1<br><br></li>
<li>
BeginTime.wDay = -1<br><br></li>
<li>
BeginTime.wHour = 4<br><br></li>
<li>
BeginTime.wMinute = 30<br><br></li>
<li>
BeginTime.wSecond = 0<br><br></li>
<li>
BeginTime.wMillisecond = 0</li>
</ul>
<p>
To run every Wednesday at 1:00pm, set:
<ul type=disc>
<li>
BeginTime.wYear =&nbsp; -1<br><br></li>
<li>
BeginTime.wMonth = -1<br><br></li>
<li>
BeginTime.wDayOfWeek = 3; // as per SYSTEMTIME definition, Sunday=0,Monday=1...<br><br></li>
<li>
BeginTime.wDay = -1<br><br></li>
<li>
BeginTime.wHour = 13<br><br></li>
<li>
BeginTime.wMinute = 0<br><br></li>
<li>
BeginTime.wSecond = 0<br><br></li>
<li>
BeginTime.wMillisecond = 0</li>
</ul>
<p>
See <i>EndTime </i>for more details.</p>
<p>
<b>EndTime</b></p>
<p>
This field specifies the ending time for the period in which the task is run. It has the same format as the <i>StartTime</i>, and should match its repeating schedule type. This field defines the latest time at which the task will be started if the task runs only when the machine is idle, and it defines the end of the period in which it will be started if it has a <i>Time_Granularity </i>set. Also, this field defines the time that task will be terminated if <i>TerminateAtRangeEnd </i>is set. If no EndTime definition is needed, all fields may be set to -1.</p>
<p>
<b>LastRunStart</b></p>
<p>
This field indicates the time at which this task was last executed. This field should not be changed by the client.</p>
<p>
<b>LastRunEndScheduled</b></p>
<p>
This field indicates the specific time the task's period is/was scheduled to end according to the schedule defined by <i>StartTime </i>and <i>EndTime</i>. This field does <i>not</i> indicate at what time the task actually terminated (see <i>LastTerminationTime)</i>, nor will be terminated, but rather at what time the period for this task is <i>scheduled</i> to end.</p>
<p>
<b>LastTerminationTime</b></p>
<p>
This field contains the specific time this task was last terminated.</p>
<p>
<b>ReservedTime1</b></p>
<p>
This field is used internally by System Agent, and should not be used or modified by the client.</p>
<p>
<b>LastAlarmTime</b></p>
<p>
This field indicates the specific time the last scheduled program notification was displayed for this task. This field should not be used by the client. </p>
<p>
<b>ReservedTime2<br>
ReservedTime3</b></p>
<p>
These fields are reserved for future use. They should remain zero and should not be used by the client.</p>
<p>
<b>StartupInfo</b></p>
<p>
This field defines the STARTUPINFO structure that should be passed to <b>CreateProcess</b> when the task is started. See <b>CreateProcess</b>.</p>
<p>
<b>dwProcessId</b></p>
<p>
This field defines the Process Id for the task, if it is running. See <b>CreateProcess</b>. This field should not be modified by the client.</p>
<p>
<b>dwThreadId</b></p>
<p>
This field defines the Thread Id for the task, if it is running. See <b>CreateProcess</b>. This field should not be modified by the client.</p>
<p>
<b>LockingProcess</b></p>
<p>
This field indicates the Process ID of the program who owns the lock on this task, if there is one. This field should not be modified by the client.</p>
<p>
<b>LockTime</b></p>
<p>
This field records the GetTickCount return value when the task was locked. This field is used for data validation, and should not be used by the client.</p>
<p>
<b>fdwCreate</b></p>
<p>
This field indicates the fdwCreate flags passed to CreateProcess. If zero, System Agent uses CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP | NORMAL_PRIORITY_CLASS. See CreateProcess.</p>
<p>
<b>taskflags</b></p>
<p>
This field is a bitfield defining certain characteristics of the task:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=28%>bit 1 = Logging</td>
<td width=72%>1 =&gt; log execution info to the System Agent log file. </td>
</tr>
<tr valign=top>
<td width=28%>bit 3 = TaskHasRun</td>
<td width=72%>1 =&gt; the task has run at least once before; 0 means it has never run (read only).</td>
</tr>
<tr valign=top>
<td width=28%>bit 6 = NoIdleTerminated</td>
<td width=72%>1 =&gt; task was terminated because of loss of idle.</td>
</tr>
<tr valign=top>
<td width=28%>bit 7 = DontRun</td>
<td width=72%>1 =&gt; don't run during this period after change task (see below).</td>
</tr>
</table><br>
<p>
Other flags are used internally by System Agent and should not be used by the client.</p>
<p>
<b>SystemTask</b></p>
<p>
0 means standard task. 1 means task is a system task, and will not show up in the System Agent window.</p>
<p>
<b>TerminateAtRangeEnd</b></p>
<p>
If this field is set to 1, the task will be terminated at the <i>EndTime </i>if it is still running.</p>
<p>
<b>StartupTask</b></p>
<p>
If this field is set to 1, the task will be run only when System Agent engine is started.</p>
<p>
<b>AlarmEnabled</b></p>
<p>
If this field is set to 1, and a task does not run during its scheduled period for any reason, System Agent will put up a dialog box to tell the user. Notification will only occur if SAGE is running. Tasks can fail to run because the machine was off, the system was never idle, or the system was running on batteries during the scheduled time. If the task runs during a subsequent period and the dialog has not been not yet posted, the alarm is cancelled.</p>
<p>
<b>RunNow</b></p>
<p>
If this field is set to 1, the task will execute immediately.</p>
<p>
<b>TerminateNoIdle</b></p>
<p>
If this field is set to 1, the task will be terminated if it is running and the user uses the keyboard or mouse.</p>
<p>
<b>Disabled</b></p>
<p>
If this field is set to 1, the task is disabled, and will not be scheduled to run.</p>
<p>
<b>TerminateNow</b></p>
<p>
If this field is set to 1, the task will be terminated if it is currently running.</p>
<p>
<b>RestartNoIdle</b></p>
<p>
If this field is set to 1, the task will restart after <i>User_Idle </i>seconds if it was terminated because <i>TerminateNoIdle </i>was set and the user use the mouse or keyboard.</p>
<p>
<b>CommandLine</b></p>
<p>
This field defines the full command line for the task. The task may be a .COM, .BAT, .EXE, or associated file type. This is the command line that is passed to CreateProcess. It must be zero-terminated.</p>
<p>
<b>Comment</b></p>
<p>
This is the description field shown in the System Agent window. If this field is all zeros, the System Agent will use the <i>CommandLine </i>instead.</p>
<p>
<b>WorkingDirectory</b></p>
<p>
This is the working directory as defined by CreateProcess.</p>
<p>
<b>Reserved</b></p>
<p>
This field is reserved for use by the System Agent and future API enhancements. It should not be used or modified.</p>
<h4>Functions</h4>
<p>
SAGE.DLL exports the following functions:</p>
<pre><code>int System_Agent_Inititialize(void)
</code></pre>
<p>
This function should be called once to initialize memory structures. See example code below. Returns zero if successful.</p>
<pre><code>int System_Agent_End(void)
</code></pre>
<p>
This function frees up memory allocated during API processing. This function should be called once. Returns zero if successful.</p>
<pre><code>int <b>System_Agent_Get_Task_List</b>(TaskInfo **TaskList, BOOL *changed)
</code></pre>
<p>
This function gets a pointer to an array of tasks, and returns the number of tasks in the system agent's task list. TaskList is a pointer to a pointer to a task list—the memory itself is allocated by System Agent on behalf of the application. The changed parameter receives a Boolean value, with TRUE indicating that the task list has changed since the last time this function was called. A negative return value indicates an error code (see below).</p>
<pre><code>int <b>System_Agent_Add_Task</b>(TaskInfo *Task,unsigned long *Task_Identifier)
</code></pre>
<p>
Task is a TaskInfo structure that describes the task (see above). Unused fields should be initialized to zero (see example code). </p>
<p>
You must at least fill in these fields: 
<ul type=disc>
<li>
StructureSize<br><br></li>
<li>
CommandLine<br><br></li>
<li>
StartupInfo<br><br></li>
<li>
BeginTime<br><br></li>
<li>
EndTime</li>
</ul>
<p>
And you may fill in these fields:
<ul type=disc>
<li>
Time_Granularity<br><br></li>
<li>
StopAfterTime<br><br></li>
<li>
User_Idle<br><br></li>
<li>
Powered<br><br></li>
<li>
CreatorId<br><br></li>
<li>
fdwCreate<br><br></li>
<li>
taskflags<br><br></li>
<li>
SystemTask<br><br></li>
<li>
TerminateAtRangeEnd<br><br></li>
<li>
StartupTask<br><br></li>
<li>
AlarmEnabled<br><br></li>
<li>
RunNow<br><br></li>
<li>
TerminateNoIdle<br><br></li>
<li>
Disable<br><br></li>
<li>
TerminateNow<br><br></li>
<li>
RestartNoIdle<br><br></li>
<li>
WorkingDirectory<br><br></li>
<li>
Comment</li>
</ul>
<p>
Other fields should be zero and not used by the caller.</p>
<p>
See the definition for these fields above. </p>
<p>
*TaskIdentifier is filled in with the unique ID for this new task. Returns zero if successful, an error code if not.</p>
<pre><code>int <b>System_Agent_Remove_Task</b>(unsigned long Task_Identifier)
</code></pre>
<p>
This function removes the specified task from the System Agent's task list. Returns zero if successful, otherwise an error code.</p>
<pre><code>int <b>System_Agent_Lock_Task</b>(unsigned long Task_Identifier,DWORD dwProcessId,BOOL volatile)
</code></pre>
<ul type=disc>
<li>
This function locks a task so no other task can modify its settings. This should only be used when the client is changing its settings; the task should not remain locked for an extended period of time. Note that a task must be locked before it can be modified (see <b>System_Agent_Change_Task</b>).<br><br></li>
<li>
Task_Identifier is the identifier for the task to be locked. <br><br></li>
<li>
dwProcessId should be the process id of the caller (returned from GetCurrentProcessId()). <br><br></li>
<li>
Volatile = TRUE means the status, result, dwProcessId, and dwThreadId can be modified; in order to allow this, the task is disabled. A task cannot be locked using the volatile flag while it is running. Most tasks should call with the volatile parameter set to FALSE.<br><br></li>
<li>
Returns zero on success, an error code otherwise.<pre><code>int <b>System_Agent_Unlock_Task</b>(unsigned long Task_Identifier, DWORD dwProcessId,BOOL reenable)
</code></pre>
</li>
</ul>
<p>
This function unlocks a task that was locked with <i>System_Agent_Lock_Task</i>.
<ul type=disc>
<li>
Task_Identifier is the unique identifier for this task.<br><br></li>
<li>
dwProcessId is the locking process's process id, returned from GetCurrentProcessId().<br><br></li>
<li>
<i>Reenable</i> means reenable the task if it was disabled by a volatile lock. This parameter should match the <i>volatile </i>parameter that was passed into <b>System_Agent_Lock_Task</b>.<br><br></li>
<li>
Returns zero on success, an error code otherwise.<pre><code>int <b>System_Agent_Change_Task</b>(TaskInfo *Task,unsigned long Task_Identifier)
</code></pre>
<p class=tl>
This function allows the client to modify an existing task. However, the client must have an active lock (see System_Agent_Lock_Task) in order for this function to succeed. Also, some fields will not be modified unless the lock is <i>volatile </i>[status,result,dwProcessId,dwThreadId]. </P></li>
<li>
System Agent will not allow stale data to be passed to this function. The caller must call <b>System_Agent_Get_Task_List</b><i> after<b> </b></i>a lock is taken and use that "fresh" data as the basis for the modifications passed into this function. This interlocking is needed to support the multi-tasking environment. If this procedure is not used, an error code ERROR_STALE_DATA will be returned and the task will not be modified. The client should modify only those fields list in the definition for <i>System_Agent_Add_Task</i>; all other fields should not be changed.<br><br></li>
<li>
Returns zero on success, an error code otherwise.</li>
</ul>
<h4>Error codes</h4>
<p>
All system agent APIs may return one of the following error codes. Other codes may be defined in the future, so applications should not depend upon certain error codes being returned.</p>
<pre><code>#define ERROR_CANNOT_ADD_TASK&nbsp;&nbsp;&nbsp;&nbsp; -12&nbsp;&nbsp;&nbsp; // Unable to add a task, perhaps 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; because out of memory.
#define ERROR_AGENT_BUSY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -13&nbsp;&nbsp;&nbsp; // System has timed out the API call.
#define ERROR_TASK_NOT_PRESENT&nbsp;&nbsp;&nbsp; -14&nbsp;&nbsp;&nbsp; // Task_Identifer reference not in task
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; list.
#define ERROR_AGENT_NOT_PRESENT&nbsp;&nbsp; -15&nbsp;&nbsp;&nbsp; // System Agent is not active.
#define ERROR_CANNOT_LOAD_DLL&nbsp;&nbsp;&nbsp;&nbsp; -16&nbsp;&nbsp;&nbsp; // Error loading the DLL.
#define ERROR_CANNOT_LOCK_TASK&nbsp;&nbsp;&nbsp; -17&nbsp;&nbsp;&nbsp; // Task cannot be locked at this time.
#define ERROR_TASK_ALREADY_LOCKED -18&nbsp;&nbsp;&nbsp; // Attempt to lock task failed; another 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; task owns lock.
#define ERROR_CANNOT_UNLOCK_TASK&nbsp; -19&nbsp;&nbsp;&nbsp; // Unable to unlock task, perhaps 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; because not locked.
#define ERROR_TASK_LOCKED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -20&nbsp;&nbsp;&nbsp; // Task is locked by a different task, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; access denied.
#define ERROR_WRONG_VERSION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -21&nbsp;&nbsp;&nbsp; // Version of System Agent is not 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; compatible. 
#define ERROR_TASK_NOT_LOCKED&nbsp;&nbsp;&nbsp;&nbsp; -22&nbsp;&nbsp;&nbsp; // Attempt to modify a task that is not 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; locked.
#define ERROR_TASK_VOLATILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -23&nbsp;&nbsp;&nbsp; // Cannot volatile lock because task is 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; running.
#define ERROR_TASK_INVALID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -24&nbsp;&nbsp;&nbsp; // Data in task is invalid or corrupt.
#define ERROR_STALE_DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -25&nbsp;&nbsp;&nbsp; // Attempt to modify task with data got 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; before lock.
</code></pre>
<h4>Using the System Agent API</h4>
<p>
The following is the basic pseudo-code sequence for scheduling and displaying SAGE tasks:</p>
<pre><code>{
 &nbsp;&nbsp; if(error = Connect_System_Agent())&nbsp;&nbsp;&nbsp; // See example source for 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; this function below.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto exit1;
 &nbsp;&nbsp; ...
 &nbsp;&nbsp; if(gTaskList = System_Agent_Get_Task_List())
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error = CANNOT_GET_TASK_LIST;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto exit2;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; DisplayTaskStuff(gTaskList);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // User-supplied function for
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; displaying task list.
 &nbsp;&nbsp; 
 &nbsp;&nbsp; //...
 &nbsp;&nbsp; 
 &nbsp;&nbsp; memset(&amp;gMyTask,0,sizeof(TaskInfo));
 &nbsp;&nbsp; // Fill in info about task..SEE BELOW!
 &nbsp;&nbsp; if(error = System_Agent_Add_Task(&amp;gMyTask,&amp;gMyTaskIdentifer)) 
 &nbsp;&nbsp; // Add a user-defined task
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto exit2;
 &nbsp;&nbsp; //...
exit2:&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; if(System_Agent_End())
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error("Unable to terminate connection to System Agent");
exit1:
 &nbsp;&nbsp; if(error)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("error = %d",error);
 &nbsp;&nbsp; 
}
</code></pre>
<p>
There are a few things to note about this code sequence. The user-supplied function <b>Connect_System_Agent</b> must call <b>System_Agent_Initialize()</b>. Example code for this is supplied below. If this API was called, <b>System_Agent_End()</b> must also be called to clean up global memory allocations.</p>
<p>
The following is example code for initializing the System Agent API:</p>
<pre><code>/*****************&nbsp; Routine to interface to System Agent ********************/
typedef long (*PFNDLL)();
PFNDLL gpfnSystem_Agent_Initialize = NULL;
PFNDLL gpfnSystem_Agent_End = NULL;
PFNDLL gpfnSystem_Agent_Get_Task_List = NULL;
PFNDLL gpfnSystem_Agent_Add_Task&nbsp;&nbsp; = NULL;
PFNDLL gpfnSystem_Agent_Remove_Task = NULL;
PFNDLL gpfnSystem_Agent_Lock_Task = NULL;
PFNDLL gpfnSystem_Agent_Unlock_Task = NULL;
PFNDLL gpfnSystem_Agent_Change_Task = NULL;
PFNDLL gpfnSystem_Agent_Detect = NULL;
PFNDLL gpfnSystem_Agent_Enable = NULL;
static HANDLE hLib = 0;
int Connect_System_Agent(void)
{
 &nbsp; int retval;
 &nbsp; if(!hLib)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (!(hLib = LoadLibrary ("SAGE.DLL")))
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(ERROR_CANNOT_LOAD_DLL); 
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; if(!(gpfnSystem_Agent_End = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PFNDLL) GetProcAddress (hLib,"System_Agent_End")))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Unable_To_Load;
 &nbsp;&nbsp;&nbsp;&nbsp; if(!(gpfnSystem_Agent_Initialize = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PFNDLL) GetProcAddress (hLib,"System_Agent_Initialize")))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Unable_To_Load;
 &nbsp;&nbsp;&nbsp;&nbsp; if(!(gpfnSystem_Agent_Add_Task&nbsp;&nbsp; = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PFNDLL) GetProcAddress (hLib,"System_Agent_Add_Task")))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Unable_To_Load;
 &nbsp;&nbsp;&nbsp;&nbsp; if(!(gpfnSystem_Agent_Get_Task_List = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PFNDLL) GetProcAddress (hLib,"System_Agent_Get_Task_List")))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Unable_To_Load;
 &nbsp;&nbsp;&nbsp;&nbsp; if(!(gpfnSystem_Agent_Change_Task = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PFNDLL) GetProcAddress (hLib,"System_Agent_Change_Task")))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Unable_To_Load;
 &nbsp;&nbsp;&nbsp;&nbsp; if(!(gpfnSystem_Agent_Remove_Task = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PFNDLL) GetProcAddress (hLib,"System_Agent_Remove_Task")))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Unable_To_Load;
 &nbsp;&nbsp;&nbsp;&nbsp; if(!(gpfnSystem_Agent_Enable = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PFNDLL) GetProcAddress(hLib,"System_Agent_Enable")))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Unable_To_Load;
 &nbsp;&nbsp;&nbsp;&nbsp; if(!(gpfnSystem_Agent_Lock_Task&nbsp;&nbsp; = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PFNDLL) GetProcAddress(hLib,"System_Agent_Lock_Task")))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Unable_To_Load;
 &nbsp;&nbsp;&nbsp;&nbsp; if(!(gpfnSystem_Agent_Unlock_Task = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PFNDLL) GetProcAddress(hLib,"System_Agent_Unlock_Task")))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Unable_To_Load;
 &nbsp;&nbsp;&nbsp;&nbsp; if(!(gpfnSystem_Agent_Detect = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PFNDLL) GetProcAddress(hLib,"System_Agent_Detect")))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Unable_To_Load;
 &nbsp; }
  retval = (System_Agent_Detect() == 0); // Zero means agent is not present
  if(!retval)
  {
 &nbsp;&nbsp; retval = (gpfnSystem_Agent_Initialize)();&nbsp; 
 &nbsp;&nbsp; // Agent is present, so initialize interface.
  }
</code></pre>
<pre><code>&nbsp;&nbsp;if(retval)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if(hLib)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FreeLibrary(hLib);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; hLib = NULL;
 &nbsp; }
 &nbsp; return(retval);
Unable_To_Load:
 &nbsp; if(hLib)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FreeLibrary(hLib);
 &nbsp; }
 &nbsp; hLib = NULL;
 &nbsp; return(ERROR_CANNOT_LOAD_DLL);
}
int System_Agent_End(void)
{
 &nbsp; int retval;
 &nbsp; if(!hLib)
 &nbsp; {
 &nbsp;&nbsp; return(0);
 &nbsp; }
 &nbsp; retval = (gpfnSystem_Agent_End)();
 &nbsp; if(hLib)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FreeLibrary(hLib);
 &nbsp; }
 &nbsp; hLib = NULL;
 &nbsp; return(retval);
}
unsigned long System_Agent_Get_Task_List(TaskInfo **TL,BOOL *changed)
{
 &nbsp;&nbsp; return((gpfnSystem_Agent_Get_Task_List)(TL,changed));
}
int System_Agent_Remove_Task(unsigned long Task_Identifier)
{
 &nbsp; return((gpfnSystem_Agent_Remove_Task)(Task_Identifier));
}
int System_Agent_Add_Task(TaskInfo *task, unsigned long *Task_Identifier)
{
 &nbsp; return((gpfnSystem_Agent_Add_Task)(task,Task_Identifier));
}
int System_Agent_Change_Task(TaskInfo *task, unsigned long Task_Identifier)
{
 &nbsp; return((gpfnSystem_Agent_Change_Task)(task,Task_Identifier));
}
int System_Agent_Enable(BOOL eord)
{
 &nbsp; return((gpfnSystem_Agent_Enable)(eord));
}
int System_Agent_Lock_Task(unsigned long Task_Identifier,DWORD dwProcessId,BOOL volatile)
{
 &nbsp; return((gpfnSystem_Agent_Lock_Task)(Task_Identifier,dwProcessId,volatile));
}
int System_Agent_Unlock_Task(unsigned long Task_Identifier,DWORD dwProcessId,BOOL reenable)
{
 &nbsp; return((gpfnSystem_Agent_Unlock_Task)(Task_Identifier,dwProcessId,reenable));
}
int System_Agent_Detect(void)
{
 &nbsp; return((gpfnSystem_Agent_Detect)());
}
/*****************************************************************************/
</code></pre>
</BODY>
</HTML>
