<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Visual InterDev 1.0 to Pass Parameters to and from Microsoft SQL Server Stored Procedures</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_visql"></a>Using Visual InterDev 1.0 to Pass Parameters to and from Microsoft SQL Server Stored Procedures</h1>
<p>
Mike Pope<br>
Visual InterDev Technical Writer<br>
Microsoft Corporation</p>
<p>
August 1997</p>
<p class=indent>
<B><b>Editor's Note&nbsp;&nbsp;&nbsp;</b></B>Information in this article applies to version 1.0 of Microsoft Visual InterDev.</p>
<h2>Introduction</h2>
<p>
If your Microsoft® Visual InterDev™ application includes Active Server Pages (ASP) that interact with a Microsoft SQL Server™ database, and if that database contains stored procedures, you can use ActiveX™ Data Objects (ADO) to call the stored procedures. Calling stored procedures is a good idea because they are compiled and therefore generally run faster than SQL commands alone. In addition, you can call system stored procedures to manage your server or return system information.</p>
<p>
Because stored procedures are designed to be used over and over, they generally rely on values passed to them, called <i>input parameters</i>. For example, a stored procedure might retrieve or update an employee record based on an employee ID passed to it and used in the WHERE clause of an SQL SELECT command or the SET clause of an UPDATE command.</p>
<p>
Stored procedures can also return values. Most stored procedures are written to return an integer value, the <i>return value,</i> often used as an error flag. In addition, stored procedures can return information using an <i>output parameter. </i>Output parameters can return any type of data, except long data types such as text or image, and are used to return values calculated in the stored procedure. A typical example of an output parameter value might be a record count or an aggregate summary value.</p>
<p>
This article explains how you can pass parameters to stored procedures and fetch return parameter values. Along the way, it offers advice on efficient or easy ways to accomplish these tasks, and tips for success.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>All the script examples in this paper use Microsoft Visual Basic®, Scripting Edition (VBScript), but the principles apply to any language in which you can call ADO. Visual InterDev design-time controls (DTCs) generate script in the default language for the page.</p>
<h2>Passing Input Parameters to a Stored Procedure</h2>
<p>
When you are working with a stored procedure that uses parameters, you most commonly pass one or more values to it. In Visual InterDev, you can set up a call to a stored procedure in several ways, depending on how comfortable you are with coding and how efficient your stored procedure call has to be:
<ul type=disc>
<li>
Use the Data Command or DataRange Header DTCs to define the call to the stored procedure. This method is the easiest and results in efficient script.<br><br></li>
<li>
Script the call yourself, and pass the parameters directly in the <b>Execute</b> method of an ADO Command object. If you are comfortable writing script, this is a relatively simple process, but is not the most efficient one.<br><br></li>
<li>
Script the call yourself, and set up parameters in the ADO Command object's Parameters collection. This method is more verbose than simply passing parameters with the <b>Execute</b> method but is more efficient when it runs.</li>
</ul>
<p>
In most situations you'll probably just use the DTCs to create the database access script. However, you might find it useful to be familiar with all the ways of passing a parameter, either to be able to select a method suitable to your application or simply to understand what happens when you use a DTC.</p>
<h3><a name="visql_spec"></a>Specifying Input Parameter Values in a DTC</h3>
<p>
To specify a stored procedure as the command for a DTC, insert the DTC in your page. Then open the <b>Properties</b> window for the DTC, choose the <b>Control</b> tab, and then choose <b>Stored Procedure</b> from the <b>Command Type</b> dialog box. When you do, the <b>Command Text</b> dialog box is loaded with the names of all the stored procedures accessible to the current data connection as shown in Figure 1.</p>
<p>
<img src="visql01.gif" border=0></p>
<p class=label>
<b>Figure 1. The Control tab of the DTC Properties window</b></p>
<p>
When you choose the name of a stored procedure, the DTC automatically determines whether the stored procedure requires parameters, and if so, what their data type and length is. Choose the <b>Parameters</b> tab in the <b>Properties</b> window, and you'll see a list of the parameters, as shown in Figure 2.</p>
<p>
<img src="visql02.gif" border=0></p>
<p class=label>
<b>Figure 2. The Parameters tab of the DTC Properties window</b></p>
<p>
Input parameters are marked with <img src="visql05.gif" border=0>. The type and size information is read-only; you can specify only the value for each input parameter. To specify a value, select the parameter in the list, enter a value in the <b>Set values for parameters box</b>, and click the <b>check mark</b>. If you forget to click the check mark, the value won't be entered for that parameter.</p>
<p>
You can enter any expression for the parameter value, including literals, the names of variables, or any combination that is a legal expression in ASP script. However, there are a few tricks:
<ul type=disc>
<li>
To enter a literal value, just type it in. You probably wouldn't do this very often, but you might find it useful, for example, if you are calling a system stored procedure with a fixed value.<br><br></li>
<li>
To enter a variable name or expression, enclose the value in square brackets and put an equal sign in front of it (for example, <code>=[MyVar]</code>). If you don't do this, the DTC will assume you are entering a literal value.<br><br></li>
<li>
To enter an expression, put an equal sign in front of it.</li>
</ul>
<p>
The following table shows you examples of how to enter different types of expressions.</p>
<p class=label>
<b>Table 1. Parameter Value Expressions</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Value Type</b></td>
<td class=label width=35%><b>Example</b></td>
<td class=label width=45%><b>Enter this way</b></td>
</tr>
<tr valign=top>
<td width=20%>Literal</td>
<td width=35%>"Password"<br>
12</td>
<td width=45%><code>Password<br>
12</code></td>
</tr>
<tr valign=top>
<td width=20%>Variable</td>
<td width=35%>VLName</td>
<td width=45%><code>=[vLName]</code></td>
</tr>
<tr valign=top>
<td width=20%>Expression</td>
<td width=35%>Session("LoginID")<br>
Request.Form("LName")</td>
<td width=45%><code>=Session("LoginID")<br>
=Request.Form("LName")</code></td>
</tr>
</table><br>
<p>
If you are entering a variable that will contain text data (data types char or varchar in SQL Server), you can skip the equal sign in front of the variable in brackets. For example, you could enter <code>[vLastName]</code> instead of <code>=[vLastName]</code>. However, it's better to always include the equal sign for all variables.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>In some versions of ADO, you might experience difficulties with the SQL Server Decimal data type. If so, you need to make a small change in the script generated by the DTC. For details, see <a href="#visql_fix">"Fixing Decimal Data Types,"</a> later in this paper.</p>
<p>
Figure 3 is what the <b>Parameters</b> tab of the DTC's <b>Properties</b> page might look like if you enter different types of parameters.</p>
<p>
<img src="visql03.gif" border=0></p>
<p class=label>
<b>Figure 3. Possible parameter types</b></p>
<p>
When you save the DTC, it generates script to call the stored procedure and pass parameters to it. If you're curious about this generated script, or if you want to manipulate the script further, see <a href="#visql_pass">"Passing Input Parameters Using the Parameters Collection,"</a> later in this paper.</p>
<p>
If you specified a variable for a parameter, you have to initialize it somewhere before the script generated by the DTC. The DTC script begins this way:</p>
<pre><code>&lt;!-- METADATA TYPE="DesignerControl" startspan
</code></pre>
<p>
Above that section of script, add script to load the variable. For example, the following script gets the value of a Hypertext Markup Language (HTML) form control and puts it into a variable:</p>
<pre><code>vLName = Request.Form("LastName")
</code></pre>
<p>
In addition, of course, you have to provide a means to display (or otherwise use) the results of the stored procedure. If you use a Data Range Header DTC to generate the call for the stored procedure, you can use a Data Range Footer DTC to generate the script to display results. Alternatively, you can script the display by hand-editing the script generated by the DTC.</p>
<h3>Passing Input Parameters in the Execute Method</h3>
<p>
If you prefer to write your own script to call the stored procedure, you can do so using just a few statements. If you are familiar with using ADO objects for data access, you'll see that passing parameters is like ordinary data access, with only minor additions.</p>
<p>
For those not already familiar with ADO objects, here is a quick introduction. Data access is managed through three server-side ADO objects:
<ul type=disc>
<li>
A <i>Connection</i> object that manages communication with the data source.<br><br></li>
<li>
A <i>Command</i> object that manages the text and parameters of SQL commands and stored procedures.<br><br></li>
<li>
A <i>Recordset</i> object that contains the result set (if one is created by the stored procedure).</li>
</ul>
<p>
In general, the script you write to call the stored procedure must:
<ol>
<li>
Create a Connection object, and then open it, passing a connection string.<br><br></li>
<li>
Create a Command object, and assign the connection object to it. <br><br></li>
<li>
Set properties of the Command object to specify that you want to call a stored procedure (rather than run an SQL command directly), and to specify the name of the procedure.<br><br></li>
<li>
Create and open the result set by calling the Command object's <b>Execute</b> method.</li>
</ol>
<p>
These four steps describe basic data access with ADO.</p>
<p>
To pass a parameter to the stored procedure, you need just a couple of extra steps. First, before calling the Command object's <b>Execute</b> method, you call the <b>Refresh</b> method of the Command object's Parameters collection. Calling the <b>Refresh</b> method causes the Command object to read the information about the expected parameters and to be able to handle the data type and length of the data you will pass. If you forget this step, you'll see an error like this:</p>
<pre><code>Unable to determine parameter type for at least one variant parameter.
</code></pre>
<p>
Calling the <b>Refresh</b> method is an easy way to get data type information for the parameters, but requires an extra trip to the server to read the data type information, which is why this is not the most efficient way to pass parameters. </p>
<p>
Second, to actually pass values to the stored procedure parameters, you call the Command object's <b>Execute</b> method, and pass your data in the method. The <b>Execute</b> method accepts stored procedure values in its second parameter, which must be an array. (In VBScript, you can create the array using the <code>ARRAY()</code> function.) The elements in the array correspond by position with parameters in the stored procedure, but are offset by one—the first input parameter of the stored procedure is actually the second array element, the second input parameter is the third array element, and so on. The first array element is reserved for the stored procedure's return value.</p>
<p>
The description of how to do all this is actually longer than the script to accomplish it. Here's a sample in which a variable containing the name "Smith" is passed to a stored procedure called <b>GetName</b>.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>Most values used with ADO methods and properties are numeric. For best readability and fewer errors, it is strongly recommended that you use constants in place of these numeric values. A full set of constants is defined in the files Adovbs.inc (for VBScript) and Adojavas.inc (for Microsoft JScript™), which you can add to your project and then include in your ASP files using the ASP <code>#include</code> directive.</p>
<pre><code>&lt;!-- #include adovbs.inc --&gt;
&lt;%
vLastName = "Smith"
' Create connection object, then open it
Set oConn = Server.CreateObject("ADODB.Connection")
oConn.Open "DRIVER={SQL Server};SERVER=MyServer; _
 &nbsp; UID=sa;PWD=;DATABASE=Employees"
' Create command object, assign connection to it
Set oCmd = Server.CreateObject("ADODB.Command")
Set oCmd.ActiveConnection = oConn
oCmd.CommandText = "dbo.GetName"   'Name of SP
oCmd.CommandType = adCmdStoredProc   'ADO constant for 4
<b>oCmd.Parameters.Refresh</b>
' Create record set object by executing command object.
' Parameters for the stored procedure are passed in the 
' Command object's Execute method. The first element of 
' the array passed in the Execute method is reserved
' for the return value, so it is not used here.
Set oRs = <b>oCmd.Execute(, Array(,vLastName))</b>
%&gt;
</code></pre>
<p>
Passing input parameters using the <b>Execute</b> method is easy, but relies on implicit interactions between ADO and the database. You can control parameters more explicitly and efficiently using the Command object's Parameter collection.</p>
<h3><a name="visql_pass"></a>Passing Input Parameters Using the Parameters Collection</h3>
<p>
The most efficient way to manage parameters for a stored procedure is to use the ADO Command object's Parameters collection. If you use a DTC to create a call to a stored procedure, you'll notice that the DTC-generated script uses the Parameters collection to pass parameters to the procedure.</p>
<p>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Be careful if you use a DTC to generate script and then want to modify the script. If you use the visual designer to edit the DTC after you have changed the generated script manually, you will lose your changes. Either avoid making changes to the generated script, or if you do make changes, remove the HTML &lt;METADATA&gt; definition tag for the DTC so that you do not inadvertently use the visual designer.</p>
<p>
The Parameters collection is like an array of parameters. Each parameter in the collection is a separate object that has its own properties, such as a name, data type, length, and value.</p>
<p>
<img src="visql04.gif" border=0></p>
<p class=label>
<b>Figure 4. The Parameters collection</b></p>
<p>
When you use the Parameters collection, you must already know the details about the parameters you want to pass, such as their data types. That's why the using Parameters collection is more efficient than calling the <b>Refresh</b> and <b>Execute</b> methods: ADO does not have to query the database to get this information.</p>
<p>
To use the Parameters collection, you start by creating the usual ADO Connection and Command objects. You specify the stored procedure name as the Command object's <b>CommandText</b> property, and the value 4 (adCmdStoredProc) as its <b>CommandType</b>, as shown in the following example:</p>
<pre><code>&lt;!-- #include adovbs.inc --&gt;
&lt;%
Set oConn = Server.CreateObject("ADODB.Connection")
oConn.Open "DRIVER={SQL Server};SERVER=MyServer; _
   UID=sa;PWD=;DATABASE=Employees"
Set oCmd = Server.CreateObject("ADODB.Command")
Set oCmd.ActiveConnection = oConn
oCmd.CommandText = "dbo.NewEmpl"   'Name of SP
oCmd.CommandType = adCmdStoredProc   'ADO constant for 4
%&gt;
</code></pre>
<p>
You then create a new <b>Parameter</b> object for each parameter that the stored procedure expects and add it to the Command collection. To create the Parameter object, call the Command object's <b>CreateParameter</b> method. You can pass the following information directly in the method, or if you prefer, set the corresponding object properties afterward:
<ul type=disc>
<li>
<b>Name.</b> A name by which you will be able to refer to the Parameter object elsewhere in your script. This is optional.<br><br></li>
<li>
<b>Type.</b> An ADO value indicating the data type of the parameter. Table 2 is a list of SQL Server data types and the corresponding ADO data type.<p class=label>
<b>Table 2. SQL Server Data Types and Corresponding ADO Data Types</b>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=45%><b>SQL Server Data Type</b></td>
<td class=label width=55%><b>ADO Data Type</b></td>
</tr>
<tr valign=top>
<td width=45%>binary</td>
<td width=55%>adBinary (128)</td>
</tr>
<tr valign=top>
<td width=45%>varbinary</td>
<td width=55%>adVarBinary (204)</td>
</tr>
<tr valign=top>
<td width=45%>char</td>
<td width=55%>adChar (129)</td>
</tr>
<tr valign=top>
<td width=45%>varchar</td>
<td width=55%>adVarChar (200)</td>
</tr>
<tr valign=top>
<td width=45%>datetime</td>
<td width=55%>adDBTimeStamp (135)</td>
</tr>
<tr valign=top>
<td width=45%>smalldatetime</td>
<td width=55%>adDBTimeStamp (135)</td>
</tr>
<tr valign=top>
<td width=45%>decimal</td>
<td width=55%>adNumeric (131) (See note below)</td>
</tr>
<tr valign=top>
<td width=45%>numeric</td>
<td width=55%>adNumeric (131)</td>
</tr>
<tr valign=top>
<td width=45%>float</td>
<td width=55%>adDouble (5)</td>
</tr>
<tr valign=top>
<td width=45%>real</td>
<td width=55%>adSingle (4)</td>
</tr>
<tr valign=top>
<td width=45%>int</td>
<td width=55%>adInteger (3)</td>
</tr>
<tr valign=top>
<td width=45%>smallint</td>
<td width=55%>adSmallInt (2)</td>
</tr>
<tr valign=top>
<td width=45%>tinyint</td>
<td width=55%>adUnsignedTinyInt (17)</td>
</tr>
<tr valign=top>
<td width=45%>money</td>
<td width=55%>adNumeric (131)</td>
</tr>
<tr valign=top>
<td width=45%>smallmoney</td>
<td width=55%>adNumeric (131)</td>
</tr>
<tr valign=top>
<td width=45%>bit</td>
<td width=55%>adBoolean (11)</td>
</tr>
<tr valign=top>
<td width=45%>timestamp</td>
<td width=55%>adBinary (128)</td>
</tr>
<tr valign=top>
<td width=45%>text</td>
<td width=55%>adLongVarChar (201)</td>
</tr>
<tr valign=top>
<td width=45%>image</td>
<td width=55%>adLongVarBinary (205)</td>
</tr>
</table><br>
<p class=atl>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>If you use a DTC, the DTC will map adDecimal (14) as the ADO data type of an SQL Server decimal. However, in some versions of ADO, you might experience difficulties with this mapping. If so, you need to substitute a different data type. For details, see <a href="#visql_fix">"Fixing Decimal Data Types,"</a> later in this paper.</p></li>
<li>
<b>Direction.</b> A property indicating whether you are passing a value to the stored procedure or getting one back. Table 3 describes direction values.<p class=label>
Table 3.<b> Direction Values</b>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=47%><B><b>Direction value</b></B></td>
<td width=53%><B><b>Description</b></B></td>
</tr>
<tr valign=top>
<td width=47%>adParamInput (1) (Default)</td>
<td width=53%>Passing data to stored procedure (input parameter)</td>
</tr>
<tr valign=top>
<td width=47%>adParamOutput (2)</td>
<td width=53%>Passing data from stored procedure (output parameter)</td>
</tr>
<tr valign=top>
<td width=47%>adParamInputOutput (3)</td>
<td width=53%>Bidirectional parameter</td>
</tr>
<tr valign=top>
<td width=47%>adParamReturnValue (4)</td>
<td width=53%>Return value</td>
</tr>
</table><br>
</li>
<li>
<b>Size.</b> The maximum length of the data you intend to pass. For character data, this must be equal to or less than the maximum length that the corresponding stored procedure parameter will accept. This value is not required when you are defining numeric parameters.<br><br></li>
<li>
<b>Value.</b> The actual value to pass to the stored procedure. This can be a literal value, the name of a variable, or an expression.</li>
</ul>
<p>
After creating a Parameter object, you add it to the Parameters collection by calling the collection's <b>Append</b> method. Here's a simple example:</p>
<pre><code>&lt;!-- #include adovbs.inc --&gt;
Set oTmp = oCmd.CreateParameter("pEmpID", adInteger, _
 &nbsp; adParamInput,, 100)
oCmd.Parameters.Append oTmp
</code></pre>
<p>
You could compress both steps (creating the parameter and appending it to the collection) into a single line using a command such as the following:</p>
<pre><code>oCmd.Parameters.Append oCmd.CreateParameter("pEmpID",_
 &nbsp; adInteger, 1,, 100)
</code></pre>
<p>
You must create and append a Parameter object for each parameter that the stored procedure expects. When you do, be sure that you create and append the parameters in the order that the stored procedure declares them, because when the stored procedure is called, the Parameter objects are passed by position.</p>
<p>
Here's an example that creates three parameters. The first is an integer, the second a character string, and the third a date. For the sake of the example, the first parameter is passed as a literal value, the second as a variable, and the third as an expression. As each parameter is created, its object reference is stored in a temporary variable, which is then passed to the <b>Append</b> method to be added to the Parameters collection.</p>
<pre><code>&lt;!-- #include adovbs.inc --&gt;
&lt;%
Set oTmp = oCmd.CreateParameter("pEmpID", adInteger,_
 &nbsp; adParamInput,, 100)
oCmd.Parameters.Append oTmp

Set oTmp = oCmd.CreateParameter("pEmpLName", adChar,_
 &nbsp; adParamInput, 25, vLastName)
oCmd.Parameters.Append oTmp

Set oTmp = oCmd.CreateParameter("pEmpHireDate",_
 &nbsp; adDBTimeStamp, adParamInput,,_
 &nbsp; Request.Form("HireDate"))
oCmd.Parameters.Append oTmp
%&gt;
</code></pre>
<p>
After the parameters are created and appended to the Command object's Parameters collection, you can create and open a result set using that command. Opening the result set passes the parameters to the stored procedure, and then executes the procedure. For example, you could add the following line immediately after the preceding example:</p>
<pre><code>&lt;%
Set oRs = Server.CreateObject("ADODB.Recordset")
oRs.Open oCmd
%&gt;
</code></pre>
<p>
After creating parameters and appending them to the Parameters collection, you can change their values at any time, which is useful if you want to call the same stored procedure multiple times in the same page. To change a parameter, set its <b>Value</b> property to a new value, as in this example:</p>
<pre><code>oCmd.Parameters("pEmpID").Value = 100
</code></pre>
<p>
Alternatively, you can reference the parameter by its position within the collection:</p>
<pre><code>oCmd.Parameters(1).Value = 100
</code></pre>
<p>
An even more abbreviated version simply specifies the positional value without even referencing the Parameters collection at all:</p>
<pre><code>oCmd(1) = 100
</code></pre>
<p>
The last method is the most compact way to reference parameters, but is less readable and can therefore result in errors. </p>
<p>
As an example of how to reference and change parameters, the following script creates a small report of insurance policies using two result sets. The first result set shows the policies with claims in 1995 and the second with claims in 1996. After the first record set is displayed, it is closed. The parameter values are changed, and then the record set it opened (and thus executed) again:</p>
<pre><code>&lt;%
' [Script to create ADO objects not included here]
vStartDate = "Jan 1, 1995"
vEndDate = "Dec 31, 1995"
Set tmpParam = oCmd.CreateParameter("pStartDate", 135,_
 &nbsp; 1,,vStartDate)
oCmd.parameters.append tmpParam
Set tmpParam = oCmd.CreateParameter("pEndDate", 135,_
 &nbsp; 1,,vEndDate)
oCmd.parameters.append tmpParam
oRs.Open oCmd
%&gt;
&lt;h2&gt;Claims in 1995&lt;/h2&gt;
&lt;%Do until oRs.EOF%&gt;
 &nbsp; &lt;P&gt;PolicyID = &lt;% =oRs.Fields("PolicyID")%&gt;&lt;br&gt;
 &nbsp; Date = &lt;% =oRs.Fields("ClaimDate")%&gt;&lt;/P&gt;
 &nbsp; &lt;%oRs.MoveNext%&gt;
&lt;%Loop%&gt;
&lt;%oRs.Close%&gt;

&lt;!-- The parameter values are now changed and the 
 &nbsp;&nbsp;&nbsp; record set opened again. --&gt;
&lt;%
oCmd.Parameters("pStartDate").Value = "Jan 1, 1996"
oCmd(1) = "Dec 31, 1996"      ' Alternate syntax 
oRs.Open oCmd
%&gt;
&lt;h2&gt;Claims in 1996&lt;/h2&gt;
&lt;%Do until oRs.EOF%&gt;
 &nbsp; &lt;P&gt;PolicyID = &lt;% =oRs.Fields("PolicyID")%&gt;&lt;br&gt;
 &nbsp; Date = &lt;% =oRs.Fields("ClaimDate")%&gt;&lt;/P&gt;
 &nbsp; &lt;%oRs.MoveNext%&gt;
&lt;%Loop%&gt;
&lt;%oRs.Close%&gt;
</code></pre>
<h3><a name="visql_fix"></a>Fixing Decimal Data Types</h3>
<p>
If the stored procedure you are calling includes a parameter with the SQL Server data type of decimal, money, or smallmoney, you might experience difficulty if you use the ADO data type adDecimal (14) when creating a Parameter object. DTCs assign the ADO data type 14 if they detect a decimal data type in the stored procedure, so you're particularly likely to see the problem if you've used a DTC.</p>
<p>
You'll know you have the problem if the stored procedure has one of the decimal data types and you see this error when requesting the Web page that calls the stored procedure:</p>
<pre><code>At least one parameter contained a type that was not supported.
</code></pre>
<p>
To make the fix, you need to find the line in which the decimal parameter is created. In the script generated by the DTC, look for calls to the <b>CreateParameter</b> method. For example, you might find a line like this:</p>
<pre><code>Set tmpParam = cmdTemp.CreateParameter("@vSalary",
 &nbsp; 14, 1, 4, [vSalary])
</code></pre>
<p>
In the <b>CreateParameter</b> method, the second parameter is the data type of the data you are passing. You will find the value 14 there for decimal and money data types. Substitute the ADO data type adNumeric (131), and the stored procedure will work fine.</p>
<h2>Getting Output Parameter Values from a Stored Procedure</h2>
<p>
If the stored procedure you are calling returns a value—either the return value or an output parameter declared explicitly in the stored procedure—you can get the value to use in your Web application. Getting the value of an output parameter is similar to passing an input parameter value to the procedure, but requires an extra step or two.</p>
<p>
The first thing to do is to determine whether your stored procedure generates a result set. Some don't; they only calculate a value and return that. Either way, you have to know whether there will be a result set, because that will determine how you can get the value of the output parameters.</p>
<p>
As with passing parameters, there are different ways to get output parameters:
<ul type=disc>
<li>
Using a DTC to set up a call to the stored procedure. However, even if you use the DTC, you might still need to modify some of the generated script.<br><br></li>
<li>
Manually setting up the parameters using the Command object's Parameters collection.</li>
</ul>
<p>
Whichever way you choose, you must then add some script to extract the value of the parameters after the stored procedure has run.</p>
<h3>Using a DTC to Fetch Output Parameter Values</h3>
<p>
To use a DTC to call a stored procedure that returns output parameter values, you use the same basic technique that you use when the stored procedure requires input parameters. (For details, see <a href="#visql_spec">"Specifying Input Parameter Values in a DTC"</a> earlier in this paper.)</p>
<p>
One difference is that when you click on the Command tab of the <b>Properties</b> window, you see the output parameters marked with <b><img src="visql06.gif" border=0></b> and the return value marked with <img src="visql07.gif" border=0>. The Command tab allows you to specify an expression (most logically, a variable) for the output parameter. However, because you won't use any variables that you specify here, there's no real need to enter anything for the output parameters.</p>
<p>
When you save the DTC, it generates script to call the stored procedure and manage the parameters. However, it does not complete the job for you. You must still add script to actually extract the value of the individual output parameters (and if you like, the stored procedure's return value).</p>
<p>
In addition, if the stored procedure produces a result set, you have to add some script to handle SQL Server output parameter values, because SQL Server does not return output parameter values until after any result sets produced by the stored procedure have been processed.</p>
<p>
At this point, therefore, you are at the same point as if you had scripted the stored procedure call yourself and set up the Command object's Parameter collection, as described in the next section. For details about how to process the result set and extract the parameter values, see <a href="#visql_extra">"Extracting the Values of Output Parameters,"</a> later in this paper.</p>
<h3>Using the Parameters Collection with Output Parameters</h3>
<p>
You can use the Command object's Parameters collection to set up output parameters in almost the same way that you set up input parameters. (For the basics about using the Parameter collection, see <a href="#visql_pass">"Passing Input Parameters Using the Parameters Collection"</a> earlier in this paper.)</p>
<p>
When you use the <b>CreateParameter</b> method to create a Parameter object for an output parameter, the differences from creating an input parameter are these:
<ul type=disc>
<li>
The <b>Name</b> property is handier, because you can use it later when extracting the value of the parameter. If you use a DTC, a name is assigned for you based on the name of the parameter in the stored procedure. However, there is no particular relationship between parameter names in the ADO parameter and the stored procedure, and the names don't have to match. In fact, names are optional.<br><br></li>
<li>
The <b>Direction</b> property is set to 2, indicating an output parameter. You might also set it to 3 (bidirectional) if you are using the same parameter both to pass and receive data. If you are creating a Parameter object to get the stored procedure's return value, set the direction to 4.<br><br></li>
<li>
The <b>Value</b> property isn't passed in the <b>CreateParameter</b> method, since the stored procedure will set it.</li>
</ul>
<p>
The order in which you create the ADO parameters is important, as it is when setting up to pass input parameters—they are matched up between the Parameters collection and the stored procedure in the order they are declared in the stored procedure. If you create a parameter for the stored procedure's return value, it must always be the first element (element zero) in the collection.</p>
<p>
The following example shows how you might set up an ADO parameter to get the value of a stored procedure's return value and one output parameter:</p>
<pre><code>&lt;!-- #include adovbs.inc --&gt;
&lt;%
Set oTmp = oCmd.CreateParameter("Return Value", _
 &nbsp; adInteger, adParamReturnValue)
oCmd.Parameters.Append oTmp
Set oTmp = oCmd.CreateParameter("vAverageSales",_
 &nbsp; adInteger, adParamOutput)
oCmd.Parameters.Append oTmp
%&gt;
</code></pre>
<p>
After setting up the Parameters collection, you can execute the stored procedure. As with input parameters, you have two choices:
<ul type=disc>
<li>
Call the Command object's <b>Execute</b> method. This is a good choice if the stored procedure does not return a result set. For example:<pre><code>&lt;!-- #include adovbs.inc --&gt;
&lt;%
Set oTmp = oCmd.CreateParameter("vAverageSales",_
 &nbsp; adInteger, adParamOutput)
oCmd.Parameters.Append oTmp
oCmd.Execute
%&gt;
</code></pre>
</li>
<li>
Create a Recordset object, and call its <b>Open</b> method or the Command object's <b>Execute</b> method. The <b>Open</b> method allows you more flexibility, such as maintaining a bidirectional cursor in the result set. You must use one of these two methods if the stored procedure returns a result set. If you use a DTC, you'll see that the DTC creates a Recordset object and calls its <b>Open</b> method, because the DTC does not check that a stored procedure creates a result set. For example:<pre><code>&lt;!-- #include adovbs.inc --&gt;
&lt;%
Set oTmp = oCmd.CreateParameter("vAverageSales",_
 &nbsp; adInteger, adParamOutput)
oCmd.Parameters.Append oTmp
Set oRs = Server.CreateObject("ADODB.Recordset")
oRs.Open oCmd
%&gt;
</code></pre>
</li>
</ul>
<h3><a name="visql_extra"></a>Extracting the Values of Output Parameters</h3>
<p>
After the stored procedure has run, you can extract the return value and the value of the output parameters. If the stored procedure does not return a result set, and if you scripted a call to it using the Command object's <b>Execute</b> method, you're all set. However, you have to manage the result set if either of the following applies:
<ul type=disc>
<li>
You scripted the call yourself and used the Recordset object's <b>Open</b> method to create the result set.<br><br></li>
<li>
You used a DTC to set up a call to the stored procedure, whether or not the stored procedure returned a result set.</li>
</ul>
<p>
If the stored procedure returns a result set, you probably want to use that result set in your application. Therefore, you should add the necessary script, or use a DTC to manage the result set for you. Either way, following the script that uses the result set, you must close the result set, using script such as this:</p>
<pre><code>&lt;%oRs.Close%&gt;
</code></pre>
<p>
If you have used a DTC, your line of script will probably look more like this:</p>
<pre><code>&lt;%Datacommand1.Close%&gt;
</code></pre>
<p>
Be sure that you put this script after the last possible reference to the result set; otherwise, ADO will display an error when you next attempt to access the result set. Also be sure to put this line outside of the metadata definitions for any DTCs you are using, or the line will be overwritten the next time you use the visual designer to edit the DTC.</p>
<p>
The other possible situation is that the stored procedure does not return a result set, but your script has run the stored procedure by calling a Recordset object's <b>Open</b> method. If you used a DTC, this is your situation, because the DTC had no way of knowing that the stored procedure wouldn't produce a result set. </p>
<p>
You have a couple of choices. One is to root out the call to the <b>Open</b> method and substitute a call to the Command object's <b>Execute</b> method. The disadvantage is that you are then changing script generated by the DTC, with the danger of losing your changes if you ever again use the visual designer to edit the DTC.</p>
<p>
A safer choice is to add some script that removes the (nonexistent) result set, and then throws away the Recordset object. Add some lines like the following:</p>
<pre><code>&lt;%Datacommand1.Open cmdTemp%&gt;
[...]
' The following script should appear outside the DTC
' metadata definition
&lt;%While Not Datacommand1 Is Nothing
 &nbsp; Set Datacommand1 = Datacommand1.NextRecordset()
Wend
%&gt;
</code></pre>
<p>
Now you're ready to get the output parameters. To do so, get the value of the parameter's <b>Value</b> property, something like this:</p>
<pre><code>Last name = &lt;%=oCmd.Parameters("vAverageSales").Value%&gt;
</code></pre>
<p>
Here's an example for extracting a parameter if you're using a DTC:</p>
<pre><code>Last name=&lt;%=Datacommand1.Parameters_
 &nbsp; ("@vAverageSales").Value%&gt;
</code></pre>
<p>
You can refer to the parameter you want by the name you assigned it when you created it, or by its position in the Parameters collection, as in the following example:</p>
<pre><code>Last Name = &lt;%=oCmd.Parameters(1).Value%&gt;
</code></pre>
<p>
If you use a positional reference, remember that the collection begins with element zero. You'll also have to remember where each parameter is in the collection—and don't forget that the stored procedure's return value is often in element zero.</p>
<h2>Summing Up</h2>
<p>
Calling stored procedures is an efficient way to manage data in your Web applications, made all the more powerful by the ability to pass parameters to and from the procedure. In Visual InterDev, you can use DTCs to help you call stored procedures, or you can script the call yourself using ADO objects. Passing parameters does not add much complexity to the ordinary methods of accessing a database, but does require that you understand how to set up a DTC or your own script both to pass and receive parameters. By mastering the few details required to successfully pass parameters, you can manage stored procedures with ease.</p>
</BODY>
</HTML>
