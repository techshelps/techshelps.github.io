<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Pointers to Member Functions and Templates</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_pointer"></a>Pointers to Member Functions and Templates</h1>
<p>
Dale Rogerson</p>
<p>
July 20, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4324">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the TemMemPtr sample application.</a></p>
<h2>Abstract</h2>
<p>
Pointers to member functions are used to implement member function callbacks, which can reside in any class due to the use of templates.The TemMemPtr sample application illustrates the concept.</p>
<h2>Introduction</h2>
<p>
Using callbacks is one of the most powerful ways to customize an object. The traditional example is the <b>qsort</b> function, which takes a pointer to a function that compares two objects. However, <b>qsort</b> only works if the function is not a member of a class.</p>
<p>
I recently wrote an application containing a customizable dialog box. However, unlike the normal C-style callbacks used by <b>qsort</b> and in most Win32®-based applications, I used C++ member functions to implement these callbacks. By cleverly using templates, the dialog box could call member functions in any C++ class, including my <b>CView</b>- and <b>CDocument</b>-derived classes.</p>
<h2>Pointers to Member Functions</h2>
<p>
Callbacks are implemented with pointers to functions: A pointer to the callback is passed to a function, which then calls the callback by means of the pointer. If you want to use a member function as a callback, you need to use a pointer to the member function.</p>
<p>
Let’s take a closer look at pointers to member functions. Take, for example, the following <b>CFoo</b> class:</p>
<pre><code>class CFoo {
public:
 &nbsp; void f(int) ;
} ;
</code></pre>
<p>
Let’s call <b>CFoo::f</b> through a pointer. Below, I have defined <b>MemFntPtr</b> as a pointer to a <b>CFoo</b> member function taking an <b>integer</b> and returning <b>void</b>:</p>
<pre><code>typedef void (CFoo::*MemFntPtr)(int) ;
</code></pre>
<p>
Then I declare a pointer to a member function and initialize it with the address of <b>CFoo::f</b>:</p>
<pre><code>MemFuncPtr ptr = &amp;CFoo::f ;
</code></pre>
<p>
The following code fragment shows how to call <b>CFoo::f</b>:</p>
<pre><code>CFoo aFoo ;
CFoo* pFoo = &amp;aFoo ;
// Call f directly.
aFoo.f(5) ;
// Call f via an object pointer.
pFoo-&gt;f(5) ;
// Call f using member function pointer.
(aFoo.*ptr)(5) ; 
// Call f using member function pointer 
//&nbsp; and an object pointer.
(pFoo-&gt;*ptr)(5) ;
</code></pre>
<p>
At first glance, pointers to member functions look very different from pointers to functions. However, the table below shows that pointers to member functions are similar syntactically to pointers to functions.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Pointer to Function</b></td>
<td class=label colspan=2 width=52%><b>Pointer to Member Function</b></td>
</tr>
<tr valign=top>
<td width=48%><pre><pre><code>int f(char *p) { ... }</code></pre>
</pre>
</td>
<td width=50%><pre><code>class C { ... } ;</code><pre><code>int C::f(char *p) { ... }</code></pre>
</pre>
</td>
</tr>
<tr valign=top>
<td width=48%><pre><code>int (*pf)(char*) = &amp;f ;</code></pre>
</td>
<td width=50%><pre><code>int (C::*pf)(char*) = &amp;C::f ;</code></pre>
</td>
</tr>
<tr valign=top>
<td width=48%><pre><pre><code>int i = (*pf)("hello") ;</code></pre>
</pre>
</td>
<td width=50%><pre><code>C aC ;</code><pre><code>int i = (aC.*pf)("hello") ;</code></pre>
</pre>
</td>
</tr>
</table><br>
<h2>Pointers to Virtual Member Functions</h2>
<p>
Pointers to member functions can point to virtual members with all the associated benefits. Consider the following definitions:</p>
<pre><code>class CAircraft {
public:
 virtual void TakeOff() ;
 virtual void Fly() ;
 virtual void Land() ;
} ;

class CAirplane : public CAircraft {
public:
 virtual void TakeOff() ;
 virtual void Fly() ;
 virtual void Land() ;
} ;

class CHelicopter : public CAircraft {
public:
 virtual void TakeOff() ;
 virtual void Fly() ;
 virtual void Land() ;
} ;
</code></pre>
<p>
Let's create a helicopter and a plane (boy, don't you wish it were this easy!):</p>
<pre><code>CHelicopter aHeli ;
CAirplane aPlane ;
</code></pre>
<p>
Now, let’s take off in the helicopter. We define <b>Maneuver</b> to be a pointer to a member function without parameters and returning <b>void</b>. The following statements define <b>pManeuver</b> as a pointer to <b>CAircraft::TakeOff</b> and <b>pCraft</b> as a <b>CAircraft</b> pointer pointing to <b>aHeli</b>.</p>
<pre><code>typedef void (CAircraft::*Maneuver)() ;
Maneuver pManeuver = &amp;CAircraft::TakeOff ;
CAircraft* pCraft = &amp;aHeli ;
</code></pre>
<p>
Now we are ready to take off in our helicopter!</p>
<pre><code>(pCraft-&gt;*pManeuver)() ;
</code></pre>
<p>
To take off in our plane, we just change the value of <b>pCraft</b> to the address of <b>aPlane</b> and use the same statement we used previously:</p>
<pre><code>pCraft = &amp;aPlane ;
(pCraft-&gt;*pManeuver)() ; 
</code></pre>
<p>
To land our plane and helicopter, we change the value of <b>pManeuver</b> to the address of <b>CAircraft::Land</b>:</p>
<pre><code>aManeuver = &amp;CAircraft::Land ;
(pCraft-&gt;*pManeuver)() ;&nbsp; // Land the plane. . . 
pCraft = &amp;aHeli ;
(pCraft-&gt;*pManeuver)() ;&nbsp; //&nbsp; and helicopter.
</code></pre>
<p>
Using pointers to virtual member functions is a powerful technique and can lead to some dynamic solutions to programming problems. The solution above is useful in programs in which a user selects an object (picture, sound, or video) and an operation to perform on that object ( play, copy, delete, and so on). The code to do the operation can be as simple as:</p>
<pre><code>(pSelectedObject-&gt;*pSelectedOperation)() ;
</code></pre>
<p>
The Microsoft Foundation Class Library (MFC) message maps use pointers to member functions to route messages to the appropriate function. Just look at the MFC <b>CWnd::WndProc</b> function.</p>
<h2>Back to Callbacks</h2>
<p>
I started this article talking about callbacks. As an example, let’s say that I want my application to customize certain controls in a dialog box. So, I pass a callback to the dialog box, and the dialog box will call the callback with a pointer to one of its controls. The callback can then customize the control.</p>
<p>
Below is the definition of the document class with the callback member function for customizing the dialog box.</p>
<pre><code>class CMyDoc : public CDoc {
.
.
.
 // Callback.
 void CalledByDialog(CWnd* pWnd) ;
 // Initalize and call dialog.
 void OnCallitFromdoc() ;
.
.
.
} ;
</code></pre>
<p>
The dialog box is declared as follows:</p>
<pre><code>class CTheDialog : public CDialog
{
.
.
.
public:
 // Set object containing the callback.
 void SetObjectPtr(CMyDoc* ptr)
 &nbsp;&nbsp;&nbsp;&nbsp; {m_ptrObject = ptr; } 
 // Define callback's signature.
 typedef void (CMyDoc::*PtrMemFnt)(CWnd*);
 // Set which function is the callback.
 void SetPtrMemFnt(PtrMemFnt ptr)
 &nbsp;&nbsp;&nbsp;&nbsp; {m_ptrMemFnt = ptr; }
protected:
 // Store pointers.
 CMyDoc* m_ptrObject ;
 PtrMemFnt m_ptrMemFnt ;
 // Call the callback.
 virtual void CallMemberPtr(CWnd* pWnd)
  { (m_ptrObject-&gt;*m_ptrMemFnt)(pWnd) ;}
.
.
.
 BOOL CTheDialog::OnInitDialog() ;
.
.
.
};
</code></pre>
<p>
<b>SetObjectPtr</b> tells the dialog box which object contains the member function callback. <b>SetPtrMemFnt</b> tells the dialog box which function in the object is the callback. <b>PtrMemFnt</b> defines which type of functions can be used as callbacks. In this case, <b>CMyDoc</b> member functions taking a <b>CWnd</b> pointer and returning a <b>void</b> can be callbacks.</p>
<p>
Let’s follow the execution path to see what happens. First, <b>CMyDoc::OnCallitFromdoc</b> creates the dialog box and passes the object pointer and the member function pointer for our callback to the dialog box.</p>
<pre><code>void CMyDoc::OnCallitFromdoc() 
{
 CTheDialog aDlg ;
 aDlg.SetObjectPtr(this) ;
 aDlg.SetPtrMemFnt(&amp;CMyDoc::CalledByDialog) ;
 aDlg.DoModal() ;
}
</code></pre>
<p>
When the dialog box starts, <b>OnInitDialog</b> calls <b>CallMemberPtr</b>.</p>
<pre><code>BOOL CTheDialog::OnInitDialog() 
{
 CDialog::OnInitDialog();
 CallMemberPtr() ;&nbsp; // Call the callback.
 return TRUE;
}
</code></pre>
<p>
<b>CallMemberPtr</b> calls the callback with the statement:</p>
<pre><code>(m_ptrObject-&gt;*m_ptrMemFnt)(pWnd);
</code></pre>
<p>
The callback is defined in <b>CMyDoc</b> as:</p>
<pre><code>void CMyDoc::CalledByDialog(CWnd* pWnd)
{
 pWnd-&gt;SetWindowText(
 &nbsp; "Hello from the Doc class.") ;
}
</code></pre>
<p>
Now we have a dialog box that can be customized by callbacks in <b>CMyDoc</b>.</p>
<h2>Problems</h2>
<p>
But there’s a problem with this implementation of a callback. <b>CTheDialog</b> can only be customized by a <b>CMyDoc</b> object. Consider the following code:</p>
<pre><code>class CMyView : public CView {
.
.
.
 // Callback.
 void CalledByDialog(CWnd* pWnd) ; 
 // Initalize and call dialog.
 void OnCallitFromview() ;
.
.
.
} ;
void CMyView::OnCallitFromview() 
{
 CTheDialog aDlg ;
 // The following does not work 
 //&nbsp; because CMyView != CMyDoc.
 aDlg.SetObjectPtr(this);
 aDlg.SetPtrMemFnt(&amp;CViewDoc::CalledByDialog);
 aDlg.DoModal() ;
}
</code></pre>
<p>
<b>CMyView::OnCallitFromview</b> as shown above will not work. <b>CTheDialog::SetObjectPtr</b> expects a <b>CMyDoc</b> pointer, and <b>CTheDialog::SetPtrMemFnt</b> expects a pointer to a member function in <b>CMyDoc</b>.</p>
<pre><code>typedef void (CMyDoc::*PtrMemFnt)(CWnd* pWnd);
</code></pre>
<p>
So how can my dialog box invoke callbacks in both <b>CMyDoc</b> and <b>CMyView</b>? When you want to do something with multiple incompatible types, it’s time to look at templates.</p>
<h2>Templates and Callbacks</h2>
<p>
A class can be thought of as a recipe from which objects are created. A class template is a recipe from which classes are created. Using templates is a form of meta-programming; the compiler uses the template to generate code customized for a particular type.</p>
<p>
For the template solution, I moved all of the code supporting callbacks from <b>CTheDialog</b> into a new template class. This new template class, <b>CTemplateDialog</b>, is derived from <b>CTheDialog</b>.</p>
<pre><code>class CTheDialog : public CDialog
{
.
.
.
// Implementation.
protected:
 virtual void CallMemberPtr(CWnd*) = 0 ;
 BOOL CTheDialog::OnInitDialog() ;
.
.
.
};
</code></pre>
<p>
A pure virtual version of <b>CallMemberPtr</b> is left in <b>CTheDialog</b> so that the implementation of <b>CTheDialog::OnInitDialog</b> remains the same.</p>
<p>
All of the callback code removed from <b>CTheDialog</b> was placed in <b>CTemplateDialog</b>, which inherits from <b>CTheDialog</b>. Below is the definition for the <b>CTemplateDialog</b> template class. The template takes one parameter, <i>T</i>, which it uses to fill out the template when generating code. The compiler will replace all <i>T’</i>s in the code below with the appropriate class.</p>
<pre><code>template&lt;class T&gt; 
class CTemplateDialog : public CTheDialog
{
 public:
  void SetObjectPtr(T* ptr) 
 &nbsp;&nbsp;&nbsp;&nbsp; {m_ptrObject = ptr;} 
  typedef void (T::*PtrMemFnt)(CWnd*) ;

  void SetPtrMemFnt(PtrMemFnt ptr) 
 &nbsp;&nbsp; {m_ptrMemFnt = ptr; }
 protected:
  T* m_ptrObject ;
  PtrMemFnt m_ptrMemFnt ;
  virtual void CallMemberPtr(CWnd* pWnd) 
 &nbsp;&nbsp; { (m_ptrObject-&gt;*m_ptrMemFnt)(pWnd) ;}
};
</code></pre>
<p>
For example, if you use:</p>
<pre><code>CTemplateDialog&lt;CMyDoc&gt; aDlg ;
</code></pre>
<p>
all of the <i>T’</i>s will be replaced with <b>CMyDoc</b>, generating the following code:</p>
<pre><code>.
.
.
void SetObjectPtr(CMyDoc* ptr) 
  {m_ptrObject = ptr; } 
typedef void (CMyDoc::*PtrMemFnt)(CWnd*) ;
.
.
.
CMyDoc* m_ptrObject ;
.
.
.
</code></pre>
<p>
It seems a lot like macros, doesn’t it? But this is typesafe and completely supported by the compiler.</p>
<p>
The callback is initialized and the dialog box is still executed from the <b>CMyDoc::OnCallitFromdoc</b> function, but now <b>CTemplateDialog</b> is used instead of <b>CTheDialog</b>.</p>
<pre><code>void CMyDoc::OnCallitFromdoc() 
{
 CTemplateDialog&lt;CMyDoc&gt; aDlg ;
 aDlg.SetObjectPtr(this) ;
 aDlg.SetPtrMemFnt(&amp;CMyDoc::CalledByDialog) ;
 aDlg.DoModal() ;
}
</code></pre>
<p>
Now we can also customize the dialog box from our <b>CMyView</b> class:</p>
<pre><code>void CMyView::OnCallitFromview() 
{
 CTemplateDialog&lt;CMyView&gt; aDlg ;
 aDlg.SetObjectPtr(this) ;
 aDlg.SetPtrMemFnt(&amp;CMyView::CalledByDialog) ;
 aDlg.DoModal() ;
}
</code></pre>
<h2>Summary</h2>
<p>
Templates and pointers to member functions are two very powerful features of C++. Using these two features in conjunction results in even more powerful solutions to programming problems.</p>
</BODY>
</HTML>
