<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using CODECs to Compress Wave Audio</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_codec"></a>Using CODECs to Compress Wave Audio</h1>
<p>
Nigel Thompson</p>
<p>
April 4, 1997</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5058">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the CODEC sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
Microsoft® Windows® 95 and Microsoft Windows NT® operating systems both include CODECs that can compress and decompress wave audio streams. Saving your wave audio data in compressed form can help with data storage requirements and reduce data transmission times when audio is sent over a network.</p>
<p>
This article and its accompanying sample code shows how to compress wave audio packets using any of the CODECs installed on a Windows system. By altering the code very slightly it can also be used to decompress compressed data or perform data format conversions.</p>
<p>
The sample code was developed using Microsoft Visual C++® version 5.0 and tested on the Windows 95 and Windows NT 4.0 operating systems.</p>
<h2>Introduction</h2>
<p>
Windows 95 and, more recently, Windows NT both include the ability to handle compressed waveform audio and video data streams using installable CODECs. </p>
<p>
A CODEC is a small piece of code used to COmpress or DECompress a data stream (hence CO-DEC). Most CODECs handle both compression and decompression. However, some CODECs are designed only to decompress so that proprietary data can be played on a system but the data format cannot be created on that system. </p>
<p>
Although a CODEC can be used in principal to compress or decompress any stream of data, various CODECs have been designed to compress certain data types with either higher compression ratios, better fidelity, or real-time performance. For example, the best way to get a high degree of video data compression may not give adequate results when applied to audio data and vice versa.</p>
<p>
This article focuses on how to use a CODEC from your own code to compress audio data into one of the formats supported by the CODECs on your system. The primary reason for compressing audio data is to reduce the volume of data required to store a sound sequence. Smaller data volumes mean that less disk space is occupied by the sounds and that they can be transmitted faster over a modem or network link. If the data is compressed into one of the common formats supported by Windows systems, it can be played back directly without the need to decompress it manually—the system will use its own CODECs to decompress the data for playback.</p>
<h2>What CODECs Are in My System?</h2>
<p>
Windows 95 and Windows NT come complete with a number of standard CODECs and can have others installed by applications that are installed on the system. For example, the DSP Group, Inc. TrueSpeech CODEC ships with Windows 95, so any program you write for Windows 95 will have this CODEC available (providing the user hasn't removed it or disabled it using the Control Panel). An example of a CODEC that might be installed later is the one that the Microsoft Network (MSN) software uses for its own audio data.</p>
<p>
All the installed CODECs are managed by the Audio Compression Manager (ACM). We can find out what CODECs are installed, and what formats each of them supports, by querying the ACM from a simple program. You can also double-click <b>Multimedia</b> in the Control Panel, and then click the <b>Advanced</b> tab to see a list of the installed CODECs on your system.</p>
<p>
Writing a simple command line program to query the ACM provides a good introduction to dealing with the ACM and examining what each CODEC it manages can do. The CAPS program that accompanies this article does just that—so let's have a look at the code and I'll explain what each step does as we go through it.</p>
<p>
Let's begin by looking at what header files we need to include to be able to call the ACM application programming interfaces (APIs):</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;mmsystem.h&gt;
#include &lt;mmreg.h&gt;  // Multimedia registration
#include &lt;msacm.h&gt; &nbsp;&nbsp; // Audio Compression Manager
#include &lt;stdio.h&gt;
</code></pre>
<p>
The mmsystem.h header defines most of the multimedia support for Windows but not the ACM API set or any of the manufacturer-specific defines. Mmreg.h contains definitions of wave format tags for various wave data types as designed by different manufacturers. It also contains definitions of structures (based on WAVEFORMATEX) that are used to manipulate the different wave data types. The msacm.h file contains the APIs, flags, and so on for the ACM.</p>
<p>
The first thing we can do is perform some general queries of the ACM to determine its version number and get information such as how many drivers it is currently managing. Here's part of the code that queries the ACM:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get the ACM version.
 &nbsp;&nbsp; DWORD dwACMVer = acmGetVersion();
 &nbsp;&nbsp; printf("ACM version %u.%.02u build %u",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(dwACMVer) &gt;&gt; 8,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIWORD(dwACMVer) &amp; 0x00FF,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOWORD(dwACMVer));
 &nbsp;&nbsp; if (LOWORD(dwACMVer) == 0) printf(" (Retail)");
 &nbsp;&nbsp; printf("\n");

 &nbsp;&nbsp; // Show some ACM metrics.
 &nbsp;&nbsp; printf("ACM metrics:\n");

 &nbsp;&nbsp; DWORD dwCodecs = 0;
 &nbsp;&nbsp; MMRESULT mmr = acmMetrics(NULL, ACM_METRIC_COUNT_CODECS, &amp;dwCodecs);
 &nbsp;&nbsp; if (mmr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; show_error(mmr);
 &nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%lu codecs installed\n", dwCodecs);
 &nbsp;&nbsp; }
</code></pre>
<p>
The CAPS sample queries the ACM for a few more metrics. With the sample files, you can look at the code in detail and run the application to see the results for yourself.</p>
<p>
Having looked at the ACM, we can now ask it to enumerate all of the drivers currently in the system. As is common practice in Windows programming, the enumeration function we call uses a callback function in our code to report data for each enumerated device. Here's the call that begins the enumeration of all the devices currently managed by the ACM:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;// Enumerate the set of enabled drivers.
 &nbsp;&nbsp; printf("Enabled drivers:\n");
 &nbsp;&nbsp; mmr = acmDriverEnum(DriverEnumProc, 0, 0); 
 &nbsp;&nbsp; if (mmr) show_error(mmr);
</code></pre>
<p>
Like many other multimedia functions, most of the ACM function calls return an MMRESULT value that indicates any error that might occur. A zero value indicates that the function call completed successfully. Now, let's see the enumeration callback function <b>DriverEnumProc</b>, which is called for each driver in the system:</p>
<pre><code>BOOL CALLBACK DriverEnumProc(HACMDRIVERID hadid, DWORD dwInstance, DWORD fdwSupport)
{
 &nbsp;&nbsp; printf(" id: %8.8lxH", hadid);
 &nbsp;&nbsp; printf("&nbsp; supports:\n");
 &nbsp;&nbsp; if (fdwSupport &amp; ACMDRIVERDETAILS_SUPPORTF_ASYNC) printf("&nbsp;&nbsp; async conversions\n");
 &nbsp;&nbsp; if (fdwSupport &amp; ACMDRIVERDETAILS_SUPPORTF_CODEC) printf("&nbsp;&nbsp; different format conversions\n");
 &nbsp;&nbsp; if (fdwSupport &amp; ACMDRIVERDETAILS_SUPPORTF_CONVERTER) printf("&nbsp;&nbsp; same format conversions\n");
 &nbsp;&nbsp; if (fdwSupport &amp; ACMDRIVERDETAILS_SUPPORTF_FILTER) printf("&nbsp;&nbsp; filtering\n");

 &nbsp;&nbsp; // Get some details.
 &nbsp;&nbsp; ACMDRIVERDETAILS dd;
 &nbsp;&nbsp; dd.cbStruct = sizeof(dd);
 &nbsp;&nbsp; MMRESULT mmr = acmDriverDetails(hadid, &amp;dd, 0);
 &nbsp;&nbsp; if (mmr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; "); show_error(mmr);
 &nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; Short name: %s\n", dd.szShortName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; Long name:&nbsp; %s\n", dd.szLongName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; Copyright:&nbsp; %s\n", dd.szCopyright);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; Licensing:&nbsp; %s\n", dd.szLicensing);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; Features:&nbsp;&nbsp; %s\n", dd.szFeatures);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; Supports %u formats\n", dd.cFormatTags);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; Supports %u filter formats\n", dd.cFilterTags);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Open the driver.
 &nbsp;&nbsp; HACMDRIVER had = NULL;
 &nbsp;&nbsp; mmr = acmDriverOpen(&amp;had, hadid, 0);
 &nbsp;&nbsp; if (mmr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; "); show_error(mmr);
 &nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwSize = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmr = acmMetrics(had, ACM_METRIC_MAX_SIZE_FORMAT, &amp;dwSize);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dwSize &lt; sizeof(WAVEFORMATEX)) dwSize = sizeof(WAVEFORMATEX); // for MS-PCM
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WAVEFORMATEX* pwf = (WAVEFORMATEX*) malloc(dwSize);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset(pwf, 0, dwSize);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwf-&gt;cbSize = LOWORD(dwSize) - sizeof(WAVEFORMATEX);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwf-&gt;wFormatTag = WAVE_FORMAT_UNKNOWN;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACMFORMATDETAILS fd;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset(&amp;fd, 0, sizeof(fd));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd.cbStruct = sizeof(fd);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd.pwfx = pwf;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd.cbwfx = dwSize;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd.dwFormatTag = WAVE_FORMAT_UNKNOWN;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmr = acmFormatEnum(had, &amp;fd, FormatEnumProc, 0, 0);&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mmr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&nbsp;&nbsp; ");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; show_error(mmr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(pwf);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acmDriverClose(had, 0);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; return TRUE; // Continue enumeration.
}
</code></pre>
<p>
The callback function is passed a set of flags that describe the type of support the driver has. Some drivers can operate asynchronously while others cannot. Some drivers can convert one wave data format to another (these are CODECs) and other drivers can only perform filtering operations where the input and output formats are the same. Note that the ACM maintains this data along with the text name of the driver, copyright information, and so on so that we can look at this data without the need to load or open a specific driver. This is convenient, for example, when we want to present a list box to the user to select a specific driver to use.</p>
<p>
To obtain more detailed information about the capabilities of a driver, we must load the driver and open it, which is done by calling <b>acmOpenDriver</b>. Once the driver is open, we can request that it enumerate the wave data formats it supports. There is one minor complication here—although all wave format description structures are based on WAVEFORMATEX, many formats use an extended form of the structure to hold information specific to the structure. If we want to enumerate all the formats, we need some idea of how big a structure to allocate so that the driver can fill in the details. We can find the size of the largest structure required by calling <b>acmMetrics</b> and passing the ACM_METRIC_MAX_SIZE_FORMAT flag. </p>
<p>
If you look at the code above, you'll see that I simply cast the result of the allocation to be a <b>WAVEFORMATEX </b>pointer. I'm not interested in any type-specific data here, just the common information so that this pointer does all I need it to.</p>
<p>
Having allocated the structure, I can now call <b>acmFormatEnum</b> to enumerate the supported formats. Once again, we use a callback function to receive the enumerated format data:</p>
<pre><code>BOOL CALLBACK FormatEnumProc(HACMDRIVERID hadid, LPACMFORMATDETAILS pafd, DWORD dwInstance, DWORD fdwSupport)
{
 &nbsp;&nbsp; printf("&nbsp;&nbsp;&nbsp; %4.4lXH, %s\n", pafd-&gt;dwFormatTag, pafd-&gt;szFormat);


 &nbsp;&nbsp; return TRUE; // Continue enumerating.
}
</code></pre>
<p>
As you can see, this one's trivial and just prints out some of the information about the format.</p>
<p>
So, with the code above, you can query the ACM for all its drivers and find what formats are supported by each. I suggest you run the CAPS program now and see what your system currently has installed.</p>
<h2>Using a Specific CODEC</h2>
<p>
Okay, so we've seen how to find out what CODECs are installed on your system—now let's see how we locate a specific CODEC and use it to compress some audio data. Let's look at the CONV sample, which compresses a simple wave data packet using one of the available CODECs. To keep the code as simple as possible, I implemented it in a console application and have made no attempt either to play the compressed data or to save it to a file. The sample code simply shows how to find the driver you need and get it to convert the data into a compressed form. The rest, as we say, is up to you.</p>
<h3>Doing the Compression Two-Step</h3>
<p>
In the ideal world, compressing some data would be simply a case of saying to the system: "Here's some data, compress it in this format please." Unfortunately, the Windows programming world is far from ideal and, as usual, we get to do a lot of the grunt work ourselves. The first and most important problem to solve arises because of the fact that any given CODEC may not be able to compress the data format you just happen to be working in. For example, let's say that we record some data (perhaps a user speaking into a microphone) at 11.025 kHz, in 8-bit, mono pulse-code modulation (PCM), which is a format all Multimedia PCs can record in. We'd like to send this message to a relative via modem, so we want to compress it as much as possible to get the data size down. We choose to use the TrueSpeech CODEC, which comes with Windows and can achieve approximately 10:1 compression. The problem we immediately come up against is that the TrueSpeech CODEC can't handle 11.025 kHz, 8-bit, mono PCM data. It can only handle 8.000 kHz, 16 bit, mono PCM (or 8-bit in some cases). So, we have to first convert the source data into an intermediate PCM format that the TrueSpeech CODEC can handle, and then get the TrueSpeech CODEC to convert the intermediate data to the final format that we need.</p>
<p>
Converting one PCM format to another can be done using a different CODEC that also ships with Windows, so you need to use one CODEC to convert the data to the format the other CODEC can handle. Given that we know how to enumerate the CODECs and their supported formats, this looks reasonable.</p>
<p>
There is, however, one further problem that I chose to ignore in my sample code and I'll leave for you to resolve. If we have a CODEC that will create the compressed format we want but supports several input formats, how do we choose the best intermediate format to use? Following Nigel's maxim, which states, "Always do the least amount of work possible," I chose to use the first enumerated PCM format the CODEC supports. While this is very easy to implement, it can lead to some loss of data fidelity. Consider that the CODEC we want to use has some algorithm for almost lossless compression and can accept 8 or 16 bit PCM data at 11.025 or 22.050 kHz. Let's say we want to convert a high fidelity sample recorded at 44.1 kHz, 16 bit stereo. We are trying to reduce the data volume, but not at the expense of quality. If we simply enumerate the formats the CODEC supports, the first one we find might well be 11.025 kHz, 8-bit mono. If we convert to this format first and then compress it, we will certainly have lost some quality because the intermediate format we chose was not good enough. If we'd have used 16-bit and 22 kHz, we would have done much better. Having warned you of this pitfall, let's look now at the CONV sample and see how it works.</p>
<h3>The CONV Sample Application</h3>
<p>
The CONV sample works in four stages: it creates some sample waveform data, locates a suitable CODEC, converts the data to an intermediate form the CODEC can handle, and finally converts it to the required form. For simplicity, the source data is created programmatically rather than by a live recording or by reading a .wav file:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;// First we create a wave that might have been just recorded.
 &nbsp;&nbsp; // The format is 11.025 kHz, 8 bit mono PCM which is a recording
 &nbsp;&nbsp; // format available on all machines.
 &nbsp;&nbsp; // Our sample wave will be 1 second long and will be a sine wave 
 &nbsp;&nbsp; // of 1kHz, which is exactly 1,000 cycles.

 &nbsp;&nbsp; WAVEFORMATEX wfSrc;
 &nbsp;&nbsp; memset(&amp;wfSrc, 0, sizeof(wfSrc));
 &nbsp;&nbsp; wfSrc.cbSize = 0;
 &nbsp;&nbsp; wfSrc.wFormatTag = WAVE_FORMAT_PCM; // PCM
 &nbsp;&nbsp; wfSrc.nChannels = 1; // Mono
 &nbsp;&nbsp; wfSrc.nSamplesPerSec = 11025; // 11.025 kHz
 &nbsp;&nbsp; wfSrc.wBitsPerSample = 8; // 8 bit
 &nbsp;&nbsp; wfSrc.nBlockAlign = wfSrc.nChannels * wfSrc.wBitsPerSample / 8;
 &nbsp;&nbsp; wfSrc.nAvgBytesPerSec = wfSrc.nSamplesPerSec * wfSrc.nBlockAlign;

 &nbsp;&nbsp; DWORD dwSrcSamples = wfSrc.nSamplesPerSec;
 &nbsp;&nbsp; BYTE* pSrcData = new BYTE [dwSrcSamples]; // 1 second duration
 &nbsp;&nbsp; BYTE* pData = pSrcData;
 &nbsp;&nbsp; double f = 1000.0;
 &nbsp;&nbsp; double pi = 4.0 * atan(1.0);
 &nbsp;&nbsp; double w = 2.0 * pi * f;
 &nbsp;&nbsp; for (DWORD dw = 0; dw &lt; dwSrcSamples; dw++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double t = (double) dw / (double) wfSrc.nSamplesPerSec; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pData++ = 128 + (BYTE)(127.0 * sin(w * t));
 &nbsp;&nbsp; }
</code></pre>
<p>
A <b>WAVEFORMATEX </b>structure is created to describe the source data format and a 11.025 kHz, 8-bit, mono PCM wave of one-second duration is generated with some simple math.</p>
<p>
The next step is to choose a format we'd like to convert the data to and locate a suitable CODEC. </p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;WORD wFormatTag = WAVE_FORMAT_DSPGROUP_TRUESPEECH;

 &nbsp;&nbsp; // Now we locate a CODEC that supports the destination format tag.
 &nbsp;&nbsp; HACMDRIVERID hadid = find_driver(wFormatTag);
 &nbsp;&nbsp; if (hadid == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("No driver found\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; printf("Driver found (hadid: %4.4lXH)\n", hadid);
</code></pre>
<p>
The <b>find_driver</b> function enumerates all the drivers until it finds one that supports the given tag value (in this case WAVE_FORMAT_DSPGROUP_TRUESPEECH). I won't show the details because it's very similar to the enumeration code we looked at earlier. You can examine how it works for yourself later.</p>
<p>
Having located the driver, we now need to construct a <b>WAVEFORMATEX </b>structure for the final compressed data format that the driver will generate and also one for the intermediate PCM format that the driver needs as input:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get the details of the format.
 &nbsp;&nbsp; // Note: this is just the first of one or more possible formats for the given tag.
 &nbsp;&nbsp; WAVEFORMATEX* pwfDrv = get_driver_format(hadid, wFormatTag);
 &nbsp;&nbsp; if (pwfDrv == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error getting format info\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; printf("Driver format: %u bits, %lu samples per second\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwfDrv-&gt;wBitsPerSample, pwfDrv-&gt;nSamplesPerSec);

 &nbsp;&nbsp; // Get a PCM format tag the driver supports.
 &nbsp;&nbsp; // Note: we just pick the first supported PCM format which might not really
 &nbsp;&nbsp; // be the best choice.
 &nbsp;&nbsp; WAVEFORMATEX* pwfPCM = get_driver_format(hadid, WAVE_FORMAT_PCM);
 &nbsp;&nbsp; if (pwfPCM == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error getting PCM format info\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; printf("PCM format: %u bits, %lu samples per second\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwfPCM-&gt;wBitsPerSample, pwfPCM-&gt;nSamplesPerSec);
</code></pre>
<p>
At the risk of repeating myself, beware that the <b>get_driver_format</b> function just enumerates for the first matching format—this might not give you the best possible quality.</p>
<p>
Now we have <b>WAVEFORMATEX</b> structures built to describe the source format, the intermediate PCM format, and the final compressed format. It's time to start converting the data. Conversion is done by using what the ACM calls a stream. We open the stream passing descriptions of the source and destination formats, and then ask the stream to convert them.</p>
<p>
In the case we'll look at here, the conversion is done synchronously and may take quite some time if the CODEC algorithm is complex. Some CODECs can work asynchronously, notifying you as things progress via a message to a window, a call to a callback function, or setting an event. The code here just gets the job done with the least fuss—but you do get to wait until it's complete. There is one other important point. As you'll see, when we open the conversion streams, we specify the ACM_STREAMOPENF_NONREALTIME flag. This is very important. If you omit this flag then some drivers (for example the TrueSpeech driver) will report error 512 (not possible). This error is telling you that the conversion you asked for cannot be done in real time. This isn't an issue in my sample, but it would be if you were trying to convert a lot of data at the same time you were playing it. </p>
<p>
So, let's look now at the first conversion step, which converts the source format to the intermediate format:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;/////////////////////////////////////////////////////////////////////////////
 &nbsp;&nbsp; // Convert the source wave to the PCM format supported by the CODEC.
 &nbsp;&nbsp; // We use any driver that can do the PCM to PCM conversion.
 &nbsp;&nbsp; HACMSTREAM hstr = NULL;
 &nbsp;&nbsp; mmr = acmStreamOpen(&amp;hstr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, // Any driver
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;wfSrc, // Source format
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwfPCM, // Destination format
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, // No filter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, // No callback
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, // Instance data (not used)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACM_STREAMOPENF_NONREALTIME); // flags
 &nbsp;&nbsp; if (mmr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Failed to open a stream to do PCM to PCM conversion\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Allocate a buffer for the result of the conversion.
 &nbsp;&nbsp; DWORD dwSrcBytes = dwSrcSamples * wfSrc.wBitsPerSample / 8;
 &nbsp;&nbsp; DWORD dwDst1Samples = dwSrcSamples * pwfPCM-&gt;nSamplesPerSec / wfSrc.nSamplesPerSec;
 &nbsp;&nbsp; DWORD dwDst1Bytes = dwDst1Samples * pwfPCM-&gt;wBitsPerSample / 8;
 &nbsp;&nbsp; BYTE* pDst1Data = new BYTE [dwDst1Bytes];

 &nbsp;&nbsp; // Fill in the conversion info.
 &nbsp;&nbsp; ACMSTREAMHEADER strhdr;
 &nbsp;&nbsp; memset(&amp;strhdr, 0, sizeof(strhdr));
 &nbsp;&nbsp; strhdr.cbStruct = sizeof(strhdr);
 &nbsp;&nbsp; strhdr.pbSrc = pSrcData; // The source data to convert
 &nbsp;&nbsp; strhdr.cbSrcLength = dwSrcBytes;
 &nbsp;&nbsp; strhdr.pbDst = pDst1Data;
 &nbsp;&nbsp; strhdr.cbDstLength = dwDst1Bytes;

 &nbsp;&nbsp; // Prep the header.
 &nbsp;&nbsp; mmr = acmStreamPrepareHeader(hstr, &amp;strhdr, 0); 

 &nbsp;&nbsp; // Convert the data.
 &nbsp;&nbsp; printf("Converting to intermediate PCM format...\n");
 &nbsp;&nbsp; mmr = acmStreamConvert(hstr, &amp;strhdr, 0);
 &nbsp;&nbsp; if (mmr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Failed to do PCM to PCM conversion\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; printf("Converted OK\n");

 &nbsp;&nbsp; // Close the stream.
 &nbsp;&nbsp; acmStreamClose(hstr, 0);
</code></pre>
<p>
When the stream is opened, the second parameter is set to NULL, indicating that we will accept any driver to perform this conversion. The only complexity is computing how much buffer space we'll need for the output data. Because a PCM to PCM conversion involves no compression or decompression, the computation is straight forward.</p>
<p>
You might note the call to <b>acmStreamPrepareHeader</b>, which actually is a convenience for the driver and allows it to lock the memory before conversion begins.</p>
<p>
The final step is to convert the intermediate format to the final compressed format:</p>
<pre><code>///////////////////////////////////////////////////////////////////////////////////
 &nbsp;&nbsp; // Convert the intermediate PCM format to the final format.

 &nbsp;&nbsp; // Open the driver.
 &nbsp;&nbsp; HACMDRIVER had = NULL;
 &nbsp;&nbsp; mmr = acmDriverOpen(&amp;had, hadid, 0);
 &nbsp;&nbsp; if (mmr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Failed to open driver\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Open the conversion stream.
 &nbsp;&nbsp; // Note the use of the ACM_STREAMOPENF_NONREALTIME flag. Without this
 &nbsp;&nbsp; // some software compressors will report error 512 - not possible.
 &nbsp;&nbsp; mmr = acmStreamOpen(&amp;hstr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; had, // Driver handle
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwfPCM, // Source format
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwfDrv, // Destination format
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, // No filter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, // No callback
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, // Instance data (not used)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACM_STREAMOPENF_NONREALTIME); // Flags
 &nbsp;&nbsp; if (mmr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Failed to open a stream to do PCM to driver format conversion\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Allocate a buffer for the result of the conversion.
 &nbsp;&nbsp; // Compute the output buffer size based on the average byte rate
 &nbsp;&nbsp; // and add a bit for randomness.
 &nbsp;&nbsp; // The IMA_ADPCM driver fails the conversion without this extra space.
 &nbsp;&nbsp; DWORD dwDst2Bytes = pwfDrv-&gt;nAvgBytesPerSec * dwDst1Samples /
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwfPCM-&gt;nSamplesPerSec;
 &nbsp;&nbsp; dwDst2Bytes = dwDst2Bytes * 3 / 2; // add a little room
 &nbsp;&nbsp; BYTE* pDst2Data = new BYTE [dwDst2Bytes];

 &nbsp;&nbsp; // Fill in the conversion info.
 &nbsp;&nbsp; ACMSTREAMHEADER strhdr2;
 &nbsp;&nbsp; memset(&amp;strhdr2, 0, sizeof(strhdr2));
 &nbsp;&nbsp; strhdr2.cbStruct = sizeof(strhdr2);
 &nbsp;&nbsp; strhdr2.pbSrc = pDst1Data; // the source data to convert
 &nbsp;&nbsp; strhdr2.cbSrcLength = dwDst1Bytes;
 &nbsp;&nbsp; strhdr2.pbDst = pDst2Data;
 &nbsp;&nbsp; strhdr2.cbDstLength = dwDst2Bytes;

 &nbsp;&nbsp; // Prep the header.
 &nbsp;&nbsp; mmr = acmStreamPrepareHeader(hstr, &amp;strhdr2, 0); 

 &nbsp;&nbsp; // Convert the data.
 &nbsp;&nbsp; printf("Converting to final format...\n");
 &nbsp;&nbsp; mmr = acmStreamConvert(hstr, &amp;strhdr2, 0);
 &nbsp;&nbsp; if (mmr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Failed to do PCM to driver format conversion\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; printf("Converted OK\n");

 &nbsp;&nbsp; // Close the stream and driver.
 &nbsp;&nbsp; mmr = acmStreamClose(hstr, 0);
 &nbsp;&nbsp; mmr = acmDriverClose(had, 0);
</code></pre>
<p>
This is very similar to the PCM to PCM conversion, but in this case we supply the handle to the driver we want to use when we open the stream. Actually, we could supply NULL here too because we already ascertained that the driver exists, but supplying the handle helps the system avoid wasting time finding the driver for us.</p>
<p>
Computing the buffer size for the compressed data is a little tricky and requires some slight guesswork. The <b>nAvgBytesPerSec </b>field of the <b>WAVEFORMATEX </b>structure indicates the average rate at which bytes are read during playback. We can use this to estimate how much data we need in order to store the compressed wave. Some drivers give data that is truly average and not the worst case, so I chose to add 50 percent more to the buffer. This works well in practice even if it is a little wasteful. Once the conversion is complete, the <b>cbDstLengthUsed</b> field of the <b>ACMSTREAMHEADER</b> structure contains the actual number of bytes used in the buffer. I used this to compute the compression ratio:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;// Show the conversion stats.
 &nbsp;&nbsp; printf("Source wave had %lu bytes\n", dwSrcBytes);
 &nbsp;&nbsp; printf("Converted wave has %lu bytes\n", strhdr2.cbDstLengthUsed);
 &nbsp;&nbsp; printf("Compression ratio is %f\n", (double) dwSrcBytes /
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (double) strhdr2.cbDstLengthUsed);
</code></pre>
<h2>Summary</h2>
<p>
Compressing waveform data using the CODECs that ship with the Windows operating systems is easy to do and results in data that occupies less disk space and takes less time to transmit. If you have a proprietary compression format, you can create your own CODEC to install and use it in the same way I've shown here.</p>
<p>
As usual, I'm happy to answer questions regarding this article. I can be contacted by email: nigel-t@msn.com.</p>
</BODY>
</HTML>
