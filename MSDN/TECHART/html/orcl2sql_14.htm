<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ODBC</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>ODBC</h1>
<p>
This section details how Oracle and SQL Server use ODBC and provides information about developing applications with ODBC.</p>
<h3>Recommended Conversion Strategy</h3>
<p>
Use the following process when you convert your application code from Oracle to SQL Server:
<ol>
<li>
Consider converting your application to ODBC if it is written using Oracle Pro*C or the Oracle Call Interface.<br><br></li>
<li>
Understand SQL Server default result sets and cursor options, and choose the fetching strategy that is most efficient for your application.<br><br></li>
<li>
Remap Oracle ODBC SQL data types to SQL Server ODBC SQL data types where appropriate.<br><br></li>
<li>
Use the ODBC Extended SQL extensions to create generic SQL statements.<br><br></li>
<li>
Determine if manual commit mode is required for the SQL Server application.<br><br></li>
<li>
Test the performance of your application(s) and modify the program(s) as necessary.</li>
</ol>
<h3>Application Development Using ODBC</h3>
<p>
The Microsoft Open Database Connectivity (ODBC) interface enables you to create applications that are interoperable with multiple database systems. The ODBC SQL Server driver enables you to create ODBC client/server applications that take maximum advantage of Microsoft SQL Server and Oracle.</p>
<p>
Microsoft offers a variety of support options to help you get the most from Microsoft SQL Server and ODBC. For information about these options, see the service and support information in your Microsoft SQL Server package and the online support information in the Microsoft Developer's Network.</p>
<p>
In addition, you can get technical support information from the Microsoft Knowledge Base (KB). Information about the Knowledge Base (including how to get KB articles, how to get the KB on CD, and how to contribute to the KB) is available in the Help file Kb_msl.hlp, located in the \Mssql\Install directory.</p>
<p>
There are many vendors for Oracle ODBC drivers. They include Oracle, Intersolv, Visigenic, Openlink, and others. Microsoft has licensed the source to the Oracle ODBC driver version 2.0 from Visigenic. A driver based on that source, called the Microsoft ODBC Driver for Oracle, is shipped with Microsoft Visual Studio™97. Oracle is no longer producing its own ODBC drivers and has licensed the rights to develop future ODBC drivers to Intersolv.</p>
<p>
These different vendors offer varying levels of ODBC support. You must contact them directly to ensure that they support the ODBC conformance levels that your application requires. ODBC defines one set of conformance levels for the API and another set for the SQL grammar. </p>
<p>
<img src="orcl2sql_23.gif" border=0></p>
<p>
In order for an ODBC driver to claim conformance, it must provide support for all specified functionality at a given level. This must be done even if the DBMS does not support all of the capabilities for the specified level.</p>
<p>
For more information about ODBC and its conformance levels, see the <i>Microsoft ODBC 3.0 Programmer's Reference and SDK Guide</i>. </p>
<h3>ODBC Architecture</h3>
<p>
Microsoft provides both 16-bit and 32-bit versions of its the ODBC SQL Server driver. The 32-bit ODBC SQL Server driver is thread safe. The driver serializes shared access by multiple threads to shared statement handles (hstmt), connection handles (hdbc), and environment handles (henv). However, the ODBC program is still responsible for keeping operations within statement and connection spaces in the proper sequence, even when the program uses multiple threads.</p>
<p>
Because the ODBC driver for Oracle may be supplied by one of many possible vendors, there are many possible scenarios regarding architecture and operation. Again, you must contact the vendor to ensure that the ODBC driver meets your application requirements.</p>
<p>
In most cases, the ODBC driver for Oracle uses SQL*Net to connect to the Oracle DBMS. SQL*Net may not be used, however, when connecting to Personal Oracle.</p>
<p>
The illustration shows the application/driver architecture for 32-bit environments. </p>
<p>
<img src="orcl2sql_24.gif" border=0></p>
<p>
The term <i>thunking</i> means intercepting a function call, doing some special processing to translate between 16-bit and 32-bit code, and then transferring control to a target function. Note how the ODBC Cursor Library optionally resides between the driver manager and its driver. This library provides scrollable cursor services on top of drivers that just support forward-only cursors.</p>
<h3>Forward-only Cursors</h3>
<p>
Oracle and SQL Server treat result sets and cursors differently. Understanding these differences is essential for successfully moving a client application from Oracle to SQL Server and having it perform optimally.</p>
<p>
In Oracle, any result set from a SELECT statement is treated as a forward-only cursor when fetched in the client application. This holds true whether you are using ODBC, OCI, or Embedded SQL as your development tool.</p>
<p>
By default, each Oracle FETCH command issued by the client program (for example, <b>SQLFetch</b> in ODBC) causes a round-trip across the network to the server to return one row. If a client application wishes to fetch more than one row at a time across the network, it must set up an array in its program and perform an array fetch.</p>
<p>
Between fetches, no locks are held at the server for a read-only cursor, because of Oracle's multiversioning concurrency model. When the program specifies an updatable cursor with the FOR UPDATE clause, all of the requested rows in the SELECT statement are locked when the statement is opened. These row-level locks remain in place until the program issues a COMMIT or ROLLBACK request.</p>
<p>
In SQL Server, a SELECT statement is not always associated with a cursor at the server. By default, SQL Server simply streams all the result set rows from a SELECT statement back to the client. This streaming starts as soon as the SELECT is executed. Result set streams can also be returned by SELECT statements within stored procedures. Additionally, a single stored procedure or batch of commands can stream back multiple result sets in response to a single EXECUTE statement.</p>
<p>
The SQL Server client is responsible for fetching these default result sets as soon as they are available. For default result sets, fetches at the client do not result in round-trips to the server. Instead, fetches from a default result set just pull data from local network buffers into program variables. This default result set model creates an efficient mechanism to return multiple rows of data to the client in a single round-trip across this network. Minimizing network round-trips is usually the most important factor in client/server application performance.</p>
<p>
Compared to Oracle's cursors, default result sets put some additional responsibilities on the SQL Server client application. The SQL Server client application must immediately fetch all the result set rows returned by an EXECUTE statement. If the application needs to present rows incrementally to other parts of the program, it must buffer the rows to an internal array. If it fails to fetch all result set rows, the connection to SQL Server remains busy.</p>
<p>
If this occurs, no other work (such as UPDATE statements) can be executed on that connection until the entire result set rows are fetched, or the client cancels the request. Moreover, the server continues to hold share locks on table data pages until the fetch has completed. The fact that these share locks are held until a fetch is complete make it mandatory that you fetch all rows as quickly as possible. This technique is in direct contrast to the incremental style of fetch that is commonly found in Oracle applications.</p>
<h3>Server Cursors</h3>
<p>
SQL Server offers <i>server cursors</i> to address the need for incremental fetching of result sets across the network. Server cursors can be requested in an application by simply calling <b>SQLSetStmtOption</b> to set the SQL_CURSOR_TYPE option.</p>
<p>
When a SELECT statement is executed as a server cursor, only a cursor identifier is returned by the EXECUTE statement. Subsequent fetch requests pass the cursor identifier back to the server along with a parameter specifying the number of rows to fetch at once. The server returns the number of rows requested.</p>
<p>
Between fetch requests, the connection remains free to issue other commands, including other cursor OPEN or FETCH requests. In ODBC terms, this means that server cursors allow the SQL Server driver to support multiple active statements on a single connection.</p>
<p>
Furthermore, server cursors don't usually hold locks between fetch requests, so you are free to pause for user input between fetches without impacting other users. Server cursors can be updated in place using either optimistic conflict detection or pessimistic scroll locking concurrency options.</p>
<p>
While these features make programming with server cursors more familiar to Oracle developers, they don't come for free. Compared to default result sets:
<ul type=disc>
<li>
Server cursors are more expensive in terms of server resources, because temporary storage space is used to maintain cursor state information at the server.<br><br></li>
<li>
Server cursors are more expensive to retrieve a given result set of data with, because the execute and each fetch request in a server cursor is a separate round-trip to the server.<br><br></li>
<li>
Server cursors are less flexible in terms of the kind of batches and stored procedures they support. This is because a server cursor can only execute a single SELECT statement at a time, whereas default result sets can be used for batches and stored procedures that return multiple result sets or include non-SELECT statements.</li>
</ul>
<p>
For these reasons, it is wise to limit using server cursors to those parts of your application that need their features. An example illustrating the use of server cursors can be found in the LIST_STUDENTS function in the Ssdemo.cpp sample SQL Server ODBC program file. </p>
<h3>Scrollable Cursors</h3>
<p>
The Oracle DBMS supports only forward-scrolling cursors. Each row is fetched to the application in the order it was specified in the query. Oracle does not accept requests to move backwards to a previously fetched row. The only way to move backwards is to close the cursor and reopen it. Unfortunately, you are repositioned back to the first row in the active query set.</p>
<p>
Because SQL Server supports scrollable cursors, you can position a SQL Server cursor to any row location that you want. You can scroll both forward and backwards. For many applications involving a user interface, scrollability is a very useful feature. With scrollable cursors, your application can fetch a screen full of rows at a time, and only fetch additional rows as the user asks for them.</p>
<p>
<img src="orcl2sql_25.gif" border=0></p>
<p>
Although Oracle doesn't directly support scrollable cursors, this limitation can be minimized using one of several ODBC options. For example, some Oracle ODBC drivers, such as the one that ships with the Microsoft Developer Studio™, offer client-based scrollable cursors in the driver itself.</p>
<p>
Alternatively, the ODBC Cursor Library supports block scrollable cursors for any ODBC driver that complies with the Level One conformance level. Both of these client cursor options support scrolling by using the DBMS for forward-only fetching, and caching result set data in memory or on disk. When data is requested, the driver retrieves it from the DBMS or its local cache as needed.</p>
<p>
Client-based cursors also support positioned UPDATE and DELETE statements for the result sets generated by SELECT statements. The cursor library constructs an UPDATE or DELETE statement with a WHERE clause that specifies the cached value for each column in a row. </p>
<p>
If you need scrollable cursors and are trying to maintain the same source code for both Oracle and SQL Server implementations, the ODBC Cursor Library is a useful option. To obtain more information about the OCBC Cursor Library, see the <i>Microsoft ODBC 3.0 Programmer's Reference and SDK Guide</i>.</p>
<h3>Strategies for Using SQL Server Default Result Sets <br>
and Server Cursors</h3>
<p>
With all of the options that SQL Server offers for fetching data, it's sometimes difficult to decide what to use and when. Here are some useful guidelines:
<ul type=disc>
<li>
Default result sets are always the fastest way to get an entire set of data from SQL Server down to the client. Look for opportunities in your application where you can use this to your advantage. Batch report generation, for example, generally processes an entire result set to completion, with no user interaction and no updates in the middle of processing.<br><br></li>
<li>
If your program requires updatable cursors, use server cursors.&nbsp; Default result sets are never updatable using positioned UPDATE or DELETE statements. Additionally, server cursors are better at updating than client-based cursors that have to simulate a positioned UPDATE or DELETE by constructing an equivalent searched UPDATE or DELETE statement.<br><br></li>
<li>
If your program needs scrollable, read-only cursors, both the ODBC Cursor Library or server cursors offer a good choice. The ODBC Cursor Library gives you compatible behavior across SQL Server and Oracle, while server cursors give more flexibility as to how much data to fetch across the network at once.<br><br></li>
<li>
When using default result sets, or ODBC Cursor Library cursors built on top of default result sets, be sure to fetch to the end of a result set as quickly as possible, to avoid holding share locks at the server.<br><br></li>
<li>
When using server cursors, be sure to use <b>SQLExtendedFetch</b> to fetch in blocks of rows rather than a single row at a time. This is the same as array-type fetching in Oracle applications. Every fetch request on a server cursor requires a round-trip from the application to the DBMS on the network.<p class=tl>
Grocery shopping provides a good analogy: Assume you purchase ten bags of groceries at the grocery store, load one bag into your car, drive home, drop it off, and return to the grocery store for the next bag. This is an unlikely scenario, but this is what you do to SQL Server and your program by making single-row fetches from a server cursor.</P></li>
<li>
If your program requires only forward-only, read-only cursors but depends on having multiple cursors open on the same connection, use default result sets when you know you can fetch the entire result set immediately into program variables. Use server cursors when you don't know if you cannot fetch all of the rows immediately.</li>
</ul>
<p>
This strategy is not as difficult as it sounds. Most programmers know, for example, when they are issuing a singleton select that can return at most one row. For singleton fetches, using a default result set is more efficient than using a server cursor.</p>
<p>
For an example of this technique, see the LIST_STUDENTS function in the Ssdemo.cpp sample SQL Server ODBC program file. Note how a server cursor is requested only if the SELECT statement may return more than one row. Following the execute step, the rowset size is set to a reasonable batch size. This allows the same <b>SQLExtendedFetch</b> loop to work efficiently in either the default result set or the server cursor case.</p>
<h3>Multiple Active Statements (hstmt's) per Connection</h3>
<p>
The ODBC driver uses a statement handle (hstmt) to track each active SQL statement within the program. The statement handle is always associated with a DBMS connection handle (hdbc). The ODBC driver manager uses the connection handle to send the requested SQL statement to the specified DBMS. Most ODBC drivers for Oracle allow multiple statement handles per connection. However, the SQL Server ODBC driver allows only one active statement handle per connection when using default result sets. The <b>SQLGetInfo</b> function of this SQL Server driver returns the value 1 when queried with the SQL_ACTIVE_STATEMENTS option. When statement options are set in a way that server cursors are used, multiple active statements per connection handle are supported.</p>
<p>
For more information about how to set statement options to request server cursors, see<i> Programming ODBC for Microsoft SQL Server</i>. </p>
<h3>Data Type Mappings</h3>
<p>
The SQL Server ODBC driver offers a richer set of data type mappings than any available Oracle ODBC driver. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>SQL Server data type</b></td>
<td class=label width=51%><b>ODBC SQL data type</b></td>
</tr>
<tr valign=top>
<td width=49%><b>binary</b></td>
<td width=51%>SQL_BINARY</td>
</tr>
<tr valign=top>
<td width=49%><b>bit</b></td>
<td width=51%>SQL_BIT</td>
</tr>
<tr valign=top>
<td width=49%><b>char, character</b></td>
<td width=51%>SQL_CHAR</td>
</tr>
<tr valign=top>
<td width=49%><b>datetime</b></td>
<td width=51%>SQL_TIMESTAMP</td>
</tr>
<tr valign=top>
<td width=49%><b>decimal, dec</b></td>
<td width=51%>SQL_DECIMAL</td>
</tr>
<tr valign=top>
<td width=49%><b>float, double precision, float(n) </b>for n = 8-15</td>
<td width=51%>SQL_FLOAT</td>
</tr>
<tr valign=top>
<td width=49%><b>image</b></td>
<td width=51%>SQL_LONGVARBINARY</td>
</tr>
<tr valign=top>
<td width=49%><b>int, integer</b></td>
<td width=51%>SQL_INTEGER</td>
</tr>
<tr valign=top>
<td width=49%><b>money</b></td>
<td width=51%>SQL_DECIMAL</td>
</tr>
<tr valign=top>
<td width=49%><b>numeric</b></td>
<td width=51%>SQL_NUMERIC</td>
</tr>
<tr valign=top>
<td width=49%><b>real, float(n) </b>for n = 1-7</td>
<td width=51%>SQL_REAL</td>
</tr>
<tr valign=top>
<td width=49%><b>smalldatetime</b></td>
<td width=51%>SQL_TIMESTAMP</td>
</tr>
<tr valign=top>
<td width=49%><b>smallint</b></td>
<td width=51%>SQL_SMALLINT</td>
</tr>
<tr valign=top>
<td width=49%><b>smallmoney</b></td>
<td width=51%>SQL_DECIMAL</td>
</tr>
<tr valign=top>
<td width=49%><b>sysname</b></td>
<td width=51%>SQL_VARCHAR</td>
</tr>
<tr valign=top>
<td width=49%><b>text</b></td>
<td width=51%>SQL_LONGVARCHAR</td>
</tr>
<tr valign=top>
<td width=49%><b>timestamp</b></td>
<td width=51%>SQL_BINARY</td>
</tr>
<tr valign=top>
<td width=49%><b>tinyint</b></td>
<td width=51%>SQL_TINYINT</td>
</tr>
<tr valign=top>
<td width=49%><b>varbinary</b></td>
<td width=51%>SQL_VARBINARY</td>
</tr>
<tr valign=top>
<td width=49%><b>varchar</b></td>
<td width=51%>SQL_VARCHAR</td>
</tr>
</table><br>
<p>
It is important to note that the <b>timestamp</b> data type is converted to the SQL_BINARY data type. This is because the values in <b>timestamp</b> columns are not <b>datetime</b> data, but rather <b>binary(8)</b> data. They are used to indicate the sequence of SQL&nbsp;Server activity on the row.</p>
<p>
The Oracle data type mappings for the Microsoft ODBC driver for Oracle are shown in the following table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle data type</b></td>
<td class=label width=51%><b>ODBC SQL data type</b></td>
</tr>
<tr valign=top>
<td width=49%>CHAR</td>
<td width=51%>SQL_CHAR</td>
</tr>
<tr valign=top>
<td width=49%>DATE</td>
<td width=51%>SQL_TIMESTAMP</td>
</tr>
<tr valign=top>
<td width=49%>LONG</td>
<td width=51%>SQL_LONGVARCHAR</td>
</tr>
<tr valign=top>
<td width=49%>LONG RAW</td>
<td width=51%>SQL_LONGVARBINARY</td>
</tr>
<tr valign=top>
<td width=49%>NUMBER</td>
<td width=51%>SQL_FLOAT</td>
</tr>
<tr valign=top>
<td width=49%>NUMBER(P)</td>
<td width=51%>SQL_DECIMAL</td>
</tr>
<tr valign=top>
<td width=49%>NUMBER(P,S)</td>
<td width=51%>SQL_DECIMAL</td>
</tr>
<tr valign=top>
<td width=49%>RAW</td>
<td width=51%>SQL_BINARY</td>
</tr>
<tr valign=top>
<td width=49%>VARCHAR2</td>
<td width=51%>SQL_VARCHAR</td>
</tr>
</table><br>
<p>
Note that Oracle ODBC drivers from other vendors may have alternative data type mappings.</p>
<h3>ODBC Extended SQL</h3>
<p>
The ODBC extended SQL standard provides SQL extensions to ODBC that support the advanced nonstandard SQL feature set offered in both Oracle and SQL Server. This standard allows the ODBC driver to convert generic SQL statements to Oracle- and SQL Server-native SQL syntax. </p>
<p>
This standard addresses outer joins, such as predicate escape characters, scalar functions, date/time/timestamp values, and stored programs. The following syntax is used to identify these extensions:</p>
<pre><code>--(*vendor(Microsoft), product(ODBC) extension *)--

OR

{extension}
</code></pre>
<p>
The conversion takes place at run time and does not require the revision of any program code. In most application development scenarios, the best approach to take is to write one program and allow ODBC to perform the DBMS conversion process when the program is run.</p>
<h3>Outer Joins</h3>
<p>
The Oracle outer join syntax is not compatible with the SQL Server outer join syntax. If you use Oracle syntax when writing an outer join statement, you must revise it for SQL Server. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Oracle</b></td>
<td class=label width=52%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=48%>SELECT STUDENT.SSN, FNAME, LNAME,<br>
CCODE, GRADE<br>
FROM STUDENT, GRADE<br>
WHERE STUDENT.SSN = GRADE.SSN(+)</td>
<td width=52%>SELECT STUDENT.SSN, FNAME, LNAME,<br>
&nbsp;&nbsp;&nbsp;&nbsp;CCODE, GRADE<br>
FROM STUDENT LEFT OUTER JOIN GRADE<br>
&nbsp;&nbsp;&nbsp;&nbsp;ON STUDENT.SSN = GRADE.SSN</td>
</tr>
</table><br>
<p>
This revision could have been avoided by using the ODBC extended SQL outer join syntax. This example works with Oracle and SQL Server:</p>
<pre><code>SELECT STUDENT.SSN, FNAME, LNAME, CCODE, GRADE
FROM {oj STUDENT LEFT OUTER JOIN GRADE ON STUDENT.SSN = GRADE.SSN}
</code></pre>
<h3>Scalar Functions</h3>
<p>
ODBC provides five types of scalar functions:
<ul type=disc>
<li>
Data type conversion <br><br></li>
<li>
Numeric <br><br></li>
<li>
String <br><br></li>
<li>
System <br><br></li>
<li>
Time and date </li>
</ul>
<p>
Scalar functions can be used on columns of a result set and on columns that restrict rows of a result set. A good example of a scalar function is the SUBSTRING function, which returns a subset of a character string. The following ODBC scalar SUBSTRING function works with Oracle and SQL Server:</p>
<pre><code>SELECT {fn SUBSTRING(LNAME,1,5)}
FROM STUDENT
</code></pre>
<p>
If this scalar function is not used, you must write the following DBMS-specific program code for Oracle and SQL Server:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Oracle</b></td>
<td class=label width=52%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=48%>SELECT <b>SUBSTR</b>(LNAME,1,5)<br>
FROM STUDENT</td>
<td width=52%>SELECT <b>SUBSTRING</b>(LNAME,1,5)<br>
FROM STUDENT</td>
</tr>
</table><br>
<h3>Date, Time, and Timestamp Values</h3>
<p>
ODBC provides three escape clauses for date, time, and timestamp values:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=17%><b>Category</b></td>
<td class=label width=37%><b>Shorthand syntax</b></td>
<td class=label width=46%><b>Format</b></td>
</tr>
<tr valign=top>
<td width=17%>Date</td>
<td width=37%>{d 'value'}</td>
<td width=46%>"yyyy-mm-dd"</td>
</tr>
<tr valign=top>
<td width=17%>Time</td>
<td width=37%>{t 'value'}</td>
<td width=46%>"hh:mm:ss"</td>
</tr>
<tr valign=top>
<td width=17%>Timestamp</td>
<td width=37%>{Ts 'value'}</td>
<td width=46%>"yyyy-mm-dd hh:mm:ss[.f…]"</td>
</tr>
</table><br>
<p>
This ODBC shorthand syntax can be generically applied to both Oracle and SQL Server:</p>
<pre><code>SELECT SSN, FNAME, LNAME, BIRTH_DATE
FROM STUDENT WHERE BIRTH_DATE &lt; {D '1970-07-04'}
</code></pre>
<p>
It is worth noting that the format of dates has more of an impact on Oracle than it does on SQL Server. Oracle expects the date format 'DD-MON-YY'. If any other format is used, the TO_CHAR or TO_DATE functions must be used with a date format model to perform a format conversion.</p>
<p>
SQL Server automatically converts most common date formats. The CONVERT function can be used for those situations where an automatic conversion cannot be performed.</p>
<p>
This DBMS-specific syntax is required to use the date format shown in the previous example. Notice how a conversion function is not required with SQL Server.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Oracle</b></td>
<td class=label width=50%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=50%>SELECT SSN, FNAME, LNAME, <br>
&nbsp;&nbsp;&nbsp;&nbsp;BIRTH_DATE<br>
FROM STUDENT<br>
WHERE BIRTH_DATE &lt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>TO_DATE(</b>'1970-07-04',<b> 'YYYY-MM-DD')</b></td>
<td width=50%>SELECT SSN, FNAME, LNAME, <br>
&nbsp;&nbsp;&nbsp;&nbsp;BIRTH_DATE<br>
FROM STUDENT<br>
WHERE BIRTH_DATE &lt; '1970-07-04'</td>
</tr>
</table><br>
<h3>Calling Stored Procedures</h3>
<p>
The following ODBC shorthand syntax is used for calling stored programs. It supports SQL Server procedures, and Oracle procedures, functions, and packages.</p>
<pre><code>{?=} call procedure_name[(parameter(s))]}
</code></pre>
<p>
The optional "?=" syntax is used to capture the return value for an Oracle function or a SQL Server procedure. The parameter syntax is used to pass and return values to and from the called program. In most situations, the same syntax can be generically applied to Oracle and SQL Server applications. This program code works with either DBMS:</p>
<pre><code>SQLExecDirect(hstmt1,(SQLCHAR *)"{? = call DEPT_ADMIN.DELETE_DEPT(?)}",SQL_NTS);
</code></pre>
<p>
Oracle packages introduce an exception to this rule. When calling a function or procedure that exists in a package, the package name must be placed in front of the program name.</p>
<p>
In the following example, the SHOW_RELUCTANT_STUDENTS function is part of the Oracle package P1. This function must exist in a package because it returns multiple rows from a PL/SQL cursor. This code sample is extracted from the RELUCTANT_STUDENTS functions in the Oracle and SQL Server sample ODBC programs.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=51%><b>Oracle</b></td>
<td class=label width=49%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=51%>SQLExecDirect(hstmt1, (SQLCHAR*)"{<b>? = call</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>STUDENT_ADMIN.P1.SHOW_RELUCTANT<br>
&nbsp;&nbsp;&nbsp;&nbsp;_STUDENTS(?)}"</b>,SQL_NTS);</td>
<td width=49%>SQLExecDirect(hstmt1, (SQLCHAR*)<b>"{? = call</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>STUDENT_ADMIN.SHOW_RELUCTANT<br>
&nbsp;&nbsp;&nbsp;&nbsp;_STUDENTS}"</b>,SQL_NTS);</td>
</tr>
</table><br>
<p>
The SHOW_RELUCTANT_STUDENTS function in the package P1 uses a package cursor to retrieve multiple rows of data. Each row must be requested with a call to this function. If there are no more rows to retrieve, the function returns the value of 0, indicating that there are no more rows to retrieve.</p>
<p>
Although this sample Oracle package and its function are capable of returning multiple rows of data, the resulting performance may be less than satisfactory. SQL Server procedures are much more efficient with this type of operation.</p>
<h3>Native SQL Translation</h3>
<p>
Because of the variety of ODBC drivers for both Oracle and SQL Server, you may not always get the same conversion string for the extended SQL functions. To assist with application debugging issues, you may want to consider using the <b>SQLNativeSql</b> function. This function returns the SQL string as translated by the driver.</p>
<p>
The following are examples of what this function may return for the following input SQL string containing the scalar function CONVERT. The column SSN is defined as the type CHAR(9), and it is converted to a numeric value:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=28%><b><br>
Original statement</b></td>
<td class=label width=35%><b><br>
Converted Oracle statement</b></td>
<td class=label width=37%><b>Converted SQL Server statement</b></td>
</tr>
<tr valign=top>
<td width=28%>SELECT <b>(fn CONVERT <br>
(SSN, SQL_INTEGER)}</b> <br>
FROM STUDENT</td>
<td width=35%>SELECT <b>TO_NUMBER(SSN)</b><br>
FROM STUDENT</td>
<td width=37%>SELECT <b>CONVERT(INT,SSN)</b> <br>
FROM STUDENT</td>
</tr>
</table><br>
<h3>The Common.cpp Sample Program</h3>
<p>
The Common.cpp sample program does not take advantage of the ODBC Extended SQL syntax. Rather, it employs a series of views and procedures to hide statements and functions that are not common between Oracle and SQL Server. This program, although written using ODBC, is intended to show how an application programmer can easily overcome any apparent hurdles when trying to write one common program.</p>
<p>
These techniques and strategies are best employed in a non-ODBC development environment. If you are using ODBC, it is recommended that you seriously consider using the ODBC Extended SQL syntax to overcome any syntactical differences between Oracle and SQL Server.</p>
<h3>Manual Commit Mode</h3>
<p>
Oracle automatically enters the transaction mode whenever a user modifies data. This must be followed by an explicit COMMIT to write the changes to the database. If a user wants to undo the changes, the user can issue the ROLLBACK statement.</p>
<p>
By default, SQL Server automatically commits each change as it occurs. This is called autocommit mode in ODBC. If you do not want this to occur, you can use the BEGIN TRANSACTION statement to signal the start of a block of statements comprising a transaction. After this statement is issued, it is followed by an explicit COMMIT TRANSACTION or ROLLBACK TRANSACTION statement.</p>
<p>
To ensure compatibility with your Oracle application, it is recommended that you use the <b>SQLConnectOption</b> function to place your SQL Server application in implicit transaction mode. The SQL_AUTOCOMMIT option must be set to SQL_AUTOCOMMIT_OFF in order to accomplish this. This code excerpt from the sample programs demonstrates this concept:</p>
<pre><code>SQLSetConnectOption(hdbc1, SQL_AUTOCOMMIT,-sql_AUTOCOMMIT_OFF);
</code></pre>
<p>
The SQL_AUTOCOMMIT_OFF option tells the driver to use implicit transactions. The default option SQL_AUTOCOMMIT_ON instructs the driver to use autocommit mode, in which each statement is committed immediately after it is executed. Changing from manual-commit mode to autocommit mode commits any open transactions on the connection.</p>
<p>
If the SQL_AUTOCOMMIT_OFF option is set, the application must explicitly commit or roll back transactions with the <b>SQLTransact</b> function. This function requests a commit or rollback operation for all active operations on all statement handles associated with a connection handle. It can also request that a commit or rollback operation be performed for all connections associated with the environment handle.</p>
<pre><code>SQLTransact(henv1, hdbc1, SQL_ROLLBACK);
(SQLTransact(henv1, hdbc1, SQL_COMMIT);
</code></pre>
<p>
When autocommit mode is turned off, the driver issues SET IMPLICIT_TRANSACTIONS ON command to the server. Starting with SQL Server 6.5, DDL commands are supported in this mode.</p>
<p>
To commit or roll back a transaction in manual-commit mode, the application must call <b>SQLTransact</b>. The SQL Server driver sends a COMMIT TRANSACTION statement to commit a transaction, and a ROLLBACK TRANSACTION statement to roll back a transaction.</p>
<h3>Manual Commit Mode and Performance</h3>
<p>
The use of the manual commit mode may adversely affect the performance of your SQL Server application. Every COMMIT request requires a separate round-trip to the server to send the COMMIT TRANSACTION string.</p>
<p>
If you have single atomic transactions (a single INSERT, UPDATE, or DELETE immediately followed by a COMMIT), you should use the autocommit mode, which is the SQL Server default. The only reason not to do this is to ensure absolute compatibility with Oracle and the way it handles transactions.</p>
<p>
In the sample programs, the manual commit mode has been turned on, even for atomic transactions. The reason for this is was to demonstrate how easily a SQL Server application can be developed that closely mimics the operation of a similar application designed for the Oracle DBMS.</p>
</BODY>
</HTML>
