<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Improving the Performance of Windows 95 Games</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_gameperf"></a></sup>Improving the Performance of Windows 95 Games</h1>
<p>
Peter Donnelly<br>
Microsoft Corporation</p>
<p>
<i>Peter Donnelly has been a game designer since 1972 and a programmer since 1984. He has authored four "paper" games with historical and fantasy themes, and his computer design credits include three interactive comic-book adventures and one full-scale adventure game. He has also developed shareware games and game editors for MS-DOS and Windows.</i></p>
<p>
December 6, 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5047">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the sample code associated with this technical article.</a></p>
<h2>Abstract</h2>
<p>
A key issue in the development of real-time games for the Windows® 95 environment is the prevention of stalls or stutters in the game loop as Windows performs some peripheral task. In "<a href="msdn_dos2win.htm">Moving Your Game to Windows, Part I"</a> I described some techniques for accurately pacing events and giving greater priority to time-critical threads. In this article I suggest solutions to other stalling problems caused by system events.</p>
<h3>Code Memory Paging</h3>
<p>
<b>Problem:</b> Game performance slows down when some functions are called.</p>
<p>
<b>Cause:</b> The application resides on CD-ROM, and access times are slow. Not all functions can fit into RAM, and those not recently used may have to be read from the CD when called.</p>
<p>
<b>Solution:</b> Load the entire application to virtual memory. That way, when functions are discarded from RAM they are put in the paging file (commonly called the swapfile), whence they are more quickly retrieved than from the CD. Raymond Chen's sample code in DMDFM.C will load all or part of any application into memory. The sample program, LOADAPPTEST.C, loads all of itself into memory when you press F2. (To view or copy the sample files, click the hotlink at the top of this article.)</p>
<h3>CD-ROM Caching</h3>
<p>
<b>Problem:</b> Applications may actually be slowed down by the CD-ROM cache.</p>
<p>
<b>Cause:</b> The read-ahead cache allocates memory for functions that may not necessarily be used. The result is that functions already in RAM may have to be paged out.</p>
<p>
<b>Solution:</b> Load the application to the swapfile as explained in the previous section.</p>
<p>
In general, you should not attempt to implement your own CD-ROM caching system. It is likely to interact with the system cache in ways that interfere with performance.</p>
<h3>Data Memory Paging</h3>
<p>
<b>Problem:</b> Performance slows down as data is accessed from the swapfile, even though the application has attempted to load all data into memory by walking through it and "touching" it.</p>
<p>
<b>Cause:</b> The explanation requires some understanding of how Windows decides when a block of memory should be discarded or paged out, i.e., moved from RAM to the swapfile.</p>
<p>
The Windows 95 memory manager includes a safeguard against processes that use a block of memory once and then forget about it. Consider, for example, a large bitmap used as desktop wallpaper. The user has been running a maximized application, so that the bitmap has long since been paged out. Then the user minimizes the application for a moment. Now the system needs to reload the wallpaper bitmap so it can paint it onto the screen. Without a safeguard, the bitmap would elbow aside a lot of other pages from RAM, even though they might contain code or data that will be needed again as soon as the application is restored. The bitmap is unlikely to be needed again for some time, but it is now hogging physical memory.</p>
<p>
The safety mechanism prevents this from happening in the following way. When the system loads in a page (a page being 4 kilobytes on <i>x</i>86 machines), it first leaves it in a state of limbo. While it is in this state, the page never acquires a "last accessed" timestamp, even if it is accessed again. It is promoted to full status only when 16 more pages (in Windows 95) have been loaded. But at this point it is marked as not having been recently used, so it is still a prime candidate for disposal the next time physical memory is needed. Only if the page is accessed after promotion to full memory status does Windows mark it as recently used, thus recognizing it as potentially useful and worth keeping in physical memory.</p>
<p>
In the case of the desktop wallpaper example, this means that the first page loaded is likely to be discarded after 16 more pages have been loaded. As each new page is loaded, another one is promoted from limbo and one is discarded. The result is that loading an image of any size requires the replacement of as little as 17 x 4 = 68K of physical memory. (Again, the numbers are valid for Windows 95.)</p>
<p>
Any attempt to force Windows to keep a large block of data in physical memory by simply walking through it page by page will fail, because the safety mechanism treats the data just like the bitmap in our example.</p>
<p>
<b>Solution:</b> In order to have Windows recognize a page of memory as being too important to discard, you must touch it again as soon as it has been promoted from limbo. (Touching it before it is promoted will not have the desired effect.) The following function will accomplish this:</p>
<pre><code>/*
  Assume that pb and cb are both rounded to page boundaries
  and that PageSize has been determined from GetSystemInformation().
*/
#define cbLag&nbsp; (16 * PageSize)

void MakeRegionPresent(volatile BYTE *pb, UINT cb)
  {
  UINT ib;

  Assert(((DWORD)pb &amp; (PageSize - 1)) == 0);
  Assert(((DWORD)cb &amp; (PageSize - 1)) == 0);

  for (ib = cbLag; ib &lt; cb; ib += PageSize)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pb[ib - cbLag];
 &nbsp;&nbsp; pb[ib];
 &nbsp;&nbsp; }
  }
</code></pre>
<h3>The Five-Minute Pause</h3>
<p>
<b>Problem:</b> With certain configurations, the system suspends all other business every five minutes while it polls the network.</p>
<p>
<b>Cause:</b> The problem occurs, in general, when DHCP (dynamic host configuration protocol; see the bibliography for further information) is installed on a network adapter (possibly the dial-up network adapter; i.e., modem), but the adapter is not on a network that has a DHCP server. This often happens when the user has accidentally enabled DHCP on the physical network adapter but meant to enable it on the dial-up adapter. It also happens when the user has enabled DHCP on the modem, but the Internet service provider doesn't use DHCP.</p>
<p>
<b>Solution:</b> Tell the user to change the network settings according to the following instructions:</p>
<p class=indent>
In Control Panel, double-click Network. From the component list on the Configuration page, click TCP/IP and then click the Properties button. On the IP Address tab, click Specify an IP Address and then enter the IP address and subnet mask for your computer<b>.</b> (You can obtain these numbers by running WINIPCFG.)</p>
<h3>Swapfile Cleanup</h3>
<p>
<b>Problem:</b> Windows decides it is time to clean up the swapfile and embarks on this task, bringing other applications to their knees.</p>
<p>
<b>Cause:</b> Windows decides to start housekeeping when it sees that all applications are idle, i.e., sitting on <b>GetMessage</b>. </p>
<p>
<b>Solution:</b> As long as your application appears to be busy, Windows will postpone its housekeeping tasks. Don't use any blocking <b>GetMessage</b> calls—use <b>PeekMessage</b> instead, to keep the message pump going.</p>
<p>
The following code fragment shows one way to use <b>PeekMessage</b> instead of <b>GetMessage</b> in the main message loop. Assume that the <i>AppPaused</i> Boolean is set to TRUE whenever the application loses the focus. This flag ensures that the app won't eat up CPU time by continuing to run the <b>PeekMessage</b> loop even when it is theoretically idle.</p>
<pre><code>MSG&nbsp; msg;

do
  {
  if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; if (msg.message == WM_QUIT) break;&nbsp; // the only way out of the loop
 &nbsp;&nbsp; TranslateMessage(&amp;msg);
 &nbsp;&nbsp; DispatchMessage(&amp;msg);
 &nbsp;&nbsp; }
  else
 &nbsp;&nbsp; {
 &nbsp;&nbsp; if (AppPaused) WaitMessage();
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // do any non-message-based processing here, e.g. animation
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
  }
while (TRUE);
return msg.wParam;
</code></pre>
<h3>Bibliography</h3>
<p>
Microsoft Corporation, "Configuring TCP/IP with DHCP" in <i>Windows 95 Resource Kit</i>, MSDN Library.</p>
<p>
Microsoft Corporation, "DHCP (Dynamic Host Configuration Protocol) Basics" in <i>Windows for Workgroups and Windows NT Knowledge Base</i>.</p>
</BODY>
</HTML>
