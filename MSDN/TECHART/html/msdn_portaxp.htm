<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Porting Applications from Windows NT/X86 to Windows NT/Alpha AXP</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_portaxp"></a>Porting Applications from Windows NT/X86 to Windows NT/Alpha AXP</h1>
<p>
Digital Equipment Corporation<br>
Maynard, Massachusetts</p>
<p>
October 1994</p>
<h2>Abstract</h2>
<p>
This article describes how to port Windows NT™ applications on the Intel® X86 platform to DEC® Alpha AXP™. Issues of interest to Windows NT version 3.5 developers, such as compiler descriptions, porting methodologies, and Alpha AXP optimization, are discussed in this article.</p>
<p>
This article contains the following chapters and appendixes:
<ul type=disc>
<li>
Chapter 1. Introduction. Provides an overview of the porting process from Intel X86 and Alpha AXP.<br><br></li>
<li>
Chapter 2. Compiler Descriptions. Provides an overview of the CLAXP, DEC FORTRAN, and ASAXP compilers.<br><br></li>
<li>
Chapter 3. Porting Overview. Outlines the steps to port your Windows NT version 3.5 application to Alpha AXP.<br><br></li>
<li>
Chapter 4. Architectural Issues. Itemizes the architectural differences between X86 and Alpha AXP.<br><br></li>
<li>
Chapter 5. Public Domain Tools for Alpha AXP. Provides a list of public domain tools available for development on Alpha AXP.<br><br></li>
<li>
Chapter 6. Alpha AXP Application Tuning and Optimization. Describes the features for tuning and optimizing applications on Alpha AXP.<br><br></li>
<li>
Appendix A. Compiler Options Comparison.<br><br></li>
<li>
Appendix B. Data Type Comparison.<br><br></li>
<li>
Appendix C. Data Type Natural Alignment.</li>
</ul>
<h2>Chapter 1. Introduction</h2>
<p>
This chapter provides an overview of porting applications from Microsoft® Windows NT™ version 3.5 on Intel® X86 to Windows NT version 3.5 on DEC® Alpha AXP™ machines. This chapter briefly describes Alpha AXP and helps you assess the effort needed to port your applications from Intel X86 to Alpha AXP.</p>
<h3>1.1.&nbsp; Windows NT Version 3.5 for Alpha AXP</h3>
<p>
Alpha AXP is a high-performance, 64-bit operating system neutral architecture, developed by Digital Equipment Corporation ("DEC," or "Digital"). Alpha AXP has a 64-bit physical and virtual address space and processes 64-bit integers and floating-point numbers.</p>
<p>
The Alpha AXP architecture is a scalable architecture that will support faster and faster chip designs over its long design lifetime. First-generation chips (DECchip 21064 family) are available with clock speeds from 133MHz to 200MHz. Second-generation chips (DECchip 21064A family) are available with clock speeds from 225MHz to 275MHz. These chips provide industry-leading performance using dual-issue designs, meaning that two instructions can be processed each clock cycle.</p>
<p>
Digital is currently shipping client systems for Windows NT for Alpha AXP using a 150MHz 21064 and server systems that support up to 4-way SMP and that support 190MHz 21064 processor boards. Both give excellent performance, and because they have the same byte ordering as Intel X86, they interoperate very efficiently with Intel systems.</p>
<p>
Windows NT is a Microsoft operating system that has been ported to and optimized for the Alpha AXP architecture through collaborative engineering work between Digital and Microsoft. It is one of three operating systems (the others being OSF/1, UNIX®, and OpenVMS) currently shipping on the Alpha AXP platforms.</p>
<p>
Windows NT is a modern, 32-bit, multitasking operating system that exploits some advanced features, such as 64-bit registers, of the Alpha AXP architecture. Windows NT supports a 32-bit virtual address space on Alpha AXP, as it does when implemented on Intel X86 architectures.</p>
<h3>1.2.&nbsp; Execution of X86 DOS and Win16 Executables on Alpha AXP</h3>
<p>
Part of Windows NT is a subsystem or facility that allows MS-DOS® and Win16 Intel executables to run on Alpha AXP and interoperate with native Win32® applications. These applications run more slowly than native applications for many reasons, but for personal productivity tools, mail, and many other low-performance applications, performance may be very satisfactory.</p>
<p>
In Windows NT version 3.5, OLE 2.01 allows enhanced interoperability between Win16 (16-bit Microsoft Windows®–based applications) and Win32 (32-bit Windows-based) applications. Each Win16 application can run in its own address space, improving system robustness. Performance of these Intel X86 executables on RISC microprocessors such as Alpha AXP is also significantly improved.</p>
<p>
The features described above are important to your clients. Your clients will want to interoperate between native, high performance Win32 Alpha AXP applications and legacy, X86 Win16 executables, lower performance applications, and personal productivity tools. Developers may find some value in this feature, therefore your support staff will need to understand how Win16 and Win32 applications interoperate and share data on both Intel X86 and Alpha AXP platforms.</p>
<h3>1.3.&nbsp; Porting Applications from Windows NT/X86 to Windows NT/Alpha AXP</h3>
<p>
In contrast to the support for Intel Win16 executables in Windows NT, native Win32 Intel programs will not execute on Alpha AXP. Recompilation of these applications is the proper method to provide support for Alpha AXP. This recompilation is usually very easy; some developers port significant applications in less than one working day.</p>
<p>
Many popular CASE tools and compilers, including the Microsoft SDK, are supported on both Intel X86 Windows NT and on Alpha AXP Windows NT. These common tools ease migration and allow Alpha AXP to be a development platform for deployment on Intel NT, and vice versa.</p>
<p>
The following table lists the basic porting steps:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=13%><b>Step</b></td>
<td class=label width=87%><b>Procedure</b></td>
</tr>
<tr valign=top>
<td width=13%>1</td>
<td width=87%>Set up the source and make files on Alpha AXP.</td>
</tr>
<tr valign=top>
<td width=13%>2</td>
<td width=87%>Ensure the components that make up the development environment are available on Alpha AXP.</td>
</tr>
<tr valign=top>
<td width=13%>3</td>
<td width=87%>Modify the make files as necessary, so they work in the Alpha AXP <i>nmake </i>environment.</td>
</tr>
<tr valign=top>
<td width=13%>4</td>
<td width=87%>Compile and link your application.</td>
</tr>
<tr valign=top>
<td width=13%>5</td>
<td width=87%>Correct any errors and re-compile and/or re-link your application.</td>
</tr>
<tr valign=top>
<td width=13%>6</td>
<td width=87%>Test your application.</td>
</tr>
<tr valign=top>
<td width=13%>7</td>
<td width=87%>Optimize your application.</td>
</tr>
</table><br>
<h2>Chapter 2. Compiler Descriptions </h2>
<p>
This chapter describes the CLAXP compiler, as well as other Digital compilers available on Alpha AXP. With the exception of the compiler, the Win32 SDK is the same on both Intel X86 and Alpha AXP. The compiler on the Win32 SDK for Alpha AXP is called CLAXP, not CL386. An alias, CL, is now used on all platforms, making make files more uniform.</p>
<h3>2.1.&nbsp; CLAXP</h3>
<p>
CLAXP is Digital's and Microsoft's compiler on Windows NT for Alpha AXP. The CLAXP compiler generates Alpha AXP–specific optimized machine code. The compiler front end, or code interpreter, looks very similar to Microsoft's CL386 compiler. The interpreter accepts and parses most of the CL386 switches. The back end is Digital’s code optimizer that generates code optimized specifically for the Alpha AXP architecture.</p>
<p>
For further details on the CLAXP compiler, see the <i>CLAXP Compiler Specifications Version 8.00 </i>document. This document is located in \mstools\bin\claxp.txt. For more information on designing your application to take advantage of the Alpha AXP architecture, see the <i>Windows NT for Alpha AXP Calling Standard</i> document.</p>
<h3>2.2.&nbsp; DEC FORTRAN</h3>
<p>
The DEC FORTRAN compiler for Alpha AXP is an implementation of full language FORTRAN-77 conforming to American National Standard FORTRAN, ANSI X3.9-1978. The DEC FORTRAN compiler will compile any source code pool that strictly adheres to ANSI FORTRAN-77. </p>
<p>
The compiler also supports extensions to the ANSI standard, including a number of extensions defined by the DEC FORTRAN compiler that runs on OpenVMS, DEC OSF/1, and ULTRIX systems. The following list describes some of the more significant extensions: 
<ul type=disc>
<li>
Additional statements such as DO WHILE, ENDDO, ACCEPT, and TYPE.<br><br></li>
<li>
Support for dynamic memory allocation and POINTER data type.<br><br></li>
<li>
Support for reading and writing binary data files in big-endian and VAX, IBM®, and CRAY® floating point formats.<br><br></li>
<li>
Support for 64-bit signed integers using INTEGER*8 and LOGICAL*8.</li>
</ul>
<p>
Other vendor's FORTRAN compilers' extensions may differ. However, because Digital's FORTRAN extensions have often become de facto standards, compatibility is likely even when syntax extensions are used. </p>
<p>
Certain FORTRAN extensions specific to Microsoft FORTRAN that are not yet supported by DEC FORTRAN are:
<ul type=disc>
<li>
Dynamically allocated arrays.<br><br></li>
<li>
SELECT CASE, INTERFACE TO, CYCLE, and EXIT statements.</li>
</ul>
<p>
These extensions (except the INTERFACE TO statement) will be supported in the next major release of DEC FORTRAN. </p>
<p>
In addition to language extensions, the DEC FORTRAN run-time library provides a number of built-in utility routines to the ANSI-defined intrinsic functions. Other compilers are likely to differ in what utility routines are available.</p>
<p>
The development kit provided with DEC FORTRAN supports a command line interface and the <i>nmake</i> utility. Source code debugging with a graphical user interface is provided via the <i>windbg</i> utility.</p>
<p>
DEC FORTRAN uses GEM as its back-end on all Alpha AXP platforms. The DEC FORTRAN compiler provides a multiphased optimizer that is capable of performing optimizations across entire programs. Although builds may take more time and memory compared to compilers that optimize less thoroughly, the improved performance of highly optimized code at run time is worth the added time.</p>
<p>
DEC FORTRAN is run-time compatible with CLAXP. This capability allows you to mix and match FORTRAN and C/C++ modules to meet your application needs. Run-time compatibility with other compilers has not been tested, though it may work if proper calling standards are followed.</p>
<p>
The DEC FORTRAN kit includes dynamic-link library (DLL) versions of its Run-Time Libraries (RTLs). These RTLs can be reproduced and distributed royalty-free worldwide.</p>
<h3>2.3.&nbsp; Windows NT Assembler (ASAXP)</h3>
<p>
ASAXP compiles source files written in Alpha AXP assembly language. You need to be familiar with both the Alpha AXP 21064 DECchip architecture and the Alpha AXP assembly language. For assembler syntax, see the file \mstools\bin\asaxp.txt.</p>
<h2>Chapter 3. Porting Overview</h2>
<p>
In most cases, porting your application simply means recompiling and relinking the application on Alpha AXP. If you use the Win32 SDK to develop your application, you only have to make minor changes to your development environment. This chapter describes how to port your application to Alpha AXP.</p>
<h3>3.1.&nbsp; Modifying the nmake Environment</h3>
<p>
If you use the <i>nmake</i> utility on your Intel X86 system, your application's build environment will need very few changes to work on Alpha AXP. If you use another build system, be sure the that system is available on Alpha AXP. Otherwise, you need to modify your make file(s) to work with <i>nmake</i>. The following sections describe the changes you need to be aware of.</p>
<h4>3.1.1.&nbsp; Modify host machine symbols</h4>
<p>
The _ALPHA_ symbol defines the Alpha AXP target environment. The make file should pass -D_ALPHA_= 1 to the CLAXP compiler. If the make file includes &lt;ntwin32.mak&gt;, this is automatically ensured. </p>
<p>
Additionally, ensure that the symbols _MIPS_ and _X86_ are not defined.</p>
<h4>3.1.2.&nbsp; Modify compiler options</h4>
<p>
Most of the compiler options are the same on both Intel X86 and Alpha AXP. There are two compiler flag changes on Alpha AXP to be aware of:
<ul type=disc>
<li>
/Gn flags (These flags do not support Intel X86 optimization.)<br><br></li>
<li>
/On flags (Certain flags are different from Intel X86.)</li>
</ul>
<p>
See Appendix A for a list of compiler options. The \mstools\bin\claxp.txt file provides detailed information about the compiler flags. </p>
<h4>3.1.3.&nbsp; Other build environments</h4>
<p>
If you use other build environments and your build software is not ported to Alpha AXP, you must rebuild your dependency files. The <i>nmake</i> compiler, linker, and resource macros are predefined in a file named \mstools\h\ntwin32.mak. Use this file as a start for rebuilding your application. The Building Applications chapter in the <i>Windows NT SDK Programming Techniques</i> document provides further information about the build process.</p>
<h3>3.2.&nbsp; Porting References to Header Files</h3>
<p>
In most cases, you do not need to modify the header files. Compile the application first and investigate any header file errors generated by the compiler. The following sections describe some common header file changes that may be required.</p>
<h4>3.2.1.&nbsp; Machine-specific #ifdef statements</h4>
<p>
Applications developed on multiple platforms may have preprocessing operators defined for different machine types—for example<code>, </code><b>#ifdef _X86_, #ifdef _MIPS_</b>. These statements must be updated to apply to Alpha AXP. This is accomplished by adding an <b>#ifdef&nbsp; _ALPHA_</b> section and adding the appropriate architecture-specific code. These symbols are defined in ntwin32.mak.</p>
<h3>3.3.&nbsp; Recompiling</h3>
<p>
Once the necessary changes have been made to the build environment, executing the <i>nmake </i>utility will compile your application. It is also possible to compile the application from command line by using the CLAXP compiler. Most of the CL386 options are available on the CLAXP compiler. You can also compile your program in command prompt mode. Appendix A contains a list of Alpha AXP compiler options. </p>
<h3>3.4.&nbsp; Relinking</h3>
<p>
The <i>link</i> command on Alpha AXP is the same as on Intel X86 and understands the same flags. </p>
<h3>3.5.&nbsp; Debugging</h3>
<p>
There are three debuggers currently available on Alpha AXP systems to help you debug code at the application and kernel levels: <i>windbg</i>, NTSD, and KD. The following section provides a brief introduction to these debuggers.</p>
<h4>3.5.1.&nbsp; windbg</h4>
<p>
The WinDebug debugger, <i>windbg</i>, is a GUI-based debugging tool. It is located in \mstools\bin or in the <i>Win32 SDK Tools</i> program group. The debugger allows you to set breakpoints; examine values of local variables, registers, and assembly-language instructions; and so on.</p>
<p>
To debug your application, compile the code with the /Zi and /Od options. Then link with debug:full and debugtype:cv (CodeView®-style debugging information), or with debug:full and debugtype:coff (for global only, non-static symbols). The <i>windbg</i> debugger also has full 64-bit register support on Alpha AXP NT systems.</p>
<h4>3.5.2.&nbsp; NTSD</h4>
<p>
You can use the NT Symbolic Debugger (NTSD) for assembler programs that have been compiled and linked with the debugtype:coff and debug:partial options using the link32 command. There are two commands (rL, rF) available on Windows NT for AXP that are not available on Intel X86. These commands enable you to examine large integers and floating point registers. </p>
<p>
For information on commands and how to use NTSD, see the <i>Tools User's Guide in Microsoft Win32 SDK.</i></p>
<h4>3.5.3.&nbsp; KD</h4>
<p>
The Kernel Debugger (KD) allows you to debug kernel-mode executables and device drivers. KD can also be used to perform remote driver debugging between different architectures. For example, you can use KD to debug an Alpha AXP driver from an Intel machine and vice versa.</p>
<h2>Chapter 4. Architectural Issues</h2>
<p>
This section briefly discusses the architectural issues you need to consider when porting applications from Windows NT for Intel X86 to Windows NT for Alpha AXP.</p>
<p>
For a detailed description of the architectural considerations that need to be addressed when porting your application, see the <i>AXP Notes </i>document. You can locate this document in the <i>Win32 SDK Tools</i> program group. The \mstools\bin\claxp.txt file is also a good reference for compiler-specific features.</p>
<h3>4.1.&nbsp; Variable Argument Lists</h3>
<p>
For defining variable argument lists, the CLAXP compiler supports two header files:
<ul type=disc>
<li>
ANSI standards &lt;stdarg.h&gt;<br><br></li>
<li>
Traditional &lt;varargs.h&gt;</li>
</ul>
<p>
Use the macros va_start(list,v), va_arg(list,mode) &amp; va_end(list) as defined in the header file &lt;stdarg.h&gt;. All programs that properly use the varargs macros for variable argument list processing will port unchanged to Windows NT on Alpha AXP.</p>
<p>
The following example illustrates the proper use of the varargs macros:</p>
<pre><code>// Example: VARARG.C
 &nbsp;&nbsp; /* VARARGS.C illustrates passing a variable number of 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arguments using the following macros:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_arg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end
 &nbsp;&nbsp; *
 &nbsp;&nbsp; * Also the ANSI and UNIX type:
 &nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list
 &nbsp;&nbsp; * and the UNIX types:
 &nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_alist&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_dcl
 &nbsp;&nbsp; */
 &nbsp;&nbsp; 
 &nbsp;&nbsp; #include &lt;stdio.h&gt;
 &nbsp;&nbsp; #include &lt;stdarg.h&gt;
 &nbsp;&nbsp; int average( int first, ... );
 &nbsp;&nbsp; 
 &nbsp;&nbsp; void main()
 &nbsp;&nbsp; {
 &nbsp;&nbsp; /* Call with 3 integers (-1 is used as terminator). */
 &nbsp;&nbsp; printf( "Average is: %d\n", average( 2, 3, 4, -1 ) ); 
 &nbsp;&nbsp; 
 &nbsp;&nbsp; /* Call with 4 integers. */
 &nbsp;&nbsp; printf( "Average is: %d\n", average( 5, 7, 9, 11, -1 ) );
 &nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; /* Call with just -1 terminator. */
 &nbsp;&nbsp; printf( "Average is: %d\n", average( -1 ) );
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; /* Returns the average of a variable list of integers. */
 &nbsp;&nbsp; int average( int first, ... )
 &nbsp;&nbsp; {
 &nbsp;&nbsp; int count = 0, sum = 0, i = first;
 &nbsp;&nbsp; va_list marker;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; va_start( marker, first );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Initialize variable arguments */
 &nbsp;&nbsp; )
 &nbsp;&nbsp; {
 &nbsp;&nbsp; sum += i;
 &nbsp;&nbsp; count++;
 &nbsp;&nbsp; i = va_arg( marker, int);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; va_end( marker );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Reset variable arguments */
 &nbsp;&nbsp; return( sum ? (sum / count) : 0 );
 &nbsp;&nbsp; }
</code></pre>
<h3>4.2.&nbsp; Uninitialized Variables</h3>
<p>
An error message, "Memory Access Errors", is displayed for uninitialized variables due to&nbsp; inappropriate values on the high order bits of those variables. Use the <i>Disassembly</i> option in <i>windbg</i> to locate the improperly initialized variables. </p>
<p>
When using the <i>Disassembly</i> option, a listing from the compiler is very helpful; create a .COD file using the /FAcs CLAXP (compiler) option. In optimized only cases, specify the -O*&nbsp; -Zi options and use the listing file created.</p>
<p>
If you notice behavior such as a floating point exception, invalid access, and so on, examine the variables involved and investigate the call stack until you find the offending variable.</p>
<h3>4.3.&nbsp; Data Alignment and the UNALIGNED Keyword</h3>
<p>
The Alpha AXP memory architecture naturally aligns and references data in 2-, 4-, or 8-byte quantities. In Windows NT version 3.5, there is a switch to enable the alignment fault exceptions. (Automatic fixups are disabled by default.) Turning off automatic fixups by default is desirable because it allows Alpha AXP application developers to locate alignment faults in their own applications.</p>
<p>
For maximum performance, align your data structure components on natural boundaries. Also, avoid using byte and word length integers in favor of longwords or quadwords wherever possible. (For example, avoid using chars and shorts; use ints or int64s instead.)</p>
<p>
If unaligned access of data is required, you can use the UNALIGNED pointer qualifier defined in the Windows NT system include files. The performance using UNALIGNED is better than the kernel handle alignment faults (though not as good as using aligned data). When instructed, the compiler will insert routines to handle the unaligned data; and thus avoid operating system trap(s), resulting in significantly improved performance. </p>
<p>
The UNALIGNED pointer is portable across all Windows NT platforms, regardless of whether the machine has alignment restrictions or not.</p>
<p>
The following is a table of UNALIGNED pointer examples:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=43%>UNALIGNED int</td>
<td width=19%>*ip;</td>
<td width=38%>// pointer to unaligned int</td>
</tr>
<tr valign=top>
<td width=43%>int UNALIGNED</td>
<td width=19%>*ip;</td>
<td width=38%>// pointer to unaligned int</td>
</tr>
<tr valign=top>
<td width=43%>int * UNALIGNED</td>
<td width=19%> ip;</td>
<td width=38%>// wrong</td>
</tr>
<tr valign=top>
<td width=43%>typedef struct _FOO UNALIGNED</td>
<td width=19%>*PFOO;</td>
<td width=38%>// pointer to unaligned struct</td>
</tr>
<tr valign=top>
<td width=43%>typedef SYMBOLS UNALIGNED</td>
<td width=19%>*psymbols;</td>
<td width=38%>// pointer to unaligned symbol</td>
</tr>
<tr valign=top>
<td width=43%>UNALIGNED PLONG</td>
<td width=19%>NextEntry;</td>
<td width=38%>// wrong</td>
</tr>
<tr valign=top>
<td width=43%>PLONG UNALIGNED</td>
<td width=19%>NextEntry;</td>
<td width=38%>// wrong</td>
</tr>
<tr valign=top>
<td width=43%>LONG UNLIGNED</td>
<td width=19%>*NextEntry;</td>
<td width=38%>// correct</td>
</tr>
</table><br>
<p>
There are routines available to help locate the source of alignment traps. Performance gains of up to 20 percent have been observed when the programmer instructs the compiler in such a way that an alignment trap will not occur.</p>
<p>
See Appendix C for details on data type natural alignment.</p>
<h3>4.4.&nbsp; Structure Packing</h3>
<p>
The<b> #pragma pack</b> directive can be used to pack structure members together tighter than the default packing the compiler would use. In some cases this is necessary to map structures to preexisting data. In other cases, it is to reduce memory use. It results in structure members that no longer have their natural alignment; thus the CLAXP treats access to these structure members as unaligned. The code generated is bigger and slower than aligned access because the compiler will load the 16-bit, 32-bit, or 64-bit object byte by byte, or by checking the alignment dynamically. This is still much faster than a hardware trap. /ZP8 is the default packing CLAXP would use.</p>
<p>
Use the <b>#pragma pack</b> directive only when necessary, such as when compiling a data structure that will be read from a disk file. For example: </p>
<pre><code>#pragma pack(1)
 typedef struct
{
...
}
#pragma pack()&nbsp; //resume default
</code></pre>
<p>
If you use the <b>#pragma pack</b> directive, it is necessary to appropriately declare pointers as UNALIGNED. Note that you may incur a large performance penalty for UNALIGNED access. </p>
<h3>4.5.&nbsp; Data Structures: 64-Bit Data Types</h3>
<p>
On Alpha AXP platforms, LARGE_INTEGER types are treated as one naturally aligned quadword. CLAXP adds 64-bit integer support. CLAXP handles type long double as a 64-bit floating point type (rather than 80-bit). See Appendix B for a data types comparison list.</p>
<h3>4.6.&nbsp; Integer Division by Zero Exception</h3>
<p>
By default, integer division by zero is reported as an exception on Alpha AXP. The exception may occur on Alpha AXP but not on Intel X86. This is considered a latent bug in the original code and should be corrected.</p>
<h3>4.7.&nbsp; Floating Point Behavior</h3>
<p>
All Windows NT platforms use identical IEEE floating point formats. For finite floating point values, Alpha AXP floating point behavior is identical to that of MIPS® and Intel X86. However, for non-finite floating point values (for example, infinity, denormals, and NaNs) the Alpha AXP will raise a floating point exception when such values are encountered. The floating point exceptions are:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=69%>STATUS_FLOAT_DIVIDE_BY_ZERO</td>
<td width=31%>0xC000008E</td>
</tr>
<tr valign=top>
<td width=69%>STATUS_FLOAT_INVALID_OPERATION</td>
<td width=31%>0xC0000090</td>
</tr>
<tr valign=top>
<td width=69%>STATUS_FLOAT_OVERFLOW</td>
<td width=31%>0xC0000091</td>
</tr>
<tr valign=top>
<td width=69%>STATUS_FLOAT_UNDERFLOW</td>
<td width=31%>0xC0000093</td>
</tr>
<tr valign=top>
<td width=69%>STATUS_FLOAT_INEXACT_RESULT</td>
<td width=31%>0xC000008F</td>
</tr>
</table><br>
<p>
Note that if you use default options, floating point exceptions that are not reported under Intel X86 may raise floating points exceptions in Alpha AXP. </p>
<p>
At the present time, the CLAXP compiler supports the following IEEE related options:
<ul type=disc>
<li>
/QAieee (same as QAieee1 described below.)<br><br></li>
<li>
/QAieee0 <p class=tl>
IEEE floating point NaNs, Infinities, and denormals are not supported in the compiled code. Underflows are quickly forced to zero, and the use of a NaN or Infinity raises an exception. This is the default value, and should be used for all applications except those that require IEEE-floating point exception behavior, because it produces the fastest execution speed. </P><p class=tl>
Run-time library routines may still produce NaNs and denormals, however, so the use of the _matherr routine to handle those situations is recommended. If an application does require support for IEEE NaNs and denormals, use the QAieee option (equivalently /Qaieee1).</P></li>
<li>
/Qaieee1<p class=tl>
IEEE floating point NaNs, Infinities, and denormals are supported. Use this value for applications that expect IEEE-compliant, masked response handling of non-finite operands.</P></li>
<li>
/Qaieee2<p class=tl>
Same as /QAieee1, but IEEE Inexact Operation exceptions are also enabled. Use this value only for applications requiring the IEEE inexact operation exception to be raised (this is almost never needed).</P></li>
</ul>
<h3>4.8.&nbsp; Imprecise Location of Exceptions</h3>
<p>
For normal compile modes, if one of the exceptions listed in the previous section does occur, it is likely that the exception PC does not point to the instructions that actually cause the trap. If using a debugger, look for the offending floating point instruction a few instructions prior to the Fir (continuation address). If you are looking near the beginning of a function, look at the last few instructions in the calling frame.</p>
<p>
Compile your code using the /QAieee1 option if you want the exceptions to be precise. </p>
<h3>4.9.&nbsp; CONTEXT Structure Definition</h3>
<p>
The CONTEXT structure is an architecture-dependent data structure that contains register data. If you have code that accesses fields in this structure, you will need to modify the application for Alpha AXP.</p>
<h3>4.10.&nbsp; Page Size Assumptions</h3>
<p>
The page size is architecture-dependent (4 KB on Intel and 8 KB on Alpha AXP<i>) </i>and should not be hard-coded into applications.<i> </i>If the application assumes the page size to be 4 KB, it will not work correctly on Windows NT on Alpha AXP.</p>
<h3>4.11.&nbsp; LARGE_INTEGER &amp; Quadword Types</h3>
<p>
Although the LARGE_INTEGER data type is a 64-bit integer, it is not a quadword. A quadword is a 64-bit integer data type and is not supported on Windows NT for Alpha AXP.<i> </i>LARGE_INTEGER is created from an array of two longwords. The LARGE_INTEGER data type can only be used in conjunction with a set of run-time library functions. (For example, LargeIntegerAdd, and so on.)</p>
<h3>4.12.&nbsp; Multithreaded Granularity of Access</h3>
<p>
Ideally, you would like to have atomic load/store of shared data. An atomic load/store requires a single instruction. On the Intel X86 platform,<i> </i>the size of shared data is 1, 2, or 4 bytes, but on Alpha AXP it is 4 or 8 bytes.</p>
<p>
To ensure portability across platforms, it is necessary to protect multithread access to shared data structure with locks. (For example, EnterCriticalSection, LeaveCriticalSection.)</p>
<h3>4.13.&nbsp; setjmp/longjmp Jump Buffer</h3>
<p>
The jump buffer is compiler-specific and version-specific. If you use setjmp/longjmp, do not link objects produced by various compilers or versions. </p>
<h3>4.14.&nbsp; Assembler Source Files</h3>
<p>
The CLAXP compiler does not produce any assembler source files.</p>
<h2>Chapter 5. Public Domain Tools for Alpha AXP</h2>
<p>
This chapter lists some of the common utilities that are publicly available on the Internet for Alpha AXP. </p>
<h3>5.1.&nbsp; Alpha AXP Developer Support Home Page</h3>
<p>
You can access Digital’s Alpha AXP Developer Support home page on the World Wide Web by specifying the following Universal Resource Locator (URL):</p>
<pre><code>http://www.digital.com/www-swdev/
</code></pre>
<p>
From the Alpha AXP Developer Support home page, follow the steps below to access the public domain tools:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=4%></td>
<td class=label width=43%><b>To reach...</b></td>
<td class=label width=53%><b>Click on...</b></td>
</tr>
<tr valign=top>
<td width=4%>1</td>
<td width=43%>Alpha AXP Technical Support page</td>
<td width=53%>TECH button (on the Alpha AXP Support home page)</td>
</tr>
<tr valign=top>
<td width=4%>2</td>
<td width=43%>Microsoft Windows NT Software page</td>
<td width=53%>Microsoft Windows NT (in the Software Area)</td>
</tr>
<tr valign=top>
<td width=4%>3</td>
<td width=43%>Windows NT Public Domain page (this is where the tools are stored)</td>
<td width=53%>Unsupported Software Tools Built for Alpha AXP (in the Public Domain Software area)</td>
</tr>
</table><br>
<h3>5.2.&nbsp; List of Public Domain Tools</h3>
<p>
Most of the public domain utilities also contain the executables for Intel-based Windows NT machines. Note that all of these tools were collected from the Internet and are copyrighted as per the agreements in the individual source code.<i> </i>Digital makes no warranties, either written or implied, concerning this software. The following table lists the public domain tools available on the Internet. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=18%><b>Tool</b></td>
<td class=label width=82%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=18%>bsdcmpat.lib</td>
<td width=82%>Contains a library of routines to help in porting to NT.<i> </i>Routines include bcmp, bcopy, bstring, bzero,getopt, index, and isctype.<p>
Headers include ctype, getopt, paths, string, strings, and unistd. </p>
</td>
</tr>
<tr valign=top>
<td width=18%>cal.exe</td>
<td width=82%>Prints a calendar.<i> </i>If you specify a number between 1 and 12 for month, only that month is printed for that year.<i> </i>Year can be between 1 and 9999.</td>
</tr>
<tr valign=top>
<td width=18%>cat.exe</td>
<td width=82%>Reads each file in sequence and displays it on the standard output.</td>
</tr>
<tr valign=top>
<td width=18%>cmp.exe</td>
<td width=82%>Compares two files.<i> </i>With no options, cmp makes no comment if the files are the same.<i> </i>If they differ, it reports the byte and line number at which the difference occurred to the standard output.</td>
</tr>
<tr valign=top>
<td width=18%>color.exe</td>
<td width=82%>Changes the color of the foreground and background. The available colors are black, blue, green, cyan, red, and magenta.</td>
</tr>
<tr valign=top>
<td width=18%>comm.exe</td>
<td width=82%>Compares sorted data.</td>
</tr>
<tr valign=top>
<td width=18%>compress.exe</td>
<td width=82%>Uses modified Lempel-Ziv.<i> </i>This command is compatible<i> </i>with the compress/decompression used on the UNIX systems compress<i> </i>programs.<i> </i>This is version 4 and supports up to 16 bits compression.</td>
</tr>
<tr valign=top>
<td width=18%>egrep.exe</td>
<td width=82%>Searches a file for regular expressions.<i> </i>Egrep patterns are full regular expressions.</td>
</tr>
<tr valign=top>
<td width=18%>grep.exe</td>
<td width=82%>Searches a file for regular expressions.<i> </i>Grep patterns are limited regular expressions in the style of 'ex'.</td>
</tr>
<tr valign=top>
<td width=18%>flex.exe</td>
<td width=82%>Generates output as C code source file via programs that recognize lexical patterns in text, Fast Lexical Analyzer Generator (FLEX).</td>
</tr>
<tr valign=top>
<td width=18%>fold.exe</td>
<td width=82%>Folds the contents of the specified files, or the standard input if none are specified, breaking the lines to have a maximum of 80 characters. </td>
</tr>
<tr valign=top>
<td width=18%>head.exe</td>
<td width=82%>Gives the first n lines of the specified files or the standard input.</td>
</tr>
<tr valign=top>
<td width=18%>ls.exe</td>
<td width=82%>Acts as a UNIX ls work-alike. Some options are different or absent. Use the -? command line argument for help. The executable is compiled for I386 and should be UNIX-code–compatible, but hasn't been tested.</td>
</tr>
<tr valign=top>
<td width=18%>mawk.exe</td>
<td width=82%>Implements the AWK programming language.</td>
</tr>
<tr valign=top>
<td width=18%>mewinnt.exe</td>
<td width=82%>Invokes the MicroEMACS windows editor.</td>
</tr>
<tr valign=top>
<td width=18%>par.exe</td>
<td width=82%>Copies, by way of a filter, its input to its output, changing all white characters (except newlines) to spaces, and reformatting each paragraph.<i> </i>Paragraphs are delimited by vacant lines, which are lines containing no more than a prefix, suffix, and intervening spaces.</td>
</tr>
<tr valign=top>
<td width=18%>perl.exe,<br>
perlglob.exe</td>
<td width=82%>Combines, using the Perl language, some of the features of C, sed, awk, and shell.</td>
</tr>
<tr valign=top>
<td width=18%>sed.exe</td>
<td width=82%>Uses regular-expression<i> </i>routines from EMACS (may not be fast). GNU sed is a batch stream editor.<i> </i>For speed, use Perl.</td>
</tr>
<tr valign=top>
<td width=18%>soss.exe</td>
<td width=82%>Runs SOSS, a file server conforming to SUN Microsystems' NFS protocol version 2.</td>
</tr>
<tr valign=top>
<td width=18%>tar.exe</td>
<td width=82%>Executes a&nbsp; version of the tape archiver command available on most UNIX machines based upon the GNU tar utility.<i> </i>It does not yet utilize the tape drive available. </td>
</tr>
<tr valign=top>
<td width=18%>uniq.exe</td>
<td width=82%>Reports repeated lines in a file.<i> </i>The repeated lines must be adjacent in order to be found. </td>
</tr>
<tr valign=top>
<td width=18%>unshar.exe</td>
<td width=82%>Extracts files from the SHELL archive.</td>
</tr>
<tr valign=top>
<td width=18%>viewps.exe</td>
<td width=82%>PostScript text extractor.</td>
</tr>
<tr valign=top>
<td width=18%>win100.exe</td>
<td width=82%>Invokes Kermit and terminal emulator.</td>
</tr>
<tr valign=top>
<td width=18%>winvn.exe</td>
<td width=82%>Runs the Visual Usenet news reader for Microsoft Windows.</td>
</tr>
<tr valign=top>
<td width=18%>xstr.exe</td>
<td width=82%>Extracts and hashes strings in a C program.</td>
</tr>
<tr valign=top>
<td width=18%>xvi.exe</td>
<td width=82%>Runs a portable multiwindow version of the UNIX editor, 'vi'.</td>
</tr>
<tr valign=top>
<td width=18%>yacc.exe</td>
<td width=82%>Runs Berkeley Yacc, an LALR parser generator.<i> </i>It has been made as<i> </i>compatible as possible with AT&amp;T® Yacc.</td>
</tr>
<tr valign=top>
<td width=18%>zip.exe,<br>
unzip.exe</td>
<td width=82%>Packages and compresses (archive) files.<br>
Lists/test/extracts from a ZIP archive file.</td>
</tr>
</table><br>
<h2>Chapter 6. Alpha AXP Application Tuning and Optimization</h2>
<p>
This chapter contains a summary of tips and hints for optimizing your application on Windows NT for Alpha AXP. For detailed performance analysis and optimization techniques on Windows NT, see the <i>Optimizing Windows NT (Volume 3 of the Windows NT Resource Kit )</i> book by Russ Blake from Microsoft Press®.</p>
<h3>6.1.&nbsp; Compiler Options</h3>
<p>
An important tool in optimizing your application is the compiler. Once your application is working, recompile the application with optimization turned on (using the /Ox switch). The performance gain will vary from application to application but typically you can expect a 20–30 percent gain in performance. Also consider specifying some of the other CLAXP optimization switches summarized below for any potential gain in performance.</p>
<p>
Since you often develop your application initially in debug mode to facilitate testing and debugging of your application (using the -Zi -Od switches), remember that the compiler has turned off optimization. You can quickly turn off debugging in <i>nmake</i> by passing <i>nmake</i> a nodebug flag—for example, &gt;<i>nmake</i> nodebug=1.</p>
<h4>6.1.1.&nbsp; CLAXP</h4>
<p>
Use the following options for optimization:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=33%><b>Option</b></td>
<td class=label width=67%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=33%>/Ox</td>
<td width=67%>full optimization (except in-lining)</td>
</tr>
<tr valign=top>
<td width=33%>/O2</td>
<td width=67%>full optimization (same as /Ox /Ob2)</td>
</tr>
<tr valign=top>
<td width=33%>/d2O3 /Ob2 /Oi</td>
<td width=67%>full optimization with byte vectorization</td>
</tr>
<tr valign=top>
<td width=33%>/d2Gt64</td>
<td width=67%>use of Global Pointer</td>
</tr>
</table><br>
<p>
You can also use UNALIGNED keyword for unaligned data. See the ALIGNMENT section below.</p>
<h4>6.1.2. DEC F77</h4>
<p>
If you are using the DEC F77 compiler for your FORTRAN application, the following table lists the optimization switches that are not enabled by default:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=34%><b>Optimization Switch</b></td>
<td class=label width=35%><b>Description</b></td>
<td class=label width=31%><b>Notes</b></td>
</tr>
<tr valign=top>
<td width=34%>/align:dcommons</td>
<td width=35%>Aligns COMMON data blocks on natural<i> </i>boundaries up to eight bytes.</td>
<td width=31%>These switches may be enabled en masse via /fast.</td>
</tr>
<tr valign=top>
<td width=34%>/assume:noaccuracy_sensitive</td>
<td width=35%>Allows floating point operations to be reordered.</td>
<td width=31%>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr valign=top>
<td width=34%>/math_library:fast</td>
<td width=35%>Uses versions of some intrinsics that trade a small amount of accuracy for improved performance.</td>
<td width=31%>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr valign=top>
<td width=34%>/inline:all</td>
<td width=35%>Inlines every possible routine.</td>
<td width=31%>Use these switches carefully.<i> </i>By default, the compiler automatically inlines and unrolls according to its heuristics. </td>
</tr>
<tr valign=top>
<td width=34%>/unroll:&lt;count&gt;</td>
<td width=35%>Specifies how many times loops are unrolled.</td>
<td width=31%>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
</table><br>
<h3>6.2.&nbsp; Tools</h3>
<p>
Key tools for performance are described below.<i> </i>For more detailed information on the use of these tools, see the <i>Optimizing Windows NT</i> book.</p>
<p class=dt>
PerfMon (Performance Monitor)</p>
<p class=indent>
Performance Monitor (PerfMon) analyzes the performance of your system or application. Use this tool to analyze all the key areas for potential bottlenecks—CPU usage, disk I/O activity, memory statistics, network traffic, and so forth.</p>
<p class=dt>
WAP<i> </i>(Windows API Profiler)</p>
<p class=indent>
WAP profiles the Windows API. For example, how much time is spent in which Win32 API calls?<i> </i>It can be run without recompiling your application and is part of the Windows NT SDK.</p>
<p class=dt>
CAP (Call Attributed Profiler)</p>
<p class=indent>
CAP profiles your entire application (how much time is spent in each function).<i> </i>This is used to identify the "hot spots" in your program so you can focus on those areas for optimization.<i> </i>WAP requires that you recompile your application with the -Gh option on the C compiler. (Currently only C programs are supported.)<i> </i>It is part of the Windows NT SDK.</p>
<p class=dt>
WST (Working Set Tuner)</p>
<p class=indent>
WST can improve the speed of your program by reducing processor cache bottlenecks.<i> </i>It does this by telling the linker to reorder the functions in your program in the order that most reduces paging. Using WST involves several steps.<i> </i>See the <i>Optimizing Windows NT</i> book for more details.</p>
<h3>6.3.&nbsp; Alignment Fixups</h3>
<p>
In both versions of Windows NT (3.1 and 3.5), the operating system automatically resolves Alpha AXP alignment faults at run time by default. In most cases this is a desirable feature because the alternative would be for an application to unexpectedly terminate with a data misalignment exception if any alignment fault occurred.</p>
<p>
However, allowing the operating system to resolve alignment faults can degrade the performance of your application if there are hundreds or thousands of alignment fixups per second. The rate of alignment fixups can be monitored using the PerfMon or wperf performance tools.</p>
<p>
To eliminate alignment errors in your application on Alpha AXP, change the default operating system control for alignment exceptions so that alignment faults become visible to your application. You can then use the debugger to locate the source of the alignment faults.</p>
<h4>6.3.1.&nbsp; Changing operating system defaults</h4>
<p>
You can change operating system defaults in the registry by using the new SDK tool called axpalign (an easy and preferred method) or with the regedt32 method. The two methods are discussed below.
<ul type=disc>
<li>
To enable alignment fault exceptions (using axpalign) enter:<p class=tl>
axpalign /enable </P><p class=tl>
To disable alignment fault exceptions enter:</P><p class=tl>
axpalign /disable </P></li>
<li>
To enable Alpha AXP alignment fault exceptions (using regedt32) add the following value in HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\:<p class=tl>
EnableAlignmentFaultExceptions : REG_DWORD : 0x1</P><p class=tl>
To disable alignment fault exceptions and revert to the default operating system behavior, enter the following value:</P><p class=tl>
EnableAlignmentFaultExceptions : REG_DWORD : 0x0</P></li>
</ul>
<p>
After using either method, you will need to reboot your system. The changes apply system-wide and affect all applications. Use this method only while locating alignment faults in your own system or application. Otherwise, older applications that still contain alignment errors may terminate with data misalignment exceptions.</p>
<p>
If your application requires that the operating system handle alignment faults regardless of the operating system alignment exception control, insert the following statement early in your program: </p>
<pre><code>SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);
</code></pre>
<p>
This statement must be executed before any alignment error can occur. The effect of the statement is to set a flag that causes the operating system to handle alignment faults for your program.</p>
<h4>6.3.2.&nbsp; Displaying alignment fixups per second</h4>
<p>
Use the PerfMon or wperf tools to display the number of alignment fixups per second. If this value is zero, you do not need to debug your system or application. A value of less than 100 or 500 alignment fixups per second is not considered a performance problem. However, addressing alignment faults is essential for obtaining good performance on RISC architectures. </p>
<h4>6.3.3.&nbsp; Techniques for addressing alignment faults </h4>
<p>
There are several techniques for addressing alignment faults:
<ul type=disc>
<li>
Use the UNALIGNED compiler keyword if your application must access unaligned data.<b> </b>It is faster than letting the<b> </b>kernel fix up unaligned data.<b> </b>See Chapter 4 for a description of the UNALIGNED type qualifier.<br><br></li>
<li>
Do not use the <b>#pragma pack(1)</b> directive unless absolutely necessary.<b> </b>This will cause more alignment faults on all RISC architectures, including Alpha AXP. See Chapter 4 for a description of the<b> #pragma pack</b> directive.<br><br></li>
<li>
Avoid misleading casts. Pointer casts are used to cast one pointer type to another.<b> </b>One subtle and undetectable problem with this can occur when casting to a pointer with stronger alignment requirements.<b> </b>For example,<pre><code>long *ip;
...
percent = (double *)ip / 100.0; 
</code></pre>
<p class=tl>
will cause an alignment trap if the value of pointer ip is not a multiple of 8. Since ip is merely a pointer to a 4-byte long type, there is no reason to believe it will be a multiple of 8.<b> </b>The compiler cannot detect this at compile time.<b> </b>Another example is when the address for some data is obtained from a memory allocation function that makes no guarantee about the alignment of the address it returns.<b> </b></P><p class=tl>
For example, if <b>MyAlloc()</b> does not round up addresses to 8-byte multiples, then:</P><pre><code>TimePtr = MyAlloc(8);
...
MyQuerySystemTime((PLARGE_INTEGER)TimePtr);
</code></pre>
<p class=tl>
may result in an alignment trap because <b>MyQuerySystemTime</b> is expecting the address of a properly aligned LARGE_INTEGER type.</P><p class=tl>
Note that on MIPS platforms this particular code example will work as expected even though the code is wrong, because LARGE_INTEGER types are treated as two naturally aligned longwords.<b> </b>On Alpha AXP platforms the code may result in an alignment trap because LARGE_INTEGER types are treated as one naturally aligned quadword.</P></li>
<li>
Do not pass unaligned pointers to another function. If you take the address of a member of an unaligned or packed structure and pass it as an argument to a function, with or without a cast, it is likely that an alignment trap will occur. For example:<pre><code>struct _FOO {
...
long count;
};
struct _FOO UNALIGNED *pFoo;
void SetCounter(long * ip);
...
pFoo-&gt;count++;// Ok, the compiler knows 
// the long may be unaligned.
SetCounter(&amp;pFoo-&gt;count);    // WRONG! Function
// SetCounter is expecting
// a pointer to a normal,
// aligned long.
</code></pre>
<p class=tl>
One workaround in this case is to type <b>SetCounter</b><code> </code>to receive an UNALIGNED pointer rather than a normal pointer.<b> </b>Another work-around is to declare a local count variable and pass its address to <b>SetCounter</b>.</P><p class=tl>
Note that the Windows NT system services do not explicitly enforce quadword alignment of quadword pointer parameters.</P></li>
</ul>
<h2>Appendix A. Compiler Options Comparison</h2>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>CLAXP</b></td>
<td class=label width=25%><b>CL386</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%>/?,/help</td>
<td width=25%>/?,/help</td>
<td width=50%>print compiler options</td>
</tr>
<tr valign=top>
<td width=25%>/batch</td>
<td width=25%>/batch</td>
<td width=50%>batch compiler mode</td>
</tr>
<tr valign=top>
<td width=25%>/Bd</td>
<td width=25%>/Bd</td>
<td width=50%>verbose, shows all default macros and include files</td>
</tr>
<tr valign=top>
<td width=25%>/c</td>
<td width=25%>/c</td>
<td width=50%>compile only, no link</td>
</tr>
<tr valign=top>
<td width=25%>/C</td>
<td width=25%>/C</td>
<td width=50%>preserve comments during preprocessing</td>
</tr>
<tr valign=top>
<td width=25%>/D&lt;name&gt;{=|#}&lt;text&gt;</td>
<td width=25%>/D&lt;name&gt;{=|#}&lt;text&gt;</td>
<td width=50%>define macro or constant</td>
</tr>
<tr valign=top>
<td width=25%>/E</td>
<td width=25%>/E</td>
<td width=50%>preprocess to stdout</td>
</tr>
<tr valign=top>
<td width=25%>/EP</td>
<td width=25%>/EP</td>
<td width=50%>preprocess to stdout, but no #line</td>
</tr>
<tr valign=top>
<td width=25%>/F&lt;num&gt; </td>
<td width=25%>/F&lt;num&gt; </td>
<td width=50%>set stack size</td>
</tr>
<tr valign=top>
<td width=25%>/Fa[file]</td>
<td width=25%>/Fa[file]</td>
<td width=50%>name assembly listing file</td>
</tr>
<tr valign=top>
<td width=25%>/FA&lt;s|c&gt; </td>
<td width=25%>/FA&lt;a|s|c&gt;</td>
<td width=50%>configure assembly listing, in CLAXP /FAa=/FAc</td>
</tr>
<tr valign=top>
<td width=25%>/Fd[file] </td>
<td width=25%>/Fd[file] </td>
<td width=50%>specify program database .PDB file</td>
</tr>
<tr valign=top>
<td width=25%>/Fe&lt;file&gt;</td>
<td width=25%>/Fe&lt;file&gt;</td>
<td width=50%>specify executable file</td>
</tr>
<tr valign=top>
<td width=25%>/FI[file],/Fc[file]</td>
<td width=25%>/FI[file]</td>
<td width=50%>specify forced include file, use /FAc, /FAcs</td>
</tr>
<tr valign=top>
<td width=25%>/Fm[file]</td>
<td width=25%>/Fm[file]</td>
<td width=50%>specify linker map file</td>
</tr>
<tr valign=top>
<td width=25%>/Fo&lt;file&gt;</td>
<td width=25%>/Fo&lt;file&gt;</td>
<td width=50%>specify object file</td>
</tr>
<tr valign=top>
<td width=25%>/Fp&lt;file&gt;</td>
<td width=25%>/Fp&lt;file&gt;</td>
<td width=50%>specify precompiled header file</td>
</tr>
<tr valign=top>
<td width=25%>/Fr[file]</td>
<td width=25%>/Fr[file]</td>
<td width=50%>specify source browser file</td>
</tr>
<tr valign=top>
<td width=25%>/FR[file]</td>
<td width=25%>/FR[file]</td>
<td width=50%>specify extended .SBR file</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/G3</td>
<td width=50%>optimize for 80386</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/G4</td>
<td width=50%>optimize for 80486 (default)</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/G5</td>
<td width=50%>optimize for Pentium</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/Gd</td>
<td width=50%>__cdecl calling convention</td>
</tr>
<tr valign=top>
<td width=25%>/Ge</td>
<td width=25%>/Ge</td>
<td width=50%>enable stack checking calls (default)</td>
</tr>
<tr valign=top>
<td width=25%>/Gf</td>
<td width=25%>/Gf</td>
<td width=50%>enable string pooling</td>
</tr>
<tr valign=top>
<td width=25%>/Gh</td>
<td width=25%>/Gh</td>
<td width=50%>enable hook __penter function call</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/Gr</td>
<td width=50%>__fastcall calling convention</td>
</tr>
<tr valign=top>
<td width=25%>/Gs[num]</td>
<td width=25%>/Gs[num]</td>
<td width=50%>disable stack checking calls</td>
</tr>
<tr valign=top>
<td width=25%>/Gt&lt;n&gt;</td>
<td width=25%>/Gt&lt;n&gt;</td>
<td width=50%>threshold for gp-relative data</td>
</tr>
<tr valign=top>
<td width=25%>/Gy</td>
<td width=25%>/Gy</td>
<td width=50%>separate functions for linker</td>
</tr>
<tr valign=top>
<td width=25%>/Gz</td>
<td width=25%>/Gz</td>
<td width=50%>__stdcall calling convention</td>
</tr>
<tr valign=top>
<td width=25%>/H&lt;num&gt;</td>
<td width=25%>/H&lt;num&gt;</td>
<td width=50%>max external name length</td>
</tr>
<tr valign=top>
<td width=25%>/I&lt;dir&gt;</td>
<td width=25%>/I&lt;dir&gt;</td>
<td width=50%>add to include search path</td>
</tr>
<tr valign=top>
<td width=25%>/J</td>
<td width=25%>/J</td>
<td width=50%>default char type is unsigned</td>
</tr>
<tr valign=top>
<td width=25%>/link</td>
<td width=25%>/link</td>
<td width=50%>linker control options</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/LD</td>
<td width=50%>create .DLL</td>
</tr>
<tr valign=top>
<td width=25%>/MD</td>
<td width=25%>/MD</td>
<td width=50%>link with MSVCRT.LIB</td>
</tr>
<tr valign=top>
<td width=25%>/MD</td>
<td width=25%>/ML</td>
<td width=50%>link with LIBC.LIB</td>
</tr>
<tr valign=top>
<td width=25%>/nologo</td>
<td width=25%>/nologo</td>
<td width=50%>logo suppress copyright message</td>
</tr>
<tr valign=top>
<td width=25%>/O</td>
<td width=25%>not available</td>
<td width=50%>maximum speed, /Oi /Ob2 or O2</td>
</tr>
<tr valign=top>
<td width=25%>/O1</td>
<td width=25%>/O1</td>
<td width=50%>minimize space </td>
</tr>
<tr valign=top>
<td width=25%>/O2</td>
<td width=25%>/O2</td>
<td width=50%>maximize speed (same as /O)</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/Oa</td>
<td width=50%>assume no aliasing</td>
</tr>
<tr valign=top>
<td width=25%>/Ob&lt;0|1|2&gt; </td>
<td width=25%>/Ob&lt;0|1|2&gt; </td>
<td width=50%>inline expansion (default n=0)</td>
</tr>
<tr valign=top>
<td width=25%>/Od</td>
<td width=25%>/Od</td>
<td width=50%>disable optimizations (default if /Zi and no /O*)</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/Og</td>
<td width=50%>enable global optimization</td>
</tr>
<tr valign=top>
<td width=25%>/Oi[-]</td>
<td width=25%>/Oi[-]</td>
<td width=50%>enable intrinsic functions (default=Oi-)?</td>
</tr>
<tr valign=top>
<td width=25%>/Op[-]</td>
<td width=25%>/Op[-]</td>
<td width=50%>improve floating-pt consistency (decrease performance)</td>
</tr>
<tr valign=top>
<td width=25%>CLAXP</td>
<td width=25%>CL386</td>
<td width=50%>Description</td>
</tr>
<tr valign=top>
<td width=25%>not available (see /O1)</td>
<td width=25%>/Os</td>
<td width=50%>minimize space</td>
</tr>
<tr valign=top>
<td width=25%>not available (see /O2)</td>
<td width=25%>/Ot</td>
<td width=50%>maximize speed</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/Ow</td>
<td width=50%>assume cross-function aliasing</td>
</tr>
<tr valign=top>
<td width=25%>/Ox</td>
<td width=25%>/Ox</td>
<td width=50%>maximum opts (/Ogityb1 /Gs for CL386, /Oi /Ob2 for CLAXP)</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/Oy[-] </td>
<td width=50%>enable frame pointer omission</td>
</tr>
<tr valign=top>
<td width=25%>/P</td>
<td width=25%>/P</td>
<td width=50%>preprocess to file</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/QmipsGx</td>
<td width=50%>generate MIPS-specific instructions</td>
</tr>
<tr valign=top>
<td width=25%>/QAgl</td>
<td width=25%>not available</td>
<td width=50%>generate fetches and stores in units of longword</td>
</tr>
<tr valign=top>
<td width=25%>/QAgq</td>
<td width=25%>not available</td>
<td width=50%>generate fetches and stores in units of quadword</td>
</tr>
<tr valign=top>
<td width=25%>/QAieee, /QAieee1</td>
<td width=25%>not available</td>
<td width=50%>IEEE floating point NaNs, infinities, and denormals support</td>
</tr>
<tr valign=top>
<td width=25%>/QAieee0</td>
<td width=25%>not available</td>
<td width=50%>disable IEEE floating point support</td>
</tr>
<tr valign=top>
<td width=25%>/QAieee2</td>
<td width=25%>not available</td>
<td width=50%>/QAieee1 and IEEE Inexact Operation exception support</td>
</tr>
<tr valign=top>
<td width=25%>/Tc&lt;source file&gt; </td>
<td width=25%>/Tc&lt;source file&gt; </td>
<td width=50%>compile file as .c</td>
</tr>
<tr valign=top>
<td width=25%>/Tp&lt;source file&gt;</td>
<td width=25%>/Tp&lt;source file&gt;</td>
<td width=50%>compile file as .cpp</td>
</tr>
<tr valign=top>
<td width=25%>/u</td>
<td width=25%>/u</td>
<td width=50%>remove all predefined macros</td>
</tr>
<tr valign=top>
<td width=25%>/U&lt;name&gt;</td>
<td width=25%>/U&lt;name&gt;</td>
<td width=50%>remove predefined macro</td>
</tr>
<tr valign=top>
<td width=25%>/V&lt;string&gt;</td>
<td width=25%>/V&lt;string&gt;</td>
<td width=50%>set version string</td>
</tr>
<tr valign=top>
<td width=25%>/vd&lt;0|1&gt; </td>
<td width=25%>/vd&lt;0|1&gt; </td>
<td width=50%>disable/enable vtordisp</td>
</tr>
<tr valign=top>
<td width=25%>/vmb</td>
<td width=25%>/vmb</td>
<td width=50%>best case for pointers to class members</td>
</tr>
<tr valign=top>
<td width=25%>/vmg</td>
<td width=25%>/vmg</td>
<td width=50%>full generality for pointers to class members</td>
</tr>
<tr valign=top>
<td width=25%>/vms</td>
<td width=25%>/vms</td>
<td width=50%>define single inheritance</td>
</tr>
<tr valign=top>
<td width=25%>/vmm</td>
<td width=25%>/vmm</td>
<td width=50%>define multiple inheritance</td>
</tr>
<tr valign=top>
<td width=25%>/vmv</td>
<td width=25%>/vmv</td>
<td width=50%>define virtual inheritance</td>
</tr>
<tr valign=top>
<td width=25%>/w,/W0</td>
<td width=25%>/w,/W0</td>
<td width=50%>disable all warnings</td>
</tr>
<tr valign=top>
<td width=25%>/W&lt;n&gt;</td>
<td width=25%>/W&lt;n&gt;</td>
<td width=50%>set warning level (default n=1)</td>
</tr>
<tr valign=top>
<td width=25%>/WX</td>
<td width=25%>/WX</td>
<td width=50%>treat warnings as errors</td>
</tr>
<tr valign=top>
<td width=25%>/X</td>
<td width=25%>/X</td>
<td width=50%>ignore standard include directories</td>
</tr>
<tr valign=top>
<td width=25%>/Yc[file]</td>
<td width=25%>/Yc[file]</td>
<td width=50%>create .PCH file</td>
</tr>
<tr valign=top>
<td width=25%>/Yd</td>
<td width=25%>/Yd</td>
<td width=50%>put debug info in every .OBJ</td>
</tr>
<tr valign=top>
<td width=25%>/Yu</td>
<td width=25%>/Yu</td>
<td width=50%>use .PCH file</td>
</tr>
<tr valign=top>
<td width=25%>/YX[file]</td>
<td width=25%>/YX[file]</td>
<td width=50%>automatic .PCH</td>
</tr>
<tr valign=top>
<td width=25%>/Z7</td>
<td width=25%>/Z7</td>
<td width=50%>C7 style CodeView information</td>
</tr>
<tr valign=top>
<td width=25%>/Za</td>
<td width=25%>/Za</td>
<td width=50%>ANSI compatibility (implies /Op)</td>
</tr>
<tr valign=top>
<td width=25%>/Zd</td>
<td width=25%>/Zd</td>
<td width=50%>debugging information</td>
</tr>
<tr valign=top>
<td width=25%>/Ze</td>
<td width=25%>/Ze</td>
<td width=50%>enable extensions (default)</td>
</tr>
<tr valign=top>
<td width=25%>/Zg</td>
<td width=25%>/Zg</td>
<td width=50%>generate function prototypes</td>
</tr>
<tr valign=top>
<td width=25%>/Zh</td>
<td width=25%>/Zh</td>
<td width=50%>home arguments (low-level debugging)</td>
</tr>
<tr valign=top>
<td width=25%>/Zi</td>
<td width=25%>/Zi</td>
<td width=50%>prepare for debugging (CodeView I information for <i>windbg</i>)</td>
</tr>
<tr valign=top>
<td width=25%>not available</td>
<td width=25%>/Zl</td>
<td width=50%>omit default library name in .OBJ</td>
</tr>
<tr valign=top>
<td width=25%>/Zn</td>
<td width=25%>/Zn</td>
<td width=50%>turn off SBRPACK for .SBR files</td>
</tr>
<tr valign=top>
<td width=25%>/Zp[n]</td>
<td width=25%>/Zp[n]</td>
<td width=50%>pack structs on n-byte boundary</td>
</tr>
<tr valign=top>
<td width=25%>/Zs</td>
<td width=25%>/Zs</td>
<td width=50%>syntax check only</td>
</tr>
</table><br>
<h2>Appendix B. Data Type Comparison</h2>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=44%><b>Data Type (byte)</b></td>
<td class=label width=31%><b>Alpha AXP</b></td>
<td class=label width=25%><b>Intel X86</b></td>
</tr>
<tr valign=top>
<td width=44%>char</td>
<td width=31%>1</td>
<td width=25%>1</td>
</tr>
<tr valign=top>
<td width=44%>unsigned char </td>
<td width=31%>1</td>
<td width=25%>1</td>
</tr>
<tr valign=top>
<td width=44%>short</td>
<td width=31%>2</td>
<td width=25%>2</td>
</tr>
<tr valign=top>
<td width=44%>unsigned short</td>
<td width=31%>2</td>
<td width=25%>2</td>
</tr>
<tr valign=top>
<td width=44%>int</td>
<td width=31%>4</td>
<td width=25%>4</td>
</tr>
<tr valign=top>
<td width=44%>unsigned int</td>
<td width=31%>4</td>
<td width=25%>4</td>
</tr>
<tr valign=top>
<td width=44%>long</td>
<td width=31%>4</td>
<td width=25%>4</td>
</tr>
<tr valign=top>
<td width=44%>unsigned long</td>
<td width=31%>4</td>
<td width=25%>4</td>
</tr>
<tr valign=top>
<td width=44%>void *</td>
<td width=31%>4</td>
<td width=25%>4</td>
</tr>
<tr valign=top>
<td width=44%>char *</td>
<td width=31%>4&nbsp;&nbsp; </td>
<td width=25%>4</td>
</tr>
<tr valign=top>
<td width=44%>float</td>
<td width=31%>4 </td>
<td width=25%>4</td>
</tr>
<tr valign=top>
<td width=44%>double</td>
<td width=31%>8</td>
<td width=25%>8</td>
</tr>
<tr valign=top>
<td width=44%>long double</td>
<td width=31%>8</td>
<td width=25%>10</td>
</tr>
</table><br>
<p>
All data types are identical except for long double.</p>
<h2>Appendix C. Data Type Natural Alignment</h2>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=39%><b>Data Type</b></td>
<td class=label width=61%><b>Alignment Starting Position</b></td>
</tr>
<tr valign=top>
<td width=39%>8-bit character string</td>
<td width=61%>Byte boundary</td>
</tr>
<tr valign=top>
<td width=39%>16-bit integer</td>
<td width=61%>Address that is a multiple of 2 (word alignment)</td>
</tr>
<tr valign=top>
<td width=39%>32-bit integer</td>
<td width=61%>Address that is a multiple of 4 (longword alignment)</td>
</tr>
<tr valign=top>
<td width=39%>64-bit integer</td>
<td width=61%>Address that is a multiple of 8 (quadword alignment)</td>
</tr>
<tr valign=top>
<td width=39%>IEEE floating single S</td>
<td width=61%>Address that is a multiple of 4 (longword alignment)</td>
</tr>
<tr valign=top>
<td width=39%>IEEE floating double T</td>
<td width=61%>Address that is a multiple of 8 (quadword alignment)</td>
</tr>
<tr valign=top>
<td width=39%>IEEE floating extended X</td>
<td width=61%>Address that is a multiple of 16 (octaword alignment)</td>
</tr>
<tr valign=top>
<td width=39%>IEEE floating single S complex</td>
<td width=61%>Address that is a multiple of 4 (longword alignment)</td>
</tr>
<tr valign=top>
<td width=39%>IEEE floating double T complex</td>
<td width=61%>Address that is a multiple of 8 (quadword alignment)</td>
</tr>
<tr valign=top>
<td width=39%>IEEE floating extended X complex</td>
<td width=61%>Address that is a multiple of 16 (octaword alignment)</td>
</tr>
</table><br>
<h2>Additional Reading</h2>
<p>
In addition to this article, the following documents will help you in porting your application from Windows NT for Intel X86 to Alpha AXP:</p>
<p>
Microsoft <i>Win32 Software Development Kit for Alpha AXP</i>, on \mstools\bin\axpnotes.txt.</p>
<p>
Microsoft <i>Win32 Software Development Kit for Alpha AXP</i>, on \mstools\bin\claxp.txt.</p>
<p>
Microsoft <i>Win32 Software Development Kit for Alpha AXP</i>, on \mstools\bin\asaxp.txt.</p>
<p>
Microsoft <i>Win32 Software Development Kit for Alpha AXP</i>, on \mstools\bin\wap.txt.</p>
<p>
<i>Windows NT for Alpha AXP Calling Standards</i>, Digital Equipment Corporation, Rev 1.7, January 1994.</p>
<p>
Russ Blake, <i>Optimizing Windows NT</i>, Microsoft Corporation, Summer 1993.</p>
<p>
Microsoft<i> Win32 SDK</i> version 3.5, <i>Tools User's Guide, </i>Microsoft Corporation, 1993.</p>
<p>
********************</p>
<p>
Copyright 1994 Digital Equipment Corporation. All rights reserved. Restricted rights: Use, duplication, or disclosure by the U.S. Government is subject to restrictions as set forth in subparagraph (c)(1)(ii) of the Rights in Technical Data and Computer Software clause at DFARS 252.227-7013.</p>
<p>
The information in this document is subject to change without notice and should not be construed as a commitment by Digital Equipment Corporation. Digital Equipment Corporation assumes no responsibility for any errors that may appear in this document.<br>
This software described in this document is furnished under a license and may be used or copied only in accordance with the terms of such license.<br>
No responsibility is assumed for the use or reliability of software on equipment that is not supplied by Digital or its affiliated companies.</p>
<p>
Alpha AXP, DEC C, DEC FORTRAN, DEC OSF/1, Open VMS, ULTRIX, and VAX are trademarks of Digital Equipment Corporation.<br>
Intel is a trademark of Intel Corporation.<br>
CodeView, Microsoft, Microsoft Press, MS-DOS, and Windows are registered trademarks and Windows NT and Visual C++ are trademarks of Microsoft Corporation.<br>
All other trademarks and registered trademarks are the property of their respective holders.</p>
</BODY>
</HTML>
