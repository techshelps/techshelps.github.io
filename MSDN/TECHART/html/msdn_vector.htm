<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Use of Two-Dimensional Vectors with Windows NT</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_vector"></a></sup>Use of Two-Dimensional Vectors with Windows NT</h1>
<p>
Dennis Crain<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: December 1, 1993</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="1918">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the VECTOR2D sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article discusses two-dimensional vectors and their use in graphics, and basic vector operations. Their implementation is provided in C. The article also includes a typical application (finding the point nearest a line) that uses vectors to illustrate the utility of vectors and operations on vectors. A Microsoft® Windows NT™ dynamic-link library (DLL) and source code implement a basic library of two-dimensional vector operations.</p>
<h2>Introduction</h2>
<p>
From its inception, the Microsoft® Windows™ operating system has provided basic two-dimensional graphics capabilities such as clipping, line drawing, shapes such as polygons, and so on. The Windows NT™ operating system takes this capability a step further by including two-dimensional transformations to rotate, scale, translate, shear, and reflect graphics objects as well as Bézier curves and wide pens. This is great, but there are still a ton of things that a graphics application must do itself to achieve respectability.</p>
<p>
For example, how do you determine the distance of a given point from a line or a curve? How do you determine the reflection of a ray from a surface? One thing these questions have in common is that they both can be solved by using vectors and operations on those vectors. This article discusses the basics of two-dimensional vectors and vector operations. A C implementation of these concepts is provided in the body of the article and as sample code implementing the vector operations in a Windows NT dynamic-link library (DLL). View this article and its associated code as a first step to building a significant library of graphics tools that will allow you to write that fully featured, two-dimensional graphics application. Future articles will deal with more advanced graphics topics that use the vector operations discussed in this article.</p>
<h2>Vectors 101: What Is a Vector?</h2>
<p>
If you are thinking "Just what is a vector?", this section is for you! It's really not uncommon to wonder what a vector is. If your graphics programming experience has been limited to Windows and your application development did not involve graphics editors of one sort or another, you probably have never dealt with vectors. I will not attempt to describe vectors exhaustively; you can find the details in countless textbooks on the subject. I will describe them to such a point of understanding that we can move on to the practical use of vectors within a two-dimensional graphics application.</p>
<p>
An important distinction to make up-front is that a vector is not a point, although the representation is similar for both. For example, a point, <i>p</i>, is typically described using an ordered pair of numbers, for example <i>p</i> = (100, 200). This is commonly interpreted as the point located 100 units in the x direction and 200 units in the y direction from some well-defined and consistent origin. The vector <b><i>p</i></b> (denoted as a vector by using bold text), where <b><i>p</i></b> = (100, 200), is interpreted very differently. The vector describes <i>displacement</i>. It may originate anywhere in the coordinate system. In this example, the vector is displaced 100 units in the x direction and 200 units in the y direction from some arbitrary point.</p>
<p>
Figures 1 and 2 illustrate these concepts. In Figure 1, a line segment is drawn between the two points. In my attempt to distinguish between points and vectors, the important thing to note is that the points are positions within a coordinate system denoted by the ordered pairs (1, 1) and (2, 2).</p>
<p>
<img src="vector_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Line segment between the points (1, 1) and (2, 2)</b></p>
<p>
Figure 2 shows the vector defined by the same two points—(1, 1) and (2, 2). Because vectors describe displacement, the vector can be represented by the 2-tuple (1, 1). That is, the vector is displaced 1 unit in the x direction and 1 unit in the y direction.</p>
<p>
<img src="vector_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Vector associated with the points (1, 1) and (2, 2)</b></p>
<p>
That brings us to a very useful definition of a vector. The vector <b><i>p</i></b> is defined by the difference between the two points used to place the vector in the coordinate space: <b><i>p</i></b> = (x2 - x1, y2 - y1). In the example above, the vector <b><i>p</i></b> = (2 - 1, 2 - 1), which is simply (1, 1). The vector <b><i>p</i></b> in figure 2 is said to be bound to the point (1, 1), although, as Figure 3 illustrates, this vector could easily be bound to any point in the coordinate space. Note that all three vectors are described by the 2-tuple (1, 1).</p>
<p>
<img src="vector_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Vectors may be bound to any point</b></p>
<p>
So much for what a vector is and what it isn't. Let's move on to the various operations that can be performed on vectors.</p>
<h2>The Vector Space</h2>
<p>
Vector space? As in "beam me up"? Not quite. As Foley et al. explain it, the vector space is a set composed of vectors upon which addition and scalar multiplication can take place. There are tons of analogies that can give you a sense of what the vector space is. You may want to insert your own at this point. Here are a few of my favorites: Think of the vector space as a croquet court. The vectors are represented by the motion of the balls as you hit them. Vector addition takes place when you place your ball next to your opponent's and smack it 50 feet in the opposite direction. Or there is the pool table analogy. Forget the balls for a moment. Just consider the pool cue. The pool cue has a length, as does a vector. Like a vector, the pool cue is bound to an origin that moves around the table as you try to line up shots. This example helps you think of the vector space in terms of a plane. This should give you a feel for the vector space. So as not to belabor it, let's move on to the motivation for using vectors.</p>
<h2>Why Use Vectors?</h2>
<p>
Good question. I have some simple answers. Vectors are convenient. They allow you to do complex things using simple concepts. This simplicity is derived from the fact that, through vectors, many geometric concepts can be expressed algebraically with little consideration of the coordinate system. Vectors simplify your life. Once you have written a vector library, solutions to various graphics problems are reduced to creative use of the functions in your library.</p>
<h2>Vector Operations</h2>
<p>
Remember what I said about the vector space? It includes addition and scalar multiplication of vectors. These are the two basic operations from which all vector use is derived. This section discusses vector addition, multiplication, and a few other operations. But remember, each additional operation is simply a use of the two operations found in the vector space—addition and multiplication.</p>
<p>
Before jumping off into each operation, let's define the structure used to define a two-dimensional vector in this article and used in the C implementation of each operation. The following structure is composed of two values, the x and y components of the vector. These are doubled to permit the use of real number values. Real numbers are required to fulfill the requirement of scalar multiplication (multiplication by real numbers) in the vector space.</p>
<pre><code>typedef struct tagVECTOR2D&nbsp; {
  double&nbsp;&nbsp;&nbsp;&nbsp; x;
  double&nbsp;&nbsp;&nbsp;&nbsp; y;
} VECTOR2D, *PVECTOR2D;
</code></pre>
<p>
Throughout much of this article I will use two vectors, <b><i>a</i></b> and <b><i>b</i></b>. The <b><i>a</i></b> vector is represented by the 2-tuple (4, 5). The <b><i>b</i></b> vector is represented by the 2-tuple (2, 3).</p>
<h3>Addition of Vectors</h3>
<p>
Vectors may be added to one another. The vector obtained by the addition of two vectors is nothing more than the sum of the components. This is easily represented as follows: Given two vectors, <b>a</b> and <b>b</b>, the resultant vector <b><i>c</i></b> = (<b><i>a</i></b>1 + <b><i>b</i></b>1, <b><i>a</i></b>2 + <b><i>b</i></b>2). Using the previously assigned 2-tuples for these vectors, <b>c</b> = (4 + 2, 5 + 3) = (6, 8).</p>
<p>
This operation can be implemented in the following code. The parameters <i>v0</i> and <i>v1</i> are pointers to <b>VECTOR2D</b> structures that contain the two vectors to be added. The resulting vector is placed in the parameter <i>v</i>, whose address is returned as an indication of the success of the operation.</p>
<pre><code>PVECTOR2D APIENTRY vAddVectors(PVECTOR2D v0, PVECTOR2D v1, PVECTOR2D v)
{
  if (v0 == NULL || v1 == NULL)
 &nbsp;&nbsp; v = (PVECTOR2D)NULL;
  else
  {
 &nbsp;&nbsp; v-&gt;x = v0-&gt;x + v1-&gt;x;
 &nbsp;&nbsp; v-&gt;y = v0-&gt;y + v1-&gt;y;
  }
  return(v);
}
</code></pre>
<p>
Figure 4 illustrates the addition of two vectors and the resultant vector. Note that vector addition is not simply a matter of adding the lengths together. That is vector multiplication. Vector addition is a "geometric sort of thing." The sum of the two vectors is a vector that is the sum of the displacements. If you draw a vector from the tail of <b>a</b> to the head of <b>b</b>, as in Figure 4, you can see that the displacement of the vector is the same as that derived algebraically.</p>
<p>
<img src="vector_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Addition of two vectors</b></p>
<h3>Multiplication of Vectors</h3>
<p>
Multiplication of vectors is the second operation required in the vector space. Vectors are most commonly multiplied to produce scaling, or what is known as the <i>dot product</i>. Scaling a vector simply increases the overall displacement of a vector by changing the x and y components of the vector by some scaling factor. The following code demonstrates scaling.</p>
<pre><code>PVECTOR2D APIENTRY vScaleVector(PVECTOR2D v0, double dScaling, PVECTOR2D v)
{
  if (v0 == NULL)
 &nbsp;&nbsp; v = (PVECTOR2D)NULL;
  else
  {
 &nbsp;&nbsp; if (dScaling != 0)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; v-&gt;x = (v0-&gt;x *= dScaling);
 &nbsp;&nbsp;&nbsp;&nbsp; v-&gt;y = (v0-&gt;y *= dScaling);
 &nbsp;&nbsp; }
  }
  return(v);
}
</code></pre>
<p>
Figure 5 illustrates the scaling of two vectors.</p>
<p>
<b><img src="vector_5.gif" border=0></b></p>
<p class=label>
<b>Figure 5. Scaling of two vectors</b></p>
<p>
The dot product of two vectors is the sum of the products of the components of the vectors. The dot product for the vectors <b><i>a</i></b> and <b><i>b</i></b> is <b><i>a</i></b>1 * <b><i>a</i></b>2 + <b><i>b</i></b>1 * <b><i>b</i></b>2. Given the sample vectors (4, 5) and (2, 3), the dot product is 4 * 2 + 5 * 3, or 23. This is easily implemented in the code that follows.</p>
<pre><code>double APIENTRY vDotProduct(PVECTOR2D v0, PVECTOR2D v1)
{
  double dotprod;

  dotprod = (v0 == NULL || v1 == NULL) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? 0.0 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (v0-&gt;x * v1-&gt;x) + (v0-&gt;y * v1-&gt;y);

  return(dotprod);
}
</code></pre>
<p>
Dot products are used frequently in graphics—to determine the angle between vectors, to determine if two vectors are perpendicular, and to decompose a vector into its components. This decomposition (that reminds me of a joke about Beethoven) is what we will use in the next section, which deals with a common problem—selecting a line in a graphics application with a mouse.</p>
<p>
This covers the two operations essential to vectors and fulfills the definition of a vector space. Let's now take a look at useful operations derived from the use of vector addition and scalar multiplication.</p>
<h3>Subtraction of Vectors</h3>
<p>
No rocket science here. Most of us would agree that subtraction is merely addition with a different outlook on life!</p>
<pre><code>PVECTOR2D APIENTRY vSubtractVectors(PVECTOR2D v0, PVECTOR2D v1, PVECTOR2D v)
{
  if (v0 == NULL || v1 == NULL)
 &nbsp;&nbsp; v = (PVECTOR2D)NULL;
  else
  {
 &nbsp;&nbsp; v-&gt;x = v0-&gt;x - v1-&gt;x;
 &nbsp;&nbsp; v-&gt;y = v0-&gt;y - v1-&gt;y;
  }
  return(v);
}
</code></pre>
<h3>The Length of a Vector</h3>
<p>
The length or magnitude of a vector is the distance from the head of the vector to the tail of the vector. Distance is the operative word here. Remember the Pythagorean theorem? It asserts that the distance between two points can be obtained by the following formula:</p>
<p>
<img src="vector_6.gif" border=0></p>
<p>
If you have doubts, take a look at a math textbook. Because the components of a two-dimensional vector are the differences between two points, this formula can be restated as follows, given the vector <b><i>a</i></b>:</p>
<p>
<img src="vector_7.gif" border=0></p>
<p>
This relationship is easily implemented in the following code.</p>
<pre><code>double APIENTRY vVectorMagnitude(PVECTOR2D v0)
{
  double dMagnitude;

  if (v0 == NULL)
 &nbsp;&nbsp; dMagnitude = 0.0;
  else
 &nbsp;&nbsp; dMagnitude = sqrt(vVectorSquared(v0));
  return (dMagnitude);
}
</code></pre>
<h3>Finding the Distance from a Point to a Line</h3>
<p>
Let's say you have a really cool application that draws lines on the screen. The product specification states that you must be able to move these lines with a mouse. So, how do you know when you are clicking on the line? The rectangle bounding the line (determined by the endpoints of the line) lets you know that you are "close." That is a great way to indicate that you are even looking for a line, but it is just not good enough for accurately selecting a line. You could try to recall some of that wonderful trigonometry stuff that you learned in high school. You could do something really stupid, like testing the color of the pixel. Or you could use those vectors!</p>
<p>
This technique involves resolving the vector between one of the endpoints of the line and the point at which the mouse click occurred into its components. One of the components of this vector is another vector that is perpendicular to the line and passes though the mouse point. The length (or magnitude) of this vector is the distance from the point to the line. Figure 6 illustrates the projection of the "mouse" vector <b><i>a</i></b> onto the line and the perpendicular "normal" vector. It is the length of that vector that determines the distance between the point and the line.</p>
<p>
<img src="vector_8.gif" border=0></p>
<p class=label>
<b>Figure 6. Vectors used to find distance between point and line</b></p>
<p>
Let's take a look at the code.</p>
<pre><code>void APIENTRY vProjectAndResolve(PVECTOR2D v0, PVECTOR2D v1, PPROJECTION ppProj)
{
  VECTOR2D ttProjection, ttOrthogonal;
  double proj1;
  //
  //obtain projection vector - v0 onto v1
  //
  //c = a * b
  //&nbsp;&nbsp;&nbsp; ----- b
  //&nbsp;&nbsp;&nbsp; |b|^2
  //
  proj1 = vDotProduct(v0, v1)/vDotProduct(v1, v1);
  ttProjection.x = v1-&gt;x * proj1;
  ttProjection.y = v1-&gt;y * proj1;
  //
  //obtain perpendicular projection : e = a - c
  //
  vSubtractVectors(v0, &amp;ttProjection, &amp;ttOrthogonal);
  //
  //fill PROJECTION structure with appropriate values
  //
  ppProj-&gt;LenProjection = vVectorMagnitude(&amp;ttProjection);
  ppProj-&gt;LenPerpProjection = vVectorMagnitude(&amp;ttOrthogonal);

  ppProj-&gt;ttProjection.x = ttProjection.x;
  ppProj-&gt;ttProjection.y = ttProjection.y;
  ppProj-&gt;ttPerpProjection.x = ttOrthogonal.x;
  ppProj-&gt;ttPerpProjection.y = ttOrthogonal.y;
}
</code></pre>
<h3>VECTOR2D.DLL</h3>
<p>
VECTOR2D.DLL is a dynamic-link library for Windows NT. It includes all of the functions described in this article—and some functions not discussed in the article. The source code is included. You may use the DLL as-is or add functions to it.</p>
<p>
The following macro and functions are contained within the DLL.</p>
<h4>POINTS2VECTOR2D</h4>
<p>
The <b>POINTS2VECTOR2D</b> macro converts two points to a two-dimensional vector.</p>
<p>
<b>Syntax</b></p>
<pre><code>POINTS2VECTOR2D(pt0, pt1, vect)
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=8%><i>pt0</i></td>
<td width=92%>A <b>POINT</b> structure containing the first coordinate of the two-dimensional vector.</td>
</tr>
<tr valign=top>
<td width=8%><i>pt1</i></td>
<td width=92%>A <b>POINT</b> structure containing the second coordinate of the two-dimensional vector.</td>
</tr>
<tr valign=top>
<td width=8%><i>vect</i></td>
<td width=92%>A <b>VECTOR2D</b> structure in which the <i>x</i> and <i>y</i> components of the two-dimensional vector are placed.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
None.</p>
<h4>vAddVectors</h4>
<p>
The <b>vAddVectors</b> function adds the components of one two-dimensional vector to another. The resultant vector <b><i>c</i></b> = (<b><i>a</i></b>1 + <b><i>b</i></b>1, <b><i>a</i></b>2 + <b><i>b</i></b>2).</p>
<p>
<b>Syntax</b></p>
<pre><code>PVECTOR2D vAddVectors(PVECTOR2D v0, PVECTOR2D v1, PVECTOR2D v);
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=7%><i>v0</i></td>
<td width=93%>A pointer to a <b>VECTOR2D</b> structure containing the components of the first two-dimensional vector.</td>
</tr>
<tr valign=top>
<td width=7%><i>v1</i></td>
<td width=93%>A pointer to a <b>VECTOR2D</b> structure containing the components of the second two-dimensional vector.</td>
</tr>
<tr valign=top>
<td width=7%><i>v</i></td>
<td width=93%>A pointer to a <b>VECTOR2D</b> structure in which the components of the two-dimensional vector obtained from the addition of the first two are placed.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
A pointer to a <b>VECTOR2D</b> structure containing the new vector obtained from the addition of the first two parameters.</p>
<h4>vDistFromPointToLine</h4>
<p>
The <b>vDistFromPointToLine</b> function computes the distance from the point <i>ptTest</i> to the line defined by endpoints <i>pt0</i> and <i>pt1</i>. This is done by resolving the vector from <i>pt0</i> to <i>ptTest</i> into its components. The length of the component vector that is attached to the head of the vector from <i>pt0</i> to <i>ptTest</i> is the distance of <i>ptTest</i> from the line.</p>
<p>
<b>Syntax</b></p>
<pre><code>double vDistFromPointToLine(LPPOINT pt0, LPPOINT pt1, LPPOINT ptTest);
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=10%><i>pt0</i></td>
<td width=90%>A pointer to a <b>POINT</b> structure containing the first endpoint of the line.</td>
</tr>
<tr valign=top>
<td width=10%><i>pt1</i></td>
<td width=90%>A pointer to a <b>POINT</b> structure containing the second endpoint of the line.</td>
</tr>
<tr valign=top>
<td width=10%><i>ptTest</i></td>
<td width=90%>A pointer to a <b>POINT</b> structure containing the point for which the distance from the line is to be computed.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
A double value that contains the distance of <i>ptTest</i> to the line defined by the endpoints <i>pt0</i> and <i>pt1</i>.</p>
<h4>vDotProduct</h4>
<p>
The <b>vDotProduct</b> function computes the dot product of two vectors. The dot product of two vectors is the sum of the products of the components of the vectors; that is, for the vectors <b><i>a</i></b> and <b><i>b</i></b>, the dot product = <b><i>a</i></b>1 * <b><i>a</i></b>2 + <b><i>b</i></b>1 * <b><i>b</i></b>2.</p>
<p>
<b>Syntax</b></p>
<pre><code>double vDotProduct(PVECTOR2D v0, PVECTOR2D v1);
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=7%><i>v0</i></td>
<td width=93%>A pointer to a <b>VECTOR2D</b> structure containing the first vector used for obtaining a dot product.</td>
</tr>
<tr valign=top>
<td width=7%><i>v1</i></td>
<td width=93%>A pointer to a <b>VECTOR2D</b> structure containing the second vector used for obtaining a dot product.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
A double value containing the scalar dot product value.</p>
<h4>vIsPerpendicular</h4>
<p>
The <b>vIsPerpendicular</b> function determines if two vectors are perpendicular to one another by testing the dot product of the two vectors. If the dot product is zero, the vectors are perpendicular.</p>
<p>
<b>Syntax</b></p>
<pre><code>BOOL vIsPerpendicular(PVECTOR2D v0, PVECTOR2D v1);
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=8%><i>v0</i></td>
<td width=92%>A pointer to a <b>VECTOR2D</b> structure containing the first vector.</td>
</tr>
<tr valign=top>
<td width=8%><i>v1</i></td>
<td width=92%>A pointer to a <b>VECTOR2D</b> structure containing the second vector.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
TRUE if the two vectors are perpendicular; FALSE if the vectors are not perpendicular.</p>
<h4>vLinearCombination</h4>
<p>
The <b>vLinearCombination</b> function scales the components of two vectors and adds them together to form a new vector having the linear combination. The resultant vector where <i>u</i> and <i>v</i> are scaling factors and <b><i>a</i></b> and <b><i>b</i></b> are vectors is <b><i>c</i> = </b>u<b><i>a</i> + </b>v<b><i>b</i></b>.</p>
<p>
<b>Syntax</b></p>
<pre><code>PVECTOR2D vLinearCombination(PVECTOR2D ptScale, PVECTOR2D v0, PVECTOR2D v1,
 &nbsp; PVECTOR2D v);
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=10%><i>ptScale</i></td>
<td width=90%>A pointer to a <b>VECTOR2D</b> structure containing the scaling values.</td>
</tr>
<tr valign=top>
<td width=10%><i>v0</i></td>
<td width=90%>A pointer to a <b>VECTOR2D</b> structure containing the first of two vectors to be combined linearly.</td>
</tr>
<tr valign=top>
<td width=10%><i>v1</i></td>
<td width=90%>A pointer to a <b>VECTOR2D</b> structure containing the second of two vectors to be combined linearly. </td>
</tr>
<tr valign=top>
<td width=10%><i>v</i></td>
<td width=90%>A pointer to a <b>VECTOR2D</b> structure in which the results of linearly combining vectors <i>v0</i> and <i>v1</i> are stored.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
A pointer to a <b>VECTOR2D</b> structure containing a vector that is the result of the linear combination.</p>
<h4>vNormalizeVector</h4>
<p>
A normalized vector is a vector with a length of 1. The resultant vector is often called a <i>unit vector</i>. The <b>vNormalizeVector</b> function converts a vector into a normalized vector. To normalize a vector, the vector is scaled by the reciprocal of the magnitude of the vector: <b><i>c</i></b>n = <b><i>c</i></b> * 1/|<b><i>c</i></b>|.</p>
<p>
<b>Syntax</b></p>
<pre><code>void vNormalizeVector(PVECTOR2D v0);
</code></pre>
<p>
<b>Parameter</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=8%><i>v0</i></td>
<td width=92%>A pointer to a <b>VECTOR2D</b> structure containing the vector to normalize.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
Void.</p>
<h4>vNormalVector</h4>
<p>
The <b>vNormalVector</b> function computes the vector that is normal to a given vector. For the vector <b><i>a</i></b>, the normal vector <b><i>n</i></b> = (-<b><i>a</i></b>y, <b><i>a</i></b>x).</p>
<p>
<b>Syntax</b></p>
<pre><code>PVECTOR2D vNormalVector(PVECTOR2D v0, PVECTOR2D v);
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=6%><i>v0</i></td>
<td width=94%>A pointer to a <b>VECTOR2D</b> structure containing the vector for which a normal vector is sought.</td>
</tr>
<tr valign=top>
<td width=6%><i>v</i></td>
<td width=94%>A pointer to a <b>VECTOR2D</b> structure containing the computed normal vector.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
A pointer to a <b>VECTOR2D</b> structure containing the normal vector.</p>
<h4>vScaleVector</h4>
<p>
The <b>vScaleVector</b> function scales the components of a vector by a user-supplied scaling factor.</p>
<p>
<b>Syntax</b></p>
<pre><code>PVECTOR2D&nbsp; APIENTRY vScaleVector(PVECTOR2D v0, double dScaling, PVECTOR2D v);
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=11%><i>v0</i></td>
<td width=89%>A pointer to a <b>VECTOR2D</b> structure containing the components of the two-dimensional vector to be scaled.</td>
</tr>
<tr valign=top>
<td width=11%><i>dScaling</i></td>
<td width=89%>The value by which to scale the components of <i>v0</i>.</td>
</tr>
<tr valign=top>
<td width=11%><i>v</i></td>
<td width=89%>A pointer to a <b>VECTOR2D</b> structure in which the results of multiplying (scaling) the components of <i>v0</i> by <i>dScaling</i> are stored.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
A pointer to a <b>VECTOR2D</b> structure containing the scaled vector.</p>
<h4>vSubtractVectors</h4>
<p>
The <b>vSubtractVectors</b> function subtracts the components of one two-dimensional vector from another. The resultant vector <b><i>c</i></b> = (<b><i>a</i></b>1 - <b><i>b</i></b>1, <b><i>a</i></b>2 - <b><i>b</i></b>2).</p>
<p>
<b>Syntax</b></p>
<pre><code>PVECTOR2D vSubtractVectors(PVECTOR2D v0, PVECTOR2D v1, PVECTOR2D v);
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=8%><i>v0</i></td>
<td width=92%>A pointer to a <b>VECTOR2D</b> structure containing the components of the first two-dimensional vector.</td>
</tr>
<tr valign=top>
<td width=8%><i>v1</i></td>
<td width=92%>A pointer to a <b>VECTOR2D</b> structure containing the components of the second two-dimensional vector.</td>
</tr>
<tr valign=top>
<td width=8%><i>v</i></td>
<td width=92%>A pointer to a <b>VECTOR2D</b> structure in which the components of the two-dimensional vector obtained from the subtraction of the first two are placed.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
A pointer to a <b>VECTOR2D</b> structure containing the new vector obtained from the subtraction of the first two parameters.</p>
<h4>vPointNormalForm</h4>
<p>
The <b>vPointNormalForm</b> function computes the components of the point normal equation of a line in a plane vector that is normal to a given vector. For the vector <b><i>a</i></b>, the normal vector <b><i>n</i></b> = (-<b><i>a</i></b>y, <b><i>a</i></b>x).</p>
<p>
<b>Syntax</b></p>
<pre><code>BOOL vPointNormalForm(PVECTOR2D v0, PVECTOR2D v1, PPOINTNORMAL ppnPointNormal);
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=21%><i>v0</i></td>
<td width=79%>A pointer to a <b>VECTOR2D</b> structure containing the vector for which a normal vector is sought.</td>
</tr>
<tr valign=top>
<td width=21%><i>v1</i></td>
<td width=79%>A pointer to a <b>VECTOR2D</b> structure containing the computed normal vector.</td>
</tr>
<tr valign=top>
<td width=21%><i>ppnPointNormal</i></td>
<td width=79%>A pointer to a <b>VECTOR2D</b> structure to contain the normal vector.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
TRUE if the normal vector is computed successfully; FALSE if it is not.</p>
<h4>vProjectAndResolve</h4>
<p>
The <b>vProjectAndResolve</b> function resolves a vector into two vector components. The first is a vector obtained by projecting vector <i>v0</i> onto <i>v1</i>. The second is a vector that is perpendicular (normal) to the projected vector. It extends from the head of the projected vector <i>v1</i> to the head of the original vector <i>v0</i>.</p>
<p>
<b>Syntax</b></p>
<pre><code>void vProjectAndResolve(PVECTOR2D v0, PVECTOR2D v1, PPROJECTION ppProj);
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=10%><i>v0</i></td>
<td width=90%>A pointer to a <b>VECTOR2D</b> structure containing the vector for which a normal vector is sought.</td>
</tr>
<tr valign=top>
<td width=10%><i>v1</i></td>
<td width=90%>A pointer to a <b>VECTOR2D</b> structure containing the original line converted to a vector.</td>
</tr>
<tr valign=top>
<td width=10%><i>ppProj</i></td>
<td width=90%>A pointer to a <b>PROJECTION</b> structure containing the resolved vectors and their lengths.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
Void.</p>
<h4>vVectorAngle</h4>
<p>
The <b>vVectorAngle</b> function computes the cosine of the angle between two vectors.</p>
<p>
<b>Syntax</b></p>
<pre><code>double vVectorAngle(PVECTOR2D v0, PVECTOR2D v1);
</code></pre>
<p>
<b>Parameters</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=8%><i>v0</i></td>
<td width=92%>A pointer to a <b>VECTOR2D</b> structure containing the first vector.</td>
</tr>
<tr valign=top>
<td width=8%><i>v1</i></td>
<td width=92%>A pointer to a <b>VECTOR2D</b> structure containing the second vector.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
A double value indicating the cosine of the angle between the two vectors.</p>
<h4>vVectorMagnitude</h4>
<p>
The <b>vVectorMagnitude</b> function determines the length of a vector by summing the squares of each component of the vector. The magnitude is equal to <b><i>a</i></b>.x * <b><i>a</i></b>.x + <b><i>a</i></b>.y * <b><i>a</i></b>.y.</p>
<p>
<b>Syntax</b></p>
<pre><code>double vVectorMagnitude(PVECTOR2D v0);
</code></pre>
<p>
<b>Parameter</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=8%><i>v0</i></td>
<td width=92%>A pointer to a <b>VECTOR2D</b> structure containing the vector upon which to determine the magnitude.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
A double value that is the magnitude of the vector.</p>
<h4>vVectorSquared</h4>
<p>
The <b>vVectorSquared</b> function squares each component of the vector and adds them together to produce the squared value of the vector. SquaredValue = <b><i>a</i></b>.x * <b><i>a</i></b>.x + <b><i>a</i></b>.y * <b><i>a</i></b>.y.</p>
<p>
<b>Syntax</b></p>
<pre><code>double vVectorSquared(PVECTOR2D v0);
</code></pre>
<p>
<b>Parameter</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=6%><i>v0</i></td>
<td width=94%>A pointer to a <b>VECTOR2D</b> structure containing the vector upon which to determine the squared value.</td>
</tr>
</table><br>
<p>
<b>Return value</b></p>
<p>
A double value that is the squared value of the vector.</p>
<h2>Bibliography</h2>
<p>
<i>Computer Graphics</i>. Hill, F. S., Jr. 1990, Macmillan: New York, NY.</p>
<p>
<i>Computer Graphics: Principles and Practices</i> (2nd ed). Foley, J. D.; van Dam, A.; Feiner, S. K.; and Hughes, J. F. 1990, Addison-Wesley: Reading, MA.</p>
<p>
<i>Graphics Gems</i>. Glassner, A. S. (ed) 1990, Academic Press: San Diego, CA.</p>
</BODY>
</HTML>
