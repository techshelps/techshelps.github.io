<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NT Service: An OLE Control for Creating Windows NT Services in Visual Basic</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_ntsrvocx"></a></sup>NT Service: An OLE Control for Creating Windows NT Services in Visual Basic</h1>
<p>
Mauricio Ordóñez<br>
Microsoft Consulting Services</p>
<p>
June 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4920">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the NTSRVOCX sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes an OLE Control that enables developers to create Microsoft® Visual Basic® applications that function as Microsoft Windows NT® services. With the <b>NTService</b> control, you can install a service, log events, and respond to start, stop, pause, and continue events.</p>
<p>
The interface between the control and the operating system was based on the C++ class described in Nigel Thompson’s technical article <a href="msdn_ntservic.htm">“Creating a Simple Windows NT Service in C++,”</a> in the Microsoft Developer Network Library.</p>
<h2>Introduction</h2>
<p>
Microsoft® Windows NT® services are processes that run without requiring a user to be logged on to the system. Typically, we see such services being used for industrial-strength application servers, such as Microsoft SQL Server and Microsoft Exchange Server, or for parts of the operating system, as in the case of Dynamic Host Interface Protocol (DHCP) and Windows® Internet Name Service (WINS) servers.</p>
<p>
The services architecture also offers an attractive solution when you need an application to:
<ul type=disc>
<li>
Start when the operating system boots up even if no user is logged on.<br><br></li>
<li>
Start and stop the process remotely by authorized personnel such as domain administrators.<br><br></li>
<li>
Log on with an account in order to access domain resources with integrated security. Examples of these resources include Microsoft Exchange Server mailbox agents and data collection processes.</li>
</ul>
<p>
Previously, developers could write services only in C or C++. The operating system interface for services requires a callback function and blocks the main thread of execution. Because Visual Basic 4.0 has neither threads nor callback functions, developers cannot call these application programming interfaces (APIs) directly. Consequently, developers of Visual Basic applications relied on the SRVANY utility provided in the Windows NT Resource Kit. This tool allows any executable to be started by the system at boot time; however, because the communication between SRVANY and the application is limited to standard window messages, the solution is not very robust. Moreover, SRVANY lacks support for the <b>pause</b> and <b>continue</b> functions.</p>
<p>
The <b>NTService</b> OLE Control eliminates the need for helper processes like SRVANY by enabling Visual Basic applications to directly interface with the services’ APIs. The control translates signals from the operating system into events that can be processed by the Visual Basic application. It also provides support for functions that services typically require, such as installation and event logging.</p>
<h2>Creating a Service with Visual Basic</h2>
<p>
Creating a service begins by dropping the <b>NTService</b> control on a form. Services typically do not have any user interface, but in Visual Basic the control needs a form to serve as a container. At a minimum, you will need to set some properties and implement the installation routine and handlers for the <b>Start</b> and <b>Stop</b> events.</p>
<h3>Error Handling</h3>
<p>
Your service must never depend on being able to display user interface elements. For example, your code should prevent any message box from appearing that would require the user to clear it. If a message box appears while the service is not interactive, the process will wait indefinitely without anybody to clear the message box.</p>
<p>
The proper way to avoid this problem is to set <b>On Error</b> handlers on your service. Because you will probably be interested in seeing any errors that occur, you should use the event-logging function, <b>LogEvent</b>, to preserve error messages and conditions.</p>
<h3>Initialization</h3>
<p>
Your service will need to carry out installation, running, and removal. One way to accomplish this is by testing command-line parameters in the <b>Form</b> <b>Load</b> event (Figure 1). For example:
<ul type=disc>
<li>
<b>-install</b> installs the service.<br><br></li>
<li>
<b>-uninstall</b> removes the service.<br><br></li>
<li>
<b>-debug</b> enables the service to run from the development environment.</li>
</ul>
<p>
By default, the service will assume it is being started by the services controller to run as a service.</p>
<p>
<b>Figure 1. Service Initialization in Form Load Event</b></p>
<pre><code>Private Sub Form_Load()
 &nbsp;&nbsp; Dim strDisplayName As String

On Error Goto Err_Load

 &nbsp;&nbsp; strDisplayName = NTService1.DisplayName
 &nbsp;&nbsp; 
 &nbsp;&nbsp; If Command = "-install" Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Enable interaction with desktop.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NTService1.Interactive = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NTService1.Install Then
MsgBox strDisplayName &amp; " installed successfully"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox strDisplayName &amp; " failed to install"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ElseIf Command = "-uninstall" Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NTService1.Uninstall Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox strDisplayName &amp; " uninstalled successfully"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox strDisplayName &amp; " failed to uninstall"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ElseIf Command = "-debug" Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NTService1.Debug = True
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ElseIf Command &lt;&gt; "" Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "Invalid command option"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End
 &nbsp;&nbsp; 
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ' Connect service to Windows NT services controller.
 &nbsp;&nbsp; NTService1.StartService
 &nbsp;&nbsp; 
Err_Load:
 &nbsp;&nbsp; ' Error starting service
 &nbsp;&nbsp; 
End Sub
</code></pre>
<p>
To install the service, you need to set some properties at design or run time and call the <b>Install</b> method:
<ul type=disc>
<li>
<b>ServiceName</b> identifies the name of the service to be installed. You can also use this name to control the service with the <b>net</b> command.<br><br></li>
<li>
<b>DisplayName</b> specifies the name to be displayed by such user interface programs as the Windows NT Services Control Panel.</li>
</ul>
<p>
To run the service so that it can begin processing, call the <b>StartService</b> method. This method sets up the service framework that calls the <b>Start</b> event for initialization and the <b>Stop</b> event for shutdown.</p>
<h3>Events</h3>
<p>
At a minimum, your service needs to process the <b>Start</b> and <b>Stop</b> events. You can use these events to begin or halt processing in your service.</p>
<p>
The <b>Start</b> event (Figure 2) receives a Boolean parameter that must be set to True if the event was processed successfully. By default, the control will assume that the event is not handled or that an error has occurred.</p>
<p>
<b>Figure 2. Start Event Handler</b></p>
<pre><code>Private Sub NTService1_Start(Success As Boolean)

On Error Goto Err_Start

 &nbsp;&nbsp; ' TODO: Begin processing

 &nbsp;&nbsp; Success = True&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Report success

Err_Start:
 &nbsp;&nbsp; Call NTService1.LogEvent(svcMessageError, svcEventError, "[" &amp; _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err.Number &amp; "] " &amp; Err.Description)
End Sub
</code></pre>
<p>
The <b>Stop</b> event (Figure 3) is the signal indicating that the service should terminate. You are responsible for freeing resources and terminating your processing.</p>
<p>
<b>Figure 3. Stop Event Handler</b></p>
<pre><code>Private Sub NTService1_Stop()
On Error Goto Err_Stop

 &nbsp;&nbsp; ' TODO: Suspend processing and release resources
 &nbsp;&nbsp; 
 &nbsp;&nbsp; Unload Me&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' End process

Err_Stop:
 &nbsp;&nbsp; Call NTService1.LogEvent(svcMessageError, svcEventError, "[" &amp; _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err.Number &amp; "] " &amp; Err.Description)
End Sub
</code></pre>
<h3>Debugging</h3>
<p>
When the service starts, you need to determine if the service should attempt to communicate with the Windows NT services controller. The difference between a service and other processes is that the service communicates with the services controller. Otherwise, the same application could run as a console or graphical user interface (GUI) application.</p>
<p>
If you want to run the service from the Visual Basic development environment or from the console, you must set the <b>Debug</b> property to True. You will still need to call the <b>StartService</b> method in order to trigger the normal events.</p>
<p>
You may find it very useful to set the Advanced Options for the project to include this command-line parameter.</p>
<h2>Control Internals</h2>
<p>
Many of the details of creating services in C or C++ are well documented. These examples assume that the entire application is designed around the Windows NT service framework defined by the Win32® APIs. The <b>NTService</b> control must bridge the services interfaces with the Visual Basic application model, which presents some interesting challenges:</p>
<h3>Service Thread</h3>
<p>
During initialization, services call the <b>StartServiceCtrlDispatcher</b> API, passing a callback function that is used by the service controller for service initialization. The control cannot call the dispatcher function in a method because this function blocks the caller until the service is stopped. To solve this problem, the control creates a separate thread that is responsible for calling the dispatcher. This allows the primary thread used by Visual Basic to continue processing while the other thread is blocked by the services dispatcher.</p>
<p>
While the application is running as a service, events will fire from the service thread and the control request handler. Both of these functions execute on different thread contexts from the Visual Basic code. Because Visual Basic is not thread-safe, the apartment-model OLE control rules specify that all calls must occur in the same thread where the object was created. The effect on the <b>NTService</b> control is that it must transfer execution to the primary thread in order to generate notification events. This is done by posting window messages to the control’s invisible window and letting the window message dispatch loop inside Visual Basic transfer execution to the control.</p>
<p>
The control’s window is critical to the routing of messages from the services dispatcher to the Visual Basic application. Because OLE control containers have some discretion as to when the control window is created, the control informs the container that the window must exist always. This is done by marking the control with the <b>OLEMISC_SIMPLEFRAME</b> attribute and enabling the simple frame interface in the control constructor.</p>
<p>
The <b>StartService</b> method (Figure 4) checks the <b>Debug</b> property to determine if the service thread should be created. If the service was not started by the services controller, there is no need to call the dispatcher, so the control triggers the <b>Start</b> event immediately.</p>
<p>
<b>Figure 4. StartService Method</b></p>
<pre><code>BOOL CNtSvcCtrl::StartService()
{
 &nbsp;&nbsp; BOOL bSuccess = FALSE;

 &nbsp;&nbsp; // Initialize service status.
 &nbsp;&nbsp; m_Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
 &nbsp;&nbsp; m_Status.dwCurrentState = SERVICE_STOPPED;
 &nbsp;&nbsp; m_Status.dwControlsAccepted = SERVICE_ACCEPT_STOP |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_controlsAccepted;
 &nbsp;&nbsp; m_Status.dwWin32ExitCode = 0;
 &nbsp;&nbsp; m_Status.dwServiceSpecificExitCode = 0;
 &nbsp;&nbsp; m_Status.dwCheckPoint = 0;
 &nbsp;&nbsp; m_Status.dwWaitHint = 0;

 &nbsp;&nbsp; // In debug mode, don’t create a service thread.
 &nbsp;&nbsp; if (m_bIsDebug)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pThis-&gt;PostMessage(CWM_START, 0, 0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bSuccess = TRUE;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwThreadId;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a service thread to communicate with
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the services dispatcher.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_hServiceThread = CreateThread(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ServiceThread, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwThreadId);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_hServiceThread)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bSuccess = TRUE;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; return bSuccess;
}
</code></pre>
<p>
The service thread (Figure 5) exists solely for the purpose of making the blocking call to the dispatcher. The real initialization of the control takes place in the <b>ServiceMain</b> function.</p>
<p>
<b>Figure 5. Service Thread</b></p>
<pre><code>DWORD CNtSvcCtrl::ServiceThread(LPVOID)
{
 &nbsp;&nbsp; BOOL b;

 &nbsp;&nbsp; // Get a pointer to the C++ object.
 &nbsp;&nbsp; CNtSvcCtrl* pService = m_pThis;

 &nbsp;&nbsp; SERVICE_TABLE_ENTRY st[] = {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {m_pThis-&gt;m_szServiceName, ServiceMain},
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {NULL, NULL}
 &nbsp;&nbsp; };

 &nbsp;&nbsp; m_pThis-&gt;DebugMsg(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT("Calling StartServiceCtrlDispatcher()"));

 &nbsp;&nbsp; // Call the services dispatcher. This call blocks
 &nbsp;&nbsp; // until the service stops.
 &nbsp;&nbsp; b = ::StartServiceCtrlDispatcher(st);

 &nbsp;&nbsp; m_pThis-&gt;DebugMsg(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT("Returned from StartServiceCtrlDispatcher()"));

 &nbsp;&nbsp; return b;
}
</code></pre>
<h3>ServiceMain Function</h3>
<p>
The services dispatcher calls the <b>ServiceMain</b> function (Figure 6) with the expectation that the function will not return until the service has stopped. The function is responsible for:
<ul type=disc>
<li>
Registering the request handler and reporting status to the dispatcher.<br><br></li>
<li>
Notifying the Visual Basic application that the service started.<br><br></li>
<li>
Waiting for the <b>Stop</b> event to occur.</li>
</ul>
<p>
<b>Figure 6. ServiceMain Function</b></p>
<pre><code>void CNtSvcCtrl::ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
 &nbsp;&nbsp; // Get a pointer to the C++ object.
 &nbsp;&nbsp; CNtSvcCtrl* pService = m_pThis;

 &nbsp;&nbsp; pService-&gt;DebugMsg(TEXT("Entering CNtSvcCtrl::ServiceMain()"));

 &nbsp;&nbsp; // Register the control request handler.
 &nbsp;&nbsp; pService-&gt;m_Status.dwCurrentState = SERVICE_START_PENDING;
 &nbsp;&nbsp; pService-&gt;m_hServiceStatus = RegisterServiceCtrlHandler(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pService-&gt;m_szServiceName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Handler);

 &nbsp;&nbsp; if (pService-&gt;m_hServiceStatus == NULL) 
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pService-&gt;LogEvent(EVENTLOG_ERROR_TYPE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EVMSG_CTRLHANDLERNOTINSTALLED, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; pService-&gt;m_hStopEvent = CreateEvent(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp; // no security attributes
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE,&nbsp;&nbsp;&nbsp; // manual reset event
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE,&nbsp;&nbsp; // not-signaled
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);&nbsp;&nbsp; // no name

 &nbsp;&nbsp; // Notify the user that the service is starting.
 &nbsp;&nbsp; m_pThis-&gt;PostMessage(CWM_START, 0, 0);

 &nbsp;&nbsp; // The service thread will wait indefinitely until the service 
 &nbsp;&nbsp; // control manager or the user signals the stop event. 
 &nbsp;&nbsp; // This event is set inside the StopService method.
 &nbsp;&nbsp; WaitForSingleObject(m_pThis-&gt;m_hStopEvent, INFINITE);

 &nbsp;&nbsp; // Tell the service manager we are stopped.
 &nbsp;&nbsp; pService-&gt;SetStatus(SERVICE_STOPPED);
 &nbsp;&nbsp; pService-&gt;ReportStatus();

 &nbsp;&nbsp; pService-&gt;DebugMsg(TEXT("Leaving CNtSvcCtrl::ServiceMain()"));
}
</code></pre>
<p>
The <b>ServiceMain</b> function posts a message back to the control to indicate the start notification. This ensures that the control will fire the <b>Start</b> event from the primary thread without violating OLE threading rules.</p>
<h3>Request Handler Function</h3>
<p>
The services controller notifies the service via the request handler function (Figure 7) that was registered in the initialization phase. This function also executes in a different thread context—requiring transfer of execution with window messages.</p>
<p>
<b>Figure 7. Request handler function</b></p>
<pre><code>void CNtSvcCtrl::Handler(DWORD dwOpcode)
{
 &nbsp;&nbsp; // Get a pointer to the object.
 &nbsp;&nbsp; CNtSvcCtrl* pService = m_pThis;

 &nbsp;&nbsp; pService-&gt;DebugMsg("CNTService::Handler(%lu)", dwOpcode);
 &nbsp;&nbsp; switch (dwOpcode) {
 &nbsp;&nbsp; case SERVICE_CONTROL_STOP: // 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pService-&gt;SetStatus(SERVICE_STOP_PENDING);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case SERVICE_CONTROL_PAUSE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pService-&gt;SetStatus(SERVICE_PAUSE_PENDING);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Report current status.
 &nbsp;&nbsp; m_pThis-&gt;ReportStatus();

 &nbsp;&nbsp; // Defer message.
 &nbsp;&nbsp; m_pThis-&gt;PostMessage (CWM_HANDLER,dwOpcode, 0);
}

// Window message handler for CWM_HANDLER.
LRESULT CNtSvcCtrl::OnHandler(WPARAM wParam, LPARAM lParam)
{
 &nbsp;&nbsp; // Get a pointer to the C++ object.
 &nbsp;&nbsp; CNtSvcCtrl* pService = m_pThis;

 &nbsp;&nbsp; BOOL bSuccess = FALSE;

 &nbsp;&nbsp; // Report current status.
 &nbsp;&nbsp; ReportStatus();

 &nbsp;&nbsp; switch (wParam)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; case SERVICE_CONTROL_STOP: // 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pThis-&gt;StopService();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case SERVICE_CONTROL_PAUSE: // 2
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pService-&gt;FirePause(&amp;bSuccess);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bSuccess)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetStatus (SERVICE_PAUSED);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case SERVICE_CONTROL_CONTINUE: // 3
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pService-&gt;FireContinue(&amp;bSuccess);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bSuccess)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetStatus (SERVICE_RUNNING);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pService-&gt;FireControl(wParam);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Report current status.
 &nbsp;&nbsp; ReportStatus();

 &nbsp;&nbsp; return 0L;
}
</code></pre>
<h2>Uses</h2>
<p>
Just because your application is running as a service does not mean that it can handle the processing requirements of application servers such as Microsoft SQL Server or Microsoft Exchange Server. Visual Basic services are single-threaded and do not expose programming interfaces. The introduction of the Distributed Component Object Model (DCOM) in Windows NT version 4.0 will allow the service to be callable through OLE Automation interfaces locally or from a remote computer.</p>
<p>
The best use of this type of service is to augment application servers. For example, if you need to capture a real-time data broadcast in a SQL database, you could add Windows NT service support to make your application easier to administer. Likewise, you could write Microsoft Exchange Server mailbox agents in a higher-level language, taking advantage of existing components, such as OLE Messaging, to simplify development.</p>
<h2>Summary</h2>
<p>
The <b>NTService</b> control is primarily designed to let developers create Visual Basic applications that install and run as Windows NT services. These applications benefit from automatic startup, remote administration, and event logging. Server processes can be a useful tool in the client/server developer’s toolbox.</p>
</BODY>
</HTML>
