<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Corporate Developer's Guide to Office 95 API Issues</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_off95api"></a>Corporate Developer's Guide to Office 95 API Issues</h1>
<p>
Ken Lassesen<br>
Microsoft Developer Network Technology Group</p>
<p>
April 28, 1995</p>
<h2>Abstract</h2>
<p>
This technical article examines how to write Microsoft® Office solution code that will successfully make application programming interface (API) calls using both 16-bit and 32-bit versions of Office products. In particular, this article applies to Microsoft Access®, Visual Basic®, Microsoft Word, Microsoft Excel, and Microsoft Project. There are three ways to make such API calls: using <b>REGISTER</b>, using<b> Declare</b> statements, and using a type library. This article examines each way of making an API call, accompanied by examples. The reader is assumed to be familiar with my earlier technical article, <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_32bitapi">
</object><a href=JavaScript:alink_1.Click()>"Porting Your 16-Bit Office-Based Solutions to 32-Bit Office,"</a> and is assumed to be an experienced Office developer who needs to port or write solutions to meet the new 16-bit to 32-bit interoperability requirement.</p>
<h2>Introduction</h2>
<p>
The challenge of writing a solution for several generations of Microsoft® Office products across several platforms is unfamiliar to most compiled-language developers. Compiled-language application developers enjoy the luxury of picking a time slice of a compiler's evolution, encapsulating the solution into an executable file, and rarely having to deal with issues caused by the evolution of a product. An Office solution should have one solution file (an .XLS, .MDB, .MPP, or .DOT file) that will execute correctly with all Office products and on all operating systems. Office developers must write solutions that are backward-compatible with versions released five years ago and forward-compatible with the next versions of Office. For example, an expense report that runs on Microsoft Excel 4.0 and Microsoft Excel 5.0 should be able to run on Microsoft Excel NT, Microsoft Excel 95, and Microsoft Excel 2001 (assuming there is one).</p>
<p>
Office 95 introduces 32-bit Office products into the mainstream corporate environment, where they will coexist with 16-bit Office products for many years. My earlier technical article, <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_32bitapi">
</object><a href=JavaScript:alink_2.Click()>"Porting Your 16-Bit Office-Based Solutions to 32-Bit Office,"</a> describes the problems of not being able to call 16-bit APIs from a 32-bit application and not being able to call 32-bit APIs from a 16-bit application. The 16-bit/32-bit interoperability solution presented in that article is examined in depth in this article. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;A rule of thumb that will convert many API calls in Windows® version 3.1 to Win32® application programming interface (API) calls is what I call the Rule of 32A: "Add a <i>32</i> to the DLL name and an <i>A</i> (for ANSI) to the function name if a string is used in any of the call's parameters." This rule of thumb will work for the majority of API calls, but is not a true solution because it will fail to work for some functions. </p>
<p>
The 16-bit/32-bit interoperability solution requires more than porting a 16-bit API call to its equivalent 32-bit API call (in other words, using the 32A Rule); it requires that the solution select the appropriate API call when the solution is executed in a 16-bit or a 32-bit Office product.</p>
<h3>Terminology</h3>
<p>
To reduce confusion over the word <i>application</i>, the following table defines the terms used in this technical article.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Term</b></td>
<td class=label width=76%><b>Definition</b></td>
</tr>
<tr valign=top>
<td width=24%>Office product</td>
<td width=76%>A product that does not compile code to an executable. One of the following products: Microsoft Project, Microsoft Access, Word for Windows, Microsoft Excel.</td>
</tr>
<tr valign=top>
<td width=24%>Compiled language</td>
<td width=76%>A product that compiles code to create an executable, for example, Visual Basic®, FORTRAN PowerStation™, Visual FoxPro®, and Visual C++™. </td>
</tr>
<tr valign=top>
<td width=24%>Solution</td>
<td width=76%>An application developed by a third party or a developer using an Office product and in its file format, such as Microsoft Excel (.XLS), Word (.DOT), Microsoft Project (.MPP), or Microsoft Access (.MDB). </td>
</tr>
<tr valign=top>
<td width=24%>Solution code</td>
<td width=76%>The code (XLM or Basic or both) in which the solution is written.</td>
</tr>
<tr valign=top>
<td width=24%>Platforms</td>
<td width=76%>Microsoft® Windows and Apple® Macintosh® operating systems. Some Office products exist for all versions of Windows and Macintosh operating systems. Microsoft Excel can execute the same applications (with some restrictions) on both a Macintosh and a Windows PC by copying the solution to the other operating system. </td>
</tr>
</table><br>
<h2>API-Calling Methods</h2>
<p>
Solution code can be written in one of three ways—using Microsoft Excel macros (XLM), Basic (Access Basic, Visual Basic, Visual Basic for Applications, and WordBasic), or a combination of XLM and Basic. XLM uses the <b>REGISTER</b> and the <b>CALL</b> commands to make API calls while Basic uses a <b>Declare</b> statement, a type library, or both to make API calls. A Microsoft Excel solution that has been passed from developer to developer may use all these ways of making API calls. All three ways will work in the latest version of Microsoft Excel. </p>
<p class=label>
<b>Table 1. API-Calling Methods Described</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=15%><b>Method</b></td>
<td class=label width=35%><b>Language</b></td>
<td class=label width=50%><b>Technique for Making API Calls</b></td>
</tr>
<tr valign=top>
<td width=15%><b>REGISTER </b></td>
<td width=35%>XLM macros</td>
<td width=50%>Uses the <b>REGISTER</b> and <b>CALL</b> functions from macros .</td>
</tr>
<tr valign=top>
<td width=15%><b>Declare </b></td>
<td width=35%>Access Basic, Visual Basic, Visual Basic for Applications, WordBasic</td>
<td width=50%>Uses a <b>Declare</b> statement.</td>
</tr>
<tr valign=top>
<td width=15%>Type library </td>
<td width=35%>Visual Basic for Applications only</td>
<td width=50%>Select type library method from the Object Browser.</td>
</tr>
</table><br>
<p>
These methods are not product version-specific but are dependent on developers' code-writing preferences or the range of products on which the solution must run. For example, a developer may write an solution in XLM for Microsoft Excel 95 because the solution must also work with Microsoft Excel 4.0. Table 2 shows which API-calling methods work in which Microsoft products.</p>
<p class=label>
<b>Table 2. API-Calling Methods for Microsoft Products</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=19%><b><br>
Product</b></td>
<td class=label width=18%><b><br>
Version</b></td>
<td class=label width=22%><b>REGISTER Method</b></td>
<td class=label width=20%><b>Declare Method</b></td>
<td class=label width=21%><b>Type Library Method</b></td>
</tr>
<tr valign=top>
<td width=19%>Microsoft Excel</td>
<td width=18%>3.0, 4.0</td>
<td width=22%>X</td>
<td width=20%></td>
<td width=21%></td>
</tr>
<tr valign=top>
<td width=19%>Microsoft Excel</td>
<td width=18%>5.0, 5.0 NT, 95</td>
<td width=22%>X</td>
<td width=20%>X</td>
<td width=21%>X</td>
</tr>
<tr valign=top>
<td width=19%>Word</td>
<td width=18%>2.0, 6.0, 95</td>
<td width=22%></td>
<td width=20%>X</td>
<td width=21%></td>
</tr>
<tr valign=top>
<td width=19%>Visual Basic</td>
<td width=18%>1.0, 2.0, 3.0</td>
<td width=22%></td>
<td width=20%>X</td>
<td width=21%></td>
</tr>
<tr valign=top>
<td width=19%>Visual Basic</td>
<td width=18%>4.0</td>
<td width=22%></td>
<td width=20%>X</td>
<td width=21%>X</td>
</tr>
<tr valign=top>
<td width=19%>Project</td>
<td width=18%>4.0, 95</td>
<td width=22%></td>
<td width=20%>X</td>
<td width=21%></td>
</tr>
<tr valign=top>
<td width=19%>Microsoft Access</td>
<td width=18%>1.0, 1.1, 2.0</td>
<td width=22%></td>
<td width=20%>X</td>
<td width=21%></td>
</tr>
<tr valign=top>
<td width=19%>Microsoft Access</td>
<td width=18%>95</td>
<td width=22%></td>
<td width=20%>X</td>
<td width=21%>X</td>
</tr>
<tr valign=top>
<td width=19%>FoxPro</td>
<td width=18%>2.5</td>
<td width=22%></td>
<td width=20%>X</td>
<td width=21%></td>
</tr>
<tr valign=top>
<td width=19%>FoxPro</td>
<td width=18%>3.0</td>
<td width=22%></td>
<td width=20%>X</td>
<td width=21%>X</td>
</tr>
</table><br>
<p>
As we look at each method of making 16-bit and 32-bit API calls, we will examine the same simple API call: <b>GetTickCount</b>. </p>
<h3>REGISTER Method</h3>
<p>
API calls using the <b>REGISTER</b> method are unfamiliar to developers who started writing Office solutions after they started to code in Visual Basic. The older generations of Microsoft Excel developers make API calls from XLM and avoid using Visual Basic for Applications. XLM should not be viewed as old technology—even though it has not been changed since Microsoft Excel 4.0. It may be the best choice if performance is a critical issue. The Microsoft Excel 5.0 Developer's Kit states one advantage of making an API call directly from XLM:</p>
<p class=indent>
<i>Because the C API is optimized for use from the Microsoft Excel macro language and the worksheet, it is not a very good mechanism for writing external functions to be used by Visual Basic (although Visual Basic and the C API can be combined into hybrid solutions).</i></p>
<p>
To make an API call from XLM requires the use of the<b> REGISTER</b> function to reference the dynamic-link library (DLL) and the <b>CALL</b> function to execute it. The <b>REGISTER</b> function performs the equivalent of a <b>Declare</b> statement in Visual Basic for Applications. The recommended <b>REGISTER</b> syntax is:</p>
<pre><code>REGISTER(module_text,procedure,type_text,function_text,argument_text,macro_type,category,shortcut_text)
</code></pre>
<p>
To return to our sample API call, we can implement <b>GetTickCount</b> in a few lines of XLM code.</p>
<p>
<img src="off95api_1.gif" border=0></p>
<p>
This code produces the following output in 16-bit Microsoft Excel:</p>
<p>
<img src="off95api_2.gif" border=0></p>
<p>
The code fails if we run it with 32-bit Microsoft Excel. The API call returns #VALUE!, indicating a failure to pass values to or from the DLL:</p>
<p>
<img src="off95api_3.gif" border=0></p>
<p>
We must convert it to a 32-bit API call, so we use the 32A Rule of adding a <i>32</i> to the DLL name and an <i>A</i> if it's a string. Code that implements the 32A Rule is shown below.</p>
<p>
<img src="off95api_4.gif" border=0></p>
<p>
When we call <b>TestGetTickCount32A</b>, we receive a different error. The #NAME? value is returned, meaning the function does not exist in the DLL. It's either the wrong DLL or the wrong function name. (Remember, function names are case-sensitive.) This must be one of the exceptions to the 32A Rule. (I confess, I picked this function on purpose.)&nbsp; </p>
<p>
<img src="off95api_5.gif" border=0></p>
<p>
In the MSDN Library, look up <b>GetTickCount</b> in the Platform SDK using the Keyword Index. The Quick Info jump at the top of the topic tells you the function is in the KERNEL32 library. (It was in the USER library in Windows 3.<i>x</i>.) The code below shows the corrected macro for 32-bit Microsoft Excel.</p>
<p>
<img src="off95api_6.gif" border=0></p>
<p>
When this code is run with 32-bit Microsoft Excel, we obtain the correct results:</p>
<p>
<img src="off95api_7.gif" border=0></p>
<p>
To illustrate the way API calls behave with 16-bit and 32-bit Microsoft Excel, examine Table 3, which shows the results of these macros. The macro that uses the 32A Rule ("32A bits") produces the same result in both 16-bit and 32-bit solutions. This illustrates the ability of the <b>REGISTER</b> function to locate (or fail to locate) the function name in both 16-bit and 32-bit DLLs from either 16-bit and 32-bit solutions. The return of #VALUE! indicates problems in passing or receiving parameters. </p>
<p class=label>
<b>Table 3. Results of Making Calls Across 16-Bit and 32-Bit Layers from Microsoft Excel </b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Microsoft Excel 4.0 (16-bit version)</b></td>
<td class=label width=50%><b>Microsoft Excel 95 (32-bit version)</b></td>
</tr>
<tr valign=top>
<td width=50%> &nbsp;&nbsp; <img src="off95api_8.gif" border=0>  </td>
<td width=50%> &nbsp;&nbsp;&nbsp; <img src="off95api_9.gif" border=0></td>
</tr>
</table><br>
<p>
We can write macros that make 16-bit API calls <i>or</i> 32-bit API calls—but we <i>must</i> write macros that can make 16-bit API calls <i>and</i> 32-bit API calls, depending on the version of the Office product. Solution code must run on <i>both</i> 16-bit Microsoft Excel and 32-bit Microsoft Excel. The Visual Basic for Applications function <b>Engine32</b>, described in my earlier article (<object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_32bitapi">
</object><a href=JavaScript:alink_3.Click()>"Porting Your 16-Bit Office-Based Solutions to 32-Bit Office"</a>) does not work with Microsoft Excel 4.0. (Microsoft Excel 4.0 does not include Visual Basic for Applications.) <b>Engine32</b> <i>does</i> work for Microsoft Excel 5.0 or higher. A Microsoft Excel 4.0-compatible <b>Engine32</b> function must use macro code. </p>
<h4>Engine32 Function for XLM</h4>
<p>
For XLM, the solution is similar to the Visual Basic for Applications solution. The function <b>Info("osversion")</b> will contain <i>32</i> if Microsoft Excel is a 32-bit version. The <b>Engine32</b> macro shown below returns TRUE if Microsoft Excel is a 32-bit version, FALSE if Microsoft Excel is a 16-bit version.</p>
<p>
<img src="off95api_10.gif" border=0></p>
<h4>Sample REGISTER-method solution</h4>
<p>
With <b>Engine32</b> defined, the macro code for <b>GetTickCount</b> is simple:</p>
<p>
<img src="off95api_11.gif" border=0></p>
<p>
<b>Engine32</b> will work correctly with all versions of Microsoft Excel. The <b>GetTickCount</b> function performs the same as the API call did in Windows 3.1.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you are concerned about performance, you should register all the API calls when you load the solution. </p>
<h4>Steps of the REGISTER-method solution</h4>
<p>
If you are converting Microsoft Excel solutions to run on both 16-bit and 32-bit products, I suggest the following steps:
<ol>
<li>
Create a new macro sheet called <b>APICALLS</b>.<br><br></li>
<li>
Create the <b>Engine32</b> function in the <b>APICALLS </b>macro sheet<b>.</b><br><br></li>
<li>
Locate all the <b>REGISTER</b> functions in the solution and move them to <b>APICALLS</b>, one per column.<br><br></li>
<li>
Using the macro code above in the sample <b>REGISTER</b> solution as a template, create functions for each API on your macro sheets.<ul type=disc>
<li>
Add the needed <b>ARGUMENT</b> lines. <br><br></li>
<li>
Add the needed <b>RESULT</b> lines. <br><br></li>
<li>
Add the 16-bit API <b>REGISTER</b> line, appending <i>16</i> to the function text. <br><br></li>
<li>
Add the 32-bit API <b>REGISTER</b> line, appending <i>32</i> to the function text.<br><br></li>
<li>
Do any needed data manipulation to make the API call.<br><br></li>
<li>
Add an <b>If</b> line to call the appropriate API.<br><br></li>
<li>
<b>RETURN</b> the return value (if any). </li>
</ul>
</li>
<li>
Test the function.<br><br></li>
<li>
Define the function to Microsoft Excel.</li>
</ol>
<p>
This process allows existing API calls in macro sheets to be left untouched. Once you have created the macro sheet <b>APICALLS</b> (and tested it), you may import it into other solutions and reuse the macros, thus cutting conversion time. The content of this macro sheet is solution-independent (it contains only Windows API calls ) and reusable in other solutions. This macro sheet <b>APICALLS</b> becomes a Rosetta stone for future 16-bit/32-bit solution development.</p>
<h3>Declare Method</h3>
<p>
The introduction of Visual Basic for Applications gives Microsoft Excel developers an alternative to XLM. Visual Basic, WordBasic, and Microsoft Access developers are able to also write Microsoft Excel and Microsoft Project solutions with little difficulty. Basic code can be exchanged among a wide variety of products. The younger generation of Office developers will write code in Visual Basic for Applications and rarely use XLM.</p>
<p>
To call an API from Visual Basic for Applications requires an API <b>Declare</b> statement. A declared API is callable anywhere in Basic code (or in a macro). There are two methods of doing <b>Declare</b> statements, as shown below.</p>
<p>
<b>Word Declare statements</b></p>
<pre><code>'Word was first in doing Declare statements. 
'Its format was frozen for backward compatability.
Declare Sub SubName Lib LibName$ [(ArgumentList)] [ Alias Routine$]
Declare Function FunctionName[$] Lib LibName$ [( ArgumentList)] [Alias Routine$] As Type
</code></pre>
<p>
<b>Visual Basic for Applications, Basic, and Microsoft Access Declare statements</b></p>
<pre><code>Declare Sub globalname Lib "libname" [Alias "aliasname" ][([ argumentlist])]
Declare Function globalname Lib libname [Alias aliasname ] [([ argumentlist])] [As type]
</code></pre>
<p>
Because I have already discussed some of the issues in <object id=alink_4 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_32bitapi">
</object><a href=JavaScript:alink_4.Click()>"Porting Your 16-Bit Office-Based Solutions to 32-Bit Office"</a> and derived a methodology above, I will cut to a sample function and then show the steps of the <b>Declare</b> solution.</p>
<h4>Basic Engine32 function</h4>
<p>
The <b>Engine32</b> function returns <b>True</b> if 32-bit API calls will work (and 16-bit API calls will fail), and it returns <b>False</b> if 16-bit API calls will work (and 32-bit API calls will fail). The <b>Engine32 </b>functions given in <object id=alink_5 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_32bitapi">
</object><a href=JavaScript:alink_5.Click()>"Porting Your 16-Bit Office-Based Solutions to 32-Bit Office"</a> were designed to show how they differ in each Office product. The versions given below are modified for better performance and to work with more versions.</p>
<p>
Performance was improved by initializing static variables on the first function call. All subsequent calls use the static variables instead of repeating additional function calls. Another method for improving performance is to initialize a <b>Global</b> or <b>Public</b> variable; however, this has the drawback that if a <b>Reset</b> occurs in some products, all subsequent API calls may fail until the <b>Global</b> variable is reinitialized. </p>
<p>
<b>Microsoft Excel 5 or higher and Project 4 or higher</b></p>
<p>
The <b>Application</b>.<b>OperatingSystem</b> property in Microsoft Excel and Microsoft Project always contains <i>32</i> if the product is a 32-bit product. The product version number is not sufficient because Microsoft Excel 5.0 is available as both a 16-bit and a 32-bit product. </p>
<pre><code>Function Engine32%()
Static sEngine32%,SEval%&nbsp; 'Statics are used to improve performance.
If SEval% Then Engine32%=sEngine32%: Exit Function
If instr(Application.OperatingSystem,"32") then sEngine32%=True
Seval%=True
Engine32%=sEngine32%
End Function
</code></pre>
<p>
<b>Microsoft Access 1.1 or higher</b></p>
<p>
Microsoft Access has no product version that is both 16-bit and 32-bit. Checking the version number by calling <b>SysCmd </b>determines which version of Microsoft Access is being used. Microsoft Access 1.1 does not have a version number constant built in, so we always use 7 to ensure that the code will work with Microsoft Access 1.1. This method should be used to see whether your solution code should make a 16-bit or 32-bit API call.</p>
<pre><code>Function Engine32% ()
Static sEngine32%,SEval%
If SEval% Then Engine32%=sEngine32%: Exit Function
If SysCmd(7) &gt; 2 Then sEngine32% = True
Seval%=True
End Function
</code></pre>
<p>
<b>Word for Windows 2.0 or higher</b></p>
<p>
Word must evaluate the <b>Engine32</b> function each time because Word does not support static variables. First we check to see if the product version number is high enough to indicate it may be a 32-bit version, and then we check the version of the operating system to see whether it is a 32-bit one. This two-stage process is needed because <b>GetSystemInfo</b> is not available on versions before Word 6.0, and Word 6.0 is available in both 16-bit and 32-bit versions.</p>
<pre><code>Function Engine32
Engine32 = 0
If&nbsp; Val(AppInfo$(2)) &gt; 5 Then
 &nbsp; OS$ = GetSystemInfo$(23)
 &nbsp; If Val(OS$) &gt; 6.3 Or Len(OS$) = 0 Then Engine32 = - 1
End If
End Function
</code></pre>
<p>
<b>Visual Basic</b></p>
<p>
Although Visual Basic does not use solution code, Basic code is often exchanged with the products covered above. Visual Basic 4.0 does not have the <b>Application.OperatingSystem</b> property (this is not technically a part of Visual Basic for Applications), but uses conditional compilation with #IF and #ELSE. If you intend to share your code with other Microsoft products, you should create the following function (and not use conditional compilation elsewhere):</p>
<pre><code>Function Engine32%()
'This is for VB4 only.
#IF WIN16
 &nbsp; Engine32% = False
#ELSE
 &nbsp; Engine32% = True
#ENDIF
End Function
</code></pre>
<p>
For earlier versions of Visual Basic, use the following:</p>
<pre><code>Function Engine32%()
'This is for VB1 - VB3; #IF is not supported.
Engine32% = False
End Function
</code></pre>
<h4>Sample Declare-method solution </h4>
<p>
The following code demonstrates the <b>Declare</b>-method solution, except for Word:</p>
<pre><code>Declare Function GetTickCount32 Lib "Kernel32" Alias "GetTickCount" () As Long
Declare Function GetTickCount16 Lib "USER" Alias "GetTickCount" () As Long

Function GetTickCount() As Long
If Engine32() Then
 &nbsp;&nbsp; GetTickCount = GetTickCount32()
Else
 &nbsp;&nbsp; GetTickCount = GetTickCount16()
End If
End Function
</code></pre>
<p>
The <b>Engine32</b> function is used to determine which API call to make. The <b>Declare</b> statements indicate the actual API function name as an <b>Alias</b> to avoid accidental changes of case (32-bit API calls are case-sensitive) and then indicate the bitness of the API function by adding <i>16</i> or <i>32</i> to the end of the function.</p>
<p>
This code can be copied and pasted in all Office products except Word. WordBasic existed before the Basic used in the other Office products and is <i>different</i>. We will examine the Word solution later.</p>
<h4>Steps of the Declare-method solution</h4>
<p>
If you are converting solutions to run on 16-bit and 32-bit products, I suggest the following steps:
<ol>
<li>
Create a new module called <b>APICalls</b>.<br><br></li>
<li>
Create the <b>Engine32</b> function in <b>APICalls.</b><br><br></li>
<li>
Locate all the <b>Declare</b> functions in the solution and move them to <b>APICalls</b>.<br><br></li>
<li>
Using the code in the "Sample Declare-method solution" above as a template, create functions for each API.<ol>
<li>
The arguments should match the Windows version 3.1 API calls.<br><br></li>
<li>
The results should be Win32 API call results. (Visual Basic will automatically convert to Windows version 3.1 if needed.)<br><br></li>
<li>
Add the 16-bit API Declare line in the Declarations; append 16 to the function name .<br><br></li>
<li>
Add the 32-bit API Declare line in the Declarations; append 32 to the function name.<br><br></li>
<li>
Do any needed data manipulation. <br><br></li>
<li>
Add an If line to call the appropriate API.<br><br></li>
<li>
Return the return value (if any).</li>
</ol>
</li>
<li>
Test the function.</li>
</ol>
<p>
This process allows existing calls in other modules to be left untouched. Once the developer defines and tests the <b>APICalls </b>module, she or he may import and reuse the module in other solutions, thus cutting conversion time. The content of this module is solution-independent and the developer may use the module again. This module, <b>APICalls</b>, becomes a component for future 16-bit/32-bit solution development in Visual Basic for Applications. </p>
<p>
<b>API-wrapper alternative solution</b></p>
<p>
I usually put a wrapper around API calls instead of exposing the API call in the code. For example, I will wrap code around <b>GetProfileString</b> to create a function called <b>vbGetWinIni</b> that takes the same arguments but returns the string instead. I discuss the conversion of common API wrappers converted into DLLs in the technical article <object id=alink_6 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_nativevb">
</object><a href=JavaScript:alink_6.Click()>"Creating Useful Native Visual Basic and Microsoft Access Functions."</a></p>
<p>
If you code in this style, you may wish to modify the API-wrapper function to call the appropriate API instead of creating additional functions.</p>
<h4>Word sample Declare-method solution</h4>
<p>
Word has a different <b>Declare</b> format and syntax. The Word solution is more complex because you cannot place both the 16-bit and 32-bit <b>Declare</b> statements in the same macro. The solution is to create three macro libraries: <b>APICALL16</b> and <b>APICALL32</b>, that contain the <b>Declare</b> statements for each operating environment, and a 16-bit/32-bit interoperability macro, <b>APICALLS</b>. This may sound very confusing, so let us go through it step by step.</p>
<p>
First, we create a macro library called <b>APICALL16</b>. This macro contains all the 16-bit API <b>Declare</b> statements.</p>
<pre><code>'This is APICALL16 -- all 16-bit Declare statements are placed here.
Declare Function GetTickCount16 Lib "USER" Alias "GetTickCount"() As Long
Function GetTickCount
GetTickCount = GetTickCount16
End Function
</code></pre>
<p>
Second, we create a macro library called <b>APICALL32</b>. This macro contains all the 32-bit API <b>Declare</b> statements.</p>
<pre><code>'This is APICALL32 -- all 32-bit Declare statements are placed here.
Declare Function GetTickCount32 Lib "KERNEL32"() Alias "GetTickCount" As Long
Function GetTickCount
GetTickCount = GetTickCount32
End Function
</code></pre>
<p>
Third, we create a macro library called <b>APICALLS</b>. This macro contains <b>Engine32</b> and the procedures your solution code will call.</p>
<pre><code>'This is APICALLS -- no Declare statements may be in this macro.
Function Engine32
Engine32 = 0
If&nbsp; Val(AppInfo$(2)) &gt; 5 Then
 &nbsp; OS$ = GetSystemInfo$(23)
 &nbsp; If Val(OS$) &gt; 6.3 Or Len(OS$) = 0 Then Engine32 = - 1
End If
End Function

Function GetTickCount
If Engine32 Then
 &nbsp; GetTickCount = APICall32.GetTickCount
Else
 &nbsp; GetTickCount = APICall16.GetTickCount
End If
End Function
'Other API function calls are placed here.
</code></pre>
<p>
You can now call this function from your solution code. You must preface your calls with <b>APICALLS</b>, for example:</p>
<pre><code>Sub MAIN
MsgBox Str$(APICalls.GetTickCount)
End Sub
</code></pre>
<h4>Steps of the Word Declare-method solution</h4>
<p>
If you are converting Word solutions to run on 16-bit and 32-bit products, I suggest the following steps:
<ol>
<li>
Create a new module called <b>APICALLS</b>. <br><br></li>
<li>
Create the <b>Engine32</b> function in <b>APICALLS.</b><br><br></li>
<li>
Create a new module called <b>APICALL16</b>. <br><br></li>
<li>
Locate all the 16-bit <b>Declare</b> statements in the solution and move them to <b>APICALL16</b>.<br><br></li>
<li>
Create a new module called <b>APICALL32</b>. <br><br></li>
<li>
Create the equivalent 32-bit <b>Declare</b> statements and put them to <b>APICALL32</b>.<br><br></li>
<li>
Using the template above, create functions for each API in each of the three macro libraries.<br><br></li>
<li>
Add <b>APICALLS</b> before all calls to the API in your solution code.<br><br></li>
<li>
Test each function. </li>
</ol>
<p>
This process allows existing calls in other modules to be left untouched. Once the developer defines and tests these macros, she or he may add them to the NORMAL.DOT template and reuse the macros in other solutions so as to cut conversion time. </p>
<h3>Type Library Method</h3>
<p>
The type library method of making API calls is new to most developers. Bruce McKinney's forthcoming Microsoft Press® book, <i>Hard Core Visual Basic</i>, includes the Windows API Functions type library for 16-bit API calls (WIN16.TLB) and a matching type library for 32-bit API calls (WIN32.TLB). Once these type libraries<b> </b>are registered, the appropriate type library is loaded for the 16-bit or 32-bit version of the Office product.</p>
<p>
A type library provides easy access to the API calls with the products Microsoft Excel 5.0 or higher, Microsoft Project 4.0 or higher, Visual Basic 4.0 or higher, and Microsoft Access 95 or higher. All the Windows API calls become native functions. (See my article <object id=alink_7 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_nativevb">
</object><a href=JavaScript:alink_7.Click()>"Creating Useful Native Visual Basic and Microsoft Access Functions"</a> for related material that works with earlier versions of Visual Basic and Microsoft Access only.) Because this approach is new to many of my readers, I will go through the steps in detail.</p>
<h4>Registering the type library</h4>
<p>
The following steps will add a type library called Windows API Functions to your registry. This makes this type library available for <i>all</i> products that use Visual Basic for Applications, not only the product in which you registered it. 
<ol>
<li>
Open any Visual Basic for Applications product (for example, Microsoft Excel 5.0).<br><br></li>
<li>
To create a module, choose Macro Module from the Insert menu.<br><br></li>
<li>
Choose References from the Tools menu. The References dialog box is displayed as in Figure 1.<p>
<img src="off95api_12.gif" border=0></P><p class=label>
<b>Figure 1. The References dialog box</b>
</li>
<li>
Assuming that you have not registered the Windows API Functions type library, click the Browse button and locate WIN32.TLB, and click OK. Repeat with WIN16.TLB. Both WIN16.TLB and WIN32.TLB will be registered. See Figure 2.<p>
<img src="off95api_13.gif" border=0></P><p class=label>
<b>Figure 2. Selecting the type library</b>
</li>
<li>
After the Browse dialog closes, scroll to the bottom of the References dialog box, and you will see the Windows API Functions type library in the list (Figure 3).<p>
<img src="off95api_14.gif" border=0></P><p class=label>
<b>Figure 3. Registering Windows API Functions </b>
</li>
<li>
Close the References dialog box.<br><br></li>
<li>
From the View menu, choose Object Browser.<br><br></li>
<li>
In the Object Browser dialog box, select Win (Windows API Functions type library) in the Libraries/Workbooks drop-down list box. All the available functions will appear in the Objects/Modules and Methods/Properties list boxes below (Figure 4).<p>
<img src="off95api_15.gif" border=0></P><p class=label>
<b>Figure 4. Microsoft Excel 5.0 Object Browser showing objects and methods available in Bruce McKinney's Windows API Functions type library</b>
</li>
<li>
In the Objects/Modules list box, select Kernel; then in the Methods/Properties list box, select GetTickCount. <br><br></li>
<li>
Click the Paste button. GetTickCount appears in the Module.</li>
</ol>
<p>
The following shows the code to display the value returned by the <b>GetTickCount</b> API call in a message box.</p>
<pre><code>Sub Demo()
MsgBox Str$(GetTickCount)
End Sub
</code></pre>
<p>
No <b>REGISTER </b>command nor <b>Declare</b> statements are needed. The code above is all the code you need.</p>
<h4>Steps of the type library-method solution</h4>
<p>
If you are converting solutions to run on 16-bit and 32-bit products, I suggest the following steps—assuming the Windows API Functions type library is registered:
<ol>
<li>
Remove all your <b>Declare</b> statements, assuming you are using only standard 16-bit API calls.<br><br></li>
<li>
Check the Windows API Functions check box in the References dialog box.</li>
</ol>
<p>
That is all. You have done a complete porting.</p>
<h4>Type library issues</h4>
<p>
Type libraries are a developing technology—there are very few type libraries commercially available. Bruce did an excellent job in designing the type library to work with both 16-bit and 32-bit products using the Windows 3.1 API call names. Nonetheless, type libraries have some issues that should be reviewed:
<ul type=disc>
<li>
The Windows API Functions type library adds more than a thousand new reserved words to Visual Basic for Applications. All the API calls contained in the type library<b> </b>become reserved words in the language. If you have an existing function called <b>ordShell</b>, you must change its name so that it does not conflict with the <b>ordShell</b> function already defined in the type library.<br><br></li>
<li>
The Windows API Functions type library does not include API calls that require a user-defined type (UDT). This may change in future versions.<br><br></li>
<li>
The Windows API Functions type library methods are not available on spreadsheets in Microsoft Excel.</li>
</ul>
<p>
This technology is very promising and will simplify the use of API calls in developing Office solutions. </p>
</BODY>
</HTML>
