<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tom's Handy Dandy MFC/COM/MIDL Recipe Book for Creating Custom Interfaces</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_mfccom"></a></sup>Tom's Handy Dandy MFC/COM/MIDL Recipe Book for Creating Custom Interfaces</h1>
<h3>Instructions and Guidelines for Using MFC and MIDL to Create COM Objects with Custom Interfaces </h3>
<p>
Tom Laird-McConnell</p>
<p>
Created: November 30, 1994<br>
Revised: August 1995<br>
Version 2.0</p>
<p>
<i>A word of thanks to Steve Hiskey, whom I tricked into being my guinea pig; Dean McCrory for great feedback on MFC stuff; and all of the miscellaneous people on the e-mail aliases who patiently put up with all of my annoying questions.</i></p>
<h2>Abstract</h2>
<p>
The purpose of this document is to provide a step-by-step description of how to create component object module (COM) objects that export custom interfaces from .DLLs or .EXEs by utilizing the class technology provided in the Microsoft® Foundation Class Library (MFC) classes and the Microsoft MIDL compiler. This document supposes a level of knowledge equivalent to taking the OLE Literacy course, which is highly recommended to understand this article. It also assumes that the user understands dynamic-link libraries (.DLLs), .EXEs, and C++.</p>
<h2>Objects, Classes, Interfaces, and GUIDs</h2>
<p>
<img src="mfccom_1.gif" border=0></p>
<h3>Classes</h3>
<p>
A <i>class</i> is defined as a data structure with a set of interfaces by which you can manipulate the data structure. C++ provides a concept of a class in a programming language. Component object modules (COM) provide a method by which a class in any language can be published with the operating system and used in a language-independent manner.</p>
<h3>Objects</h3>
<p>
An <i>object </i>is an instance of a class. Whether an instance of the class was created via C++ <b>new</b>, or was created via COM with <b>CoCreateInstance</b>, the key distinction is that it is one of many possible instances of the single definition of a class.</p>
<h3>Interfaces</h3>
<p>
An <i>interface</i> is a group of methods (functions) in a class. OLE is actually a set of redefined interfaces that a COM class can support. So don't get all caught up in all of the OLE interfaces and technologies when thinking about designing a COM class. If you need to do something that an OLE interface does, you should worry about what the interface looks like and what it does. Otherwise, the only interfaces that you really need to know are <b>IUnknown</b> and <b>IClassFactory()</b>.</p>
<h3>GUIDs (CLSIDS and IIDS)</h3>
<p>
A <i>GUID</i> is a <b>g</b>lobally <b>u</b>nique <b>id</b>entifier. A GUID is a 128-bit, or 8-byte, number. It is generated automatically for you by a tool called GUIDGEN. Every COM class must have a GUID, and that GUID is called a <i>CLSID</i>, or Class ID. Each COM class has an entry created in the registry under the HKEY_CLASSES\CLSID where the CLSID is registered, and a pointer to the DLL/EXE file that implements that CLASSID. An <i>IID</i> is a GUID for an interface to a COM Class. It is used to ask an object if it supports a particular interface. It also gets registered with the system in the register, under HKEY_CLASSES\Interfaces.</p>
<h2>Tree and File Naming Standards</h2>
<p>
All of the different types of files can get very confusing. To try to minimize some of that confusion, I have come up with the following tree and file naming standards. For purposes of this discussion, let's say that we have a COM object called "Labrador". It supports two interfaces, <b>IMammal()</b> and <b>IDog()</b>, and will live in a .DLL or .EXE (it doesn't matter which).</p>
<pre><code>\Source\
 &nbsp;&nbsp; Classes\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Support\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Common files for supporting COM
RPCHelp.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Interface RPC helper code
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ComHelp.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Support file for OLE implementation
Ifaces\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMammal\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMammal.IDL&nbsp; // Interface definition in IDL language.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMammal.h&nbsp;&nbsp;&nbsp; // Interface definition.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMammal_p.c&nbsp; // Interface proxy code for OUT_OF_PROC.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMammal_s.c&nbsp; // Interface stub code for OUT_OF_PROC.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dlldata.c&nbsp;&nbsp;&nbsp; // Interface DLL support for OUT_OF_PROC.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMammal.mak&nbsp; // Project file for OUT_OF_PROC.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDog\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDog.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // INPROC only version, (see addendum).
 &nbsp;&nbsp; 
Labrador\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Labrador.mak&nbsp;&nbsp;&nbsp;&nbsp; // Make file for Labrador COM Class.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Labrador.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // C++ class definition.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Labrador.cpp&nbsp;&nbsp;&nbsp; // C++ class implementation.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Husky\&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Husky.mak&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Make file for Husky COM Class.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; etc....
</code></pre>
<h3>Interface Files</h3>
<p>
Interface files are header files that define an interface to an class. They are shared among multiple classes, and so they should go into a common location, such as Interfaces. For instance, Labrador, Husky, and Newfoundland classes all share the same <b>IDog.h</b> interface definition, and so there should be one easy place to find the interface definition—namely, Ifaces\IDog. The name of interfaces and there files should always be IXXXX where XXX is the name of the interface. So <b>IDog.h</b> defines the IDog interface, and <b>IMammal.h</b> defines the IMammal interface. Additionally, if you want to make your custom interface supportable across a process boundary (OUT_OF_PROC), these directories also contain the marshalling code implementation that is shared by everyone who exposes this interface. This allows the marshalling code to be implemented once and shared by all classes that expose that interface.</p>
<h3>COM Class Projects</h3>
<p>
Each COM class lives in a .DLL or .EXE, so it should exist in its own directory, as its own project. It should be in the tree under the Source\Classes directory and the name should be the name of the COM Class. For instance, our "Labrador" class ought to be implemented in a project called Labrador.mak in \Source\Classes\Labrador and the output of the project should be Labrador.dll, or Labrador.exe.</p>
<h3>Class ID Headers</h3>
<p>
ClassID headers are essentially simple include files that define the unique GUID for a particular COM class. Because they are shared like interface files, they should go into a common directory such as \Source\Classes\ClassIds and be named XXXXID.H. So the Labrador ClassID header file would be called LabradorID.h and live in \Source\Classes\ClassIDs.</p>
<h3>COM Class Implementation Files</h3>
<p>
The COM class implementation file is a C++ class. As such it is convenient to follow the class naming convention that MFC follows, namely using a <i>C</i> as a prefix (in front of the class name) to signify that this is the header or the implementation of the class. So, for instance, the Labrador classes internal definition is defined in CLabrador.h and the implementation itself is in CLabrador.cpp. Obviously, these files would go into the same directory as the project that owns them, namely \Source\Classes\Labrador.</p>
<h2>Tools and Environment</h2>
<p>
This section describes how to add some commonly used tools to the Visual C++™ Tools menu to make it easier to work with. It is entirely optional to do the items in this section, but it is easier to have them available in this manner.</p>
<h3>MIDL Compiler</h3>
<p>
The MIDL compiler that comes with the Win32® SDK has been modified to provide marshalling support for interfaces across compiler boundaries. Although we could do custom interface marshalling without MIDL, it's much easier if it's around. Unfortunately, this means we need to have both the Win32 SDK and Visual C++ 2.0 installed, even though we will only be using the MIDL compiler portion of the Win32 SDK. Hopefully this will change in the future.
<ol>
<li>
Install the Win32 SDK.<p class=tl>
<b>Note:</b>  You don't need any of the samples or special tools, so to save disk space you can remove those items when installing by using the custom screen.</P></li>
<li>
When it asks you to register environment variables in the system, agree to do it.</li>
</ol>
<h3>Visual C++ 2.2</h3>
<ol>
<li>
Install Visual C++ 2.2.<br><br></li>
<li>
When it asks you to register environment variables in the system, agree to do it.</li>
</ol>
<h3>Customizations to Visual C++ Tools Menu</h3>
<p>
These are optional additions, but they do make your life a little bit easier.</p>
<h4>GUIDGEN</h4>
<p>
This section shows you how to add a command to the Tools menu to generate a UUID, which can be used for an interface ID, a class ID, or any other 128-bit UUID. To use it, select Tools\Generate GUID, and it will create a unique UUID that can be copied and pasted into your code in four different formats.
<ol>
<li>
Select Tools\Customize, and click Tools.<br><br></li>
<li>
Click the New button.<br><br></li>
<li>
In Menu Text, type Generate UUID.<br><br></li>
<li>
In Command, type GUIDGEN.EXE.<br><br></li>
<li>
Clear out Arguments.<br><br></li>
<li>
Clear out Initial dir.</li>
</ol>
<h4>MIDL compiler</h4>
<p>
This section shows you how to add a command to the Tools menu to compile an IDL file using the MIDL compiler. Once this has been added, you can load the .IDL file, select Tools/Compile IDL, and the MIDL compiler will generate all of the .C source files for marshalling.
<ol>
<li>
Select Tools\Customize, and click Tools.<br><br></li>
<li>
Click the New button.<br><br></li>
<li>
 In Menu Text, type Compile IDL file.<br><br></li>
<li>
In Command, type MIDL.EXE.<br><br></li>
<li>
In Arguments, type /ms_ext /char unsigned&nbsp; /c_ext $FileName.<br><br></li>
<li>
In InitialDir, type $FileDir.<br><br></li>
<li>
Click Redirect to Output Window (turn it on).</li>
</ol>
<h4>REGEDIT</h4>
<p>
This section shows you how to add a command to the Tools menu to take a .REG file and load it into the registry. Again, to use it, load the .REG file, and then select Tools\Register .REG file, and it will create all of the entries.
<ol>
<li>
Select Tools\Customize, and click Tools.<br><br></li>
<li>
Click the New button.<br><br></li>
<li>
In Menu Text, type Register .REG File.<br><br></li>
<li>
In Command, type REGEDIT.EXE.<br><br></li>
<li>
In Arguments, type -s $FileName.<br><br></li>
<li>
In InitialDir, type $FileDir.</li>
</ol>
<h2>Create Support Modules</h2>
<h3>Create ComHelp.h</h3>
<p>
This file contains some support macros that make implementing interfaces a little bit easier. In particular, these macros will create the redirection back to the parent object for the <b>IUnknown</b> interface. This reduces the amount of duplicate code you have to create.
<ol>
<li>
Create file Source\Support\ComHelp.h<br><br></li>
<li>
Put the following set of macros into it:<pre><code>// ---------------------------------------------
// IUnknown macros for implementing redirection to parent
// IUnknown implementation
// ---------------------------------------------

#ifndef IMPLEMENT_IUNKNOWN

#define IMPLEMENT_IUNKNOWN_ADDREF(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; STDMETHODIMP_(ULONG) ObjectClass::X##InterfaceClass::AddRef(void) \
 &nbsp;&nbsp; { \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; METHOD_PROLOGUE(ObjectClass, InterfaceClass); \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pThis-&gt;ExternalAddRef(); \
 &nbsp;&nbsp; }

#define IMPLEMENT_IUNKNOWN_RELEASE(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; STDMETHODIMP_(ULONG) ObjectClass::X##InterfaceClass::Release(void) \
 &nbsp;&nbsp; { \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; METHOD_PROLOGUE(ObjectClass, InterfaceClass); \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pThis-&gt;ExternalRelease(); \
 &nbsp;&nbsp; }

#define IMPLEMENT_IUNKNOWN_QUERYINTERFACE(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; STDMETHODIMP ObjectClass::X##InterfaceClass::QueryInterface(REFIID riid, LPVOID *ppVoid) \
 &nbsp;&nbsp; { \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; METHOD_PROLOGUE(ObjectClass, InterfaceClass); \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HRESULT)pThis-&gt;ExternalQueryInterface(&amp;riid, ppVoid); \
 &nbsp;&nbsp; }

#define IMPLEMENT_IUNKNOWN(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; IMPLEMENT_IUNKNOWN_ADDREF(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; IMPLEMENT_IUNKNOWN_RELEASE(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; IMPLEMENT_IUNKNOWN_QUERYINTERFACE(ObjectClass, InterfaceClass)

#endif
</code></pre>
</li>
</ol>
<h3>Create RPCHelp.c</h3>
<p>
This section shows you how to create interface libraries that use RPC code. When you do this, you have to tediously change your make file to add four somewhat obscure library references. By creating a file with library pragmas in it, you can reduce that step to simply adding a file to your project, which is a nicety.
<ol>
<li>
Create a file called Source\Classes\Support\RPCHelp.c.<br><br></li>
<li>
Edit it to look like this:<pre><code>#pragma comment(lib, "rpcndr.lib") 
#pragma comment(lib, "rpcdce4.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")
</code></pre>
</li>
</ol>
<h2>Implementing Custom Interfaces</h2>
<p>
A custom interface is an interface that the system doesn't already support (for instance, the OLE Interfaces are defined by the operating system and have built in marshalling support.). If your interface is used only to talk to an INPROC server, you don't need to provide marshalling code to package parameters between two process spaces. On the other hand, if your interface is a custom interface that is not supported by the OS, and it might be used between two processes or two machines, you need to provide marshalling code to transfer parameter data across process boundaries. Normally, this is a really tedious, arcane process, but with the latest release of the Microsoft RPC MIDL compiler, you can automatically generate the necessary DLL code by describing your interface with the <i>interface definition language</i> (IDL).</p>
<h3>Create Project File in Classes\Ifaces Directory</h3>
<p>
Each Interface should go into its own directory to provide a logical place for interface marshalling support code to live. So, first we create a Visual C++ project.
<ol>
<li>
Create Project \Source\Classes\Ifaces\IMammal\IMammal.mak as a dynamic-link library.<br><br></li>
<li>
When it asks for a project name, type IMammal.<br><br></li>
<li>
When it asks for a file to add, add Classes\Support\RPCHelp.c.</li>
</ol>
<h3>Create IDL File</h3>
<p>
Now we need to define our interface using the interface definition language (IDL). To do so, take the following steps:
<ol>
<li>
Create a file named after your interface with an IDL extension (IMammal.IDL in our case).<br><br></li>
<li>
Type in the following code:<pre><code>[
object,
uuid(56b8d0e0-fa8b-11cd-8a02-00608cc80b9c),
pointer_default(unique)
]

interface IMammal : IUnknown
{
import "unknwn.idl";

HRESULT GetSpeciesName([out, string, size_is(255)] char *p);
HRESULT&nbsp;&nbsp;&nbsp; IsAlive([out] BOOL *pBool);
}
</code></pre>
<p class=tl>
<b>Note:</b> All return values must be HRESULT (standard OLE return value). If the return value is something different, MIDL will not provide marshalling information to marshal across process boundaries (this is for network support). In the event of a network error, they want to ensure they can return a valid error code without having to throw an exception.</P></li>
<li>
Select Tools\Generate UUID.<br><br></li>
<li>
Copy and paste the 128-bit number into the UUID section in the .IDL file. This is the unique 128-bit number assigned to your interface. You only need to generate this once when the interface is created.<br><br></li>
<li>
Specify your interface as if it were a C++ class, following the .IDL. For more information about IDL, check out the RPC documentation in the Win32 SDK [ Ed. note: the Win32 SDK is now called the platform SDK] (MSDN Library, Platform, SDK, and DDK Documentation).<br><br></li>
<li>
Add it to the project file list by selecting Project\File, and adding IMammal.IDL.</li>
</ol>
<h3>Compile .IDL File with MIDL Compiler</h3>
<p>
Now we run the .IDL file through the MIDL compiler, which generates a bunch of C source code.
<ol>
<li>
Load the IMammal.IDL file.<br><br></li>
<li>
Select Tools\Compile IDL. This command will generate source code based on your interface definition.<br><br></li>
<li>
You will need to add some entries to the include path for Visual C++ so it can pick up MIDL include files. Select Tools/Options/Directories, click INCLUDE, and make sure that win32sdkdrive\mstools\h and win32sdkdrive \mstools\idl are added to the end of your include path.<br><br></li>
<li>
You will also need to add the mstools library to your path, so click LIBS and add win32sdkdrive \mstools\lib to the end of the library path.</li>
</ol>
<h3>Add .C Files to Project</h3>
<p>
The MIDL compiler has now generated three new C source files: IMammal_i.c, IMammal_p.c, and dlldata.c. These files actually implement the marshalling code for our <b>IMammal</b> interface in a .DLL called IMammal.dll. Now we need to add these source files to the project so Visual C++ can compile them.
<ol>
<li>
Select Projects\Files.<br><br></li>
<li>
Add all of the .C files to the project.</li>
</ol>
<h3>Create DEF File for Interface .DLL</h3>
<p>
The .DLL created by this project, although generated by the MIDL compiler, is just another OLE object of a special type, with an <b>IMarshall</b> interface defined. As such, the .DLL needs to have its <b>DllGetClassObject</b> and <b>DllCanUnloadNow()</b> entry points exported. I think that the MIDL compiler should have spit this out, but it didn't, so we have to create the .DEF file for our .DLL and link it into the project.
<ol>
<li>
Create IMammal.DEF as follows:<pre><code>LIBRARY&nbsp;&nbsp;&nbsp;&nbsp; IMAMMAL
DESCRIPTION 'IMAMMAL Interface Marshalling'

EXPORTS
DllGetClassObject
DllCanUnloadNow
</code></pre>
</li>
<li>
Add to the project via Projects\Files.</li>
</ol>
<h3>Build the .DLL</h3>
<p>
Build the project. You should get a .DLL file called IMammal.DLL.</p>
<h3>Create .REG File for Interface</h3>
<p>
We now need to build a .REG file that provides the registration information for our interface.
<ol>
<li>
Create IMammal.reg.<br><br></li>
<li>
Add the following keys, substituting the UUID for your interface and path and .DLL name as appropriate:<pre><code>REGEDIT
HKEY_CLASSES_ROOT\Interface\{7cca10d0-f823-11cd-8a02-00608cc80b9c} = IMammal
HKEY_CLASSES_ROOT\Interface\{7cca10d0-f823-11cd-8a02-00608cc80b9c}\ProxyStubClsid32 = {7cca10d0-f823-11cd-8a02-00608cc80b9c}
HKEY_CLASSES_ROOT\CLSID\{7cca10d0-f823-11cd-8a02-00608cc80b9c} = IMammal_PSFactory
HKEY_CLASSES_ROOT\CLSID\{7cca10d0-f823-11cd-8a02-00608cc80b9c}\InprocServer32 = c:\Source\Classes\Ifaces\IMammal\WinDebug\IMammal.dll
</code></pre>
</li>
<li>
With file still loaded and in front, select Tools\Register REG file. This will actually register your interface .DLL with the OLE system.</li>
</ol>
<h3>Implement IDog</h3>
<p>
For purposes of our sample code, follow the above instructions again, and create our interface for IDog, whose .IDL file looks like this:</p>
<pre><code>[
 &nbsp;&nbsp; object,
 &nbsp;&nbsp; uuid(7cca10d0-f823-11cd-8a02-00608cc80b9c),
 &nbsp;&nbsp; pointer_default(unique)
]

interface IDog : IUnknown
{
 &nbsp;&nbsp; import "unknwn.idl";

 &nbsp;&nbsp; HRESULT GetPetName([out, string, size_is(255)] char *p);
 &nbsp;&nbsp; HRESULT SetPetName([in, string] char *p);
 &nbsp;&nbsp; HRESULT IsBarking([out] BOOL *pBool);
}
</code></pre>
<h2>Implementing COM Classes</h2>
<p>
This section shows you how to create a COM object, which, by virtue of using the MFC libraries, can be compiled as either an INPROC .DLL or an OUT_OF_PROC .EXE. We do it in such a way that we are able to leverage the MFC ClassWizard support. Using ClassWizard to tack on OLE Automation in the future is a big savings when you get to that point. In addition, we are able to leverage all of the MFC libraries and save ourselves from having to implement tons of redundant code.</p>
<p>
When we are done creating our CLabrador class, we will have a class CLabrador that has two internal classes, XMammal and XDog, each of which is derived from the interface virtual class IMammal and IDog, respectively. Therefore the implementation of IMammal that CLabrador exports is the internal class XMammal.</p>
<p>
<img src="mfccom_2.gif" border=0></p>
<p>
The details of this process are hidden by the macros that are used. The full description of what goes on under the hood is in MFC Technical Article 38 (MSDN Library Archive, Technical Articles, Visual C++).</p>
<h3>Create a Project with AppWizard</h3>
<ol>
<li>
Create your Source\Classes<i> </i>directory.<br><br></li>
<li>
At File/New/Project<i> </i>in Visual C++, select MFC AppWizard (DLL).<br><br></li>
<li>
Make sure that the root directory is the Source\Classes directory.<br><br></li>
<li>
When it asks for a project name, type the name of your class. In our case, type "Labrador".<br><br></li>
<li>
Click/press Create<br><br></li>
<li>
Select “Use MFC in static library”.<br><br></li>
<li>
Select “OLE Automation”.<br><br></li>
<li>
Click/press Finish.</li>
</ol>
<h3>Use ClassWizard to Create a COM Class</h3>
<p>
We reenabled ClassWizard because we want to create a new C++ class derived from the MFC class CCmdTarget. A CCmdTarget is a base class that implements such functions as <b>IUnknown</b>, <b>IDispatch</b> for OLE Automation, and message dispatches for dealing with windows messages. It's a good thing to derive from, and by doing it from within ClassWizard, we not only get the base COM functionality, but we gain the ability to be created via <b>COleObjectFactory</b>, and we also get ClassWizard support for adding an OLE Automation interface to our COM object in the future, which is a very good thing. At any rate, you can ignore this description and just follow this list of commands. It's harder to read it than it is to just click and type everything in. Such is life.
<ol>
<li>
Go into ClassWizard, click Add Class.<br><br></li>
<li>
For the Class Name, type in <b>CLabrador</b>.<p class=tl>
<b>Note:</b>  We put a C in front of the name because this is the definition and implementation of the internal C++ class. Therefore the name of the DLL is Labrador, which is the COM class name, and the name of the internal C++ class is CLabrador. This is a personal preference; you are free to use whatever naming conventions you like.</P></li>
<li>
For the Class Type, select CCmdTarget. This is the MFC class from which you are going to derive all of your cool functionality.<p class=tl>
<b>Note:</b>  You might consider changing the names for the header and C++ source file at this point to follow whatever naming schemes you want, particularly if you don't like the ones generated by Visual C++.</P></li>
<li>
Check the OLE Automation check box, and check the OLE Creatable check box if your object can be created by itself. If it cannot, because it is dependent on another object already existing, do not click the OLE Creatable check box.<br><br></li>
<li>
The external name for the class should be “Labrador”. (That is, the class “Labrador” is implemented by Clabrador.)<br><br></li>
<li>
Click Create Class. You now have the framework for your Labrador class!</li>
</ol>
<h3>Create Class ID for Your Class</h3>
<p>
We want to have a header file that contains just the CLASSID for your Labrador COM class, without revealing the details of the implementation of it. We also want it to be in a common directory, so anyone interested in it can have a header file that easily defines it. So let's create one.
<ol>
<li>
Create Source\Classes\ClassIDs\LabID.h<p class=tl>
<b>Note:</b>  We do not put the C on the front because this is a file referring to the COM class, not the internal C++ class. We put the ID on the end to signify that this is the class ID for the Labrador COM class. Again, this is just a style issue, so do whatever you like.</P></li>
<li>
You could use GUIDGEN to generate your GUID for your CLASSID, but ClassWizard has already generated a GUID for your class when it generated the code. So go to Labrador.cpp, and copy the line that looks like this:<pre><code>IMPLEMENT_OLECREATE(CLabrador, "Labrador", 0x44bed660, 0xf517, 0x11cd,
0x8a, 0x2, 0x0, 0x60, 0x8c, 0xc8, 0xb, 0x9c) to LabradorID.h.
</code></pre>
</li>
<li>
Now change IMPLEMENT_OLECREATE( to be DEFINE_GUID(.<br><br></li>
<li>
Change CLabrador to be CLSID_Labrador, because this macro is defining the variable CLSID_Labrador.<br><br></li>
<li>
Remove the string "Labrador", which is not used in the DEFINE_GUID macro.<br><br></li>
<li>
Save the file. It should look as follows:<pre><code>//
// CLASS ID for CLabrador object
//
#ifndef _CLSID_Labrador_
#define _CLSID_Labrador_

// {A0D0B312-F1D5-11CD-8A01-00608CC80B9C}
DEFINE_GUID(CLSID_Labrador, 
0xa0d0b312, 0xf1d5, 0x11cd, 0x8a, 0x1, 0x0, 0x60, 0x8c, 0xc8, 0xb, 0x9c);

#endif
</code></pre>
</li>
</ol>
<h3>Create an Interface Definition Section for Each Supported Interface in Your Object</h3>
<p>
Each Interface exposed by our COM class is implemented using macros. These macros end up expanding to embedded classes derived from the virtual IXXXX interface definition. For an in-depth description of how all of this works, check out Technical Note 38 (MSDN Library Archive, Technical Articles, Visual C++). It gives a complete background on alternative methods of doing this, as well as on the workings of the macros that MFC provides.
<ol>
<li>
Edit Labrador.h (created above).<br><br></li>
<li>
Add #include "..\Ifaces\IDog\IDog.h" and #include "..\Ifaces\IMammal\IMammal.h" to the top of the header file.<br><br></li>
<li>
Define any internal variables in the Attributes section. In our case we will have two CStrings—"m_SpeciesName" and "m_PetName"—and two BOOL members, m_IsAlive and m_IsBarking.<br><br></li>
<li>
Add a DECLARE_INTERFACE_MAP() line at the bottom of your protected: section of the class.<br><br></li>
<li>
Add a BEGIN_INTERFACE_PART(Name, IName) and END_INTERFACE_PART(Name) where <i>IName</i> is the interface you are adding, and <i>Name</i> is that interface minus the 'I' character. What actually happens here is the macros are expanded to be <i>class XName : public IName</i> (that is to say, an internal class called XName is defined, which is derived from the virtual base class IName). If you don't understand what I just said, don't worry about it. Read Technical Note 38 (MSDN Library Archive, Technical Articles, Visual C++) if you want a real explanation of the magic here.<br><br></li>
<li>
Inside this section add a line for every method in your interface (refer back to the Objects\Interfaces files for the methods).<p class=tl>
<b>Note 1:</b> All return values must be HRESULT (standard OLE return value). If the return value is something different, MIDL will not provide marshalling information to marshal across process boundaries (this is mainly to provide network support). In the event of a network error, they want to ensure they can return a valid error code without having to throw an exception.</P><p class=tl>
<b>Note 2:</b>  You don't have to define IUnknown methods <b>AddRef()</b>, <b>Release()</b>, and <b>QueryInterface()</b>, because they are done automatically.</P><p class=tl>
<b>Note 3:</b>  Because at this point you are dealing with C++, you don't need to define the THIS parameter as you had to in the INTERFACE file.</P></li>
<li>
Add another BEGIN_INTERFACE_PART, END_INTERFACE_PART for each one of your interfaces.<br><br></li>
<li>
When you are done, Labrador.h should look as follows:<pre><code>// Labrador.h : main header file for the LABRADOR DLL
//

#ifndef __AFXWIN_H__
 &nbsp;&nbsp; #error include 'stdafx.h' before including this file for PCH
#endif

/////////////////////////////////////////////////////////////////////////////
// CLabradorApp
// See Labrador.cpp for the implementation of this class
//

class CLabradorApp : public CWinApp
{
public:
 &nbsp;&nbsp; CLabradorApp();

// Overrides
 &nbsp;&nbsp; // ClassWizard generated virtual function overrides
 &nbsp;&nbsp; //{{AFX_VIRTUAL(CLabradorApp)
 &nbsp;&nbsp; public:
 &nbsp;&nbsp; virtual BOOL InitInstance();
 &nbsp;&nbsp; //}}AFX_VIRTUAL

 &nbsp;&nbsp; //{{AFX_MSG(CLabradorApp)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // NOTE: ClassWizard will add and remove member functions here.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; DO NOT EDIT what you see in these blocks of generated code !
 &nbsp;&nbsp; //}}AFX_MSG
 &nbsp;&nbsp; DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CLabrador command target

#include "..\Ifaces\IDog\IDog.h" 
#include "..\Ifaces\IMammal\IMammal.h" 

class CLabrador : public CCmdTarget
{
 &nbsp;&nbsp; DECLARE_DYNCREATE(CLabrador)
protected:
 &nbsp;&nbsp; CLabrador();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // protected constructor used by dynamic creation

// Attributes
public:
 &nbsp;&nbsp; CString m_SpeciesName;
 &nbsp;&nbsp; CString m_PetName;
 &nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp; m_IsAlive;
 &nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp; m_IsBarking;

// Operations
public:

// Overrides
 &nbsp;&nbsp; // ClassWizard generated virtual function overrides
 &nbsp;&nbsp; //{{AFX_VIRTUAL(CLabrador)
 &nbsp;&nbsp; public:
 &nbsp;&nbsp; virtual void OnFinalRelease();
 &nbsp;&nbsp; //}}AFX_VIRTUAL

// Implementation
protected:
 &nbsp;&nbsp; virtual ~CLabrador();

 &nbsp;&nbsp; // Generated message map functions
 &nbsp;&nbsp; //{{AFX_MSG(CLabrador)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // NOTE - the ClassWizard will add and remove member functions here.
 &nbsp;&nbsp; //}}AFX_MSG

 &nbsp;&nbsp; DECLARE_MESSAGE_MAP()
 &nbsp;&nbsp; DECLARE_OLECREATE(CLabrador)

 &nbsp;&nbsp; // Generated OLE dispatch map functions
 &nbsp;&nbsp; //{{AFX_DISPATCH(CLabrador)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // NOTE - the ClassWizard will add and remove member functions here.
 &nbsp;&nbsp; //}}AFX_DISPATCH
 &nbsp;&nbsp; DECLARE_DISPATCH_MAP()
 &nbsp;&nbsp; DECLARE_INTERFACE_MAP() 

 &nbsp;&nbsp; BEGIN_INTERFACE_PART(Mammal, IMammal)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(GetSpeciesName)(char *pStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(IsAlive)(BOOL *pBool);
 &nbsp;&nbsp; END_INTERFACE_PART(Mammal)

 &nbsp;&nbsp; BEGIN_INTERFACE_PART(Dog, IDog)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(GetPetName)(char *pStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(SetPetName)(char *pStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(IsBarking)(BOOL *pBool);
 &nbsp;&nbsp; END_INTERFACE_PART(Dog)
};
</code></pre>
</li>
</ol>
<h3>Modify Labrador.cpp to Include Header Files</h3>
<p>
We need to add a couple of include files from our support directory:
<ol>
<li>
Edit Labrador.cpp.<br><br></li>
<li>
Add an <b>#include "..\support\ComHelp.h" </b>to the top of this file. This adds some helper macros I have created.<br><br></li>
<li>
Add all of your interface files, such as “..\Ifaces\Idog\Idog.h” and “..\Ifaces\Imammal\Imammal.h”.</li>
</ol>
<h3>Add .EXE Support Sections to Your COM Object</h3>
<p>
The next step is to modify the CLabradorApp so that it can be recompiled as an executable or a .DLL (which is to say, INPROC or OUTOFPROC). We do this by adding initialization calls to <b>InitInstance()</b> and by adding #ifdefs around the .DLL entry points.
<ol>
<li>
Edit CLabrdorApp::InitInstance(). Add a section that looks like this:<pre><code>#ifndef _WINDLL
// This section needed only if we are an .EXE.

// Figure out if we are being started by OLE.
if (!RunEmbedded() &amp;&amp; !RunAutomated())
{
COleObjectFactory::UpdateRegistryAll();
AfxMessageBox("Can't run standalone.");
return FALSE;
}

// Initialize OLE libraries.
if (!AfxOleInit())
{
AfxMessageBox("OLE Initilization failed!");
return FALSE;
}
#endif
</code></pre>
</li>
<li>
Find the section with the comment “Special entry points required for inproc servers”, followed by DllGetClassObject() and DllCanUnloadNow().<br><br></li>
<li>
Add #ifdef _WINDLL around the DllGetClassObject and DllCanUnloadNow APIs. This removes the INPROC entry points when you are making an OUT_OF_PROC .EXE server. It should look like this:<pre><code>// Special entry points required for inproc servers

#if (_MFC_VER &gt;= 0x300)
#ifdef _WINDLL
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return AfxDllGetClassObject(rclsid, riid, ppv);
}

STDAPI DllCanUnloadNow(void)
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return AfxDllCanUnloadNow();
}
#endif
#endif
</code></pre>
</li>
</ol>
<h3>Define Interface Mapping from IID to Interface Implementation</h3>
<p>
The next step is to implement the methods we defined above using the BEGIN_INTERFACE_PART sections. Again, this is fully documented in Technical Note 38 (MSDN Library Archive, Technical Articles, Visual C++). The DYNCREATE stuff is necessary to be able to utilize a common Class Factory provided by MFC, as well as the ability to identify the lineage of a particular class. For information on DYNCREATE, check out the Visual C++ documentation.
<ol>
<li>
Edit Labrador.cpp.<br><br></li>
<li>
Add a section that declares your interface map. This section essentially defines a table of mappings between the Interface IIDs for each interface, and the actual internal class definition that implements that interface within your class. This allows the CCmdTarget to automatically handle QueryInterface for us.<br><br></li>
<li>
Labrador.cpp should look as follows:<pre><code>//
// INTERFACE MAP for CLabrador
//
BEGIN_INTERFACE_MAP(CLabrador, CCmdTarget)
 &nbsp;&nbsp; INTERFACE_PART(CLabrador, IID_IMammal, Mammal)&nbsp; // map IID_IMammal to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // m_XMammal
 &nbsp;&nbsp; INTERFACE_PART(CLabrador, IID_IDog, Dog)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // map IID_IDog to m_XDog
END_INTERFACE_MAP()
</code></pre>
</li>
</ol>
<h3>Implement Interfaces Within Your Object</h3>
<p>
Now we actually implement the methods defined in our interfaces. Note that for the IUnknown case, we defer all of our IUnknown requests to the parent, allowing it to implement the details of those methods once. The parent ends up passing them to CCmdTarget, which kindly implements all of our Reference tracking and QueryInterface duties for us. The reason we use the <b>ExternalAddRef()</b> method is that CCmdTarget uses that as a way for the internal object to specify aggregation. This is essentially MFC's method for hiding the details of object aggregation. (If you don't know what that is, don't worry about it.)
<ol>
<li>
To support the IUnknown interfaces, we add a line IMPLEMENT_IUNKNOWN(CLabrador, Mammal). This uses the macros we defined in MFCComHelp.h to do the redirection that was described in step 2. This macro implements all of the IUnknown interfaces for IMammal.<br><br></li>
<li>
Now we actually implement the methods for each interface subclass, which is done with macros. Following is the IMammal definition. Notice that we are defining a method for the internal class XMammal, for the class CLabrador. Because we are an internal class, we don't have access to who our parent is, but this is what the METHOD_PROLOGUE macro does: It provides us with a pThis pointer, which is a pointer to the parent class (CLabrador in our case). Because the XMammal has friend status with CLabrador, it has access to all of the private parts of its parent, and we can access all of CLabrador's data directly via the pThis pointer.<pre><code>// *********************************************************************
// ************ CLabrador::XMammal implmentation of IMammal ************
// *********************************************************************

// IUnknown methods for XMammal class 
IMPLMENT_IUNKNOWN(CLabrador, Mammal)

// Extra methods that are part of IMammal
STDMETHODIMP CLabrador::XMammal::GetSpeciesName(char *pStr)
{
METHOD_PROLOGUE(CLabrador, Mammal);&nbsp;&nbsp;&nbsp;&nbsp; // Creates a pThis pointer to 
// CLabrador Parent
TRACE("CLabrador::XMammal::GetSpeciesName()\n");
if (pStr)
strcpy((char *)pStr, (LPCTSTR)pThis-&gt;m_SpeciesName);
return (HRESULT)NOERROR;&nbsp;&nbsp;&nbsp; // Gave them our name
}

STDMETHODIMP CLabrador::XMammal::IsAlive(BOOL *pBool)
{
METHOD_PROLOGUE(CLabrador, Mammal);&nbsp;&nbsp;&nbsp;&nbsp; // Creates a pThis pointer to 
// CLabrador Parent.
TRACE("CLabrador::XMammal::IsAlive()\n");
if (pBool)
{
*pBool = pThis-&gt;m_IsAlive;&nbsp;&nbsp;&nbsp; // Gave them our alive state.
return S_OK;
}
return E_BADPOINTER;
}
</code></pre>
</li>
<li>
Repeat step 2 for any additional interfaces defined, such as IDog.</li>
</ol>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Each interface requires its own AddRef/Release/QueryInterface implementation.</p>
<h3>Add Interface IID Definition Modules to Project</h3>
<p>
When the MIDL compiler generates your IID for an interface, it puts only an external reference to that IID structure in the IFoo.h header file. To get the actual definition of the IID structure, you need to link with a small module that contains the IID as a structure. The developers did this so that there would only be one definition for your application.
<ol>
<li>
Select Projects/Files.<br><br></li>
<li>
Add ..\Ifaces\IDog\IDog_i.c.<br><br></li>
<li>
Add ..\Ifaces\IMammal\IMammal_i.c.</li>
</ol>
<h3>Fix Precompiled Header Problem</h3>
<p>
When VC++ generates your project, it has precompiled headers up to STDAFX.H checked. Unfortunately, this doesn’t work with the files generated by the MIDL compiler, so you need to turn on Automatic Precompiled headers.
<ol>
<li>
Select Projects/Settings.<br><br></li>
<li>
Click C/C++ booktab.<br><br></li>
<li>
Click the “Precompiled Headers” category <br><br></li>
<li>
Turn off “Use PCH file”.<br><br></li>
<li>
Turn on Automatic use of Precompiled Headers.</li>
</ol>
<h3>Add.EXE Targets to Project to Support OUT_OF_PROC .EXE Object</h3>
<p>
So far we are set up for our object to be built as an INPROC server .DLL. Because we are using the MFC CWinApp-derived functions for our ClassFactory support code, we can change our object to be an OUTOFPROC server by simply creating a new .EXE target. All of the code stays the same, so in this section, we change our project targets so that we can build (1) Win32 debug and release DLL INPROC versions and (2) Win32 debug and release EXE OUT OF PROC versions.
<ol>
<li>
Click Project/Targets for the class project file.<br><br></li>
<li>
Click "Win32 Debug" and rename as "Win32 DLL Debug".<br><br></li>
<li>
Click "Win32 Release" and rename as "Win32 DLL Release".<br><br></li>
<li>
Click New.<br><br></li>
<li>
Type "Win32 EXE Debug"; click Win32 Application, Use Default Settings, and Debug Build.<br><br></li>
<li>
Click New.<br><br></li>
<li>
Type "Win32 EXE Release"; click Win32 Application, Use Default Settings; and turn off Debug Build.<br><br></li>
<li>
Exit this dialog, and go into the Project/Settings Dialog.<br><br></li>
<li>
Click the Win32 EXE Debug entry, go to the "General" section, and select "Use MFC In Shared DLL". Make the intermediate and output directory “WinEXEDebug”.<br><br></li>
<li>
Click the Win32 EXE Release entry, go to the "General" Section, and select "Use MFC In Shared DLL". Make the intermediate and output directory “WinEXERel”.</li>
</ol>
<p>
This makes the DLL target use WinDebug and WinRel, and makes the .EXE target WinExeDebug and WinExeRel. Now you can build a .DLL or .EXE by simply selecting the target. All the source code stays the same!</p>
<h3>Build Your .DLL or .EXE</h3>
<ol>
<li>
Select the .DLL target.<br><br></li>
<li>
Build it.<br><br></li>
<li>
Select the .EXE Target.<br><br></li>
<li>
Build it.</li>
</ol>
<p>
You now have both an INPROC and an OUTOFPROC server for your object.</p>
<h3>Register Your COM Object</h3>
<p>
Now we need to register with the system that your ClassID exists inside your DLL, and where your DLL resides. To do that, create a registry file. This makes it easy to define the registry entries once, and then distribute them to people who want to use it.
<ol>
<li>
Create a file called Labrador.reg.<br><br></li>
<li>
Add a line: REGEDIT.<br><br></li>
<li>
Add a line as follows, but substitute your ClassID string for the numbers below, and use the real path to your DLL after the equal line:<pre><code>HKEY_CLASSES_ROOT\CLSID\{12345678-1234-1234-1234-123456789ABC}\InprocServer32 = 
\path\to\labrador.dll
</code></pre>
</li>
<li>
Add a line as follows, but substitute your ClassID string for the numbers below, and use the real path to your .EXE after the equal line:<pre><code>HKEY_CLASSES_ROOT\CLSID\{12345678-1234-1234-1234-123456789ABC }\LocalServer32 = 
\path\to\labrador.exe
</code></pre>
</li>
<li>
Save your file as Labrador.reg. It should look like the following:<pre><code>REGEDIT
HKEY_CLASSES_ROOT\CLSID\{12345678-1234-1234-1234-123456789ABC } = Labrador Class
HKEY_CLASSES_ROOT\CLSID\{12345678-1234-1234-1234-123456789ABC }\InprocServer32 = 
\source\classes\Labrador\WinDebug\Labrador.dll
HKEY_CLASSES_ROOT\CLSID\{12345678-1234-1234-1234-123456789ABC }\LocalServer32 = 
\source\classes\Labrador\WinExeDebug\Labrador.exe
</code></pre>
</li>
<li>
Run <b>regedit -s labrador.reg </b>That's it! You have now registered your class with the system!</li>
</ol>
<p>
You can now test your COM object with custom interfaces!</p>
<h2>Using Your COM Object and Its Interfaces</h2>
<p>
OK, so now you have created a COM object, and you have registered it with the system. Now it is time to write a test program that actually uses the object.</p>
<h3>Create a Test Application with AppWizard</h3>
<p>
Umm. . . push the button. If you can't figure this one out, you probably haven't really made it this far yet.</p>
<h3>Include Interface Header File</h3>
<ol>
<li>
Add #include for INITGUID.H.<br><br></li>
<li>
Include all Interface definition files (for instance, IMammal.h and IDog.h).<br><br></li>
<li>
Include all ClassID definition files (such as LabID.h). For example:<pre><code>#include &lt;afxole.h&gt;
#include &lt;initguid.h&gt;
#include "..\Ifaces\IMammal\IMammal.h"
#include "..\Ifaces\IDog\IDog.h"
#include "..\ClassIDs\LabID.h"
</code></pre>
</li>
</ol>
<h3>Add Interface IID Files to the Project</h3>
<p>
When the MIDL compiler generates an IXXXX.H file, it generates the IID_IXXXX as a extern reference to a global variable. Then it also spits out a file called IXXXX_I.C. This file is nothing more than the global variable declaration of the IID_IXXXX. It operates this way so that there is only one definition for the whole project, as opposed to a definition that includes the header inside each object file. You need to add these interface global declaration files to your project so that they are compiled with your project.
<ol>
<li>
Open Projects/Files.<br><br></li>
<li>
Add Ifaces\IMammal\IMammal_i.c (this has just the 16-byte IID identifier in it).<br><br></li>
<li>
Add Ifaces\IDog\IDog_i.c (this has just the 16-byte IID identifier in it).<br><br></li>
<li>
Add any other IID definition files.</li>
</ol>
<h3>CoCreateInstance</h3>
<p>
<b>CoCreateInstance()</b> is the function that will create an instance of the object, as well as return a pointer to a particular interface of that object. Once you get your interface, you use the pointer to it to your heart's content, but call <b>Release()</b> on it when you are done. Here is some sample code:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;IMammal *pIMammal;
 &nbsp;&nbsp; IDog *pIDog;
 &nbsp;&nbsp; char szTmp[255];

 &nbsp;&nbsp; // Init OLE libraries.
 &nbsp;&nbsp; AfxOleInit();

#ifdef USE_IN_PROC&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Create an instance of a Labrador IN PROC.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; CoCreateInstance(&nbsp;&nbsp; CLSID_Labrador,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // CLASSID for CLabrador.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ignore this.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSCTX_INPROC_SERVER,&nbsp;&nbsp; // Server.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IMammal,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Interface you want.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID *)&amp;pIMammal);&nbsp;&nbsp; // Place to store interface.
#else
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Create an instance of a Labrador OUT_OF_PROC.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; CoCreateInstance(&nbsp;&nbsp; CLSID_Labrador,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // CLASSID for CLabrador.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ignore this.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSCTX_LOCAL_SERVER,&nbsp;&nbsp;&nbsp; // Server.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IMammal,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Interface you want.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID *)&amp;pIMammal);&nbsp;&nbsp; // Place to store interface.
#endif&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; if (pIMammal)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIMammal-&gt;GetSpeciesName(szTmp);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("Species name is &lt;%s&gt;\n",szTmp);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL fIsAlive;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIMammal-&gt;IsAlive(&amp;fIsAlive);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fIsAlive)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("And it's alive!\n");
 &nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("And it's dead!\n");

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Hey, maybe it's a Dog; let's ask it!

if (pIMammal-&gt;QueryInterface(IID_IDog, (LPVOID *)&amp;pIDog) == S_OK)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL fIsBarking;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIDog-&gt;GetPetName(szTmp);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("Dog's name is &lt;%s&gt;\n", szTmp);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIDog-&gt;IsBarking(&amp;fIsBarking);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fIsBarking)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("BARK! BARK! BARK! BARK!\n");

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIDog-&gt;SetPetName("KIVA");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIDog-&gt;GetPetName(szTmp);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("Dog's New name is &lt;%s&gt;\n", szTmp);

 &nbsp;&nbsp;&nbsp; // Release our IDog interface
 &nbsp;&nbsp;&nbsp; pIDog-&gt;Release();
 &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; // Release our IMammal interface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIMammal-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get COM to free unused libraries (a favor to COM).
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CoFreeUnusedLibraries();
 &nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
<h2>Appendix A. Common Problems</h2>
<p>
The following are tips that will help you avoid common problems:
<ul type=disc>
<li>
Check to make sure that your object is correctly registered in the registry. You can do this by running RegEdit32, or regedit -s.<br><br></li>
<li>
Check to make sure that your custom interface .DLL is properly registered in the registry.<br><br></li>
<li>
Double/triple check that the GUIDs under which you are registered are the correct ones.<br><br></li>
<li>
Double/triple check to make sure that paths to executables and/or .DLLs are correct.<br><br></li>
<li>
When you are tracing in the debugger, if you don’t see the “Labrador.DLL symbols loading” message, you aren’t even getting to the point of finding the .DLL, which points to a registry problem. Likewise, if you do see that, and it still fails to create, you are probably doing something wrong inside the object.<br><br></li>
<li>
Double check to make sure that you have added the proper .EXE support to your CLabradorApp class (AfxOleInit()).</li>
</ul>
<h2>Appendix B. Debugging Issues with COM Objects</h2>
<h3>Problems with Startup</h3>
<p>
One of the problems you may have with an out-of-process server is that you aren't running in the process that is being debugged. One way you can get around this is to add a <i>DebugBreak() </i>line as the first statement in your <b>CWinApp:InitInstance()</b> method. This will cause an exception, which if you press "cancel" will drop you into a debugger in the server executable. Once inside, you can set breakpoints as appropriate, running with two debuggers. This is useful for debugging situations in which you haven’t even successfully created the object yet. </p>
<h3>OLE RPC Debugging Support</h3>
<p>
If you are not having a problem with the initial startup code, Visual C++ actually supports tracing into a OLE RPC call to an out-of-process server. If you are on a line, such as pIDog-&gt;GetPetName() from the above sample, and you press F8 to trace the method, Visual C++ will actually launch another copy of Visual C++, attach it to the server executable, and trace the method. It will then Ping-Pong back and forth as you step in and out of the different modules. This is a good thing, and someone ought to buy the VC++ team a beer.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Make sure that you have the TOOLS/OPTIONS/DEBUG “Just in Time” debugging and “OLE RPC debugging” turned on.</p>
<h3>OUT_OF_PROC Servers</h3>
<p>
The other way that you can handle testing your out-of-process server is simply to start it with the /EMBEDDING switch. This is the signal that OLE uses when starting an .EXE to let it know that it should be in OLE mode.</p>
<h2>Appendix C. Adding OLE Automation</h2>
<p>
If you want to add OLE Automation support, there are numerous sources of VC++ information about creating OLE Automation with MFC, but here is a quick overview of how to use ClassWizard to add an OLE Automation interface to your new object.</p>
<h3>Adding OLE Automation Methods and Properties</h3>
<p>
Now we go into ClassWizard and use it to create our OLE Automation interface. This is where you realize the advantages of using the MFC libraries.
<ol>
<li>
Select Project\ClassWizard.<br><br></li>
<li>
Click the OLE Automation booktab.<br><br></li>
<li>
Click the Add Method button.<br><br></li>
<li>
Type <i>GetSpeciesName</i> in the external name field.<br><br></li>
<li>
Select Return type of BSTR (that's a string for you and me).<br><br></li>
<li>
Click OK.<br><br></li>
<li>
Click Add Property.<br><br></li>
<li>
Type <i>PetName</i> as the external name, and click Get/Set Methods. Notice that it has automatically created two method names, <b>GetPetName</b> and <b>SetPetName</b>.<br><br></li>
<li>
Set the data type to BSTR as well, and click OK.</li>
</ol>
<h3>Defining OLE Automation Methods and Properties</h3>
<p>
Now we define the functions that ClassWizard has defined in our ODL file.
<ol>
<li>
Double Click <b>GetSpeciesName()</b>. Notice that it took you to an implementation of a new C++ method on our class. This method actually gets called whenever someone makes an OLE Automation request to <b>GetSpeciesName</b>. All details of OLE Automation are hidden and taken care of; you just need to define the function.<br><br></li>
<li>
Delete the line that says <i>CString s</i>. We don't want to use this string, but we want to use our class data m_SpeciesName.<br><br></li>
<li>
Change the <i>s.AllocSysString</i> to <i>m_SpeciesName.AllocSysString()</i>. This says we want to return our internal class string in a global manner to OLE Automation.<br><br></li>
<li>
Now go back into ClassWizard and double-click the <b>GetPetName</b> property.<br><br></li>
<li>
Define it appropriately as well. You should end up with a chunk of code that looks like this:<pre><code>BSTR CLabrador::GetSpeciesName() 
{
 &nbsp;&nbsp; // TODO: Add your dispatch handler code here.
 &nbsp;&nbsp; return m_SpeciesName.AllocSysString();
}

BSTR CLabrador::GetPetName() 
{
 &nbsp;&nbsp; // TODO: Add your property handler here.
 &nbsp;&nbsp; return m_PetName.AllocSysString();
}

void CLabrador::SetPetName(LPCTSTR lpszNewValue) 
{
 &nbsp;&nbsp; // TODO: Add your property handler here.
 &nbsp;&nbsp; m_PetName = lpszNewValue;
}
</code></pre>
</li>
</ol>
<h3>Using OLE Automation from C++</h3>
<p>
MFC also has outstanding support for being an OLE Automation client. ClassWizard knows how to take a TypeLib (.TLB) file and generate a C++ class that completely handles all of the details of doing IDispatch, with all the methods having real type-safe checking information on them.</p>
<h4>Creating an interface class from TypeLib</h4>
<ol>
<li>
Create a test application using AppWizard.<br><br></li>
<li>
Go into ClassWizard for this application, and click the OLE Automation book tab.<br><br></li>
<li>
Click the Import OLE Automation Type Lib button.<br><br></li>
<li>
Select the ILabrador name, and tell it to create two classes called ILabrador.h and ILabrador.cpp.<br><br></li>
<li>
Add the generated .h and .cpp files to your project.</li>
</ol>
<p>
This class is now the a wrapper around the IDispatch interface.</p>
<h4>Using DispatchClass</h4>
<p>
To use this class, find an appropriate place, and take the following steps:
<ol>
<li>
Declare an ILabrador function.<br><br></li>
<li>
#include &lt;initguid.h&gt;.<br><br></li>
<li>
#include "\Source\Classes\ClassIDs\LabradorID.h".<br><br></li>
<li>
Call <b>CreateDispatch()</b>, passing the CLSID_Labrador.<br><br></li>
<li>
Call the methods. Ta-da! Your code should look like the following:<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;ILabrador iLab;
 &nbsp;&nbsp; CString Temp;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (iLab.CreateDispatch(CLSID_Labrador))
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = iLab.GetSpeciesName();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("GetSpeciesName() = %s", (LPCTSTR)Temp);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("IsAlive() is %d", iLab.GetIsAlive());

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = iLab.GetPetName();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("GetPetName() = %s", (LPCTSTR)Temp);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = "RILEY";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iLab.SetPetName(Temp);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp = iLab.GetPetName();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("GetPetName() = %s", (LPCTSTR)Temp);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iLab.ReleaseDispatch();
 &nbsp;&nbsp; }
</code></pre>
</li>
</ol>
<p>
For complete documentation on how this works, see the MFC COleDispatchDriver Class documentation.</p>
<h2>Appendix D. Reference Materials</h2>
<h3>Development Library</h3>
<p>
"Technical Note 33: DLL Version of MFC" (MSDN Library Archive, Technical Articles, Visual C++ 1.5 [16-bit] Articles, MFC 2.5 Technical Notes). This basically describes the differences between AfxDLLs and standalone DLLs. This is the information that led to the weird AppWizard workaround in the beginning.</p>
<p>
"Technical Note 38: MFC/OLE IUnknown Implementation" (MSDN Library Archive, Technical Articles, Visual C++ 1.5 [16-bit] Articles, MFC 2.5 Technical Notes). If you have any nagging questions about how the heck all of this works, you absolutely need to read this article. It describes what all of these macros are, what the alternatives are, and so forth.</p>
<p>
<i>Inside OLE 2</i> by Kraig Brockschmidt (MSDN Library, Books). A good overview of all the OLE technologies, from top to bottom.</p>
<p>
The RPC documentation contains a complete and comprehensive description of the IDL language that is used to describe your interface to RPC.</p>
<p>
The Win32 SDK [Ed. note: the Win32 SDK is now called the Platform SDK] describes the process of using the MIDL compiler (see Platform, SDK, and DDK Documentation).</p>
<p>
There is also a series of articles by Nigel Thompson that should provide a lot of information as well.</p>
<h3>MFC Class Definitions</h3>
<p>
Again, if you are curious about how all of this works:
<ul type=disc>
<li>
Check out CCmdTarget Documentation/Source code in MFC\SRC.<br><br></li>
<li>
Check out COleObjectFactory Documentation/Source code in MFC\SRC.<br><br></li>
<li>
For OLE automation, check out COleDispatchDriver.</li>
</ul>
<h2>Appendix E: INPROC Only Interface Definition Header Files</h2>
<p>
If you know that you only have an INPROC server, you don't have to do all of that marshalling rigamarole. Instead, you can use MFC-provided macros to define the interface as simply an IFoo.h file. But you should note that if you do end up going to MIDL, you are going to have to throw these files away and start over with an .IDL file.</p>
<p>
Each IXXXX interface needs a header file that other applications can include, that tells them what a particular interface looks like. This interface header is created by using MFC macros that hide all the gory details of class definitions, virtual function tables, and so forth.</p>
<p>
Here's what my interface definitions of IMammal and IDog look like. The main macros being used here are pretty straightforward. For more information, refer to the MFC documentation, in particular Technical Note 38 in the MSDN Library Archive.</p>
<pre><code>#ifndef _IMammal_
#define _IMammal_

#undef INTERFACE
#define INTERFACE IMammal

// {B312D550-EF8E-11cd-8A01-EEEEEEEEEEEE}
DEFINE_GUID(IID_IMammal, 
0xb312d550, 0xef8e, 0x11cd, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE);

DECLARE_INTERFACE_(IMammal, IUnknown)
{
 &nbsp;&nbsp; // Definition of IUnknown.
 &nbsp;&nbsp; STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *) PURE;
 &nbsp;&nbsp; STDMETHOD_(ULONG,AddRef)(THIS) PURE;
 &nbsp;&nbsp; STDMETHOD_(ULONG,Release)(THIS) PURE;

 &nbsp;&nbsp; // Definition of IMammal.
 &nbsp;&nbsp; STDMETHOD(GetSpeciesName)(THIS_ LPSTR) PURE;
 &nbsp;&nbsp; STDMETHOD_(BOOL, IsAlive)(THIS) PURE;
};
#endif
</code></pre>
<ol>
<li>
Create a new interface definition file, Interfaces\IMammal\IMammal.h.<br><br></li>
<li>
Run utility GUIDGEN, select the DEFINE_GUID format, and paste it into the appropriate section of the file. This is the statistically unique identifier for <i>this</i> interface for the world! <i>Do not use the one I have defined here, it's bogus!</i><br><br></li>
<li>
Change the &lt;&lt;name&gt;&gt; to the name of your Interface, IMammal.<br><br></li>
<li>
Create a line that says, DECLARE_INTERFACE_(IMammal, IUnknown). This creates a standard definition of virtual base class called IMammal, derived from the already-defined IUnknown.<br><br></li>
<li>
Every interface requires the three methods (QueryInterface, AddRef and Release) defined in IUnknown, so copy those three lines verbatim from above.<br><br></li>
<li>
Now add any methods you want your interface to support. There are two macros that are used to do this: One is STDMETHOD(MethodName)(THIS_ Parm1, Parm2) PURE, the other is STDMETHOD_(ReturnType, MethodName)(THIS Parm1, Parm2). The difference between the two is that STDMETHOD defaults to a return value of HRESULT, while STDMETHOD_ allows you to define the return value. Also note that inasmuch as an interface is language-independent, you need to have a THIS parameter passed to <i>all</i> methods for an interface. Use THIS if there are no parameters following, and use THIS_ if there are parameters following. These macros hide all language details from the user.<pre><code>#ifndef _IDog_
#define _IDog_

#undef INTERFACE
#define INTERFACE IDog

// {B312D550-EF8E-11cd-8A01-FFFFFFFFFFFF}
DEFINE_GUID(IID_IDog, 
0xb312d550, 0xef8e, 0x11cd, 0x8a, 0x1, 0x0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF);

DECLARE_INTERFACE_(IDog, IUnknown)
{
 &nbsp;&nbsp; // Definition of IUnknown.
 &nbsp;&nbsp; STDMETHOD(QueryInterface)(THIS_ REFIID, LPVOID *) PURE;
 &nbsp;&nbsp; STDMETHOD_(ULONG,AddRef)(THIS) PURE;
 &nbsp;&nbsp; STDMETHOD_(ULONG,Release)(THIS) PURE;

 &nbsp;&nbsp; // Definition of IDog.
 &nbsp;&nbsp; STDMETHOD(GetPetName)(THIS_ LPSTR) PURE;
 &nbsp;&nbsp; STDMETHOD_(BOOL, IsBarking)(THIS) PURE;
};
#endif
</code></pre>
</li>
</ol>
</BODY>
</HTML>
