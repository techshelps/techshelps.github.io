<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Connectors and Cables</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_cables"></a></sup>Connectors and Cables</h1>
<p>
Dennis Crain<br>
Microsoft Developer Network Technology Group</p>
<p>
May 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3313">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the DragBez sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes the exercise of creating a C++ base class that permits interactive drawing of two endpoints and a Bezier curve connecting them. The motivation for creating the class was a desire to draw electrical connectors and cables within an application. Although the result does not look like electrical connectors and cables, the <b>CCables</b> base class is implemented in such a way that the drawing functions are easily overridden to permit more realistic drawing. The class is useful where there is any need to draw two visual objects connected by a curve. Microsoft® Win32® sample code is provided for the class and an application that utilizes the class.</p>
<h2>Dennis Will Do It, Right?</h2>
<p>
So there I am, just minding my own business, reading the latest post from the Jag-lovers (Jag as in Jaguar the car) list server in Perth, Australia. This wiry little guy with a British accent comes up to me and says, "Dennis, I am writing a cool application that would look even cooler if the user interface included some nifty 3-D wire cables that plugged into gnarly-looking BNC or RCA connectors." Intently looking at him, I replied, "Sounds great. When are you going to write that code?" To which he replied, "This sounds right up your alley, Dennis." I knew that was coming! To humor him, I let him describe his vision with me. After all, I was reading mail about British cars and he is British.</p>
<p>
Well, you've probably guessed the rest of the story. Why else would I be writing this article? However, I envisioned a group effort on this project. I agreed to provide the first part, a C++ class that would provide a means of drawing two endpoints and a curve between them in 2-D. Doesn't sound very exciting, does it. Well, I got a bit excited over it. It was fun and really turns out to be quite useful. For instance, suppose you wanted to draw data-flow diagrams and the connections between them (one of my favorite things to do in my spare time!). You could simply take my code, throw it in your application, and draw data-flow diagrams to your heart's content.</p>
<p>
In addition to describing how I wrote the C++ class (<b>CCables</b>), I will show you how to modify the position of the endpoints (connectors) on the fly from within the calling class. Still not excited? How about a picture? If that doesn't get you interested, I suggest that you probably don't have a use for this topic.</p>
<p>
<img src="cables_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Sample connectors and cables</b></p>
<h2>The CCables Class</h2>
<p>
At conception, the <b>CCables</b> class was to provide a means for drawing two connectors and then drawing the cable between them. I selected the name <b>CCables</b> to suggest the use of the class to simulate an electrical cable situated between two electrical connectors (albeit the final product looks nothing like electrical connectors and cables). The connectors are represented by ellipses, and the cable is a Bezier curve. Of course, the functions that draw these elements are virtual and can be overridden. As the class evolved, I provided member functions to permit hit-testing of the connectors, to control the shape of the control polygon (for the Bezier curve), and to provide information about the connectors. The best place to start is in the CCABLES.H file.</p>
<h2>Inside CCABLES.H</h2>
<p>
The essential elements of the <b>CCables</b> class are a pair of connectors and a cable connecting them. Everything else is provided to properly render and query them. Three data members define the relationship between the two connectors and the cable between them.</p>
<h3>Data Members for the Connectors</h3>
<p>
The nice thing about sample code is that you don't need to be quite as flexible as would be required in production code. This is a terrific excuse to let you know that this class deals with a single curve with two endpoints. Consistent with the connector metaphor, the endpoints are called <i>m_FirstConnector</i> and <i>m_SecondConnector</i>. They are <b>CPoint</b> objects as illustrated below.</p>
<pre><code>CPoint m_FirstConnector;
CPoint m_SecondConnector;
</code></pre>
<h3>Data Member for the Cable</h3>
<p>
The cable is drawn as a Bezier curve. The only data member required for the curve is an array of control points as shown below. NUMCONTROLPTS is an enumerated type with a value of 4. I will discuss how these points are generated later, in the discussion of the implementation of the class.</p>
<pre><code>POINT&nbsp; m_CtrlPts[NUMCONTROLPTS];
</code></pre>
<h3>Other Data Members</h3>
<p>
As mentioned above, other data members are used to render and maintain the relationships between the connectors and the cable. Many of these data members are flags or symbols such as the following:</p>
<pre><code>const DWORD FIRSTCONNECT;
const DWORD SECONDCONNECT;
enum&nbsp;&nbsp; {NUMCONTROLPTS = 4};
enum&nbsp;&nbsp; {BADQUAD, QUAD1, QUAD2, QUAD3, QUAD4};
enum&nbsp;&nbsp; {CONNECTORRADIUS = 7};
enum&nbsp;&nbsp; {HITTESTRECTS = 2};
</code></pre>
<p>
The first two <b>const</b> <b>DWORD</b> variables are used as flags in the <b>OnDrawConnector</b> and <b>OnDrawCable</b> functions. Notice that after the two <b>const</b> <b>DWORD</b>s, several enumerated types are defined as well. Before I continue, I need to vent my feelings regarding the use of enumerated types versus the use of constants.</p>
<h4>Soap Box! Enumerated types versus constants</h4>
<p>
If you read my last article, <a href="msdn_mfcexp.htm">"MFC: I'll Never Use It!",</a> you know that I am new to C++. As such, I am accustomed to using the preprocessor to define various symbols that I need for use in my programs. So, my include files generally include lots of the following:</p>
<pre><code>#define FIRSTCONNECT&nbsp; 1
#define SECONDCONNECT 2
</code></pre>
<p>
Being a good engineer, I took a C++ class and was told that I should use constants instead of <b>#define</b> to ensure type safety. So I did this with two flags used in the <b>DrawConnector</b> function:</p>
<pre><code>const DWORD FIRSTCONNECT;
const DWORD SECONDCONNECT;
</code></pre>
<p>
The only problem I have with this is that I must now initialize them in the constructor, and copy constructor member initialization lists as follows:</p>
<pre><code>CCables::CCables(const CCables&amp; ccables) : FIRSTCONNECT (0x0001),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECONDCONNECT(0x0002)
{
...
}
</code></pre>
<p>
Although I like the prospect of type safety and the ability to see these symbols in my debugger, I really don't like how cluttered this could get. What if I had 300 flags and bitmasks? What a mess that would be! I have left these constants in the class just to demonstrate the use of a member initialization list. However, my preference is to use enumerated types.</p>
<p>
Using enumerated types, I would have defined the above two flags in the following manner in the include file:</p>
<pre><code>enum {FIRSTCONNECT = 0x0001, SECONDCONNECT = 0x0002};
</code></pre>
<p>
In my opinion, this is very straightforward and less error prone. Note that I use several enumerated types in the class. The only other alternative was to continue using <b>#define</b>. Having looked at lots of C++ code around Microsoft, I have found that the use of enumerated types is common. Unfortunately, so is the use of <b>#define</b>.</p>
<p>
OK, off the soap box!</p>
<h3>Other Data Members (continued)</h3>
<p>
The enumerated types (shown below again for convenience) are used for 1) the number of <b>POINT</b> structures in an array for the Bezier curve; 2) determining the direction of the mouse gesture away from the mouse click that determines the location of the first connector; 3) the radius of the ellipses used to draw the connectors; and 4) the number of <b>CRects</b> in an array used to track hit-testing areas over the connectors.</p>
<pre><code>enum&nbsp;&nbsp; {NUMCONTROLPTS = 4};
enum&nbsp;&nbsp; {BADQUAD, QUAD1, QUAD2, QUAD3, QUAD4};
enum&nbsp;&nbsp; {CONNECTORRADIUS = 7};
enum&nbsp;&nbsp; {HITTESTRECTS = 2};
</code></pre>
<p>
Finally, the following data members are used for 1) tracking the relative position of the mouse gesture from the mouse click that determines the first connector; 2) the orientation of the gesture away from the first connector (see #2 above); and 3) the rectangles associated with the connectors for hit-testing.</p>
<pre><code>int&nbsp;&nbsp;&nbsp; m_GestureLimit;
int&nbsp;&nbsp;&nbsp; m_GestureOrient;
CRect&nbsp; m_Hittest[HITTESTRECTS];
</code></pre>
<h3>Member Functions</h3>
<p>
The following code is CCABLES.H in its entirety. Public functions include <b>OnDrawConnector</b>, <b>OnDrawCable</b>, <b>SetConnectorPoint</b>, <b>SetGestureLimit</b>, <b>GetConnectorPoint</b>, and <b>HittestConnector</b>. An assignment operator and copy constructor are also provided. Two protected functions, <b>SetControlPoints</b> and <b>GetGestureOrientation</b>, are provided to assign the endpoints and the control polygon of the Bezier curve (the cable), and to determine the orientation of the control polygon, respectively.</p>
<pre><code>class CCables : public CObject
{
// Operations.
public:
  CCables();
  virtual ~CCables();
  CCables&amp; CCables::operator=(const CCables &amp; ccables);
  CCables::CCables(const CCables&amp; ccables);
  BOOL HittestConnector(CPoint point);
  CPoint GetConnectorPoint(int nConnectorNum);
  void SetConnectorPoint(CPoint point, int nConnectorNum, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRect *prectHittest = NULL);
  virtual BOOL SetGestureLimit(CPoint point);
  virtual BOOL OnDrawConnector(CDC *pdc, int nConnectorNum);
  virtual BOOL OnDrawCable(CDC *pdc, int nViewLandmarks);

protected:
  void SetControlPoints();
  void GetGestureOrientation(CPoint XY0, CPoint XY1);

// Attributes.
public:
  const DWORD FIRSTCONNECT;
  const DWORD SECONDCONNECT;

protected:
  enum&nbsp;&nbsp; {NUMCONTROLPTS = 4};
  enum&nbsp;&nbsp; {BADQUAD, QUAD1, QUAD2, QUAD3, QUAD4}; 
  enum&nbsp;&nbsp; {CONNECTORRADIUS = 7};
  enum&nbsp;&nbsp; {HITTESTRECTS = 2};
  CPoint m_FirstConnector;
  CPoint m_SecondConnector;
  POINT&nbsp; m_CtrlPts[NUMCONTROLPTS];
  int&nbsp;&nbsp;&nbsp; m_GestureLimit;
  int&nbsp;&nbsp;&nbsp; m_GestureOrient;
  CRect&nbsp; m_Hittest[HITTESTRECTS];
};
</code></pre>
<h2>Implementing CCables</h2>
<p>
Let's take a look at the implementation of the <b>CCables</b> class in three different areas. First we'll look at the class essentials, such as the constructor, destructor, copy constructor, and assignment operator. Then we will explore the two core functions of the class, <b>SetConnectorPoint</b> and <b>SetGestureLimit</b>, and the functions that support them. Finally we will briefly discuss the two virtual functions used to draw the connectors and cable, <b>OnDrawConnector</b> and <b>OnDrawCable</b>.</p>
<h3>Class Essentials</h3>
<p>
The class essentials include the constructor, destructor, assignment operator, and copy constructor.</p>
<h4>Constructor and destructor</h4>
<p>
The only thing unusual about the constructor is that awkward member initialization list (as discussed above). The <i>m_GestureOrient</i> variable is set to the BADQUAD enumerated type to simply establish the fact that the gesture orientation needs to be established (in the <b>GetGestureOrientation</b> function).</p>
<pre><code>CCables::CCables() : FIRSTCONNECT(0x0001), SECONDCONNECT(0x0002)
{
  m_GestureOrient = BADQUAD;
}
</code></pre>
<p>
The destructor does nothing special.</p>
<h4>Assignment operator and copy constructor</h4>
<p>
So why did I have to include an assignment operator? Why wouldn't the default assignment operator work? After all, there is nothing complex going on during assignment, as you can see in the following code.</p>
<pre><code>CCables&amp; CCables::operator=(const CCables&amp; ccables)
{
  m_FirstConnector = ccables.m_FirstConnector;
  m_SecondConnector = ccables.m_SecondConnector;
  memcpy(&amp;m_CtrlPts, &amp;ccables.m_CtrlPts, NUMCONTROLPTS * sizeof(POINT));
  m_GestureLimit = ccables.m_GestureLimit;
  m_GestureOrient = ccables.m_GestureOrient;
  memcpy(&amp;m_Hittest, &amp;ccables.m_Hittest, HITTESTRECTS * sizeof(CRect));
  return *this;
}
</code></pre>
<p>
As it turns out, the problem was not a problem at all, rather a "feature" to protect over-zealous programmers. If you look in AFX.H at the definition of <b>CObject</b>, you will find the assignment operator override has been made private. This effectively disables default assignment. A nearby comment in AFX.H indicates that this is to force compiler errors versus unexpected behavior. Talk about inconvenient! However, when you think about it, this makes perfect sense. After all, default assignment could be deadly if you are dynamically allocating memory in your class derived from <b>CObject</b>.</p>
<p>
In the <b>CObject</b> class, the copy constructor is also private. Note in the following code that the copy constructor must also include the member initialization list found with the constructor.</p>
<pre><code>CCables::CCables(const CCables&amp; ccables) : FIRSTCONNECT(0x0001),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECONDCONNECT(0x0002)
{
  m_FirstConnector = ccables.m_FirstConnector;
  m_SecondConnector = ccables.m_SecondConnector;
  memcpy(&amp;m_CtrlPts, &amp;ccables.m_CtrlPts, NUMCONTROLPTS * sizeof(POINT));
  m_GestureLimit = ccables.m_GestureLimit;
  m_GestureOrient = ccables.m_GestureOrient;
  memcpy(&amp;m_Hittest, &amp;ccables.m_Hittest, HITTESTRECTS * sizeof(CRect));
}
</code></pre>
<h3>Core Functions</h3>
<p>
So just what are the core functions? They are the functions that must be called before you can successfully draw the connectors and the cable. The core functions are <b>SetConnectorPoint</b> and <b>SetGestureLimit</b>. These functions call <b>SetControlPoints</b> and <b>GetGestureOrientation</b>, respectively.</p>
<h4>SetConnectorPoint</h4>
<p>
The prototype for this function is:</p>
<pre><code>BOOL CCables::SetConnectorPoint(CPoint point, int nConnectorNum,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRect *prectHittest = NULL);
</code></pre>
<p>
This function performs two tasks. One task is that of saving the rectangular area around the connector to be used as an area for subsequent hit-testing of the connector. If the <i>prectHittest</i> parameter is non-NULL, that rectangle becomes the area for hit-testing that particular connector. If this parameter is NULL, the rectangle is calculated based on the location of the connector and the CONNECTORRADIUS constant.</p>
<p>
However, the most important task of the function is to assign the locations of the two connectors to the <i>m_FirstConnector</i> and <i>m_SecondConnector</i> member variables. The variable for which the assignment is to operate on is determined by the <b>const</b> <b>DWORD</b> flags discussed earlier, FIRSTCONNECT and SECONDCONNECT. The following code illustrates this process.</p>
<pre><code>BOOL CCables::SetConnectorPoint(...)
{
...
 &nbsp;&nbsp; if (nConnectorNum == (int)FIRSTCONNECT)
 &nbsp;&nbsp;&nbsp;&nbsp; m_FirstConnector = point; 
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; m_SecondConnector = point; 
 &nbsp;&nbsp;&nbsp;&nbsp; SetControlPoints();
 &nbsp;&nbsp; }
...
};
</code></pre>
<p>
Notice that the <b>SetControlPoints</b> function is called after assigning a value to <i>m_SecondConnector</i>.</p>
<h4>SetControlPoints</h4>
<p>
The prototype for this function is:</p>
<pre><code>void SetControlPoints();
</code></pre>
<p>
This function assigns the appropriate values to an array of points,<i> m_CtrlPts</i>. Appropriate values are those values that form the control polygon for the Bezier curve to be drawn later. Figure 2 illustrates the geometry of the control polygon.</p>
<p>
<img src="cables_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Control polygon for drawing of Bezier curve to represent cable</b></p>
<p>
The points x0,y0 and x1,y1 correspond to the <i>m_FirstConnec</i>t and <i>m_SecondConnect</i> data members. Gesture corresponds to the <i>m_GestureLimit</i> data member. But you don't know anything about the gesture limit yet. So let's continue with the <b>SetGestureLimit</b> function.</p>
<h4>SetGestureLimit</h4>
<p>
The prototype for this function is:</p>
<pre><code>virtual BOOL SetGestureLimit(CPoint point);
</code></pre>
<p>
In the above discussion of the <b>SetControlPoints</b> function, I mentioned the <i>m_GestureLimit </i>data member. The value assigned to this data member is the distance, in the y direction, of the second and third control points from the endpoints. An example of a "gesture" is mouse movement as shown in Figure 3.</p>
<p>
<img src="cables_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Mouse gesture that determines y offset for control polygon (purple line represents arc of mouse movement)</b></p>
<p>
As shown in the following code, <i>m_GestureLimit</i> is the y component of the <b>CPoint</b> object passed to the function. The assignment is slightly different depending on the orientation of the mouse movement away from the origin of the connector. If the movement is out of the first or second quadrant of the connector, the y component is decreasinghence the conditional statement <i>m_GestureLimit = </i>(<i>point.y &lt;= m_GestureLimit</i>)<i> ? point.y : m_GestureLimit</i>. If the movement is out of the third for fourth quadrant, the y component is increasing. In this case the assignment is based on the condition statement <i>m_GestureLimit = </i>(<i>point.y &gt; m_GestureLimit</i>)<i> ? point.y : m_GestureLimit</i>.</p>
<pre><code>BOOL CCables::SetGestureLimit(CPoint point)
{
 &nbsp;&nbsp; if (m_GestureOrient == BADQUAD)
 &nbsp;&nbsp;&nbsp;&nbsp; GetGestureOrientation(m_FirstConnector, point);

 &nbsp;&nbsp; switch (m_GestureOrient)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; case QUAD1:
 &nbsp;&nbsp;&nbsp;&nbsp; case QUAD2:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_GestureLimit = (point.y &lt;= m_GestureLimit) ? point.y : m_GestureLimit;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; case QUAD3:
 &nbsp;&nbsp;&nbsp;&nbsp; case QUAD4:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_GestureLimit = (point.y &gt; m_GestureLimit) ? point.y : m_GestureLimit;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
However, before these assignments can be made, the direction of the mouse movement away from the connector must be known. That is why, in the code above, a call to <b>GetGestureOrientation</b> precedes the switch statement in which the assignment of <i>m_GestureLimit</i> takes place.</p>
<h4>GetGestureOrientation</h4>
<p>
The prototype for this function is:</p>
<pre><code>void CCables::GetGestureOrientation(CPoint XY0, CPoint XY1);
</code></pre>
<p>
This purpose of this function is to determine the direction of the mouse gesture away from the first endpoint (connector). Figure 4 illustrates the four directions considered relevant to the implementation of <b>GetGestureOrientation</b>.</p>
<p>
<img src="cables_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Four directions of mouse gesture away from connector</b></p>
<p>
To detect the direction in which the mouse is moving, two points are compared. If x1 is greater than x0, the two candidate directions are quadrants 1 and 4. If x1 is less than x0, the two candidates are quadrants 2 and 3. In the following code, notice that if there is no movement in the x or y direction (BADQUAD), the gesture limit is set to y0 and the function returns. This takes care of the special case where the mouse down and mouse up events occur at the same point.</p>
<pre><code>void CCables::GetGestureOrientation(CPoint XY0, CPoint XY1)
{
  if ((XY1.x - XY0.x == BADQUAD) || (XY1.y - XY0.y == BADQUAD))
  {
 &nbsp;&nbsp; m_GestureLimit = XY0.y;
 &nbsp;&nbsp; return;
  }
// Detect quadrant.
  m_GestureOrient = (XY1.x &gt;= XY0.x) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? ((XY1.y &gt;= XY0.y) ? QUAD4 : QUAD1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ((XY1.y &gt; XY0.y) ? QUAD3 : QUAD2);
  m_GestureLimit = XY0.y;
}
</code></pre>
<h3>Drawing Functions</h3>
<p>
Two functions, <b>OnDrawConnector</b> and <b>OnDrawCable</b>, are called to draw the connectors and cable, respectively. Each function is virtual to let you draw the connector and cable components as you see fit. The following discusses the base implementation of these functions.</p>
<h4>OnDrawConnector</h4>
<p>
The connector is drawn as an ellipse. The bounding rectangle for the ellipse is the previously determined rectangle used for hit-testing (in the <b>SetConnectorPoint</b> function). The function selects a NULL brush into the DC so that the interior of the ellipse is transparent.</p>
<pre><code>BOOL CCables::OnDrawConnector(CDC *pdc, int nConnectorNum)
{
  ASSERT (pdc);
  BOOL bRet = FALSE;
  // Draw connector based on hittest rect.
  if (pdc)
  {
 &nbsp;&nbsp; // Get the appropriate hittest rect.
 &nbsp;&nbsp; CRect rectDraw = (nConnectorNum &amp; FIRSTCONNECT) ? m_Hittest[0]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : m_Hittest[1];
 &nbsp;&nbsp; CBrush *pBrush = new(CBrush);
 &nbsp;&nbsp; pBrush-&gt;CreateStockObject(NULL_BRUSH);
 &nbsp;&nbsp; CBrush *OldBrush = pdc-&gt;SelectObject(pBrush);
 &nbsp;&nbsp; pdc-&gt;Ellipse((LPRECT)rectDraw);
 &nbsp;&nbsp; pdc-&gt;SelectObject(OldBrush);
 &nbsp;&nbsp; delete pBrush;
 &nbsp;&nbsp; bRet = TRUE;
  }
  return bRet;
}
</code></pre>
<h4>OnDrawCable</h4>
<p>
This function draws the cable as a Bezier curve, using the control points previously determined and set in the <b>SetConnectorPoint</b> function. In addition, the control polygon may be drawn if the <i>nViewLandmarks</i> parameter has a value greater than or equal to 1. The control points are copied to an array of points and passed to the GDI <b>PolyLine</b> function. Ellipses are used to draw the second and third control points for clarity. Note the use of a red solid pen for drawing the polyline.</p>
<pre><code>BOOL CCables::OnDrawCable(CDC *pdc, int nViewLandmarks)
{
  ASSERT (pdc);
  BOOL bRet = FALSE;

  if (pdc)
  {
 &nbsp;&nbsp; if (pdc-&gt;PolyBezier((const POINT *)&amp;m_CtrlPts, NUMCONTROLPTS))
 &nbsp;&nbsp;&nbsp;&nbsp; bRet = TRUE;

 &nbsp;&nbsp; if (nViewLandmarks)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; POINT points[4];
 &nbsp;&nbsp;&nbsp;&nbsp; points[0].x = m_CtrlPts[0].x;
 &nbsp;&nbsp;&nbsp;&nbsp; points[0].y = m_CtrlPts[0].y;
 &nbsp;&nbsp;&nbsp;&nbsp; points[1].x = m_CtrlPts[1].x;
 &nbsp;&nbsp;&nbsp;&nbsp; points[1].y = m_CtrlPts[1].y;
 &nbsp;&nbsp;&nbsp;&nbsp; points[2].x = m_CtrlPts[2].x;
 &nbsp;&nbsp;&nbsp;&nbsp; points[2].y = m_CtrlPts[2].y;
 &nbsp;&nbsp;&nbsp;&nbsp; points[3].x = m_CtrlPts[3].x;
 &nbsp;&nbsp;&nbsp;&nbsp; points[3].y = m_CtrlPts[3].y;

 &nbsp;&nbsp;&nbsp;&nbsp; CPen cpen(PS_SOLID, 1, RGB(0xFF, 0x00, 0x00));
 &nbsp;&nbsp;&nbsp;&nbsp; CPen *cpOldPen = pdc-&gt;SelectObject(&amp;cpen);
 &nbsp;&nbsp;&nbsp;&nbsp; // Draw control polygon.
 &nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;Polyline((LPPOINT)&amp;points, 4);
 &nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;SelectObject(cpOldPen);
 &nbsp;&nbsp;&nbsp;&nbsp; cpen.DeleteObject();
 &nbsp;&nbsp;&nbsp;&nbsp; // Draw 2nd and 3rd control points.
 &nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;Ellipse(m_CtrlPts[1].x-2, m_CtrlPts[1].y-2, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_CtrlPts[1].x + 2, m_CtrlPts[1].y + 2);
 &nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;Ellipse(m_CtrlPts[2].x -2, m_CtrlPts[2].y -2, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_CtrlPts[2].x + 2, m_CtrlPts[2].y + 2);
 &nbsp;&nbsp; }
  }
  return bRet;
}
</code></pre>
<h2>Using CCables in DragBez</h2>
<p>
The DragBez sample interactively utilizes the <b>CCables</b> class. I used the application wizard to create DragBez. It is a single-document interface (SDI) application. The user uses the left mouse button to click and drag the cable in the desired direction. When the user releases the left mouse button, the second connector and the cable are drawn. To reposition the connectors and cables, the user clicks a connector (using the right mouse button) and drags the connector to a new position.</p>
<p>
The action all takes place in the mouse event handlers in the view class (in the DRAGBVW.CPP file). In addition to discussing how the <b>CCables</b> class is used, I will discuss how I used the <b>CList</b> template.</p>
<h3>Left Mouse Events</h3>
<p>
DragBez has two relevant left mouse eventsleft mouse down and left mouse up. Left mouse events create new connectors and cables.</p>
<h4>Left mouse down</h4>
<p>
The sequence of events begins with a left mouse down event. When this event takes place, the <b>OnLButtonUp</b> function is called. This function simply allocates a <b>CCables</b> object (<i>m_pCables</i>) and calls <b>CCable::SetConnectorPoint</b> and <b>CCable::OnDrawConnector</b> as described above. Note that the object is not deleted in this function. It will be used later and added to a list of <b>CCables</b> objects.</p>
<pre><code>void CDragbezView::OnLButtonDown(UINT nFlags, CPoint point) 
{
 &nbsp;&nbsp; CDC *pdc = GetDC();
 &nbsp;&nbsp; // If m_pCables, then user probably released Lbutton outside of 
 &nbsp;&nbsp; // client area, so delete dangling pointer.
 &nbsp;&nbsp; if (m_pCables)
 &nbsp;&nbsp;&nbsp;&nbsp; delete(m_pCables);
 &nbsp;&nbsp; m_pCables = new(CCables);
 &nbsp;&nbsp; m_bGestureSet = FALSE;
 &nbsp;&nbsp; if (m_pCables &amp;&amp; pdc)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; m_pCables-&gt;SetConnectorPoint(point, m_pCables-&gt;FIRSTCONNECT);
 &nbsp;&nbsp;&nbsp;&nbsp; m_pCables-&gt;OnDrawConnector(pdc, m_pCables-&gt;FIRSTCONNECT);
 &nbsp;&nbsp;&nbsp;&nbsp; ReleaseDC(pdc);
 &nbsp;&nbsp; }
}
</code></pre>
<h4>Left mouse up</h4>
<p>
When the user releases the left mouse button, the <b>OnLButtonUp</b> event handler is called. The location at which this takes place is assumed to be the location of the second connector. Accordingly, <b>CCable::SetConnectorPoint</b> is called, using the SECONDCONNECT flag. The connector is drawn by calling <b>CCable::OnDrawConnector</b>. Then the cable is drawn by a call to <b>CCable::OnDrawCable</b>. Finally, the <b>CCable</b> object is added to a list of objects.</p>
<pre><code>void CDragbezView::OnLButtonUp(UINT nFlags, CPoint point) 
{
 &nbsp; CDC *pdc = GetDC();
 &nbsp; if (m_pCables &amp;&amp; pdc)
 &nbsp; {
 &nbsp;&nbsp;&nbsp; if (!m_bGestureSet)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bGestureSet = m_pCables-&gt;SetGestureLimit(point);
 &nbsp;&nbsp;&nbsp; m_pCables-&gt;SetConnectorPoint(point, m_pCables-&gt;SECONDCONNECT);
 &nbsp;&nbsp;&nbsp; m_pCables-&gt;OnDrawConnector(pdc, m_pCables-&gt;SECONDCONNECT);
 &nbsp;&nbsp;&nbsp; m_pCables-&gt;OnDrawCable(pdc, m_ViewLandmarks);
 &nbsp;&nbsp;&nbsp; // Add the ccable object.
 &nbsp;&nbsp;&nbsp; m_connectorlist.AddTail(*m_pCables);
 &nbsp;&nbsp;&nbsp; delete(m_pCables);
 &nbsp;&nbsp;&nbsp; m_pCables = NULL;
 &nbsp;&nbsp;&nbsp; ReleaseDC(pdc);
 &nbsp; }
}
</code></pre>
<h3>Right Mouse Events</h3>
<p>
DragBez acts upon two right mouse eventsright mouse down and right mouse up. Right mouse events modify connectors and cable locations.</p>
<h4>Right mouse down</h4>
<p>
When a right mouse down event occurs, the list of previously drawn connectors is traversed. As the list is traversed, the location of the right mouse down event is compared to the hit-test rectangle (in the <b>CCable::HittestConnector</b> function) that is part of each <b>CCable</b> object in the list. If the right mouse point is within the hit-test rectangle, success is assumed and the traversal of the list stops. The point associated with the connector is then retrieved by calling <b>CCable::GetConnectorPoint</b>. This point is assigned to <i>m_OldMousePos</i>. Why the old mouse position? Well, remember, right mouse events are used to modify the position of the connectors.</p>
<pre><code>void CDragbezView::OnRButtonDown(UINT nFlags, CPoint point) 
{
 &nbsp;&nbsp; POSITION pos;
 &nbsp;&nbsp; pos = m_connectorlist.GetHeadPosition();
 &nbsp;&nbsp; while (pos) {
 &nbsp;&nbsp;&nbsp;&nbsp; m_pos = pos;
 &nbsp;&nbsp;&nbsp;&nbsp; m_PickedCable = m_connectorlist.GetNext(pos);
 &nbsp;&nbsp;&nbsp;&nbsp; if ((m_nConnector = m_PickedCable.HittestConnector(point)))
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bConnectorHit = TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_OldMousePos = m_PickedCable.GetConnectorPoint(m_nConnector);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_szHitPointDiff = m_OldMousePos - point;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bConnectorHit = FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
}
</code></pre>
<h4>Right mouse up</h4>
<p>
It is assumed that when the user releases the right mouse button, the location at which that takes place will become the new location of the connector. So, the list is updated with the <b>CCable</b> object in its current state.</p>
<pre><code>void CDragbezView::OnRButtonUp(UINT nFlags, CPoint point) 
{
 &nbsp;&nbsp; if (m_pos)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; m_connectorlist.SetAt(m_pos, m_PickedCable);
 &nbsp;&nbsp;&nbsp;&nbsp; InvalidateRect(NULL);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; MessageBeep(0);
}
</code></pre>
<p>
But something is missing here. How is the position information within the object getting updated? This is happening in the mouse move handler, <b>OnMouseMove</b>.</p>
<h3>Mouse Move Handler</h3>
<p>
The <b>OnMouseMove</b> function handles mouse movement while the left or right mouse button is depressed. Recall that these two states correspond to the general observation that the left mouse button is involved in the creation of connectors and the cable, and the right mouse button is associated with the modification of existing connectors and cables.</p>
<p>
During mouse movement with the left mouse button depressed, <b>CCable::SetGestureLimit</b> is called. You may recall that this function is one of the core functions of the <b>CCables</b> class; it is used to assign the y component of the second and third control points for the Bezier curve used to represent the cable.</p>
<pre><code>void CDragbezView::OnMouseMove(UINT nFlags, CPoint point) 
{
 &nbsp;&nbsp; if (nFlags &amp; MK_LBUTTON)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (m_pCables)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bGestureSet = m_pCables-&gt;SetGestureLimit(point);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; if (nFlags &amp; MK_RBUTTON)
 &nbsp;&nbsp;&nbsp;&nbsp; ...
}
</code></pre>
<p>
When the right mouse button is depressed during mouse movement, things become a bit more complicated. After making sure that a connector was successfully hit-tested, the ROP code is changed to R2_NOT, the old connector and cable are drawn, the new connector position is set in the object (by a call to <b>CCable::SetConnectorPoint</b>), and the connectors and cable are drawn. The following code illustrates these steps.</p>
<pre><code>void CDragbezView::OnMouseMove(UINT nFlags, CPoint point) 
{
 &nbsp;&nbsp; if (nFlags &amp; MK_LBUTTON)
 &nbsp;&nbsp;&nbsp;&nbsp; ...
 &nbsp;&nbsp; if (nFlags &amp; MK_RBUTTON)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (m_bConnectorHit &amp;&amp; m_pos)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDC *pdc = GetDC();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pdc)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD nConnect = (m_nConnector &amp; m_PickedCable.FIRSTCONNECT) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? m_PickedCable.FIRSTCONNECT 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : m_PickedCable.SECONDCONNECT;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int oldrop = pdc-&gt;SetROP2(R2_NOT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_PickedCable.SetConnectorPoint(m_OldMousePos, nConnect);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_PickedCable.OnDrawConnector(pdc, nConnect);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_PickedCable.OnDrawCable(pdc, m_ViewLandmarks);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point.Offset(m_szHitPointDiff);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_PickedCable.SetConnectorPoint(point, nConnect);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_PickedCable.OnDrawConnector(pdc, nConnect);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_PickedCable.OnDrawCable(pdc, m_ViewLandmarks);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_OldMousePos = point;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdc-&gt;SetROP2(oldrop);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReleaseDC(pdc);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
}
</code></pre>
<h3>CList Template</h3>
<p>
I used the <b>CList</b> template for the list of <b>CCable</b> objects. To create a list, I included the following in the public section of DRAGVW.H:</p>
<pre><code>CList &lt;CCables, CCables&amp;&gt; m_connectlist
</code></pre>
<p>
It was all very straightforward and convenient. However, I did run into a problem that was not addressed in any of the documentation that I encountered. I needed to provide my own assignment operator. You may recall my earlier discussion about this. <b>CList</b> is derived from <b>CObject</b>. If you look in AFX.H at the definition of <b>CObject</b>, you will find the assignment operator override has been made private. This disables default assignment. So, it is just a simple matter of providing an assignment operator in your own class derived from <b>CObject.</b></p>
<h2>Summary</h2>
<p>
The <b>CCable</b> class started out as an exercise to create electrical connectors and cables for use in a co-worker's application. This article describes the creation of the base class for doing this. Although the resultant connectors and cables look nothing like electrical connectors and cables, the base class is very useful should you need to have any two visual objects connected by a curved line (represented by a Bezier curve). Perhaps my co-worker will use the class as a base for his <b>3DCCables</b> class!</p>
</BODY>
</HTML>
