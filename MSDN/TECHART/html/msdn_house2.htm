<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFC/COM Objects 2: Using Interfaces</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_house2"></a></sup>MFC/COM Objects 2: Using Interfaces</h1>
<p>
Nigel Thompson<br>
Microsoft Developer Network Technology Group</p>
<p>
March 20, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4230">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the HOUSE2 sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4246">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the Animate library.</a></p>
<h2>Abstract</h2>
<p>
This technical article is the second in a series that describes creating and using 32-bit Component Object Model (COM) objects with Visual C++™ and the Microsoft® Foundation Class Library (MFC). This article describes how COM object interfaces are used to control the objects themselves.</p>
<h2>Introduction</h2>
<p>
In <a href="msdn_house1.htm">"MFC/COM Objects 1: Creating a Simple Object,"</a> we looked at creating a simple COM object and using that object from inside an application. The object we created was a simple light bulb, which supported an interface that allowed the application using the object to tell the object to draw itself. I called that interface <b>IDrawing</b>. The application didn't need to know anything about the light bulb other than the fact that it supported the <b>IDrawing</b> interface. Because the application (the house) knew how to use the <b>IDrawing</b> interface, it was able to show the light bulb by calling appropriate functions in the light bulb's <b>IDrawing </b>interface.</p>
<p>
What I'm going to do next is introduce some other objects: a standard lamp, a TV, and a radio. These new objects will all support the <b>IDrawing</b> interface, so the house will be able to show them in the rooms they occupy. We're also going to define some new interfaces and show how the house can use these new interfaces to control one of the objects (the lamp, TV, or radio) without knowing exactly what kind of object it's actually dealing with.</p>
<p>
What's the point of this? The idea is that at some point in the future, new objects can be added to the house, and the house will be able to control those new objects without any changes in the house code, providing the new objects support the interfaces the house understands. So the house code becomes somewhat future-proof as new appliances are invented.</p>
<h2>An Interface Hierarchy</h2>
<p>
All appliances are not created equal. Some appliances are very simple and can only be turned on and off. Lights can be on or off, and some lights can be set at intermediate levels of brightness. And some appliances, like TVs or radios, can be off or on, but also can be on a particular station, and so on.</p>
<p>
It's obviously possible to design an interface that deals with off and on. It's reasonably easy to see how to design an interface that also deals with brightness, but it's not easy to see how to design the totally universal remote control that would be needed to control all the TVs, radios, and stereos in the world. It's not even very practical to try to design a future-proof TV or radio controller, so how are we going to produce a generic interface that the house can use for TVs and radios? We're not. We're going to let the appliance itself do that, and the house will simply ask the appliance if it has some fancy interface of its own that it can show to the user.</p>
<p>
So when the house wants to control an appliance, it first asks the appliance if it has its own user interface, and if so, it tells the appliance to show the control panel to the user. If the appliance isn't that smart, the house tries to see if the appliance has a brightness-control interface. If it does, the house can show a simple dimmer-type control, and use the brightness interface in the appliance to set the light level in response to what the user does with the dimmer. And as a last resort, the house can see if the appliance supports the on-off interface, and if so, the house can show the user a simple switch and use the appliance's on-off interface to control it.</p>
<p>
The interfaces that the house understands are as follows: </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=31%><b>Interface</b></td>
<td class=label width=69%><b>Functions</b></td>
</tr>
<tr valign=top>
<td width=31%><b>IOutlet</b></td>
<td width=69%><b>On</b>, <b>Off</b>, and <b>GetState</b></td>
</tr>
<tr valign=top>
<td width=31%><b>ILight</b></td>
<td width=69%><b>SetBrightness</b> and <b>GetBrightness</b></td>
</tr>
<tr valign=top>
<td width=31%><b>IApplianceUI</b></td>
<td width=69%><b>ShowControl</b></td>
</tr>
</table><br>
<p>
All appliances support one or more of these interfaces. Let's see how the house uses these when the user double-clicks an object:</p>
<pre><code>void CMainFrame::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
 &nbsp;&nbsp; if(m_pSelectRect == NULL) return; // No selection

 &nbsp;&nbsp; // Get the object's IUnknown interface pointer.
 &nbsp;&nbsp; IUnknown* pIUnknown = m_pAppliance[m_iSelect];
 &nbsp;&nbsp; ASSERT(pIUnknown);

 &nbsp;&nbsp; // See if it supports the IApplianceUI interface.
 &nbsp;&nbsp; IApplianceUI* pIApplianceUI = NULL;
 &nbsp;&nbsp; if (pIUnknown-&gt;QueryInterface(IID_IApplianceUI,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID*)&amp;pIApplianceUI) == S_OK) {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Put up the interface.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIApplianceUI-&gt;ShowControl(this);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIApplianceUI-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // See if it supports the ILight interface.
 &nbsp;&nbsp; ILight* pILight = NULL;
 &nbsp;&nbsp; if (pIUnknown-&gt;QueryInterface(IID_ILight,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID*)&amp;pILight) == S_OK) {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Put up the interface.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLightDlg* pDlg = new CLightDlg;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDlg-&gt;m_pILight = pILight;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDlg-&gt;m_pParent = this;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDlg-&gt;Create();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pILight-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // See if it supports the IOutlet interface.
 &nbsp;&nbsp; IOutlet* pIOutlet = NULL;
 &nbsp;&nbsp; if (pIUnknown-&gt;QueryInterface(IID_IOutlet,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID*)&amp;pIOutlet) == S_OK) {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Put up the interface.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COutletDlg* pDlg = new COutletDlg;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDlg-&gt;m_pIOutlet = pIOutlet;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDlg-&gt;m_pParent = this;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDlg-&gt;Create();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIOutlet-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }


 &nbsp;&nbsp; // Pretty much a dead loss, this one.
 &nbsp;&nbsp; AfxMessageBox("This appliance is not controllable");
}
</code></pre>
<p>
First of all, the house gets a pointer to the object's <b>IUnknown</b> interface. This pointer was saved when the object was first created and inserted in the house. Then the object's <b>IUnknown::QueryInterface</b> function is called to see if the object supports the <b>IApplianceUI</b> interface. If it does, the object is asked to show its own control. Figure 1 shows the radio's controller.</p>
<p>
<img src="house2_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The radio's controller</b></p>
<p>
If <b>IApplianceUI</b> is not supported, the house tries for the <b>ILight</b> interface. If this is supported by the object, the house puts up a slider control like the one shown in Figure 2.</p>
<p>
<img src="house2_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The house's light controller</b></p>
<p>
When the user moves the slider, the house uses the object's <b>ILight::SetBrightness</b> function to set the new light level.</p>
<p>
If the object doesn't support <b>ILight</b>, the house finally tries for the <b>IOutlet</b> interface, and if it finds the interface, it uses a control like the one shown in Figure 3 to allow the user to switch the appliance on or off.</p>
<p>
<img src="house2_3.gif" border=0></p>
<p class=label>
<b>Figure 3. The house's on-off controller</b></p>
<h2>What Happens When Objects Change State</h2>
<p>
If you've played with the HOUSE2 sample, you'll have discovered that the lights do turn on and off, and the radio plays a tune. That's what we wanted to happen, of course, but there's a part of the story that I've skipped. Let's say you double-clicked on a light bulb and got a controller like the one shown in Figure 3. You click the On button, and the house responds by calling the object's <b>IOutlet::On</b> function. The object then sets its own state to be ON. Fine and dandy, but how does the image of the light in the house change to show the new state? The object can't just redraw itself because it can't know how the house is rendering its own image. For example, the house may be using an off-screen bitmap to compose changes in its own image. In order to show the new state of the light bulb, the house must ask the light bulb to draw itself to the off-screen buffer (or whatever) and then make these changes show on the screen.</p>
<p>
In the sample shown here, I cheated to make the light bulb's visible state change. When you click the buttons in the Outlet dialog box, the dialog code sends a message to the house's main window, asking it to repaint itself. As a result of this message, the house will ask the light bulb to draw itself, and so you'll see the change of state.</p>
<p>
When you play with the radio's buttons, the radio itself starts the tune playing. There is no visible change of state in the house—perhaps you hadn't noticed that!</p>
<p>
What we have so far is a push-only system. The application using the COM objects is telling them what to do, but isn't providing a path for information from the objects to the application. So currently there is no way for an appliance to tell the house that its state has changed and the house should redraw it.</p>
<p>
Another side effect of this push-only model is that if you double-click an object twice, so as to bring up two instances of its controller, you'll find that the controllers don't know about each other. So (for example) if you have two sliders controlling the same light, moving one slider doesn't move the other one—it just changes the state of the light.</p>
<p>
What we really need is a way for users of an object to be notified of changes of state in the object. When an object changes state, its users may indicate that change by either redrawing the object or showing a control in a new position. We'll be looking at how to implement this in the next article in the series, <a href="msdn_house3.htm">"MFC/COM Objects 3: Objects That Talk Back."</a></p>
<h2>Objects with Multiple Interfaces</h2>
<p>
The COM objects we created in the previous article, <a href="msdn_house1.htm">"MFC/COM Objects 1: Creating a Simple Object,"</a> had only a single interface: <b>IDrawing</b>. Let's look at what's required to support several interfaces in a single object. We'll look at how the standard lamp that implements <b>IDrawing</b>, <b>IOutlet</b>, and <b>ILight</b> was done. Let's begin by looking at what got added to the header file to define the new interfaces. Here's part of the STANDARD.H file showing all the interface definitions:</p>
<pre><code>class CStandardLamp : public CCmdTarget
{
 &nbsp; [...]

 &nbsp;&nbsp; // Declare the interface map for this object.
 &nbsp;&nbsp; DECLARE_INTERFACE_MAP()

 &nbsp;&nbsp; // IDrawing interface
 &nbsp;&nbsp; BEGIN_INTERFACE_PART(Drawing, IDrawing)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(Draw)(CDC* pDC,int x, int y);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(SetPalette)(CPalette* pPal);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(GetRect)(CRect* pRect);
 &nbsp;&nbsp; END_INTERFACE_PART(Drawing)

 &nbsp;&nbsp; // IOutlet interface
 &nbsp;&nbsp; BEGIN_INTERFACE_PART(Outlet, IOutlet)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(On)();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(Off)();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(GetState)(BOOL* pState);
 &nbsp;&nbsp; END_INTERFACE_PART(Outlet)

 &nbsp;&nbsp; // ILight interface
 &nbsp;&nbsp; BEGIN_INTERFACE_PART(Light, ILight)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(SetBrightness)(BYTE bLevel);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(GetBrightness)(BYTE* pLevel);
 &nbsp;&nbsp; END_INTERFACE_PART(Light)

 &nbsp; [...]
};
</code></pre>
<p>
Notice that all that's needed is a declaration of each interface supported. The <b>BEGIN_INTERFACE_PART</b> and <b>END_INTERFACE_PART</b> macros are supplied by the Microsoft® Foundation Class Library (MFC). The <b>STDMETHOD</b> macro is supplied by the OLE libraries (which define COM objects).</p>
<p>
The implementation is a little bit more involved because every interface must support the <b>IUnknown</b> interface functions. MFC provides almost everything needed to support <b>IUnknown</b> in your own interfaces, but you still need to write a small amount of code to implement <b>AddRef</b>, <b>Release</b>, and <b>QueryInterface</b>. If you refer to the first article in this series (<a href="msdn_house1.htm">"MFC/COM Objects 1: Creating a Simple Object"</a>), you'll see that I included code for these functions in the <b>IDrawing</b> interface. We need to include almost exactly the same code in the <b>IOutlet</b> and <b>ILight</b> interfaces. In fact, it's so similar that I gave in and used a macro to avoid repeatedly typing the same code. The macro is called <b>IMPLEMENT_IUNKNOWN</b> and can be found in the IMPIUNK.H file. Please note that although this sounds a lot like an MFC macro name, it is <i>not</i> an MFC macro. Here it is:</p>
<pre><code>#ifndef IMPLEMENT_IUNKNOWN

#define IMPLEMENT_IUNKNOWN_ADDREF(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; STDMETHODIMP_(ULONG) ObjectClass::X##InterfaceClass::AddRef(void) \
 &nbsp;&nbsp; { \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; METHOD_PROLOGUE(ObjectClass, InterfaceClass); \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pThis-&gt;ExternalAddRef(); \
 &nbsp;&nbsp; }

#define IMPLEMENT_IUNKNOWN_RELEASE(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; STDMETHODIMP_(ULONG) ObjectClass::X##InterfaceClass::Release(void) \
 &nbsp;&nbsp; { \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; METHOD_PROLOGUE(ObjectClass, InterfaceClass); \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pThis-&gt;ExternalRelease(); \
 &nbsp;&nbsp; }

#define IMPLEMENT_IUNKNOWN_QUERYINTERFACE(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; STDMETHODIMP ObjectClass::X##InterfaceClass::QueryInterface(REFIID riid, LPVOID* ppVoid) \
 &nbsp;&nbsp; { \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; METHOD_PROLOGUE(ObjectClass, InterfaceClass); \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HRESULT)pThis-&gt;ExternalQueryInterface(&amp;riid, ppVoid); \
 &nbsp;&nbsp; }

#define IMPLEMENT_IUNKNOWN(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; IMPLEMENT_IUNKNOWN_ADDREF(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; IMPLEMENT_IUNKNOWN_RELEASE(ObjectClass, InterfaceClass) \
 &nbsp;&nbsp; IMPLEMENT_IUNKNOWN_QUERYINTERFACE(ObjectClass, InterfaceClass)

#endif // IMPLEMENT_IUNKNOWN
</code></pre>
<p>
Now that we have the macro, we can look at how the standard lamp's interfaces are implemented with a bit less clutter. The first addition is to the interface map:</p>
<pre><code>BEGIN_INTERFACE_MAP(CStandardLamp, CCmdTarget)
 &nbsp;&nbsp; INTERFACE_PART(CStandardLamp, IID_IDrawing, Drawing)
 &nbsp;&nbsp; INTERFACE_PART(CStandardLamp, IID_IOutlet, Outlet)
 &nbsp;&nbsp; INTERFACE_PART(CStandardLamp, IID_ILight, Light)
END_INTERFACE_MAP()
</code></pre>
<p>
We have simply added entries for the <b>IOutlet</b> and <b>ILight</b> interfaces.</p>
<p>
I'm not going to show you the implementation of <b>IDrawing</b> because that's unchanged. Let's look at how <b>IOutlet</b> is implemented:</p>
<pre><code>/////////////////////////////////////////////////////////
// IOutlet interface

// IUnknown for IOutlet
 &nbsp;&nbsp; IMPLEMENT_IUNKNOWN(CStandardLamp, Outlet)

// IOutlet methods
STDMETHODIMP CStandardLamp::XOutlet::On()
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CStandardLamp, Outlet);
 &nbsp;&nbsp; pThis-&gt;m_bLevel = 255;
 &nbsp;&nbsp; return NOERROR;
}

STDMETHODIMP CStandardLamp::XOutlet::Off()
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CStandardLamp, Outlet);
 &nbsp;&nbsp; pThis-&gt;m_bLevel = 0;
 &nbsp;&nbsp; return NOERROR;
}

STDMETHODIMP CStandardLamp::XOutlet::GetState(BOOL* pState)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CStandardLamp, Outlet);
 &nbsp;&nbsp; if (!pState) return E_INVALIDARG;
 &nbsp;&nbsp; *pState = (pThis-&gt;m_bLevel &gt; 0) ? TRUE : FALSE;
 &nbsp;&nbsp; return NOERROR;
}
</code></pre>
<p>
Yes, that's the entire thing. The <b>IMPLEMENT_IUNKNOWN</b> macro saves a lot of clutter. Note that each of the methods must include the METHOD_PROLOGUE macro, which provides access to the member of the containing class (<b>CStandardLamp</b>) and its <b>pThis</b> member. The actual implementation of the functionality of the <b>On</b>, <b>Off</b>, and <b>GetState</b> functions is trivial.</p>
<p>
Implementation of the <b>ILight</b> interface is even simpler:</p>
<pre><code>// IUnknown for ILight
 &nbsp;&nbsp; IMPLEMENT_IUNKNOWN(CStandardLamp, Light)

// ILight methods
STDMETHODIMP CStandardLamp::XLight::SetBrightness(BYTE bLevel)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CStandardLamp, Light);
 &nbsp;&nbsp; pThis-&gt;m_bLevel = bLevel;
 &nbsp;&nbsp; return NOERROR;
}

STDMETHODIMP CStandardLamp::XLight::GetBrightness(BYTE* pLevel)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CStandardLamp, Light);
 &nbsp;&nbsp; if (!pLevel) return E_INVALIDARG;
 &nbsp;&nbsp; *pLevel = pThis-&gt;m_bLevel;
 &nbsp;&nbsp; return NOERROR;
}
</code></pre>
<h2>Summary</h2>
<p>
Adding interfaces to an existing COM object is quite simple. For an application to use a new interface, it is required only to understand the interface; it need have no knowledge of the nature of the actual object that supports it.</p>
<p>
You might try adding a new appliance to the sample given here and see if the house can control it correctly. If your new appliance is to have its own user interface, take a look at how the radio was implemented.</p>
</BODY>
</HTML>
