<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OpenGL V: Translating Windows DIBs</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_gl5"></a></sup>OpenGL V: Translating Windows DIBs</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
February 8, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3268">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the EasyDIB sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3270">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the GLlib DLL for this technical article.</a></p>
<h2>Abstract</h2>
<p>
OpenGL™ is a portable language for rendering three-dimensional (3-D) graphics. OpenGL does not understand Microsoft® Windows® device-independent bitmaps (DIBs); instead, it has its own format for representing images. This article explains how to translate a Windows DIB into a format usable with OpenGL. Some knowledge of the Windows DIB format and the Microsoft Foundation Class Library (MFC) is expected. The EasyDIB sample application and GLlib dynamic-link library (DLL) demonstrate the ideas presented in this article.</p>
<h2>Introduction</h2>
<p>
Back when I was in college, I had a French roommate we called Fred because we couldn't pronounce his real name. Fred took a trip around the U.S. in an old maroon Oldsmobile. This car was amazing. The speedometer didn't work; it always read zero miles per hour unless the car was in reverse. The parking brake didn't work; you had to flash the blinkers yourself. Only the passenger door would open. Yet, the engine ran beautifully. . . until Fred and the car got to Mississippi. There, in the middle of I-20, the engine suddenly stopped and the speedometer started working.</p>
<p>
Luckily, Fred was close to a phone booth and called for a tow truck. Now, Fred's English was impeccable, but he had a French accent, and the tow truck driver spoke English with one of those delightful Southern accents only found in Mississippi. As a result, Fred couldn't understand the tow truck driver, and the tow truck driver couldn't understand Fred, although they were both speaking English.</p>
<p>
Fred didn't stay stranded that hot, humid July day, because the tow truck driver's wife came to the rescue. She translated her husband's Southern drawl into English for Fred and Fred's French-accented English into Southern drawl for her husband.</p>
<p>
Amazingly, there is an analogy between this story and using Windows® device-independent bitmaps (DIBs) with OpenGL™. Give me a minute to find it. . . .</p>
<p>
Windows DIBs represent graphic images. OpenGL can display graphic images. However, OpenGL cannot display Windows DIBs directly. Windows DIBs must be translated into a slightly different format to be rendered by OpenGL. Like the tow truck driver's wife, who translated English into English, we'll translate an image into an image for OpenGL.</p>
<h2>Background</h2>
<p>
This section provides some background information to help explain why Windows DIBs do not work directly with OpenGL. OpenGL is portable across a wide variety of platforms, from the X Window System™ to high-end Silicon Graphics® workstations. On all of these systems, OpenGL uses the <b>glDrawPixels</b> command to display an image on the screen. Each system uses a slightly different native format for images: The X Window System uses a pixmap, Microsoft® Windows uses a DIB, and OpenGL has its own format required by <b>glDrawPixels</b>.</p>
<p>
To render bitmaps with OpenGL, an application must translate the image format used by the system to the format used by OpenGL. Figure 1 illustrates this process.</p>
<p>
<img src="gl5_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Image formats must be converted for use with OpenGL.</b></p>
<p>
In this article, my focus is on converting Windows DIBs to a format usable by OpenGL. Figure 2 shows the process covered by this article.</p>
<p>
<img src="gl5_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Translating a Windows DIB for use with OpenGL</b></p>
<h2>OpenGL Image Format</h2>
<p>
The OpenGL function that renders images, <b>glDrawPixels</b>, provides a good place to start examining the OpenGL image format. Chapter 8 in the <i>OpenGL Programming Guide</i> (also called the "Red Book"; see the bibliography at the end of this article) and the <i>OpenGL Reference Manual</i> (also called the "Blue Book"; see the bibliography) both provide information on <b>glDrawPixels</b>.</p>
<p>
The prototype for <b>glDrawPixels </b>is as follows:</p>
<pre><code>glDrawPixels( GLsizei width,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLsizei height,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLenum format,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Glenum type,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const GLvoid *pixels) ;
</code></pre>
<p>
The first two parameters specify the width and height of the image, in pixels. The last parameter is a pointer to the pixel data itself. The other two parameters, <i>format</i> and <i>type</i>, tell <b>glDrawPixels</b> how to interpret the data that the <i>pixels</i> parameter points to. </p>
<p>
The <i>format</i> parameter specifies the composition of each element in the image. It can have the following values:
<ul type=disc>
<li>
GL_RGB<br><br></li>
<li>
GL_RGBA<br><br></li>
<li>
GL_COLOR_INDEX<br><br></li>
<li>
GL_STENCIL_INDEX<br><br></li>
<li>
GL_DEPTH_COMPONENT<br><br></li>
<li>
GL_RED<br><br></li>
<li>
GL_GREEN<br><br></li>
<li>
GL_BLUE<br><br></li>
<li>
GL_ALPHA<br><br></li>
<li>
GL_LUMINANCE<br><br></li>
<li>
GL_LUMINANCE_ALPHA</li>
</ul>
<p>
In this article, we'll deal only with GL_RGB and GL_RGBA, because these parameters follow the formats used by Microsoft Windows most closely. </p>
<p>
The <i>type </i>parameter specifies the data type of the information in the image. It can have the following values:
<ul type=disc>
<li>
GL_UNSIGNED_BYTE<br><br></li>
<li>
GL_BYTE<br><br></li>
<li>
GL_BITMAP<br><br></li>
<li>
GL_UNSIGNED_SHORT<br><br></li>
<li>
GL_SHORT<br><br></li>
<li>
GL_UNSIGNED_INT<br><br></li>
<li>
GL_INT<br><br></li>
<li>
GL_FLOAT</li>
</ul>
<p>
The code in this article uses GL_UNSIGNED_BYTE, because that's the data type that Windows uses for its DIBs.</p>
<p>
Take the following example:</p>
<pre><code>glRasterPos3d(x, y, z) ;
glDrawPixels(cx, cy, GL_RGB, GL_UNSIGNED_BYTE, pPixels) ;
</code></pre>
<p>
OpenGL draws the image stored at <b>pPixels </b>at the coordinate (<i>x</i>, <i>y</i>, <i>z</i>). The <i>void* pPixels</i> variable points to RGB triples stored as three unsigned bytes. Figure 3 summarizes what we learned about the image format by studying <b>glDrawPixels</b>.</p>
<p>
<img src="gl5_3.gif" border=0></p>
<p class=label>
<b>Figure 3. OpenGL image format</b></p>
<p>
The following example is slightly different from our previous example:</p>
<pre><code>glRasterPos3d(x, y, z) ;
glDrawPixels(cx, cy, GL_RGBA, GL_UNSIGNED_BYTE, pPixels) ;
</code></pre>
<p>
Instead of storing RGB triples, the GL_RGBA format parameter specifies that each pixel is made up of four unsigned bytes—one byte each for the red, green, blue, and alpha components.</p>
<p>
Although examining <b>glDrawPixels</b> does provide us with some insight into how OpenGL stores images, we still need to answer some questions, such as how the pixels are stored in memory.</p>
<h3>glPixelStore</h3>
<p>
The OpenGL <b>glPixelStore</b> command controls how pixels are stored in, and read from, memory. In OpenGL, the term "pack" refers to putting images in memory, and the term "unpack" refers to reading images from memory and putting them on the screen. We want to translate a Windows DIB into a format that OpenGL can unpack and display on the screen. Therefore, our interest lies only in the unpacking functionality of <b>glPixelStore</b>.</p>
<p>
<b>glPixelStore</b> controls six OpenGL parameters that affect unpacking images. The following table (based on the table in Chapter 8 of the Red Book) lists these parameters:</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=38%><b>Parameter Name</b></td>
<td class=label width=19%><b>Type</b></td>
<td class=label width=20%><b>Initial Value</b></td>
<td class=label width=23%><b>Valid Range</b></td>
</tr>
<tr valign=top>
<td width=38%>GL_UNPACK_ SWAP_BYTES</td>
<td width=19%>GLboolean</td>
<td width=20%>FALSE</td>
<td width=23%>TRUE/FALSE</td>
</tr>
<tr valign=top>
<td width=38%>GL_UNPACK_LSB_FIRST</td>
<td width=19%>GLboolean</td>
<td width=20%>FALSE</td>
<td width=23%>TRUE/FALSE</td>
</tr>
<tr valign=top>
<td width=38%>GL_UNPACK_ROW_LENGTH</td>
<td width=19%>GLint</td>
<td width=20%>0</td>
<td width=23%>i &gt; 0</td>
</tr>
<tr valign=top>
<td width=38%>GL_UNPACK_SKIP_ROWS</td>
<td width=19%>GLint</td>
<td width=20%>0</td>
<td width=23%>i &gt; 0</td>
</tr>
<tr valign=top>
<td width=38%>GL_UNPACK_SKIP_PIXELS</td>
<td width=19%>GLint</td>
<td width=20%>0</td>
<td width=23%>I &gt; 0</td>
</tr>
<tr valign=top>
<td width=38%>GL_UNPACK_ALIGNMENT</td>
<td width=19%>GLint</td>
<td width=20%>4</td>
<td width=23%>1, 2, 4, 8</td>
</tr>
</table><br>
<p>
The GL_UNPACK_SWAP_BYTES parameter is needed only when transferring images between systems that order bytes differently. We can ignore this parameter because we are using the DIBs on a Microsoft Windows system.</p>
<p>
GL_UNPACK_LSB_FIRST is used only with 1-bit-per-pixel (bpp) images, which we don't cover in this article.</p>
<p>
The next three parameters, GL_UNPACK_ROW_LENGTH, GL_UNPACK_SKIP_ROWS, and GL_UNPACK_SKIP_PIXELS, are used to display a piece of a larger image. We're interested in displaying the entire image, so we can ignore these flags as well.</p>
<p>
This leaves us with one measly flag, GL_UNPACK_ALIGNMENT, which controls the alignment of pixel rows. The following table shows the allowable values for GL_UNPACK_ALIGNMENT and their meanings:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Value</b></td>
<td class=label width=79%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=21%>1</td>
<td width=79%>Byte alignment (that is, no alignment)</td>
</tr>
<tr valign=top>
<td width=21%>2</td>
<td width=79%>Row alignment to even-numbered bytes</td>
</tr>
<tr valign=top>
<td width=21%>4</td>
<td width=79%>Word alignment</td>
</tr>
<tr valign=top>
<td width=21%>8</td>
<td width=79%>Double-word alignment</td>
</tr>
</table><br>
<p>
GL_UNPACK_ALIGNMENT will pad the end of a row with enough bytes to start the next row on the proper boundary. </p>
<p>
It's amazing that the Red Book does not mention the ordering of the RGB triple in memory. As mentioned in the Blue Book, red is always stored first, followed by green, and then blue. This order cannot be modified with <b>glPixelStore</b>. Figure 4 summarizes what we learned about the image format by studying <b>glPixelStore</b>.</p>
<p>
<img src="gl5_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Storage of an OpenGL image</b></p>
<p>
From the discussion above, we can see that an OpenGL image is a chunk of memory with a certain format, type, alignment, width, and height. Pretty simple, really.</p>
<p>
For more information, see the section "Storing, Transforming, and Mapping Pixels" in Chapter 8 of the Red Book.</p>
<h2>Windows DIB Format</h2>
<p>
At a basic level, a Windows DIB is similar to an OpenGL image in that both consist of a chunk of memory in a specific format. Unfortunately, the formats are different. Window DIBs come in almost as many flavors as Baskin-Robbins ice cream. For example, Windows DIBs may have 1-, 4-, 8-, 16-, 24-, and 32-bpp formats and a variety of compression types. My biggest complaint with Windows DIBs is the lack of functions for handling DIBs: Win32® has no functions for loading DIBs and very few functions that help you use DIBs.</p>
<p>
Fortunately, the Development Library includes plenty of information about the Windows DIB format. (See the bibliography at the end of this article for a listing.) The best source of information is Nigel Thompson's book <i>Animation Techniques for Win32</i> (available from Microsoft Press®). In fact, I use Nigel's <b>CDIB </b>class to read all Windows DIBs.</p>
<p>
The Windows DIB format differs from the OpenGL image format in its storage of RGB components. The red, green, blue (RGB) order in OpenGL is reversed to blue, green, red (BGR) in a Windows DIB. In addition, the rows of the DIB are <b>DWORD</b>-aligned in a Windows DIB. Figure 5 shows the format of a Windows DIB.</p>
<p>
<img src="gl5_5.gif" border=0></p>
<p class=label>
<b>Figure 5. 24-bpp DIB format</b></p>
<h3>Loading a DIB</h3>
<p>
As I mentioned in the previous section, I used the <b>CDIB</b> class from Nigel's animation library to load the Windows DIB. The <b>CDIB </b>class has a very convenient <b>Load </b>member function that takes a filename and loads the file. Here is the code from GLlib that loads a Windows DIB and starts the translation process:</p>
<pre><code>void CGLImage::Load(LPCTSTR filename, TRANSLATEMETHOD enumMethod)
{
 &nbsp; //
 &nbsp; // Is an image already loaded?
 &nbsp; //
 &nbsp; if (m_pBits) 
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Clean up previous image.
 &nbsp;&nbsp;&nbsp;&nbsp; free(m_pBits );
 &nbsp;&nbsp;&nbsp;&nbsp; m_pBits = NULL ;
 &nbsp;&nbsp;&nbsp;&nbsp; m_iHeight = 0 ;
 &nbsp;&nbsp;&nbsp;&nbsp; m_iWidth = 0 ;
 &nbsp; }

 &nbsp; //
 &nbsp; // Create a DIB using Nigel's animation library.
 &nbsp; //
 &nbsp; CDIB aDib ;
 &nbsp; aDib.Load(filename) ;

 &nbsp; // Get width and height in pixels.
 &nbsp; m_iWidth&nbsp;&nbsp;&nbsp; = aDib.GetWidth() ; 
 &nbsp; m_iHeight&nbsp;&nbsp;&nbsp; = aDib.GetHeight() ;

 &nbsp; //
 &nbsp; // Create a palette from the colors in the DIB.
 &nbsp; //
 &nbsp; CDIBPal aPalSrc ;
 &nbsp; aPalSrc.Create(&amp;aDib) ;

 &nbsp; //
 &nbsp; // Translate using one of three methods.
 &nbsp; //
 &nbsp; m_enumMethod = enumMethod;
 &nbsp; switch(m_enumMethod)
 &nbsp; {
 &nbsp; case TRANS_GDI:
 &nbsp;&nbsp;&nbsp;&nbsp; m_PixelFormat = GL_RGBA ;
 &nbsp;&nbsp;&nbsp;&nbsp; TranslateByGDI(aDib, aPalSrc) ;
 &nbsp;&nbsp;&nbsp;&nbsp; break ;
 &nbsp; case TRANS_BOTH:
 &nbsp;&nbsp;&nbsp;&nbsp; m_PixelFormat = GL_RGB ;
 &nbsp;&nbsp;&nbsp;&nbsp; TranslateByBoth(aDib, aPalSrc) ;
 &nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; case TRANS_DIY:
 &nbsp; default: 
 &nbsp;&nbsp;&nbsp;&nbsp; m_PixelFormat = GL_RGB ;
 &nbsp;&nbsp;&nbsp;&nbsp; TranslateByYourself(aDib, aPalSrc) ;
 &nbsp; }

}
</code></pre>
<p>
I also used Nigel's <b>CDIBPal </b>class, which conveniently creates a palette from a <b>CDIB </b>object's color table. Using Nigel's classes really simplified this part of the code. </p>
<h2>Translation</h2>
<p>
Now that we have examined the formats of Windows DIB and OpenGL images, we are ready to translate from one format to the other. We'll examine three methods for translating the Windows DIB to a format usable by OpenGL. In the first method, we write all the translation code ourselves. In the second method, we use the graphics device interface (GDI) to do all the work. In the last method, we use GDI to do part of the translation and provide some extra code to finish the work. The translation methods are called from <b>CGLImage::Load</b> in GLlib. See the previous section for a listing of this code.</p>
<h3>Do-It-Yourself Method</h3>
<p>
The first method of translation is the do-it-yourself method. In this method, we write all the code that translates a DIB to an OpenGL image. Because we write the code, we know exactly what the translation process is. The disadvantage of this method is that a DIB can have many different formats, all of which the translation code must handle. The source code in <b>CGLImage::TranslateByYourself</b> handles 4-, 8-, and 24-bpp DIBs. The other formats are left as an exercise for the reader. </p>
<p>
<b>CGLImage::TranslateByYourself</b> converts Windows DIBs to an array of 24-bpp structures (<b>CGLRGBTRIPLE</b>) with no padding. A skeleton of <b>TranslateByYourself</b> is shown below. The details of the actual translation are given later in this section.</p>
<pre><code>int nBitsPerPix = aDib.GetBitsPerPixel() ;
void* pBits&nbsp;&nbsp;&nbsp;&nbsp; = aDib.GetBitsAddress() ;
int storageWidth = aDib.GetStorageWidth() ; // storage width in BYTES!

CGLRGBTRIPLE* pGLRGB =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (CGLRGBTRIPLE*)malloc(m_iWidth*m_iHeight*sizeof(CGLRGBTRIPLE));
CGLRGBTRIPLE* pDest = pGLRGB ;

switch(nBitsPerPixel)
{
case 24:
.
.
.
 &nbsp; break ;
case 8:
.
.
.
 &nbsp; break ;
.
.
.
}
</code></pre>
<p>
The image is rendered with the OpenGL command:</p>
<pre><code>glPixelStorei(GL_UNPACK_ALIGNMENT, 1) ;
glDrawPixels(m_iWidth, m_iHeight, GL_RGB, GL_UNSIGNED_BYTE, m_pBits) ;
</code></pre>
<p>
<b>glPixelStore </b>turns padding off. The call to <b>glDrawPixels </b>uses the GL_RGB pixel format to specify a 24-bpp format for the memory that <b>m_pBits</b> points to.</p>
<p>
As I mentioned above, <b>CGLImage::TranslateByYourself </b>creates a new chunk of memory consisting of <b>CGLRGBTRIPLE </b>structures, which are defined in IMAGE.CPP as follows:</p>
<pre><code>typedef struct _CGLRGBTRIPLE {
 &nbsp; BYTE rgbRed ;
 &nbsp; BYTE rgbGreen ;
 &nbsp; BYTE rgbBlue ;
} CGLRGBTRIPLE ;
</code></pre>
<p>
The placement of the red and blue color components in this structure differs from the placement of components in the Windows <b>RGBTRIPLE</b> structure. Windows places the blue color component first in memory, whereas OpenGL looks for the red color component first.</p>
<pre><code>typedef struct _RGBTRIPLE { //rgbt
 &nbsp; BYTE rgbtBlue ;
 &nbsp; BYTE rgbtGreen ;
 &nbsp; BYTE rgbtRed ;
} RGBTRIPLE ;
</code></pre>
<p>
<img src="gl5_6.gif" border=0></p>
<p class=label>
<b>Figure 6. Ordering of color components in memory</b></p>
<h4>24-bpp DIBs</h4>
<p>
The conversion of 24-bpp Windows DIBs to OpenGL images consists of removing the boundary padding and rearranging the bits from an <b>RGBTRIPLE </b>format to the <b>CGLRGBTRIPLE </b>format:</p>
<pre><code>.
.
.
int storageWidth = aDib.GetStorageWidth() ; // storage width in BYTES!
CGLRGBTRIPLE* pDest = pGLRGB ;
.
.
.

 &nbsp; case 24:
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RGBTRIPLE* pSrc = (RGBTRIPLE*) pBits ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int widthDiff = storageWidth - m_iWidth*sizeof(RGBTRIPLE) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j = 0 ; j &lt; m_iHeight ; j++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0 ; i &lt; m_iWidth ; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDest-&gt;rgbRed = pSrc-&gt;rgbtRed ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDest-&gt;rgbGreen = pSrc-&gt;rgbtGreen ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDest-&gt;rgbBlue = pSrc-&gt;rgbtBlue ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDest++ ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSrc++ ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSrc = (RGBTRIPLE*)( (BYTE*)pSrc + widthDiff) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; break ;
</code></pre>
<p>
The <i>storageWidth</i> variable contains the actual width (in bytes) of the DIB in memory, including padding. <i>storageWidth</i><b> </b>is used to remove the padding at the end of the DIB.</p>
<h4>8-bpp DIBs</h4>
<p>
Unlike the 24-bpp DIB format, the 8-bpp DIB format uses a color table. Nigel's <b>CDIB</b> class contains the <b>GetClrTabAddress </b>function, which returns a pointer to the DIB's color table. Translating the 8-bpp DIB into a form usable by OpenGL consists of looking up the color of each pixel and inserting this color into the destination image. The color is converted from an <b>RGBQUAD</b> into a <b>CGLRGBTRIPLE</b>, and padding is removed in the process.</p>
<pre><code>&nbsp;case 8:
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BYTE* pSrc = (BYTE*) pBits ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RGBQUAD* pClrTab = aDib.GetClrTabAddress() ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int widthDiff = storageWidth - m_iWidth ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j = 0 ; j &lt; m_iHeight ; j++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0 ; i &lt; m_iWidth ; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDest-&gt;rgbRed = pClrTab[*pSrc].rgbRed ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDest-&gt;rgbGreen = pClrTab[*pSrc].rgbGreen ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDest-&gt;rgbBlue = pClrTab[*pSrc].rgbBlue ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDest++ ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSrc++ ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSrc += widthDiff ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; break ;
</code></pre>
<h4>4-bpp DIBs and other formats</h4>
<p>
The code for translating 4-bpp DIBs is included in <b>CGLImage::TranslateByYourself</b>. You have enough information to write the remaining formats yourself.</p>
<h3>GDI Method</h3>
<p>
The GDI method uses the Win32 <b>StretchDIBits</b> function to perform the translation. This method creates a DIB section in a format that OpenGL can use, and the original DIB is drawn on the new DIB section with <b>StretchDIBits</b>. We then pass the pointer to the bits to OpenGL, so it can render the picture.</p>
<p>
The challenge of this method is trying to find the overlap between the set of formats that <b>StretchDIBits </b>supports and the set that OpenGL supports. The difficulty lies in the order of the color components in memory. Again, Windows puts blue first while OpenGL puts red first.</p>
<p>
32-bpp DIBs come to the rescue! Based on the theory that more is better, the Windows DIB specification was extended to include 16- and 32-bpp formats. Although these additions do not directly improve life (try finding any 16- or 32-bpp DIBs), the extension to the DIB specification does help us rearrange the color components.</p>
<h4>BI_BITFIELDS</h4>
<p>
We can customize the byte ordering with 16- or 32-bpp DIBs. To customize, set <b>BITMAPINFOHEADER.biCompression </b>to BI_BITFIELDS, and then supply three <b>DWORD</b>s (or <b>RGBQUAD</b>s) containing masks that determine the pixel layout. The first <b>DWORD</b> contains the red mask, the second <b>DWORD</b> contains the green mask, and the third <b>DWORD</b> contains the blue mask. Using <b>RGBQUAD</b>s instead of <b>DWORD</b>s can make the reversal of bytes more obvious in our case:</p>
<pre><code>BITMAPINFO* pBMI ;
.
.
.
// Red mask moves the red byte into blue's normal position.
pBMI-&gt;bmiColors[0].rgbBlue = 0xff ; 

// Green mask doesn't move location of green byte.
pBMI-&gt;bmiColors[1].rgbGreen = 0xff ; 

// Blue mask moves the blue byte into red's normal position.
pBMI-&gt;bmiColors[2].rgbRed = 0xff ;
</code></pre>
<p>
See "Formats Using BI_BITFIELDS and Color Masks" in the "Bitmap Format Extensions" section of the Video for Windows SDK (in Product Documentation, SDKs, Win32 SDK for Windows 3.5) for more information on BI_BITFIELDS.</p>
<p>
To use the byte reordering feature of BI_BITFIELDS, we must use 32-bpp DIBs. To get OpenGL to display a 32-bpp DIB instead of a 24-bpp DIB, we must use GL_RGBA instead of GL_RGB as a format specifier:</p>
<pre><code>glPixelStorei(GL_UNPACK_ALIGNMENT, 1) ;
glDrawPixels(m_iWidth, m_iHeight, <b>GL_RGBA</b>, GL_UNSIGNED_BYTE, m_pBits) ;
</code></pre>
<p>
This approach wastes one byte per pixel. It also assumes that the driver will place a zero in the fourth location, which becomes the alpha component in OpenGL.</p>
<p>
Another problem with this method is that it works only in Windows NT™. In Windows 95, <b>CreateDIBSection </b>will create an arbitrary format with BI_BITFIELDS, but the other GDI calls (for example, <b>BitBlt</b>) will only support a subset of the possible BI_BITFIELD masks. For 32-bpp DIBs, the GDI calls will only support 8-8-8 BGR with BI_BITFIELDS.</p>
<h4>CGLImage::TranslateByGDI</h4>
<p>
The code for translating a Windows DIB into an OpenGL image using GDI is shown below. The code creates a new 32-bpp DIB section and uses the BI_BITFIELDS style to customize the color component arrangement in memory. It then draws the Windows DIB in the new DIB section using the <b>CDIB::Draw </b>from Nigel's animation library. The resulting image is in a format that OpenGL can use.</p>
<pre><code>void CGLImage::TranslateByGDI(CDIB&amp; aDib, CDIBPal&amp; aPalSrc)
{
 &nbsp; //
 &nbsp; // Allocate memory for new DIB section header. Include 
 &nbsp; // room for 3 color masks. BITMAPINFO includes one RGBQUAD.
 &nbsp; //
 &nbsp;&nbsp; int iSize = sizeof(BITMAPINFO) + 2 * sizeof(RGBQUAD);
 &nbsp;&nbsp; BITMAPINFO* pBMI = (BITMAPINFO*) malloc(iSize);
 &nbsp;&nbsp; memset(pBMI, 0, iSize);

 &nbsp;&nbsp; // Fill in the header info.
 &nbsp;&nbsp; pBMI-&gt;bmiHeader.biSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = sizeof(BITMAPINFOHEADER);
 &nbsp;&nbsp; pBMI-&gt;bmiHeader.biWidth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = m_iWidth;
 &nbsp;&nbsp; pBMI-&gt;bmiHeader.biHeight&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = m_iHeight;
 &nbsp;&nbsp; pBMI-&gt;bmiHeader.biPlanes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;
 &nbsp;&nbsp; pBMI-&gt;bmiHeader.biBitCount&nbsp;&nbsp;&nbsp; = 32 ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Must use 32 bpps 
 &nbsp;&nbsp; pBMI-&gt;bmiHeader.biCompression = BI_BITFIELDS ; // to use this flag.

 &nbsp; //
 &nbsp; // Rearrange RGB component storage from BGR to RGB.
 &nbsp; //
 &nbsp; pBMI-&gt;bmiColors[0].rgbBlue&nbsp; = 0xff ; // Store red in blue's normal position.
 &nbsp; pBMI-&gt;bmiColors[1].rgbGreen = 0xff ; // Green stays the same.
 &nbsp; pBMI-&gt;bmiColors[2].rgbRed&nbsp;&nbsp; = 0xff ; // Store blue in red's normal position.

 &nbsp; //
 &nbsp; // Create the new 32-bpp DIB section.
 &nbsp; //
 &nbsp; CDC dc;
 &nbsp; dc.CreateCompatibleDC(NULL);
 &nbsp; BYTE* pBits ;
 &nbsp; HBITMAP hbmBuffer = CreateDIBSection( dc.GetSafeHdc(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBMI,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIB_RGB_COLORS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (VOID **) &amp;pBits,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);

 &nbsp; // Select DIB into DC.
 &nbsp; HBITMAP hbmOld = (HBITMAP)::SelectObject(dc.GetSafeHdc(), hbmBuffer);

 &nbsp; // Blt the Windows DIB into our new DIB.
 &nbsp; dc.SelectPalette(&amp;aPalSrc,0) ;
 &nbsp; dc.RealizePalette() ;
 &nbsp; aDib.Draw(&amp;dc,0,0) ; // Use Nigel's Animation class.
 &nbsp; GdiFlush() ;

 &nbsp; //
 &nbsp; // Copy the bits out of the DIB section. This allows us to delete
 &nbsp; // the DIB section since we don't need it. It's possible to keep 
 &nbsp; // the DIB section around and use pBits directly.
 &nbsp; //
 &nbsp; int iImageSize = m_iWidth * m_iHeight * sizeof(RGBQUAD) ;
 &nbsp; m_pBits = malloc(iImageSize) ;
 &nbsp; memcpy(m_pBits, pBits, iImageSize) ;

 &nbsp; //
 &nbsp; // Get rid of all the GDI stuff.
 &nbsp; //
 &nbsp;&nbsp; if (hbmOld)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (HBITMAP)::SelectObject(dc.GetSafeHdc(), hbmOld);

 &nbsp; DeleteObject(hbmBuffer) ;
}
</code></pre>
<p>
In the code above, I copied the bits out of the DIB section and into a new chunk of memory, and then deleted the DIB. This step makes <b>TranslateByGDI </b>more like <b>TranslateByYourself</b>, resulting in a much simpler class for demonstration purposes. However, this step is not necessary; it wastes time, especially when dealing with large images. </p>
<p>
You can change <b>CGLImage </b>so it only uses <b>TranslateByGDI</b>, and then pass the <b>pBits </b>pointer returned by the <b>CreateDIBSection </b>call to <b>glDrawPixels</b>. Now you don't have to waste time copying the image again.</p>
<h3>Partial GDI Method</h3>
<p>
The last method we'll look at is my favorite. It combines the do-it-yourself method and the GDI method in one nice, clean method. I use GDI to translate the bitmap from its original format to a 32-bpp format. Using 32 bpp instead of 24 bpp means that I don't have to worry about boundary padding. I use my own code to rearrange the bytes from 32-bpp BGR ordering to 24-bit RGB ordering. </p>
<p>
This method has three major advantages: It doesn't rely on BI_BITFIELDS, it doesn't waste any bytes of memory, and it will run in Windows 95. We use the same command for rendering the image that we used in the do-it-yourself method:</p>
<pre><code>glPixelStorei(GL_UNPACK_ALIGNMENT, 1) ;
glDrawPixels(m_iWidth, m_iHeight, GL_RGB, GL_UNSIGNED_BYTE, m_pBits) ;
</code></pre>
<p>
The code for <b>CGLImage::TranslateByBoth</b> is given below:</p>
<pre><code>void CGLImage::TranslateByBoth(CDIB&amp; aDib, CDIBPal&amp; aPalSrc)
{
 &nbsp; //
 &nbsp; // Allocate memory for new DIB section. 
 &nbsp; // No color table is needed.
 &nbsp; //
 &nbsp; const int BITMAPINFOHEADER_SIZE = sizeof(BITMAPINFOHEADER) ;
 &nbsp; BYTE* abBitmapInfo[BITMAPINFOHEADER_SIZE] ;
 &nbsp; BITMAPINFOHEADER* pBMIH = (BITMAPINFOHEADER*)abBitmapInfo;
 &nbsp; memset(pBMIH, 0, BITMAPINFOHEADER_SIZE);

 &nbsp; // Fill in the header info.
 &nbsp; pBMIH-&gt;biSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = sizeof(BITMAPINFOHEADER);
 &nbsp; pBMIH-&gt;biWidth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = m_iWidth;
 &nbsp; pBMIH-&gt;biHeight&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = m_iHeight;
 &nbsp; pBMIH-&gt;biPlanes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1;
 &nbsp; pBMIH-&gt;biBitCount&nbsp;&nbsp;&nbsp;&nbsp; = 32 ; 
 &nbsp; pBMIH-&gt;biCompression&nbsp; = BI_RGB ; 

 &nbsp; //
 &nbsp; // Create the new 32-bpp DIB section.
 &nbsp; //
 &nbsp; CDC dc;
 &nbsp; dc.CreateCompatibleDC(NULL);
 &nbsp; BYTE* pBits ;
 &nbsp; HBITMAP hbmBuffer = CreateDIBSection( dc.GetSafeHdc(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (BITMAPINFO*) pBMIH,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIB_RGB_COLORS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (VOID **) &amp;pBits,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);
 &nbsp; // Select DIB into DC.
 &nbsp; HBITMAP hbmOld = (HBITMAP)::SelectObject(dc.GetSafeHdc(), hbmBuffer);

 &nbsp; // Blt the Windows DIB into our new DIB.
 &nbsp; dc.SelectPalette(&amp;aPalSrc,0) ;
 &nbsp; dc.RealizePalette() ;
 &nbsp; aDib.Draw(&amp;dc,0,0) ;
 &nbsp; GdiFlush() ;

 &nbsp; //
 &nbsp; // Copy the bits out of the DIB section. 
 &nbsp; // Change from BGR to RGB.
 &nbsp; //
 &nbsp; int iImageSize = m_iWidth * m_iHeight * sizeof(CGLRGBTRIPLE) ;
 &nbsp; m_pBits = malloc(iImageSize) ;

 &nbsp; RGBQUAD* pSrc = (RGBQUAD*)pBits ;
 &nbsp; CGLRGBTRIPLE* pDest = (CGLRGBTRIPLE*) m_pBits ;
 &nbsp; for (int i = 0 ; i &lt; m_iWidth*m_iHeight ; i++)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; pDest-&gt;rgbRed = pSrc-&gt;rgbRed ;
 &nbsp;&nbsp;&nbsp;&nbsp; pDest-&gt;rgbGreen = pSrc-&gt;rgbGreen ;
 &nbsp;&nbsp;&nbsp;&nbsp; pDest-&gt;rgbBlue = pSrc-&gt;rgbBlue ;
 &nbsp;&nbsp;&nbsp;&nbsp; pDest++ ;
 &nbsp;&nbsp;&nbsp;&nbsp; pSrc++ ;
 &nbsp; }

 &nbsp; //
 &nbsp; // Get rid of all the GDI stuff.
 &nbsp; //
 &nbsp; if (hbmOld)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (HBITMAP)::SelectObject(dc.GetSafeHdc(), hbmOld);

 &nbsp; DeleteObject(hbmBuffer) ;
}
</code></pre>
<p>
There are billions and billions of other combinations you can choose from, but now you get the picture.</p>
<h2>CGLImage</h2>
<p>
I have encapsulated the code for translating Windows DIBs to OpenGL images in the <b>CGLImage</b> class, which is in the GLlib dynamic-link library (DLL). After <b>CGLImage</b> loads the DIB with Nigel's <b>CDIB</b> class, it translates the DIB.</p>
<p>
The following example shows how to translate a DIB using the do-it-yourself method:</p>
<pre><code>anImage.Load("MD500D.BMP", TRANS_DIY) ;
</code></pre>
<p>
The following example shows how to translate a DIB using the GDI method:</p>
<pre><code>anImage.Load("MD500D.BMP", TRANS_GDI) ;
</code></pre>
<p>
The last two examples load an image and convert it using the partial GDI method:</p>
<pre><code>CGLImage anImage ;
anImage.Load("MD500D.BMP") ; 

anImage.Load("MD500D.BMP", TRANS_BOTH) ;
</code></pre>
<p>
The only other member function currently included in <b>CGLImage </b>is <b>DrawPixels</b>, which conveniently calls <b>glDrawPixels</b>:</p>
<pre><code>void CGLImage::DrawPixels(CGL* pGL)
{
 &nbsp; ASSERT((m_iWidth != 0) &amp;&amp; (m_iHeight !=0)) ;
 &nbsp; ASSERT(m_pBits) ;
 &nbsp; pGL-&gt;MakeCurrent() ;
 &nbsp; GLint iAlign ;
 &nbsp; glGetIntegerv(GL_UNPACK_ALIGNMENT, &amp;iAlign) ; 
 &nbsp; glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

 &nbsp; glDrawPixels(m_iWidth, m_iHeight, m_PixelFormat, GL_UNSIGNED_BYTE, m_pBits) ;

 &nbsp; glPixelStorei(GL_UNPACK_ALIGNMENT, iAlign);
}
</code></pre>
<p>
My EasyDIB sample application calls <b>CGLImage::Load</b> in <b>CScene::OnInit </b>and in <b>CSceneVw::OnOptionsLoadBitmap</b>. <b>CGLImage::DrawPixels</b> is called in <b>CScene::OnRender</b>.</p>
<p>
In my <a href="msdn_gl3.htm">"OpenGL III: Building an OpenGL C++ Class"</a> article, I explained the value of not encapsulating the OpenGL functions. Now why did I go and encapsulate <b>glDrawPixels</b>? Here are my reasons:
<ul type=disc>
<li>
Images are translated differently on different systems. Encapsulating <b>glDrawPixels</b> simplifies the support of multiple systems, thus enhancing portability. Currently, <b>CGLImage</b> contains multiple translation functions, which can easily translate images from the X Window System or Silicon Graphics to OpenGL.<br><br></li>
<li>
The <b>glDrawPixels</b> parameters suggest a structure. Working with structures is easier from member functions. </li>
</ul>
<h2>Changes to GLlib</h2>
<p>
I modified the GLlib DLL by adding the <b>CGLImage</b> class. I also changed the <b>CGL </b>class by modifying <b>CGL::Create</b> and adding <b>CGL::OnCreate</b>.</p>
<h4>CGL::Create and CGL::OnCreate</h4>
<p>
I changed <b>CGL::Create </b>to take the <b>PIXELFORMATDESCRIPTOR.dwFlags </b>as a parameter. This gives the user of the class more control over the pixel format. Currently, <b>CGL </b>does not allow you to render OpenGL commands on a bitmap. I will add this support and document it in a future article.</p>
<p>
<b>CGL::Create </b>now makes a call to <b>CGL::OnCreate </b>after setting up the <b>PIXELFORMATDESCRIPTOR</b> structure. Applications that use <b>CGL </b>can set up the <b>CGL </b>instance either by calling <b>CGL::Create</b> or by overriding <b>CGL::OnCreate</b> and changing the pixel format there.</p>
<p>
<b>CGL::OnCreate </b>is very similar to the <b>CWnd::OnPreCreateWindow</b> function in the Microsoft Foundation Class Library (MFC). The EasyDIB sample application overrides <b>CGL::OnCreate</b> in the <b>CScene</b> class. EasyDIB turns double buffering off in <b>CScene::OnCreate</b>, so it does not have to implement <b>CSceneView::OnCreate</b> and make a call to <b>CGL::Create </b>as EasyCI did. Another benefit of this arrangement is that it places more of the OpenGL-oriented code in <b>CScene</b> instead of spreading it out to <b>CSceneView</b>.</p>
<h2>Conclusion</h2>
<p>
Translating Windows DIBs into a format that OpenGL can use is not difficult, once you understand the format that Windows uses and the format that OpenGL expects. You might say that it's kind of like translating English to English.</p>
<h2>Bibliography</h2>
<h3>Sources of Information on OpenGL</h3>
<p>
Crain, Dennis. <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started."</a> April 1994. (MSDN Library, Technical Articles)</p>
<p>
Neider, Jackie, Tom Davis, and Mason Woo. <i>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1993. ISBN 0-201-63274-8. (This book is also known as the "Red Book".)</p>
<p>
OpenGL Architecture Review Board. <i>OpenGL Reference Manual: The Official Reference Document for OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1992. ISBN 0-201-63276-4. (This book is also known as the "Blue Book".)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: Introducing the OpenGL Interface, Part I." <i>Microsoft Systems Journal</i> 9 (October 1994). (MSDN Library Archive Edition, Library, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: The OpenGL Interface, Part II." <i>Microsoft Systems Journal</i> 9 (November 1994). (MSDN Library Archive Edition, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Understanding Modelview Transformations in OpenGL for Windows NT." <i>Microsoft Systems Journal</i> 10 (February 1995). </p>
<p>
Rogerson, Dale. <a href="msdn_gl1.htm">"OpenGL I: Quick Start."</a>. December 1994. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode"</a>. December 1994. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl3.htm">"OpenGL III: Building an OpenGL C++ Class."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl4.htm">"OpenGL IV: Color Index Mode."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl6.htm">"OpenGL VI: Rendering on DIBs with PFD_DRAW_TO_BITMAP."</a> April 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl7.htm">"OpenGL VII: Scratching the Surface of Texture Mapping."</a> May 1995. (MSDN Library, Technical Articles)</p>
<p>
Microsoft Win32 Software Development Kit (SDK) for Windows NT 3.5 <i>OpenGL Programmer's Reference</i>. </p>
<h3>Sources of Information on DIBs</h3>
<p>
Gery, Ron. <a href="msdn_dibs2.htm">"DIBs and Their Use."</a>. March 1992. (MSDN Library, Technical Articles) </p>
<p>
Gery, Ron. <a href="msdn_dibpal.htm">"Using DIBs with Palettes."</a> March 1992. (MSDN Library, Technical Articles)</p>
<p>
Microsoft Win32 Software Development Kit (SDK) for Windows NT 3.5 <i>Video for Windows</i> </p>
<p>
Rodent, Herman. "16- and 32-Bit-Per-Pixel DIB Formats for Windows: The Color of Things to Come." January 1993. (MSDN Library Archive, Technical Articles)</p>
<p>
Thompson, Nigel. <i>Animation Techniques for Win32</i>. Redmond, WA: Microsoft Press, 1995. </p>
</BODY>
</HTML>
