<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFC/COM Objects 1: Creating a Simple Object</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_house1"></a></sup>MFC/COM Objects 1: Creating a Simple Object</h1>
<p>
Nigel Thompson<br>
Microsoft Developer Network Technology Group</p>
<p>
March 6, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4228">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the HOUSE1 sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4245">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the Animate library.</a></p>
<h2>Abstract</h2>
<p>
This technical article is the first in a series of articles that describe creating and using 32-bit Component Object Model (COM) objects with Visual C++™ and the Microsoft® Foundation Class Library (MFC). The sample application that accompanies this article, HOUSE, shows a simple COM object and an application that uses the object. A comparison is drawn between C++ objects and COM objects.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;To run the HOUSE sample, you must first register the APPLIANCES in the registry. Copy HOUSE.EXE and APPLIANCES.DLL to your local disk. Edit APPLIANCES.REG to show the path to where you installed APPLIANCES.DLL. Type "REGEDIT -s APPLIANCES.REG" in a command window to make the registry entries.</p>
<h2>Introduction</h2>
<p>
Some time ago (nearly two years) my colleague Herman Rodent wrote a series of technical articles entitled <a href="msdn_ole2a.htm">"OLE for Idiots."</a> In the final article, Herman essentially says, "OLE in C is too hard. Wait for MFC to do it for you. Then port your application to C++ and MFC." Well, the Microsoft® Foundation Class Library (MFC) has moved along very nicely since then, and the "Cairo" team is busy building the next generation of the Windows NT™ operating system on the Component Object Model (COM), so I thought it was about time to revisit the COM/OLE arena and see how things were going.</p>
<p>
With the release of Visual C++™ version 2.1, creating your own COM objects based on the MFC classes has become very easy. In this article, we'll go through creating an application that uses a C++ object to implement a light-bulb object, and then we'll create a COM version of the same thing. In a later article, I'll be showing a bit more on how COM objects can be used, but for now, we'll just concentrate on creating a simple one.</p>
<p>
You might well ask, "Why are you doing this? What is the purpose of these COM objects?" And indeed, those are very reasonable questions. I am doing this as an exercise to see exactly how hard it is to create a COM object of my own using the best tools I currently have available. In other words, is it practical to build your own COM objects today? As to what their purpose is, that's a longer answer and really outside the scope of this article, but let me quote my friend and colleague Dale Rogerson: "COM is a sort of object-oriented approach to DLLs. COM is to DLLs what C++ is to C." So if you view COM objects as a better way to reuse your code in a more object-oriented way, you'll have a good handle on why I'm interested in trying to build some COM objects of my own.</p>
<h2>Building the Base Application</h2>
<p>
I created the HOUSE sample as a single-document-interface (SDI) application using the Microsoft Foundation Class Libraries (MFC) and AppWizard. The application is designed to be a type of house controller. The house has several appliances: TV, radio, and lights. The idea is to design a set of interfaces and objects to implement control of these appliances. For this article, we'll stick to just one appliance: a light bulb.</p>
<p>
Step one is to get the framework up and running. The application framework is SDI without any&nbsp; printing, status bar, toolbar, or OLE support. Remember, this isn't an OLE project—it's only about COM objects.</p>
<p>
I used AppWizard to create the framework and then removed the document and view classes, leaving just the <b>CMainFrame</b> class and the application class. I tidied up the menus and so on to remove redundant items. The application initialization code was modified to create the main window. The toolbar and status bar were removed, and the main window had code added so that it would size to fit the image. I added a picture of the house to the application's resources and then added code that uses my Animate library to draw the image of the house when a WM_ERASEBKGND message is sent to the main window. You can see the result in Figure 1 (below, just above the heading " 'That's Easy,' Says Sir Robin").</p>
<h3>Interfaces and Objects </h3>
<p>
Having managed to get a picture of the house in the application, we now need to add some of the appliances—this is where the fun starts. To begin with, let's keep the objective very simple: Add a single light bulb that we can see.</p>
<p>
We can achieve this goal in one of two ways. We could create a C++ class for the object and have it draw itself, or we could create a COM object with a drawing interface. The drawing interface would have a member function that draws the light bulb. Since we know a bit about C++ classes and maybe not so much about COM objects, let's create a C++ version first and then go on to create a COM object that does the same thing later.</p>
<h2>Creating a C++ Class Light Bulb</h2>
<p>
Let's create a class called <b>CLightBulb</b>. We need to be able to draw the light bulb in the house somewhere, so it will need some sort of <b>Draw</b> function. Because the bulb is not rectangular, we must draw it with some parts of its image transparent. The <b>CDIB</b> class in the Animate library will draw one device-independent bitmap (DIB) transparently to another DIB surface (by copying nontransparent pixels). So we have all the tools we need to build this simple object.</p>
<p>
The <b>CLightBulb</b> class is implemented in the LTBULB.H and LTBULB.CPPfiles. Here's the definition from LTBULB.H:</p>
<pre><code>class CLightBulb : public CObject
{
public:
 &nbsp;&nbsp; CLightBulb();
 &nbsp;&nbsp; ~CLightBulb();
 &nbsp;&nbsp; BOOL Create(UINT uiResourceID, CPalette* pPal = NULL);
 &nbsp;&nbsp; void Draw(CDC* pDC, int x, int y);

protected:
 &nbsp;&nbsp; CDIB m_dibImage;
 &nbsp;&nbsp; CPalette* m_pPal;
};
</code></pre>
<p>
Notice that I have opted for a two-phase form of object creation—a constructor and a <b>Create</b> function. I like to create objects this way because it makes dealing with errors easier. The object has two member variables: a <b>CDIB</b> object to hold the image and a pointer to a <b>CPalette</b> object to keep track of the application's palette.</p>
<p>
Let's look now at how the <b>CLightBulb</b> class is implemented in LTBULB.CPP, beginning with the constructor and destructor:</p>
<pre><code>CLightBulb::CLightBulb()
{
 &nbsp;&nbsp; m_pPal = NULL;
}

CLightBulb::~CLightBulb()
{
}
</code></pre>
<p>
Gosh, Nigel, that's really complex. OK, so this is trivial stuff, but trust me—it will get harder. Here's the <b>Create</b> function that actually creates the object:</p>
<pre><code>BOOL CLightBulb::Create(UINT uiResourceID, CPalette* pPal/*= NULL*/)
{
 &nbsp;&nbsp; // Try to load the image resource.
 &nbsp;&nbsp; if (!m_dibImage.Load(uiResourceID)) return FALSE;

 &nbsp;&nbsp; // If a palette was supplied, map the image colors to the palette.
 &nbsp;&nbsp; m_pPal = pPal;
 &nbsp;&nbsp; if (pPal) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dibImage.MapColorsToPalette(pPal);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
The image is loaded and mapped to the application's palette, which is no big deal because most of the work is done in the <b>CDIB</b> class. I love code reuse! Finally, let's see the <b>Draw</b> function:</p>
<pre><code>void CLightBulb::Draw(CDC* pDC, int x, int y)
{
 &nbsp;&nbsp; // Get a copy of the background the same size as the image.
 &nbsp;&nbsp; int w = m_dibImage.GetWidth();
 &nbsp;&nbsp; int h = m_dibImage.GetHeight();
 &nbsp;&nbsp; CDIBSurface dsBuffer;
 &nbsp;&nbsp; dsBuffer.Create(w, h, m_pPal);
 &nbsp;&nbsp; CDC* pDCBuf = dsBuffer.GetDC();
 &nbsp;&nbsp; CPalette* pOldPal = NULL;
 &nbsp;&nbsp; if (m_pPal) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDCBuf-&gt;SelectPalette(m_pPal, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDCBuf-&gt;RealizePalette();
 &nbsp;&nbsp; }
 &nbsp;&nbsp; pDCBuf-&gt;BitBlt(0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w, h,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDC,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x, y,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SRCCOPY);

 &nbsp;&nbsp; // Flush the GDI queue before we do a direct pixel operation.
 &nbsp;&nbsp; ::GdiFlush();

 &nbsp;&nbsp; // Get the palette index of the top-left pixel, which defines
 &nbsp;&nbsp; // the image transparency color.
 &nbsp;&nbsp; BYTE* pPixel = (BYTE*) m_dibImage.GetPixelAddress(0, 0);
 &nbsp;&nbsp; ASSERT(pPixel);

 &nbsp;&nbsp; // Draw the image transparently to the buffer.
 &nbsp;&nbsp; m_dibImage.CopyBits(&amp;dsBuffer,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w, h,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PALETTEINDEX(*pPixel));

 &nbsp;&nbsp; // Now copy the composite image back to the main DC.
 &nbsp;&nbsp; pDC-&gt;BitBlt(x, y,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w, h,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDCBuf,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SRCCOPY);

 &nbsp;&nbsp; // Tidy up.
 &nbsp;&nbsp; if (pOldPal) pDCBuf-&gt;SelectPalette(pOldPal, FALSE);

}
</code></pre>
<p>
The <b>Draw</b> function can be summarized thus: Copy the background to a buffer; draw the light-bulb shape on top; and finally, copy the composed image back to the screen.</p>
<h3>Trying out CLightBulb</h3>
<p>
To try out the <b>CLightBulb </b>class, let's put a light bulb in the center of the ceiling of the bottom room (see Figure 1 below). We'll add a <b>CLightBulb </b>object to the main window, and when the main window gets a WM_PAINT message, we'll ask the light-bulb object to draw itself. So in MAINFRM.H, we include a single member variable:</p>
<pre><code>CLightBulb* m_pLightBulb1;
</code></pre>
<p>
Note that this is a pointer to a <b>CLightBulb</b> object. I could have simply used an instance of the object, but I want to get used to the idea of pointers to objects, so that when we implement them as COM objects, we won't have to change too much.</p>
<p>
When the main window is created, a new light bulb object is created:</p>
<pre><code>int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
 &nbsp;&nbsp; [.....]

 &nbsp;&nbsp; // Create the main room light-bulb object.
 &nbsp;&nbsp; m_pLightBulb1 = new CLightBulb;
 &nbsp;&nbsp; ASSERT(m_pLightBulb1);
 &nbsp;&nbsp; m_pLightBulb1-&gt;Create(IDR_DIB_LIGHT BULB_ON, &amp;m_pal);

 &nbsp; return 0;
}
</code></pre>
<p>
Now all that's left to do is draw the object. The right time to do this is when the main window gets a WM_PAINT message. So we use ClassWizard to add a handler, and then we add a few lines of code: </p>
<pre><code>void CMainFrame::OnPaint() 
{
 &nbsp; CPaintDC dc(this); // Device context for painting
 &nbsp;&nbsp; CPalette* pOldPal = dc.SelectPalette(&amp;m_pal, FALSE);
 &nbsp;&nbsp; dc.RealizePalette();
 &nbsp; 
 &nbsp;&nbsp; // Ask the main room light bulb to draw itself.
 &nbsp;&nbsp; ASSERT(m_pLightBulb1);
 &nbsp;&nbsp; m_pLightBulb1-&gt;Draw(&amp;dc, 186, 247);

 &nbsp;&nbsp; dc.SelectPalette(pOldPal, FALSE);
}
</code></pre>
<p>
The palette is selected into the device context (DC), and the object is asked to draw itself.</p>
<p>
We need to do one more thing—ensure that the object is deleted when the main window goes away:</p>
<pre><code>CMainFrame::~CMainFrame()
{
 &nbsp;&nbsp; if (m_pLightBulb1) delete m_pLightBulb1;
}
</code></pre>
<p>
So now we have a house with a light bulb. Figure 1 shows a screen shot of the story so far.</p>
<p>
<img src="house1_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The house with a single C++ object light bulb</b></p>
<h2>"That's Easy," Says Sir Robin in Monty Python's Holy Grail</h2>
<p>
This is one of my favorite lines from my favorite movie. Brave Sir Robin declares crossing the bridge to be easy, right before he gets killed!</p>
<p>
So with that thought in mind, let's move right along and create a COM object that will do what the <b>CLightBulb</b> class does, or at least, let's consider what this wonderful new object will look like and how it will behave.</p>
<p>
Our light bulb does only one thing so far—draw itself. But an object drawing itself isn't really just an attribute of light bulbs. Many other objects could draw a rendition of themselves, too. So this idea of drawing yourself could be specified as something many different objects might like to support. So drawing yourself might be specified as an <i>interface</i> that an object supports. For example, we <i>might</i> describe the drawing interface like this:</p>
<pre><code>Interface: Drawing
 &nbsp;&nbsp; Function: void Draw(CDC* pDC, int x, int y)
</code></pre>
<p>
So if we knew that an object supported the <i>Drawing</i> interface, we could (somehow or other) call its <b>Draw</b> function to get it to draw itself. I know this is all getting a bit tedious and probably seems rather simplistic, but bear with me.</p>
<p>
When we built the <b>CLightBulb</b> class, the header file contained the definition of the class, and given this information, we could call the <b>CLightBulb::Draw</b> function with the correct parameters and so on. But how did we know where the <b>Draw</b> function was located in the C++ object? Well, we didn't. We relied on the C++ compiler to figure that out based on the class definition we supplied in the header file. So in designing an interface, we always need to define how member functions are accessed via that interface. In C++ we do this via the class definition. In implementing an interface for a COM object, we do it in a very similar way. In fact, it's so similar you probably won't see any difference, and the reason for that is that COM interfaces were designed to be trivial to implement in C++. That doesn't mean that you can't use a COM object interface from C. It just means that, if you are using it from C++, it's going to look very much like accessing a C++ class. So we could possibly define our drawing interface like this:</p>
<pre><code>class IDrawing
{
public:
 &nbsp; virtual void Draw(CDC* pDC, int x, int y) = 0;
};
</code></pre>
<p>
This is an abstract base class that has one function defined. You can't create one of these objects because it has a pure virtual function in it ( the <i>= 0</i> bit). Instead, you must derive your own class from this base class and implement the <b>Draw</b> function to suit your own needs. Someone wishing to call the <b>Draw </b>function in your class only needs to know the definition of <b>IDrawing</b> to understand how to get your object to draw itself.</p>
<p>
At this point, the discussion could get very long-winded, and I want to avoid that and cut to the chase. So if you want to know more about COM objects and their interfaces, read Kraig Brockschmidt's book <i>Inside OLE 2</i> and also Visual C++ 2.0 "Technical Note 38: MFC/OLE <b>IUnknown</b> Implementation," which describes how the <b>IUnknown</b> interface is implemented in the MFC classes. For now, let's just concentrate on implementing our <b>IDrawing</b> interface in C++.</p>
<h2>Implementing IDrawing in C++</h2>
<p>
If you search the MSDN Library CD, you'll find a good deal of documentation on remote procedure calls (RPC), Interface Definition Language (IDL), and the Microsoft IDL (MIDL) compiler. All of this stuff is designed to aid you in creating COM objects that work correctly even if they are on remote machines. For our example today, I am going to ignore any issues related to RPC—we can revisit that later. </p>
<p>
If you were to look at Kraig's book, you'd see that he implements his interfaces using the macros supplied in the OLE header files. These macros expand to either a C or C++ definition, depending on how they are used. Inasmuch as our focus is on C++ and I don't want anything hidden by a set of macros, I'm going to define our interfaces directly in C++.</p>
<p>
If we should decide later that these interfaces might be of use to someone else (possibly a C programmer), we would redefine them using the OLE macros. If we should go so far as to want to use these objects via RPC, we would revisit the definition and translate it into an IDL description and use the MIDL compiler to generate the interface and the marshaling dynamic-link libraries (DLLs) that we would need.</p>
<p>
So the final definition of the <b>IDrawing</b> interface for today (from IDRAWING.H) is:</p>
<pre><code>class IDrawing : public IUnknown
{
 &nbsp;&nbsp; // Standard IUnknown interface functions
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE QueryInterface(IID&amp; riid,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID* ppvObj) = 0;
 &nbsp;&nbsp; virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
 &nbsp;&nbsp; virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

 &nbsp;&nbsp; // This interface
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE Draw(CDC* pDC,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int y) = 0;
};
</code></pre>
<p>
Note the definition of the <b>AddRef</b>, <b>Release</b>, and <b>QueryInterface</b> functions common to all COM object interfaces. I should warn you that although this all looks very hunky-dory, there might just be a Catch-22 here. If you look back at how I implemented <b>CLightBulb::Draw</b>, you'll see that the object's palette is used (via <b>m_pPal</b>). Because the <b>IDrawing</b> interface knows nothing of palettes (yet!), it probably isn't going to do what we need, but let's not worry about that yet. Let's get some sort of object built that uses this interface, and worry about the details of the implementation later.</p>
<p>
Because this is a COM interface, it supports <b>AddRef</b>, <b>Release</b>, and of course, <b>QueryInterface</b>. If you look at the <b>QueryInterface</b> parameters, you'll see that the first one is a reference to an <b>IID</b>, which is the unique ID of this interface. So before we can get any further, we need to define an ID. To do this, run the GUIDGEN tool, which comes with Visual C++. (As a convenience, you might want to add this handy tool to your Visual C++ Tools menu). Run the tool, and select the second option (DEFINE_GUID(...)). Copy the result to the Clipboard.</p>
<p>
Paste the generated code into the interface header file, and replace the section that says <i>&lt;&lt;name&gt;&gt;</i> with the interface name. Here's the definition of <b>IDrawing</b>'s ID from the file IDRAWING.H:</p>
<pre><code>// {15038B10-3D3E-11ce-9EE5-00AA004231BF}
DEFINE_GUID(IID_IDrawing, 
0x15038b10, 0x3d3e, 0x11ce, 0x9e, 0xe5, 0x0, 0xaa, 0x0, 0x42, 0x31, 0xbf);
</code></pre>
<p>
Now we have a unique identifier for this interface and a definition for the functions it supports. This interface file and others that we'll create are kept in a common place so that all components can have access to them. In the HOUSE samples, I used an INCLUDE directory to store this sort of information. Figure 2 shows the directory structure of my project.</p>
<p>
<img src="house1_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The HOUSE project directory structure</b></p>
<h2>Creating a COM Light Bulb</h2>
<p>
Now let's look at how we create a light bulb as a COM object. We are going to create a DLL that will contain the image of the light bulb and all its drawing code. The DLL will export certain functions so that the system can find out which objects are in it and which interfaces they support. In OLE terms, this DLL will be an InProc server—that is, this object will function only as an add-on to an existing application. It can't be used on its own (it's not an executable), and it can't be used remotely from another machine (it has no RPC support), so it's pretty simple, but nonetheless useful.</p>
<p>
There are several ways to go about building a COM object that uses the MFC classes. Tom Laird-McConnell has an excellent article in the MSDN Library, <a href="msdn_mfccom.htm">"Tom's Handy Dandy MFC/COM/MIDL Recipe Book for Creating Custom Interfaces."</a> Tom's article will show you what you need to do if you are using Visual C++ 2.0, which has only limited support for creating DLL COM objects.</p>
<p>
Fortunately for us, the MFC guys have been burning the midnight oil, and Visual C++ version 2.1 includes much better AppWizard support for what we want. Specifically, the version 2.1 AppWizard allows us to create a DLL based on the MFC classes with those classes statically linked to the DLL. Soooo, I'm going to describe the process using Visual C++ 2.1. If you have only Visual C++ 2.0, read Tom's article. The process is a bit longer, but you'll get there just the same.</p>
<h3>Build the Project</h3>
<p>
The first step is to construct the framework; this is done using the Visual C++ 2.1 AppWizard. Run Visual C++ and ask to create a new project. In AppWizard, select "MFC AppWizard (DLL)" and check the option to use the static-link version of the MFC libraries (which is <i>not</i> the default); also check the OLE Automation box. Even if you're not going to use any OLE Automation features (and we're not here), you need this option to bring in some startup code. In the HOUSE1 sample, the light-bulb object is a part of the APPLIANCES project subdirectory.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;It's very important that you use the static-link version of the MFC libraries and not the run-time DLL version because your COM object could be used by a non-MFC application (yes, there are a few of those out there). The MFC classes won't work correctly if you select the DLL option. (The DLL version needs to be working on behalf of an MFC application—they cooperate). For the same reason, any other code you are going to use in your COM object must use the static-link MFC run-time library, too. This was inconvenient for me because I wanted to use my own Animate library, which I had built to use the MFC DLL at run time to save space. So for this project, I had to build a special version that uses the MFC classes statically linked.</p>
<p>
So once the framework is created, add your own headers, libraries, and so on to the project as usual. I usually build the framework at this point to make sure I haven't done anything stupid.</p>
<h3>Add the Object and Interface GUIDs</h3>
<p>
All COM (and OLE) IDs are 128-bit values. To save space in the application, these are built into the application one time only rather than, say, using a definition macro to reproduce them every time they are needed. The easiest way I have found to do this is to add all the ID header files to a single .CPP file and to add that .CPP file to the project. Here is GUIDS.CPP from the APPLIANCES project:</p>
<pre><code>// GUIDS.CPP
#include "stdafx.h"
#include &lt;initguid.h&gt;

#include "..\include\appliancesid.h"
#include "..\include\idrawing.h"
</code></pre>
<p>
GUIDS.CPP includes STDAFX.H, as all CPP files for the project do. It also includes INITGUID.H, which is a standard OLE header file that helps to ensure our ID values get built correctly once and once only. I've skipped ahead just a bit here; we'll get back to creating APPLIANCESID.H shortly.</p>
<h3>Create the Object Class</h3>
<p>
Now we'll add the code that implements the light-bulb object. Use ClassWizard to create a new class derived from <b>CCmdTarget</b>. (Remember that you need to be running Visual C++ version 2.1.) We are deriving from <b>CCmdTarget</b> because that class has MFC's implementation of the <b>IUnknown</b> interface in it. I called my class <b>CLightBulb</b>. Be sure to check the OLE Automation and OLE Creatable options. If you will expose this object to other applications (such as Visual Basic), you might want to enter an external name (such as <i>Light bulb</i>) for the object. Reminder: Most Basic programmers don't know <b>CThing</b> from a hole in the ground.</p>
<p>
When ClassWizard has finished creating the new files, take a look at them. In the .CPP file, you'll see a macro near the bottom that looks like this:</p>
<pre><code>IMPLEMENT_OLECREATE(CLightBulb, "Light bulb", 0x3a015b30, 0x41fc, 0x11ce, 0x9e, 0xe5, 0x0, 0xaa, 0x0, 0x42, 0x31, 0xbf)
</code></pre>
<p>
This macro implements the class factory support that will allow an external application to create one of your objects. Note that the ClassWizard generated a GUID for the class for you, so you don't need to run GUIDGEN for this object. We'll add the actual code for the implementation of the object in just a minute.</p>
<h3>Create the Object ID File</h3>
<p>
Now that our object has an ID, it's time to add the ID definition file for it that I spoke of earlier. Here's APPLIANCESID.H, which defines the light-bulb object:</p>
<pre><code>// AppliancesID.h

#ifndef _CLSID_Light bulb_
#define _CLSID_Light bulb_

DEFINE_GUID(CLSID_Light bulb, 
0x3a015b30, 0x41fc, 0x11ce, 0x9e, 0xe5, 0x0, 0xaa, 0x0, 0x42, 0x31, 0xbf);

#endif // _CLSID_Light bulb_
</code></pre>
<p>
The ID value in here was simply cut and pasted from the IMPLEMENT_OLECREATE macro shown above.</p>
<h3>Create the Object REG File</h3>
<p>
Our new object needs to be entered in the system registry so that it can be located by applications wishing to use it. Doing this is very easy: Create a .REG file with the appropriate entries, then run REGEDIT to install the new data in the registry. Here's APPLIANCES.REG:</p>
<pre><code>REGEDIT
HKEY_CLASSES_ROOT\CLSID\{3A015B30-41FC-11ce-9EE5-00AA004231BF}
 &nbsp; = Light bulb Class
HKEY_CLASSES_ROOT\CLSID\{3A015B30-41FC-11ce-9EE5-0AA004231BF}
 &nbsp; \InprocServer32&nbsp;&nbsp;&nbsp; = c:\apps\ole\appliances\windebug\appliances.dll
</code></pre>
<p>
The first HKEY. . . line is the human-readable description of the class, and the second HKEY.&nbsp;.&nbsp;. line describes the path to a 32-bit InProc server that implements the class. Note that the lines are split here for readability, but the file itself has only three lines of text in it. Also note that the path to the DLL shown here is the one I was using for development. In practice, your installation utility would need to set this path.</p>
<p>
To register the new information, run REGEDIT:</p>
<pre><code>REGEDIT -s APPLIANCES.REG
</code></pre>
<h3>Add Your Object's Interface Definitions</h3>
<p>
Now that we have all the framework and support files in place, we can implement the object's code. We'll start by adding the interface definitions and private member variables to the header file. Here's LIGHTBL.H, showing only the bits we need to add to what ClassWizard generated:</p>
<pre><code>class CLightBulb : public CCmdTarget
{
 &nbsp;&nbsp; [.....]

 &nbsp;&nbsp; // Declare the interface map for this object.
 &nbsp;&nbsp; DECLARE_INTERFACE_MAP()

 &nbsp;&nbsp; // IDrawing interface
 &nbsp;&nbsp; BEGIN_INTERFACE_PART(Drawing, IDrawing)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(Draw)(CDC* pDC,int x, int y);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(SetPalette)(CPalette* pPal);
 &nbsp;&nbsp; END_INTERFACE_PART(Drawing)

 &nbsp;&nbsp; // Member variables
 &nbsp;&nbsp; CDIB m_dibImage;
 &nbsp;&nbsp; CPalette* m_pPal;
};
</code></pre>
<p>
As you can see, there are three additional sections. The <b>DECLARE_INTERFACE_MAP</b> macro provides the basic COM interface definition. (More information is in the MFC "Technical Note 38: MFC/OLE <b>IUnknown</b> Implementation" article.) Then we define the <b>IDrawing</b> interface itself using the <b>BEGIN_INTERFACE_PART</b> macro to mark the start of the interface and the <b>END_INTERFACE_PART</b> to mark the end. Each function supported by the interface is defined between these macros. Note the use of the OLE-defined <b>STDMETHOD</b> macro, which ensures that the function has the correct return type and calling convention. If your function returns something other than the standard <b>HRESULT</b>, you will need to use the <b>STDMETHOD_</b> macro.</p>
<p>
OK, so much for using yet more macros, but what do they do? This is covered in MFC Technical Note 38, but to summarize: These macros provide a definition of a <i>nested class</i>. In the case shown here, the nested class will be called <b>XDrawing</b>. The <b>X</b> is used to differentiate it from an interface or regular C++ class. The <b>XDrawing</b> class has <b>AddRef</b>, <b>Release</b>, and <b>QueryInterface</b> members defined automatically, so you don't need to define these yourself. You only need to define your own interface functions.</p>
<p>
You might also note that I have rather sneakily included a <b>SetPalette</b> function here. I mentioned earlier (if you remember back that far!) that we might need to deal with palettes. Well, this is how I handled the problem. More about this palette issue later.</p>
<p>
Finally, two member variables are declared, one to hold the image of the object and another to point to a palette to use in drawing the object.</p>
<p>
Let's look now at how the object is implemented.</p>
<h3>Implementing the Object Code</h3>
<p>
The first things to add to the .CPP file that ClassWizard generated are any header files we need. Here's the include set for the light-bulb object (from LIGHTBL.CPP):</p>
<pre><code>#include "stdafx.h"
#include "Appliances.h"
#include "..\include\idrawing.h"
#include "lightbl.h"
#include "resource.h"
</code></pre>
<p>
IDRAWING.H is the <b>IDrawing</b> interface definition, and RESOURCE.H is required because the light-bulb image is contained in a resource.</p>
<p>
We need to add several chunks of code to provide for the basic COM interface support before we get to our own functions. The first thing required is the implementation of the interface map, which is done using another set of MFC macros:</p>
<pre><code>BEGIN_INTERFACE_MAP(CLightBulb, CCmdTarget)
 &nbsp;&nbsp; INTERFACE_PART(CLightBulb, IID_IDrawing, Drawing)
END_INTERFACE_MAP()
</code></pre>
<p>
These macros implement a data table that the <b>CCmdTarget</b> class uses to implement the <b>IUnknown </b>interface. Again, see MFC Technical Note 38 for more details.</p>
<p>
The next thing to add is the implementation of <b>IUnknown</b> for our <b>IDrawing</b> interface:</p>
<pre><code>// IUnknown for IDrawing
STDMETHODIMP_(ULONG) CLightBulb::XDrawing::AddRef(void)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CLightBulb, Drawing);
 &nbsp;&nbsp; return pThis-&gt;ExternalAddRef();
}
 
STDMETHODIMP_(ULONG) CLightBulb::XDrawing::Release(void)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CLightBulb, Drawing);
 &nbsp;&nbsp; return pThis-&gt;ExternalRelease();
}

STDMETHODIMP CLightBulb::XDrawing::QueryInterface(REFIID riid, LPVOID* ppVoid)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CLightBulb, Drawing);
 &nbsp;&nbsp; TRACE("CLightBulb::XDrawing::QueryInterface\n");
 &nbsp;&nbsp; return pThis-&gt;ExternalQueryInterface(&amp;riid, ppVoid);
}
</code></pre>
<p>
These functions are the implementation of the <b>AddRef</b>, <b>Release</b>, and <b>QueryInterface</b> functions that were declared for you in the <b>XDrawing</b> nested class. The <b>METHOD_PROLOGUE</b> macro is required to gain access to the containing class (which is derived from <b>CCmdTarget</b>). In particular, it allows you to use the <b>pThis</b> member variable to access the data and functions in your object. </p>
<p>
Because this implementation is trivial, given the name of the interface class (<b>IDrawing</b>), it can be easily implemented as a macro set. See Tom Laird-McConnell's article ("Tom's Handy Dandy MFC/COM Recipe Book") for an example. I didn't use a macro here because I wanted you to see what's going on. Learning first, easy tools later.</p>
<p>
Now we can add the code that implements our own interface functions. Here's the code for the <b>Draw</b> function:</p>
<pre><code>STDMETHODIMP CLightBulb::XDrawing::Draw(CDC* pDC, int x, int y)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CLightBulb, Drawing);
 &nbsp;&nbsp; TRACE("CLightBulb::XDrawing::Draw");

 &nbsp;&nbsp; // Get a copy of the background the same size as the image.
 &nbsp;&nbsp; int w = pThis-&gt;m_dibImage.GetWidth();
 &nbsp;&nbsp; int h = pThis-&gt;m_dibImage.GetHeight();
 &nbsp;&nbsp; CDIBSurface dsBuffer;
 &nbsp;&nbsp; dsBuffer.Create(w, h, pThis-&gt;m_pPal);
 &nbsp;&nbsp; CDC* pDCBuf = dsBuffer.GetDC();
 &nbsp;&nbsp; CPalette* pOldPal = NULL;
 &nbsp;&nbsp; if (pThis-&gt;m_pPal) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDCBuf-&gt;SelectPalette(pThis-&gt;m_pPal, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDCBuf-&gt;RealizePalette();
 &nbsp;&nbsp; }
 &nbsp;&nbsp; pDCBuf-&gt;BitBlt(0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w, h,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDC,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x, y,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SRCCOPY);

 &nbsp;&nbsp; // Flush the GDI queue before we do a direct pixel operation.
 &nbsp;&nbsp; ::GdiFlush();

 &nbsp;&nbsp; // Get the palette index of the top-left pixel, which defines
 &nbsp;&nbsp; // the image transparency color.
 &nbsp;&nbsp; BYTE* pPixel = (BYTE*) pThis-&gt;m_dibImage.GetPixelAddress(0, 0);
 &nbsp;&nbsp; ASSERT(pPixel);

 &nbsp;&nbsp; // Draw the image transparently to the buffer.
 &nbsp;&nbsp; pThis-&gt;m_dibImage.CopyBits(&amp;dsBuffer,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w, h,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PALETTEINDEX(*pPixel));

 &nbsp;&nbsp; // Now copy the composite image back to the main DC.
 &nbsp;&nbsp; pDC-&gt;BitBlt(x, y,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w, h,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDCBuf,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SRCCOPY);

 &nbsp;&nbsp; // Tidy up.
 &nbsp;&nbsp; if (pOldPal) pDCBuf-&gt;SelectPalette(pOldPal, FALSE);


 &nbsp;&nbsp; return NOERROR;
}
</code></pre>
<p>
This is very similar to the code we used way back in the original <b>CLightBulb</b> C++ class at the beginning of this article—with a couple of additions. First, note the <b>METHOD_PROLOGUE</b> macro at the start, which links this function to its <b>IUnknown</b> implementation and provides the <b>pThis</b> member. Note, too, that this is a standard COM function that returns an <b>HRESULT</b>, and so the return value is of type <b>HRESULT</b>. Apart from these minor additions, the code is the same as we used before.</p>
<h3>Oh, Yes—the Palette Thing</h3>
<p>
And finally, we need a way to tell the object which palette the application is using. In the original C++ class, I provided this via the <b>Create</b> member function as an argument. I could have done the same thing here, but I decided to implement it in a more obvious way and provide a <b>SetPalette</b> function, which can be called as many times as you like to map the object's image to the palette the application is currently using. Here's the implementation of <b>SetPalette</b>:</p>
<pre><code>STDMETHODIMP CLightBulb::XDrawing::SetPalette(CPalette* pPal)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CLightBulb, Drawing);
 &nbsp;&nbsp; TRACE("CLightBulb::XDrawing::SetPalette");

 &nbsp;&nbsp; if (!pPal) return E_INVALIDARG;

 &nbsp;&nbsp; pThis-&gt;m_pPal = pPal;

 &nbsp;&nbsp; // Reload the image and map it to the new palette.
 &nbsp;&nbsp; pThis-&gt;m_dibImage.Load(IDR_DIB_LIGHT BULB_ON);
 &nbsp;&nbsp; pThis-&gt;m_dibImage.MapColorsToPalette(pThis-&gt;m_pPal);

 &nbsp;&nbsp; return NOERROR;
}
</code></pre>
<p>
So now you have an object you can build.</p>
<h2>Using Your New Object</h2>
<p>
Let's now turn our attention to how an application uses one of these fine new objects you have created. This is documented well in many places, including Kraig's book, so I will be brief here. In the HOUSE1 project's MAINFRM files, we add a new member variable:</p>
<pre><code>IUnknown* m_pLight bulb2;
</code></pre>
<p>
This is simply a pointer to an <b>IUnknown</b> interface, so it can point to any COM object. Now let's see how the object is created (from <b>CMainFrame::OnCreate</b>):</p>
<pre><code>// Initialize the OLE support.
 &nbsp;&nbsp; BOOL b = AfxOleInit();
 &nbsp;&nbsp; ASSERT(b);

 &nbsp;&nbsp; // Create a COM light bulb for one of the other rooms.
 &nbsp;&nbsp; dprintf2("Creating COM light bulb");
 &nbsp;&nbsp; HRESULT hr = ::CoCreateInstance(CLSID_Light bulb,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IUnknown,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID*)&amp;m_pLight bulb2);
 &nbsp;&nbsp; if (FAILED(hr)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dprintf1("Failed to create object. SCODE: %8.8lXH (%lu)\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetScode(hr),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetScode(hr) &amp; 0x0000FFFF);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pLight bulb2 = NULL;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; ASSERT(m_pLight bulb2);

 &nbsp;&nbsp; // Get a pointer to the IDrawing interface.
 &nbsp;&nbsp; IDrawing* pIDrawing = NULL;
 &nbsp;&nbsp; if (m_pLight bulb2-&gt;QueryInterface(IID_IDrawing,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID*)&amp;pIDrawing) == S_OK) {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Give the COM object a pointer to our palette.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIDrawing-&gt;SetPalette(&amp;m_pal);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Free the interface.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIDrawing-&gt;Release();
 &nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dprintf1("Failed to set palette in COM object");
 &nbsp;&nbsp; }
</code></pre>
<p>
A call to <b>CoCreateInstance</b> creates the object. Having got a pointer to its <b>IUnknown</b> interface, we can ask for a pointer to the object's <b>IDrawing</b> interface. If the object supports the <b>IDrawing</b> interface, we use the pointer to call the <b>SetPalette </b>function to let it know which palette the application is using. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you remove the error-handling code, this really becomes four calls: <b>CoCreateInstance</b>, <b>QueryInterface</b>, <b>SetPalette</b>, and <b>Release</b>. Note that the call to <b>Release</b> is important because it indicates that we're finished with the temporary <b>IDrawing</b> interface pointer we obtained.</p>
<p>
Drawing the new object is simple:</p>
<pre><code>// Ask the top-left room light bulb to draw itself.
 &nbsp;&nbsp; if (m_pLight bulb2) {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get a pointer to the IDrawing interface.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDrawing* pIDrawing = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pLight bulb2-&gt;QueryInterface(IID_IDrawing,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID*)&amp;pIDrawing) == S_OK) {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ask it to draw.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(pIDrawing);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pIDrawing-&gt;Draw(&amp;dc, 135, 121) != S_OK) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dprintf1("IDrawing::Draw failed");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Release the interface.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIDrawing-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dprintf1("No IDrawing interface found");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
</code></pre>
<p>
Note that, instead of keeping the <b>IUnknown</b> pointer to the light-bulb object, I could have simply kept the <b>IDrawing</b> pointer and avoided asking for it each time. I wanted to be obvious here rather than efficient; I'm demonstrating COM object use, not speedy programming techniques.</p>
<h2>Summary</h2>
<p>
Visual C++ version 2.1 makes creating COM objects very easy. In the next article, I'll continue developing the house by adding some other appliances and showing how COM object interfaces make controlling a variety of different devices easy.</p>
</BODY>
</HTML>
