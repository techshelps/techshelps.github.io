<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Developing for the Microsoft SideWinder 3D Pro</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_sidewind3d"></a></sup>Developing for the Microsoft SideWinder 3D Pro</h1>
<p>
Microsoft Corporation</p>
<p>
June 24, 1996 (updated August 15, 1996)</p>
<h2>Introduction</h2>
<p>
The Microsoft® SideWinder™ 3D Pro joystick incorporates digital-optical technology for precision, speed, and reliability. Using the joystick is simple: it doesn't drift, it requires no calibration, and it offers more buttons, more axis control (four degrees of freedom), and faster poll time. In other words, it gives you more time to render cool graphics that enhance game play. </p>
<h2>Supporting the SideWinder 3D Pro Joystick</h2>
<p>
The SideWinder 3D Pro includes a minidriver to DirectInput™. To find out if a SideWinder 3D Pro is installed, you don't have to interpret the Registry settings; all you need to do is enumerate the currently selected joystick devices. The following console-application code fragment lists the OEM product name for all 16 joysticks: </p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;mmsystem.h&gt;
#include &lt;regstr.h&gt;
#include &lt;stdio.h&gt;
// Function prototypes:
MMRESULT joyGetOEMProductName(UINT id, LPTSTR pszName);
//
// --- Main Console application ---
// Enumerates JOYSTICKID 1 to 16, and displays the OEM product name for all 16
// Joysticks.&nbsp; Uses the routine joyGetOEMProductName.
//
void main(void)
{
 TCHAR szNameDevice[256];
 UINT i;
 for (i=JOYSTICKID1; i&lt; joyGetNumDevs(); i++)
 {
  printf("JOYSTICKID#%d : ", (i+1));
  if (joyGetOEMProductName(i, (LPTSTR) &amp;szNameDevice[0]) != ERROR_SUCCESS)
  {
 &nbsp; printf("None\n");
  }
  else
  {
 &nbsp; printf("%s\n", szNameDevice);
  }
 }
}
// ----------------------------------------------------------------------------
//
// Function: joyGetOEMProductName
// Parameters: UINT id&nbsp; - Joystick ID from JOYSTICKID1 to JOYSTICK16
//&nbsp;&nbsp;&nbsp; TCHAR * pszName - String storage for the OEM Product name
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for the selected Joystick device specified
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; by the parameter "id"
//
// Returns:&nbsp; If Successful, pszName contains OEM product name for JOYSTICKID
//&nbsp;&nbsp;&nbsp; else Failure, returns MMRESULT error code, and pszName is cleared.
//
// Comments:
// JOYSTICKID1 to JOYSTICKID16 is zero-based, while the registry entries are
//&nbsp; 1-based.&nbsp; This routine expects the parameter "id" to be using JOYSTICKID1
//&nbsp; to JOYSTICKID16 which are defined in the multimedia header file mmsystem.h
//&nbsp; The following registry keys/values are defined in the header file 
//&nbsp; regstr.h:
//&nbsp;&nbsp; REGSTR_PATH_JOYCONFIG
//&nbsp;&nbsp; REGSTR_PATH_JOYOEM
//&nbsp;&nbsp; REGSTR_VAL_JOYOEMNAME 
// 
// ----------------------------------------------------------------------------
}
MMRESULT joyGetOEMProductName(UINT id, TCHAR * pszName)
{
 JOYCAPS JoyCaps;
 TCHAR szKey[256];
 TCHAR szValue[256];
 UCHAR szOEMKey[256];
 HKEY hKey;
 DWORD dwcb;
 LONG lr;
// Note: JOYSTICKID1-16 is zero-based; registry entries for VJOYD areis 1-based.
 id++;&nbsp; 
 if (id &gt; joyGetNumDevs() ) return JOYERR_NOCANDO;
// Open .. MediaResources\CurrentJoystickSettings
 joyGetDevCaps((id-1), &amp;JoyCaps, sizeof(JoyCaps));
 sprintf(szKey,
 &nbsp; "%s\\%s\\%s",
 &nbsp; REGSTR_PATH_JOYCONFIG,
 &nbsp; JoyCaps.szRegKey,
 &nbsp; REGSTR_KEY_JOYCURR);
 lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPTSTR) &amp;szKey, 0, KEY_ALL_ACCESS, &amp;hKey);
 if (lr != ERROR_SUCCESS) return JOYERR_NOCANDO;
// Get OEM Key name. If the query is unsuccessful, then&nbsp; Null the string and return 
// an Error.
 dwcb = sizeof(szOEMKey);
 sprintf(szValue, "Joystick%d%s", id, REGSTR_VAL_JOYOEMNAME);
 lr = RegQueryValueEx(hKey, szValue, 0, 0, (LPBYTE) &amp;szOEMKey, (LPDWORD) &amp;dwcb);
 RegCloseKey(hKey);
 if (lr != ERROR_SUCCESS)
 {
  *pszName = 0;
  return JOYERR_NOCANDO;
 }
// Open OEM Key from ...MediaProperties
 sprintf(szKey, "%s\\%s", REGSTR_PATH_JOYOEM, szOEMKey);
 lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_ALL_ACCESS, &amp;hKey);
 if (lr != ERROR_SUCCESS) return JOYERR_NOCANDO;
// Get OEM Name
 dwcb = sizeof(szValue);
 lr = RegQueryValueEx( hKey,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGSTR_VAL_JOYOEMNAME,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPBYTE) pszName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPDWORD) &amp;dwcb);
 RegCloseKey(hKey);
 if (lr != ERROR_SUCCESS)
  return JOYERR_NOCANDO;
 else
  return JOYERR_NOERROR;
}
</code></pre>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;Don't forget to link your code with Winmm.lib.</p>
<p>
To determine if the SideWinder 3D Pro is currently selected, do a string compare of the OEM product name—which is obtained from the joyGetOEMProductName routine—with the string "SideWinder 3D Pro." </p>
<p>
The SideWinder 3D Pro supports x and y axis rotation, throttle-slide control, an eight-way hat switch, and eight buttons. The JOYCAPS members listed below show the control capabilities.</p>
<p class=label>
<b>SideWinder 3D Pro Control Capability</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>JOYCAPS Member</b></td>
<td class=label width=58%><b>Control Capability</b></td>
</tr>
<tr valign=top>
<td width=42%>jc.wXmin = 0</td>
<td width=58%>Minimum x axis</td>
</tr>
<tr valign=top>
<td width=42%>jc.wXmax = 65535</td>
<td width=58%>Maximum x axis</td>
</tr>
<tr valign=top>
<td width=42%>jc.wYmin = 0</td>
<td width=58%>Minimum y axis</td>
</tr>
<tr valign=top>
<td width=42%>jc.wYmax = 65535</td>
<td width=58%>Maximum y axis</td>
</tr>
<tr valign=top>
<td width=42%>jc.wZmin = 0</td>
<td width=58%>Minimum throttle-slide control axis</td>
</tr>
<tr valign=top>
<td width=42%>jc.wZmax = 65535</td>
<td width=58%>Maximum throttle-slide control axis</td>
</tr>
<tr valign=top>
<td width=42%>jc.wRmin = 0</td>
<td width=58%>Minimum z rotation (rudder) axis</td>
</tr>
<tr valign=top>
<td width=42%>jc.wRmax = 65535</td>
<td width=58%>Maximum z rotation (rudder) axis</td>
</tr>
<tr valign=top>
<td width=42%>jc.wNumButtons = 8</td>
<td width=58%>Eight buttons available</td>
</tr>
</table><br>
<h2>Polling the SideWinder 3D Pro Joystick</h2>
<p>
Polling a typical joystick can take anywhere from 1.2 to nearly 8 milliseconds (ms). That's way too slow for most game developers: they'd rather use that precious time for graphics rendering and play action. </p>
<p>
Because the SideWinder 3D Pro uses digital overdrive technology, you can use a single poll call to get information about all four axes, eight buttons, and the status of the eight-way hat switch in an average of 800 microseconds! This makes it unnecessary to poll each button and axis separately. The following code module demonstrates how this API is used by getting the SideWinder 3D Pro data from DirectInput:</p>
<pre><code>// Reminder:&nbsp; You need mmsystem.h and you must link with winmm.lib
#include &lt;windows.h&gt;
#include &lt;mmsystem.h&gt;
BOOL GetJoyData()
{
 JoyInfoEx jix;
 int nJoyID = JOYSTICKID1;
 char szErr[256];
 memset(&amp;jix, 0x00, sizeof(JOYINFOEX)); // For good measure.
 jix.dwSize = sizeof(JOYINFOEX);
 // Note:&nbsp; With Midas, it takes no more time to return all 
 // information from the joystick than it does to just get only
 // the button states or axis.
 //
 jix.dwFlags = JOY_RETURNALL;
 strcpy(szErr,"");
 // JjoyGetPoxEx will fill in the joyinfoex struct with all the
 // joystick information.
 
 //
 switch(joyGetPosEx(nJoyID, &amp;jix))
 {
  case JOYERR_NOERROR: // No problem.
 &nbsp; break;
  case MMSYSERR_NODRIVER:
 &nbsp; strcpy(szErr,"The joystick driver is not present.");
 &nbsp; return FALSE;
  case MMSYSERR_INVALPARAM:
 &nbsp; strcpy(szErr,"An invalid parameter was passed.");
 &nbsp; return FALSE;
  case MMSYSERR_BADDEVICEID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; strcpy(szErr,"The specified joystick identifier is invalid.");
 &nbsp; return FALSE;
  case JOYERR_UNPLUGGED:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; strcpy(szErr,"Your joystick is unplugged.");
 &nbsp; return FALSE;
  default:
 &nbsp; strcpy(szErr,"Unknown joystick error.");
 &nbsp; return FALSE;
 }&nbsp;&nbsp; // End of switch.
 //
 // This where you get the axis and buttons info.
 // All axis are in the range 0 to 65535.
 // jix.dwXpos - X position.
 // jix.dwYPos - Y position.
 // jix.dwZPos - Throttle slider control.
 // jix.dwRpos - Z Rotation position.
 //
 // To see if button 1 is pressed: 
 //&nbsp;&nbsp;&nbsp; (jix.dwButtons &amp; JOY_BUTTON1) ? PRESSED : NOT_PRESSED;
 // likewise for the other buttons JOY_BUTTON2, JOY_BUTTON3 ...; 
 // JOY_BUTTON8
 //
 // Hat switch (POV) is in jix.dwPOV.
 // The range is 0 to 35900 and the value is -1 if the 
 // hat switch is not pressed.
 //
 return TRUE; 
} // GetJoyData()
</code></pre>
<h2>Using the SideWinder 3D Pro Joystick with MS-DOS Games</h2>
<p>
You can use the SideWinder 3D Pro joystick in an MS-DOS® box under Windows® 95, but the SideWinder 3D Pro is optimized for Windows 95 games. If you run MS-DOS games under Windows 95, the minidriver will be giving you joystick data in digital overdrive mode, but the joystick data will only be for CH Flightstick Pro or ThrustMaster® emulation. You won't get the full benefit of digital overdrive, since MS-DOS games use analog. </p>
<p class=label>
<b>When Digital Overdrive Is Used</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=44%><b>Environment</b></td>
<td class=label width=56%><b>Uses Digital Overdrive?</b></td>
</tr>
<tr valign=top>
<td width=44%>Windows 95 DirectInput</td>
<td width=56%>Yes</td>
</tr>
<tr valign=top>
<td width=44%>MS-DOS under Windows 95</td>
<td width=56%>Yes</td>
</tr>
<tr valign=top>
<td width=44%>MS-DOS</td>
<td width=56%>No; use CH/TM Analog emulation switch. </td>
</tr>
</table><br>
<h2>Questions and Answers</h2>
<p>
<b>What about calibration? </b></p>
<p>
None is required; SideWinder 3D Pro is self-calibrating. </p>
<p>
<b>Can I write non-Windows 95 games (for example, MS-DOS native games) that take advantage of the digital overdrive mode? </b></p>
<p>
No; digital overdrive mode requires DirectInput, which requires Windows 95. </p>
<p>
<b>If I need additional information, who do I talk to? </b></p>
<p>
Send e-mail to swinddev@microsoft.com. Make sure you include your name and your company name with your question.</p>
</BODY>
</HTML>
