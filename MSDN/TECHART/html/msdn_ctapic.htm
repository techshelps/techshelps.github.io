<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating a TAPI Connection Using CTapiConnection</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_ctapic"></a></sup>Creating a TAPI Connection Using CTapiConnection</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
November 1995<br>
Revised: August 1996 (Changed function <b>CheckAndReallocBuffer</b> so that it zeroes out the memory allocated for TAPI structures.)</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4473">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the DIALIT sample application.</a></p>
<h2>Abstract</h2>
<p>
This article demonstrates how the developer can add some simple telephony capabilities to an application by using the Microsoft® Foundation Class Library (MFC). I created a class, <b>CTapiConnection</b>, that supports the basic functionality needed to use the Microsoft Windows® Telephony Application Programming Interface (TAPI) to automatically dial the telephone for a voice connection. It's a really good idea to read <a href="msdn_tapinto.htm">"TAP into the Future"</a> (also available in the MSDN Library) before reading this article to familiarize yourself with the overall design of TAPI; otherwise, you may not understand some of the steps. This article takes the reader through the steps necessary to do the following:
<ul type=disc>
<li>
Initialize TAPI<br><br></li>
<li>
Obtain a phone line<br><br></li>
<li>
Place a call<br><br></li>
<li>
End a call</li>
</ul>
<h2>The DIALIT Sample</h2>
<p>
When I decided to write a sample that uses the Telephony Application Programming Interface (TAPI), the first thing I did was look through the Microsoft® Win32® Software Development Kit (SDK) for any and all information about it. Happily, I found the <i>Microsoft Telephony Programmer's Reference</i> and the <i>Microsoft Telephony Service Provider Interface (TSPI) for Telephony</i>. The programmer's reference is intended to document the functionality that an application using TAPI will need. The service provider documentation is for developers who are going to write their own TAPI services (that is, vendors of telephony equipment).</p>
<p>
With the documentation in hand, I also wanted to find some sample source code to look at. Tucked (or should I say buried?) in the Product Sample tree of the MSDN Library, I found the TAPICOMM (MSDN Library, Sample Code, Product Samples) sample, which demonstrates how to use TAPI for data transmission. It also demonstrates how to use the Communications (COMM) API and how to use multiple threads in your application. In short, it's terrific. Unfortunately, it's also a really big sample. To get to the generic TAPI code is a navigational challenge. As a result, I knew that it would be helpful to give you a simple sample and a Microsoft Foundation Class Library (MFC) class to help you learn about TAPI.</p>
<p>
Thus, I decided to create a simple telephone dialer, and I came up with the DIALIT sample. It was written using Visual C++® 2.2 and MFC version 3.1. It is a Win32-based application that has been built and tested on Windows® 95. As you can see from Figure 1, the user interface is minimal. (Yes, you are reading this correctly. I really did write something non-GUI. Amazing!)</p>
<p>
<img src="ctapic_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The DIALIT sample</b></p>
<h2>The CTapiConnection Class</h2>
<p>
The <b>CTapiConnection</b> class was designed for the DIALIT sample to allow the application developer a simple method of establishing a TAPI connection. The class, as defined in the TAPIUTILS.H file, is shown below. The member functions will be described in more detail later in this article.</p>
<pre><code>class CTapiConnection
{

 protected:
 &nbsp;&nbsp; // This area contains the protected members of the CTapiConnection class.
 &nbsp;&nbsp; DWORD m_dwNumDevs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the number of line devices available
 &nbsp;&nbsp; DWORD m_dwDeviceID;&nbsp;&nbsp;&nbsp;&nbsp; // the line device ID
 &nbsp;&nbsp; DWORD m_dwRequestedID;
 &nbsp;&nbsp; LONG m_lAsyncReply;

 &nbsp;&nbsp; // BOOLEANS to handle reentrancy.
 &nbsp;&nbsp; BOOL m_bShuttingDown;
 &nbsp;&nbsp; BOOL m_bStoppingCall;
 &nbsp;&nbsp; BOOL m_bInitializing;
 &nbsp;&nbsp; BOOL m_bReplyReceived;
 &nbsp;&nbsp; BOOL m_bTapiInUse;&nbsp;&nbsp;&nbsp;&nbsp; // whether TAPI is in use or not
 &nbsp;&nbsp; BOOL m_bInitialized;&nbsp;&nbsp; // whether TAPI has been initialized

 public:
 &nbsp;&nbsp; // This area contains the public members of the CTapiConnection class.
 &nbsp;&nbsp; HLINEAPP m_hLineApp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the usage handle of this application for TAPI
 &nbsp;&nbsp; HCALL m_hCall;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle to the call
 &nbsp;&nbsp; HLINE m_hLine;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle to the open line
 &nbsp;&nbsp; DWORD m_dwAPIVersion;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the API version
 &nbsp;&nbsp; char m_szPhoneNumber[64];&nbsp; // the phone number to call

 protected:
 &nbsp;&nbsp; // Here is where I put the protected (internal) functions.
BOOL ShutdownTAPI();
 &nbsp;&nbsp; BOOL HandleLineErr(long lLineErr);
 &nbsp;&nbsp; LPLINEDEVCAPS GetDeviceLine(DWORD *dwAPIVersion, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPLINEDEVCAPS lpLineDevCaps);
 &nbsp;&nbsp; LPLINEDEVCAPS MylineGetDevCaps(LPLINEDEVCAPS lpLineDevCaps,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwDeviceID, DWORD dwAPIVersion);
 &nbsp;&nbsp; LPVOID CheckAndReAllocBuffer(LPVOID lpBuffer, size_t sizeBufferMinimum);
 &nbsp;&nbsp; LPLINEADDRESSCAPS MylineGetAddressCaps (LPLINEADDRESSCAPS lpLineAddressCaps,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwDeviceID, DWORD dwAddressID, DWORD dwAPIVersion, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwExtVersion);
 &nbsp;&nbsp; BOOL MakeTheCall(LPLINEDEVCAPS lpLineDevCaps,LPCSTR lpszAddress);
 &nbsp;&nbsp; LPLINECALLPARAMS CreateCallParams (LPLINECALLPARAMS lpCallParams, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPCSTR lpszDisplayableAddress);
 &nbsp;&nbsp; long WaitForReply (long lRequestID);
 &nbsp;&nbsp; void HandleLineCallState(DWORD dwDevice, DWORD dwMessage, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwCallbackInstance,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);
 private:
 &nbsp; // This section is for private functions.

 public:
 &nbsp;&nbsp; // Public functions.
 &nbsp;&nbsp; CTapiConnection();
 &nbsp;&nbsp; ~CTapiConnection();
 &nbsp;&nbsp; BOOL Create(char *szPhoneNumber = NULL);
 &nbsp;&nbsp; BOOL DialCall(char *szPhoneNumber = NULL);
 &nbsp;&nbsp; BOOL HangupCall();
 &nbsp;&nbsp; static void CALLBACK lineCallbackFunc(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);

};
</code></pre>
<p>
As you can glean from the class definition, implementing basic telephony requires a lot of work. But you will notice that the member functions that I have defined are simple:
<ul type=disc>
<li>
Create<br><br></li>
<li>
DialCall<br><br></li>
<li>
HangupCall<br><br></li>
<li>
lineCallbackFunc</li>
</ul>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The line callback function is not called directly by the application using the class; rather, it is called by the system for line notifications. I'll talk more about the line callback function later in this article.</p>
<h2>Step One: Initializing TAPI</h2>
<p>
The first thing an application must do before it uses any telephony services is to initialize TAPI. This means that the application must establish some way to communicate between itself and TAPI. TAPI uses a callback function to facilitate this communication. The application tells TAPI the address of this callback function when the application makes a call to <b>lineInitialize</b>.</p>
<p>
The <b>lineInitialize</b> function fills in two values passed to it: a usage handle (shown in the following example as <i>m_hLineApp</i>) and the number of line devices available to the application (shown in the following example as <i>m_dwNumDevs</i>). If the call to <b>lineInitialize</b> is successful, a value of zero is returned. If an error occurs, a negative value is returned. All TAPI functions return a value of zero to signal success. To make it easier for me, I defined a constant called SUCCESS to be zero and used that in my code.</p>
<p>
The following example is the code I wrote to initialize TAPI. It takes a pointer to a string containing the phone number to be dialed. By default, this pointer is NULL. The member function that actually dials the phone number, <b>DialCall</b>, also takes as a parameter the telephone number to dial. The user of the class can specify the number in either place.</p>
<pre><code>BOOL CTapiConnection::Create(char *szPhoneNumber)
{
 &nbsp;&nbsp; long lReturn;

 &nbsp;&nbsp; // If we're already initialized, then initialization succeeds.
 &nbsp;&nbsp; if (m_hLineApp)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;

 &nbsp;&nbsp; // If we're in the middle of initializing, then fail, we're not done.
 &nbsp;&nbsp; if (m_bInitializing)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp;&nbsp; m_bInitializing = TRUE;

 &nbsp;&nbsp; // Initialize TAPI.
 &nbsp;&nbsp; do
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lReturn = ::lineInitialize(&amp;m_hLineApp, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxGetInstanceHandle(), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lineCallbackFunc, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "DialIt", 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;m_dwNumDevs);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_dwNumDevs == 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox("There are no telephony devices installed.");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bInitializing = FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HandleLineErr(lReturn))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("lineInitialize unhandled error\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bInitializing = FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; while(lReturn != SUCCESS);

 &nbsp;&nbsp; // If the user furnished a phone number, copy it over.
 &nbsp;&nbsp; if (szPhoneNumber)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(m_szPhoneNumber, szPhoneNumber);

 &nbsp;&nbsp; m_bInitializing = FALSE;
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<h2>Step Two: Obtaining a Line</h2>
<p>
Now that TAPI has been initialized, the application needs to interact with the user to know what type of call to make. The application does this by building a dialog box or property sheet using the standard Win32 functions. There isn't a handy common dialog for this. (Drats!) In the DIALIT sample, a simple dialog box lets the user enter the desired phone number to dial in the edit box and then click the Dial button to dial.</p>
<p>
When we know the number to dial and that we should dial it, the application needs to obtain a line handle. This is done by a call to the <b>lineOpen</b> function. Before the application can make a call to <b>lineOpen</b>, though, it has to make sure that the line can support the type of call that the application is trying to make. In the case of the DIALIT sample, this is a line that is capable of voice transmission.</p>
<h3>Getting the Line Capabilities</h3>
<p>
The application calls the <b>lineGetDevCaps</b> function to determine the capabilities of a given phone line. The function fills in a structure, <b>LINEDEVCAPS</b>, containing this information. Sounds straightforward, doesn't it. Well, there's a bit of a catch: the <b>LINEDEVCAPS</b> structure is defined by the telephony service provider and, as such, is variable length. After the application makes the call to <b>lineGetDevCaps</b>, it must check to see if the amount of space supplied for the structure was sufficient for the size of the provider's structure. This is done by comparing the <b>dwNeededSize</b> and <b>dwTotalSize</b> fields. If the needed size is larger than the total size, the application needs to pass a larger buffer to the function and try again. I created a function that calls <b>lineGetDevCaps</b> until a sufficient sized buffer is returned for this purpose. This function calls another function, <b>CheckAndReAllocBuffer</b>, that checks to see if the buffer exists and is large enough; it also fills in the <b>dwTotalSize</b><i> </i>field of the <b>LINEDEVCAPS</b> structure. Filling in this field is imperative. If you don't set this correctly, the call to <b>lineGetDevCaps</b> will most likely fail. This function is called from the <b>DialCall</b> member function of the <b>CTapiConnection</b> class.</p>
<pre><code>LPLINEDEVCAPS CTapiConnection::MylineGetDevCaps(
 &nbsp;&nbsp; LPLINEDEVCAPS lpLineDevCaps,
 &nbsp;&nbsp; DWORD dwDeviceID, DWORD dwAPIVersion)
{
 &nbsp;&nbsp; // Allocate enough space for the structure plus 1024.
 &nbsp;&nbsp; size_t sizeofLineDevCaps = sizeof(LINEDEVCAPS) + 1024;
 &nbsp;&nbsp; long lReturn;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Continue this loop until the structure is big enough.
 &nbsp;&nbsp; while(TRUE)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Make sure the buffer exists, is valid, and is big enough.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpLineDevCaps = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPLINEDEVCAPS) CheckAndReAllocBuffer(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID) lpLineDevCaps,&nbsp;&nbsp; // pointer to existing buffer, if any
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeofLineDevCaps);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // minimum size the buffer should be

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lpLineDevCaps == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Make the call to fill the structure.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lReturn = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::lineGetDevCaps(m_hLineApp, dwDeviceID, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwAPIVersion, 0, lpLineDevCaps);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HandleLineErr(lReturn))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalFree(lpLineDevCaps);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (lReturn != SUCCESS);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the buffer was big enough, then succeed.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((lpLineDevCaps -&gt; dwNeededSize) &lt;= (lpLineDevCaps -&gt; dwTotalSize))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return lpLineDevCaps;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Buffer wasn't big enough. Make it bigger and try again.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeofLineDevCaps = lpLineDevCaps -&gt; dwNeededSize;
 &nbsp;&nbsp; }
}

LPVOID CTapiConnection::CheckAndReAllocBuffer(LPVOID lpBuffer, 
 &nbsp; size_t sizeBufferMinimum)
{
 &nbsp;&nbsp; size_t sizeBuffer;

 &nbsp;&nbsp; if (lpBuffer == NULL)&nbsp;&nbsp; // allocate the buffer if necessary
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeBuffer = sizeBufferMinimum;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpBuffer = (LPVOID) LocalAlloc (LPTR, sizeBuffer);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lpBuffer == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("LocalAlloc failed in CheckAndReAllocBuffer./n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else&nbsp;&nbsp; // if the structure already exists, make sure it is good
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeBuffer = LocalSize((HLOCAL) lpBuffer);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sizeBuffer == 0)&nbsp;&nbsp; // bad pointer?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Was the buffer big enough for the structure?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sizeBuffer &lt; sizeBufferMinimum)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalFree(lpBuffer);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CheckAndReAllocBuffer(NULL, sizeBufferMinimum);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; }
 &nbsp;&nbsp; // Set the dwTotalSize field to the size of the buffer or the call will&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; // fail.
memset(lpBuffer, 0, sizeBuffer);
 &nbsp; ((LPVARSTRING) lpBuffer ) -&gt; dwTotalSize = (DWORD) sizeBuffer;
 &nbsp;&nbsp; return lpBuffer;
}
</code></pre>
<p>
Another task that must be accomplished before actually obtaining the line is to call the <b>lineNegotiateAPIVersion</b> function. This function indicates the version of TAPI that the application was written to support. In the DIALIT sample, I pass in constants that are defined at the top of the TAPIUTILS.CPP file to indicate which versions of TAPI support my sample. This is done in the <b>GetDeviceLine</b> member function, which obtains the first usable voice line available to me.</p>
<pre><code>// TAPI version that this sample is designed to use.
#define SAMPLE_TAPI_VERSION 0x00010004

// Early TAPI version.
#define EARLY_TAPI_VERSION 0x00010003

LPLINEDEVCAPS CTapiConnection::GetDeviceLine(DWORD *pdwAPIVersion, 
 &nbsp; LPLINEDEVCAPS lpLineDevCaps)
{
 &nbsp;&nbsp; DWORD dwDeviceID;
 &nbsp;&nbsp; char szLineUnavail[] = "Line Unavailable";
 &nbsp;&nbsp; char szLineUnnamed[] = "Line Unnamed";
 &nbsp;&nbsp; char szLineNameEmpty[] = "Line Name is Empty";
 &nbsp;&nbsp; LPSTR lpszLineName;
 &nbsp;&nbsp; long lReturn;
 &nbsp;&nbsp; char buf[MAX_PATH];
 &nbsp;&nbsp; LINEEXTENSIONID lineExtID;
 &nbsp;&nbsp; BOOL bDone = FALSE;

 &nbsp;&nbsp; for (dwDeviceID = 0; (dwDeviceID &lt; m_dwNumDevs) &amp;&amp; !bDone; dwDeviceID ++)
 &nbsp;&nbsp; {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lReturn = ::lineNegotiateAPIVersion(m_hLineApp, dwDeviceID, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EARLY_TAPI_VERSION, SAMPLE_TAPI_VERSION,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdwAPIVersion, &amp;lineExtID);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((HandleLineErr(lReturn))&amp;&amp;(*pdwAPIVersion))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpLineDevCaps = MylineGetDevCaps(lpLineDevCaps, dwDeviceID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pdwAPIVersion);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((lpLineDevCaps -&gt; dwLineNameSize) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lpLineDevCaps -&gt; dwLineNameOffset) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lpLineDevCaps -&gt; dwStringFormat == STRINGFORMAT_ASCII))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This is the name of the device.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszLineName = ((char *) lpLineDevCaps) + 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpLineDevCaps -&gt; dwLineNameOffset;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(buf, "Name of device is: %s\n", lpszLineName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString(buf);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp; // DevCaps doesn't have a valid line name. Unnamed.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszLineName = szLineUnnamed;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp; // Couldn't NegotiateAPIVersion. Line is unavail.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszLineName = szLineUnavail;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If this line is usable and we don't have a default initial
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // line yet, make this the initial line.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((lpszLineName != szLineUnavail) &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lReturn == SUCCESS )) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dwDeviceID = dwDeviceID;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bDone = TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dwDeviceID = MAXDWORD;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return (lpLineDevCaps);
}
</code></pre>
<p>
In your application, you may wish to get the line information and present it to the user. For example, on my laptop computer I have two modems: one that I use when I am running without using the docking station and one that I use when I am docked. The way my sample is written now, the first modem selected is the one that I use when I am docked. This means that I can't test the sample at home. (Too bad. How sad.)</p>
<h3>Calling lineOpen</h3>
<p>
We've chosen a line, and now we want to know whether this is the line we want to use. In the DIALIT sample, we check to see if the line is usable, if it can handle voice calls, and if it is capable of dialing out. This is done by checking the values filled into the <b>LINEDEVCAPS</b> structure I passed in.</p>
<pre><code>if (!(lpLineDevCaps-&gt;dwBearerModes &amp; LINEBEARERMODE_VOICE ))
{
 &nbsp;&nbsp; AfxMessageBox("The selected line doesn't support VOICE capabilities");
 &nbsp;&nbsp; goto DeleteBuffers;
}
// Does this line have the capability to make calls?
if (!(lpLineDevCaps-&gt;dwLineFeatures &amp; LINEFEATURE_MAKECALL))
{
 &nbsp;&nbsp; AfxMessageBox("The selected line doesn't support MAKECALL capabilities");
 &nbsp;&nbsp; goto DeleteBuffers;
}
// Does this line have the capability for interactive voice?
if (!(lpLineDevCaps-&gt;dwMediaModes &amp; LINEMEDIAMODE_INTERACTIVEVOICE))
{
 &nbsp;&nbsp; AfxMessageBox("The selected line doesn't support INTERACTIVE VOICE
 &nbsp;&nbsp;&nbsp;&nbsp; capabilities");
 &nbsp;&nbsp; goto DeleteBuffers;
}
</code></pre>
<p>
An application uses the <b>lineOpen</b> function to place calls and to monitor incoming calls. When opening a line for an outgoing call, the DIALIT sample sets the privilege level to LINECALLPRIVILEGE_NONE to insulate it from incoming calls and to allow outgoing calls. You can set other privileges, but these are for call monitoring.</p>
<pre><code>// Open the line for an outgoing call.
do
{
 &nbsp;&nbsp; lReturn = ::lineOpen(m_hLineApp, m_dwDeviceID, &amp;m_hLine,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dwAPIVersion, 0, 0, LINECALLPRIVILEGE_NONE, 0, 0);

 &nbsp;&nbsp; if((lReturn == LINEERR_ALLOCATED) ||(lReturn == LINEERR_RESOURCEUNAVAIL))
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HangupCall();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("Line is already in use by a non-TAPI application"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " or by another TAPI Service Provider.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto DeleteBuffers;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; if (HandleLineErr(lReturn))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("Unable to Use Line\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HangupCall();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto DeleteBuffers;
 &nbsp;&nbsp; }
}
while(lReturn != SUCCESS);
</code></pre>
<h2>Step Three: Placing the Call</h2>
<p>
That's right. We haven't even placed the call yet. Aren't you glad I've written a class?</p>
<p>
An application uses the <b>lineMakeCall</b> function to place a call. This function takes the following parameters:
<ul type=disc>
<li>
A handle to the open line obtained from the <b>lineOpen</b> call.<br><br></li>
<li>
A pointer to the handle for the call. This will be filled in by <b>lineMakeCall</b>.<br><br></li>
<li>
The destination address (the area code and telephone number).<br><br></li>
<li>
The country code (which can be set to zero to use the default value).<br><br></li>
<li>
A pointer to line parameters. This allows the application to specify how the call should be set up (that is, the data rate, dialing parameters, and so on). If this is set to NULL, the default setup is used.</li>
</ul>
<p>
The <b>lineMakeCall</b> function returns a positive "request ID" (which I saved in the <i>m_dwRequestID</i> member variable of my class) if the function will be completed asynchronously, or a negative error number if an error has occurred. The following function demonstrates how the <b>LPCALLPARAMS</b> structure can be filled in to support a simple interactive voice call.</p>
<pre><code>LPLINECALLPARAMS CTapiConnection::CreateCallParams (
 &nbsp;&nbsp; LPLINECALLPARAMS lpCallParams, LPCSTR lpszDisplayableAddress)
{
 &nbsp;&nbsp; size_t sizeDisplayableAddress;

 &nbsp;&nbsp; if (lpszDisplayableAddress == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszDisplayableAddress = "";

 &nbsp;&nbsp; sizeDisplayableAddress = strlen(lpszDisplayableAddress) + 1;

 &nbsp;&nbsp; lpCallParams = (LPLINECALLPARAMS) CheckAndReAllocBuffer(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID) lpCallParams, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(LINECALLPARAMS) + sizeDisplayableAddress);

 &nbsp;&nbsp; if (lpCallParams == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
 &nbsp;&nbsp; 
// This is where we configure the line.
 &nbsp;&nbsp; lpCallParams -&gt; dwBearerMode = LINEBEARERMODE_VOICE;
 &nbsp;&nbsp; lpCallParams -&gt; dwMediaMode&nbsp; = LINEMEDIAMODE_INTERACTIVEVOICE;

 &nbsp;&nbsp; // This specifies that we want to use only IDLE calls and
 &nbsp;&nbsp; // don't want to cut into a call that might not be IDLE (ie, in use).
 &nbsp;&nbsp; lpCallParams -&gt; dwCallParamFlags = LINECALLPARAMFLAGS_IDLE;

 &nbsp;&nbsp; // If there are multiple addresses on line, use first anyway.
 &nbsp;&nbsp; // It will take a more complex application than a simple tty app
 &nbsp;&nbsp; // to use multiple addresses on a line anyway.
 &nbsp;&nbsp; lpCallParams -&gt; dwAddressMode = LINEADDRESSMODE_ADDRESSID;

 &nbsp;&nbsp; // Address we are dialing.
 &nbsp;&nbsp; lpCallParams -&gt; dwDisplayableAddressOffset = sizeof(LINECALLPARAMS);
 &nbsp;&nbsp; lpCallParams -&gt; dwDisplayableAddressSize = sizeDisplayableAddress;
 &nbsp;&nbsp; strcpy((LPSTR)lpCallParams + sizeof(LINECALLPARAMS), 
 &nbsp;&nbsp;&nbsp;&nbsp; lpszDisplayableAddress);

 &nbsp;&nbsp; return lpCallParams;
}
</code></pre>
<p>
After the <b>lineMakeCall</b> function successfully sets up the call, the application receives a LINE_REPLY message (the asynchronous reply to <b>lineMakeCall</b>). The application gets this message through its callback function. This means that a call at the local end has been established (that is, we have a dial tone). The LINE_REPLY message also informs the application that the call handle returned by <b>lineMakeCall</b> is valid. The following code shows the line callback function that the DIALIT sample uses.</p>
<pre><code>void CALLBACK CTapiConnection::lineCallbackFunc(
 &nbsp;&nbsp; DWORD dwDevice, DWORD dwMsg, DWORD dwCallbackInstance, 
 &nbsp;&nbsp; DWORD dwParam1, DWORD dwParam2, DWORD dwParam3)
{

 &nbsp;&nbsp; // Handle the line messages.
 &nbsp;&nbsp; switch(dwMsg)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINE_CALLSTATE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyThis-&gt;HandleLineCallState(dwDevice, dwMsg, dwCallbackInstance, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwParam1, dwParam2, dwParam3);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINE_CLOSE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Line has been shut down.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(MyThis);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyThis-&gt;m_hLine = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyThis-&gt;m_hCall = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyThis-&gt;HangupCall();&nbsp;&nbsp; // all handles invalidated by this time
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINE_REPLY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((long) dwParam2 != SUCCESS)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("LINE_REPLY error\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("LINE_REPLY: successfully replied\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINE_CREATE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(MyThis);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MyThis-&gt;m_dwNumDevs &lt;= dwParam1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyThis-&gt;m_dwNumDevs = dwParam1+1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("lineCallbackFunc message ignored\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return;
}
</code></pre>
<p>
Several other messages or notifications are sent to the application's callback function. For instance, as the call is placed, the call passes through a number of states, each of which results in a LINE_CALLSTATE message sent to the callback function. After the message indicating the connected state is received, the application can begin sending data. I used a handler for the LINE_CALLSTATE message that prints debug messages indicating the current call status. For your application, you may wish to write these messages to a status bar.</p>
<pre><code>void CTapiConnection::HandleLineCallState(
 &nbsp;&nbsp; DWORD dwDevice, DWORD dwMessage, DWORD dwCallbackInstance,
 &nbsp;&nbsp; DWORD dwParam1, DWORD dwParam2, DWORD dwParam3)
{

 &nbsp;&nbsp; // Error if this CALLSTATE doesn't apply to our call in progress.
 &nbsp;&nbsp; if ((HCALL) dwDevice != m_hCall)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("LINE_CALLSTATE: Unknown device ID");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // dwParam1 is the specific CALLSTATE change that is occurring.
 &nbsp;&nbsp; switch (dwParam1)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINECALLSTATE_DIALTONE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("Dial Tone\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINECALLSTATE_DIALING:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("Dialing\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINECALLSTATE_PROCEEDING:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("Proceeding\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINECALLSTATE_RINGBACK:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("RingBack\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINECALLSTATE_BUSY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("Line busy, shutting down\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HangupCall();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINECALLSTATE_IDLE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("Line idle\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HangupCall();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINECALLSTATE_SPECIALINFO:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("Special Info, probably couldn't dial number\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HangupCall();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINECALLSTATE_DISCONNECTED:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR pszReasonDisconnected;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (dwParam2)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_NORMAL:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Remote Party Disconnected";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_UNKNOWN:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Disconnected: Unknown reason";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_REJECT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Remote Party rejected call";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_PICKUP:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Disconnected: Call was picked up on another phone";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_FORWARDED:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Disconnected: Forwarded";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_BUSY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Disconnected: Busy";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_NOANSWER:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Disconnected: No Answer";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_BADADDRESS:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Disconnected: Bad Address";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_UNREACHABLE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Disconnected: Unreachable";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_CONGESTION:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Disconnected: Congestion";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_INCOMPATIBLE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Disconnected: Incompatible";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_UNAVAIL:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Disconnected: Unavailable";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINEDISCONNECTMODE_NODIALTONE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = "Disconnected: No Dial Tone";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pszReasonDisconnected = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Disconnected: LINECALLSTATE; Bad Reason";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString(pszReasonDisconnected);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HangupCall();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LINECALLSTATE_CONNECTED:&nbsp;&nbsp; // CONNECTED!!!
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("Connected!\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("Unhandled LINECALLSTATE message\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }
}
</code></pre>
<h2>Step Four: Sending Data</h2>
<p>
If the DIALIT sample supported data transmission, now would be the time that it would send the data. The user would specify, through some user interface widget, what file or data to send and then initiate the data transmission. The TAPI functions continue to manage the opened line and the call in progress, but the actual transmission is started and controlled by non-TAPI functions (that is, COMM functions). This is the type of transmission that the TAPICOMM sample demonstrates.</p>
<p>
In our case, we are establishing a voice call. TAPI continues to monitor the line and call, but if there is anything special we need to do, it is up to us. When a call is connected, the service provider may display a dialog box asking the user to lift the telephone receiver and click the Talk button.</p>
<p>
<img src="ctapic_2.gif" border=0></p>
<p class=label>
<b>Figure 2. A Call Status dialog box</b></p>
<p>
In our sample, we use a function (borrowed from the TAPICOMM sample) that allows us to resynchronize a TAPI line call by waiting for the LINE_REPLY message. In other words, it waits until a LINE_REPLY is received or the line is shut down. The function is called from the same thread that made the call to <b>lineInitialize</b>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you try to call this function from a different thread than the thread that called the <b>lineInitialize</b> function, the <b>PeekMessage</b> function will not be synchronized with the correct thread. Instead, it will be peeking at the message pump for the wrong thread. You will remember from reading the <a href="msdn_tapinto.htm">"TAP into the Future"</a> article that TAPI is designed such that a hidden window is created by TAPI on behalf of the application when the <b>lineInitialize</b> function is called. All notifications and messages are sent to the callback function specified in the <b>lineInitialize</b> function. Thus the thread that called <b>lineInitialize</b> contains the message pump for the messages that will be sent to the callback function.</p>
<p>
If the call was dropped while in a wait state, this function can potentially be re-entered. We handle this by dropping out of the function and assuming that the call was canceled. This is the reason for the <i>bReentered</i> flag. This flag is set to FALSE when the function is entered and TRUE when the function is exited. If <i>bReentered</i> is ever TRUE during the function processing, then the function was re-entered.</p>
<pre><code>long CTapiConnection::WaitForReply (long lRequestID)
{
 &nbsp;&nbsp; static BOOL bReentered;
 &nbsp;&nbsp; bReentered = FALSE;

 &nbsp;&nbsp; if (lRequestID &gt; SUCCESS)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSG msg; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwTimeStarted;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bReplyReceived = FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dwRequestedID = (DWORD) lRequestID;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Initializing this just in case there is a bug
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that sets m_bReplyReceived without setting the reply value.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_lAsyncReply = LINEERR_OPERATIONFAILED;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwTimeStarted = GetTickCount();

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(!m_bReplyReceived)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslateMessage(&amp;msg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DispatchMessage(&amp;msg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This should only occur if the line is shut down while waiting.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((m_hCall != NULL) &amp;&amp;(!m_bTapiInUse || bReentered))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bReentered = TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return WAITERR_WAITABORTED;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // It's a really bad idea to timeout a wait for a LINE_REPLY.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If we are expecting a LINE_REPLY, we should wait till we get
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // it; it might take a long time to dial (for example).

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If 5 seconds go by without a reply, it might be a good idea
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to display a dialog box to tell the user that a
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // wait is in progress and to give the user the capability to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // abort the wait.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bReentered = TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_lAsyncReply;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; bReentered = TRUE;
 &nbsp;&nbsp; return lRequestID;
}
</code></pre>
<h2>Step Five: Ending the Call</h2>
<p>
When the user finishes the phone call, the application receives a LINE_CALLSTATE message telling it that the state of a line device has changed. At this point the application can disconnect the call. In the DIALIT sample, the application disconnects the call when the user clicks the Hang Up button. The sample ends the calls, closes the line, shuts down TAPI, and exits.</p>
<p>
Before the application disconnects the call, it checks to see if a call is already in progress. If not, the application calls the <b>lineDrop</b> function to place the call in the IDLE state. The call handle must then be released for the finished call. This is done by the <b>lineDeallocateCall</b> function. Finally, <b>lineClose</b> is called to close the line. At this point, there will be no more incoming or outgoing calls using that line handle.</p>
<pre><code>BOOL CTapiConnection::HangupCall()
{
 &nbsp;&nbsp; LPLINECALLSTATUS pLineCallStatus = NULL;
 &nbsp;&nbsp; long lReturn;

 &nbsp;&nbsp; // Prevent HangupCall re-entrancy problems.
 &nbsp;&nbsp; if (m_bStoppingCall)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;

 &nbsp;&nbsp; // If TAPI is not being used right now, then the call is hung up.
 &nbsp;&nbsp; if (!m_bTapiInUse)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;

 &nbsp;&nbsp; m_bStoppingCall = TRUE;

 &nbsp;&nbsp; // If there is a call in progress, drop and deallocate it.
 &nbsp;&nbsp; if (m_hCall)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pLineCallStatus = (LPLINECALLSTATUS)malloc(sizeof(LINECALLSTATUS));

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!pLineCallStatus)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShutdownTAPI();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bStoppingCall = FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lReturn = ::lineGetCallStatus(m_hCall, pLineCallStatus);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Only drop the call when the line is not IDLE.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!((pLineCallStatus -&gt; dwCallState) &amp; LINECALLSTATE_IDLE))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::lineDrop(m_hCall, NULL, 0);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The call is now idle. Deallocate it!
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lReturn = ::lineDeallocateCall(m_hCall);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HandleLineErr(lReturn))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("lineDeallocateCall unhandled error\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(lReturn != SUCCESS);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // If we have a line open, close it.
 &nbsp;&nbsp; if (m_hLine)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lReturn = ::lineClose(m_hLine);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HandleLineErr(lReturn))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("lineClose unhandled error\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(lReturn != SUCCESS);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Clean up.
 &nbsp;&nbsp; m_hCall = NULL;
 &nbsp;&nbsp; m_hLine = NULL;
 &nbsp;&nbsp; m_bTapiInUse = FALSE;
 &nbsp;&nbsp; m_bStoppingCall = FALSE;&nbsp;&nbsp; // allow HangupCall to be called again

 &nbsp;&nbsp; // Need to free buffer returned from lineGetCallStatus.
 &nbsp;&nbsp; if (pLineCallStatus)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(pLineCallStatus);&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
Next, the application calls <b>lineShutdown</b> to end the use of TAPI.</p>
<pre><code>BOOL CTapiConnection::ShutdownTAPI()
{
 &nbsp;&nbsp; long lReturn;

 &nbsp;&nbsp; // If we aren't initialized, then Shutdown is unnecessary.
 &nbsp;&nbsp; if (m_hLineApp == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;

 &nbsp;&nbsp; // Prevent ShutdownTAPI re-entrancy problems.
 &nbsp;&nbsp; if (m_bShuttingDown)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;

 &nbsp;&nbsp; m_bShuttingDown = TRUE;

 &nbsp;&nbsp; HangupCall();

 &nbsp;&nbsp; lReturn = ::lineShutdown(m_hLineApp);
 &nbsp;&nbsp; if (!HandleLineErr(lReturn))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputDebugString("lineShutdown unhandled error\n");

 &nbsp;&nbsp; m_bTapiInUse = FALSE;
 &nbsp;&nbsp; m_hLineApp = NULL;
 &nbsp;&nbsp; m_hCall = NULL;
 &nbsp;&nbsp; m_hLine = NULL;
 &nbsp;&nbsp; m_bShuttingDown = FALSE;
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
At this point the application is finished using TAPI and can continue to do whatever else it was designed to do. In the DIALIT sample, the application exits.</p>
<h2>Summary</h2>
<p>
As mentioned at the beginning of this article, this class was written to provide the most basic TAPI functionality of initialization, ability to obtain a line, dial voice calls, drop a line, and shut down. It can easily be expanded to support data modem capabilities or a snazzy user interface (you can certainly do better than the one I did). The class could even be wrapped into an OLE Control and used by a Visual Basic® application. So now that you have a simple class that you can use to include TAPI functionality in your application, some sample code, the Win32 SDK, the documentation, and this article, you really have no excuse to avoid TAPI any more. I've done much of the hard work for you already, so please make the time spent worthwhile and use the class.</p>
</BODY>
</HTML>
