<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFC/COM Objects 4: Aggregation</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_house4"></a></sup>MFC/COM Objects 4: Aggregation</h1>
<p>
Nigel Thompson<br>
Microsoft Developer Network Technology Group</p>
<p>
March 20, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4234">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the HOUSE4 sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This technical article is the fourth in a series that describes creating and using 32-bit Component Object Model (COM) objects with Visual C++™ and the Microsoft Foundation Class Library (MFC). This article looks at code reuse through object aggregation.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Before running the sample, you must register the location of APPLIANCES.DLL in the registry. See the first article in this series (<a href="msdn_house1.htm">"MFC/COM Objects 1: Creating a Simple Object"</a>) for details on how to do this.</p>
<h2>Introduction</h2>
<p>
If you have read the previous three articles in this "MFC/COM Objects" series, you may well have thought to yourself that there seems to be an awful lot of code required to implement a few simple interfaces, and also that there is a lot of code replication in my examples. Well, even if you haven't had those thoughts, I have. It has seemed to me for a while now that I should in some way be reusing some bits of the code rather than doing yet another cut and paste job.</p>
<p>
In this article I want to look at a method of code reuse, supported by COM objects, called <i>aggregation</i>. After reading a lot of what has been written to date, I have to say that several people have really avoided the issue in practical terms. I will try very hard not to do that, too!</p>
<p>
Before we go any further, let me answer one question that you might have about using multiple inheritance as a means of incorporating multiple interfaces into a single object. In response to the "Can we do this?" question, there are two answers: "Yes" and "No." On the "Yes" side, there are ways to use multiple inheritance, but they are a bit outside the scope of these articles. On the "No" side, I have to tell you that if you want to stick with the Microsoft® Foundation Class Library (MFC) and the wonders of the Visual C++™ AppWizard, you have to live without multiple inheritance because the MFC folks will not be using it. So when AppWizard becomes capable of creating and editing COM object code, it's going to do it through object aggregation and the macros you've seen so far.</p>
<h2>Aggregation</h2>
<p>
I don't want to go into horrendous detail about exactly how object aggregation works because you can read about that in the <i>OLE 2.0 Design Specification</i>, in Kraig Brockschmidt's book <i>Inside OLE 2</i> (MSDN Library, Books), and a few articles in the MSDN Library. Aggregation is a way of having a COM object support a given interface without implementing that interface directly itself. Instead, the COM object includes another object that <i>does</i> support that interface, and the containing object exports the interface from the contained object. Figure 1 shows the idea a bit more clearly.</p>
<p>
<img src="house4_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Aggregation in use</b></p>
<p>
To the user of the appliance object, it is as though the appliance supports the <b>IDrawing</b> interface even though in actual fact it is implemented in a different object. There is a lot more to the mechanism of aggregation than I've talked about here, but this is enough detail for now.</p>
<h2>Reusing Some of the Code</h2>
<p>
If you dig through the code of the various appliances I have built for the HOUSE sample, you'll find that they all support the <b>IDrawing </b>interface, and in fact, all implement it the same way with pretty much exactly the same piece of code. So here's a good candidate for code reuse. If you read the previous article (<a href="msdn_house3.htm">"MFC/COM Objects 3: Objects That Talk Back"</a>), you might have thought that the <b>INotifySrc</b> interface would be a handy thing to have in all objects that can change state—I did, too. So my second candidate for the aggregation treatment is a notification list object that any appliance can use to keep track of who needs notification of changes of state.</p>
<p>
Of these two examples, the notification list object is the easiest to envisage. After all, one list is much like another, and if the list object were to support adding a user, removing a user, and notifying all users, we'd have the design pretty much done. So I could alter my earlier definition of <b>INotify</b> a bit, crank out the code, and have an object ready for aggregation into one of the appliances.</p>
<p>
The first example of reuse—support for the <b>IDrawing</b> interface—is a bit harder to envisage. You can't simply have a chunk of code that draws without knowing exactly what it needs to draw. In the case of the appliances, I always wanted to draw a bitmap. The bitmap sometimes changed when the appliance changed state, but in essence, I wanted to be able to say, "This is my bitmap. Draw it." So I could perhaps create a bitmap object (a COM object, that is) that supports the <b>IDrawing </b>interface, and the appliance could use one of these bitmap objects. But (and this is a big <i>but</i>) how will the appliance tell the bitmap object which bitmap to draw? Be careful here! You can't simply say, "Give it a pointer. . ." because we're now dealing with a COM object that can (in principal, at least) be in a different address space. Even if we say this bitmap object will always be in an InProc server, and so the addressing problem is moot, we still don't have a way to tell the bitmap object which bitmap to load. We could always define yet another interface—<b>IBitmap</b> perhaps—that has a <b>Load</b> function. Then the appliance object can create a bitmap object, call its <b>IBitmap::Load</b> function to load the image, and via object aggregation, export the bitmap's <b>IDrawing </b>interface to the outside world.</p>
<p>
Does all this sound a bit complex to you? Does this seem like we're adding a thousand lines of code to save five? Well, it does to me, too, so no point going on with the discussion. It's time to do a little creative programming and see what all this boils down to in practice. The goals are (1) to create a bitmap object that supports <b>IDrawing</b>, (2) to use that in each of the appliances, and (3) to create a notification list object that is used by any object that can change state and might want to tell its user about that fact. We'll start with the notification list object.</p>
<h2>The NotifySrcList Object</h2>
<p>
Figure 2 shows the <b>NotifySrcList</b> object and its interfaces.</p>
<p>
<img src="house4_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The NotifySrcList object</b></p>
<p>
In moving the <b>INotifySrc</b> interface into this object, I decided to rename the interface functions so that they made a bit more sense. I also added a new member, <b>NotifyAll</b>. Here's the new interface definition:</p>
<pre><code>// {A7B3F570-4E8D-11ce-9EED-00AA004231BF}
DEFINE_GUID(IID_INotifySrc, 
0xa7b3f570, 0x4e8d, 0x11ce, 0x9e, 0xed, 0x0, 0xaa, 0x0, 0x42, 0x31, 0xbf);

class INotifySrc : public IUnknown
{
public:
 &nbsp;&nbsp; // Standard IUnknown interface functions
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID* ppvObj) = 0;
 &nbsp;&nbsp; virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
 &nbsp;&nbsp; virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

 &nbsp;&nbsp; // This interface
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE AddUser(INotify* pNotify,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID pUserInfo) = 0;
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE RemoveUser(INotify* pNotify) = 0;
 &nbsp;&nbsp; virtual HRESULT STDMETHODCALLTYPE NotifyAll(void) = 0;
};
</code></pre>
<p>
The members we're primarily interested in are <b>AddUser</b>, <b>RemoveUser</b>, and <b>NotifyAll</b>. The <b>NotifyAll</b> member walks the list and calls each entry to notify it of some change that has occurred. Let's go through the process of creating this new object step by step and then see how it's put to use.</p>
<p>
Use ClassWizard to create a new class derived from <b>CCmdTarget</b>. (Don't forget to check the OLE Automation and OLE Creatable boxes.) Add the interface map declaration, the interface definition, and any member variables to the header file. We also need to define a simple class to hold the user information:</p>
<pre><code>class CNotifyListObject : public CCmdTarget
{
 &nbsp; [...]
 &nbsp;&nbsp; // Declare the interface map for this object.
 &nbsp;&nbsp; DECLARE_INTERFACE_MAP()

 &nbsp;&nbsp; BEGIN_INTERFACE_PART(NotifySrc, INotifySrc)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(AddUser)(INotify* pNotify, LPVOID pUserInfo);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(RemoveUser)(INotify* pNotify);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(NotifyAll)();
 &nbsp;&nbsp; END_INTERFACE_PART(NotifySrc)

 &nbsp;&nbsp; CObList m_NotifyList;
};

// Notification info class
class CUserInfo
{
public:
 &nbsp;&nbsp; INotify* pNotify;
 &nbsp;&nbsp; LPVOID pUserInfo;
};
</code></pre>
<p>
In the implementation file, we add the interface map:</p>
<pre><code>BEGIN_INTERFACE_MAP(CNotifyListObject, CCmdTarget)
 &nbsp;&nbsp; INTERFACE_PART(CNotifyListObject, IID_INotifySrc, NotifySrc)
END_INTERFACE_MAP()
</code></pre>
<p>
In the constructor, we add a call to <b>EnableAggregation()</b> to (yes, you guessed it) enable object aggregation:</p>
<pre><code>CNotifyListObject::CNotifyListObject()
{
 &nbsp; EnableAutomation();

 &nbsp;&nbsp; // Make this object aggregatable.
 &nbsp;&nbsp; EnableAggregation();
 &nbsp; 
 &nbsp; // To keep the application running as long as an OLE automation 
 &nbsp; // object is active, the constructor calls AfxOleLockApp.
 &nbsp; 
 &nbsp; AfxOleLockApp();
}
</code></pre>
<p>
By default, MFC's <b>IUnknown</b> implementation in <b>CCmdTarget</b> doesn't support object aggregation because there's a small amount of overhead required on every call to <b>QueryInterface</b> for aggregated objects.</p>
<p>
When we are finished with this object, we need to be sure we release any interface pointers we might be hanging on to in our list. So a small piece of code is added to <b>OnFinalRelease</b>:</p>
<pre><code>void CNotifyListObject::OnFinalRelease()
{
 &nbsp;&nbsp; // Make sure the notification list has all its entries removed.
 &nbsp;&nbsp; while (!m_NotifyList.IsEmpty()) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUserInfo* pInfo = (CUserInfo*)m_NotifyList.RemoveHead();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(pInfo);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pInfo-&gt;pNotify-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete pInfo;
 &nbsp;&nbsp; }
 &nbsp; delete this;
}
</code></pre>
<p>
Now we simply need to implement the <b>INotifySrc</b> functions. This is pretty trivial stuff, but for once, I'll include all the code here:</p>
<pre><code>/////////////////////////////////////////////////////////
// INotifySrc interface

// IUnknown for INotifySrc
 &nbsp;&nbsp; IMPLEMENT_IUNKNOWN(CNotifyListObject, NotifySrc)

// INotifySrc methods
STDMETHODIMP CNotifyListObject::XNotifySrc::AddUser(INotify* pNotify,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID pUserInfo)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CNotifyListObject, NotifySrc);
 &nbsp;&nbsp; if (!pNotify) return E_INVALIDARG;

 &nbsp;&nbsp; // Save the user's INotify interface and info.
 &nbsp;&nbsp; pNotify-&gt;AddRef();
 &nbsp;&nbsp; CUserInfo* pInfo = new CUserInfo;
 &nbsp;&nbsp; ASSERT(pInfo);
 &nbsp;&nbsp; pInfo-&gt;pNotify = pNotify;
 &nbsp;&nbsp; pInfo-&gt;pUserInfo = pUserInfo;
 &nbsp;&nbsp; pThis-&gt;m_NotifyList.AddTail((CObject*)pInfo);

 &nbsp;&nbsp; return NOERROR;
}

STDMETHODIMP CNotifyListObject::XNotifySrc::RemoveUser(INotify* pNotify)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CNotifyListObject, NotifySrc);
 &nbsp;&nbsp; if (!pNotify) return E_INVALIDARG;

 &nbsp;&nbsp; // Find this one in the list.
 &nbsp;&nbsp; POSITION pos = pThis-&gt;m_NotifyList.GetHeadPosition();
 &nbsp;&nbsp; POSITION pfnd = NULL;
 &nbsp;&nbsp; CUserInfo* pInfo = NULL;
 &nbsp;&nbsp; while (pos) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfnd = pos;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pInfo = (CUserInfo*)pThis-&gt;m_NotifyList.GetNext(pos);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pInfo-&gt;pNotify == pNotify) break;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; if (!pfnd) return E_INVALIDARG; // Not found.

 &nbsp;&nbsp; // Remove it from the list and delete the info object.
 &nbsp;&nbsp; pThis-&gt;m_NotifyList.RemoveAt(pfnd);
 &nbsp;&nbsp; delete pInfo;

 &nbsp;&nbsp; // Say we're done with the user's interface now.
 &nbsp;&nbsp; pNotify-&gt;Release();

 &nbsp;&nbsp; return NOERROR;
}

STDMETHODIMP CNotifyListObject::XNotifySrc::NotifyAll()
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CNotifyListObject, NotifySrc);

 &nbsp;&nbsp; // Walk the notification list.
 &nbsp;&nbsp; POSITION pos = pThis-&gt;m_NotifyList.GetHeadPosition();
 &nbsp;&nbsp; while(pos) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUserInfo* pInfo = (CUserInfo*)pThis-&gt;m_NotifyList.GetNext(pos);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(pInfo &amp;&amp; pInfo-&gt;pNotify);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Report the change of state.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pInfo-&gt;pNotify-&gt;Change(pInfo-&gt;pUserInfo);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; return NOERROR;
}
</code></pre>
<p>
The only remaining things to do are add an entry in APPLIANCESID.H for the new object, modify the registry file for the new object, and run REGEDIT to install it. Now let's look at how the <b>NotifyListSrc</b> object can be used to replace the direct implementation of <b>INotifySrc</b> in the standard lamp object.</p>
<h3>Using the NotifyListSrc Object</h3>
<p>
To try out the <b>NotifyListSrc</b> object, I first edited the standard lamp files to remove all the implementation of <b>INotifySrc</b>. Having cleaned out the old, we can start to add the new. In the header file, we add some member variables and a declaration for <b>OnCreateAggregates</b>:</p>
<pre><code>class CStandardLamp : public CCmdTarget
{
 &nbsp; [...]
 &nbsp;&nbsp; // Notification list
 &nbsp;&nbsp; IUnknown* m_punkNotifyList;
 &nbsp;&nbsp; INotifySrc* m_pINotifySrc; // cached ptr 

 &nbsp;&nbsp; // Overrides for aggregation
 &nbsp;&nbsp; virtual BOOL OnCreateAggregates();

 &nbsp;&nbsp; // Helpers
 &nbsp;&nbsp; void NotifyChange();
};
</code></pre>
<p>
There are two interface pointers declared: <b>m_punkNotifyList</b>, which will point to the <b>IUnknown</b> interface on a <b>NotifyListSrc</b> object, and <b>m_pINotifySrc</b>, which will point to the object's <b>INotifySrc</b> interface. We don't <i>need</i> to have two pointers. We could live with just the <b>m_punkNotifyList</b> pointer and use <b>QueryInterface</b> to get the <b>INotifySrc</b> pointer every time we wanted it. However, we're likely to need the <b>INotifySrc</b> interface a lot, and calling <b>QueryInterface</b> frequently might slow things down. So we'll get an <b>INotifySrc</b> pointer and cache it here. <b>OnCreateAggregates</b> is a virtual function declared in <b>CCmdTarget</b>. <b>NotifyChange</b> is a local helper function.</p>
<p>
Let's look at the implementation code next. The first thing to do is make the pointers NULL in the constructor:</p>
<pre><code>CStandardLamp::CStandardLamp()
{
 &nbsp; [...]
 &nbsp;&nbsp; m_punkNotifyList = NULL;
 &nbsp;&nbsp; m_pINotifySrc = NULL;
 &nbsp; [...]
}
</code></pre>
<p>
Then we add the interface map entry, which will make use of the aggregated object:</p>
<pre><code>BEGIN_INTERFACE_MAP(CStandardLamp, CCmdTarget)
 &nbsp;&nbsp; INTERFACE_PART(CStandardLamp, IID_IDrawing, Drawing)
 &nbsp;&nbsp; INTERFACE_PART(CStandardLamp, IID_IOutlet, Outlet)
 &nbsp;&nbsp; INTERFACE_PART(CStandardLamp, IID_ILight, Light)
 &nbsp;&nbsp; INTERFACE_AGGREGATE(CStandardLamp, m_punkNotifyList)
END_INTERFACE_MAP()
</code></pre>
<p>
Note that we have replaced the direct implementation of <b>INotifySrc</b> with an aggregated version supplied by the object whose <b>IUnknown</b> interface pointer will be held in the <b>m_punkNotifyList</b> variable.</p>
<p>
We now add the <b>OnCreateAggregates</b> function:</p>
<pre><code>BOOL CStandardLamp::OnCreateAggregates()
{
 &nbsp;&nbsp; // Create the objects we want to aggregate.
 &nbsp;&nbsp; HRESULT hr = ::CoCreateInstance(CLSID_NotifyListObject,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetControllingUnknown(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IUnknown,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID*)&amp;m_punkNotifyList);
 &nbsp;&nbsp; if (FAILED(hr)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("Failed to create object. SCODE: %8.8lXH (%lu)\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetScode(hr),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetScode(hr) &amp; 0x0000FFFF);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_punkNotifyList = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; ASSERT(m_punkNotifyList);

 &nbsp;&nbsp; // Get a pointer to the object's INotifySrc interface,
 &nbsp;&nbsp; // so we won't have to get this every time we want to use it.
 &nbsp;&nbsp; if (m_punkNotifyList-&gt;QueryInterface(IID_INotifySrc, (LPVOID*)&amp;m_pINotifySrc) != S_OK) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("INotifySrc not supported");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; ASSERT(m_pINotifySrc);

 &nbsp;&nbsp; // When we got the INotifySrc pointer, this caused our main object
 &nbsp;&nbsp; // ref count to be incremented by one (because the notify src list
 &nbsp;&nbsp; // object is aggregated). We don't want this extra ref count, so
 &nbsp;&nbsp; // we manually remove it. (Yes, I know this doesn't look very kosher.)
 &nbsp;&nbsp; m_dwRef--;
 &nbsp;&nbsp; ASSERT(m_dwRef &gt; 0);

 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
This function creates an instance of the <b>NotifyListObject</b> object and saves its <b>IUnknown</b> pointer in <b>m_punkNotifyList</b> for use by the interface map. Then it goes on to obtain a pointer to the object's <b>INotifySrc</b> interface and saves it in <b>m_pINotifySrc</b>. This bit requires a bit of rather hacky code to implement correctly. Because the notify list object is aggregated into the standard lamp object, when I get a pointer to any one of the notify lists interfaces, the reference count of the standard lamp object is incremented <b>not</b> the reference count of the list object. Since any object that has a reference count on itself can never be deleted, we have to do something here to set the balance straight. What we do is simply decrement the standard lamp's reference count by one. This is straight out of the <i>OLE 2.0 Design Specification</i>, so be kind to me and send your comments to them.</p>
<p>
This is all that's needed for the standard lamp object to support <b>INotifySrc</b>. MFC's object aggregation support does everything else. The only other thing to do now is modify the standard lamp code to call the notify list object's <b>NotifyAll</b> member to report changes. I did this in two steps, using a helper function. Here's an example of where it's used:</p>
<pre><code>STDMETHODIMP CStandardLamp::XLight::SetBrightness(BYTE bLevel)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CStandardLamp, Light);
 &nbsp;&nbsp; pThis-&gt;m_bLevel = bLevel;
 &nbsp;&nbsp; pThis-&gt;NotifyChange();
 &nbsp;&nbsp; return NOERROR;
}
</code></pre>
<p>
And here's what the <b>NotifyChange</b> helper does:</p>
<pre><code>void CStandardLamp::NotifyChange()
{
 &nbsp;&nbsp; ASSERT(m_pINotifySrc);
 &nbsp;&nbsp; m_pINotifySrc-&gt;NotifyAll();
}
</code></pre>
<p>
I agree that you could probably just use <b>m_pINotifySrc-&gt;NotifyAll();</b> inline instead of calling this function, but I wanted to guarantee the <b>ASSERT</b> would be there every time. And finally, we need to tidy up when <b>OnFinalRelease</b> is called:</p>
<pre><code>void CStandardLamp::OnFinalRelease()
{
 &nbsp; m_dwRef++;
 &nbsp; ASSERT(m_pINotifySrc);
 &nbsp; m_dwRef++;
 &nbsp; m_pINotifySrc-&gt;Release();

 &nbsp; ASSERT(m_punkNotifyList);
 &nbsp; m_punkNotifyList-&gt;Release();

 &nbsp; delete this;
}
</code></pre>
<p>
This code releases the pointer we have on the list object interfaces. Because the <b>INotifySrc</b> pointer required us to do some direct modification of the lamp object reference count, we must be sure that we compensate for that here. So for every cached interface pointer we have created, we must increment the lamp object's reference count by one before releasing the interface pointer. Unfortunately, that's not quite all. We must <i>also</i> do an additional increment of the reference count to be sure that the destructor of the lamp object gets called only once. Again—go and read the <i>OLE 2.0 Design Specification</i> for a more detailed analysis of this problem.</p>
<p>
Now we have a standard lamp that supports <b>INotifySrc</b> through object aggregation. That was so much fun to do I thought we'd move right along and do it all again for <b>IDrawing</b> &lt;grin&gt;.</p>
<h2>Providing Support for IDrawing</h2>
<p>
Providing support for <b>IDrawing</b> in all the appliance objects through object aggregation is a little more tricky than it was to support <b>INotifySrc</b> because we're going to need to know <i>what</i> to draw. The object we'll create here is based on a bitmap (a device-independent bitmap actually) and has two interfaces. One interface allows us to set up the correct image; the other is the <b>IDrawing</b> interface.</p>
<p>
<img src="house4_3.gif" border=0></p>
<p class=label>
<b>Figure 3. The BitmapObject object</b></p>
<p>
I'll just warn you here that this isn't going to be the definitive bitmap object you've been looking for—it's a cheap and cheerful demo of an aggregatable object—that's all. Since so much of the way we'll build this object is the same as we did for the notify list object, I'm going to skip a lot of the code and just give you the "to do" list.</p>
<h3>Creating the BitmapObject Object</h3>
<p>
Here are the steps I took to create the <b>BitmapObject</b> object:
<ol>
<li>
Create a new interface definition for <b>IBitmap</b> in IBITMAP.H (with its own UUID).<br><br></li>
<li>
Add IBITMAP.H to GUIDS.CPP.<br><br></li>
<li>
Use ClassWizard to create a new class (<b>CBitmapObject</b>) from <b>CCmdTarget</b>.<br><br></li>
<li>
Edit the registry file to include the new object, and run the file through REGEDIT to register the new object.<br><br></li>
<li>
In the header file, add the interface map and interface definitions for <b>IBitmap</b> and <b>IDrawing</b>. Add local variables as required.<br><br></li>
<li>
In the CPP file, include any needed header, and add the interface map.<br><br></li>
<li>
In the constructor, add <b>EnableAggregation</b>.<br><br></li>
<li>
Implement the <b>IBitmap</b> and <b>IDrawing</b> interfaces.<br><br></li>
<li>
Add an entry in APPLIANCESID.H for <b>IBitmap</b>.</li>
</ol>
<p>
The results of this are in BITMAPOB.H and BITMAPOB.CPP.</p>
<h3>Using the BitmapObject Object to Provide IDrawing Support</h3>
<p>
I decided to demonstrate use of the <b>BitmapObject</b> object in the radio because it has the simplest implementation of <b>IDrawing</b>. I'm going to give you the list of steps here, and let you review the code later.
<ol>
<li>
In RADIO.H remove all references to <b>IDrawing</b> and the <b>m_pPal</b> and <b>m_dibImage</b> members.<br><br></li>
<li>
Add the definition for <b>OnCreateAggregates</b>.<br><br></li>
<li>
Add a member variable to point to the <b>IUnknown</b> interface of the bitmap object.<br><br></li>
<li>
In the .CPP file, remove all the old implementation of <b>IDrawing</b>.<br><br></li>
<li>
In the constructor, set the bitmap object pointer to NULL. <br><br></li>
<li>
Add the <b>INTERFACE_AGGREGATE</b> map entry. <br><br></li>
<li>
Add the <b>OnCreateAggregates</b> function and create the bitmap object. Use an <b>IBitmap</b> pointer to actually load the bitmap image.<br><br></li>
<li>
In <b>OnFinalRelease</b>, release the bitmap object interface.</li>
</ol>
<p>
Having done all of that, the radio now should draw itself exactly as it did before, but now it doesn't have to implement the <b>IDrawing</b> code itself.</p>
<h2>Summary</h2>
<p>
Using object aggregation can help you reuse one piece of code in multiple COM objects that require a common interface. If you have time, perhaps you'd like to modify the rest of the appliances in the sample to use the bitmap object and support the <b>INotifySrc</b> interface, too.</p>
</BODY>
</HTML>
