<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ODBC Driver Writer's Kit for Microsoft Access</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_odk"></a>ODBC Driver Writer's Kit for Microsoft Access</h1>
<p>
Microsoft Corporation</p>
<h2>ODBC API Calls Made by Microsoft Access</h2>
<h3>Description</h3>
<p>
This section contains a list of all of the open database connectivity (ODBC) application programming interface (API) calls used by Microsoft® Access®. Included with each API is a list of parameters that are passed to that API.</p>
<h3>Access Use of ODBC</h3>
<p>
Unless otherwise noted, functions may be called in <i>any</i> valid manner, and parameters may be any value, including NULL, 0, -1, and so on.</p>
<p>
<b>SQLAllocConnect</b></p>
<p>
<b>SQLAllocEnv</b></p>
<p>
<b>SQLAllocStmt</b></p>
<p>
<b>SQLCancel</b></p>
<p>
<b>SQLColumns</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=43%>TableQualifier</td>
<td width=57%>always NULL</td>
</tr>
<tr valign=top>
<td width=43%>TableOwner</td>
<td width=57%>always specified</td>
</tr>
<tr valign=top>
<td width=43%>TableName</td>
<td width=57%>always specified</td>
</tr>
<tr valign=top>
<td width=43%>ColumnName</td>
<td width=57%>always NULL</td>
</tr>
</table><br>
<p>
Result set columns needed:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=27%>2</td>
<td width=73%>(owner name)</td>
</tr>
<tr valign=top>
<td width=27%>3</td>
<td width=73%>(table name)</td>
</tr>
<tr valign=top>
<td width=27%>4</td>
<td width=73%>(column name)</td>
</tr>
<tr valign=top>
<td width=27%>5</td>
<td width=73%>(data type)</td>
</tr>
<tr valign=top>
<td width=27%>7</td>
<td width=73%>(precision)</td>
</tr>
<tr valign=top>
<td width=27%>9</td>
<td width=73%>(scale)</td>
</tr>
<tr valign=top>
<td width=27%>11</td>
<td width=73%>(nullable)</td>
</tr>
</table><br>
<p>
<b>SQLDescribeCol</b></p>
<p>
<b>SQLDisconnect</b></p>
<p>
<b>SQLDriverConnect</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=36%>szConnStrIn</td>
<td width=64%>may be complete, partial, or empty</td>
</tr>
<tr valign=top>
<td width=36%>szConnStrOut</td>
<td width=64%>not always specified</td>
</tr>
<tr valign=top>
<td width=36%>cbConnStrOutMax</td>
<td width=64%>not always specified</td>
</tr>
<tr valign=top>
<td width=36%>pcbConnStrOut</td>
<td width=64%>always NULL</td>
</tr>
</table><br>
<p class=indent>
fDriverCompletion</p>
<p class=indent>
SQL_DRIVER_NOPROMPT</p>
<p class=indent>
SQL_DRIVER_COMPLETE</p>
<p class=indent>
SQL_DRIVER_COMPLETE_REQUIRED</p>
<p>
<b>SQLError</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=49%>hstmt</td>
<td width=51%>sometimes 0</td>
</tr>
<tr valign=top>
<td width=49%>szSqlState</td>
<td width=51%>always specified</td>
</tr>
<tr valign=top>
<td width=49%>pfNativeError</td>
<td width=51%>always specified</td>
</tr>
<tr valign=top>
<td width=49%>szErrorMsg</td>
<td width=51%>always specified</td>
</tr>
<tr valign=top>
<td width=49%>cbErrorMsgMax</td>
<td width=51%>always specified</td>
</tr>
<tr valign=top>
<td width=49%>pcbErrorMsg</td>
<td width=51%>always specified</td>
</tr>
</table><br>
<p>
<b>SQLExecDirect</b></p>
<p>
<b>SQLExecute</b></p>
<p>
<b>SQLFetch</b></p>
<p>
<b>SQLFreeConnect</b></p>
<p>
<b>SQLFreeEnv</b></p>
<p>
<b>SQLFreeStmt</b></p>
<p class=indent>
fOption</p>
<p class=indent>
SQL_CLOSE</p>
<p class=indent>
SQL_DROP</p>
<p>
<b>SQLGetData</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=15%>fCType</td>
<td width=85%>For catalog functions, always SQL_C_DEFAULT. Otherwise, fCType can be any value, including SQL_C_DEFAULT. If "Driver not capable" is returned, SQL_C_CHAR is used instead.</td>
</tr>
</table><br>
<p>
<b>SQLGetInfo</b></p>
<p class=indent>
fInfoType</p>
<p class=indent>
SQL_ACTIVE_STATEMENTS</p>
<p class=indent>
SQL_ODBC_API_CONFORMANCE (must be &gt;= 1)</p>
<p class=indent>
SQL_DBMS_NAME</p>
<p class=indent>
SQL_DBMS_VER</p>
<p class=indent>
SQL_STRING_FUNCTIONS</p>
<p class=indent>
SQL_NUMERIC_FUNCTIONS</p>
<p class=indent>
SQL_TIMEDATE_FUNCTIONS</p>
<p class=indent>
SQL_SYSTEM_FUNCTIONS</p>
<p class=indent>
SQL_OUTER_JOINS</p>
<p class=indent>
SQL_EXPRESSIONS_IN_ORDERBY</p>
<p class=indent>
SQL_CONCAT_NULL_BEHAVIOR</p>
<p class=indent>
SQL_DATA_SOURCE_READ_ONLY</p>
<p class=indent>
SQL_TXN_CAPABLE</p>
<p class=indent>
SQL_CURSOR_COMMIT_BEHAVIOR</p>
<p class=indent>
SQL_CURSOR_ROLLBACK_BEHAVIOR</p>
<p class=indent>
SQL_IDENTIFIER_QUOTE_CHAR (expecting 1 char)</p>
<p>
<b>SQLGetTypeInfo</b></p>
<p class=indent>
fSqlType</p>
<p class=indent>
SQL_CHAR</p>
<p class=indent>
SQL_VARCHAR</p>
<p class=indent>
SQL_LONGVARCHAR</p>
<p class=indent>
SQL_ALL_TYPES</p>
<p class=indent>
Result set columns needed:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=26%>1</td>
<td width=74%>(type name)</td>
</tr>
<tr valign=top>
<td width=26%>2</td>
<td width=74%>(data type)</td>
</tr>
<tr valign=top>
<td width=26%>3</td>
<td width=74%>(precision)</td>
</tr>
<tr valign=top>
<td width=26%>6</td>
<td width=74%>(create params)</td>
</tr>
<tr valign=top>
<td width=26%>9</td>
<td width=74%>(searchable)</td>
</tr>
</table><br>
<p>
<b>SQLNumResultCols</b></p>
<p>
<b>SQLParamData</b></p>
<p>
<b>SQLPrepare</b></p>
<p>
<b>SQLPutData</b></p>
<p>
<b>SQLRowCount</b></p>
<p>
<b>SQLSetConnectOption</b></p>
<p class=indent>
fOption</p>
<p class=indent>
SQL_AUTOCOMMIT</p>
<p class=indent>
SQL_OPT_TRACEFILE</p>
<p class=indent>
SQL_OPT_TRACE</p>
<p class=indent>
SQL_LOGIN_TIMEOUT</p>
<p>
<b>SQLSetParam</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=15%>fCType</td>
<td width=85%>any value, including SQL_C_DEFAULT</td>
</tr>
<tr valign=top>
<td width=15%>fSqlType</td>
<td width=85%>any value (generally whatever SQLColumns returned)<br>
NOTE: fCType-to-fSqlType will be "reasonable".</td>
</tr>
<tr valign=top>
<td width=15%>cbColDef</td>
<td width=85%>max bytes in column (precision), or length of long value (if cbValue == SQL_DATA_AT_EXEC), or SQL_NULL_DATA</td>
</tr>
<tr valign=top>
<td width=15%>ibScale</td>
<td width=85%>Generally whatever SQLColumns returned</td>
</tr>
<tr valign=top>
<td width=15%>rgbValue</td>
<td width=85%>pointer to data buffer, or pointer to client's private data structure (for SQLParamData)</td>
</tr>
<tr valign=top>
<td width=15%>cbValue</td>
<td width=85%>length of data buffer, or SQL_NULL_DATA, or SQL_DATA_AT_EXEC (cbColDef == total length of long value)</td>
</tr>
</table><br>
<p>
<b>SQLSetStmtOption</b></p>
<p class=indent>
fOption</p>
<p class=indent>
SQL_QUERY_TIMEOUT (need not succeed)</p>
<p class=indent>
SQL_MAX_LENGTH</p>
<p class=indent>
SQL_ASYNC_ENABLE (need not succeed)</p>
<p>
<b>SQLSpecialColumns</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=30%>fColType</td>
<td width=70%>always SQL_ROWVER</td>
</tr>
<tr valign=top>
<td width=30%>TableQualifier</td>
<td width=70%>always NULL</td>
</tr>
<tr valign=top>
<td width=30%>TableOwner</td>
<td width=70%>always specified</td>
</tr>
<tr valign=top>
<td width=30%>TableName</td>
<td width=70%>always specified</td>
</tr>
<tr valign=top>
<td width=30%>fScope</td>
<td width=70%>always SQL_SCOPE_TRANSACTION</td>
</tr>
<tr valign=top>
<td width=30%>fNullable</td>
<td width=70%>always SQL_NULLABLE</td>
</tr>
</table><br>
<p class=indent>
Result set columns needed:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=30%>2</td>
<td width=70%>(column name)</td>
</tr>
</table><br>
<p>
<b>SQLStatistics</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=40%>TableQualifier</td>
<td width=60%>always NULL</td>
</tr>
<tr valign=top>
<td width=40%>TableOwner</td>
<td width=60%>always specified</td>
</tr>
<tr valign=top>
<td width=40%>TableName</td>
<td width=60%>always specified</td>
</tr>
<tr valign=top>
<td width=40%>fUnique</td>
<td width=60%>SQL_INDEX_ALL</td>
</tr>
<tr valign=top>
<td width=40%>fAccuracy</td>
<td width=60%>SQL_ENSURE</td>
</tr>
</table><br>
<p class=indent>
Result set columns needed:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=17%>2</td>
<td width=83%>(owner name)</td>
</tr>
<tr valign=top>
<td width=17%>3</td>
<td width=83%>(table name)</td>
</tr>
<tr valign=top>
<td width=17%>4</td>
<td width=83%>(non unique)</td>
</tr>
<tr valign=top>
<td width=17%>5</td>
<td width=83%>(index qualifier)</td>
</tr>
<tr valign=top>
<td width=17%>6</td>
<td width=83%>(index name)</td>
</tr>
<tr valign=top>
<td width=17%>9</td>
<td width=83%>(column name)</td>
</tr>
<tr valign=top>
<td width=17%>10</td>
<td width=83%>(collation)</td>
</tr>
<tr valign=top>
<td width=17%>11</td>
<td width=83%>(cardinality)</td>
</tr>
<tr valign=top>
<td width=17%>12</td>
<td width=83%>(pages)</td>
</tr>
</table><br>
<p>
<b>SQLTables</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=47%>TableQualifier</td>
<td width=53%>always NULL</td>
</tr>
<tr valign=top>
<td width=47%>TableOwner</td>
<td width=53%>always NULL</td>
</tr>
<tr valign=top>
<td width=47%>TableName</td>
<td width=53%>not always specified</td>
</tr>
<tr valign=top>
<td width=47%>TableType</td>
<td width=53%>always NULL</td>
</tr>
</table><br>
<p class=indent>
Result set columns needed:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=22%>2</td>
<td width=78%>(table owner)</td>
</tr>
<tr valign=top>
<td width=22%>3</td>
<td width=78%>(table name)</td>
</tr>
<tr valign=top>
<td width=22%>4</td>
<td width=78%>(table type)</td>
</tr>
</table><br>
<p>
<b>SQLTransact</b></p>
<p class=indent>
fType</p>
<p class=indent>
SQL_COMMIT</p>
<p class=indent>
SQL_ROLLBACK</p>
<h2>ODBC SQL Grammar Used by Microsoft Access</h2>
<h3>Description</h3>
<p>
This section describes the elements of the ODBC SQL Grammar that are used by Microsoft Access. The ODBC SQL Grammar is described in full in Appendix C of the ODBC <i>Programmer's Reference</i>.</p>
<h3>ODBC SQL Grammar</h3>
<h4>Statements</h4>
<p>
CREATE TABLE base-table-name (name type, ...)</p>
<p>
DELETE FROM ... WHERE search-condition</p>
<p>
DROP TABLE</p>
<p>
INSERT INTO ... (...) VALUES (...)</p>
<p>
SELECT [DISTINCT] select-list</p>
<p class=indent>
FROM ...</p>
<p class=indent>
WHERE ...</p>
<p class=indent>
GROUP BY ...</p>
<p class=indent>
HAVING ...</p>
<p class=indent>
ORDER BY ...</p>
<p>
UPDATE ... SET ... WHERE search-condition</p>
<p>
That is, except for GROUP BY and HAVING, all statements are Minimum.</p>
<h4>Elements</h4>
<p>
Minimum</p>
<p class=indent>
all elements used</p>
<p>
Core (NOT USED)</p>
<p class=indent>
sub-query</p>
<p class=indent>
cursor-name</p>
<p class=indent>
exists-predicate</p>
<p class=indent>
index-name</p>
<p class=indent>
pattern-value ::= USER</p>
<p class=indent>
quantified-predicate</p>
<p class=indent>
query-specification</p>
<p class=indent>
referenced-columns</p>
<p class=indent>
referencing-columns</p>
<p class=indent>
table-name.*</p>
<p class=indent>
viewed-table-name</p>
<p>
Extended (NOT USED)</p>
<p class=indent>
binary-literal</p>
<p class=indent>
date-literal</p>
<p class=indent>
date-type</p>
<p class=indent>
ODBC-std-esc-initiator</p>
<p class=indent>
ODBC-std-esc-terminator</p>
<p class=indent>
procedure</p>
<p class=indent>
time-literal</p>
<p class=indent>
time-type</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;data-types and ODBC-esc-extensions (outer joins, and so on) are used only to the extent that the driver claims to support them. Exception: ODBC-date-time-extension is assumed to be supported.</p>
<h2>Microsoft Access/ODBC Datatype Mappings</h2>
<h3>Description</h3>
<p>
This section describes the mapping of datatypes between Microsoft Access and ODBC.</p>
<h3>How ODBC Datatypes Are Mapped to Access Types</h3>
<p>
When creating an attachment, Access calls <b>SQLColumns</b>(szRemoteTableName) to enumerate ODBC column information for each column in the remote table.</p>
<p>
For each column, it returns:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=33%>fSqlType</td>
<td width=67%>ODBC data type</td>
</tr>
<tr valign=top>
<td width=33%>lPrecision</td>
<td width=67%>ODBC precision of column</td>
</tr>
<tr valign=top>
<td width=33%>wScale</td>
<td width=67%>ODBC scale of column</td>
</tr>
</table><br>
<p>
Documentation for ODBC types and ODBC's idea of "precision" and "scale" is in Appendix D of the <i>ODBC Programmer's Reference</i>.</p>
<p>
Access maps [fSqlType,lPrecision,wScale] to an Access datatype. This is the datatype stored in the attached table definition, and it is what the user sees. The ODBC type information is saved, per column, and fed back into ODBC whenever Access "uses" the column (SELECTing, UPDATEing, INSERTing the column, and making parameters from queries by it).</p>
<p>
The type mapping is done as follows:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>ODBC Datatype</b></td>
<td class=label width=71%><b>Access Datatype</b></td>
</tr>
<tr valign=top>
<td width=29%>SQL_BIT</td>
<td width=71%>Yes/No</td>
</tr>
<tr valign=top>
<td width=29%>SQL_TINYINT<p>
SQL_SMALLINT</p>
</td>
<td width=71%>Number -- Size: Integer</td>
</tr>
<tr valign=top>
<td width=29%>SQL_INTEGER</td>
<td width=71%>Number -- Size: Long Integer</td>
</tr>
<tr valign=top>
<td width=29%>SQL_REAL</td>
<td width=71%>Number -- Size: Single</td>
</tr>
<tr valign=top>
<td width=29%>SQL_FLOAT<p>
SQL_DOUBLE</p>
</td>
<td width=71%>Number -- Size: Double</td>
</tr>
<tr valign=top>
<td width=29%>SQL_TIMESTAMP<p>
SQL_DATE</p>
<p>
SQL_TIME</p>
</td>
<td width=71%>DateTime</td>
</tr>
<tr valign=top>
<td width=29%>SQL_CHAR<p>
SQL_VARCHAR</p>
</td>
<td width=71%>if lPrecision &lt;= 255, then Text (Field Size = lPrecision)<p>
if lPrecision &gt;  255, then Memo</p>
</td>
</tr>
<tr valign=top>
<td width=29%>SQL_BINARY<p>
SQL_VARBINARY</p>
</td>
<td width=71%>if lPrecision &lt;= 255, then Binary (Field Size = lPrecision)<p>
if lPrecision &gt;  255, then OLE Object</p>
</td>
</tr>
<tr valign=top>
<td width=29%>SQL_LONGVARBINARY</td>
<td width=71%>OLE Object</td>
</tr>
<tr valign=top>
<td width=29%>SQL_LONGVARCHAR</td>
<td width=71%>Memo</td>
</tr>
<tr valign=top>
<td width=29%>SQL_DECIMAL<p>
SQL_NUMERIC</p>
</td>
<td width=71%>if SQL Server, then<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if lPrecision = 19, and wScale = 4, then Currency</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if lPrecision = 10, and wScale = 4, then Currency</p>
<p>
if wScale = 0, then</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if lPrecision &lt;= 4, then Number -- Size: Integer</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if lPrecision &lt;= 9, then Number -- Size: Long Integer</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if lPrecision &lt;= 15, then Number -- Size: Double</p>
<p>
if wScale &gt; 0, then</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if lPrecision &lt;= 15, then Number -- Size: Double</p>
</td>
</tr>
</table><br>
<p>
Anything not covered above is mapped to Text(Field Size==255).</p>
<h2>How Access Datatypes Are Mapped to ODBC Datatypes</h2>
<p>
When executing a "SELECT INTO" query with an ODBC destination (this includes File Export in Access), Access maps each source column type to a destination column type. A CREATE TABLE statement and multiple INSERT statements are sent to the server using these destination types. Access calls <b>SQLGetTypeInfo</b> to get ODBC type information for all datatypes supported by the back-end. A collection of internal data structures is built, describing the type information in an Access-digestible format. The type mapping is done as follows.</p>
<p>
(In the mapping below, replace SQL_SMALLINT with SQL_NUMERIC(5,0) if SQL_SMALLINT is not supported by the server. Replace SQL_INTEGER with SQL_NUMERIC(10,0) if SQL_INTEGER is not supported. Replace SQL_VARCHAR with SQL_CHAR if SQL_VARCHAR is not supported by the server. If SQL_CHAR is also not supported, the query fails.)</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Access Datatype</b></td>
<td class=label width=73%><b>ODBC Datatype</b></td>
</tr>
<tr valign=top>
<td width=27%>Yes/No</td>
<td width=73%>SQL_BIT, if supported, else<br>
SQL_SMALLINT, if supported, else<br>
SQL_INTEGER, if supported, else<br>
SQL_VARCHAR(5)</td>
</tr>
<tr valign=top>
<td width=27%>Number --Size: Byte<br>
 Number --Size:&nbsp; Integer</td>
<td width=73%>SQL_SMALLINT, if supported, else<br>
SQL_INTEGER, if supported, else<br>
SQL_VARCHAR(10)</td>
</tr>
<tr valign=top>
<td width=27%>Number --Size: Long Integer</td>
<td width=73%>SQL_INTEGER, if supported, else<br>
SQL_VARCHAR(20)</td>
</tr>
<tr valign=top>
<td width=27%>Currency</td>
<td width=73%>SQL_DECIMAL(19,4), if SQL Server, else<br>
SQL_FLOAT, if supported, else<br>
SQL_VARCHAR(30)</td>
</tr>
<tr valign=top>
<td width=27%>Number --Size: Single</td>
<td width=73%>SQL_REAL, if supported, else<br>
SQL_FLOAT, if supported, else<br>
SQL_VARCHAR(30)</td>
</tr>
<tr valign=top>
<td width=27%>Number --Size: Double</td>
<td width=73%>SQL_FLOAT, if supported, else<br>
SQL_VARCHAR(40)</td>
</tr>
<tr valign=top>
<td width=27%>DateTime</td>
<td width=73%>SQL_TIMESTAMP, if supported, else<br>
SQL_VARCHAR(40)</td>
</tr>
<tr valign=top>
<td width=27%>Text(Field Size)</td>
<td width=73%>SQL_VARCHAR(MIN(Field Size,ServerMax))</td>
</tr>
<tr valign=top>
<td width=27%>Binary(Field Size)</td>
<td width=73%>SQL_VARBINARY(MIN(Field Size,ServerMax)), if supported, else<br>
query fails</td>
</tr>
<tr valign=top>
<td width=27%>Memo</td>
<td width=73%>SQL_LONGVARCHAR(ServerMax), if supported, else<br>
SQL_VARCHAR(ServerMax), if ServerMax &gt;= 2000, else<br>
query fails</td>
</tr>
<tr valign=top>
<td width=27%>OLE Object</td>
<td width=73%>SQL_LONGVARBINARY(ServerMax), if supported, else<br>
SQL_VARBINARY(ServerMax), if ServerMax &gt;= 2000, else<br>
query fails</td>
</tr>
</table><br>
<h2>Microsoft Access Initialization File (MSACCESS.INI) Settings for ODBC</h2>
<h3>Description</h3>
<p>
This section contains a table of all of the valid entries that can appear in the Microsoft Access Initialization File, MSACCESS.INI.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=10%><b>Section</b></td>
<td class=label width=24%><b>Entry</b></td>
<td class=label width=10%><b>Value</b></td>
<td class=label width=56%><b>Effect</b></td>
</tr>
<tr valign=top>
<td width=10%>Debug</td>
<td width=24%>RmtTrace</td>
<td width=10%>0</td>
<td width=56%>Use asynchronous query execution if possible; no ODBC API tracing (default)</td>
</tr>
<tr valign=top>
<td width=10%></td>
<td width=24%></td>
<td width=10%>8</td>
<td width=56%>Trace ODBC API calls into "odbcapi.txt" in Access directory</td>
</tr>
<tr valign=top>
<td width=10%></td>
<td width=24%></td>
<td width=10%>16</td>
<td width=56%>Force synchronous query execution</td>
</tr>
<tr valign=top>
<td width=10%></td>
<td width=24%></td>
<td width=10%>24</td>
<td width=56%>Trace ODBC API calls; force asynchronous query execution</td>
</tr>
<tr valign=top>
<td width=10%>ODBC</td>
<td width=24%>TraceSQLMode</td>
<td width=10%>0</td>
<td width=56%>No tracing (default)</td>
</tr>
<tr valign=top>
<td width=10%></td>
<td width=24%></td>
<td width=10%>1</td>
<td width=56%>Trace SQL sent to ODBC into "sqlout.txt" in Access directory</td>
</tr>
<tr valign=top>
<td width=10%>ODBC</td>
<td width=24%>QueryTimeout</td>
<td width=10%>S</td>
<td width=56%>S sec, works async (default:60)</td>
</tr>
<tr valign=top>
<td width=10%>ODBC</td>
<td width=24%>LoginTimeout</td>
<td width=10%>S</td>
<td width=56%>S sec (default:20)</td>
</tr>
<tr valign=top>
<td width=10%>ODBC</td>
<td width=24%>ConnectionTimeout</td>
<td width=10%>S</td>
<td width=56%>S sec, kill idle connections (default:600)</td>
</tr>
<tr valign=top>
<td width=10%>ODBC</td>
<td width=24%>AsyncRetryInterval</td>
<td width=10%>M</td>
<td width=56%>M millisecs, between async retries (default:500)</td>
</tr>
<tr valign=top>
<td width=10%>ODBC</td>
<td width=24%>AttachCaseSensitive</td>
<td width=10%>0</td>
<td width=56%>Attach to first name matching specified string</td>
</tr>
<tr valign=top>
<td width=10%></td>
<td width=24%></td>
<td width=10%>1</td>
<td width=56%>Attach only to name exactly matching specified string</td>
</tr>
<tr valign=top>
<td width=10%>ODBC</td>
<td width=24%>AttachableObjects</td>
<td width=10%>string</td>
<td width=56%>List of object types to allow attaching (default:'TABLE','VIEW','SYSTEM TABLE', 'ALIAS','SYNONYM')</td>
</tr>
<tr valign=top>
<td width=10%>ODBC</td>
<td width=24%>SnapshotOnly</td>
<td width=10%>0</td>
<td width=56%>Get index information on attach, to allow Dynasets (default)</td>
</tr>
<tr valign=top>
<td width=10%></td>
<td width=24%></td>
<td width=10%>1</td>
<td width=56%>Ignore index information on attach, forces snapshots</td>
</tr>
</table><br>
<h2>Microsoft Access ODBC Spec-Compliance Error Codes</h2>
<h3>Description</h3>
<p>
This section contains a table of errors that will be returned when Access determines that a driver has failed to comply with the ODBC specification. The table contains an error number that will be returned by Access. Following the error number are two pieces of information:
<ul type=disc>
<li>
A description of the ODBC API call that was made, including any parameter values<br><br></li>
<li>
A description of the condition that caused the error</li>
</ul>
<h3>ODBC Spec-Compliance Errors</h3>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=8%><b>Error</b></td>
<td class=label width=57%><b>ODBC Call</b></td>
<td class=label width=35%><b>Condition causing the error</b></td>
</tr>
<tr valign=top>
<td width=8%>-7701</td>
<td width=57%>SQLGetInfo(ODBC_API_CONFORMANCE) </td>
<td width=35%>*pcbInfoValue != 2</td>
</tr>
<tr valign=top>
<td width=8%>-7702</td>
<td width=57%>SQLGetInfo(ODBC_API_CONFORMANCE)</td>
<td width=35%>wValue &lt; 1</td>
</tr>
<tr valign=top>
<td width=8%>-7703</td>
<td width=57%>SQLGetData(fCType=SQL_C_CHAR)</td>
<td width=35%>Call return "driver could not convert"</td>
</tr>
<tr valign=top>
<td width=8%>-7704</td>
<td width=57%>SQLGetTypeInfo(SQL_ALL_TYPES)</td>
<td width=35%>neither SQL_CHAR nor SQL_VARCHAR was returned; type support is insufficient</td>
</tr>
<tr valign=top>
<td width=8%>-7705</td>
<td width=57%>SQLGetTypeInfo ==&gt; SQLNumResultCols</td>
<td width=35%>*pccol &lt; 6</td>
</tr>
<tr valign=top>
<td width=8%>-7706</td>
<td width=57%>SQLGetTypeInfo ==&gt; SQLGetData(TYPE_NAME) </td>
<td width=35%>*pcbValue &lt;= 0</td>
</tr>
<tr valign=top>
<td width=8%>-7707</td>
<td width=57%>SQLGetTypeInfo ==&gt; SQLGetData(DATA_TYPE)</td>
<td width=35%>*pcbValue != 2</td>
</tr>
<tr valign=top>
<td width=8%>-7708</td>
<td width=57%>SQLGetTypeInfo ==&gt; SQLGetData(PRECISION)</td>
<td width=35%>*pcbValue != 0 or *pcbValue != 4</td>
</tr>
<tr valign=top>
<td width=8%>-7709</td>
<td width=57%></td>
<td width=35%>odbc.dll missing API function (possibly bad odbc.dll)</td>
</tr>
<tr valign=top>
<td width=8%>-7710</td>
<td width=57%>SQLSetParam(fSQLType=SQL_VARCHAR)</td>
<td width=35%>driver could not convert</td>
</tr>
<tr valign=top>
<td width=8%>-7711</td>
<td width=57%>SQLError</td>
<td width=35%>An error was returned by an ODBC call, but no error string was returned</td>
</tr>
<tr valign=top>
<td width=8%>-7712</td>
<td width=57%></td>
<td width=35%>primary key &gt; 255 bytes</td>
</tr>
<tr valign=top>
<td width=8%>-7713</td>
<td width=57%></td>
<td width=35%>SQL_INVALID_HANDLE returned by ODBC API; i.e., driver claims henv/hdbc/hstmt is invalid</td>
</tr>
<tr valign=top>
<td width=8%>-7714</td>
<td width=57%>SQLGetTypeInfo ==&gt; SQLNumResultCols</td>
<td width=35%>*pccol &lt; 9</td>
</tr>
<tr valign=top>
<td width=8%>-7715</td>
<td width=57%>SQLTables ==&gt; SQLGetData(TABLE_OWNER/TABLE_NAME) </td>
<td width=35%>length(ownername.tablename) &gt; 255 bytes</td>
</tr>
<tr valign=top>
<td width=8%>-7716</td>
<td width=57%>SQLTables ==&gt; SQLGetData(TABLE_NAME) </td>
<td width=35%>*pcbValue &lt;= 0</td>
</tr>
<tr valign=top>
<td width=8%>-7717</td>
<td width=57%>SQLTables ==&gt; SQLGetData(TABLE_TYPE) </td>
<td width=35%>*pcbValue &lt;= 0</td>
</tr>
<tr valign=top>
<td width=8%>-7718</td>
<td width=57%>SQLTables ==&gt; SQLGetData(TABLE_TYPE)</td>
<td width=35%>*pcbValue &gt; 128</td>
</tr>
<tr valign=top>
<td width=8%>-7719</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(COLUMN_NAME)</td>
<td width=35%>total length of columns for index &gt; 255 bytes</td>
</tr>
<tr valign=top>
<td width=8%>-7720</td>
<td width=57%>SQLGetInfo(SQL_CURSOR_COMMIT_BEHAVIOR)</td>
<td width=35%>*pcbInfoValue != 2</td>
</tr>
<tr valign=top>
<td width=8%>-7721</td>
<td width=57%>SQLGetInfo(SQL_CURSOR_ROLLBACK_<br>
BEHAVIOR)</td>
<td width=35%>*pcbInfoValue != 2</td>
</tr>
<tr valign=top>
<td width=8%>-7722</td>
<td width=57%>SQLTables ==&gt; SQLNumResultCols</td>
<td width=35%>*pccol &lt; 4</td>
</tr>
<tr valign=top>
<td width=8%>-7723</td>
<td width=57%>SQLSpecialColumns ==&gt; SQLNumResultCols</td>
<td width=35%>*pccol &lt; 2</td>
</tr>
<tr valign=top>
<td width=8%>-7724</td>
<td width=57%>SQLSpecialColumns ==&gt; SQLGetData(COLUMN_NAME)</td>
<td width=35%>*pcbValue &lt;= 0</td>
</tr>
<tr valign=top>
<td width=8%>-7725</td>
<td width=57%>SQLGetTypeInfo ==&gt; SQLGetData(SEARCHABLE)</td>
<td width=35%>*pcbValue != 2</td>
</tr>
<tr valign=top>
<td width=8%>-7726</td>
<td width=57%>SQLGetTypeInfo ==&gt; SQLGetData(SEARCHABLE) </td>
<td width=35%>value out of range</td>
</tr>
<tr valign=top>
<td width=8%>-7727</td>
<td width=57%>SQLColumns ==&gt; SQLNumResultCols </td>
<td width=35%>*pccol &lt; 11</td>
</tr>
<tr valign=top>
<td width=8%>-7728</td>
<td width=57%>SQLColumns ==&gt; SQLGetData(TABLE_OWNER)</td>
<td width=35%>*pcbValue &lt; 0</td>
</tr>
<tr valign=top>
<td width=8%>-7729</td>
<td width=57%>SQLColumns ==&gt; SQLGetData(TABLE_NAME)</td>
<td width=35%>*pcbValue &lt;= 0</td>
</tr>
<tr valign=top>
<td width=8%>-7730</td>
<td width=57%>SQLColumns ==&gt; SQLGetData(COLUMN_NAME)</td>
<td width=35%>*pcbValue &lt;= 0</td>
</tr>
<tr valign=top>
<td width=8%>-7731</td>
<td width=57%>SQLColumns ==&gt; SQLGetData(DATA_TYPE)</td>
<td width=35%>*pcbValue != 2</td>
</tr>
<tr valign=top>
<td width=8%>-7732</td>
<td width=57%>SQLColumns ==&gt; SQLGetData(PRECISION)</td>
<td width=35%>*pcbValue != 0 or 4</td>
</tr>
<tr valign=top>
<td width=8%>-7733</td>
<td width=57%>SQLColumns ==&gt; SQLGetData(SCALE)</td>
<td width=35%>*pcbValue != 0 or 2</td>
</tr>
<tr valign=top>
<td width=8%>-7734</td>
<td width=57%>SQLColumns ==&gt; SQLGetData(NULLABLE)</td>
<td width=35%>*pcbValue != 0 or 2</td>
</tr>
<tr valign=top>
<td width=8%>-7735</td>
<td width=57%>SQLColumns ==&gt; SQLGetData(NULLABLE)</td>
<td width=35%>value out of range</td>
</tr>
<tr valign=top>
<td width=8%>-7736</td>
<td width=57%>SQLStatistics ==&gt; SQLNumResultCols</td>
<td width=35%>*pccol &lt; 12</td>
</tr>
<tr valign=top>
<td width=8%>-7737</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(TABLE_OWNER)</td>
<td width=35%>*pcbValue &lt; 0</td>
</tr>
<tr valign=top>
<td width=8%>-7738</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(TABLE_NAME)</td>
<td width=35%>*pcbValue &lt;= 0</td>
</tr>
<tr valign=top>
<td width=8%>-7739</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(NON_UNIQUE)</td>
<td width=35%>*pcbValue != 2</td>
</tr>
<tr valign=top>
<td width=8%>-7740</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(INDEX_QUALIFIER)</td>
<td width=35%>*pcbValue &lt; 0</td>
</tr>
<tr valign=top>
<td width=8%>-7741</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(INDEX_QUALIFIER/INDEX_NAME)</td>
<td width=35%>length(qualifier.indexname) &gt; 255 bytes</td>
</tr>
<tr valign=top>
<td width=8%>-7742</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(INDEX_NAME)</td>
<td width=35%>*pcbValue &lt; 0</td>
</tr>
<tr valign=top>
<td width=8%>-7743</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(TYPE)</td>
<td width=35%>*pcbValue != 2</td>
</tr>
<tr valign=top>
<td width=8%>-7744</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(TYPE)</td>
<td width=35%>value out of range</td>
</tr>
<tr valign=top>
<td width=8%>-7745</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(TYPE/NON_UNIQUE/INDEX_NAME)</td>
<td width=35%>TYPE == SQL_TABLE_STAT, but either NON_UNIQUE or INDEX_NAME is non-NULL</td>
</tr>
<tr valign=top>
<td width=8%>-7746</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(TYPE/NON_UNIQUE/INDEX_NAME)</td>
<td width=35%>TYPE != SQL_TABLE_STAT, but either NON_UNIQUE or INDEX_NAME is NULL</td>
</tr>
<tr valign=top>
<td width=8%>-7747</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(COLUMN_NAME)</td>
<td width=35%>*pcbValue &lt;= 0</td>
</tr>
<tr valign=top>
<td width=8%>-7748</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(COLLATION)</td>
<td width=35%>*pcbValue != 0 or 1</td>
</tr>
<tr valign=top>
<td width=8%>-7749</td>
<td width=57%>SQLStatistics ==&gt; SQLGetData(COLLATION)</td>
<td width=35%>value not 'A' or 'D'</td>
</tr>
<tr valign=top>
<td width=8%>-7750</td>
<td width=57%>SQLGetInfo(SQL_TXN_CAPABLE)</td>
<td width=35%>*pcbInfoValue != 2</td>
</tr>
<tr valign=top>
<td width=8%>-7751</td>
<td width=57%>SQLGetInfo(SQL_TXN_CAPABLE)</td>
<td width=35%>value &lt; 0 or &gt; 2</td>
</tr>
<tr valign=top>
<td width=8%>-7752</td>
<td width=57%>SQLGetInfo(SQL_DATA_SOURCE_READ_ONLY)</td>
<td width=35%>*pcbInfoValue != 1</td>
</tr>
<tr valign=top>
<td width=8%>-7753</td>
<td width=57%>SQLGetInfo(SQL_DATA_SOURCE_READ_ONLY)</td>
<td width=35%>value not 'Y' or 'N'</td>
</tr>
<tr valign=top>
<td width=8%>-7754</td>
<td width=57%>SQLGetInfo(SQL_IDENTIFIER_QUOTE_CHAR)</td>
<td width=35%>*pcbInfoValue != 1</td>
</tr>
<tr valign=top>
<td width=8%>-7755</td>
<td width=57%>SQLGetInfo(SQL_IDENTIFIER_QUOTE_CHAR)</td>
<td width=35%>value '.' or alphanum</td>
</tr>
<tr valign=top>
<td width=8%>-7756</td>
<td width=57%>SQLGetInfo(SQL_STRING_FUNCTIONS)</td>
<td width=35%>*pcbInfoValue != 4</td>
</tr>
<tr valign=top>
<td width=8%>-7757</td>
<td width=57%>SQLGetInfo(SQL_NUMERIC_FUNCTIONS)</td>
<td width=35%>*pcbInfoValue != 4</td>
</tr>
<tr valign=top>
<td width=8%>-7758</td>
<td width=57%>SQLGetInfo(SQL_TIMEDATE_FUNCTIONS)</td>
<td width=35%>*pcbInfoValue != 4</td>
</tr>
<tr valign=top>
<td width=8%>-7759</td>
<td width=57%>SQLGetInfo(SQL_SYSTEM_FUNCTIONS)</td>
<td width=35%>*pcbInfoValue != 4</td>
</tr>
<tr valign=top>
<td width=8%>-7760</td>
<td width=57%>SQLGetInfo(SQL_OUTER_JOINS)</td>
<td width=35%>*pcbInfoValue != 1</td>
</tr>
<tr valign=top>
<td width=8%>-7761</td>
<td width=57%>SQLGetInfo(SQL_OUTER_JOINS)</td>
<td width=35%>value not 'Y' or 'N'</td>
</tr>
<tr valign=top>
<td width=8%>-7762</td>
<td width=57%>SQLGetInfo(SQL_EXPRESSIONS_IN_ORDERBY)</td>
<td width=35%>*pcbInfoValue != 1</td>
</tr>
<tr valign=top>
<td width=8%>-7763</td>
<td width=57%>SQLGetInfo(SQL_EXPRESSIONS_IN_ORDERBY)</td>
<td width=35%>value not 'Y' or 'N'</td>
</tr>
<tr valign=top>
<td width=8%>-7764</td>
<td width=57%>SQLGetInfo(SQL_CONCAT_NULL_BEHAVIOR)</td>
<td width=35%>*pcbInfoValue != 2</td>
</tr>
<tr valign=top>
<td width=8%>-7765</td>
<td width=57%>SQLGetInfo(SQL_CONCAT_NULL_BEHAVIOR)</td>
<td width=35%>value not 0 or 1</td>
</tr>
<tr valign=top>
<td width=8%>-7766</td>
<td width=57%>SQLGetData(SQL_C_BIT)</td>
<td width=35%>pcbValue != 1</td>
</tr>
<tr valign=top>
<td width=8%>-7767</td>
<td width=57%>SQLGetData(SQL_C_SHORT)</td>
<td width=35%>pcbValue != 2</td>
</tr>
<tr valign=top>
<td width=8%>-7768</td>
<td width=57%>SQLGetData(SQL_C_TIMESTAMP)</td>
<td width=35%>pcbValue != sizeof(TIMESTAMP_STRUCT)</td>
</tr>
</table><br>
<h2>General Caveats when Using ODBC Drivers with Microsoft Access</h2>
<h3>Description</h3>
<p>
This section describes general caveats to keep in mind when using ODBC drivers with Microsoft Access. It includes assumptions that Access makes regarding driver behavior as well as giving some specific implementation details of Access functionality.</p>
<h3>ODBC Driver Writer Caveats</h3>
<h4>Cursor commit behavior and transaction handling</h4>
<p>
Access calls SQLGetInfo for:</p>
<p class=indent>
SQL_ACTIVE_STATEMENTS</p>
<p class=indent>
SQL_TXN_CAPABLE</p>
<p class=indent>
SQL_CURSOR_COMMIT_BEHAVIOR</p>
<p class=indent>
SQL_CURSOR_ROLLBACK_BEHAVIOR</p>
<p>
If ACTIVE_STATEMENTS = = 1, then Access will spawn a new real connection whenever it needs to execute a query that will have pending results, that is, that will not immediately be <b>SQLFetch</b>ed to the end. If ACTIVE_STATEMENTS != 1, then Access will share existing connections, even for queries that have pending results. The positions of these cursors is assumed to be stable, even across transactions.</p>
<p>
If TXN_CAPABLE returns &gt;= 1, then Access will simulate wrapping a transaction around each INSERT/UPDATE/DELETE statement. 
<ul type=disc>
<li>
To simulate a BEGIN TRANSACTION, Access calls SQLSetConnectOption(AUTO_COMMIT, 0).<br><br></li>
<li>
To simulate a COMMIT TRANSACTION, Access calls SQLTransact(SQL_COMMIT) followed by SQLSetConnectOption(AUTO_COMMIT, 1).<br><br></li>
<li>
To simulate a ROLLBACK TRANSACTION, Access calls SQLTransact(SQL_ROLLBACK) followed by SQLSetConnectOption(AUTO_COMMIT, 1).</li>
</ul>
<p>
If TXN_CAPABLE returns 0, then Access will stay in AUTO_COMMIT mode permanently.</p>
<p>
Let CURSOR_BEHAVIOR be the minimum of CURSOR_COMMIT_BEHAVIOR and CURSOR_ROLLBACK_BEHAVIOR. If CURSOR_BEHAVIOR &lt; 1, then Access will pretend that the data source is READ_ONLY, and that transactions are not supported. If CURSOR_BEHAVIOR = = 1, and ACTIVE_STATEMENTS != 1, then Access will pretend that ACTIVE_STATEMENTS = = 1, in order to force a new connection for each pending-results-query. See comments on ACTIVE_STATMENTS.</p>
<h4>Identifier quoting</h4>
<p>
Access calls <b>SQLGetInfo</b> for:</p>
<p class=indent>
SQL_IDENTIFIER_QUOTE_CHAR</p>
<p>
If this is a blank, then identifier quoting is assumed unsupported. If it is not a blank, then this char is used to prefix and suffix <i>every </i>owner, table, and column reference in <i>every </i>query that Access sends to the driver.</p>
<h4>Identifying a unique index</h4>
<p>
When attaching an ODBC table, Access calls <b>SQLStatistics</b> to collect index information. The first unique index returned is marked as the "primary" index. Exception: Indexes on floating-point columns are not marked "primary." The determination of a column being a floating-point column is made <i>after </i>the ODBC type has been mapped to an Access type (see typemap.doc). Unless a "primary" index is found, the attached table will not be updatable.</p>
<h4>Sending LIKE to the ODBC driver</h4>
<p>
Access calls <b>SQLTypeInfo</b> to determine the "searchability" of SQL_CHAR, SQL_VARCHAR, and SQL_LONGVARCHAR. Unless the SEARCHABLE column of the result set is SQL_LIKE_ONLY or SQL_SEARCHABLE, Access will perform LIKE operations on such columns locally.</p>
<h4>Sending expressions to the ODBC driver</h4>
<p>
Access calls <b>SQLGetInfo</b> for:</p>
<p>
SQL_STRING_FUNCTIONS</p>
<p>
SQL_NUMERIC_FUNCTIONS</p>
<p>
SQL_TIMEDATE_FUNCTIONS</p>
<p>
SQL_SYSTEM_FUNCTIONS</p>
<p>
SQL_OUTER_JOINS</p>
<p>
SQL_EXPRESSIONS_IN_ORDERBY</p>
<p>
SQL_CONCAT_NULL_BEHAVIOR</p>
<p>
The values returned are used to determine how much of a query Access may safely send to the driver for execution, and how much must be performed locally by the Access engine.</p>
<h4>Datatype conversions</h4>
<p>
Access calls <b>SQLGetData</b> to retrieve result sets. The <i>fCType</i> parameter value is determined as follows: <b>SQLColumns</b> returns the ODBC type of each column in a table. <b>SQLDescribeCol</b> is also sometimes used. These are mapped to Access data types (see typemap.doc). These Access types are then mapped to <i>fCType</i> values.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=22%><b>Access Type</b></td>
<td class=label width=30%><b>ODBC fCType</b></td>
<td class=label width=48%><b>Type in Table Design</b></td>
</tr>
<tr valign=top>
<td width=22%>Bit</td>
<td width=30%>SQL_C_BIT</td>
<td width=48%>Yes/No</td>
</tr>
<tr valign=top>
<td width=22%>UByte</td>
<td width=30%>SQL_C_SHORT</td>
<td width=48%>Number, Field Size = Byte</td>
</tr>
<tr valign=top>
<td width=22%>Short</td>
<td width=30%>SQL_C_SHORT</td>
<td width=48%>Number, Field Size = Integer</td>
</tr>
<tr valign=top>
<td width=22%>Long</td>
<td width=30%>SQL_C_LONG</td>
<td width=48%>Number, Field Size = Long Integer</td>
</tr>
<tr valign=top>
<td width=22%>Currency</td>
<td width=30%>SQL_C_CHAR</td>
<td width=48%>Currency</td>
</tr>
<tr valign=top>
<td width=22%>Single</td>
<td width=30%>SQL_C_FLOAT</td>
<td width=48%>Number, Field Size = Single</td>
</tr>
<tr valign=top>
<td width=22%>Double</td>
<td width=30%>SQL_C_DOUBLE</td>
<td width=48%>Number, Field Size = Double</td>
</tr>
<tr valign=top>
<td width=22%>DateTime</td>
<td width=30%>SQL_C_TIMESTAMP</td>
<td width=48%>Date/Time</td>
</tr>
<tr valign=top>
<td width=22%>Binary</td>
<td width=30%>SQL_C_BINARY</td>
<td width=48%>&lt;none&gt;</td>
</tr>
<tr valign=top>
<td width=22%>Text</td>
<td width=30%>SQL_C_CHAR</td>
<td width=48%>Text</td>
</tr>
<tr valign=top>
<td width=22%>LongBin</td>
<td width=30%>SQL_C_BINARY</td>
<td width=48%>OLE Object</td>
</tr>
<tr valign=top>
<td width=22%>LongText</td>
<td width=30%>SQL_C_CHAR</td>
<td width=48%>Memo</td>
</tr>
</table><br>
<p>
Generally, these mappings will not result in "unreasonable" requests for driver conversions. But if <b>SQLGetData</b> returns the "driver cannot convert" error (sqlstate = = "S1C00"), then Access will use fCType = = SQL_C_CHAR for that column, for the remainder of the result set. If the driver cannot convert the data to SQL_C_CHAR, Access returns an error. Conversion of any type to char is not unreasonable.</p>
<h4>Special characters contained in column names</h4>
<p>
A self-join query on a table with a column name containing ',' (comma) will fail, with a "syntax error". Also, column names containing '=' (equals) will cause updates/deletes to fail ("syntax error"), if NULL values are involved. If the primary key has a column name containing '=' (equals), then NULL values in this column will cause browsing to fail ("syntax error"). These behaviors are Access bugs, but may not be fixed for Access 1.1 because of their rarity, and the difficulty of handling these cases.</p>
<h4>Tracing the SQL that is sent to the ODBC driver</h4>
<p>
Adding TraceSQLMode=1 in the [ODBC] section of the MSACCESS.INI file will cause a log file, "sqlout.txt", to be written in the Access directory. This file is always appended to, never overwritten. The lines beginning with "SQLExecDirect" and "SQLPrepare" indicate the SQL that Access is passing to the driver. The "SQLExecute" lines trace calls to <b>SQLExecute</b> on a previously prepared hstmt, and print only the general type of statement executed (for example, "UPDATE", "DELETE"). This log file often contains as much useful information as ODBC API tracing, but with much less chaff, especially in ASYNC mode.</p>
<h4>Connection timeout</h4>
<p>
Access holds onto one or two connections, even when idle, so that you can quickly open and close datasheets/forms without constantly reconnecting. Two idle connections are held only if SQL_ACTIVE_STATEMENTS = = 1. These idle connections are closed after N seconds of idle time, controlled by the <i>ConnectionTimeout</i> value in the [ODBC] section of the MSACCESS.INI file (600 seconds, by default). All connections are closed when Access exits.</p>
<h4>Connection management</h4>
<p>
Access implemented connection-sharing based on two things: SQL_ACTIVE_STATEMENTS (see above comment) and matching connect strings. Access will consider two connect strings to match if:
<ul type=disc>
<li>
The DSN parameter from both connect strings are the same; and<br><br></li>
<li>
The Database parameter is either nonexistent in both connect strings or the same in both connect strings.</li>
</ul>
<h4>Reading the remote connectivity configuration table</h4>
<p>
When starting a connection, Access executes the query</p>
<pre><code>SELECT nValue FROM MSysConf WHERE Config = 101
</code></pre>
<p>
against the data source. Any errors during execution/fetching of this query are ignored. This table is not required to exist in the data source, but allows for Access-specific configuration options.</p>
<h4>Checking for out-of-date stored procedures on SQL Server</h4>
<p>
SQL_SUCCESS_WITH_INFO with sqlstate = = "S1000" is treated as an error. This prevents attaching SQL Server tables on a server whose ODBC Stored Procedures are out-of-date.</p>
<h4>Distinguishing errors from warnings</h4>
<p>
Access calls <b>SQLError</b> immediately after any ODBC API that returns an error code other than:</p>
<p>
SQL_SUCCESS</p>
<p>
SQL_INVALID_HANDLE</p>
<p>
SQL_NO_DATA_FOUND</p>
<p>
SQL_STILL_EXECUTING</p>
<p>
SQL_NEED_DATA</p>
<p>
SQLError must return at least one sqlstate and error string. Otherwise, the "error" is assumed to be a harmless warning, and is ignored.</p>
<p>
<b>Sending "parameterized" queries to the ODBC driver</b></p>
<p>
Access queries may contain parameters. If declared explicitly, and given a type, Access will try to send expressions containing these parameters to the driver for evaluation. Parameters are explicitly declared by adding them to the Parameter Dialog under the Query menu in Query Design. <b>SQLSetParam</b> is called for each query parameter sent, with values as follows:</p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=18%><b>Access Type</b></td>
<td class=label width=27%><b>ODBC fCType</b></td>
<td class=label width=29%><b>fSqlType</b></td>
<td class=label width=12%><b>cbColDef</b></td>
<td class=label width=14%><b>ibScale</b></td>
</tr>
<tr valign=top>
<td width=18%>Yes/No</td>
<td width=27%>SQL_C_BIT</td>
<td width=29%>SQL_BIT</td>
<td width=12%>0</td>
<td width=14%>0</td>
</tr>
<tr valign=top>
<td width=18%>Byte</td>
<td width=27%>SQL_C_SHORT</td>
<td width=29%>SQL_SMALLINT</td>
<td width=12%>0</td>
<td width=14%>0</td>
</tr>
<tr valign=top>
<td width=18%>Integer</td>
<td width=27%>SQL_C_SHORT</td>
<td width=29%>SQL_SMALLINT</td>
<td width=12%>0</td>
<td width=14%>0</td>
</tr>
<tr valign=top>
<td width=18%>LongInteger</td>
<td width=27%>SQL_C_LONG</td>
<td width=29%>SQL_INTEGER</td>
<td width=12%>0</td>
<td width=14%>0</td>
</tr>
<tr valign=top>
<td width=18%>Currency</td>
<td width=27%>SQL_C_CHAR</td>
<td width=29%>SQL_DECIMAL</td>
<td width=12%>19</td>
<td width=14%>4</td>
</tr>
<tr valign=top>
<td width=18%>Single</td>
<td width=27%>SQL_C_FLOAT</td>
<td width=29%>SQL_FLOAT</td>
<td width=12%>0</td>
<td width=14%>0</td>
</tr>
<tr valign=top>
<td width=18%>Double</td>
<td width=27%>SQL_C_DOUBLE</td>
<td width=29%>SQL_FLOAT</td>
<td width=12%>0</td>
<td width=14%>0</td>
</tr>
<tr valign=top>
<td width=18%>Date/Time</td>
<td width=27%>SQL_C_TIMESTAMP</td>
<td width=29%>SQL_TIMESTAMP</td>
<td width=12%>19</td>
<td width=14%>0</td>
</tr>
<tr valign=top>
<td width=18%>Binary</td>
<td width=27%>SQL_C_BINARY</td>
<td width=29%>SQL_VARBINARY</td>
<td width=12%>255</td>
<td width=14%>0</td>
</tr>
<tr valign=top>
<td width=18%>Text</td>
<td width=27%>SQL_C_CHAR</td>
<td width=29%>SQL_VARCHAR</td>
<td width=12%>255</td>
<td width=14%>0</td>
</tr>
<tr valign=top>
<td width=18%>OLE Object</td>
<td width=27%>SQL_C_BINARY</td>
<td width=29%>SQL_LONGVARBINARY</td>
<td width=12%>0</td>
<td width=14%>0</td>
</tr>
<tr valign=top>
<td width=18%>Memo</td>
<td width=27%>SQL_C_CHAR</td>
<td width=29%>SQL_LONGVARCHAR</td>
<td width=12%>0</td>
<td width=14%>0</td>
</tr>
</table><br>
<p>
Generally, these mappings will not result in "unreasonable" requests for driver conversions. But if <b>SQLSetParam</b> returns the "driver cannot convert" error (sqlstate = = "S1C00"), then Access will try again with fSqlType = = SQL_VARCHAR, cbColDef = = 255, and ibScale = = 0 (with fCType unchanged). If the driver still cannot convert, Access returns an error.</p>
<h4>Asynchronous query execution</h4>
<p>
Access calls <b>SQLSetStmtOption</b> with SQL_QUERY_TIMEOUT and SQL_ASYNC_ENABLE, and ignores any errors that result.</p>
<h4>Using SQL_DATA_AT_EXEC for non-NULL data</h4>
<p>
When updating/inserting/exporting ODBC data, Access always specifies SQL_DATA_AT_EXEC for all non-NULL columns of type SQL_LONGVARCHAR and SQL_LONGVARBINARY. In all other cases, SQL_DATA_AT_EXEC is not used.</p>
<h4>INSERT INTO syntax</h4>
<p>
When inserting in a datasheet, Access uses:</p>
<pre><code>INSERT INTO MyTable (col1, col2, ...) VALUES (?, ?, ...)
</code></pre>
<p>
When exporting, Access uses:</p>
<pre><code>INSERT INTO MyTable VALUES (?, ?, ...)
</code></pre>
<p>
unless there are Memo or OLE Object columns, in which case Access again uses:</p>
<pre><code>INSERT INTO MyTable (col1, col2, ...) VALUES (?, ?, ...)
</code></pre>
<h4>Rolling back transactions</h4>
<p>
When simulating a ROLLBACK TRANSACTION, errors from <b>SQLTransact</b> are ignored, and are assumed to be of the "already rolled back" nature. This because triggers often do their own rollback, but Access cannot know this.</p>
<h4>Special version columns</h4>
<p>
If <b>SQLSpecialColumns</b>(ROWVER) reports a ROWVER column (say, "RV"), Access uses it to implement optimistic concurrency during datasheet updates. On datasheet update/delete, the UPDATE/DELETE query is appended with "AND RV = ?", and the old value supplied.</p>
<p>
If there is no ROWVER column, then all updatable columns are compared to their old values, as in:</p>
<pre><code>UPDATE MyTable SET col1 = ?, col2 = ?, col3 = ?
WHERE PrimKey = ? AND col1 = ? AND col2 = ? AND col3 = ?
</code></pre>
<p>
LONGVARCHARs and LONGVARBINARYs are excluded from the comparison.</p>
<p>
In either case, the query is executed, and <b>SQLRowCount</b> is called. If crow = = 1, the operation succeeds. If crow = = 0, Access assumes that another user changed the row first, and the operation fails. If crow &lt; 0, an error is assumed, and the operation fails. If crow &gt; 1, then it is assumed that the primary index was dropped, and that rows with duplicate keys were added; the operation fails, after rolling back the multiple updates/deletes.</p>
<h2>Using the Microsoft Access ODBC Test Application</h2>
<h3>Description</h3>
<p>
This section describes the Microsoft Access ODBC Test Application. It gives a brief overview of the purpose of the application and then describes the installation process. It then describes the functionality of the application and how you can customize the application for your ODBC driver.</p>
<h3>Overview</h3>
<p>
The Microsoft Access ODBC Test Application is an Access database designed to verify that your ODBC driver works correctly when used with Microsoft Access. The database contains forms, reports, queries, macros, and modules that will test a variety of functions using the ODBC driver you have developed. In addition to the database, ODBCTEST.MDB, the application contains the SQL Pass-Through DLL, MSASP110.DLL. This DLL allows Access commands directly to an ODBC data source for processing.</p>
<p>
The application presents the driver writer with a list of tasks to perform. You may choose any or all of the tasks, and have those tasks executed against data that is accessed via your driver. The application will keep track of the total number of tasks that have been executed, as well as the results of those tasks. You can even configure the application to execute tasks that you define yourself!</p>
<h3>Installation</h3>
<p>
To install the Microsoft Access ODBC Test Application, simply copy the file from the Install diskette to the Access directory on your hard drive. To begin the application, open the database ODBCTEST.MDB from the FileOpenDatabase menu option in Access.</p>
<h3>Setup Parameters Dialog</h3>
<p>
When the application is first started, you will be presented with the Setup Parameters dialog. The Setup Parameters dialog prompts for five pieces of information:
<ul type=disc>
<li>
<b>Server Name:</b> The name of the ODBC data source you will be testing against.<br><br></li>
<li>
<b>Database Name:</b> The name of the database, if necessary, in which to create tables.<br><br></li>
<li>
<b>User ID:</b> The log-in for the given data source.<br><br></li>
<li>
<b>Password:</b> The password for the specified User ID.<br><br></li>
<li>
<b>Current DB:</b> The name of the ODBC Test application database—ODBCTEST.MDB</li>
</ul>
<h3>Main Menu</h3>
<p>
After the Setup Parameters have been specified, choose OK. The application will connect to the data source and bring up the ODBC Test Database Main Menu. The Main Menu contains five options:
<ul type=disc>
<li>
<b>Setup Parameters:</b> Invokes the Setup Parameters dialog discussed in the section above.<br><br></li>
<li>
<b>Select Tasks:</b> Invokes the "Select Tasks To Run" Form, which allows you to choose the tests to execute.<br><br></li>
<li>
<b>Add/Remove Tasks:</b> Allows you to add or remove tasks from the list of tasks to run.<br><br></li>
<li>
<b>Clear Results Table:</b> Clears the table that contains the results of previous test execution.<br><br></li>
<li>
<b>Close:</b> Terminates the ODBC Test Application.</li>
</ul>
<h3>Select Tasks to Run</h3>
<p>
The Select Tasks to Run form presents a list of tests to be executed. The list of tests is in a multi-select scrolling subform. Choose the <b>Select All</b> button to select all of the tests or choose the <b>Clear All</b> button to de-select all of the tests. Once you have chosen the set of tests you would like to execute, choose the <b>Go!</b> button. This will begin the test execution. The <b>Close</b> button will return you to the Main Menu.</p>
<h3>Table Status Form</h3>
<p>
The Table Status Form is present whenever the ODBC Test Application is active. It shows the current status of executing tests as well as the status of each of the tables used by the tests. Tables can be in one of three states: DOES NOT EXIST, DIRTY, or LOADED. You can force all tables to be marked as either DIRTY or DOES NOT EXIST. DOES NOT EXIST means that the table has not been created yet on the specified data source, and therefore must be exported before a test can be run against that table. DIRTY means that the table exists, but one or more records has been modified. This implies that the data needs to be re-exported before a test can be run against that table. LOADED means the table exists and is in an unmodified state. Tests can be run against this table without further operations being performed on it.</p>
<p>
During test execution, the Table Status Form will display the name of the currently executing test. It will also display a running summary of the total number of tests that have passed and failed, as well as indicating the current progress of the tests—for example, Executing test 5 of 10.</p>
<h3>Customizing the Application for Your Driver</h3>
<p>
Although the ODBCTEST.MDB is designed to be used "as is," it may be necessary to customize the application for data-source-specific features. There is an Access Basic module called "SQL Syntax Sensitive" that contains all of the SQL commands that are sent to the data source via the SQL Pass-through DLL. You should verify that the syntax being executed is the proper syntax for your driver. In addition, there is a function in the "SQL Syntax Sensitive" module called <b>pf_DumpTransaction</b>. If your data source does not support the concept of a transaction log (or you do not need to manually clear out the log), you should comment out the call to <b>pf_DumpTransaction</b> in the <b>pf_BeginTest</b> function of the "Testing Tasks" module.</p>
</BODY>
</HTML>
