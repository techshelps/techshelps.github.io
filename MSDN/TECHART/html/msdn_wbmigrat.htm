<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WordBasic Migration to Visual Basic</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_wbmigrat"></a>WordBasic Migration to Visual Basic</h1>
<p>
Microsoft Corporation </p>
<p>
November 4, 1996</p>
<h2>Abstract</h2>
<p>
Microsoft has integrated WordBasic migration to Microsoft® Visual Basic® as transparently as possible. When a template file is opened, either directly or indirectly (attached templates are an example of indirect) the WordBasic code is converted to Visual Basic automatically. In most cases the user doesn't even know that a conversion process happened. Templates, wizards, and add-ins: load, convert and run without prompts. This paper explains the conversion process, many of the known conversion issues, and solutions to resolve conversion issues.</p>
<h2>Changes in Terminology</h2>
<p>
<b>Macro:</b> Any valid entry-point for code. In WordBasic, a macro is a module with a Sub Main entry point. In Microsoft Word 97, a macro is any public subroutine that does not take parameters. Word 97 still uses the Sub Main entry point for backward compatibility. However, using public subroutines is the preferred entry point. Only valid entry points will show up in Word's Macros dialog and can be assigned to command bars.</p>
<p>
<b>Add-in:</b> To be consistent with other Office applications, global templates are now called add-ins. An add-in is any template that is global in scope. Word add-in libraries (.wll files) are still considered add-ins as well. To see which add-ins are currently loaded, click <b>Templates and Add-Ins</b> on the <b>Tools</b> menu.</p>
<p>
<b>Procedure:</b> Either a subroutine or function. Used to simplify documentation when the distinction between subroutine and function does not matter.</p>
<h2>Conversion Process</h2>
<p>
When a template that contains WordBasic code is opened in Word 97, the WordBasic code is automatically converted into Visual Basic code. This is done as soon as the template is opened. If the template is saved in Word 97 format, the WordBasic code is removed. This process cannot be undone by saving the file back as Word versions 6.0 or 7.0 format. Saving the file in a previous file format removes the Visual Basic code. </p>
<p>
Work spaces that use both Word 97 and Word 6.0/7.0 must use duplicate templates or Word 6.0/7.0 version templates. Using the duplicate templates option means using two templates, one saved in Word 97 format and the other in Word 6.0/7.0 format. Keeping templates in the old file format will require users of Word 97 to wait for the conversion process to complete every time a template file is opened (strongly discouraged).</p>
<p>
There is no WordBasic interpreter in Word 97. All WordBasic statements are methods of the WordBasic object in the Word object model. For those who are familiar with the WordBasic Automation object that was used to drive Word 6.0 and 7.0, this is basically the same concept, except that the code is executed within Word. </p>
<p>
First let's examine successful translation of WordBasic to Visual Basic. The following code shows WordBasic syntax prior to conversion:</p>
<pre><code>Dim Shared MySharedVariable$
Sub MAIN
 &nbsp; 'Simple variable assignment.
 &nbsp; MyVariable$ = "Hello World!"
 &nbsp; 'Display a message box using the variable.
 &nbsp; MsgBox MyVariable$
 &nbsp; 'Illustrate using some simple WordBasic statements.
 &nbsp; 'Create a new file
 &nbsp; FileNewDefault
 &nbsp; 'Call the below function (very simple)
 &nbsp; MySharedVariable$ = MyFunction$
 &nbsp; 'Select the whole document.
 &nbsp; EditSelectAll
 &nbsp; 'Delete the contents of the document.
 &nbsp; EditClear
 &nbsp; 'Insert new text using the module variable.
 &nbsp; Insert MySharedVariable$
 &nbsp; 'Demonstrate naming collisions. Debug is a keyword in VBA.
 &nbsp; If Debug = 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp; FileClose 2
 &nbsp; End If
End Sub
Function MyFunction$
 &nbsp; MyFunction$ = "This is a test of the national broadcasting system ..."
End Function
</code></pre>
<p>
The following is the same code after conversion.</p>
<pre><code>Dim MySharedVariable$
Public Sub MAIN()
 &nbsp;&nbsp; Dim MyVariable$
 &nbsp;&nbsp; Dim Debug_
 &nbsp;&nbsp; MySharedVariable$ = ""
 &nbsp;&nbsp; 'Simple variable assignment.
 &nbsp;&nbsp; MyVariable$ = "Hello World!"
 &nbsp;&nbsp; 'Display a message box using the variable.
 &nbsp;&nbsp; WordBasic.MsgBox MyVariable$
 &nbsp;&nbsp; 'Illustrate using some simple WordBasic statements.
 &nbsp;&nbsp; 'Create a new file
 &nbsp;&nbsp; WordBasic.FileNewDefault
 &nbsp;&nbsp; 'Call the below function (very simple).
 &nbsp;&nbsp; MySharedVariable$ = MyFunction$
 &nbsp;&nbsp; 'Select the whole document.
 &nbsp;&nbsp; WordBasic.EditSelectAll
 &nbsp;&nbsp; 'Delete the contents of the document.
 &nbsp;&nbsp; WordBasic.EditClear
 &nbsp;&nbsp; 'Insert new text using the module variable.
 &nbsp;&nbsp; WordBasic.Insert MySharedVariable$
 &nbsp;&nbsp; 'Demonstrate naming collisions. Debug is a keyword in VBA.
 &nbsp;&nbsp; If Debug_ = 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WordBasic.FileClose 2
 &nbsp;&nbsp; End If
End Sub
Private Function MyFunction$()
 &nbsp;&nbsp; MyFunction$ = "This is a test of the national broadcasting system ..."
End Function
</code></pre>
<p>
A few things to note about the converted code:
<ul type=disc>
<li>
All variables are dimensioned at the top of the procedure or in the module declaration section. Also note that numeric variables are defined as the <b>Variant</b> data type by default.<br><br></li>
<li>
Variable names that conflict with Visual Basic keywords are modified. The variable named <i>Debug</i> is changed to <i>Debug_</i> during the conversion.<br><br></li>
<li>
Module level variables are initialized to their default values in Sub Main (MySharedVariable$ = ""). Visual Basic module level variables are persistent until the template is removed from memory. The WordBasic converter assumes that Sub Main is the only entry point of a WordBasic macro. The developer is responsible for handling side effects of modules that have multiple entry points.<br><br></li>
<li>
All WordBasic statements are prefixed with the WordBasic object. The WordBasic object includes methods that correspond to the WordBasic statements and functions and makes it possible to run WordBasic macros in Word 97.<br><br></li>
<li>
Sub Main is declared public and <b>MyFunction$</b> is declared private. The reason for this scoping issue is described below.</li>
</ul>
<p>
The following conversion sample is a macro that calls a function within another macro (the other macro is called <b>Test1</b> and the function is <b>MyFunction$</b>):</p>
<pre><code>Sub MAIN
 &nbsp;&nbsp; Insert Test1.MyFunction$
End Sub
</code></pre>
<p>
The WordBasic object implemented a new method named <b>Call</b> to handle this situation, as seen in the following code:</p>
<pre><code>Public Sub MAIN()
 &nbsp;&nbsp; WordBasic.Insert WordBasic.Call("Test1.MyFunction$")
End Sub
</code></pre>
<p>
Visual Basic cannot call the <b>MyFunction$</b> function from any module external to <b>Test1</b> because it was converted to private in scope. (Only procedures within the same Visual Basic module can call a private procedure using the Visual Basic calling convention.) Adding private scope was done to preserve the WordBasic calling functionality. </p>
<p>
Using <b>WordBasic.Call</b> is significantly slower than using the Visual Basic <b>Call</b> statement. To improve performance in cross-module calls, change the declaration of the procedure you're calling from private to public. In the calling statement, remove <b>WordBasic.Call</b> and use the Visual Basic <b>Call</b> statement, as follows:</p>
<pre><code>Public Sub MAIN()
 &nbsp;&nbsp; 'The Call keyword is not required, but used here to emphasis it.
 &nbsp;&nbsp; WordBasic.Insert Call Test1.MyFunction$
End Sub
</code></pre>
<p>
For more details, see <a href="#callconven">"Word Calling Conventions"</a>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If the scope of a subroutine is changed to public, it will be listed as a valid entry point. If this is an undesired side effect, verify that the users can perceive the performance gains.</p>
<p class=indent>
If the subroutine or function to be called exists in another template, the calling template must reference the source template project. This can be done by adding a reference to the project in the <b>References</b> dialog box in the Visual Basic Editor. For more details, see "Check or Add an Object Library Reference" in Help.</p>
<h3>Long-Term Conversion Process</h3>
<p>
The Word 97 process of converting WordBasic code to Visual Basic code is a short-term solution. The preferred long term solution is to rewrite the converted WordBasic code using Visual Basic objects other than the WordBasic object. One of the primary reasons for the WordBasic object is to extend the life span of old WordBasic code. This enables IS departments to upgrade the install base to Word 97 before a rewrite of the old code base is complete. The code base can be replaced at a managed pace.</p>
<p>
Why rewrite the converted code using the hierarchical Word object model? Performance, efficiency, and maintenance are all dramatically improved with well written object-model code. </p>
<h4>More information</h4>
<p>
For more information about converting WordBasic macros to Visual Basic, refer to the following Help topics:
<ul type=disc>
<li>
Converting WordBasic macros to Visual Basic<br><br></li>
<li>
Conceptual differences between WordBasic and Visual Basic<br><br></li>
<li>
Visual Basic equivalents for WordBasic Commands</li>
</ul>
<h2>WordBasic Migration Issues</h2>
<p>
Most migration issues are a result of the functional differences between WordBasic and Visual Basic for Applications. Migrating to Visual Basic for Applications as the development platform for Word also means that Word must abide by an existing standard. In most cases, the conversion is seamless. This section describes eight significant issues that may halt converted macros from executing. Frequently, minor edits to the source code can quickly resolve a conversion issue.</p>
<h3>Finding Old Syntax Errors</h3>
<p>
WordBasic is a true interpreted language and Visual Basic is not. One side effect of true interpreted languages is that statements are not validated until they are executed. In the case of WordBasic, if a statement is never executed, it is never parsed or validated. The following WordBasic code contains a statement that is never executed.</p>
<pre><code>If 0 &lt;&gt; 0 Then
 &nbsp; 1 = SyntaxErrorSpokenHere
End If
MsgBox "Worked"
</code></pre>
<p>
This code functions correctly in the WordBasic environment but causes a compile error in Visual Basic. Visual Basic is a quasi-interpreted language, meaning that Visual Basic compiles code and also executes statements through an interpreter. When Visual Basic compiles code, it parses every statement into <i>excodes</i>. Excodes are compacted statements that the interpreter executes. This compile process improves execution performance. The side effect of this compile process is that every line of code must successfully compile. In the previous example, even though the line that contains the syntax error will never execute, it is syntactically incorrect; in Visual Basic, the parser raises an error. This error causes the parser to halt, ending the compilation process and any chance of the code executing.</p>
<p>
The only solution here is to edit the source code, correct the errors, and recompile to test for other errors. Repeat the process until the project compiles successfully. </p>
<p>
Adding <b>Option Explicit</b> to the top of every module is highly recommended. <b>Option Explicit</b> forces variable declaration, raising a compile time error for undeclared variables. These are commonly just misspelled variables. To have <b>Option Explicit</b> automatically inserted for you, click <b>Options</b> on the <b>Tools</b> menu in the Visual Basic Editor, and then check <b>Require Variable Declaration</b> in the <b>Options</b> dialog box.</p>
<h3>Converting Templates that Contain Execute-Only Macros</h3>
<p>
In Visual Basic, the project represents the solution. The components of the project represent a logical division of the project, but cannot function alone. In WordBasic, the macro represents the solution. To be consistent with other Office applications, the macro maps as a project component (module) and the document or template maps as the project. </p>
<p>
This design change affects how source code is protected. Visual Basic only provides project-level protection. To protect one macro, the whole project must be protected. In the case of an add-in or template, this is generally a non-issue. </p>
<p>
In the case of the Normal template, however, this is an issue. It is very common for Word developers to copy project hooks into the Normal template. Solutions that are one or two macros would copy the protected macros into the Normal template. </p>
<p>
This creates a problem for the conversion process. Should Word allow protected macros to convert? If it does, should it protect the whole template or expose the code? After careful study, most users preferred to have access to their converted macros instead of a protected template. Therefore, the conversion process removes execute-only macros from the Normal template. Word does make a back-up copy of the Normal template, called Normal.wbk.</p>
<p>
There is a working solution, but it must be implemented prior to installing Word 97. Move all execute-only macros from the Normal template into a global template called 2Normal.dot (Templates and add-ins are loaded alphabetically). This way 2Normal.dot will be a protected template after conversion, but won't affect the users personal macros stored in Normal. Most solutions will correctly function after the conversion.</p>
<p>
When Word starts, it loads the Normal template. If the Normal template has not been converted into the new Word 97 format, Word converts it at this time. This conversion is silent (no prompts). For all other templates, Word displays a prompt asking the user to replace the existing template with the converted template, save the template with a different name, or cancel. If the user chooses to replace a template and the template contains protected macros, the protection is irreversible. In most cases this is the desired functionality.</p>
<h3>Copying Macros from One Template to Another</h3>
<p>
The macro protection change had a rippling effect on the WordBasic <b>MacroCopy</b> command and the Word Organizer. Below is a summary of the changes.
<ul type=disc>
<li>
Macros in protected projects cannot be copied.<br><br></li>
<li>
Macros cannot be copied into protected projects.<br><br></li>
<li>
The <i>ExecuteOnly</i> argument functionality of the WordBasic <b>MacroCopy</b> statement has been disabled.<br><br></li>
<li>
The Organizer does not list macros in a protected document.</li>
</ul>
<p>
Why was this done? 
<ul type=disc>
<li>
To protect the intellectual property of developers.<br><br></li>
<li>
To protect any sensitive information that may have been embedded in the source code.<br><br></li>
<li>
To protect the consumer from having his or her template encrypted.</li>
</ul>
<p>
If it were possible to copy a macro from a protected project to a public project, the macro would be editable. If it were possible to copy a macro to a public module as execute-only, it would encrypt the whole project.</p>
<p>
These changes significantly affect installation routines. The solution provider should refrain from using the Normal template as a code repository. All code stored in Normal must be public (visible to all). Utility or vertical solutions that enhance the application environment should be installed as global templates. Workflow and task oriented solutions should be implemented as attach templates or wizards.</p>
<p>
Solutions that are distributed as products should be distributed using professional software distribution tools. </p>
<h3>Editing and Creating Macros</h3>
<p>
There is no WordBasic editor in Word 97. As a result, WordBasic commands that pertain to the WordBasic editor will not work (such as <b>REM</b>, <b>ShowVars</b>, and <b>ToolsMacro .Edit</b>). These routines must be written in Visual Basic to work with the Visual Basic Editor, which is represented by the <b>VBE</b> object. For more information about using the methods and properties of the <b>VBE</b> object see Help.</p>
<p>
The following code is a simple demonstration of automating the Visual Basic Editor. The code adds a module to the Normal template, renames the module to <b>NewCode</b>, inserts a procedure named <b>Sub Main</b> to the module, and then executes the procedure. To test the following code, insert the subroutine into a module in the Visual Basic Editor. Make sure there is a reference to the Microsoft Visual Basic for Applications Extensibility object before executing the code.</p>
<pre><code>Sub AddProcToNormal()
 &nbsp;&nbsp; Const MODULE_NAME As String = "NewCode"
 &nbsp;&nbsp; Const PROJECT_NAME As String = "Normal"
 &nbsp;&nbsp; 
 &nbsp;&nbsp; Dim vbModule As VBIDE.VBComponent
 &nbsp;&nbsp; Dim szCode As String
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Add a new module and set a reference to it.
 &nbsp;&nbsp; Set vbModule = Application.VBE.VBProjects(PROJECT_NAME). _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VBComponents.Add(vbext_ct_StdModule)
 &nbsp;&nbsp; 'Name the module NewCode.
 &nbsp;&nbsp; vbModule.Name = MODULE_NAME
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 'Define the code to be inserted.
 &nbsp;&nbsp; szCode = "Sub Main()" &amp; vbCrLf &amp; _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbTab &amp; "Msgbox ""This is a test.""" &amp; vbCrLf &amp; _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "End Sub" &amp; vbCrLf
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; 'Add the code to the module.
 &nbsp;&nbsp; vbModule.CodeModule.AddFromString szCode
 &nbsp;&nbsp; 'Execute the macro.
 &nbsp;&nbsp; Application.Run MODULE_NAME &amp; ".Main"
 &nbsp;&nbsp; 
End Sub
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Previously, a common Automation hack used to improve performance was to copy WordBasic code into the WordBasic editor using Automation and then execute the macro. This technique does not work in Word 97.</p>
<h3>Updating 16-Bit API Calls</h3>
<p>
16-bit application programming interface (API) declarations must be converted to 32-bit declarations. This limitation also existed in 32-bit WordBasic (in Windows NT® and Windows® 95). For people who have yet to migrate to the 32-bit world, there is some relief. Bruce McKinney, author of <i>Hardcore Visual Basic</i> (Microsoft Press, 1996), has made his Visual Basic 4.0 Windows type library available here.</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4925">
</OBJECT><a href="javascript:sample1.Click()">To download the type library, click here to view a list of sample files. From the list, select bin\win32.tlb and click Copy</a></p>
<p>
Why use the type library? The type library will save you the time of looking up the declaration for the 32-bit version of the API. The type library also provides easy access to the whole Windows library. Using the type library reduces memory consumption of unused API declarations and reduces the maintenance cost of duplicating API declarations across multiple projects. </p>
<p>
<b>To use the Windows type library (Win32.tlb) file</b>
<ol>
<li>
Copy the type library to the Windows system directory. <br><br></li>
<li>
In every project where there are Windows API calls, make a reference to the Windows type library. References are added in the <b>References</b> dialog box (use the <b>References</b> command on the <b>Tools</b> menu in the Visual Basic Editor).<br><br></li>
<li>
Remark out all 16-bit API declarations. Word automatically remarks out standard Windows API calls.<br><br></li>
<li>
Force Visual Basic to compile the project (use the <b>Compile Project</b> command on the <b>Debug</b> menu in the Visual Basic Editor).</li>
</ol>
<p>
Visual Basic will halt compilation at the first error it finds. If it halts at an API function, check to see that the alias (function name) is the same name as in the type library. Use the Object Browser to look up functions in the type library. Repeat this process until the project successfully compiles and runs.</p>
<p>
For more detailed information on porting 16-bit solutions to 32-bit Word, see <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_32bitapi">
</object><a href=JavaScript:alink_1.Click()>Porting Your 16-Bit Microsoft Office-Based Solutions to 32-Bit Microsoft Office</a>. </p>
<h3>Updating API Calls that Return LPSTR</h3>
<p>
WordBasic supported LPSTRs (long pointer to a string) returned from external function calls. This feature was unique to WordBasic. Visual Basic requires that BSTR (basic string) be returned from external calls. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Many of the functions in the Wbodbc.wll that was released with the Word Development Kit for Word 95 and Word 6.0 return LPSTRs.</p>
<h3>Opening Documents with Long Macro Names</h3>
<p>
WordBasic allowed macro names (module names) to be 40 characters. Visual Basic module names are limited to 31 characters. If a template contains 2 macros with the same first 31 characters, Word cannot correctly modify the names of both macros. This will cause Word to fail on opening the template. The only work around is to open the template in Word 6.0 or 7.0 and rename the macros to shorter names.</p>
<h3>Converting Localized WordBasic Code to Word 97</h3>
<p>
WordBasic statements are stored in a <i>tokenized </i>format. When Word 97 converts WordBasic code, it converts the tokens into English statements. However if the developer used localized names in strings, these strings won't be converted. For example, the following WordBasic statement:</p>
<pre><code>ToolsMacro .Name="FichierImprimerDéfaut", .Run 
</code></pre>
<p>
Successfully converts to the following Visual Basic statement:</p>
<pre><code>WordBasic.ToolsMacro Name:="FichierImprimerDéfaut", Run:=1
</code></pre>
<p>
On execution an error will occur ("Unable to run specified macro", Error 4644).</p>
<p>
In the past, developing WordBasic solutions for international markets has been difficult. Word 97 addresses international development issues by using enumerated constants in place of literal strings. For example, to change the style to Heading 1, you use the <b>wdStyleHeading1</b> constant instead of the literal string "Heading 1." </p>
<pre><code>'The following statement works in English Word.
Selection.Style = ActiveDocument.Styles("Heading 1")
'The following statement works for all versions of Word 97.
Selection.Style = ActiveDocument.Styles(wdStyleHeading1)
</code></pre>
<p>
There are other features that are part of the Visual Basic language that dramatically improve the ability to write international macros. For more information on international development, see the MSDN Library on developing for international markets, including Chapter 29, "International Issues," in the Programmer's Guide in the Visual Basic documentation; "Developing for International Markets," in the C++ documentation; and the <i>Globalization Resource Kit</i>, in Books and Periodicals. </p>
<h2><a name="callconven"></a>Word Calling Conventions</h2>
<p>
The methodology that Word uses to find and execute a macro is termed a calling convention. In Word 97 there are three distinct and different calling conventions. These are Visual Basic <b>Call</b>, <b>WordBasic.Call</b> and <b>Application.Run</b>.</p>
<h3>Visual Basic Calling Convention</h3>
<p>
The Visual Basic calling convention is the most natural and efficient calling method. Visual Basic permits scope descriptors (public and private) to define the visibility of procedures to other modules. Private procedures are visible only within the module. Public procedures can be called from any other procedure. </p>
<p>
The period (.) is termed the navigation operator in Visual Basic. In the same way, objects, methods, and properties are navigated with the navigation operator, so are modules and procedures. For example, to call the <b>MySub</b> subroutine in a module called <b>MyModule</b> in the Normal template, the following syntax can be used. This is termed an explicit call. The <b>Call</b> keyword is optional. It is in brackets to accentuate that the Visual Basic <b>Call</b> statement is being executed with or without the call keyword prefixing the statement.</p>
<pre><code>[Call] Normal.MyModule.MySub
</code></pre>
<p>
<b>MySub</b> could be called without any navigation operators. This is an implicit call. In this case, the first <b>MySub</b> procedure or method is executed. Visual Basic first looks in the calling module, and then all other modules in the project. If the procedure isn't found, Visual Basic enumerates each reference for <b>MySub</b>. If no procedure or method exists, a compile-time error is generated. Visual Basic inserts the explicit reference in the excodes.</p>
<p>
So what does this really mean? First, to call procedures that exist in other templates (Normal, add-ins, or global templates), a reference to that project (template) must be made to the project. This can be added manually or programmatically. Second, when the solution is distributed, all of the references must be resolved before the solution can execute.</p>
<p>
The following code illustrates how to programmatically add a reference:</p>
<pre><code>Sub AddReference()
 &nbsp;&nbsp; On Error GoTo ErrorHandler
 &nbsp;&nbsp; ThisDocument.VBProject.References.AddFromFile "Normal.dot"
 &nbsp;&nbsp; Exit Sub
ErrorHandler:
 &nbsp;&nbsp; Select Case Err.Number
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox Err.Description &amp; "; " &amp; Err.Number &amp; _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "; " &amp; Err.Source
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err.Clear
 &nbsp;&nbsp; End Select
End Sub
</code></pre>
<p>
For more information, see "Understanding Scope and Visibility" in Help.</p>
<h3>Word Calling Conventions</h3>
<p>
Word 97 has two calling conventions (external to Visual Basic). These are <b>WordBasic.Call</b> and <b>Application.Run</b>. Both are methods of the respective parent object. Both are similar in overall behavior. Both are significantly slower in execution than using the standard Visual Basic <b>Call</b> technique. However, the Word conventions have other uses.</p>
<p>
Word implements a calling convention that is based on the active environment. That is, the macros, command bars, and key assignments that are available depend on the active document and its attached template. So, when either <b>WordBasic.Call</b> or <b>Application.Run</b> are used, the call enumerates each level, in the following order, looking for the specified macro.
<ol>
<li>
Active document<br><br></li>
<li>
Attached template<br><br></li>
<li>
Normal template<br><br></li>
<li>
Add-ins and global templates<br><br></li>
<li>
Built-in commands</li>
</ol>
<p>
Because the attached template can be dynamically removed or changed, the developer can implement polymorphic programming techniques to Word. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Word documents can now contain code and be attached to a template. This new functionality enables the Word developer to use new programming techniques never before possible.</p>
<p>
As an example, assume there is a macro called <b>FileOpen</b> in the Normal template. When the users selects <b>Open</b> on the <b>File</b> menu, Word will search the above levels, starting at the first, for <b>FileOpen</b>. In this example, when the Normal template is reached, the FileOpen macro will execute. In most cases, Word's built-in commands are not over-ridden, so the built-in commands execute.</p>
<p>
The two differences between <b>WordBasic.Call</b> and <b>Application.Run</b> are the search order in which Word searches for a procedure and the way parameters are passed.</p>
<p>
In Word 97, there are two types of macros. One is a subroutine (call this new style) and the other is <b>MacroName.Main</b> (call this old style). <b>WordBasic.Call</b> first searches for a new style macro then for an old style macro. If this fails for the current level, Word moves to the next level, and so on, until the macro is found or the search is exhausted. <b>Application.Run</b> searches all levels first for new style then repeats the search for old style macros.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;It is possible to have a converted macro enter at the wrong entry point. For example, if a WordBasic macro contained a subroutine whose name was the same as the macro (module name), the entry point under Word 97 would be at the subroutine instead of Sub Main.</p>
<p>
Parameters can be passed through <b>WordBasic.Call</b> but not <b>Application.Run.</b></p>
<h2>Conclusion</h2>
<p>
In most cases, the conversion process from WordBasic to Visual Basic is seamless. With preplanning, migration issues can be minimized. Other issues can be resolved with minor edits to the converted source code. In Word 97, the converted code can be modified to add features never before possible in WordBasic. In time, all of the code that executes through the WordBasic object can be replaced with Visual Basic code that uses the Word object model. </p>
</BODY>
</HTML>
