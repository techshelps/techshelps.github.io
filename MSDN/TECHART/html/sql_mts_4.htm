<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Visual Basic 5.0 to Build Microsoft Transaction Server Components</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Using Visual Basic 5.0 to Build Microsoft Transaction Server Components</h1>
<p>
<img src="sql_mts_6.gif" border=0></p>
<p>
The database application components&nbsp;you build with Microsoft Visual&nbsp;Basic for Microsoft Transaction Server and SQL&nbsp;Server model the activity of your organization's business. These components implement business rules, provide views, and transform the state of an application. For example, bank records in one or more database systems represent the durable state of the business, such as the amount of money in an account. The application components update that state to reflect changes, such as debits and credits. </p>
<p>
Microsoft Transaction Server application components&nbsp;are COM&nbsp;in-process server components&nbsp;(DLLs). You can create and implement these components with Visual&nbsp;Basic as well as Visual&nbsp;C++, Visual&nbsp;J++, or any ActiveX-compatible development tool. </p>
<p>
Transaction Server shelters you from complex server issues, allowing you to focus on implementing business functions. Because components running under Transaction Server can take advantage of transactions, you can write applications as if they run in isolation. Transaction Server handles concurrency, resource pooling, security, context&nbsp;management, and other system-level complexities. The transaction system, working in cooperation with database servers and other types of resource managers, ensures that concurrent transactions are atomic, consistent, have proper isolation, and, once committed, are durable. </p>
<p>
To help you learn to create Microsoft Transaction Server components, this section will show you how to build a component using SQL&nbsp;Server and Visual&nbsp;Basic. You build the component by creating a project with a class module that exposes a method. Database connectivity is handled by the Microsoft Transaction Server ODBC resource dispenser, which provides automatic connection pooling through Microsoft Transaction Server. </p>
<p>
When you create a database application, each time the application is used, it obtains, uses, and then releases its database connection. A database connection is a valuable resource. One of the most efficient models for resource usage in scalable applications is to use connections sparingly, acquire them only when you really need them, and return them as soon as possible. </p>
<p>
Microsoft Transaction Server provides resource sharing through its Resource Dispenser Manager and resource dispensers. The Resource Dispenser Manager works with specific resource dispensers to automatically pool and recycle resources. The ODBC&nbsp;3.0 Driver Manager is a Microsoft Transaction Server resource dispenser, also referred to as the ODBC resource dispenser. </p>
<p>
You do not need to implement any Transaction Server-specific APIs to begin using the ODBC resource dispenser. When you use Remote Data Objects (RDO) to access the database, RDO in turn uses ODBC. Whenever any component running in the Transaction Server run-time environment uses ODBC directly or indirectly, the component automatically uses the ODBC resource dispenser. Microsoft Transaction Server is aware of your database connectivity when you register your component with Microsoft Transaction Server Explorer.</p>
<p>
When an object in your application releases the database connection, the connection is returned to a pool. When the object is called again, it requests the same database connection. Instead of creating a new connection, the ODBC resource dispenser recycles the pooled connection, which saves time and server resources.</p>
<p>
For more information about creating Visual&nbsp;Basic/SQL&nbsp;Server applications, see <i>Hitchhiker's Guide to Visual&nbsp;Basic and SQL&nbsp;Server, Fifth Edition</i> by Bill Vaughn.</p>
<p>
Before you start coding, you should have an ODBC data source configured to access SQL&nbsp;Server:
<ul type=disc>
<li>
In Control Panel, click ODBC.<p>
<img src="sql_mts_7.gif" border=0></P><p>
<img src="sql_mts_8.gif" border=0></P></li>
<li>
Click <b>Add</b>, and then select SQL&nbsp;Server. Click <b>Finish</b>. <br><br></li>
<li>
Click <b>Options.</b> <br><br></li>
<li>
Specify the data source name as MTxSamples&nbsp;and the&nbsp;Server&nbsp;as (local). Enter the default database to use for the <b>Account</b> table (<b>pubs</b> for example).<br><br></li>
<li>
Make sure that Microsoft SQL&nbsp;Server is running. In the <b>Server</b> box of SQL Service Manager, click a SQL&nbsp;Server. If the spotlight is green, then that SQL&nbsp;Server is running; if not, double-click <b>Start/Continue</b>.<p>
<img src="sql_mts_9.gif" border=0></P></li>
<li>
In Visual&nbsp;Basic, start a new project as an ActiveX DLL. After you have initiated the project, you can write Visual&nbsp;Basic code. <p class=tl>
This is a server component and has no user interface. You access a database using Remote Data Objects (RDO) and enable the ODBC resource dispenser to pool connections.</P><p>
<img src="sql_mts_10.gif" border=0></P></li>
</ul>
<h3>Code Sample</h3>
<p>
Your code should follow the simplified format below.</p>
<p>
Set public functions.</p>
<p>
Check to see if the RDO connection is valid:</p>
<pre><code>if rdoConnection throws an exception
On Error GoTo ErrorHandler

' obtain the RDO environment and connection
Dim rdoConn As rdoConnection
Set rdoConn = rdoEngine.rdoEnvironments(0).OpenConnection("", rdDriverNoPrompt, 
False, strConnect)
</code></pre>
<p>
(Error handling is typically placed at the end of code; it is here for clarity.)</p>
<pre><code>ErrorHandler:

If Not rdoConn Is Nothing Then
&nbsp; &nbsp; rdoConn.Close
End If

strResult = Err.Description&nbsp;&nbsp;&nbsp;&nbsp; 'return the error message and indicate that 
an error occurred to your component
End Function
</code></pre>
<p>
Write SQL logic for accessing SQL&nbsp;Server tables:</p>
<pre><code>Dim strSQL As String
strSQL = SQL logic goes here…
</code></pre>
<p>
Enter RDO connection parameters:</p>
<pre><code>rdoConn.Execute strSQL, Options:=rdExecDirect

' if anything else happens
On Error GoTo ErrorHandler
</code></pre>
<p>
If no errors, then continue processing:</p>
<pre><code>strSQL = SQL logic goes here…
Dim rdoRS As rdoResultset
Set rdoRS = rdoConn.OpenResultset(strSQL, Option:=rdExecDirect)
If rdoRS.EOF &lt;&gt; True Then
</code></pre>
<p>
Application logic goes here:</p>
<pre><code>rdoConn.Close
</code></pre>
<p>
Close database connections so MTS ODBC resource dispenser can reallocate as required:</p>
<pre><code>Exit Function
</code></pre>
<p>
As you can see, even existing Visual&nbsp;Basic code can be easily managed using Transaction Server because RDO uses ODBC and ODBC is managed by MTS at run time. Only DLLs can be registered with Microsoft Transaction Server—you must rebuild executables as DLLs first.</p>
<p>
After writing code, build the component as a DLL&nbsp;and save it. You will have to use Microsoft Transaction Server Explorer to register the component with the MTS run-time environment. For more information about how to monitor transactions of an application during testing, see "Microsoft Transaction Server Explorer," later in this paper.</p>
<p>
Each time you change a Microsoft Transaction Server component, the registry must be updated with the new component information. The Development version of Microsoft Transaction Server includes a Visual&nbsp;Basic 4.0–compatible add-in that automates this process (click <b>VB Addin</b> during Setup). The next time you run Visual&nbsp;Basic 4.0, the add-in is installed in Visual&nbsp;Basic. The add-in refreshes all of your Transaction Server component DLLs&nbsp;whenever you recompile your project. </p>
<p>
You can set this feature on a per-project basis by toggling the command on the Visual&nbsp;Basic <b>Add-Ins</b>&nbsp;menu. After a compile, on the Visual&nbsp;Basic <b>Add-Ins</b>&nbsp;menu, point to <b>MTxServer RegRefresh</b>, and then click <b>AutoRefresh</b>. A check mark indicates that the feature is enabled. To refresh all Transaction Server components at any given time, on the Visual&nbsp;Basic <b>Add-Ins</b>&nbsp;menu, point to <b>MTxServer RegRefresh</b>, and then click <b>Refresh all components now</b>. </p>
<h3>Improving Scalability</h3>
<p>
There are several ways to optimize Visual&nbsp;Basic code for MTS and SQL&nbsp;Server. Traditionally, objects have been handled in a couple ways:
<ul type=disc>
<li>
A client can create, use, and release an object. The next time it needs the object, it creates it again. This technique conserves server resources. However, as an application scales up, performance slows down. If an object is on a remote computer, a network roundtrip occurs each time an object is created; this negatively affects performance. <br><br></li>
<li>
A client can create an object and hold onto it until the client no longer needs it; this approach is faster. However, in a large-scale application, it quickly becomes expensive in terms of server resources. </li>
</ul>
<p>
While either of these approaches might be fine for a small-scale application, as an application scales up, they both become inefficient. <i>Just-in-time activation</i>&nbsp;provides the best of both approaches, while avoiding the disadvantages of each. It uses server resources efficiently without requiring changes to the client.</p>
<p>
By adding a few lines of code, you can implement just-in-time activation. When an object calls <b>SetComplete</b>, it notifies the Transaction Server run-time environment that it should be deactivated as soon as it returns control to the client. This allows the Transaction Server run-time environment to release object resources, including any database connections held, prior to the release of the object. The client continues to hold a reference to the deactivated object. When a client calls a method on a deactivated object, the reference is automatically bound to a new object. Thus, the client has the illusion of a continuous reference to a single object, without tying up server resources unnecessarily. </p>
<h3>Implementing Just-in-Time Activation</h3>
<p>
Every Transaction Server object&nbsp;has a context&nbsp;object associated with it. The context object contains information about the execution environment of the object, such as the identity of the object creator and, optionally, the transaction encompassing the work of the object. An object context is similar in concept to the process context that an operating system maintains for an executing program. The Microsoft Transaction Server run-time environment manages a context for each object. A context object is created when an object is created. You can use a context to declare when the work of the object is complete. The Transaction Server run-time environment can safely deactivate an object, making its resources available for reuse while supporting a greater number of concurrent users. </p>
<p>
To implement just-in-time activation:
<ul type=disc>
<li>
Call <b>GetObjectContext</b>&nbsp;to get a reference to the context object:<pre><code>Dim ctxNAME As ObjectContext
Set ctxObject = GetObjectContext()
</code></pre>
</li>
<li>
Call <b>SetComplete</b> when an object has completed its work successfully: <pre><code>ctxObject.SetComplete
</code></pre>
<p class=tl>
<b>SetComplete</b>&nbsp;notifies the Transaction Server run-time environment that the object (NAME in this case), should be deactivated as soon as it returns control to the client. </P><p class=tl>
Call <b>SetAbort</b> when an object has not completed its work successfully. </P><p class=tl>
<b>SetAbort</b> notifies the Transaction Server run-time environment that the object should be deactivated as soon as it returns control to the client. ctxObject.SetAbort would be set in the ErrorHandler division.</P></li>
</ul>
<h3>Code Sample</h3>
<p>
Using earlier code (changes are bold):</p>
<p>
Set public functions.</p>
<p>
Get the object context:</p>
<pre><code><b>Dim ctxObject As ObjectContext
</b>Set ctxObject = GetObjectContext()
</code></pre>
<p>
Check to see if the RDO connection is valid:</p>
<pre><code>' if rdoConnection throws an exception
On Error GoTo ErrorHandler

' obtain the RDO environment and connection
Dim rdoConn As rdoConnection
Set rdoConn = rdoEngine.rdoEnvironments(0).OpenConnection("", rdDriverNoPrompt, 
False, strConnect)
</code></pre>
<p>
&nbsp;(Error handling is typically placed at the end of code; it is here for clarity.)</p>
<pre><code>ErrorHandler:

If Not rdoConn Is Nothing Then
&nbsp; &nbsp; rdoConn.Close
End If

strResult = Err.Description&nbsp;&nbsp;&nbsp;&nbsp; 'return the error message and indicate that 
an error occurred to your component
End Function
</code></pre>
<p>
Write SQL logic for accessing SQL&nbsp;Server tables:</p>
<pre><code>Dim strSQL As String
strSQL = SQL logic goes here…
</code></pre>
<p>
Enter RDO connection parameters:</p>
<pre><code>rdoConn.Execute strSQL, Options:=rdExecDirect

' if anything else happens
On Error GoTo ErrorHandler
</code></pre>
<p>
If no errors, then continue processing:</p>
<pre><code>strSQL = SQL logic goes here…
Dim rdoRS As rdoResultset
Set rdoRS = rdoConn.OpenResultset(strSQL, Option:=rdExecDirect)
If rdoRS.EOF &lt;&gt; True Then
</code></pre>
<p>
Application logic goes here:</p>
<pre><code>rdoConn.Close
</code></pre>
<p>
Close database connections so MTS ODBC resource dispenser can reallocate as required. Object has completed work, so free it up:</p>
<pre><code><b>ctxObject.SetComplete

</b>Exit Function
</code></pre>
</BODY>
</HTML>
