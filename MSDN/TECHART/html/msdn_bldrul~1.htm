<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Controlling the Build Process with Custom Build Rules</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_bldrul~1"></a></sup>Controlling the Build Process with Custom Build Rules </h1>
<p>
Microsoft Corporation</p>
<p>
March 19, 1997</p>
<h2>Introduction</h2>
<p>
The custom build rules have been improved for Visual C++®, Version 5: 
<ul type=disc>
<li>
Your custom build rules are implemented as operating-system batch files. <br><br></li>
<li>
You can specify pre-link and post-build steps. <br><br></li>
<li>
You can specify input dependencies for individual files. </li>
</ul>
<h2>Build Rules Implemented as Operating System Batch Files</h2>
<p>
The batch files, generated during the build process, run your rules and are then deleted. Because the build rules are implemented as batch files, you can use the development environment's build system to perform any action allowed by the operating system's command processor, such as cd, copy, del, md. </p>
<h3>Examples</h3>
<p>
The following operating system command creates a directory if it doesn't already exist: </p>
<pre><code>if not exist ..\lib\x386 md ..\lib\x386 
</code></pre>
<p>
The following operating-system command clears the read-only file attribute for My.lib: </p>
<pre><code>if exist ..\lib\x386\My.lib attrib -r ..\lib\x386\My.lib 
</code></pre>
<p>
The ATL COM AppWizard generates a per-file build rule that calls the MIDL compiler for .idl files. Use the ATL COM AppWizard to create a COM project, select the project's .idl file, press Alt+F7 to access the Build Settings dialog, and study the custom build rule that specifies input to and output from the MIDL compiler. </p>
<h2>Using Macros and Environment Variables In Build Rules</h2>
<p>
Predefined macros and environment variables in build rules are useful for two reasons: 
<ul type=disc>
<li>
They generalize your build rules so that your projects run as expected on different computers. <br><br></li>
<li>
They allow you to specify the locations of directories and files using fewer key strokes. The Directory and Files buttons on the Custom Build tab provide fast, mouse-click access to these macros. </li>
</ul>
<h3>Using the Build System's Macros</h3>
<p>
When you create a project, the development environment's build system predefines several macros that you can use in your build rules. These are easily recognized because they use mixed-case letters (for example, $(<i>TargetPath</i>)). The build system's macros are documented in the Visual C++ 5.0 documentation in the "Macros for Custom Build Commands" topic. The definitions of the defined macros are specific to your project; if you create a project on one computer and it is used on other computers, the definitions are carried with the project.</p>
<p>
The macros are understood by both the build process and NMAKE. If you create an NMAKE-compatible .mak file using the Export Makefile command (Project menu), the definitions of the macros that you use in your project are written to the resulting .mak file. </p>
<p>
If neither the build system nor NMAKE can find the definition of a mixed-case macro, the operating system's environment variables are searched for a match. </p>
<h3>Using Operating-System Environment Variables</h3>
<p>
Both the build system and NMAKE recognize operating system environment variables if they are wrapped with the dollar-sign syntax that is recognized by NMAKE. For example, use the following syntax to use the LIB environment variable in a build rule:</p>
<pre><code>$(LIB) 
</code></pre>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;You must specify all environment variables to the build system and to NMAKE in uppercase letters, as shown in the example above. This is required because the build system follows the historic behavior of NMAKE. NMAKE stores the macro definitions for environment variables in uppercase letters. </p>
<p>
Environment variables, such as PATH, INCLUDE, LIB, MSDEVDIR, are useful because they are computer-specific. Because the location of important files, such as CL.exe, Link.exe, and Lib.exe, can differ from computer to computer, the use of common environment variables on each computer allow a project to build as expected on different computers. This assumes that the necessary Visual C++ tools have been installed to each computer using Setup.</p>
<h3>Managing Environment Variables</h3>
<p>
For Microsoft® Windows NT® 4.0, environment variables are managed from the Environment tab of the Control Panel's System application. For Microsoft Windows® 95, they are managed by batch files such as Autoexec.bat.</p>
<h3>Specifying Environment Variables Using Batch-File Syntax</h3>
<p>
In limited cases, you can use environment variables that are wrapped with percent-sign syntax, such as %LIB%. This syntax is commonly used in batch files. Neither the development environment's build system nor NMAKE understand the percent-sign syntax and cannot use their own upper-case copies of the environment variables to interpret environment variables so specified. When encountering this syntax, both tools pass the token to the operating system's command processor for interpretation.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;You can use this syntax in only the Build command(s) grid control of the Custom Build tab. You cannot successfully use it in either the Output file(s) or the user-defined dependencies grid control of the Custom Build tab.</p>
<h2>When Do Custom Build Rules Run?</h2>
<p>
Custom build rules are run at different times, depending upon whether they are specified on the Custom Build tab, the Pre-link step tab, or the Post-link step tab.</p>
<h3>Rules Specified with the Custom Build Tab</h3>
<p>
Rules entered on the Custom Build tab run only when any input file is out of date with respect to its output file or if the output file doesn't exist.
<ul type=disc>
<li>
Per-file rules that you enter into the Custom Build tab run before the normal build-system tools (such as the compiler, the resource compiler, and so on) are run. <p class=tl>
<b>Important:</b> Do not attach per-file rules to the output files of build-system tools such as .obj, .res, and .tbl files. Such per-file rules will not run as expected.</P></li>
<li>
Per-project rules that you enter into the Custom Build tab run after the normal build process finishes. </li>
</ul>
<h3>Rules Specified with the Post-build Step Tab</h3>
<p>
Rules that you enter into the Post-build step tab run after successful completion of the normal build process, including successful completion of rules entered on the Custom Build tab. No file timestamps are checked. </p>
<h3>Rules Specified with the Pre-link Step Tab</h3>
<p>
Rules that you enter into the Pre-link step tab run between compile and link time. No file timestamps are checked.</p>
<h3>Specifying Build Rules That Run Before the Link Process</h3>
<p>
You can use the Pre-link step tab to specify build rules that run before the link process. This tab is useful for such actions as creating directories or setting file attributes before the link process. </p>
<h4>To specify Pre-link steps: </h4>
<ol>
<li>
Right-click the appropriate project from the <b>FileView</b> tab of the Workspace window, and then click <b>Settings</b>. <br><br></li>
<li>
Choose the appropriate project configuration (such as <b>Debug</b>, <b>Release</b>, <b>All Configurations</b>), from the <b>Settings For</b> list. <br><br></li>
<li>
Select the<b> Pre-link step</b> tab. <br><br></li>
<li>
Type operating-system batch file commands, environment variables, and build-rule macros into the grid control. </li>
</ol>
<h3>Specifying Build Rules that Run After the Build Process</h3>
<p>
You can use the Post-build step tab to specify build rules that run after the build process finishes. These rules will run after those specified on other build rule tabs. You can also use this tab to automatically copy an output file to a drop point, generate a mail message reporting that the build has finished, or run a process that doesn't create an output file, such as regsvr32. </p>
<p>
For example, if you've used the ATL COM AppWizard to create an ATL project, look at the Build Rules tab and note that the custom build rule generates a dummy file named regsvr32.trg. This dummy output file has, as a dependency, your ATL COM object and fulfills the necessity that rules entered in the Build Rules tab have an output file whose existence or time stamp can be checked before an action can be taken. In this case, the rule registers your ATL COM object with the operating system, should the build process run far enough to create a new version of the object. </p>
<p>
The ATL COM AppWizard was written to use this technique before the existence of the Post-build step tab. You could move the regsvr32 /s /c "$(<i>TargetPath</i>)" rule to this new tab and it would run without the necessity of creating a dummy file. </p>
<h4>To specify Post-build steps: </h4>
<ol>
<li>
Right-click the appropriate project from the <b>FileView</b> tab of the Workspace window, and then click <b>Settings</b>. <br><br></li>
<li>
Choose the appropriate project configuration (such as <b>Debug</b>, <b>Release</b>, <b>All Configurations</b>), from the <b>Settings For</b> list. <br><br></li>
<li>
Select the <b>Post-build step</b> tab. <br><br></li>
<li>
Type operating-system batch file commands, environment variables, and build-rule macros into the grid control. </li>
</ol>
<h2>Specifying Input Dependencies</h2>
<p>
You can now specify all of the input files to a file, even if the build process doesn't recognize the extension of either an input file or the dependent file. </p>
<p>
To specify input dependencies: 
<ol>
<li>
Right-click the appropriate project from the <b>FileView</b> tab of the Workspace window, and then click <b>Settings</b>. <br><br></li>
<li>
Choose the appropriate project configuration (such as <b>Debug</b>, <b>Release</b>, <b>All Configurations</b>), from the <b>Settings For</b> list. </li>
</ol>
<p>
If the file type is one that is not handled by the development environment's build system: 
<ol>
<li>
Click the <b>Custom Build</b> tab. <br><br></li>
<li>
Click <b>Dependencies</b>. <br><br></li>
<li>
Type all of the input files into the grid control. </li>
</ol>
<p>
If the file type is one that is already handled by the development environment's build system (such as .cpp, .rc, .idl), the Custom Build tab will not display unless you do the following: 
<ol>
<li>
Click the <b>General</b> tab. <br><br></li>
<li>
Check <b>Always Use Custom Build</b> step. <br><br></li>
<li>
The <b>Custom Build</b> tab appears. <br><br></li>
<li>
Type all of the input files into the grid control. </li>
</ol>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;If you choose to define custom dependencies for a file type that the build system already handles, such as .c or .cpp files in Visual C++ and .java files in Visual J++, you are responsible for all of the steps in the related custom process. </p>
<h2>How to Debug Build Rules</h2>
<p>
The development environment supports three easy ways to debug your custom build rules. We've included a couple of "gotchas" if you're stumped. 
<ul type=disc>
<li>
<b>Save the custom build rule batch files<br>
</b>When you start the build process for a single file or an entire project, the development environment generates one or more batch files that reflect your custom build rules and then runs them. The batch files exist only during the build process. However, you can save the batch files for examination during the debugging process by entering the following command as the first line of any rule you are debugging: <pre><code>copy %0 command.bat
</code></pre>
</li>
<li>
<b>Use Echo On to view the custom build rules<br>
</b>Because the build rules are implemented as batch files, you can use the Echo On command to print the results of your build rules to the development environment's Output window. Echo Off is the default. <p class=tl>
To echo build rules: </P><ol>
<li>
Right-click the appropriate project from the <b>FileView</b> tab of the Workspace window, and then click <b>Settings</b>. <br><br></li>
<li>
Choose the appropriate project configuration (such as <b>Debug</b>, <b>Release</b>, <b>All Configurations</b>), from the <b>Settings For</b> list. <br><br></li>
<li>
Click the <b>Custom Build</b>, <b>Pre-link step</b>, or the <b>Post-build step</b> tab as appropriate. <br><br></li>
<li>
Type Echo On into the grid control that reflects the build rule you want to debug. <br><br></li>
<li>
Use the <b>Move Item Up</b> and <b>Move Item Down</b> arrow buttons to move the echo on command to the point after which you need to see output. </li>
</ol>
</li>
<li>
<b>Check the build log<br>
</b>One of the most important debugging tools is the build log (.plg) that each build, whether of a project or a file, generates. The build log contains the low-level commands of the build process. These will include each of your build rules, with macros and environment expanded, and their results. </li>
</ul>
<h3>Gotchas</h3>
<p>
Here are two details to check:
<ul type=disc>
<li>
A common mistake when calling a batch file from within a build rule is to fail to precede the invocation of the batch file with the call command. If the call command is missing, no parts of the build rule that occur after the batch file will run after the batch file exits. Remember to examine your project's build log (.plg) file to determine the actions of your build rules.<br><br></li>
<li>
You must add any file to the project if it is both generated by a build rule and listed as a dependency for another file. Otherwise, the build rules will not run in the correct order.</li>
</ul>
</BODY>
</HTML>
