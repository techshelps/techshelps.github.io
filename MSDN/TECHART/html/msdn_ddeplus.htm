<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing DDE Using C++ Classes</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_ddeplus"></a></sup>Implementing DDE Using C++ Classes</h1>
<p>
Nigel Thompson<br>
Microsoft Developer Network Technology Group</p>
<p>
March 6, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4224">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the DDECPP set of samples for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes a set of C++ classes that can be used in implementing DDE servers and clients. The server implementation provides full support for the System topic. These classes were developed using Visual C++™ version 2.0 under Microsoft® Windows NT™ version 3.5.</p>
<h2>Introduction</h2>
<p>
Many moons ago, my good friend and alter ego Herman Rodent wrote a series on dynamic data exchange (DDE) culminating in the article <a href="msdn_ddeserv.htm">"Quick and Easy DDE Server,"</a> in which he described how to implement a complete DDE server using only one application programming interface (API) call. Of course, this API call required you to cut and paste some 3,000 lines of code into your application first.</p>
<p>
Well, there I was at home this Christmas suffering slightly from present-opening overload with my children and wondering if a bit of computer tinkering might be in order. I had recently purchased an X10 home controller interface and was in the middle of writing some control software for it and had decided that a Net DDE interface would be a good add-on feature. If the controller sat on our server at home (yes, my house is networked), my wife could run a simple Visual Basic® application to turn on the printer upstairs in my workroom, play with the lighting and so on. Sooo. . . since the new application was a 32-bit C++ beast, and I didn't want to do any more work than necessary to implement my DDE server, I decided to try to port Herman's old 16-bit DDE server code into my new Visual C++™ application. Well, I did that and it worked, but I wasn't satisfied with the results, so when I got back to work after the vacation, I decided to implement the same level of DDE support in some custom-built classes. This technical article describes those classes and the test applications that use them. This work actually goes a little beyond support for a server—it also includes a conversation object, which makes using DDE in a client application much simpler, too.</p>
<h2>DDE Object Classes</h2>
<p>
Figure 1 shows the set of classes used to support DDE. All objects are derived from the Microsoft® Foundation Class Library version 3.0.</p>
<p>
<img src="ddeplus_1.gif" border=0></p>
<p class=label>
<b>Figure 1. C++ Classes used to support DDE</b></p>
<p>
OK, I forgive you if you think I've gone a bit overboard here. That's pretty much what I thought when I created the diagram. In fact, there isn't as much here as there might seem. Let's go through the classes and see what they do.</p>
<h3>CHSZ</h3>
<p>
The <b>CHSZ</b> class provides a convenient way to create the <b>HSZ</b> string handles that the DDEML library uses. These objects are constructed using a pointer to a string and contain the <b>HSZ</b> handle value. An <b>HSZ</b> casting operator enables the object to be used anywhere an <b>HSZ</b> handle would be required in a DDEML library function call. We'll see these in use in the code a little later.</p>
<h3>CDDECountedObject</h3>
<p>
When I implemented the <b>CDDEConv</b> class, I found that the class needed to be reference-counted, so I created a simple base class to encapsulate the reference-counting functions, <b>AddRef</b> and <b>Release</b>. Those of you familiar with the Component Object Model on which OLE is based will recognize these functions. This is a trivial class but simplifies the classes derived from it slightly. Again, we'll see it in use later when we look at managing conversations.</p>
<h3>CDDEConv and CDDEConvList</h3>
<p>
<b>CDDEConv</b> encapsulates a DDE conversation. Because conversations can be initiated by the application acting as a client or another application using your application as a server, conversations can be created locally or thrust upon us by another application. Keeping track of when the conversation object can be deleted is simplified by giving the object a reference count. Hence, <b>CDDEConv</b> is derived from <b>CDDECountedObject</b>. The <b>CDDEConvList</b> class provides a list of <b>CDDEConv</b> objects.</p>
<h3>CDDEItem and CDDEItemList</h3>
<p>
DDE revolves around services, conversations, topics, and items. The <b>CDDEItem</b> class encapsulates a single item. The <b>CDDEItemList</b> class provides for a list of <b>CDDEItem</b> objects in a topic.</p>
<h3>CDDEStringItem</h3>
<p>
The <b>CDDEStringItem</b> isn't used in the DDE support classes but is provided as a convenient way of implementing an item that is simply a string of text. The item can be requested (peeked into) or poked. The DDEServ sample uses this class.</p>
<h3>CDDESystemItem . . .</h3>
<p>
The <b>CDDESystemItem</b>, <b>CDDESystemItem_TopicList</b>, <b>CDDESystemItem_ItemList</b>, and <b>CDDESystemItem_FormatList</b> classes are all used to support the System topic in a server.</p>
<h3>CDDETopic and CDDETopicList</h3>
<p>
The <b>CDDETopic</b> class encapsulates a DDE topic. The <b>CDDETopicList </b>class provides for a list of topics.</p>
<h3>CDDEServerSystemTopic</h3>
<p>
This special topic is used to support the System topic in a server.</p>
<p>
The classes of most importance when creating a server application are <b>CDDEServer</b>, <b>CDDETopic</b>, and <b>CDDEItem</b>. When you are creating a client application, the most important classes are <b>CDDEServer</b> and <b>CDDEConv</b>.</p>
<h2>Creating a DDE Server Application</h2>
<p>
Let's look at what's required to build a simple DDE server. We'll be using the DDEServ sample as an example. The DDEServ sample doesn't really do very much, but it shows how to build a simple server framework upon which you can easily add your own functionality. Figure 2 shows a screen shot of the server.</p>
<p>
<img src="ddeplus_2.gif" border=0></p>
<p class=label>
<b>Figure 2. A screen shot of the DDEServ sample application</b></p>
<p>
DDEServ was build using the Visual C++ AppWizard. It's a simple single-document-interface (SDI) application with no bells or whistles. The document class has no real function, and the view class exists only to display status messages so that we can see what's going on inside the server as it operates. The area of most interest is the main frame window. This is where the DDE server object resides. The MAINFRM.H header file contains the declaration of the server object:</p>
<pre><code>// Attributes
public:
 &nbsp;&nbsp; CMyServer m_Server;
</code></pre>
<p>
OK, so you expected to see a <b>CDDEServer</b> object. <b>CMyServer</b> is derived from <b>CDDEServer</b> (in MYSERV.H):</p>
<pre><code>class CMyServer : public CDDEServer
{
public:
 &nbsp;&nbsp; CMyServer();
 &nbsp;&nbsp; virtual ~CMyServer();
 &nbsp;&nbsp; virtual void Status(const char* pszFormat, ...);
 &nbsp;&nbsp; virtual BOOL OnCreate();

public:
 &nbsp;&nbsp; CMyTopic m_DataTopic;
 &nbsp;&nbsp; CMyStringItem m_StringItem1;
 &nbsp;&nbsp; CMyStringItem m_StringItem2;
};
</code></pre>
<p>
Notice that <b>CMyServer</b> overrides the <b>Status</b> and <b>OnCreate</b> functions defined in <b>CDDEServer</b>. The <b>Status</b> function is really a debugging aid. It is used in the DDEServ sample to print progress and error messages in the main window, so you can see what's going on. The <b>OnCreate</b> member is called when the server object has been created, to allow any derived class to set up its own topics and items.</p>
<p>
As you can see, <b>CMyServer</b> has three member variables: a topic and two items. <b>CMyTopic</b> is derived from <b>CDDETopic</b>:</p>
<pre><code>class CMyTopic : public CDDETopic
{
public:
 &nbsp;&nbsp; CMyTopic();
 &nbsp;&nbsp; virtual BOOL Exec(void* pData, DWORD dwSize);
};
</code></pre>
<p>
The <b>Exec </b>member function is overridden so that DDE execute commands will be handled by <b>CMyTopic</b> objects. (The default action in <b>CDDETopic</b> is to fail them.)</p>
<p>
The <b>CMyString</b> objects are derived from <b>CDDEStringItem</b>:</p>
<pre><code>class CMyStringItem : public CDDEStringItem
{
protected:
 &nbsp;&nbsp; virtual void OnPoke();
};
</code></pre>
<p>
The <b>OnPoke</b> member is overridden so that the object will be notified of any change in the object's data caused by a DDE Poke command.</p>
<p>
Let's see how these derived classes are implemented now in MYSERV.CPP. Let's begin by looking at what happens when the server object is created in the <b>CMainFrame::OnCreate</b> function (from MAINFRM.CPP):</p>
<pre><code>int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
 &nbsp;&nbsp; ... Code ommitted here

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Start the DDE server.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; if (!m_Server.Create(AfxGetAppName())) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buf[128];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(buf,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Service failed to start. Error: %d",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Server.GetLastError());
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox(buf);
 &nbsp;&nbsp; }

 &nbsp; return 0;
}
</code></pre>
<p>
The server object's <b>Create</b> member is called using the name of the service to be created. As is common practice in DDE applications, the service name is the same as the name of the application. <b>CDDEServer::Create</b> does the grunt work of establishing the new service and registering itself with the DDEML library. It then calls the <b>OnCreate</b> function to allow any derived class a chance to set itself up. Let's see how <b>CMyServer</b> handles this:</p>
<pre><code>BOOL CMyServer::OnCreate()
{
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Add our own topics and items.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; m_DataTopic.Create("Data");
 &nbsp;&nbsp; AddTopic(&amp;m_DataTopic);

 &nbsp;&nbsp; m_StringItem1.Create("String1");
 &nbsp;&nbsp; m_DataTopic.AddItem(&amp;m_StringItem1);

 &nbsp;&nbsp; m_StringItem2.Create("String2");
 &nbsp;&nbsp; m_DataTopic.AddItem(&amp;m_StringItem2);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Set up some data in the strings.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; m_StringItem1.SetData("This is string 1");
 &nbsp;&nbsp; m_StringItem2.SetData("This is string 2");

 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
The single topic is created and named Data. The topic is then added to the server's topic list. The two string items are created, added to the topic list, and then given initial values. Calling <b>CDDEStringItem::SetData </b>not only changes the data in the item, but also sends an advise message to any client that might be interested in the change of value.</p>
<p>
If a client of this service requests data from one of the items, that data is supplied automatically by the service. There is no interaction with the application. If an external application pokes data to one of the items, the item data changes and the item object's <b>OnPoke</b> member is called to notify any derived object that the data has changed. (<b>CDDEStringItem</b> does nothing.)</p>
<p>
If an external application attempts to send the Data topic an execute command, the object's <b>Exec</b> member is called. <b>CMyTopic</b> handles this by simply printing a message to the main window:</p>
<pre><code>BOOL CMyTopic::Exec(void* pData, DWORD dwSize)
{
 &nbsp;&nbsp; STATUS("Exec: %s", (char*)pData);
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
Obviously, I've skipped over a lot of the details here, but you should be able to see that by simply deriving your own item and topic classes, it's very simple to implement a DDE server. In fact, because the <b>CDDEServer</b> has functions of its own to handle Request, Poke, and Exec commands, you need not implement any topics or items at all. You could override the server's functions and implement all the functionality right there. The only thing that would be missing from this implementation would be support for the DDE System topic. The <b>CDDETopic</b> and <b>CDDEItem</b> objects are normally kept in lists that the server can walk in order to satisfy System topic requests. To understand more about supporting the System topic, see <a href="msdn_ddesystp.htm">"Supporting the DDE System Topic,"</a> by Herman Rodent in the Microsoft Development Library.</p>
<h2>Creating a DDE Client Application</h2>
<p>
I chose to create the sample DDE client application as a dialog-type application, using the Visual C++ AppWizard. I didn't choose this over a more common SDI document/view application because it's better, but because I hadn't tried this before. So this is (as usual) just another way to skin the cat. Figure 3 shows a screen shot of the sample DDECli application.</p>
<p>
<img src="ddeplus_3.gif" border=0></p>
<p class=label>
<b>Figure 3. A screen shot of the DDECli sample application</b></p>
<p>
The DDECli sample application is a very generic DDE client. It allows you to connect to a named service and topic. Once connected, it can send Exec commands to the topic and peek and poke at specific items of the topic. A status window provides information on what's happening as the client talks to the server.</p>
<p>
The client application actually shares a fair bit in common with a server, and in fact, it uses a <b>CDDEServer</b> object in the same way the DDEServ sample did. The main difference between the client application and the server is that the client deals mostly with conversations rather than discrete topics and items. So in building a client application, we will make use of the <b>CDDEConv</b> object.</p>
<p>
The main window of the dialog contains the server object and a pointer to a current conversation object:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CMyClient m_DDEClient;
 &nbsp; CMyConv* m_pConversation;
</code></pre>
<p>
Notice here that we are dealing with classes derived from <b>CDDEServer</b> and <b>CDDEConv</b>. When the dialog is first initialized, the server object is created:</p>
<pre><code>BOOL CDDECliDlg::OnInitDialog()
{
 &nbsp; ... Code omitted 
 &nbsp; 
 &nbsp; Status("Initializing service");

 &nbsp;&nbsp; if (!m_DDEClient.Create(AfxGetAppName())) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox("Failed to initialize DDE client");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; }
 &nbsp; 
 &nbsp; Status("Service running");
 &nbsp;&nbsp; UpdateUI();
 &nbsp; return TRUE;&nbsp; // Return TRUE unless you set the focus to a control.
}
</code></pre>
<p>
Notice that the client application is initialized exactly the same way the server application was, and in fact, the client is also a server, although in this case it supports no topics other than the System topic.</p>
<h3>Handling a Connection</h3>
<p>
When DDECli is running, type in the name of a service and a topic (such as DDEServ and Data). Then click the connect button to make the connection. Here's how the connection is handled in the code:</p>
<pre><code>void CDDECliDlg::OnConnectBtn() 
{
 &nbsp;&nbsp; ASSERT(!m_pConversation);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Get the current data set.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; UpdateData(TRUE);
 &nbsp;&nbsp; if (m_strService.GetLength() == 0) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox("You must enter a service name");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; if (m_strTopic.GetLength() == 0) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox("You must enter a topic name");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Try to connect to the specified service and topic.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; m_pConversation = new CMyConv(&amp;m_DDEClient, this);
 &nbsp;&nbsp; ASSERT(m_pConversation);
 &nbsp;&nbsp; m_pConversation-&gt;AddRef();
 &nbsp;&nbsp; if (!m_pConversation-&gt;ConnectTo(m_strService, m_strTopic)) {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pConversation-&gt;Release(); // and it should get deleted
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pConversation = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; Status("Connected to %s|%s",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (const char*)m_strService,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (const char*)m_strTopic);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // If an item is listed, get the current value and 
 &nbsp;&nbsp; // set up an advise request for changes.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (m_strItem.GetLength() &gt; 0) { 

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwSize = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void* pData = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pConversation-&gt;Request(m_strItem, &amp;pData, &amp;dwSize);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dwSize) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_strItemData = (char*)pData;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateData(FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete pData;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ask for notice if it changes.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pConversation-&gt;Advise(m_strItem);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Status("Failed to get data from %s",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (const char*) m_strItem);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; UpdateUI();
}
</code></pre>
<p>
The name of the service and topic are obtained from the dialog variables, and a new <b>CMyConv</b> object is created. Because conversation objects are reference-counted, the object's <b>AddRef</b> member is called to increase its reference count. The conversation's <b>ConnectTo</b> member is called to make the connection, and if all goes well, a status message is displayed.</p>
<p>
Once the connection is made, a check is run to see if the name of an item has been entered. If it has, the conversation object requests data from that item and sets up a DDE Advise request so that if the item data changes at the server, the conversation object will be notified.</p>
<h3>Making Execute Requests</h3>
<p>
To send an execute request to the service topic, enter the command text and click the Exec button. The code does the following:</p>
<pre><code>void CDDECliDlg::OnExecBtn() 
{
 &nbsp; ASSERT(m_pConversation);
 &nbsp;&nbsp; UpdateData(TRUE);
 &nbsp;&nbsp; if (!m_pConversation-&gt;Exec(m_strExecCmd)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Status("Exec failed");
 &nbsp;&nbsp; }
}
</code></pre>
<p>
The execute command is extracted from the dialog, and the conversation's <b>Exec</b> member function is called to send the command to the server.</p>
<h3>Poking Data to an Item</h3>
<p>
Data can be poked to an item very simply by entering the text (only text transfers are supported in this example) in the item data window and clicking the Poke button. Again, the implementation is very simple:</p>
<pre><code>void CDDECliDlg::OnPokeBtn() 
{
 &nbsp; ASSERT(m_pConversation);
 &nbsp;&nbsp; UpdateData(TRUE);
 &nbsp;&nbsp; if (!m_pConversation-&gt;Poke(CF_TEXT,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_strItem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void*)(const char*)m_strItemData,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_strItemData.GetLength() + 1)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Status("Poke failed");
 &nbsp;&nbsp; }
}
</code></pre>
<h2>Summary</h2>
<p>
I've very briefly presented here a set of C++ classes that will allow you to implement a DDE server or client. For more details on the DDE mechanism and how it functions, please search the rest of the Development Library. There are several articles on how DDE works, as well as several implementation examples in C. And finally, don't forget that Visual Basic makes a great test tool for DDE servers. Writing a Visual Basic test client can be as simple as writing a dozen lines of code.</p>
</BODY>
</HTML>
