<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Rules of the Component Object Model</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_therules"></a></sup>The Rules of the Component Object Model</h1>
<p>
Charlie Kindel<br>
Program Manager, Windows NT</p>
<p>
October 20, 1995</p>
<h2>Abstract</h2>
<p>
This paper is intended to be a quick reference for the primary rules of using and implementing Microsoft® Component Object Model (COM) objects. Readers interested in gaining a better understanding of what COM is, as well as the motivations behind its design and philosophy, should read the first two chapters of the<i> Component Object Model Specification</i> (MSDN Library, Specifications). Chapter 1 is a brief introduction, and Chapter 2 provides a thorough overview. The information presented here is all taken from the COM specification. </p>
<h2>Rule #1: Must Implement IUnknown</h2>
<p>
An object is not a Microsoft® Component Object Model (COM) object unless it implements at least one interface that at minimum is <b>IUnknown</b>.</p>
<h2>Interface Design Rules</h2>
<ul type=disc>
<li>
Interfaces must directly or indirectly inherit from <b>IUnknown</b>.<br><br></li>
<li>
Interfaces must have a unique interface identifier (IID).<br><br></li>
<li>
Interfaces are immutable. Once assigned an IID and published, no element of the interface definition may change.<br><br></li>
<li>
Interface member functions should have a return type of <b>HRESULT</b> to allow the remoting infrastructure to report remote procedure call (RPC) errors.<br><br></li>
<li>
String parameters in interface member functions should be Unicode™.</li>
</ul>
<h2>Implementing IUnknown</h2>
<ul type=disc>
<li>
<i><b>Object identity.</b> </i>It is required that any call to <b>QueryInterface</b> on any interface for a given object instance for the specific interface<b> IUnknown</b> must always return the same physical pointer value. This enables calling <b>QueryInterface(IID_IUnknown, ...)</b> on any two interfaces and comparing the results to determine whether they point to the same instance of an object (the same COM object identity).<br><br></li>
<li>
<i><b>Static interface set.</b> </i>It is required that the set of interfaces accessible on an object via <b>QueryInterface</b> be static, not dynamic. That is, if <b>QueryInterface</b> succeeds for a given IID once, it will always succeed on subsequent calls on the same object (except in catastrophic failure situations), <i>and</i> if <b>QueryInterface</b> fails for a given IID, subsequent calls for the same IID on the same object must also fail.<br><br></li>
<li>
<b><i>Object integrity.</i></b> <b>QueryInterface</b><i> </i>must be reflexive, symmetric, and transitive with respect to the set of interfaces that are accessible. That is, given the code snippet below:<pre><code>IA * pA = (some function returning an IA *);
IB * pB = NULL;
HRESULT hr;
hr = pA-&gt;QueryInterface(IID_IB, &amp;pB); // line 4
</code></pre>
</li>
</ul>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=18%><b>Symmetric:</b></td>
<td width=82%><b>pA-&gt;QueryInterface(IID_IA, ...)</b> must succeed (a&gt;&gt;a)</td>
</tr>
<tr valign=top>
<td width=18%><b>Reflexive:</b></td>
<td width=82%>If, in line 4, <b>pB </b>was successfully obtained, then<pre><code>&nbsp;&nbsp;pB-&gt;QueryInterface(IID_IA, ...)</code></pre>
<p>
must succeed (a&gt;&gt;b, then b&gt;&gt;a).</p>
</td>
</tr>
<tr valign=top>
<td width=18%><b>Transitive:</b></td>
<td width=82%>If, in line 4, <b>pB </b>was successfully obtained, and we do<pre><code>&nbsp;&nbsp;IC * pC = NULL;
  hr = <b>pB</b>-&gt;QueryInterface(IID_IC, &amp;pC);&nbsp;&nbsp;&nbsp; //Line 7</code></pre>
<p>
and <b><i>pC</i></b> is successfully obtained in line 7, then</p>
<pre><code>&nbsp;&nbsp;pA-&gt;QueryInterface(IID_IC, ...)</code></pre>
<p>
must succeed (a&gt;&gt;b, and b&gt;&gt;c, then a&gt;&gt;c).</p>
</td>
</tr>
</table><br>
<ul type=disc>
<li>
<b><i>Minimum reference counter size</i></b>. <b>AddRef</b> implementations are required to maintain a counter that is large enough to support 2 31 –1 outstanding pointer references to all the interfaces on a given object taken as a whole. A 32-bit unsigned integer fits this requirement.<br><br></li>
<li>
<b><i>Release cannot indicate failure</i></b>. If a client needs to know that resources have been freed, and so forth, it must use a method in some interface on the object with higher-level semantics before calling <b>Release</b>.</li>
</ul>
<h2>Memory Management Rules</h2>
<ul type=disc>
<li>
The lifetime management of pointers to interfaces is always accomplished through the <b>AddRef</b> and <b>Release</b> methods found on every COM interface. (See "Reference-Counting Rules" below.)<br><br></li>
<li>
The following rules apply to parameters to interface member functions, including the return value, that are not passed "by-value":<ul type=disc>
<li>
For in parameters, the caller should allocate and free the memory.<br><br></li>
<li>
The out parameters must be allocated by the callee and freed by the caller using the standard COM memory allocator.<br><br></li>
<li>
The in<i>-</i>out parameters are initially allocated by the caller, then freed and re-allocated by the callee if necessary. As with out parameters, the caller is responsible for freeing the final returned value. The standard COM memory allocator must be used.</li>
</ul>
</li>
<li>
If a function returns a failure code, then in general the caller has no way to clean up the out or in-out parameters. This leads to a few additional rules:<ul type=disc>
<li>
In error returns, out parameters must <i>always </i>be reliably set to a value that will be cleaned up without any action on the caller's part. <br><br></li>
<li>
Further, it is the case that all out pointer parameters (including pointer members of a caller-allocate callee-fill structure) <i>must</i> explicitly be set to NULL. The most straightforward way to ensure this is (in part) to set these values to NULL on function entry.<br><br></li>
<li>
In error returns, all in-out parameters must either be left alone by the callee (and thus remaining at the value to which it was initialized by the caller; if the caller didn't initialize it, then it's an out parameter, not an in-out parameter) or be explicitly set as in the out parameter error return case.</li>
</ul>
</li>
</ul>
<h2>Reference-Counting Rules</h2>
<p>
<b>Rule 1:</b> <b>AddRef </b>must be called for every new copy of an interface pointer, and <b>Release</b> called for every destruction of an interface pointer, except where subsequent rules explicitly permit otherwise.</p>
<p>
The following rules call out common nonexceptions to Rule 1.
<ul type=disc>
<li>
<b>Rule 1a:</b> <i>In-out-parameters to functions. </i>The caller must <b>AddRef</b> the actual parameter, since it will be <b>Released</b> by the callee when the out-value is stored on top of it.<br><br></li>
<li>
<b>Rule 1b:</b> <i>Fetching a global variable. </i>The local copy of the interface pointer fetched from an existing copy of the pointer in a global variable must be independently reference counted, because called functions might destroy the copy in the global while the local copy is still alive.<br><br></li>
<li>
<b>Rule 1c:</b> <i>New pointers synthesized out of "thin air."</i> A function that synthesizes an interface pointer using special internal knowledge, rather than obtaining it from some other source, must do an initial <b>AddRef</b> on the newly synthesized pointer. Important examples of such routines include instance creation routines, implementations of <b>IUnknown::QueryInterface</b>, and so on.<br><br></li>
<li>
<b>Rule 1d</b>: <i>Returning a copy of an internally stored pointer. </i>After the pointer has been returned, the callee has no idea how its lifetime relates to that of the internally stored copy of the pointer. Thus, the callee must call <b>AddRef</b> on the pointer copy before returning it.</li>
</ul>
<p>
<b>Rule 2:</b>  Special knowledge on the part of a piece of code of the relationships of the beginnings and the endings of the lifetimes of two or more copies of an interface pointer can allow <b>AddRef/Release</b> pairs to be omitted. 
<ul type=disc>
<li>
From a COM client's perspective, reference-counting is <i>always </i>a per-interface concept. Clients should never assume that an object uses the same reference count for all interfaces.<br><br></li>
<li>
The return values of <b>AddRef</b> and <b>Release</b> should not be relied upon, and should be used only for debugging purposes.<br><br></li>
<li>
Pointer stability; see details in the OLE Help file under "Reference-Counting Rules," subsection "Stabilizing the <b>this</b> Pointer and Keeping it Valid."</li>
</ul>
<p>
See the excellent <a href="msdn_objlife.htm">"Managing Object Lifetimes in OLE"</a> technical article by Douglas Hodges, and Chapter 3 of <i>Inside OLE</i>, 2nd edition, by Kraig Brockschmidt (MSDN Library, Books) for more information on reference-counting.</p>
<h2>COM Application Responsibilities</h2>
<p>
Each process that uses COM in any way—client, server, object implementor—is responsible for three things:
<ol>
<li>
Verify that the COM Library is a compatible version with the COM function <b>CoBuildVersion</b>.<br><br></li>
<li>
Initialize the COM Library before using any other functions in it by calling <b>CoInitialize</b>.<br><br></li>
<li>
Uninitialize the COM Library when it is no longer in use by <b>CoUninitialize</b><i>.</i></li>
</ol>
<p>
In-process servers can assume that the process they are being loaded into has already performed these steps.</p>
<h2>Server Rules</h2>
<ul type=disc>
<li>
In-process servers must export <b>DllGetClassObject</b> and <b>DllCanUnloadNow</b>.<br><br></li>
<li>
In-process servers must support COM self-registration.<ul type=disc>
<li>
In-process and local servers should put an <b>OLESelfReg</b> string in their file version information.<br><br></li>
<li>
In-process servers should export <b>DllRegisterServer</b> and <b>DllUnRegisterServer</b>.<br><br></li>
<li>
Local servers should support the <b>/RegServer</b> and <b>/UnRegServer</b> command-line switches.</li>
</ul>
</li>
</ul>
<h2>Creating Aggregatable Objects</h2>
<p>
Creating objects that can be aggregated is optional; however, it is simple to do, and doing so has significant benefits. The following rules must be followed in order to create an object that is aggregatable (often called the <i>inner</i> object).
<ul type=disc>
<li>
The inner object's implementation of <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> for the <b>IUnknown</b> interface controls the inner object's reference count alone, and must not delegate to the outer unknown. This <b>IUnknown</b> implementation is called the <i>implicit <b>IUnknown.</b></i><br><br></li>
<li>
The implementation of <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b> members of all interfaces that the inner object implements, other than <b>IUnknown</b> itself, must delegate to the outer unknown. These implementations must not directly affect the inner object's reference count.<br><br></li>
<li>
The implicit <b>IUnknown</b> must implement the <b>QueryInterface</b> behavior for only the inner object.<br><br></li>
<li>
The aggregatable object must not call <b>AddRef</b> when holding a reference to the outer unknown pointer.<br><br></li>
<li>
If, when the object is created, any interface other than <b>IUnknown </b>is requested, the creation must fail with <b>E_UNKNOWN</b>.</li>
</ul>
<p>
The code fragment below illustrates a correct implementation of an aggregatable object using the nested class approach to implementing interfaces:</p>
<pre><code>// CSomeObject is an aggregatable object that implements
// IUnknown and ISomeInterface
class CSomeObject : public IUnknown
{
 &nbsp;&nbsp; private:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_cRef;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Object reference count
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IUnknown*&nbsp;&nbsp;&nbsp; m_pUnkOuter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Outer unknown, no AddRef

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Nested class to implement the ISomeInterface interface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class CImpSomeInterface : public ISomeInterface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend class CSomeObject ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_cRef;&nbsp;&nbsp;&nbsp; // Interface ref-count, for debugging
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IUnknown*&nbsp;&nbsp;&nbsp; m_pUnkOuter;&nbsp; // Outer unknown, for delegation
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CImpSomeInterface() { m_cRef = 0;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~ CImpSomeInterface(void) {};

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IUnknown members delegate to the outer unknown</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IUnknown members do not control lifetime of object</b>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHODIMP&nbsp;&nbsp;&nbsp;&nbsp; QueryInterface(REFIID riid, void** ppv)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; return m_pUnkOuter-&gt;QueryInterface(riid,ppv);&nbsp; };

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHODIMP_(DWORD) AddRef(void)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp; return m_pUnkOuter-&gt;AddRef();&nbsp;&nbsp; };

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHODIMP_(DWORD) Release(void)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp; return m_pUnkOuter-&gt;Release();&nbsp;&nbsp; };

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ISomeInterface members
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHODIMP SomeMethod(void) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; return S_OK;&nbsp;&nbsp;&nbsp; };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CImpSomeInterface m_ImpSomeInterface ;
 &nbsp;&nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CSomeObject(IUnknown * pUnkOuter)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_cRef=0;

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No AddRef necessary if non-NULL as we're aggregated.</b>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pUnkOuter=pUnkOuter;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ImpSomeInterface.m_pUnkOuter=pUnkOuter;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~CSomeObject(void) {} ;

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Static member function for creating new instances (don't use</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // new directly). Protects against outer objects asking for interfaces </b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // other than IUnknown</b>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static HRESULT Create(IUnknown* pUnkOuter, REFIID riid, void **ppv)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CSomeObject*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pObj;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pUnkOuter != NULL &amp;&amp; riid != IID_IUnknown)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CLASS_E_NOAGGREGATION;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pObj = new CSomeObject(pUnkOuter);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pObj == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_OUTOFMEMORY;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set up the right unknown for delegation (the non-aggregation 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pUnkOuter == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pObj-&gt;m_pUnkOuter = (IUnknown*)pObj ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT hr;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr = pObj-&gt;QueryInterface(riid, (void**)ppv)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete pObj ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Implicit IUnknown members, non-delegating</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Implicit QueryInterface only controls inner object</b>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHODIMP QueryInterface(REFIID riid, void** ppv)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv=NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (riid == IID_IUnknown)&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv=this;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (riid == IID_ISomeInterface)&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ppv=&amp;m_ImpSomeInterface;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (NULL==*ppv)&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode(E_NOINTERFACE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((IUnknown*)*ppv)-&gt;AddRef();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NOERROR;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHODIMP_(DWORD) AddRef(void)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ++m_cRef; };
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHODIMP_(DWORD) Release(void)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (--m_cRef != 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_cRef;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete this;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
};
</code></pre>
<h2>Aggregating Objects</h2>
<p>
When developing an object that aggregates in another object, these rules must be followed:
<ul type=disc>
<li>
When creating the inner object, the outer object must explicitly ask for <b>IUnknown</b>.<br><br></li>
<li>
The outer object must protect its implementation of <b>Release</b> from reentrancy with an artificial reference count around its destruction code.<br><br></li>
<li>
The outer object must call its own outer unknown's <b>Release</b> if it queries for a pointer to any of the inner object's interfaces. To free this pointer, the outer object calls its own outer unknown's <b>AddRef</b> followed by <b>Release</b> on the inner object's pointer:<pre><code>// Obtaining inner object interface pointer
pUnkInner-&gt;QueryInterface(IID_IFoo, &amp;pIFoo);
pUnkOuter-&gt;Release();

// Releasing inner object interface pointer
pUnkOuter-&gt;AddRef();
pIFoo-&gt;Release();
</code></pre>
</li>
<li>
The outer object must not blindly delegate a query for any unrecognized interface of the inner object unless that behavior is specifically the intention of the outer object.</li>
</ul>
<h2>Apartment Threading Model</h2>
<p>
The details of apartment-model threading are actually quite simple, but must be followed carefully, as follows:</p>
<p>
Every object lives on a single thread (within a single apartment).
<ul type=disc>
<li>
All calls to an object must be made on its thread (within its apartment). It is forbidden to call an object directly from another thread. Applications that attempt to use objects in this free-threaded manner will likely experience problems that will prevent them from running properly in future versions of the operating systems. The implication of this rule is that <i>all </i>pointers to objects must be marshalled between apartments.<br><br></li>
<li>
Each apartment/thread with objects in it must have a message queue in order to handle calls from other processes and apartments within the same process. This means simply that the thread's work function must have a <b>GetMessage/DispatchMessage</b> loop. If other synchronization primitives are being used to communicate between threads, the Microsoft Win32® function <b>MsgWaitForMultipleObjects</b> can be used to wait for both messages and thread synchronization events.<br><br></li>
<li>
DLL-based or in-process objects must be marked in the registry as "apartment aware" by adding the named value "<b>ThreadingModel=Apartment</b>" to their <b>InprocServer32</b> key in the registration database.<br><br></li>
<li>
Apartment-aware objects must write DLL entry points carefully. Each apartment that calls <b>CoCreateInstance</b> on an apartment-aware object will call <b>DllGetClassObject</b> from its thread. <b>DllGetClassObject</b> should therefore be able to give away multiple class objects or a single thread-safe object. Calls to <b>CoFreeUnusedLibraries</b> from any thread always route through the main apartment's thread to call <b>DllCanUnloadNow</b>.</li>
</ul>
</BODY>
</HTML>
