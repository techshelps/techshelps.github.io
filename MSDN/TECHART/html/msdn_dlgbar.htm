<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using CDialogBar in 32-Bit MDI Applications</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_dlgbar"></a>Using CDialogBar in 32-Bit MDI Applications</h1>
<p>
Nigel Thompson<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: September 27, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3017">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the FWTEST sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3015">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the ANIMATE sample application.</a></p>
<h2>Abstract</h2>
<p>
This article describes how the <b>CDialogBar</b> class can be used to create Control Panel-like windows in a multiple document interface (MDI) application. A companion article, <a href="msdn_custctl.htm">"Simple Custom Controls for 32-Bit Visual C++ Applications,"</a> describes a simple way to include custom controls in the application without having to create a separate dynamic-link library (DLL) for each control. Applications built using the techniques described in these articles can be shipped as a single .EXE file without additional DLLs for the controls.</p>
<p>
FWTEST, the sample application that accompanies the articles, includes examples of two different Control Panel-like windows. One window uses standard Microsoft® Windows® controls and is discussed in this article. The other Control Panel-like example uses a variety of custom controls and is discussed in “Simple Custom Controls for 32-Bit Visual C++ Applications." The window that uses custom controls also uses a 256-color palette. The FWTEST samples use the ANIMATE library.</p>
<h2>Introduction</h2>
<p>
Multiple document interface (MDI) applications often need to do a little more than just show one or more views of a document. Often they need to be able to show other windows not related to the documents at all. I refer to these windows as "control panels" because that’s generally what I use them for—controlling some aspect of the application’s behavior. There are other cases when it’s useful to be able to create a simple window showing some data and containing a few controls. Again, these windows may have little or nothing to do with a particular document. Such a window might be showing the current weather forecast, for example, while the main part of the application is concerned with scheduling rock-climbing trips to Smith Rock (a common requirement &lt;grin&gt;). I like my applications to be colorful, and so I also wanted my control panels to be able to use a 256-color palette.</p>
<p>
The Microsoft® Foundation Class Library (MFC) provides the <b>CFormView</b> class as a way to use a dialog template to design a form. This is pretty close to what I want in a control panel, except that <b>CFormView</b> is derived from <b>CView</b> and is very closely tied to the whole template-document-view model. I did try using <b>CFormView</b> for my control panel windows. I generated a dummy document and template but got into all sorts of problems because this dummy document then becomes one of the options presented when the user chooses the File New command. I quickly decided that <b>CFormView</b> is for creating forms to edit documents and not for Nigel’s control panels.</p>
<p>
MFC also provides the <b>CDialogBar</b> class, which can be used effectively to add a modeless dialog bar to some part of a window. The dialog bar occupies some part of the window’s client area. Using <b>CDialogBar</b> looked very promising; if I could make the dialog bar occupy the entire client area, I’d have what I wanted. But life isn’t that easy. It turns out that <b>CDialogBar</b> is a little challenged (to be politically correct, for once) when it comes to scroll bars. If you add a scroll bar to a <b>CDialogBar</b> window, the scroll bar doesn’t work, although the other one or two problems with using <b>CDialogBar</b> to create a control panel window are solvable.</p>
<p>
What I'm looking for is a simple way to design and build windows that act like MDI child windows but are not related to the application’s documents, views, or templates. This technical article describes how the <b>CDialogBar</b> class can be used (with some help) to create control panel windows and how custom controls can be used to make them more appealing.</p>
<h2>The CDialogBar Class</h2>
<p>
The <b>CDialogBar</b> class is derived from <b>CControlBar</b>, which is derived from <b>CWnd</b>. Figure 1 shows the full derivation of <b>CDialogBar</b>.</p>
<p>
<img src="dlgbar_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The derivation of CDialogBar</b></p>
<p>
Notice that <b>CDialogBar</b> is <i>not</i> derived from <b>CDialog</b>. <b>CDialog</b>’s derivation is shown in Figure 2.</p>
<p>
<img src="dlgbar_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The derivation of CDialog</b></p>
<p>
The fact that <b>CDialogBar</b> is not derived from <b>CDialog</b> causes several problems when we try to create <b>CDialogBar</b> windows using App Studio and ClassWizard. ClassWizard can, for example, add a handler function for the OK button being clicked. Unfortunately, ClassWizard thinks we are creating a dialog box and adds the virtual function <b>OnOK</b> to the application source code. The problem is that <b>OnOK</b> is a member of <b>CDialog</b> and not <b>CDialogBar</b>, so when the user clicks the OK button, your code doesn’t get called. Another irritating problem with <b>CDialogBar</b> is that it doesn’t pass scroll bar messages to its parent, so if you add a scroll bar to the template, the scroll bar won’t work. </p>
<p>
In order to make implementing a panel full of controls a lot simpler, we need a new class or two. We need a new class derived from <b>CMDIChildWnd</b> to fix problems related to the handling of frame messages and one derived from <b>CDialogBar</b> to fix the problems with scroll bars.</p>
<h3>Naming New Classes</h3>
<p>
Naming new classes is always tough: The ideal name is usually already taken or means too many different things. I wanted to replace <b>CDialogBar</b> with some other meaningful name, yet retain its roots. Because the things I’m trying to create with the first new class are like instrument control panels, I called them <i>dialog panels</i> and called the class <b>CDlgPanel</b>. Because I needed a new frame to go around my new dialog panels, I called the second class <b>CDlgPanelFrame</b>.</p>
<h3>The Cure</h3>
<p>
Most of the problems with <b>CDialogBar</b> can be cured by deriving a new class from <b>CDialogBar</b> and overriding a few of <b>CDialogBar</b>’s functions. In the FWTEST sample application, the <b>CDlgPanel</b> class fixes the scroll bar problem and adds some other useful functionality, such as the ability to determine the size in pixels of the dialog template. The problems with the <b>OnOK</b> virtual function can be fixed by deriving a new frame window class from <b>CMDIChildWnd</b>. In FWTEST, this new class is called <b>CDlgPanelFrame</b>. We’ll look at the implementation of <b>CDlgPanel</b> and <b>CDlgPanelFrame</b> next. Figure 3 shows a test window from the FWTEST sample that includes a variety of Windows controls.</p>
<p>
<img src="dlgbar_3.gif" border=0></p>
<p class=label>
<b>Figure 3. A test control panel from the FWTEST sample</b></p>
<h2>CDlgPanel : public CDialogBar</h2>
<p>
The <b>CDlgPanel</b> class is derived publicly from <b>CDialogBar</b> and its primary function is to pass scroll bar messages to its parent window so that scroll bar controls in the dialog template will work correctly. As secondary functions, the <b>CDlgPanel</b> class also provides a convenient <b>Create</b> function, a mechanism for handling a palette, and a way to retrieve the dimensions of the dialog template in pixels. Here’s the class definition from DLGPANEL.H:</p>
<pre><code>class CDlgPanel : public CDialogBar
{
public:
 &nbsp;&nbsp; CDlgPanel();
 &nbsp;&nbsp; BOOL Create(CWnd* pParentWnd, UINT nIDTemplate,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nStyle, UINT nID, CPalette* pPal);
 &nbsp;&nbsp; void GetPanelRect(RECT* pRect);
 &nbsp;&nbsp; virtual ~CDlgPanel();
 &nbsp;&nbsp; virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

private:
 &nbsp;&nbsp; CPalette* m_pPal;
 &nbsp;&nbsp; UINT m_uiIDTemplate;

 &nbsp;&nbsp; //{{AFX_MSG(CDlgPanel)
 &nbsp;&nbsp; //}}AFX_MSG
 &nbsp;&nbsp; DECLARE_MESSAGE_MAP()
};
</code></pre>
<p>
Let’s see how the <b>Create</b> function works first:</p>
<pre><code>BOOL CDlgPanel::Create(CWnd* pParentWnd, UINT nIDTemplate,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT nStyle, UINT nID, CPalette* pPal)
{
 &nbsp;&nbsp; m_pPal = pPal;
 &nbsp;&nbsp; m_uiIDTemplate = nIDTemplate;
 &nbsp;&nbsp; BOOL b = CDialogBar::Create(pParentWnd, nIDTemplate,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nStyle, nID);
 &nbsp;&nbsp; if (!b) return FALSE;
 &nbsp;&nbsp; // Send all child windows and their children a message
 &nbsp;&nbsp; // containing the palette.
 &nbsp;&nbsp; SendMessageToDescendants(DLGPANELMSG_SETPALETTE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, (LPARAM) m_pPal, TRUE);
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
The <b>Create</b> function takes the parent window, template, and child window ID arguments and calls <b>CDialogBar::Create</b> to create the window. Having done that, it sends a message to all the child windows (the controls in the dialog) to let them know the palette that is being used. The DLGPANELMSG_SETPALETTE message is defined in DLGPANEL.H as:</p>
<pre><code>#define DLGPANELMSG_SETPALETTE (WM_USER+100)
</code></pre>
<p>
Obviously, the standard Windows controls don’t know a palette from a Book of the Month Club subscription (an equally dangerous and misunderstood object), but our own custom controls can make good use of this, as we’ll see shortly.</p>
<p>
I mentioned earlier that <b>CDialogBar</b> doesn’t support scroll bars. You can verify this by experiment or by looking in the MFC source code. The MFC\SRC\BARCORE.CPP file contains this code:</p>
<pre><code>LRESULT CControlBar::WindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
 &nbsp;&nbsp; ASSERT_VALID(this);

 &nbsp;&nbsp; // Parent notification messages are just passed to parent of control bar.
 &nbsp;&nbsp; switch (nMsg)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; case WM_COMMAND:
 &nbsp;&nbsp; case WM_DRAWITEM:
 &nbsp;&nbsp; case WM_MEASUREITEM:
 &nbsp;&nbsp; case WM_DELETEITEM:
 &nbsp;&nbsp; case WM_COMPAREITEM:
 &nbsp;&nbsp; case WM_VKEYTOITEM:
 &nbsp;&nbsp; case WM_CHARTOITEM:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ::SendMessage(::GetParent(m_hWnd), nMsg, wParam, lParam);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return CWnd::WindowProc(nMsg, wParam, lParam);
}
</code></pre>
<p>
This code is used to send control window notification messages to the parent (frame) window. As you can see, WM_HSCROLL and WM_VSCROLL are missing. I assume these were omitted because of problems with dialog bar frame windows that might have scroll bars of their own. In creating simple control panel windows, I don't want scroll bars in the frame window; therefore, the WM_HSCROLL and WM_VSCROLL messages must be coming from controls within the window rather than from scroll bars on the outside of the window. <b>CDlgPanel </b>overrides <b>CControlBar::WindowProc </b>to fix the problem:</p>
<pre><code>LRESULT CDlgPanel::WindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
 &nbsp;&nbsp; // Parent notification messages are just passed to parent of control bar.
 &nbsp;&nbsp; switch (nMsg)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; case WM_COMMAND:
 &nbsp;&nbsp; case WM_DRAWITEM:
 &nbsp;&nbsp; case WM_MEASUREITEM:
 &nbsp;&nbsp; case WM_DELETEITEM:
 &nbsp;&nbsp; case WM_COMPAREITEM:
 &nbsp;&nbsp; case WM_VKEYTOITEM:
 &nbsp;&nbsp; case WM_CHARTOITEM:
 &nbsp;&nbsp; case WM_HSCROLL:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // new
 &nbsp;&nbsp; case WM_VSCROLL:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // new
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ::SendMessage(::GetParent(m_hWnd), nMsg, wParam, lParam);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return CDialogBar::WindowProc(nMsg, wParam, lParam);
}
</code></pre>
<p>
That’s all it takes. Now you can add scroll bar controls to the dialog template, and they’ll work just fine.</p>
<p>
The final function that <b>CDlgPanel</b> provides is to return the dimensions of the dialog template in pixels. Dialog templates are created in dialog box units. Dialog box units are related to the size of the font used to create the dialog box. This relationship generally makes a lot of sense because if the user changes the system font, the dialogs and their controls are all resized to ensure that the text in the dialog box, on its buttons, and so on, still fits correctly. <b>CDlgPanel</b> includes the <b>GetPanelRect</b> function to return the dimensions of the dialog template:</p>
<pre><code>void CDlgPanel::GetPanelRect(RECT* pRect)
{
 &nbsp;&nbsp; // Load the dialog template.
 &nbsp;&nbsp; CDlgTemplate tpl(m_uiIDTemplate);
 &nbsp;&nbsp; ASSERT(pRect);
 &nbsp;&nbsp; tpl.GetDlgRect(pRect);
}
</code></pre>
<p>
Wow, that looks easy! But wait! What’s that <b>CDlgTemplate</b> thing?</p>
<h2>The CDlgTemplate Class</h2>
<p>
The <b>CDlgTemplate</b> class was written by Paul Oka, a consultant with Microsoft Consulting Services, and provides a vast number of dialog template functions. I’m using only one of those functions (<b>GetDlgRect</b>) here to get the template dimensions. The source code for the <b>CDlgTemplate</b> class is in the DLGTEMPL.H and DLGTEMPL.CPP files of the FWTEST sample. The class was written so that dialog templates could be used to design forms for an application. Each form consists of a number of Windows controls. The application itself builds the forms rather than calling the Windows dialog manager to create them so that the application can have more complete control.</p>
<p>
The constructor for the <b>CDlgTemplate</b> class takes the ID of the dialog-template resource. It opens the template and extracts from it various bits of information, such as the dialog base unit dimension, which is what I wanted in order to be able to compute the size of the window required to contain a given dialog template. The <b>GetDLUBaseUnits</b> function computes the value of the base units:</p>
<pre><code>void CDlgTemplate::GetDLUBaseUnits()
{
 &nbsp;&nbsp; HDC hDC = ::GetDC(NULL);
 &nbsp;&nbsp; int nWeight;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Round up to get better results (NigelT).
 &nbsp;&nbsp; // Note that this is still wrong for Lucida Console 8pt
 &nbsp;&nbsp; // for some unknown reason.
 &nbsp;&nbsp; int nHeight = (m_pDialogHeader-&gt;GetPointSize() *
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::GetDeviceCaps(hDC, LOGPIXELSY) + 36) / 72;
 &nbsp;&nbsp; TRACE("Font size: %d pt. Height: %d pixels", 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pDialogHeader-&gt;GetPointSize(), nHeight);
 &nbsp;&nbsp; CFont font;

 &nbsp;&nbsp; nWeight = FW_BOLD; // All dialogs use bold fonts (NigelT).
 &nbsp;&nbsp; font.CreateFont(-nHeight, 0, 0, 0, nWeight, 0, 0, 0, 0, 0, 0, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pDialogHeader-&gt;GetFaceName());

 &nbsp;&nbsp; HGDIOBJ hOldFont = ::SelectObject(hDC, font.m_hObject);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; TEXTMETRIC tm;
 &nbsp;&nbsp; ::GetTextMetrics(hDC, &amp;tm);
 &nbsp;&nbsp; m_cyBase = tm.tmHeight;

 &nbsp;&nbsp; TRACE("Font pitch and family: %4.4XH", tm.tmPitchAndFamily);
 &nbsp;&nbsp; if (tm.tmPitchAndFamily &amp; 0x01)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Proportional font
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("Dlg has prop font");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char szAveCharWidth[52];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Array to hold A-Z,a-z
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 26; i++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szAveCharWidth[i] = (char)(i + 'a');
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szAveCharWidth[i + 26] = (char)(i + 'A');
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIZE sizeExtent;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::GetTextExtentPoint(hDC, szAveCharWidth, 52, &amp;sizeExtent);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_cxBase = (sizeExtent.cx + 26) / 52;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("Dlg has fixed pitch font");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_cxBase = tm.tmAveCharWidth;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; TRACE("Dlg base units: %d x %d", m_cxBase, m_cyBase);
 &nbsp;&nbsp; ::SelectObject(hDC, hOldFont);
 &nbsp;&nbsp; ::ReleaseDC(NULL, hDC);
}
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This code is very similar to code in the Windows 3.1 dialog manager and works for almost all fonts. However, you should be aware than some fonts (Fixedsys, for example) give incorrect results. I have been unable to track down the cause of this despite digging in the Windows source code for some hours. The problem seems to be the way the size of the average character is rounded up. All the errors I have found corresponded to either the computed height or width being off by one pixel. Should the solution to this bug be found, I’ll add it to the MSDN Library in a subsequent article.</p>
<h2>CDlgPanelFrame : public CMDIChildWnd</h2>
<p>
Now that we have a fixed version of <b>CDialogBar</b>, we need to see how to create a new MDI child window that has a <b>CDlgTemplate</b> window filling its entire client area. Once we’ve done that, we’ll have all that’s required to create a control panel like the one shown in Figure 3.</p>
<p>
Recall that I mentioned earlier that the default OK and Cancel button handlers, <b>OnOK</b> and <b>OnCancel</b>, are not members of <b>CDialogBar</b>. We can fix this problem in the frame window we will use to handle the notification messages from the dialog panels we create. To do this, we derive a new class from <b>CMDIChildWnd</b>. In FWTEST this new class is called <b>CDlgPanelFrame</b>. <b>CDlgPanelFrame</b>’s primary function is to handle the <b>OnOK</b> and <b>OnCancel</b> functions. It also provides a convenient <b>Create</b> function and an <b>OnSize</b> handler to conveniently set the size of the frame window to fit the size of the dialog panel within it. Doing this in an <b>OnSize</b> function might seem a bit bizarre, but I find it works well and is easy to find in the source code later when you’ve forgotten how it all works. Here’s the definition of the class from DLGPANFM.H:</p>
<pre><code>class CDlgPanelFrame : public CMDIChildWnd
{
 &nbsp;&nbsp; DECLARE_DYNCREATE(CDlgPanelFrame)
public:
 &nbsp;&nbsp; CDlgPanelFrame(); 
 &nbsp;&nbsp; BOOL Create(LPCSTR lpszWindowName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const RECT&amp; rect,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMDIFrameWnd* pParentWnd,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT uiTemplateID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT uiResourceID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPalette* pPal = NULL);

// Implementation
protected:
 &nbsp;&nbsp; CPalette* m_pPal;
 &nbsp;&nbsp; CDlgPanel m_wndPanel;
 &nbsp;&nbsp; UINT m_uiTemplateID;

 &nbsp;&nbsp; virtual ~CDlgPanelFrame();

 &nbsp;&nbsp; // Generated message map functions
 &nbsp;&nbsp; //{{AFX_MSG(CDlgPanelFrame)
 &nbsp;&nbsp; afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
 &nbsp;&nbsp; afx_msg void OnSize(UINT nType, int cx, int cy);
 &nbsp;&nbsp; virtual void OnOK();
 &nbsp;&nbsp; virtual void OnCancel();
 &nbsp;&nbsp; //}}AFX_MSG
 &nbsp;&nbsp; DECLARE_MESSAGE_MAP()
};
</code></pre>
<p>
Notice the member variables for keeping track of the current palette and the <b>CDlgPanel</b> object, which will occupy the entire client area. Let’s begin with a look at the <b>Create</b> function from DLGPANFM.CPP:</p>
<pre><code>BOOL CDlgPanelFrame::Create(LPCSTR lpszWindowName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const RECT&amp; rc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMDIFrameWnd* pParentWnd,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT uiTemplateID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT uiResourceID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPalette* pPal/*= NULL*/)
{
 &nbsp;&nbsp; m_pPal = pPal;
 &nbsp;&nbsp; m_uiTemplateID = uiTemplateID;

 &nbsp;&nbsp; // Create the window with a caption and just a thin border.
 &nbsp;&nbsp; return CMDIChildWnd::Create(GetIconWndClass(WS_CHILD|WS_VISIBLE|WS_OVERLAPPEDWINDOW,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uiResourceID),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszWindowName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_CHILD|WS_VISIBLE|WS_OVERLAPPED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |WS_CAPTION|WS_BORDER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pParentWnd);
}
</code></pre>
<p>
The <b>Create</b> function stores the palette and template ID for use later and then calls the base class to create the window. The <i>uiResourceID</i> parameter is used to load an appropriate icon for this window. The undocumented MFC function <b>GetIconWndClass</b> is used to obtain the name of a suitable window class based on the style of the window and the supplied icon. Note that I have chosen to omit a system menu and the Maximize and Minimize buttons. This is simply because I happened to want the windows to look that way in my application (see Figure 3). You can alter this to your own taste or include a <i>dwStyle</i> parameter for more flexibility.</p>
<p>
<b>CDlgPanelFrame</b> includes a handler for WM_CREATE messages that is called as a part of the window creation process:</p>
<pre><code>int CDlgPanelFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
 &nbsp;&nbsp; if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Create the dialog panel.
 &nbsp;&nbsp; // Note that we send them the palette we are using.
 
 &nbsp;&nbsp; ASSERT(m_uiTemplateID);
 &nbsp;&nbsp; if (!m_wndPanel.Create(this,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_uiTemplateID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CBRS_TOP,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, // Child ID
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pPal)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("Failed to create panel from template");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; return 0;
}
</code></pre>
<p>
<b>OnCreate</b> creates the panel window from the dialog template ID supplied to the <b>Create</b> function. Note that I have used the CBRS_TOP flag here, but that since the panel will occupy the entire client area, it is not relevant. Also note that the palette is passed down to the panel window (which passes it to its control windows).</p>
<p>
<b>CDlgPanelFrame </b>also includes a handler for WM_SIZE messages:</p>
<pre><code>void CDlgPanelFrame::OnSize(UINT nType, int cx, int cy)
{
 &nbsp;&nbsp; CMDIChildWnd::OnSize(nType, cx, cy);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Get the size of the panel and resize the parent frame to fit.
 &nbsp;&nbsp; CRect rcPanel;
 &nbsp;&nbsp; m_wndPanel.GetPanelRect(&amp;rcPanel);
 &nbsp;&nbsp; if ((cx == rcPanel.right) &amp;&amp; (cy == rcPanel.bottom)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; CRect rcWnd;
 &nbsp;&nbsp; GetWindowRect(&amp;rcWnd);
 &nbsp;&nbsp; rcWnd.right -= cx - rcPanel.right;
 &nbsp;&nbsp; rcWnd.bottom -= cy - rcPanel.bottom;
 &nbsp;&nbsp; SetWindowPos(NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcWnd.right - rcWnd.left,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcWnd.bottom - rcWnd.top,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOMOVE); 
}
</code></pre>
<p>
Using <b>OnSize</b> in this way is a little strange in as much as the window will resize itself to fit the size of the dialog template. This works well in practice, so I have left it this way. It helps me keep track of all the sizing code having it here, but you are welcome to do your own thing if you find this too weird.</p>
<p>
The final functions in <b>CDlgPanelFrame </b>serve simply as reminders that the <b>OnOK </b>and <b>OnCancel </b>functions need to be implemented in any class you derive from <b>CDlgPanelFrame</b> if you have OK and Cancel buttons.</p>
<pre><code>void CDlgPanelFrame::OnOK()
{
 &nbsp;&nbsp; TRACE("No OnOK handler in your derived class");
}

void CDlgPanelFrame::OnCancel()
{
 &nbsp;&nbsp; TRACE("No OnCancel handler in your derived class");
}
</code></pre>
<h2>Using CDlgPanelFrame</h2>
<p>
The FWTEST sample includes the files PANELFRA.H and PANELFRA.CPP as an example of how to use the <b>CDlgPanelFrame</b> class. The code in these files implements the panel shown in Figure 3. Note that the panel includes OK and Cancel buttons, scroll bars, and a combo box. We’ve discussed what it takes to make the OK and Cancel buttons and the scroll bars work, but the combo box needs a little help, too.</p>
<h3>The Trouble with Combo Boxes</h3>
<p>
I like to use combo boxes with the CBS_DROPDOWNLIST style for many purposes. However, when used as controls in a dialog box, they have one major failing: When the user clicks a new selection from the list, the application gets a CBN_SELCHANGE message <i>before</i> the text of the static part of the control has changed, and no CBN_EDITCHANGE message is sent at all. This means that you have to treat this type of combo box as a special case. Normally when the edit window of a combo box is altered, the application gets a CBN_EDITCHANGE message, and the application can simply call <b>GetWindowText</b> to retrieve the new text. Fortunately, there is a very simple cure for this problem: On receiving a CBN__SELCHANGE message, simply post a CBN_EDITCHANGE message back to the same window. Note that we <i>post</i> the message, not <i>send</i> it, so that it will be placed in the message queue and processed after the combo box has actually updated its window text. Here’s the code from PANELFRA.CPP that does this:</p>
<pre><code>void CPanelFrame::OnSelchangeCombo()
{
 &nbsp;&nbsp; // Handle the CBN_SELCHANGE messages by converting them to 
 &nbsp;&nbsp; // CBN_EDITCHANGE messages.
 &nbsp;&nbsp; // CBN_SELCHANGE occurs before the edit window text has changed, and
 &nbsp;&nbsp; // combo boxes of the drop-down-list style don't send CBN_EDITCHANGE
 &nbsp;&nbsp; // messages, so we post the CBN_EDITCHANGE message to ourselves.

 &nbsp;&nbsp; PostMessage(WM_COMMAND,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAKEWPARAM(IDC_COMBO, CBN_EDITCHANGE),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPARAM)(m_wndPanel.GetDlgItem(IDC_COMBO)-&gt;m_hWnd));
}
</code></pre>
<p>
Unfortunately, we can’t handle this message translation transparently in the <b>CDlgPanelFrame</b> class because we can’t tell if it’s a combo box or a list box that is sending the message, and the SELCHANGE and EDITCHANGE messages have different values for combo and list boxes. So you simply have to add this simple function to the class you derive from <b>CDlgPanelFrame</b>.</p>
<h2>More Exciting Controls</h2>
<p>
The standard Windows controls are functional but not too stunning to look at. If you’d like to see something a little more jazzy in your application, read <a href="msdn_custctl.htm">"Simple Custom Controls for 32-Bit Visual C++ Applications,"</a> which explains how to include custom controls in your application without the pain of creating dynamic-link libraries for each control.</p>
<h2>Final Tips</h2>
<p>
As a finishing touch, I thought I’d pass on a few other tips that relate to using the dialog panels.</p>
<p>
Watch out for <b>CWnd::GetDlgItem</b>, which returns a <i>temporary</i> <b>CWnd</b> object pointer. Don’t store it for use later; you must get it every time you want it. Because you often want to get a pointer to a control object, you might want to add some helper functions to <b>CDlgPanelFrame</b>, such as <b>GetDlgItem(UINT uiCtlID)</b>. This saves you from having to use <b>m_wndPanel.GetDlgItem(<i>id</i>)</b> in your frame code. </p>
<p>
More information on handling user-defined messages, such as the one I used to send palette information to the control windows, can be found in the "User Defined Windows Messages" section of "Technical Note 6: Message Maps" [Technical Articles, Visual C++ 1.0 (32-bit), MFC 2.0 (32-bit) Technical Notes].</p>
</BODY>
</HTML>
