<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tip 55: Diagnosing "Error in Loading DLL" with LoadLibrary</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_msdn55"></a></sup>Tip 55: Diagnosing "Error in Loading DLL" with LoadLibrary</h1>
<p>
Created: April 17, 1995</p>
<h2>Abstract</h2>
<p>
When developing applications in Visual Basic® that run on different computer systems, you must process error conditions such as missing dynamic-link library (.DLL) files. The Windows® application programming interface (API) <b>LoadLibrary</b>, <b>FreeLibrary</b>, and <b>SetErrorMode</b> functions can be used to create an error-handling routine that will capture and process the "Error in Loading DLL" error message returned when Windows cannot find the specified .DLL file on the target machine. This article explains how your application can determine if a .DLL is on the user's system.</p>
<h2>Trapping Errors When DLLs Are Missing</h2>
<p>
When an application calls a function in a dynamic-link library (.DLL) file, it loads the .DLL into memory and executes the specified function. However, if the .DLL file does not exist on the user's machine, Windows® responds by displaying an "Error in loading DLL" error message.</p>
<p>
In a Visual Basic® application, you can write your own routine to determine if the specified .DLL file exists and prevent Windows from generating its own critical error message (Int 24h). This can be done by using the Windows application programming interface (API) <b>LoadLibrary</b>, <b>FreeLibrary</b>, and <b>SetErrorMode</b> functions.</p>
<p>
The <b>LoadLibrary</b> function loads the specified .DLL into memory. To use this function in your Visual Basic program, include the following <b>Declare</b> statement in the General Declarations section of your form:</p>
<pre><code>Declare Function LoadLibrary Lib "Kernel" (ByVal f$) As Integer
</code></pre>
<p>
The <b>LoadLibrary</b> function requires only one argument—the name of the library file you want to load. After calling this function, <b>LoadLibrary</b> returns an integer value that contains the instance handle of the .DLL or an error code (the value returned is less than 32, indicating an error has occurred). The following error codes and their meanings are returned by the LoadLibrary function.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=8%>0</td>
<td width=92%>System was out of memory, executable file was corrupt, or relocations were invalid.</td>
</tr>
<tr valign=top>
<td width=8%>2</td>
<td width=92%>File was not found.</td>
</tr>
<tr valign=top>
<td width=8%>3</td>
<td width=92%>Path was not found</td>
</tr>
<tr valign=top>
<td width=8%>5</td>
<td width=92%>Attempt was made to dynamically link to a task, or there was a sharing or network-protection error.</td>
</tr>
<tr valign=top>
<td width=8%>6</td>
<td width=92%>Library required separate data segments for each task.</td>
</tr>
<tr valign=top>
<td width=8%>8</td>
<td width=92%>There was insufficient memory to start the application.</td>
</tr>
<tr valign=top>
<td width=8%>10</td>
<td width=92%>Windows version was incorrect.</td>
</tr>
<tr valign=top>
<td width=8%>11</td>
<td width=92%>Executable file was invalid. Either it was not a Windows-based application or there was an error in the .EXE image.</td>
</tr>
<tr valign=top>
<td width=8%>12</td>
<td width=92%>Application was designed for a different operating system.</td>
</tr>
<tr valign=top>
<td width=8%>13</td>
<td width=92%>Application was designed for MS-DOS® version 4.0.</td>
</tr>
<tr valign=top>
<td width=8%>14</td>
<td width=92%>Type of executable file was unknown.</td>
</tr>
<tr valign=top>
<td width=8%>15</td>
<td width=92%>Attempt was made to load a real-mode application (developed for an earlier version of Windows).</td>
</tr>
<tr valign=top>
<td width=8%>16</td>
<td width=92%>Attempt was made to load a second instance of an executable file containing multiple data segments that were not marked read-only.</td>
</tr>
<tr valign=top>
<td width=8%>19</td>
<td width=92%>Attempt was made to load a compressed executable file. The file must be decompressed before it can be loaded.</td>
</tr>
<tr valign=top>
<td width=8%>20</td>
<td width=92%>Dynamic-link library (.DLL) file was invalid. One of the .DLLs required to run this application was corrupt.</td>
</tr>
<tr valign=top>
<td width=8%>21</td>
<td width=92%>Application requires Microsoft® Windows 32-bit extensions.</td>
</tr>
</table><br>
<p>
The Windows API <b>FreeLibrary</b> function unloads a previously loaded .DLL. The <b>FreeLibrary</b> function should be called after you have tried to load a .DLL file with the <b>LoadLibrary</b> function. This function's declaration statement is as follows:</p>
<pre><code>Declare Sub FreeLibrary Lib "Kernel" (ByVal h As Integer)
</code></pre>
<p>
To unload a .DLL from memory, you simply call the <b>FreeLibrary</b> function with the module's instance handle.</p>
<p>
If your Visual Basic application attempts to load a .DLL that does not exist, Windows will respond with a critical-error-handler message box. You can use the Windows API <b>SetErrorMode</b> function to tell Windows to handle the error or to tell Windows that your program will process the error condition itself. The declaration statement for <b>SetErrorMode</b> is as follows:</p>
<pre><code>Declare Function SetErrorMode Lib "Kernel" (ByVal wMode As Integer) As Integer
</code></pre>
<p>
This function requires only one argument: a constant value that tells Windows how to handle Interrupt 24h errors. The value you pass to <b>SetErrorMode</b> may be a combination of these values:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=35%>SEM_FAILCRITICALERRORS</td>
<td width=65%>Windows does not display the critical-error-handler message box and so returns the error to the calling application.</td>
</tr>
<tr valign=top>
<td width=35%>SEM_NOGPFAULTERRORBOX</td>
<td width=65%>Windows does not display the general-protection-fault message box. This flag should be set only by debugging applications that handle GP faults themselves.</td>
</tr>
<tr valign=top>
<td width=35%>SEM_NOOPENFILERRORBOX</td>
<td width=65%>Windows does not display a message box when it fails to find a file.</td>
</tr>
</table><br>
<p>
After calling the <b>SetErrorMode</b> function, an integer value is returned. This value is the previous state of the error-mode flag.</p>
<p>
In a Visual Basic application, you can use the <b>SetErrorMode</b> function in conjunction with the <b>LoadLibrary</b> and <b>FreeLibrary</b> functions to determine if a user's system has the .DLL files your program needs.</p>
<h2>Example Program</h2>
<p>
The following program shows how to trap Error Code 48, "Error in loading DLL", from within your Visual Basic application.
<ol>
<li>
Create a new project in Visual Basic. Form1 is created by default.<br><br></li>
<li>
Add the following <b>Declare</b> statements to the General Declarations section of Form1 (note that each <b>Declare</b> statement must be typed as a single line of text):<pre><code>Declare Function LoadLibrary Lib "Kernel" (ByVal f$) As Integer
Declare Sub FreeLibrary Lib "Kernel" (ByVal h As Integer)
Declare Function SetErrorMode Lib "Kernel" (ByVal wMode As Integer) As Integer
</code></pre>
</li>
<li>
Add the following code to the Form_Load event for Form1:<pre><code>Sub Form_Load()
  Dim NameofDLL As String
  Dim IsThere As Integer
  Dim ErrNumber As Integer
  Dim ErrText As String
 &nbsp;&nbsp; 
  NameofDLL = "kernel.dll"
  IsThere = DoesLibraryExist(NameofDLL, ErrNumber, ErrText)
 &nbsp;&nbsp; 
  If IsThere = True Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text1.Text = "DLL exists!"
 &nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp; text1.Text = Str$(ErrNumber) + " " + ErrText
  End If
 &nbsp;&nbsp; 
End Sub
</code></pre>
</li>
<li>
Add a <b>Text Box</b> control to Form1. Text1 is created by default.<br><br></li>
<li>
Create a new function called <b>DoesLibraryExist</b>. Add the following code to this function (note that the first line, the OriginalErrorValue% lines, and all Explain$ lines must be typed as a single line of code):<pre><code>Function DoesLibraryExist(DllName$, ErrorReturned%, ErrorExplanation$)
 &nbsp; As Integer
Dim hInst As Integer
Dim ReturnValue As Integer
Dim Explain$
Dim OriginalErrorValue%
Const SEM_NOOPENFILEERRORBOX = &amp;H8000
Const SEM_FAILCRITICALERRORS = &amp;H1

  ReturnValue = True
  OriginalErrorValue% = SetErrorMode(SEM_NOOPENFILEERRORBOX Or 
 &nbsp;&nbsp;&nbsp; SEM_FAILCRITICALERRORS)
  hInst = LoadLibrary(DllName$)
  OriginalErrorValue% = SetErrorMode(OriginalErrorValue)
  If hInst &gt; 32 Then
 &nbsp;&nbsp;&nbsp; ReturnValue = True
 &nbsp;&nbsp;&nbsp; FreeLibrary (hInst)
  Else
 &nbsp;&nbsp;&nbsp; ReturnValue = False
 &nbsp;&nbsp;&nbsp; Select Case hInst
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 0
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "System is out of memory, executable file is corrupt, or 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relocations are invalid."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 2
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "File not found."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 3
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "Path not found."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 5
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "Sharing or network protection error."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 6
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "Library required separate data segments for each task."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 8
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "Insufficient memory."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 10
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "Incorrect Windows version."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 11
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "It was either not a Windows application or there was an 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error in the file."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 12
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "It was designed for a different operating system."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 13
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "It was designed for MS-DOS 4.0."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 14
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "File type unknown."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 15
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "The file was designed for an earlier Version of Windows."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 16
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "An attempt was made to load a second instance of an 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; executable file containing multiple data segments not marked 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read-only."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 19
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "Attempt was made to load a compressed file. It must be 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decompressed before it can be loaded."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 20
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "DLL file is invalid. This file or one called by it is
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; corrupt."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 21
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "The file requires Microsoft Windows 32-bit extensions."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Explain$ = "The reason it wouldn't load is unclear. Error code " &amp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Trim(Str(hInst)) &amp; "."
 &nbsp;&nbsp;&nbsp; End Select
 &nbsp;&nbsp;&nbsp; ErrorReturned = Int(hInst)
 &nbsp;&nbsp;&nbsp; ErrorExplanation$ = Explain$
  End If
DoesLibraryExist = ReturnValue
End Function
</code></pre>
</li>
</ol>
<p>
When you run this program, it should display the message "DLL Exists" in the Text Box. Change the <i>NameofDLL</i> string variable to "WIN.COM" and run the application a second time. You should receive an error number and error message in the Text Box because there is no .DLL file by the name of WIN.COM.</p>
</BODY>
</HTML>
