<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Enhanced Metafiles in Win32</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_enhmeta"></a></sup>Enhanced Metafiles in Win32</h1>
<p>
Dennis Crain<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: June 10, 1993</p>
<h2>Abstract</h2>
<p>
With the advent of the Microsoft® Win32™ Application Programming Interface (API), a new metafile format called <i>enhanced metafiles</i> has been introduced. The overall design goal of the enhanced metafile was to describe a picture without any coding restrictions and to make a metafile easier to use. Enhanced metafiles have many advantages over the older Windows metafiles found in Microsoft Windows™ version 3.1 (Win16). Improvements found in the enhanced metafile include an expanded header, a description string, a metafile palette, and an increase in the number and type of graphics device interface (GDI) functions that may be recorded. In addition to these enhancements, the metafile record and playback code in Win32 has been designed to remove all of the restrictions that applied to Windows metafiles with respect to scaling, clipping, embedding, and querying, among others. To top it off, enhanced metafiles may be played on any device in a device-independent manner. This article describes the differences between Windows metafiles and enhanced metafiles. Sample code that illustrates the basic concepts of creating and playing enhanced metafiles is provided at the end of this article.</p>
<h2>Introduction</h2>
<p>
The tried-and-true Microsoft® Windows™ metafile has been an invaluable aid to the development of numerous drawing and presentation applications for Windows. However, the "vanilla" Windows metafile did not address issues related to scalability and device independence. Left on their own, developers attempted to address this issue in various ways. Some developers embedded application, location, or scaling comments in the metafiles. This resulted in extremely nonportable metafiles. Others added headers to the metafile that provided various application-specific information. The net result of most of these efforts was, once again, nonportable metafiles. However, one of these endeavors—<i>placeable metafiles</i>—caught on. Developed by Aldus Corporation, placeable metafiles include a 22-byte header that provides, among other things, mapping and measurement information that can be used to scale the metafile.</p>
<p>
The proliferation of the placeable metafile, other homegrown formats, and the confusion of many developers regarding the use of metafiles led to a demand for a metafile format that addressed all of the development community's needs. Thus the Win32 enhanced metafile was born. Developed by Microsoft, the enhanced metafile distinguishes itself from the Windows metafile in that it is device-independent and much easier to use. Easier to use? You bet! Remember having to code two paths to deal with drawing? One code path drew to the screen; the second code path drew to metafiles. The only way to get around this was to use a subset of graphics device interface (GDI) functions that used logical coordinates. Although this permitted limited scaling capabilities, it restricted the use of many helpful GDI functions. You definitely couldn't query the metafile device context (DC) for information such as window origins and extents. With the advent of the enhanced metafile, those restrictions are unnecessary! A single code path is all that is required to draw to any DC, whether it be a metafile, screen, or printer DC. Furthermore, you no longer need to use a subset of GDI; for example, you can now do the following:</p>
<pre><code>DeleteObject(SelectObject(hdcMeta, hbrOldBrush));
</code></pre>
<p>
Yes, the old object versus TRUE or FALSE is returned by <b>SelectObject</b> when used with a metafile DC. This was not possible with Windows metafiles and is a good indication of the potential for success of the enhanced metafile. Finally, in an enhanced metafile, you can query the current position in the client area.</p>
<p>
But what about all of those Windows metafiles? There are thousands of them in the marketplace. It would be a shame to see them go to waste. With this in mind, Win32 functions were written that convert Windows metafiles to enhanced metafiles. However, enhanced metafiles cannot be used in Win16. Figure 1 illustrates the compatibility of the two metafile formats and environments.</p>
<p>
<img src="enhmeta_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Metafile compatibility in the Win16 and Win32 environments</b></p>
<p>
This article discusses the differences between the Windows metafile and the enhanced metafile, the format of the enhanced metafile, its features, and techniques for its use. </p>
<h2>Windows Metafiles vs. Enhanced Metafiles</h2>
<p>
A Windows metafile is used for applications written using the Windows version 3.<i>x</i> application programming interface (API). The format of a Windows metafile consists of a header and an array of metafile records. Windows metafiles are limited in their capabilities and should rarely be used in Win32-based applications. That being said, the Windows metafile functions are supported in Win32 to maintain backward compatibility with applications that use the older Windows metafiles.</p>
<p>
An enhanced metafile is used in applications written using the Win32 API. (Win32s™, however, does <i>not</i> implement enhanced metafiles.) The enhanced format consists of a header, a table of handles to GDI objects, a private palette, and an array of metafile records. Enhanced metafiles provide true device independence. You can think of the picture stored in an enhanced metafile as a snapshot of the video display taken at a particular moment. This snapshot maintains its dimensions no matter where it appears: on a printer, a plotter, the desktop, or in the client area of any Win32-based application.</p>
<h3>Metafile Structure</h3>
<p>
At first glance, Windows metafiles and enhanced metafiles share the same overall structure. They are an array of variable-length structures called metafile records. The first records in the metafile specify general information such as the resolution of the device on which the picture was created, the dimensions of the picture, and so on. The remaining records, which constitute the bulk of any metafile, correspond to the GDI functions required to draw the picture.</p>
<p>
A closer inspection reveals a number of differences between them, as shown in Figure 2. Unlike the Windows metafile, the enhanced metafile has a different header and may include a description string and an optional palette stored in a special end-of-file record. The enhanced metafile also provides support for additional types of records.</p>
<p>
<img src="enhmeta_2.gif" border=0> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src="enhmeta_3.gif" border=0></p>
<p class=label>
<b>Figure 2. Structure of a Windows metafile and an enhanced metafile</b></p>
<h4>Enhanced metafile header</h4>
<p>
The major difference between the Windows metafile header and the enhanced metafile header is that the Windows metafile header contains only size and version information, whereas the enhanced metafile header contains dimension and resolution information, as well as size and version information. The Windows metafile header has the following form:</p>
<pre><code>typedef struct tagMETAHEADER {
 &nbsp;&nbsp; WORD&nbsp; mtType;
 &nbsp;&nbsp; WORD&nbsp; mtHeaderSize;
 &nbsp;&nbsp; WORD&nbsp; mtVersion;
 &nbsp;&nbsp; DWORD mtSize;
 &nbsp;&nbsp; WORD&nbsp; mtNoObjects;
 &nbsp;&nbsp; DWORD mtMaxRecord;
 &nbsp;&nbsp; WORD&nbsp; mtNoParameters;
} METAHEADER;
</code></pre>
<p>
In contrast, notice the added dimension and resolution information in the code for an enhanced metafile header below. This information is used by the metafile playback functions to achieve device independence.</p>
<pre><code>typedef struct tagENHMETAHEADER
{
  DWORD&nbsp;&nbsp; iType;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Record type EMR_HEADER.
  DWORD&nbsp;&nbsp; nSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Record size in bytes. This may be greater
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // than the sizeof(ENHMETAHEADER).
  RECTL&nbsp;&nbsp; rclBounds;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Inclusive-inclusive bounds in device units.
  RECTL&nbsp;&nbsp; rclFrame;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Inclusive-inclusive Picture Frame of 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // metafile in .01 mm units. 
  DWORD&nbsp;&nbsp; dSignature;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Signature.&nbsp; Must be ENHMETA_SIGNATURE.
  DWORD&nbsp;&nbsp; nVersion;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Version number.
  DWORD&nbsp;&nbsp; nBytes;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Size of the metafile in bytes.
  DWORD&nbsp;&nbsp; nRecords;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of records in the metafile.
  WORD&nbsp;&nbsp;&nbsp; nHandles;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of handles in the handle table.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle index zero is reserved.
  WORD&nbsp;&nbsp;&nbsp; sReserved;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved.&nbsp; Must be zero.
  DWORD&nbsp;&nbsp; nDescription;&nbsp;&nbsp;&nbsp; // Number of chars in the unicode description string.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This is 0 if there is no description string.
  DWORD&nbsp;&nbsp; offDescription;&nbsp; // Offset to the metafile description record.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This is 0 if there is no description string.
  DWORD&nbsp;&nbsp; nPalEntries;&nbsp;&nbsp;&nbsp;&nbsp; // Number of entries in the metafile palette.
  SIZEL&nbsp;&nbsp; szlDevice;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Size of the reference device in pixels. 
  SIZEL&nbsp;&nbsp; szlMillimeters;&nbsp; // Size of the reference device in millimeters.
} ENHMETAHEADER;
</code></pre>
<p>
A good question at this point might be, "How much of the header information in the enhanced metafile do I need to provide?" When you call <b>CreateEnhMetafile</b>, you provide a long pointer to a rectangle that specifies the picture frame, and you provide a DC that serves as a reference. The members <b>szlDevice</b> and <b>szlMillimeters</b> are derived from the reference DC. You can also provide a long pointer to a string that describes the metafile.</p>
<p>
<b>rclFrame</b></p>
<p>
The picture frame is stored in the metafile header structure member <b>rclFrame</b>. When you create the metafile using <b>CreateEnhMetaFile</b>, a pointer to a <b>RECT</b> structure (<i>lpRect</i>) is among the parameters. It is this rectangle that specifies the picture frame. The left and top members of the <b>RECT</b> structure must be values less than the right and bottom members, respectively. Points along the edges of the rectangle are included in the picture. If <i>lpRect</i> is NULL, GDI computes the dimensions of the smallest rectangle that surrounds the picture. The <i>lpRect</i> parameter should be provided whenever possible.</p>
<p>
<b>nDescription and offDescription</b></p>
<p>
Information regarding the description string is maintained in two structure members of the metafile header, <b>nDescription</b> and <b>offDescription</b>. This string is also specified when you create the metafile using <b>CreateEnhMetaFile</b>. The <i>lpDescription</i> parameter contains the address of the description string. When the metafile is created, the length of the description string is stored in the metafile header. When the metafile is closed, GDI writes the string to the metafile and updates <b>offDescription</b> in the header.</p>
<p>
<b>nPalEntries</b></p>
<p>
As palettes are created and selected into a metafile DC, GDI accumulates the palette entries and places them in a "metafile palette." This palette is located in the <b>EMR_EOF</b> record. An application can store the palette in an enhanced metafile by calling either the <b>CreatePalette</b> or <b>SetPaletteEntries</b> function and the <b>SelectPalette</b> function before creating the picture. <b>nPalEntries</b> is updated as the palette is collected in the metafile palette.</p>
<h4>Enhanced metafile records</h4>
<p>
The Windows metafile record and the enhanced metafile record are similar in structure and size (see code below). However, before breathing a sigh of relief, take a closer look at the record structure. The size and type members are reversed. This could be a potential pitfall when porting existing 16-bit Windows-based applications to Win32. Take note that the array of parameters is now an array of <b>DWORD</b> values to accommodate the 32-bit girth of GDI.</p>
<pre><code>typedef struct tagMETARECORD
  {
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rdSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Record size in bytes
 &nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rdFunction;&nbsp;&nbsp;&nbsp; // Record type META_XXX
 &nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rdParm[1];&nbsp;&nbsp;&nbsp;&nbsp; // WORD array of parameters
  } METARECORD;
</code></pre>
<pre><code>typedef struct tagENHMETARECORD
{
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; iType;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Record type EMR_XXX
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; nSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Record size in bytes
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; dParm[1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DWORD Array of parameters
} ENHMETARECORD;
</code></pre>
<p>
Several new metafile records have been added to an already extensive list of records. Table 1 lists the records found in enhanced metafile records with their corresponding <b>iType</b> values, which can be found in <b>WINGDI.H</b>. Some of the records seem to be similar, for example, <b>EMR_EXTTEXTOUTA</b> and <b>EMR_EXTTEXTOUTW</b>. The <i>A</i> specifies that the text is based on ANSI and the <i>W</i> indicates that it is based on UNICODE. Another similar pair is <b>EMR_POLYLINE</b> and <b>EMR_POLYLINE16</b>. The 16 indicates that GDI has converted the points for <b>PolyLine</b> to 16 bits for the purpose of saving space in the metafile.</p>
<p class=label>
<b>Table 1. Enhanced Metafile Records</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>Record</b></td>
<td class=label width=12%><b>Value</b></td>
<td class=label width=35%><b>Record</b></td>
<td class=label width=11%><b>Value</b></td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_ABORTPATH</code></pre>
</td>
<td width=12%><pre><code>68</code></pre>
</td>
<td width=35%><pre><code>EMR_POLYLINE</code></pre>
</td>
<td width=11%><pre><code>4</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_ANGLEARC</code></pre>
</td>
<td width=12%><pre><code>41</code></pre>
</td>
<td width=35%><pre><code>EMR_POLYLINE16</code></pre>
</td>
<td width=11%><pre><code>87</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_ARC</code></pre>
</td>
<td width=12%><pre><code>45</code></pre>
</td>
<td width=35%><pre><code>EMR_POLYLINETO</code></pre>
</td>
<td width=11%><pre><code>6</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_ARCTO</code></pre>
</td>
<td width=12%><pre><code>55</code></pre>
</td>
<td width=35%><pre><code>EMR_POLYLINETO16</code></pre>
</td>
<td width=11%><pre><code>89</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_BEGINPATH</code></pre>
</td>
<td width=12%><pre><code>59</code></pre>
</td>
<td width=35%><pre><code>EMR_POLYPOLYGON</code></pre>
</td>
<td width=11%><pre><code>8</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_BITBLT</code></pre>
</td>
<td width=12%><pre><code>76</code></pre>
</td>
<td width=35%><pre><code>EMR_POLYPOLYGON16</code></pre>
</td>
<td width=11%><pre><code>91</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_CHORD</code></pre>
</td>
<td width=12%><pre><code>46</code></pre>
</td>
<td width=35%><pre><code>EMR_POLYPOLYLINE</code></pre>
</td>
<td width=11%><pre><code>7</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_CLOSEFIGURE</code></pre>
</td>
<td width=12%><pre><code>61</code></pre>
</td>
<td width=35%><pre><code>EMR_POLYPOLYLINE16</code></pre>
</td>
<td width=11%><pre><code>90</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_CREATEBRUSHINDIRECT</code></pre>
</td>
<td width=12%><pre><code>39</code></pre>
</td>
<td width=35%><pre><code>EMR_POLYTEXTOUTA</code></pre>
</td>
<td width=11%><pre><code>96</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_CREATEDIBPATTERNBRUSHPT</code></pre>
</td>
<td width=12%><pre><code>94</code></pre>
</td>
<td width=35%><pre><code>EMR_POLYTEXTOUTW</code></pre>
</td>
<td width=11%><pre><code>97</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_CREATEMONOBRUSH</code></pre>
</td>
<td width=12%><pre><code>93</code></pre>
</td>
<td width=35%><pre><code>EMR_REALIZEPALETTE</code></pre>
</td>
<td width=11%><pre><code>52</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_CREATEPALETTE</code></pre>
</td>
<td width=12%><pre><code>49</code></pre>
</td>
<td width=35%><pre><code>EMR_RECTANGLE</code></pre>
</td>
<td width=11%><pre><code>43</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_CREATEPEN</code></pre>
</td>
<td width=12%><pre><code>38</code></pre>
</td>
<td width=35%><pre><code>EMR_RESIZEPALETTE</code></pre>
</td>
<td width=11%><pre><code>51</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_DELETEOBJECT</code></pre>
</td>
<td width=12%><pre><code>40</code></pre>
</td>
<td width=35%><pre><code>EMR_RESTOREDC</code></pre>
</td>
<td width=11%><pre><code>34</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_ELLIPSE</code></pre>
</td>
<td width=12%><pre><code>42</code></pre>
</td>
<td width=35%><pre><code>EMR_ROUNDRECT</code></pre>
</td>
<td width=11%><pre><code>44</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_ENDPATH</code></pre>
</td>
<td width=12%><pre><code>60</code></pre>
</td>
<td width=35%><pre><code>EMR_SAVEDC</code></pre>
</td>
<td width=11%><pre><code>33</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_EOF</code></pre>
</td>
<td width=12%><pre><code>14</code></pre>
</td>
<td width=35%><pre><code>EMR_SCALEVIEWPORTEXTEX</code></pre>
</td>
<td width=11%><pre><code>31</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_EXCLUDECLIPRECT</code></pre>
</td>
<td width=12%><pre><code>29</code></pre>
</td>
<td width=35%><pre><code>EMR_SCALEWINDOWEXTEX</code></pre>
</td>
<td width=11%><pre><code>32</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_EXTCREATEFONTINDIRECTW</code></pre>
</td>
<td width=12%><pre><code>82</code></pre>
</td>
<td width=35%><pre><code>EMR_SELECTCLIPPATH</code></pre>
</td>
<td width=11%><pre><code>67</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_EXTCREATEPEN</code></pre>
</td>
<td width=12%><pre><code>95</code></pre>
</td>
<td width=35%><pre><code>EMR_SELECTOBJECT</code></pre>
</td>
<td width=11%><pre><code>37</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_EXTFLOODFILL</code></pre>
</td>
<td width=12%><pre><code>53</code></pre>
</td>
<td width=35%><pre><code>EMR_SELECTPALETTE</code></pre>
</td>
<td width=11%><pre><code>48</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_EXTSELECTCLIPRGN</code></pre>
</td>
<td width=12%><pre><code>75</code></pre>
</td>
<td width=35%><pre><code>EMR_SETARCDIRECTION</code></pre>
</td>
<td width=11%><pre><code>57</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_EXTTEXTOUTA</code></pre>
</td>
<td width=12%><pre><code>83</code></pre>
</td>
<td width=35%><pre><code>EMR_SETBKCOLOR</code></pre>
</td>
<td width=11%><pre><code>25</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_EXTTEXTOUTW</code></pre>
</td>
<td width=12%><pre><code>84</code></pre>
</td>
<td width=35%><pre><code>EMR_SETBKMODE</code></pre>
</td>
<td width=11%><pre><code>18</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_FILLPATH</code></pre>
</td>
<td width=12%><pre><code>62</code></pre>
</td>
<td width=35%><pre><code>EMR_SETBRUSHORGEX</code></pre>
</td>
<td width=11%><pre><code>13</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_FILLRGN</code></pre>
</td>
<td width=12%><pre><code>71</code></pre>
</td>
<td width=35%><pre><code>EMR_SETCOLORADJUSTMENT</code></pre>
</td>
<td width=11%><pre><code>23</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_FLATTENPATH</code></pre>
</td>
<td width=12%><pre><code>65</code></pre>
</td>
<td width=35%><pre><code>EMR_SETDIBITSTODEVICE</code></pre>
</td>
<td width=11%><pre><code>80</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_FRAMERGN</code></pre>
</td>
<td width=12%><pre><code>72</code></pre>
</td>
<td width=35%><pre><code>EMR_SETMAPMODE</code></pre>
</td>
<td width=11%><pre><code>17</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_GDICOMMENT</code></pre>
</td>
<td width=12%><pre><code>70</code></pre>
</td>
<td width=35%><pre><code>EMR_SETMAPPERFLAGS</code></pre>
</td>
<td width=11%><pre><code>16</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_HEADER</code></pre>
</td>
<td width=12%><pre><code>1</code></pre>
</td>
<td width=35%><pre><code>EMR_SETMETARGN</code></pre>
</td>
<td width=11%><pre><code>28</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_INTERSECTCLIPRECT</code></pre>
</td>
<td width=12%><pre><code>30</code></pre>
</td>
<td width=35%><pre><code>EMR_SETMITERLIMIT</code></pre>
</td>
<td width=11%><pre><code>58</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_INVERTRGN</code></pre>
</td>
<td width=12%><pre><code>73</code></pre>
</td>
<td width=35%><pre><code>EMR_SETPALETTEENTRIES</code></pre>
</td>
<td width=11%><pre><code>50</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_LINETO</code></pre>
</td>
<td width=12%><pre><code>54</code></pre>
</td>
<td width=35%><pre><code>EMR_SETPIXELV</code></pre>
</td>
<td width=11%><pre><code>15</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_MASKBLT</code></pre>
</td>
<td width=12%><pre><code>78</code></pre>
</td>
<td width=35%><pre><code>EMR_SETPOLYFILLMODE</code></pre>
</td>
<td width=11%><pre><code>19</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_MODIFYWORLDTRANSFORM</code></pre>
</td>
<td width=12%><pre><code>36</code></pre>
</td>
<td width=35%><pre><code>EMR_SETROP2</code></pre>
</td>
<td width=11%><pre><code>20</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_MOVETOEX</code></pre>
</td>
<td width=12%><pre><code>27</code></pre>
</td>
<td width=35%><pre><code>EMR_SETSTRETCHBLTMODE</code></pre>
</td>
<td width=11%><pre><code>21</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_OFFSETCLIPRGN</code></pre>
</td>
<td width=12%><pre><code>26</code></pre>
</td>
<td width=35%><pre><code>EMR_SETTEXTALIGN</code></pre>
</td>
<td width=11%><pre><code>22</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_PAINTRGN</code></pre>
</td>
<td width=12%><pre><code>74</code></pre>
</td>
<td width=35%><pre><code>EMR_SETTEXTCOLOR</code></pre>
</td>
<td width=11%><pre><code>24</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_PIE</code></pre>
</td>
<td width=12%><pre><code>47</code></pre>
</td>
<td width=35%><pre><code>EMR_SETVIEWPORTEXTEX</code></pre>
</td>
<td width=11%><pre><code>11</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_PLGBLT</code></pre>
</td>
<td width=12%><pre><code>79</code></pre>
</td>
<td width=35%><pre><code>EMR_SETVIEWPORTORGEX</code></pre>
</td>
<td width=11%><pre><code>12</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_POLYBEZIER</code></pre>
</td>
<td width=12%><pre><code>2</code></pre>
</td>
<td width=35%><pre><code>EMR_SETWINDOWEXTEX</code></pre>
</td>
<td width=11%><pre><code>9</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_POLYBEZIER16</code></pre>
</td>
<td width=12%><pre><code>85</code></pre>
</td>
<td width=35%><pre><code>EMR_SETWINDOWORGEX</code></pre>
</td>
<td width=11%><pre><code>10</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_POLYBEZIERTO</code></pre>
</td>
<td width=12%><pre><code>5</code></pre>
</td>
<td width=35%><pre><code>EMR_SETWORLDTRANSFORM</code></pre>
</td>
<td width=11%><pre><code>35</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_POLYBEZIERTO16</code></pre>
</td>
<td width=12%><pre><code>88</code></pre>
</td>
<td width=35%><pre><code>EMR_STRETCHBLT</code></pre>
</td>
<td width=11%><pre><code>77</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_POLYDRAW</code></pre>
</td>
<td width=12%><pre><code>56</code></pre>
</td>
<td width=35%><pre><code>EMR_STRETCHDIBITS</code></pre>
</td>
<td width=11%><pre><code>81</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_POLYDRAW16</code></pre>
</td>
<td width=12%><pre><code>92</code></pre>
</td>
<td width=35%><pre><code>EMR_STROKEANDFILLPATH</code></pre>
</td>
<td width=11%><pre><code>63</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_POLYGON</code></pre>
</td>
<td width=12%><pre><code>3</code></pre>
</td>
<td width=35%><pre><code>EMR_STROKEPATH</code></pre>
</td>
<td width=11%><pre><code>64</code></pre>
</td>
</tr>
<tr valign=top>
<td width=42%><pre><code>EMR_POLYGON16</code></pre>
</td>
<td width=12%><pre><code>86</code></pre>
</td>
<td width=35%><pre><code>EMR_WIDENPATH</code></pre>
</td>
<td width=11%><pre><code>66</code></pre>
</td>
</tr>
</table><br>
<p>
Of the records listed in Table 1, two are present in every enhanced metafile. The first record in any enhanced metafile is the metafile header. The value of this record is <b>EMR_HEADER</b> (1). The last record of an enhanced metafile is always the end-of-file record. The value of this record is <b>EMR_EOF</b> (14).</p>
<p>
In addition to the enhanced metafile header and metafile records, two additional pieces of data may be found in an enhanced metafile. The optional description string follows the enhanced metafile header. An optional color palette, if it exists, is contained in a special enhanced metafile record, the <b>EMR_EOF</b> record. The <b>EMR_EOF</b> is present even when a palette is not available.</p>
<h4>Description string</h4>
<p>
Have you ever just wanted to know what was in a given metafile without having to decipher a cryptic filename or play back the entire metafile? The enhanced metafile provides an optional description string that provides exactly this information. In addition to a descriptive name, the string specifies the name of the application that created the picture. The string must contain a null character between the application name and the picture name. It must terminate with two null characters; for example, "ACME Inc.\0Rocket Skates\0\0", where \0 represents the null character. If <b>lpDescription</b> is NULL, there is no corresponding entry in the header of the enhanced metafile. If the description string is present, it is found <b>offDescription</b> bytes from the beginning of the <b>ENHMETAHEADER</b> structure. The array found at that offset contains <b>nDescription</b> characters. A convenient way to obtain the description string is to use the <b>GetEnhMetaFileDescription</b> function.</p>
<h4>Color palette</h4>
<p>
When a palette was required in a Windows metafile, you recorded a <b>CreatePalette</b>, <b>SelectPalette</b>, and <b>RealizePalette</b> sequence. When the Windows metafile was played back, the palette was selected as a foreground palette. The realization of the foreground palette typically resulted in odd screen behavior as the other palettes went to the background. With enhanced metafiles, palette sequences may still be recorded, but they are never selected and realized as foreground palettes when they are subsequently played back. These palette functions serve only to build the metafile palette. Enhanced metafiles place this optional palette in the metafile end-of-file record (<b>EMR_EOF)</b>. Although the palette is optional, there are advantages to using it. One palette may be generated and used for the duration of the playback, thus avoiding the problems associated with foreground and background palette changes. The optional palette also makes it easier for a palette-oriented application to examine the metafile colors and merge them with an existing palette. The easiest way to get the palette is to call <b>GetEnhMetaFilePaletteEntries</b>. However, you can locate the palette yourself if you wish. First, determine whether there is a palette. This is done by examining <b>nPalEntries</b> in the enhanced metafile header or in the last record of the metafile, the <b>EMR_EOF</b> record (see code below).</p>
<pre><code>typedef struct tagEMREOF
{
 &nbsp;&nbsp; EMR&nbsp;&nbsp;&nbsp;&nbsp; emr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Base enhanced metafile record.
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; nPalEntries;&nbsp;&nbsp;&nbsp; // Number of palette entries.
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; offPalEntries;&nbsp; // Offset to the palette entries.
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; nSizeLast;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Same as emr.nSize and must be the
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // last DWORD of the record.&nbsp; The palette
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // entries, if they exist, precede this field.
} EMREOF;
</code></pre>
<p>
If this value is greater than zero, a palette is present. The <b>nSizeLast</b> member of the <b>EMR_EOF</b> record indicates how many bytes to seek back to find the beginning of the <b>EMR_EOF</b> record. Seek forward from this point by <b>offPalEntries</b>, and bingo! you have a palette location. After having used either method to obtain the palette, you can simply select the palette into the destination DC, realize it, and then play back the metafile.</p>
<h3>Device Independence</h3>
<p>
Achieving device independence was very difficult, if not impossible, with Windows metafiles. The placeable variant of the Windows metafile provided the best shot at this. The additional header provided in the placeable metafile (see code below) provided an opportunity for an application to render these metafiles in a device-relative way.</p>
<pre><code>typedef struct tagPLACEABLEMETAFILEHEADER {
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; key;
 &nbsp;&nbsp; HANDLE&nbsp; hmf;
 &nbsp;&nbsp; RECT&nbsp;&nbsp;&nbsp; bbox;
 &nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp; inch;
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; reserved;
 &nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp; checksum;
} PLACEABLEMETAFILEHEADER;
</code></pre>
<p>
Device independence was typically achieved by setting the mapping mode to anisotropic, setting the viewport extents to the physical dimensions of the device, and finally setting the windows extents to the product of the device's physical dimensions (in inches) and the metafile units per inch (contained in the inch member of the header structure). The biggest problem with this approach was that variants of the placeable Windows metafile began surfacing. Often the mapping mode and viewport extents were included in the metafile as records. This necessitated enumerating the metafile as a method of filtering out undesirable records. Unfortunately, the bounding box and metafile units per inch often did not match the environment being set by the undesirable metafile records! This led to the situation in which even the placeable metafiles were, once again, application-specific.</p>
<p>
Device independence is a key feature of enhanced metafiles. The Microsoft Win32 Software Development Kit (SDK) for Windows NT <i>Programmer's Reference: Overviews</i> states that "...when an application creates a picture measuring 2 inches by 4 inches on a VGA display and stores that picture in a metafile, it (the picture) will maintain those original dimensions when it is printed on a 300 dpi laser printer or copied over a network and displayed in another application that is running on an 8514/A video display." So, just how is this done? The key to achieving this device independence is the use of a <i>reference device context</i>, that is, the context of the device on which the picture was created. When a metafile is created, information regarding the reference DC is placed in the enhanced metafile header. More specifically, GDI calls <b>GetDeviceCaps</b> and assigns the <b>HORZSIZE</b> and <b>VERTSIZE</b> return values to <b>szlMillimeters</b> and assigns the <b>HORZRES</b> and <b>VERTRES</b> return values to <b>szlDevice</b>. The <b>rclFrame</b> member is assigned the bounding rectangle specified in the <i>lpRect</i> parameter of <b>CreateEnhMetaFile</b>. If <i>lpRect</i> is NULL, GDI determines the bounding rectangle and assigns it to <b>rclFrame</b>. This information is sufficient to enable the playback functions to provide device independence. When a metafile is played back, the picture undergoes a series of transformations that scale and translate the picture to the output rectangle that was specified in the call to the <b>PlayEnhMetaFile</b> or <b>EnumEnhMetaFile</b> playback functions. These transformations rely on the dimensions of the picture frame (<b>rclFrame</b>), the dimensions of the device upon which the metafile was created (<b>szlMillimeters</b> and <b>szlDevice</b>), and the world-to-page transform values currently set in the destination DC.</p>
<h3>Compatibility</h3>
<p>
Although it is not recommended, Windows metafiles can be used with Win32-based applications. Unfortunately, enhanced metafiles cannot be used in Windows version 3.<i>x</i>. The Win32 API provides these familiar-sounding functions that manipulate Windows metafiles:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=31%><b>CloseMetaFile</b></td>
<td width=69%>Closes a Windows metafile DC.</td>
</tr>
<tr valign=top>
<td width=31%><b>CopyMetaFile</b></td>
<td width=69%>Copies a Windows metafile.</td>
</tr>
<tr valign=top>
<td width=31%><b>CreateMetaFile</b></td>
<td width=69%>Creates a Windows metafile DC.</td>
</tr>
<tr valign=top>
<td width=31%><b>DeleteMetaFile</b></td>
<td width=69%>Invalidates Windows metafile handle. </td>
</tr>
<tr valign=top>
<td width=31%><b>EnumMetaFile</b></td>
<td width=69%>Returns GDI calls within a Windows metafile. </td>
</tr>
<tr valign=top>
<td width=31%><b>EnumMetaFileProc</b></td>
<td width=69%>Processes metafile data.</td>
</tr>
<tr valign=top>
<td width=31%><b>GetMetaFile</b></td>
<td width=69%>Creates a Windows metafile. </td>
</tr>
<tr valign=top>
<td width=31%><b>GetMetaFileBitsEx</b></td>
<td width=69%>Copies Windows metafile bits to a buffer. </td>
</tr>
<tr valign=top>
<td width=31%><b>PlayMetaFile</b></td>
<td width=69%>Plays a Windows metafile to a DC. </td>
</tr>
<tr valign=top>
<td width=31%><b>PlayMetaFileRecord</b></td>
<td width=69%>Plays a Windows metafile record. </td>
</tr>
<tr valign=top>
<td width=31%><b>SetMetaFileBitsEx</b></td>
<td width=69%>Creates a memory-based Windows metafile from data. </td>
</tr>
<tr valign=top>
<td width=31%><b>GetMetaFileBits</b></td>
<td width=69%>Obsolete; use GetMetaFileBitsEx. </td>
</tr>
<tr valign=top>
<td width=31%><b>SetMetaFileBits</b></td>
<td width=69%>Obsolete; use SetMetaFileBitsEx. </td>
</tr>
</table><br>
<p>
In addition to providing functions that enable the use of Windows metafiles, the Win32 API also provides functions to convert Windows metafiles into enhanced metafiles. These include the following functions:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=32%><b>GetWinMetaFileBits</b></td>
<td width=68%>Retrieves enhanced metafile contents in Windows format.</td>
</tr>
<tr valign=top>
<td width=32%><b>SetWinMetaFileBits</b></td>
<td width=68%>Creates enhanced metafile from Windows metafile data.</td>
</tr>
</table><br>
<h2>Pulling It All Together</h2>
<p>
At this point, the differences between a Windows metafile and an enhanced metafile should be clear:
<ul type=disc>
<li>
The enhanced metafile header is larger and more complete than a Windows metafile.<br><br></li>
<li>
The enhanced metafile may contain a description string or a palette.<br><br></li>
<li>
The enhanced metafile achieves device independence by means of a reference DC and special transformations in the playback functions.</li>
</ul>
<p>
A quick look at the enhanced metafile functions and some example code should help clarify the features of enhanced metafiles.</p>
<h3>Enhanced Metafile Functions</h3>
<p>
The following functions are very similar to the functions used for Windows metafiles. The differences that exist do so to accommodate new features of enhanced metafiles.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=39%><b>CloseEnhMetaFile</b></td>
<td width=61%>Closes an enhanced metafile DC.</td>
</tr>
<tr valign=top>
<td width=39%><b>CopyEnhMetaFile</b></td>
<td width=61%>Copies an enhanced metafile.</td>
</tr>
<tr valign=top>
<td width=39%><b>CreateEnhMetaFile</b></td>
<td width=61%>Creates an enhanced metafile DC.</td>
</tr>
<tr valign=top>
<td width=39%><b>DeleteEnhMetaFile</b></td>
<td width=61%>Invalidates enhanced metafile handle.</td>
</tr>
<tr valign=top>
<td width=39%><b>EnhMetaFileProc</b></td>
<td width=61%>Processes enhanced metafile data.</td>
</tr>
<tr valign=top>
<td width=39%><b>EnumEnhMetaFile</b></td>
<td width=61%>Returns GDI calls within an enhanced metafile.</td>
</tr>
<tr valign=top>
<td width=39%><b>GdiComment</b></td>
<td width=61%>Adds a comment to an enhanced metafile.</td>
</tr>
<tr valign=top>
<td width=39%><b>GetEnhMetaFile</b></td>
<td width=61%>Creates an enhanced metafile.</td>
</tr>
<tr valign=top>
<td width=39%><b>GetEnhMetaFileBits</b></td>
<td width=61%>Copies enhanced metafile bits to a buffer.</td>
</tr>
<tr valign=top>
<td width=39%><b>GetEnhMetaFileDescription</b></td>
<td width=61%>Returns creator and title for enhanced metafile.</td>
</tr>
<tr valign=top>
<td width=39%><b>GetEnhMetaFileHeader</b></td>
<td width=61%>Returns enhanced metafile header.</td>
</tr>
<tr valign=top>
<td width=39%><b>GetEnhMetaFilePaletteEntries</b></td>
<td width=61%>Returns enhanced metafile palette entries.</td>
</tr>
<tr valign=top>
<td width=39%><b>PlayEnhMetaFile</b></td>
<td width=61%>Plays an enhanced metafile to a DC.</td>
</tr>
<tr valign=top>
<td width=39%><b>PlayEnhMetaFileRecord</b></td>
<td width=61%>Plays an enhanced metafile record.</td>
</tr>
<tr valign=top>
<td width=39%><b>SetEnhMetaFileBits</b></td>
<td width=61%>Creates a memory-based enhanced metafile from data.</td>
</tr>
</table><br>
<h4>GdiComment</h4>
<p>
<b>GdiComment</b> deserves a little elaboration. When a comment was needed in a Windows metafile, the <b>MFCOMMENT</b> printer escape was used. These comments were restricted to private data only. The <b>MFCOMMENT</b> printer escape cannot be used in enhanced metafiles. Escapes, in general, cannot be used in enhanced metafiles because they would introduce device dependence, which is in direct opposition to the goal of device independence. Realizing that there is still a place for private data in metafiles, the architects of the Win32 API made <b>GdiComment</b> available for embedding private information in enhanced metafiles. But <b>GdiComment</b> is more than simply an alternative to <b>MFCOMMENT</b>. It was designed to enable public comments as well. The currently supported public comments include:
<ul type=disc>
<li>
<b>GDICOMMENT_WINDOWS_METAFILE</b><br><br></li>
<li>
<b>GDICOMMENT_BEGINGROUP</b><br><br></li>
<li>
<b>GDICOMMENT_ENDGROUP</b><br><br></li>
<li>
<b>GDICOMMENT_MULTIFORMATS</b></li>
</ul>
<p>
The use of public comment permits embedding of other metafiles and encapsulated PostScript (EPS) files within the metafile. The multiformat public comment is the most exciting of the comments. (I must be losing touch with reality!) If an EPS file is embedded in an enhanced metafile and subsequently played back, GDI will select the best format for the device! Transparently! When I first heard about the multiformat comment, I was sure that I was going to be expending a great deal of effort writing code for rendering EPS files. I was relieved to find out how wrong I was!</p>
<h3>Coding Examples</h3>
<p>
The example code in the following sections demonstrates the creation and playback of an enhanced metafile, illustrating how some of these functions are used. (These examples are pared-down versions of examples in the Win32 documentation.)</p>
<h4>Creating an enhanced metafile</h4>
<p>
Creating an enhanced metafile is similar to creating a Windows metafile. The code that follows demonstrates the creation of an enhanced metafile that is stored on a disk. The example uses a device context for the application window as the reference DC. The dimensions of the application's client area are used to define the dimensions of the picture frame. Using the rectangle dimensions returned by the <b>GetClientRect</b> function, the example converts the device units to .01-millimeter units and passes the converted values to the <b>CreateEnhMetaFile</b> function. The example also embeds a text description of the picture in the header of the enhanced metafile.</p>
<pre><code>// Obtain a handle to a reference DC.

hdcRef = GetDC(hWnd);

// Determine the picture frame dimensions.
// iWidthMM is the display width in millimeters.
// iHeightMM is the display height in millimeters.
// iWidthPels is the display width in pixels.
// iHeightPels is the display height in pixels.

iWidthMM = GetDeviceCaps(hdcRef, HORZSIZE);
iHeightMM = GetDeviceCaps(hdcRef, VERTSIZE);
iWidthPels = GetDeviceCaps(hdcRef, HORZRES);
iHeightPels = GetDeviceCaps(hdcRef, VERTRES);

// Use iWidthMM, iWidthPels, iHeightMM, and iHeightPels to determine the
// number of .01-millimeter units per pixel in the x and y directions.

iMMPerPelX = (iWidthMM * 100)/iWidthPels;
iMMPerPelY = (iHeightMM * 100)/iHeightPels;

// Retrieve the coordinates of the client rectangle in pixels.

GetClientRect(hWnd, &amp;rect);

// Convert client coordinates to .01-mm units. 

rect.left = rect.left * iMMPerPelX;
rect.top = rect.top * iMMPerPelY;
rect.right = rect.right * iMMPerPelX;
rect.bottom = rect.bottom * iMMPerPelY;

// Create the metafile DC.

hdcMeta = CreateEnhMetaFile(hdcRef, (LPTSTR)"MYFILE.EMF", &amp;rect,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR)"ACME Inc.\0Rocket Skates\0\0");

if (!hdcMeta)
 &nbsp;&nbsp; errhandler("CreateEnhMetaFile", hWnd);

// Release the reference DC.

ReleaseDC(hWnd, hdcRef);
</code></pre>
<h4>Playing an enhanced metafile</h4>
<p>
Playing an enhanced metafile is also similar to the method used to play Windows metafiles. The following example demonstrates how to open an enhanced metafile stored on disk, and displays the associated picture in the client area. The example passes the handle returned by the <b>GetEnhMetaFile</b> function to the <b>PlayEnhMetaFile</b> function in order to display the picture. Before diving into the code, consider the following advice about enumeration of the metafile and some tips on how to maximize the advanced features of the GDI metafile player.</p>
<p>
<b>Using EnumEnhMetaFile</b></p>
<p>
It's common practice to enumerate Windows metafiles, rather than simply to play them back, to achieve better control over positioning, scaling, getting access to application-specific comments, or manipulating the palette records. However, the improvements to enhanced metafiles reduce the need for enumeration of the metafile. In Win32, most applications need to use only <b>PlayEnhMetaFile</b> unless they need to edit the enhanced metafile by adding, deleting, or modifying records, in which case they'd use <b>EnumEnhMetaFile</b>.</p>
<p>
<b>Advanced features</b></p>
<p>
Three advanced features of enhanced metafiles require action by the application before playing the metafile to the destination DC:
<ul type=disc>
<li>
Advanced palette functionality<br><br></li>
<li>
Advanced clipping capabilities<br><br></li>
<li>
World-to-page transform values</li>
</ul>
<p>
The advanced palette functionality provides a means of examining the palette before playing the metafile. This is useful if the palette is to be merged with another or optimized before the enhanced metafile is played or enumerated. If the metafile palette is to be used, it must be retrieved (<b>GetEnhMetaFilePaletteEntries</b>), manipulated as desired, created, selected, and realized in the destination DC.</p>
<p>
The advanced clipping capabilities permit the enhanced metafile to be clipped to a predetermined clipping region. To accomplish this, the metafile player determines if a clipping region exists in the destination DC. If a clipping region exists, the region is applied to the metafile contents as they are played. To use the clipping feature, create and select any clipping regions into the destination DC prior to playing the metafile.</p>
<p>
Finally, the metafile player applies world-to-page transform values set in the destination DC to the contents of the enhanced metafile. If any scaling, rotation, reflection, or shearing is desired, set the world-to-page transform value in the destination DC before playing the metafile.</p>
<pre><code>hemf = GetEnhMetaFile((LPSTR)"MYFILE.EMF");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Open the metafile.

hDC = GetDC(hWnd);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Retrieve a handle to a window DC.

GetClientRect(hWnd, &amp;rect);&nbsp; // Retrieve the client rectangle dimensions.

PlayEnhMetaFile(hDC, hemf, &amp;rect);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw the picture.

DeleteEnhMetaFile(hemf);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Release the metafile handle.

ReleaseDC(hWnd, hDC);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Release the window DC.
</code></pre>
<h2>Summary</h2>
<p>
Enhanced metafiles are a giant step beyond the Windows metafile. An expanded metafile header, a description string, a palette, device independence, and ease of porting from the Windows metafile format make enhanced metafiles an offer you can't refuse! It is expected that the advanced features of enhanced metafiles will make the use of metafiles more acceptable than Windows metafiles. With the features listed below, it is easy to understand why enhanced metafiles will become an invaluable tool for Win32-based applications:
<ul type=disc>
<li>
Full transformation support (removes scaling restrictions found in Windows metafiles)<br><br></li>
<li>
Unrestricted clipping capabilities<br><br></li>
<li>
Improved palette support<br><br></li>
<li>
Query support (as in <b>GetViewportExtent</b> and <b>GetCurrentPositionEx</b>)<br><br></li>
<li>
Advanced embedding features (metafiles and EPS files)</li>
</ul>
<p>
Probably the most important point to make about enhanced metafiles is that there is very little reason to enumerate the metafile. The playback code is smarter and does much of what developers have had to do themselves by means of enumeration for years.</p>
</BODY>
</HTML>
