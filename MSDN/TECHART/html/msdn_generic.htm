<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Generic: Anatomy of a Simple Win32 Application</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_generic"></a>Generic: Anatomy of a Simple Win32 Application</h1>
<p>
Robert B. Hess<br>
Microsoft Corporation</p>
<p>
Created: October 17, 1994</p>
<p>
<i>Robert Hess is a Software Design Engineer for Microsoft, working in the Developer Relations group. He has worked for Microsoft for over six years as a developer for various Windows platforms.</i></p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3141">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the Generic sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article reviews some of the aspects of the Generic sample application that illustrate a well-behaved application written for the Win32® environment.</p>
<h2>Introduction</h2>
<p>
Generic is a sample application that attempts to illustrate the "minimum" functionality that should be expected of a well-behaved application developed for the Win32® environment. Other than that, this application has virtually no actual functionality of its own. This makes it easier for you to use Generic as a starting point for your own application development or for investigating the Win32 Application Programming Interface (API).</p>
<p>
This document will attempt to provide a quick overview of the important aspects of the Generic application, focusing on the areas that are new or different from 16-bit Windows®.</p>
<p>
This article is not a tutorial. I will assume that the reader is already familiar with the introductory aspects of Windows-based programming.</p>
<p>
<img src="generic_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The Generic sample application</b></p>
<h2>A "Generic" History</h2>
<p>
The Windows Software Development Kit (SDK) has included a Generic sample application for quite some time. When the Win32 SDK was first being developed, I noticed that this application was quite sad indeed. While it did bring up a window on the screen, it did very little more than this. The program didn't even have an icon associated with it—it was a bare-bones Windows-based application rather than a generic one. I also noticed that many of the other sample applications that we were presenting also lacked many of the aspects of programming that we are constantly encouraging developers to implement in their Windows-based applications.</p>
<p>
For the Win32 SDK, I decided that I would rewrite generic as the "bar" that virtually every Microsoft® Windows-based application should at least be able to clear. By definition, Generic would have no actual functionality of its own, thereby not requiring you to remove existing code in order to modify it for your own purposes. However, at the same time, Generic would attempt to illustrate as many aspects of Windows programming as possible that should be included in all Windows-based programs.</p>
<p>
The Windows 95 SDK includes a version of my Generic sample. In fact, many of the sample applications within the Windows 95 SDK are based on this version. Unfortunately, all of these samples are currently using a slightly lobotomized version of Generic that doesn't fully illustrate how an application that is compatible with Windows 95 should use the Win32 API. This article introduces the "new and improved" version of Generic that attempts to present a minimum level of functionality that all Windows-based applications should be able to meet, as well as being a totally well-behaved citizen of the Windows 95 environment.</p>
<p>
Because the Windows 95 operating system is still under development at this time, there may be additions and changes to what should be expected of an application written for this environment. As these changes are added to the system, I will be updating the sources associated with this article to illustrate these aspects. Please check the updates to this article to determine if there are changes that you need to be aware of. Due to changes that have been made in the Windows 95 operating system since the M6 release of the beta Windows 95 SDK, the version of Generic that is presented here is not fully compatible with the M6 release.</p>
<h2>Topics Discussed in This Document</h2>
<ul type=disc>
<li>
Registering both large and small icons<br><br></li>
<li>
Locating a "previous" instance<br><br></li>
<li>
A menu bar that conforms to the user interface (UI) guidelines<br><br></li>
<li>
Context menu on right-click in the client area<br><br></li>
<li>
Version information in the resource<br><br></li>
<li>
An About box<ul type=disc>
<li>
Setting the font to non-bold in a dialog box<br><br></li>
<li>
Populating the About box with the version information from the resource<br><br></li>
<li>
Centering a dialog box over the application window</li>
</ul>
</li>
<li>
Version checking to detect Win32s™, Windows NT™, or Windows 95<br><br></li>
<li>
Properly populated WinHelp menu<br><br></li>
<li>
Proper launching of WinHelp<br><br></li>
<li>
A WinHelp source file that doesn't require an RTF word processor<br><br></li>
<li>
A .CNT file for creating a proper index page using Windows 95 WinHelp<br><br></li>
<li>
Monitoring the Display Change message to detect dynamic resolution changes<br><br></li>
<li>
A "normal" nmake script (MAKEFILE) that is human-readable<br><br></li>
<li>
A Visual C++™ nmake script (GENERIC.MAK) that can be used to build this project using Visual C++ version 2.0<br><br></li>
<li>
Compatibility of resulting executable with Win32s, Windows NT, and Windows 95</li>
</ul>
<h2>Registering Both Large and Small icons</h2>
<p>
Windows 95 introduces the use of smaller icons in some of its user interface features, most notably in the title bar to replace the System menu icon. Unfortunately, simply compressing the already registered 32x32 icon for this icon can result in a rather ugly image, and because there was no other way to alert the system as to exactly which icon to use for this, a new function, <b>RegisterClassEx</b>, had to be brought on board. This function is essentially the same as the old <b>RegisterClass</b> call, except that the structure you pass in has two additional elements: <b>cbSize</b> and <b>hIconSm</b>. The <b>cbSize</b> value keeps track of any additional changes that might be needed for this structure and allows the system to "do the right thing," based on which structure is being used. The <b>hIconSm</b> value passes in the handle to the small icon.</p>
<p>
In my sample code, I use <b>LoadIcon</b> to get the small icon handle. The icon resource I load contains only a small icon (16x16), so I don't have to worry about Windows pulling out the 32x32 icon instead. The new <b>LoadIconEx</b> function, which will allow me to specify the desired icon resolution, should be available any day now in Windows 95. When this is in, I will be able to include both the 32x32 and the 16x16 icon in a single icon resource.</p>
<p>
<img src="generic_2.gif" border=0></p>
<p class=label>
<b>Figure 2.&nbsp; 32x32 icon</b></p>
<p>
<img src="generic_3.gif" border=0></p>
<p class=label>
<b>Figure 3.&nbsp; 32x32 icon shrunk to 16x16</b></p>
<p>
<img src="generic_4.gif" border=0></p>
<p class=label>
<b>Figure 4.&nbsp; 16x16 icon</b></p>
<h2>Locating a "Previous" Instance</h2>
<p>
In both Windows NT and Windows 95, the <i>hPrevInstance</i> parameter that is passed to the <b>WinMain</b> function will always be NULL. This is because it is no longer necessary (or appropriate) to perform things such as <b>RegisterClass</b> only during the execution of the first instance of an application.</p>
<p>
This poses a problem. If you want only a single instance of your application to run at one time, you now need to work a little harder in accomplish this. In my sample code, I illustrate a common and recommended method of doing this, which is to use the <b>FindWindow</b> function to locate another window of a specified class.</p>
<pre><code>hwnd = FindWindow (szAppName, NULL);
if (hwnd) {
 &nbsp; // We found another version of ourself. Let's defer to it:
 &nbsp; if (IsIconic(hwnd)) {
 &nbsp;&nbsp;&nbsp;&nbsp; ShowWindow(hwnd, SW_RESTORE);
 &nbsp; }
 &nbsp; SetForegroundWindow (hwnd);
 &nbsp; // If this app actually had any functionality, we would
 &nbsp; // also want to communicate any action that our "twin"
 &nbsp; // should now perform based on how the user tried to
 &nbsp; // execute us.
 &nbsp; return FALSE;
}
</code></pre>
<h2>A Menu Bar That Conforms to the UI Guidelines</h2>
<p>
While there is no ironclad definition for a menu bar that all applications should use, there are some general guidelines on the placement and layout of menu items. For example, it is extremely bad practice to include top-level menu items that don't have pop-ups attached (when the user clicks the menu name, it carries out some action). I see this very often in sample applications, and there isn't any excuse for it.</p>
<p>
In Generic, I have followed the general guidelines for the layout of a menu bar, and simply disabled those that don't apply to this sample application. If you were going to turn this into a test-bed application, you might want to add a Test menu between the Edit and Help menus. You could then list multiple menu items that indicate various tests that you have coded.</p>
<p>
If you need to implement any of the disabled menu items, simply remove the GRAYED attribute from its definition in the resource file, and then add code to the specific case statement in the code.</p>
<p>
The suggested layout for the Help menu has changed for Windows 95. You'll notice that I actually define two separate menus in my resource, and at run time I determine the correct one to assign to the class I am registering. There are other ways to do this, but this method is relatively simple and easy to see.</p>
<pre><code>GENERIC MENU DISCARDABLE 
BEGIN
 &nbsp;&nbsp; POPUP "&amp;File"
 &nbsp;&nbsp; BEGIN
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;New",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_NEW, GRAYED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;Open...",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_OPEN, GRAYED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;Save",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_SAVE, GRAYED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "Save &amp;As...",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_SAVEAS, GRAYED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM SEPARATOR
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;Print...",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_PRINT, GRAYED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "P&amp;rint Setup...",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_PRINTSETUP, GRAYED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM SEPARATOR
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "E&amp;xit",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_EXIT
 &nbsp;&nbsp; END
 &nbsp;&nbsp; POPUP "&amp;Edit"
 &nbsp;&nbsp; BEGIN
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;Undo\tCtrl+Z",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_UNDO, GRAYED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM SEPARATOR
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "Cu&amp;t\tCtrl+X",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_CUT, GRAYED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;Copy\tCtrl+C",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_COPY, GRAYED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;Paste\tCtrl+V",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_PASTE, GRAYED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "Paste &amp;Link",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_LINK, GRAYED
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM SEPARATOR
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "Lin&amp;ks...",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_LINKS, GRAYED
 &nbsp;&nbsp; END
 &nbsp;&nbsp; POPUP "&amp;Help", HELP
 &nbsp;&nbsp; BEGIN
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;Help Topics...",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_HELPTOPICS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM SEPARATOR
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;About Generic...",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_ABOUT
 &nbsp;&nbsp; END
END
</code></pre>
<h2>Context Menu on Right-Click in the Client Area</h2>
<p>
Windows 95 is placing a high level of importance on the use of the right mouse button to bring up context-sensitive menus. Since Generic doesn't have anything to be context-aware of, I am merely bringing up the pop-up from the Help menu. You can easily replace this with code that will determine what sort of context menu makes sense to bring up, and do that instead. In most cases, you would have alternate pop-up menus defined in your resource file that you would select from, or you would build the menus on the fly.</p>
<pre><code>case WM_RBUTTONDOWN: // Right-click in window's client area...
 &nbsp; pnt.x = LOWORD(lParam);
 &nbsp; pnt.y = HIWORD(lParam);
 &nbsp; ClientToScreen(hWnd, (LPPOINT) &amp;pnt);

 &nbsp; // This is where you would determine the appropriate "context"
 &nbsp; // menu to bring up. Since this app has no real functionality,
 &nbsp; // we will just bring up the Help menu:
 &nbsp; hMenu = GetSubMenu (GetMenu (hWnd), 2);
 &nbsp; if (hMenu) {
 &nbsp;&nbsp;&nbsp;&nbsp; TrackPopupMenu (hMenu, 0, pnt.x, pnt.y, 0, hWnd, NULL);
 &nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp; // Couldn't find the menu...
 &nbsp;&nbsp;&nbsp;&nbsp; MessageBeep(0);
 &nbsp; }
 &nbsp; break;
</code></pre>
<h2>Version Information in the Resource</h2>
<p>
The File Manager in Windows NT and the property sheets in Windows 95 will allow the user to browse certain strings in the application's resource to look at version information. Adding this resource type to your application allows your application to expose some useful information to the user.</p>
<p>
The format of the information being stored in the resource is not quite as simple as ordinary string resources, but you should be able to get a good idea about the layout by simply looking at the sources.</p>
<pre><code>1 VERSIONINFO
FILEVERSION&nbsp;&nbsp;&nbsp;&nbsp; 3,5,0,0
PRODUCTVERSION&nbsp; 3,5,0,0
FILEOS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VOS__WINDOWS32
FILETYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VFT_APP
BEGIN
 &nbsp; BLOCK "StringFileInfo"
 &nbsp; BEGIN
 &nbsp;&nbsp;&nbsp;&nbsp; BLOCK "040904E4"
 &nbsp;&nbsp;&nbsp;&nbsp; BEGIN
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "FileDescription", "Generic Example Application\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "LegalCopyright",&nbsp; "Copyright \251 Microsoft Corp. 1990 - 1994\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "Comments",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Written by: Robert B. Hess\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "CompanyName",&nbsp;&nbsp;&nbsp;&nbsp; "Microsoft Corporation\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "FileVersion",&nbsp;&nbsp;&nbsp;&nbsp; "3.5\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "LegalTrademarks", "Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(tm) is a trademark of Microsoft Corporation\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "ProductName",&nbsp;&nbsp;&nbsp;&nbsp; "Generic\0"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VALUE "ProductVersion",&nbsp; "3.5\0"
 &nbsp;&nbsp;&nbsp;&nbsp; END
 &nbsp; END
 &nbsp; BLOCK "VarFileInfo"
 &nbsp; BEGIN
 &nbsp;&nbsp;&nbsp;&nbsp; VALUE "Translation", 0x409, 1252
 &nbsp; END
END
</code></pre>
<p>
<img src="generic_5.gif" border=0></p>
<p class=label>
<b>Figure 5.&nbsp; Version information</b></p>
<h2>An About Box</h2>
<p>
About boxes are extremely easy to implement, but it is amazing how many sample applications don't include one. Although it would have been very easy for me to simply call <b>MessageBox</b>, I chose to almost double the amount of code in Generic to bring up an About box that could be used in a retail application. Since virtually all of this special functionality is coming out of the resource file, it is very easy to modify the look of this dialog box to fit your needs.</p>
<p>
<img src="generic_6.gif" border=0></p>
<p class=label>
<b>Figure 6. The Generic About box</b></p>
<h3>Setting the Font to Non-Bold in a Dialog Box</h3>
<p>
One problem that people always complain about is that dialog boxes always use a bold font. Therefore, I decided to show two things in my About box: how to switch to a more normal font, and how to set two separate fonts in the same dialog (which isn't any harder). All it takes is to properly create a font handle using the <b>CreateFont</b> function and then use <b>WM_SETFONT </b>to tell the control which the new font to use. When the dialog exits, you need to clean up the fonts, of course. </p>
<pre><code>hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, VARIABLE_PITCH | FF_SWISS, "");
hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, VARIABLE_PITCH | FF_SWISS, "");
...
SendMessage ( GetDlgItem (hDlg, i), WM_SETFONT, (UINT)((i==IDC_TRADEMARK) ? hFinePrint : hfontDlg),TRUE);
</code></pre>
<h3>Populating the About Box with the Version Information From the Resource</h3>
<p>
I use the version information that is stored in the resource to populate static text fields in my About box dialog for two reasons: to help remind you to update this information, and to prevent you from forgetting to change similar information in two separate locations. I simply assigned the default text of these static text controls to be the name of the version string that should be inserted into the static controls at run time. My About box dialog procedure does the rest.</p>
<p>
While it is possible to add multilingual version text to your resource, at the present time, neither the resource nor the dialog procedure are doing anything specifically along these lines. I leave that up to you to do on your own.</p>
<pre><code>// Walk through the dialog items that we want to replace:
for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++) {
 &nbsp; GetDlgItemText(hDlg, i, szResult, sizeof(szResult));
 &nbsp; szGetName[wRootLen] = (char)0;
 &nbsp; lstrcat (szGetName, szResult);
 &nbsp; uVersionLen = 0;
 &nbsp; lpVersion = NULL;
 &nbsp; bRetCode =&nbsp; VerQueryValue((LPVOID)lpstrVffInfo, (LPSTR)szGetName, (LPVOID)&amp;lpVersion, (UINT *)&amp;uVersionLen);
 &nbsp; if ( bRetCode &amp;&amp; uVersionLen &amp;&amp; lpVersion) {
 &nbsp;&nbsp;&nbsp;&nbsp; // Replace dialog item text with version info
 &nbsp;&nbsp;&nbsp;&nbsp; lstrcpy(szResult, lpVersion);
 &nbsp;&nbsp;&nbsp;&nbsp; SetDlgItemText(hDlg, i, szResult);
 &nbsp; }
} // for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++)
</code></pre>
<h3>Centering a Dialog Over the Application Window</h3>
<p>
I've noticed some professional retail applications that bring up dialog boxes that are skewed in relationship to the parent application, or worse yet, clipped by the edge of the screen, sometimes to the point that the OK button is not even visible</p>
<p>
It is fairly easy to reposition the dialog boxes so that they maintain a relationship with the parent application and aren't clipped by the screen. I use the following code in virtually all of my applications. I find that it adds that little touch that isn't necessarily noticed by the user, but would be noticed if it hadn't been there.</p>
<p>
Windows 95 also adds the task bar, which could occlude the window or dialog, so I have modified this code to take that into account when positioning the window.</p>
<pre><code>// Get the height and width of the child window.
GetWindowRect (hwndChild, &amp;rChild);
wChild = rChild.right - rChild.left;
hChild = rChild.bottom - rChild.top;

// Get the height and width of the parent window.
GetWindowRect (hwndParent, &amp;rParent);
wParent = rParent.right - rParent.left;
hParent = rParent.bottom - rParent.top;

// Get the limits of the "work area".
bResult = SystemParametersInfo( SPI_GETWORKAREA, sizeof(RECT), &amp;rWorkArea, 0);
if (!bResult) {
 &nbsp; rWorkArea.left = rWorkArea.top = 0;
 &nbsp; rWorkArea.right = GetSystemMetrics(SM_CXSCREEN);
 &nbsp; rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN);
}

// Calculate new X position, then adjust for work area.
xNew = rParent.left + ((wParent - wChild) /2);
if (xNew &lt; rWorkArea.left) {
 &nbsp; xNew = rWorkArea.left;
} else if ((xNew+wChild) &gt; rWorkArea.right) {
 &nbsp; xNew = rWorkArea.right - wChild;
}

// Calculate new Y position, then adjust for work area.
yNew = rParent.top&nbsp; + ((hParent - hChild) /2);
if (yNew &lt; rWorkArea.top) {
 &nbsp; yNew = rWorkArea.top;
} else if ((yNew+hChild) &gt; rWorkArea.bottom) {
 &nbsp; yNew = rWorkArea.bottom - hChild;
}

SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
</code></pre>
<h2>Version Checking to Detect Win32s, Windows NT, or Windows 95</h2>
<p>
Since applications written for Win32 can now run on three separate operating systems (Windows NT, Windows 3.1 with Win32s, and Windows 95), it is sometimes very important for applications to determine which system they are running on, so they can decide which features and functionality to expose. It is really quite simple to do this, but many applications still don't seem to do it quite right. For a 32-bit application, the code you need is shown below:</p>
<pre><code>dwVersion = GetVersion();
if (dwVersion &lt; 0x80000000) {
 &nbsp; // Windows NT
} else if (LOBYTE(LOWORD(dwVersion))&lt;4) {
 &nbsp; // Win32s
} else {
 &nbsp; // Windows 95
}
</code></pre>
<p>
I'm using this code to populate a string in my About box that reports the version of Windows this program is being run on.</p>
<h2>Properly Populated WinHelp Menu</h2>
<p>
One of the menus that seems to confuse a lot of people is the Help menu. I will agree that there hasn't been enough information that specifically illustrates how this should be done, but after reading through the UI guide and looking at a number of applications, I am presenting a layout in this application that appears to be fairly common. Personally, I find the Help On Help item kind of awkward, but it is in the Windows 3.1 UI guidelines as well as in many applications, so I include it here to illustrate its implementation.</p>
<p>
It is also important to note that the Windows 95 Help menu has a slightly different recommended layout, based on some of the changes in displaying WinHelp to the user in Windows 95. As mentioned previously, I am determining which menu to associate with the application at run time as a quick and easy way to switch the layouts.</p>
<p>
Sample layout for the Help menu in Windows 3.<i>x</i>:</p>
<pre><code>POPUP "&amp;Help"
 &nbsp; BEGIN
 &nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;Contents",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_HELPCONTENTS, HELP
 &nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;Search for Help On...",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_HELPSEARCH, HELP
 &nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;How to Use Help",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_HELPHELP, HELP
 &nbsp;&nbsp;&nbsp;&nbsp; MENUITEM SEPARATOR
 &nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;About Generic...",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_ABOUT
 &nbsp; END
</code></pre>
<p>
Sample layout for the Help menu in Windows 95:</p>
<pre><code>POPUP "&amp;Help"
 &nbsp; BEGIN
 &nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;Help Topics...",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_HELPTOPICS
 &nbsp;&nbsp;&nbsp;&nbsp; MENUITEM SEPARATOR
 &nbsp;&nbsp;&nbsp;&nbsp; MENUITEM "&amp;About Generic...",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDM_ABOUT
 &nbsp; END
</code></pre>
<h2>Proper Launching of WinHelp</h2>
<p>
In addition to a lack of About dialogs in sample applications, I also notice a severe lack of any WinHelp support. While a quick test application that you write may not warrant the time and energy required to prepare a Help file, I feel that any sample application that is being distributed for others to look at and utilize should definitely include a Help file. How many times have you received a set of sample applications, quickly compiled all of them, then started running them to see what they demonstrated? How many times did you look at one of these applications, slightly stunned because you didn't have a clue as to what you were supposed to do? Several (OK, many) of our own sample applications suffer from this, and there really isn't any good excuse for it.</p>
<p>
One of the possible reasons is the lack of good example code that illustrates exactly how you should launch WinHelp in order to make it useful. Most people probably don't tackle that aspect until later in their development cycle. Well, that excuse is now useless:</p>
<pre><code>case IDM_HELPTOPICS: // "Help Topics...": Only called on Windows 95
 &nbsp; bGotHelp = WinHelp (hWnd, "GENERIC.HLP", HELP_FINDER,(DWORD)0);
 &nbsp; break;
case IDM_HELPCONTENTS: // "Contents": Not called on Windows 95
 &nbsp; bGotHelp = WinHelp (hWnd, "GENERIC.HLP", HELP_CONTENTS,(DWORD)0);
break;
case IDM_HELPSEARCH: // "Search for Help On...": Not called on Windows 95
 &nbsp; bGotHelp = WinHelp(hWnd, "GENERIC.HLP", HELP_PARTIALKEY, (DWORD)(LPSTR)"");
 &nbsp; break;
case IDM_HELPHELP: // "How to Use Help": Not called on Windows 95
 &nbsp; bGotHelp = WinHelp(hWnd, (LPSTR)NULL, HELP_HELPONHELP, 0)) {
 &nbsp; break;
</code></pre>
<h2>A WinHelp Source File That Doesn't Require an RTF Word Processor</h2>
<p>
The other reason that many sample applications don't include WinHelp support is probably because the authoring of a WinHelp file can often be quite daunting. I personally have never seen any good documentation in an SDK or Integrated Development Environment package that properly describes how to author WinHelp files. Add to that the fact that the suggested authoring tool is a word processor that supports RTF files (such as Word for Windows), and the fact that you are basically "tricking" this word processor to format the document for WinHelp, and it isn't very surprising that most developers don't add WinHelp to their sample applications.</p>
<p>
Since RTF is a format for describing a rich text document using <i>normal</i> text, it actually is possible to create a WinHelp file with any text editor. In GENERIC.RTF, you will not only find basically human-readable text that creates a reasonable WinHelp file, but I have also tried to add enough comments to give you a quick idea on what is necessary for WinHelp. You might want to track down some RTF documentation if you want to do anything fancier than what I am doing in my sample. The MSDN Library CD-ROM contains full RTF documentation.</p>
<p>
I have supplied two different ways to create the help file: The MAKEFILE script creates the Help file using the HC31 help compiler, and MAKEHELP.BAT uses the new help compiler (HCRTF) that comes with the Windows 95 SDK to build a WinHelp file.</p>
<h2>A .CNT File for Creating a Proper Index Page Using Windows 95 WinHelp</h2>
<p>
One of the changes for Windows 95 is a new method of navigating the WinHelp file from the contents page. One thing this adds to the process is a .CNT file that describes the layout of the contents. By including a .CNT file with your .HLP file, Windows 95 will be able to create a contents/index page for you automatically. It then saves this page out as a hidden file so it won't have to recreate it again (this is what happens when the little "flipping page" dialog comes up when you start up a WinHelp file in Windows 95 for the first time). If the timestamp on the .CNT or .HLP file gets altered, Windows 95 will create a new index file.</p>
<pre><code>:Base generic.hlp
:Title Sample Dialog Title
:Index=generic.hlp
1 Introduction=Introduction@generic.hlp
1 Topics
2 First=FIRST_TOPIC@generic.hlp
2 Second=SECOND_TOPIC@generic.hlp
2 Third=THIRD_TOPIC@generic.hlp
2 Fourth=FOURTH_TOPIC@generic.hlp
</code></pre>
<p>
Refer to the Windows 95 documentation for full information on the format of a .CNT file</p>
<h2>Monitoring the Display Change Message to Detect Dynamic Resolution Changes</h2>
<p>
Plug and Play is a new feature for Windows 95, and it is fairly important for applications to start using it. Since Generic isn't opening up any resources on devices that might go away, there really isn't anything for Generic to do with regards to Plug and Play. However, I have added the code to detect when the user dynamically changes the screen resolution. All that I do is post a <b>MessageBox</b> to report this fact, but you may want to do other things in your application.</p>
<pre><code>case WM_DISPLAYCHANGE:
 &nbsp; szScreen.cx = LOWORD(lParam);
 &nbsp; szScreen.cy = HIWORD(lParam);
 &nbsp; if (fChanged) {
 &nbsp;&nbsp;&nbsp;&nbsp; // The display *has* changed. szScreen reflects the
 &nbsp;&nbsp;&nbsp;&nbsp; // new size.
 &nbsp;&nbsp;&nbsp;&nbsp; MessageBox (GetFocus(), "Display Changed", szAppName, 0);
 &nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp; // The display *is* changing. szScreen reflects the
 &nbsp;&nbsp;&nbsp;&nbsp; // original size.
 &nbsp;&nbsp;&nbsp;&nbsp; MessageBeep(0);
 &nbsp; }
 &nbsp; break;
</code></pre>
<h2>A "Normal" nmake Script (MAKEFILE) That is Human-Readable</h2>
<p>
Despite the landslide penetration of Visual C++ into the development market, I think it is important to include fairly simple nmake scripts so that people know which switches and such are being set. I did take a little extra time and tried to make a nmake script that is flexible enough that you can build any relatively simple project by simply making a few changes.</p>
<p>
I hope I added enough comments so that you can see what is going on.</p>
<h2>A Visual C++ nmake Script (GENERIC.MAK) That Can Be Used to Build This Project Using Visual C++ 2.0</h2>
<p>
And <i>because</i> of the landslide penetration of Visual C++, I am also including an nmake script created by Visual C++ 2.0. One drawback is that Visual C++ doesn't understand how to build WinHelp files, so you will have to do this manually if you use this script file.</p>
<p>
If you are using a development environment other than Visual C++ 2.0 that is capable of automatically generating make scripts for you, all you should need to do is start up a new project and add GENERIC.C and GENERIC.DEF to it. You will also want to add VERSION.LIB to the list of standard libraries that you link to.</p>
<h2>Compatibility of Resulting Executable With Win32s, Windows NT, and Windows 95</h2>
<p>
Last, but probably most important, is the fact that the Generic application is fully compatible with Win32s, Windows NT, and Windows 95.</p>
<h2>Summary</h2>
<p>
As I indicated at the beginning of this article, Generic is not intended to have any real functionality of its own. Instead, it is meant to provide a very minimal skeleton that you can use for building your own sample applications. Because of this, there are a lot of things that Generic doesn't illustrate.</p>
<p>
For the purpose of illustration, all of the code for Generic is included in a single source code file. While this does make it easier to understand what is going on in this application, it is not a recommended method to follow for your own applications. It is more appropriate to modularize your code so that separate source code files contain code for specific functionality. Furthermore, Generic does not illustrate the usage of any of the common dialogs or any of the new common controls that have been added to Windows 95. These and other aspects of programming for the Windows environment are best left up to other sample applications, hopefully coming soon to a source code library near you!</p>
</BODY>
</HTML>
