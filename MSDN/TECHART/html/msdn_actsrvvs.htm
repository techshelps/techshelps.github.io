<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating an Active Server Component in Visual Studio 97</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_actsrvvs"></a>Creating an Active Server Component in Visual Studio 97 </h1>
<p>
Wayne Berry </p>
<p>
June 1997 </p>
<p>
<i>Wayne Berry is the editor for </i>15 Seconds<i> (http://www.15seconds.com/), a twice monthly online publication written for Internet developers and content providers about IIS, ISAPI, and Active Server.</i></p>
<h2>Introduction </h2>
<p>
This article provides a simple example of how to create an Active Server component in Microsoft® Visual Studio™ 97 using the Active Template Library (ATL) version 2.0 and Microsoft Visual C++® version 5.0. The Active Server component works with Active Server Pages (ASP) as an extension of Active Server. When placed within an ASP page, the component we are going to create will get the user's cookie, or assign a cookie if the user doesn't have one. </p>
<p>
If you are still using Microsoft Visual C++ version 4.2, we recommend that you upgrade to Microsoft Visual Studio 97, which makes COM objects much easier to program. </p>
<p>
If you don't plan to use ASP technologies, you may want to consider using a simple object, instead. Please see the discussion at the end of this article. </p>
<p>
Creating an Active Server component consists of five steps: 
<ol>
<li>
Creating an ATL project <br><br></li>
<li>
Adding an Active Server component <br><br></li>
<li>
Creating a method <br><br></li>
<li>
Making it work <br><br></li>
<li>
Adding the component to an ASP page </li>
</ol>
<p>
If you have already installed Visual Studio 97, you can get started right away. </p>
<h2>Step 1. Creating an ATL Project </h2>
<p>
The first step in building an Active Server component is to create an ATL project. We will create the ATL project using the ATL COM AppWizard. The code produced by the wizard is nothing more than a DLL shell, with the ability to register the objects that will be defined later, to create those objects through a class factory, and to build a DllMain that supports the DLL shell. The shell by itself is not an Active Server component. The shell is a holder for many Active Server components. These components share the same code that is available in the shell and can share functionality between them because they exist in the same DLL. To create an ATL project in Visual Studio 97:
<ol>
<li>
From the <b>File</b> menu, choose <b>New</b>. <br><br></li>
<li>
Click the <b>Project</b> tab. <br><br></li>
<li>
From the list of projects, choose <b>ATL COM AppWizard</b>. <br><br></li>
<li>
For the project name, type SMUM. It is important to note that this is the name of the project, not the name of the object. We like to give the project the same name as that of the company under which the project will be licensed. In this example, "SMUM" stands for "Sign Me Up Marketing." We also prefer to use the project name as the first part of the object's common name. For instance, the Prog ID of the object in this example will be SMUM.Example. We prefer not to give the project the same name as the object because there may be more than one object within a project/shell. Also, the ATL wizard will have problems with filenames later if the object and the project have the same name. <p>
<img src="actsrvvs1.gif" border=0></P><p class=label>
<b>Figure 1. New project </b>
</li>
<li>
Click <b>OK</b>. The <b>ATL COM AppWizard - Step 1 of 1</b> dialog box will appear (Figure&nbsp;2). <br><br></li>
<li>
Check <b>Allow merging of proxy/stub code</b>. <p>
<img src="actsrvvs2.gif" border=0></P><p class=label>
<b>Figure 2. ATL COM AppWizard</b>
</li>
<li>
Click <b>Finish</b>. <br><br></li>
<li>
Click <b>OK</b>. </li>
</ol>
<p>
Files affected:
<ul type=disc>
<li>
<b>SMUM.cpp</b>.<b> </b>This file contains the code for the project, including code for the Class Factory, registration, and DllMain. <br><br></li>
<li>
<b>SMUM.def</b>. This is the definition file that tells the compiler which procedure to export; the class factory and the registration functions are exported. <br><br></li>
<li>
<b>SMUM.idl</b>. This is the interface definition file. The ATL COM AppWizard doesn't implement any interfaces through the .idl file until objects are added in step 2. <br><br></li>
<li>
<b>SMUM.rc</b>. This is the DLL resource file. <br><br></li>
<li>
<b>StdAfx.cpp</b>,<b> StdAfx.h</b>. Precompiled header files. <br><br></li>
<li>
<b>dlldatax.c</b>. This file contains code for merging the proxy/stub. </li>
</ul>
<h2>Step 2. Adding an Active Server Component </h2>
<p>
The second step is to add an Active Server component to the shell. This is done using the ATL Object Wizard. 
<ol>
<li>
From the Visual Studio <b>Insert</b> menu, click <b>New ATL Object</b>. The <b>ATL Object Wizard</b> dialog box will appear (Figure 3). <br><br></li>
<li>
Click Objects from the left-hand list box. <br><br></li>
<li>
In the right-hand list box, click <b>ActiveX Server Component</b>. <p>
<img src="actsrvvs3.gif" border=0></P><p class=label>
<b>Figure 3. ATL Object Wizard </b>
</li>
<li>
Click <b>Next</b>. The <b>ATL Wizard Object Properties</b> dialog box will appear. <br><br></li>
<li>
For <b>Short Name</b>, type the name of the component. In this example, we will call the component "Example". Notice that while you type, the wizard automatically fills in the other properties. <br><br></li>
<li>
Type the object's Prog ID by highlighting the first part of the <b>Prog ID</b> and replacing it with "SMUM" (in step one, I mentioned that the example object Prog ID would be "SMUM.Example"). Be careful not to highlight the period that separates the two parts of the Prog ID. The wizard will not allow you to type a period in this edit box. If you delete the period, you will have to start the ATL Object Wizard again. <br><br></li>
<li>
Modify the <b>Type</b> to read "Sign Me Up Marketing Example Component", so that when you test the component from the ActiveX Control Test Container, you will be able to find it quickly. The ActiveX Control Test Container is a tool that comes with the Visual C++ installation of Visual Studio 97. The test container loads COM objects and allows you to test them by their method and properties. <p>
<img src="actsrvvs4.gif" border=0></P><p class=label>
<b>Figure 4. ATL Wizard Object Properties </b>
</li>
<li>
Click <b>OK</b> to create the object. </li>
</ol>
<p>
The ATL Object Wizard creates these files: 
<ul type=disc>
<li>
Example.cpp <br><br></li>
<li>
Example.h </li>
</ul>
<p>
The wizard also adds code describing the interface of the <b>Example</b> object to the project's SMUM.idl. </p>
<p>
When the ATL Object Wizard creates an Active Server component, it adds by default the member variables that interface with the <b>Application</b>, <b>Request</b>, <b>Response</b>, <b>Server</b>, and <b>Session</b> objects.&nbsp; </p>
<h2>Step 3. Creating a Method </h2>
<p>
Now, we will implement a method to get and set a cookie. First, we need to add a method called <b>GetCookie</b> to the <b>Example</b> interface. 
<ol>
<li>
Go to the Project window of the SMUM project. <br><br></li>
<li>
Click the <b>Class View</b> tab. <br><br></li>
<li>
Expand the <b>CExample</b> class until you can see the <b>IExample</b> interface. <br><br></li>
<li>
Right-click <b>IExample</b>, and choose <b>Add Method </b>(Figure 5). <p>
<img src="actsrvvs5.gif" border=0></P><p class=label>
<b>Figure 5. Adding a method in the Project view </b>
</li>
<li>
The <b>Add Method to Interface</b> dialog box should appear (Figure 6). <br><br></li>
<li>
For <b>Method Name</b>, type "GetCookie". <br><br></li>
<li>
For Parameters, type "[out,retval] BSTR *pVal". <p>
<img src="actsrvvs6.gif" border=0></P><p class=label>
<b>Figure 6. Adding a method to the interface </b>
</li>
<li>
Click <b>OK</b>. </li>
</ol>
<p>
By using Visual Studio 97 to add a method in the Project view, you automatically insert the interface description into the *.idl file, and supporting code for the class is generated.&nbsp; </p>
<h2>Step 4. Making It Work </h2>
<p>
Now we are going to add the functionality to the <b>GetCookie</b> method created in Step 3. This method gets the current cookie; if not available, it creates a cookie and returns its value. </p>
<p>
To quickly find the section of code where Visual Studio added the method, expand the project in the Project window, expand the <b>IExample</b> interface, and double-click on the <b>GetCookie</b> method. Add the following code: </p>
<pre><code>STDMETHODIMP CExample::GetCookie(BSTR * pVal)
{
 &nbsp; GUID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guid;
 &nbsp; TCHAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCookie[25];
 &nbsp; VARIANT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varOptional;
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr;
 &nbsp; // Check the Pointer. 
 &nbsp; if (pVal==NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER; 
 &nbsp; // Optimistically set the Returning. 
 &nbsp; // HRESULT
 &nbsp; hr=S_OK;
 &nbsp; // Configure the Optional Variant.
 &nbsp; // This configuration follows
 &nbsp; // the documentation for the
 &nbsp; // Active Server Object Interfaces.
 &nbsp; V_ERROR(&amp;varOptional) == DISP_E_PARAMNOTFOUND;
 &nbsp; // Check to make sure all the interfaces
 &nbsp; // loaded correctly.&nbsp; This is the part
 &nbsp; // that would fail if you called this
 &nbsp; // object from Visual Basic.
 &nbsp; if (m_bOnStartPageCalled)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Allocate the Request Dictionary Objects
 &nbsp;&nbsp;&nbsp;&nbsp; // so that we can pass them to the Active
 &nbsp;&nbsp;&nbsp;&nbsp; // Server Object Interfaces.
 &nbsp;&nbsp;&nbsp;&nbsp; CComPtr&lt;IRequestDictionary&gt; piReadDict;
 &nbsp;&nbsp;&nbsp;&nbsp; CComPtr&lt;IRequestDictionary&gt; piWriteDict;
 &nbsp;&nbsp;&nbsp;&nbsp; // Pointer to the Write Cookie Interface
 &nbsp;&nbsp;&nbsp;&nbsp; IWriteCookie&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *piWriteCookie;
 &nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; // From the Request Interface retrieve
 &nbsp;&nbsp;&nbsp;&nbsp; // a Dictionary of Cookies.
 &nbsp;&nbsp;&nbsp;&nbsp; hr=m_piRequest-&gt;get_Cookies(&amp;piReadDict);
 &nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp;&nbsp;&nbsp; // Allocate and set Variants to pass to 
 &nbsp;&nbsp;&nbsp;&nbsp; // the dictionary.
 &nbsp;&nbsp;&nbsp;&nbsp; CComVariant vtIn(_T("GUID"));
 &nbsp;&nbsp;&nbsp;&nbsp; CComVariant&nbsp;&nbsp; vtOut;
 &nbsp;&nbsp;&nbsp;&nbsp; // Get the Cookie from the dictionary
 &nbsp;&nbsp;&nbsp;&nbsp; // named SMUMID and put it in vtOut.
 &nbsp;&nbsp;&nbsp;&nbsp; hr = piReadDict-&gt;get_Item(vtIn, &amp;vtOut);
 &nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp;&nbsp;&nbsp; // vtOut contains an IDispatch Pointer. 
 &nbsp;&nbsp;&nbsp;&nbsp; // To fetch the value for the cookie, you
 &nbsp;&nbsp;&nbsp;&nbsp; // must get the Default Value for the 
 &nbsp;&nbsp;&nbsp;&nbsp; // object stored in vtOut using VariantChangeType.&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; hr = VariantChangeType(&amp;vtOut, &amp;vtOut, 0, VT_BSTR);
 &nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp;&nbsp;&nbsp; // If the Cookie isn't set then
 &nbsp;&nbsp;&nbsp;&nbsp; // the length of vtOut will be 0.
 &nbsp;&nbsp;&nbsp;&nbsp; if (!wcslen(V_BSTR(&amp;vtOut)))
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // There isn't a Cookie assigned
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // so we have to create one.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use a GUID for the Unqiue User Cookie.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CoCreateGuid(&amp;guid);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Put the GUID into a String.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wsprintf(lpszCookie,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _T("%X%X%X%X%X%X%X%X%X%X%X"),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guid.Data1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guid.Data2, guid.Data3,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guid.Data4[0], guid.Data4[1],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guid.Data4[2], guid.Data4[3],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guid.Data4[4], guid.Data4[5],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guid.Data4[6], guid.Data4[7]);
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a Variant from the String.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CComVariant&nbsp;&nbsp; vtCookieValue(lpszCookie);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the writable Cookie Dictionary 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // from the Response Object.&nbsp; Notice
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that it is the Response Object and
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // not the Request Object like above.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr=m_piResponse-&gt;get_Cookies(&amp;piWriteDict);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (hr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the Writable Interface for
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the GUID cookie from the Cookie Dictionary.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Notice here that the GUID cookie
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // doesn't exist in the dictionary, but we
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // can still ask for its interface.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = piWriteDict-&gt;get_Item(vtIn, &amp;vtOut);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(hr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Make it easy on ourselves, get and cast
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the IDistpach value to the dual interface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that we want to call.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; piWriteCookie = (IWriteCookie*)(vtOut.ppdispVal);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create the Cookie using the Name GUID and the Value of
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the GUID that we generated.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = piWriteCookie-&gt;put_Item(varOptional,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_BSTR(&amp;vtCookieValue));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(hr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create an Expiration Date sometime in the future.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // To keep the example simple, I am using my birthday
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in 2010. 10/4/2010. Some other time, we will show
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // how to generate a VB DATE (double) without MFC.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATE&nbsp;&nbsp; dtExpiration=40455.0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This is required if you want the browser
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to retain the cookie between sessions.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = piWriteCookie-&gt;put_Expires(dtExpiration);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(hr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Assign the out,retval.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pVal = ::SysAllocString(V_BSTR(&amp;vtCookieValue)); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A little help for Debugging.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ATLTRACE (_T("Setting Cookie to: %s\n"),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_BSTR(&amp;vtCookieValue));
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Assign the out,retval.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pVal = ::SysAllocString(V_BSTR(&amp;vtOut));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A little help for Debugging.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ATLTRACE (_T("Cookie was set to: %s\n"),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V_BSTR(&amp;vtOut));
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
 &nbsp; return hr;


} 
</code></pre>
<p>
Once you have added the code, build the DLL. After compilation and linking, Visual Studio will register the DLL. If you have Microsoft Internet Information Server (IIS) installed, you can now use the component.&nbsp; </p>
<h2>Step 5. Adding the Component to an ASP Page </h2>
<p>
The last step is to add the component you just built to your ASP page. </p>
<p>
Here is the right way to call the Active Server component. Notice that the cookie header precedes the &lt;HTML&gt; and &lt;BODY&gt; tags. </p>
<pre><code>&lt;%
' Here is where the OnStartPage method is called
Set Example=Server.CreateObject("SMUM.Example.1")
'Here is the method call to assign the cookie
Cookie = Example.GetCookie()
%&gt;
&lt;HTML&gt;
&lt;BODY&gt;
&lt;%=Cookie%&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;When setting cookies, you must always assign the cookie header before the main body (&lt;HTML&gt; and &lt;BODY&gt; tags) of your page. For instance, this is the wrong way to send the code: </p>
<pre><code>&lt;HTML&gt;
&lt;BODY&gt;
&lt;%
Set Example=Server.CreateObject("SMUM.Example.1")
' The Cookie Header is set with this
' call if a cookie doesn't exist,
' which is too late since some of the body text has
' been sent already.
Cookie = Example.GetCookie()
%&gt;
The Cookie is : &lt;%=Cookie%&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
<h2>Components or Simple Objects? </h2>
<p>
We just ran through the steps to create an Active Server component using the ATL Object Wizard, which inserted code and created files to support the COM object named Example. This is the same code that the wizard would have created if we had chosen to create a simple object. </p>
<p>
Simple objects are sometimes more appropriate for large projects if you plan to use the same object over and over and if that object won't require access to Active Server component interfaces (<b>Application</b>, <b>Request</b>, <b>Response</b>, <b>Server</b>, and <b>Session</b>). When creating an Active Server component, the wizard adds code to access those interfaces. This is convenient only if the component is going to be used in an Active Server environment. </p>
<h2>A Cookie Example </h2>
<p>
If you want to create a customer object based on a cookie, you can call an Active Server component from an ASP page. For example: </p>
<pre><code>Set Creator=Server.CreateObject("SMUM.CustomerCreator.1")
Set Customer = Creator.CreateCustomer
Customer.EmailAddress = "webmaster@signmeup.com" 
</code></pre>
<p>
The cookie call to the <b>Request</b> object is hidden from the ASP developer. When the <b>CustomerCreator</b> object performs the <b>CreateCustomer</b> method, the cookie value is retrieved from the <b>Request</b> interface within the <b>CustomerCreator</b> object. If the user does not currently have a cookie, the <b>Creator</b> object also sets the cookie in the <b>Response</b> interface. Finally, the e-mail address is written to a database, with the cookie serving as the primary key. </p>
<p>
Consider this example in which the <b>Creator</b> object is a simple object instead of an Active Server component. </p>
<pre><code>Set Creator=Server.CreateObject("SMUM.CustomerCreator.1")
Set Customer = Creator.CreateCustomer(Request.Cookies("SMUMID")) 
Response.Cookies("SMUMID") = Customer.Cookie
Customer.EmailAddress = "webmaster@signmeup.com" 
</code></pre>
<p>
In this example, we have to pass the cookie in the <b>Creator</b> object and assign the cookie once we have created the <b>Customer</b> object. This technique makes more work for the programmer. If it is more work, why is it better to create a simple object? The answer lies within the scope of the project. </p>
<p>
For instance, once all the e-mail addresses have been collected from the Web site, you may want to view each customer address from your desktop. With the simple object, you can create a Microsoft Visual Basic® application that views each e-mail address in turn. However, you cannot call the Active Server component from Visual Basic, because the instantiation of the Active Server interfaces would fail. </p>
<p>
Simple objects can be called from Visual Basic and from ASP pages; Active Server components can be called only from ASP pages. For a little more work, you can get a lot more use out of your object.</p>
</BODY>
</HTML>
