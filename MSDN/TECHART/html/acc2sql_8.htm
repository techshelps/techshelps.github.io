<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Changes to Your Data</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Changes to Your Data</h1>
<p>
Changes must be made to certain types of data in a Microsoft Access database to take advantage of SQL Server features.</p>
<h3>Float vs. Double Data Type</h3>
<p>
Two of the most common errors that occur with linked SQL Server tables after modifying a record are "#Deleted" and the related "Data has Changed. Operation stopped." These errors are most often caused by the presence of a <b>float</b> data type column in SQL Server, by a <b>datetime</b> data type on the server, or by a trigger that modifies a value after it is inserted. For more information about these errors, see "Common Error Messages," later in this paper.</p>
<p>
Before you can update a table, the table must have a unique index so that Microsoft Access can identify records. When making an update, Microsoft Access prepares an update query, for example:</p>
<pre><code>Update mytable set(CustName = 'XYZ') where CustID = 12345
</code></pre>
<p>
Before Microsoft Access sends this UPDATE statement, it must consider a possible problem. If someone else edited this record after Microsoft Access first read the message, this update could silently overwrite someone else's changes. To avoid that, Microsoft Access reads the message record again to ensure that it has not changed. If the unique index or the column being changed is a <b>float</b> data type, this process may generate a discrepancy.</p>
<p>
Microsoft Access does not have a <b>float</b> data type. When linked to a SQL Server database with a float field, Microsoft Access converts the values to a Visual Basic <b>double</b> data type. The<b> double</b> and <b>float</b> data types are similar and this is usually a reasonable match. However, these are not exact data types, they are approximate data types. For example, the value of one-third (1/3) cannot be represented as an exact decimal or binary value. To resolve this, the <b>float</b> and <b>double</b> data types use an approximation not unlike scientific notation. However, the C language float and the Visual Basic language double do not use the same formula and calculations may be imprecise. If Microsoft Access can't find the specific value in a SQL Server table because of an imprecise calculation, it will come to one of two conclusions:
<ul type=disc>
<li>
If the <b>float</b> data type was the table's unique index, Microsoft Access assumes the record was deleted because it can't locate the record. <br><br></li>
<li>
If the unique index remains unchanged but the value of the float field is different, Microsoft Access assumes that someone else changed the record and presents the data changed error. </li>
</ul>
<p>
A similar problem occurs if a SQL Server table has a trigger that modifies the value of a column. For example, if Microsoft Access inserts a record with order number 1234 into a table with a trigger that adds the year to the order number (971234), Microsoft Access returns the deleted error as it no longer can find the record it inserted.</p>
<p>
Work around these problems by avoiding <b>float</b> data types as unique indexes identifying the rows. Also include a timestamp field in the table when you use float or datetime fields. When a timestamp field is present, Microsoft Access checks the timestamp only, not all the values in the record, as that would have changed if any column had been updated.</p>
<h3>Identity Data Type</h3>
<p>
SQL Server has an automatically incrementing field, called an Identity field, similar to the Microsoft Access AutoNumber field. The Upsizing Wizard creates a table on the server with an identity field, turns off the functionality of the field with the IDENTITY_INSERT option, copies the existing AutoNumber values into the table, and turns the IDENTITY_INSERT option back on. This preserves the original AutoNumber values from your Microsoft Access table and begins future records with the highest number in your table, incrementing by one. For more information on the use of IDENTITY_INSERT, see Knowledge Base article Q152035 INF, "Appending Data From Access Table to SQL Table."</p>
<h3>Changing True from -1 to +1</h3>
<p>
Microsoft Access stores either a zero (0) or a minus one (-1) in the Yes/No data type. Microsoft Access interprets 0 as 0, No, or False. Microsoft Access interprets any non-zero value as –1, Yes, or True.</p>
<p>
A bit field stored in SQL Server that is selected in ISQL/w appears as either a zero (0) or a plus one (1). Think of the result as True (1) or False (0). When you link to this table with Microsoft Access, you can accurately check for a value of 0 but not 1. The correct method in Microsoft Access is to test for a value of True or False.</p>
<h3>Data Type Conversions</h3>
<p>
The most common data type changes when upgrading from Microsoft Access to SQL Server are:
<ul type=disc>
<li>
Microsoft Access Memo fields become SQL Server text fields.<br><br></li>
<li>
Microsoft Access OLE fields become SQL Server image fields.<br><br></li>
<li>
Microsoft Access text fields become SQL Server varchar fields. This is the default, but the Upsizing Wizard can be modified to convert Microsoft Access text fields to char fields instead. To make this change, start Microsoft Access and open the Upsizing Wizard library database. For Microsoft Access 95, the filename is Wzcs.mda. For Microsoft Access 97, the filename is Wzcs97.mda. When the database is open, select the <b>Modules</b> tab and open the UT_ModUserConstants module. Search for the UT_USE_CHAR constant and change the default value from False to True.</li>
</ul>
<p>
For more information about data type conversions, see the "Table of Data Type Conversions" in the Appendix.</p>
<h3>Top N Queries</h3>
<p>
SQL Server does not have the Microsoft Access syntax for a Top N or Top N Percent query. You can provide this functionality in SQL Server by ordering the output and returning the specified number of rows. The SET statement precedes the SELECT statement.</p>
<pre><code>SET rowcount 5
SELECT qty, ord_date 
FROM sales
ORDER BY qty DESC
</code></pre>
<p>
To calculate a percentage of the rows returned, declare a variable. Count the records and compute the number of records that you want. Select the correct number of records. This query returns the top third of the records.</p>
<pre><code>DECLARE @desiredrows int
SELECT @ desiredrows = COUNT(*)/3 FROM sales
SET ROWCOUNT @ desiredrows
SELECT qty, ord_date 
FROM sales
ORDER BY qty DESC
</code></pre>
<h3>Unsupported Data Access Objects and Methods</h3>
<p>
The following data access objects are not supported for linked SQL Server tables:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=44%>Container</td>
<td width=56%>Document</td>
</tr>
<tr valign=top>
<td width=44%>Index</td>
<td width=56%>QueryDef</td>
</tr>
<tr valign=top>
<td width=44%>Relation</td>
<td width=56%>Dynaset object in exclusive mode</td>
</tr>
</table><br>
<p>
The following methods are not supported:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=44%>CompactDatabase</td>
<td width=56%>CreateDatabase</td>
</tr>
<tr valign=top>
<td width=44%>CreateField</td>
<td width=56%>CreateQueryDef</td>
</tr>
<tr valign=top>
<td width=44%>DeleteQueryDef</td>
<td width=56%>ListParameters</td>
</tr>
<tr valign=top>
<td width=44%>ListTables</td>
<td width=56%>OpenQueryDef</td>
</tr>
<tr valign=top>
<td width=44%>RepairDatabase</td>
<td width=56%>Seek</td>
</tr>
<tr valign=top>
<td width=44%>SetDefaultWorkspace</td>
<td width=56%></td>
</tr>
</table><br>
</BODY>
</HTML>
