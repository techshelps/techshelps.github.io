<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A Virtual List Box Implementation with VLIST</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_vlb"></a></sup>A Virtual List Box Implementation with VLIST</h1>
<p>
Kyle Marsh<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: September 2, 1992</p>
<p>
Revised: January 26, 1993 (see the "Revisions" section below for a list of changes)</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="174">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the VLIST sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
The standard list box control in Microsoft® Windows™ can contain a limited number of items. Applications may need to implement list boxes that exceed this limitation. This article introduces a custom control called VLIST, which is a <i>virtual list box</i> capable of displaying millions of items. Part 1 of the article provides instructions for using the VLIST virtual list box, and documents the styles and messages that VLIST supports. Part 2 describes how VLIST was implemented, and discusses the problems encountered and decisions made during the implementation; readers who would like to modify VLIST or implement their own virtual list box may find this section interesting. For a working example of VLIST, see the Microsoft Developer Network CD—the topic listing in the Index window was implemented with VLIST.</p>
<h2>Revisions (January 26, 1993)</h2>
<p>
This article was revised on January 26, 1993, to reflect the changes listed below.</p>
<p>
<b>New features in VLIST:</b>
<ul type=disc>
<li>
VLIST now compiles and operates under Win32™.<br><br></li>
<li>
The VLBN_FREEITEM and VLBN_FREEALL notifications were added to allow applications to free items that are not actually displayed.<br><br></li>
<li>
The ID of the VLIST control was added to the VLIST structure to allow multiple VLIST controls for each window or dialog box.<br><br></li>
<li>
The VLBR_FINDSTRING,.VLBR_FINDSTRINGEXACT, VLBR_SELECTSTRING, VLBR_GETITEMDATA, VLBR_GETTEXT, and VLBR_GETTEXTLEN messages were added to differentiate between messages from VLIST to the application and messages from the application to VLIST when the same message could be sent either way. VLBR_ messages are sent from VLIST to the application.<br><br></li>
<li>
The VLBS_3DFRAME style was added.</li>
</ul>
<p>
<b>Bug fixes in VLIST:</b>
<ul type=disc>
<li>
<i>pVLBox-&gt;hwndList</i> is now initialized in <b>VLBCreateHandler</b>.<br><br></li>
<li>
In several places, the line <b>pVLBox-&gt;wFlags &amp; USEDATAVALUES;</b> was changed to <b>pVLBox-&gt;wFlags |= USEDATAVALUES;</b> in the source code.<br><br></li>
<li>
VLB_SELECTSTRING now sets the selection correctly.<br><br></li>
<li>
The <i>lData</i> and <i>lIndex</i> values were reversed in VLB_GETTEXT; this has been corrected.<br><br></li>
<li>
VLIST now sends LBN_SELCHANGE notifications when scrolling the list.<br><br></li>
<li>
Horizontal scrolling has been fixed.<br><br></li>
<li>
VLIST now sends the correct class name to the dialog editor.<br><br></li>
<li>
VLB_GETTEXTLEN now takes a <b>PVLBSTRUCT</b> as <i>lParam</i>, as documented.<br><br></li>
<li>
VLB_GETTOPINDEX now returns the correct value and not always zero.<br><br></li>
<li>
An errant semicolon was removed from VLB_SETTOPINDEX.<br><br></li>
<li>
The selected item no longer changes when the list is scrolled up.</li>
</ul>
<p>
We thank Pablo Ahumada Mardones, Lewis V. Rothrock, Tom McConnell, and Bob Carter for reporting (and, in some cases, fixing) these bugs.</p>
<p>
<b>Documentation errors:</b>
<ul type=disc>
<li>
The VLB_SETTOPINDEX message is now documented correctly.<br><br></li>
<li>
The VLB_SETCURSEL message is now documented correctly.</li>
</ul>
<h2>Introduction</h2>
<p>
The standard list box control in Microsoft® Windows™ version 3.1 has a number of limitations:
<ul type=disc>
<li>
It can display a maximum of 32,767 items.<br><br></li>
<li>
It is limited to 32K of item data. Therefore, list boxes that store strings can contain a maximum of 5440 items, and list boxes that don't store strings (owner-drawn list boxes implemented without the LBS_HASSTRINGS style) can contain a maximum of 8160 items.<br><br></li>
<li>
It is limited to 64K of string data. Therefore, a list box with an average string length of 30 bytes per item can store a maximum of 2184 items.</li>
</ul>
<p>
Future versions of Windows may support standard list boxes that stretch these limits; however, an application designed for Windows version 3.1 must use a custom control for this purpose. The custom control discussed in this article is called a <i>virtual list box</i> and can contain millions of items.</p>
<h3>Is a Virtual List Box Necessary?</h3>
<p>
Before you decide to use a list box with many (say, more than a thousand) items, you should consider the following two issues:
<ul type=disc>
<li>
<b>Appropriateness.</b> Is a list box the best way to display these items? If the list has 10,000 items and only 20 items are visible, the user can see only a small percentage of the list (0.2 percent) at one time. To get from the top of the list to the bottom of the list, the user must page down 500 times. The user can jump to the top or bottom of the list with one action, but finding a particular item in the list is usually a time-consuming task. You should explore better ways to present the data before deciding to use a list box.<br><br></li>
<li>
<b>Overhead.</b> How much overhead is required to fill the list box? Consider a database with 100,000 names. To add all the names to the list box, the application must read through the entire data file, extract and format the names, and add them to the list box one name at a time. The list box, in turn, must allocate memory for each new item and copy the data into this memory. The user is usually interested in a small percentage of the items, and effort spent retrieving and storing all items is wasted overhead. A large amount of data can result in such a huge overhead that performance becomes unacceptable.</li>
</ul>
<p>
If you decide that a list box is the best way to present the data, a virtual list box will help reduce the amount of overhead.</p>
<p>
A virtual list box appears to contain many items, but actually contains only enough items to fill the list box display. When the user scrolls the list box up or down one line, the virtual list box loads the next or previous item to be displayed. When the user scrolls the list box up or down one page, the virtual list box loads the previous or next page of items. A virtual list box that loads and unloads items in this manner is also called a <i>paging list box</i> (or <i>swapping list box</i>).</p>
<h3>Advantages of the Virtual List Box</h3>
<p>
A virtual list box has three advantages over the Windows standard list box control:
<ul type=disc>
<li>
<b>Unlimited size.</b> A virtual list box can accommodate up to four billion items. For example, you can create a virtual list box that contains all of the names in the phone book. Of course, paging through a few million names is probably the last thing a user wants to do, so a virtual list box with that many items is just as inappropriate as a standard list box.<br><br></li>
<li>
<b>Small overhead.</b> The only overhead required involves displaying the current page to the user. By keeping overhead to a minimum, a virtual list box can appear to contain many thousands of items without incurring a performance penalty. Instead of reading hundreds or thousands of records and putting them into a list box, the application reads only a few records at a time. For example, a multiuser database application strives to keep locked records at a minimum. In this case, a virtual list box is more efficient than a standard list box, even when displaying a small number of items.<br><br></li>
<li>
<b>Reasonable memory requirements.</b> A virtual list box does not require a large amount of memory because it loads a limited number of items at one time. Even if a large amount of memory is available, either physically or through Windows virtual memory modes (enhanced mode and Windows NT™), you should keep memory usage to a minimum to improve overall system performance.</li>
</ul>
<h3>Disadvantages of the Virtual List Box</h3>
<p>
A virtual list box does have two disadvantages:
<ul type=disc>
<li>
<b>Slower scrolling speed.</b> A standard list box stores all items in memory and is ready to display them instantly. A virtual list box must add new items and remove old items as it scrolls the list. Depending on how complicated the logic is for retrieving the new items, scrolling may result in a noticeable performance degradation.<br><br></li>
<li>
<b>Increased coding requirements.</b> In a standard list box, the application usually scans items once, as they are added to the list. In a virtual list box, the application must be able to scan items forward and backward from any given starting point in the list.</li>
</ul>
<h2>Part 1.&nbsp; Using VLIST</h2>
<p>
The VLIST custom control implements a single-selection, single-column virtual list box. VLIST manages functions such as filling and scrolling the list box, but relies on the application to retrieve items for the list box. This leads to a control situation that differs considerably from the control situation for a standard list box. With a standard list box, the application adds and removes items as needed. When items are added, the list can be scrolled without any further information from the application. With VLIST, the application sends the VLIST control a message indicating that it is ready to receive messages. From that point on, the VLIST control sends messages to the application to request information.</p>
<p>
VLIST requires two types of information:
<ul type=disc>
<li>
A long integer indicating the number of items in the VLIST control.<br><br></li>
<li>
An item to be used by the VLIST control.</li>
</ul>
<h3>How Many Items?</h3>
<p>
To control the scroll box (also known as the scrollbar thumb), VLIST must know the number of items in the list. A standard list box obtains the number of items in the list by counting items as they are added to the list. Applications that use the VLIST control, however, may not be able to obtain this information easily. Without this information, VLIST is unable to control the scroll range and cannot position the scroll box correctly.</p>
<p>
For example, let's assume that the VLIST control contains customer names that start with <i>M</i>, <i>N</i>, or <i>O</i>. Most databases cannot tell the application how many names fit this criterion without actually counting the names. Counting could be a time-consuming operation, so the application may decide to tell VLIST that it does not know how many items are going to be in the list.</p>
<p>
If an application cannot determine the number of items in the virtual list box, VLIST places the scroll box in the middle of the scroll bar. This allows the user to scroll up or down the list one page or line at a time using the scroll bar or scroll arrows. The user can also move the scroll box to a specific position in the scroll bar. In this case, VLIST asks the application for the item closest to the specified location and positions the list accordingly. The application may or may not be able to provide the information; in either case, the scroll box returns to the middle of the scroll bar. Because the placement of the scroll box should represent the current position in the list, placing the scroll box in the middle of the bar is likely to mislead and confuse the user. Whenever possible, an application should determine the number of items in the virtual list box to avoid this situation.</p>
<p>
VLIST can be modified to present a different appearance when the number of items in the list is not known. For example, VLIST could have buttons for line up, line down, page up, and page down instead of a scroll bar (see Figure 1).</p>
<p>
<img src="vlb_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Customizing the VLIST control</b></p>
<p>
This new interface solves the scroll box placement problem by omitting the scroll box. Because the control does not look like a standard list box, the user does not expect it to act like one. The trade-off is the additional documentation this interface would require. (On the other hand, a scroll bar that does not operate correctly also requires additional documentation.)</p>
<h3>What Item?</h3>
<p>
A standard list box identifies an individual item by its index number. The item at the top of the list is item 0, the next item is item 1, and so on. In some cases, it would be better if the application used a 32-bit data value instead of the index number to identify an item. For example, in a list of customer names that begin with <i>M</i>, it may be impractical for the application to get item number 1000. The application can start at the first item and get the next item until it reaches item number 1000, but it may incur a severe performance penalty in doing so. In this case, it would be easier for the application to get the item based on a 32-bit data value associated with an item. If this data value is the record identifier for the item in the database, the application can go directly to the record associated with this item. For convenience, VLIST can use either the item's index number or its 32-bit data value (which is supplied by the application) to identify the item—the application makes this choice. (See "The Item Identifier" section, later in this article.)</p>
<h4>Using the index number</h4>
<p>
How an application identifies an item affects how VLIST responds to certain actions. When an application uses the item's index number as an identifier, VLIST can use the index number to position the scroll box accurately. For example, when item number 50 is displayed in the first line of a list box that contains 100 items, VLIST can place the scroll box in the middle of the scroll bar. The index number also allows VLIST to respond to a user's request to jump to a particular location in the list. If there are 100 items in the list and the user wants to see 75 percent through the list, VLIST asks the application for item number 75.</p>
<h4>Using the counter</h4>
<p>
When the application requests that VLIST use the 32-bit data value to identify an item, VLIST cannot use the item index to position the scroll box, but will use its own counter instead. This counter is initialized when the top or bottom of the list is displayed. When the user scrolls up or down the list, VLIST increases or decreases the counter as needed. This gives a good approximation of where the scroll box should be located. However, when the list moves without scrolling (for example, in response to a search), VLIST places the scroll box in the middle of the scroll bar because it does not know where to position it. As discussed previously, this placement gives the user incorrect feedback about the actual list position and must be documented.</p>
<p>
An application that uses VLIST should use index numbers to identify items whenever possible. When the user requests to jump to a particular location, for example, by moving the scroll box 75 percent of the way down the scroll bar, VLIST asks the application for the item that is 75 percent of the way through the list. If the application cannot fulfill this request, VLIST will not move the list to jump to the user-requested location. For example, many databases cannot easily go to the record that is 75 percent of the way through a file, so database applications may not be able to comply with the user's request. All applications should be able to respond to the 0 percent (top of list) and 100 percent (bottom of list) requests.</p>
<h3>Communications Between VLIST and the Application</h3>
<p>
The VLIST control communicates with the application through messages. The application starts the communication by sending an initialization message to VLIST. From that point on, both VLIST and the application communicate through messages. The application sends its messages to the VLIST window; VLIST sends its messages to its parent window. When VLIST is used in a dialog box, VLIST sends its messages to the dialog manager, which passes them to the dialog procedure.</p>
<h3>The Item Identifier</h3>
<p>
Some messages accept or return a particular item. As discussed in the "What Item?" section, an item can be identified either through an index number or through a 32-bit data value supplied by the application. By default, the index number is used unless the application:
<ul type=disc>
<li>
Specifies the VLB_USEDATAVALUES style, which forces the use of data values.<br><br></li>
<li>
Returns VLB_ERR in the <b>nStatus</b> field of the <b>VLBSTRUCT</b> structure in response to a VLB_RANGE message. (See the next section for a discussion of <b>VLBSTRUCT</b>.) VLIST uses VLB_RANGE to obtain the number of items in the list. If the number of items is not known, both VLIST and the application use 32-bit data values to identify items.</li>
</ul>
<h3>The Virtual List Box Structure</h3>
<p>
Because messages are limited to two parameters, <i>wParam</i> and <i>lParam</i>, and VLIST needs to send and receive more information than can fit within these parameters, VLIST defines a structure called <b>VLBSTRUCT</b> to pass information to and from the application. <b>VLBSTRUCT</b> has the following format:</p>
<pre><code>typedef struct _VLBStruct {
 &nbsp; int&nbsp;&nbsp; nCtlID;
 &nbsp; int&nbsp;&nbsp; nStatus;
 &nbsp; LONG&nbsp; lData;
 &nbsp; LONG&nbsp; lIndex;
 &nbsp; LPSTR lpTextPointer;
 &nbsp; LPSTR lpFindString;
} VLBSTRUCT;
</code></pre>
<p>
where:
<ul type=disc>
<li>
<b>nCtlID</b> is the ID of the VLIST control.<br><br></li>
<li>
<b>nStatus</b> is set by the application to indicate the status of the request by VLIST. Values are VLB_OK (successful), VLB_ERR (an error occurred), and VLB_ENDOFFILE (end of file was reached).<br><br></li>
<li>
<b>lData</b> is the 32-bit data value associated with the item. This value is used both by VLIST, as it makes a request, and by the application, as it fulfills a request. VLIST always associates the data value with the item in the list, so there is no need to send another message to make this association.<br><br></li>
<li>
<b>lIndex</b> is the logical index for the item. This is a 32-bit data value because the virtual list box can contain more than 32,767 items. If the application cannot identify the item index, this number has no meaning and is ignored by VLIST.<br><br></li>
<li>
<b>lpTextPointer</b> is a pointer to the text string for the item. This value is filled in by the application as it passes an item to VLIST. If the list box is an owner-drawn list box and does not have the VLBS_HASSTRINGS style, this value has no meaning and is ignored by VLIST.<br><br></li>
<li>
<b>lpFindString</b> is a pointer to a string to search for in the list box. This value is filled in by VLIST when it sends a VLB_FINDSTRING, VLB_FINDSTRINGEXACT, or VLB_SELECTSTRING message to the application. This value has no meaning at other times and is ignored by VLIST.</li>
</ul>
<h3>VLIST Styles</h3>
<p>
The VLBS_ styles described in this section have the same meanings as their LBS_ counterparts in Windows version 3.1, except for VLBS_NOINTEGRALHEIGHT, which VLIST treats differently. VLIST also adds a new style called VLBS_USEDATAVALUES for identifying items. For more information on the LBS_ counterparts of these styles, see the "List Box Controls" technical article on the Microsoft Developer Network CD (Technical Articles, Windows Articles, Window Manager Articles).</p>
<p>
<b>VLBS_3DFRAME</b></p>
<p>
Specifies that the VLIST control has a 3-D frame.</p>
<p>
<b>VLBS_HASSTRINGS</b></p>
<p>
Specifies that the VLIST control contains items consisting of strings. VLIST maintains the memory and pointers for the strings so the application can use the VLB_GETTEXT message to retrieve the text for a particular item. By default, all VLIST controls except those that are owner-drawn have this style. An application can create an owner-drawn VLIST control either with or without this style.</p>
<p>
<b>VLBS_NOINTEGRALHEIGHT</b></p>
<p>
Specifies that the size of VLIST is exactly the size specified by the application when it created the VLIST control. Normally, VLIST sizes a control so that it does not display partial items. Please note that VLIST does not support the display of partial items even when this style is used. If a VLIST control has the VLBS_NOINTEGRALHEIGHT style, VLIST leaves the space for a partial line blank.</p>
<p>
<b>VLBS_NOREDRAW</b></p>
<p>
Specifies that the appearance of the VLIST control is not updated when changes are made. This style can be changed at any time by sending a WM_SETREDRAW message.</p>
<p>
<b>VLBS_NOTIFY</b></p>
<p>
Specifies that VLIST notifies the application with an input message whenever the user clicks or double-clicks an item.</p>
<p>
<b>VLBS_OWNERDRAWFIXED</b></p>
<p>
Specifies that the owner of VLIST is responsible for drawing the contents of the VLIST control and that the items in the control are of the same height. The owner window receives a WM_MEASUREITEM message when the list box is created and a WM_DRAWITEM message when a visual aspect of the list box has changed.</p>
<p>
<b>VLBS_USEDATAVALUES</b></p>
<p>
Specifies that VLIST always uses an item's 32-bit data value to identify the item. The index number is ignored.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This style uses a bit that the standard Windows list box does not use, so it may conflict with a new list box style in the future.</p>
<p>
<b>VLBS_USETABSTOPS</b></p>
<p>
Allows VLIST to recognize and expand tab characters when drawing its strings. The default tab positions are 32 dialog box units.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;A dialog box unit is a horizontal or vertical distance. One horizontal dialog box unit is equal to one-fourth of the current dialog box base width unit. The dialog box base units are computed from the height and width of the current system font. The <b>GetDialogBaseUnits</b> function returns the current dialog box base units in pixels.</p>
<p>
<b>VLBS_WANTKEYBOARDINPUT</b></p>
<p>
Specifies that the owner of the VLIST control receives WM_VKEYTOITEM or WM_CHARTOITEM messages whenever the user presses a key and the list box has the input focus. This allows an application to perform special processing on the keyboard input. If a list box has the VLBS_HASSTRINGS style, the list box can receive WM_VKEYTOITEM messages but not WM_CHARTOITEM messages. If a list box does not have the VLBS_HASSTRINGS style, the list box can receive WM_CHARTOITEM messages as well as WM_VKEYTOITEM messages.</p>
<h3>VLIST Messages</h3>
<p>
VLIST supports the messages described below. Most of these are equivalents of the LB_ messages used for standard list boxes.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;VLIST also accepts the LB_ messages, but these messages treat the virtual control as a standard list box and may cause unpredictable behavior in VLIST.</p>
<p>
<b>VLB_FINDITEM</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
VLIST sends this message to the application to request the item specified in <i>lpvlb</i>. If the application can locate the item, it returns VLB_OK in <i>lpvlb-&gt;nStatus</i> and the item in <i>lpvlb</i>. Otherwise, it returns VLB_ERR in <i>lpvlb-&gt;nStatus</i>.</p>
<p>
<b>VLB_FINDPOS</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
VLIST sends this message to the application to request the item that is located a specified percentage down the list. The percentage is specified in the <i>lpvlp-&gt;lIndex </i>and<i> lpvlb-&gt;lData </i>fields. If the application can locate the item, it returns VLB_OK in <i>lpvlb-&gt;nStatus</i> and the item in <i>lpvlb</i>. Otherwise, it returns VLB_ERR in <i>lpvlb-&gt;nStatus</i>.</p>
<p>
<b>VLB_FINDSTRING, VLB_FINDSTRINGEXACT, VLB_SELECTSTRING<br>
VLBR_FINDSTRING, VLBR_FINDSTRINGEXACT, VLBR_SELECTSTRING</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
The application sends VLIST the following messages to find the string specified in <i>lpvlb-&gt;lpszFindString</i>:
<ul type=disc>
<li>
VLB_FINDSTRING searches for an item that begins with the characters in the specified string.<br><br></li>
<li>
VLB_FINDSTRINGEXACT searches for an item that matches the specified string.<br><br></li>
<li>
VLB_SELECTSTRING searches for an item that begins with the characters in the specified string and selects that item.</li>
</ul>
<p>
To locate the string, VLIST sends the corresponding VLBR_ message with the same <i>wParam</i> and <i>lParam</i> values to the application. The application is free to implement any search technique it needs at this point (that is, the application can deviate from the descriptions of VLB_FINDSTRING, VLB_FINDSTRINGEXACT, and VLB_SELECTSTRING above). If the application locates the requested item, it returns VLB_OK in <i>lpvlb-&gt;nStatus</i>, and VLIST returns the item identifier to the application. (If the message is VLB_SELECTSTRING, VLIST also selects the item.) If the application cannot find the requested item, it returns a status of VLB_ERR in <i>lpvlb-&gt;nStatus</i>,<i> </i>and VLIST returns VLB_ERR to the application.</p>
<p>
<b>VLB_FIRST</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
VLIST sends this message to the application to request the first item in the list. If the application can locate the item, it returns VLB_OK in <i>lpvlb-&gt;nStatus</i> and the item in <i>lpvlb</i>. Otherwise, it returns VLB_ERR in <i>lpvlb-&gt;nStatus</i>.</p>
<p>
<b>VLB_GETCOUNT</b></p>
<pre><code>wParam = 0;
lParam = 0L;
</code></pre>
<p>
The application sends this message to VLIST to request the number of items in the virtual list box. VLIST returns the number of items in the virtual list, or –1L if it does not know the number.</p>
<p>
<b>VLB_GETCURSEL</b></p>
<pre><code>wParam = 0;
lParam = 0L;
</code></pre>
<p>
The application sends this message to VLIST to request the ID of the currently selected item. VLIST returns the item identifier for the selected item, or –1L if no item is currently selected.</p>
<p>
<b>VLB_GETHORIZONTALEXTENT</b></p>
<pre><code>wParam = 0;
lParam = 0L;
</code></pre>
<p>
The application sends this message to VLIST to request the horizontal extent for the virtual list box. VLIST returns the horizontal extent of the list box in pixels.</p>
<p>
<b>VLB_GETITEMDATA<br>
VLBR_GETITEMDATA</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
The application sends the VLB_GETITEMDATA message to VLIST to retrieve the 32-bit data value associated with the item specified in <i>lpvlb</i>. If the item is not currently displayed in the list box, VLIST sends the VLBR_GETITEMDATA message to the application to request the data value. If the application locates the item, it returns VLB_OK in <i>lpvlb-&gt;nStatus</i> and the data value in <i>lpvlb-&gt;lData</i>; if it cannot locate the item, it returns VLB_ERR in <i>lpvlb-&gt;nStatus</i>. VLIST returns the 32-bit data value of the specified item, or VLB_ERR if it cannot obtain this value.</p>
<p>
<b>VLB_GETITEMHEIGHT</b></p>
<pre><code>wParam = 0;
lParam = 0L;
</code></pre>
<p>
The application sends this message to VLIST to request the height of items in the list box. VLIST returns the height in pixels.</p>
<p>
<b>VLB_GETITEMRECT</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
The application sends this message to VLIST to request the client rectangle for the item specified in <i>lpvlb</i>. The pointer to the RECT structure that is to receive the rectangle must be placed in the <b>lpTextPointer</b> field of <i>lpvlb</i>. If the item is visible, VLIST returns VLB_OK. If the item is not currently visible, VLIST returns VLB_ERR.</p>
<p>
<b>VLB_GETLINES</b></p>
<pre><code>wParam = 0;
lParam = 0L;
</code></pre>
<p>
The application sends this message to VLIST to request the number of visible lines in the list box. VLIST returns the number of visible items in the list.</p>
<p>
<b>VLB_GETTEXT<br>
VLBR_GETTEXT</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
The application sends the VLB_GETTEXT message to VLIST to retrieve the string for the item specified in <i>lpvlb</i>. If the specified item is not visible, VLIST sends the VLBR_GETTEXT message to the application to request the text. VLIST returns the string length in bytes and copies the string to <i>lpvlb-&gt;lpszText</i>. If VLIST cannot obtain the string for the specified item, it returns VLB_ERR. The location that <i>lpvlb-&gt;lpszText</i> points to must be large enough to hold the string and terminating null character. You can use VLB_GETTEXTLEN to obtain the length of the string before copying it. If the application locates the item, it returns VLB_OK in <i>lpvlb-&gt;nStatus</i> and the string in <i>lpvlb-&gt;lpszText</i>. If it cannot locate the item, it returns VLB_ERR in <i>lpvlb-&gt;nStatus</i>.</p>
<p>
<b>VLB_GETTEXTLEN<br>
VLBR_GETTEXTLEN</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
The application sends the VLB_GETTEXTLEN message to VLIST to request the string length for the item specified in <i>lpvlb</i>. If the specified item is not visible, VLIST sends the VLBR_GETTEXTLEN message to the application to request the string length. VLIST returns the string length, or VLB_ERR if it cannot obtain the string for the specified item. If the application locates the item, it returns VLB_OK in <i>lpvlb-&gt;nStatus</i> and the string in <i>lpvlb-&gt;lpszText</i>. If the application cannot locate the item, it returns VLB_ERR in <i>lpvlb-&gt;nStatus</i>.</p>
<p>
<b>VLB_GETTOPINDEX</b></p>
<pre><code>wParam = 0;
lParam = 0L;
</code></pre>
<p>
The application sends this message to VLIST to request the first visible item in the list. VLIST returns the item identifier for this item.</p>
<p>
<b>VLB_INITIALIZE</b></p>
<pre><code>lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
The application sends this message to VLIST to initialize the list box. When VLIST receives this message, it begins managing the virtual list box functions. VLIST returns VLB_OK.</p>
<p>
<b>VLB_LAST</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
VLIST sends this message to the application to request the last item in the list. If the application can locate the item, it returns VLB_OK in <i>lpvlb-&gt;nStatus</i> and the item in <i>lpvlb</i>. Otherwise, it returns VLB_ERR in <i>lpvlb-&gt;nStatus</i>.</p>
<p>
<b>VLB_NEXT</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
VLIST sends this message to the application to request the item after the item specified in <i>lpvlb</i>. If the application can locate the item, it returns VLB_OK in <i>lpvlb-&gt;nStatus</i> and the item in <i>lpvlb</i>. Otherwise, it returns VLB_ERR in <i>lpvlb-&gt;nStatus</i>.</p>
<p>
<b>VLB_PAGEDOWN</b></p>
<pre><code>nAdjust = wParam;
lParam&nbsp; = 0L;
</code></pre>
<p>
The application sends this message to VLIST to scroll the virtual list box down one page. A page is the number of visible lines. The application can adjust the number of items scrolled by specifying the number of lines to add to the page size. A negative value causes the virtual list box to scroll fewer than the visible number of lines; a positive value causes the virtual list box to scroll more than the visible number of lines. The message returns VLB_ERR if an error occurs.</p>
<p>
<b>VLB_PAGEUP</b></p>
<pre><code>nAdjust = wParam;
lParam = 0L;
</code></pre>
<p>
The application sends this message to VLIST to scroll the virtual list box up one page. A page is the number of visible lines. The application can adjust the number of items scrolled by specifying the number of lines to add to the page size. A negative value causes the virtual list box to scroll fewer than the visible number of lines; a positive value causes the virtual list box to scroll more than the visible number of lines. The message returns VLB_ERR if an error occurs.</p>
<p>
<b>VLB_PREV</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
VLIST sends this message to the application to request the item before the item specified in <i>lpvlb</i>. If the application can locate the item, it returns VLB_OK in <i>lpvlb-&gt;nStatus</i> and the item in <i>lpvlb</i>. Otherwise, it returns VLB_ERR in <i>lpvlb-&gt;nStatus</i>.</p>
<p>
<b>VLB_RANGE</b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
After receiving the VLB_INITIALIZE, VLB_UPDATEPAGE, and VLB_RESETCONTENT messages, VLIST sends this message to the application to request the number of items in the virtual list box. If the application knows the number of items, it returns VLB_OK in <i>lpvlb-&gt;nStatus</i> and the number of items in <i>lpvlb-&gt;lIndex</i>. If the application does not know the number of items in the virtual list box, it returns VLB_ERR in <i>lpvlb-&gt;nStatus.</i></p>
<p>
<b>VLB_RESETCONTENT</b></p>
<pre><code>wParam = 0;
lParam = 0L;
</code></pre>
<p>
The application sends this message to VLIST to request that VLIST reset the contents of the list box. In response, VLIST sends a VLB_RANGE message to its parent window and displays the top of the virtual list. VLIST returns VLB_OK.</p>
<p>
<b>VLB_SETCURSEL</b></p>
<pre><code>wParam = nOption;
lParam = (LPARAM) lIndex or lData;
</code></pre>
<p>
The application sends this message to VLIST to select an item and to scroll it into view if necessary. The <i>nOption</i> parameter specifies how the target item is determined and can have the following values:
<ul type=disc>
<li>
VLB_FINDITEM—Find the item specified in <i>lParam</i>. <br><br></li>
<li>
VLB_FIRST—Find the first item in the list.<br><br></li>
<li>
VLB_LAST—Find the last item in the list. The last item is displayed at the bottom of the list box.<br><br></li>
<li>
VLB_NEXT—Find the item after the item specified in <i>lParam</i>. If the <i>lParam</i> item is at the bottom of the list box, VLIST scrolls the list down one line so the target item is at the bottom of the list box. If the specified item is not visible, VLIST positions the list so the target item is at the top of the list box.<br><br></li>
<li>
VLB_PREV—Find the item before the item specified in <i>lParam</i>. If the <i>lParam</i> item is at the top of the list box, VLIST scrolls the list up one line so the target item is at the top of the list box. If the specified item is not visible, VLIST positions the list so the target item is at the top of the list box.</li>
</ul>
<p>
VLIST returns VLB_OK if it can locate the target item, or VLB_ERR if it cannot.</p>
<p>
<b>VLB_SETHORIZONTALEXTENT</b></p>
<pre><code>wParam = nHorizontalExtent;
lParam = 0L;
</code></pre>
<p>
The application sends this message to VLIST to set the horizontal scroll range to the given value. This message does not return a value.</p>
<p>
<b>VLB_SETITEMDATA </b></p>
<pre><code>wParam = 0;
lpvlb = (LPVLBSTRUCT) lParam;
</code></pre>
<p>
The application sends this message to VLIST to set the 32-bit data value of the item specified in <i>lpvlb </i>to<i> </i>the value in <i>lpvlb-&gt;lData</i>. If the item is not currently visible, the data value is not set. This message returns VLB_ERR if an error occurs.</p>
<p>
<b>VLB_SETITEMHEIGHT</b></p>
<pre><code>wParam&nbsp; = 0;
lParam = MAKELPARAM(cyItem, 0);
</code></pre>
<p>
The application sends this message to VLIST to set the line height of items in the list box to the given value. The message returns VLB_ERR if the height is invalid.</p>
<p>
<b>VLB_SETTABSTOPS</b></p>
<pre><code>wParam = (WPARAM) cTabs;&nbsp; 
lParam = (LPARAM) (int FAR*) lpTabs;
</code></pre>
<p>
The application sends this message to set the tab-stop positions in the virtual list box. (The virtual list box must be created with the VLBS_USETABSTOPS style.)
<ul type=disc>
<li>
If the <i>cTabs</i> parameter is zero and the <i>lpTabs</i> parameter is NULL, the default tab stop is two dialog box units.<br><br></li>
<li>
If <i>cTabs</i> is 1, the list box has tab stops separated by the distance specified by <i>lpTabs</i>.<br><br></li>
<li>
If <i>lpTabs</i> points to more than a single value, a tab stop is set for each value in <i>lpTabs</i>, up to the number specified by <i>cTabs</i>.</li>
</ul>
<p>
A dialog box unit is a horizontal or vertical distance. One horizontal dialog box unit is equal to one-fourth of the current dialog box base width unit. The dialog box base units are computed from the height and width of the current system font. The <b>GetDialogBaseUnits</b> function returns the current dialog box base units in pixels. For more information on dialog units, see the "Ask Dr. GUI #5" technical article on the Microsoft Developer Network CD. The message returns nonzero if all the tabs were set; otherwise, the return value is zero.</p>
<p>
<b>VLB_SETTOPINDEX</b></p>
<pre><code>wParam = 0;
lParam = (LPARAM) index;
</code></pre>
<p>
The application sends this message to VLIST to ensure that the item specified in <i>lParam</i> is visible. VLIST positions the list so that either the specified item appears at the top of the list box or the maximum scroll range has been reached. The message returns VLB_ERR if an error occurs.</p>
<p>
<b>VLB_UPDATEPAGE</b></p>
<pre><code>wParam = 0;
lParam = 0L;
</code></pre>
<p>
The application sends this message to VLIST to update the contents of the virtual list box. VLIST does not add or delete items in the same way a standard list box does. To add, remove, or update the items in the virtual list, the application must use VLB_UPDATEPAGE. The message returns VLB_ERR if an error occurs.</p>
<p>
<b>VLBN_FREEALL</b></p>
<pre><code>wParam = 0;
lParam = 0L;
</code></pre>
<p>
VLIST sends this message to the application when VLIST removes all the items from the display. This allows the application to free any memory required by the items or to free any lock that the items might have.</p>
<p>
<b>VLBN_FREEITEM</b></p>
<pre><code>wParam = 0;
lParam = lData or lIndex;
</code></pre>
<p>
VLIST sends this message to the application when VLIST removes the specified item from the display. This allows the application to free any memory required by the item or to free any lock that the item might have.</p>
<h3>Sample Dialog Procedure</h3>
<p>
In the following code, the <b>DIALOGSMsgProc</b> function shows the dialog procedure for a dialog box that contains a VLIST control. The virtual list box has 10,000 items in the format:</p>
<p class=indent>
<i>nnnn</i> Item</p>
<p>
where <i>nnnn</i> is the item number.</p>
<pre><code>BOOL FAR PASCAL DIALOGSMsgProc(HWND hWndDlg, UINT Message, WPARAM 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wParam, LPARAM lParam)
{
 int i,j;
 HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwndList;
 static char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szText[128];
 LPVLBSTRUCT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct;

 switch(Message)
 &nbsp; {
 &nbsp;&nbsp; case WM_INITDIALOG:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwCenter(hWndDlg, 0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Initialize working variables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwndList = GetDlgItem(hWndDlg, 101);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage(hwndList, VLB_INITIALIZE, 0, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; /* End of WM_INITDIALOG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */

 &nbsp;&nbsp; case WM_CLOSE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Closing the Dialog behaves the same as Cancel&nbsp;&nbsp;&nbsp; */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostMessage(hWndDlg, WM_COMMAND, IDCANCEL, 0L);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; /* End of WM_CLOSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */

 &nbsp;&nbsp; case WM_COMMAND:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(wParam)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case IDOK:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EndDialog(hWndDlg, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp; /* End of WM_COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */

 &nbsp;&nbsp; case VLB_PREV:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct = (LPVLBSTRUCT)lParam;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( lpvlbInStruct-&gt;lIndex &gt; 0 ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;nStatus = VLB_OK;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lIndex--;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lData = lpvlbInStruct-&gt;lIndex;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(szText,"%ld Item",lpvlbInStruct-&gt;lIndex);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lpTextPointer = szText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;nStatus = VLB_ENDOFFILE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case VLB_FINDPOS:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct = (LPVLBSTRUCT)lParam;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( lpvlbInStruct-&gt;lIndex == 0L ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto First;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ( lpvlbInStruct-&gt;lIndex == 100L ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Last;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lIndex = lpvlbInStruct-&gt;lData*1000L;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;nStatus = VLB_OK;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(szText,"%ld Item",lpvlbInStruct-&gt;lIndex);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lpTextPointer = szText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case VLB_FINDITEM:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct = (LPVLBSTRUCT)lParam;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lIndex = lpvlbInStruct-&gt;lData;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;nStatus = VLB_OK;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(szText,"%ld Item",lpvlbInStruct-&gt;lIndex);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lpTextPointer = szText;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case VLBR_FINDSTRING:
 &nbsp;&nbsp; case VLBR_FINDSTRINGEXACT:
 &nbsp;&nbsp; case VLBR_SELECTSTRING:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrcpy(szText,lpvlbInStruct-&gt;lpFindString);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lIndex = atol(szText);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(szText,"%ld Item",lpvlbInStruct-&gt;lIndex);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lpTextPointer = szText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lData = lpvlbInStruct-&gt;lIndex;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;nStatus = VLB_OK;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case VLB_RANGE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct = (LPVLBSTRUCT)lParam;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lIndex = 100000L;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;nStatus = VLB_OK;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case VLB_NEXT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct = (LPVLBSTRUCT)lParam;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( lpvlbInStruct-&gt;lIndex &lt; 99999L ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;nStatus = VLB_OK;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lIndex++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lData = lpvlbInStruct-&gt;lIndex;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(szText,"%ld Item",lpvlbInStruct-&gt;lIndex);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lpTextPointer = szText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;nStatus = VLB_ENDOFFILE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case VLB_FIRST:
First:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct = (LPVLBSTRUCT)lParam;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;nStatus = VLB_OK;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lIndex = 0L;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(szText,"%ld Item",lpvlbInStruct-&gt;lIndex);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lpTextPointer = szText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lData = lpvlbInStruct-&gt;lIndex;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;

 &nbsp;&nbsp; case VLB_LAST:
Last:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct = (LPVLBSTRUCT)lParam;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;nStatus = VLB_OK;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lIndex = 99999L;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(szText,"%ld Item",lpvlbInStruct-&gt;lIndex);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lpTextPointer = szText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lData = lpvlbInStruct-&gt;lIndex;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case VLB_GETITEMDATA:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct = (LPVLBSTRUCT)lParam;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;nStatus = VLB_OK;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpvlbInStruct-&gt;lData = lpvlbInStruct-&gt;lIndex;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp; }
 return TRUE;
}
</code></pre>
<h2>Part 2.&nbsp; Implementing VLIST</h2>
<p>
This section describes the implementation of VLIST for those of you who are interested in its history. This information is useful for readers who would like to modify VLIST or create their own virtual list boxes.</p>
<h3>Two Methods for Implementing a Virtual List Box</h3>
<p>
Ideally, a virtual list box should look and behave exactly like a standard list box, and should support the same styles as a standard list box (owner-drawn, multiple or extended selection, multiple column, and so on). You can implement a virtual list box in two ways:
<ol>
<li>
<b>Write the virtual list box from scratch</b>.<p class=tl>
The disadvantage of this method is the tremendous effort required to duplicate the functionality of a standard list box. Each new feature that Windows adds to the standard list box must be duplicated in the virtual list box. The advantage of this method is that it yields a virtual list box without compromises—you can modify the behavior of the list box because the code is custom.</P></li>
<li>
<b>Write a virtual list box based on a standard Windows list box.</b><p class=tl>
This method requires less effort than method 1 because you can use most of the functionality of the standard list box as is. New features added to the standard list box need not be added to the virtual list box. However, this method may require some compromises—because the behavior of the base list box is under the control of Windows, modifying the behavior for a particular virtual list box may not be possible.</P></li>
</ol>
<p>
The following sections describe the implementation of a virtual list box (called VLIST) based on a Windows list box (method 2 above).</p>
<h3>Two Windows</h3>
<p>
The VLIST virtual list box control consists of two windows:
<ul type=disc>
<li>
The first window is the main window for the control and provides the border for the virtual list box.<br><br></li>
<li>
The second window is a standard Windows list box, but is created without a border. This window is a child of the main window and covers the main window's client area completely.</li>
</ul>
<p>
These two windows appear together to form a control that looks like a single standard list box. (See Figure 2.)</p>
<p>
<img src="vlb_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The two windows in VLIST</b></p>
<h3>Why Two Windows?</h3>
<p>
Using two windows allows VLIST to be packaged as a separate window class and as a custom control, so a developer can use the virtual list box as easily as any of the standard controls provided with Windows.
<ul type=disc>
<li>
Using a separate window class allows you to use the window's extra bytes to store a pointer to a structure that contains the information for each virtual list box instance. This is necessary because a virtual list box needs to store its own control information.<br><br></li>
<li>
Packaging the virtual list box as a custom control lets you access it through the Dialog Editor.</li>
</ul>
<p>
You could also implement VLIST by subclassing a standard list box, but that would mean that an application that uses the virtual list box would have to create a standard list box, and then subclass it. If the virtual list box is written from scratch, it needs only one window.</p>
<h3>Creating the VLIST Control</h3>
<p>
An application that uses VLIST creates the VLIST main window by calling the <b>CreateWindow</b> or <b>DialogBox</b> function. When the main window is created, VLIST must do some initialization processing of its own by processing the WM_NCCREATE and WM_CREATE messages.</p>
<h4>WM_NCCREATE</h4>
<p>
When VLIST gets the WM_NCCREATE message from Windows, it locally allocates its information structure, stores the pointer to the structure in the window's extra bytes, and then ensures that the main window does not have vertical or horizontal scroll bars.</p>
<pre><code>LONG VLBNcCreateHandler( HWND hwnd, LPCREATESTRUCT lpcreateStruct)
{
  PVLBOX pVLBox;

  //
  // Allocate storage for the VLBOX structure.
  //
  pVLBox = (PVLBOX) LocalAlloc(LPTR, sizeof(VLBOX));

  if (!pVLBox)
 &nbsp;&nbsp;&nbsp;&nbsp; // Error, no memory
 &nbsp;&nbsp;&nbsp;&nbsp; return((long)NULL);

  SetWindowWord(hwnd, 0, (WPARAM)(WORD)pVLBox);

  pVLBox-&gt;styleSave = lpcreateStruct-&gt;style;

  //
  // Make sure that there are no scroll bar styles.
  //
  SetWindowLong(hwnd, GWL_STYLE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPARAM)(DWORD)( pVLBox-&gt;styleSave &amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~WS_VSCROLL &amp; ~WS_HSCROLL));


  return((LONG)(DWORD)(WORD)hwnd);

}
</code></pre>
<h4>WM_CREATE</h4>
<p>
When VLIST receives the WM_CREATE message from Windows, it initializes the variables in the information structure, and determines the height of the font used and the number of lines in the list box. VLIST then ensures that the style it will use to create the child window list box is acceptable. The child window list box:
<ul type=disc>
<li>
Must not have a scroll bar (do not use WS_VSCROLL or WS_HSCROLL).<br><br></li>
<li>
Must not have a border (do not use WS_BORDER or WS_THICKFRAME).<br><br></li>
<li>
Must not have the following styles (VLIST does not support these):<ul type=disc>
<li>
LBS_SORT: The order of the virtual list box is controlled by the application that uses it.<br><br></li>
<li>
LBS_MULTIPLESEL, LBS_EXTENDEDSEL, LBS_OWNERDRAWVARIABLE, LBS_MULTICOLUMN: These styles are not supported in this example, although it is possible to add support for these.</li>
</ul>
</li>
<li>
Must have the LBS_WANTKEYBOARDINPUT style. VLIST will need to get keyboard events that are sent to the list box so it can react to scrolling keystrokes.<br><br></li>
<li>
Must have the LBS_NOINTEGRALHEIGHT style. VLIST needs to size the child window so that the list box fills the main window's client area completely and the scroll bar appears to be a part of the main window. If you do not use this style, Windows shrinks the child window to fit only visible lines and leaves a blank space between the bottom of the scroll bar and the main window's border.<p class=tl>
<b>Note:</b> VLIST cannot display partially visible lines even if you use LBS_NOINTEGRALHEIGHT, because the way a standard list box scrolls these lines is incompatible with the way VLIST manages scrolling. In a standard list box, when the list is scrolled up, the selected item is moved down. When the selection reaches a partially visible item, Windows forces that item to be fully visible by scrolling the list box up the necessary height. This scrolling causes problems for VLIST, because VLIST needs to control scrolling itself. If VLIST were written from scratch, it could mimic the standard list box behavior and could select partially visible items during scrolling.</P></li>
<li>
Must have the LBS_NOTIFY style, so VLIST can react to changes in the selected item in the child window list box.</li>
</ul>
<p>
After processing the child window's style, VLIST calls <b>CreateWindow</b> to create the child window, and then subclasses the window to handle focus and scrolling functionality.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Don't confuse subclassing the standard list box with implementing VLIST with a subclass. In this program, VLIST (not the application) subclasses the standard list box it uses. The application does not need to subclass VLIST.</p>
<pre><code>LONG VLBCreateHandler( PVLBOX pVLBox, HWND hwnd, LPCREATESTRUCT 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpcreateStruct)
{
  LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; windowStyle = pVLBox-&gt;styleSave;
  RECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc;
  TEXTMETRIC&nbsp;&nbsp;&nbsp;&nbsp; TextMetric;
  HDC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hdc;

  //
  // Initialize variables.
  //
  pVLBox-&gt;hwnd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = hwnd;
  pVLBox-&gt;hwndParent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = lpcreateStruct-&gt;hwndParent;
  pVLBox-&gt;nId&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (int) lpcreateStruct-&gt;hMenu;
  pVLBox-&gt;hInstance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = lpcreateStruct-&gt;hInstance;
  pVLBox-&gt;nvlbRedrawState = 1;
  pVLBox-&gt;lNumLogicalRecs = -2L;
  pVLBox-&gt;lSelItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = -1L;
  pVLBox-&gt;wFlags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;
  pVLBox-&gt;hwndList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;

  //
  // Enforce the use of 32-bit data values.
  //
  if ( windowStyle &amp; VLBS_USEDATAVALUES )
 &nbsp;&nbsp;&nbsp;&nbsp; pVLBox-&gt;wFlags&nbsp; |= USEDATAVALUES;
  else
 &nbsp;&nbsp;&nbsp;&nbsp; pVLBox-&gt;wFlags &amp;= ~USEDATAVALUES;

  //
  // Determine if this VLB is storing strings.
  //
  pVLBox-&gt;wFlags |= HASSTRINGS;
  if ((windowStyle &amp; VLBS_OWNERDRAWFIXED )
 &nbsp;&nbsp;&nbsp; &amp;&amp; (!(windowStyle &amp; VLBS_HASSTRINGS)))
 &nbsp;&nbsp;&nbsp; pVLBox-&gt;wFlags &amp;= ~HASSTRINGS;

  //
  // Get the font height and number of lines.
  //
  hdc = GetDC(hwnd);
  GetTextMetrics(hdc, &amp;TextMetric);
  ReleaseDC(hwnd,hdc);
  pVLBox-&gt;nchHeight = TextMetric.tmHeight;
  GetClientRect(hwnd,&amp;rc);
  pVLBox-&gt;nLines = ((rc.bottom - rc.top) / pVLBox-&gt;nchHeight);

  //
  // Remove borders and scroll bars.
  //
  windowStyle = windowStyle &amp; ~WS_BORDER &amp; ~WS_THICKFRAME;
  windowStyle = windowStyle &amp; ~WS_VSCROLL &amp; ~WS_HSCROLL;

  //
  // Remove standard list box we don't support.
  //
  windowStyle = windowStyle &amp; ~LBS_SORT;
  windowStyle = windowStyle &amp; ~LBS_MULTIPLESEL;
  windowStyle = windowStyle &amp; ~LBS_OWNERDRAWVARIABLE;
  windowStyle = windowStyle &amp; ~LBS_MULTICOLUMN;
  windowStyle = windowStyle &amp; ~VLBS_USEDATAVALUES;

  //
  // Add list box styles we must have.
  //
  windowStyle = windowStyle | LBS_WANTKEYBOARDINPUT;
  windowStyle = windowStyle | LBS_NOINTEGRALHEIGHT;
  windowStyle = windowStyle | LBS_NOTIFY;

  //
  // Create the list box window.
  //
  pVLBox-&gt;hwndList =
 &nbsp;&nbsp; CreateWindowEx((DWORD)0L,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR)"LISTBOX",(LPSTR)NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; windowStyle | WS_CHILD,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.right,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.bottom,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pVLBox-&gt;hwnd,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (HMENU)VLBLBOXID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pVLBox-&gt;hInstance,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);

  if (!pVLBox-&gt;hwndList)
 &nbsp;&nbsp;&nbsp;&nbsp; return((LONG)-1L);

  //
  // Subclass the list box.
  //
  pVLBox-&gt;lpfnLBWndProc = (WNDPROC)SetWindowLong(pVLBox-&gt;hwndList, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GWL_WNDPROC,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LONG)(WNDPROC)LBSubclassProc);

  return((LONG)(DWORD)(WORD)hwnd);
}
</code></pre>
<h3>Destroying the Virtual List Box</h3>
<p>
When the VLIST main window is destroyed, VLIST must free its information structure. This processing occurs when VLIST receives the WM_NCDESTROY message.</p>
<pre><code>void VLBNcDestroyHandler(HWND hwnd,&nbsp; PVLBOX pVLBox, WPARAM wParam, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPARAM lParam)
{

  if (pVLBox)
 &nbsp;&nbsp;&nbsp;&nbsp; LocalFree((HANDLE)pVLBox);

  //
  // In case rogue messages float through after we free 
  // the pVLBox, set the handle in the window structure to
  // FFFF, and test for this value at the top of the VLIST WndProc.
  //
  SetWindowWord(hwnd, 0, (WPARAM)-1);

  DefWindowProc(hwnd, WM_NCDESTROY, wParam, lParam);
}
</code></pre>
<h3>Sizing the Virtual List Box</h3>
<p>
Each time the virtual list box is resized (that is, whenever the main window receives a WM_SIZE message), the child window list box must also be resized. When the main window receives this message, VLIST:
<ul type=disc>
<li>
Determines the line height. If VLIST is an owner-drawn list box, the application may resize the height of each line with a VLB_SETITEMHEIGHT message. In this case, the virtual list box must be resized with the new line height even if the size of the window itself does not change, because a new line height may increase or decrease the number of lines that fit into the list box.<br><br></li>
<li>
Resizes the main window to hold only fully visible lines, if the virtual list box has the VLBS_NOINTEGRALHEIGHT style.<br><br></li>
<li>
Resizes the child window to completely fill the main window's client area.<br><br></li>
<li>
Calculates a new number of visible lines. <br><br></li>
<li>
Refreshes the child window if the virtual list box contained data before the resizing took place. If the list box is now large enough to hold all of the items in the virtual list box, VLIST displays all of the items; otherwise, VLIST redraws the current display.</li>
</ul>
<pre><code>void VLBSizeHandler( PVLBOX pVLBox, int nItemHeight)
//
// Recalculates the size of the internal control in response to
// the resizing of the virtual list box window.
//
{
  HDC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hdc;
  TEXTMETRIC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextMetric;
  RECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcWindow;
  RECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcClient;
  HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hOldFont;

  //
  // Set the line height.
  //
  if ( nItemHeight ) {
 &nbsp;&nbsp; pVLBox-&gt;nchHeight = nItemHeight;
  }
  else if ((pVLBox-&gt;styleSave &amp; VLBS_OWNERDRAWFIXED) ) {
 &nbsp;&nbsp; pVLBox-&gt;nchHeight = (int) SendMessage(pVLBox-&gt;hwndList,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LB_GETITEMHEIGHT, 0,0L);
  }
  else {
 &nbsp;&nbsp; hdc = GetDC(pVLBox-&gt;hwndList);
 &nbsp;&nbsp; if (pVLBox-&gt;hFont)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hOldFont = SelectObject(hdc, pVLBox-&gt;hFont);
 &nbsp;&nbsp; GetTextMetrics(hdc, &amp;TextMetric);
 &nbsp;&nbsp; pVLBox-&gt;nchHeight = TextMetric.tmHeight;
 &nbsp;&nbsp; if (pVLBox-&gt;hFont)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SelectObject(hdc, hOldFont);
 &nbsp;&nbsp; ReleaseDC(pVLBox-&gt;hwndList,hdc);
  }

  //
  // Get the main window's client area.
  //
  GetClientRect(pVLBox-&gt;hwnd,&amp;rcClient);

  //
  // Is there a window?
  // Does the list box have an integral height?
  //
  if (pVLBox-&gt;hwnd &amp;&amp; !(pVLBox-&gt;styleSave&amp;VLBS_NOINTEGRALHEIGHT) ) {
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // If it needs adjusting...
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; if (rcClient.bottom % pVLBox-&gt;nchHeight) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...adjust it.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetWindowRect(pVLBox-&gt;hwnd,&amp;rcWindow);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowPos(pVLBox-&gt;hwnd, NULL, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcWindow.right - rcWindow.left,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((rcClient.bottom/pVLBox-&gt;nchHeight)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pVLBox-&gt;nchHeight)+((rcWindow.bottom-
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcWindow.top) - (rcClient.bottom)),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
 &nbsp;&nbsp;&nbsp;&nbsp; }
  }

  //
  // Now adjust the child window list box to fill the new
  // main window's client area.
  //
  if ( pVLBox-&gt;hwndList ) {
 &nbsp;&nbsp;&nbsp;&nbsp; GetClientRect(pVLBox-&gt;hwnd,&amp;rcClient);
 &nbsp;&nbsp;&nbsp;&nbsp; SetWindowPos(pVLBox-&gt;hwndList, NULL, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcClient.right+(GetSystemMetrics(SM_CXBORDER)*2),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcClient.bottom+(GetSystemMetrics(SM_CXBORDER)*2),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
  }

  //
  // Calculate the number of lines.
  //
  pVLBox-&gt;nLines = rcClient.bottom / pVLBox-&gt;nchHeight;

  //
  // If there is stuff already in the list box, update
  // the display (there may be more or fewer items now).
  //
  if ( pVLBox-&gt;lNumLogicalRecs != -2L ) {
 &nbsp;&nbsp;&nbsp;&nbsp; if ( pVLBox-&gt;lNumLogicalRecs &lt;= pVLBox-&gt;nLines ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VLBFirstPage(pVLBox);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else if ( pVLBox-&gt;wFlags &amp; USEDATAVALUES ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VLBFindPage(pVLBox, SendMessage(pVLBox-&gt;hwndList, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LB_GETITEMDATA, 0, 0L), FALSE );
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VLBFindPage(pVLBox, pVLBox-&gt;lToplRecNum, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp; }

  }

}
</code></pre>
<h3>Setting the Font for the Virtual List Box</h3>
<p>
When VLIST gets a WM_SETFONT message, it sets the child window's font to a new value by sending a WM_SETFONT message to the child window list box. VLIST then resizes the list box based on this new font.</p>
<pre><code>void VLBSetFontHandler( PVLBOX pVLBox, HANDLE hFont, BOOL fRedraw)
{
  pVLBox-&gt;hFont = hFont;

  SendMessage(pVLBox-&gt;hwndList, WM_SETFONT, (WPARAM)hFont,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPARAM)FALSE);

  VLBSizeHandler(pVLBox, 0);

  if (fRedraw)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; InvalidateRect(pVLBox-&gt;hwnd, NULL, TRUE);
 &nbsp;&nbsp; }
}
</code></pre>
<h3>Managing the Scroll Bars</h3>
<p>
Windows manages the vertical scroll bar in a standard list box. If the list box is not large enough to accommodate all of the items, Windows gives the list box a vertical scroll bar. When the list box is able to display all of the items, Windows removes the vertical scroll bar. Thus, Windows frees the application from having to manage the scroll bar manually.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Windows version 3.1 provides a new style called LBS_DISABLENOSCROLL, which disables the scroll bars instead of removing them. Our discussion on adding and removing scroll bars in this section also applies to enabling and disabling scroll bars.</p>
<p>
VLIST manages the vertical scroll bar itself. Because there are only enough items to fill the child window list box, Windows always removes the vertical scroll bar from the list box. To avoid this, VLIST must ensure that the child window list box is created without the WS_VSCROLL and WS_HSCROLL styles. (The standard list box does not distinguish between vertical and horizontal scroll bar styles; if either style is specified, the other is assumed.) VLIST calls the <b>ShowScrollBar</b> function to add or remove the vertical scroll bar as necessary. Because the standard list box does not think that it has scroll bars to manage, it does not interfere with VLIST.</p>
<pre><code>void UpdateVLBWindow( PVLBOX pVLBox, LPRECT lpRect)
{
 &nbsp;&nbsp; int&nbsp;&nbsp; nPos;

 &nbsp;&nbsp; if ( pVLBox-&gt;lNumLogicalRecs == -1L )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetScrollPos(pVLBox-&gt;hwndList, SB_VERT, 50, TRUE);
 &nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( pVLBox-&gt;lNumLogicalRecs &lt;= pVLBox-&gt;nLines ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( pVLBox-&gt;styleSave &amp; VLBS_DISABLENOSCROLL )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EnableScrollBar(pVLBox-&gt;hwndList, SB_VERT, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESB_DISABLE_BOTH);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowScrollBar(pVLBox-&gt;hwndList, SB_VERT, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( pVLBox-&gt;styleSave &amp; VLBS_DISABLENOSCROLL )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EnableScrollBar(pVLBox-&gt;hwndList, SB_VERT, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESB_ENABLE_BOTH);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowScrollBar(pVLBox-&gt;hwndList, SB_VERT, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( pVLBox-&gt;lToplIndex &gt;= 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (pVLBox-&gt;lNumLogicalRecs-pVLBox-&gt;nLines) ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPos = 100;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pVLBox-&gt;lToplIndex == 0L) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPos = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nPos = (int) ((pVLBox-&gt;lToplIndex*100L) / 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (pVLBox-&gt;lNumLogicalRecs-pVLBox-&gt;nLines+1));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetScrollPos(pVLBox-&gt;hwndList, SB_VERT, nPos, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; }

}
</code></pre>
<p>
Because the child window list box is created without the WS_HSCROLL and WS_VSCROLL styles, VLIST must also provide an interface between the application and the horizontal scroll bar management features of the child window list box. For this purpose, VLIST implements the VLB_GETHORIZONTALEXTENT and VLB_SETHORIZONTALEXTENT messages. When a horizontal scroll bar is added or removed from the child window list box, VLIST adjusts the number of visible lines in the virtual list box accordingly.</p>
<h3>Controlling the Selection</h3>
<p>
In a standard list box, Windows keeps track of selected items. In a virtual list box, VLIST tracks selected items itself. When the selected item is scrolled out of view in the child window list box, VLIST removes the selected state. When the selected item scrolls back into view in the child window list box, VLIST sets it as the selected item. Because this implementation does not support extended or multiple selection list boxes, VLIST only needs to track the selected item and know if there is no selection. VLIST could support a multiple selection style by keeping a list of selected items.</p>
<h3>Scrolling the Virtual List Box</h3>
<p>
The main function of VLIST is to scroll the virtual list box contents—scrolling gives VLIST the appearance that it contains more items than it actually stores. As VLIST scrolls, it adds items to, and deletes items from, the child window list box. There are five possible scrolling actions:
<ul type=disc>
<li>
Scroll down a line.<p class=tl>
Get the item after the last item in the child window list box. If this item exists, remove the item at the top of the list and add the new item to the bottom of the list.</P></li>
<li>
Scroll up a line.<p class=tl>
Get the item before the first item in the child window list box. If this item exists, remove the item at the bottom of the list and add the new item to the top of the list.</P></li>
<li>
Scroll down a page.<p class=tl>
Get the item after the last item in the child window list box. While this item exists, or until the number of lines displayed in the list box has been scrolled, remove the item at the top of the list and add the new item to the bottom of the list. We selected this implementation instead of asking the parent window for one page at a time for two reasons:</P><ul type=disc>
<li>
It simplifies the communication between the application and the virtual list box. Only next item and previous item messages are needed, so the application has fewer messages it must implement handlers for.<br><br></li>
<li>
It frees the application from having to determine when a page is full. For example, let's assume that the list box is positioned so that it is half a page from the bottom of the list, and VLIST asks the application to send the next page. The application must place the bottom half of the current page's items at the top of the last page, and then fill the last page with the rest of the items. Because VLIST fills the pages, the application does not have to deal with this extra complexity.</li>
</ul>
</li>
<li>
Scroll up a page.<p class=tl>
Get the item before the first item in the child window list box. While this item exists, or until the number of lines displayed in the list box has been scrolled, remove the item at the bottom of the list and add the new item to the top.</P></li>
<li>
Scroll to a particular position.<p class=tl>
The virtual list box can scroll to four positions:</P><ul type=disc>
<li>
To a particular item. For a given item identifier (the item's index number or a 32-bit data value; see the "What Item?" section earlier in this article), VLIST requests the item from the application, and then positions the list box so that the given item is the first visible item.<br><br></li>
<li>
To a location in the list. This is very similar to scrolling to a particular item, but in this case a percentage through the list is used. VLIST requests the item at the specified location in the list from the application, and then positions the list so that the item closest to that percentage is the first visible item.<br><br></li>
<li>
To the top of the list. The first item appears as the first visible item.<br><br></li>
<li>
To the bottom of the list. The last item in the list appears as the last visible item.</li>
</ul>
</li>
</ul>
<p>
In each case, VLIST asks the parent window to find the item. If the item exists, VLIST:
<ol>
<li>
Removes the selection, if one exists.<br><br></li>
<li>
Clears the list box.<br><br></li>
<li>
Adds the first item.<br><br></li>
<li>
Adds the appropriate number of items to fill the list box (less one for the given item) or until the bottom of the list is reached.</li>
</ol>
<h3>Hocus Pocus Focus Smocus</h3>
<p>
When the selection state changes, the focus rectangle issue rears its ugly head. Standard single-selection list boxes draw a focus rectangle on a selected item. When the selection is removed with LB_SETCURSEL, the focus rectangle stays on the item. When a selected item is scrolled out of view, the focus rectangle goes with it, but the list still has focus. VLIST mimics this behavior. However, when a selected item is scrolled out of view and VLIST sets the current selection to –1 with the LB_SETCURSEL message, the child window list box draws a focus rectangle around the item that previously had the selection. To avoid this, VLIST sets the focus back to its main window when it sets the selected item to –1. The main window sends any keyboard messages it receives to the child window list box and sets the focus back to the child window list box. When the child window list box receives the focus from Windows, and there is no selection or the selection is not visible, it sets the focus to the main window. The main window keeps the focus if there is no selection or if the current selection is not visible. These steps give the virtual list box the appearance of behaving the same as a standard list box.</p>
<h3>Keyboard Messages</h3>
<p>
When a standard list box receives a WM_VSCROLL message to page the list box up or down, it scrolls (up or down) by the number of visible lines. When a standard list box receives a PageUp or PageDown keystroke, it scrolls the list box (up or down) one line less than the number of visible lines. The VLIST implements the varying scroll amounts in the same way.</p>
<h3>Minimizing Flicker</h3>
<p>
Applications use the WM_SETREDRAW message to minimize the flicker associated with list box updates. This message causes the list box to delay updating the display so that all changes can be performed at once. VLIST also uses WM_SETREDRAW when it scrolls to a new position or when it processes multiple updates, for example, when paging up and down the list box. In these cases, VLIST behaves like a standard list box.</p>
<p>
Single-line scrolling requires a different technique. Each time the standard list box processes a WM_SETREDRAW message to turn on the redraw flag, it invalidates its window and causes the background to be erased. When an item is added to, or deleted from, a list box, Windows invalidates the list box in the same way. When VLIST scrolls one line at a time, it deletes an item and then adds a new item. As a result, the list box ensures that flicker occurs. To stop the flicker, VLIST must update the list box display itself. First, VLIST removes and adds the items. Then, it uses the <b>ValidateRect</b> function to tell Windows not to paint the now invalidated area. Finally, VLIST scrolls the list box window itself and tells Windows to repaint the new (top or bottom) line. This technique eliminates flicker associated with single-line scrolling.</p>
<p>
The following sample code illustrates this procedure:</p>
<pre><code>//
// Remove the top string.
//
SendMessage(pVLBox-&gt;hwndList, LB_DELETESTRING, 0, 0L);

//
// Add the new line.
//
SendMessage(pVLBox-&gt;hwndList, LB_ADDSTRING, 0, (LPARAM)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pVLBox-&gt;vlbStruct.lpTextPointer);

//
// Tell Windows not to paint the whole list box.
//
ValidateRect(pVLBox-&gt;hwndList, NULL);

//
// Scroll the window up.
//
ScrollWindow(pVLBox-&gt;hwndList, 0, (-1)*pVLBox-&gt;nchHeight,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, NULL);

//
// Now tell Windows that the bottom line needs fixing.
//
SendMessage(pVLBox-&gt;hwndList, LB_GETITEMRECT,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pVLBox-&gt;nLines-1, (LPARAM)(LPRECT)&amp;UpdRect);

InvalidateRect(pVLBox-&gt;hwndList, &amp;UpdRect, TRUE);

UpdateWindow(pVLBox-&gt;hwndList);
</code></pre>
</BODY>
</HTML>
