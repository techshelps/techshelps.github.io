<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft Windows and the C Compiler Options</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_optim"></a></sup>Microsoft Windows and the C Compiler Options</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
<i>Mr. Rogerson is widely known for having reported the largest number of duckbilled platypus sightings in the greater Seattle area.</i></p>
<p>
Created: May 5, 1992</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="131">
</OBJECT><a href="javascript:sample1.Click()">Click to view or copy the Zusammen sample application files for this technical article.</a></p>
<h2>Abstract</h2>
<p>
One of the key issues in the development and design of commercial applications is <i>optimization</i>—how to make an application run quickly while taking up as little memory as possible. Although optimization is a goal for all applications, the Microsoft® Windows™ graphical environment presents some unique challenges. This article provides tips and techniques for using the Microsoft C version 6.0 and C/C++ version 7.0 compilers to optimize applications for Windows. It discusses the following optimization techniques:
<ul type=disc>
<li>
Using compiler options<br><br></li>
<li>
Optimizing the prolog and epilog code<br><br></li>
<li>
Optimizing the calling convention<br><br></li>
<li>
Aliasing (using the <b>/Ow</b> and <b>/Oa</b> options)</li>
</ul>
<h2>General Optimization Strategies</h2>
<p>
Optimization is a battle between two forces: small size and fast execution. As with most engineering problems, deciding which side to take is never easy. The following guidelines will help you optimize your applications for the Microsoft® Windows™ graphical environment.
<ul type=disc>
<li>
If your application runs in real mode, always optimize for size. Memory is the limiting resource in real mode. Using too much memory leads to both speed loss and memory loss, resulting in a performance hit.<br><br></li>
<li>
Memory is not as scarce in protected mode (that is, in standard and enhanced modes) as it is in real mode, so you must decide whether to optimize for speed or for size. However, as users start running multiple programs simultaneously, memory becomes scarce. The rule of thumb for both Windows and other operating environments is to optimize for speed the 10 percent that runs 90 percent of the time. Tools such as the Microsoft Source Code Profiler help determine where optimizations should be made.<br><br></li>
<li>
Because Windows is a visual interactive environment, several shortcuts help identify areas that need speed optimization. Any code that displays information directly on the screen, including code that responds to WM_PAINT, WM_CREATE, and WM_INITDIALOG messages, should be optimized. A dialog box does not appear until the WM_INITDIALOG process is complete, so the user must wait. Speed is not as critical in other areas because the user can move the mouse only so fast. In most situations, the code underlying the selection processes in a dialog box need not be optimized. </li>
</ul>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The Microsoft C version 6.0 compiler precedes most function modifiers with a single underscore (_), for example, <b>_loadds</b>, <b>_export</b>, <b>_near</b>, <b>_far</b>, <b>_pascal</b>, <b>_cdecl</b>, and <b>_export</b>. The Microsoft C/C++ version 7.0 compiler uses two underscores (__) for ANSI C compatibility but recognizes the single underscore for backward compatibility. This article uses C version 6.0 compiler syntax except when discussing features available only in C/C++ version 7.0.</p>
<h2>The Sample Application: Zusammen</h2>
<p>
The sample application, Zusammen, illustrates the use of the compiler options. Zusammen, which means <i>together</i> in German, scrolls two different windows simultaneously. To scroll, the user selects the windows with the mouse and clicks Zusammen's scroll bars. This makes it easy to compare data in two different windows or applications.</p>
<p>
Zusammen consists of a program generated by MAKEAPP and a dynamic-link library (DLL) called Picker. MAKEAPP is a sample program included in the Windows version 3.1 Software Development Kit (SDK). The Picker DLL selects the windows to be scrolled.</p>
<p>
The make files for Zusammen and Picker are combined for simplicity. All functions are classified as local, global, entry point, or DLL entry point and declared with an appropriate <b>#define</b> statement, for example:</p>
<pre><code>void LOCAL cleanup(HWND hwndDlg);
BOOL DLL_ENTRY Picker_Do(HWND, LP_PICKER_STRUCT);
</code></pre>
<ul type=disc>
<li>
A <i>local function</i> is a function called from within a segment.<br><br></li>
<li>
A <i>global function</i> is a function called from outside a segment.<br><br></li>
<li>
An <i>entry point</i> is a function that Windows calls.<br><br></li>
<li>
A <i>DLL entry point</i> is a DLL function that a client application calls.</li>
</ul>
<p>
For demonstration purposes, the symbols are defined in the make files. Using symbols facilitates switching memory models and optimizing applications. You can also port applications to flat-model environments easily by using <b>#define</b> <b>NEAR</b> and <b>#define FAR</b> (from WINDOWS.H) instead of <b>__near</b> and <b>__far</b>. Some possibilities are:</p>
<pre><code>#define LOCAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEAR
#define DLL_ENTRY&nbsp;&nbsp;&nbsp; FAR PASCAL
</code></pre>
<p>
or:</p>
<pre><code>#define LOCAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEAR PASCAL
#define DLL_ENTRY&nbsp;&nbsp; FAR PASCAL __loadds
</code></pre>
<h2>The Solution</h2>
<p>
Tables 1 through 3 show options recommended for general use. These options can be used as defaults in make files because they do not require changes to the source code to compile correctly. Each table shows the options for building an application and a DLL and differentiates between the debugging (development) phase and the released product. The options in Table 1 apply to applications or libraries that run in real mode; the options in Tables 2 and 3 apply to applications or libraries that run only in protected mode. Table 3 is for C/C++ version 7.0 use only.</p>
<p>
The developer must choose either the <b>/Ot</b> option to optimize for speed (time) or the <b>/Os</b> option to optimize for size. The C version 6.0 compiler defaults to <b>/Ot</b>. The C/C++ version 7.0 compiler defaults to <b>/Od</b>, which disables all optimizations and enables fast compiling (<b>/f</b>).</p>
<p>
The <b>/Oa</b> and <b>/Ow</b> options do not appear in the tables; both options assume no aliasing and require that the C source meet certain conditions to work properly. These two options are discussed in the "Aliasing and Windows" section. In general, use <b>/Ow</b> instead of <b>/Oa</b> for Windows-based applications. You can turn the no-aliasing assumption on and off using <b>#pragma optimize</b> with the <b>a</b> or <b>w</b> switch.</p>
<p>
Another option that is not included in the tables is the optimized prolog/epilog option <b>/GW</b>. In C version 6.0, this option generates code that does not work in real mode; it is fixed in C/C++ version 7.0. For backward compatibility, the C/C++ version 7.0 <b>/Gq</b> option generates the same prolog/epilog as the C version 6.0 <b>/GW</b> switch. Although the fixed <b>/GW</b> option results in a smaller prolog for non-entry-point functions, better optimizations are available for protected-mode applications, as discussed in the next section.</p>
<p>
<b>Table 1. Compiler Options for Real Mode (C 6.0 and C/C++ 7.0)</b></p>
<p>
<b><img src="optim_1.gif" border=0></b></p>
<h3>The General Solution for Protected Mode</h3>
<p>
If your application runs only in protected mode, you can use the additional optimization options shown in the second row of Table 2. Make1 demonstrates the use of these options, which are safe for all modules in a protected-mode application.</p>
<p>
You can realize additional savings in space and time by compiling modules without entry points separately from those with entry points. Use the options in the third row of Table 2 for modules without entry points. Make2 demonstrates the use of both sets of options. The Zusammen sample application is already set up with far calls and entry points in separate C files. This application should run only in protected mode, so you should compile with the resource compiler (RC) <b>/T</b> option to ensure that the application never runs in real mode.</p>
<p>
DLLs can benefit from the techniques presented in the "Optimized DLL Prolog and Epilog" section. These techniques work with both C version 6.0 and C/C++ version 7.0.</p>
<p>
<b>Table 2. Compiler Options for Protected Mode Only (C 6.0 and C/C++ 7.0)</b></p>
<p>
<b><img src="optim_2.gif" border=0></b></p>
<h3>The General Solution for Protected Mode and C/C++ 7.0</h3>
<p>
The C/C++ version 7.0 compiler includes special optimizations for protected-mode Windows programs (see Table 3). These special optimizations include <b>/GA</b> (for applications), <b>/GD</b> (for DLLs), and <b>/GEx</b> (to customize the prolog) and help reduce the amount of overhead the prolog/epilog code causes. The <b>/GA</b> and <b>/GD</b> options add the prolog and epilog code only to far functions marked with <b>__export</b> instead of compiling all far functions with the extra code. With <b>__export</b>, entry points need not be placed in a separate file as required by C version 6.0. </p>
<p>
Applications that do not mark far functions with <b>__export</b> can use the <b>/GA /GEf</b> or <b>/GD /GEf</b> options to generate the prolog/epilog code for all far functions. <b>/GEe</b> causes the compiler to export the functions by emitting a linker <b>EXPDEF</b> record. By default, <b>/GD</b> emits the <b>EXPDEF</b> record but <b>/GA</b> does not. Applications compiled with <b>/GA</b> usually do not need the <b>EXPDEF</b> record. Only real-mode applications need <b>/GEr</b> and <b>/GEm</b>; protected-mode applications have no use for these options. The following options generate equivalent prolog/epilog code:
<ul type=disc>
<li>
/GA is equivalent to /GA /GEs /D_WINDOWS.<br><br></li>
<li>
/GD is equivalent to /GD /GEd /GEe /Aw /D_WINDOWS /D_WINDLL.</li>
</ul>
<p>
<b>Table 3. Compiler Options for Protected Mode (C/C++ 7.0 Only)</b></p>
<p>
<b><img src="optim_3.gif" border=0></b></p>
<h2>Overview of Compiler Options</h2>
<h3>Generate Intrinsic Functions (/Oi)</h3>
<p>
The <b>/Oi</b> option replaces often-used C library functions with equivalent inline versions. This replacement saves time by removing the function overhead but increases program size because it expands the functions. </p>
<p>
In C version 6.0, the <b>/Oi</b> option is not recommended for general use because it causes bugs in some situations, especially when DS != SS. Using <b>#pragma intrinsic</b> to selectively optimize functions reduces the chance of encountering a bug. </p>
<p>
The ZUSAMMEN.C module of the sample application demonstrates the use of <b>#pragma</b> <b>intrinsic</b>. Although this particular use does not drastically increase program speed, it does demonstrate the right ideas: It speeds up the WM_PAINT function and is used on a function that is called three times per WM_PAINT message. The best savings occur when the <b>intrinsic</b> function is in a loop or is called frequently.</p>
<h3>Pack Structure Members (/Zp)</h3>
<p>
The <b>/Zp</b> option controls storage allocation for structures and structure members. To save as much memory as possible, Windows packs all structures on a 1-byte boundary. Although this saves memory, it can result in performance degradation. Intel® processors work more efficiently when word-sized data is placed in even addresses. An application must pack Windows structures to communicate successfully with Windows, but it need not pack its own structures. Because Windows structures are prevalent, it is better to compile with the <b>/Zp</b> option and use <b>#pragma pack</b> on internal data structures. Passing an improperly packed structure to Windows can lead to problems that are difficult to debug. Both Zusammen and Picker use <b>#pragma pack</b> on their internal data structures. (See the FRAME.H, APP.H, and PACK_DLL.H modules.)</p>
<p>
Note that PICKER.DLL packs <b>PICKER_STRUCT</b>. Because most Windows-based applications pack structures, it is safer to leave DLL structures packed. In most cases, the speed optimization is not worth the extra trouble of documenting the unpacked functions, especially if the DLL will be used with other languages or products, such as Microsoft Visual Basic™ or Microsoft Word for Windows.</p>
<h3>Set Warning Level (/W3)</h3>
<p>
All Windows-based programs should be compiled at warning level 3. You can fix many hard-to-detect bugs by removing the warnings that appear during compilation. It is less expensive to fix a warning message than to ship a bug fix release to unsatisfied users. All applications should be run in Windows debug mode before release.</p>
<h3>Compile for Debugging (/Zi) and Disable Optimizations (/Od )</h3>
<p>
It is often easier to turn off optimizations to debug a module. Some optimizations can introduce bugs into (or remove bugs from) otherwise correct programs. For this reason, an application must be fully tested with release options, and all developers and testers should be aware of the options used.</p>
<h3>Stack Checking (/Gs)</h3>
<p>
By default, the compiler generates code to "check the stack"; that is, each time a function is called, <b>chkstk</b> (actually <b>_aNchkstk</b>) compares the available stack space with the additional amount the function needs. If the function requires more space than is available, the program generates a run-time error message. Table 4 (below, under "Examining the Prolog and Epilog Code") shows the call to <b>chkstk</b>, which is removed by compiling with <b>/Gs</b>. Stack checking adds significant overhead, so it is usually disabled with the <b>/Gs</b> option after sufficient testing. It is usually a good idea to reenable stack checking on recursive functions with the <b>check_stack</b> pragma. </p>
<h3>#define Statements (/DSTRICT, /D_WINDOWS, /D_WINDLL)</h3>
<p>
The <b>#define</b> statements <b>/DSTRICT</b>, <b>/D_WINDOWS</b>, and <b>/D_WINDLL</b> are recommended for all Windows-based applications. Using <b>/DSTRICT</b> with WINDOWS.H results in a more robust and type-safe application. <b>/DSTRICT</b> lets you use macros to replace Windows functions such as <b>GetStockObject</b> with type-safe versions such as <b>GetStockBrush</b> and <b>GetStockPen</b>. </p>
<p>
The C header files use <b>/D_WINDOWS</b> and <b>/D_WINDLL</b> to determine the correct prototypes and typedefs to include. <b>/D_WINDLL</b> ensures that using an invalid library function in a DLL generates an error. The C/C++ version 7.0 compiler <b>/GA</b> option automatically sets <b>/D_WINDOWS</b>; the <b>/GD</b> option sets both <b>/D_WINDOWS</b> and <b>/D_WINDLL</b>.</p>
<h2>Optimizing the Prolog and Epilog</h2>
<p>
Programs designed for Windows, unlike those designed for MS-DOS®, have special sections of code called the <i>prolog</i> and <i>epilog</i> added to entry points. For this reason, Windows uses special compilers. When you compile a program with the <b>/Gw</b> option, all far functions receive the extra prolog and epilog code and increase in size by about 10 bytes. You can take the following steps to reduce this overhead, especially for protected-mode-only applications:
<ul type=disc>
<li>
Reduce the number of far calls.<br><br></li>
<li>
Reduce the prolog and epilog code.</li>
</ul>
<h3>Reducing the Number of Far Calls</h3>
<p>
Because <b>/Gw</b> adds the extra code only to far functions, reducing the number of far functions is a good way to trim program size. In the small memory model, all functions are near unless explicitly labeled as far, so reducing far calls is not a problem. In the medium memory model, all functions default to far and therefore receive the extra prolog and epilog code. In C version 6.0, you can use two methods to reduce this overhead:
<ul type=disc>
<li>
Organize source modules. Label all functions explicitly as either near or far, and compile with the medium model.<br><br></li>
<li>
Use mixed-model programming with small model as the base.</li>
</ul>
<p>
C/C++ version 7.0 users do not need either of these methods; they can use the <b>/GA</b> and <b>/GD</b> options to add prolog/epilog code only to far functions marked with <b>__export</b>. Other far functions are compiled without additional overhead. To add the prolog and epilog code to all far functions, use <b>/GA</b> <b>/GEf</b> or <b>/GD</b> <b>/GEf</b>.</p>
<h4>Organizing source modules</h4>
<p>
To reduce the number of far calls, you must organize source modules carefully. Each module is divided into internal functions and external functions. Internal functions are called only from within the module; external functions are called from outside the module. As a direct result of this arrangement, internal functions are marked near and external functions are marked far.</p>
<p>
The Zusammen sample application is arranged in this manner. Each module has a header file that prototypes all external functions as far. Each source file prototypes its internal functions as near because they are not needed outside the module.</p>
<p>
For large applications, you can use a tool such as MicroQuill's Segmentor to determine the best segmentation to use. You can also organize source modules manually, but the process must be repeated whenever the source file changes.</p>
<p>
Another method for reducing far call overhead is to use the <b>FARCALLTRANSLATION</b> and <b>PACKCODE</b> linker options. This method works exclusively on protected-mode-only applications and should not be used in real mode. <b>PACKCODE</b> combines code segments. You can specify the size of the segments to pack on the command line (for example, <b>/PACKCODE:8000</b>). The default size limit is 65530 bytes. C/C++ version 7.0 turns <b>PACKCODE</b> on by default for all segmented executables. If a far function is called from the same segment, <b>FARCALLTRANSLATION</b> replaces the far call with a near call.</p>
<h4>Mixed-model programming</h4>
<p>
In mixed-model programming, the small model acts as the base. All far functions are explicitly labeled as in the previous method. Each module is compiled with the <b>/NT</b> option, which places the module in a different segment, for example:</p>
<pre><code>cl /c /Gw /Od /Zp /W3 /NT _MOD1 mod1.c
cl /c /Gw /Od /Zp /W3 /NT _MOD2 mod2.c
</code></pre>
<p>
Because the small model is used, all other functions default as near model and <i>presto!</i>—no far call overhead. The SDK Multipad sample application uses this method for compiling, although many of its near functions are labeled as such. Make3 compiles Zusammen using this method.</p>
<p>
In practice, this method does not save much work—it only eliminates the need to label near functions explicitly. However, labeling near functions is useful for documenting local and global functions.</p>
<p>
In mixed-model programming, only functions in the default _TEXT code segment can call the C run-time library. Multipad avoids this limitation by not calling any C run-time library functions. Mixed-model programming uses the small-model C library, which is placed in the _TEXT segment. Because these library routines are based in small model, they assume all code as near. If a C library function is called from a different segment, a linker fixup error occurs because the linker cannot resolve a near jump into another segment. There is no convenient way to avoid this restriction.</p>
<p>
<b>Removing the C run-time library</b></p>
<p>
Because the C run-time library is not used, you need not link to it. The Windows version 3.1 SDK includes libraries named <i>x</i>NOCRTW.LIBthat do not contain any C run-time functions. Each memory model has one such library containing the minimum amount of code needed to resolve all compiler references. Using this library saves about 1.5K from the _TEXT code segment size and about 500 bytes from the default data segment size. Linking time also improves slightly. When using the <i>x</i>NOCRTW.LIB libraries, note that the standard C libraries may contain some operations that seem ordinary (such as long multiplication).</p>
<h3>Examining the Prolog and Epilog Code</h3>
<p>
Decreasing the number of far functions is only part of the battle. Not all far functions need the full prolog and epilog code, as the existence of the <b>/GW</b>,<b> /GA</b>,<b> </b>and<b> /GD </b>options shows. The C/C++ version 7.0 <b>/GA</b> and <b>/GD</b> options provide the best achievable optimizations of the prolog and epilog code. The C version 6.0 <b>/GW</b> option provides an optimized version of the prolog/epilog code for far functions that are not entry points. However, when armed with a little knowledge, the C version 6.0 compiler user can generate better results for protected-mode applications than those the <b>/GW</b> option provides, as discussed in the following sections.</p>
<h4>What does the prolog/epilog code do anyway?</h4>
<p>
The prolog/epilog code sets the DS register to the correct value to compensate for the existence of multiple data segments and their movements. The second column of Table 4 shows the assembly-language listing of the prolog/epilog code that every far function receives when it is compiled with <b>/Gw</b>. The last column shows the prolog/epilog code that near functions receive. This is the same code that far functions contain when they are not compiled with <b>/Gw</b>.</p>
<p>
<b>Table 4. Assembly Listing of Prolog and Epilog Code (C 6.0)</b></p>
<p>
<img src="optim_4.gif" border=0></p>
<p>
C/C++ version 7.0 provides additional optimizations for real mode, even if you use the <b>/Gw</b> and <b>/GW</b> options. These optimizations include:
<ul type=disc>
<li>
Using <b>mov ax,ds</b> instead of a push/pop sequence in the Preamble phase.<br><br></li>
<li>
Using <b>lea sp, WORD PTR -2[bp]</b> for the Release Frame phase.</li>
</ul>
<p>
Table 5 shows the compiler output for these options.</p>
<p>
<b>Table 5. Assembly Listing of Prolog and Epilog Code (C/C++ 7.0)</b></p>
<p>
<img src="optim_5.gif" border=0></p>
<p>
Most of the prolog/epilog code is not needed in protected mode but is essential for real mode. The <b>/GW</b> option does not have the <b>push ds</b> instruction that all far functions require in real mode to save the data segment; for this reason, <b>/GW</b> does not work in real mode. Not much can be done to optimize the prolog/epilog code that C version 6.0 generates for real-mode applications, so this article focuses on optimization in protected mode only. For more information on what happens during real mode, see <i>Programming Windows</i> by Charles Petzold (Redmond, Wash.: Microsoft Press, 1990). For the compiler writer's viewpoint, see the Windows version 3.1 SDK Help file.</p>
<p>
The order of phases in the C/C++ version 7.0 compiler options <b>/GA</b> and <b>/GD</b> differs slightly from that of <b>/Gw</b>: The Alloc Frame phase occurs before the Save DS and Load DS phases (when compiling without <b>/G2</b>). As a result, the <b>/GA</b> and <b>/GD</b> options remove the two <b>dec bp</b> instructions from the Release Frame phase. The compiler output for the <b>/GA</b> and <b>/GD</b> options is shown in Table 6.</p>
<p>
<b>Table 6. Assembly Listing of Prolog and Epilog Code (C/C++ 7.0)</b></p>
<p>
<img src="optim_6.gif" border=0></p>
<h4>Protected mode only</h4>
<p>
The Mark Frame and Unmark Frame phases are not needed during protected mode and can be ignored. The prolog/epilog code for a near function and the prolog/epilog compiled with <b>/Gw</b> differ in four phases: Preamble, Save DS, Load DS, and Restore DS. The other phases—Link Frame, Alloc Frame, Release Frame, and Unlink Frame—are the same; they set up the stack frame for the function. (See Figure 1.)</p>
<p>
<img src="optim_7.gif" border=0></p>
<p class=label>
<b>Figure 1. Stack Frame Creation</b></p>
<p>
The compiler generates code to access the parameters passed to the function using positive offsets to BP ([BP + XXXX]). Negative offsets from BP ([BP – XXXX]) access the function's local variables. This happens for all C functions—near functions, far functions, and functions compiled with the <b>/Gw</b> option.</p>
<h4>Optimizing for 80286 processors (/G2)</h4>
<p>
Because protected mode requires an 80286 processor at the minimum, you should use some of the special 80286 instructions through the <b>/G2</b> option. Two instructions—<b>enter</b> and <b>leave</b>—are relevant to our current discussion. <b>Enter</b> performs the same function as Link Frame and Allocate Frame, and <b>leave</b> performs the same function as Release Frame and Unlink Frame. Table 7 shows the prolog/epilog code for near and far functions compiled with the <b>/G2s</b> option and without the <b>/Gw</b> option.</p>
<p>
<b>Table 7. Assembly Listing of Prolog/Epilog Code Compiled with /G2s</b></p>
<p>
<img src="optim_8.gif" border=0></p>
<p>
Unfortunately, the <b>/Gw</b> option overrides the <b>/G2</b> option in C version 6.0 and generates the prolog/epilog code without the <b>enter</b> and <b>leave</b> instructions. The C/C++ version 7.0 compiler corrects this limitation; it generates Windows prolog/epilog code with the <b>enter</b> and <b>leave</b> instructions when it compiles with <b>/GA</b> or <b>/GD</b> and <b>/G2</b>. Table 8 shows the prolog/epilog code for functions compiled with C/C++ version 7.0 options.</p>
<p>
<b>Table 8. Assembly Listing of Prolog and Epilog Code for C/C++ 7.0 (Protected Mode Only)</b></p>
<p>
<img src="optim_9.gif" border=0></p>
<h4>The prolog preamble's purpose</h4>
<p>
The Preamble, Save DS, Load DS, and Restore DS phases exist only when you compile a far function with a Windows option (<b>/Gw</b>, <b>/GW</b>, <b>/GD,</b> or <b>/GA</b>). Programs developed for Windows, unlike those developed for MS-DOS, can have multiple instances, each with its own movable default data segment. When control is transferred from Windows to an application or from an application to a DLL, a mechanism is needed for changing DS to point to the correct default data segment. This mechanism consists of the prolog/epilog code, the Windows program loader, the EXPORT section of the DEF file (or <b>_export</b>), and the <b>MakeProcInstance</b> function. </p>
<p>
Nothing seems to happen in the Preamble, Save DS, and Load DS phases:</p>
<pre><code>push ds&nbsp;&nbsp;&nbsp;&nbsp; ; move ds into ax
pop ax
nop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; now ax = ds
push ds&nbsp;&nbsp;&nbsp;&nbsp; ; save ds
mov ds,ax&nbsp;&nbsp; ; ds = ax, but ax = ds
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; therefore ds = ds
</code></pre>
<p>
It seems like a lot of work to set DS equal to itself. However, a lot happens behind the scenes. Examining the code with the Microsoft CodeView® debugger reveals three Preamble phases different from the code listing the <b>/Fc</b> compiler option generates (see Make4). The <b>Client_WinProc </b>(in WCLIENT.C), <b>Client_Initialize</b> (in CLIENT.C), and <b>Picker_Do</b> (in PICKER.C) functions demonstrate these phases. Table 9 lists these phases.</p>
<p>
<b>Table 9. Preamble Variations</b></p>
<p>
<img src="optim_10.gif" border=0></p>
<p>
The Windows program loader magically changes the Preamble phase of the prolog. The loader first examines the list of exported functions when it loads a program. When it finds an entry-point function with the <b>/Gw</b> preamble, it changes the preamble. If the function is not exported or the preamble is different, the loader leaves it alone, and DS retains its value. For example, in <b>Client_Initialize</b>, the DS register does not have to be changed so it is not.</p>
<p>
If the function is part of a single-instance application, the value can be set directly because single-instance applications have only one data segment. Because DLLs are always single instance, they belong to this group. AX is set directly to DGROUP. In the Load DS phase, DS is loaded with the DGROUP value from AX, resulting in a correct DS value for the function.</p>
<p>
In exported far functions, as demonstrated by <b>Client_WinProc</b>, Windows removes the entire preamble but still loads DS from AX during the Load DS phase. So where does it load AX? It depends on how Windows calls the function. For all window procedures, including <b>Client_WinProc</b>, Windows sets up AX correctly before calling the procedure.</p>
<p>
That leaves callbacks such as those used with the <b>EnumFontFamilies</b> function. You can set up an <b>EnumFontFamilies</b> callback as follows:</p>
<pre><code>FARPROC lpCallBack;

lpCallBack = MakeProcInstance(CallBack, hInstance);
EnumFontFamilies(hdc, NULL, lpCallBack, (LPSTR)NULL);
FreeProcInstance(lpCallBack);
</code></pre>
<p>
<b>MakeProcInstance</b> creates an instance thunk, which is basically a jump table with an added capability: setting AX. Instance thunks appear as follows:</p>
<pre><code>mov ax,XXXX
jmp &lt;actual function address&gt; &nbsp;&nbsp;&nbsp;&nbsp; ;jump to actual function
</code></pre>
<p>
The return value of <b>MakeProcInstance</b> is the address of the instance thunk. This address is passed to <b>EnumFontFamilies</b>, which calls the instance thunk instead of the function itself. The instance thunk sets up AX with the current address of the data segment. In real mode, Windows changes this address each time it moves the data segment and jumps to the function that loads DS with the value in AX. And <i>presto! chango!</i> DS has the correct value.</p>
<p>
This discussion leads to some interesting conclusions:
<ul type=disc>
<li>
An application cannot call an exported far function directly; it must use the result of <b>MakeProcInstance</b> as a function pointer instead.<br><br></li>
<li>
An application should not use <b>MakeProcInstance</b> when calling a function in a DLL.<br><br></li>
<li>
DLLs should not call <b>MakeProcInstance</b> on any exported far function that resides inside the DLL. <br><br></li>
<li>
Nonexported far functions do not need the prolog/epilog code.<br><br></li>
<li>
Windows sets up the AX register as part of its message-passing mechanism. Window procedures do not have instance thunks. <br><br></li>
<li>
There are no obvious optimizations.</li>
</ul>
<h3>FixDS (/GA and /GEs)</h3>
<p>
FixDS by Michael Geary is a public domain program available on CompuServe® that brings insight and imagination to the optimization process. Borland® C++ and Microsoft C/C++ version 7.0 both incorporate this feature. Under Microsoft C/C++ version 7.0 you can use <b>/GA</b> to perform the same function as FixDS (see Tables 6 and 8).</p>
<p>
So far, we have not discussed the SS stack segment register. The prolog code does not set SS anywhere. This must mean that the Windows Task Manager sets SS before the function is executed. Because a Windows-based application is not normally compiled with the <b>/Au</b> or <b>/Aw</b> option, SS == DS. So there is no reason why DS cannot be loaded simply from SS.</p>
<p>
Instead of pushing DS into AX, FixDS modifies the prolog to put SS into AX, which is eventually placed in DS (see the fourth column of Table 10). This preamble differs from the standard Windows preamble, so the Windows loader does not modify it.</p>
<p>
This method has two convenient side effects:
<ul type=disc>
<li>
You no longer need <b>MakeProcInstance</b>.<br><br></li>
<li>
You do not have to export entry points.</li>
</ul>
<p>
FixDS does not work for DLLs because DS != SS.</p>
<p>
<b>Table 10. Assembly Listing of Optimized Prolog and Epilog</b></p>
<p>
<img src="optim_11.gif" border=0></p>
<p>
The C/C++ version 7.0 compiler extends the ideas of FixDS by letting the programmer specify where DS gets its value. You can use the <b>/GE<i>x</i></b> option in conjunction with the <b>/GA</b> and <b>/GD</b> options to load DS. The following options are available:
<ul type=disc>
<li>
<b>/GEa</b>—Load DS from AX. This is equivalent to <b>/Gw</b> and <b>/GW</b>.<br><br></li>
<li>
<b>/GEd</b>—Load DS from DGROUP. This is the default behavior for <b>/GD</b> and is useful for DLLs, as explained in the next section.<br><br></li>
<li>
<b>/GEs</b>—Load DS from SS. This is equivalent to FixDS and is the default behavior for <b>/GA</b>.</li>
</ul>
<p>
When you compile an application with <b>/GA</b>, the functions marked with <b>__export</b> are not really exported (you can look at the exported functions with EXEHDR). If you compile the program with <b>/GA</b> <b>/GEe</b>, the<b> </b>EXEHDR listing shows all exported functions. A program that you compile with <b>/GA</b> loads DS from SS and does not need to export its entry points, as mentioned above. A program compiled with <b>/GA</b> <b>/GEa</b> should normally be compiled with <b>/GEe</b>.</p>
<p>
The <b>/GD</b> and <b>/GA</b> options work differently. The <b>/GD</b> option exports functions marked with <b>__export</b>. To stop the compiler from exporting functions in a DLL, use <b>/GA</b> <b>/GEd</b> <b>/D_WINDLL</b> <b>/Aw</b> instead of <b>/GD.</b> </p>
<h3>Optimized DLL Prolog and Epilog</h3>
<p>
Although the previous recommendations (excluding FixDS) work fine with DLLs, a better optimization method exists. To optimize a DLL with C version 6.0, compile all DLL modules with the options listed in Table 2 for modules without entry points:</p>
<p>
/Aw&nbsp; /G2&nbsp; /Gs&nbsp; /Oclgne&nbsp; /W3&nbsp; /Zp</p>
<p>
This compilation does not generate prolog or epilog code because the <b>/Gw</b> option is not used. To load DS correctly, mark all entry-point functions with <b>_loadds</b>. Place the functions that the client application calls in the DEF file. This changes the prolog/epilog code to match the second column of Table 10. </p>
<p>
<b>_loadds</b> basically adds the same lines that the Windows function loader changes in the Preamble for a DLL. See Make5 for an example of this method. Again, this is for protected-mode-only applications.</p>
<p>
The <b>/GD</b> option in C/C++ version 7.0 defaults to loading DS from the default data segment (see the third column of Table 10). The <b>/GD</b> option also sets <b>_WINDLL</b> and <b>/Aw</b>. </p>
<p>
Notice that the compiler options include <b>/Aw</b> but not <b>/Au</b>. The <b>/Aw</b> option informs the compiler that DS != SS. The <b>/Au</b> option is equivalent to <b>/Aw</b> and a <b>_loadds</b> on every function, far and near. This is not an optimization because even near functions receive the three lines of code that set up the DS register.</p>
<p>
Using <b>_loadds</b> does not work for applications that have multiple instances and therefore multiple DGROUPs. It does, however, work for single-instance applications. A single-instance application need not export functions because the application passes function addresses to Windows. The application should make sure that another instance cannot start by checking the value of <i>hInstance</i>. Windows creates a new data segment for the application, but the application contains hard-coded pointers to the first data segment. The application should also set up a single data segment in the DEF file as:</p>
<pre><code>DATA SINGLE MOVEABLE
</code></pre>
<p>
Otherwise, the <b>_loadds</b> function modifier will generate warnings. There is no need to use <b>MakeProcInstance</b> because the <b>_loadds</b> function modifier sets up the DS register correctly.</p>
<h4>EXPORT vs. _export</h4>
<p>
In the previous examples, the functions are exported in the DEF file. You can also use the <b>_export</b> keyword to export DLL functions. This method has some drawbacks, depending on the method you use to link the application with the DLL. There are three methods:
<ul type=disc>
<li>
Including an IMPORTS line in the DEF file<br><br></li>
<li>
Using the IMPLIB utility<br><br></li>
<li>
Linking explicitly at run time</li>
</ul>
<p>
<b>Including an IMPORTS line in the DEF file</b></p>
<p>
Including an IMPORTS line in the DEF file of the application, for example:</p>
<pre><code>IMPORTS
 &nbsp; PICKER.Picker_Do
</code></pre>
<p>
although inconvenient for DLLs with many functions, allows you to rename functions, for example:</p>
<pre><code>IMPORTS
 &nbsp; PickIt = PICKER.Picker_Do
</code></pre>
<p>
Now the application can call <b>PickIt</b> instead of <b>Picker_Do</b>. This is useful when DLLs from different vendors use the same function name and when you import a function directly by its ordinal number. The linker gives each exported function an ordinal number to speed up linking by eliminating the need to search for the function. You can override the default ordinal number by specifying a number after an "at" sign (@) in the DLL's DEF file, for example:</p>
<pre><code>; DLL .DEF
EXPORTS
 &nbsp; Picker_Do @1
</code></pre>
<p>
An application can import this function with the following DEF file entry:</p>
<pre><code>; Apps .DEF
IMPORTS
 &nbsp; PickIt = PICKER.1
</code></pre>
<p>
DLLs should always include ordinal numbers on exported functions.</p>
<p>
<b>Using the IMPLIB utility</b></p>
<p>
Most programmers use the IMPLIB utility instead of an IMPORTS line in their DEF files. IMPLIB takes the DEF file of a DLL or, if <b>_export</b> is used, takes the DLL itself and builds a LIB file. The application links with the LIB file to resolve the calls to the DLL. Therefore, the IMPORTS line is not needed. </p>
<p>
One of the drawbacks of <b>_export</b> is that it assumes linking by name instead of linking by ordinal number. As a result, the linker gives the function an ordinal number and the function name is placed in the Resident Name Table.</p>
<p>
The linker is not likely to assign the same number each time it links the program. For example, the output of the EXEHDR program for a program with two exported functions may originally look like this:</p>
<pre><code>Exports:
ord seg offset name
  1&nbsp;&nbsp; 1&nbsp; 07a1&nbsp; WEP exported, shared data
  4&nbsp;&nbsp; 1&nbsp; 0e06&nbsp; ___EXPORTEDSTUB exported, shared data
  3&nbsp;&nbsp; 1&nbsp; 00ac&nbsp; PICKER_OLDDLGPROC exported, shared data
  2&nbsp;&nbsp; 1&nbsp; 0061&nbsp; PICKER_DO exported, shared data
</code></pre>
<p>
Adding a third exported function to the program may change all the ordinals in the EXEHDR output, for example:</p>
<pre><code>Exports:
ord seg offset name
  1&nbsp;&nbsp; 1&nbsp; 07a1&nbsp; WEP exported, shared data
  3&nbsp;&nbsp; 1&nbsp; 0e06&nbsp; ___EXPORTEDSTUB exported, shared data
  4&nbsp;&nbsp; 1&nbsp; 0f00&nbsp; NewFunction exported, shared data
  2&nbsp;&nbsp; 1&nbsp; 00ac&nbsp; PICKER_OLDDLGPROC exported, shared data
  5&nbsp;&nbsp; 1&nbsp; 0061&nbsp; PICKER_DO exported, shared data
</code></pre>
<p>
Applications that use any method of ordinal linking must now be recompiled to use the new ordinals. You may also have to recompile if you use the EXPORT statement without explicitly giving ordinal numbers. Having to recompile an application each time the DLL changes offsets many of the advantages of using DLLs.</p>
<p>
Linking by name also results in function names being placed in the Resident Name Table, which is an array of function addresses indexed by function name. The Resident Name Table stays in memory for the life of the DLL. When linking by ordinal number, the function names reside on disk in the Non-Resident Name Table while an array of function addresses indexed by ordinal number resides in memory.</p>
<p>
For a large DLL, the Resident Name Table could consume a significant amount of memory. Also, linking by name is much slower than linking by ordinal number because Windows must perform a series of string comparisons to find the function in the table.</p>
<p>
<b>Linking explicitly at run time</b></p>
<p>
Run-time dynamic linking occurs when a function call is resolved at run time instead of load time. For example:</p>
<pre><code>HANDLE hLib ;
FARPROC lpfnPick ;
// Get library handle.
hLib = LoadLibrary("PICKER.DLL") ;
// Get address of function.
lpfnPick = GetProcAddress(hLib, "Picker_Do") ;
// Call the function.
(*lpfnPick) (hwnd, &amp;aPicker ) ;
// Free the library. 
FreeLibrary( hLib) ;
</code></pre>
<p>
Linking by name does not use the ordinal number of the function. When linking by name it is much faster to have the function name in the Resident Name Table.</p>
<p>
However, using ordinal numbers is still faster and uses less memory. For example:</p>
<pre><code>#define PICKER_DO 3
HANDLE hLib ;
FARPROC lpfnPick ;
// Get library handle.
hLib = LoadLibrary("PICKER.DLL") ;
// Get address of function.
lpfnPick = GetProcAddress(hLib, MAKEINTRESOURCE(PICKER_DO)) ;
// Call the function.
(*lpfnPick) (hwnd, &amp;aPicker ) ;
// Free the library. 
FreeLibrary( hLib) ;
</code></pre>
<p>
The fastest, most flexible method, regardless of the linking method you use, is to explicitly list the functions with ordinal numbers in the EXPORTS section of the DEF file. The C/C++ version 7.0 <b>/GD</b> option encourages the use of <b>__export</b> to mark entry points. If you use this option, we recommend that you add an EXPORT entry in the DEF file for all functions that an application calls.</p>
<h4>DS != SS issues</h4>
<p>
Some problems can arise within a DLL because DS != SS. A common problem occurs when a DLL calls the standard C run-time library. For example, if you compile the following code with the <b>/Aw</b> option:</p>
<pre><code>void Foo()
{
 &nbsp; char str[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // allocates str on stack,
 &nbsp; strcpy(str,"BAR");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; passing the far pointer as a 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; near pointer
} 
</code></pre>
<p>
the compiler generates a near/far mismatch error because <b>strcpy</b> expects <b>str</b> to be in the default data segment (a near pointer). However, <b>str</b> is allocated on the stack (making it a far pointer) because the stack segment does not equal the data segment. The following examples show how to avoid this situation.
<ul type=disc>
<li>
You can place the array in the data segment by making it static:<pre><code>void Foo2()
{
 &nbsp; static char str[10];&nbsp;&nbsp;&nbsp;&nbsp; // allocate str in data segment
 &nbsp; strcpy(str,"BAR");&nbsp; 
}
</code></pre>
</li>
<li>
You can place the array in the data segment by making it global:<pre><code>char str[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // allocate str in data segment

void Foo3()
{
 &nbsp; strcpy(str,"BAR");&nbsp; 
}
</code></pre>
</li>
<li>
Instead of linking with the small-model version of <b>strcpy</b>, you can use the large-model (also called the model-independent) version:<pre><code>void Foo4()
{
 &nbsp; char str[10];
 &nbsp; _fstrcpy(str,"BAR");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // accept far pointers
}
</code></pre>
<p class=tl>
This version expects far pointers instead of near pointers and therefore casts the near pointers into far pointers.</P></li>
<li>
You can also use the following functions from the Windows library:<ul type=disc>
<li>
<b>lstrcat</b><br><br></li>
<li>
<b>lstrcmp</b><br><br></li>
<li>
<b>lstrcmpi</b><br><br></li>
<li>
<b>lstrcpy</b><br><br></li>
<li>
<b>lstrlen</b><br><br></li>
<li>
<b>wsprintf</b><br><br></li>
<li>
<b>wvsprintf</b></li>
</ul>
<p class=tl>
If you use one of these functions, the previous example becomes:</P><pre><code>void Foo4()
{
 &nbsp; char str[10];
 &nbsp; lstrcpy(str,"BAR");&nbsp;&nbsp;&nbsp;&nbsp; // accept far pointers
}
</code></pre>
</li>
</ul>
<p>
The following code fragment:</p>
<pre><code>void Foo5()
{
 &nbsp; char str[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // allocated on stack
 &nbsp; char *pstr ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // near pointer based on DS

 &nbsp; pstr = str ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // loss of segment
 &nbsp; strcpy(pstr,"BAR");
}
</code></pre>
<p>
causes the compiler to generate the error message:</p>
<pre><code>warning C4758: address of automatic (local) variable taken.
 &nbsp;&nbsp;&nbsp; DS != SS.
</code></pre>
<p>
In this example, <b>pstr</b> is set to the offset of <b>str</b>, and the segment is lost because <b>pstr</b> is a near pointer. Declaring <b>pstr</b> a far pointer eliminates this problem. However, you cannot pass a far pointer to <b>strcpy</b> so you must use <b>_fstrcpy</b>, which results in the following corrected code:</p>
<pre><code>void Foo6()
{
 &nbsp; char str[10];
 &nbsp; char FAR *pstr ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // far pointer

 &nbsp; pstr = str ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no segment loss
 &nbsp; _fstrcpy(pstr,"BAR");
}
</code></pre>
<p>
The following code also prevents the segment loss:</p>
<pre><code>void Foo7()
{
 &nbsp; static char str[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DS-based pointer
 &nbsp; char *pstr ;

 &nbsp; pstr = str ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no segment loss
 &nbsp; strcpy(pstr,"BAR");
 &nbsp; }
</code></pre>
<p>
What happens if the C run-time function does not have a far version? For example, in the Picker DLL, the <b>picker_OnMouseUp</b> function calls <b>_splitpath</b>, which requires near pointers. Using static or global structures poses problems for multiple applications that use Picker simultaneously. To avoid these problems, Picker allocates memory from the local heap with the <b>LocalAlloc</b>(LMEM_FIXED,<i>size</i>) function, which returns a local pointer. This is exactly what Picker needs to call <b>_splitpath</b>.</p>
<h3>Summary</h3>
<p>
Follow these guidelines to avoid DS != SS problems:
<ul type=disc>
<li>
Be sure that all pointers you pass to a DLL are far pointers.<br><br></li>
<li>
Declare pointers to stack variables as far pointers.<br><br></li>
<li>
Declare arrays as static or global.<br><br></li>
<li>
Avoid storing arrays on the stack.<br><br></li>
<li>
Avoid storing variables referenced by pointers on the stack.<br><br></li>
<li>
Use the local heap for storing data.<br><br></li>
<li>
Use far versions of C run-time functions (such as <b>_fstrcpy</b>).<br><br></li>
<li>
Use equivalent Windows functions (such as <b>wsprintf</b> or <b>lstrcpy</b>).<br><br></li>
<li>
Use prototypes on all functions.</li>
</ul>
<p>
Reminders about DLLs:
<ul type=disc>
<li>
FixDS does not work with DLLs because DS != SS.<br><br></li>
<li>
Avoid using <b>_export</b> in DLLs with C version 6.0.<br><br></li>
<li>
Use the DEF file to override the default behavior of functions marked with <b>_export</b>. <br><br></li>
<li>
Always assign ordinal numbers to all exported DLL functions.<br><br></li>
<li>
<b>/Au</b> introduces a considerable amount of overhead; use <b>/Aw</b> and <b>_loadds</b> instead.<br><br></li>
<li>
Replace <b>/Gw </b>with <b>_loadds</b> on exported functions.</li>
</ul>
<h2>Optimizing the Calling Convention</h2>
<p>
Several calling conventions can be used for optimization, including <b>_cdecl (/Gd)</b>, <b>PASCAL (/Gc)</b>, and <b>_fastcall (/Gr)</b>:
<ul type=disc>
<li>
<b>_cdecl</b> is the default C calling convention and is slightly slower than <b>PASCAL</b> and <b>_fastcall</b>.<br><br></li>
<li>
<b>PASCAL</b> (defined in WINDOWS.H as <b>_pascal</b>) is used to communicate between Windows and an application. It is faster than <b>_cdecl</b> but does not allow variable argument functions such as <b>wsprintf</b>.<br><br></li>
<li>
<b>_fastcall</b> is the fastest method. It places some of the parameters in registers but does not support variable argument functions and cannot be used with <b>_export</b> or <b>PASCAL</b>, so entry points cannot use the <b>_fastcall</b> modifier. Under C/C++ version 7.0, the <b>__fastcall </b>modifiercan conflict with the Windows prolog/epilog code if used in the following combinations.<br><br></li>
<li>
<b>__fastcall, __far, Gw</b> (also invalid in C version 6.0)<br><br></li>
<li>
<b>__fastcall, __far, __export, GA</b><br><br></li>
<li>
<b>__fastcall, __far, __export, GD</b><br><br></li>
<li>
<b>__fastcall, __far, GA, GEf</b><br><br></li>
<li>
<b>__fastcall, __far, GD, GEf</b><br><br></li>
<li>
<b>__fastcall, __far, __export, GA, GEf</b><br><br></li>
<li>
<b>__fastcall, __far, __export, GD, GEf</b></li>
</ul>
<p>
Because the C run-time library is compiled with the <b>_cdecl</b> convention, you must include header files such as STDLIB.H and STRING.H when you use a different calling convention. These header files explicitly mark each function as <b>_cdecl</b> to simplify changing the default convention. When you use a third-party library, you may have to add the <b>_cdecl</b> function modifier to the header files.</p>
<p>
You can use any calling convention as the default convention for applications, as long as you declare all entry points <b>FAR PASCAL</b> and declare the <b>WinMain</b> function <b>PASCAL</b>. Marking callback functions as <b>PASCAL</b> is usually safer, even if you use the <b>/Gc</b> Pascal convention option, because it avoids problems if the calling convention changes inadvertently. It is also a good form of code commenting.</p>
<p>
Summary of calling conventions:
<ul type=disc>
<li>
<b>WinMain</b> should use the <b>PASCAL</b> calling convention.<br><br></li>
<li>
Entry points that Windows calls must be <b>FAR PASCAL</b>.<br><br></li>
<li>
Only <b>_cdecl</b> allows variable arguments.<br><br></li>
<li>
<b>_fastcall</b> is incompatible with <b>_export</b> or <b>PASCAL</b> and is therefore incompatible with Windows prolog/epilog code.</li>
</ul>
<h3>DLLs and _cdecl</h3>
<p>
A DLL, unlike an application, can use any calling convention, even for application-called entry points. An application that calls a DLL must know which calling convention the DLL expects and must use that convention. </p>
<p>
A DLL may need to implement a variable argument function. Because <b>_cdecl</b> is the only convention that supports variable arguments, it is the convention of choice. If you want a DLL function to use variable arguments, use the <b>_cdecl</b> convention instead of the <b>PASCAL</b> convention.</p>
<p>
Note the following caveats when using variable argument lists in DLLs:
<ul type=disc>
<li>
The variable argument macros from STDARG.H use the default pointer size to point to the arguments that are on the stack. In the small or medium model, the pointers are near pointers. Because DS != SS, these pointers do not point to the correct value and must be changed to far pointers before you can use these macros, as shown in the modified STDARG.H below:<pre><code>/****************************************************************
 *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File:&nbsp; wstdarg.h
 *&nbsp;&nbsp; Remarks:&nbsp; Macro definitions for variable argument lists
 *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; used in DLLs.
 ****************************************************************/
typedef char <b>_far </b>*wva_list ;

#define wva_start( ap, v )&nbsp; (ap = (wva_list) &amp;v + sizeof( v ))
#define wva_arg( ap, t )&nbsp;&nbsp;&nbsp; (((t <b>_far</b> *)(ap += sizeof( t )))[-1])
#define wva_end( ap )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ap = NULL)
</code></pre>
</li>
<li>
When passing arguments by reference, always use far pointer declarations. The compiler synthesizes far pointers by pushing the DS and the offset of the memory location onto the stack. This provides the DLL with the proper information to access the application's data segment.<br><br></li>
<li>
Because functions with variable arguments are defined using <b>_cdecl</b>, pointer arguments that are not declared in the parameter list must be typecast in the function call; otherwise, the omission of the function parameter prototype causes unpredictable results. For example:<pre><code>void FAR _cdecl DebugPrint( LPSTR lpStr, LPSTR lpFmt, ... )
DebugPrint( szValue, "%s, value passed: %d\r\n",
 &nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) "DebugPrint() called", (int) 10 ) ;
</code></pre>
</li>
<li>
When you import or export a function, you must declare it with an underscore (_) prefix in the DEF file. You must also preserve case sensitivity in the function name. For example, you can declare the function above as follows:<pre><code>EXPORTS
 &nbsp; WEP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @1&nbsp;&nbsp; RESIDENTNAME
 &nbsp; _DebugPrint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @2
</code></pre>
</li>
<li>
<b>cdecl</b> functions must either be linked by ordinal number or have all-uppercase names.<p class=tl>
Unlike Pascal functions, which are converted to uppercase before they are exported, <b>_cdecl</b> functions retain their case when exported. The Windows dynamic-linking mechanism always converts function names to uppercase before it looks in the DLL for the function. However, functions exported from a DLL are expected to be in uppercase and are not converted. The result is a comparison between an uppercase function name and a mixed-case function name. This comparison, of course, fails. The solution is to declare the function name all-uppercase or to link by ordinal number and avoid the whole comparison problem.</P></li>
<li>
Variable argument C run-time library functions such as <b>vsprintf</b> and <b>vfprintf</b> do not take DS != SS into account. These functions are not available in DLLs. Compile with <b>/D_WINDLL</b> instead of <b>/D_WINDOWS</b> to detect functions that DLLs do not support. The C/C++ version 7.0 compiler option <b>/GD</b> does this automatically.</li>
</ul>
<p>
If the DLL will be used with different languages such as Visual Basic, Borland C++, Microsoft Excel, Zortech C++, or Microsoft FORTRAN, you should use the <b>PASCAL</b> convention. The registers used by the <b>_fastcall</b> convention can change between compiler versions and are not compatible between compilers by different vendors.</p>
<h2>Aliasing and Windows (/Ow and /Oa)</h2>
<p>
An <i>alias</i> is a second name that refers to a memory location. For example, in:</p>
<pre><code>int i ;
int *p ;
p = &amp;i ; 
</code></pre>
<p>
pointer <b>p</b> is an alias of variable <i>i</i>. You can use aliases to perform tasks while keeping the original pointer around, for example:</p>
<pre><code>// No error checking.
// Get a pointer.
//
LPSTR ptr = GlobalLock(GlobalAlloc(GHND,1000));
LPSRT ptr_alias = ptr ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // alias the pointer
for ( i = 0 ; i &lt; 1000 ; i++)
 &nbsp; *(ptr_alias++) = foo(i) ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // use the alias
GlobalFree(GlobalHandle(ptr));&nbsp;&nbsp;&nbsp; // free the memory
</code></pre>
<p>
The compiler makes the following assumptions if there is no aliasing:
<ul type=disc>
<li>
If a variable is used directly, no pointers reference that variable.<br><br></li>
<li>
If a pointer references a variable, that variable is not used directly.<br><br></li>
<li>
If a pointer modifies a memory location, no other pointers access the same memory location.</li>
</ul>
<h3>Global Register Allocation (/Oe)</h3>
<p>
Although aliasing is a common and acceptable practice, the compiler can improve optimizations if it can assume that there is no aliasing, because it can place more memory locations into registers. By default, the compiler uses registers:
<ul type=disc>
<li>
To hold temporary copies of variables.<br><br></li>
<li>
To hold variables declared with the <b>register</b> keyword.<br><br></li>
<li>
To pass arguments to functions declared with <b>fastcall</b> or compiled with <b>/Gr</b>.</li>
</ul>
<p>
The <b>/Ow</b> and <b>/Oa</b> options signal the compiler that it has more freedom to place variables or memory locations into registers; these options do not cause the compiler to keep variables in registers. </p>
<p>
The global register allocation option <b>/Oe</b>, on the other hand, allocates register storage to variables, memory locations, or common subexpressions. Instead of using registers only for temporary storage or for producing intermediate results, the <b>/Oe</b> option places the most frequently used variables into registers. For example, <b>/Oe</b> places a window handle, <i>hWnd</i>, in a register if a function is likely to use <i>hWnd</i> repeatedly. </p>
<p>
Because the no-aliasing options increase the compiler's opportunities to place a variable in a register, it makes sense to use these options with <b>/Oe</b>. In many cases, the <b>/Ow</b> and<b> /Oa</b> options do not optimize without the <b>/Oe</b> option. In some cases, you can eliminate problems with <b>/Ow</b> or <b>/Oa</b> by turning off <b>/Oe</b> optimization.</p>
<h3>Using /Ow Instead of /Oa</h3>
<p>
What is the difference between <b>/Ow</b> (Windows version) and <b>/Oa</b>? Basically, <b>/Ow</b> is a relaxed version of <b>/Oa</b>. It assumes aliasing will occur across function calls, so a memory location placed in a register is reloaded after a function call. For example, in:</p>
<pre><code>foobar( int * p) ;
{
 &nbsp; // Compiler puts the value that p points to into a register.
 &nbsp; *p = 5 ;
 &nbsp; foo() ;
 &nbsp; // If compiled with /Ow, the compiler reloads the register 
 &nbsp; //&nbsp; with p.
 &nbsp; (*p)++ ;
}
</code></pre>
<p>
the compiler places the memory referenced by pointer <b>p</b> into a register. If the <b>/Ow</b> option is set, the compiler reloads the register. If the <b>/Oa</b> option is set, pointer <b>p</b> is not reloaded after the function call. Thus, <b>/Ow</b> tells the compiler to forget everything about pointed-to values after function calls.</p>
<p>
Compiling the code fragment above with <b>/Ox</b> and <b>/Oa</b> results in the following code:</p>
<pre><code>mov&nbsp;&nbsp; si,WORD PTR [bp+4]&nbsp;&nbsp; ; pointer p is passed in at [bp+4]
mov&nbsp;&nbsp; WORD PTR [si],5
call&nbsp; _foo
mov&nbsp;&nbsp; WORD PTR [si],6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; compiler assumes that *p cannot
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp; change and generates *p=6 instead
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp; of (*p)++ 
</code></pre>
<p>
Notice how the compiler optimized away the last line that incremented pointer <b>p</b>.</p>
<p>
Compiling the code with <b>/Ox</b> and <b>/Ow</b> results in the following correct version:</p>
<pre><code>mov&nbsp;&nbsp; si,WORD PTR [bp+4]&nbsp;&nbsp; ; p
mov&nbsp;&nbsp; WORD PTR [si],5
call&nbsp; _foo
inc&nbsp;&nbsp; WORD PTR [si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; compiler assumes that 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp; *p might change.
</code></pre>
<p>
To understand the benefit this technique adds to a Windows-based program, look at the following code fragment:</p>
<pre><code>void Foo(HWND hwnd)
{
 &nbsp; char ach[80];

 &nbsp; // Zero terminate the string in case of error.
 &nbsp; //
 &nbsp; ach[0] = 0;

 &nbsp; SendMessage(hwnd, WM_GETTEXT, sizeof(ach), (LONG)(LPSTR)ach);

 &nbsp; // If some text is returned, do something with it.
 &nbsp; //
 &nbsp; if (ach[0] != 0)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; Bar(ach);
 &nbsp; }
}
</code></pre>
<p>
If you compile this code fragment with <b>/Oa</b> and C version 6.0, <b>Bar</b> is never called. If you use C/C++ version 7.0, <b>Bar</b> is called. The C version 6.0 compiler assumes that <b>ach</b> does not change in the <b>SendMessage</b> call and optimizes the call to the <b>if</b> block because <b>ach[0]</b> is still zero. If you compile the code with <b>/Ow</b>, the compiler expects <b>ach</b> to change after any function, including <b>SendMessage</b>. </p>
<p>
The C version 6.0 compiler appears to be pretty dumb—it does not realize that the <b>ach</b> pointer was passed to <b>SendMessage</b>. However, as far as the compiler can tell, a <b>LONG</b> was passed, not the pointer. If a pointer had been passed, <b>/Oa</b> would have worked. For example, in the following code:</p>
<pre><code>void SomeFunc(HWND hwnd, LPSTR astr, int asize)
{
 &nbsp; SendMessage(hwnd, WM_GETTEXT, asize, (LONG)astr);
}

void Foo(HWND hwnd)
{
 &nbsp; char ach[80];


 &nbsp; //Pass a pointer.
 &nbsp; SomeFunc(hwnd,(LPSTR)ach, sizeof(ach));

 &nbsp; if (ach[0] != 0)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; Bar(ach);
 &nbsp; }
}
</code></pre>
<p>
the compiler knows that the pointer is being passed and can be changed. This problem can occur in any function that takes a pointer as a <b>DWORD</b> (<i>lparam</i>) or a <b>WORD</b> (<i>wparam</i>). The C/C++ version 7.0 compiler corrects this behavior.</p>
<p>
You can also solve this problem by simply declaring <b>ach</b> volatile. This<b> </b>causes the compiler to place a variable in a register only if it must. However, <b>/Ow</b> usually generates better code than using the <b>volatile</b> keyword.</p>
<p>
Although <b>/Ow</b> is the easiest solution, the code it generates is not as efficient as the code <b>/Oa</b> generates, as illustrated by the <i>hWnd</i> window handle in the previous example. Window handles are commonly used in functions. They are perfect examples of variable types that are meant to be placed into registers; however, with the <b>/Ow</b> option they are reloaded after any function call. Using <b>#pragma optimize</b> at strategic locations to turn <b>/Ow</b> and <b>/Oa</b> off prevents problems associated with reloading. A profiler can help determine the placement of such statements.</p>
<p>
The <b>STRICT</b> macros defined in the Windows version 3.1 SDK WINDOWS.H file also reduce the need for the <b>/Ow</b> option. WINDOWSX.H includes macros that make most window functions type-safe. So, a pointer is passed as a pointer instead of being passed as a <b>LONG</b>. The <b>STRICT</b> macros can make an application more robust and should be used even if the <b>/Oa</b> option is not in effect.</p>
<h3>Avoiding Undocumented Features</h3>
<p>
Undocumented "features" are rarely necessary or useful, with the exception of file functions such as <b>_lcreate</b> that were not documented before Windows version 3.<i>x</i>. For example, an undocumented feature that saves neither time nor effort is demonstrated by the following code segment.</p>
<pre><code>HANDLE h = LocalAlloc(LMEM_MOVEABLE, cb);
HANDLE h2;
char* p;

// WARNING: Undocumented Hack.
// Dereference the handle without locking it.
//
char* p = *((char**)h);

// Use *p for a bit.
*p = 0;

h2 = LocalAlloc(LMEM_MOVEABLE, cb);

// Hmm... It could have moved, so dereference it again.
//
p = *((char**)h);

if (*p = 0)
{
   // Do something.
}
</code></pre>
<p>
You should not use this undocumented feature for two reasons:
<ul type=disc>
<li>
Future versions of Windows will have a flat memory model and will not support this type of memory accessing.<br><br></li>
<li>
The code will not compile as expected if you use the <b>/Oa</b> option. The <b>p</b> pointer is not passed to the <b>LocalAlloc</b> function; therefore, the compiler assumes that <b>p</b> will not change as a result of this function call. The programmer has tried to outsmart the compiler by dereferencing the pointer again after the function call, so the program appears to be safe. Not quite.... The compiler removes the second dereference statement because it assumes that <b>p</b> did not change as a result of the function call; this is exactly what the person who had to support the code would do.</li>
</ul>
<p>
To avoid this problem:
<ul type=disc>
<li>
Do not use this undocumented feature. (This is the best solution.)<br><br></li>
<li>
Use <b>/Ow</b> instead of <b>/Oa</b>.<br><br></li>
<li>
Always lock handles to memory before using them. <br><br></li>
<li>
Use <b>#pragma optimize</b> to selectively turn the <b>/Ow</b> option on and off. You can also turn <b>/Oe</b> off.<br><br></li>
<li>
Use the <b>volatile</b> keyword to ensure that variables are not placed in registers.</li>
</ul>
</BODY>
</HTML>
