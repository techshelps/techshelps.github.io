<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Migrating Your Database from Microsoft SQL Server Version 4.21 to Version 6.5</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_sqlport"></a></sup>Migrating Your Database from Microsoft SQL Server Version 4.21 to Version 6.5</h1>
<p>
Mark Gendron<br>
Microsoft Developer Network Technology Group</p>
<p>
August 12, 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4996">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the Build421 sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4995">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the Build65 sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
Upgrading to a new version of Microsoft® SQL Server can be a daunting prospect—the plethora of new features can seem overwhelming and the idea of introducing something new into a system after you have smoothed out all the wrinkles may seem less than appealing. Modifying your database schema to use new features can be costly and may have unintended effects on your system. Nevertheless, the gains can also be worth the cost in terms of better performance, simpler code, and easier maintenance in the future. </p>
<p>
The purpose of this article is to guide the reader through the process of updating a Microsoft SQL Server version 4.21 database to take advantage of new features introduced in versions 6.0 and 6.5. To illustrate the upgrade process, a sample version 4.21 database is provided. This article does not emphasize the mechanics of performing a server upgrade, which is covered in the product documentation. </p>
<h2>Introduction</h2>
<p>
There are good reasons to upgrade to Microsoft® SQL Server version 6.5 even if you do not wish to invest significant budget and development time in updating your code and adopting new features. For example, simply upgrading your server to version 6.5 will allow you to take advantage of internal optimizations to the Microsoft SQL Server product. You may also benefit from easier system administration via new tools like SQL Enterprise Manager (introduced in version 6.0). </p>
<p>
Upgrading from version 4.21 can be as simple as installing the new version on your server and checking your database for a few simple "gotchas." Upgrading can also be as complex as redesigning your database and your client applications to take advantage of a host of new features. </p>
<p>
This article examines upgrading from your version 4.21 database to version 6.5 by addressing the following areas: 
<ul type=disc>
<li>
<b>Upgrade Fundamentals.</b> Description of some basic precautions and practices, such as backing up data and verifying physical integrity of the database. Also included are a few additional ideas that you may not have considered. <br><br></li>
<li>
<b>Using New Features.</b> Discussion of some new features of versions 6.0 and 6.5. The sample database is used to demonstrate how these features can be implemented. Features that are discussed range from simple tweaks to more significant schema modifications. Assuming that the database that is being upgraded has been properly designed, there should be no negative effect on client applications. </li>
</ul>
<h2>Sample Database</h2>
<p>
To demonstrate the issues discussed in this article, I have developed a sample database that can be built in both versions 4.21 and 6.5 of Microsoft SQL Server. This is a simple database for organizing and managing content for a World Wide Web site and publishing that content. The database tracks both hierarchical content organization (directories and/or virtual roots) and hyperlinks. </p>
<p>
This article is not intended to deal with database design. Database purists will note that this is neither a logical model nor a complete physical model. It is a simplistic physical design that is adequate for our purposes. </p>
<h3>Development Environment</h3>
<p>
Samples used in this article were developed on the following versions of Microsoft SQL Server: 
<ul type=disc>
<li>
SQL Server for Windows NT 4.21a.05 (Intel X86) <br>
Jun 28 1995 08:20:31<br>
Copyright © 1988–1995 Microsoft Corporation; Copyright Sybase, Inc. 1987–1995<br>
(SQL Server 4.21a running Service Pack 4)<br><br></li>
<li>
Microsoft SQL Server 6.50–6.50.201 (Intel X86) <br>
Apr 3 1996 02:55:53<br>
Copyright © 1988–1996 Microsoft Corporation</li>
</ul>
<p>
The development server was a Dell Omniplex 590 running Microsoft Windows NT® version 4.0 (build 1314). </p>
<h3>Sample Tables</h3>
<p>
<img src="sqlport_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Sample database schema for Microsoft SQL Server version 4.21</b></p>
<p>
Figure 1 (above) shows the relationships of the following tables in the database:
<ul type=disc>
<li>
<b>Article.</b> Describes a discrete piece of content, such as a technical article, white paper, newspaper article, and so on. <br><br></li>
<li>
<b>Author.</b> Creator of the article. <br><br></li>
<li>
<b>Editor.</b> Editor of the article. <br><br></li>
<li>
<b>Matter.</b> Defines the relationship between an article and an editor. Any "issue" that involves an article and an editor is tracked by creating a matter. Matters might include "editing first draft," "technical review," and so on. <br><br></li>
<li>
<b>Publication.</b> Any organization of articles into a group or "publication." In this example, a publication could be a World Wide Web site. The database could track changes in the Web site by creating a separate publication for each site build date. <br><br></li>
<li>
<b>Node.</b> Any point in a publication hierarchy that can "contain" other nodes and/or articles. In our Web site example, a node represents a virtual root. A node may be related to one or more other nodes in parent-child relationships. <br><br></li>
<li>
<b>ArticlePub.</b> An article may be associated with a node by creating an ArticlePub entry. This places the article in a hierarchical structure. <br><br></li>
<li>
<b>Link.</b> A link associates two ArticlePub entries. In our example, this association would define a hyperlink from one article to another, or a jump within the same article. The <i>LinkSourceMethod</i> and <i>LinkTargetMethod</i> attributes define how the location and formatting of the hyperlink should be created. For example, if the article is in rich-text format (RTF), <i>LinkSourceMethod</i> and <i>LinkTargetMethod</i> might contain OLE Automation commands that would launch Microsoft Word and build the hyperlinks. The specifics of how these attributes might be used are not discussed further in this article. They are included simply to illustrate how the Link table is intended to be used and to make the database look cool. <br><br></li>
<li>
<b>PKIdentifier.</b> This table provides primary key values that are used to uniquely identify records in the various tables. In our example, the Identifier table assigns <i>ArticleID</i>, <i>AuthorID</i>, <i>PublicationID</i>, and so on. This table is not required in version 6.5. The <b>varchar(64)</b> primary key is obviously not efficient; however, this table will contain fewer than a dozen records, so performance will not be an issue. <br><br></li>
<li>
<b>CheckUpgrade.</b> This table may be built in version 4.21, but violates keywords and reserved words in versions 6.0 and 6.5. (not pictured in Figure 1). </li>
</ul>
<h3>Sample Stored Procedures</h3>
<p>
The database contains the following stored procedures: 
<ul type=disc>
<li>
<b>GetNextPKID.</b> Retrieves a primary key value from the PKIdentifier table. This procedure is not required in version 6.5. <br><br></li>
<li>
<b>InsertArticle.</b> Creates an Article record. <br><br></li>
<li>
<b>InsertArticleExt.</b> A variation of the InsertArticle procedure, using the CASE expression. <br><br></li>
<li>
<b>InsertMatter.</b> Creates a Matter record. <br><br></li>
<li>
<b>AuthSum.</b> Summarizes author ID by article type. Uses syntax that is legal in version 4.21 but not in versions 6.0 and 6.5. <br><br></li>
<li>
<b>TestCheckUpgrade.</b> This stored procedure may be built in version 4.21, but violates keywords and reserved words in versions 6.0 and 6.5. </li>
</ul>
<h3>User-Defined Datatypes</h3>
<p>
User-defined datatypes are used in the sample database to make the design easier to follow. Some of these would obviously not be appropriate in a real-world physical database implementation. 
<ul type=disc>
<li>
<b>PKID.</b> <b>Integer</b>; primary key identifier. <br><br></li>
<li>
<b>TypeCode.</b> <b>varchar(48)</b>; an all-purpose "category" type. <br><br></li>
<li>
<b>StdDescription.</b> <b>varchar(128)</b>; an all-purpose "description" type. </li>
</ul>
<h3>Building the Sample Database</h3>
<p>
To build the sample database you will need to follow the steps below. Note that there are separate versions of the sample scripts for versions 4.21 and 6.5. The script names are the same for each version. 
<ol>
<li>
Build a Microsoft database named "Content." Minimal allocation is needed; 2 megabytes for the data and 1 megabyte for the transaction log should be more than sufficient. <br><br></li>
<li>
Run the sample scripts in the following order: <ul type=disc>
<li>
DBBuild.SQL<br><br></li>
<li>
DataLoad.SQL<br><br></li>
<li>
GetNxtID.SQL (version 4.21 only)<br><br></li>
<li>
INSArtic.SQL<br><br></li>
<li>
INSMatte.SQL<br><br></li>
<li>
Keywords.SQL<br><br></li>
<li>
AuthSum.SQL</li>
</ul>
</li>
</ol>
<h2>Upgrade Fundamentals</h2>
<p>
Assuming that you will be upgrading your current Microsoft SQL Server version 4.21 installation to run version 6.5, there are basically two ways to proceed: 
<ol>
<li>
Run the setup program and upgrade the existing installation. Your existing database(s) will be converted. <br><br></li>
<li>
Bulk-copy process (BCP) your data out to files and uninstall version 4.21. Install version 6.5, rebuild your database(s), and BCP your data into the new database. </li>
</ol>
<p>
The mechanics of the upgrade process are explained quite well in the documentation that accompanies versions 6.0 and 6.5. You may refer to <i>Upgrading SQL Server</i> in the online documentation to review these steps. Although I will refer to some of these steps, they will not be covered extensively in this article. </p>
<p>
Whether you upgrade Microsoft SQL Server or reinstall it, and regardless of whether you will make significant changes to your database, any upgrade effort requires due diligence to protect your data. You will want to back up everything in sight to protect against any difficulties in the upgrade process. You may also want to test the referential integrity of your data and identify any referential integrity breakdowns before you upgrade. Although this has nothing to do with the upgrade process itself, let's face it: Changes make customers nervous, and rightfully so. If problems are identified after the upgrade, you may take some heat for it, even if the problems have nothing to do with your upgrade. A little extra coverage never hurt anyone—least of all a developer or a system administrator! </p>
<p>
The issues covered in this section are: 
<ul type=disc>
<li>
Documenting the database <br><br></li>
<li>
Checking for database consistency <br><br></li>
<li>
Verifying character sets and sort order <br><br></li>
<li>
Ensuring referential integrity <br><br></li>
<li>
Checking for keyword compatibility <br><br></li>
<li>
Third-party tool considerations</li>
</ul>
<h3>Document the Database</h3>
<p>
All too often, Microsoft SQL Server databases are "documented" only in the system tables. This is an unfortunate side-effect of overly ambitious development schedules and/or careless developers. Even if the database was religiously documented during development, subsequent changes may not be reflected in the documentation. Care should be taken to have the documentation updated whenever a change is made to the database. Unfortunately, in a world of late-night fixes and overworked operations personnel, this does not always happen. </p>
<p>
Even if you do have database documentation and it appears to be accurate, you may want to buy some additional peace of mind by reverse-engineering the production database to produce a "snapshot" of its design prior to the upgrade. If discrepancies are found after the upgrade, this snapshot will prove valuable in determining whether they arose during the upgrade process or afterward. This, too, may provide some valuable coverage. </p>
<p>
Taking a snapshot of the database is simple if you have a database modeling tool like ER<i>win</i> by Logic Works to do this work for you. If you don't have appropriate software, you can still produce some crude (but accurate) scripts by using Transact-SQL commands. A trick that I like to use is to generate these statements for all database objects by linking to the system tables. For example, the following statement will generate an SP_HELP command for each table in the database: </p>
<pre><code>SELECT 'sp_help ' 
  + name + char(10) 
  + 'go' + char(10) 
FROM sysobjects 
WHERE type = 'U' 
</code></pre>
<p>
You can then paste the resulting SP_HELP commands into ISQL/W and generate definitions for all tables, indexes, primary keys, and foreign keys in your database. A similar statement can be used to generate scripts for all triggers and stored procedures: </p>
<pre><code>SELECT 'sp_helptext ' 
  + name 
  + char(10) 
  + 'go' 
  + char(10) 
FROM sysobjects 
WHERE type in ('TR','P')&nbsp; 
ORDER BY type, name 
</code></pre>
<p>
Similar commands can be used to document other database objects, such as rules, defaults, and views. With luck, the scripts that you generate will match both your published documentation and the scripts in your source code management system. </p>
<h3>Check for Database Consistency</h3>
<p>
Before upgrading, use the DBCC command to check the consistency of your database. There are several DBCC options available. You should at least use CHECKDB and NEWALLOC. These options will verify your data and index page linking, index sorting, pointer consistency, page and extent usage, and so on. </p>
<p>
If problems are found, you will need to take steps to repair the database before proceeding. Be sure to back up the database before doing so. </p>
<h3>Verify Character Sets and Sort Order</h3>
<p>
By default, the Microsoft SQL Server version 4.21 setup program uses the <i>850 Multilingual</i> character set and a <i>binary</i> sort. In version 6.5, the default character set is <i>ISO</i> and the default sort is<i> dictionary order, case-insensitive</i>. </p>
<p>
If you upgrade your existing server, version 6.5 will use the same character set and sort order that was selected for your version 4.21 database. If you prefer to uninstall version 4.21 and install version 6.5, be sure to select the correct character set and sort order. If they are different after you upgrade, you can expect to see different results from some of your queries. </p>
<h3>Ensure Referential Integrity</h3>
<p>
A properly designed relational database will include primary and foreign key declarations to define referential integrity rules. Because version 4.21 lacks declarative referential integrity (DRI), your database should also include triggers to enforce each foreign key relationship. If any of these triggers are missing or have been compromised in any way, your data may contain breakdowns in referential integrity. In other words, you may have a child entity containing one or more records whose foreign key attribute(s) do not have a matching primary key value in the parent entity. </p>
<p>
For example, in our database there are four Author records defined in our sample data set. The AuthorID values for these records are 1 through 4. If the Article table were to contain a record in which AuthorID (the foreign key) was set to 5, then the Article record would reference an Author record that does not exist. This is an example of a breakdown in referential integrity. </p>
<p>
Writing queries to verify referential integrity can be time-consuming if your database is large or if there are a large number of foreign key declarations. If the database includes triggers to enforce all foreign key relationships, this is a good sign that there should be few—if any—referential integrity breakdowns. If you see "danger signs," you may want your test plan to include a full set of queries to check referential integrity. "Danger signs" include: 
<ul type=disc>
<li>
Lack of primary key and foreign key declarations. <br><br></li>
<li>
Lack of triggers to enforce referential integrity. <br><br></li>
<li>
Client applications or batch processes accessing the data tables directly, instead of using stored procedures. <br><br></li>
<li>
Poor security measures, such as login IDs, that give users greater permission levels than they require. <br><br></li>
<li>
Lack of error handling to warn of conditions or actions that could compromise referential integrity. </li>
</ul>
<p>
If you discover referential integrity breakdowns, you should resolve these before upgrading your database. Depending on the circumstances of the breakdown, you may want to work with your customer to resolve these or quietly resolve them yourself. If you find significant problems with the database architecture, you may need to push for more development and test resources than you had originally planned for. With luck, the bearer of bad tidings will not be slain. </p>
<h3>Check Keyword Compatibility</h3>
<p>
Beginning with Microsoft SQL Server version 6.0, new keywords and reserved words were introduced that may conflict with attribute names in your version 4.21 database. Some of these keywords are specific to Microsoft SQL Server and some have been introduced for ANSI compliance. A list of these keywords can be found in the online documentation. </p>
<p>
You probably know that you should run the CHKUPG.EXE utility to identify any keyword or reserved word conflicts in your version 4.21 database. If you are using attribute names that conflict with any keywords or reserved words, you will need to correct this before you upgrade. Unfortunately, CHKUPG.EXE is not as thorough as you might expect it to be. Consider the following table definition and stored procedure: </p>
<pre><code>CREATE TABLE CheckUpgrade 

  /* keywords */

  (<b>identitycol</b> &nbsp; int NOT NULL, 
 &nbsp; <b>constraint</b> &nbsp;&nbsp; int, 
 &nbsp; <b>floppy</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varchar(24), 

  /* reserved words */

 &nbsp; <b>cascaded</b> &nbsp;&nbsp;&nbsp;&nbsp; bit, 
 &nbsp; <b>deferred</b> &nbsp;&nbsp;&nbsp;&nbsp; tinyint, 
 &nbsp; <b>retaindays</b> &nbsp;&nbsp; smallint) 


CREATE PROCEDURE TestCheckUpgrade 
AS BEGIN 

  CREATE TABLE #temp1 

  /* keywords */

 &nbsp; (<b>identitycol</b> &nbsp; int NOT NULL, 
 &nbsp;&nbsp; <b>constraint</b> &nbsp;&nbsp; int, 
 &nbsp;&nbsp; <b>floppy</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varchar(24), 

  /* reserved words */

 &nbsp; <b>cascaded</b> &nbsp;&nbsp;&nbsp;&nbsp; bit, 
 &nbsp; <b>deferred</b> &nbsp;&nbsp;&nbsp;&nbsp; tinyint, 
 &nbsp; <b>retaindays</b> &nbsp;&nbsp; smallint) 

  DROP TABLE #temp1 
END 
</code></pre>
<p>
Both of these objects use keywords and reserved words as identifiers (bold text). Let's run CHKUPG.EXE and see what happens. </p>
<pre><code>Database: Content

 &nbsp; Status: 0
 &nbsp;&nbsp;&nbsp;&nbsp; (No problem)

 &nbsp; Missing objects in Syscomments
 &nbsp;&nbsp;&nbsp;&nbsp; None

 &nbsp; Keyword conflicts
 &nbsp;&nbsp;&nbsp;&nbsp; Column name: CheckUpgrade.CASCADED&nbsp;&nbsp;&nbsp;&nbsp; [SQL-92 keyword]
 &nbsp;&nbsp;&nbsp;&nbsp; Column name: CheckUpgrade.CONSTRAINT&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; Column name: CheckUpgrade.DEFERRED&nbsp;&nbsp;&nbsp;&nbsp; [SQL-92 keyword]
 &nbsp;&nbsp;&nbsp;&nbsp; Column name: CheckUpgrade.FLOPPY&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; Column name: CheckUpgrade.IDENTITYCOL&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; Column name: CheckUpgrade.RETAINDAYS&nbsp;&nbsp; [SQL-92 keyword]
</code></pre>
<p>
What's this? CHKUPG.EXE found the violations in the CheckUpgrade table definition, but it missed the violations in the TestCheckUpgrade procedure! This stored procedure will build correctly in version 4.21, but it cannot be built in versions 6.0 or 6.5. If you try to upgrade your server, the database that contains this procedure will not upgrade successfully. </p>
<p>
Another situation that CHKUPG.EXE will not detect is syntax that is valid in version 4.21 but not in versions 6.0 or 6.5. Here is an example: </p>
<pre><code>CREATE PROCEDURE AuthorSummary 
AS BEGIN 

SELECT AuthorID, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COUNT(*) 
FROM&nbsp;&nbsp; Article 
GROUP BY ArticleType 

END
</code></pre>
<p>
In version 4.21, your query may roll up (group) its results by an attribute that is not included in the SELECT list. ANSI-92 prohibits this, so this stored procedure will not compile in version 6.0 or 6.5. This procedure could be upgraded by adding ArticleType to the SELECT list. </p>
<p>
Naturally, CHCKUPG.EXE cannot detect any conflicts in code that does not exist in your database. Any embedded Transact-SQL commands outside your database may also contain keyword and reserved word conflicts. You will need to look very carefully at your client applications, your production batch scripts, and so on. If your system only allows database access via stored procedures, this will not be a problem because you will identify and correct those stored procedures when you test your database. </p>
<p>
If you are concerned about keyword and reserved-word conflicts (and you should be), you should seriously consider testing all of your database build scripts on a server running Microsoft SQL Server version 6.5 before you perform your upgrade. </p>
<h3>Third-Party Tools</h3>
<p>
If you use any third-party tools that have not been upgraded for compatibility with Microsoft SQL Server versions 6.0 and 6.5, you will need to consider their effect on your development and maintenance efforts. Code generators that are only SQL Server version 4.21–aware may violate any of the keywords, reserved words, or syntax that have been discussed. Data modeling packages that were designed for version 4.21 will not recognize the new <i>sysconstraints</i> system table; they will not be able to generate or interpret the declarative referential integrity enhancements that will be discussed later in this article. </p>
<p>
If you use a third-party tool that must create or interpret objects in your database, it is a safe bet that this tool must be upgraded to work with version 6.0 or 6.5. Unless you can live without this tool, you will want to investigate before proceeding with your upgrade. </p>
<h2>Using New Features</h2>
<p>
If you want to take advantage of some of the latest Microsoft SQL Server features, consider investing a bit more time and budget in your upgrade. There are a host of new features in version 6.5 that can be adopted at varying costs and with minimal impact on other aspects of your system. The following features will be addressed: 
<ul type=disc>
<li>
Declarative referential integrity <br><br></li>
<li>
Primary and foreign keys <br><br></li>
<li>
The <b>Identity</b> property <br><br></li>
<li>
ANSI-standard join clauses <br><br></li>
<li>
Setting variables and columns <br><br></li>
<li>
The CASE expression </li>
</ul>
<h3>Declarative Referential Integrity</h3>
<p>
Microsoft SQL Server version 6.0 introduced Declarative Referential Integrity (DRI). DRI offers ANSI-standard attribute constraints such as PRIMARY KEY, FOREIGN KEY, CHECK, DEFAULT, and UNIQUE. To enhance the DRI capability of version 6.0, the new <b>Identity</b> property has also been introduced. The DRI capabilities of Microsoft SQL Server offer more sophisticated methods for enforcing your business rules in your database. In some cases (though not all), you will be able to eliminate complex triggers and replace them with simple DRI constraints in your CREATE TABLE statements. Microsoft SQL Server will enforce these constraints automatically without the need for you to write any additional code. </p>
<p>
Business rules that can be modeled with simple Boolean expressions can usually be enforced with DRI. For example, the following rules can be enforced with the CHECK constraint: 
<ul type=disc>
<li>
<i>"Refund date must be greater than or equal to order date."</i> (CHECK constraint)<br><br></li>
<li>
<i>"Book return date must be twenty days after checkout date."</i> (DEFAULT constraint)<br><br></li>
<li>
<i>"Order quantity must be a multiple of five."</i> (CHECK constraint)</li>
</ul>
<p>
There are some business rules that cannot be modeled with DRI constraints but can be enforced with triggers. Here are some business rules that cannot be enforced using DRI constraints: 
<ul type=disc>
<li>
<i>"A customer may not place more than 999 orders in a calendar year."</i> (A subquery is required to count the number of orders the customer has placed.)<br><br></li>
<li>
<i>"Part number 850324 may not be ordered by customers in Arizona."</i> (The customer's address resides in a different table from the order details, so a subquery would be needed to evaluate it.)</li>
</ul>
<p>
Constraints are defined in a new system table called <i>sysconstraints</i>. </p>
<h4>Primary and Foreign Keys</h4>
<p>
A <i>primary key</i> consists of one or more fields that uniquely identify a record in a table. A <i>foreign key</i> is one or more fields that refer to a primary key in another table. In our example, consider the Author and Article tables, and their primary and foreign keys: </p>
<pre><code>CREATE TABLE Author
  (AuthorID&nbsp;&nbsp; PKID,
 &nbsp; Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StdDescription)

exec sp_primarykey Author, AuthorID

CREATE TABLE Article
  (ArticleID&nbsp;&nbsp;&nbsp;&nbsp; PKID,
 &nbsp; ArticleType&nbsp;&nbsp; TypeCode,
 &nbsp; AuthorID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PKID,
 &nbsp; Title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StdDescription NULL)

exec sp_primarykey Article, ArticleID
exec sp_foreignkey Article, Author, AuthorID
</code></pre>
<p>
Here we have created the two tables, declared a primary key on each, and declared a foreign key in the Article table. Unfortunately, defining these keys does not mean that the database will enforce them! In version 4.21, primary and foreign key declarations are for documentation purposes only; calling sp_primarykey and sp_foreignkey simply creates entries in the <i>syskeys</i> table and Microsoft SQL Server does nothing more with them. To enforce the primary keys, a unique index must be created: </p>
<pre><code>CREATE UNIQUE CLUSTERED INDEX XPKAuthor
ON Author (AuthorID)
</code></pre>
<p>
In order to enforce the foreign key, several triggers must be created: </p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Table</b></td>
<td class=label width=35%><b>Operation</b></td>
<td class=label width=40%><b>Trigger</b></td>
</tr>
<tr valign=top>
<td width=25%>Author</td>
<td width=35%>Delete</td>
<td width=40%>tD_Author</td>
</tr>
<tr valign=top>
<td width=25%>Author</td>
<td width=35%>Update</td>
<td width=40%>tU_Author</td>
</tr>
<tr valign=top>
<td width=25%>Article</td>
<td width=35%>Insert</td>
<td width=40%>tI_Article</td>
</tr>
<tr valign=top>
<td width=25%>Article</td>
<td width=35%>Update</td>
<td width=40%>tU_Article</td>
</tr>
</table><br>
<p>
Each trigger must check whether the requested operation violates the foreign key relationship. If it does, the trigger will roll back the transaction and raise an error message. </p>
<p>
This multistep process of declaring and enforcing referential integrity is one reason why referential integrity breakdowns are so common in version 4.21 databases: Tables may be defined with primary and foreign key declarations but without unique indexes and triggers to actually enforce the relationship rules. </p>
<p>
Beginning with Microsoft SQL Server version 6.0, triggers are no longer needed to enforce foreign key relationships, and unique indexes are not required to enforce primary keys. In their place, ANSI-standard attribute constraints are introduced. Consider the updated declarations for the Author and Article tables: </p>
<pre><code>CREATE TABLE Author
  (AuthorID&nbsp; PKID IDENTITY(1,1) PRIMARY KEY CLUSTERED,
 &nbsp; Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StdDescription NULL)

CREATE TABLE Article
  (ArticleID&nbsp;&nbsp;&nbsp; PKID IDENTITY(1,1) PRIMARY KEY CLUSTERED,
 &nbsp; ArticleType&nbsp; TypeCode,
 &nbsp; AuthorID&nbsp;&nbsp;&nbsp;&nbsp; PKID FOREIGN KEY (AuthorID) REFERENCES Author(AuthorID),
 &nbsp; Title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StdDescription NULL)
</code></pre>
<p>
Table definitions in versions 6.0 and 6.5 also allow ANSI-standard DEFAULT and CHECK constraints, which can replace the old-style defaults and rules. Using defaults and rules required that the defaults and rules first be created and then bound to either a specific column or to a user-defined datatype. The ANSI-standard DEFAULT and CHECK constraints simplify&nbsp; this process considerably. Note that the version 4.21 rule syntax and default syntax are still supported for backward compatibility. They can still be useful if you want to define these constraints for a user-defined datatype rather than defining them column by column. </p>
<p>
By defining primary and foreign keys in the table declaration, we eliminate the need for the calls to sp_primarykey and sp_foreignkey. Unique indexes need no longer be explicitly declared on the primary key attributes, and we can do away with the triggers—the database enforces the relationships automatically. That's a lot of code that we can eliminate. Less code means less maintenance and fewer chances to forget to build an object or relationship when recreating the database. </p>
<h4>Identity Property</h4>
<p>
In the above examples, I tossed in a little something extra: an <b>Identity</b> property. The <b>Identity</b> property allows you to specify a column that will be automatically populated with an incremented value each time a new record is added to the table. In the above examples, we have specified that we will start at 1, and increment by 1. This is the default seed and increment, but it is never a bad idea to specify such information for clarity. </p>
<p>
Using the <b>Identity</b> property on the primary key attributes has several advantages over the method we used in the sample version 4.21 database: 
<ul type=disc>
<li>
It eliminates the separate table (Identifier) for tracking the next available identifier value for each sequential key. <br><br></li>
<li>
It eliminates the stored procedure (GetNextPKID) that is used to retrieve values from the Identifier table and update it. This has the added advantage of eliminating the page locking on the Identifier table, which could present a bottleneck in multi-user situations. <br><br></li>
<li>
It simplifies INSERT procedures, which no longer need to call GetNextPKID before creating a record. </li>
</ul>
<p>
By using the <b>Identity</b> property, our InsertArticle procedure can be rewritten as follows (note that the deleted code is displayed in <b>bold</b> type for clarity):</p>
<pre><code>CREATE PROCEDURE InsertArticle
  (@ArticleID PKID OUT, 
 &nbsp; @ArticleType TypeCode, 
 &nbsp; @AuthorID PKID, 
 &nbsp; @Title StdDescription) 
AS BEGIN 

<b>DECLARE @ArtID&nbsp;&nbsp;&nbsp;&nbsp; PKID </b>

DECLARE @rc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 

<b>EXECUTE @rc = GetNextPKID&nbsp; </b>

<b> &nbsp; @PKIDName = 'ArticleID', </b>

<b> &nbsp; @PKIDValue = @ArtID OUT </b>


<b>IF @rc = -1 GOTO ERROR_EXIT </b>



INSERT INTO Article 

<b>  (ArticleID, </b>

 &nbsp; ArticleType, 
 &nbsp; AuthorID, 
 &nbsp; Title) 
VALUES 

<b>  (@ArtID, </b>

 &nbsp; @ArticleType, 
 &nbsp; @AuthorID, 
 &nbsp; @Title)

IF @@rowcount &lt;&gt; 1 GOTO ERROR_EXIT 

SUCCESS:

<b>  SELECT @ArticleID = @ArtID </b>

  SELECT @ArticleID = @@IDENTITY 
  RETURN 0

ERROR_EXIT:
  /* Raise an error message. */
  RETURN -1
END 
</code></pre>
<p>
Note the use of the new global variable, @@IDENTITY. After an INSERT statement involving an <b>Identity</b> column, this global variable will always contain the most recently assigned <b>Identity</b> value for the current process. </p>
<p>
It is possible to insert specific values into an <b>Identity</b> column by setting the table's IDENTITY_INSERT option, as follows: </p>
<pre><code>SET IDENTITY_INSERT Article ON 
/* INSERT statement including IDENTITY value */
SET IDENTITY_INSERT Article OFF 
</code></pre>
<p>
This technique is useful when loading data for which you must guarantee specific <b>Identity</b> values to maintain referential integrity. For an example of how to use the IDENTITY_INSERT option, see the data load scripts for the version 6.5 sample database. </p>
<h3>ANSI-Standard Join Clauses</h3>
<p>
Microsoft SQL Server version 6.5 introduces support for the following ANSI-standard join clauses: 
<ul type=disc>
<li>
INNER JOIN<br><br></li>
<li>
LEFT OUTER JOIN<br><br></li>
<li>
RIGHT OUTER JOIN<br><br></li>
<li>
FULL OUTER JOIN<br><br></li>
<li>
CROSS JOIN</li>
</ul>
<p>
Although the old-style join operators are still supported for compatibility, this support may be dropped in future releases of Microsoft SQL Server. Refer to the Microsoft SQL Server version 6.5 online documentation, <i>Future Feature Support</i> note, for more information about future support for old-style features. </p>
<p>
A significant feature of the ANSI-standard join operators is that the WHERE clause and its operators are no longer overloaded to provide both joins and restrictions. When the ANSI-standard join operators are used, the WHERE clause is used only for restrictions—"equal to," "greater than," and so on. </p>
<p>
The following sections provide some sample queries, using the old-style join syntax and the ANSI-standard operators. (The cross join is rarely used, and it will not be discussed further here.)</p>
<h4>INNER JOIN</h4>
<p>
Consider the following query, which lists all technical articles and their authors: </p>
<pre><code>SELECT a.Title, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; au.Name 
FROM&nbsp;&nbsp; Article a, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author au 
WHERE&nbsp; a.AuthorID = au.AuthorID 
AND&nbsp;&nbsp;&nbsp; a.ArticleType = 'Technical Article' 
</code></pre>
<p>
Note that the WHERE clause contains both a join and a restriction and that both clauses use the "=" operator. In the join clause, the "=" operator is overloaded to indicate both the <i>type</i> of join (in this case, a natural join) and <i>which attributes</i> should be compared in the join. This same query written using the ANSI-standard INNER JOIN operator looks like this: </p>
<pre><code>SELECT a.Title, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; au.Name 
FROM&nbsp;&nbsp; Article a INNER JOIN Author au 
ON&nbsp;&nbsp;&nbsp;&nbsp; a.AuthorID = au.AuthorID 
WHERE&nbsp; a.ArticleType = 'Technical Article' 
</code></pre>
<p>
Note that the WHERE clause no longer contains join information. Furthermore, the two components of the join (the type of join and the attributes used in the join) are no longer specified with a single overloaded operator. The type of join is specified with the INNER JOIN operator, while the "ON" keyword and "=" operator describe the attributes used in the join. </p>
<h4>LEFT and RIGHT OUTER JOIN</h4>
<p>
Following is an example of an outer join using the old join syntax. This join lists all articles and the editors to which they are assigned (if any). </p>
<pre><code>SELECT a.Title, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.EditorID&nbsp;&nbsp;&nbsp; 
INTO&nbsp;&nbsp; #temp1 
FROM&nbsp;&nbsp; Article a, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matter m 
WHERE&nbsp; a.ArticleID *= m.ArticleID 

SELECT t.Title AS 'Article', 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.Name AS 'Editor' 
FROM&nbsp;&nbsp; #temp1 t, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Editor e 
WHERE&nbsp; t.EditorID *= e.EditorID 

drop table #temp1 
</code></pre>
<p>
This query looks quite different when the ANSI-standard LEFT OUTER JOIN operator is used. Note that Microsoft SQL Server is much happier about performing this query in a single SELECT statement when the ANSI-standard operators are used. </p>
<pre><code>SELECT a.Title, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.Name 
FROM&nbsp;&nbsp; (Article a LEFT OUTER JOIN Matter m 
ON&nbsp;&nbsp;&nbsp;&nbsp; a.ArticleID = m.ArticleID) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LEFT OUTER JOIN Editor e 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON m.EditorID = e.EditorID 
</code></pre>
<h4>FULL OUTER JOIN</h4>
<p>
Suppose you want to produce a list that displays all articles and all editors, and also indicates when an article is assigned to an editor. This would be a rather challenging query in Microsoft SQL Server version 4.21, but the ANSI-standard FULL OUTER JOIN syntax makes it a snap: </p>
<pre><code>SELECT a.Title AS 'Article', 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.Name AS 'Editor' 
FROM&nbsp;&nbsp; (Article a FULL OUTER JOIN Matter m 
ON&nbsp;&nbsp;&nbsp;&nbsp; a.ArticleID = m.ArticleID) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FULL OUTER JOIN Editor e 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON m.EditorID = e.EditorID 
</code></pre>
<p>
The results look like this: </p>
<pre><code>Article&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Editor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
------------------------------------------------- --------------------
(null)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tina Brockwell&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
(null)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mindy H. Cameron&nbsp;&nbsp;&nbsp; 
Converting from MS Cardfile to SQL Server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Steve Landers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Using Distributed Transactions in SQL Server 6.5&nbsp; Mark Cromwell&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Overview of Microsoft Internet Technologies&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (null)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Microsoft Distributed Leaflet API&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (null)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</code></pre>
<h3>Setting Variables and Columns</h3>
<p>
Using the <b>Identity</b> property allows us to eliminate the GetNextPKID procedure. Nevertheless, let's resurrect that procedure for a moment because it provides a perfect opportunity to demonstrate how to verify both old and new column values in a single UPDATE statement. This offers the advantage of reducing the time during which locks are held, which may improve performance in a multi-user situation. </p>
<p>
The GetNextPKID procedure uses an explicit transaction containing a SELECT statement followed by an UPDATE. This prevents multiple clients from retrieving the same primary key value. Beginning with version 6.0, it is possible to include variable assignments in the SET list of an UPDATE operation. The single UPDATE operation is an implicit transaction, eliminating the need for BEGIN TRAN and COMMIT TRAN. This results in the lock being held for a shorter period of time and simplifies the code. </p>
<p>
Using this technique, GetNextPKID can be rewritten as shown below. Note that the old GetNextPKID procedure assumed that the PKIdentifier table contains the <i>next available</i> primary key value, while the new version assumes that PKIdentifier contains the <i>most recently used</i> primary key value. </p>
<pre><code>CREATE PROCEDURE TestMe&nbsp; 
  (@PKIDName varchar(64), 
 &nbsp; @PKIDValue PKID OUT) 

AS BEGIN 

DECLARE @PKID&nbsp;&nbsp;&nbsp; PKID 

UPDATE PKIdentifier 
SET PKIDValue = PKIDValue + 1, @PKID = PKIDValue 
WHERE PKIDName = @PKIDName 
 
IF @@ROWCOUNT &lt;&gt; 1 
BEGIN 
  /* Raise an error message. */
  RETURN -1
END 

SELECT @PKIDValue = @PKID 
RETURN 0 
END 
</code></pre>
<h3>CASE Expression</h3>
<p>
Microsoft SQL Server version 6.0 introduced the ANSI-compliant CASE expression. The CASE expression can substantially reduce the complexity of your code when you need to evaluate a large number of conditional values. </p>
<p>
To demonstrate the CASE expression, let's return to the InsertArticle procedure. The ArticleType parameter will accept just about anything that the user cares to enter. This is not a great idea. In the real world, we would probably make this attribute a foreign key to a table containing defined article types. For demonstration purposes, let's see how the CASE expression could be used to evaluate user inputs and select an appropriate article type. The following code can be inserted into the ArticleInsert procedure to evaluate the ArticleType parameter prior to the INSERT operation. Notice that this code is written to be case-insensitive. </p>
<pre><code>/* 
 * Evaluate the user-entered @ArticleType, 
 * and select an appropriate predefined type code. 
 */
SELECT @ArticleType= 
  CASE 
 &nbsp;&nbsp; WHEN CHARINDEX('TEC', UPPER(@ArticleType)) &lt;&gt; 0 THEN 'Technical Article'
 &nbsp;&nbsp; WHEN CHARINDEX('WH', UPPER(@ArticleType)) &lt;&gt; 0 THEN 'Whitepaper' 
 &nbsp;&nbsp; WHEN CHARINDEX('BA', UPPER(@ArticleType)) &lt;&gt; 0 THEN 'Backgrounder' 
 &nbsp;&nbsp; WHEN CHARINDEX('SP', UPPER(@ArticleType)) &lt;&gt; 0 THEN 'Specification' 
 &nbsp;&nbsp; WHEN CHARINDEX('DO', UPPER(@ArticleType)) &lt;&gt; 0 THEN 'Documentation' 
 &nbsp;&nbsp; ELSE 'Unknown' 
  END 
</code></pre>
<h2>Conclusion</h2>
<p>
There is more to upgrading from Microsoft SQL Server version 4.21 than simply dumping your database and running the setup program. Although you can take a minimalist approach to upgrading your SQL Server database, you may also want to examine your data and your database more closely in order to ensure a smooth transition and lots of happy customers. Your upgrade effort may provide an opportunity to uncover hidden problems in your existing database, and correct them before they cause unexpected problems. </p>
<p>
Significant changes have been introduced in versions 6.0 and 6.5—changes that may require you to rewrite some of your code from your version 4.21 database. There are also many new features that you can adopt to reduce the amount of code you must maintain, increase reliability, and keep your customers happy. </p>
</BODY>
</HTML>
