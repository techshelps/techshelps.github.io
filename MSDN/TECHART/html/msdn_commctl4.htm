<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Win32 Common Controls, Part 4: Header Windows and List View Windows</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_commctl4"></a>Win32 Common Controls, Part 4: Header Windows and List View Windows</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
April 1994</p>
<p>
Revised: February 1995 (LVS_NOITEMDATA style deleted)<br>
June 1995 (LVS_ALWAYSSEL removed; LVS_SHOWSELALWAYS added)</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="2313">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the ListView sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
The next release of the Microsoft® Windows® operating system (called Windows 95) presents a new set of common controls to developers of Windows-based applications. These controls are provided in a new dynamic-link library (DLL) called COMCTL32.DLL. The controls allow developers to integrate existing applications into the new Windows 95 shell more thoroughly and seamlessly. COMCTL32.DLL is included with Windows 95 and will also be supported in Win32s® (running on Windows version 3.1) and in Windows NT™. Note that these controls are 32-bit only—they will not be supported in 16-bit Windows environments. </p>
<p>
This article describes two new common controls, header windows and list view windows, which are generally used together. It is the fourth in a series of articles introducing the new common controls. The other articles in the series cover the following topics:
<ul type=disc>
<li>
<a href="msdn_commctl1.htm">Part 1: The basics</a><br><br></li>
<li>
<a href="msdn_commctl2.htm">Part 2: Status bars and toolbars</a><br><br></li>
<li>
<a href="msdn_commctl3.htm">Part 3: Trackbars, progress bars, and up-down controls</a><br><br></li>
<li>
<a href="msdn_commctl5.htm">Part 5: Image lists and tree view windows</a><br><br></li>
<li>
<a href="msdn_commctl6.htm">Part 6: Tab controls and property sheets</a></li>
</ul>
<p>
Parts 2–6 of the series have associated code samples that demonstrate the use of the Win32® common controls.</p>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;The ListView executable file associated with this article was built and tested using the Windows 95 Preliminary Development Kit. The executable will run only on Windows 95; it will not run under Windows 3.1 or Windows NT. If you have Windows 95 installed on your machine, but you have problems running this sample, copy the project files to your system using the button above, rebuild the project, and run the executable.</p>
<p>
Please note that this article is based on preliminary information that is subject to change before the final version of Windows 95.</p>
<h2>Header Windows</h2>
<p>
A header window<i> </i>is a horizontal window usually positioned above columns of text or numbers, containing titles for each column. Microsoft® Mail and Microsoft Excel include examples of these controls. You can divide a header window into parts, called <i>header items</i>, and allow the user to set the width of each item. Items can behave like push buttons and do something (for example, sort data) when the user clicks them. Header items appear as text on a gray background. It is important to note that header windows do not support a keyboard interface, and, as a result, do not accept the input focus.</p>
<p>
Header windows are generally used in conjunction with list view windows. You can see an example of a header window/list view window combination in the ListView sample that is associated with this article.</p>
<p>
Each item in a header window can have a string, a bitmapped image, and an application-defined 32-bit value associated with it. The string and bitmap are displayed within the boundaries of the item. If an item contains both a string and an image, the image is displayed above the string. If the string and image overlap, the string overwrites the overlapping portion of the image. Figure 1 illustrates a typical header window with four header items.</p>
<p>
<img src="commctl4_1.gif" border=0></p>
<p class=label>
<b>Figure 1. A header window with four header items</b></p>
<h3>Header Window Styles</h3>
<p>
Header windows can have different window styles that determine the appearance and behavior of the window. For example, if you include the HDS_DIVIDERTRACK window style, the user will be able to set the width of the items by dragging the divider between the items with the mouse. You set the initial styles when you create the header window. If you want to get the current styles or change the styles later, you can use the <b>GetWindowLong</b> and <b>SetWindowLong</b> functions. Table 1 lists the header window styles supported in the Microsoft Windows® 95 operating system.</p>
<p class=label>
<b>Table 1. Header Window Styles</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Style</b></td>
<td class=label width=75%><b>Use</b></td>
</tr>
<tr valign=top>
<td width=25%>HDS_BUTTONS</td>
<td width=75%>Causes header items to act like push buttons. This style is useful if your application must do something (for example, sort a list) when the user clicks a header item.</td>
</tr>
<tr valign=top>
<td width=25%>HDS_DIVIDERTRACK</td>
<td width=75%>Enables the user to use the divider area between header items to set the width of the items.</td>
</tr>
<tr valign=top>
<td width=25%>HDS_HIDDEN</td>
<td width=75%>Hides the header window. (You may want to do this, for example, if you want to create the header window when launching your application, but fill in the text for header items later, or if you want to reuse the header window and dynamically change the associated text.)</td>
</tr>
<tr valign=top>
<td width=25%>HDS_HORZ</td>
<td width=75%>Specifies a horizontal header window.</td>
</tr>
</table><br>
<h3>Header Window Behavior</h3>
<p>
Typically, you must set the size and position of a header window to fit within the boundaries of a particular rectangle, such as the client area of the parent window. The default position is (–100, –100); the default width and height are 10 device units each. You can query the system for the appropriate size and position by sending the HDM_LAYOUT message to the header window. When sending this message, you fill in the coordinates of the rectangle that the header window should occupy, and you pass a pointer to a <b>WINDOWPOS</b> structure. The header window fills in the <b>WINDOWPOS</b> structure with size and position values appropriate for positioning the window along the top of the specified rectangle. The height value is the sum of the width of the window's horizontal borders and the average height of characters in the font currently selected into the window's device context. If you want to use the HDM_LAYOUT message to set the initial size and position of a header window, you should set the initial visibility state of the window so that it is hidden (by specifying the HDS_HIDDEN style). Once you have created the window and used the HDM_LAYOUT message to get the size and position values, you can call the <b>SetWindowPos</b> function to set the new size, position, and visibility state.</p>
<h3>Creating a Header Window</h3>
<p>
You can create a header window by calling the <b>CreateWindow</b> or <b>CreateWindowEx</b> function, and specifying WC_HEADER for the class name. You can use the following code to create a header window and position it along the top of its parent window's client area. The code uses the <b>Header_Layout</b> macro (which sends the HDM_LAYOUT message) to get the appropriate size and position for the header window, given the bounding rectangle of the parent window's client area. The <b>CreateHeaderWindow</b> function returns the handle of the newly created header window. If the header window cannot be created, the function returns NULL.</p>
<pre><code>HWND CreateHeaderWindow(HWND hwndParent)
{
 &nbsp; HWND hwndHeader;
 &nbsp; RECT rcParent;
 &nbsp; HD_LAYOUT hdl;
 &nbsp; WINDOWPOS wp;

 &nbsp; if ((hwndHeader = CreateWindowEx(
 &nbsp;&nbsp;&nbsp;&nbsp; 0L,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No extended styles.
 &nbsp;&nbsp;&nbsp;&nbsp; WC_HEADER,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A header class window.
 &nbsp;&nbsp;&nbsp;&nbsp; (LPCTSTR) NULL, // No default text.
 &nbsp;&nbsp;&nbsp;&nbsp; WS_CHILD | WS_BORDER | HDS_BUTTONS | HDS_HORZ | HDS_DIVIDERTRACK, 
 &nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 0,&nbsp;&nbsp;&nbsp;&nbsp; // No size or position.
 &nbsp;&nbsp;&nbsp;&nbsp; hwndParent,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle to the parent window.
 &nbsp;&nbsp;&nbsp;&nbsp; (HMENU) ID_HEADER,&nbsp; // ID for the header window.
 &nbsp;&nbsp;&nbsp;&nbsp; hInst,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Current instance.
 &nbsp;&nbsp;&nbsp;&nbsp; (LPVOID) NULL)) == NULL) // No application-defined data.

 &nbsp;&nbsp;&nbsp;&nbsp; return (HWND) NULL;

 &nbsp; // Get the bounding rectangle of the parent window's client area.
 &nbsp; GetClientRect(hwndParent, &amp;rcParent);

 &nbsp; hdl.prc = &amp;rcParent;
 &nbsp; hdl.pwpos = &amp;wp;
 &nbsp; // Call the Header_Layout macro to get the appropriate size
 &nbsp; // for the window.
 &nbsp; if (Header_Layout (hwndHeader, &amp;hdl) == FALSE)
 &nbsp;&nbsp;&nbsp;&nbsp; return (HWND) NULL;

 &nbsp; // Set the size, position, and visibility of the header window.
 &nbsp; SetWindowPos(hwndHeader, wp.hwndInsertAfter, wp.x, wp.y,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wp.cx, wp.cy, wp.flags | SWP_SHOWWINDOW);

 &nbsp; return hwndHeader;
}
</code></pre>
<h3>Adding an Item to a Header Window</h3>
<p>
Now that the header window has been created, it is time to start adding items to it. (It would be pretty silly to have a header window with no items.) You can add an item to a header window by sending the HDM_INSERTITEM message to the window or by calling the <b>Header_InsertItem</b> macro. The HDM_INSERTITEM message includes the address of an <b>HD_ITEM</b> structure that defines the properties of the item, including its string, bitmap, initial size, and application-defined value. The structure also specifies formatting flags that tell the header window whether to center, left-justify, or right-justify the string or bitmap within the item's rectangle. The following code demonstrates how to add an item (string or bitmap) to a header window using the <b>Header_InsertItem</b> macro.</p>
<pre><code>BOOL InsertItem(HWND hwndHeader, LPSTR lpsz, HBITMAP hBitmap)
{
 &nbsp; HD_ITEM hdi;&nbsp; // Header item.

 &nbsp; // The .fmt member is valid and the .cxy member specifies the width.
 &nbsp; hdi.mask = HDI_FORMAT | HDI_WIDTH; 
 &nbsp; hdi.fmt = HDF_LEFT;&nbsp; // Left-justify the item.

 &nbsp; if (lpsz)&nbsp; // It is a string.
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; hdi.mask |= HDI_TEXT;&nbsp;&nbsp; // The .pszText member is valid.
 &nbsp;&nbsp;&nbsp;&nbsp; hdi.pszText = lpsz;&nbsp;&nbsp;&nbsp;&nbsp; // The text for the item.
 &nbsp;&nbsp;&nbsp;&nbsp; hdi.cxy = 75;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The initial width.
 &nbsp;&nbsp;&nbsp;&nbsp; hdi.cchTextMax = lstrlen(hdi.pszText);&nbsp; // The length of the string.
 &nbsp;&nbsp;&nbsp;&nbsp; hdi.fmt |= HDF_STRING;&nbsp; // This item is a string.
 &nbsp; }
 &nbsp; if (hBitmap)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; hdi.mask |= HDI_BITMAP; // The .hbm member is valid.
 &nbsp;&nbsp;&nbsp;&nbsp; hdi.cxy = 32;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The initial width.
 &nbsp;&nbsp;&nbsp;&nbsp; hdi.hbm = hBitmap;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The handle to the bitmap.
 &nbsp;&nbsp;&nbsp;&nbsp; hdi.fmt |= HDF_BITMAP;&nbsp; // This item is a bitmap.
 &nbsp; }

 &nbsp; // Insert the item at the current index.
 &nbsp; if (Header_InsertItem(hwndHeader, CurrIndex, &amp;hdi) == TRUE)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CurrIndex++;&nbsp; // Increment the index.
 &nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp; }
 &nbsp; return FALSE;
}
</code></pre>
<h3>Header Window Messages</h3>
<p>
An application sends messages to header windows as it would to any other window, to change the behavior and appearance of the window. For example, you can add items, delete items, or change the text of an item by sending the appropriate message. Each message has a corresponding macro that you can send to a header window. This section lists header window messages, the corresponding macros, return values, and parameters. The <i>hwndHD</i> parameter for each macro is the handle to the header window. In many cases, <i>wParam</i> and <i>lParam</i> are zero and not used. The structures mentioned in the descriptions below are described in the next section, "Header Window Structures."</p>
<h4>HDM_DELETEITEM</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item to delete
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The HDM_DELETEITEM message deletes an item from a header window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the item to delete. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> <b>BOOL Header_DeleteItem</b>(<i>hwndHD</i>, <i>i</i>);</p>
<h4>HDM_GETITEM</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item
lParam = (HD_ITEM *)phdi;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ buffer receiving the item information
</code></pre>
<p>
<b>Description:</b> The HDM_GETITEM message gets information about an item in a header window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the item for which information is requested. <i>lParam</i> (<b>HD_ITEM *</b> <i>phdi</i>) is the address of an <b>HD_ITEM</b> structure. The <i>mask</i> member of the <b>HD_ITEM</b> structure indicates the type of information being requested. The other members of the structure are filled in based on the requested information. If <i>mask</i> is zero, the message returns TRUE, but copies no information to the <b>HD_ITEM</b> structure.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>Header_GetItem</b>(<i>hwndHD</i>, <i>i</i>, <i>phdi</i>); </p>
<h4>HDM_GETITEMCOUNT</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The HDM_GETITEMCOUNT message gets a count of the items in a header window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The number of items if successful; –1 otherwise.</p>
<p>
<b>Macro:</b> <b>int</b> <b>Header_GetItemCount</b>(<i>hwndHD</i>); </p>
<h4>HDM_INSERTITEM</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item after which to insert 
lParam = (HD_ITEM *)phdi;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ structure containing item information
</code></pre>
<p>
<b>Description:</b> The HDM_INSERTITEM message inserts a new item within a header window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the item after which the new item is to be inserted. The new item is inserted at the end of the header window if <i>i</i> is greater than or equal to the number of items in the window. <i>lParam</i> (<b>HD_ITEM</b> * <i>phdi</i>) is the address of an <b>HD_ITEM</b> structure that contains information about the new item.</p>
<p>
<b>Return value:</b> The index of the new item if successful; –1 otherwise.</p>
<p>
<b>Macro:</b> <b>int</b> <b>Header_InsertItem</b>(<i>hwndHD</i>, <i>i</i>, <i>phdi</i>);</p>
<h4>HDM_LAYOUT</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (HD_LAYOUT *)playout;&nbsp;&nbsp;&nbsp; \\ structure containing layout information
</code></pre>
<p>
<b>Description:</b> The HDM_LAYOUT message gets the size and position of a header within a given rectangle. This message is used to determine the dimensions of a new header window, given the bounding rectangle specified in the <i>prc</i> member of the <b>HD_LAYOUT</b> structure.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>HD_LAYOUT</b> * <i>playout</i>) is the address of an <b>HD_LAYOUT</b> structure. In <b>HD_LAYOUT</b>, the <i>prc</i> member specifies the coordinates of a rectangle, and the <i>pwpos</i> member is filled in with the size and position of the header window within the given rectangle.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>Header_Layout</b>(<i>hwndHD</i>, <i>playout</i>); </p>
<h4>HDM_SETITEM</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item to be set
lParam = (HD_ITEM *)phdi;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ structure containing item information
</code></pre>
<p>
<b>Description:</b> The HDM_SETITEM message sets the attributes of the specified item in a header window. The HDN_ITEMCHANGING notification is sent to the parent window before the item attributes are changed. The parent window can return FALSE to prevent the changes, in which case HDM_SETITEM returns FALSE. If the parent window returns TRUE, the changes are made and the parent window receives an HDN_ITEMCHANGED notification.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the item whose attributes are to be changed. <i>lParam</i> (<b>HD_ITEM</b> * <i>phdi</i>) is the address of an <b>HD_ITEM</b> structure. The <i>mask</i> member of the <b>HD_ITEM</b> structure indicates the attributes to set. The other members of the structure specify the new attributes.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>Header_SetItem</b>(<i>hwndHD</i>, <i>i</i>, <i>phdi</i>); </p>
<h3>Header Window Structures</h3>
<p>
This section lists the new structures in Windows 95 that support header windows. An application may need to use these structures whenever it sends a message or notification to a header window.</p>
<h4>HD_ITEM</h4>
<pre><code>typedef struct _HD_ITEM {
 &nbsp;&nbsp; UINT mask;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ mask flags, as described below
 &nbsp;&nbsp; int cxy;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ width and height of the item
 &nbsp;&nbsp; LPSTR pszText;&nbsp; \\ the item string
 &nbsp;&nbsp; HBITMAP hbm;&nbsp;&nbsp;&nbsp; \\ handle of the item bitmap
 &nbsp;&nbsp; int cchText;&nbsp;&nbsp;&nbsp; \\ length of the item string, in characters
 &nbsp;&nbsp; int fmt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ format flags, as described below
 &nbsp;&nbsp; LPARAM lParam;&nbsp; \\ application-defined data
} HD_ITEM;
</code></pre>
<p>
The <b>HD_ITEM</b> structure contains information about an item in a header window. You fill in this structure whenever you add an item to the header window. You can also get this information by using the <b>Header_GetItem</b> macro. The <b>HD_ITEM</b> structure has the following members:
<ul type=disc>
<li>
<b>UINT</b> <i>mask</i>: Mask flags that indicate which of the other structure members contain valid data. This member can be a combination of the following flags:<p class=tl>
HDI_BITMAP: The <i>hbm</i> member is valid.</P><p class=tl>
HDI_FORMAT: The <i>fmt</i> member is valid.</P><p class=tl>
HDI_HEIGHT: The <i>cxy</i> member is valid and specifies the height of the item.</P><p class=tl>
HDI_LPARAM: The <i>lParam</i> member is valid.</P><p class=tl>
HDI_TEXT: The <i>pszText</i> and <i>cchTextMax</i> members are valid.</P><p class=tl>
HDI_WIDTH: The <i>cxy </i>member is valid and specifies the width of the item.</P></li>
<li>
<b>int</b> <i>cxy</i>: The width or height of the item, depending on which flag was specified, HDI_HEIGHT or HDI_WIDTH.<br><br></li>
<li>
<b>LPSTR</b> <i>pszText</i>: The address of the item string.<br><br></li>
<li>
<b>HBITMAP</b> <i>hbm</i>: The handle of the item bitmap.<br><br></li>
<li>
<b>int</b> <i>cchText</i>: The length of the item string in characters.<br><br></li>
<li>
<b>int</b> <i>fmt</i>: Format flags that determine how to draw the item. This member can be one of the following values:<p class=tl>
HDF_CENTER: Center the contents (string or bitmap) of the item.</P><p class=tl>
HDF_LEFT: Left-justify the contents of the item.</P><p class=tl>
HDF_RIGHT: Right-justify the contents of the item.</P><p class=tl>
This member can also be combined with one of the following values:</P><p class=tl>
HDF_BITMAP: The item displays a bitmap.</P><p class=tl>
HDF_OWNERDRAW: The header window's parent window draws the item.</P><p class=tl>
HDF_STRING: The item displays a string.</P></li>
<li>
<b>LPARAM</b> <i>lParam</i>: This member is for application-defined item data.</li>
</ul>
<h4>HD_LAYOUT</h4>
<pre><code>typedef struct _HD_LAYOUT {
 &nbsp;&nbsp; RECT FAR *prc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ bounding rectangle coordinates
 &nbsp;&nbsp; WINDOWPOS FAR *pwpos;&nbsp; \\ appropriate size for the header window
} HD_LAYOUT;
</code></pre>
<p>
The <b>HD_LAYOUT</b> structure contains information for setting the size and position of a header window. This structure is used with the HDM_LAYOUT message and contains the following members:
<ul type=disc>
<li>
<b>RECT FAR *</b> <i>prc</i>: Address of a <b>RECT</b> structure that contains the coordinates of a bounding rectangle for the header window.<br><br></li>
<li>
<b>WINDOWPOS FAR *</b> <i>pwpos</i>: Address of a <b>WINDOWPOS</b> structure that is filled in with the correct size and position of the header window.</li>
</ul>
<h4>HD_NOTIFY</h4>
<pre><code>typedef struct _HD_NOTIFY {
 &nbsp;&nbsp; NMHDR hdr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ common control notification structure
 &nbsp;&nbsp; int iItem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item
 &nbsp;&nbsp; int iButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the mouse button
 &nbsp;&nbsp; HD_ITEM *pitem;&nbsp;&nbsp; \\ item information
} HD_NOTIFY;
</code></pre>
<p>
The <b>HD_NOTIFY</b> structure contains information used to process notification messages from a header window. This structure contains the following members:
<ul type=disc>
<li>
<b>NMHDR</b> <i>hdr</i>: A notification message structure that is common to all of the new common controls in Windows 95.<br><br></li>
<li>
<b>int</b> <i>iItem</i>: The index of the item associated with the notification.<br><br></li>
<li>
<b>int</b> <i>iButton</i>: The index of the mouse button that generated the notification. This member can be one of the following values:<p class=tl>
0: The user clicked the left mouse button.</P><p class=tl>
1: The user clicked the right mouse button.</P><p class=tl>
2: The user clicked the middle mouse button.</P></li>
<li>
<b>HD_ITEM FAR *</b> <i>pitem</i>: The address of an <b>HD_ITEM</b> structure that contains information about the header item associated with the notification.</li>
</ul>
<h3>Header Window Notification Messages</h3>
<p>
Table 2 lists the notification messages that Windows sends to header windows. The parent window of the header window receives these messages via a WM_NOTIFY message. For each notification, the <i>lParam</i> is a FAR pointer to an <b>HD_NOTIFY</b> structure (described in the previous section).</p>
<p class=label>
<b>Table 2. Header Window Notification Messages</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Message</b></td>
<td class=label width=74%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=26%>HDN_BEGINTRACK</td>
<td width=74%>Sent when the user begins dragging a divider in the window (the user has pressed the left mouse button while the mouse cursor is over a divider in the header window). The parent window may return FALSE to allow tracking of the divider, or TRUE to prevent tracking.</td>
</tr>
<tr valign=top>
<td width=26%>HDN_ENDTRACK</td>
<td width=74%>Sent when the user finishes dragging a divider.</td>
</tr>
<tr valign=top>
<td width=26%>HDN_ITEMCHANGED</td>
<td width=74%>Sent when the attributes of a header item have changed.</td>
</tr>
<tr valign=top>
<td width=26%>HDN_ITEMCHANGING</td>
<td width=74%>Sent when the attributes of a header item are about to change. The parent window may return FALSE to allow the changes, or TRUE to prevent them.</td>
</tr>
<tr valign=top>
<td width=26%>HDN_ITEMCLICK</td>
<td width=74%>Sent when the user clicks the header window. A header window sends this notification after the user releases the left mouse button. A window that has the HDS_DIVIDERTRACK style does not send this notification when the user clicks the divider.</td>
</tr>
<tr valign=top>
<td width=26%>HDN_TRACK</td>
<td width=74%>Sent when the user drags a divider in the header window. The parent window may return FALSE to continue tracking the divider, or TRUE to end tracking.</td>
</tr>
</table><br>
<h2>List View Windows</h2>
<p>
A list view window displays a collection of items such as files or folders. The user or an application can manipulate these items in a variety of ways, for example, they can drag the items or sort them by clicking the column headings. Any number of subitems can be associated with each item, but all items must have the same number of subitems. A subitem contains a text string that appears next to the item in report view.</p>
<p>
A list view window can be viewed in four different ways (views): using their large (or standard) icons, using their small icons, as a list, or as a report. The current view is specified by two window style bits that you can set with the <b>SetWindowStyle</b> function.</p>
<p>
In standard icon view, each item is represented by a full-sized icon and a text label. The user can drag items to any location in the list view window. A list view window in standard icon view (illustrated in Figure 2) resembles a program group in the Windows 3.1 Program Manager. </p>
<p>
<img src="commctl4_2.gif" border=0></p>
<p class=label>
<b>Figure 2. A list view window in standard icon view</b></p>
<p>
In small icon view, each item is represented by a small icon and text to the right of the icon, thus saving screen real estate. As in standard icon view, the user can drag the items to any location in the window. Figure 3 shows a list view window in small icon view. To avoid truncating the labels, you can reset the length of the displayed text in your program.</p>
<p>
<img src="commctl4_3.gif" border=0></p>
<p class=label>
<b>Figure 3. A list view window in small icon view</b></p>
<p>
List view also uses the small icon and the text label to the right of the icon, but the items are arranged in columns and cannot be dragged by the user (Figure 4).</p>
<p>
<img src="commctl4_4.gif" border=0></p>
<p class=label>
<b>Figure 4. A list view window in list view</b></p>
<p>
In report view, you can display the items with their small icons and labels, and you can provide additional information about each item. Each item appears on its own line, with information arranged in columns. The leftmost column contains the icon, followed by the text label. Additional columns display the text for each of the item's subitems. Optionally, you can use a header window to show the title of each column. In Figure 5, if the user clicks one of the column headings, the list is sorted based on the sort criterion specified for that column. For example, clicking the Bedrooms heading sorts the data by the number of bedrooms.</p>
<p>
<img src="commctl4_5.gif" border=0></p>
<p class=label>
<b>Figure 5. A list view window in report view</b></p>
<h3>List View Window Styles and States</h3>
<p>
You can specify different window styles when you create a list view window to determine the appearance and behavior of the window. You set the initial styles when you create the list view window with the <b>CreateWindow</b> or <b>CreateWindowEx</b> function. Table 3 lists the window styles that Windows 95 supports for list view windows.</p>
<p class=label>
<b>Table 3. List View Window Styles</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Style</b></td>
<td class=label width=71%><b>Use</b></td>
</tr>
<tr valign=top>
<td width=29%>LVS_ICON, LVS_SMALLICON, LVS_LIST, or <br>
LVS_REPORT</td>
<td width=71%>Specifies the current view for the window: standard icon, small icon, list, or report.</td>
</tr>
<tr valign=top>
<td width=29%>LVS_SINGLESEL</td>
<td width=71%>Allows the user to select only one item at a time from the list view window. By default, the user may select multiple items.</td>
</tr>
<tr valign=top>
<td width=29%>LVS_SHOWSELALWAYS</td>
<td width=71%>Specifies that the selection (if any) should always be shown, even if the list view does not have the focus.</td>
</tr>
<tr valign=top>
<td width=29%>LVS_SORTASCENDING or LVS_SORTDESCENDING</td>
<td width=71%>Sorts items based on their text labels. Items can be sorted either in ascending or descending order.</td>
</tr>
<tr valign=top>
<td width=29%>LVS_SHAREIMAGELISTS</td>
<td width=71%>Prevents image lists from being created when the window is created, or destroyed when the window is destroyed.</td>
</tr>
<tr valign=top>
<td width=29%>LVS_NOLABELWRAP</td>
<td width=71%>Displays text labels on a single line in icon view. By default, text labels may wrap in icon view.</td>
</tr>
<tr valign=top>
<td width=29%>LVS_AUTOARRANGE</td>
<td width=71%>Automatically arranges icons in standard icon view and small icon view.</td>
</tr>
<tr valign=top>
<td width=29%>LVS_EDITLABELS</td>
<td width=71%>Allows the user to edit text labels in place.</td>
</tr>
<tr valign=top>
<td width=29%>LVS_ALIGNLEFT, LVS_ALIGNRIGHT, LVS_ALIGNBOTTOM, or LVS_ALIGNTOP</td>
<td width=71%>Specifies the alignment of items within the list view window. These flags only apply to standard icon and small icon view.</td>
</tr>
<tr valign=top>
<td width=29%>LVS_NOCOLUMNHEADER</td>
<td width=71%>Specifies that there is no column header. This style is valid for report view only.</td>
</tr>
<tr valign=top>
<td width=29%>LVS_NOSCROLL</td>
<td width=71%>Disables scrolling. No item is allowed outside of the client area.</td>
</tr>
<tr valign=top>
<td width=29%>LVS_STATEIMAGES</td>
<td width=71%>Indicates that there is a user-defined state for the images. This style uses the state image list.</td>
</tr>
</table><br>
<p>
Use the <b>SetWindowStyle</b> function to set some or all of the window styles for a list view window, and to notify the list view window that its style is changing. This function sends the WM_STYLECHANGING and WM_STYLECHANGED messages to the list view window. The mask parameter of <b>SetWindowStyle</b> can be one of the following:
<ul type=disc>
<li>
LVS_TYPEMASK: Change the current view. This value is a bitwise OR of the LVS_ICON, LVS_SMALLICON, LVS_LIST, and LVS_REPORT style flags.<br><br></li>
<li>
LVS_ALIGNMASK: Change the current alignment. This value is a bitwise OR of the LVS_ALIGNLEFT, LVS_ALIGNRIGHT, LVS_ALIGNBOTTOM, and LVS_ALIGNTOP style flags.</li>
</ul>
<p>
Each item in a list view window has a current state (for example, selected or marked). These states are updated in response to a user's actions or when they are changed explicitly in the code. By default, the list view window maintains the state of each list item. However, you can specify that the list view notify the parent window (using the LVN_GETDISPINFO notification) whenever it needs to determine the state of an item via a callback. Table 4 lists the different states allowed for items.</p>
<p class=label>
<b>Table 4. List View Item States</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Value</b></td>
<td class=label width=75%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=25%>LVIS_SELECTED</td>
<td width=75%>The item is selected. The appearance of a selected item depends on whether it has the focus and on the system colors used for selection.</td>
</tr>
<tr valign=top>
<td width=25%>LVIS_FOCUSED</td>
<td width=75%>The item has the focus and is surrounded by a standard focus rectangle. Although more than one item may be selected, only one item can have the focus.</td>
</tr>
<tr valign=top>
<td width=25%>LVIS_CUT</td>
<td width=75%>The item is checked.</td>
</tr>
<tr valign=top>
<td width=25%>LVIS_DISABLED</td>
<td width=75%>The item is disabled and is drawn using the standard disabled style and coloring.</td>
</tr>
<tr valign=top>
<td width=25%>LVIS_HIDDEN</td>
<td width=75%>The item is not visible and does not respond to user interaction.</td>
</tr>
<tr valign=top>
<td width=25%>LVIS_DROPHILITED</td>
<td width=75%>The item is highlighted as a drag-and-drop target.</td>
</tr>
<tr valign=top>
<td width=25%>LVIS_LINK</td>
<td width=75%>The item is a link and is drawn accordingly.</td>
</tr>
<tr valign=top>
<td width=25%>LIVS_OVERLAYMASK</td>
<td width=75%>The item is used as an image list overlay image.</td>
</tr>
<tr valign=top>
<td width=25%>LVIS_USERMASK</td>
<td width=75%>The item uses client bits for state image drawing.</td>
</tr>
</table><br>
<h3>Creating a List View Window</h3>
<p>
Creating a list view window may appear to be a daunting task at first. Getting all of the information placed in the correct structures involves several steps:
<ol>
<li>
Create the window using <b>CreateWindow</b> or <b>CreateWindowEx</b>, specifying WC_LISTVIEW for the class name.<br><br></li>
<li>
Create image lists for the large and small icon views. Load the bitmaps for the images and add them to the image list. For more information on image lists, please see the next article in this series, entitled <a href="msdn_commctl5.htm">"Win32 Common Controls, Part Five: Image Lists and Tree View Windows,"</a> in the MSDN Library.<br><br></li>
<li>
Initialize the column headings you will use by loading the strings and calling <b>ListView_InsertColumn</b>.<br><br></li>
<li>
Insert each item into the list view and initialize any associated text.</li>
</ol>
<p>
The following code demonstrates these steps. For my sample, I created a real-estate listing. A structure that I defined contains information about the houses listed, including address, city, price, number of bedrooms, and number of bathrooms. I created an icon for each city represented (three icons total).</p>
<pre><code>// House structure used for listing.
typedef struct tagHOUSEINFO {
 &nbsp; char szAddress[MAX_ADDRESS];
 &nbsp; char szCity[MAX_CITY];
 &nbsp; int iPrice;
 &nbsp; int iBeds;
 &nbsp; int iBaths;
} HOUSEINFO;

// Function that creates the list view window.
HWND CreateListView (HWND hWndParent)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
{
 &nbsp; HWND hWndList;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle to the list view window.
 &nbsp; RECT rcl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rectangle for setting the size of the window.
 &nbsp; HICON hIcon;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle to an icon.
 &nbsp; int index;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Index used in for loops.
 &nbsp; HIMAGELIST hSmall, hLarge; // Handles to image lists for large and small&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // icons.
 &nbsp; LV_COLUMN lvC;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // List view column structure.
 &nbsp; char szText[64];&nbsp;&nbsp;&nbsp; // place to store some text.
 &nbsp; LV_ITEM lvI;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // List view item structure.
 &nbsp; int iSubItem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Index for inserting subitems.

 &nbsp; // Ensure that the common window DLL is loaded.
 &nbsp; InitCommonControls();

 &nbsp; // Get the size and position of the parent window.
 &nbsp; GetClientRect(hWndParent, &amp;rcl);

 &nbsp; // Create the list view window.
 &nbsp; hWndList = CreateWindowEx( 0L,
 &nbsp;&nbsp;&nbsp;&nbsp; WC_LISTVIEW,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // List view class.
 &nbsp;&nbsp;&nbsp;&nbsp; "",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No default text.
 &nbsp;&nbsp;&nbsp;&nbsp; WS_VISIBLE | WS_CHILD | WS_BORDER | LVS_REPORT, // Window styles.
 &nbsp;&nbsp;&nbsp;&nbsp; 0, 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Default x and y position.
 &nbsp;&nbsp;&nbsp;&nbsp; rcl.right - rcl.left, rcl.bottom - rcl.top, // Width and height of window.
 &nbsp;&nbsp;&nbsp;&nbsp; HWndParent,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Parent window.
 &nbsp;&nbsp;&nbsp;&nbsp; (HMENU) ID_LISTVIEW,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Window ID.
 &nbsp;&nbsp;&nbsp;&nbsp; HInst,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Current instance.
 &nbsp;&nbsp;&nbsp;&nbsp; NULL );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No application-defined data.

 &nbsp; if (hWndList == NULL )
 &nbsp;&nbsp;&nbsp;&nbsp; return NULL;

 &nbsp; // Initialize the list view window.
 &nbsp; // First, initialize the image lists we will need
 &nbsp; // to create an image list for the small icons.
 &nbsp; hSmall = ImageList_Create ( BITMAP_WIDTH, BITMAP_HEIGHT, FALSE, 3, 0 );

 &nbsp; // Create an image list for the large icons.
 &nbsp; hLarge = ImageList_Create (BITMAP_WIDTH, BITMAP_HEIGHT, FALSE, 3, 0 )

 &nbsp; // Load the icons and add them to the image lists.
 &nbsp; for (index = REDMOND; index &lt;= SEATTLE ; index++)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; hIcon = LoadIcon ( hInst, MAKEINTRESOURCE(index));
 &nbsp;&nbsp;&nbsp;&nbsp; // There are 3 of each icon type, so add 3 at a time.
 &nbsp;&nbsp;&nbsp;&nbsp; for (iSubItem = 0; iSubItem &lt; 3; iSubItem++)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((ImageList_AddIcon(hSmall, hIcon) == -1) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ImageList_AddIcon(hLarge, hIcon) == -1))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }

 &nbsp; // Make sure that all of the icons are in the lists.
 &nbsp; if (ImageList_GetImageCount(hSmall) &lt; 3)
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp; if (ImageList_GetImageCount(hLarge) &lt; 3)
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp; // Associate lists with list view window.
 &nbsp; ListView_SetImageList(hWndList, hSmall, LVSIL_SMALL);
 &nbsp; ListView_SetImageList(hWndList, hLarge, LVS1L_NORMAL);

 &nbsp; // Now initialize the columns we will need.
 &nbsp; // Initialize the LV_COLUMN structure.
 &nbsp; // The mask specifies that the .fmt, .ex, width, and .subitem members 
 &nbsp; // of the structure are valid.
 &nbsp; lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
 &nbsp; lvC.fmt = LVCFMT_LEFT;&nbsp; // Left-align the column.
 &nbsp; lvC.cx = 75;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Width of the column, in pixels.
 &nbsp; lvC.pszText = szText;&nbsp;&nbsp; // The text for the column.

 &nbsp; // Add the columns. They are loaded from a string table.
 &nbsp; for (index = 0; index &lt;= NUM_COLUMNS; index++)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; lvC.iSubItem = index;
 &nbsp;&nbsp;&nbsp;&nbsp; LoadString( hInst, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDS_ADDRESS + index,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szText,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(szText));
 &nbsp;&nbsp;&nbsp;&nbsp; if (ListView_InsertColumn(hWndList, index, &amp;lvC) == -1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
 &nbsp; }

 &nbsp; // Finally, let's add the actual items to the window.
 &nbsp; // Fill in the LV_ITEM structure for each of the items to add
 &nbsp; // to the list.
 &nbsp; // The mask specifies that the .pszText, .iImage, .lParam and .state
 &nbsp; // members of the LV_ITEM structure are valid.
 &nbsp; lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
 &nbsp; lvI.state = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; lvI.stateMask = 0;&nbsp; 

 &nbsp; for (index = 0; index &lt; NUM_ITEMS; index++)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; lvI.iItem = index;
 &nbsp;&nbsp;&nbsp;&nbsp; lvI.iSubItem = 0;
 &nbsp;&nbsp;&nbsp;&nbsp; // The parent window is responsible for storing the text. The list view
 &nbsp;&nbsp;&nbsp;&nbsp; // window will send an LVN_GETDISPINFO when it needs the text to display.
 &nbsp;&nbsp;&nbsp;&nbsp; lvI.pszText = LPSTR_TEXTCALLBACK; 
 &nbsp;&nbsp;&nbsp;&nbsp; lvI.cchTextMax = MAX_ITEMLEN;
 &nbsp;&nbsp;&nbsp;&nbsp; lvI.iImage = index;
 &nbsp;&nbsp;&nbsp;&nbsp; lvI.lParam = (LPARAM)&amp;rgHouseInfo[index];

 &nbsp;&nbsp;&nbsp;&nbsp; if (ListView_InsertItem(hWndList, &amp;lvI) == -1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;

 &nbsp;&nbsp;&nbsp;&nbsp; for (iSubItem = 1; iSubItem &lt; NUM_COLUMNS; iSubItem++)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListView_SetItemText( hWndList,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iSubItem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR_TEXTCALLBACK);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
 &nbsp; return (hWndList);
}
</code></pre>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="2314">
</OBJECT><a href="javascript:sample2.Click()">To see how the code above behaves, click to open the ListView project files and run LISTVIEW.EXE.</a></p>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;The ListView executable file was built and tested using the Windows 95 Preliminary Development Kit. The executable will run only on Windows 95; it will not run under Windows 3.1 or Windows NT. If you have Windows 95 installed on your computer but you have problems running this sample, copy the project files to your system, rebuild the project, and run the executable.</p>
<h3>Handling the WM_NOTIFY Message in a List View Window</h3>
<p>
Once you have created a list view window, you need some way to handle the WM_NOTIFY messages that will be sent to the parent window. The following code is an implementation of a handler that I set up to do this. When the parent window receives the WM_NOTIFY notification, it calls this function to see whether it needs text for a list view item and whether it is necessary to sort the items. I am only interested in two of the notifications: the LVN_GETDISPINFO notification, which is sent when the system needs text supplied for a list view item, and the LVN_COLUMNCLICK notification, which is sent whenever the user clicks a column heading.</p>
<pre><code>LRESULT NotifyHandler( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
 &nbsp; LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
 &nbsp; NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
 &nbsp; HOUSEINFO *pHouse = (HOUSEINFO *)(pLvdi-&gt;item.lParam);
 &nbsp; static char szText[10];

 &nbsp; if (wParam != ID_LISTVIEW)
 &nbsp;&nbsp;&nbsp;&nbsp; return 0L;

 &nbsp; switch(pLvdi-&gt;hdr.code)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; case LVN_GETDISPINFO:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Display the appropriate item, getting the text or number
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // from the HOUSEINFO structure I set up.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (pLvdi-&gt;item.iSubItem)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:&nbsp;&nbsp;&nbsp;&nbsp; // Address
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pLvdi-&gt;item.pszText = pHouse-&gt;szAddress;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:&nbsp;&nbsp;&nbsp;&nbsp; // City
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pLvdi-&gt;item.pszText = pHouse-&gt;szCity;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:&nbsp;&nbsp;&nbsp;&nbsp; // Price
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wsprintf(szText, "$%u", pHouse-&gt;iPrice);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pLvdi-&gt;item.pszText = szText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:&nbsp;&nbsp;&nbsp;&nbsp; // Number of bedrooms
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wsprintf(szText, "%u", pHouse-&gt;iBeds);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pLvdi-&gt;item.pszText = szText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4:&nbsp;&nbsp;&nbsp;&nbsp; // Number of bathrooms
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wsprintf(szText, "%u", pHouse-&gt;iBaths);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pLvdi-&gt;item.pszText = szText;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; case LVN_COLUMNCLICK:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The user clicked one of the column headings. Sort by
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // this column. This function calls an application-defined
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // comparison callback function, ListViewCompareProc. The 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // code for the comparison procedure is listed in the next section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListView_SortItems( pNm-&gt;hdr.hwndFrom,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListViewCompareProc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPARAM)(pNm-&gt;iSubItem));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; }
 &nbsp; return 0L;
}
</code></pre>
<h3>Sorting Items in Response to a Column Heading Click</h3>
<p>
Our list view window is now almost fully functional. The only thing left to implement is the code to sort the list view items when the user clicks a column heading. The list view window does not sort the items for you. (Drats!) This makes some sense—how would the system know which criterion you wanted to sort on (for example, color or size)? However, I would have liked to see Windows 95 provide some built-in sorting callbacks for "standard" sorting needs such as string comparisons and numeric sorts. (I guess I'll have to drop another suggestion in the big black box.) Because the list view window doesn't have this capability, you have to provide a callback function to do the sorting.</p>
<p>
The following code demonstrates one method of sorting. It uses the <b>lstrcmpi</b> function to compare strings and simple arithmetic to sort the numbers. The <b>lstrcmpi</b> function compares two strings by checking the first character in the strings, the second character, the third character, and so on against each other until it reaches the end of the strings or it finds an inequality. The function returns the difference of the values of the first mismatched characters it encounters, for example, it determines that "abcz" is greater than "abcdefg" and returns the difference between z and d. For those of you who have localization concerns, the language (locale) selected by the user at setup time (or via the Control Panel) determines which string is greater (or whether the strings are the same). If no language (locale) is selected, Windows performs the comparison by using default values. This function can compare two double-byte character set (DBCS) strings in the DBCS version of Windows:</p>
<pre><code>int CALLBACK ListViewCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM 
 &nbsp; lParamSort)
{
 &nbsp; HOUSEINFO *pHouse1 = (HOUSEINFO *)lParam1;
 &nbsp; HOUSEINFO *pHouse2 = (HOUSEINFO *)lParam2;
 &nbsp; LPSTR lpStr1, lpStr2;
 &nbsp; int iResult;

 &nbsp; if (pHouse1 &amp;&amp; pHouse2)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; switch( lParamSort)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:&nbsp;&nbsp;&nbsp;&nbsp; // Sort by address.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpStr1 = pHouse1-&gt;szAddress;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpStr2 = pHouse2-&gt;szAddress;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iResult = lstrcmpi(lpStr1, lpStr2);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:&nbsp;&nbsp;&nbsp;&nbsp; // Sort by city.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpStr1 = pHouse1-&gt;szCity;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpStr2 = pHouse2-&gt;szCity;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iResult = lstrcmpi(lpStr1, lpStr2);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:&nbsp;&nbsp;&nbsp;&nbsp; // Sort by price.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iResult = pHouse1-&gt;iPrice - pHouse2-&gt;iPrice;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:&nbsp;&nbsp;&nbsp;&nbsp; // Sort by the number of bedrooms.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iResult = pHouse1-&gt;iBeds - pHouse2-&gt;iBeds;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4:&nbsp;&nbsp;&nbsp;&nbsp; // Sort by the number of bathrooms.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iResult = pHouse1-&gt;iBaths - pHouse2-&gt;iBaths;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iResult = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
 &nbsp; return(iResult);
}
</code></pre>
<h3>List View Messages</h3>
<p>
This very long section lists the new messages you can use to manipulate list view windows. My suggestion is to skip to the next section, "List View Structures," and refer back to this section when you want to learn about specific functionality. Of course, if you love reading lists, this will be your favorite section. For the messages listed below, HWND <i>hwndLV</i> refers to the handle to the list view window unless otherwise noted. In many cases, <i>wParam </i>and/or <i>lParam</i> are zero and not used.</p>
<h4>LVM_ARRANGE</h4>
<pre><code>wParam = UINT code;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ alignment and sort flag
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_ARRANGE message arranges the items in icon view.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>UINT</b> <i>code</i>) is the alignment and (optionally) the sort flag. The sort flag can be one of the values listed in Table 5 below. <i>lParam</i> is not used.</p>
<p class=label>
<b>Table 5. List View Alignment Options</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=35%><b>Value</b></td>
<td class=label width=65%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=35%>LVA_DEFAULT</td>
<td width=65%>Use the current alignment.</td>
</tr>
<tr valign=top>
<td width=35%>LVA_ALIGNLEFT</td>
<td width=65%>Align along the left of the list window.</td>
</tr>
<tr valign=top>
<td width=35%>LVA_ALIGNTOP</td>
<td width=65%>Align along the top of the list window.</td>
</tr>
<tr valign=top>
<td width=35%>LVA_ALIGNBOTTOM</td>
<td width=65%>Align along the bottom of the list window.</td>
</tr>
<tr valign=top>
<td width=35%>LVA_ALIGNRIGHT</td>
<td width=65%>Align along the right of the list window.</td>
</tr>
<tr valign=top>
<td width=35%>LVA_SNAPTOGRID</td>
<td width=65%>Arrange the icons according to the closest grid position.</td>
</tr>
<tr valign=top>
<td width=35%>LVA_SORTASCENDING</td>
<td width=65%>Sort in ascending order.</td>
</tr>
<tr valign=top>
<td width=35%>LVA_SORTDESCENDING</td>
<td width=65%>Sort in descending order.</td>
</tr>
</table><br>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> <b>BOOL</b> <b>ListView_Arrange</b>(<b>HWND</b> <i>hwndLV</i>, <b>UINT</b> <i>code</i>);</p>
<h4>LVM_CREATEDRAGIMAGE</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the list view item
lParam = lpptUpLeft;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_CREATEDRAGIMAGE message creates a drag image for the specified item.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the list view item. <i>lParam</i> (<b>LPPOINT</b> <i>lpptUpLeft</i>) is the address of a <b>POINT</b> structure that receives the initial location of the upper-left corner of the image, in view coordinates. </p>
<p>
<b>Return value:</b> The handle to the image list created, or NULL if unsuccessful.</p>
<p>
<b>Macro:</b> (<b>HIMAGELIST</b>)<b>ListView_CreateDragImage</b>(<i>hwndLV</i>, <i>iItem</i>, <i>lpptUpLeft</i>); </p>
<h4>LVM_DELETEALLITEMS</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_DELETEALLITEMS message removes all items from a list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (BOOL)ListView_DeleteAllItems(<i>hwndLV</i>);</p>
<h4>LVM_DELETECOLUMN</h4>
<pre><code>wParam = iCol;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the column to delete
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_DELETECOLUMN message removes a column from a list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>iCol</i>) is the index of the column to delete. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_DeleteColumn</b>(<i>hwndLV</i>, <i>iCol</i>);</p>
<h4>LVM_DELETEITEM</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item to delete
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_DELETEITEM message removes an item from a list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the item to delete. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_DeleteItem</b>(<i>hwndLV</i>, <i>i</i>); </p>
<h4>LVM_EDITLABEL</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item being edited
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_EDITLABEL message begins in-place editing of an item's text. This message selects and sets the focus to the item. When the user completes or cancels editing, the edit window is destroyed and the handle becomes invalid. You can safely subclass the edit window, but do not destroy it. To cancel editing, you can send the list view a WM_CANCELMODE message.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the list view item being edited. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> If successful, the message returns the handle of the edit window used to edit the text. This will be NULL if the editing is unsuccessful.</p>
<p>
<b>Macro:</b> (<b>HWND</b>)<b>ListView_EditLabel</b>(<i>hwndLV</i>, <i>i</i>);</p>
<h4>LVM_ENSUREVISIBLE</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item
lParam = (BOOL)fPartialOK;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ TRUE to prohibit scrolling
</code></pre>
<p>
<b>Description:</b> The LVM_ENSUREVISIBLE message ensures that a list view item is entirely or partially visible by scrolling the list view window if necessary.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the list view item. If <i>lParam</i> (<b>BOOL</b> <i>fPartialOK</i>) is TRUE, no scrolling will occur if the item is at least partially visible. If FALSE, the item must be entirely visible.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_EnsureVisible</b>(<i>hwndLV</i>, <i>I</i>, <i>fPartialOK</i>);</p>
<h4>LVM_FINDITEM</h4>
<pre><code>wParam = iStart;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of item to start search
lParam = (LV_FINDINFO *)plvfi;&nbsp;&nbsp;&nbsp; \\ structure specifying search criteria
</code></pre>
<p>
<b>Description:</b> The LVM_FINDITEM message searches for a list view item.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>iStart</i>) is the index of the item at which the search will start. Specifying –1 will start the search at the beginning. <i>lParam</i> (<b>LV_FINDINFO</b> <i>*plvfi</i>) is the structure that specifies the search criteria.</p>
<p>
<b>Return value:</b> If successful, the message returns an <b>int</b> indicating the index of the list view item. If unsuccessful, the message returns –1.</p>
<p>
<b>Macro:</b> (<b>int</b>)<b>ListView_FindItem</b>(<i>hwndLV</i>, <i>iStart</i>, <i>plvfi</i>); </p>
<h4>LVM_GETBKCOLOR</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_GETBKCOLOR message gets the background color of the list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The background color of the window (<b>COLORREF</b>).</p>
<p>
<b>Macro:</b> (<b>COLORREF</b>) <b>ListView_GetBkColor</b> (<i>hwndLV</i>); </p>
<h4>LVM_GETCALLBACKMASK</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_GETCALLBACKMASK message gets the callback mask for a list view window. For information about the callback mask, see Table 4, List View Item States, previously in this article.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The callback mask (<b>UINT</b>).</p>
<p>
<b>Macro:</b> (<b>UINT</b>)<b>ListView_GetCallbackMask</b>(<i>hwndLV</i>);</p>
<h4>LVM_GETCOLUMN</h4>
<pre><code>wParam = iCol;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the column
lParam = (LV_COLUMN FAR *)pcol;&nbsp;&nbsp; \\ structure that gets the column information
</code></pre>
<p>
<b>Description:</b> The LVM_GETCOLUMN message gets the attributes of a list view column. The <i>mask</i> member of the <b>LV_COLUMN</b> structure passed in specifies which attributes to get. If the LVCF_TEXT flag is specified, the <i>pszText</i> member must contain the address of the buffer that receives the item text, and the <i>cchTextMax</i> member must specify the size of the buffer.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>iCol</i>) is the index of the column. <i>lParam</i> (<b>LV_COLUMN</b> <i>FAR * pcol</i>) is the structure to be filled in with column information.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_GetColumn</b>(<i>hwndLV</i>, <i>iCol</i>, <i>pcol</i>);</p>
<h4>LVM_GETCOLUMNWIDTH</h4>
<pre><code>wParam = iCol;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the column
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_GETCOLUMNWIDTH message gets the width of a column in list view or report view.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>iCol</i>) is the index of the column. This is ignored in list view. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> The column width if successful; zero otherwise.</p>
<p>
<b>Macro:</b> (<b>int</b>)<b>ListView_GetColumnWidth</b>(<i>hwndLV</i>, <i>iCol</i>);</p>
<h4>LVM_GETCOUNTPERPAGE</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_GETCOUNTPERPAGE message calculates the number of items that can fit vertically in the visible area of a view control in list view or report view.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The number of items if successful. If the list view is currently in standard icon or small icon view, the return value is the total number of items in the list view.</p>
<p>
<b>Macro:</b> <b>(int)ListView_GetCountPerPage</b>(<i>hwndLV</i>);</p>
<h4>LVM_GETEDITCONTROL</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_GETEDITCONTROL message gets the handle of the edit window used to edit the item text in place. The edit window is destroyed and the handle becomes invalid when the user completes or cancels editing. You can safely subclass the edit window, but do not destroy it. To cancel editing, you can send the list view a WM_CANCELMODE message. The list view item being edited is the item that is currently in the focused state.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The handle of the edit window if successful. If the message is unsuccessful or no label is currently being edited, the message returns NULL.</p>
<p>
<b>Macro:</b> (<b>HWND</b>)<b>ListView_GetEditControl</b>(<i>hwndLV</i>);</p>
<h4>LVM_GETIMAGELIST</h4>
<pre><code>wParam = (BOOL)fSmallImages;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ TRUE to get small icon list
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_GETIMAGELIST message gets the handle of an image list used for drawing list view items.</p>
<p>
<b>Parameters:</b> If <i>wParam</i> (<b>int</b> <i>fSmallImages</i>) is TRUE, the message returns a handle for the small icon image list; if FALSE, the message returns a handle for the standard icon image list. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> The handle of the specified image list if successful; NULL otherwise.</p>
<p>
<b>Macro:</b> <b>HIMAGELIST</b> <b>ListView_GetImageList</b>(<i>hwndLV</i>, <i>fSmallImages</i>);</p>
<h4>LVM_GETITEM</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (LV_ITEM FAR *)pitem;&nbsp;&nbsp;&nbsp; \\ structure receiving item information
</code></pre>
<p>
<b>Description:</b> The LVM_GETITEM message gets a list view item's attributes.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>LV_ITEM</b> <i>FAR</i> <i>* pitem</i>) is the item structure to fill in. The <i>iItem</i> and <i>iSubItem</i> members of the <b>LV_ITEM</b> structure identify the item or subitem on which to get information, and the <i>mask</i> member specifies the attributes to get. If the <i>mask</i> member specifies the LVIF_TEXT flag, the <i>pszText</i> member must contain the address of the buffer that receives the item text, and the <i>cchTextMax</i> member must specify the size of the buffer. If the <i>mask</i> member specifies the LVIF_STATE flag, the <i>stateMask</i> member specifies which item states are to be returned.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_GetItem</b>(<i>hwndLV</i>, <i>pitem</i>);</p>
<h4>LVM_GETITEMCOUNT</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_GETITEMCOUNT message gets the number of items in a list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The number of items.</p>
<p>
<b>Macro:</b> (<b>int</b>)<b>ListView_GetItemCount</b>(<i>hwndLV</i>);</p>
<h4>LVM_GETITEMPOSITION</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the list view item
lParam = (POINT FAR *)ppt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ position of the item
</code></pre>
<p>
<b>Description:</b> The LVM_GETITEMPOSITION message gets the position of a list view item in standard icon and small icon views.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the list view item. <i>lParam</i> (<b>POINT</b> <i>FAR* ppt</i>) is the position of the item in the list view window's client coordinates.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_GetItemPosition</b>(<i>hwndLV</i>, <i>I</i>, <i>ppt</i>);</p>
<h4>LVM_GETITEMRECT</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item
lParam = (RECT FAR *)prc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ bounding rectangle
</code></pre>
<p>
<b>Description:</b> The LVM_GETITEMRECT message gets the bounding rectangle for an item in the current view.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the item. <i>lParam</i> (<b>RECT</b> <i>FAR * prc</i>) is the bounding rectangle. The <b>int</b> <i>code</i> member of the <b>RECT</b> structure specifies the portion of the list item for which you want to get the bounding rectangle. This can be one of the values listed in Table 6 below. The code portion is specified in the <i>prc-&gt;left</i> member of the <b>RECT</b> structure.</p>
<p class=label>
<b>Table 6. List View Bounding Rectangle Options</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Option</b></td>
<td class=label width=73%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=27%>LVIR_BOUNDS</td>
<td width=73%>Get the bounding rectangle for the entire item, including the icon and the label.</td>
</tr>
<tr valign=top>
<td width=27%>LVIR_ICON</td>
<td width=73%>Get the bounding rectangle for the icon only.</td>
</tr>
<tr valign=top>
<td width=27%>LVIR_IMAGE</td>
<td width=73%>Get the bounding rectangle for the icon, but exclude the icon margin.</td>
</tr>
<tr valign=top>
<td width=27%>LVIR_LABEL</td>
<td width=73%>Get the bounding rectangle for the icon label.</td>
</tr>
<tr valign=top>
<td width=27%>LVIR_SELECTBOUNDS</td>
<td width=73%>Set the bounding rectangle to include the icon and the item text in the label such that when the user clicks within the rectangle, the item is selected.</td>
</tr>
</table><br>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_GetItemRect</b>(<i>hwndLV</i>, <i>i</i>, <i>prc</i>, <i>code</i>);</p>
<h4>LVM_GETITEMSTATE</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item
lParam = UINT mask;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ flag indicating which state flags to get
</code></pre>
<p>
<b>Description:</b> The LVM_GETITEMSTATE message gets the state of a list view item.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the item. <i>lParam</i> (<b>UINT</b> <i>mask</i>) specifies which state flags to get.</p>
<p>
<b>Return value:</b> The item's state flags, as described in Table 4, List View Item States, previously in this article.</p>
<p>
<b>Macro:</b> (<b>UINT</b>)<b>ListView_GetItemState</b>(<i>hwndLV</i>, <i>i</i>, <i>mask</i>);</p>
<h4>LVM_GETITEMTEXT</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item
lParam = (LV_ITEM FAR *)plvi;&nbsp;&nbsp;&nbsp;&nbsp; \\ structure that receives the text
</code></pre>
<p>
<b>Description:</b> The LVM_GETITEMTEXT message gets the item text of a list view item or subitem.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the item. <i>lParam</i> (<b>LV_ITEM</b> <i>FAR * plvi</i>) is the item structure. This structure should have the <i>iSubItem</i> member filled in (if you want to get the text for a subitem) and the maximum number of characters to get. You must fill in the following members of the <b>LV_ITEM</b> structure:
<ul type=disc>
<li>
<b>int</b> <i>iSubItem</i>: The index of the subitem.<br><br></li>
<li>
<b>LPSTR</b> <i>pszText</i>: The address of a buffer to receive the text.<br><br></li>
<li>
<b>int</b> <i>cchTextMax</i>: The maximum number of characters to get (in bytes).</li>
</ul>
<p>
<b>Return value:</b> The length of the item text.</p>
<p>
<b>Macro:</b> (<b>int</b>)<b>ListView_GetItemText</b>(<i>hwndLV</i>, <i>i</i>, <i>iSubItem</i>, <i>pszText</i>, <i>cchTextMax</i>);</p>
<h4>LVM_GETNEXTITEM</h4>
<pre><code>wParam = iStart;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of item to start at
lParam = UINT flags;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ relational flags
</code></pre>
<p>
<b>Description:</b> The LVM_GETNEXTITEM message searches for the next list view item starting from a specified item. If an item does not have all of the specified state flags set, the search continues with the next item.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>iStart</i>) is the index of the item to start at, or –1 to start from the beginning. In <i>lParam</i> (<b>UINT</b> <i>flags</i>), <i>flags</i> specify the geometric relation of the requested item to the specified item and the state of the requested item. The geometric relation can be one of the values listed in Table 7 below. Note that the first five flags are mutually exclusive but can be used in combination with any of the remaining flags.</p>
<p class=label>
<b>Table 7. List View Search Criteria</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Value</b></td>
<td class=label width=76%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=24%>LVNI_ALL</td>
<td width=76%>Search for a subsequent item based on the index. This is the default.</td>
</tr>
<tr valign=top>
<td width=24%>LVNI_ABOVE</td>
<td width=76%>Search for an item that is above the specified item.</td>
</tr>
<tr valign=top>
<td width=24%>LVNI_BELOW</td>
<td width=76%>Search for an item that is below the specified item.</td>
</tr>
<tr valign=top>
<td width=24%>LVNI_TORIGHT</td>
<td width=76%>Search for an item to the right of the specified item.</td>
</tr>
<tr valign=top>
<td width=24%>LVNI_TOLEFT</td>
<td width=76%>Search for an item to the left of the specified item.</td>
</tr>
<tr valign=top>
<td width=24%>LVNI_FOCUSED</td>
<td width=76%>Return focused items.</td>
</tr>
<tr valign=top>
<td width=24%>LVNI_SELECTED</td>
<td width=76%>Return selected items.</td>
</tr>
<tr valign=top>
<td width=24%>LVNI_CUT</td>
<td width=76%>Return marked items.</td>
</tr>
<tr valign=top>
<td width=24%>LVNI_HIDDEN</td>
<td width=76%>Return hidden items.</td>
</tr>
<tr valign=top>
<td width=24%>LVNI_DROPHILITED</td>
<td width=76%>Return the drop-highlighted items.</td>
</tr>
<tr valign=top>
<td width=24%>LVNI_PREVIOUS</td>
<td width=76%>Search backwards.</td>
</tr>
</table><br>
<p>
<b>Return value:</b> The index of the next item if successful; –1 otherwise.</p>
<p>
<b>Macro:</b> (<b>int</b>)<b>ListView_GetNextItem</b>(<i>hwndLV</i>, <i>iStart</i>, <i>flags</i>);</p>
<h4>LVM_GETORIGIN</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (POINT FAR *)ppt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ structure receiving origin values
</code></pre>
<p>
<b>Description:</b> The LVM_GETORIGIN message gets the list view origin, which is needed for setting the item position.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam </i>(<b>POINT</b> <i>FAR * ppt</i>) specifies a structure that receives the origin values.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_GetOrigin</b>(<i>hwndLV</i>, <i>ppt</i>);</p>
<h4>LVM_GETSTRINGWIDTH</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (LPCSTR)psz;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ the string
</code></pre>
<p>
<b>Description:</b> The LVM_GETSTRINGWIDTH message gets the minimum column width necessary to display the given string. The returned width takes the current font and column margins of the list view into account, but does not take the width of a small icon into account.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>LPCSTR</b> <i>psz</i>) specifies the string.</p>
<p>
<b>Return value:</b> The column width if successful; 0 otherwise.</p>
<p>
<b>Macro:</b> (<b>int</b>)<b>ListView_GetStringWidth</b>(<i>hwndLV</i>, <i>psz</i>);</p>
<h4>LVM_GETTEXTBKCOLOR</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_GETTEXTPKCOLOR message gets the background text color in a list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The background color of the text (<b>COLORREF</b>).</p>
<p>
<b>Macro:</b> (<b>COLORREF</b>)<b>ListView_GetTextBkColor</b>(<i>hwndLV</i>);</p>
<h4>LVM_GETTEXTCOLOR</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_GETTEXTCOLOR message gets the color of the text in a list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The text color (<b>COLORREF</b>).</p>
<p>
<b>Macro:</b> <b>(COLORREF)ListView_GetTextColor</b>(<i>hwndLV</i>);</p>
<h4>LVM_GETTOPINDEX</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_GETTOPINDEX message gets the index of the first visible item in the list view. </p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The index of the first visible item (<b>int </b><i>i</i>).</p>
<p>
<b>Macro:</b> (<b>int</b>)<b>ListView_GetTopIndex</b>(<i>hwndLV</i>, <i>ppt</i>);</p>
<h4>LVM_GETVIEWRECT</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = RECT FAR *prc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ bounding rectangle
</code></pre>
<p>
<b>Description:</b> The LVM_GETITEMSTATE message gets the bounding rectangle of all of the items in a list view in icon view.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>RECT</b> <i>FAR * prc</i>) is the bounding rectangle. All coordinates are in list view client window units.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_GetViewRect</b>(<i>hwndLV</i>, <i>prc</i>);</p>
<h4>LVM_HITTEST</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (LV_HITTESTINFO FAR *)pinfo;&nbsp; \\ position to hit test
</code></pre>
<p>
<b>Description:</b> The LVM_HITTEST message determines which list view item is at a specified position. </p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>LV_HITTESTINFO</b> <i>FAR * pinfo</i>) specifies the structure containing the position to hit test.</p>
<p>
<b>Return value:</b> The index of the item at the specified position; –1 otherwise.</p>
<p>
<b>Macro:</b> (<b>int</b>)<b>ListView_HitTest</b>(<i>hwndLV</i>, <i>pinfo</i>);</p>
<h4>LVM_INSERTCOLUMN</h4>
<pre><code>wParam = iCol;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the new column
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_INSERTCOLUMN message inserts a new column in a list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>iCol</i>) is the index of the new column. <i>lParam</i> (<b>const</b> <b>LV_COLUMN</b> <i>FAR * pcol</i>) specifies the structure containing column information.</p>
<p>
<b>Return value:</b> The index of the new column; –1 if an error occurred.</p>
<p>
<b>Macro:</b> (<b>int</b>)<b>ListView_InsertColumn</b>(<i>hwndLV</i>, <i>iCol</i>, <i>pcol</i>);</p>
<h4>LVM_INSERTITEM</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (const LV_ITEM FAR *)pitem;&nbsp; \\ new item information
</code></pre>
<p>
<b>Description:</b> The LVM_INSERTITEM message inserts a new item in a list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>const</b> <b>LV_ITEM</b> <i>FAR * pitem</i>) specifies the structure containing item information. The <i>iItem</i> member specifies the index of the new item. The <i>iSubItem</i> member must be zero; this message cannot be used to insert subitems.</p>
<p>
<b>Return value:</b> The index of the new item if successful; –1 otherwise.</p>
<p>
<b>Macro:</b> (<b>int</b>)<b>ListView_InsertItem</b>(<i>hwndLV</i>, <i>pitem</i>);</p>
<h4>LVM_REDRAWITEMS</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = MAKELONG(iFirst, iLast); \\ range of items to redraw
</code></pre>
<p>
<b>Description:</b> The LVM_REDRAWITEMS message forces a redraw of a range of list view items. The specified items are not actually repainted until the list view window receives a WM_PAINT message. To repaint immediately, call the <b>UpdateWindow</b> function after using this message.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. In <i>lParam</i> (<b>MAKELONG</b> <i>iFirst iLast</i>) the high-order word is <b>int</b> <i>iFirst</i>—the index of the first item in the range to redraw. The low-order word is <b>int</b> <i>iLast</i>—the index of the last item in the range to redraw.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_RedrawItems</b>(<i>hwndLV</i>, <i>iFirst</i>, <i>iLast</i>);</p>
<h4>LVM_SCROLL</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = MAKELONG(dx, dy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ horizontal and vertical scrolling
</code></pre>
<p>
<b>Description:</b> The LVM_SCROLL message scrolls the contents of a list view window. If the current view is report view, the <i>dx</i> parameter must be zero and the <i>dy</i> parameter is the number of lines to scroll. </p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. In <i>lParam</i> (<b>MAKELONG</b> <i>dx dy</i>), the high-order word is <b>int</b> <i>dx</i>—the amount of horizontal scrolling, in pixels. The low-order word is <b>int</b> <i>dy</i>—the amount of vertical scrolling, in pixels.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_Scroll</b>(<i>hwndLV</i>, <i>dx</i>, <i>dy</i>);</p>
<h4>LVM_SETBKCOLOR</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (COLORREF)clrBk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ background color to set
</code></pre>
<p>
<b>Description:</b> The LVM_SETBKCOLOR message sets the background color of the list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>COLORREF</b> <i>clrBk</i>) is the background color to set, or CLR_NONE for no background color. List views with background colors redraw themselves significantly faster than those without background colors.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_SetBkColor</b>(<i>hwndLV</i>, <i>clrBk</i>);</p>
<h4>LVM_SETCALLBACKMASK</h4>
<pre><code>wParam = UINT mask;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ callback mask
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_SETCALLBACKMASK message sets the callback mask for a list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>UINT</b> <i>mask</i>) is the new value of the callback mask. See Table 4, List View Item States, previously in this article for available masks. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_SetCallbackMask</b>(<i>lwndLV</i>, <i>mask</i>);</p>
<h4>LVM_SETCOLUMN</h4>
<pre><code>wParam = iCol;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the column
lParam = (LV_COLUMN FAR *)pcol;&nbsp;&nbsp; \\ structure containing column attributes
</code></pre>
<p>
<b>Description:</b> The LVM_SETCOLUMN message sets the attributes of a list view column.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>iCol</i>) is the index of the column. <i>lParam</i> (<b>LV_COLUMN</b> <i>FAR *pcol</i>) is the structure containing the new attributes. The <i>mask</i> member of the structure specifies which column attributes to set. If the <i>mask</i> member specifies the LVCF_TEXT flag, the <i>pszText</i> member is the address of a null-terminated string, and the <i>cchTextMax</i> is ignored.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_SetColumn</b>(<i>hwndLV</i>, <i>iCol</i>, <i>pcol</i>);</p>
<h4>LVM_SETCOLUMNWIDTH</h4>
<pre><code>wParam = iCol;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the column
lParam = cx;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ new width
</code></pre>
<p>
<b>Description:</b> The LVM_SETCOLUMNWIDTH message sets the width of a column in report view or list view.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>iCol</i>) is the index of the column. <i>lParam</i> (<b>int</b> <i>cx</i>) is the new width of the column.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_SetColumnWidth</b>(<i>hwndLV</i>, <i>iCol</i>, <i>cx</i>);</p>
<h4>LVM_SETIMAGELIST</h4>
<pre><code>wParam = iImageList;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ LVSIL_SMALL, LVSIL_NORMAL, or LVSIL_STATE
lParam = (HIMAGELIST) himl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the image list
</code></pre>
<p>
<b>Description:</b> The LVM_SETIMAGELIST message sets the image list used for drawing list view items.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>ImageList</i>) is LVSIL_SMALL for a small icons, LVSIL_NORMAL for standard icons, or LVSIL_STATE for a state image list. <i>lParam</i> (<b>HIMAGELIST</b> <i>himl</i>) is the handle to the image list.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_SetImageList</b>(<i>hwndLV</i>, <i>himl</i>, <i>iImageList</i>);</p>
<h4>LVM_SETITEM</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (const LV_ITEM FAR *)pitem;&nbsp; \\ new item attributes
</code></pre>
<p>
<b>Description:</b> The LVM_SETITEM message sets a list view item's attributes. </p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>const</b> <b>LV_ITEM</b> <i>FAR * pitem</i>) specifies the structure that contains the new item attributes.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_SetItem</b>(<i>hwndLV</i>, <i>pitem</i>);</p>
<h4>LVM_SETITEMCOUNT</h4>
<pre><code>wParam = cItems;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ count of the items
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_SETITEMCOUNT message sets the item count of a list view.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>cItems</i>) is the count of the items. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise. </p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_SetItemCount</b>(<i>hwndLV</i>, <i>cItems</i>);</p>
<h4>LVM_SETITEMPOSITION</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ item index
lParam = MAKELONG(x, y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ top-left corner of the new item
</code></pre>
<p>
<b>Description:</b> The LVM_SETITEMPOSITION message sets the position of a list view item in standard icon or small icon view relative to the list view rectangle.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the list view item. <i>lParam</i> (<b>int</b> <i>x y</i>) is the top-left corner of the new item in list view client coordinates. The high-order word is <i>x</i>, and the low-order word is <i>y</i>.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro: </b>(<b>BOOL</b>)<b>ListView_SetItemPosition</b>(<i>hwndLV</i>, <i>i x</i>, <i>y</i>);</p>
<h4>LVM_SETITEMSTATE</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item
lParam = (LV_ITEM FAR *)plvi;&nbsp;&nbsp;&nbsp;&nbsp; \\ new item state
</code></pre>
<p>
<b>Description:</b> The LVM_SETITEMSTATE message sets the state of a list view item. </p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the item. <i>lParam</i> (<b>LV_ITEM</b> <i>FAR * plvi</i>) specifies the two fields that need to be filled in, as follows:
<ul type=disc>
<li>
<b>lvi.state</b> (<b>UINT</b> <i>data</i>): The new state flags for the item.<br><br></li>
<li>
<b>liv.stateMask</b> (<b>UINT</b> <i>mask</i>): The mask, as described in Table 4, List View Item States, previously in this article.</li>
</ul>
<p>
<b>Return value: </b>TRUE if successful; FALSE otherwise. However, the message returns a VOID.</p>
<p>
<b>Macro:</b> (<b>VOID</b>)<b>ListView_SetItemState</b>(<i>hwndLV</i>, <i>I</i>, <i>data</i>, <i>mask</i>);</p>
<h4>LVM_SETITEMTEXT</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item
lParam = (LV_ITEM FAR *)plvi;&nbsp;&nbsp;&nbsp;&nbsp; \\ new item text
</code></pre>
<p>
<b>Description:</b> The LVM_SETITEMTEXT message sets the text of a list view item or subitem.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the item. <i>lParam</i> (<b>LV_ITEM</b> <i>FAR * plvi</i>) specifies the fields <b>lvi.iSubItem </b>and <b>lvi.pszText</b>. These fields should be filled in as follows:
<ul type=disc>
<li>
<b>int</b> <i>iSubItem</i>: The index of the subitem. This is zero if the item to set is not a subitem.<br><br></li>
<li>
<b>LPCSTR</b> <i>pszText</i>: The text of the item to set.</li>
</ul>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_SetItemText</b>(<i>hwndLV</i>, <i>I</i>, <i>iSubItem</i>, <i>pszText</i>);</p>
<h4>LVM_SETTEXTBKCOLOR</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (COLORREF)clrText;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ new background text color
</code></pre>
<p>
<b>Description:</b> The LVM_SETTEXTBKCOLOR message sets the background text color of a list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>COLORREF</b> <i>clrText</i>) is the new background text color.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_SetTextBkColor</b>(<i>hwndLV</i>, <i>clrText</i>);</p>
<h4>LVM_SETTEXTCOLOR</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (COLORREF)clrText;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ new text color
</code></pre>
<p>
<b>Description:</b> The LVM_SETTEXTCOLOR message sets the text color in a list view window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> (<b>COLORREF</b> <i>clrText</i>) is the new text color.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_SetTextColor</b>(<i>hwndLV</i>, <i>clrText</i>);</p>
<h4>LVM_SORTITEMS</h4>
<pre><code>wParam = (LPARAM)lParamSort;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ application-defined parameter
lParam = (PFNLVCOMPARE) pfnCompare;&nbsp;&nbsp; \\ sorting callback function
</code></pre>
<p>
<b>Description:</b> The LVM_SORTITEMS message sorts list view items using an application-defined comparison function. The index of each item changes to reflect the new sequence. The comparison function must return a negative value if the first item should precede the second, a positive value if the first item should follow the second, or zero if the two items are equivalent. The <i>lParam1</i> and<i> lParam2</i> parameters correspond to the <i>lParam</i> member of the <b>LV_ITEM</b> structure for the two items being compared. The <i>lParamSort</i> parameter is identical to the value passed to the <b>ListView_SortItems</b> macro.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>LPARAM</b> <i>lParamSort</i>) is the application-defined parameter that is passed to the comparison function. <i>lParam</i> (<b>PFNLVCOMPARE</b> <i>pfnCompare</i>) is a callback function that does the comparison. The comparison function has the following form:</p>
<p>
<b>int</b> <b>CALLBACK</b> <b>CompareFunc</b>(<b>LPARAM</b> <i>lParam1</i>, <b>LPARAM</b> <i>lParam2</i>, <b>LPARAM</b> <i>lParamSort</i>);</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_SortItems</b>(<i>hwndLV</i>, <i>pfnCompare</i>, <i>lParamSort</i>); </p>
<h4>LVM_UPDATE</h4>
<pre><code>wParam = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The LVM_UPDATE message updates a list view item. If the list view has the LVS_AUTOARRANGE style, the list view will be arranged.</p>
<p>
<b>Parameters:</b> <i>wParam</i> (<b>int</b> <i>i</i>) is the index of the item to update. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<p>
<b>Macro:</b> (<b>BOOL</b>)<b>ListView_Update</b>(<i>hwndLV</i>, <i>i</i>);</p>
<h3>List View Structures</h3>
<p>
The following structures are used with the macros described in the previous section and with the notifications described in the next section. You will notice that most of these structures use masks heavily to determine the valid members of the structure. You will also notice that some masks can be used with more than one structure.</p>
<h4>LV_COLUMN</h4>
<pre><code>typedef struct _LV_COLUMN {
 &nbsp;&nbsp; UINT mask;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ specifies which members are valid
 &nbsp;&nbsp; int fmt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ format of the column
 &nbsp;&nbsp; int cx;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ width of the column in pixels
 &nbsp;&nbsp; LPSTR pszText;&nbsp;&nbsp;&nbsp; \\ column heading text
 &nbsp;&nbsp; int cchTextMax;&nbsp;&nbsp; \\ size of text buffer
 &nbsp;&nbsp; int iSubItem;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the subitem associated with the column
} LV_COLUMN;
</code></pre>
<p>
The <b>LV_COLUMN</b> structure contains information about a column in report view. It can also be used to receive information about a column. This structure is used with the <b>ListView_GetColumn</b>, <b>ListView_SetColumn</b>, <b>ListView_InsertColumn</b>, and <b>ListView_DeleteColumn</b> macros. The <b>LV_COLUMN</b> structure includes the following members:
<ul type=disc>
<li>
<b>UINT</b> <i>mask</i>: A value that specifies which members are valid. This can be one of the values listed in Table 8 below.<br><br></li>
<li>
<b>int</b> <i>fmt</i>: Alignment of the column. This can be one of three values: LVCFMT_LEFT, LVCFMT_RIGHT, or LVCFMT_CENTER.<br><br></li>
<li>
<b>int</b> <i>cx</i>: The width of the column in pixels.<br><br></li>
<li>
<b>LPSTR</b> <i>pszText</i>: Address of a null-terminated string containing the column heading, if the structure contains information about a column. If the structure is receiving information about a column, this member specifies the address of the buffer to receive the column heading.<br><br></li>
<li>
<b>int</b> <i>cchTextMax</i>: Size of the buffer that the <i>pszText</i> member points to. This member is ignored if the structure is not receiving information about a column.<br><br></li>
<li>
<b>int</b> <i>iSubItem</i>: The index of the subitem associated with the column.</li>
</ul>
<p class=label>
<b>Table 8. List View Column Format Masks</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Value</b></td>
<td class=label width=73%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=27%>LVCF_ALL</td>
<td width=73%>All members of the structure are valid.</td>
</tr>
<tr valign=top>
<td width=27%>LVCT_FMT</td>
<td width=73%>The .<i>fmt</i> member of the structure is valid.</td>
</tr>
<tr valign=top>
<td width=27%>LVCF_WIDTH</td>
<td width=73%>The .<i>cx</i> member of the structure is valid.</td>
</tr>
<tr valign=top>
<td width=27%>LVCF_TEXT</td>
<td width=73%>The .<i>pszText</i> member of the structure is valid.</td>
</tr>
<tr valign=top>
<td width=27%>LVCF_SUBITEM</td>
<td width=73%>The .<i>iSubItem</i> member of the structure is valid.</td>
</tr>
</table><br>
<h4>LV_DISPINFO</h4>
<pre><code>typedef struct _LV_DISPINFO {
 &nbsp;&nbsp; NMHDR hdr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ common control notification structure
 &nbsp;&nbsp; LV_ITEM item;&nbsp;&nbsp;&nbsp;&nbsp; \\ list view item
} LV_DISPINFO;
</code></pre>
<p>
The <b>LV_DISPINFO</b> structure is used with the LVN_GETDISPINFO and LVN_SETDISPINFO notifications to get and set information about a list view item. These notifications are sent only if the parent window is responsible for maintaining certain information. The <b>LV_DISPINFO</b> structure includes the following members:
<ul type=disc>
<li>
<b>NMHDR</b> <i>hdr</i>: A WM_NOTIFY message header.<br><br></li>
<li>
<b>LV_ITEM</b> <i>item</i>: A list view item (as described later in this section).</li>
</ul>
<h4>LV_DRAGITEMINFO</h4>
<pre><code>typedef struct _LV_DRAGITEMINFO {
 &nbsp;&nbsp; HWND hwndRoot;&nbsp;&nbsp;&nbsp; \\ handle of the drag root window
 &nbsp;&nbsp; HWND hwndFrom;&nbsp;&nbsp;&nbsp; \\ handle of the drag source window
 &nbsp;&nbsp; UINT fmt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ format of the drag data
 &nbsp;&nbsp; LPARAM lParam;&nbsp;&nbsp;&nbsp; \\ application-defined data
 &nbsp;&nbsp; POINT ptOffset;&nbsp;&nbsp; \\ screen coordinates of where drag began
} LV_DRAGITEMINFO;
</code></pre>
<p>
The <b>LV_DRAGITEMINFO</b> structure contains information about the item being dragged. This structure is used with the <b>ListView_DragItem</b> macro. The <b>LV_DRAGITEMINFO</b> structure includes the following members:
<ul type=disc>
<li>
<b>HWND</b> <i>hwndRoot</i>: Handle of the window that is the root of the drag operation.<br><br></li>
<li>
<b>HWND</b> <i>hwndFrom</i>: Handle of the window that is the source of the drag operation. This window will receive the drag notification messages.<br><br></li>
<li>
<b>UINT</b> <i>fmt</i>: The format of the drag data.<br><br></li>
<li>
<b>LPARAM</b> <i>lParam</i>: A value to send with drag notifications.<br><br></li>
<li>
<b>POINT</b> <i>ptOffset</i>: The screen coordinates of the point where the drag began.</li>
</ul>
<h4>LV_FINDINFO</h4>
<pre><code>typedef struct _LV_FINDINFO {
 &nbsp;&nbsp; UINT flags;&nbsp;&nbsp;&nbsp;&nbsp; \\ type of search to perform
 &nbsp;&nbsp; LPCSTR psz;&nbsp;&nbsp;&nbsp;&nbsp; \\ string to compare with
 &nbsp;&nbsp; LPARAM lParam;&nbsp; \\ value to compare with LV_ITEM's lParam member
} LV_FINDINFO;
</code></pre>
<p>
The <b>LV_FINDINFO</b> structure contains information used to search for a list view item. This structure is used with the <b>ListView_FindItem</b> macro. The <b>LV_FINDINFO</b> structure includes the following members:
<ul type=disc>
<li>
<b>UINT</b> <i>flags</i>: The type of search to perform. These flags can be a combination of the values listed in Table 9 below.<br><br></li>
<li>
<b>LPCSTR</b> <i>psz</i>: A null-terminated string to compare with item text if the LVFI_STRING, LVFI_SUBSTRING, or LVFI_PARTIAL flag is specified.<br><br></li>
<li>
<b>LPARAM</b> <i>lParam</i>: Value to compare with the <i>lParam</i> member of a list view item's <b>LV_ITEM</b> structure if the LVFI_PARAM flag is specified.</li>
</ul>
<p class=label>
<b>Table 9. List View Find Flags</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Flag</b></td>
<td class=label width=79%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=21%>LVFI_PARAM</td>
<td width=79%>Searches based on the <i>lParam</i> member. The <i>lParam</i> member of the matching item's <b>LV_ITEM</b> structure must match the <i>lParam</i> member of this structure. If this flag is specified, all other flags are ignored.</td>
</tr>
<tr valign=top>
<td width=21%>LVFI_STRING</td>
<td width=79%>Searches based on item text. Unless additional flags are specified, the item text of the matching item must exactly match the string that the <i>psz</i> member points to.</td>
</tr>
<tr valign=top>
<td width=21%>LVFI_SUBSTRING</td>
<td width=79%>Matches if the string the <i>psz</i> member points to is contained anywhere in the item text. This flag cannot be used with LVFI_PARTIAL. This flag implies LVFI_STRING.</td>
</tr>
<tr valign=top>
<td width=21%>LVFI _PARTIAL</td>
<td width=79%>Matches if the item text begins with the string that the <i>psz</i> member points to. This flag implies LVFI_STRING.</td>
</tr>
<tr valign=top>
<td width=21%>LVFI_NOCASE</td>
<td width=79%>Ignores case in string comparisons. This flag is ignored if LVFI_STRING is not specified.</td>
</tr>
</table><br>
<h4>LV_HITTESTINFO</h4>
<pre><code>typedef struct _LV_HITTESTINFO {
 &nbsp;&nbsp; POINT pt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ position to hit test
 &nbsp;&nbsp; UINT flags;&nbsp;&nbsp;&nbsp; \\ receives results of hit test
} LV_HITTESTINFO;
</code></pre>
<p>
The <b>LV_HITTESTINFO</b> structure contains information about a hit test. This structure is used with the <b>ListView_HitTest</b> macro. The structure includes the following members:
<ul type=disc>
<li>
<b>POINT</b> <i>pt</i>: The position to hit test in client coordinates.<br><br></li>
<li>
<b>UINT</b> <i>flags</i>: This member receives the results of the hit test. This value can be one or more of the values listed in Table 10 below. When the position is outside the list view's client area, the flag will be LVHT_ABOVE, LVHT_BELOW, LVHT_TORIGHT, or LVHT_TOLEFT. Two of these flags can be combined, for example, if the position is above and to the left of the client area. These flags are useful for scrolling.</li>
</ul>
<p class=label>
<b>Table 10. List View Hit Test Flags</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Flag</b></td>
<td class=label width=76%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=24%>LVHT_NOWHERE</td>
<td width=76%>The position is inside the list view's client window but not over a list item.</td>
</tr>
<tr valign=top>
<td width=24%>LVHT_ONITEMICON</td>
<td width=76%>The position is over a list item's icon.</td>
</tr>
<tr valign=top>
<td width=24%>LVHT_ONITEMLABEL</td>
<td width=76%>The position is over a list item's text.</td>
</tr>
<tr valign=top>
<td width=24%>LVHT_ONITEM</td>
<td width=76%>The position is on an item. This is a combination of LVHT_ONEITEMICON and LVHT_ONITEMLABEL.</td>
</tr>
<tr valign=top>
<td width=24%>LVHT_ABOVE</td>
<td width=76%>The position is above the list view's client area.</td>
</tr>
<tr valign=top>
<td width=24%>LVHT_BELOW</td>
<td width=76%>The position is below the list view's client area.</td>
</tr>
<tr valign=top>
<td width=24%>LVHT_TORIGHT</td>
<td width=76%>The position is to the right of the list view's client area.</td>
</tr>
<tr valign=top>
<td width=24%>LVHT_TOLEFT</td>
<td width=76%>The position is to the left of the list view's client area.</td>
</tr>
</table><br>
<h4>LV_ITEM</h4>
<pre><code>typedef struct _LV_ITEM {
 &nbsp;&nbsp; UINT mask;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ mask specifying which members are valid
 &nbsp;&nbsp; int iItem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the item
 &nbsp;&nbsp; int iSubItem;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the subitem
 &nbsp;&nbsp; UINT state;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ item state
 &nbsp;&nbsp; UINT stateMask;&nbsp;&nbsp; \\ state of item
 &nbsp;&nbsp; LPSTR pszText;&nbsp;&nbsp;&nbsp; \\ item text
 &nbsp;&nbsp; int cchText;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ size of text buffer
 &nbsp;&nbsp; int iImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the icon image in the image list
 &nbsp;&nbsp; LPARAM lParam;&nbsp;&nbsp;&nbsp; \\ application-defined item data
} LV_ITEM;
</code></pre>
<p>
The <b>LV_ITEM</b> structure contains the attributes of a list view item. This structure is used by a number of macros (all of which send messages), including <b>ListView_GetItem</b>, <b>ListView_SetItem</b>, <b>ListView_InsertItem</b>, and <b>ListView_DeleteItem</b>. The <b>LV_ITEM</b> structure includes the following members:
<ul type=disc>
<li>
<b>UINT</b> <i>mask</i>: The value that specifies which members of the structure are valid. This mask can be a combination of the values listed in Table 11 below.<br><br></li>
<li>
<b>int</b> <i>iItem</i>: The item that this structure refers to.<br><br></li>
<li>
<b>int</b> <i>iSubItem</i>: The subitem that this item refers to, or zero if this is not a subitem.<br><br></li>
<li>
<b>UINT</b> <i>state</i>: The current item state, using the valid LVIS_* list view style flags.<br><br></li>
<li>
<b>UINT</b> <i>stateMask</i>: The possible item state flags, using the valid LVIS_* list view style flags.<br><br></li>
<li>
<b>LPSTR</b> <i>pszText</i>: Address of a null-terminated string containing the item text, if the structure specifies item attributes. If this member is LPSTR_TEXTCALLBACK, the parent window is responsible for storing the name. In this case, the list view sends the parent window an LVN_GETDISPINFO notification when it needs the item text for displaying, sorting, or editing, and an LVN_SETDISPINFO notification when the item text changes. If the structure is receiving item attributes, this member is the address of the buffer to receive the item text.<br><br></li>
<li>
<b>int</b> <i>cchText</i>: Size of the buffer that the <i>pszText</i> member points to, if the structure is receiving item attributes. This member is ignored if the structure specifies item attributes.<br><br></li>
<li>
<b>int</b> <i>iImage</i>: Index of the icon image in its image list.<br><br></li>
<li>
<b>LPARAM</b> <i>lParam</i>: A 32-bit value to associate with the item.</li>
</ul>
<p class=label>
<b>Table 11. List View Item Masks</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=28%><b>Value</b></td>
<td class=label width=72%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=28%>LVIF_TEXT</td>
<td width=72%>The <i>pszText</i> member is valid.</td>
</tr>
<tr valign=top>
<td width=28%>LVIF_IMAGE</td>
<td width=72%>The <i>iImage</i> member is valid.</td>
</tr>
<tr valign=top>
<td width=28%>LVIF_PARAM</td>
<td width=72%>The <i>lParam</i> member is valid.</td>
</tr>
<tr valign=top>
<td width=28%>LVIF_STATE</td>
<td width=72%>The <i>state</i> member is valid.</td>
</tr>
</table><br>
<h4>LV_KEYDOWN</h4>
<pre><code>typedef struct _LV_KEYDOWN {
 &nbsp;&nbsp; NMHDR hdr;&nbsp;&nbsp;&nbsp;&nbsp; \\ common control notification structure
 &nbsp;&nbsp; WORD wVKey;&nbsp;&nbsp;&nbsp; \\ virtual key code
 &nbsp;&nbsp; UINT flags;&nbsp;&nbsp;&nbsp; \\ always zero
} LV_KEYDOWN;
</code></pre>
<p>
The <b>LV_KEYDOWN</b> structure contains information about a keyboard event in a list view window. This structure is used with the LVN_KEYDOWN notification. The structure includes the following members:
<ul type=disc>
<li>
<b>NMHDR</b> <i>hdr</i>: The WM_NOTFY structure.<br><br></li>
<li>
<b>WORD</b> <i>wVKey</i>: The virtual key code.<br><br></li>
<li>
<b>UINT</b> <i>flags</i>: Always zero.</li>
</ul>
<h4>NM_LISTVIEW</h4>
<pre><code>typedef struct _NM_LISTVIEW {
 &nbsp;&nbsp; NMHDR hdr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ common control notification structure
 &nbsp;&nbsp; int iItem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ the list view item
 &nbsp;&nbsp; int iSubItem;&nbsp;&nbsp;&nbsp; \\ the subitem
 &nbsp;&nbsp; UINT uNewState;&nbsp; \\ new item state
 &nbsp;&nbsp; UINT uOldState;&nbsp; \\ old item state
 &nbsp;&nbsp; UINT uChanged;&nbsp;&nbsp; \\ which item attribute changed
 &nbsp;&nbsp; POINT ptAction;&nbsp; \\ location where the event occurred
} NM_LISTVIEW;
</code></pre>
<p>
The <b>NM_LISTVIEW</b> structure contains information about a list view notification. The address of this structure is specified as the <i>lParam</i> parameter of the WM_NOTIFY message for several list view notifications. The structure includes the following members:
<ul type=disc>
<li>
<b>NMHDR</b> <i>hdr</i>: Header information that is used with all WM_NOTIFY messages. The <b>NMHDR</b> structure is described in the <a href="msdn_commctl1.htm">"Win32 Common Controls, Part 1: The Basics"</a> article in this series.<br><br></li>
<li>
<b>int</b> <i>iItem</i>: The list view item.<br><br></li>
<li>
<b>int</b> <i>iSubItem</i>: The subitem.<br><br></li>
<li>
<b>UINT</b> <i>uNewState</i>, <i>uOldState</i>: New and old item states. Both members are zero for notifications that do not use them. The value specified can be a combination of the values listed in Table 3, List View Window Styles, previously in this article.<br><br></li>
<li>
<b>UINT</b> <i>uChanged</i>: Value that specifies which item attributes changed. This member is zero for notifications that do not use it. The value specified is a combination of the values listed in Table 11, List View Item Masks, above.<br><br></li>
<li>
<b>POINT</b> <i>ptAction</i>: The location where the event occurred. This flag is valid only for the LVN_BEGINDRAG and LVN_BEGINRDRAG notifications.</li>
</ul>
<h3>List View Notification Messages</h3>
<p>
Oh dear, yet another list. I promise that this is the last one (in this article). Feel free to skip this section if you are sick of reading lists. The following table lists the notification messages that Windows sends to list view windows. All of these notifications are sent via a WM_NOTIFY message to the list view window's parent window. </p>
<p class=label>
<b>Table 12. List View Notification Messages</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Message</b></td>
<td class=label width=73%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=27%>LVN_BEGINDRAG</td>
<td width=73%>Sent when the user begins a drag-and-drop operation involving the left mouse button.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_BEGINLABELEDIT</td>
<td width=73%>Sent when the user begins to edit the label of an item.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_BEGINRDRAG</td>
<td width=73%>Sent when the user begins a drag-and-drop operation involving the right mouse button.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_COLUMNCLICK</td>
<td width=73%>Sent when the user clicks a column.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_DELETEALLITEMS</td>
<td width=73%>Sent when all items in the list view are deleted.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_DELETEITEM</td>
<td width=73%>Sent when an item is deleted.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_ENDDRAG</td>
<td width=73%>Sent when default processing for a drag-and-drop operation involving the left mouse button has ended.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_ENDLABELEDIT</td>
<td width=73%>Sent when the user finishes editing the label of an item.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_ENDRDRAG</td>
<td width=73%>Sent when default processing for a drag-and-drop operation involving the right mouse button has ended.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_GETDISPINFO</td>
<td width=73%>Requests that a list view's parent window provide information for displaying or sorting an item.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_INSERTITEM</td>
<td width=73%>Sent when a new item is inserted.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_ITEMCHANGED</td>
<td width=73%>Sent when an item has changed.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_ITEMCHANGING</td>
<td width=73%>Sent when an item is changing. Returning FALSE for this notification will disallow the change.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_KEYDOWN</td>
<td width=73%>Sent when a key has been pressed.</td>
</tr>
<tr valign=top>
<td width=27%>LVN_SETDISPINFO</td>
<td width=73%>Sent when the parent window must update the information it maintains for an item.</td>
</tr>
</table><br>
<h2>Summary</h2>
<p>
Now you know how to create and use the new list view and column header windows that are built into Windows 95. These two new windows will really help you give your application the same look as the Windows 95 shell. So, find some areas in your application that would benefit from this new look, and use the code that I have given you to add this functionality to your application. Be the first one on your block to adopt the visual appeal of the new shell, and sneer at those who stick to the old method of displaying information.</p>
<p>
I am really excited about my next article, which covers image lists and the new tree view window. Finally, we are giving you the ability to create a hierarchical tree that is built into the system. It's about time. The article is called <a href="msdn_commctl5.htm">"Win32 Common Controls, Part 5: Image Lists and Tree View Windows."</a></p>
</BODY>
</HTML>
