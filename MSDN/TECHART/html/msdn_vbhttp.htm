<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Win32 Internet HTTP Functions in Visual Basic</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_vbhttp"></a></sup>Win32 Internet HTTP Functions in Visual Basic</h1>
<p>
James Braum<br>
Microsoft Developer Network Technology Group</p>
<p>
September 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5007">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the VBHTTP sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
Visual Basic® lets you leverage the power of the Microsoft® Win32® Internet (WinInet for short) Software Development Kit (SDK) in a number of useful ways. The WinInet general Internet functions allow you to easily read files from the Internet. This article is a successor to <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_vbnetget">
</object><a href=JavaScript:alink_1.Click()>"Visual Basic and the WinInet SDK,"</a> which shows you the basics of these general functions. This technical article lets you dig a little deeper into the WinInet bag of tricks, showing you HTTP functions that will allow to do such things as determine a file size before reading it, examine and modify HTTP request headers, and look at HTTP response headers. A sample Visual Basic application (called VBHTTP) shows request and response headers that are exchanged between a client and an HTTP server during a transaction. You can do exciting things with WinInet, so I encourage you to read on for some ideas and examples of what can be done.</p>
<h2>Introduction</h2>
<p>
The Microsoft Win32 Internet (WinInet) application programming interface (API) allows you to quickly create Internet-aware applications using a wealth of functions for working with HTTP, FTP, and Gopher protocols. Without the API, you would be overwhelmed with having to know the specifics of HTTP, TCP/IP, FTP, Windows® Sockets, and so on. Fortunately, the WinInet API makes life significantly easier. With Visual Basic, you can use the functionality that WinInet exposes in a number of useful ways. This article sheds some light on HTTP request and response headers, and how you can use them. A small sample (VBHTTP) illustrates the headers and shows how you can use this information to customize your HTTP server requests.</p>
<p>
The WinInet API also provides FTP and Gopher functions; however, the WinInet SDK documentation indicates that these functions are best suited to asynchronous use, and Visual Basic requires third-party tools to use asynchronous functions and callbacks. Therefore, this article focuses on HTTP functions, which can safely be called synchronously. (For a look at how you would use the FTP functions asynchronously using Visual C++®, please refer to Robert Coleridge's article titled <a href="msdn_advftp.htm">"Advanced FTP: Teaching Fido to Phetch."</a></p>
<p>
This article begins with some background on the Hypertext Transfer Protocol (HTTP) and moves into HTTP specifics and the use of request and response headers. </p>
<h2>HTTP Primer</h2>
<h3>What Is HTTP?</h3>
<p>
The Hypertext Transfer Protocol (HTTP) has been in use since 1990. HTTP is an application-level protocol that is fast and non–resource-intensive. It is the protocol used to transmit Hypertext Markup Language (HTML) files. It can be considered a generic protocol that can be used in a variety of ways.</p>
<p>
This article is concerned with HTTP version 1.0, which is in common use today. The next version of HTTP, referred to as HTTP/1.1, is currently being developed by the World Wide Web Consortium (W3C) and the HTTP working group of the Internet Engineering Task Force (IETF). Their Web site at <a href="http://www.w3.org/">http://www.w3.org/</a> contains current drafts of specifications and more information about HTTP.</p>
<p>
HTTP uses a request-and-response model to transfer information. In a simple case, the user agent (client application) sends a request to the server. The server responds with a message that contains a success or failure code, protocol version, server information, and body content, depending on the request. The user agent can modify the request to provide greater control over the server. The section of this article titled "WinInet HTTP Functions" looks at a WinInet function that will allow us to make such modifications.</p>
<h3>HTTP Servers</h3>
<p>
The WinInet HTTP functions work with HTTP servers that recognize requests in HTTP/1.0. HTTP servers can actually be less complex than a typical user agent because they have an easier job: they just respond to requests. The client, on the other hand, must process the information that it has received in response to a request. In the case of an HTML file, this involves a significant amount of processing. To display an HTML page, for example, multiple threads may be spawned to simultaneously load and display inline .GIF and .JPG files.</p>
<h3>HTTP Clients</h3>
<p>
WinInet is useful for creating HTTP clients. (The client is the application that sends a request to a server.) You can build your own Web browser, create Web-traversing robots, or write your own Internet-aware application for solving some particular problem.</p>
<h3>Request Headers</h3>
<p>
Request headers are sent to the server as part of a request message. You can modify them to develop client applications that have detailed control over the server. If your client application needs caching capabilities, security, and so forth, you can append or modify request headers to do this.</p>
<p>
Commonly used HTTP/1.0 request headers are:
<ul type=disc>
<li>
Authorization <br><br></li>
<li>
From<br><br></li>
<li>
If-Modified-Since<br><br></li>
<li>
User-Agent</li>
</ul>
<p>
Refer to the Internet Draft (http://www.w3.org/pub/WWW/Protocols/HTTP/1.0/spec.txt), published by the Internet Engineering Task Force in August 1996, for detailed descriptions of request headers.</p>
<h3>Response Messages and Headers</h3>
<p>
HTTP servers respond to client requests in the form of a response message. This message contains a status line, response headers, and entity-header meta-information about the resource (that is, information about the resource itself, not about the information that is contained in the resource) identified in the request message sent by the client. The status line contains the HTTP version number, a status code, and a reason phrase. For instance, "HTTP/1.0 200 OK" is a typical status line returned in a response message from an HTTP server. Table 1 contains status codes and reason phrases.</p>
<p class=label>
<b>Table 1. Status Codes and Their Meaning</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=39%><b>Status Code</b></td>
<td class=label width=61%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=39%>200</td>
<td width=61%>OK</td>
</tr>
<tr valign=top>
<td width=39%>201</td>
<td width=61%>Created</td>
</tr>
<tr valign=top>
<td width=39%>202</td>
<td width=61%>Accepted</td>
</tr>
<tr valign=top>
<td width=39%>204</td>
<td width=61%>No Content</td>
</tr>
<tr valign=top>
<td width=39%>301</td>
<td width=61%>Moved Permanently</td>
</tr>
<tr valign=top>
<td width=39%>302</td>
<td width=61%>Moved Temporarily</td>
</tr>
<tr valign=top>
<td width=39%>304</td>
<td width=61%>Not Modified</td>
</tr>
<tr valign=top>
<td width=39%>400</td>
<td width=61%>Bad Request</td>
</tr>
<tr valign=top>
<td width=39%>401</td>
<td width=61%>Unauthorized</td>
</tr>
<tr valign=top>
<td width=39%>403</td>
<td width=61%>Forbidden</td>
</tr>
<tr valign=top>
<td width=39%>404</td>
<td width=61%>Not Found</td>
</tr>
<tr valign=top>
<td width=39%>500</td>
<td width=61%>Internal Server Error</td>
</tr>
<tr valign=top>
<td width=39%>501</td>
<td width=61%>Not Implemented</td>
</tr>
<tr valign=top>
<td width=39%>502</td>
<td width=61%>Bad Gateway</td>
</tr>
<tr valign=top>
<td width=39%>503</td>
<td width=61%>Service Unavailable</td>
</tr>
</table><br>
<p>
Two common response headers are:
<ul type=disc>
<li>
Location<br><br></li>
<li>
Server</li>
</ul>
<p>
Entity-header fields that contain meta-information about the file (resource) specified in the request are also returned with the response message. Common entity-header fields are:
<ul type=disc>
<li>
Allow<br><br></li>
<li>
Content-Encoding<br><br></li>
<li>
Content-Length<br><br></li>
<li>
Content-Type<br><br></li>
<li>
Expires<br><br></li>
<li>
Last-Modified</li>
</ul>
<p>
The VBHTTP sample application groups the entity-header fields under the "Response Headers" tab to make it clearer to read. Instead of differentiating between response headers and entity-header fields, you can think in terms of headers returned in response to a request. This oversimplifies the issue somewhat, but this article is concerned with making things easy.</p>
<p>
OK, enough background theory. Let's look at some actual Visual Basic code that lets us both view and modify our requests.</p>
<h2>WinInet HTTP Functions</h2>
<p>
We will dive in with some sample code that requests a page, then looks at the content length of that page:</p>
<pre><code>Dim hInternetSession&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Long
Dim hInternetConnect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Long
Dim hHttpOpenRequest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Long
Dim sBuffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As String * 1024
Dim lBufferLength&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Long
lBufferLength = Len(sBuffer)
hInternetSession = InternetOpen(scUserAgent, _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0)
hInternetConnect = InternetConnect(hInternetSession, _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "www.microsoft.com", INTERNET_DEFAULT_HTTP_PORT, _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbNullString, vbNullString, INTERNET_SERVICE_HTTP, 0, 0)
hHttpOpenRequest = HttpOpenRequest(hInternetConnect, "GET", _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbNullString,"HTTP/1.0", vbNullString, 0, _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_FLAG_RELOAD, 0)
HttpSendRequest hHttpOpenRequest, vbNullString, 0, 0, 0
HttpQueryInfo hHttpOpenRequest, HTTP_QUERY_CONTENT_LENGTH, _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal sBuffer, lBufferLength, 0
Debug.Print sBuffer
InternetCloseHandle (hInternetSession)
</code></pre>
<p>
It doesn't take much code to examine the HTTP response headers before taking further action in your code. This example opens "www.microsoft.com" using the access parameters contained in the registry, then sends a request to retrieve the file. After sending the request, we examine the response from the server. The buffer contains the length of the file. (To keep things clear, the code does not check for errors.) Not all servers will provide file length for you. After examining the response header for content length, you can decide if you want to retrieve the file, using the <b>InternetReadFile</b> function.</p>
<p>
Notice that there is only one call to <b>InternetCloseHandle</b>. This function allows you to close entire handle subtrees. Closing the root handle will close all subsequent handles you may have opened up.</p>
<p>
This is the type of functionality that the WinInet HTTP functions provide that you can't get with the Internet functions. You will still use some Internet functions to open the connection and actually read the file.</p>
<p>
The following sections examine these WinInet functions: <b>InternetOpen</b>, <b>InternetConnect</b>, <b>HttpOpenRequest</b>, <b>HttpAddRequestHeaders</b>, <b>HttpSendRequest</b>, <b>HttpQueryInfo</b>, <b>InternetReadFile</b>, and <b>InternetCloseHandle</b>.</p>
<h3>InternetOpen</h3>
<p>
<b>InternetOpen</b> initializes our application's use of WinInet functions. A long handle is returned. Below are the two constants you can use to call the function, as well as the declaration you will need:</p>
<pre><code>Public Const scUserAgent = "my wininet app"
Public Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Public Declare Function InternetOpen Lib "wininet.dll" Alias _ 
 &nbsp; "InternetOpenA" (ByVal sAgent As String, ByVal lAccessType _ 
 &nbsp; As Long, ByVal sProxyName As String, ByVal sProxyBypass As _ 
 &nbsp; String, ByVal lFlags As Long) As Long
</code></pre>
<p>
The Win32 Internet functions do not currently provide support for Unicode. However, support will be provided in future versions. Therefore, all the functions are aliased to call the ANSI version.</p>
<h3>InternetConnect</h3>
<p>
<b>InternetConnect</b> returns a handle to an HTTP session. The two constants tell the function to listen on port 80, the default port that HTTP servers listen to, before establishing the connection. Here are the declaration and two constants that you will need:</p>
<pre><code>Public Declare Function InternetConnect Lib "wininet.dll" Alias _
 &nbsp; "InternetConnectA" (ByVal&nbsp; InternetSession As Long, _
 &nbsp; ByVal sServerName As String, ByVal nServerPort As Integer, _
 &nbsp; ByVal sUsername As String, ByVal sPassword As String, _
 &nbsp; ByVal lService As Long, ByVal lFlags As Long, _ 
 &nbsp; ByVal lContext As Long) As Long
Public Const INTERNET_DEFAULT_HTTP_PORT = 80
Public Const INTERNET_SERVICE_HTTP = 3
</code></pre>
<h3>HttpOpenRequest</h3>
<p>
<b>HttpOpenRequest</b> returns an HTTP request handle. Here are the declaration and a constant you will need:</p>
<pre><code>Public Declare Function HttpOpenRequest Lib "wininet.dll" Alias _ 
 &nbsp;&nbsp;&nbsp;&nbsp; "HttpOpenRequestA" (ByVal hHttpSession As Long, ByVal sVerb As _ 
 &nbsp;&nbsp;&nbsp;&nbsp; String, ByVal sObjectName As String, ByVal sVersion As String, _ 
 &nbsp;&nbsp;&nbsp;&nbsp; ByVal sReferer As String, ByVal something As Long, ByVal lFlags _ 
 &nbsp;&nbsp;&nbsp;&nbsp; As Long, ByVal lContext As Long) As Long
Public Const INTERNET_FLAG_RELOAD = &amp;H80000000
</code></pre>
<p>
<b>HttpOpenRequest</b> takes eight parameters (described below) and returns the HTTP request handle, if successful. The handle holds the request until you send it with <b>HttpSendRequest</b>, which stores the HTTP headers to be sent as part of the request. 
<ul type=disc>
<li>
<i>hHttpSession</i> is the handle returned from a previous call to <b>InternetConnect</b>.<br><br></li>
<li>
<i>sVerb</i> is a string that contains a method, or verb, to use for the request. Two common HTTP 1.0 verbs (methods) are GET and POST. These verbs are case-sensitive. GET retrieves a file. POST tells the server to accept some information that you are passing to it—for example, when you are submitting a response to a form. If the <i>sVerb</i> parameter is NULL, GET will be used.</li>
</ul>
<p>
If the <b>If-Modified-Since</b> header field is used, the GET becomes a conditional get. It will only retrieve the file if the file has been modified since a particular date specified in the header field. You can structure your requests to only retrieve the file if it has been changed since some predetermined point in time. An example of this will be illustrated below.
<ul type=disc>
<li>
<i>sObjectName</i> is the object we are interested in. This is usually a file, but it can also be a search specifier or an executable.<br><br></li>
<li>
<i>sVersion</i> is the HTTP version. Leaving this NULL is equivalent to specifying HTTP/1.0.<br><br></li>
<li>
<i>sReferer</i> is a string that contains a URL of a document containing a URL in the <i>sObjectName</i>. This parameter can be left NULL to specify no "referer" [sic].<br><br></li>
<li>
<i>sAcceptTypes</i> is a string containing a list of valid acceptance types. Leaving this NULL will indicate that only text documents will be accepted.<br><br></li>
<li>
<i>lFlags</i> is an action flag. Use the <b>INTERNET_FLAG_RELOAD</b> flag to instruct the function to retrieve data from the server even if it is locally cached.<br><br></li>
<li>
<i>lContext</i> is an application-defined value. For the simple examples presented here, just use 0.</li>
</ul>
<h3>HttpAddRequestHeaders</h3>
<p>
The <b>HttpAddRequestHeaders</b> function allows you to add or modify headers before sending them to the server. Here are the declaration and three constants you need:</p>
<pre><code>Public Declare Function HttpAddRequestHeaders Lib "wininet.dll" Alias _
 &nbsp;&nbsp;&nbsp;&nbsp; "HttpAddRequestHeadersA" (ByVal hHttpRequest As Long, _ 
 &nbsp;&nbsp;&nbsp;&nbsp; ByVal sHeaders As String, ByVal lHeadersLength As Long, ByVal _
 &nbsp;&nbsp;&nbsp;&nbsp; lModifiers As Long) As Integer
Public Const HTTP_ADDREQ_FLAG_ADD_IF_NEW = &amp;H10000000
Public Const HTTP_ADDREQ_FLAG_ADD = &amp;H20000000
Public Const HTTP_ADDREQ_FLAG_REPLACE = &amp;H80000000
</code></pre>
<ul type=disc>
<li>
<i>hHttpRequest</i> is the handle returned from the call to <b>HttpOpenRequest</b>. This is contrary to the WinInet SDK documentation, which indicates that this is the handle returned from the call to <b>InternetConnect</b>. So please note that you should pass the handle returned from the <b>HttpOpenRequest</b> call, or the function call will return NULL.<br><br></li>
<li>
The <i>sHeaders</i> parameter contains the headers you want to append to the request. Each header must be terminated with a carriage return/line feed (CR/LF) pair. You can send more than one header with this string. A common header that you can send is the "If-Modified-Since" header, which will add conditional behavior to the GET verb specified in the <b>HttpOpenRequest</b> function. After opening a request, you can append a header that tells the server not to return the contents of the file in the body of the message if the file has not been modified since a certain date (see note below). This is how a Web browser could manage caching pages: Before sending the request, the client looks to see if it already has a copy of the page. If it does, it checks the time that it was loaded into the cache directory. The browser then appends the appropriate request header. If the file has not been updated since the last time it was cached on the client's machine, the server will respond with status code 304, which indicates "not modified." The browser then displays the page by reading it from the cache instead of bringing it across the wire.<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;All HTTP/1.0 dates are represented as Greenwich Mean Time (GMT). An HTTP Date in augmented Backus-Naur Form (BNF) is:</p><pre><code>HTTP-date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = rfc1123-date | rfc850-date | asctime-date
rfc1123-date&nbsp;&nbsp; = wkday "," SP date1 SP time SP "GMT"
rfc850-date&nbsp;&nbsp;&nbsp; = weekday "," SP date2 SP time SP "GMT"
asctime-date&nbsp;&nbsp; = wkday SP date3 SP time SP 4DIGIT
date1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2DIGIT SP month SP 4DIGIT
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; day month year (e.g., 02 Jun 1982)
date2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2DIGIT "-" month "-" 2DIGIT
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; day-month-year (e.g., 02-Jun-82)
date3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = month SP ( 2DIGIT | ( SP 1DIGIT ))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; month day (e.g., Jun&nbsp; 2)
time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2DIGIT ":" 2DIGIT ":" 2DIGIT
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 00:00:00 - 23:59:59
wkday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = "Mon" | "Tue" | "Wed"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | "Thu" | "Fri" | "Sat" | "Sun"
weekday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = "Monday" | "Tuesday" | "Wednesday"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | "Thursday" | "Friday" | "Saturday" | "Sunday"
month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = "Jan" | "Feb" | "Mar" | "Apr"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | "May" | "Jun" | "Jul" | "Aug"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | "Sep" | "Oct" | "Nov" | "Dec"
</code></pre>
<p class=tl>
(See also: <a href="http://www.w3.org/">http://www.w3.org/</a>)</P></li>
<li>
<i>lHeadersLength</i> is the length of the <i>sHeaders</i> string. <br><br></li>
<li>
<i>lModifiers</i> are several different flags you can use to modify the behavior of the function. The constants are defined above. You can add the flags together to get the desired action. Here are three flags that you can use:<ul type=disc>
<li>
<b>HTTP_ADDREQ_FLAG_REPLACE</b> is used to remove existing headers or overwrite them with new ones. If the header already exists and the value you are specifying is empty, that header will be removed. If you are supplying a new value to an existing header, this new value will replace the old value.<br><br></li>
<li>
<b>HTTP_ADDREQ_FLAG_ADD</b> adds the header to the request message if it does not already exist.<br><br></li>
<li>
<b>HTTP_ADDREQ_FLAG_ADD_IF_NEW</b> adds a header. If a header already exists, however, the function will return an error.</li>
</ul>
</li>
</ul>
<p>
There are three other flags that can be used if you are interested in coalescing headers. Refer to the WinInet SDK documentation (<a href="http://www.microsoft.com/intdev/sdk/docs/wininet">http://www.microsoft.com/intdev/sdk/docs/wininet</a>) if this interests you.</p>
<h3>HttpSendRequest</h3>
<p>
After you have opened your request and added request headers, if any, you are ready to send your request to the server. The <b>HttpSendRequest</b> function does exactly what you would expect: It sends your request. It also lets you append additional request headers before you send it, so you do not have to make an additional call to <b>HttpAddRequestHeaders</b>. (I would, however, recommend using <b>HttpAddRequestHeaders</b> so you can explicitly check the return value to ensure that the request headers were successfully appended or modified.) After the request is sent, the status line, response headers, and any entity header meta-information are read. You can interrogate these with the <b>HttpQueryInfo</b> function, which is discussed below.</p>
<p>
The declaration for <b>HttpSendRequest</b> is:</p>
<pre><code>Public Declare Function HttpSendRequest Lib "wininet.dll" Alias _ 
 &nbsp;&nbsp;&nbsp;&nbsp; "HttpSendRequestA" (ByVal hHttpRequest As Long, ByVal sHeaders _ 
 &nbsp;&nbsp;&nbsp;&nbsp; As String, ByVal lHeadersLength As Long, sOptional As Any, _ 
 &nbsp;&nbsp;&nbsp;&nbsp; ByVal&nbsp; lOptionalLength As Long) As Integer
</code></pre>
<p>
The function will return <b>TRUE</b> if the request was successfully sent.
<ul type=disc>
<li>
<i>hHttpRequest</i> is the handle returned from <b>HttpOpenRequest</b>.<br><br></li>
<li>
<i>sHeaders</i> and <i>lHeadersLength</i> are two parameters that can be used for appending additional headers to the request, instead of making a separate call to <b>HttpAddRequestHeaders</b>.<br><br></li>
<li>
<i>sOptional</i> and <i>lOptionalLength</i> are parameters for sending additional data along with the request. This is not used for GET requests, so we leave these two parameters NULL in our sample application.</li>
</ul>
<h3>HttpQueryInfo</h3>
<p>
This function lets you look at the status line, response headers, and entity header meta-information returned from the request sent by <b>HttpSendRequest</b>. </p>
<p>
The declaration is:</p>
<pre><code>Public Declare Function HttpQueryInfo Lib "wininet.dll" _
 &nbsp; Alias "HttpQueryInfoA" (ByVal hHttpRequest As Long, _
 &nbsp; ByVal lInfoLevel As Long, ByRef sBuffer As Any, _
 &nbsp; ByRef lBufferLength As Long, ByRef lIndex As Long) As Integer
Public Const HTTP_QUERY_FLAG_REQUEST_HEADERS = &amp;H80000000
</code></pre>
<p>
The function returns <b>TRUE</b> if successful.
<ul type=disc>
<li>
As usual, <i>hHttpRequest</i> is the handle returned from the call to <b>HttpOpenRequest</b>. <br><br></li>
<li>
<i>lInfoLevel </i>is the response header or entity-header metainformation we are interested in interrogating, along with a request modifier flag. If you do not include an optional flag, the response headers will be queried. The sample application contains a number of constants you can use for querying these attributes. <b>HTTP_QUERY_CONTENT_LENGTH</b> is one such constant that can be used to get metainformation about the resource identified in the request. <br><br></li>
<li>
<i>sBuffer</i> is the buffer into which the results are copied. Notice that the declaration specifies that the parameter will be passed <i>by reference</i>. When you actually call the function, you can call it <i>by value</i> with the <b>ByVal</b> keyword in front of the variable in the function call.<br><br></li>
<li>
<i>lBufferlength</i> is the length of the buffer. When the function successfully returns strings, this value will be set to the actual length of the response that was copied into the buffer. If the function fails, this parameter indicates the size that the buffer must actually be in order to receive the string.<br><br></li>
<li>
<i>lIndex</i> is used when you have multiple headers with the same name. Leave this set to 0 unless you have some need for using multiple headers.</li>
</ul>
<h3>InternetReadFile</h3>
<p>
<b>InternetReadFile</b> is the function that will start reading the file once you have sent the request and decided to actually retrieve the body content.</p>
<pre><code>Public Declare Function InternetReadFile Lib "wininet.dll" _ 
 &nbsp;&nbsp;&nbsp;&nbsp; (ByVal hFile&nbsp; As Long, ByVal sBuffer As String, _
 &nbsp;&nbsp;&nbsp;&nbsp; ByVal lNumberOfBytesToRead As Long, lNumberOfBytesRead As Long) _
 &nbsp;&nbsp;&nbsp;&nbsp; As Integer
</code></pre>
<ul type=disc>
<li>
<i>hFile</i> is the handle returned from the call to <b>HttpOpenRequest</b>.<br><br></li>
<li>
<i>sBuffer</i> is the buffer.<br><br></li>
<li>
<i>lNumberOfBytesToRead</i> is the number of bytes returned; <i>lNumberOfBytesRead</i> is the actual number of bytes that were read. </li>
</ul>
<h3>InternetCloseHandle</h3>
<p>
The <b>InternetCloseHandle</b> function closes handles and frees resources associated with WinInet functions. The function returns <b>TRUE</b> if the handle is successfully closed. This is the declaration:</p>
<pre><code>Public Declare Function InternetCloseHandle Lib "wininet.dll" _
 &nbsp; (ByVal hInet As Long) As Integer
</code></pre>
<ul type=disc>
<li>
<i>hInet</i> is the handle you want to close.</li>
</ul>
<h2>VBHTTP Sample Application</h2>
<p>
This sample application lets you examine the request and response headers that are exchanged between the client and the HTTP server during a typical transaction. The following screen shot, from our sample, is what you will see when you run it (Figure 1).</p>
<p>
<img src="vbhttp_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Response view</b></p>
<p>
The screen contains results sent back from the request sent to www.microsoft.com. We are looking at the status message, response headers, and entity header meta-information about the resource content.</p>
<p>
From this we can determine that the content length is 10,447 bytes, the status code is 200 (which means "OK"), and the content expires on Wednesday, September 11, 1996, at 16:19:02 GMT. With this, your Internet-aware application can determine if the content is still valid, verify that the content type is correct, and set up a progress meter so that when the resource is read the progress can be displayed.</p>
<p>
Let's take a look at the request headers that were sent to the server (Figure 2).</p>
<p>
<img src="vbhttp_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Request view</b></p>
<p>
We can see that GET is the request method, "http sample" is the user agent (this is typically more useful product information), and the Pragma is "No-Cache," which tells the server to send the page regardless of whether or not the client has it cached. You can also see that we sent a cookie—"MC1=GUID=3986c31df6ce11cfbcee0000f84a13db"—to the server.</p>
<p>
These are just to give you an idea of what information is available with simple calls to the WinInet functions. </p>
<h3>How Is This Useful to Me?</h3>
<p>
You can add a request header instructing the server to send the content of the resource <i>only</i> if it was updated after a certain time. This way the application only retrieves the content if it has changed since the last time it was retrieved. </p>
<p>
For instance, a call to the WinInet <b>HttpAddRequestHeaders</b> function adds a request header that indicates to the server that we are only interested in seeing the content of the resource specified in the <b>HttpOpenRequest</b> call if that resource has been modified since August 24, 1996. The following example shows how this request header is added. You would insert the following code just after you open your HTTP request using the handle returned from that call.</p>
<pre><code>Dim sHeaders&nbsp;&nbsp;&nbsp; As String
Dim lLength&nbsp;&nbsp;&nbsp; As Long
Dim iRetVal&nbsp;&nbsp;&nbsp; As Integer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
sHeaders = "If-Modified-Since: Sat, 24 Aug 1996 17:38:52 GMT" &amp; vbCrLf
lLength = Len(sHeaders)
iRetVal = HttpAddRequestHeaders(hInternetConnect, sHeaders, lLength, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HTTP_ADDREQ_FLAG_ADD Or HTTP_ADDREQ_FLAG_REPLACE)
</code></pre>
<p>
Check the return value to make sure that it successfully added the request. </p>
<p>
If the file has not been modified since the date specified, the status code in the response message will be 304, "Not Modified." You can check for this, then opt to not call the <b>InternetReadFile</b> function to retrieve the contents.</p>
<h3>DLL Version</h3>
<p>
It is easy to check which version of the WinInet DLL you are using. Add these declarations to your project:</p>
<pre><code>Public Declare Function InternetQueryOption Lib "wininet.dll" _
 &nbsp;&nbsp;&nbsp;&nbsp; Alias "InternetQueryOptionA" (ByVal hInternet As Long, _
 &nbsp;&nbsp;&nbsp;&nbsp; ByVal lOption As Long, ByRef sBuffer As Any, ByRef lBufferLength _
 &nbsp;&nbsp;&nbsp;&nbsp; As Long) As Integer
Public Const INTERNET_OPTION_VERSION = 40
Public Type tWinInetDLLVersion
 &nbsp;&nbsp; lMajorVersion As Long
 &nbsp;&nbsp; lMinorVersion As Long
End Type
</code></pre>
<p>
<b>InternetQueryOption</b> is a WinInet function that lets you check option settings on a specified handle. <b>INTERNET_OPTION_VERSION</b> will return the version of the DLL that you are currently using. </p>
<p>
This is how you call the function:</p>
<pre><code>dim vDllVersion As tWinInetDLLVersion
dim iRetVal&nbsp;&nbsp;&nbsp; As Integer
iRetVal = InternetQueryOption (hInternetSession, _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_OPTION_VERSION, vDllVersion, Len(vDllVersion))
Debug.Print vDllVersion.lMajorVersion
Debug.Print vDllVersion.lMinorVersion
</code></pre>
<p>
You can use this function to check for the length of time before a connection attempt will time out, or to return the parent handle of the connection, and so forth. </p>
<h2>Conclusion</h2>
<p>
As you can see, the WinInet HTTP functions provide you with more flexibility than the general WinInet Internet functions. Using these functions will allow you to build slick Internet-aware applications that have more sophisticated control over the requests they send to the server. </p>
</BODY>
</HTML>
