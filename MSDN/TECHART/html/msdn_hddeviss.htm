<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HelpDesk Sample Development Issues</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_hddeviss"></a>HelpDesk Sample Development Issues</h1>
<p>
Robert Coleridge, Steve Kirk, Kevin Marzec, and Dale Smith<br>
MSDN Content Development Group</p>
<p>
February 1998</p>
<h3>Contents</h3>
<p>
<a href="#hddeviss_midstr">Midstream Design Changes for the HelpDesk Sample</a><br>
<a href="#hddeviss_mtsdeploy">MTS Deployment</a><br>
<a href="#hddeviss_setup">Developing the HelpDesk Setup and Deployment</a><br>
<a href="#hddeviss_newguy">New Guy+Existing Project=New Challenges</a></p>
<h2><a name="hddeviss_midstr"></a>Midstream Design Changes for the HelpDesk Sample</h2>
<p>
by Robert Coleridge</p>
<h4>Taps to TAPI</h4>
<p>
When we first envisioned the HelpDesk sample, we saw a great use for the Telephony API (TAPI). Users would make requests for help by telephone, the request would be stored in a voice mail system, and then transcribed into a formal (textual) help request. Unfortunately, the changing state of the technology forced us to make a hard decision. </p>
<p>
Because TAPI 2.1 was not developed along COM architectural lines, we decided that we would encapsulate TAPI 2.1 and create our own COM object for use with the HelpDesk sample. However, during development of this object, TAPI 3.0, fully COM-compliant, was announced and unveiled at the Professional Developer's Conference (PDC). We had to look seriously at whether or not to continue with our own model. HelpDesk is meant as a sample of technologies and methodologies that developers can use; with TAPI 3.0 near release, we realized that encapsulating TAPI 2.1 would not be the best use of our time, nor would it benefit our readers.</p>
<p>
With this in mind we had to go back and remove code for voice storage and manipulation. The code to do this is fairly straightforward and would be easy to implement once TAPI 3.0 becomes available.</p>
<p>
A project design must take into account changing technology. Any project that tries to keep up with technology will never be implemented. It is best to select a technology and implement it. This is assuming that the technology serves the required purpose and does not need to be "forced" into the project. If a technology must be forced into a project then it is either the wrong technology, or the project design needs to change. In our case we changed the design.</p>
<h4><a name="hddeviss_expand"></a>Redesigning the self-expanding object</h4>
<p>
During development of the HelpDesk sample we realized that our self-expanding object model was not efficient enough for the project. Often, objects either needed more or less expansion than our model allowed. We had to go back and redesign the object expansion.</p>
<p>
First, let me review the types of expanding objects: the fully expanding, the self-expanding, and what we came up with, the layered self-expanding object (Figure 1).</p>
<p>
A <i>fully expanded</i> object carries all of its data with it, from instantiation to destruction. No matter how the data is retrieved, whether the object has a few simple atomic members or several thousand objects in collections, all the data is contained within the object. This type is great for speed of data access, unfortunately it is deadly when it comes to memory and network resources.</p>
<p>
When a <i>self-expanding</i> object is instantiated, it only carries the information necessary to fully populate itself when its data is actually needed. Because it delays the actual self-population until necessary, the self-expanding object is much leaner than the fully-expanded object. This design has the advantage of less bulk to slow down the network, but it takes two hits to the database to fully populate the object. Once again, it is a tradeoff: speed or resources.</p>
<p>
As a solution we developed a <i>layered self-expanding</i> object model. This differs from the "self-expanding" model only in when the expansion takes place and how much data is expanded at each layer. The layers are defined at design time and could be <i>n</i> layers deep.</p>
<p>
For an example, let's look at the CTech object as it was originally implemented in the HelpDesk sample. When a technician object (CTech) was created from a database record, the object contained the Primary Key Id (PKId) of it's associated record. If the user requested any other data (such as Email alias), the entire record was pulled into the object and expanded. </p>
<p>
To give the object a layered expansion, we have the initial loading of the object store the PKId of the technician record. When the technician's email alias, skill, or location records is requested the object is only partially expanded. The other fields ( for example, the collection of requests) are not contained in the object until they are requested, at which point the object is fully populated.</p>
<p>
This design has the advantage of even less bulk to slow down the network, but it also takes three trips to the database to fully populate the object. Again, it is a case of speed vs. resources.</p>
<p>
This model does take some extra work at the design phase but the improvements later on are definitely worth the effort.</p>
<p>
<img src="hddeviss1.gif" border=0></p>
<p class=label>
<b>Figure 1. Three types of expanding objects</b></p>
<h4>Moving from smart to dumb objects</h4>
<p>
Early in the design process we decided to use smart objects. As we moved through the project we began to realize that our sample, which was partially web oriented, needed thinner objects. With this in mind, we went back and turned our bulky smart objects into thinner dumb ones.</p>
<p>
A dumb object is a simple part, destined for a greater whole (rather Zen, wouldn't you say!). It contains data only (and possibly constructor/destructor methods). The object does not contain any operational code and must be "cared" for by a larger administrative object, which manages the object and manipulates its data. Usually, the dumb object is created outside of the Administrator object.</p>
<p>
If these objects are so dumb then why use them? Good question. Since the object carries data only, they are thinner than objects that contain code necessary to manipulate that data. Hence, they are ideal for Web or high-volume applications. </p>
<p>
When should smart objects be used? When you want objects that can be "torn off" from somewhere and used on their own. This is their greatest strength, but it is also their greatest weakness. Due to the extra contained code, the smart object tends to be bulkier than its dumb object cousin. In a scenario where network bandwidth is high or the volume of objects transferred is low, smart objects could be the way to go. When there is going to be significant network traffic, you should consider the smaller, lighter "dumb objects."</p>
<h2><a name="hddeviss_mtsdeploy"></a>MTS Deployment</h2>
<p>
by Steve Kirk</p>
<p>
The HelpDesk API hides transaction details from all parts of the application except the business and data services layers. In fact, the only difference, above the business layer, between the Microsoft Transaction Server (MTS) and Non-MTS versions of the application is in the naming of the two component families. This version similarity allowed us to develop the bulk of the application using the Non-MTS version with the expectation that there would be few surprises when deploying the MTS version as a distributed application. When we finally tested the system under MTS we had a couple of surprises, which I’ll cover here.</p>
<h4>Importing components into MTS packages</h4>
<p>
By misinterpreting the meaning of controls in the Transaction Server Explorer user interface (MTS Version 1.1), I created an easy-to-remedy but effective show stopper that prevented the client applications from instantiating remote objects. You won’t encounter this problem if you follow the instructions for setting up an MTS package in <a href="msdn_hddeploy.htm">"MSDN HelpDesk Sample Installation"</a> to the letter, but if you use those instructions only as a general guide, you may repeat my experience.</p>
<p>
The HelpDesk server setup installs components that provide data and business services on the computer. You then use the Transaction Server Explorer to create a package that contains these components (based on your distribution scenario) and you export the package so that it can be installed on remote computers.</p>
<p>
I made the mistake when I added components to the package. The two available options are to <b>Install new component(s)</b> or to <b>Import component(s) that are already registered</b>. I reasoned that either option would result in an equivalent package since the components were installed on the computer on which I built the package. I thought that either method of selection would cause MTS to extract the type library data from the component and to add this type library to the package. However, I found that importing does not examine the components to get type library information (even for local components) and that the resulting package only allows a remote client to instantiate objects using late binding. Check for this error if you receive "can’t create object" errors from HelpDesk MTS clients.</p>
<h4>Implications for ByRef</h4>
<p>
The next surprise is more interesting for developers of MTS components in Visual Basic because it involves API architecture, Visual Basic data types, COM, and MTS. I found that a few methods failed in the MTS versions while, in the non-MTS versions, everything worked fine. As Fred Pace explains in <a href="msdn_hdobj.htm">"Designing the Transaction-Processing Object Model for the HelpDesk,"</a> the HelpDesk components use dynamic arrays as data containers that are passed between objects. When the workflow object needs data, it passes an array by reference to the business layer object which, in turn, passes the array on to the data-access layer where it is resized and filled with data. I found that the failures were limited to code that expands technician and user objects in multiple stages. See Robert Coleridge’s discussion of <a href="#hddeviss_expand">self expanding objects</a>. The technician objects within the collection returned by HDClient.CAdmin.GetTechnicians are initially populated with only the PKId of the corresponding technician. Property get procedures on the technician test for and trigger object expansion as required. Two stages of expansion are used: the first stage populates the primary properties of the technician (alias, skill and location) and the second stage populates the collection of requests assigned to the technician. The refresh procedure performs this property population at the depth specified by the bExpandFull parameter. The following code segment shows that he sData() array is filled by <b>GetTech()</b> and, if necessary, it is resized and filled by <b>GetRequests()</b>. The code was failing on the second call to oTrans during a full expansion. The problem ceased when I eliminated the ReDim array before the second oTrans call. </p>
<pre><code>Private Sub Refresh(bExpandFull As Boolean)

Dim oTrans&nbsp; As HDServer.CTrans
Dim oReq&nbsp;&nbsp;&nbsp; As CRequest
Dim sData() As String
…
‘ Initialize object properties
Clear
‘ Get business services object
Set oTrans = New HDServer.CTrans
‘ Get first stage data and populate member variables
If oTrans.GetTech(m_lPKId, sData) Then
 &nbsp;&nbsp; m_lLocId = CLng(sData(icTechLocId, icZeroDim))
 &nbsp;&nbsp; m_lSkillId = CLng(sData(icTechSkillId, icZeroDim))
 &nbsp;&nbsp; m_sAlias = Trim$(sData(icAlias, icZeroDim))
 &nbsp;&nbsp; ‘ Perform second stage expansion if requested
 &nbsp;&nbsp; If If bExpandFull Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘ Initialize Details list
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set m_cReqs = New Collection
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘ Resize the array (causes GetRequests to fail under MTS)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReDim sData(0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘ Get request data and populate list
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If oTrans.GetRequests(m_lPKId, sData) Then
…
End Sub
</code></pre>
<p>
Although the array is owned in one way by the refresh procedure (due to scope), the array is resized by an object under MTS. Because the ByRef array is modified within the scope of an MTS transaction, the refresh procedure loses ownership of the right to resize the array. Although coding conventions often call for explicitly initializing a variable before each use even where this leads to multiple initializations, this situation, where the size of the array is determined from within component code under MTS, dictate that you only resize at the layer of the object within MTS rather than from either place. </p>
<h2><a name="hddeviss_setup"></a>Developing the HelpDesk Setup and Deployment </h2>
<p>
by Kevin Marzec</p>
<h4>MTS package generation and configuration</h4>
<p>
While putting the HelpDesk setup program together, we ran into some areas that caused us problems. The first, involving Microsoft Transaction Server, was probably the easiest to overcome, as most of the issues dealt with user error more than anything else. When building an MTS application, I highly recommend reading the MTS documentation, especially those topics about package creation and export. Here are a few tips and tricks for the uninitiated:
<ul type=disc>
<li>
Do not run the exported package on the server computer. The package that you generate is to be executed on the client computers to enable them to connect to the server components. If you generate your package in MTS and then run the exported executable on the same machine, you will end up with duplicate registry entries for your components, which could potentially lead to confusion when one object searches for another. <br><br></li>
<li>
To remove a component from MTS (and the registry), delete the component from the package first. If you simply delete the package, the registry entries for the included components will not be removed. <br><br></li>
<li>
For efficiency, I recommend that all MTS components running on the same computer be packaged together in the same package. To do this in HelpDesk, add the DBExec component to the package that contains HDServer <i>after</i> you have exported the package. However, if you were running DBExec alone remotely, it would be installed into its own MTS package on the remote computer, and this package would then be exported to the HDServer computer, where it would be executed. This provides your clients access only to the functionality of HDServer. <br><br></li>
<li>
Also, remember to set your component properties to "Supports Transactions."</li>
</ul>
<h4>Registry configuration</h4>
<p>
We also ran into some difficulties with the registry,<b> </b>that mystical place that can unreservedly bring your system to a halt if you don't treat it right. Before you reregister a component, you want to be sure that you first remove any existing registry entries associated with it, <i>especially</i> if you are registering it through Microsoft Transaction Server, and <i>even more especially</i> if you are registering it through an exported MTS package. Components registered through an exported package will have an entry in the <b>Add/Remove Programs</b> utility of the Control Panel. This entry, listed as <b>Remote Applications—&lt;</b><i>package name</i><b>&gt;</b>, is created when you execute an MTS package. Using the <b>Add/Remove Programs</b> utility to remove a component will clear it from the registry. </p>
<p>
However, even the best of us make mistakes every now and then, and the kind folks at Microsoft have invented a nifty little utility that will help you deal with mangled registry situations. REGBACK is included in the Microsoft Windows NT® Resource Kit. It will back up your registry so that, in case of problems with configuration, you can restore it and try again. In general, as with any critical data, it is a good idea to back up your registry often, especially before you install and test applications whose stability may be unknown.</p>
<h4>Debugging</h4>
<p>
Imagine that you have built your application and have created and run a setup program for it. You attempt to run the application and you receive an error such as "Error 046 – ActiveX component can't create object". And the application closes. Before you run screaming out into the night, there are a few things you can try. (However, remember that prevention is the best cure, and there is nothing like good error handling and reporting to avoid cases like this.) </p>
<p>
Even a problem as ambiguous as this can be dealt with in a rational way. It is often difficult to distinguish between a configuration problem and a "real" bug (application problem). When in doubt, use Microsoft Visual Basic® to walk through the code and see where the failure is occurring. The easiest way to do this is to create a new project that will instantiate a top-level object as follows:</p>
<pre><code>Private Sub Form_Load()
Dim oAdmin As New CAdmin
Dim oTech As CTech
For Each oTech In oAdmin.GetTechnicians
 &nbsp;&nbsp; Debug.Print oTech.Alias
Next
End Sub
</code></pre>
<p>
Next, add each of the components to this project (making sure that your references are set correctly), and step through it. When doing this, make sure that you are not using MTS-based components. Because MTS requires that MTS-aware objects be instantiated within the MTS process space, attempting to create an MTS object while in Visual Basic design mode will cause an error. In order to step through the HelpDesk source code in design mode, you must use the non-MTS code. </p>
<p>
In the case of the HelpDesk sample application, there is a bUseMTS compiler flag, which, when set to 0, will disable MTS from your code. If you disable MTS from your code and everything runs flawlessly, the problem is most likely due to a misconfiguration of one or more of your MTS components. However, if you still get the same problem as before, you can walk through the code step by step and determine what is failing. Hopefully this method will isolate any problem that you are having. If it doesn't, maybe running screaming out into the night isn't such a bad idea after all.</p>
<h2><a name="hddeviss_newguy"></a>New Guy+Existing Project=New Challenges</h2>
<p>
by Dale Smith</p>
<p>
A new team member has many issues to deal with, like locating the lunchroom or, for that matter, figuring out how to get out of the building when it is time to go home. Add to that, coming in late in the development cycle of an existing project, and the task can seem daunting. Well, I recently joined the MSDN Content Development team toward the end of development of the HelpDesk sample. This created some very interesting and maybe not so unique challenges. I needed to learn new technologies. I needed to learn new methodologies and approaches to design. I needed to become familiar with the existing project and coding standards. And I needed to learn it all yesterday.</p>
<h4>Back to school—Learning new technologies</h4>
<p>
Coming late into the development cycle of a project requires you to quickly learn unfamiliar technologies. In trying to come up to speed, I discovered that I faced two obstacles. First, I only had time to skim through books while gleaning the most important points. Second, the other developers were busy with their own issues and didn't have time to spend on my "learning curve." This meant that I had to learn from the existing code, using the project itself as a textbook. </p>
<p>
One of the best resources for learning new technologies is other developers' code. Keep an open mind as you view the code and learn from the experience of other people; and be careful not to arrogantly criticize the techniques used in a belief that some things could be done better. Remember that while you are coming in with a set of technologies that you are comfortable with, you may not completely understand the needs of the project. </p>
<h4>Ongoing education—Learning new methodologies</h4>
<p>
For someone who has spent a considerable amount of time developing desktop applications, entering the emerging world of distributed computing via the Internet requires a whole new way of thinking. A client-server design on one or two machines is one thing, but a distributed component architecture, or <i>n</i>-tier design, is a different one altogether. After spending some time looking at the HelpDesk code it became clear that there were four distinct components or layers. What I discovered could help you understand this new development paradigm. You could look at these as if you were peeling layers from an onion. The outer layer is the presentation layer or what the user sees. The next layer, or workflow layer, acts as the middleman between the next layer down, the business layer, and the presentation layer. The workflow layer determines what is required in order for an operation to be completed. It contains the rules that determine what parameters are passed to the business layer to be able to process a request. The next layer, or business logic layer, determines how the request is to be handled. It contains the rules that validate the parameters used to process the request. And finally, the bottom data layer "talks" to the database, retrieving and making changes to the data. This layered approach helps to isolate the components and make development easier by separating the components into manageable self-contained units that can be distributed among several computers across a network or around the world.</p>
<h4>On the job training—Integrating into an existing project</h4>
<p>
In trying to adapt quickly to the team, some old habits needed to be changed quickly. Inheriting someone else's code required me to adapt my coding technique to what had already been written.&nbsp; Again, using the other parts of the project as a guide allowed me to adapt and discover what needed to be done to the code I was working on.</p>
<h4>In retrospect </h4>
<p>
No matter when you join a project, timing is critical. It's easy to get distracted by going off on tangents—there are a lot of new and exciting technologies out there. Don't take time from the existing project to chase after them. Define your goals clearly and focus your attention strictly on achieving them. As with any venture, the best approach is to plan ahead and proceed with attainable goals. Above all, be open minded and enjoy the experience! </p>
</BODY>
</HTML>
