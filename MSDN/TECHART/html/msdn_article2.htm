<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Article 2. Libraries Made Too Easy</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1><a name="msdn_article2"></a>Article 2. Libraries Made Too Easy</h1>
<p>
Bruce McKinney</p>
<p>
April 18, 1996</p>
<p>
Microsoft® Visual Basic® 4.0 may have come as kind of a shock to those poor unfortunates who wrote large dynamic-link libraries (DLLs) to enhance Visual Basic 3.0. Although Microsoft promised compatibility with old Basic programs (and for the most part came through), it never made any promises about compatibility of DLLs. Rather than risk breaking every control ever written, Microsoft provided a compatibility layer for running VBX controls in 16-bit Visual Basic 4.0. But it provided no compatibility layer for DLLs that weren't controls. And of course, it would have been pretty difficult to make 16-bit DLLs or controls very compatible with their 32-bit counterparts. </p>
<p>
So this article (second of five in a series) will start at ground zero. I assume that you have never written a DLL for Visual Basic. If you managed to figure out the instructions in the VB4DLL.TXT file (supplied with version 4.0) and create a DLL (despite the lack of sample code), humor me. Forget everything you learned and start over with me. You can skim if you think you already know it, but I'm going to be introducing some topics that will be very important in later articles, so skip this one at your peril. </p>
<h2>The Three Levels of DLL Programming</h2>
<p>
There are several different ways to add procedures written in C++ (or some other compiled language) to your Visual Basic programs. Following are three ways that I discuss in some depth in this series.
<ul type=disc>
<li>
<b>Level 1.</b> Write your programs using the same style and following the same rules as the application programming interface (API) functions in system DLLs. This is an excellent choice if you happen to be on the Windows® programming team and are writing a new DLL for use by all Windows programs in all languages. But you aren't. This approach used to have some appeal because it was the only way to write language-independent DLLs for use from any language. Most languages handle numbers pretty much the same, but they have different ways of dealing with strings, arrays, and untyped variables. The system API format, although not documented as a standard, provides a compromise that works moderately well in all languages, but not very well in any language. Basic procedures you write using this style don't look like Basic procedures. This chapter will cover how to process numbers and structures at level 1, but I'm not going to say much about the old-fashioned way of doing strings and arrays. <br><br></li>
<li>
<b>Level 2.</b> Use OLE types to create DLL functions that work transparently in Visual Basic and other OLE-compatible languages. The three OLE types you need to understand are BSTR, VARIANT, and SAFEARRAY. Numeric types work the same as in level 1. By using these types, you can make your new Basic procedures look like built-in Basic procedures. It's the polite thing to do, but implementation is more difficult. So what. You do extra work so that your customers do less work. Articles 3, 4, and 5 of this series will make the work, well, not exactly easy, but tolerable. Those of you who wrote the Visual Basic 3.0 equivalent of this type of DLL using the VBAPI library have a head start. You must forget the specifics of what you already know, but it's just another API. The principles are the same. <br><br></li>
<li>
<b>Level 3.</b> Write OLE objects just like the ones provided by Visual Basic. You can make objects that look like objects—similar to controls and the DAO—or you can make objects that look like libraries—similar to the Visual Basic and Visual Basic for Applications libraries. This is the right thing to do because objects you write this way can raise errors, be collected in collections, have methods and properties, and do all sorts of other wondrous things that haven't even been invented yet. Alas, I'm not going to tell you how to go to level 3 in this series. Maybe another time.</li>
</ul>
<p>
This chapter tells how to write DLLs at level 2. The part of level 1 that is a subset of level 2 is also covered. Most of what you learn here will carry over when you start writing level 3 objects and libraries. </p>
<h2>The Mechanics of Building DLLs</h2>
<p>
We have to wade through some tedious mechanical issues before we can get to the fun of real programming. I'll use my Visual Basic Utilities DLL as an illustration. </p>
<p>
The VBUTIL DLL was provided in 16- and 32-bit formats with my book <i>Hardcore Visual Basic</i>. It contained various functions for fiddling bits, making Win32® functions more Basic-friendly, and doing a few other tasks that Basic doesn't handle. This book provides an updated 32-bit version with a few more functions and some enhanced programming tools. The old version was written in C, but this version is in C++ and takes advantage of some C++ types (classes) that will be introduced in this article and explained in detail in subsequent articles. </p>
<h3>The Sample Code</h3>
<p>
The sample code for this article (and for Articles 3, 4, and 5) consists of two libraries—one static, one dynamic. The OleType library is a static library intended for C++&nbsp; programmers. VBUtil is a dynamic-link library intended for Visual Basic programmers. The VBUtil library uses the OleType library. When you write your own DLLs for Visual Basic, you’ll use VBUtil as a model. You’ll use OleType as a tool. </p>
<p>
The OleType library comes in two versions—Release and Debug. There are no separate Unicode™ versions of this library because Unicode conversion is handled at run time through function overloading, as you’ll see in Article 3. VBUTIL32.DLL can be built four different ways—ANSI Debug, ANSI Release, Unicode Debug, and Unicode Release. In fact, there is only one version of the file because registering four different DLLs under Visual Basic would be too much trouble. Changing the build settings overwrites the previous version. The Visual Basic project Cpp4VB.VBP gives the procedures in VBUTIL32.DLL a workout. </p>
<p>
The sample files for this series contain a README.TXT file with specific instructions for setting up and building the sample libraries. </p>
<h3>Static and Dynamic Library Summary</h3>
<p>
Let’s look at the parts of the two libraries in more detail. First, the following table shows the files in the OLETYPE project.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>File</b></td>
<td class=label width=76%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=24%>OLETYPE.MDP and OLETYPE.MAK</td>
<td width=76%>These are the Microsoft Developer Studio project files. If you use a different compiler, you will have to use its project format. </td>
</tr>
<tr valign=top>
<td width=24%>OLETYPE.H</td>
<td width=76%>This file defines the standard OLE types described later in this chapter. It includes the BSTRING.H, VARIANT.H, and SAFEARRAY.H files described below so that clients see only one include file.</td>
</tr>
<tr valign=top>
<td width=24%>BSTRING.H and BSTRING.CPP</td>
<td width=76%>These files declare and implement a new String type that encapsulates the OLE BSTR type. </td>
</tr>
<tr valign=top>
<td width=24%>VARIANT.H and VARIANT.CPP </td>
<td width=76%>These files declare and implement a new Variant type that encapsulates the OLE VARIANT type. </td>
</tr>
<tr valign=top>
<td width=24%>SAFEARRAY.H</td>
<td width=76%>This file declares and implements a new SafeArray template type that encapsulates the OLE SAFEARRAY type. Where’s the .CPP file? Article 5 will explain. </td>
</tr>
</table><br>
<p>
The result of building this project is the release (OleType.Lib) or debug (OleTypeD.Lib) version of a static library. The OleType.H and OleType.Odl include files should be considered part of the library. Put them in your include directory and include them in the appropriate files of any projects that use the OleType library. </p>
<p>
The following table shows files for the VBUTIL project.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>File</b></td>
<td class=label width=76%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=24%>VBUTIL.MDP and VBUTIL.MAK</td>
<td width=76%>These are the Microsoft Developer Studio project files. If you use a different compiler, you will have to use its project format. </td>
</tr>
<tr valign=top>
<td width=24%>VBUTIL.DEF</td>
<td width=76%>The .DEF file is required to define exports for new functions. </td>
</tr>
<tr valign=top>
<td width=24%>VBUTIL.RC</td>
<td width=76%>The only resources here are version resources. You could also embed the type library as a resource. Later I’ll explain why VBUTIL doesn’t.</td>
</tr>
<tr valign=top>
<td width=24%>VBUTIL.ODL</td>
<td width=76%>Polite DLLs should provide a type library so that clients don’t have to bother with <b>Declare </b>statements. Article 1 describes type library source files. This article adds a few more details. </td>
</tr>
<tr valign=top>
<td width=24%>VBUTIL.CPP and VBUTIL.H</td>
<td width=76%>These files just provide initialization and termination routines, global variables, error handling, and definitions used by any DLL. The real functionality goes in separate source files. They also serve as the base files for precompiled headers. </td>
</tr>
<tr valign=top>
<td width=24%>TOOLS.CPP and TOOLS.H </td>
<td width=76%>These files provide some general utility functions for manipulating bits and other chores that can’t be done easily in Basic. This article contains several samples from these files.</td>
</tr>
<tr valign=top>
<td width=24%>WIN32.CPP and WIN32.H</td>
<td width=76%>These files provide Basic-style implementations of some Win32 functions that are difficult to use in Visual Basic. You’ll see examples in Articles 3 and 4. </td>
</tr>
<tr valign=top>
<td width=24%>OLETYPE.H, OLETYPE.ODL, and OLETYPE.LIB</td>
<td width=76%>These files provide definitions of standard OLE types. See Articles 3, 4, and 5.</td>
</tr>
<tr valign=top>
<td width=24%>TEST.CPP and TEST.H </td>
<td width=76%>These files provide test functions that systematically test the <b>String</b>, <b>Variant</b>, and <b>SafeArray</b> classes.&nbsp; You could put this module in conditionals so that it won’t be built in release builds. </td>
</tr>
</table><br>
<h3>Build Settings</h3>
<p>
Let me summarize a few of the settings I use in the Microsoft Developer Studio. The same issues will come up with other compilers, though the solutions may be slightly different. 
<ul type=disc>
<li>
In the Precompiled Headers category of the C/C++ tab, set "Automatic use of precompiled headers through VBUTIL.H."<br><br></li>
<li>
Normally you should leave the _MBCS macro defined in the Preprocessor category of the C/C++ tab. This default setting builds your DLL for ANSI strings. You can change the setting to _UNICODE if you want faster string processing under Windows NT®, but you should be aware that your DLL will no longer work under Windows 95, which doesn't handle Unicode. I'll discuss this in more detail in Article 3. <br><br></li>
<li>
In the General category of the Link tab, set the output file to your DLL name and desired destination. I prefer to create the DLL in my Windows directory (C:\WINDOWS on all my machines) because Visual Basic can find it there. Note that during debugging, you'll have to unload any Visual Basic test program that uses the DLL. You'll get a sharing access error if you try to re-link the DLL while Visual Basic is using it. I put the DLL in the same location whether I'm doing a debug or release build. Some readers may prefer to put copies of their debug and release DLLs in separate directories following the Visual C++ defaults. I don't use this method, but it can work if Visual Basic can find the DLL and the type library. <br><br></li>
<li>
On the OLE Types tab, set the target type library (.TLB) file to the same destination directory as the DLL. You must expand the Debug and Release folders, select VBUTIL.ODL, and make the settings in the Output filename field. This field is disabled if the .ODL file isn't expanded. The development environment will automatically build the .TLB file, but again you must unload any Basic test program to avoid sharing errors. <br><br></li>
<li>
You can embed the type library in the DLL file by making it a resource. I don't embed the resources in function DLLs such as those described here. I do embed them in OLE server DLLs (not discussed in this series). The reason is that I don't want the type library information distributed to end users. It's extra overhead that customers don't need, and I don't want to give away valuable information to my customers' customers, who haven't bought my product. I distribute the .TLB file to my Visual Basic customers, but they don't need to send it to their customers. </li>
</ul>
<h3>Module Initialization and Standard Definitions</h3>
<p>
I put all the standard stuff required by any DLL in the VBUTIL.CPP and VBUTIL.H files. Normally, these will rarely change during the life of a project. If you put the standard definitions and include files required by all projects in VBUTIL.H and set this file to become part of your precompiled header, you can get much faster builds for changes in the rest of the project. </p>
<p>
Here are the standard initialization routines in VBUTIL.CPP:</p>
<pre><code>#include "vbutil.h"

HINSTANCE hInst;

// This function is the library entry point. It's technically 
// optional for 32-bit programs, but you'll have more options later 
// if you define it here. 

BOOL WINAPI DllMain(HINSTANCE hInstA, DWORD dwReason, LPVOID lpvReserved)
{
 &nbsp;&nbsp; switch (dwReason) {
 &nbsp;&nbsp; case DLL_PROCESS_ATTACH:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The DLL is being mapped into the process's address space.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do any additional initialization here.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInst = hInstA;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case DLL_THREAD_ATTACH:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A thread is being created.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case DLL_THREAD_DETACH:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A thread is exiting cleanly.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case DLL_PROCESS_DETACH:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The DLL is being unmapped from the process's address space.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do any additional cleanup here.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInst = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
Some of you may be old enough to remember the ancient times when 16-bit DLLs had a <b>LibMain</b> function for initialization and a <b>WEP</b> (Windows Exit Procedure) function for cleanup. Nowadays, there's just one function and it handles not only program initialization and cleanup, but also the same operations for separate threads started by the DLL. This series isn't going to get into separate threads, but you get the idea.</p>
<p>
The <i>hInst </i>variable is saved globally, based on the passed value of the <i>hInstA </i>parameter. This may prove handy in your DLL functions if you ever need an instance handle for loading resources. </p>
<p>
VBUTIL.H contains mostly standard include files and a few standard definitions. </p>
<pre><code>#include &lt;windows.h&gt; 
#include &lt;io.h&gt;
#include &lt;iostream.h&gt;
#include &lt;strstrea.h&gt;
#include "oletype.h"

// Temporary buffer size
const TEMP_MAX = 512;

#define DLLAPI&nbsp; WINAPI // Currently evaluates to __stdcall.

// Make ASSERT statement (fails in expressions where it shouldn't be used).
#if defined(DEBUG)
 &nbsp; #define ASSERT(f) \
 &nbsp;&nbsp;&nbsp;&nbsp; if (f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(f) 
#else
 &nbsp; #define ASSERT(f) NULL
#endif

void ErrorHandler(Long e);
DWORD HResultToErr(Long e);
</code></pre>
<p>
The contents of all those include files will go into the precompiled header the first time you compile and you won't have to compile them again. You might need to add more include files if you use more run-time functions in your DLL. You'll have to recompile when you add them. We'll be talking about the <b>DLLAPI</b> macro in the next section. The <b>ASSERT</b> macro is a standard one that I use in all my coding. Its purpose is to make asserting within an expression—a dangerous technique—illegal so that it will generate a compile-time error. I borrowed this technique from Steve Maguire's book, <i>Writing Solid Code</i> (Microsoft Press, 1993). </p>
<h3>Calling Convention and Linkage</h3>
<p>
Calling conventions are simple: Use <b>stdcall</b>. OLE supports three different calling conventions: <b>stdcall</b>, <b>pascal</b>, and <b>cdecl</b>. Most compilers support only two conventions: <b>pascal</b> and <b>cdecl</b> for 16-bit compilers or <b>stdcall</b> and <b>cdecl</b> for 32-bit compilers. Because this article focuses solely on 32-bit code, we can eliminate <b>pascal</b>. The only reason to use the <b>cdecl</b> convention is so that you can have a variable number of arguments in the C style. The only kind of host that could use such arguments is a C or C++ client. Because we're building a DLL targeted at Visual Basic, we can eliminate <b>cdecl</b>. That leaves <b>stdcall</b>, which is in fact the only calling convention recognized by 32-bit Visual Basic. </p>
<p>
You don't need to understand that the <b>stdcall</b> convention means that the callee cleans the stack or that arguments are pushed right to left. These details generally only matter to compiler writers. But you do need to understand something about the <b>stdcall</b> linking conventions. </p>
<p>
Almost everyone (myself included) who starts writing DLLs for Visual Basic makes the same mistake. In the old 16-bit days, you specified that a function should be exported to a DLL like this: </p>
<pre><code>void __export __pascal DoNothing(void);
</code></pre>
<p>
Neither <b>__pascal</b> nor <b>__export</b> work in 32-bit compilers. Their approximate equivalents are <b>__stdcall</b> and <b>__declspec(dllexport)</b>. So the natural thing is to write the function like this:</p>
<pre><code>void __declspec(dllexport) __stdcall DoNothing(void);
</code></pre>
<p>
In Microsoft Visual C++, this produced the following function name in the DLL: </p>
<pre><code>?DoNothing@@YGXXZ
</code></pre>
<p>
(You can verify this by building a DLL and checking the exported functions with the <b>DUMPBIN</b> program provided with Visual C++.) By default, C++ mangles names in order to support functions with the same names but different parameter lists. All C++ compilers mangle names, although different compilers use different mangling schemes. </p>
<p>
You can turn off C++ name mangling like this:</p>
<pre><code>extern "C" void __declspec(dllexport) __stdcall DoNothing(void);
</code></pre>
<p>
This produces the following name in the DLL:</p>
<pre><code>_DoNothing@0
</code></pre>
<p>
Here the mangling follows the Win32 <b>stdcall</b> mangling convention. The names always have an underscore prefix and a suffix of the "at" sign (@) followed by the number of bytes of parameters in hexadecimal.</p>
<p>
This isn't what you want for Visual Basic. Of course, your clients could get around this limitation by aliasing all their <b>Declare</b> statements:</p>
<pre><code>Declare Sub DoNothing Lib "MyLib.DLL" Alias "_DoNothing@0" ()
</code></pre>
<p>
However, it would be extremely rude to impose this extra burden on your users. In fact, it's not very polite to force your users to write any <b>Declare</b> statements. You should provide a type library. And if you do, you can get around this problem by aliasing the functions there. The ODL code would look like this:</p>
<pre><code>[
entry("_DoNothing@0"),
helpstring("Do absolutely nothing")
]
void WINAPI DoNothing(); 
</code></pre>
<p>
This works OK, but you have to figure out <b>stdcall</b> mangling for every function. It's not really difficult—usually just multiply the number of parameters by four and append this number in hexadecimal after the @ sign. But the easier solution is to specify the export name in the .DEF file. </p>
<p>
A .DEF file is optional for Win32 DLLs. Most of the options you set in a .DEF file have acceptable defaults. You can get by without one on most C++ projects, but unfortunately you'll probably want to use one when targeting Visual Basic. You can define your functions like this: </p>
<pre><code>void __stdcall DoNothing(void); 
</code></pre>
<p>
Add a .DEF file entry in the EXPORTS section for each function:</p>
<pre><code>EXPORTS
 &nbsp;&nbsp; DoNothing
</code></pre>
<p>
Now the function name comes out the way you expect in the DLL: <b>DoNothing</b>. You don't have to use aliases in <b>Declare</b> statements or type library entries. You <i>do</i> have to remember to modify the .DEF file every time you create a new function. </p>
<p>
So why does VBUtil use DLLAPI instead of <b>__stdcall</b> in its function prototypes and definitions? </p>
<pre><code>void DLLAPI DoNothing(void); 
</code></pre>
<p>
I'm not just trying to get rid of underscores, although that's a pleasant side effect. (I'm going to resist the urge to flame about the ANSI C++ requirement for double underscores on compiler-specific keywords.) If you check back through the chain of definitions (the browser in the Microsoft Developer Studio makes this easy), you'll find the following declaration in VBUTIL.H:</p>
<pre><code>#define DLLAPI&nbsp; WINAPI
</code></pre>
<p>
Going back one more level to the Win32 include file WINDEF.H, you'll find this: </p>
<pre><code>#define WINAPI&nbsp; __stdcall
</code></pre>
<p>
I keep this somewhat confusing system to make it easy to port to new environments (such as Macintosh®) or to different compilers. For example, instead of <b>__declspec(dllexport)</b>, your compiler might have a 32-bit attribute that has the same effect as the old 16-bit <b>__export</b> attribute. Let's assume this attribute is called (surprise!) <b>__export</b>. You change the <b>define</b> statement to this: </p>
<pre><code>#define DLLAPI&nbsp; WINAPI __export
</code></pre>
<p>
Now you don't need a .DEF file. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Borland representatives assured me that their implementation of extern "C" and <b>__export</b> or <b>__declspec(dllexport)</b> will generate unmangled function names and that you won't need a .DEF file. I didn't have a chance to test this for Borland® C++ or other compilers. </p>
<h3>Debugging</h3>
<p>
I'm going to describe some of the debugging issues for the Microsoft development environment. Other IDEs will no doubt have similar issues. </p>
<p>
I make the Visual Basic environment (VB32.EXE) the program to be debugged. I set the working directory to the directory containing my Basic test programs. You'll have to adjust the directories for your own configuration. I set the program arguments to /r with the name of my Basic test program. When I press the Go toolbar button (or use the Start hotkey or menu item), the IDE runs Visual Basic, which runs my Basic test program, which loads my DLL. When I execute Basic code that uses DLL functions, the IDE will stop at any breakpoints in my C++ code. The load time is a little slow, but I can debug normally. </p>
<p>
Before any of this happens, you'll see the same obnoxious error message described in Article 1, telling you that VB32.EXE does not contain debugging information. Be calm. Do not curse. As my dad says, "It'll get better, or you'll get used to it." Or you'll get your hands on Visual C++ 4.1, which fixes the problem. </p>
<p>
To do serious debugging of the DLLs in this chapter, you'll need to enable Unicode debugging by modifying the AUTOEXP.DAT file. I'll explain this in detail in Article 3. </p>
<p>
Another thing I usually do is to enable the startup banner for debug builds in the Customize mode of the C/C++ tab in the Settings dialog. This causes the environment to output a lot more information during compiles, including the complete compile command lines with all the options used. Once you've got a project working properly, you may prefer to turn off this extra noise, but it can be handy for debugging build problems. The Linker and OLE Types tabs have similar setting, although I find these less useful. </p>
<h2>The OLE Types</h2>
<p>
C++ has types and more types—signed types, unsigned types, pointer types, intrinsic types, implementation-specific types, standard <b>typedef</b>ed types . . . . And there are more coming when the ANSI C++ committee lays down the law "real soon now."</p>
<p>
Basic takes a different approach. It has only a few types, but they're solid ones. No pointer types. No unsigned types. No types that act like types but aren't quite types (such as char* in C++). Because this article is about extending Visual Basic with C++, we're going to trim the C++ type list down to fit the Basic type list. Or to be more exact, we're going to trim C++ types to OLE size. </p>
<p>
One goal of OLE automation is to be language-independent, but because the people who wrote the technology also work on Visual Basic for Applications, the OLE types look strangely familiar to Basic programmers. Here is a table of OLE types with comparisons of Basic and C++ types. </p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>OLE Type</b></td>
<td class=label width=36%><b>Basic Type</b></td>
<td class=label width=35%><b>C++ Type</b></td>
</tr>
<tr valign=top>
<td width=29%>BYTE</td>
<td width=36%>Byte</td>
<td width=35%>unsigned char</td>
</tr>
<tr valign=top>
<td width=29%>SHORT</td>
<td width=36%>Integer</td>
<td width=35%>short</td>
</tr>
<tr valign=top>
<td width=29%>LONG</td>
<td width=36%>Long</td>
<td width=35%>long</td>
</tr>
<tr valign=top>
<td width=29%>FLOAT</td>
<td width=36%>Single</td>
<td width=35%>float</td>
</tr>
<tr valign=top>
<td width=29%>double</td>
<td width=36%>Double</td>
<td width=35%>double</td>
</tr>
<tr valign=top>
<td width=29%>CURRENCY</td>
<td width=36%>Currency</td>
<td width=35%>__int64 </td>
</tr>
<tr valign=top>
<td width=29%>HRESULT</td>
<td width=36%>none</td>
<td width=35%>long</td>
</tr>
<tr valign=top>
<td width=29%>VARIANT</td>
<td width=36%>Variant</td>
<td width=35%>none</td>
</tr>
<tr valign=top>
<td width=29%>IDispatch*</td>
<td width=36%>Object</td>
<td width=35%>none</td>
</tr>
<tr valign=top>
<td width=29%>IUnknown*</td>
<td width=36%>none</td>
<td width=35%>none</td>
</tr>
<tr valign=top>
<td width=29%>SAFEARRAY</td>
<td width=36%>array syntax</td>
<td width=35%>none</td>
</tr>
</table><br>
<p>
The OLETYPE.H include file contains classes or <b>typedef</b>s that create Basic type names out of the corresponding C++ and OLE types. OLETYPE.ODL has similar declarations for Object Description Language. If you add new modules to VBUTIL (and that's what it's for), you should include OLETYPE.H at the top of each new module file. OLETYPE.ODL is already included in VBUTIL.ODL. </p>
<p>
Because the type definitions work out differently for each type, we'll have to look at them on a case-by-case basis. </p>
<h3>Numeric Types—Byte, Integer, Long, Single, and Double</h3>
<p>
Basic calls them Byte, Integer, Long, Single, and Double. C++ calls them unsigned char, short, long, float, and double. Windows calls them BYTE, SHORT, LONG, FLOAT, and double (really), but rarely uses the floating point types at all. OLE usually calls them by their Windows names. If you've seen one (and you will), you've seen them all. There is one inconsistency to note: Byte is an unsigned type, whereas Integer and Long are signed. Here are the typedefs to implement our Basic names. </p>
<pre><code>typedef unsigned char&nbsp;&nbsp; Byte;
typedef short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer;
typedef long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Long;
typedef float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Single;
typedef double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Double;
</code></pre>
<p>
Do you notice a conspicuous absence here? There is no type for the system word size (what C++ calls int). Basic has no such concept—to the chagrin of Visual Basic 4.0 programmers who wanted to write portable Basic code easily. Probably the reason Basic didn't provide this feature is that OLE doesn't provide it. The OLE automation model assumes that all types are size-specific. This annoyance doesn't affect these articles because we're 32-bit only, but the same problem will come up again when the world starts moving from 32-bit to 64-bit. </p>
<h3>Boolean</h3>
<p>
Basic calls it Boolean. OLE calls it VARIANT_BOOL. I call it Boolean in my C++ code. But it's really just a C++ short variable. In other words, C++ can't tell the difference between a Basic Boolean and a Basic Integer. This will create some difficulties (later in Article 4) when we try to overload constructors and other member functions for the C++ Variant type. </p>
<p>
You might think that a variable with only two possible values would be the one area where two languages couldn't possibly find anything significant to disagree about. Wrong! Basic and C++ have different ideas on the subject, and you can get caught with annoying bugs if you don't understand the differences. </p>
<p>
The Windows BOOL type is an int (32 bits in 32-bit mode), defined like this in WINDEF.H: </p>
<pre><code>typedef int&nbsp; BOOL;
</code></pre>
<p>
The Basic Boolean type is a short (always 16 bits). You might argue that it would make more sense to make a Boolean type a byte (for more efficient storage) or an int (for more efficient run-time processing). But for whatever reason, OLE defines VARIANT_BOOL like this in OAIDL.H:</p>
<pre><code>typedef short&nbsp;&nbsp; VARIANT_BOOL;
</code></pre>
<p>
There's more to this difference than size. Windows defines the following values for TRUE and FALSE:</p>
<pre><code>#define TRUE&nbsp; 1
#define FALSE 0
</code></pre>
<p>
OLE defines its own Boolean constants: </p>
<pre><code>#define VARIANT_TRUE&nbsp; ((VARIANT_BOOL)0xffff)
#define VARIANT_FALSE ((VARIANT_BOOL)0)
</code></pre>
<p>
Basic uses the OLE versions, although it spells them differently. For your convenience, I provide versions with Basic spelling in VARIANT.H: </p>
<pre><code>typedef VARIANT_BOOL   Boolean;
const Boolean True = VARIANT_TRUE;
const Boolean False = VARIANT_FALSE;
</code></pre>
<p>
I haven't checked every possible language, but C-based languages are the only ones I know of that use 1 as the constant value of truth. Most languages use -1. This doesn't make much difference on the C++ side, and most Basic programmers already know how to handle the differences on the Basic side. </p>
<p>
For now, Boolean, True, and False are more language-independent than BOOL, TRUE, and FALSE. C++ is supposed to add an intrinsic Boolean type called "bool," but it hasn't appeared in the compiler I use, and when it does, I'm not sure it will be compatible with OLE's Boolean type anyway. Most C and C++ representations of Boolean map to the int or to unsigned char rather than to short. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The MIDL compiler that will eventually replace MKTYPLIB (as described in Article 1) has an intrinsic Boolean type that is an unsigned char. WINTYPE.ODL conditionally defines Boolean (note the initial capital) to VARIANT_BOOL so that when MIDL becomes available, Boolean will have the size used by OLE and Visual Basic. </p>
<h3>Currency</h3>
<p>
Basic calls it Currency. OLE calls it CURRENCY. The Microsoft Foundation Classes call it <b>COleCurrency</b>. But what it really is is a 64-bit integer. OLE represents it something like this (with extra typedefs and macros cleaned out):</p>
<pre><code>union CURRENCY {
 &nbsp;&nbsp; struct {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long Lo;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long Hi;
 &nbsp;&nbsp; };
 &nbsp;&nbsp; LONGLONG int64;&nbsp;&nbsp; // __int64 in Microsoft Visual C++
};
</code></pre>
<p>
This allows you to address the data all in one chunk with the <i>int64 </i>field, or in 32-bit pieces with the <i>Lo </i>and <i>Hi </i>fields. In Microsoft Visual C++, LONGLONG is a <b>typedef</b> to the nonstandard intrinsic type <b>__int64</b>. Other compiler vendors may not provide this type or may call it something different. A Borland representative told me their compiler doesn't support a 64-bit integer type. I don't know about other vendors. If your compiler has the same type with a different name, you can typedef LONGLONG to your compiler's intrinsic type and everything will be fine. </p>
<p>
Visual Basic already provides good support for the currency type. I doubt that many people will want to write C++ code to enhance it, so this series isn't going to say much more about Currency. I could be wrong. If you really want to work with Currency in C++, take a look at MFC's <b>COleVariant</b> class. Unlike my Variant type (see Article 4 in this series), theirs encapsulates currency through the <b>COleCurrency</b> class and provides a lot of support for handling currency variables inside or outside of variants. </p>
<h3>Date</h3>
<p>
Visual Basic calls it Date (introduced in Version 4). OLE calls it DATE. MFC calls it <b>COleDateTime</b>. But it's really just a double. As with other typedefed types, C++ can't tell the difference between a DATE and double. I don't have much to say about this type for the same reasons I don't say much about Currency. I think relatively few programmers want to enhance Visual Basic by writing new Date functions. If I'm wrong, go ahead and enhance my Variant type. This is another area where the MFC <b>COleVariant</b> class does a lot more than my Variant type. </p>
<p>
By the way, OLE provides the <b>DosDateTimeToVariantTime</b> and <b>VariantTimeToDosDateTime</b> functions to convert dates. Unfortunately, the MS-DOS® date format these functions work with is accurate to two-second intervals—far less precision than provided by the Date format. If I were going to add full Date functionality, I'd skip the OLE conversion functions and write my own. That's what the <b>COleDateTime</b> class does. </p>
<h3>Errors</h3>
<p>
OLE calls this type HRESULT. To C++, it's a long. Basic doesn't have an intrinsic type that maps directly to an HRESULT, but it does have an <b>Err</b> object that represents the information contained in an HRESULT and more. Again, you'll have some difficulties with this type because C++ can't tell the difference between an HRESULT and a long. Fortunately, you'll rarely need to use this type. </p>
<p>
You can think of an HRESULT as an error code, but it actually goes beyond that. An HRESULT indicates the results of a function. Generally we think of a function result in terms of success or failure. Some functions return 0 to indicate failure and non-zero to indicate success. This corresponds with how people think of Booleans, but it is limiting because functions often have only one kind of success, but many kinds of failure. Therefore, some functions return 0 to indicate success and an error code to indicate failure. An HRESULT carries this further, allowing you to return different kinds of failure and different kinds of success. Negative numbers indicate failure, and they contain several specific bits indicating the kind and severity of the error. Positive numbers (including zero) indicate success. Usually functions return the <b>S_OK</b> macro, which represents zero, but if a function can succeed in various ways, it might return some other positive success code. </p>
<h3>String</h3>
<p>
Basic calls it String. OLE calls it BSTR. C++ doesn't know anything about this concept, but the <b>String</b> class that we'll introduce in Article 3 of this series will make it easy. OleType.H includes BString.H, which defines the <b>String</b> class. </p>
<h3>Variant</h3>
<p>
Basic calls it Variant. OLE calls it VARIANT. MFC calls it <b>COleVariant</b>. It's basically just a structure containing a union. The whole thing takes up 64 bits. I'll wrap the native structure up in the <b>Variant</b> class in Article 4 of this series. OleType.H includes Variant.H, which defines the <b>Variant</b> class. </p>
<h3>IDispatch and IUnknown Pointers</h3>
<p>
Basic calls them <b>Object</b>, <b>Control</b>, <b>Form</b>, and <b>Collection</b>, or it may recognize them through an object-specific name. Whatever you call your objects, Visual Basic sees them as <b>IDispatch</b> pointers. <b>IDispatch</b> pointers are a specific type of <b>IUnknown</b> pointers. Unfortunately, I'm not going to get around to them in this series. Creating objects is a subject well beyond the scope of these articles, but using objects created by others—such as Visual Basic programs calling our C++ DLL functions—should be covered. I'm sorry I didn't have time to discuss this subject. </p>
<h3>Arrays</h3>
<p>
A Visual Basic array is actually what OLE calls a SAFEARRAY structure. We'll be encapsulating this concept in Article 5 of this series. For now, let's just say that an array is a subtype that can contain multiple instances of any other subtype. You can have an array of Integers or of Strings or of Objects or of any of the other standard OLE types. You can even have a Variant containing an array of Variants. OleType.H includes SafeArray.H, which defines the <b>SafeArray</b> template class. </p>
<h2>Using Simple Types</h2>
<p>
When it comes to simple types such as integers and floating point numbers, the Windows application programming interface (API) way is good enough for everyone. You can do it the same way the Window system DLLs do it. The C++ side is as easy as the Basic side. </p>
<h3>Numbers by Value</h3>
<p>
When you pass a number as input to a function, there's not much reason to pass it any way other than by value. The Basic default is to pass by reference, but the C++ default is by value. Inasmuch as you're writing your DLL in C++, you might as well pass by value. Visual Basic won't know the difference if you provide a type library. Here's a typical function passing parameters by value:</p>
<pre><code>Long DLLAPI MakeDWord(Long wHi, Long wLo)
{
 &nbsp; return (wHi &lt;&lt; 16) | (wLo &amp; 0x0000FFFFL);
}
</code></pre>
<p>
The type library entry for this function looks like this: </p>
<pre><code>[
entry("MakeDWord"),
helpstring("Returns a DWord from two passed words"),
]
DWORD WINAPI MakeDWord([in] DWORD dwHi, [in] DWORD dwLo);
</code></pre>
<p>
The code should be clear, but why am I using Windows types, such as DWORD, rather than C types? That's a tricky question. I'm not a big fan of DWORD and WORD rather than unsigned long and unsigned short, but a lot of code you write for DLLs will call the Windows API, which expects Window type names. Using <b>typedef</b>s lets you use the same type names in your C++ and ODL source files. For example, DWORD in the type library actually means signed long, while DWORD in the C++ source means unsigned long. This issue was discussed in Article 1.</p>
<p>
You can see the source for <b>MakeDWord</b> and other similar functions in TOOLS.CPP and TOOLS.H. The Bits button in the Cpp4VB sample program tests these functions. </p>
<p>
Floating-point parameters work the same as integer arguments: </p>
<pre><code>Double DLLAPI DoubleDouble(Double rInput)
{
 &nbsp; return (rInput * 2);
}
</code></pre>
<h3>Numbers by Reference</h3>
<p>
A number passed by reference in Visual Basic is a pointer to a numeric variable in C++. Normally, you use <i>ByRef</i> parameters to receive multiple return values. For example, let's say you wanted a Basic-style wrapper for the Windows API <b>GetCurrentPositionEx</b> function. Every device context (hDC) has a current X/Y coordinate that can be returned by reference in a POINT structure. (The original <b>GetCurrentPosition</b> returned a POINT structure directly, but that doesn't work well in 32-bit, so <b>GetCurrentPositionEx</b> took over.) The C++ prototype looks like this: </p>
<pre><code>BOOL GetCurrentPositionEx(HDC hdc, LPPOINT pPoint);
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;For reasons unknown, the Windows API uses the abbreviation LP or lp to refer to pointers. I believe LP stands for long pointer, which is what everyone else in the world used to call a far pointer. Almost all Windows pointers were far even in the 16-bit world, so there was never any need to qualify them. In the 32-bit world, far (or long) pointers are just a bad dream, but we still see the bizarre LP notation in Windows include files and Windows documentation. Enough is enough. This book uses the old names for types because that's what they are in the include files (LPSTR, LPPOINT, and so on). But we'll just use <i>p </i>rather than <i>lp </i>for the variable names we control (<i>pPoint</i>, <i>pch</i>, and so on). </p>
<p>
You can certainly call <b>GetCurrentPositionEx</b> from Basic, but it's a little awkward. Basic doesn't recognize structures in type libraries, so you have to write both the <b>Declare</b> statement and the UDT on the Basic side. It would be a lot simpler if the original name were reused for a function such as this:</p>
<pre><code>BOOL GetCurrentPosition(HDC hDC, int * pX, int * pY);
</code></pre>
<p>
You could easily write a Basic wrapper for this function, but it's easier (and slightly more efficient) in C++. </p>
<pre><code>BOOL GetCurrentPosition(HDC hDC, int * pX, int * pY)
{
 &nbsp;&nbsp; POINT pt;
 &nbsp;&nbsp; f = GetCurrentPositionEx(hdc, &amp;pt);
 &nbsp;&nbsp; *pX = pt.x;
 &nbsp;&nbsp; *pY = pt.y;
 &nbsp;&nbsp; return (f);
}
</code></pre>
<p>
The ODL version looks like this:</p>
<pre><code>[
entry("GetCurrentPosition"),
helpstring("Returns the X and Y coordinates of a given device context"),
]
BOOL GetCurrentPosition([in] HDC hDC, [out] int * pX, [out] int * pY);
</code></pre>
<p>
The same technique works for floating point numbers, integers of every size, and Boolean variables. </p>
<h3>Structures</h3>
<p>
The first question to ask yourself about structures is, do you really want to use them in your DLL functions? If your target client is Visual Basic, you should certainly think twice. If you're using small API structures such as POINT and RECT, it's probably better to pass coordinates in and receive coordinate results as separate parameters. If you're using large structures in order to pass in or receive chunks of mixed-type data, an object may be a better choice than a structure. </p>
<p>
Remember, you can't use type libraries for your structures or functions that receive them. Everything has to be on the Basic side. The complications increase if you want your structures to contain strings, arrays, or other structures. Although you can use structures in DLLs like the ones in this chapter, you can't use structures reliably in the methods and properties of OLE objects. You have no choice when writing type libraries that map API functions, but if you're writing your own functions, you can design them any way you want to. If you decide, despite my advice, to use structures, here are a few things to remember. </p>
<p>
Basic user-defined types have the same default 4-byte alignment as C++ structures. For example, the following UDT takes 20 bytes:</p>
<pre><code>Type BadBunchOStuff
 &nbsp;&nbsp; bLittle As Byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' One byte data, three bytes padding
 &nbsp;&nbsp; lBig As Long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Four bytes data
 &nbsp;&nbsp; iMedium As Integer&nbsp;&nbsp;&nbsp;&nbsp; ' Two bytes data, two bytes padding
 &nbsp;&nbsp; sText As String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Four bytes data (pointer)
 &nbsp;&nbsp; bMoreLittle As Byte&nbsp;&nbsp;&nbsp; ' One byte data, three bytes padding&nbsp;&nbsp;&nbsp; 
End Type
</code></pre>
<p>
When designing your structures, you'll save a little memory space if you put <b>Integer</b> and <b>Byte</b> fields next to each other. Here's a better way to organize the same data: </p>
<pre><code>Type BunchOStuff
 &nbsp;&nbsp; bLittle As Byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' One byte data
 &nbsp;&nbsp; bMoreLittle As Byte&nbsp;&nbsp;&nbsp; ' One byte data
 &nbsp;&nbsp; iMedium As Integer&nbsp;&nbsp;&nbsp;&nbsp; ' Two bytes data
 &nbsp;&nbsp; lBig As Long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Four bytes data
 &nbsp;&nbsp; sText As String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Four bytes data (pointer)
End Type
</code></pre>
<p>
This one uses only 12 bytes. </p>
<p>
On the C++ side, the data looks like this: </p>
<pre><code>struct BunchOStuff {
 &nbsp;&nbsp; BYTE bLittle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // One byte data
 &nbsp;&nbsp; BYTE bMoreLittle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // One byte data
 &nbsp;&nbsp; SHORT iMedium;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Two bytes data
 &nbsp;&nbsp; LONG lBig;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Four bytes data
 &nbsp;&nbsp; BSTR sText;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Four bytes data (pointer)
};
</code></pre>
<p>
A function that uses this data might look like this:</p>
<pre><code>void GetBunchOStuff(BunchOStuff * pStuff)
{
 &nbsp;&nbsp; pStuff-&gt;bLittle = GetLittle();
 &nbsp;&nbsp; pStuff-&gt;bMoreLittle = GetLittle();
 &nbsp;&nbsp; pStuff-&gt;lBig = GetBig();
 &nbsp;&nbsp; ...
}
</code></pre>
<p>
Because you can't define this function in a type library, you'll need a Basic <b>Declare</b> statement like the following: </p>
<pre><code>Declare Sub GetBunchOStuff Lib "MyDll" (stuff As BunchOStuff)
</code></pre>
<h3>Strings the Windows Way</h3>
<p>
You can write DLL functions to take Windows <i>lpstr</i> parameters like API functions, but this isn't politically correct. I've been known to pass input parameters as LPSTR type as a shortcut, but your Basic clients will consider you extremely rude if you define output parameters this way. Your C++ DLLs are supposed to serve your Basic clients, making everything easy and hiding the messy details. We'll get to the Basic way of doing this with <b>Strings</b> soon, but first let's take a short look at the shortcut for input parameters.</p>
<p>
Assume you want a function that looks like this in Basic:</p>
<pre><code>f = ExistFile("FILE.TMP")
</code></pre>
<p>
The politically correct way to define it in ODL is this:</p>
<pre><code>Boolean ExistFile([in] BSTR sFile);
</code></pre>
<p>
This says Basic will pass in a normal Basic string (a BSTR) and the DLL will accept and handle it as a BSTR, as we'll discuss in Article 3. Basic won't do any Unicode translation, but your DLL will have to. It's kind of a messy business, but we'll provide a <b>String</b> class to clean things up. </p>
<p>
The other alternative is to define the function like this in ODL:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boolean WINAPI ExistFile([in] LPSTR lpFileName);
</code></pre>
<p>
In this case, Basic will do the same Unicode conversion it does for Windows API functions. The string is originally Unicode, but Basic makes an ANSI copy of it for the C++ side. Because this function doesn't need to pass anything back, the copy is perfectly adequate for the DLL. The function can be implemented like this: </p>
<pre><code>Boolean DLLAPI ExistFile(LPCSTR szFile)
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; return ((szFile == NULL) ? FALSE : !_access(szFile, 0));
}
</code></pre>
<p>
This is one of those rare functions that is actually easier to implement in C++ than in Basic. Notice that it uses the constant version LPCSTR to enforce that the string will be used only for input and never modified. </p>
<p>
The <b>ExistFile</b> function is tested by the Exist File button in the sample program. </p>
<h3>Arrays, Typeless Variables, and Pointers</h3>
<p>
Don't do it. We have to learn to deal with such things (arrays, that is) in the Windows API way when mapping system DLLs to type libraries. The system DLLs are what they are. But when you write your own DLLs, you shouldn't impose this inconvenience on your clients. </p>
<p>
Instead of API-style arrays, use SafeArrays, as described in Article 5. Your clients can pass arrays naturally:</p>
<pre><code>c = CountArray(ai())
</code></pre>
<p>
This is much better than the unnatural way you have to pass API arrays by passing the first element: </p>
<pre><code>c = CountApiArray(ai(0))
</code></pre>
<p>
Besides, you get the better index protection of the SafeArray type. </p>
<p>
Typeless variables are usually represented in C++ as void pointers (<b>void *</b>). You have to do a lot of type-casting to get such functions to compile without warnings. OLE offers Variants as a safer (although less efficient) way to do typeless variables. Article 4 describes Variants. </p>
<p>
Basically, you destroy Basic's type safety net when you write C++ functions that take void pointers or any other kind of pointer. You can usually figure out a hack to write a <b>Declare</b> or type library entry for such functions, but you'll have to do it without my help. </p>
</BODY>
</HTML>
