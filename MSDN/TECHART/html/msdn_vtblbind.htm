<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Taking Advantage of the OLE Automation Marshaller</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_vtblbind"></a></sup>Taking Advantage of the OLE Automation Marshaller</h1>
<p>
Microsoft Corporation</p>
<p>
October 18, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4501">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files for the VTBLBIND sample application.</a></p>
<h2>Abstract</h2>
<p>
This sample, and accompanying article, will illustrate how to implement and call OLE Automation interfaces that support VTBL binding by providing a type library and by using the marshaller provided by OLE Automation.</p>
<h2>Overview</h2>
<p>
The VTBLBIND samples, CLIENT and SERVER, demonstrate the use of the OLE Automation marshaller to marshall Component Object Model (COM) interfaces that you define.</p>
<p>
A COM interface can be marshalled using standard marshalling or custom marshalling. In standard marshalling, proxy and stub code will marshall and unmarshall the parameters and/or return values of an interface method call between processes. The Microsoft Interface Definition Language (MIDL) compiler can be used to generate proxy and stub code to standard-marshall a COM interface.</p>
<p>
In custom marshalling, the object will implement <b>IMarshal</b> to marshall the entire object to another process space. See the COM Specification (MSDN Library, Specifications) and Chapter 6 of Kraig Brockschmidt's <i>Inside OLE, Second Edition</i> (MSDN Library, Books), for further information on custom marshalling.</p>
<p>
An interface can also be standard-marshalled by a marshaller provided by OLE Automation. This OLE Automation marshaller can marshall any custom interface that is described using a type library and that uses a limited set of data types called the OLE Automation compatible types. This marshaller implements OLE Automation's VTBL binding. VTBL binding is the mechanism used by any COM interface client to bind to the implementation of the COM interface in the server. OLE Automation uses this term to distinguish it from other binding mechanisms that it supports, such as late binding and ID binding.</p>
<h2>Building the Samples</h2>
<p>
The samples presented here require that the Win32® Software Development Kit (SDK) be installed. Be sure that your MSTOOLS environment variable points to the root of your Win32 SDK directory (typically C:\MSTOOLS).
<ul type=disc>
<li>
These samples rely on the COMMON sample found in the SAMPLES\OLE\COMMON directory of the Win32 SDK. Before attempting to build the other samples, compile COMMON first.<br><br></li>
<li>
The MAKEFILE in the SERVER directory will run the MKTYPLIB.EXE tool, which will compile SERVER.ODL into the SERVER.TLB type library. MKTYPLIB.EXE will also generate the IVtblServer.h file, which contains a C/C++ declaration of the custom interface and the graphical user interface IDs (GUIDs) of the interface and the server. It will then create SERVER.EXE.<br><br></li>
<li>
The client will use the information in IVtblServer.h to create the server instance and to call methods in the IVtblServer interface. After building SERVER.EXE<b>,</b> copy IVtblServer.h to the \CLIENT directory.<br><br></li>
<li>
The MAKEFILE in the \CLIENT directory will create CLIENT.EXE.<br><br></li>
<li>
NMAKE, with no options, will build a 32-bit ANSI sample that will run on Windows® 95 or Windows NT™ 3.5<i>x</i>.<br><br></li>
<li>
NMAKE HOST=NT will build a 32-bit Unicode™ sample that will run only on Windows NT.<br><br></li>
<li>
DEBUG=1 and DEBUG=2 can be used to build debug and non-debug versions.</li>
</ul>
<h2>Running the Samples</h2>
<ol>
<li>
Register the server by running SERVER.EXE /REGSERVER.<br><br></li>
<li>
Run CLIENT.EXE in the client directory. CLIENT.EXE will use <b>CoCreateInstance</b> to create an instance of SERVER.EXE. It will then use <b>IUnknown::QueryInterface</b> to get the <b>IVtblServer</b> custom interface from the server. <b>IVtblServer::put_Message</b> is called to pass the server a string that the server will display later. <b>IVtblServer::DisplayMessage</b> is called with the coordinates at which the string is to be displayed and the number of times the string is to be displayed. The server will display the string "Hello, Universe" seven times, starting at coordinate (5, 3), as specified by the client. The client will then pause for ten seconds and release the server. The server will shut down when its last reference is released. Finally, the client will shut down.</li>
</ol>
<h2>Key Points</h2>
<p>
This sample shows how to create a COM interface that can be standard-marshalled by OLE Automation, how to create a type library that describes the interface, and how to register the interface so that OLE Automation will marshall it. </p>
<p>
Marshalling code for COM interfaces is usually generated using the MIDL compiler. However, this marshalling code doesn't support 16-to-16-bit and 16-to-32-bit interoperability. (See the Win32 SDK online documentation, "Interoperability Using Custom Interfaces [either MIDL or Manually Written Marshalling]" for a description of this limitation.)</p>
<p>
The OLE Automation marshaller supports 16-to-16-bit and 16-to-32-bit interoperability for local servers (.EXE servers) and can be used as a workaround to the interoperability problem if you are interested in 16-bit support. However, the types that can be used in interfaces that can be marshalled by the OLE Automation marshaller are restricted to the OLE-Automation–compatible types discussed below. In addition, because the OLE Automation marshaller is generic, it is not as efficient as the marshalling code generated by MIDL.</p>
<h2>Architecture</h2>
<h3>Server Architecture</h3>
<p>
The following steps describe the creation of an interface that can be marshalled by the OLE Automation marshaller.</p>
<h4>Step 1</h4>
<p>
The server describes the custom interface in the Object Description Language (ODL) in SERVER.ODL. For example, <b>IVtblServer</b> is described as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;[
 &nbsp;&nbsp;&nbsp;&nbsp; uuid(2ED17402-F80F-11ce-8161-00AA0060D733),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IID_IVtblServer
 &nbsp;&nbsp;&nbsp;&nbsp; oleautomation
 &nbsp;&nbsp; ]
 &nbsp;&nbsp; interface IVtblServer : IUnknown
 &nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT put_Message([in] BSTR Message);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT get_Message([out] BSTR *pMessage);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT DisplayMessage([in] SAFEARRAY(unsigned char) Coordinate,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] short Times);
 &nbsp;&nbsp; }
</code></pre>
<p>
<b>put_Message</b> is used to pass a string to be displayed to the server.</p>
<p>
<b>DisplayMessage</b> will display the string "Times times" at the coordinate (COORD structure) passed using the SAFEARRAY(unsigned char).</p>
<p>
<b>get_Message</b> will return the string that will be displayed by the server.</p>
<p>
The <b>IVtblServer</b> custom interface derives from <b>IUnknown</b> and has three methods. The <i>uuid</i> attribute specifies the interface ID (IID) of the interface. The <i>oleautomation</i> attribute specifies that the interface can be marshalled by the marshaller provided by OLE Automation.</p>
<p>
The ODL syntax is described in Chapter 7 of <i>OLE Programmer's Reference, Volume 2</i>, <i>second edition </i>(see <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_mspmsdn">
</object><a href=JavaScript:alink_1.Click()>"Microsoft Press Technical Reference Books"</a> in the MSDN Library for ordering information)<i>.</i></p>
<p>
The types that can be used by the custom interface are restricted to OLE Automation compatible types found in the following table.</p>
<p class=label>
<b>OLE Automation Compatible Types</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Type</b></td>
<td class=label width=74%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=26%><b>short</b></td>
<td width=74%>16-bit signed integer.</td>
</tr>
<tr valign=top>
<td width=26%><b>long</b></td>
<td width=74%>32-bit signed integer.</td>
</tr>
<tr valign=top>
<td width=26%><b>float</b></td>
<td width=74%>32-bit IEEE floating-point number.</td>
</tr>
<tr valign=top>
<td width=26%><b>double</b></td>
<td width=74%>64-bit IEEE floating-point number.</td>
</tr>
<tr valign=top>
<td width=26%><b>CURRENCY</b></td>
<td width=74%>8-byte fixed-point number.</td>
</tr>
<tr valign=top>
<td width=26%><b>DATE</b></td>
<td width=74%>64-bit floating-point fractional number of days since December 30, 1899.</td>
</tr>
<tr valign=top>
<td width=26%><b>BSTR</b></td>
<td width=74%>Length-prefixed string. Strings must be passed using this type. BSTRs must be created and manipulated using the functions described in <i>OLE Programmer's Reference, Vol. 2</i>.</td>
</tr>
<tr valign=top>
<td width=26%><b>Boolean</b></td>
<td width=74%>Data item that can have the values True or False. The size maps to VARIANT_BOOL.</td>
</tr>
<tr valign=top>
<td width=26%><b>VARIANT</b></td>
<td width=74%>VARIANT type. This VARIANT can contain any type marked with a [V] in the VARENUM enumeration in oaidl.h. VARIANTs that contain other types cannot be marshalled by OLE Automation.</td>
</tr>
<tr valign=top>
<td width=26%><b>SCODE</b></td>
<td width=74%>OLE SCODE.</td>
</tr>
<tr valign=top>
<td width=26%><b>unsigned char</b></td>
<td width=74%>Unsigned 8-bit data item. A SAFEARRAY(unsigned char) can be used to pass binary data.</td>
</tr>
<tr valign=top>
<td width=26%><b>IUnknown*</b></td>
<td width=74%><b>IUnknown</b> interface pointer. Any OLE interface can be passed using this type.</td>
</tr>
<tr valign=top>
<td width=26%><b>IDispatch*</b></td>
<td width=74%><b>IDispatch</b> interface pointer.</td>
</tr>
<tr valign=top>
<td width=26%><b>SAFEARRAY(<i>type)</i></b></td>
<td width=74%>Array of <i>type. type </i>can be any of the types above this row. <i>type</i> cannot be any of the types below this row. SAFEARRAYS must be created and manipulated using the SAFEARRAY functions described in the <i>OLE Programmer's Reference, Vol. 2.</i></td>
</tr>
<tr valign=top>
<td width=26%><b>short*</b></td>
<td width=74%>Pointer to short. Can be used to pass a short by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>long*</b></td>
<td width=74%>Pointer to long. Can be used to pass a long by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>float*</b></td>
<td width=74%>Pointer to float. Can be used to pass a float by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>double*</b></td>
<td width=74%>Pointer to double. Can be used to pass a double by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>CURRENCY*</b></td>
<td width=74%>Pointer to CURRENCY. Can be used to pass a CURRENCY by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>DATE*</b></td>
<td width=74%>Pointer to DATE. Can be used to pass a DATE by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>BSTR*</b></td>
<td width=74%>Pointer to BSTR. Can be used to pass a BSTR by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>boolean*</b></td>
<td width=74%>Pointer to boolean. Can be used to pass a boolean by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>VARIANT*</b></td>
<td width=74%>Pointer to variant. Can be used to pass a VARIANT by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>SCODE*</b></td>
<td width=74%>Pointer to SCODE. Can be used to pass an SCODE by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>unsigned char*</b></td>
<td width=74%>Pointer to unsigned char. Can be used to pass an unsigned char by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>IUnknown**</b></td>
<td width=74%>Pointer to <b>IUnknown*</b>. Can be used to pass an <b>IUnknown</b> interface by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>IDispatch**</b></td>
<td width=74%>Pointer to <b>IDispatch*</b>. Can be used to pass an <b>IDispatch</b> interface by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>SAFEARRAY(<i>type</i>) *</b></td>
<td width=74%>Pointer to SAFEARRAY. Can be used to pass a SAFEARRAY by reference.</td>
</tr>
<tr valign=top>
<td width=26%><b>HRESULT</b></td>
<td width=74%>Return type used for reporting error information in interfaces. Can only be used as a return type. Use SCODE for parameter types. SCODE and HRESULT are the same in Win32.</td>
</tr>
</table><br>
<p>
The marshaller provided by OLE Automation cannot understand structures. Structures can be passed using a SAFEARRAY(unsigned char). The sample demonstrates how a COORD structure is passed in this manner. Also see the article <a href="http://www.microsoft.com/kb/articles/q122/2/89.htm">"Passing Structures in OLE Automation"</a> (http://www.microsoft.com/kb/articles/q122/2/89.htm) for a discussion of passing structures.</p>
<p>
The <b>coclass</b> entry in SERVER.ODL describes the server object and the interfaces that it supports. The <i>uuid</i> attribute of the <b>coclass</b> is the CLSID of the server and is used in the <b>CoCreateInstance</b> call in the client to create the server.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;[
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uuid(2ED17401-F80F-11ce-8161-00AA0060D733)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // CLSID_VtblServer
 &nbsp;&nbsp; ]
 &nbsp;&nbsp; coclass VtblServer
 &nbsp;&nbsp; {&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [default] interface IVtblServer;
 &nbsp;&nbsp; }
</code></pre>
<p>
SERVER.ODL is compiled by MKTYPLIB.EXE to produce the SERVER.TLB type library and the IVtblServer.h interface declaration file.</p>
<h4>Step 2</h4>
<p>
SERVER.H declares <b>CVtblServer</b>, which implements <b>IVtblServer</b> and <b>CVtblServerCF</b>, which in turn implements <b>IClassFactory</b>.</p>
<h4>Step 3</h4>
<p>
SERVER.CPP implements <b>CVtblServer</b> and <b>CVtblServerCF</b>.</p>
<h4>Step 4</h4>
<p>
The server is a self-registering COM server (using the Self-Registering Server specification defined originally by the OLE Controls specification). The server will register its CLSID, full path, type library, and the custom interface in the system registry when it is run with the /RegServer command-line argument. The type library and custom interface are registered as follows by the <b>RegisterTypeLib</b> OLE function.</p>
<p>
The custom interface, <b>IVtblServer</b>, is registered as follows:</p>
<pre><code>HKEY_CLASSES_ROOT\Interface\{2ED17402-F80F-11ce-8161-00AA0060D733} = IVtblServer
HKEY_CLASSES_ROOT\Interface\{2ED17402-F80F-11ce-8161-00AA0060D733}\
 &nbsp; TypeLib = {2ED17400-F80F-11ce-8161-00AA0060D733}
HKEY_CLASSES_ROOT\Interface\{2ED17402-F80F-11ce-8161-00AA0060D733}\
 &nbsp; ProxyStubClsid = {00020424-0000-0000-C000-000000000046}
HKEY_CLASSES_ROOT\Interface\{2ED17402-F80F-11ce-8161-00AA0060D733}\
 &nbsp; ProxyStubClsid32 = {00020424-0000-0000-C000-000000000046}
</code></pre>
<ul type=disc>
<li>
{2ED17402-F80F-11ce-8161-00AA0060D733} corresponds to the IID of the custom interface. {00020424-0000-0000-C000-000000000046} is the CLSID of the OLE Automation marshaller that will marshall this custom interface. This is a CLSID that is provided by OLE and was not generated by the sample.<br><br></li>
<li>
The TypeLib key is used to point to the GUID of the type library that describes this custom interface. When the custom interface is marshalled, OLE will look up its interface registration in the system registry using the IID.<br><br></li>
<li>
The ProxyStubClsid(32) key will point to an object that will marshall the interface. OLE will create this object and ask it to marshall the interface. In this case, OLE will create the OLE Automation marshaller. The OLE Automation marshaller will use the TypeLib key to obtain the type library that describes the interface and will marshall the interface based on this type information.<br><br></li>
<li>
The CLSID that is specified by ProxyStubClsid(32) must <b>always</b> be {00020424-0000-0000-C000-000000000046} for an interface that is to be marshalled by the OLE Automation marshaller.</li>
</ul>
<p>
The type library is registered as follows:</p>
<pre><code>HKEY_CLASSES_ROOT\TypeLib\{2ED17400-F80F-11ce-8161-00AA0060D733}
HKEY_CLASSES_ROOT\TypeLib\{2ED17400-F80F-11ce-8161-00AA0060D733}\
 &nbsp; 1.0 = VtblServer 1.0 Type Library
HKEY_CLASSES_ROOT\TypeLib\{2ED17400-F80F-11ce-8161-00AA0060D733}\
 &nbsp; 1.0\0\win32 = server.tlb
</code></pre>
<ul type=disc>
<li>
{2ED17400-F80F-11ce-8161-00AA0060D733} is the GUID of the type library.<br><br></li>
<li>
\1.0\0\win32 corresponds to version 1.0 and locale ID 0 (language neutral) of the type library on the Win32 platform. The version and locale IDs correspond to the version and lcid attributes in the SERVER.ODL file. The locale ID is important for late binding in OLE automation and is not important for VTBL binding. The full path of SERVER.TLB is registered.</li>
</ul>
<h3>Client Architecture</h3>
<p>
The following steps describe the creation of a client that can use the custom interface:
<ol>
<li>
<b>IVtblServer.h</b>, generated by MKTYPLIB.EXE in the server project, is copied into the client's directory. This file contains the CLSID of the server and the IID of the <b>IVtblServer</b> custom interface.<br><br></li>
<li>
In CLIENT.CPP, the client creates an instance of the server using <b>CoCreateInstance</b> and the CLSID of the server from IVtblServer.h. The custom interface is then obtained using <b>IUnknown::QueryInterface</b> and the IID from IVtblServer.h. <b>IVtblServer::put_Message</b> is called. A string must be passed as a BSTR. <b>SysAllocString</b> is used to allocate the BSTR that is passed to <b>::put_Message</b>. <b>IVtblServer::DisplayMessage</b> is used to pass a COORD structure and a short. The COORD structure is passed in a SAFEARRAY(unsigned char) because the OLE Automation marshaller cannot understand structures.</li>
</ol>
<h4>GUID generation</h4>
<p>
This sample required generation of three GUIDs using the GUIDGEN.EXE tool: the CLSID of the server, the GUID of the type library, and the IID of the custom interface. </p>
<h2>Related Information</h2>
<p>
In addition to compile-time VTBL binding, OLE Automation also allows run-time ID binding and late binding to the custom interface implementation through another interface called <b>IDispatch</b>. See chapter 1 of <i>OLE Programmer's Reference, Vol. 2, second edition</i>, for details of these binding mechanisms. It is possible for an interface to support VTBL binding, ID binding, and late binding by deriving from <b>IDispatch</b> and by using the dual attribute in the declaration of the interface in the .ODL file. Such an interface is called a <i>dual interface</i>.</p>
<p>
Clients that use VTBL binding to access the dual interface will use the OLE automation marshaller, while clients that use ID binding and late binding will use <b>IDispatch::Invoke</b> to invoke methods in the dual interface. The HELLO (version 2.0) and LINES samples that ship with the Win32 SDK demonstrate the implementation of these dual interfaces. Chapters 1 and 2 of <i>OLE Programmer's Reference, Vol. 2, second edition</i> describe the implementation of dual interfaces.</p>
</BODY>
</HTML>
