<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Developing for the Microsoft SideWinder Game Pad</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_sidewind"></a></sup>Developing for the Microsoft SideWinder Game Pad</h1>
<p>
Microsoft Corporation<br>
June 24, 1996 (updated August 15, 1996)</p>
<h2>Introduction</h2>
<p>
The SideWinder™ game pad introduces some of the most advanced gaming-device technology available on the market. It incorporates digital overdrive for speed, and reliability for enhanced game play. The game pad is simple to use and to write for, contains an 8-position directional pad with 10 buttons, does not drift or require calibration, and polls very quickly. The SideWinder game pad allows you to connect up to four other game pads and includes pass-through mode, so you can plug in the SideWinder 3D Pro joystick. </p>
<p>
Adding support for the SideWinder game pad in your next game is easy.</p>
<h2>Supporting the SideWinder Game Pad</h2>
<p>
SideWinder game pad includes a minidriver that works seamlessly with DirectInput™. To find out if a SideWinder game pad is installed, you don't have to interpret the Registry settings; you simply enumerate the currently selected joystick devices. The following console application code fragment lists the OEM product name for all 16 joysticks:</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;mmsystem.h&gt;
#include &lt;regstr.h&gt;
#include &lt;stdio.h&gt;
// Function prototypes:
MMRESULT joyGetOEMProductName(UINT id, LPTSTR pszName);
//
// --- Main Console application ---
// Enumerates JOYSTICKID 1 to 16, and displays the OEM product name for all 16
// joysticks.&nbsp; Uses the routine joyGetOEMProductName.
//
void main(void)
{
 TCHAR szNameDevice[256];
 UINT i;
 for (i=JOYSTICKID1; i&lt; joyGetNumDevs(); i++)
 {
  printf("JOYSTICKID#%d : ", (i+1));
  if (joyGetOEMProductName(i, (LPTSTR) &amp;szNameDevice[0]) != ERROR_SUCCESS)
  {
 &nbsp; printf("None\n");
  }
  else
  {
 &nbsp; printf("%s\n", szNameDevice);
  }
 }
}
// ----------------------------------------------------------------------------
//
// Function: joyGetOEMProductName
// Parameters: UINT id&nbsp; - Joystick ID from JOYSTICKID1 to JOYSTICK16
//&nbsp;&nbsp;&nbsp; TCHAR * pszName - String storage for the OEM Product name
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for the selected Joystick device specified
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; by the parameter "id"
//
// Returns:&nbsp; If Successful, pszName contains OEM product name for JOYSTICKID
//&nbsp;&nbsp;&nbsp; else Failure, returns MMRESULT error code, and pszName is cleared.
//
// Comments:
// JOYSTICKID1 to JOYSTICKID16 is zero-based, while the registry entries are
//&nbsp; 1-based.&nbsp; This routine expects the parameter "id" to be using JOYSTICKID1
//&nbsp; to JOYSTICKID16, which are defined in the multimedia header file mmsystem.h.
//&nbsp; The following registry keys/values are defined in the header file 
//&nbsp; regstr.h:
//&nbsp;&nbsp; REGSTR_PATH_JOYCONFIG
//&nbsp;&nbsp; REGSTR_PATH_JOYOEM
//&nbsp;&nbsp; REGSTR_VAL_JOYOEMNAME 
// 
// ----------------------------------------------------------------------------
MMRESULT joyGetOEMProductName(UINT id, TCHAR * pszName)
{
 JOYCAPS JoyCaps;
 TCHAR szKey[256];
 TCHAR szValue[256];
 UCHAR szOEMKey[256];
 HKEY hKey;
 DWORD dwcb;
 LONG lr;
// Note: JOYSTICKID1-16 is zero-based, registry entries for VJOYD are 1-based.
 id++;&nbsp; 
 if (id &gt; joyGetNumDevs() ) return JOYERR_NOCANDO;
// Open .. MediaResources\CurrentJoystickSettings
 joyGetDevCaps((id-1), &amp;JoyCaps, sizeof(JoyCaps));
 sprintf(szKey,
 &nbsp; "%s\\%s\\%s",
 &nbsp; REGSTR_PATH_JOYCONFIG,
 &nbsp; JoyCaps.szRegKey,
 &nbsp; REGSTR_KEY_JOYCURR);
 lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPTSTR) &amp;szKey, 0, KEY_ALL_ACCESS, &amp;hKey);
 if (lr != ERROR_SUCCESS) return JOYERR_NOCANDO;
// Get OEM Key name. If the query is unsuccesful, then Null the string and 
// return&nbsp; an Error.
 dwcb = sizeof(szOEMKey);
 sprintf(szValue, "Joystick%d%s", id, REGSTR_VAL_JOYOEMNAME);
 lr = RegQueryValueEx(hKey, szValue, 0, 0, (LPBYTE) &amp;szOEMKey, (LPDWORD) &amp;dwcb);
 RegCloseKey(hKey); if (lr != ERROR_SUCCESS)
 {
  *pszName = 0;
  return JOYERR_NOCANDO;
 }
// Open OEM Key from ...MediaProperties.
 sprintf(szKey, "%s\\%s", REGSTR_PATH_JOYOEM, szOEMKey);
 lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_ALL_ACCESS, &amp;hKey);
 if (lr != ERROR_SUCCESS) return JOYERR_NOCANDO;
// Get OEM Name.
 dwcb = sizeof(szValue);
 lr = RegQueryValueEx( hKey,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGSTR_VAL_JOYOEMNAME,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPBYTE) pszName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPDWORD) &amp;dwcb);
 RegCloseKey(hKey);
 if (lr != ERROR_SUCCESS)
  return JOYERR_NOCANDO;
 else
  return JOYERR_NOERROR;
}
</code></pre>
<p>
<b>Tip:</b> Don't forget to link your code with winmm.lib. </p>
<p>
To determine whether the SideWinder game pad is currently selected, do a string compare of the OEM product name—which is obtained from the <b>joyGetOEMProductName</b> routine—with the string "Microsoft SideWinder game pad". </p>
<p>
The SideWinder game pad has a directional pad (d-pad) and 10 buttons (A, B, C, X, Y, Z, left trigger, right trigger, Macro, and Start). All of the game pad's capabilities are found in the JOYCAPS structure, shown in the following sample code.</p>
<pre><code>#include &lt;mmsystem.h&gt;
JOYCAPS jc;
. . .
MMRESULT ret = joyGetDevCaps(JOYSTICKID1, &amp;jc, sizeof(jc));
. . .
</code></pre>
<p>
The following JOYCAPS members sample code shows the game pad control capabilities. </p>
<p class=label>
<b>SideWinder Game Pad Control Capability</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>JOYCAPS Member</b></td>
<td class=label width=50%><b>Control Capability</b></td>
</tr>
<tr valign=top>
<td width=50%>jc.wXmin = 0</td>
<td width=50%>Minimum d-Pad x axis</td>
</tr>
<tr valign=top>
<td width=50%>jc.wXmax = 65535</td>
<td width=50%>Maximum d-Pad x axis</td>
</tr>
<tr valign=top>
<td width=50%>jc.wYmin = 0</td>
<td width=50%>Minimum d-Pad y axis</td>
</tr>
<tr valign=top>
<td width=50%>jc.wYmax = 65535</td>
<td width=50%>Maximum d-Pad y axis</td>
</tr>
<tr valign=top>
<td width=50%>jc.wZmin = 0</td>
<td width=50%>Not applicable</td>
</tr>
<tr valign=top>
<td width=50%>jc.wZmax = 65535</td>
<td width=50%>Not applicable</td>
</tr>
<tr valign=top>
<td width=50%>jc.wRmin = 0</td>
<td width=50%>Not applicable</td>
</tr>
<tr valign=top>
<td width=50%>jc.wRmax = 65535</td>
<td width=50%>Not applicable</td>
</tr>
<tr valign=top>
<td width=50%>jc.wNumButtons = 10</td>
<td width=50%>10 buttons available</td>
</tr>
</table><br>
<p>
The following table illustrates the button assignments for the SideWinder game pad. </p>
<p class=label>
<b>Button Assignments for SideWinder Game Pad</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=47%><b>JOY_BUTTONx</b></td>
<td class=label width=53%><b>SideWinder Game Pad</b></td>
</tr>
<tr valign=top>
<td width=47%>JOY_BUTTON1</td>
<td width=53%>A</td>
</tr>
<tr valign=top>
<td width=47%>JOY_BUTTON2</td>
<td width=53%>B</td>
</tr>
<tr valign=top>
<td width=47%>JOY_BUTTON3</td>
<td width=53%>C</td>
</tr>
<tr valign=top>
<td width=47%>JOY_BUTTON4</td>
<td width=53%>X</td>
</tr>
<tr valign=top>
<td width=47%>JOY_BUTTON5</td>
<td width=53%>Y</td>
</tr>
<tr valign=top>
<td width=47%>JOY_BUTTON6</td>
<td width=53%>Z</td>
</tr>
<tr valign=top>
<td width=47%>JOY_BUTTON7</td>
<td width=53%>Left trigger</td>
</tr>
<tr valign=top>
<td width=47%>JOY_BUTTON8</td>
<td width=53%>Right trigger</td>
</tr>
<tr valign=top>
<td width=47%>JOY_BUTTON9</td>
<td width=53%>Start</td>
</tr>
<tr valign=top>
<td width=47%>JOY_BUTTON10</td>
<td width=53%>Macro*</td>
</tr>
</table><br>
<p>
*You can use the Microsoft Game Device Profiler (which ships with the SideWinder game pad) to record your favorite moves. To play a game pad macro, press the Macro button, then press the button (A, B, C, X, Y, Z, or one of the triggers) to which you assigned the macro.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The Mode button on the game pad switches the game pad between digital overdrive and pass-through mode; you cannot poll this button.</p>
<h2>Connecting Multiple Game Pads at Once</h2>
<p>
You can connect up to four SideWinder game pads together on a Windows® 95 system using the SideWinder game pad drivers. To connect multiple game pads, daisy-chain them; you don't need a hub device.</p>
<p>
To program your game for multiple game pads, you need to determine how many SideWinder game pads are connected to the user's system. DirectInput supports up to 16 joysticks (using JOYSTICKID1 through JOYSTICKID16). </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;A compiler error using JOYSTICKID3 to JOYSTICKID16 might mean that the joystick IDs aren't defined in the Mmsystem.h header file that was shipped with the SDK. To resolve this error, define the joystick IDs yourself as enumerated types from 1 to 16.</p>
<p>
The following sample code module enumerates the number of joysticks (and game pads) that are currently connected to the user's system.</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;mmsystem.h&gt;
. . .
/****************************************************************************
**
** UINT joyGetNumDevicesConnected(void)
**
** Description : Determine the number of joysticks that are connected.
**
** Parameters : None.
**
** Returns&nbsp; : UINT - Number of devices connected.
**
*****************************************************************************/
UINT joyGetNumDevicesConnected(void)
{
UINT JoyID;
 UINT nDevicesConnected=0;
 JOYINFOEX ji;
 ji.dwSize = sizeof(JOYINFOEX);
 for (JoyID=JOYSTICKID1; JoyID&lt;joyGetNumDevs(); JoyID++)
 {
  if (joyGetPosEx(JoyID, &amp;ji)==JOYERR_NOERROR)
  {
 &nbsp; nDevicesConnected++;
  }
 }
 return nDevicesConnected;
}
</code></pre>
<h2>Polling the Game Pad</h2>
<p>
Polling a typical joystick can take anywhere from 1.2 to nearly 8 milliseconds. That's way too slow for most game developers, who would rather use that time for graphics rendering and play action.</p>
<p>
Because the SideWinder game pad uses digital overdrive technology, you can quickly poll all 10 game pad buttons in a single poll call. This typically takes only 210 microseconds (µs) for 1 game pad, 360 µs when all 4 are connected. This makes it unnecessary to poll each button and axis separately. For details about the game pad buttons, see "Button Assignments for SideWinder Game Pad" above.</p>
<p>
The DirectInput API <b>joyGetPosEx</b> is used to poll the game pad. The following code module demonstrates how this API is used by getting the SideWinder game pad data from DirectInput:</p>
<pre><code>// Reminder: You need mmsystem.h and you must link with winmm.lib.
#include &lt;windows.h&gt;
#include &lt;mmsystem.h&gt;
BOOL GetJoyData(UINT uJoyId, LPJOYINFOEX lpji)
{
 memset(lpji, 0, sizeof(JOYINFOEX)); // For good measure.
 lpji-&gt;dwSize = sizeof(JOYINFOEX);
 // Note: With game pad, it takes no more time to return all 
 // information from the joystick than it does to get only
 // the button states or axis.
 //
 lpji-&gt;dwFlags = JOY_RETURNALL;
 // JoyGetPosEx will fill in the joyinfoex struct with all the
 // joystick information.
 //
 switch(joyGetPosEx(uJoyID, lpji))
 {
  case JOYERR_NOERROR: // No problem.
 &nbsp; break;
  case MMSYSERR_NODRIVER:
 &nbsp; MessageBox( NULL, 
 &nbsp;&nbsp;&nbsp;&nbsp; "The game pad driver is not present.",
 &nbsp;&nbsp;&nbsp;&nbsp; "JOYSTICK ERROR",MB_OK);
 &nbsp; return FALSE;
  case MMSYSERR_INVALPARAM:
 &nbsp; MessageBox( NULL, 
 &nbsp;&nbsp;&nbsp;&nbsp; "An invalid parameter was passed.",
 &nbsp;&nbsp;&nbsp;&nbsp; "JOYSTICK ERROR",MB_OK);
 &nbsp; return FALSE;
  case MMSYSERR_BADDEVICEID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; MessageBox( NULL, 
 &nbsp;&nbsp;&nbsp;&nbsp; "The specified JOYSTICKID identifier is invalid.",
 &nbsp;&nbsp;&nbsp;&nbsp; "JOYSTICK ERROR",MB_OK);
 &nbsp; return FALSE;
  case JOYERR_UNPLUGGED:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; MessageBox( NULL, 
 &nbsp;&nbsp;&nbsp;&nbsp; "Your game pad is unplugged.",
 &nbsp;&nbsp;&nbsp;&nbsp; "JOYSTICK ERROR",MB_OK);
 &nbsp; return FALSE;
  default:
 &nbsp; MessageBox( NULL, 
 &nbsp;&nbsp;&nbsp;&nbsp; "Unknown game pad error.",
 &nbsp;&nbsp;&nbsp;&nbsp; "JOYSTICK ERROR",MB_OK);
 &nbsp; return FALSE;
 }&nbsp;&nbsp; // End of switch.
 return TRUE; 
} // GetJoyData()
. . .
</code></pre>
<h2>Using the Game Pad with MS-DOS Games</h2>
<p>
You can use the SideWinder game pad in an MS-DOS® box under Windows 95. If you run an MS-DOS game under Windows 95, the minidriver provides you with game pad data in digital overdrive mode. </p>
<p class=label>
<b>When Digital Overdrive Is Used</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=65%><b>Environment</b></td>
<td class=label width=35%><b>Digital Overdrive</b></td>
</tr>
<tr valign=top>
<td width=65%>Windows 95 DirectInput</td>
<td width=35%>Yes</td>
</tr>
<tr valign=top>
<td width=65%>DOS box while running Windows 95</td>
<td width=35%>Yes</td>
</tr>
<tr valign=top>
<td width=65%>Pure DOS</td>
<td width=35%>No</td>
</tr>
</table><br>
<h2>Questions and Answers</h2>
<h4>Does the user need to recalibrate the game pad?</h4>
<p>
No, the game pad is self-calibrating.</p>
<h4>Can I write non-Windows 95 games (for example MS-DOS native games) that take advantage of the digital overdrive mode? </h4>
<p>
At the moment, no. If you're interested in doing this, send e-mail to swinddev@microsoft.com.</p>
<h4>How do I support multiple SideWinder game pads?</h4>
<p>
All of the DirectInput functions, except for <b>joyGetNumDevs</b>, require a joystick ID. Up to 16 different joysticks can be supported. The following code module (basically a wrapper for the registry information) creates a data structure (context) of up to 16 possible joystick connections.</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;mmsystem.h&gt;
. . .
typedef struct _CONTEXTINFO
{
 UINT id;&nbsp;&nbsp;&nbsp;&nbsp; // Keep the Joystick ID here.
 char szOEMProductName[128];&nbsp; // OEM product name.
 JOYCAPS JoyCaps;&nbsp;&nbsp; // joystick capabilities.
} CONTEXTINFO;
typedef struct _JOYCONTEXT
{
 UINT nDevices;&nbsp;&nbsp;&nbsp; // Number of joysticks connected (number of CONTEXTINFO).
 CONTEXTINFO ContextInfo[16];&nbsp; // Up to 16 possible joystick device Contexts.
} JOYCONTEXT, *PJOYCONTEXT;
/****************************************************************************
**
** void joyGetContext(PJOYCONTEXT pjc)
**
** Description :&nbsp; Get the current joystick devices context.
** Parameters : PJOYCONTEXT pjc - pointer to JOYCONTEXT structure containing
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the current state of the connected joystick
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; devices (see above declaration).
** Returns&nbsp; : None.
*****************************************************************************/
void joyGetContext(PJOYCONTEXT pjc)
{
 UINT JoyID;
 UINT i=0;
 JOYINFOEX ji;
 ji.dwSize = sizeof(JOYINFOEX);
 for (JoyID=JOYSTICKID1; JoyID&lt;joyGetNumDevs(); JoyID++)
 {
  if (joyGetPosEx(JoyID, &amp;ji)==JOYERR_NOERROR)
  {
 &nbsp; pJoyContext-&gt;ContextInfo[i].id = JoyID;
 &nbsp; joyGetOEMProductName(JoyID, pjc-&gt;ContextInfo[i].szOEMProductName);
 &nbsp; joyGetDevCaps(JoyID, &amp;pjc-&gt;ContextInfo[i].JoyCaps);
 &nbsp; i++;
  }
 }
 pJoyContext-&gt;nDevices= i;
}
</code></pre>
<h4>How can I detect when the game pad settings are changed? </h4>
<p>
The SideWinder family of products has a built-in mechanism for informing the minidrivers of the device status. You can daisy-chain up to four SideWinder game pads together, or you can connect a SideWinder 3D Pro joystick to a SideWinder game pad. When a device's status changes, a notification message is broadcast to all top-level windows, including disabled or invisible windows. This notification can be used to:
<ul type=disc>
<li>
Dynamically change the context of the device or devices that are being used in game play.<br><br></li>
<li>
Interactively inform the user that the game knows about the changes that the user made. </li>
</ul>
<p>
To be notified of changes in joystick settings, the application must first retrieve the message ID of the notification event posted by the DirectInput driver subsystem. To retrieve the message ID, use the <b>RegisterWindowMessage</b> Windows API call, which passes "MSJSTICK_VJOYD_MSGSTR" as its argument:</p>
<pre><code>uMsgId = RegisterWindowMessage("MSJSTICK_VJOYD_MSGSTR" );
</code></pre>
<p>
With the message ID retrieved, you can use the application's windows message queue to check for the occurrence of this notification, as shown in the following example.</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;mmsystem.h&gt;
. . .
UINT uMsgId;
int WinMain(...)
{
// Retrieve message ID that joystick driver subsystem posts.
 uMsgId = RegisterWindowMessage("MSJSTICK_VJOYD_MSGSTR");
 
 // Init Instance, Register Classes, Create Window etc. . . .
// Acquire messages from queue and dispatch messages until a WM_QUIT 
// message is received. 
  while (GetMessage(&amp;msg,NULL, NULL, NULL)) 
 {
 &nbsp; TranslateMessage(&amp;msg);&nbsp; // Translates virtual key codes.
 &nbsp; DispatchMessage(&amp;msg);&nbsp; // Dispatches message to window.
  }
return (msg.wParam);&nbsp;&nbsp; // Returns the value from PostQuitMessage.
}
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
// Did the joystick configuration change?
if(msg == uMsgId)
{
 // YES! 
 // This is where we can inform the user of the changes in joystick
 // configuration and/or update our joystick device context. . . 
 return (DefWindowProc(hWnd, msg, wParam, lParam));
}
// Perform normal message processing. . .
switch (msg)
{
 . . .
}
 return (NULL);
}
</code></pre>
<h4>If I need more information, who do I talk to? </h4>
<p>
Send your question to swinddev@microsoft.com. Make sure you include your name and your company name.</p>
</BODY>
</HTML>
