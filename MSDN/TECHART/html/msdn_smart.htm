<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Calling COM Objects with Smart Interface Pointers</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_smart"></a></sup>Calling COM Objects with Smart Interface Pointers</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
October 6, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4475">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files for the SICLIENT sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article examines using C++ smart interface pointers to access Component Object Model (COM) interfaces. The SIClient sample application is associated with this article.</p>
<h2>Introduction</h2>
<p>
A long time ago, in the dark, dark past, Nigel Thompson wrote a series of technotes on OLE programming called "OLE for Idiots" (MSDN Library, Technical Articles). His shouts of anguish at forgetting to correctly <b>AddRef</b> or <b>Release</b> an interface could be heard up and down the hallway. I thought there had to be some way to use smart pointers in C++ to automatically <b>Release</b> the Component Object Model (COM) components, making the use of COM components much easier. However, I started working on the then-unreleased Microsoft® Foundation Class Library (MFC), where reference counting wasn't a concern because it was hidden inside the MFC classes.</p>
<p>
After writing the article <a href="msdn_micom1.htm">"MFC/COM Objects 8: Revisiting Multiple Inheritance Without MFC,"</a> I decided to look again at using a smart pointer class to simplify using COM interfaces. The results of this investigation didn't live to up my expectations, and I doubt I will use smart interface pointers in my own code. However, your COM project might be different from mine, and my reasons for deciding not to use a COM component might not affect you.</p>
<p>
In this article, I will discuss the following topics:
<ul type=disc>
<li>
Reasons for creating a smart interface pointer class<br><br></li>
<li>
How to build a smart interface pointer class<br><br></li>
<li>
Using the smart interface pointer class<br><br></li>
<li>
Reasons why I don't like the smart interface pointer class</li>
</ul>
<p>
In the source code in this article, I use the prefix <i>pI</i> to refer to a pointer to an interface, such as:</p>
<pre><code>IPersist* pIPersist ;
</code></pre>
<p>
I use the prefix <i>SI</i> to refer to a smart interface pointer:</p>
<pre><code>CSmartInterface&lt;IPersist&gt; SIPersist ;
</code></pre>
<h2>Reasons for Creating a Smart Interface Pointer Class</h2>
<p>
The main reason I wanted a smart interface pointer class was to automatically <b>AddRef</b> and <b>Release</b> the interface pointer.</p>
<p>
When using COM interface pointers, you have to follow several rules. First, never call the <b>delete </b>operator on an interface pointer; call <b>Release</b> instead. The following code is incorrect:</p>
<pre><code>IDraw* pIDraw ;
CoCreateInstance(...,IID,_IDraw, (void**)&amp;pIDraw) ;
pIDraw-&gt;Draw(0,0,100,100) ;
delete pIDraw ; // Don't delete an interface pointer.
</code></pre>
<p>
The following code is correct:</p>
<pre><code>IDraw* pIDraw ;
CoCreateInstance(...,IID,_IDraw, (void**)&amp;pIDraw) ;
pIDraw-&gt;Draw(0,0,100,100) ;
pIDraw-&gt;Release() ;
</code></pre>
<p>
C++ programmers normally <b>delete</b> an object pointer. For this reason, it is easy for C++ programmers to forget and call <b>delete</b> instead of <b>Release</b> on an interface pointer. It is also a hard error for C++ programmers to find, because deleting pointers is so natural.</p>
<p>
The second rule is to call <b>AddRef</b> when creating a new pointer. The following code is incorrect:</p>
<pre><code>IDraw* pIDraw ;
CoCreateInstance(...,IID,_IDraw, (void**)&amp;pIDraw) ;
IDraw* pIDraw2 = pIDraw ;
pIDraw-&gt;Draw() ;
pIDraw-&gt;Release() ; 
pIDraw2-&gt;TurnLeft(5) ;
</code></pre>
<p>
The following is the correct version:</p>
<pre><code>IDraw* pIDraw ;
CoCreateInstance(...,IID,_IDraw, (void**)&amp;pIDraw) ;
IDraw* pIDraw2 = pIDraw ;

<b>pIDraw2-&gt;AddRef() ;</b>

pIDraw-&gt;Draw() ;
pIDraw-&gt;Release() ; 
pIDraw2-&gt;TurnLeft(5) ;
pIDraw-&gt;Release() ;
</code></pre>
<p>
The above example is exceedingly trivial; however, in complicated code, this error can be difficult to track down.</p>
<p>
These are not the only reasons for using a smart interface pointer class. Don Box covers some other reasons in his column in <i>C++ Report</i> (see the bibliography at the end of this article).</p>
<h2>How to Build a Smart Interface Pointer Class</h2>
<p>
A smart interface pointer class starts life the same way as a smart pointer class: by implementing the <b>operator–&gt;</b> for a class. This process is also referred to as <i>delegation</i>. By overriding <b>operator-&gt;</b>, we can make a class that simulates a pointer call. For example:</p>
<pre><code>void Draw()
{
 &nbsp;&nbsp; CSmartInterface&lt;IDraw&gt; SIDraw;
 &nbsp;&nbsp; CoCreateInstance(...,IID,_IDraw, (void**)&amp;SIDraw) ;
 &nbsp;&nbsp; SIDraw-&gt;Draw() ;
}
</code></pre>
<p>
There are several things to notice in the above code. First, a template class is used to implement the smart interface pointer. This makes the smart pointer interface class type-safe. Second, <b>operator&amp;</b> has been overloaded, as we will soon see, to return the address of the pointer contained in <b>CSmartInterface</b>. Third, even though <b>SIDraw</b> isn't a pointer, we use <b>operator-&gt;</b> to call the members in the <b>IDraw</b> interface. Fourth, we don't call <b>Release</b> because <b>CSmartInterface</b> is created on the stack and the destructor will automatically call <b>Release</b>.</p>
<p>
Below are the significant parts of the <b>CSmartInterface</b> header. All of the member functions and operators are defined inline later in the header file.</p>
<pre><code>template &lt;class I&gt;
class CSmartInterface
{
public:
 &nbsp; // Construction
 &nbsp; CSmartInterface(I* pI = NULL) ;

 &nbsp; // Copy Constructor
 &nbsp; CSmartInterface(const CSmartInterface&lt;I&gt;&amp; rSI) ;

 &nbsp; // Destruction
 &nbsp; ~CSmartInterface() ;

 &nbsp; // Assignment from I*
 &nbsp; CSmartInterface&lt;I&gt;&amp; operator=(I* pI) ;

 &nbsp; //
 &nbsp; // Operators
 &nbsp; //

 &nbsp; // Conversion
 &nbsp; operator I*() ;

 &nbsp; // Deref
 &nbsp; I* operator-&gt;() ;

 &nbsp; // Address of
 &nbsp; I** operator&amp;() ;

 &nbsp; // Equality
 &nbsp; BOOL operator==(I* pI) const;

 &nbsp; // Inequality
 &nbsp; BOOL operator!=(I* pI) const;

 &nbsp; // Negation
 &nbsp; BOOL operator!() const ;

  protected:
 &nbsp; I* m_pI ;
};
</code></pre>
<p>
<b>CSmartInterface</b> contains a pointer to an interface. It is defined as a template function in order to be type-safe. The meat of <b>CSmartInterface</b> is overriding <b>operator–&gt;</b>:</p>
<pre><code>template &lt;class I&gt; inline 
I* CSmartInterface&lt;I&gt;::operator-&gt;()
{
 &nbsp;&nbsp; ASSERT(m_pI!=NULL) ;
 &nbsp;&nbsp; return m_pI ;
}
</code></pre>
<p>
Therefore, <b>SIDraw–&gt;Draw()</b> from the previous examples results in a call to <b>SIDraw.m_pI-&gt;Draw()</b>. <b>SIDraw</b> delegates the <b>Draw</b> call to the interface pointed to by <b>m_pI</b>. The power of this approach is that the <b>CSmartInterface&lt;IDraw&gt;</b> class does not need to be changed every time a new function has been added to the <b>IDraw</b> interface. However, as we will see, <b>CSmartInterface&lt;IDraw&gt;</b> can't stop individual calls to the <b>IDraw</b> interface.</p>
<p>
To make <b>CSmartInterface</b> a believable simulation of a native C++ pointer, more operators need to be defined than just <b>operator–&gt;</b>. In fact, the most difficult thing about making a smart pointer class is ensuring that all of the operators used on a pointer are defined and make sense. For example, when I converted the following code from</p>
<pre><code>if (pISimple == NULL) ... ;
</code></pre>
<p>
to</p>
<pre><code>if (SISimple == NULL) ... ;
</code></pre>
<p>
I had yet to define <b>operator==</b> for my smart pointer class. The resulting code compiles without error; however, it contains a bug because it compares NULL with <b>SISimple</b> and not with <b>SISimple.m_pI</b> as I had intended. After I defined <b>operator==</b>, this bug went away. The index to your favorite C++ programming book should list all the operators you need to define, thus serving as a convenient checklist. For security, I define private versions of the operators I don't think I need—that way I'll get an error message if I try to use them. An article like Robert Mashlan's "Checked Pointers for C++" in the <i>C/C++ Users Journal</i> can really help with understanding smart pointers (see the bibliography at the end of this article).</p>
<p>
Overriding most of the needed operators is straightforward. The most interesting is <b>operator=</b>.</p>
<pre><code>template &lt;class I&gt; inline 
CSmartInterface&lt;I&gt;&amp; CSmartInterface&lt;I&gt;::operator=(I* pI)
{
 &nbsp; if (m_pI != pI) //OPTIMIZE: Same pointer AddRef/Release not needed.
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (m_pI != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pI-&gt;Release() ; //Smart Pointers don't use smart pointers :-)
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; m_pI = pI ;

 &nbsp;&nbsp;&nbsp;&nbsp; if (m_pI != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pI-&gt;AddRef() ;
 &nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; return *this ;
}
</code></pre>
<p>
<b>operator=</b> will automatically <b>AddRef</b> and <b>Release</b> the interfaces for you. If <b>CSmartInterface</b> already points to an interface, it will release it and <b>AddRef</b> the new interface. This definition of&nbsp; <b>operator=</b> allows the following operations:</p>
<pre><code>void DrawThemAll()
{
 &nbsp; CSmartInterface&lt;IDraw&gt; SIDraw ;
 &nbsp; for (int i = 0 ; i &lt; MAX ; i++ )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; SIDraw = pIDraw[i] ;
 &nbsp;&nbsp;&nbsp;&nbsp; SIDraw-&gt;Forward(x) ;
 &nbsp; }
}
</code></pre>
<p>
The above code depends on <b>CSmartInterface</b>'s destructor to release the pointer, which it does:</p>
<pre><code>template &lt;class I&gt; inline 
CSmartInterface&lt;I&gt;::~CSmartInterface()
{
 &nbsp; if (m_pI != NULL)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; m_pI-&gt;Release();
 &nbsp; }
}
</code></pre>
<p>
We can take more advantage of the destructor with a proper constructor:</p>
<pre><code>template &lt;class I&gt; inline
CSmartInterface&lt;I&gt;::CSmartInterface(I* pI /*=NULL*/)
 &nbsp; : m_pI(pI)
{
 &nbsp; if (m_pI != NULL) 
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // AddRef if we are copying an existing interface pointer.
 &nbsp;&nbsp;&nbsp;&nbsp; m_pI-&gt;AddRef() ;
 &nbsp; }
}
</code></pre>
<p>
Now our example can change to:</p>
<pre><code>void DrawThemAll()
{
 &nbsp; for (int i = 0 ; i &lt; MAX ; i++ )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CSmartInterface&lt;IDraw&gt; SIDraw(pIDraw[i]) ;
 &nbsp;&nbsp;&nbsp;&nbsp; SIDraw-&gt;Forward(x) ;
 &nbsp; }
}
</code></pre>
<p>
The above code runs through a list of <b>IDraw</b> interface pointers, <b>AddRef</b>ing them, using them, and releasing them.</p>
<p>
There is a lot more that you can do with this. Don Box took the idea further in his column: He defined his equivalent of <b>CSmartInterface</b> to take the interface's ID (IID) in addition to its type. He then defined a constructor that would call <b>QueryInterface</b> if the assignment was from a different interface:</p>
<pre><code>CSmartInterface(IUnknown* pI)
 &nbsp; : m_pI(NULL)
{
 &nbsp; if (pI != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; pI-&gt;QueryInterface(*piid, (void**)&amp;m_pI) ;
}
</code></pre>
<p>
The above constructor allows us to change our example to:</p>
<pre><code>void DrawThemAll()
{
 &nbsp; for (int i = 0 ; i &lt; MAX ; i++ )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CSmartInterface&lt;IDraw, &amp;IID_Draw&gt; SIDraw(pIUnknown[i]) ;
 &nbsp;&nbsp;&nbsp;&nbsp; SIDraw-&gt;Forward(x) ;
 &nbsp; }
}
</code></pre>
<p>
This example starts to show the power of the technique. The above code is similar to:</p>
<pre><code>void DrawThemAll()
{
 &nbsp; IDraw* pIDraw ;
 &nbsp; for (int i = 0 ; i &lt; MAX ; i++ )
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; pIUnknown[i]-&gt;QueryInterface(IID_Draw, (void**)&amp;pIDraw) ;
 &nbsp;&nbsp;&nbsp;&nbsp; pIDraw-&gt;Forward(x) ;
 &nbsp;&nbsp;&nbsp;&nbsp; pIDraw-&gt;Release() ;
 &nbsp; }
}
</code></pre>
<p>
<b>operator=</b> can be extended in the same manner, so that assignments such as</p>
<pre><code>SIDraw = pIUnknown ;
</code></pre>
<p>
would call <b>QueryInterface</b>. I'm not a big fan of hidden implementation behind innocent-looking operators; however, I have to say that overloading <b>operator=</b> in this manner is very persuasive. Visual Basic® version 4.0 calls <b>QueryInterface</b> when assigning one COM object to another.</p>
<h2>Using the Smart Interface Pointer Class</h2>
<p>
There are two main rules for using <b>CSmartInterface</b>. First, don't call <b>Release</b> on a <b>CSmartInterface</b> object:</p>
<pre><code>void Draw()
{
 &nbsp;&nbsp; CSmartInterface&lt;IDraw&gt; SIDraw;
 &nbsp;&nbsp; CoCreateInstance(...,IID,_IDraw, (void**)&amp;SIDraw) ;
 &nbsp;&nbsp; SIDraw-&gt;Draw() ;
 &nbsp;&nbsp; SIDraw-&gt;Release() ; // Will compile, but is a bug.
}
</code></pre>
<p>
When <b>SIDraw–&gt;Release</b> is called, <b>SIDraw–&gt;m_pI</b> is released. <b>SIDraw–&gt;m_pI</b> is released once again when its destructor is called, if the interface hasn't already been released. This problem is not that hard to debug. If you have reference counting problems, you can just search for all occurrences of <b>Release</b>. Another approach is to use</p>
<pre><code>#define Release BOGUS_DO_NOT_CALL_RELEASE!
</code></pre>
<p>
so that using <b>Release</b> generates an error. Of course, if your application has other functions with the word "Release" in them (like many of the Win32® application programming interfaces [APIs]), this method will not work.</p>
<p>
The second rule is to avoid using <b>CSmartInterface</b> objects as pointers. It gets very confusing if you do:</p>
<pre><code>CSmartInterface&lt;ISimple&gt;* pSISimple 
 &nbsp;&nbsp;&nbsp;&nbsp; = new CSmartInterface&lt;ISimple&gt;(m_pISimple) ;
(*pSISimple)-&gt;Inc() ;
delete pSISimple ;
</code></pre>
<p>
Using a <b>typedef</b> will clean this up a little bit:</p>
<pre><code>typedef CSmartInterface&lt;ISimple&gt; CSmartISimple ;
CSmartISimple* pSISimple = new CSmartISimple(m_pISimple) ;
(*pSISimple)-&gt;Inc() ;
delete pSISimple ;
</code></pre>
<p>
However, this doesn't change the fact that <b>(*pSISimple)–&gt;Inc()</b> <b>;</b> actually isn't very (simple, that is!).</p>
<p>
If we look at why we want to have a pointer to an interface, we might find a way around the problem. We would like to release the interface at some arbitrary point in our program—not when the <b>CSmartInterface</b> object goes out of scope. The question then becomes, How do we release the interface contained in <b>CSmartInterface</b>? The answer is pretty simple:</p>
<pre><code>SISimple = NULL ;
</code></pre>
<p>
Although this is very pretty C code, it isn't at all obvious what is happening here. Both</p>
<pre><code>pISimple-&gt;Release() ;
</code></pre>
<p>
and</p>
<pre><code>delete pSISimple ;
</code></pre>
<p>
are much more obvious ways to indicate that the object is going away.</p>
<h2>Reasons Why I Don't Like the Smart Interface Pointer Class</h2>
<p>
There are several reasons why I don't plan on using the smart interface pointer class. The gist of all of these reasons is that <b>CSmartInterface</b> doesn't feel like C++. It is really strange to use <b>operator-&gt;</b> on an object and not a pointer to an object<b>.</b> </p>
<p>
A related reason is that using a pointer to a <b>CSmartInterface</b> is not straightforward—in fact, it can be very confusing. Most of my COM components use containers of cached interface pointers, and the lifetime of the interface is seldom limited to the scope of a function. I call <b>QueryInterface</b> for an interface, store it in the container, use it, and finally release it—all of this from different places in my code. With this type of structure, I need to be able to allocate and deallocate the smart interface on the stack, which, as I demonstrated in the previous section, can be very confusing.</p>
<p>
A C++ programmer is likely to <b>delete</b> an interface pointer. A COM programmer is likely to <b>Release</b> a <b>CSmartInterface</b> object. There isn't any convenient way to prevent this. So, our solution has replaced one problem with an equivalent, similar problem. Of course, the set of C++ programmers is larger than the set of COM programmers, at least for now.</p>
<p>
I have decided to use interface wrappers instead of smart interface pointers. Interface wrappers are described in my article <a href="msdn_comwrap.htm">"Calling COM Objects with Interface Wrappers."</a></p>
<h2>Conclusion</h2>
<p>
Smart interface pointers are a powerful technique that can make working with COM objects easier and more bug-free. However, I find smart interface pointers to be very strange creatures. They aren't exactly pointers and they aren't exactly objects. They also don't fit my application structure as well as I had expected. However, I strongly suggest that you try using smart interface pointers in your application and see how they work for you. They might be just the ticket you need to get your application out the door more quickly and with fewer bugs.</p>
<h2>Bibliography</h2>
<p>
Box, Don. "Component Craft: Interface pointers considered harmful." <i>C++ Report</i> (Sept. 95): p. 46.</p>
<p>
Coplien, James O. <i>Advanced C++ Programming Styles and Idioms</i>. Reading, MA: Addison-Wesley, 1991. (Look under "Delegation" in the index.)</p>
<p>
Mashlan, Robert. "Checked Pointers for C++." <i>C/C++ Users Journal</i>, (Oct. 95, Vol. 14, No. 10): p. 37.</p>
<p>
Stroustrup, Bjarne. <i>The C++ Programming Language</i>. 2d ed. Reading, MA: Addison-Wesley, 1991. Section 7.9, "Dereferencing," p. 244.</p>
<p>
Stroustrup, Bjarne. <i>The Design and Evolution of C++</i>. Reading, MA: Addison-Wesley, 1994. Section 11.5.1, "Smart Pointers," p. 241.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;Search for "Smart Pointers" in the Visual C++ version 4.0 Books Online documentation. Query results should include "Programming Techniques: Templates: When should you use Templates: Smart Pointers."</p>
</BODY>
</HTML>
