<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COM Security in Practice</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_practicom"></a>COM Security in Practice</h1>
<p>
Rajiv Dulepet</p>
<h4>Contents</h4>
<p>
<a href="#practicom_intro">Introduction</a><br>
<a href="#practicom_reg">Registry</a><br>
<a href="#practicom_act">Activation Security</a><br>
<a href="#practicom_call">Call Security</a><br>
<a href="#practicom_comm">Common Scenarios</a><br>
<a href="#practicom_ref">References</a></p>
<h2><a name="practicom_intro"></a>Introduction</h2>
<p>
The Component Object Model (COM) can make distributed applications secure without any security-specific coding or design in either the client or the component. Just as the COM programming model hides a component's location, it also hides the security requirements of a component. The same binary code that works in a single-machine environment, in which security may be of no concern, can be used securely in a distributed environment.</p>
<p>
COM provides two distinguishable categories of security. The first is termed <i>activation security</i>, and it controls which objects a client is allowed to instantiate. The second form is <i>call security</i>, which dictates how security operates at the per-call level on an established connection from a client to a server object.</p>
<p>
This article describes the exact capabilities of COM security in greater detail.</p>
<h2><a name="practicom_reg"></a>Registry</h2>
<p>
Entries in the system registry can affect how COM security allows the activation and calling of objects by a remote client. COM provides mechanisms to externally configure security settings for objects and clients. In the current implementations of COM, all security policies are enforced at the process level. All objects in a process share the same security policies unless they programmatically override them. (Details on call security are provided later in this document.) To match this process-wide security configuration, COM introduces the concept of an application identifier, or APPID.</p>
<p>
To change the security settings for the server, you can either edit System Registry entries directly or use the DCOMCNFG or OLE/COM Object Viewer utility.</p>
<h3>Application IDs</h3>
<p>
APPIDs group the configuration options for one or more COM objects into one centralized location in the registry. COM objects hosted by the same executable must map to the same APPID. In-process COM objects on a single machine that are run remotely can be forced into the same surrogate process by assigning the same APPID to their Class ID (CLSID) entries.</p>
<h3>DCOMCNFG</h3>
<p>
DCOMCNFG is a utility you can use to configure various COM-specific settings in the registry. This configuration utility, dcomcnfg.exe, is included in the Microsoft® Windows NT® operating system and is used to configure applications to use COM. The dcomcnfg.exe utility is not added to the Start menu or any groups during installation of Windows NT version 4.0. An administrator must start it from the <b>Run</b> command on the <b>Start</b> menu.</p>
<p>
DCOMCONFG must be used to configure an application's COM properties before the application can use COM to communicate over the network. The DCOMCONFG utility can be used to:
<ul type=disc>
<li>
Disable distributed components for an entire computer or for a specific application. By default, distributed components are enabled.<br><br></li>
<li>
Configure the location of an application.<br><br></li>
<li>
Set permissions on server applications, either for all applications or for individual applications.<br><br></li>
<li>
Configure the user account that will be used to execute the server application. The client application uses this account to start processes and gain access to resources on the server computer.<br><br></li>
<li>
Configure the level of security for connections between applications, for example, using packet encryption.</li>
</ul>
<p>
Both the computers that are running the client and the server applications must be configured for a distributed environment with the DCOMCONFG utility:
<ul type=disc>
<li>
<b>Client Application.</b> On the computer that will be running the client application, the administrator must specify the location of the server application. When a COM client application is used, it makes a request to a server application, which could be running on a different computer.<br><br></li>
<li>
<b>Server Application.</b> On the computer that will be running the server application, the administrator must specify the user accounts that will have permission to use or start the server application. In addition, it is necessary to specify the user accounts that will be used to run the server application.</li>
</ul>
<p>
When DCOMCNFG starts, it displays the Distributed COM Configuration Properties dialog box. This dialog box has three tabs: <b>Default Security</b>, <b>Default Properties</b>, and <b>Applications</b>.</p>
<h4>Default Security</h4>
<p>
You can use the <b>Default Security</b> tab to specify default permissions for objects on the system. This tab has three sections: <b>Access</b>, <b>Launch</b>, and <b>Configuration</b>. To change a section's defaults, click the corresponding <b>Edit Default</b> button. These default security settings are stored in the registry under HKEY_LOCAL_MACHINE\Software\Microsoft\OLE.</p>
<p>
<img src="practicom01.gif" border=0></p>
<p class=label>
<b>Figure 1. The Default Security tab</b></p>
<h4>Default Properties</h4>
<p>
On the <b>Default Properties</b> tab, you must select the <b>Enable Distributed COM on This Computer</b> check box if you want clients on other machines to access COM objects running on this machine. Selecting this option sets the HKEY_LOCAL_MACHINE\Software\Microsoft\OLE\EnableDCOM value to Y.</p>
<p>
<img src="practicom02.gif" border=0></p>
<p class=label>
<b>Figure 2. The Default Properties tab</b></p>
<h4>Applications</h4>
<p>
You can change the settings for a particular object from the <b>Applications</b> tab. To do so, you select the application from the list and click the <b>Properties</b> button. This action displays the <b>Object Properties</b> dialog box for the selected application.</p>
<p>
<img src="practicom03.gif" border=0></p>
<p class=label>
<b>Figure 3. The Applications tab</b></p>
<p>
The <b>Object Properties</b> dialog box has four tabs:
<ul type=disc>
<li>
The <b>General</b> tab confirms the application you are working with.<br><br></li>
<li>
The <b>Location</b> tab specifies where the application should run when a client calls <b>CoCreateInstance</b> with the relevant CLSID. If you select the <b>Run Application on the Following Computer</b> check box and enter a computer name, a RemoteServerName value is added under the APPID for that application. Clearing the <b>Run Application on this Computer</b> check box renames the LocalService value to _LocalService and disables it.<br><br></li>
<li>
The <b>Security</b> tab is similar to the <b>Default Security</b> tab found in the <b>Distributed COM Configuration Properties</b> dialog box, except that these settings apply only to the current application. Again, the settings are stored under the APPID for that object.<br><br></li>
<li>
The <b>Identity</b> tab identifies which user is used to run the application.</li>
</ul>
<p>
<img src="practicom04.gif" border=0></p>
<p class=label>
<b>Figure 4. The Object Properties dialog box</b></p>
<h3>OLE/COM Object Viewer</h3>
<p>
The OLE/COM Object Viewer (OLEView) is an administration and testing tool for developers and power users. It is the second way to configure security options for a component. With the OLE/COM Object Viewer, you can:
<ul type=disc>
<li>
Browse, in a structured way, all of the COM classes installed on your machine.<br><br></li>
<li>
See the registry entries for each class in an easy-to-read format.<br><br></li>
<li>
Configure any COM class on your system. This configuration includes Distributed COM activation and security settings.<br><br></li>
<li>
Configure system-wide COM settings, including enabling or disabling Distributed COM.<br><br></li>
<li>
Test any COM class by double-clicking its name. The list of interfaces that class supports will be displayed. By double-clicking an interface entry, you can invoke a viewer that will "exercise" that interface.<br><br></li>
<li>
Activate COM classes locally or remotely. This feature is great for testing distributed configurations.<br><br></li>
<li>
View type-library contents. Use this feature to figure out what methods, properties, and events a Microsoft&nbsp; ActiveX® control supports.<br><br></li>
<li>
Copy a properly formatted OBJECT tag to the clipboard for inserting into a Hypertext Markup Language (HTML) document.</li>
</ul>
<p>
<img src="practicom05.gif" border=0></p>
<p class=label>
<b>Figure 5. The OLE/COM Object Viewer</b></p>
<p>
OLEView provides more information than DCOMCNFG, and you can use it for all the settings done by DCOMCNFG except one: OLEView has no way to set the COM server to "RunAs" a certain user. The other major difference between DCOMCNFG and OLEView is that DCOMCNFG shows only the servers with APPIDs. OLEView allows the component to use Default Access and Launch permissions, but unlike DCOMCNFG it doesn't allow the user to modify the Default settings.</p>
<p>
In essence, OLEView provides all the functionality provided by clicking the <b>Properties</b> button in the <b>Application</b> tab of DCOMCNFG except for RunAs identity, and it also provides a subset of the <b>Default Properties</b> and <b>Default Security</b> tabs of DCOMCNFG.</p>
<h2><a name="practicom_act"></a>Activation Security</h2>
<p>
Activation security controls which classes a client is allowed to launch and retrieve objects from. The Service Control Manager of a particular machine automatically applies activation security. Upon receipt of a request from a remote client to activate an object (see the client activation services outlined earlier in this document), the Service Control Manager of the machine checks the request against the following information stored within its registry:
<ul type=disc>
<li>
Machine-wide settings for securing activation<br><br></li>
<li>
Per-class settings for activation</li>
</ul>
<p>
These settings are described in the following sections.</p>
<h3>Machine-wide Settings for Securing Activation</h3>
<p>
The following named values, which appear under HKEY_LOCAL_MACHINE\Software\Microsoft\OLE, control the global activation policies of the machine. Only machine administrators and the system have full access to this portion of the registry. All other users have read-only access.</p>
<pre><code>[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Ole]
 &nbsp; "EnableDCOM"="Y"
 &nbsp; "DefaultLaunchPermission" = hex: [self-relative security descriptor]
</code></pre>
<p>
The EnableDCOM named value allows or disallows remote clients to launch class code and connect to objects for the system. The DefaultLaunchPermission named value, as the name implies, sets the default access control list (ACL) to specify who has access to classes on the system.</p>
<h3>Per-Class Settings for Activation</h3>
<p>
The following key may be added under any class's APPID key (HKEY_CLASSES_ROOT\APPID\{...}) to limit activation by remote clients of specific classes. By definition, Launch security needs to be enforced by the COM libraries themselves, since the object that could potentially perform this check has not been instantiated yet. For this reason, launch security can only be externally configured and cannot be controlled programmatically.</p>
<p>
Activation security is automatically applied by the Service Control Manager (SCM) of a particular machine. Upon receipt of a request from a remote client to activate an object, the SCM on the server machine checks the request against the HKEY_CLASSES_ROOT\AppID\{...}\LaunchPermission key, which contains data describing the access control list (ACL). If the user's access control entry (ACE) is not contained within the ACL, access is denied. If the APPID does not have a LaunchPermission key, the SCM checks the request against the ACL in the DefaultLaunchPermission key under HKEY_LOCAL_MACHINE\Software\Microsoft\OLE.</p>
<p>
Launch security affords administrators granular control over who can instantiate COM objects for use by others and therefore protects business processes (as an example) from malicious or accidental initialization. For example, you may want to restrict instantiation of accounts-payable processes to employees in the Accounting group, or you may want to develop a COM server as a Windows NT service that can be started only by a specific service account.</p>
<p>
Using the DCOM Configuration utility included with Windows NT (dcomcnfg.exe), an administrator can control activation security at both the machine level and the object level. In addition to launch security, an administrator can control who can access a particular object (access security) and who can alter registry settings related to a particular object (configuration access).</p>
<p>
If an account may both launch and access an object, the account must appear on both the Launch and Access security access lists. DCOMCNFG does not enforce this constraint.</p>
<h2><a name="practicom_call"></a>Call Security</h2>
<p>
COM provides two mechanisms to secure calls. The first is similar to DCE RPC: COM provides functions and interfaces that applications can use to do their own security checking. The second mechanism is run automatically by COM. If the application provides some setup information, COM will make all the necessary checks to secure the application's objects. This automatic mechanism does security checking for the process, not for individual objects or methods. Applications requiring more fine-grained security can perform their own security checking. The two mechanisms are not exclusive: an application can ask COM to perform automatic security checking and also perform its own.</p>
<p>
COM call-security services are divided into three categories: general functions called by both clients and servers, new interfaces on client proxies, and server-side functions and call-context interfaces. The general functions initialize the automatic security mechanism and register authentication services. The proxy interfaces allow the client to control security on calls to individual interfaces. The server functions and interfaces allow the server to retrieve security information about a call and to impersonate the caller.</p>
<p>
In a typical scenario, the client queries an existing object for <b>IClientSecurity</b>, which is implemented locally by the interface remoting layer. The client uses <b>IClientSecurity</b> to control the security of individual interface proxies on the object, prior to making a call on one of the interfaces. When a call arrives at the server, the server can call <b>CoGetCallContext</b> to retrieve an <b>IServerSecurity</b> interface. <b>IServerSecurity</b> allows the server to check the client's authentication and to impersonate the client, if needed. The <b>IServerSecurity</b> object is valid for the duration of the call. The client can call <b>CoInitializeSecurity</b> to establish default call security for the process, avoiding the use of <b>IClientSecurity</b> on individual proxies. <b>CoInitializeSecurity</b> allows a server to register automatic authentication services for the process. Registering authentication services with <b>CoRegisterAuthenticationServices</b> does not prevent calls from arriving with no authentication service or with an unregistered authentication service.</p>
<p>
Implementations of <b>QueryInterface</b> must never check ACLs. COM requires that an object that supports a particular IID always return success when queried for that IID. Even if COM did not enforce that requirement, checking ACLs on <b>QueryInterface</b> would not provide any real security. If Client A legally has access to interface <b>IFoo</b>, Client A can hand a pointer to <b>IFoo</b> directly to Client B without any calls back to the server. Additionally, COM caches interface pointers and will not call <b>QueryInterface</b> on the server every time a client does a query.</p>
<p>
Each time a proxy is created, COM sets the security information to default values, which are the values used for automatic security.</p>
<p>
The flow of control looks something like this for client/server negotiation:
<ol>
<li>
Default authorization and authentication levels are set in <b>CoInitializeSecurity</b>. Authentication and authorization services can be registered with <b>CoRegisterAuthenticationServices</b>. If you call this function, you cannot also call <b>CoInitializeSecurity</b>. Authorization and authentication levels, Server Principle Name, and authorization-specific information can be set by calling <b>IClientSecurity::SetBlanket</b>. This information applies to the specific proxy.<br><br></li>
<li>
COM determines the appropriate authentication service that supports the client's requirements, based on the information obtained in step 1. Currently only NTLMSSP is supported as an authentication service. The security attributes specified by the client are compared to those for the server as specified in the call to <b>CoInitializeSecurity</b>. If the client specifies requirements less than those specified by the server, the call will fail.<br><br></li>
<li>
The programmer can have the server call <b>IServerSecurity::QueryBlanket</b> to further evaluate the requirements of the client. The server application using this interface could decide to reject the client's call based on insecure authentication or impersonation level, despite what is specified in <b>CoInitializeSecurity</b>. This behavior would be typical if the server handled general product information queries but was now required to complete a credit card transaction. <b>CoInitializeSecurity</b> could initialize the server to have low security channels by default, but for <b>ICreditCardTransaction</b>, an encrypted secure channel is required.<br><br></li>
<li>
With mutual authentication such as that offered by Kerberos V, a similar process may happen on the client side to verify that the server is not an impostor. Because of limitations in NTLMSSP, this functionality is not currently supported.</li>
</ol>
<h3>Machine-wide Settings for Call Security</h3>
<p>
The following named values appear in HKEY_LOCAL_MACHINE\Software\Microsoft\OLE and control COM call-level security capabilities in applications that do not call <b>CoInitializeSecurity</b>. Only machine administrators and the system have full access to this portion of the registry. All other users have read-only access.</p>
<pre><code>[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Ole]
 &nbsp; "DefaultAccessPermission" = hex: [self-relative security descriptor]
 &nbsp; "LegacyImpersonationLevel" = dword:2
 &nbsp; "LegacyAuthenticationLevel" = dword:2
 &nbsp; "LegacyMutualAuthentication"=dword:2
 &nbsp; "LegacySecureReferences{ XE "LegacySecureReferences"}"=dword:2
</code></pre>
<h3>Per-Class Settings for Call-Security</h3>
<p>
The following named values can be added under any class's APPID key (HKEY_CLASSES_ROOT\APPID\{...}) to limit access to objects of a specific class.</p>
<h4>AccessPermission{ XE "AccessPermission" }{ XE "Registry Keys:AccessPermission}</h4>
<p>
This named value is of type REG_BINARY. It contains data describing the ACL of the principals that can access instances of this class. Upon receiving a request to connect to an existing object of this class, the ACL is checked <i>while impersonating the caller</i>. If the access check fails, the connection is disallowed. If this named value does not exist, the machine-wide DefaultAccessPermission ACL is tested in an identical manner (see above) as a default to determine if the connection is to be allowed.</p>
<h3>Call-Level Security</h3>
<ul type=disc>
<li>
<b>CoInitializeSecurity</b>, <b>IClientSecurity</b>, <b>CoGetCallContext</b>, <b>IServerSecurity</b>, and the related helper functions are all fully supported.<br><br></li>
<li>
Microsoft Windows® 95 operating systems can make calls at any authentication level, but incoming calls will never arrive with a higher authentication level than connect (RPC_C_AUTHN_LEVEL_NONE or RPC_C_AUTHN_LEVEL_CONNECT).<br><br></li>
<li>
DCOM for Windows 95 does not support external configuration of access permissions in the registry; all processes that do not call <b>CoInitializeSecurity</b> on this release will be completely unsecured.</li>
</ul>
<h2><a name="practicom_comm"></a>Common Scenarios</h2>
<p>
This section illustrates how COM security can be used in some common scenarios.</p>
<h3>Windows 95 COM Servers</h3>
<p>
When a Windows 95 COM server is used to serve objects to remote clients, make sure to:
<ol>
<li>
Verify that the EnableDCOM and EnableRemoteConnections registry keys under HKLM\Software\Microsoft\OLE are set to Y on the server machine. EnableDCOM must be set to Y to enable any distributed COM functionality. EnableRemoteConnections must be set to Y to let the machine act as a server.<br><br></li>
<li>
On a Windows 95 computer, manually start the server. Windows 95 does not support launching servers through COM.<br><br></li>
<li>
If your server resides in a single-thread apartment (STA), try manually launching %systempath%\rpcss.exe before manually launching the server application. There are certain circumstances where DCOM for Windows 95 does not properly launch RPCSS for STA servers. Microsoft has confirmed this to be a problem in DCOM for Windows 95. We are researching this problem and will post new information as it becomes available. If manually launching RPCSS resolves the RPC_SERVER_UNAVAILABLE error, you can automatically launch RPCSS during system startup. To do so, add a named value with the value "RPCSS.EXE" to HKLM\Software\Microsoft\Windows\CurrentVersion\Run, which launches when the shell loads, or \RunServices, which launches immediately upon machine startup (before logon).</li>
</ol>
<h3>Windows 95 client and Windows NT Server</h3>
<p>
The authentication level is negotiated as follows: If you have a Windows 95 client with authentication level Connect and a Windows NT server object with authentication level Encrypt, COM will try to use Encrypt for calls in both directions. Since Windows 95 cannot receive calls at Encrypt, the Windows NT computer cannot call the Windows 95 machine. Thus both the client and server have to set the authentication level to the lowest value allowable for any call in any direction.</p>
<p>
Similarly, if you have two processes, one with a logon token and the other with an impersonation token, and you set the authentication level to none in the second, it still won't be able to call the first if its authentication level is not none.</p>
<h3>Windows NT Workstation's Network not in Domain</h3>
<p>
Please refer to "FAQ: COM Security Frequently Asked Questions," Knowledge Base article #Q158508, in the MSDN™ Library.</p>
<h3>Legacy COM Application</h3>
<p>
Three named values in the registry apply to legacy code written before DCOM. These named values exist under the HKEY_LOCAL_MACHINE\Software\Microsoft\OLE\legacy key, and COM uses them to determine what parameters to pass to <b>CoInitializeSecurity</b> on the server's behalf:
<ul type=disc>
<li>
<b>LegacyAuthenticationLevel.</b> Provides authentication level for all legacy servers.<br><br></li>
<li>
<b>LegacyImpersonationLevel.</b> Provides the default level of impersonation for all legacy applications. If the server uses security, <b>LegacyImpersonationLevel</b> will provide security context at the object level. The default value is RPC_C_IMP_LEVEL_IDENTITY.<br><br></li>
<li>
<b>LegacySecurityPreferences.</b> Provides the default setting for securing calls to <b>IUnknown::AddRef</b> and <b>IUnknown::Release</b> for all legacy applications.</li>
</ul>
<h3>Microsoft Internet Information Server and COM</h3>
<p>
Launching a COM object on a computer running the Windows NT 4.0 operating system requires certain permissions. This is not normally an issue for most interactive users, because the default permissions for launching and accessing COM objects on Windows NT allow access to anyone interactively logged on to the local machine. A Microsoft Internet Information Server (IIS) application, whether it is running in the context of the IUSR_&lt;servername&gt; account or as an impersonated user account from Basic or NTLM authentication, is not interactively logged on. Therefore, the default permissions for launching and accessing COM objects will not allow an ISAPI extension dynamic-link library (DLL), computer graphics interface (CGI) application, or Internet script to launch these objects successfully by default.</p>
<p>
With the DCOMCNFG utility on Windows NT 4.0, you can set the default permissions for all COM objects on your machine. You can use DCOMCNFG to provide COM access to the IUSR_&lt;servername&gt; account, as well as to all user accounts that might be impersonated by your IIS configuration. You can even grant permissions to the "Everyone" group.</p>
<p>
However, providing global access to all COM objects may not be in your best interests, so you can use DCOMCNFG to specify permissions for specific applications. In this way, you can provide access only to the applications you will need to access from your IIS application. COM applications can also determine what permissions are associated with launching and accessing themselves. To do so from inside your COM server, see the documentation for the <b>CoInitializeSecurity</b> function new to Windows NT 4.0, as well as that for <b>CoCreateInstanceEx</b> (in particular, the COSERVERINFO and COAUTHINFO structures) for manipulating COM access from the client side.</p>
<p>
For more information on launching COM servers from ISAPI applications, see the <a href="#practicom_ref">"References"</a> section of the article.</p>
<p>
COM requires all of the permissions discussed above. In addition, it needs to access resources across the network. If a request is received using anonymous authentication, the IUSR_&lt;servername&gt; account username and password credentials will be used to connect to the remote COM server. Unless your IIS server machine is also a domain controller, the remote machine by default will not be able to determine who the IUSR_&lt;servername&gt; account is. (It exists only on the local IIS server machine.) Adding access and launch permissions to the group "Everyone" does not help in this case, because COM will not map access by an unknown account to the guest account in the same way that the LAN Manager service does for file sharing. The COM server machine must explicitly know the account that is being used.</p>
<p>
When IIS applications are accessing resources (including COM resources) on remote machines, all the machines involved must participate in a domain relationship. Then, in Internet Manager, you can change your anonymous account to an account in the local or trusted domain. Now all machines in the domain structure will recognize the account and can explicitly add and delete access to their network resources for that account or for any groups that account is a member.</p>
<p>
Be aware that if basic authentication is used for an IIS request, access to network resources (including COM servers) will be provided in the context of the user whose credentials were passed with the request. If the user specified does not have permissions to launch or access the COM server, the request will fail.</p>
<p>
If the IIS request is validated using NTLM authentication, the impersonation level does not imply knowledge of the user name and password credentials. Therefore, access to network resources, regardless of the permissions on the resource, will be denied (with the exception of null session resources).</p>
<h3>Launching OLE Servers from ISAPI Extensions</h3>
<p>
Please refer to "HOWTO: Launching OLE Servers from ISAPI Extensions," Knowledge Base article #Q156223, in the MSDN™ Library.</p>
<h3>Interaction of Visual Basic and Internet Explorer COM Clients with COM Servers</h3>
<p>
Since Microsoft Visual Basic® and Microsoft Internet Explorer COM clients cannot call <b>CoInitializeSecurity</b>, you need to set the default authentication level to "None."</p>
<h3>COM Client/Server Application Demonstrating Call-Level Security Functions</h3>
<p>
In this section we will use the Sales Training Roadmap sample application to demonstrate how call-level security functions are used. In this application, the engineers and managers have a training plan. The application has the following characteristics and rules:
<ul type=disc>
<li>
Training information is stored in a database.<br><br></li>
<li>
Employee database IDs are derived from an employee security token (a security ID, or SID)<br><br></li>
<li>
There are three types of users: Engineer, Manager, and Administrator (a Manager is an trainee, too)<br><br></li>
<li>
The following business rules apply:<ul type=disc>
<li>
All users can submit their own training plan.<br><br></li>
<li>
All users can read their own training plan.<br><br></li>
<li>
A Manager can read everyone's training plan.<br><br></li>
<li>
The managers can approve everyone's training plans but their own.</li>
</ul>
</li>
</ul>
<p>
The application is implemented as a Training COM object connected to a Microsoft SQL Server™ database. The implementation consists of one COM object with three interfaces: <b>IEngineer</b>, <b>IManager</b>, and <b>IDatabase</b>. <b>IDatabase</b> is an internal interface and is not accessible by the client. The object runs as an out-of-process server accessed by remote clients. Users are identified by their Windows NT logon ID. The out-of-process server is started as a Windows NT Service running as "System".</p>
<pre><code>interface IEngineer {
HRESULT Read ( ... );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Read one's training plan. */
HRESULT Submit ( ... );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Submit a new training plan. */
 &nbsp; };
interface IManager {
 &nbsp; HRESULT Read ( ... );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Read anyone's training plan. */
HRESULT Approve ( ... );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Approve a training plan. */
 &nbsp; };

 &nbsp; interface IDatabase {
 &nbsp;&nbsp;&nbsp;&nbsp; HRESULT ReadRecord ( ... );&nbsp;&nbsp;&nbsp; /* Read a database record. */
 &nbsp;&nbsp;&nbsp;&nbsp; HRESULT WriteRecord ( ... );&nbsp;&nbsp; /* Write a database record. */
 &nbsp; };
</code></pre>
<p>
The following describes one possible use of COM security for the training scenario. In this example, we will look only at security on the Training class.
<ol>
<li>
Two Windows NT groups, Engineer and Manager, are created. Administrator can map to an existing group.<br><br></li>
<li>
An ACL (query rights) for Engineer and Manager is placed on:<pre><code>\CLSID\{5cb31e10-2b5f- ... }\AccessPermission
\CLSID\{5cb31e10-2b5f- ... }\LaunchPermission = Y
</code></pre>
<p class=tl>
These registry entries and ACLs prevent anyone but an Engineer or Manager from activating or accessing a Training object or its interfaces.</P></li>
<li>
To set authentication and authorization levels, the server calls <b>CoInitializeSecurityCall</b>.</li>
</ol>
<pre><code>CoInitializeSecurity (
/* Specifies access security for this process */
 &nbsp; pDefaultAccessACL,
 &nbsp; RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,&nbsp;&nbsp;&nbsp; /* Insure data is not changed */
 &nbsp; RPC_C_IMP_LEVEL_IMPERSONATE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Allow impersonation. */
 &nbsp; NULL);
</code></pre>
<ol start=4>
<li>
COM security does not currently support declarative (automatic) security checking at the interface level, so the client principal must be checked by the server to ensure it is a member of the groups allowed to call methods on a given interface. If the application was repartitioned into classes according to security requirements (Engineer and Manager classes with <b>ITraining</b> interfaces), COM declarative access security could then be used.<p class=tl>
To implement security at the interface level, the following must be coded on the server side.</P><pre><code>CoGetCallContext (IID_ServerSecurity, pSSecurity);
pSSecurity-&gt;QueryBlanket (NULL, NULL, pszPrinciple, NULL, NULL, NULL, NULL);

/* From here we want to take the principal name (which is the login of the client) and call whatever interface(s) necessary to determine if the client is in the appropriate group to call the interface. Something along the lines of: */

if (IsPrincipleInGroup (pszPrincple, "MANAGER") == FALSE)
 &nbsp;&nbsp; return E_SECURITY_VIOLATION;
</code></pre>
</li>
<li>
All the application logic (business rules) specified above must be implemented by obtaining the principal name, possibly mapping it to a SID or database key, and using it in application logic. For example, for the rule, "All users can read their own training plan," the client principal is mapped to a database key to do the database query to obtain the corresponding training record. The principal in raw form could be used as the key.</li>
</ol>
<h2><a name="practicom_ref"></a>References</h2>
<p>
The following topics are all available in the MSDN Library.</p>
<p>
Component Object Model (COM) Specification 0.9 (Specifications bin)</p>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_dcomarch">
</object><a href=JavaScript:alink_1.Click()>"DCOM Architecture"</a> by Markus Horstmann and Mary Kirtland.</p>
<p>
ActiveX SDK (SDK Documentation bin).</p>
<p>
"FAQ: COM Security Frequently Asked Questions," Knowledge Base article #Q158508.</p>
<p>
Microsoft Transaction Server 2.0 (SDK Documentation, Platform Documentation, COM and ActiveX Object Services).</p>
</BODY>
</HTML>
