<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How to Pass Parameters Between COBOL and C</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_cblcapp"></a></sup>How to Pass Parameters Between COBOL and C</h1>
<p>
Michael Hendrick<br>
Systems Support Engineer, Languages</p>
<p>
February 1992</p>
<h2>Abstract</h2>
<p>
This article explains how Microsoft® COBOL programs can pass parameters to and receive parameters from Microsoft C programs. It assumes you have a basic understanding of the COBOL and C languages.</p>
<p>
Microsoft COBOL supports calls to routines written in Microsoft C, FORTRAN, Pascal, and Assembler. This article describes the necessary syntax for calling Microsoft C routines and contains a series of examples demonstrating the interlanguage capabilities between COBOL and C. The sample programs apply to the following Microsoft products:
<ul type=disc>
<li>
Microsoft COBOL Professional Development System (PDS) versions 4.0 and 4.5 for MS-DOS® and OS/2®<br><br></li>
<li>
Microsoft C Optimizing Compiler version 6.0 for MS-DOS and OS/2</li>
</ul>
<h2>Mixed-Language Programming with COBOL and C</h2>
<h3>The C Interface to COBOL</h3>
<p>
The C interface to COBOL utilizes the standard C extern statement. The following are the recommended steps for using this statement to execute a mixed-language CALL from C:
<ol>
<li>
In the C code, include an extern statement for each COBOL routine CALLed. The extern statement should be at the beginning of the C program, before any CALLs to the COBOL routine.<p class=tl>
<b>Note:</b> When compiling, if the /Gc compiler directive is used (the /Gc option causes all functions in the module to use the FORTRAN/Pascal naming and CALLing conventions), then the cdecl keyword should be used when the COBOL function is declared (because COBOL uses the C CALLing convention, not the Pascal CALLing convention).</P></li>
<li>
To pass an argument by reference, pass a pointer to the object (all parameters must be passed by reference to COBOL).<p class=tl>
C automatically translates array names into addresses. Therefore, arrays are automatically passed by reference and don't need the * (asterisk) operator.</P></li>
<li>
Once a routine has been properly declared with an extern statement, CALL it just as you would CALL a C function.<br><br></li>
<li>
If passing structures between COBOL and C, compile the C routine with the /Zp1 compiler option to pack structure members.<br><br></li>
<li>
Always compile the C module in large model.</li>
</ol>
<h3>C Arguments</h3>
<p>
The default for C is to pass all arrays by reference (near or far, depending on the memory model) and all other data types by value. C uses far data pointers for compact, large, and huge models, and near data pointers for small and medium models.</p>
<h3>Passing C Arguments by Value</h3>
<p>
The C default is to pass everything except arrays by value.</p>
<p>
Arrays can be passed by value only if they are declared as the only member of a structure. The following example passes all 100 bytes of x directly to the C function test():</p>
<pre><code>struct x_struct {int x[100]) xs;
.
.
.
test(xs)
</code></pre>
<h3>Passing C Arguments by Reference (Near or Far)</h3>
<p>
In C, passing a pointer to an object is the equivalent of passing the object itself by reference. Within the CALLed function, each reference to the parameter itself is prefixed by an * (asterisk).</p>
<p>
Note:&nbsp;&nbsp;&nbsp;&nbsp; To pass a pointer to an object, prefix the parameter in the CALL statement with &amp;. To receive a pointer to an object, prefix the parameter's declaration with *. In the latter case, this may mean adding a second * to a parameter that already has an *. For example, to receive a pointer by value, declare it as follows:</p>
<pre><code>int&nbsp;&nbsp; *ptr;
</code></pre>
<p>
But to receive the same pointer by reference, declare it as the following:</p>
<pre><code>int&nbsp;&nbsp; **ptr;
</code></pre>
<p>
The default for arrays is to pass by reference.</p>
<h3>Effect of C Memory Models on Size of Reference</h3>
<p>
Near reference is the default for passing pointers in small and medium model C. Far reference is the default for the compact, large, and huge models.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;All C programs that are linked with COBOL must be compiled with the large memory model.</p>
<h3>Restrictions on CALLs from COBOL</h3>
<p>
The COBOL to C interface does not support near heap in the C run time. This means you should not use the function calls that access near heap in your C programs. This includes the following functions:
<ul type=disc>
<li>
_nfree()<br><br></li>
<li>
_nheapchk()<br><br></li>
<li>
_nheapset()<br><br></li>
<li>
_nheapwalk()<br><br></li>
<li>
_nmalloc()<br><br></li>
<li>
_nmsize()</li>
</ul>
<p>
To work around this, compile and link with C as the initial program. After the main C program begins, the COBOL routine can be CALLed. The COBOL code can then CALL back and forth with C. Since the C support modules are not used, there are no special restrictions on the near heap functions.</p>
<h3>Special Note on C Strings</h3>
<p>
C stores strings as simple arrays of bytes (like COBOL) but also uses a null character [ASCII NULL (0)] as the delimiter to show the end of the string. For example, consider the string declared as follows:</p>
<pre><code>char str[] = "String of text"
</code></pre>
<p>
The string is stored in 15 bytes of memory as follows:</p>
<pre><code>|S|t|r|i|n|g| |o|f| |t|e|x|t|\0|
</code></pre>
<p>
When passing a string from COBOL to C, the string will normally not have a NULL appended to the end. Because of this, none of the C routines that deal directly with a string (printf, sprintf, scanf, and so on) can be used with these strings unless a NULL is appended to the end.</p>
<p>
A NULL can be put at the end of a COBOL string by using the following declaration:</p>
<pre><code>01 CSTRING.
 &nbsp; 05 THE_STRING PIC X(10).
 &nbsp; 05 FILLER PIC X VALUE x"0".
</code></pre>
<h3>Compiling and LINKing</h3>
<p>
Several compile and link options need to be used when interfacing C and COBOL. The standard C compile line is as follows:</p>
<pre><code>CL /c /Aulf CProgName ;
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=16%><b>Option</b></td>
<td class=label width=84%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=16%>/c</td>
<td width=84%>Compiles without linking (produces only an .OBJ file).</td>
</tr>
<tr valign=top>
<td width=16%>/Aulf</td>
<td width=84%>Sets up a customized large memory model.</td>
</tr>
<tr valign=top>
<td width=16%>u</td>
<td width=84%>SS not equal to DS. DS is reloaded on function entry.</td>
</tr>
<tr valign=top>
<td width=16%>l</td>
<td width=84%>Selects large memory model Far (32-bit) code pointers.</td>
</tr>
<tr valign=top>
<td width=16%>f</td>
<td width=84%>Selects large memory model Far (32-bit) data pointers.</td>
</tr>
</table><br>
<p>
The standard LINK line for COBOL CALLing C is as follows:</p>
<p>
<b>For MS-DOS®</b></p>
<pre><code>LINK CobProg CProg MFC6INTF C6DOSIF C6DOSLB,,,LCOBOL COBAPI 
 &nbsp;&nbsp;&nbsp; LLIBCE/NOE/NOD;
</code></pre>
<p>
<b>For OS/2®</b></p>
<pre><code>LINK CobProg CProg MFC6INTF C6OS2IF C6OS2LB,,,LCOBOL OS2 
 &nbsp;&nbsp;&nbsp; LLIBCEP/NOE/NOD;
</code></pre>
<p>
The standard LINK line for C CALLing COBOL is as follows:</p>
<p>
<b>For DOS</b></p>
<pre><code>LINK CProg CobProg,,,LLIBCE LCOBOL COBAPI/NOE/NOD;
</code></pre>
<p>
<b>For OS/2</b></p>
<pre><code>LINK CProg CobProg,,,LLIBCEP LCOBOL OS2/NOE/NOD;
</code></pre>
<p>
Note that the order in which the libraries are specified in the LINK line is important.</p>
<p>
Microsoft® COBOL versions 4.0 and 4.5 introduced the shared run-time system. Although it is generally more useful to link your applications using the static run-time system (LCOBOL.LIB), you may also choose to link the applications with the shared run-time library (COBLIB.LIB) to take advantage of its more efficient methods of utilizing memory. In order to do this and link your applications to Microsoft C, you must SET the COBPOOL environment variable as referenced in the <i>Microsoft COBOL Operating Guide</i>.</p>
<h2>Common Pitfalls</h2>
<p>
This list supplies a simple checklist to go over when you encounter problems doing mixed-language programming:
<ul type=disc>
<li>
Make certain the version numbers of the two languages are compatible. Microsoft COBOL versions 4.0 and 4.5 are compatible with the C versions 5.1 and 6.<i>x</i>.<br><br></li>
<li>
Use the /NOD switch when LINKing to avoid duplicate definition errors. If duplicate definition errors still occur, use the /NOE switch in addition to the /NOD switch when LINKing.<br><br></li>
<li>
Watch for incompatible functions such as _nfree() and _nheapchk().<br><br></li>
<li>
Make certain the C program is compiled in the large memory model and the /Aulf compile options are used.<br><br></li>
<li>
If passing structures (records) to and from COBOL, use the /Zp1 compile option. (/Zp1 means that structure members will be packed on one-byte boundaries.)<br><br></li>
<li>
When COBOL is the main module and there are some C functions that are not working correctly, make the C routine the main routine and then CALL the COBOL routine. The COBOL routine can then in turn CALL back into the C routines. When this method is used, the COBOL/C support modules do not have to be used. This can correct some incompatibilities.</li>
</ul>
<h2>Batch FIles</h2>
<p>
The following batch files can be helpful when using the sample programs below. The CBC6.BAT file can be used to set your environment table correctly, but think of it as a convenience rather than a necessity when using. This means that you should already have these parameters preset in your environment when using both languages in tandem.</p>
<p>
<b>CBC6.BAT</b></p>
<pre><code>REM THIS BATCH FILE SHOULD CONFIGURE THE ENVIRONMENT TABLE TO ENABLE 
REM YOU TO COMPILE BOTH THE C AND COBOL APPLICATIONS UNDER MS-DOS 
REM CORRECTLY.
REM
REM PLEASE LOOK CLOSELY AT THE ENVIRONMENT SETTINGS AND CHANGE THOSE
REM NECESSARY IN YOUR OWN AUTOEXEC.BAT FILE.
REM
REM NOTE: IF, AFTER INVOKING THIS BATCH FILE, YOU SEE THE MESSAGE 
REM "OUT OF ENVIRONMENT", YOU WILL HAVE TO INCREASE THE AMOUNT OF 
REM ENVIRONMENT TABLE SPACE. PLEASE SEE YOUR MS-DOS MANUAL UNDER THE 
REM HEADING COMMAND.COM FOR INSTRUCTIONS ON HOW TO DO THIS.
REM
SET LIB=C:\COBOL\LIB;C:\C600\LIB
SET INCLUDE=C:\C600\INCLUDE;C:\COBOL\SOURCE
SET HELPFILES=C:\C600\HELP\*.HLP
SET INIT=C:\C600\INIT;C:\COBOL\INIT
PATH=C:\COBOL\BINB;C:\COBOL\BINR;C:\C600\BINB;C:\C600\BIN;C:\DOS
</code></pre>
<p>
<b>RUN.BAT</b></p>
<pre><code>REM THIS BATCH FILE CAN BE USED TO COMPILE AND LINK BOTH THE C AND 
REM COBOL APPLICATIONS FOR MS-DOS.
REM
REM THOSE PROGRAMS THAT REQUIRE A DIFFERENT METHOD OF COMPILING AND 
REM LINKING WITHIN THE SCOPE OF THIS APPLICATION NOTE WILL BE NOTED.
REM
REM TO INVOKE THIS BATCH FILE, YOU MUST ENTER THE BATCH FILE NAME, 
REM FOLLOWED BY THE C PROGRAM NAME (WITH NO EXTENSION), FOLLOWED BY 
REM THE COBOL PROGRAM NAME. FOR EXAMPLE:
REM
REM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUN &lt;C PROGRAM NAME&gt; &lt;COBOL PROGRAM NAME&gt;
REM
cl /c /Aulf %1.c
COBOL %2;
LINK %2&nbsp; %1 MFC6INTF C6DOSIF C6DOSLB,,,LCOBOL COBAPI LLIBCER /NOD/NOE;
</code></pre>
<p>
<b>RUN_C.BAT</b></p>
<pre><code>REM THIS BATCH FILE CAN BE USED TO COMPILE AND LINK UNDER MS-DOS 
REM ONLY WHEN THE SAMPLE C CODE IS CALLING A COBOL PROCEDURE.
REM
REM THOSE PROGRAMS THAT REQUIRE A DIFFERENT METHOD OF COMPILING AND 
REM LINKING WITHIN THE SCOPE OF THIS APPLICATION NOTE WILL BE NOTED.
REM
REM TO INVOKE THIS BATCH FILE, YOU MUST ENTER THE BATCH FILE NAME, 
REM FOLLOWED BY THE C PROGRAM NAME (WITH NO EXTENSION), FOLLOWED BY 
REM THE COBOL PROGRAM NAME. FOR EXAMPLE:
REM
REM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUN &lt;C PROGRAM NAME&gt; &lt;COBOL PROGRAM NAME&gt;
REM
cl /c /Aulf %1.c
COBOL %2;
LINK %1&nbsp; %2,,,LLIBCER LCOBOL COBAPI/NOD/NOE;
</code></pre>
<p>
<b>WINRUN.BAT</b></p>
<pre><code>REM THIS BATCH FILE IS USED TO COMPILE AND LINK THE QUICKWIN 
REM APPLICATION PROGRAM DEMONSTRATED IN THIS DOCUMENT. THIS IS A 
REM SPECIALIZED BATCH FILE. IT HAS BEEN CREATED SPECIFICALLY FOR THE 
REM SAMPLE PROGRAM PRESENTED.
REM TO CREATE A GENERIC BATCH FILE, CHANGE ALL OCCURRENCES CDLL AND 
REM TEST TO %1 AND %2 RESPECTIVELY.
REM
cl /ML /Gs /c /Zi CDLL.C
LINK CDLL+LIBENTRY,CDLL.DLL,CDLL.MAP/MAP,LDLLCEW+LIBW/NOE/NOD,CDLL 
 &nbsp;&nbsp;&nbsp; /CO;
IMPLIB CDLL.LIB CDLL.DLL
COPY CDLL.DLL C:\
COBOL TEST TARGET(286);
LINK CBLWINC+TEST+ADIS+ADISINIT+ADISKEY,TEST.EXE,,LIBW+LLIBCEW+LCOBOL+
 &nbsp;&nbsp;&nbsp; COBAPIDW+CDLL.LIB,TEST.DEF/NOE/NOD;
</code></pre>
<h2>Sample Code</h2>
<p>
The following sample code demonstrates how to pass common numeric types to a C routine by reference and by value.</p>
<p>
<b>COBNUMS.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Passing Common Numeric Types to C by Reference and by Value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 field1 pic 9(4) comp-5 value 123.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 field2 pic 9(8) comp-5 value 123456.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 field3 pic 9(4) comp-5 value 456.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 field4 pic 9(8) comp-5 value 456789.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division.
 &nbsp;&nbsp;&nbsp;&nbsp; * Fields 1 and 2 (below) are passed BY REFERENCE. The keywords
 &nbsp;&nbsp;&nbsp;&nbsp; * are omitted here since BY REFERENCE is the default method.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call "_CFUNC" using field1, field2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; by value field3,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; by value field4.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Returned pic 9(4): " field1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Returned pic 9(8): " field2.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>CFUNC.C</b></p>
<pre><code>#include &lt;stdio.h&gt;
void CFunc(int *RefInt, long *RefLong, int ValInt, long ValLong)
{
 &nbsp; printf("By Reference: %i %li\r\n", *RefInt, *RefLong);
 &nbsp; printf("By Value&nbsp;&nbsp;&nbsp; : %i %li\r\n", ValInt, ValLong);

 &nbsp; *RefInt = 321;
 &nbsp; *RefLong = 987654;
}
</code></pre>
<p>
<b>OUTPUT</b></p>
<pre><code>Returned PIC 9(4): 00321
Returned PIC 9(8): 000987654
By Reference: 123 123456
By Value&nbsp;&nbsp;&nbsp; : 456 456789
</code></pre>
<p>
The following sample code demonstrates how to pass an alphanumeric string from C to COBOL.</p>
<p>
<b>_COBPROG.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;program-id. "_cobprog".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; linkage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 field1 pic x(6).

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division using field1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "String from C: " field1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>C.C</b></p>
<pre><code>#include &lt;stdio.h&gt;
extern cdecl cobprog(char *Cptr);
char Cptr[] = "ABCDEF";
void main() {
 &nbsp; cobprog(Cptr);
}
</code></pre>
<p>
<b>Output</b></p>
<pre><code>String from C: ABCDEF
</code></pre>
<p>
The following sample code demonstrates how to pass a record from COBOL to a C data struct.</p>
<p>
<b>STRUCT.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$set vsc2&nbsp; rtncode-size(4)
 &nbsp;&nbsp;&nbsp;&nbsp; * Passing a Record from COBOL to a C struct
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 rec-1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02 var1&nbsp; pic X(8)&nbsp; value "HELLO".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02 var2&nbsp; pic X(12) value "W O R LD".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02 varc2 pic 9(04) comp-5 value 2.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02 varc3 pic 9(04) comp-5 value 3.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02 varc4 pic 9(04) comp-5 value 4.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02 varc5 pic 9(04) comp-5 value 5.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02 varc1 pic 9(04) comp-5 value 1.

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call "C_FUNCTION1" using by reference rec-1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "CBL varC--&gt; " varC1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "CBL varC--&gt; " varC2.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "CBL varC--&gt; " varC3.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "CBL varC--&gt; " varC4.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "CBL varC--&gt; " varC5.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "CBL var1--&gt; " var1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "CBL var2--&gt; " var2.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>STRUCTC.C</b></p>
<pre><code>#include &lt;stdio.h&gt;
struct struct1 {
 &nbsp; unsigned char var1[8];
 &nbsp; unsigned char var2[12];
 &nbsp; unsigned int&nbsp; var3[5];
};
 
function1(struct struct1 far *p1)
{
 &nbsp; int a;
 &nbsp; for (a=0; a&lt;5; a++)
 &nbsp;&nbsp;&nbsp;&nbsp; printf("%i\n",p1-&gt;var3[a]);
 
 &nbsp; for (a=0; a&lt;8; a++)
 &nbsp;&nbsp;&nbsp;&nbsp; printf("%c", p1-&gt;var1[a]);
 &nbsp;&nbsp;&nbsp;&nbsp; printf("\n");
 
 &nbsp; for (a=0; a&lt;12; a++)
 &nbsp;&nbsp;&nbsp;&nbsp; printf("%c", p1-&gt;var2[a]);
 &nbsp; printf("\n");
}
</code></pre>
<p>
<b>OUTPUT</b></p>
<pre><code>2
3
4
5
1
HELLO
W O R LD
CBL VARC--&gt; 00001
CBL VARC--&gt; 00002
CBL VARC--&gt; 00003
CBL VARC--&gt; 00004
CBL VARC--&gt; 00005
CBL VAR1--&gt; HELLO
CBL VAR2--&gt; W O R LD
</code></pre>
<p>
The following sample code demonstrates how to pass a record from struct from C to COBOL.</p>
<p>
<b>_COBPROC.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;identification division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; environment division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 Integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic 9(4).
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 Long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic 9(8).
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; linkage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 CobRec.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 03 COBInt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic s9(4) comp-5 value zero.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 03 COBLong&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic s9(8) comp-5 value zero.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 03 COBString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic x(21) value spaces.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division using CobRec.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; move COBInt to Integer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; move COBLong to Long.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Integer from C: " Integer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Long integer from C: " Long.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "String from C: " COBString.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit program.
</code></pre>
<p>
<b>STRUCT2C.C</b></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;stdlib.h&gt;
 &nbsp;&nbsp;&nbsp; struct CobRec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // defines data type CobRec
 &nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int varInt;&nbsp;&nbsp; // integer variable 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long varLong; // long int
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char szString[21];&nbsp;&nbsp;&nbsp;&nbsp; // string variable
 &nbsp;&nbsp;&nbsp; };

/* COBOL routines are cdecl; this means the name must be prefixed
 * with '_'. Alternatively, you can manually reverse the
 * parameters.
 */
extern far cdecl COBPROC(struct CobRec *cPtr);

main() 
{
 &nbsp; struct CobRec *cPtr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // declare pointer to struct

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get memory to hold struct
 &nbsp; cPtr = (struct CobRec *) _fmalloc(sizeof(struct CobRec));

/* NOTE: COBOL will be the main program unless BP is nonzero.
 * BP is zero until some local variables are allocated and used.
 *
 * In this example, we do use some local variables; therefore, this
 * is taken care of already.
 */
 &nbsp; printf("Positive Integers and String\n");
 &nbsp; cPtr-&gt;varInt = 32767;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // refer to member of struct and
 &nbsp; cPtr-&gt;varLong = 60000;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // assign values
 &nbsp; strcpy(cPtr-&gt;szString,"This is a test string");

 &nbsp; COBPROC ( cPtr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // CALL to COBOL procedure

 &nbsp; printf("\n\n\n");

 &nbsp; printf("Negative Integers and String\n");
 &nbsp; cPtr-&gt;varInt = -32765;
 &nbsp; cPtr-&gt;varLong = -987654;
 &nbsp; strcpy(cPtr-&gt;szString,"Here's another string\n");

 &nbsp; COBPROC ( cPtr);
}
</code></pre>
<p>
<b>OUTPUT</b></p>
<pre><code>Positive Integers and String
Integer from C: 2767
Long integer from C: 00060000
String from C: This is a test string



Negative Integers and String
Integer from C: 2765
Long integer from C: 00987654
String from C: Here's another string
</code></pre>
<p>
The following sample code demonstrates how to pass an array of integers from COBOL to C.</p>
<p>
<b>INTARRAY.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Passing an Array of Integers from COBOL to C
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 t-count pic 99.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 t-table.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 05 the-table pic 9(4) comp-5 occurs 5 times.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perform varying t-count from 1 by 1 until t-count &gt; 5
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; move t-count to the-table(t-count)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end-perform.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call "C_CProc" using t-table.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>CNTARRAY.C</b></p>
<pre><code>#include &lt;stdio.h&gt;
void CProc(int IntTable[4]) {
 &nbsp; int count;

 &nbsp; for (count = 0; count &lt; 5; count++)
 &nbsp;&nbsp;&nbsp; printf("Array [%i]: %i\r\n", count, IntTable[count]);

}
</code></pre>
<p>
<b>OUTPUT</b></p>
<pre><code>Array [0]: 1
Array [1]: 2
Array [2]: 3
Array [3]: 4
Array [4]: 5
</code></pre>
<p>
The following sample code demonstrates how to pass a two-dimensional array of long integers from COBOL to C.</p>
<p>
<b>LINT.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Passing long integers from COBOL to C
 &nbsp;&nbsp;&nbsp;&nbsp; $set bound
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 I1 pic 9.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 J1 pic 9.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 t-table.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02 t-field occurs 2 times.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 05 the-table pic 9(8) comp-5 occurs 3 times.

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perform varying I1 from 1 by 1 until I1 &gt; 2
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perform varying J1 from 1 by 1 until J1 &gt; 3
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; move J1 to the-table(I1, J1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end-perform
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end-perform.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call "_CProc" using t-table.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>LINTC.C</b></p>
<pre><code>#include &lt;stdio.h&gt;
void CProc(long IntTable[2][3]) {
 &nbsp; int i, j;

 &nbsp; for (i = 0; i &lt; 2; i++)
 &nbsp;&nbsp;&nbsp;&nbsp; for (j = 0; j &lt; 3; j++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Array [%i,%i]: %ld\r\n", i, j, IntTable[i][j]);

}
</code></pre>
<p>
<b>OUTPUT</b></p>
<pre><code>Array [0,0]: 1
Array [0,1]: 2
Array [0,2]: 3
Array [1,0]: 1
Array [1,1]: 2
Array [1,2]: 3
</code></pre>
<p>
The following sample code demonstrates how to pass a two-dimensional array of records from C to COBOL</p>
<p>
<b>_COBPROC.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;program-id. "_CobProc".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 I1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic 9.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 J1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic 9.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; linkage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 the-table.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02 t-table occurs 2 times.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 05 t-field occurs 3 times.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 field1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic 9(4) comp-5.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 field2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic x(6).

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division using the-table.

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perform varying I1 from 1 by 1 until I1 &gt; 2
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perform varying J1 from 1 by 1 until J1 &gt; 3
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "table[" I1 "][" J1 "]: " field1(I1, J1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " field2(I1, J1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end-perform
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end-perform.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>2DRECS.C</b></p>
<pre><code>#include &lt;stdio.h&gt;

struct TableStruc {&nbsp;&nbsp;&nbsp; /* define structure */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int TheInt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char String[6];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } TheTable[2][3];

extern void far cdecl CobProc(struct TableStruc TheTable[2][3]);

void main() {
 &nbsp; int i, j;

 &nbsp; for (i = 0; i &lt; 2; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* initialize structure */
 &nbsp;&nbsp;&nbsp;&nbsp; for (j = 0; j &lt; 3; j++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TheTable[i][j].TheInt = j;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sprintf(TheTable[i][j].String, "[%1i][%1i]", i, j);
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; CobProc(TheTable);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* CALL COBOL routine */
}
</code></pre>
<p>
<b>OUTPUT</b></p>
<pre><code>table[1][1]: 00000
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0][0]
table[1][2]: 00001
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0][1]
table[1][3]: 00002
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0][2]
table[2][1]: 00000
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1][0]
table[2][2]: 00001
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1][1]
table[2][3]: 00002
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1][2]
</code></pre>
<p>
The following sample code demonstrates how to pass integers by reference from COBOL to&nbsp; C.</p>
<p>
<b>COBINT.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Passing integers by reference from COBOL to C 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 passvar1 pic 9(4) comp-5 value 16384.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 passvar2 pic 9(4) comp-5 value 33.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Before the call to the C swapping function...".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Passvar1 is equal to: " passvar1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Passvar2 is equal to: " passvar2.

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call "_SwapFunc" using by reference passvar1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; by reference passvar2.

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "After the call to the C swapping function...".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Passvar1 is equal to: " passvar1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Passvar2 is equal to: " passvar2.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>CINT.C</b></p>
<pre><code>/* Manipulates integers passed from a COBOL program */
#include &lt;stdio.h&gt;

void SwapFunc(int *var1, int *var2)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Temporary value for use in swap */

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = *var1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *var1 = *var2;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *var2 = tmp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp; }
</code></pre>
<p>
<b>OUTPUT</b></p>
<pre><code>Before the call to the C swapping function...
PassVar1 is equal to: 16384
PassVar2 is equal to: 00033
After the call to the C swapping function...
PassVar1 is equal to: 00033
PassVar2 is equal to: 16384
</code></pre>
<p>
The following sample code demonstrates how to pass an integer from COBOL to C.</p>
<p>
<b>CBLINT.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 pass-var pic 9(4) comp-5 value 3.

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call "_Circum" using by value pass-var.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Radius of circle: " pass-var.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Circumference of circle: " return-code.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>C.C</b></p>
<pre><code>#include &lt;stdio.h&gt;

int Circum(int Radius) {
 &nbsp;&nbsp; float cir;
 &nbsp;&nbsp; cir = 3.14159 * Radius * Radius;
 &nbsp;&nbsp; return((int) cir);
}
</code></pre>
<p>
<b>OUTPUT</b></p>
<pre><code>Radius of circle: 00003
Circumference of circle: +0028
</code></pre>
<p>
The following sample code demonstrates passing a long integer from COBOL to C.</p>
<p>
<b>LINT.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;$set rtncode-size(2)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 pass-var pic 9(4) comp-5.

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Radius of circle?".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accept pass-var.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call "_Area" using by value pass-var.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Area of circle: " return-code.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>LINTC.C</b></p>
<pre><code>#include &lt;stdio.h&gt;
long Area(int Radius) {
 &nbsp;&nbsp; float cir;
 &nbsp;&nbsp; cir = 3.14159 * Radius * Radius;
 &nbsp;&nbsp; return((long) cir);
}
</code></pre>
<p>
<b>OUTPUT</b></p>
<pre><code>Radius of circle?
1
Area of circle: +0003
</code></pre>
<p>
The following sample code demonstrates how to pass a string from COBOL to C.</p>
<p>
<b>COBSTR.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Passing a string from COBOL to C
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identification division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program-id. cobstr.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 passvar pic x(15) value "Replace this".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "This is what is passed: " passvar.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call "_Funct" using pass-var.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "This is what comes back: " passvar.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>CSTR.C</b></p>
<pre><code>#include &lt;ctype.h&gt;

void * Funct(char *Rvalue)
 &nbsp; {
 &nbsp;&nbsp; char *cp;
 &nbsp;&nbsp; cp = Rvalue;
 &nbsp;&nbsp; while (*cp != '\0') {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *cp = toupper(*cp);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++cp;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return;
 &nbsp; }
</code></pre>
<p>
<b>OUTPUT</b></p>
<pre><code>This is what is passed: Replace this
This is what comes back: REPLACE THIS
</code></pre>
<p>
The following samples demonstrate how to call a C 6.<i>x</i> routine from a COBOL 4.5 program, where the C function, in turn, spawns another COBOL 4.5 executable.</p>
<p>
Note: The COBOL program titled COB2.CBL must be compiled and linked as a stand-alone executable module. Use the following lines to compile and link this program:</p>
<pre><code>&nbsp;&nbsp;&nbsp;COBOL COB2;
 &nbsp; LINK COB2,,,LCOBOL COBAPI/NOE/NOD;
</code></pre>
<p>
<b>MAIN.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* How to call a C function that executes another COBOL 
 &nbsp;&nbsp;&nbsp;&nbsp; * program.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program-id.&nbsp;&nbsp;&nbsp;&nbsp; main.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01 commandL.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 05&nbsp; filler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic x(01)&nbsp; value 'S'.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 05&nbsp; cmdlin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic x(124) value "COB2.EXE".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "In COBOL program 1".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call "_pcexec" using commandL.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "End of COBOL program 1".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>PCEXEC.C</b></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;process.h&gt;
pcexec (commandL)
char far commandL[125];
{
 &nbsp;&nbsp;&nbsp; printf ("Prior to C call of COB2.EXE \n");
 &nbsp;&nbsp;&nbsp; spawnl (P_WAIT, "COB2.EXE", "COB2", "spawnl", NULL);
 &nbsp;&nbsp;&nbsp; printf("After C call to COB2.EXE \n");
}
</code></pre>
<p>
<b>COB2.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* This program must be a separate executable.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program-id.&nbsp;&nbsp;&nbsp;&nbsp; cob2.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Inside COBOL program 2".
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>OUTPUT</b></p>
<pre><code>In COBOL program 1
Prior to C call of COB2.EXE
Inside COBOL program 2
After C call to COB2.EXE
End of COBOL program 1
</code></pre>
<p>
The following samples demonstrate how a COBOL 4.5 Quickwin application can call a Windows-based DLL written in C 6.<i>x</i>. </p>
<p>
<b>MAIN.CBL</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;working-storage section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 77 Var1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic 9(4) comp-5.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 77 Char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic x.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure division.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; move 1 to Var1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "Prior to DLL call: " at 0101
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display Var1 at 0120.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call 'cdll' using by reference Var1.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display "After DLL call: " at 0201.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display Var1 at 0217.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call "cbl_read_kbd_char" using Char.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop run.
</code></pre>
<p>
<b>MAIN.DEF</b></p>
<pre><code>EXETYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WINDOWS 3.0
APPLOADER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '__MSLANGLOAD'
PROTMODE
STUB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'WINSTUB.EXE'
CODE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRELOAD FIXED
DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRELOAD FIXED MULTIPLE
STACKSIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16384
HEAPSIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024
EXPORTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WNDPROC
</code></pre>
<p>
<b>CDLL.C</b></p>
<pre><code>#include &lt;windows.h&gt;
int FAR PASCAL LibMain(HANDLE hInstance,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD&nbsp; wDataSeg,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD&nbsp; cbHeapSize,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR lpszCmdLine)
{
//Additional DLL initialization fits here
if (cbHeapSize != 0)
 &nbsp;&nbsp; UnlockData(0);
return (1);
}

VOID FAR PASCAL cdll(int _far *piIntPointer)
{
if((*piIntPointer &gt;= -32768) &amp;&amp; (*piIntPointer &lt; 32767))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; (*piIntPointer)++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(1);
 &nbsp; }
else
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(0);
 &nbsp; }
}

VOID FAR PASCAL WEP (int nParameter)
{
if (nParameter == WEP_SYSTEM_EXIT)
 &nbsp; {
 &nbsp; return (1);
 &nbsp; }
else
 &nbsp; { if (nParameter == WEP_FREE_DLL)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; return (1);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; else&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (1);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
}
</code></pre>
<p>
<b>CDLL.DEF</b></p>
<pre><code>LIBRARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cdll
DESCRIPTION&nbsp;&nbsp;&nbsp;&nbsp; 'C DLL FOR WINDOWS 3.0'
EXETYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WINDOWS
STUB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'WINSTUB.EXE'
CODE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRELOAD MOVEABLE DISCARDABLE
DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRELOAD MOVEABLE SINGLE
HEAPSIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
EXPORTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cdll&nbsp;&nbsp;&nbsp; @1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WEP&nbsp;&nbsp;&nbsp;&nbsp; @2 RESIDENTNAME
</code></pre>
</BODY>
</HTML>
