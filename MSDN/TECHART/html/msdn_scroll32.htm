<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Scroll Bar Controls in Win32</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_scroll32"></a>Scroll Bar Controls in Win32</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: October 28, 1993</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="1901">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the Sizebox sample application.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="1902">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the Scroll32 sample application.</a></p>
<h2>Abstract</h2>
<p>
This article describes the functionality and design of scroll bar controls in the Microsoft® Win32® Application Programming Interface (API). It covers the following:
<ul type=disc>
<li>
Common programming techniques associated with scroll bars.<br><br></li>
<li>
The functions that are used to manipulate scroll bars.<br><br></li>
<li>
The messages that are sent to scroll bars.<br><br></li>
<li>
Current limitations and known problems with scroll bars. Whenever possible, I have provided a workaround for a given limitation or bug.</li>
</ul>
<h2>Introduction</h2>
<p>
A scroll bar control is a rectangular window that contains a scroll box (usually called the <i>thumb</i> of the scroll bar) and two scroll arrows. The scroll bar control sends a notification message to its parent window whenever the user clicks the control with the mouse. The parent window is responsible for updating the parent window's contents and the position of the thumb (if necessary).</p>
<p>
A scroll bar is part of a window, but a scroll bar control is actually a window itself. Unlike a scroll bar, a scroll bar control can be positioned anywhere in a window and used whenever the window needs to scroll input.</p>
<p>
If you are comfortable with the use of scroll bars in Win16, you have already mastered most of the information in this technical article. There are, however, some differences between Win16 and Win32® scroll bars. The major difference is that Win32 scroll bars allow full 32-bit positioning while Win16 scroll bars allow 16-bit positioning. Currently, Win32 scroll bars are limited to 16 bits of positioning information during real-time scrolling (thumb tracking). However, I have come up with a workaround that will allow you to get the full 32 bits of positioning. (See the "Limitations" section of this technical article.)</p>
<p>
The SBS_SIZEBOX scroll bar style is not fully described in the Microsoft® Windows® documentation. For a full description of this style, see the "Using the SBS_SIZEBOX Window Style" section of this article. You can use the SBS_SIZEBOX style in both Win16 and Win32.</p>
<h2>Anatomy of a Scroll Bar</h2>
<p>
A scroll bar consists of a shaded shaft with a scroll arrow at each end and a scroll box (usually called a <i>thumb</i>) between the arrows (see Figure 1).</p>
<p>
<img src="scroll32_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The anatomy of a scroll bar</b></p>
<p>
A scroll bar represents the full range (overall length or width) of a data object such as a document or picture in the window's client area. The thumb represents the portion of the data object that is visible in the client area. The user can scroll the contents of the window by clicking one of the scroll arrows, by clicking the area in the shaded shaft, or by dragging the thumb. For example, when the user clicks the up arrow, the thumb moves up and the application scrolls the contents of the window by one unit (typically a single line or column). When the user clicks inside the shaft, the application scrolls the contents by one window. The amount of scrolling that occurs when the user drags the thumb is known as the <i>scrolling range</i> and is defined by the application developer.</p>
<h2>Scroll Bar Styles</h2>
<p>
This section describes the styles that you can use when creating your scroll bar. These styles are also documented in the Microsoft Win32 SDK for Windows NT™ (see Product Documentation, SDKs, Win32 SDK, Programmer's API Reference Vol. 1, Part 1: Window Management, Chapter 14, "Scroll Bars" in the MSDN Library).</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=41%><b>Style</b></td>
<td class=label width=59%><b>Functionality</b></td>
</tr>
<tr valign=top>
<td width=41%>SBS_BOTTOMALIGN</td>
<td width=59%>Places a horizontal scroll bar at the bottom of the rectangle specified by the <b>CreateWindow</b> rectangle parameters. The scroll bar has the default height for system scroll bars. This style is used with the SBS_HORZ style.</td>
</tr>
<tr valign=top>
<td width=41%>SBS_HORZ</td>
<td width=59%>Creates a horizontal scroll bar. The scroll bar is sized according to the rectangle values passed to <b>CreateWindow</b> if neither the SBS_BOTTOMALIGN nor SBS_TOPALIGN style is specified.</td>
</tr>
<tr valign=top>
<td width=41%>SBS_LEFTALIGN</td>
<td width=59%>Places a vertical scroll bar at the left edge of the rectangle specified by the <b>CreateWindow</b> rectangle parameters. The scroll bar has the default width for system scroll bars. This style is used with the SBS_VERT style.</td>
</tr>
<tr valign=top>
<td width=41%>SBS_RIGHTALIGN</td>
<td width=59%>Places a vertical scroll bar at the right edge of the rectangle specified by the <b>CreateWindow</b> rectangle parameters. The scroll bar has the default width for system scroll bars. This style is used with the SBS_VERT style.</td>
</tr>
<tr valign=top>
<td width=41%>SBS_SIZEBOX</td>
<td width=59%>Creates a size box. (A size box is a small rectangle that is used to set the size of its parent window. See the "Using the SBS_SIZEBOX Window Style" section later in this article for more information.) If you don't specify the SBS_SIZEBOXBOTTOMRIGHTALIGN or the SBS_SIZEBOXTOPLEFTALIGN style, the size box has the height, width, and position specified by the <b>CreateWindow</b> rectangle parameters.</td>
</tr>
<tr valign=top>
<td width=41%>SBS_SIZEBOXBOTTOMRIGHTALIGN</td>
<td width=59%>Places the size box with the lower-right corner of the rectangle specified by the <b>CreateWindow</b> rectangle parameters. The size box has the default size for system size boxes. This style is used only with the SBS_SIZEBOX style.</td>
</tr>
<tr valign=top>
<td width=41%>SBS_SIZEBOXTOPLEFTALIGN</td>
<td width=59%>Places the size box with the upper-left corner of the rectangle specified by the <b>CreateWindow</b> rectangle parameters. The size box has the default size for system size boxes. This style is used only with the SBS_SIZEBOX style. </td>
</tr>
<tr valign=top>
<td width=41%>SBS_TOPALIGN</td>
<td width=59%>Puts a horizontal scroll bar at the top edge of the rectangle defined by the <b>CreateWindo</b>w rectangle parameters. The scroll bar has the default height for system scroll bars. This style is used with the SBS_HORZ style. </td>
</tr>
<tr valign=top>
<td width=41%>SBS_VERT</td>
<td width=59%>Creates a vertical scroll bar. If don't you specify the SBS_RIGHTALIGN or SBS_LEFTALIGN style, the scroll bar has the position specified by the <b>CreateWindow</b> rectangle parameters.</td>
</tr>
</table><br>
<h2>Scroll Bar Techniques</h2>
<h3>Adding a Scroll Bar to a Window</h3>
<p>
If you want to allow users to scroll the contents of your window, you can add horizontal and vertical scroll bars to the window simply by adding the WS_HSCROLL and WS_VSCROLL styles to your window in your call to <b>CreateWindow</b>. This creates the look of a "traditional" window.</p>
<pre><code>&nbsp;&nbsp;&nbsp;hWnd = CreateWindow(
 &nbsp;&nbsp;&nbsp;&nbsp; "TypicalWindow",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; "Test", 
 &nbsp;&nbsp;&nbsp;&nbsp; WS_OVERLAPPEDWINDOW | WS_HSCROLL | WS_VSCROLL,
 &nbsp;&nbsp;&nbsp;&nbsp; CW_USEDEFAULT, CW_USEDEFAULT, 300, 150,
 &nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; hInstance,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; NULL);
</code></pre>
<h3>Scrolling Text in a Window</h3>
<p>
When you add scroll bar(s) to your window, Windows notifies you whenever the user clicks the scroll bar. The application responds to these notification messages by redrawing the contents of the window that need to be redrawn. One common method of scrolling a window's contents is to call the <b>ScrollWindow</b> or <b>ScrollWindowEx</b> function with a parameter specifying the rectangular area that needs to be scrolled and drawing only the area that contains new information.</p>
<p>
A typical method used to scroll text in a window involves the following steps:
<ol>
<li>
Get the current text metrics for the window, and calculate how many lines of code will fit on the screen.<br><br></li>
<li>
Set the vertical scroll range and the scroll position based on the number of additional lines you need to display. Use the text metric for average character height in this calculation.<br><br></li>
<li>
Set the horizontal scroll range and scroll position based on the amount of text available for horizontal viewing. Use the text metric for average character width in this calculation.<br><br></li>
<li>
Once a scroll notification is given, scroll the window using the <b>ScrollWindow</b> function. Note that <b>ScrollWindow</b> invalidates part of the window for repainting. An example of this is shown in the code below. For a full code listing of this scrolling technique, see the Win32 SDK, Programmer's API Reference Vol. 1, Part 1: Window Management, Chapter 14, section 14.2.2.5, "Scrolling Text" in the MSDN Library (look under Product Documentation, SDKs, in the Source list). In the code listing below, <i>xInc</i> is the increment amount, <i>xPos</i> is the current scroll position, and <i>xMax</i> is the maximum horizontal scrolling position.<pre><code>/*
* Increment the scrolling position, adjust the position
* of the thumb, and update the window.
*/
if (xInc = max (-xPos, min (xInc, xMax - xPos))) {
xPos += xInc;
ScrollWindow (hwnd, -xChar * xInc, 0,
(CONST RECT *) NULL, (CONST RECT *) NULL);
SetScrollPos (hwnd, SB_HORZ, xPos, TRUE);
UpdateWindow (hwnd);
}
</code></pre>
</li>
<li>
Draw the text out to the screen using the current vertical scrolling position and the coordinates of the invalid rectangle to determine the range of new lines that should be drawn.<br><br></li>
<li>
In the case of a horizontal or vertical scroll notification, reset the scroll position based on an appropriate increment. For example, if the user clicks the right scroll arrow, increment your scroll position by one unit. If the user drags the thumb to the end of the scroll bar, calculate the end point and set your position to that point.</li>
</ol>
<h3>Creating a Typical Scroll Bar Control</h3>
<p>
It is possible to create a scroll bar control that acts exactly like the scroll bars created by calling <b>CreateWindow</b> with WS_HORZ or WS_VERT. Since the system already generates these scroll bars for you, there is no need to do this work. If, however, you wish to alter the standard look or function of the scroll bar, you can either subclass the scroll bars on your window or create a stand-alone control. To illustrate how built-in scroll bars work, I will now explain how you can create a scroll bar that looks and acts exactly like a system-generated scroll bar.</p>
<p>
You can create a scroll bar control that is a stand-alone control by specifying the Scrollbar class in your call to <b>CreateWindow</b>. When the scroll bar has been created, set the range of the scroll bar by calling <b>SetScrollRange</b>. Set the size of the scroll bar based on the parent window's client area and the system metrics of the thumb size of the scroll bar. (This calculation ensures that your scroll bar controls look and work exactly like the scroll bars you generate by specifying WS_HORZ and WS_VERT in the <b>CreateWindow</b> call.) Specify SBS_BOTTOMALIGN for the horizontal scroll bar and SBS_RIGHTALIGN for the vertical scroll bar.</p>
<pre><code>// Get the client rectangle of the parent window.
GetClientRect( hWndParent, &amp;RclParent);
iHThumb = GetSystemMetrics(SM_CXHTHUMB);
iVThumb = GetSystemMetrics(SM_CYVTHUMB);

// Create a horizontal scroll bar to put in the window.
hWndHorzScroll = CreateWindow(
 &nbsp;&nbsp; "SCROLLBAR", 
 &nbsp;&nbsp; (LPSTR)NULL,
 &nbsp;&nbsp;&nbsp; WS_CHILD | WS_VISIBLE | SBS_HORZ | SBS_BOTTOMALIGN,
 &nbsp;&nbsp;&nbsp; RclParent.left,RclParent.top,RclParent.right-iHThumb,RclParent.bottom,
 &nbsp;&nbsp;&nbsp; hWndParent,
 &nbsp;&nbsp;&nbsp; (HMENU)IDC_HSCROLL,
 &nbsp;&nbsp;&nbsp; (HANDLE)hInstance,
 &nbsp;&nbsp;&nbsp; NULL);

SetScrollRange( hWndHorzScroll, SB_CTL, 0, MAX_RANGE, FALSE);

// Create a vertical scroll bar to put in the window.
hWndVertScroll = CreateWindow(
 &nbsp;&nbsp; "Scrollbar", 
 &nbsp;&nbsp; (LPSTR)NULL,
 &nbsp;&nbsp; WS_CHILD | WS_VISIBLE | SBS_VERT | SBS_RIGHTALIGN,
 &nbsp;&nbsp; RclParent.left,RclParent.top,RclParent.right,RclParent.bottom-iVThumb,
 &nbsp;&nbsp; hWndParent,
 &nbsp;&nbsp; (HMENU)IDC_VERT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; hInstance,
 &nbsp;&nbsp; NULL);

SetScrollRange( hWndVertScroll, SB_CTL, 0, MAX_RANGE, FALSE);
</code></pre>
<p>
When you create these scroll bars, you will notice a white rectangle in the bottom corner of the screen where traditionally you would see a light gray rectangle. This area is drawn in response to the WM_PAINT message in your parent window procedure. The code below illustrates this method.</p>
<pre><code>RECT Rcl;
HDC hDC;
PAINTSTRUCT ps;

Rcl.left = RclParent.right - iHThumb;
Rcl.right = RclParent.right;
Rcl.top = RclParent.bottom - iVThumb;
Rcl.bottom = RclParent.bottom;
hDC = BeginPaint(hWnd, &amp;ps);
FillRect(hDC, &amp;Rcl, GetStockObject(LTGRAY_BRUSH));
EndPaint(hWnd, &amp;ps);
</code></pre>
<p>
If you want to implement scroll bars that look and act exactly like system-generated scroll bars, you must also take sizing into account. If your parent window is resizable, you will need to resize and redraw your scroll bars and the light gray rectangular fill whenever Windows sends a WM_SIZE message to the parent window procedure.</p>
<h3>Using the SBS_SIZEBOX Window Style</h3>
<p>
If you would like to add functionality to that small "dead" area between your horizontal and vertical scroll bars on your window, you can create a size box. The scroll bar window class provides a style, SBS_SIZEBOX, that can be used as an alternative to the sizing border on your window. A size box is a small rectangle that sits in the corner of your window. The user can drag the size box to resize the window. You can create a size box by using the standard <b>CreateWindow</b> call and specifying SBS_SIZEBOX in the style bits. SBS_SIZEBOX is available in both Win16 and Win32.</p>
<pre><code>hWndSizeBox = CreateWindow(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Scrollbar", 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR)NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_CHILD | WS_VISIBLE | SBS_SIZEBOX | SBS_SIZEBOXTOPLEFTALIGN,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,0,0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hWnd,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (HMENU)10,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInst,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);
</code></pre>
<p>
The function call above creates a size box as a child of the current window and places it in the upper-left corner of the window. If you choose to place the size box in the lower-right corner of your window screen, specify SBS_SIZEBOXBOTTOMRIGHTALIGN instead of SBS_SIZEBOXTOPLEFTALIGN.</p>
<p>
The Sizebox sample that accompanies this technical article demonstrates this control type. It displays a window that prompts you to click and drag the small gray box in the upper-left corner of the window (Figure 2).</p>
<p>
<img src="scroll32_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The Sizebox sample screen</b></p>
<p>
The SBS_SIZEBOXBOTTOMRIGHTALIGN style currently has a bug: The positioning is off by 3 pixels in both directions. The workaround for this problem is to add 3 pixels to the <i>xWidth</i> and <i>yHeight</i> parameters specified in the <b>CreateWindow</b> call.</p>
<p>
You should also note that a size box does not automatically reset its position when its parent window is resized. This is difficult to see in the case of the SBS_SIZEBOXTOPLEFTALIGN style because the size box is positioned at (0, 0) and seems to move along with its parent when the window is resized. However, if you align your size box control at the lower-right corner of the screen (SBS_SIZEBOXBOTTOMRIGHTALIGN), the <i>xWidth</i> and <i>yHeight</i> of the parent window will change. For this reason, you need to reset the position of the size box control using <b>SetWindowPos </b>in response to the WM_SIZE message.</p>
<h2>Scroll Bar Functions</h2>
<p>
Unlike other window classes, scroll bars are manipulated through functions. These functions are described in the sections below.</p>
<p>
The first parameter to each function is the handle to the scroll bar control (or the handle to the owner window, if the scroll bar was created with the WS_HORZ or WS_VERT window style). The second parameter specifies the type of scroll bar to manipulate:
<ul type=disc>
<li>
SB_CTL: A scroll bar control<br><br></li>
<li>
SB_HORZ: The horizontal scroll bar of the specified window<br><br></li>
<li>
SB_VERT: The vertical scroll bar of the specified window<br><br></li>
<li>
SB_BOTH: The horizontal and vertical scroll bars of the specified window</li>
</ul>
<p>
All scroll bar functions return an error in the following cases:
<ul type=disc>
<li>
The second parameter is SB_CTL, but the first parameter is not a valid handle to a scroll bar control.<br><br></li>
<li>
The second parameter is SB_HORZ, SB_VERT, or SB_BOTH, but the first parameter points to a window that does not have a scroll bar child window.</li>
</ul>
<p>
The following function sets the scroll position of the horizontal scroll bar control to 100 and forces a redraw of the scroll bar control:</p>
<pre><code>Err = SetScrollPos(hWndHorzScroll, SB_CTL, 100, TRUE);
</code></pre>
<h3>EnableScrollBar</h3>
<p>
The <b>EnableScrollBar</b> function enables or disables one or both of the scroll arrows. If you specify both vertical and horizontal scroll bars, the system changes the horizontal scroll bar first, changes the vertical scroll bar next, and then forces a redraw of the window. This function supports the SB_CTL, SB_HORZ, SB_VERT, and SB_BOTH flags.</p>
<h3>GetScrollPos</h3>
<p>
The <b>GetScrollPos</b> function returns the current position of the thumb in the specified scroll bar. If you specify a scroll bar control, <b>GetScrollPos</b> sends an SBM_GETPOS message to the control. Otherwise, it returns the thumb position that it keeps internally. This function supports the SB_CTL, SB_HORZ, and SB_VERT flags.</p>
<h3>GetScrollRange</h3>
<p>
The <b>GetScrollRange</b> function returns the current range (minimum and maximum scroll position) of the scroll bar previously set with <b>SetScrollRange</b>. If you specify a scroll bar control, <b>GetScrollRange</b> sends an SBM_GETRANGE message to the control. Otherwise, it returns the minimum and maximum values that it keeps internally for the scroll bar. If the window handle you pass to the function is not a handle to a scroll bar, or if the window specified does not have scroll bars, <b>GetScrollRange</b> returns an error and sets the minimum and maximum values that you pass to the function to 0. This function supports the SB_CTL, SB_HORZ, and SB_VERT flags.</p>
<h3>SetScrollPos</h3>
<p>
The <b>SetScrollPos</b> function sets the position of the thumb in the scroll bar to the specified value. If you specify a scroll bar control, <b>SetScrollPos</b> sends an SBM_SETPOS to the control. Otherwise, the system resets the thumb to the specified position and redraws the scroll bar and thumb. If you specify a position outside the current scroll range, <b>SetScrollPos</b> returns an error.&nbsp; This function supports the SB_CTL, SB_HORZ, and SB_VERT flags.</p>
<h3>SetScrollRange</h3>
<p>
The <b>SetScrollRange</b> function sets the range (minimum and maximum scroll position) of the scroll bar. If you specify a scroll bar control, <b>SetScrollRange</b> sends an SBM_SETRANGE to the control. Otherwise, the system sets the range to the specified minimum and maximum values. If you specify invalid values or pass an invalid window handle to the function, <b>SetScrollRange</b> returns an error. This function supports the SB_CTL, SB_HORZ, and SB_VERT flags.</p>
<h3>ShowScrollBar</h3>
<p>
The <b>ShowScrollBar</b> function shows or hides the specified scroll bar. You can use this function to hide or show a horizontal scroll bar, a vertical scroll bar, both horizontal and vertical scroll bars, or a scroll bar control. If you hide a scroll bar and then show it, you do not have to reset the thumb position and range because the window handle is still valid. This function supports the SB_CTL, SB_HORZ, SB_VERT, and SB_BOTH flags.</p>
<h2>Notification Messages</h2>
<h3>SBM_ENABLE_ARROWS</h3>
<p>
Windows sends an SBM_ENABLE_ARROWS message to a scroll bar control whenever an application wants to enable or disable scroll arrows (when the <b>EnableScrollBar</b> function is called).</p>
<pre><code>wParam = (WPARAM)fuArrows; /* enable/disable flags */
lParam = 0; /* not used - must be zero */
</code></pre>
<p>
The flags you can specify for this message are the same as those you use for <b>EnableScrollBar</b>: ESB_ENABLE_BOTH, ESB_DISABLE_LTUP, ESB_DISABLE_RTDN, and ESB_DISABLE_BOTH.</p>
<h3>SBM_GETPOS</h3>
<p>
Windows sends an SBM_GETPOS message to a scroll bar control whenever <b>GetScrollPos</b> is called. This message returns the current thumb position.</p>
<pre><code>wParam = 0; /* not used - must be zero */
lParam = 0; /* not used - must be 0 */
</code></pre>
<h3>SBM_GETRANGE</h3>
<p>
Windows sends an SBM_GETRANGE message to a scroll bar control whenever <b>GetScrollRange</b> is called. This message retrieves the minimum and maximum scroll values associated with the scroll bar.</p>
<pre><code>wParam = (WPARAM)(LPINT)lpnMinPos; /* minimum scrolling position */
lParam = (LPARAM)(LPINT)lpnMaxPos; /* maximum scrolling position */
</code></pre>
<h3>SBM_SETPOS</h3>
<p>
Windows sends an SBM_SETPOS message to a scroll bar control whenever <b>SetScrollPos</b> is called. If the scroll bar position is changed, the SBM_SETPOS returns the previous position of the thumb; otherwise, it returns 0. If the new position specified with <b>SetScrollPos</b> is outside the current scrolling range, this message will not reset the thumb.</p>
<pre><code>wParam = (WPARAM)nPos; /* new position of the thumb */
lParam = (LPARAM)(BOOL)fReDraw; /* redraw the scroll bar if TRUE */
</code></pre>
<h3>SBM_SETRANGE</h3>
<p>
Windows sends an SBM_SETRANGE message to a scroll bar control whenever <b>SetScrollRange</b> is called. The default minimum and maximum values are 0. The difference between the minimum and maximum value must not exceed 2,147,483,647(0x7FFFFFFF). (The current Win32 SDK documentation states that this limit is 32,767(0x7FFF)—this is incorrect.) If the minimum value equals the maximum value, the scroll bar control is hidden and disabled.</p>
<pre><code>wParam = (WPARAM)nMinPos; /* minimum scrolling position */
lParam = (LPARAM)nMaxPos; /* maximum scrolling position */
</code></pre>
<h3>SBM_SETRANGEREDRAW</h3>
<p>
Windows sends an SBM_SETRANGEREDRAW message to a scroll bar control when the scroll range is set and the redraw flag is TRUE. The default minimum and maximum values are 0. The difference between the minimum and maximum value must not exceed 2,147,483,647(0x7FFFFFFF). (The current Win32 SDK documentation states that this limit is 32,767(0x7FFF)—this is incorrect.) If the minimum value equals the maximum value, the scroll bar control is hidden and disabled.</p>
<pre><code>wParam = (WPARAM)nMinPos; /* minimum scrolling position */
lParam = (LPARAM)nMaxPos; /* maximum scrolling position */
</code></pre>
<h2>Interfacing with the Keyboard</h2>
<p>
The ability to manipulate the scroll bar with the keyboard instead of the mouse is not a built-in function of the scroll bar class. However, implementing scrolling behavior based on keyboard input is a fairly trivial task. One interesting problem associated with this task is determining what to do in the case of the PAGE_UP, PAGE_DOWN, HOME, and END keys. In the example below, I have associated PAGE_UP and PAGE_DOWN with the vertical scroll bar, and HOME and END with the horizontal scroll bar.</p>
<pre><code>case WM_KEYDOWN:
 &nbsp;&nbsp; switch (wParam) 
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VK_UP:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wScrollNotify = SB_LINEUP;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMessage = WM_VSCROLL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VK_PRIOR:&nbsp;&nbsp;&nbsp; //PAGEUP key
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wScrollNotify = SB_PAGEUP;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMessage = WM_VSCROLL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VK_NEXT:&nbsp;&nbsp;&nbsp;&nbsp; // PAGEDOWN key
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wScrollNotify = SB_PAGEDOWN;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMessage = WM_VSCROLL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VK_DOWN:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wScrollNotify = SB_LINEDOWN;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMessage = WM_VSCROLL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VK_HOME:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wScrollNotify = SB_BOTTOM;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMessage = WM_HSCROLL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VK_END:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wScrollNotify = SB_TOP;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMessage = WM_HSCROLL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VK_RIGHT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wScrollNotify = SB_LINEDOWN;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMessage = WM_HSCROLL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VK_LEFT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wScrollNotify = SB_LINEUP;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uMessage = WM_HSCROLL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wScrollNotify = 0xFFFF;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (wScrollNotify != -1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendMessage(hWnd, uMessage, MAKELONG(wScrollNotify, 0), 0L);
 &nbsp;&nbsp;&nbsp; break;
</code></pre>
<h2>Limitations</h2>
<p>
In Win32, you can use 32-bit values to set the range and position of the thumb in the scroll bar. However, if you are doing real-time thumb tracking using the SB_THUMBTRACK message, Win32 will give you only 16 bits of position data. This is because the position data is returned in the HIWORD of the <i>lParam</i>. To get around this limitation, you need to approximate the position yourself. One way to do this is to get the current cursor position, map it to the scroll window, and calculate the position based on the ratio between the mouse position in the scroll bar window and the point within the range of the scroll bar (Figure 3).</p>
<p>
<img src="scroll32_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Calculating the position of the thumb</b></p>
<p>
Here's one method for calculating the thumb position:</p>
<pre><code>/* User dragged the thumb. */
case SB_THUMBPOSITION:
case SB_THUMBTRACK:
 &nbsp;&nbsp; /* If range is greater than 16 bits, then convert. */
 &nbsp;&nbsp; if (uHorzMax &gt; 65535) 
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double d1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; POINT Pt;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the current cursor position.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetCursorPos(&amp;Pt);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the client rectangle of the horizontal scroll bar.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetClientRect(hWndHorzScroll, &amp;RclHorz);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Map the point of the cursor to the scroll window.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenToClient(hWndHorzScroll, &amp;Pt);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Multiply by the maximum horizontal position
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and store in a double to keep from overflowing.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d1 = (double)Pt.x * (double)uHorzMax;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Divide by the right side of the scroll window.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xNewPos = (UINT)(d1 / (double)RclHorz.right);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; }
 &nbsp;&nbsp; /* Else, just take the 16-bit value passed in HIWORD(wParam). */
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xNewPos = HIWORD(wParam);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
</code></pre>
<p>
The Scroll32 sample that is included with this technical article demonstrates this technique. Run this sample and drag the mouse along either the vertical or the horizontal scroll bar. You will see the scroll position updated in the text at the bottom of the screen. You can also set a specific scroll range and scroll position with this sample.</p>
<p>
One potential problem with the method above manifests itself in the following scenario:
<ol>
<li>
The user clicks to the right of the thumb and drags the thumb to set the scroll position.<br><br></li>
<li>
The user then clicks to the left of the thumb to set the scroll position.</li>
</ol>
<p>
At this point, the actual scroll position will be off by the distance between the left side and the right side of the thumb. You can correct this problem by calculating the scroll position based on the center of the thumb. That is, when the user clicks the thumb, get the distance between the center of the thumb and the actual cursor point and subtract that distance from the position before calculating your cursor-to-scroll-position ratio.</p>
<h2>Summary</h2>
<p>
Scroll bars are very similar in Win16 and Win32. The major difference is that Win32 scroll bars allow full 32-bit positioning while Win16 scroll bars allow 16-bit positioning. If you are already comfortable working with scroll bar controls in Win16, you will be pleasantly surprised to find that there is very little new work to do in Win32. In fact, if you do not need 32-bit precision in your positioning, you will not need to change your code at all. If you do need 32-bit precision, you will need to work around the real-time scrolling limitation that I explained in the previous section.</p>
</BODY>
</HTML>
