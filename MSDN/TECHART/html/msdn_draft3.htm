<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Microsoft Overlay Virtual Environment (MOVE)</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_draft3"></a></sup>The Microsoft Overlay Virtual Environment (MOVE)</h1>
<p>
Microsoft Corporation</p>
<p>
Created: March 20, 1992</p>
<h2>Abstract</h2>
<p>
This article explains how the Microsoft® overlay virtual environment (MOVE) helps overcome memory limitations for programs that run in the MS-DOS® operating system. The article compares MOVE technology to conventional overlays and to paged virtual memory systems, and explains the basics of the technology.</p>
<h2>Introduction</h2>
<p>
Along with death and taxes, all programmers eventually share another misery: insufficient memory. Since the beginning of their profession, programmers have needed to cram too-big programs into too-little random-access memory (RAM). Programmers for MS-DOS® are further restricted by the infamous 640K limit; a program running on a 4 MB computer, for example, can directly execute only in the first 640K of RAM. Many techniques have been employed to overcome this limitation: optimizing compilers, interpreters, MS-DOS extenders, and so on. The most commonly used technique, overlays, is also one of the most cumbersome to use. The new Microsoft overlay virtual environment (MOVE) is a significant advance over previous overlay methods. MOVE is both easier to use and more effective than conventional overlay systems.</p>
<p>
In many ways, the MOVE technology combines the benefits of overlays and virtual memory. Some of the advantages of MOVE over conventional overlays are:
<ul type=disc>
<li>
The MOVE system keeps multiple overlays in memory at the same time. This makes devising efficient overlay structures much easier.<br><br></li>
<li>
Discarded overlays can be cached in extended memory (XMS) or expanded memory (EMS).<br><br></li>
<li>
MOVE supports pointers to functions. You do not need to modify your source code.<br><br></li>
<li>
The memory allocated for overlays can be set at program startup. Your program can adapt to different memory situations.</li>
</ul>
<p>
The MOVE technology can be used only in MS-DOS operating system programs. Programs in the Microsoft Windows™ graphical environment automatically take advantage of a similar mechanism built into Windows.</p>
<p>
The next three sections cover the basics of conventional overlays and virtual memory. If you're already familiar with these concepts, you can skip ahead to "MOVE Basics."</p>
<h2>Overlay Basics</h2>
<p>
If you're not using overlays or other techniques, your program size cannot exceed available memory. When loading your program, MS-DOS copies the program's code and data segments into memory, starting at the first available memory location and continuing to the end of the program (see Figure 1).</p>
<p>
<img src="draft3_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Memory Map for a Nonoverlaid Application</b></p>
<p>
With overlays, however, the entire program need not fit into memory at one time. A portion of the program, called the <i>root</i>, occupies the lower portion of available memory and works just like a nonoverlaid program. The other portions of the program, called <i>overlays</i>, have overlapping memory addresses. This trick is accomplished by keeping only one or a subset of these overlays in memory at one time.</p>
<p>
When you use overlays, the linker automatically includes a routine called the overlay manager in your program's EXE file. When the program calls a function located in another overlay, the overlay manager loads the necessary overlay into memory, overwriting the previous overlay (Figure 2).</p>
<p>
<img src="draft3_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Memory Map for an Overlaid Application</b></p>
<p>
This way, a program can be many times larger than available memory; it only needs sufficient memory to hold the root and the largest overlay. In some overlay systems the overlays are included within the EXE file, whereas in others the overlays are separate files, usually with the OVL extension. You need not keep track of which overlay is in memory or which function is in which overlay; the overlay manager automatically handles loading the appropriate overlay when necessary.</p>
<p>
Well, if overlays sound too good to be true, you're right; they have some drawbacks. They slow your program down, sometimes considerably. All that reloading of overlays from the disk can gum up the works. Reading an instruction from an overlay on the disk can be several thousand times slower than reading the instruction from an already-loaded overlay, so the speed of your program depends heavily on how the overlays are structured. Ideal candidates for overlays are functions that are called only once during a program's execution, like initialization or error-handling routines. Routines that are used together should be grouped into the same overlay so that multiple overlays needn't be loaded to accomplish a task. The worst situation is caused by a tight inner loop calling routines in two different overlays. In cases like this, the computer spends more time loading overlays from disk than executing instructions. This phenomenon, called <i>thrashing</i>, is accompanied by grinding from your user's hard disk and groaning from your users.</p>
<p>
Determining an efficient overlay structure is fiendishly difficult, an activity closer to art than to science. Your intuitions about who calls what, particularly in a large program, are often dead wrong. Even when you know which functions are involved in a particular task, it's still difficult to balance the performance hit with the need to reduce the required memory.</p>
<h2>Example of Overlay Structure</h2>
<p>
Most programmers structure large projects into several source files, using one file for each major system in the program. For example, a hypothetical calendar program that allows the user to add appointments, view a date page, and print the calendar might be composed of the files listed below.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Source file</b></td>
<td class=label width=50%><b>Key routines</b></td>
</tr>
<tr valign=top>
<td width=50%>DATABASE.C<br>
(read, write database appointment records)</td>
<td width=50%><b>DatabaseInit</b><br>
<b>DatabaseReadRecord</b><br>
<b>DatabaseWriteRecord</b><br>
<b>DatabaseExit</b></td>
</tr>
<tr valign=top>
<td width=50%>DATAFORM.C<br>
(show, get appointment data entry)</td>
<td width=50%><b>DataFormEnter</b><br>
<b>DataFormShow</b></td>
</tr>
<tr valign=top>
<td width=50%>DATEUTIL.C<br>
(various date routines)</td>
<td width=50%><b>DateDifference</b><br>
<b>DateGet</b><br>
<b>DateShow</b></td>
</tr>
<tr valign=top>
<td width=50%>INIT<br>
(main initialization routine)</td>
<td width=50%><b>InitializeApplication</b></td>
</tr>
<tr valign=top>
<td width=50%>MAIN.C<br>
(main program file)</td>
<td width=50%><b>main</b><br>
<b>ShowMenu</b></td>
</tr>
<tr valign=top>
<td width=50%>PRINTER.C<br>
(print appointments)</td>
<td width=50%><b>PrinterInit</b><br>
<b>PrinterWrite</b></td>
</tr>
<tr valign=top>
<td width=50%>STRUTIL<br>
(various string routines)</td>
<td width=50%><b>StringGet</b><br>
<b>StringShow</b></td>
</tr>
</table><br>
<p>
An obvious overlay structure for the program can be illustrated as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=33%><b>Root</b></td>
<td class=label width=67%><b>Overlays</b></td>
</tr>
<tr valign=top>
<td width=33%>MAIN.C</td>
<td width=67%>1: DATABASE.C<br>
2: DATAFORM.C<br>
3: DATEUTIL.C<br>
4: INIT.C<br>
5: PRINTER.C<br>
6: STRUTIL.C</td>
</tr>
</table><br>
<p>
Although this structure reduces memory requirements to a bare minimum, it is probably very slow. For example, the primitives in DATEUTIL.C and STRUTIL.C are used throughout the code, so these routines should be placed in the root.</p>
<p>
As you analyze the call tree and optimize the overlay structure, you may find yourself putting more and more routines in the program's root. However, if you put too many routines in the root, your program will need nearly as much memory as the nonoverlaid version. The initialization routines in INIT.C call the hypothetical routines <b>DatabaseInit</b> in DATABASE.C and <b>PrinterInit </b>in PRINTER.C. Although these routines thematically belong in DATABASE.C and PRINTER.C, they should be included in the INIT overlay for best performance. If you move too many routines from where they belong to where they are used, your program may run faster, but it will be harder to read and to maintain the source code. A more balanced overlay structure is shown below.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=33%><b>Root</b></td>
<td class=label width=67%><b>Overlays</b></td>
</tr>
<tr valign=top>
<td width=33%>MAIN.C<br>
DATEUTIL.C<br>
STRUTIL.C</td>
<td width=67%>1: DATABASE.C<br>
(except <b>DatabaseInit</b>)</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=67%>2: DATAFORM.C</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=67%>3: INIT.C<br>
(plus <b>DatabaseInit</b> from DATABASE.C)<br>
(plus <b>PrinterInit</b> from PRINTER.C)</td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=67%>PRINTER.C<br>
(except <b>PrinterInit</b>)</td>
</tr>
</table><br>
<p>
Producing a good overlay structure requires lengthy and tedious trial-and-error work. As new capabilities are added to your program, the structure quickly becomes obsolete. Programmers working on a large system that contains hundreds of source files and thousands of functions often spend as much time tuning the overlay structure as they do writing code.</p>
<h2>Paged Virtual Memory</h2>
<p>
Because working with overlays is so difficult, computer designers have come up with a radically different approach called paged virtual memory (VM). In a paged virtual memory system, the entire address space of the computer is divided into fixed-size blocks called <i>pages</i>. The address range of the processor can be significantly larger than the memory physically contained in the computer; therefore, only a fraction of the page addresses represent actual memory addresses. The programmer doesn't have to worry about the amount of memory in a computer that has VM.</p>
<p>
All addresses used in a VM program are virtual addresses. The computer's virtual memory manager maps virtual page addresses to the physical addresses of memory. When a program needs a virtual memory page that is not mapped to a physical page in memory, the virtual memory manager copies the contents of that page from disk to a page of physical memory. The operating system maps the virtual address of the page to the physical address of the page's contents. This way, when the program reads from a particular virtual address, the computer's VM mapping scheme ensures that the program reads from the appropriate physical page. The computer doesn't need room for all the pages containing a program. The more physical pages available, the less disk activity needed and the faster the program runs. The operating system's VM manager handles loading pages from the disk, swapping modified pages to the disk and translating virtual addresses to physical addresses.</p>
<p>
Virtual memory has several advantages over overlays. First, it does not require programmer effort and eliminates the tedious process of creating overlay structures. Second, the program performs efficiently regardless of the amount of memory the user's computer contains. Most of the program's execution time is spent in a small fraction of the code. As the program executes, pages containing this core code replace pages with less critical code. The set of pages that make up the often-used code is called the program's <i>working set</i>. If the working set can fit in the computer's physical memory, the program executes efficiently and swaps pages only occasionally for infrequently used routines. If the working set cannot fit in the computer's memory, the computer thrashes, spending more time loading code from the disk than executing the program.</p>
<p>
Of course, VM is no panacea either. First, the virtual memory manager and the address translation scheme must be part of the computer hardware. The more powerful members of the Intel® CPU family, particularly the 80386 and higher, support address translation. Less powerful CPUs, however, do not support this feature. Second, the virtual memory manager must realistically be an integral part of the operating system. MS-DOS does not support virtual memory.</p>
<h2>MOVE Basics</h2>
<p>
Microsoft's new MOVE overlay technology has the best of both the overlay and virtual memory worlds. MOVE is an overlay system but has significant advantages over conventional overlays. Unlike conventional overlays, MOVE allows more than one overlay to reside in memory simultaneously. Like virtual memory, the MOVE memory manager keeps resident as many overlays as will fit. Each overlay need not fully cover a single task; two or three overlays can cooperate to complete the task. When loading a new overlay, MOVE discards the least recently used (LRU) overlay. If there is still insufficient room for the new overlay, MOVE discards the next least recently used overlay, and so on.</p>
<p>
With MOVE you can make your overlays smaller and more modular, letting the LRU algorithm determine which overlays stay in memory. Some of your overlays may remain in memory because they are needed for the normal operation of the program. This working set of overlays is similar to the working set of pages in a virtual memory system. Like virtual memory, MOVE programs naturally configure themselves for efficient operation on a given computer. Unlike virtual memory, however, you are not limited to fixed-size pages; you can group functions for better control. For example, if function A is called each time function B is called and only when function B is called, you can group A and B in the same overlay to save the disk time of loading them separately.</p>
<h2>MOVE Mechanics</h2>
<p>
You don't need to modify your C source code to create a MOVE application, but you do need to modify your CL and LINK command lines. These changes are described in the "Creating Overlaid Programs" section.</p>
<p>
Like a nonoverlaid program, a MOVE application has a single EXE file. The EXE file contains the root and all overlays. The file also contains the overlay manager routines (about 5K), which are automatically added by the linker. When a MOVE application is launched, the program's startup routine allocates a memory area to store the overlays. This area, called the <i>overlay heap</i>, is distinct from the regular heap used for <b>malloc</b>. When your application calls a function in an overlay that is not currently loaded in RAM, the MOVE manager must read the overlay from disk and copy its contents to the overlay heap before program execution can continue. If the heap does not have enough free space to hold the requested overlay, the MOVE manager discards one or more of the currently resident overlays. The least recently used overlay is discarded first. Because overlays can vary in size, the MOVE manager may have to discard multiple overlays to make sufficient room for the requested overlay.</p>
<p>
If your program is running on a computer with EMS or XMS memory, the MOVE manager can create an overlay cache for copying discarded overlays. The program cannot execute overlays directly from this cache because the cache resides above the 640K limit. If a discarded overlay is needed again, the manager copies it from the overlay cache to the overlay heap rather than reading it from the disk. Because reading from the cache is much faster than reading from the disk, the space for your working set is effectively the cache size plus the heap size. The overlay manager routines maintain the overlay cache with an LRU algorithm in a manner similar to the overlay heap.</p>
<h2>Heap and Cache Management</h2>
<p>
The MOVE overlay manager is responsible for loading requested overlays from the disk or cache and copying them to the heap. If there is insufficient contiguous heap space for the requested overlay, the MOVE manager discards the LRU overlay from the heap and checks for contiguous space again. If space is still insufficient, the MOVE manager discards the next LRU overlay and repeats these steps until sufficient contiguous space is available.</p>
<p>
At program startup, the MOVE manager attempts to allocate an overlay heap equal to the sum of the program's three largest overlays. If space is insufficient or there are less than four program overlays, MOVE allocates a heap that is the size of the largest overlay. The remaining computer free memory is retained for the conventional (<b>malloc</b>) heap. (This is default initialization behavior and can be substituted by another scheme if desired.)</p>
<p>
If the program is running on a computer with EMS or XMS memory, the MOVE manager attempts to allocate an overlay cache three times the size of the overlay heap. If there is not enough memory for a cache this size, all EMS or XMS memory is used.</p>
<p>
When the MOVE manager discards an overlay from the heap, it does not copy the overlay to the cache if a copy of the overlay is already in the cache.</p>
<p>
Individual overlays can be up to 64K in size but are usually much smaller. Overlays can be individual OBJ files, as in a conventional overlay system, or they may contain a list of functions. With large overlays, your program's performance will suffer the problems associated with conventional overlays. Your overlays should be large enough to justify the time it takes to load them from disk. Specifics vary depending on your program, and experimentation will help you find the optimal overlay size and organization. For most programs, an optimal overlay size is about 4K.</p>
<p>
If your overlaid program temporarily needs the EMS or XMS memory occupied by the cache, you can use the MOVE application programming interface (API) <b>_movepause</b> function to release the cache memory and <b>_moveresume</b> to restore the cache. This is particularly useful if your program spawns another program that needs EMS or XMS memory to function. The MOVE API functions are described in Appendix A.</p>
<h2>How Does MOVE Work?</h2>
<p>
One aspect of MOVE seems quite mysterious until you know how it works. How does the overlay manager know when it needs to load an overlay? How do calls to overlaid functions know where to branch in the overlay heap? This magic is accomplished by inserting an additional link between the function and its callers. This link, called a <i>thunk</i>, works like an additional function call. One thunk data structure is created in the root for each far function contained in the overlays. The thunk data structure contains the overlay number containing the function and the offset of the function's entry point within the overlay. The linker modifies all function calls to overlaid functions so that they call the thunk instead of directly calling the function. When a function calls the thunk, the MOVE manager locates the appropriate overlay in the heap or loads the overlay from the cache or disk and jumps to the offset specified in the thunk.</p>
<h2>Creating Overlaid Programs</h2>
<p>
You create a MOVE application by following the same edit-compile-link development cycle used for all C programs. (The old syntax, <i>link a+(b)+(c),</i> is also supported.) You will need to create an additional file, called a DEF file, for each application. The DEF file is used by the linker and specifies the makeup of the root and of each overlay. A sample DEF file for the hypothetical calendar program is shown below:</p>
<pre><code>EXETYPE DOS

;FUNCTIONS:init DatabaseInit PrinterInit

; Place main, strutil, and dateutil in the root.
FUNCTIONS:0 _main
FUNCTIONS:0 _strutil
FUNCTIONS:0 _dateutil

FUNCTIONS:1 _database
FUNCTIONS:2 _dataform
FUNCTIONS:3 _init
FUNCTIONS:3 _printer
</code></pre>
<p>
For more information on the syntax of DEF files, see "Creating Overlaid MS-DOS Programs" and "Creating Module Definition Files" in the <i>C/C++ Environment and Tools</i> manual.</p>
<p>
The first step in creating a MOVE application is to determine an appropriate overlay structure. For most programs, a good starting point is to place each OBJ file in its own overlay. The program entry point must be in the root, that is, the normal sequence is <b>_astart</b> followed by <b>main</b>. OBJ files containing universally called primitives should be placed in the root as well.</p>
<p>
MOVE gives you control over the placement of individual functions. Instead of moving a function's source code physically to another file, you specify the function in a <b>FUNCTIONS</b> statement in your application's DEF file. A function can be specified in this way only if it is a <i>packaged function.</i> Functions can be packaged by specifying the /Gy switch during compilation. For more information on packaging functions, see "CL Command Reference" and "Creating Overlaid MS-DOS Programs" in the <i>C/C++ Environment and Tools</i> manual.</p>
<h2>Optimizing Overlaid Programs</h2>
<p>
After you've created a MOVE program, you can run it under different memory conditions, assess its performance, and compare the performance of different overlay sizes and structures. A MOVE feature called <i>tracing</i> can help you optimize your overlays. Tracing a MOVE application generates a log file during program execution. The log file contains an entry for each load and discard of an overlay. A separate MS-DOS utility called TRACE reports and summarizes the information in trace log files. The TRACE utility is discussed in Appendix C. For more information on tracing, see "Creating Overlaid MS-DOS Programs" in the <i>C/C++ Environment and Tools</i> manual. Future versions of MOVE will include enhanced tools that make designing and optimizing the overlay structure easier.</p>
<p>
You can modify some of the characteristics of the MOVE manager. For example, you can change the amount of memory MOVE allocates for the overlay heap and cache by changing the constants and heuristics in the MOVEINIT.C file. For more information, see "Creating Overlaid MS-DOS Programs" in the <i>C/C++ Environment and Tools</i> manual.</p>
<h2>Appendix A: The MOVE API</h2>
<p>
The MOVE API is provided in a library called MOVE.LIB. This library is a component of the C combined libraries for medium and large models. (Another form of the library, MOVETR.LIB, also contains the MOVE API; see Appendix C.) The MOVE API is declared in the MOVEAPI.H file, which is available on disk. This appendix describes MOVE routines and functionality.</p>
<h3>The _moveinit Function</h3>
<p>
MOVE begins an overlaid program with a call to <b>_moveinit</b>, which calculates the heap and cache needed for the overlays and allocates memory for the heap and cache.</p>
<p>
You can use the default <b>_moveinit</b> function provided in MOVE.LIB, or you can write your own version of <b>_moveinit</b> and link it to your program. The source code for the default <b>_moveinit</b> function is available in the MOVEINIT.C file.</p>
<p>
The <b>_moveinit</b> call occurs before the call to <b>_astart</b> that begins a C program and performs initialization. For this reason, do not call C run-time routines from any version of <b>_moveinit</b>.</p>
<p>
The following functions are called from <b>_moveinit</b>:
<ul type=disc>
<li>
_movesetheap<br><br></li>
<li>
_movegetcache<br><br></li>
<li>
_movesetcache<br><br></li>
<li>
_movetraceon (only in MOVETR.LIB)</li>
</ul>
<p>
The functions are described in the sections below. In addition, LINK creates several variables that begin with $$; these variables are described in the "LINK Variables" section.</p>
<h3>Heap Allocation</h3>
<p>
The <b>_movesetheap</b> function sets the overlay heap size.</p>
<p>
extern unsigned short __far __cdecl _movesetheap(<br>
 &nbsp; unsigned short <i>maxovl</i>,<br>
 &nbsp; unsigned short <i>minheap</i>,<br>
 &nbsp; unsigned short <i>reqheap</i> );</p>
<p>
where:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=16%>maxovl</td>
<td width=84%>is the maximum number of overlays. The $$COVL variable always contains this value.</td>
</tr>
<tr valign=top>
<td width=16%>minheap</td>
<td width=84%>is the minimum heap size, specified in 16-byte paragraphs. The heap must be at least the size of the largest overlay. To calculate overlay sizes, use $$MPOVLSIZE as in MOVEINIT.C.</td>
</tr>
<tr valign=top>
<td width=16%>reqheap</td>
<td width=84%>is the requested heap size, specified in 16-byte paragraphs. The default <b>_moveinit</b> function requests the sum of the sizes of the three largest overlays.</td>
</tr>
</table><br>
<p>
MOVE attempts to allocate the requested amount of memory. If that much memory is not available, MOVE tries to allocate as much as possible. If the amount of available memory is less than the minimum heap requested, MOVE ends the program and issues a run-time error.</p>
<h3>Cache Allocation</h3>
<p>
The <b>_movegetcache</b> function determines the amount of memory available for a cache.</p>
<p>
<b>extern void __far __cdecl _movegetcache(<br>
 &nbsp; unsigned short __far *<i>expmem</i>,<br>
 &nbsp; unsigned short __far *<i>extmem</i> );</b></p>
<p>
where:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=16%>*expmem</td>
<td width=84%>is available expanded memory, in kilobytes.</td>
</tr>
<tr valign=top>
<td width=16%>*extmem</td>
<td width=84%>is available extended memory, in kilobytes.</td>
</tr>
</table><br>
<p>
The <b>_movesetcache</b> function allocates expanded and extended memory for an overlay cache.</p>
<p>
<b>extern unsigned short __far __cdecl _movesetcache(<br>
 &nbsp; unsigned short <i>expmem</i>,<br>
 &nbsp; unsigned short <i>extmem</i> );</b></p>
<p>
where:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=16%>expmem</td>
<td width=84%>is the requested amount of expanded memory, specified in kilobytes.</td>
</tr>
<tr valign=top>
<td width=16%>extmem</td>
<td width=84%>is the requested amount of extended memory, specified in kilobytes.</td>
</tr>
</table><br>
<p>
The default <b>_moveinit</b> function requests a cache equal to the sum of all overlays. If <b>_movesetcache</b> cannot allocate the requested amount of memory, it sets a bit in the return value. MOVEAPI.H defines the following constants to represent bits in the return value.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=41%><b>Constant</b></td>
<td class=label width=17%><b>Bit</b></td>
<td class=label width=42%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=41%>__MOVESETCACHE_ERR_NO</td>
<td width=17%>0</td>
<td width=42%>No error</td>
</tr>
<tr valign=top>
<td width=41%>__MOVESETCACHE_ERR_XMS</td>
<td width=17%>1</td>
<td width=42%>Cannot allocate extended memory </td>
</tr>
<tr valign=top>
<td width=41%>__MOVESETCACHE_ERR_EMS</td>
<td width=17%>2</td>
<td width=42%>Cannot allocate expanded memory</td>
</tr>
</table><br>
<p>
The <b>_movesetcache</b> function sets the following global variables when the overlay cache is allocated:</p>
<pre><code>extern unsigned short __far __cdecl _moveckbxms;
extern unsigned short __far __cdecl _moveckbems;
</code></pre>
<p>
The<i> _moveckbxms</i> variable is set to the size of the allocated extended memory. The <i>_moveckbems</i> variable is set to the size of the allocated expanded memory.</p>
<h3>Freeing and Reallocating Cache Memory</h3>
<p>
You can temporarily release and then restore the memory allocated for the overlay cache. This is useful when your program spawns another program that uses extended or expanded memory or when you want to prepare for a possible abnormal exit from your program.</p>
<p>
The <b>_movepause</b> function frees the cache memory and closes the executable file.</p>
<p>
extern void __far __cdecl _movepause( void );</p>
<p>
The <b>_moveresume</b> function reallocates memory for the overlay cache and reopens the executable file.</p>
<p>
extern void __far __cdecl _moveresume( void );</p>
<p>
MOVEAPI.H defines the following variables for use by these functions:</p>
<pre><code>extern unsigned short __far __cdecl _movefpause;
extern unsigned short __far __cdecl _movefpaused;
</code></pre>
<p>
MOVEAPI.H also defines constants to represent bits in <i>_movefpause</i> and <i>_movefpaused</i> as follows.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=33%><b>Constant</b></td>
<td class=label width=17%><b>Bit</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=33%>__MOVE_PAUSE_DISK</td>
<td width=17%>2</td>
<td width=50%>Represents the executable file</td>
</tr>
<tr valign=top>
<td width=33%>__MOVE_PAUSE_CACHE</td>
<td width=17%>4</td>
<td width=50%>Represents the cache memory</td>
</tr>
</table><br>
<p>
The <b>_movepause</b> function reads the value in <i>_movefpause</i> and sets <i>_movefpaused</i> to the value of the action taken by <b>_movepause</b>. Before you call <b>_movepause</b>, set <i>_movefpause</i> to __MOVE_PAUSE_DISK to close the file, and set it to __MOVE_PAUSE_CACHE to free the cache, as in:</p>
<pre><code>_movefpause |= __MOVE_PAUSE_DISK;
_movefpause |= __MOVE_PAUSE_CACHE;
_movepause();
</code></pre>
<p>
The <b>_moveresume</b> function reads the value in <i>_movefpaused</i> and then clears <i>_movefpaused.</i> The overlays that were in the heap and cache are not restored. Therefore, after a call to <b>_moveresume</b>, the program may at first run slightly more slowly as it makes calls to routines in overlays.</p>
<h3>LINK Variables</h3>
<p>
LINK creates the following variables:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=29%>$$MAIN</td>
<td width=71%>Entry point to an overlaid program. In a C program, this is defined to be <b>__astart</b>.</td>
</tr>
<tr valign=top>
<td width=29%>$$OVLTHUNKBEG</td>
<td width=71%>Beginning of the interoverlay call (thunk) table.</td>
</tr>
<tr valign=top>
<td width=29%>$$OVLTHUNKEND</td>
<td width=71%>End of the interoverlay call table.</td>
</tr>
<tr valign=top>
<td width=29%>$$CGSN</td>
<td width=71%>Number of global segments. Each object file contributing to an overlay takes up one global segment number (GSN). Each COMDAT (packaged function) segment takes up one GSN.</td>
</tr>
<tr valign=top>
<td width=29%>$$COVL</td>
<td width=71%>Number of overlays. Each overlay can contain several GSNs.</td>
</tr>
<tr valign=top>
<td width=29%>$$MPGSNBASE</td>
<td width=71%>Map of GSNs to segment displacements in an overlay.</td>
</tr>
<tr valign=top>
<td width=29%>$$MPGSNOVL</td>
<td width=71%>Map of GSNs to overlay numbers.</td>
</tr>
<tr valign=top>
<td width=29%>$$MPOVLLFA</td>
<td width=71%>Map of overlay numbers to logical file addresses of overlays in the executable file.</td>
</tr>
<tr valign=top>
<td width=29%>$$MPOVLSIZE</td>
<td width=71%>Map of overlay numbers to overlay image sizes (the size of the code actually loaded into the overlay heap).</td>
</tr>
<tr valign=top>
<td width=29%>$$INTNO</td>
<td width=71%>Overlay interrupt number.</td>
</tr>
</table><br>
<h2>Appendix B: MOVE Environment Variables</h2>
<p>
You can use environment variables at run time to specify the size of the requested overlay heap and overlay cache and the maximum number of overlays. The <b>_moveinit</b> function given in MOVEINIT.C provides environment support; you can compile this function and link it with your program. (MOVETR.LIB includes a version of <b>_moveinit</b> that already contains environment support.)</p>
<p>
First, enable environment support by compiling MOVEINIT.C with MOVE_ENV defined. Then specify the resulting MOVEINIT.OBJ when linking your program. With MOVE_ENV defined, MOVEAPI.H declares the following variable:</p>
<pre><code>extern unsigned short __far __cdecl _movesegenv;
</code></pre>
<p>
Compiling for environment support causes MOVEINIT.C to define a function called <b>_movegetenv</b>. The environment-support version of <b>_moveinit</b> uses <b>_movegetenv</b> to get the values of the following environment variables:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=25%>MOVE_HEAP</td>
<td width=75%>Requested heap (paragraphs)</td>
</tr>
<tr valign=top>
<td width=25%>MOVE_COVL</td>
<td width=75%>Maximum number of overlays</td>
</tr>
<tr valign=top>
<td width=25%>MOVE_EMS</td>
<td width=75%>Requested expanded-memory cache (paragraphs)</td>
</tr>
<tr valign=top>
<td width=25%>MOVE_XMS</td>
<td width=75%>Requested extended-memory cache (paragraphs)</td>
</tr>
</table><br>
<p>
To use these variables, set them to strings that represent the desired settings. Each string must consist of exactly four hexadecimal digits.</p>
<h2>Appendix C: The TRACE Utility</h2>
<p>
You can optimize the overlays in your program with the help of the tracing form of the MOVE library (MOVETR.LIB) and the Microsoft MOVE trace utility (TRACE) version 1.0. MOVETR.LIB contains MOVE.LIB and additional routines for tracing overlay behavior.</p>
<p>
Create a tracing version of your program as described in the following sections. When you run your program, the tracing functions create a binary file called MOVE.TRC in the directory from which the program is run. After your program ends, use TRACE to read MOVE.TRC. If the tracing results indicate that some functions cause overlays to be swapped frequently, you can reorganize the functions in the overlays by using statements in the module definition file.</p>
<h3>Creating a Tracing Version of an Overlaid Program</h3>
<p>
To create a program that will trace overlay performance, specify MOVETR.LIB in LINK's <i>libraries</i> field. This causes LINK to use the MOVETR.LIB library instead of the MOVE.LIB component of the default combined library. Use LINK's /NOE option to prevent conflicts between MOVETR.LIB and the combined library. If you explicitly specify the combined library in the <i>libraries</i> field, list MOVETR.LIB before the combined library.</p>
<h3>The Trace Functions</h3>
<p>
By default, tracing is in effect during the entire run of your program. You do not need to make any changes in your program to enable tracing. However, MOVETR.LIB provides two functions that you can use to turn tracing on and off within your program.</p>
<p>
The <b>_movetraceon</b> function turns on tracing.</p>
<p>
extern void __far __cdecl _movetraceon( void );</p>
<p>
This function opens the MOVE.TRC file and activates tracing. During tracing, information about overlay behavior is written to MOVE.TRC. The default <b>_moveinit</b> function calls <b>_movetraceon</b> at the start of the program if MOVE_PROF is defined; this definition is in MOVETR.LIB.</p>
<p>
The <b>_movetraceoff</b> function turns off tracing and closes MOVE.TRC.</p>
<p>
extern void __far __cdecl _movetraceoff( void );</p>
<p>
The tracing functions are declared in MOVEAPI.H. They are defined only in MOVETR.LIB.</p>
<h3>Running TRACE</h3>
<p>
To run TRACE, use the following syntax:</p>
<p>
TRACE [options] [tracefile]</p>
<p>
The <i>tracefile</i> is the MOVE.TRC file created during a tracing session. You can specify a path with the filename. If <i>tracefile</i> is not specified, TRACE looks in the current directory for a file called MOVE.TRC.</p>
<p>
An option is preceded by an option specifier, either a forward slash (/) or a dash (–). Options are not case sensitive. An option can be abbreviated to its initial letter. Options can appear anywhere on the command line.</p>
<p>
TRACE options are:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=25%>/SUM</td>
<td width=75%>Displays a summary of the program's performance. If /SUM is not specified, TRACE displays the entire tracing session. For details, see the "TRACE Performance Summary" section. If /SUM is specified, /EXE and /MAP have no effect.</td>
</tr>
<tr valign=top>
<td width=25%>/EXE:<i>filename</i></td>
<td width=75%>Allows TRACE to read the executable file that was traced and to extract function names for use in the trace output. Specify the filename of the executable file that generated the MOVE.TRC file. You can specify a path with the filename. If /EXE is not specified, the trace output refers to functions by overlay number and offset. The program must contain Microsoft Symbolic Debugging Information that is compatible with Microsoft CodeView® version 4.0. To include debugging information, create the object file using the /Zi option and link the program using the /CO option.</td>
</tr>
<tr valign=top>
<td width=25%>/HELP</td>
<td width=75%>Displays a usage statement.</td>
</tr>
<tr valign=top>
<td width=25%>/?</td>
<td width=75%>Displays a usage statement.</td>
</tr>
</table><br>
<h3>TRACE Output</h3>
<p>
TRACE displays information on the tracing session to the standard output device. You can use the redirection operator (&gt;) to save the output in a file. The output is in table format. Each line of output represents an interoverlay transaction. A line of information is organized into the following fields:
<ul type=disc>
<li>
The overlay to which to return from the current transaction. (If blank, the overlay in the previous line is implied.)<br><br></li>
<li>
The physical return address in segment:offset form. (If blank, the address in the previous line is implied.)<br><br></li>
<li>
The transaction type, which is one of the following:<ul type=disc>
<li>
Present<br><br></li>
<li>
Load from disk<br><br></li>
<li>
Load from expanded memory<br><br></li>
<li>
Load from extended memory<br><br></li>
<li>
Discard from heap<br><br></li>
<li>
Cache to expanded memory<br><br></li>
<li>
Cache to extended memory<br><br></li>
<li>
Discard from cache<br><br></li>
<li>
Invalid</li>
</ul>
</li>
<li>
The overlay that is the object of the transaction.<br><br></li>
<li>
The segment in memory where the transaction overlay is loaded.<br><br></li>
<li>
The interoverlay operation, which is one of the following:<ul type=disc>
<li>
Call <i>function</i>, in which <i>function</i> is:</li>
</ul>
</li>
</ul>
<p>
An overlay number and an offset in default output</p>
<p>
A function name if /EXE is used</p>
<p>
A decorated function name if /EXE and /MAP are used
<ul type=disc>
<li>
Return.<br><br></li>
<li>
If blank, the Call in the previous line is implied.</li>
</ul>
<h3>TRACE Performance Summary</h3>
<p>
When you run TRACE with the /SUM option, TRACE displays a summary of overlay performance to the standard output device. The full session is not displayed. You can use the redirection operator (&gt;) to save the output in a file. The summary information is organized into the following fields.</p>
<p class=label>
<b>OVERALL</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=16%>calls</td>
<td width=84%>Sum of Call operations</td>
</tr>
<tr valign=top>
<td width=16%>returns</td>
<td width=84%>Sum of Return operations</td>
</tr>
</table><br>
<p class=label>
<b>HEAP</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=33%>discards</td>
<td width=67%>Sum of "Discard from heap" transactions</td>
</tr>
<tr valign=top>
<td width=33%>discards / entries</td>
<td width=67%>Discards as percent of (calls + returns)</td>
</tr>
<tr valign=top>
<td width=33%>loads from disk</td>
<td width=67%>Sum of "Load from disk" transactions</td>
</tr>
<tr valign=top>
<td width=33%>loads from expanded memory</td>
<td width=67%>Sum of "Load from expanded memory" transactions</td>
</tr>
<tr valign=top>
<td width=33%>loads from extended memory</td>
<td width=67%>Sum of "Load from extended memory" transactions</td>
</tr>
</table><br>
<p class=label>
<b>CACHE</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=33%>discards</td>
<td width=67%>Sum of "Discard from cache" transactions</td>
</tr>
<tr valign=top>
<td width=33%>discards / entries</td>
<td width=67%>Discards as percent of (calls + returns)</td>
</tr>
<tr valign=top>
<td width=33%>caches to expanded memory</td>
<td width=67%>Sum of "Cache to expanded memory" transactions</td>
</tr>
<tr valign=top>
<td width=33%>caches to extended memory</td>
<td width=67%>Sum of "Cache to extended memory" transactions</td>
</tr>
</table><br>
<h3>TRACE Errors</h3>
<p>
TRACE issues the following errors and warnings.</p>
<p>
<b>TR1001Invalid filename for /EXE</b></p>
<p>
The string specified with the /EXE option was not a valid filename.</p>
<p>
<b>TR1005Missing filename for /EXE</b></p>
<p>
The /EXE option must be followed by a colon and a filename, with no spaces in between.</p>
<p>
<b>TR1007Unrecognized option</b></p>
<p>
The command line contained an option specifier, either a forward slash (/) or a dash (–), followed by a string that was not recognized as a TRACE option.</p>
<p>
<b>TR1010Cannot find trace file</b></p>
<p>
One of the following occurred:
<ul type=disc>
<li>
A trace file was specified on the command line, but the specified file does not exist.<br><br></li>
<li>
No trace file was specified on the command line and TRACE assumed a trace file called MOVE.TRC, but MOVE.TRC does not exist.</li>
</ul>
<p>
<b>TR1011Error opening/reading .EXE file</b></p>
<p>
TRACE either failed to find the executable file specified with /EXE or encountered an error while opening the file.</p>
<p>
<b>TR1012Out of memory</b></p>
<p>
The available memory is insufficient for the size of the program being traced.</p>
<p>
<b>TR1013Invalid debugging information</b></p>
<p>
The debugging information contained in the executable file was not packed using CVPACK version 4.0.</p>
<p>
<b>TR4001Cannot find function name</b></p>
<p>
TRACE could not find a function name to display. TRACE continues to generate output without displaying the function name.</p>
<p>
Function names are displayed when the /EXE option is specified. Either the executable file contains corrupt debugging information or a module in the executable file was compiled without the /Zi option for including debugging information.</p>
<p>
<b>TR4002Missing debugging information for module</b></p>
<p>
TRACE could not find a symbol to correspond to a given physical address. A module may have been compiled without the /Zi option for including debugging information.</p>
</BODY>
</HTML>
