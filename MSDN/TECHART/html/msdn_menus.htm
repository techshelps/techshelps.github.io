<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Custom Visual FoxPro Menus</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_menus"></a></sup>Creating Custom Visual FoxPro Menus</h1>
<p>
Rodney Hill<br>
Microsoft Corporation</p>
<h2>Introduction</h2>
<p>
If you're creating Microsoft® Windows® 95-compatible applications, you need to provide a menu system to expose the application's functionality to users. The Visual FoxPro™ <i>Developer's Guide</i> discusses some of the design considerations and mechanics of creating a menu system, and that is the best place to start if you are new to Visual FoxPro menus. This article supplements that information in the following areas:
<ul type=disc>
<li>
Adding menus to your applications<br><br></li>
<li>
Integrating dynamic elements with menu designer menus<br><br></li>
<li>
Adding menus to top-level forms<br><br></li>
<li>
Creating shortcut menus<br><br></li>
<li>
Creating menu classes<br><br></li>
<li>
Creating data-driven menus</li>
</ul>
<p>
Most of the information in this article applies to both Visual FoxPro 3.0 and 5.0. Information that is specific to Visual FoxPro 5.0 is noted.</p>
<h2>Adding Menus to Your Applications</h2>
<p>
The easiest and quickest way to create a menu is to use the Visual FoxPro Menu Designer, and this article assumes that you'll be doing this. The best strategy for creating menus is probably the same strategy that Microsoft has been taking with the Internet: <i>embrace and extend</i>. In the Menu Designer context, this means using the tool that Visual FoxPro provides, but extending its capabilities by adding your own code.</p>
<p>
Using the Menu Designer to create menus is described in the Visual FoxPro <i>Developer's Guide</i>. Basically, the process is:
<ol>
<li>
Use the Menu Designer to create the menu structure and assign commands to be executed when users choose menu items.<br><br></li>
<li>
Generate Visual FoxPro menu definition code (to a program file with an .MPR extension by default).<br><br></li>
<li>
Run the program in your application to create the menu.</li>
</ol>
<p>
Like other Visual FoxPro programs, a menu program runs, does what it is supposed to do (in this case define and display the menu), and then ends. The menu program does not continue running in the background, waiting for a user to choose an item from a menu. The commands that are processed when a user chooses a menu item are scoped at the system level, that is, they have access to PUBLIC variables, programs, and procedures in files specified with the SET PROCEDURE TO command.</p>
<p>
Of course, since you cannot use THISFORM or THIS outside method code, you cannot use them in code to be executed when a user chooses a menu item. To call methods or set properties of a form from a menu, use the form's object reference, or more generically </p>
<pre><code>_SCREEN.ActiveForm 
</code></pre>
<p>
For example, if you have a Close option on a File menu, you can have it execute the following line of code:</p>
<pre><code>_SCREEN.ActiveForm.Release
</code></pre>
<h3>Designing Modular Menus</h3>
<p>
You can design the entire menu structure for your application in the Menu Designer and generate a single menu program, but it's not necessarily a good idea. You can get some of the same advantages that you get with modular or object-oriented programming when you design modular menus.</p>
<p>
Instead of creating one menu program to define your entire menu structure, create separate programs for each menu in the menu system, or maybe for selected groups of menus. For example, if you create separate File, Edit, Window, Help, and application-specific menus, you can reuse the generic menus easily in multiple applications, coding and maintaining them in one place. You can also more easily add and remove specific menus as they are needed.</p>
<p>
Designing menus one at a time in the Menu Designer is an easy and straightforward way to create modular menus. There are also other tools or techniques you can use. For example, GenMenuX, a public domain tool written by Andrew Ross MacNeill, allows you to create reusable menu templates for modular menu design. GenMenuX is available for download from several Internet sites and CompuServe's FOXUSER forum.</p>
<h3>Saving and Restoring the Original Menu</h3>
<p>
In your application, remember to push the existing menu on the menu stack (that is, save it to be restored later) before running your menu program, and, when the user is finished with your application, pop the old menu off the stack, as in the following main program of an application.</p>
<pre><code>* Push the existing menu on the menu stack.

<b>PUSH MENU _MSYSMENU</b>


* Display interface.
DO File.MPR
DO Edit.MPR
DO MyApp.MPR
DO Window.MPR
DO Help.MPR

DO FORM InitialForm

* Allow the interface to process events.
READ EVENTS

* Restore the original menu.

<b>POP MENU _MSYSMENU</b>
</code></pre>
<p>
The menu stack, like all stacks, operates on a last-on, first-off basis. If you push menu A on the stack, run menu B, then push menu B on the stack, and run menu C, executing the POP MENU command will restore menu B. The next time you issue the POP MENU command, you'll restore menu A.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;PUSH MENU _MSYSMENU takes up about 12K of memory, and pushing a fully user-defined menu can take more. So for every PUSH MENU, there should always be a balancing POP MENU to make sure memory usage is kept to a minimum.</p>
<h3>Using Cascading Menus</h3>
<p>
Cascading menus are menus that are opened when a user selects a menu item on another menu. You can easily create cascading menus with the Menu Designer, but that doesn't mean that you necessarily should. Cascading menus require more mouse dexterity on the part of the user and can't provide the context or visual clues that a dialog box can. Users rarely appreciate a cascading menu that displays a single item. The developer could just as easily have put the single item on the original menu. You'll also want to avoid opening cascading menus from shortcut menus or making a user open a cascading menu from a cascading menu from a cascading menu to get to the functionality you want to expose.</p>
<h2>Integrating Dynamic Elements with Menu Designer Menus</h2>
<p>
Using Visual FoxPro menu commands and functions in conjunction with the Menu Designer and Form Designer allows you to create dynamic menus that are configurable at run time and aware of the environment.</p>
<h3>Menu Elements</h3>
<p>
The Menu Designer generates (via _GENMENU) Visual FoxPro menu definition code. When you understand this menu code, you are in a better position to extend the Menu Designer menus.</p>
<p>
Terminology has always been a problem with menus in general and FoxPro menus in particular. Microsoft documentation, for example, has alternately used the terms menu <i>command</i>, menu <i>option</i>, and menu <i>item</i> to refer to the thing programmatically created in Visual FoxPro with the DEFINE BAR command. In Visual FoxPro code, a menu consists of PADs on _MSYSMENU, POPUPs that are activated when a user chooses a PAD, and BARs that are the items on the popup that the user chooses to perform some action. When this article, and the Visual FoxPro documentation, refers to a menu, the elements involved are a <i>pad</i>, a <i>popup</i>, and one or more <i>bars</i>. </p>
<p>
The following illustration shows how the Visual FoxPro menu definition code maps to menu elements. </p>
<p>
<img src="menus_1.gif" border=0> </p>
<p>
If you search the Visual FoxPro Help file for "Menus and Menu Bars," you'll get a list of all the menu definition and manipulation commands and functions with jumps to detailed syntax and examples. The following example walks through the most basic menu commands in the order they would normally be executed.</p>
<p>
Before setting up your application's menu system, you need to remove the default Visual FoxPro menu system. The following line of code removes all the system menu pads from the system menu bar.</p>
<pre><code>SET SYSMENU TO
</code></pre>
<p>
<img src="menus_2.gif" border=0></p>
<p>
You can add a new menu pad to the system menu bar with the DEFINE PAD command:</p>
<pre><code>DEFINE PAD padReports OF _MSYSMENU ;
 &nbsp;&nbsp; PROMPT "\&lt;Reports" ;
 &nbsp;&nbsp; MESSAGE "Choose a report to run"
</code></pre>
<p>
<img src="menus_3.gif" border=0></p>
<p>
When a user clicks the new pad, however, nothing happens. You need to define a popup and bars on the popup to display the kind of menu that users expect to see when they click a menu pad:</p>
<pre><code>DEFINE POPUP popReports MARGIN
ON PAD padReports OF _MSYSMENU ACTIVATE POPUP popReports

DEFINE BAR 1 OF popReports ;
 &nbsp;&nbsp; PROMPT "Invoice" ;
 &nbsp;&nbsp; MESSAGE "Print an Invoice"
</code></pre>
<p>
<img src="menus_4.gif" border=0></p>
<p>
Now when the user clicks the Reports pad, the Invoice menu item is displayed. But you still need to add code to determine the action associated with the menu item:</p>
<pre><code>ON SELECTION BAR 1 OF popReports REPORT FORM INVOICE.FRX PREVIEW
</code></pre>
<h3>Using the Visual FoxPro System Menus</h3>
<p>
In addition to menus that you create from scratch, you can use predefined Visual FoxPro system menu elements in your applications, and there are a couple of good reasons why you should.
<ul type=disc>
<li>
System menus have built-in functionality. The Edit menu (pad name _MSM_EDIT and popup name _MEDIT), for example, allows cutting, copying, pasting, and finding text. If the Edit menu isn't available, you cannot cut, copy, or paste. The Window menu (pad name _MSM_WINDO and popup name _MWINDOW) displays the Caption of your running forms and allows a user to activate a form by choosing the caption from the menu.<br><br></li>
<li>
In the General Options dialog box of the Menu Designer, you can specify a location before or after a system menu pad.</li>
</ul>
<p>
For a list of all the system menu pad, popup, and bar names, search the Visual FoxPro Help file for "System Menu Names" or use the SYS(2013) function. The Quick Menu feature of the Menu Designer allows you to easily add all the system menus to your menu. From there, you can customize. In Visual FoxPro 5.0, when you are creating generic menu components you can just choose Insert Bar in the Menu Designer to add Visual FoxPro system menu options one at a time.</p>
<p>
When you are creating an application-specific menu component, you probably won't need Visual FoxPro system menus, but remember to specify the Location for your menu in the General Options dialog box. If you want the application-specific menu to be displayed to the left of the generic Window menu, choose Before and then choose Window in the drop-down list that becomes visible.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You can programmatically access Visual FoxPro 5.0 system menu functionality with the SYS(1500) function. For example, if the active window is an editing window, the following line of code opens the Visual FoxPro Find dialog box:</p>
<pre><code>?SYS(1500, "_MED_FIND", "_MEDIT")
</code></pre>
<h3>Disabling Menu Items</h3>
<p>
One of the most common means of having a menu dynamically adjust to the user's current work environment is to disable or enable menu items as appropriate. When you define a menu bar, use the SKIP FOR clause to specify when the menu item should be disabled. When the expression indicated by the SKIP FOR command evaluates to true (.T.), the menu item is disabled. For example, if you have a Close option on a File menu, the following line of code ensures that it is enabled only when a form is active:</p>
<pre><code>DEFINE BAR 3 OF _MFILE ;
   PROMPT "Close" ;
   MESSAGE "Close the currently active form" ;
   SKIP FOR TYPE("_SCREEN.ActiveForm") != "O"

ON SELECTION BAR 3 OF _MFILE _SCREEN.ActiveForm.Release
</code></pre>
<p>
Two samples in the Visual FoxPro Solutions sample application illustrate disabling menu items: <i>Coordinate Menu Items and Toolbar Buttons </i>and<i> Disable or Display a Check Beside a Menu Item</i>. When you run these samples, press F1 to see a description of how they were implemented. </p>
<p>
Visual FoxPro system menus automatically take care of disabling inappropriate items. For example, the Cut, Copy, and Paste items on the Edit menu (pad name _MSM_EDIT and popup name _MEDIT) are automatically disabled when no text is selected or no text is in the clipboard to paste.</p>
<p>
You can include the SKIP FOR expression in the Menu Designer when you create a menu item. While you can use the SKIP FOR clause or the SET SKIP OF command to disable an entire menu in your application by disabling the pad, this is not a standard interface for a Windows-based application. When a menu isn't applicable for a given environment, it should be removed altogether, as described in the following section.</p>
<h3>Associating Menu Pads with Forms</h3>
<p>
Often, you'll want to extend the functionality of a form by putting less frequently-used options on a menu. The menu is only appropriate when the form is active, so you need to remove the menu when the form is not active. For example, in Visual FoxPro, when the Project Manager is the active window, there is a Project menu on the menu bar. When the Project Manager is not the active window, the Project menu is removed.</p>
<p>
To design a menu to be associated with a form:
<ol>
<li>
Create a menu pad in the Menu Designer with the menu items appropriate for your form.<br><br></li>
<li>
When the Menu Designer is the active window, choose General Options from the View menu.<br><br></li>
<li>
Choose Append, Before, or After for a Location. Don't choose Replace or you'll lose all the other menu pads when your form is running.<br><br></li>
<li>
In the Menu Designer, click the Options button to open the Prompt Options dialog box.<br><br></li>
<li>
In the Prompt Options dialog box, specify a Pad Name. You'll need the pad name when removing the pad from the system menu.<br><br></li>
<li>
Generate the menu code.</li>
</ol>
<p>
To associate the menu with the form:
<ol>
<li>
In the Activate event of the form, run your menu. For example, if your menu is defined in FORMMENU.MPR, include the following code.<br><br></li>
<li>
<pre><code>DO FormMenu.MPR
</code></pre>
</li>
<li>
In the Deactivate event of the form and the Destroy event of the form, release the menu pad. For example, if your menu pad is named <i>myform</i>, include the following line of code in both places:<pre><code>RELEASE PAD myform OF _MSYSMENU
</code></pre>
</li>
</ol>
<h3>Displaying Most Recently Used Documents on the File Menu</h3>
<p>
Windows-based applications often display the most recently used (MRU) documents on the File menu so that a user can quickly go back to a document or project that he or she has been working on. It is relatively easy to provide this functionality in your applications.</p>
<h4>Tracking most recently used documents</h4>
<p>
In order to display the most recently used forms, or most recently run reports or queries, you need to save information about these documents in a table. The following table, for example, saves the prompt to display on the menu, the action to be performed when the user chooses the item, and a timestamp to order the items by their most recent use.</p>
<p>
<img src="menus_5.gif" border=0></p>
<p>
Obviously, you don't want to display the last thirty forms, reports, or queries on the file menu, so you'll need to limit the number of items to display—a good number being between four and eight.</p>
<p>
When the user runs a query, report, or form, select the table for storing the most recently used items, UPREFS.DBF in this example, and update the information, as illustrated in the following code.</p>
<p>
In this code, <i>cFormName</i> is the name of the form the user is about to run, <i>cAction</i> is a string with the action to be performed when the user subsequently chooses the menu item to reopen the form (in this case, probably <code>"DO FORM" + cFormName</code>), and <i>nMaxItems</i> is the limit you have set for the number of most recently used items to display.</p>
<pre><code>SELECT Uprefs
LOCATE FOR prompt = cFormName
IF FOUND()
 &nbsp;&nbsp; REPLACE Timestamp WITH DATETIME()
ELSE
 &nbsp;&nbsp; IF RECCOUNT() &lt; nMaxItems&nbsp; &amp;&amp; maximum number of items to display
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO Uprefs VALUES(cFormName, cAction, DATETIME())
 &nbsp;&nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET ORDER TO Timestamp ASCENDING &amp;&amp; oldest at top
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TOP
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REPLACE prompt WITH cFormName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REPLACE Action WITH cAction
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REPLACE Timestamp WITH DATETIME()
 &nbsp;&nbsp; ENDIF
ENDIF
</code></pre>
<p>
Every time you update the preferences table, you need to rerun the File menu program:</p>
<pre><code>DO FILE.MPR
</code></pre>
<h4>Adding most recently used documents to the file menu</h4>
<p>
When you create the File menu in the Menu Designer, create all the items for the File menu except for the separator bar and Exit item at the end of the menu. These will be added in code after the most recently used items are added.</p>
<p>
Add the following code in the Cleanup editing window. In this code, the <i>nBar</i> variable always reflects the number of defined bars on the menu. The <i>iPrefix</i> variable stores the number to be displayed beside the most recently used item.</p>
<pre><code>nBar = CNTBAR("_MFILE")

cOldAlias = ALIAS()

IF !USED('UPrefs')
 &nbsp;&nbsp; USE UPrefs IN 0
ENDIF
SELECT Uprefs
* Order so that most recently used is at the top.
SET ORDER TO timestamp DESCENDING

IF RECCOUNT() &gt; 0 &amp;&amp; some user preferences are saved
 &nbsp;&nbsp; iPrefix = 0
 &nbsp;&nbsp; nBar = nBar + 1
 &nbsp;&nbsp; * Add a separator bar before the MRU list.
 &nbsp;&nbsp; DEFINE BAR nBar OF _MFILE PROMPT "\-"
 &nbsp;&nbsp; SCAN
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nBar = nBar + 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iPrefix = iPrefix + 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cAction = ALLTRIM(UPrefs.Action)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFINE BAR nBar OF _MFILE PROMPT "\&lt;" + ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLTRIM(STR(iPrefix)) + " " + UPrefs.Prompt
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON SELECTION BAR nBar OF _MFILE &amp;cAction
 &nbsp;&nbsp; ENDSCAN
ENDIF

* Add the Exit menu item.
DEFINE BAR nBar + 1 OF _MFILE PROMPT "\-"
DEFINE BAR nBar + 2 OF _MFILE PROMPT "E\&lt;xit"
ON SELECTION BAR nBar + 2 OF _MFILE CLEAR EVENTS

IF !EMPTY(cOldAlias)
 &nbsp;&nbsp; SELECT (cOldAlias)
ENDIF
</code></pre>
<p>
Given the two items in the table in the example, the following illustration displays the resulting menu.</p>
<p>
<img src="menus_6.gif" border=0></p>
<h2>Adding Menus to Top-Level Forms</h2>
<p>
A top-level form (also referred to as a single-document interface or SDI form) is not a child window of the main Visual FoxPro window. In Visual FoxPro 3.0, you can create an SDI form by setting the Desktop property of the form to true (.T.). Top-level forms in Visual FoxPro 5.0 are more truly independent of the main Visual FoxPro window. You can create a top-level form in Visual FoxPro 5.0 by setting the ShowWindow property of the form to 2 - As Top-Level Form. Because the top-level form is not contained in the main Visual FoxPro window and doesn't necessarily have access to the system menu, you might want to add a menu directly to your form.</p>
<p>
The Visual FoxPro 3.0 Menu Designer doesn't allow you to create a menu for a top-level form, so you'll have to write the code yourself. The following code, for example, can be added to the Init event of a form to add a menu to the form:&nbsp; </p>
<pre><code>DEFINE MENU _example BAR IN WINDOW (THISFORM.Name) COLOR SCHEME 1

DEFINE PAD p1 OF _example PROMPT "\&lt;File"
DEFINE PAD p2 OF _example PROMPT "\&lt;Color"
ON PAD p1 OF _example ACTIVATE POPUP file
ON PAD p2 OF _example ACTIVATE POPUP color

DEFINE POPUP file MARGIN 
DEFINE BAR 1 OF file PROMPT "E\&lt;xit"
ON SELECTION BAR 1 OF file _SCREEN.ActiveForm.Release

DEFINE POPUP color MARGIN 
DEFINE BAR 1 OF color PROMPT "ForeColor"
DEFINE BAR 2 OF color PROMPT "BackColor"

ON SELECTION BAR 1 OF color _SCREEN.ActiveForm.SetAll("ForeColor", GETCOLOR())
ON SELECTION BAR 2 OF color _SCREEN.ActiveForm.SetAll("BackColor", GETCOLOR())

ACTIVATE MENU _example NOWAIT
</code></pre>
<p>
<img src="menus_7.gif" border=0></p>
<p>
In Visual FoxPro 5.0, you can use the Menu Designer to create menus for top-level forms. Choose General Options from the View menu to open the General Options dialog box, and select Top-Level Form to create a menu for a top-level form.</p>
<p>
<img src="menus_8.gif" border=0></p>
<p>
When you generate a menu for a top-level form, the generated menu code includes comments on how to use the menu:</p>
<pre><code>* To attach this menu to your Top-Level form, 
* call it from the Init event of the form:

* Syntax: DO &lt;mprname&gt; WITH &lt;oFormRef&gt; [,&lt;cMenuname&gt;|&lt;lRename&gt;]

*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oFormRef - form object reference (THIS)
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cMenuname - name for menu
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lRename - renames Name property of your form

* example:

*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROCEDURE Init
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO mymenu.mpr WITH THIS,.T.
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDPROC

* Use the optional 2nd parameter if you plan on running 
* multiple instances of your Top-Level form. The logical 
* lRename parameter will change the name property of your 
* form to the same name given the menu and may cause conflicts 
* in your code if you directly reference the form by name.
* You will also need to remove the menu when the form is 
* destroyed so that it does not remain in memory, 
* unless you wish to reactivate it later in a new form.

* If you passed the optional lRename parameter as .T., as in 
* the above example, you can easily remove the menu in the 
* form's Destroy event as shown below. This strategy is ideal 
* when using multiple instances of Top-Level forms.

* example:

*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROCEDURE Destroy
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RELEASE MENU (THIS.Name)
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDPROC
</code></pre>
<h2>Creating Shortcut Menus</h2>
<p>
A shortcut menu is typically displayed when a user right-clicks on an object. When you create a new menu in Visual FoxPro 5.0, you have to choose whether you want to create a normal menu or a shortcut menu.</p>
<p>
<img src="menus_9.gif" border=0></p>
<p>
In Visual FoxPro 5.0, there are two examples of shortcut menus in the Visual FoxPro Solutions sample application: <i>Display shortcut menus</i> and <i>Create dynamic shortcut menus</i>. The <i>Create dynamic shortcut menus</i> example, described in the "Creating Shortcut Menus Without the Menu Designer" section below, uses menu definition code in a menu utility class to create the shortcut menu. With a minor adjustment, this code can also be used in Visual FoxPro 3.0.</p>
<h3>Displaying Check Marks Beside Shortcut Menu Options</h3>
<p>
You can dynamically display check marks beside items on a shortcut menu by including the #PREPOP directive in the Setup code for the menu and using the SET MARK OF command in the Cleanup code. The #PREPOP generator directive causes the code in the menu's Cleanup to be generated before the ACTIVATE POPUP command.</p>
<p>
The <i>Display shortcut menus</i> example in the Visual FoxPro Solutions sample application illustrates how to add a check mark beside a shortcut menu item.</p>
<p>
<img src="menus_10.gif" border=0></p>
<p>
The following line of code is included in the RightClick event of the "Display shortcut menus" example form:</p>
<pre><code>DO frmshort.mpr WITH THIS
</code></pre>
<p>
FRMSHORT is the shortcut menu. The following code is included in the Setup code window for the menu:</p>
<pre><code>PARAMETER oREF
#PREPOP
</code></pre>
<p>
The oREF parameter allows you to check or set object (in this case, the form) properties in the menu code. The following code in the Cleanup code window sets a check mark beside a menu item if the AlwaysOnTop property of the form is set to true (.T.).</p>
<pre><code>SET MARK OF BAR 4 OF frmshort TO oRef.AlwaysOnTop
</code></pre>
<p>
The code that is generated from the menu includes the following lines, modifying the display of the menu item before the shortcut menu is displayed:</p>
<pre><code>SET MARK OF BAR 4 OF frmshort TO oRef.AlwaysOnTop
ACTIVATE POPUP frmshort
</code></pre>
<p>
Without the #PREPOP directive, the following code would be generated.</p>
<pre><code>ACTIVATE POPUP frmshort
SET MARK OF BAR 4 OF frmshort TO oRef.AlwaysOnTop
</code></pre>
<p>
And because code execution is suspended with the ACTIVATE POPUP command until the user makes a choice, the SET MARK OF command isn't executed until after the shortcut menu is no longer displayed.</p>
<h3>Creating Shortcut Menus Without the Menu Designer</h3>
<p>
You can also create shortcut menus without the Menu Designer. The <i>Create dynamic shortcut menus</i> example in the Visual FoxPro 5.0 Solutions sample illustrates how to create a shortcut menu driven from an array. Because it is data-driven, it is more easily configurable at run time, and the strategy works in both Visual FoxPro 3.0 and 5.0.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In order to run the following code in Visual FoxPro 3.0, you need to remove the SHORTCUT keyword from the DEFINE POPUP command. The SHORTCUT keyword was added in Visual FoxPro 5.0 to provide standard Windows 95 shortcut menu behavior.</p>
<p>
The RightClick event of the example form contains the following code. The oMenuShortcut object referenced in this code is based on the menulib class in the Visual FoxPro \SAMPLES\CLASSES\UTILITY.VCX library.</p>
<pre><code>LOCAL laMenu[5]

laMenu=""
laMenu[1]="\&lt;Center"
laMenu[2]="\&lt;Font..."
laMenu[3]="\&lt;Minimize"
laMenu[4]="\-"
laMenu[5]="E\&lt;xit"
THISFORM.oMenuShortcut.ShowMenu(@laMenu)
DO CASE
 &nbsp;&nbsp; CASE BAR()=1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.AutoCenter=.T.
 &nbsp;&nbsp; CASE BAR()=2
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.SetFont &amp;&amp; a user-defined method
 &nbsp;&nbsp; CASE BAR()=3
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.WindowState=1
 &nbsp;&nbsp; CASE BAR()=5
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THISFORM.Release
ENDCASE
</code></pre>
<p>
The ShowMenu method of the oMenuShortcut object (based on the menulib class) contains the following code:</p>
<pre><code>LPARAMETERS taMenu,tcOnSelection
LOCAL lcOnSelection,lnMenuCount,lnCount,llDoubleArray
LOCAL lcMenuItem,lcMenuSelection
EXTERNAL ARRAY taMenu

IF PARAMETERS()=0 OR TYPE("taMenu")#"C"
 &nbsp;&nbsp; RETURN .F.
ENDIF
lnMenuCount=0
lnMenuCount=ALEN(taMenu,1)
IF lnMenuCount=0
 &nbsp;&nbsp; RETURN .F.
ENDIF
llDoubleArray=(ALEN(taMenu,2)&gt;0)
ACTIVATE SCREEN
DEACTIVATE POPUP _popShortcutMenu
DEFINE POPUP _popShortcutMenu ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM MROW(),MCOL() ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MARGIN ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RELATIVE ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHORTCUT
FOR lnCount = 1 TO lnMenuCount
 &nbsp;&nbsp; lcMenuItem=IIF(llDoubleArray,taMenu[lnCount,1],taMenu[lnCount])
 &nbsp;&nbsp; DEFINE BAR lnCount OF _popShortcutMenu PROMPT (lcMenuItem)
ENDFOR
ON SELECTION POPUP _popShortcutMenu DEACTIVATE POPUP _popShortcutMenu
ACTIVATE POPUP _popShortcutMenu
RELEASE POPUP _popShortcutMenu
IF BAR()=0
 &nbsp;&nbsp; RETURN .F.
ENDIF
IF llDoubleArray
 &nbsp;&nbsp;&nbsp; lcMenuSelection=taMenu[BAR(),2]
 &nbsp;&nbsp;&nbsp; IF NOT EMPTY(lcMenuSelection) AND TYPE("lcMenuSelection")=="C"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lcOnSelection=ALLTRIM(lcMenuSelection)
 &nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp;&nbsp; IF EMPTY(lcOnSelection)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lcOnSelection=ALLTRIM(IIF(EMPTY(tcOnSelection),"",tcOnSelection))
 &nbsp;&nbsp;&nbsp; ENDIF
ELSE
 &nbsp;&nbsp; lcOnSelection=ALLTRIM(IIF(EMPTY(tcOnSelection),"",tcOnSelection))
ENDIF
IF EMPTY(lcOnSelection)
 &nbsp;&nbsp; RETURN .F.
ENDIF
&amp;lcOnSelection
</code></pre>
<p>
When the user right-clicks the form, the shortcut menu is defined from the array and displayed for user choice.</p>
<h2>Creating Menu Classes</h2>
<p>
Menus are not objects in Visual FoxPro, but you can write wrapper classes around Visual FoxPro menu definition code to provide the familiar object development interface. There are several implementations of menu classes available. For example, the <i>Visual FoxPro 3 CodeBook</i> by Yair Alan Griver (Sybex, 1995) provides source code and documentation for a robust implementation of menu classes. Other menu classes are available for downloading from the Internet. The following is a very simple example of creating and using menu classes.</p>
<pre><code>PUSH MENU _MSYSMENU

bar1 = CREATEOBJECT("mBar", "Test1", "bar1", "MESSAGEBOX(PROMPT())")
bar2 = CREATEOBJECT("mBar", "Test2", "bar2", "MESSAGEBOX(PROMPT())")
bar3 = CREATEOBJECT("mBar", "Done", "bar3", "POP MENU _MSYSMENU")
pop1 = CREATEOBJECT("mPop", "pop1")
pop1.AddBar(bar1)
pop1.AddBar(bar2)
pop1.AddBar(bar3)
pad1 = CREATEOBJECT("mPad", "Pad1", "No message")
pad1.SetPopup(pop1)


* Class Definitions
DEFINE CLASS mpad AS CUSTOM
 &nbsp;&nbsp; PadName = ""
 &nbsp;&nbsp; Message = ""
 &nbsp;&nbsp; 
 &nbsp;&nbsp; PROCEDURE Init(cName, cMessage)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.PadName = cName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.Message = cMessage
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFINE PAD (cName) OF _MSYSMENU ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROMPT cName MESSAGE cMessage
 &nbsp;&nbsp; ENDPROC&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; PROCEDURE SetPopup(oPopup)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cName = THIS.PadName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cPopup = oPopup.PopName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON PAD (cName) OF _MSYSMENU ACTIVATE POPUP (cPopup)
 &nbsp;&nbsp; ENDPROC
ENDDEFINE

DEFINE CLASS mpop AS CUSTOM
 &nbsp;&nbsp; PopName = ""
 &nbsp;&nbsp; BarCount = 0
 &nbsp;&nbsp; 
 &nbsp;&nbsp; PROCEDURE Init(cName)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.PopName = cName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFINE POPUP (cName) MARGIN
 &nbsp;&nbsp; ENDPROC
 &nbsp;&nbsp; 
 &nbsp;&nbsp; PROCEDURE AddBar(oBar)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cName = THIS.PopName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cAction = oBar.Action
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.BarCount = THIS.BarCount + 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFINE BAR THIS.BarCount OF (cName) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROMPT oBar.Prompt ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MESSAGE oBar.Message
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON SELECTION BAR THIS.BarCount OF (cName) &amp;cAction
 &nbsp;&nbsp; ENDPROC
ENDDEFINE

DEFINE CLASS mBar AS CUSTOM
 &nbsp;&nbsp; Prompt = ""
 &nbsp;&nbsp; Message = ""
 &nbsp;&nbsp; Action = ""
 &nbsp;&nbsp; 
 &nbsp;&nbsp; PROCEDURE Init(cPrompt, cMessage, cAction)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.Prompt = cPrompt
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.Message = cMessage
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.Action = cAction
 &nbsp;&nbsp; ENDPROC
ENDDEFINE
</code></pre>
<h2>Creating Data-Driven Menus</h2>
<p>
The more data-driven your menu system is, the more flexible and configurable it is at run time. You can create your own procedures or classes that manage reading data from one or more tables and construct a menu system based on the values stored in the table. The following example illustrates how to design a completely data-driven menu system.</p>
<p>
In this example, there is one table that stores menu system information and separate tables for each menu popup store bar information. The table that stores the menu system information is Menubar, defined below.</p>
<pre><code>CREATE TABLE MENUBAR ;
 &nbsp;&nbsp; (NPAD C(15), ;
 &nbsp;&nbsp; PROMPT C(25), ;
 &nbsp;&nbsp; MESSAGE M, ;
 &nbsp;&nbsp; POPNAME C(15), ;
 &nbsp;&nbsp; DBFNAME C(10))
</code></pre>
<p>
The following are some possible values for a couple of records in the menubar table:</p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=18%><b>NPAD</b></td>
<td class=label width=15%><b>PROMPT</b></td>
<td class=label width=35%><b>MESSAGE</b></td>
<td class=label width=16%><b>POPNAME</b></td>
<td class=label width=16%><b>DBFNAME</b></td>
</tr>
<tr valign=top>
<td width=18%>_MSM_FILE&nbsp; </td>
<td width=15%>\&lt;File</td>
<td width=35%>Open, Close, Save, etc.</td>
<td width=16%>_MFILE</td>
<td width=16%>FILE</td>
</tr>
<tr valign=top>
<td width=18%>_MSM_EDIT</td>
<td width=15%>\&lt;Edit</td>
<td width=35%>Cut, Copy, Paste, Find, etc.</td>
<td width=16%>_MEDIT</td>
<td width=16%>EDIT</td>
</tr>
</table><br>
<p>
This example requires a separate table for each menu, listing all the items and what to do when the item is chosen. For example, you could have a table with the following structure:</p>
<pre><code>CREATE TABLE FILE ;
 &nbsp;&nbsp; (NBAR C(15), ;
 &nbsp;&nbsp; PROMPT C(25), ;
 &nbsp;&nbsp; MESSAGE M, ;
 &nbsp;&nbsp; SKIPFOR M, ;
 &nbsp;&nbsp; HOTKEY C(8), ;
 &nbsp;&nbsp; ACTION M)
</code></pre>
<p>
The following are some possible values for a couple of records in the File table:</p>
<table border=1 cellpadding=5 cols=6 frame=below rules=rows>
<tr valign=top>
<td class=label width=11%><b>NBAR</b></td>
<td class=label width=14%><b>PROMPT</b></td>
<td class=label width=19%><b>MESSAGE</b></td>
<td class=label width=14%><b>SKIPFOR</b></td>
<td class=label width=14%><b>HOTKEY</b></td>
<td class=label width=28%><b>ACTION</b></td>
</tr>
<tr valign=top>
<td width=11%>1</td>
<td width=14%>\&lt;New</td>
<td width=19%>New Customer</td>
<td width=14%></td>
<td width=14%>Ctrl+N</td>
<td width=28%>DO NewCustomer</td>
</tr>
<tr valign=top>
<td width=11%>2</td>
<td width=14%>\&lt;Open</td>
<td width=19%>Open a form</td>
<td width=14%></td>
<td width=14%>Ctrl+O</td>
<td width=28%>DO FORM GETFILE('scx')</td>
</tr>
</table><br>
<p>
When you have the data ready, you can run a program or call a method that reads the values and creates the menus. For example, the following code reads through the menubar table and creates menus based on the menubar data.</p>
<pre><code>SELECT MenuBar
SCAN
 &nbsp;&nbsp; DEFINE PAD (ALLTRIM(npad)) OF _MSYSMENU ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROMPT ALLTRIM(Prompt) MESSAGE ALLTRIM(Message)
 &nbsp;&nbsp; DO DefinePop WITH popname, npad, dbfname
ENDSCAN
</code></pre>
<p>
The DefinePop procedure creates the popup, associates it with the appropriate pad, and defines all the bars:</p>
<pre><code>PROCEDURE DefinePop
LPARAMETERS cPopup, cPadName, cTable
cPopup = ALLTRIM(cPopup)
cPadName = ALLTRIM(cPadName)
cTable = ALLTRIM(cTable)
cOldAlias = ALIAS()

DEFINE POPUP (cPopup) RELATIVE MARGIN
ON PAD (cPadName) OF _MSYSMENU ACTIVATE POPUP (cPopup)
LOCAL cAction, cPad, cKey, cDefineString

IF !USED(cTable)
 &nbsp;&nbsp; USE (cTable) IN 0
ENDIF
SELECT (cTable)

SCAN
 &nbsp;&nbsp; cAction = ALLTRIM(action)
 &nbsp;&nbsp; cBar = ALLTRIM(nBar)
 &nbsp;&nbsp; cKey = ALLTRIM(hotkey)
 &nbsp;&nbsp; cSkipFor = ALLTRIM(skipfor)

 &nbsp;&nbsp; cDefineString = "DEFINE BAR " + cBar + ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " OF " + cPopup + ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " PROMPT '" + ALLTRIM(prompt) + "'"
 &nbsp;&nbsp; IF !EMPTY(cKey)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDefineString = cDefineString + " KEY " + cKey
 &nbsp;&nbsp; ENDIF
 &nbsp;&nbsp; IF !EMPTY(cSkipFor)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDefineString = cDefineString + " SKIP FOR " + cSkipFor
 &nbsp;&nbsp; ENDIF

 &nbsp;&nbsp; &amp;cDefineString
 &nbsp;&nbsp; ON SELECTION BAR &amp;cBar of (cPopup) &amp;cAction
ENDSCAN

IF !EMPTY(cOldAlias)
 &nbsp;&nbsp; SELECT (cOldAlias)
ENDIF
RETURN
</code></pre>
<p>
If you want to implement a data-driven menu engine like this, the best way to do it is to create a form class with methods that manage the menu definition code, then create a form based on your this class and set the DataSession property of the form to 2 - Private Data Session. When you run the form in your application, use the NOSHOW keyword so that the form is created but not displayed, for example </p>
<pre><code>DO FORM menuform NOSHOW 
</code></pre>
<p>
Then call the methods on the form to manage your menu system.</p>
<h2>Acknowledgments </h2>
<p>
Randy Brown, Tom Cooper, and Ken Levy reviewed this paper, pointing out holes and suggesting changes. Liz Ruest edited the paper.</p>
</BODY>
</HTML>
