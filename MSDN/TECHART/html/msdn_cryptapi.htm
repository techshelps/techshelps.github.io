<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Cryptography API, or How to Keep a Secret</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_cryptapi"></a></sup>The Cryptography API, or How to Keep a Secret</h1>
<p>
Robert Coleridge<br>
Microsoft Developer Network Technology Group</p>
<p>
August 19, 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5003">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the CryptAPI sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes the Microsoft® Cryptography application programming interface (API) that is available with the new Windows NT® version 4.0 release and upcoming versions of Windows® 95. This article examines what is required to set up and use this new API. In order to compile the sample application you will need Microsoft Visual C++® version 4.2 or later and Windows NT 4.0 or later.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;<b> Portions of the Cryptography API fall under U.S. export restrictions.</b></p>
<h2>Introduction</h2>
<p>
The Cryptography API has a number of significant uses within the Enterprise Computing Model. Computing on an Enterprise scale implies a more global framework for interaction between people, such as international commodity trading, interstate inventory management, and so on. Within that framework it is often necessary to transmit sensitive information over non-secure channels—for example, faxing contracts, e-mailing buy or sell orders, and so on. By using the Cryptography API, you can guarantee the security of such information.</p>
<p>
This article uses the CRYPTOAPI sample application to&nbsp; demonstrate how to decrypt or encrypt data, sign and verify files, and add and remove users.</p>
<h2>An Overview of the Cryptography API</h2>
<h3>Cryptography Service Providers (CSPs)</h3>
<p>
[Editor's note: Portions of this article are quoted directly from "The CryptoAPI Programming Model" (MSDN Library, Platform, SDK, and DDK Documentation). Those sections of text are indented (all text is normally flush left) but not preceded by a number, a bullet, or the word "Note:", so that you can easily identify them.]</p>
<p class=indent>
The Cryptography API contains functions that allow applications to encrypt or digitally sign data in a flexible manner, while providing protection for the user's sensitive private key data. All cryptographic operations are performed by independent modules known as <i>cryptographic service providers</i> (CSPs). One CSP, the Microsoft RSA Base Provider, is included with the operating system.</p>
<p class=indent>
Each CSP provides a different implementation of the Cryptography API layer. Some provide stronger cryptographic algorithms, while others contain hardware components such as <i>smartcards</i> [plastic cards containing microchips that hold security data about the user]. In addition, some CSPs may occasionally communicate with users directly, such as when digital signatures are performed using the user's <i>signature private key</i>. </p>
<p class=indent>
Applications should not take advantage of attributes particular to a specific CSP. For example, the Microsoft RSA Base Provider currently uses 40-bit <i>session keys</i> and 512-bit <i>public keys</i>. (See "Symmetric Versus Public-Key Encryption," MSDN Library, Platform, SDK, and DDK Documentation) When applications manipulate these, they should be careful not to make assumptions about the amount of memory needed to store them. Otherwise, the application is likely to fail when the user loads a different CSP onto the system. You should take care to write applications that are as well-behaved and flexible as possible.</p>
<h3>Key Databases</h3>
<p class=indent>
Each CSP has a <i>key database</i> in which it stores its persistent cryptographic keys. Each key database contains one or more <i>key containers</i>, each of which contains all the key pairs belonging to a specific user (or Cryptography API client). Each key container is given a unique name, which applications provide to the <b>CryptAcquireContext</b> function when acquiring a handle to the key container. Figure 1 is an illustration of the contents of a key database:</p>
<p>
<img src="cryptapi_1.gif" border=0></P><p class=indent>
<b>Figure 1. Contents of a key database</b></p>
<p class=indent>
The CSP stores each key container from session to session, including all the public/private key pairs it contains. However, session keys are not preserved from session to session.</p>
<p>
Although it is possible to find these keys on a computer, they are stored in an encrypted and secure format.</p>
<p class=indent>
Generally, a default key container is created for each user. This key container takes the user's logon name as its own name, which is then used by any number of applications. It is also possible for an application to create its own key container (and key pairs), which it usually names after itself.</p>
<h3>Keys</h3>
<h4>Session Keys</h4>
<p class=indent>
Session keys are used when encrypting and decrypting data. They are created by applications using either the <b>CryptGenKey</b> or the <b>CryptDeriveKey</b> function. These keys are kept inside the CSP for safekeeping.</p>
<p class=indent>
Unlike the key pairs, session keys are volatile. Applications can save these keys for later use or transmission to other users by exporting them from the CSP into application space in the form of an encrypted <i>key binary large object</i> or <i>key blob</i> using the <b>CryptExportKey</b> function.</p>
<h4>Public or Private Key Pairs</h4>
<p class=indent>
Each user generally has two public or private key pairs. One key pair is used to encrypt session keys and the other to create digital signatures. These are known as the <i>key exchange</i> key pair and the <i>signature </i>key pair, respectively.</p>
<p class=indent>
Note that although key containers created by most CSPs will contain two key pairs, this is not required. Some CSPs do not store any key pairs, while others store additional ones.</p>
<h3>Encryption</h3>
<p class=indent>
In using data encryption, a plain-text message can be encoded so it appears as completely random binary data that is very difficult (if not impossible) to transform back to the original message without a secret key. In this article, the following definitions apply:
<ul type=disc>
<li>
<i>Message</i> is used to refer to any piece of data. A message can consist of ASCII text, a database file, or any data you want to store or transmit securely.<br><br></li>
<li>
<i>Plain text</i> is used to refer to data that has not been encrypted.<br><br></li>
<li>
<i>Cipher text</i> refers to data that has been encrypted.</li>
</ul>
<p class=indent>
Once a message has been encrypted, it can be stored on nonsecure media or transmitted on a nonsecure network and still remain secret. Later, the message can be decrypted into its original form. This process is shown in Figure 2.</p>
<p>
<img src="cryptapi_2.gif" border=0></P><p class=indent>
<b>Figure 2. Encrypting and decrypting a message</b></p>
<p class=indent>
When a message is encrypted, an <i>encryption key</i> is used. This is analogous to the physical key that is used to lock a padlock. To decrypt the message, the corresponding <i>decryption key</i> must be used. It is very important to properly restrict access to the decryption key, because anyone who possesses it will be able to decrypt all messages that were encrypted with the matching encryption key.</p>
<p class=indent>
This may come as a surprise, but data encryption/decryption is pretty straightforward. The really difficult part is keeping the keys safe and transmitting them securely to other users. This topic is beyond the scope of this article but I would recommend that the reader read the section titled "Exchanging Cryptographic Keys" in the Win32® Cryptography API documentation (MSDN Library, Platform, SDK, and DDK Documentation).</p>
<p class=indent>
There are two main classes of encryption algorithms: <i>symmetric</i> algorithms and <i>public-key</i> algorithms (also known as <i>asymmetric</i> algorithms). Systems that use symmetric algorithms are sometimes referred to as <i>conventional</i>.</p>
<h4>Algorithms</h4>
<p class=indent>
Symmetric algorithms are the most common type of encryption algorithm. They are known as "symmetric" because the same key is used for both encryption and decryption. Unlike the keys used with public-key algorithms, symmetric keys are frequently changed. For this reason, they are referred to here as <i>session keys</i>. Compared to public-key algorithms, symmetric algorithms are very fast and thus are preferred when encrypting large amounts of data. Some of the more common symmetric algorithms are RC2, RC4, and the Data Encryption Standard (DES).</p>
<p class=indent>
Public-key (asymmetric) algorithms use a pair of different keys: a public key and a private key. The private key is kept private to the owner of the key pair, and the public key can be distributed to anyone who requests it. If one key is used to encrypt a message, the other key is required to decrypt the message. Public-key algorithms are very slow, on the order of a thousand times slower than symmetric algorithms. Consequently, they are normally used only to encrypt session keys. They are also used to digitally sign messages, as discussed in the next section. One of the most common public-key algorithms is the RSA Public-Key Cipher.</p>
<h4>File Signing</h4>
<p class=indent>
<i>Digital signatures</i> can be used when you have a message that you plan to distribute in plain-text form, and you want the recipients to be able to verify that the message comes from you and that it hasn't been tampered with since it left your hands. Signing a message does not alter the message, it simply generates a digital signature string you can bundle with the message or transmit separately.</p>
<p class=indent>
Digital signatures are generated using public-key signature algorithms. A private key is used to generate the signature, and the corresponding public key is used to validate the signature. This process is shown in Figure 3.</p>
<p>
<img src="cryptapi_3.gif" border=0></P><p class=indent>
<b>Figure 3. Validating a signature</b></p>
<h2>Some Cryptography API Functions</h2>
<p>
[Editor's note: Indented portions of the following text are quoted from MSDN Library, Platform, SDK, and DDK Documentation.]</p>
<h3>Initiating the CSP: CryptAcquireContext, CryptReleaseContext</h3>
<p class=indent>
The <b>CryptAcquireContext</b> function is used to obtain a handle to a particular key container within a particular CSP. This returned handle can then be used to make calls to the selected CSP.</p>
<p>
The <b>CryptReleaseContext</b> function is used to release the handle returned from a call to <b>CryptAcquireContext</b>. The <b>CryptReleaseContext</b> function does not delete any Cryptography API objects, but merely releases the handle to an object.</p>
<p class=indent>
The <b>CryptAcquireContext</b> function performs two operations. It first attempts to find a CSP with the characteristics described by various parameters. If the CSP is found, the function attempts to find a key container within the CSP that matches the specified container name. This function can also be used to create and destroy key containers, depending on the value of the parameters.</p>
<p>
To obtain a handle to the default key container of the default CSP the code would look like this:</p>
<pre><code>#include &lt;wincrypt.h&gt; &nbsp;&nbsp;&nbsp;&nbsp; // CryptoAPI definitions
/*
For non-C/C++ users the constants used here are:
#define MS_DEF_PROV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Microsoft Base Cryptographic Provider v1.0"
#define PROV_RSA_FULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
*/

BOOL bResult;
HCRYPTPROC hProv;

// Attempt to acquire a handle to the default key container.
bResult = CryptAcquireContext(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hProv,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Variable to hold returned handle.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use default key container.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MS_DEF_PROV,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use default CSP.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROV_RSA_FULL,&nbsp;&nbsp;&nbsp;&nbsp; // Type of provider to acquire.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No special action.
.
.
.
//Do some work.
.
.
.
// Release handle to container.
CryptReleaseContext(hProv);
</code></pre>
<p>
If the call to <b>CryptAcquireContext</b> is successful, the return code will be non-zero and the variable <i>hProv</i> will be a handle to the requested key container.</p>
<p>
In order to add or create a key container for the default CSP we would write code like the following:</p>
<pre><code>#include &lt;wincrypt.h&gt; &nbsp;&nbsp;&nbsp;&nbsp; // CryptoAPI definitions
/*
For non C/C++ users the constants used here are:
#define MS_DEF_PROV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Microsoft Base Cryptographic Provider v1.0"
#define PROV_RSA_FULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
#define CRYPT_NEWKEYSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8
*/

BOOL bResult;
HCRYPTPROC hProv;

// Attempt to add a new key container.
BResult = CryptAcquireContext(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hProv,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Variable to hold returned handle.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use default key container.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MS_DEF_PROV,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use default CSP.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROV_RSA_FULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Type of provider to acquire.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>CRYPT_NEWKEYSET</b>);&nbsp;&nbsp;&nbsp; // Create new key container.
.
.
.
//Do some work.
.
.
.
// Release handle to container.
CryptReleaseContext(hProv);
</code></pre>
<p>
If the call to <b>CryptAcquireContext</b> is successful, the return code will be non-zero and the variable <i>hProv</i> will be a handle to the new key container.</p>
<p>
In order to delete an existing key container from the default CSP, we would write code like the following:</p>
<pre><code>#include &lt;wincrypt.h&gt; &nbsp;&nbsp;&nbsp;&nbsp; // CryptoAPI definitions
/*
For non C/C++ users the constants used here are:
#define MS_DEF_PROV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Microsoft Base Cryptographic Provider v1.0"
#define PROV_RSA_FULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
#define CRYPT_DELETEKEYSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10
*/
BOOL bResult;
HCRYPTPROC hProv;

// Attempt to delete key container.
BResult = CryptAcquireContext(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hProv,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Variable to hold returned handle.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use default key container.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MS_DEF_PROV,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use default CSP.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROV_RSA_FULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Type of provider to acquire.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>CRYPT_DELETEKEYSET</b>);&nbsp;&nbsp; // Delete existing key container.
</code></pre>
<p>
If the call to <b>CryptAcquireContext</b> is successful, the return code will be non-zero, the key container pointed to by <i>hProv</i> will have been deleted, and the key container will no longer be valid.</p>
<h3>Hashing Data: CryptCreateHash, CryptHashData, CryptGetHashParam, and CryptDestroyHash</h3>
<p>
When I say "hashing" or "hash," I am referring to the method or algorithm used to derive a numeric value from a piece of data. This could be something as simple as adding up all of the one bits in the data, or as complicated as doing a Fourier transformation of the data.</p>
<p>
The four functions listed in the heading above are used to create or manipulate hash value from supplied data, and are usually used together:
<ul type=disc>
<li>
The <b>CryptCreateHash</b> function is used to initiate the hashing of data. It returns a handle to a CSP hash object, which can be used in subsequent calls to <b>CryptHashData</b> in order to hash the data.<br><br></li>
<li>
The next step is to use the <b>CryptGetHashParam</b> function to retrieve the hash value.<br><br></li>
<li>
The <b>CryptDestroyHash</b> function is used to release the handle returned from <b>CryptCreateHash</b>. <b>CryptDestroyHash</b> does not delete any Cryptography API objects, but merely releases the handle to a hash object.</li>
</ul>
<p>
The <b>CryptHashData</b> function is used to compute the cryptographic hash of some supplied data. This function can be called multiple times to compute the hash on large data or different pieces of data. As an example, we will hash the data that is contained in a buffer pointed to by <b>pBuffer</b> and that is <b>dwBufferLen</b> bytes long. I have chosen the <b>CALG_MD5</b> hashing algorithm for the purpose of this example only. There are many other algorithms available and fully explained in the Cryptography API SDK documentation. This example assumes only one piece of data to hash. Once the hash value has been retrieved via <b>CryptGetHashParam</b>, no more data can be hashed with this instance of the hash object.</p>
<pre><code>#include &lt;wincrypt.h&gt; &nbsp;&nbsp;&nbsp;&nbsp; // CryptoAPI definitions
/*
For non C/C++ users the constants used here are:
#define ALG_CLASS_HASH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (4 &lt;&lt; 13)
#define ALG_TYPE_ANY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0)
#define ALG_SID_MD5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3
#define CALG_MD5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5)
#define HP_HASHVAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0002&nbsp; // Hash value
#define HP_HASHSIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0004&nbsp; // Hash value size
*/
BOOL bResult;
HCRYPTHASH hHash;
DWORD dwBufferSize;
DWORD dwValue;
PBYTE pBuffer;

// Obtain handle to hash object.
bResult = CryptCreateHash(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hProv,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle to CSP obtained earlier
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALG_MD5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Hashing algorithm
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Non-keyed hash
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Should be zero
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hHash);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Variable to hold hash object handle 

// Hash data.
bResult = CryptHashData(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hHash,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle to hash object
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pointer to data buffer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwBufferlen,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Length of data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No special flags

// Get size of hash value.
dwBufferSize = sizeof(DWORD);
bResult = CryptGetHashParam(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hHash,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle to hash object
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HP_HASHSIZE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get hash value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwValue,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Buffer to hold hash value length
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwBufferSize,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Length of data buffer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Must be zero

// Create buffer to hold hash value.
pBuffer = new char [dwBufferSize];

// Get hash value.
bResult = CryptGetHashParam(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hHash,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle to hash object
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HP_HASHVAL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get hash value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Buffer to hold hash value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwBufferSize,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Length of data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Must be zero

// Release hash object.
CryptDestroyHash(hHash);
</code></pre>
<p>
The above example generated a hash value for the data pointed to by <b>pBuffer</b>. If there was more data to hash, calling <b>CryptHashData</b> with that data would have hashed the new data with the old value. Be warned—calling <b>CryptGetHashParam</b> with the <b>HP_HASHVALUE</b> parameter prevents any further hashing with that particular object.</p>
<h3>Generating Keys: CryptDeriveKey, CryptGenKey, CryptDestroyKey</h3>
<p>
These three functions are the ones used to generate handles to keys:
<ul type=disc>
<li>
The <b>CryptDeriveKey</b> function is used to generate a key from a specified password.<br><br></li>
<li>
The <b>CryptGenKey</b> function is used to generate a key from random generated data.<br><br></li>
<li>
The <b>CryptDestroyKey</b> function is used to release the handle to the key object.</li>
</ul>
<p>
If the <b>CryptGenKey</b> function is used, it is recommended that the <b>CRYPT_EXPORTABLE</b> parameter be used to create an exportable session key. This creates a value that can be moved from one computer to another. Without this parameter the value returned is only valid on that particular computer/session.</p>
<p>
Following is an example of how to use the <b>CryptDeriveKey</b> function, assuming that <b>pPassword</b> points to a user-defined password and <b>dwPasswordLength</b> contains the length of the password.</p>
<pre><code>#include &lt;wincrypt.h&gt; &nbsp;&nbsp;&nbsp;&nbsp; // CryptoAPI definitions
/*
For non C/C++ users the constants used here are:
#define ALG_CLASS_HASH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (4 &lt;&lt; 13)
#define ALG_TYPE_ANY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0)
#define ALG_SID_MD5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3
#define CALG_MD5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5)
#define CRYPT_EXPORTABLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000001
#define ALG_CLASS_DATA_ENCRYPT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3 &lt;&lt; 13)
#define ALG_TYPE_STREAM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (4 &lt;&lt; 9)
#define ALG_SID_RC2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
#define CALG_RC4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_RC4)
*/
BOOL bResult;
HCRYPTHASH hHash;
HCRYPTKEY hKey;

// Obtain handle to hash object.
bResult = CryptCreateHash(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hProv,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle to CSP obtained earlier
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALG_MD5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Hashing algorithm
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Non-keyed hash
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Should be zero
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hHash);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Variable to hold hash object handle 

// Hash data.
bResult = CryptHashData(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hHash,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle to hash object
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPassword,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pointer to password
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwPasswordLength,&nbsp; // Length of data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No special flags


// Create key from specified password.
bResult = CryptDeriveKey(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hProv,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle to CSP obtained earlier.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALG_RC4,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use a stream cipher.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hHash,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle to hashed password.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRYPT_EXPORTABLE,&nbsp;&nbsp;&nbsp; // Make key exportable.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hKey);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Variable to hold handle of key.
.
.
.
Use key to do something.
.
.
.
// Release hash object.
CryptDestroyHash(hHash);

// Release key object.
CryptDestroyKey(hKey);
</code></pre>
<h3>Encrypting and Decrypting Data: CryptEncrypt, CryptDecrypt</h3>
<p>
It would be easy, although not entirely correct, to say that the Cryptography API revolves around these two functions—the encrypting (<b>CryptEncrypt</b>) and decrypting (<b>CryptDecrypt</b>) of data.</p>
<p>
These two functions are extremely useful but require some explanation about their parameters.
<ul type=disc>
<li>
The first six parameters of each function are the same.<br><br></li>
<li>
The first two parameters are simply handles to the key and an optional hash object.<br><br></li>
<li>
The third parameter is a Boolean that remains FALSE until the last block of data, at which point it must be set to TRUE so that the function can do some special processing for the last block of data.<br><br></li>
<li>
The fourth and fifth parameters are simply a flag value and a pointer to the data to be encrypted or decrypted.<br><br></li>
<li>
The sixth parameter is the number of characters in the buffer to be encrypted.<br><br></li>
<li>
The seventh parameter is usually the same as the sixth parameter in that it specifies how long the block is. This is because for many algorithms the resulting encrypted data is the same length as the decrypted data. However, certain algorithms may increase the length of the encrypted data. In those cases the buffer pointed to by the fifth parameter must be long enough to handle the extra data.</li>
</ul>
<p>
The problem of the longer buffer can be alleviated by using the <b>CryptEncrypt</b> function itself to return the size of the required buffer prior to encryption. This technique is demonstrated in the following sample code. In this sample, certain values are assumed to have been obtained earlier, and we only want to encrypt one buffer of data pointed to by <b>pData</b>, which is <b>dwDataLen</b> bytes in length.</p>
<pre><code>BOOL bResult;
PBYTE pBuffer;
DWORD dwSize;

// Set variable to length of data in buffer.
dwSize = dwDataLen;

// Have API return us the required buffer size.
bResult = CryptEncrypt(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hKey,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Key obtained earlier
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No hashing of data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Final or only buffer of data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Must be zero
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No data yet, simply return size
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwSize,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Size of data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwSize);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Size of block

// We now have a size for the output buffer, so create buffer.
pBuffer = new char[dwSize];

// Now encrypt data.
bResult = CryptEncrypt(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hKey,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Key obtained earlier
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No hashing of data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Final or only buffer of data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Must be zero
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBuffer,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Data buffer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwSize,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Size of data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwSize);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Size of block
</code></pre>
<h4>Encrypting and Decrypting Simultaneously</h4>
<p>
When encrypting or decrypting two streams of data simultaneously with the same cryptographic key, a certain amount of care must be taken. The same physical session key must not be used for both operations, because every session key contains internal state information and it will get mixed up if used for more than one operation at a time. A fairly simple solution to this problem is to make a copy of the session key. In this way, the original key can be used for one operation and the copy used for the other.</p>
<p>
Copying a session key is done by exporting the key with <b>CryptExportKey</b> and then using <b>CryptImportKey</b> to import it back in. When the key is imported, the CSP will give the "new" key its own section of internal memory, as if it were not related at all to the original key.</p>
<h2>CRYPTOAPI Sample Application</h2>
<h3>Overview</h3>
<p>
The CRYPTOAPI sample application supplied with this article is a "complete" encryption/decryption utility. The application has the capability to add and remove users from the default CSP, to encrypt and decrypt files with or without a password, to sign and verify signatures, and to display the capabilities of the default CSP.</p>
<p>
The application has the following command structure.</p>
<pre><code>Usage: Encrypt switch [arguments]

Where switch and optional arguments are one of:

Switch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description
 /A[DDUSER]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to add user to CSP table
 /R[EMOVEUSER]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to remove user from CSP table
 /E[NCRYPT]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uf ef [pwd]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to encrypt a file
 /D[ECRYPT]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ef uf [pwd]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to decrypt a file
 /S[IGN]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uf sf [desc]&nbsp;&nbsp;&nbsp;&nbsp; to sign a file
 /V[ERIFY]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uf sf [desc]&nbsp;&nbsp;&nbsp;&nbsp; to verify a signed file
 /C[SP]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to show CSP statistics

 and&nbsp;&nbsp; uf&nbsp;&nbsp; = name of an unencrypted file
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ef&nbsp;&nbsp; = name of an encrypted file
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sf&nbsp;&nbsp; = name of a signed file
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwd&nbsp; = optional password
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc = optional signature description
</code></pre>
<h3>Coding Issues</h3>
<p>
At the time this article was written it was necessary to explicitly define a specific constant in the sample application, because the Cryptography API header file (wincrypt.h) uses the <b>_WIN32_WINNT</b> constant to determine which version of Windows NT® is running. When I wrote the sample application this constant, although necessary for compilation, had not yet been defined by the present compiler. Defining this constant allowed the code to compile without any errors, and the constant can be removed later on when a future compiler defines it.</p>
<p>
The <b>CryptAcquireContext</b> API function has an undocumented constant value called <b>MS_DEF_PROV</b>. This constant is used to indicate the default CSP. This value is used in the sample application with the /ADDUSER command line switch. This allows the application to use whatever CSP is installed, without having to know its name.</p>
<h3>Adding or Removing a User</h3>
<p>
The /ADDUSER and /REMOVERUSER switches are used to add or remove the default cryptographic client. The /ADDUSER switch must be run prior to running the other cryptographic functions, in order for them to work correctly.</p>
<p>
The following operations are performed:
<ol>
<li>
A default key container is created.<br><br></li>
<li>
A digital signature key pair is created within the key container.<br><br></li>
<li>
A key exchange key pair is created within the key container.</li>
</ol>
<p>
These operations only need to be done once, unless the operating system is reinstalled. If the default key container and key pairs have already been created, using this switch again has no effect.</p>
<p>
The /ADDUSER switch is run from the command line as follows:</p>
<pre><code>Encrypt /ADDUSER
</code></pre>
<p>
The /REMOVEUSER switch is run from the command line as follows:</p>
<pre><code>Encrypt /REMOVEUSER
</code></pre>
<h3>Encrypting or Decrypting a File</h3>
<p>
The /ENCRYPT switch is used to encrypt files. Files encrypted via this method can be decrypted later with the /DECRYPT switch.</p>
<p>
Note that the /ADDUSER switch must be run prior to doing any encryption in order to create a key container for the default user.</p>
<p>
The /ENCRYPT switch is run from the command line as follows:</p>
<pre><code>Encrypt /encrypt &lt;source file&gt; &lt;destination file&gt; [ &lt;password&gt; ]
</code></pre>
<p>
The &lt;source file&gt; argument specifies the filename of the plain-text file to be encrypted, and the &lt;destination file&gt; argument specifies the filename of the cipher-text file to be created. The optional &lt;password&gt; argument specifies a password with which to encrypt the file. If no password is specified, a random session key is used to encrypt the file. This session key is then encrypted with the key exchange public key of the default user and stored with the encrypted file. In this case, the corresponding key exchange private key is later used (by /DECRYPT) to decrypt the session key, which is used in turn to decrypt the file itself.</p>
<p>
The /DECRYPT switch is run from the command line as follows:</p>
<pre><code>Encrypt /decrypt &lt;source file&gt; &lt;destination file&gt; [ &lt;password&gt; ]
</code></pre>
<p>
The &lt;source file&gt; argument specifies the filename of the cipher-text file to be decrypted, and the &lt;destination file&gt; argument specifies the filename of the plain-text file to be created. The optional &lt;password&gt; argument specifies a password with which to decrypt the file. If a bogus password is supplied to /DECRYPT, no error is generated. This is a great security feature because there is no way for someone trying to "break" the data to know whether or not they have done so. Only a legitimate recipient of the data can decrypt it and actually KNOW it was decrypted properly.</p>
<h3>Signing and Verifying a File</h3>
<p>
The /SIGN switch is used to sign files. Files signed with this switch can be later verified with the /VERIFY switch.</p>
<p>
Note that the /ADDUSER switch must be run prior to doing any encryption, in order to create a key container for the default user.</p>
<p>
The /SIGN switch is run from the command line as follows:</p>
<pre><code>Encrypt /sign &lt;source file&gt; &lt;signature file&gt; &lt;description&gt;
</code></pre>
<p>
The &lt;source file&gt; argument specifies the filename of the file to be signed, and the &lt;signature file&gt; argument specifies the filename of the file in which to place the signature data. The &lt;description&gt; argument specifies a textual description of the data being signed. This can consist of empty quotes ("") if no description is required. See <b>CryptSignHash</b> in the online documentation for more information on signatures and description strings.</p>
<p>
The /VERIFY switch is run with the same arguments as /SIGN. If the contents of the source file, signature file, or description string have changed in any way from when the file was originally signed, an error will be reported.</p>
<h3>Showing CSP Statistics</h3>
<p>
The /CSP switch lists the algorithms supported by the default PROV_RSA_FULL provider. By default, this will be the Microsoft RSA Base Provider, which is included along with the operating system.</p>
<p>
Note that the /ADDUSER switch must be run prior to doing any encryption, in order to create a key container for the default user.</p>
<p>
The /CSP switch is run from the command line as follows:</p>
<pre><code>Encrypt /csp
</code></pre>
<p>
In addition to listing the name of each supported algorithm, this switch also lists:
<ul type=disc>
<li>
The type of algorithm (encryption, hash, key exchange, or signature).<br><br></li>
<li>
The key length used by the algorithm (or number of bits in the hash value for hash algorithms). </li>
</ul>
<p>
The algorithm identifier for the algorithm. This value can be passed to the appropriate Cryptography API function in order to create a key or hash object that makes use of the particular algorithm.</p>
<h2>Conclusion</h2>
<p>
This article has shown you how to encrypt and decrypt files, how to sign and verify files. The Cryptography API can be used to implement and provide a secure environment. With the strength of security that Microsoft has built into the API, I would strongly recommend that you use it for secure messaging but DON'T ever forget the password you used to encrypt your data. If you do, there is no way to get it back. In a future article I will show you how to encrypt data and publicly transmit it over the Internet or any other form of communication. Until then, have fun "keeping a secret!"</p>
</BODY>
</HTML>
