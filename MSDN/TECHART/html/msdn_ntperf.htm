<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Instrumenting Windows NT Applications with Performance Monitor</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_ntperf"></a>Instrumenting Windows NT Applications with Performance Monitor</h1>
<p>
Steven Pratschner, <br>
Microsoft Consulting Services</p>
<p>
September 30, 1997 </p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5181">
</OBJECT><a href="javascript:sample1.Click()">Click to copy the ExtCounters sample files for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5182">
</OBJECT><a href="javascript:sample2.Click()">Click to copy the FinSrv sample files for this technical article.</a></p>
<p>
<OBJECT id=sample3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5183">
</OBJECT><a href="javascript:sample3.Click()">Click to copy the RegPctrs sample files for this technical article.</a></p>
<h2>Introduction</h2>
<p>
Many applications, especially server applications, are increasing in complexity, often to the point where they are difficult to understand and to manage. To aid in analyzing complex applications, the Windows NT® Performance Monitor provides a general, customizable mechanism to view various counters and other metrics within a running application. This article describes a set of COM interfaces, C++ code, and utility components that make it easy for the developer to add customized counters to Performance Monitor. This article begins by briefly describing the complexities of the native Performance Monitor interface, introduces some new COM interfaces, macros and utilities, and finally leads the reader through an example where we add several counters to a program.</p>
<h3>The Benefits of Instrumenting Your Application</h3>
<p>
There are two primary benefits to using Performance Monitor to instrument an application. First, Performance Monitor can be used to tune an application. Second, a developer can use custom performance monitor counters to diagnose problems, thereby producing a higher quality application.</p>
<p>
Performance Monitor displays data in terms of objects and counters. Objects included with Windows NT include Process and Memory. Counters for the Process object include the number of running threads and the process's CPU utilization. An application integrates with Performance Monitor by providing objects and counters that are specific to the application. Because the counters are application-specific, they can be used to monitor virtually any aspect of a running application. A common use of custom performance monitor counters is to track the amount of resources used by an application. Information gathered through the custom counters can then be used to tune the application. For example, counters can be used to monitor the number of users contending for a shared resource within the application. By viewing the counter data using Performance Monitor, a developer can determine when access to the shared resource becomes a bottleneck in the application. At this point, the developer may choose to expand the number of resources available to the connected users.</p>
<p>
Custom Performance Monitor counters can also used to aid in debugging. Counters can be used to track conditions in the application without having to run the application under a debugger or add case-specific tracking code. For example, a common problem encountered when developing COM applications is object reference counting. Too many reference counts results in a COM object staying in memory longer than it should while too few reference counts results in objects being destroyed prematurely. Custom counters can be used to diagnose these situations. Counters can be added that track outstanding object references within a COM server. By watching the reference counts through Performance Monitor, a developer can identify portions of the application that include reference counting problems. </p>
<p>
Using Performance Monitor as an additional tuning and debugging tool helps you build better quality applications. As a result, these applications will have a substantially lower total cost of ownership (TCO) in the long run.</p>
<h4>Custom counter example</h4>
<p>
Microsoft® SQL Server™ is an excellent example of an application that makes extensive use of custom Performance Monitor counters. SQL Server provides several objects and counters that can be used by administrators and developers to tune the server. For example, counters can be used to determine the number and types of locks held on tables, the number of connections to the server, and the effectiveness of the procedure cache. Figure 1 shows some of the counters for the SQLServer-Locks object.</p>
<p>
<img src="ntperf1.gif" border=0></p>
<p class=label>
<b>Figure 1.</b></p>
<h2>Adding Custom Performance Monitor Counters</h2>
<p>
The Windows NT Performance Monitor provides facilities that allow applications to add custom performance counters. Performance Monitor displays these counters in the same way that it displays the counters provided by the operating system. </p>
<p>
Much of the work required to implement custom counters is the same for all applications. This article describes a set of COM interfaces, C++ classes, and utility components that provide the code that is common to all applications. This leaves the developer to concentrate on counter design and on the specifics of gathering the counter data.</p>
<p>
Adding custom counters requires several steps. This section describes those steps, provides a brief overview of the performance monitor interface, and then describes the framework we've developed for making the process of adding custom counters easier.</p>
<h3>The Native Performance Monitor Interface</h3>
<p>
When adding custom performance monitor counters, a developer must first determine what aspects of the application to measure. For example, a multiuser NT Server application may want to monitor how many users are connected to the application. After the counters are designed, the following steps must be followed to display the counters using performance monitor:
<ol>
<li>
Add the required registry entries.<br><br></li>
<li>
Implement a Performance DLL.<br><br></li>
<li>
Develop a means for the Performance DLL and the application to communicate.<br><br></li>
<li>
Modify the application to collect the data.</li>
</ol>
<p>
These steps are described in detail in the following sections. Figure 2 shows the architecture of Performance Monitor with respect to custom application counters.</p>
<p>
<img src="ntperf2.gif" border=0></p>
<p class=label>
<b>Figure 2.</b></p>
<h4>Required Registry Entries</h4>
<p>
Performance Monitor uses the registry to determine which applications provide custom counters. Those applications that provide custom counters include a Performance key under their application key. Figure 3 shows the Performance key for Microsoft SQL Server. This key is located in HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MSSQLServer.</p>
<p>
<img src="ntperf3.gif" border=0></p>
<p class=label>
<b>Figure 3.</b></p>
<p>
The names and descriptions of each application's custom counters are also stored in the registry. The list of all available counters is found under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib. Performance monitor uses this information to display a list of available counters in its user interface. Developers use a tool called <b>lodctr</b> to add counter names and descriptions to the registry. The input to <b>lodctr</b> is an .ini file that provides the name and help text for each custom counter supported by the application. A sample .ini file is provided in Figure 4.</p>
<pre><code>[info]
drivername=FINSERVER
symbolfile=FinPerf.h
[languages]
009=English
[text]
FINSERVEROBJ_009_NAME=FinancialServer
FINSERVEROBJ_009_HELP=The top level FinServer object.
ACTIVESESSIONS_009_NAME=Active Users
ACTIVESESSIONS_009_HELP=The number of active users connected to the server.
MODULELOCKS_009_NAME=Module Locks
MODULELOCKS_009_HELP=The number of DCOM object locks in the FinServer.
OPENDBCONNECTS_009_NAME=Open ODBC connections
OPENDBCONNECTS_009_HELP=The number of open ODBC connections in the FinServer.
</code></pre>
<p class=label>
<b>Figure 4.</b></p>
<p>
In addition to the entries made, <b>lodctr</b> also edits the application's Performance key to add values used by the Performance DLL during the collection process. </p>
<h4>Implementing a Performance DLL</h4>
<p>
Each application that supplies custom counters must provide a Performance DLL. Performance Monitor calls exported functions of this DLL during the data collection process. The name and location of this DLL are kept in the registry under the application's Performance key (Figure 3).</p>
<p>
Each Performance DLL must export three functions. These functions are called to initialize the Performance DLL, collect counter values from it, and perform cleanup tasks before unloading it. The names of these functions can vary and are specified in the <i>Open</i>, <i>Close,</i> and <i>Collect</i> values under the application's Performance key in the registry (Figure 3).</p>
<h3>Open</h3>
<p>
The <b>Open</b> function is called when the user selects "Add to Chart" from the "Edit" menu (or selects the + sign on the toolbar) in Performance Monitor. The primary purpose of the Open function is to give the Performance DLL a chance to perform initialization tasks before the data collection process begins.</p>
<p>
Typical tasks that are performed in the <b>Open</b> function include establishing a communication mechanism with the application being monitored, reading counter indexes from the registry, and initializing the data structures that will be used in the collection process.</p>
<h3>Collect</h3>
<p>
The <b>Collect</b> function is called each time Performance Monitor needs to obtain updated counter values. A Performance DLL returns counter values to Performance Monitor by initializing a number of data structures that define the characteristics of the counters and their current values. These structures are placed in memory supplied by Performance Monitor. The structures used in the collection process are defined in the winperf.h header file. The layout of these structures in memory is shown in Figure 5. The primary data structures from winperf.h are described briefly below.</p>
<p>
<img src="ntperf5.gif" border=0></p>
<p class=label>
<b>Figure 5.</b></p>
<p>
<b>PERF_OBJECT_TYPE</b></p>
<p>
This structure defines a Performance Monitor object. Examples of objects supplied by Windows NT are Processor, Memory, and Cache.</p>
<p>
<b>PERF_COUNTER_DEFINITION</b></p>
<p>
The characteristics of a custom counter are specified in the PERF_COUNTER_DEFINITION structure. Information in this structure includes the data type of the counter, its size, and its default scale.</p>
<p>
<b>PERF_COUNTER_BLOCK</b></p>
<p>
The PERF_COUNTER_BLOCK structure marks the beginning of the actual counter values. The only field in this structure is a size field that specifies the amount of memory taken up by all of the counter values.</p>
<h3>Close</h3>
<p>
The <b>Close</b> function is called when Performance Monitor exits. The <b>Close</b> function gives the Performance DLL a chance to perform cleanup tasks. These typically include closing the communication mechanism with the application and freeing any data structures allocated during the collection process.</p>
<h4>Communicating with the application </h4>
<p>
Because the Performance DLL is loaded in the Performance Monitor address space, an inter-process communication mechanism must be established between the Performance DLL and the application being monitored. Typically the communication mechanism is initialized in the Performance DLL's <b>Open</b> function and used in the <b>Collect</b> function to retrieve the counter values from the application.</p>
<p>
Any of the available Win32 inter-process communication mechanisms can be used. These include memory-mapped files, named pipes, and COM interface calls. Performance Monitor does not define a standard communication mechanism between Performance DLLs and applications. It is up to the developer to implement a communication scheme for each application that supports custom counters.</p>
<h4>Collecting the performance data</h4>
<p>
The final step in implementing custom performance counters is to collect the performance data itself. The application must keep track of the data values for each of its counters and give the values to the Performance DLL on demand. The method used to transfer the values depends on the communication mechanism chosen in the previous step.</p>
<h3>Using COM Interfaces to Implement Custom Application Counters</h3>
<p>
As can be seen from the previous section, adding custom performance monitor counters to an application is a complex process. In addition, much of the code required to add the counters is the same for all applications. The components described in this article make it significantly easier to add custom performance monitor counters to an application. </p>
<p>
Much of the code that is common to all applications is supplied in a generic Performance DLL and a registration component. COM interfaces have been designed that provide a higher level interface than the native Performance Monitor API. Instead of calling the Performance Monitor API directly, the developer implements a set of components that support the COM interfaces described in this article. The required registry entries are made by calling a registration component during application initialization. The developer is left to concentrate on counter design and on the specifics of gathering the counter data.</p>
<p>
This section describes how these components are used and how they fit into the Performance Monitor architecture (see Figure 6).</p>
<p>
<img src="ntperf6.gif" border=0></p>
<p class=label>
<b>Figure 6.</b></p>
<h3>Custom Counter COM Interfaces</h3>
<p>
This section describes the COM interfaces that have been designed to provide a higher level interface than the native Performance Monitor API. These interfaces are <i>IPerfmonObject</i> and <i>IPerfmonCounter</i>. Any application that supports custom counters must supply a set of components that implement these interfaces. The generic Performance DLL ExtCounters (described below) calls these interfaces during the data collection process and the registration component RegPerfCounters (described below) calls these interfaces during registration.</p>
<p>
There are several advantages to using these interfaces. First, when using these interfaces, the developer does not need to be concerned with the details of the Performance Monitor API. These details include laying out the performance monitor structures in memory and defining a communication mechanism between the Performance DLL and the application. Second, because the generic Performance DLL communicates with the application through COM interfaces, the components used to collect the performance data can be written in any language. This approach makes it easier for applications written in languages like Visual Basic® to support custom performance monitor counters.</p>
<p>
The IPerfmonObject interface represents a performance monitor object. Examples of performance monitor objects included with NT are Process and Thread. SQL Server adds custom objects including SQL Server-Procedure Cache and SQL Server-Log. In the approach presented in this document, each application exposes a Performance Monitor object.</p>
<p>
The IPerfmonCounter interface represents a custom performance monitor counter. These counters hold the data values being monitored within the application. Examples of counters from the NT Process object include Thread Count and Handle Count. A Performance Monitor object can have any number of counters.</p>
<p>
We have also provided a set of C++ classes and macros to make it easy to build components that expose the interfaces described above. The classes <i>IPerfmonObjectImpl</i> and <i>IPerfmonCounterImpl</i> provide default implementations for each member of IPerformObject and IPerfmonCounter. These classes are described later in the document.</p>
<p>
The following sections provide explanations for each member of IPerfmonObject and IPerfmonCounter. As described above, the default implementations provide by <i>IPerfmonObjectImpl</i> and <i>IPerfmonCounterImpl</i> are generally sufficient.</p>
<h4>IPerfMonObject</h4>
<p>
Each application implements one component that exposes this interface. This component is referred to as the application's collection component throughout this document. The collection component represents the application's performance monitor object. This interface provides the top-level connection to the Performance DLL. The definition of IPerfmonObject is:</p>
<pre><code>interface IPerfmonObject : IDispatch
{
 &nbsp; HRESULT GetName([out, retval] BSTR *pName);
 &nbsp; HRESULT GetHelp([out, retval] BSTR *pHelp);
 &nbsp; HRESULT GetIndex([out, retval] long *pIndex);
 &nbsp; HRESULT GetNumCounters([out, retval] long *pNumCounters);
 &nbsp; HRESULT GetCounters([out, retval] IUnknown **pCounters);
};
</code></pre>
<p class=label>
<b>Figure 7.</b></p>
<h3>GetName </h3>
<p>
Returns the name of the Performance Monitor object. This name is added to the list of Performance Monitor objects in the registry during the registration process. The name is then displayed in the "Object" dropdown on the "Add To Chart" dialog box in the Performance Monitor user interface (Figure 8). </p>
<h3>GetHelp</h3>
<p>
Returns the help text for the Performance Monitor object. Like the name, an object's help text is entered in the registry and displayed in the Performance Monitor user interface. The help text is shown when the user chooses the "Explain" button in the "Add To Chart" dialog (Figure 8).</p>
<p>
<img src="ntperf8.gif" border=0></p>
<p class=label>
<b>Figure 8.</b></p>
<h3>GetIndex</h3>
<p>
Performance Monitor requires that each object and counter be identified by a unique index. This index is stored in the registry along with the object's name and help text. Index values are always even numbers. This method returns the index for the application's Performance Monitor object. </p>
<h3>GetNumCounters</h3>
<p>
Returns the number of custom counters for this object.</p>
<h3>GetCounters</h3>
<p>
This method returns a COM enumeration containing <i>IPerfmonCounter</i> interface pointers to each of the object's counters. </p>
<h4>IPerfmonCounter</h4>
<p>
An application implements one component that exposes this interface for each custom counter it provides.</p>
<p>
Both the ExtCounters DLL and the registration component use these interfaces to gather information about a custom counter. The definition of <i>IPerfmonCounter</i> is:</p>
<pre><code>interface IPerfmonCounter : IDispatch
{
 &nbsp; HRESULT GetName([out, retval] BSTR *pName);
 &nbsp; HRESULT GetHelp([out, retval] BSTR *pHelp);
 &nbsp; HRESULT GetIndex([out, retval] long *pIndex);
 &nbsp; HRESULT GetDataType([out, retval] short *pDataType);
 &nbsp; HRESULT Collect([out, retval] VARIANT *pVariant);
};
</code></pre>
<p class=label>
<b>Figure 9.</b></p>
<h3>GetName</h3>
<p>
Returns the name of the custom counter. As with Performance Monitor objects, the name of each counter is stored in the registry and displayed in the Performance Monitor user interface. The "Counter" list box on the "Add To Chart" dialog lists the custom counters for the select object (Figure 7).</p>
<h3>GetHelp</h3>
<p>
Returns the counter's help text. The help text is stored in the registry and displayed in the Performance Monitor user interface when a user chooses the "Explain" button (Figure 7).</p>
<h3>GetIndex</h3>
<p>
Returns the counter's unique index.</p>
<h3>GetDataType</h3>
<p>
This member returns the data type of the counter. Data types are identified using the values from the VARTYPE enumeration used in OLE Automation. For example, if the counter is a 4-byte integer, this member would return VT_I4.</p>
<h3>Collect</h3>
<p>
This member is called by the Performance DLL to collect the latest value for the custom counter. The return type of this member is VARIANT. VARIANTs are used to provide flexibility in the type of data that can be returned. The implementation of <b>Collect</b> is responsible for correctly initializing the VARIANT with the appropriate type and data values. The Performance DLL will look at the type of data in the VARIANT and extract the data before passing it onto Performance Monitor.</p>
<h4>C++ Support</h4>
<p>
We have provided two C++ classes that make it easy to implement IPerfmonObject and IPerfmonCounter. The class <i>IPerfmonObjectImpl</i> provides an implementation of IPerfmonObject and <i>IPerfmonCounterImpl</i> provides an implementation of IPerfmonCounter. The goal in providing these classes is to minimize the amount of coding required to add custom performance monitor counters to an application. These classes are designed to fit easily into projects that implement COM components using ATL.</p>
<h3>IPerfmonObjectImpl</h3>
<p>
<i>IPerfmonObjectImpl</i> provides a default implementation of the IPerfmonObject interface. This class fits into the ATL class hierarchy that is used to build COM components. <i>IPerfmonObjectImpl</i> uses ATL's concept of a map to allow developers to easily specify the custom counters for their application. Typically, a developer will derive a class from <i>IPerfmonObjectImpl</i> and specify a map that describes the custom counters. Figure 10 provides an example of a class derived from <i>IPerfmonObjectImpl</i>. The sections of code that relate to <i>IPerfmonObjectImpl</i> are shown in bold.</p>
<pre><code>class CMySrvCounters : 
 &nbsp; public CComObjectRootEx&lt;CComMultiThreadModel&gt;,
 &nbsp; public CComCoClass&lt;CMySrvCounters, &amp;CLSID_CMySrvCounters&gt;,
 &nbsp; <b>public IPerfmonObjectImpl&lt;&amp;LIBID_MYSRVSERVERLib&gt;</b>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_MYSRVCOUNTERS)
BEGIN_COM_MAP(CMySrvCounters)
 &nbsp; COM_INTERFACE_ENTRY(IPerfmonObject)
 &nbsp; COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()
<b>BEGIN_COUNTER_MAP(IPerfmonCounterImpl)</b>
<b>COUNTER_ENTRY_LONG("Number of Users",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "The number of users connected to the application",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;m_numUsers)</b>
<b>COUNTER_ENTRY_LONG_FUNC("Number of ODBC Connections",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "The number of ODBC connections the application has open",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetNumODBCConnections)</b>
<b>END_COUNTER_MAP()</b>
};
</code></pre>
<p class=label>
<b>Figure 10.</b></p>
<p>
This class uses a counter map to implement two custom performance counters. The counter map works like ATL's COM map. Specifying the map will be very familiar to ATL programmers following ATL's style. The counter map begins and ends with the BEGIN_COUNTER_MAP() and END_COUNTER_MAP() entries respectively. BEGIN_COUNTER_MAP() has a parameter that specifies the type of object to create to represent a counter. Typically, this parameter will be <i>IPerfmonCounterImpl</i>. This is described in more detail in the following section.</p>
<p>
We have provided two macros for specifying the custom counters themselves. Using these macros, a developer can add a custom counter with very little coding. COUNTER_ENTRY_LONG() is used to specify a counter whose latest value is always kept in a variable. If more flexibility is needed, COUNTER_ENTRY_LONG_FUNC() can be used to specify a function that can be called to retrieve the latest counter value. The developer is responsible for implementing this function. This function will be called each time Performance Monitor asks for the latest counter values.</p>
<p>
There are obviously several other macros that could be written to specify counters. These macros could include support for other data types and different methods of accessing counter data.</p>
<h3>IPerfmonCounterImpl</h3>
<p>
Instances of <i>IPerfmonCounterImpl</i> are constructed by the application's instance of <i>IPerfmonObjectImpl</i>. These instances are released by the ExtCounters Performance DLL. When ExtCounters calls <b>IPerfmonObject::GetCounters</b>, the instance of <i>IPerfmonObjectImpl</i> uses the information in the counter map to properly construct the appropriate number of instances of <i>IPerfmonCounterImpl</i>. </p>
<p>
<i>IPerfmonCounterImpl</i> shouldn't have to be derived from if the developer uses the default implementation provided by <i>IPerfmonObjectImpl</i>. However, BEGIN_COUNTER_MAP() is parameterized to allow flexibility in situations where developers want to use an implementation of IPerfmonCounter other than the one provided by <i>IPerfmonCounterImpl</i>.</p>
<h3>The Registration Component</h3>
<p>
The registration component (<i>RegPerfCounters</i>) is used to write all the data to the registry that is needed for an application to support custom performance counters. This data includes the application's Performance key and the object and counter values typically done using the <b>lodctr</b> utility.</p>
<p>
Registration is done using a COM interface called <i>IRegisterPerfmonObject</i> that is exposed by the RegPerfCounters component. This interface is described below. Because registration is done through a COM interface, the registration component can be called from any language, including Visual Basic.</p>
<p>
As mentioned previously, each application supplies one component that exposes the IPerfmonObject interface. RegPerfCounters uses this collection component to collect the data needed during registration. </p>
<p>
RegPerfCounters creates an instance of the application's collection component and calls the GetName and GetHelp members of <i>IPerfmonObject</i> and <i>IPerfmonCounter</i> when adding the counter data to the registry.</p>
<p>
Typically the calls to the registration component are made either during application startup or when the application is performing self-registration. A typical COM server will register its components when the application is started with the –RegServer parameter. This is an excellent opportunity to register the performance monitor counter information as well. Another common scenario is to register the counter information from the application's setup program.</p>
<h4>&nbsp;IRegisterPerfmonObject</h4>
<p>
The definition of <i>IRegisterPerfmonObject</i> is:</p>
<pre><code>interface IRegisterPerfmonObject : IDispatch
{
 &nbsp; HRESULT Register([in]BSTR appName, [in]BSTR collectionGUID);
 &nbsp; HRESULT Unregister([in]BSTR appName);
};
</code></pre>
<p class=label>
<b>Figure 11.</b></p>
<h3>Register</h3>
<p>
This method registers all data needed to support custom performance monitor counters. As mentioned previously, this method creates an instance of the application's collection component to gather the data needed during registration. The parameter "collectionGUID" provides the CLSID of the application's collection component.</p>
<h3>UnRegister</h3>
<p>
This method removes the application's Performance Monitor object and counter values.</p>
<h4>C++ utilities</h4>
<p>
We have provided two C++ utility functions to make it easier to call the registration component. These functions hide of details of creating and calling the RegPerfCounters COM component. These functions are:</p>
<pre><code>bool RegisterPerformanceCounters(LPCTSTR pAppName, CLSID collectionGUID);
bool UnRegisterPerformanceCounters(LPCTSTR pAppName);
</code></pre>
<p class=label>
<b>Figure 12.</b></p>
<p>
As their names suggest, the first function is used to register the counters and the second function is used to remove them from the registry.</p>
<h3>The ExtCounters DLL</h3>
<p>
The ExtCounters DLL is a generic Performance DLL that can be used by any application. ExtCounters collects performance data from the application's collection component and formats it for use by Performance Monitor. ExtCounters implements the details of interacting with Performance Monitor so the application's collection component can focus on collecting performance data.</p>
<p>
ExtCounters uses COM to communicate with the application being monitored. The use of COM as a communication mechanism has two advantages. First, it allows interfaces to be defined independent of the applications being monitored. Second, it facilitates performance monitoring with applications written in any language that supports the creation of COM components.</p>
<p>
The ExtCounters DLL identifies an application's collection component through registry settings. When Performance Monitor calls the DLLs <b>Open</b> function, it passes the value of the Export value under the application's Linkage key. For the application MyServer, this key would be HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MyServer\Linkage. The Export value is set to the application name during registration by the RegPerfCounters utility. Given the application name, ExtCounters reads the value of the CollectionComponent value under the application's Performance key to find the CLSID of the collection component. Figure 13 shows a Performance key with the CollectionComponent value.</p>
<p>
<img src="ntperf13.gif" border=0></p>
<p class=label>
<b>Figure 13.</b></p>
<p>
In the <b>Open</b> function, ExtCounters uses this CLSID to create an instance of the collection component and obtain its <i>IPerfmonObject</i> and <i>IPerfmonCounter</i> interfaces. These interfaces are used to gather information about the application's counters and build the appropriate Performance Monitor data structures. In addition, when Performance Monitor calls the <b>Collect</b> function in ExtCounters, the DLL calls <b>IPerfmonCounter::Collect</b> on each counter to retrieve the latest counter data. In addition to the <i>CollectionComponent</i> values, several other values under the application's Performance key are used during the collection process (see Figure 13). These include:</p>
<p>
<i>Close</i></p>
<p>
This registry value is the name of the Performance DLL's <b>Close</b> function. For ExtCounters, this is always <i>CloseExtPerfData</i>.</p>
<p>
<i>Collect</i></p>
<p>
The <i>Collect</i> value holds the name of the Performance DLL's <b>Collect</b> function. For ExtCounters, this is always <i>CollectExtPerfData.</i></p>
<p>
<i>First Counter, First Help, Last Counter, Last Help</i></p>
<p>
These values contain offset information used by Performance Monitor. Indexes must be assigned for each application that provides custom objects and counters. An application assigns these starting at 0. These registry values represent the offset of a particular application's counters in Performance Monitors master list of counters. These values are written by the registration component described above. The registration component uses the <b>lodctr</b> utility to write these values.</p>
<p>
<i>Library</i></p>
<p>
The Library value contains the name of the application's Performance DLL. When adding custom counters as described in this paper, this value will always be ExtCounters. Note that the Performance DLL must be in the path.</p>
<p>
<i>Open</i></p>
<p>
This registry value is the name of the Performance DLL's <b>Open</b><i> </i>function. For ExtCounters, this is always <i>OpenExtPerfData</i>.</p>
<h2>Example: Implementing Performance Counters</h2>
<p>
This section uses an example to illustrate how to implement performance counters in an application. Our sample application is a COM server called the Financial Server. The Financial Server allows users to connect to it and perform various financial calculations. The Financial Server is accessed via DCOM from a Visual Basic client and uses SQL Server as a data store. The COM components are built using ATL and data access is done through ODBC. The high-level architecture is shown in Figure 14.</p>
<p>
<img src="ntperf14.gif" border=0></p>
<p class=label>
<b>Figure 14.</b></p>
<h3>Step 1. Design Your Counters</h3>
<p>
The first step in adding counters to an application is to determine what to measure. The Financial Server application includes counters that can be used for both tuning and debugging the application. The custom counters in the Financial Server are:</p>
<p>
<b>Active Users.</b> This counter tracks the number of users that are currently connected to the Financial Server.</p>
<p>
<b>ODBC Connections.</b> This counter tracks the number of open ODBC connections in the server.</p>
<p>
<b>Module Locks.</b> Because the Financial Server contains COM components, tracking the number of outstanding locks on the server can help debug reference counting problems. </p>
<p>
<b>Queued Events.</b> The Financial Server uses COM's connection point interfaces to send events to the Visual Basic clients. These events are queued in the server and sent in the order they are placed on the queue. The Queued Events counter tracks the number of events in the queue.</p>
<h3>Step 2. Add the Counters to Your Code</h3>
<p>
After the counters have been defined, code must be added to the application to expose the IPerfmonObject and IPerfmonCounter interfaces. First, the IDL source for IPerfmonObject and IPerfmonCounter must be included in the project's IDL file. Second, the <i>IPerfmonObjectImpl</i> and <i>IPerfmonCounterImpl</i> classes can be used to provide implementations of the required interfaces.</p>
<h4>Include IDL source</h4>
<p>
We have provided an IDL source file (PerfCounters.idl) that includes the definitions of IPerfmonObject and IPerfmonCounter. This file must be included in the project's IDL file as shown in Figure 15.</p>
<pre><code>//
// Application's interfaces described here
//
…
…
<b>#include "PerfCounters.idl"</b>
//
// The rest of the application's idl source defined below
//
[
 &nbsp; uuid(DA321ED4-79EA-11D0-8A16-400004491007),
 &nbsp; version(1.0),
 &nbsp; helpstring("FinServ 1.0 Type Library")
]
library FINSERVLib
{
…
…
};
</code></pre>
<p class=label>
<b>Figure 15.</b></p>
<h4>Implement a class derived from <i>IPerfmonObjectImpl</i></h4>
<p>
Each application that supports custom counters must provide one COM component that implements the IPerfmonObject interface. This component is used during both the data collection process and the registration process. As described above, the class <i>IPerfmonObjectImpl</i> makes it easy to write a component that exposes IPerfmonObject. To use <i>IPerfmonObjectImpl</i>, a developer derives from the class and provides a counter map. See the earlier section on C++ support for a detailed description of <i>IPerfmonObjectImpl</i>. Figure 16 below shows how <i>IPerfmonObjectImpl</i> is used in the Financial Server.</p>
<pre><code>class ATL_NO_VTABLE CFinServCounters : 
 &nbsp; public CComObjectRootEx&lt;CComMultiThreadModel&gt;,
 &nbsp; public CComCoClass&lt; CFinServCounters, &amp;CLSID_CFinServCounters&gt;,
 &nbsp; public ISupportErrorInfo,
<b> &nbsp; public IPerfmonObjectImpl&lt;&amp;LIBID_FinServLib&gt;</b>
{
public:
 &nbsp; CFinServCounters () { }
 &nbsp; virtual ~ CFinServCounters () {}
DECLARE_REGISTRY_RESOURCEID(IDR_FINSERVCOUNTERS)
BEGIN_COM_MAP(CFinServCounters)
 &nbsp; COM_INTERFACE_ENTRY(IPerfmonObject)
 &nbsp; COM_INTERFACE_ENTRY(IDispatch)
 &nbsp; COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
<b>BEGIN_COUNTER_MAP(IPerfmonCounterImpl)</b>
<b> &nbsp; COUNTER_ENTRY_LONG("Active Users Users",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "The number of users connected to the Financial Server",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;CFinServCounters::m_numUsers)</b>
<b> &nbsp; COUNTER_ENTRY_LONG_FUNC("ODBC Connections",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "The number of ODBC connections the Financial Server has open",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CFinServCounters::GetOpenDBConnections)</b>
<b> &nbsp; COUNTER_ENTRY_LONG_FUNC("Module Locks",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "The number of outstanding reference counts held on the Financial Server ",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CFinServCounters::GetModuleLocks)</b>
<b> &nbsp; COUNTER_ENTRY_LONG("Queued Events",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "The number of events waiting to be send fromthe Financial Server",</b>
<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;CFinServCounters::m_queuedEvents)</b>
<b>END_COUNTER_MAP()</b>
// ISupportsErrorInfo
 &nbsp; STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
static long m_numUsers;
static long m_queuedEvents;
static void GetOpenDBConnections(long&amp; numDBConnections);
static void GetModuleLocks(long&amp; numLocks);
};
</code></pre>
<p class=label>
<b>Figure 16.</b></p>
<h4>Providing custom counters using Visual Basic</h4>
<p>
Both the Performance DLL (ExtCounters) and the Registration DLL (RegPerfCounters) communicate with the application through COM interfaces derived from IDispatch. As a result, the components that implement IPerfmonObject and IPerfmonCounter can be written in a variety of languages including Visual Basic. Figure 17 shows a class that implements IPerfmonCounter in Visual Basic. </p>
<pre><code>Implements IPerfmonCounter
Dim m_numUsers As Long
Public Sub Class_IncrementNumUsers()
  m_numUsers = m_numUsers + 1
End Sub
Public Sub Class_DecrementNumUsers()
  m_numUsers = m_numUsers - 1
End Sub
Private Function IPerfmonCounter _Collect() As Variant
 CFinServPerfmonCounter _Collect = m_numUsers
End Function
Private Function IPerfmonCounter _GetDataType() As Integer
 CFinServPerfmonCounter _GetDataType = vbLong
End Function
Private Function IPerfmonCounter _GetHelp() As String
 CFinServPerfmonCounter _GetHelp = "The number of users connected to the Financial Server"
End Function
Private Function IPerfmonCounter _GetIndex() As Long
 CFinServPerfmonCounter _GetIndex = 2
End Function
Private Function IPerfmonCounter _GetName() As String
 CFinServPerfmonCounter _GetName = "Active Users"
End Function
</code></pre>
<p class=label>
<b>Figure 17.</b></p>
<h3>Step 3. Register Your Application's Counters</h3>
<p>
As described earlier, the registration component (<i>RegPerfCounters</i>) is used to write all the data to the registry that is needed for an application to support custom performance counters. Registration is done using a COM interface called <i>IRegisterPerfmonObject</i> that is exposed by the RegPerfCounters component. </p>
<p>
We have provided two C++ utility functions to simplify the process of calling the RegPerfCounters component.</p>
<p>
Registration can be done in a number of places in an application. The most common are:
<ul type=disc>
<li>
From the application's startup code<br><br></li>
<li>
Along with the other registration an application may do<br><br></li>
<li>
From the application's setup program</li>
</ul>
<p>
The Financial Server calls RegPerfCounters while performing other registration tasks including registering COM components. Registration occurs when the Financial Server executable is started with the /RegServer command line argument. The following example demonstrates the use of the C++ utilities to perform registration in the Financial Server in an ATL-generated WinMain routine.</p>
<pre><code>extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
 &nbsp; HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
…
…
 bool bSuccess = false;
 LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
 while (lpszToken != NULL)
 {
  if (lstrcmpi(lpszToken, _T("RegServer"))==0)
  {
 &nbsp; _Module.UpdateRegistryFromResource(IDR_FinancialServer, TRUE);
 &nbsp;&nbsp; bSuccess = SUCCEEDED( _Module.RegisterServer(TRUE)) &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterPerformanceCounters("FinancialServer", CLSID_CFinServCounters);
 &nbsp;&nbsp; break;
  }
  if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
  {
 &nbsp;&nbsp; _Module.UpdateRegistryFromResource(IDR_FinancialServer, FALSE);
 &nbsp;&nbsp; bSuccess = SUCCEEDED(_Module.UnregisterServer()) &amp;&amp;
<b>UnRegisterPerformanceCounters("FinancialServer");</b>
 &nbsp;&nbsp; break;
  }
  lpszToken = FindOneOf(lpszToken, szTokens);
}
…
…
</code></pre>
<p class=label>
<b>Figure 18.</b></p>
<h4>Calling RegPerfmonCounters from Visual Basic</h4>
<p>
As described above, registration is done through a COM interface based on IDispatch (IRegisterPerfmonObject). As a result, performance monitor counter registration can be done from any language that supports calling COM components. The following example shows Visual Basic code that registers counter information during application startup. In Visual Basic, the type library from the RegPerfmonCounters DLL must be referenced in the project through the Project-&gt;References dialog box before the registration component can be used.</p>
<pre><code>Private Sub Form_Load()
Dim regPerfCounters As New RegisterPerfmonObject
' Register the application's counters. The first parameter
' is the application name and the second parameter is the
' clsid of the component that implements IPerfmonObject
regPerfCounters.Register "MyServer", "DA321ED6-79EA-11D0-8A16-400004491007"

End Sub
</code></pre>
<p class=label>
<b>Figure 19.</b></p>
<h3>Step 4. Monitoring Your Application with PerfMon </h3>
<p>
The final step in adding custom counters is to make the ExtCounters DLL visible to Performance Monitor.</p>
<p>
Performance Monitor locates this by looking at the Library value in the application's Performance key. This information is added during the registration process. In order for Performance Monitor to find ExtCounters.dll it must be copied to a directory that is in the path. A common place to put ExtCounters.dll is in the System32 folder under your NT directory.</p>
<p>
Now that the collection component has been implemented, registration has been done, and ExtCounters is visible to Performance Monitor, the application's custom counters are ready to use. The counters will appear in the "Add To Chart" dialog (see Figure 8) in Performance Monitor and will show up on the charts when added.</p>
<h2>Other Performance Monitor Features</h2>
<p>
Performance Monitor has several other features that a Performance DLL can support. These features include the support for multiple objects in an application, multiple instances per object, and various data and counter types. These features can be implemented generically in the ExtCounters DLL in the same way the features described in this paper have been.</p>
<h2>Conclusion</h2>
<p>
Using Performance Monitor to tune and debug an application helps to produce a better quality application and to lower its TCO over time. An application takes advantage of Performance Monitor by supplying application-specific objects and counters that are displayed by Performance Monitor in the same way system provided objects are. Several steps and components are needed to implement custom counters using the native Performance Monitor interface. This paper describes a set of COM interfaces, C++ classes and generic components that make the process of adding custom counters much easier. Because the interface to Performance Monitor is described in terms of COM objects, the custom performance counters can be written in any language that supports the development of COM components.</p>
</BODY>
</HTML>
