<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating a Visual C++ Wizard for Single-Window MFC Applications</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_onewndwz"></a></sup>Creating a Visual C++ Wizard for Single-Window MFC Applications</h1>
<p>
Nigel Thompson</p>
<p>
April 30, 1997</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5140">
</OBJECT><a href="javascript:sample1.Click()">Click to copy the files in the ONEWNDWZ sample application for this technical article.</a></p>
<h2>Introduction</h2>
<p>
This article explains how to remove the MFC document/view architecture from an MFC AppWizard project and replace it with a single-window design. Then, using parts of that code for the template, I will show you how to create a Microsoft Visual C++® 5.0 wizard that generates single-window application frameworks quickly and easily.</p>
<h2>Removing the MFC Document/View Architecture</h2>
<p>
The standard set of application wizards built into the Visual C++ development system allows you to create a variety of applications based on the document/view architecture, but what if that’s not what you need? Your only alternative “out of the box” is to create a dialog-based application, and that’s what most folks settle for if they want to create a simple single-window application quickly.</p>
<p>
One alternative to using the dialog-based application wizard is to use the regular MFC-based application wizard to create a Single Document Interface (SDI) application, which includes support for the document/view architecture, and then remove the files that support document/view. This is how I usually create my own single-window applications, and it’s from this approach that I created the single-window wizard we’ll be looking at later. Let’s see how we go about converting an SDI application created by AppWizard to a single-window framework. Let’s assume the application is called TEST:
<ol>
<li>
From the <b>File </b>menu, select <b>New</b> and use the <b>MFC AppWizard (exe)</b> option to create a new project named TEST. Select the <b>Single Document</b> option with no database support, no compound document support, and whatever toolbar, status bar, and printing support you want.<br><br></li>
<li>
Remove the document and view source (.cpp) and header (.h) files from the project. To do this, delete these four files from the project directory: TESTdoc.cpp, TESTdoc.h, TESTview.cpp, and TESTview.h.<br><br></li>
<li>
Edit TEST.cpp to remove all references to TESTdoc.h and TESTview.h.<br><br></li>
<li>
Now edit the <b>InitInstance</b> function in the main source file. In this case, we will edit <b>CTestApp::InitInstance</b> in TEST.cpp. Replace all the code that initializes the document/view code with a small piece of code that creates the main window. The final function should look like this:<pre><code>BOOL CTestApp::InitInstance()
{
 &nbsp; AfxEnableControlContainer();

 &nbsp; // Standard initialization
 &nbsp; // If you are not using these features and wish to reduce the size
 &nbsp; // of your final executable, you should remove from the following
 &nbsp; // the specific initialization routines you do not need.

#ifdef _AFXDLL
 &nbsp; Enable3dControls();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Call this when using MFC in a shared DLL.
#else
 &nbsp; Enable3dControlsStatic();&nbsp;&nbsp; // Call this when linking to MFC statically.
#endif

 &nbsp; // Change the registry key under which our settings are stored.
 &nbsp; // You should modify this string to be something appropriate,
 &nbsp; // such as the name of your company or organization.
 &nbsp; SetRegistryKey(_T(“Local AppWizard-Generated Applications”));

 &nbsp; LoadStdProfileSettings();&nbsp; // Load standard INI file options (including MRU).

 &nbsp; // Load the main frame window.
 &nbsp; CMainFrame* pFrame = new CMainFrame;
 &nbsp; if (!pFrame-&gt;LoadFrame(IDR_MAINFRAME, WS_OVERLAPPEDWINDOW | WS_VISIBLE)) {
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; // Save the main window pointer.
 &nbsp; m_pMainWnd = pFrame;

 &nbsp; return TRUE;
}
</code></pre>
</li>
<li>
Edit mainframe.h and make the <b>CMainFrame</b> constructor public. The start of the class declaration should look like this:<pre><code>class CMainFrame : public CFrameWnd
{
public:
 &nbsp; CMainFrame();
 &nbsp; DECLARE_DYNCREATE(CMainFrame)
 &nbsp; [. . .]
</code></pre>
</li>
<li>
Rebuild all the dependencies (from the <b>Build</b> menu, select <b>Update All Dependencies</b>) and build the application to confirm that you have edited all the code correctly. <br><br></li>
<li>
Run the application, which shows a single window.</li>
</ol>
<p>
Now you can work with the <b>CMainFrame</b> window and do anything that you would normally do with a simple single-window application.</p>
<h3>Coping with Tool and Status Bars</h3>
<p>
Once you’ve got the single window framework up, you’ll quite likely want to create some child windows within the client area of the <b>CMainFrame</b> window. In order to do this successfully, you will need to manage the tool and status bars that share space with your proposed child.</p>
<p>
Let’s say that we have created a new window class named <b>CMyWindow</b> and we want to use one of these to fill the client area of the <b>CMainFrame</b> window. We add a <b>CMyWindow</b> object to the protected data section of the <b>CMainFrame</b> class declaration in mainframe.h, as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CMyWindow m_MyWnd;
</code></pre>
<p>
Add the following code to the end of <b>CMainFrame::OnCreate</b> to create the child window:</p>
<pre><code>&nbsp;&nbsp;&nbsp;#define MY_CHILD_ID 1

 &nbsp; // Create the child window.
 &nbsp; m_MyWnd.Create(NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; “”,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_CHILD | WS_VISIBLE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRect(0, 0, 0, 0),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MY_CHILD_ID, // Child window ID
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);

</code></pre>
<p>
Now use the ClassWizard to add a <b>RecalcLayout</b> function to <b>CMainFrame</b>. Edit the code so that it looks like this:</p>
<pre><code>void CMainFrame::RecalcLayout(BOOL bNotify) 
{
 &nbsp; CFrameWnd::RecalcLayout(bNotify);

 &nbsp; // Find the space that’s left over.
 &nbsp; CRect rc;
 &nbsp; RepositionBars(0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xFFFF,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MY_CHILD_ID, // Child window ID
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWnd::reposQuery,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;rc);
 &nbsp; if (IsWindow(m_MyWnd.GetSafeHwnd())) {
 &nbsp;&nbsp;&nbsp;&nbsp; m_MyWnd.MoveWindow(&amp;rc, FALSE);
 &nbsp; }
}
</code></pre>
<p>
Now, when the <b>CMainFrame</b> window is resized, the control bars will be moved into new positions and your child window will be resized to fit into the remaining space. Note that when you create the child window you need to assign it an ID value, and it is this ID value that’s used to identify your child window in the call to the <b>RepositionBars</b> function.</p>
<h2>A Wizard to Create Single-Window Applications</h2>
<p>
I had resisted attempting to create my own wizards for Visual C++ for some time because I always felt that the process of creating a wizard was far more complex than the effort it took to create my own application frameworks. However, after creating a single-window framework for the umpteenth time, I decided that a wizard might well be worth the work after all.</p>
<p>
You can create wizards in several ways. The simplest is to create one based on a framework that an AppWizard has generated. Then you can either alter the options slightly, or you can do your own thing for a full-blown custom design. I figured the pain would be worth it and decided I wanted a custom design for my wizard. </p>
<p>
The process of creating a custom application wizard is well documented in the Visual C++ documents, so I’ll just briefly cover the order of events and then show you some of the details of the files I ended up with in my own wizard. That should be enough for you to do your own thing. Just one warning—my wizard is trivial beyond belief. Your own design might well require a little more work!
<ol>
<li>
Use the Custom AppWizard to create a new project. I named mine OneWndWz, and I elected to use my own custom steps and to have just one step initially.<br><br></li>
<li>
Build the framework to ensure it’s okay before you start altering it.<br><br></li>
<li>
Copy all the source files from the application that you want the wizard to create to the wizard project’s template directory. (For example, I might copy test.cpp, test.h, mainframe.cpp, mainframe.h, and so on. Don’t forget that all the resource files go into the same directory—not a res subdirectory.)<br><br></li>
<li>
Edit the newproj.inf file so that it will copy the files for the newly generated application framework to the correct places. This is well documented in Visual C++. My own file looks like this:<pre><code>$$// newproj.inf = template for list of template files
$$//&nbsp; format is ‘sourceResName’ \t ‘destFileName’
$$//&nbsp;&nbsp;&nbsp; The source res name may be preceded by any combination of
$$//&nbsp;&nbsp;&nbsp; ‘=’, ‘-’,&nbsp; ‘!’, ‘?’, ‘:’, ‘#’, and/or ‘*’
$$//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘=’ =&gt; The resource is binary.
$$//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘-’ =&gt; The file should not be added to the project.
$$//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘!’ =&gt; The file should be marked exclude from build.
$$//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘?’ =&gt; The file should be treated as a help file.
$$//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘:’ =&gt; The file should be treated as a resource.
$$//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘#’ =&gt; The file should be treated as a template (implies ‘!’).
$$//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘*’ =&gt; Bypass the custom AppWizard resources when loading.
$$//&nbsp;&nbsp; If name starts with / =&gt;, then create a new subdir.

mainfrm.cpp&nbsp;&nbsp; mainfrm.cpp
mainfrm.h&nbsp;&nbsp; mainfrm.h
resource.h&nbsp;&nbsp; resource.h
stdafx.cpp&nbsp;&nbsp; stdafx.cpp
stdafx.h&nbsp;&nbsp; stdafx.h
tbasic.cpp&nbsp;&nbsp; $$root$$.cpp
tbasic.h&nbsp;&nbsp; $$root$$.h
tbasic.rc&nbsp;&nbsp; $$root$$.rc
/res
=tbasic.ico&nbsp;&nbsp; res\$$root$$.ico
tbasic.rc2&nbsp;&nbsp; res\$$root$$.rc2
</code></pre>
</li>
<li>
Add the files as template resources. Note that you need to be sure to import .ico files and other binary files as custom rather than auto. For each one imported, set its ID value to its name in quotes, for example “mainfrm.cpp”.<br><br></li>
<li>
Edit the source files and replace project-specific text with macros. In the single-window wizard case, I simply replace the application name with the <b>$$root$$</b> macro. So, for example, part of the mainframe.cpp file looks like this:<pre><code>// MainFrm.cpp : implementation of the CMainFrame class

#include “stdafx.h”
#include “$$root$$.h”

#include “MainFrm.h”
[. . .]
</code></pre>
</li>
<li>
Edit the custom dialog template. OneWndWz requires very little here because it has no options.<br><br></li>
<li>
Edit the confirm.inf file, which gives the user details about the project he or she is creating. My file contains only the following two lines of text:<pre><code>The wizard will create a project named $$root$$.
</code></pre>
<p class=tl>
There are no options.</P></li>
<li>
Edit the Help file and provide whatever help you think the user might need.</li>
</ol>
<p>
If you add options to your wizard, you’ll need to use more macros and some of the conditional statements that are explained in the Visual C++ documentation.</p>
<h3>Installation</h3>
<p>
During development of a wizard, Visual C++ automatically copies the wizard files to the right place for you. If you need to install a wizard manually, you must copy the .awx and .hlp files to the SharedIDE\Template directory of your Visual C++ installation. The full default path to the directory is C:\Program Files\DevStudio\SharedIDE\Template.</p>
<h2>Summary</h2>
<p>
Removing the MFC document/view architecture to leave a single-window framework is fairly easy to do, requiring only the removal of some files and a few code alterations. Creating a custom wizard is a bit more work, but will make it trivial to create as many single-window applications as you might need.</p>
<p>
As usual, you can contact me with questions about this or any other topic by e-mail at <a href="mailto:nigel-t@msn.com">nigel-t@msn.com</a>. You can also read some of my other work on my Web site at <a href="http://ourworld.compuserve.com/homepages/nigelt/">http://ourworld.compuserve.com/homepages/nigelt/</a>.</p>
</BODY>
</HTML>
