<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OpenGL I: Quick Start</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_gl1"></a></sup>OpenGL I: Quick Start</h1>
<p>
Dale Rogerson</p>
<p>
Microsoft Developer Network Technology Group</p>
<p>
December 1, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3194">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the GLEasy sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes GLEasy, a simple OpenGL™ program. OpenGL is a three-dimensional (3-D) graphics library included with the Microsoft® Windows NT™ version 3.5 operating system. GLEasy is a Microsoft Foundation Class Library (MFC) application that provides a good starting point for investigations into the Windows NT implementation of OpenGL.</p>
<h2>Introduction</h2>
<p>
There are several methods for teaching something. Take swimming, for example. My Uncle Ulysses had a favorite method for teaching his small young nephews how to swim. This highly sophisticated method of aquatic instruction consisted of tossing one of the aforementioned nephews off the wooden dock and into the ol' fish pond. Uncle U was a big, burly man and could toss a nephew pretty darn far. Unfortunately, I grew up in a different state and had to learn how to swim through a less scientific method of instruction taught by the local YMCA.</p>
<p>
Well, Uncle U recently passed on, and in honor of his success in reducing the number of relatives at family reunions, I decided to teach someone something using Uncle U's proven method. The someone is you, and the something is OpenGL™. I'm going to throw you into an OpenGL program. I'll scream some pointers at you from the dock as we go through this program.</p>
<p>
In other words, this article focuses on <i>what</i> you have to do, not <i>why</i> you have to do it. The bibliography provides a list of references that offer information on the "why." This article will teach you how to set up an OpenGL program, so you can devote more time to the fun of rendering three-dimensional (3-D) images. My focus is on the Windows NT™ specifics of getting an OpenGL program set up, not on the actual OpenGL code. Uncle U was similar in this respect. His interest lay in tossing nephews off the dock, not in whether they could swim.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Uncle Ulysses is a fictional character. Any resemblance to a real person is coincidental and would definitely scare the willies out of me.</p>
<h2>GLEasy</h2>
<p>
The program I am going to describe is called GLEasy. GLEasy is a simple Microsoft® Foundation Class Library (MFC) application that just happens to include some OpenGL code for placing a cube, a pyramid, and a dodecahedron (a Platonic solid with 12 sides consisting of pentagons) on the screen. You can even rotate these objects. GLEasy is a good place to start playing with OpenGL. Everything is set up for OpenGL to work correctly—all you have to do is add your own OpenGL code to render the scenes you like.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In this article, the term "OpenGL" refers to the Windows NT implementation of OpenGL. Some limitations presented in this article are limitations of OpenGL, some are limitations of the generic pixel formats, and other limitations are associated with the Windows NT implementation of OpenGL.</p>
<p>
To make it easy for you to follow the discussions in this article, I put all the relevant code in the GLEasy view class <b>CGLEasyView</b>, in the GLEASVW.H and GLEASVW.CPP files. I also included the important parts of the code in the article.</p>
<p>
The article will follow the flow of the GLEasy program. We will start at the beginning with <b>PreCreateWindow</b> and follow the program all the way to <b>OnDraw</b>, where our 3-D scene will be rendered. Along the way, we will look at the OpenGL code placed in the following message handlers:
<ul type=disc>
<li>
<b>PreCreateWindow</b><br><br></li>
<li>
<b>OnCreate</b><br><br></li>
<li>
<b>OnSize</b><br><br></li>
<li>
<b>OnEraseBkgnd</b><br><br></li>
<li>
<b>OnInitialUpdate</b><br><br></li>
<li>
<b>OnDraw</b><br><br></li>
<li>
<b>OnIdle</b></li>
</ul>
<p>
First, we need to take care of some logistics.</p>
<h2>Logistics</h2>
<p>
Before you can add OpenGL code to your MFC application, you need to handle the odds and ends described below.
<ul type=disc>
<li>
Add the following lines to STDAFX.H:<pre><code>#include "gl/gl.h"
#include "gl/glu.h"
</code></pre>
<p class=tl>
These lines will add the OpenGL header files for the OpenGL library and the utility library to the precompiled header file. Optionally, you can add the following header file to include the functions defined in the auxiliary library: </P><pre><code>#include "gl/glaux.h"&nbsp;&nbsp; // optional
</code></pre>
<p class=tl>
The auxiliary library is a collection of routines used by the sample programs listed in the <i>OpenGL Programming Guide</i> (called the "Red Book" by the people in the know; see the bibliography at the end of this article for more information). The auxiliary library is great for learning OpenGL, but I wouldn't recommend it for commercial applications. The auxiliary library was written to get something on the screen with as few lines of code as possible. The source code to the auxiliary library is included with the Microsoft Win32® Software Development Kit (SDK) for Windows NT 3.5, but not with Visual C++™. </P></li>
<li>
Link with the following libraries:<p class=tl>
OPENGL32.LIB</P><p class=tl>
GLU32.LIB</P><p class=tl>
GLAUX.LIB (optional)</P></li>
</ul>
<h2>PreCreateWindow</h2>
<p>
Now that we have taken care of the logistics, we can start examining the flow of execution in GLEasy. The first member function we call that has some effect on OpenGL is <b>PreCreateWindow</b>.</p>
<p>
OpenGL can render only into the client area of a window that has been initialized for OpenGL; it cannot render into child windows or siblings of the window. Therefore, we need to make sure that we clip the client area for children and siblings. This is easy enough to do: Simply override <b>PreCreateWindow </b>and add the following line:</p>
<pre><code>cs.style |= WS_CLIPSIBLINGS | WS_CLIPCHILDREN ;
</code></pre>
<p>
If your window does not have these style bits set, you cannot set a pixel format for it. Pixel formats are discussed in the next section.</p>
<h2>OnCreate</h2>
<p>
Before OpenGL can render images on a drawing surface (window or bitmap), the drawing surface must be initialized. A new concept, <i>pixel format</i>, was added to the graphics device interface (GDI) in Windows NT version 3.5. A pixel format specifies several properties of a drawing surface, mainly those dealing with the organization and layout of the color bits. A pixel format is specified with the <b>PIXELFORMATDESCRIPTOR</b> structure. Each window has its own current pixel format. Different windows can have different pixel formats, and a single device can support several pixel formats.</p>
<p>
For more information on pixel formats, see Dennis Crain's article <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started"</a> in the MSDN Library. I would suggest running the MYGL sample application and looking at the pixel formats supported by your system. You can learn a lot about pixel formats by playing around with MYGL for a couple of minutes.</p>
<p>
The pixel format must be described, selected, and set for an OpenGL drawing surface before OpenGL commands will work. A good place for setting the pixel format is in the <b>OnCreate </b>function for a window. The code in this section is from <b>CGLEasyView::OnCreate</b>.</p>
<h3>Describing the Pixel Format</h3>
<p>
First, we must describe the pixel format we would like. To describe a pixel format, we fill in the fields of a <b>PIXELFORMATDESCRIPTOR</b> structure. The code below shows how to do just that:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CClientDC dc(this) ;
 &nbsp; //
 &nbsp; // Fill in the pixel format descriptor.
 &nbsp; //
 &nbsp; PIXELFORMATDESCRIPTOR pfd ;
 &nbsp; memset(&amp;pfd, 0, sizeof(PIXELFORMATDESCRIPTOR)) ;
 &nbsp; pfd.nSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = sizeof(PIXELFORMATDESCRIPTOR); 
 &nbsp; pfd.nVersion&nbsp;&nbsp; = 1 ; 
 &nbsp; pfd.dwFlags&nbsp;&nbsp;&nbsp; = PFD_DOUBLEBUFFER |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PFD_SUPPORT_OPENGL |
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PFD_DRAW_TO_WINDOW ;
 &nbsp; pfd.iPixelType = PFD_TYPE_RGBA 
 &nbsp; pfd.cColorBits = 24 ;
 &nbsp; pfd.cDepthBits = 32 
 &nbsp; pfd.iLayerType = PFD_MAIN_PLANE ;
</code></pre>
<p>
The code above allocates a <b>PIXELFORMATDESCRIPTOR</b> structure and fills it in. The <b>dwFlags</b> field is set to the following values:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Value</b></td>
<td class=label width=70%><b>Means</b></td>
</tr>
<tr valign=top>
<td width=30%>PFD_SUPPORT_OPENGL</td>
<td width=70%>We want to use OpenGL on the surface. The pixel format concept is generic enough that interfaces or devices other than OpenGL could use it.</td>
</tr>
<tr valign=top>
<td width=30%>PFD_DRAW_TO_WINDOW</td>
<td width=70%>We want to render on the client area of a window and not on a bitmap.</td>
</tr>
<tr valign=top>
<td width=30%>PFD_DOUBLEBUFFER</td>
<td width=70%>We want OpenGL to do double buffering for us. OpenGL will render the scene to an off-screen buffer, and we will swap that buffer to the screen.</td>
</tr>
</table><br>
<p>
The <b>iPixelType</b> field is set to PFD_TYPE_RGBA. This tells OpenGL that we will specify colors using their red, green, and blue (RGB) components. We could have used PFD_TYPE_COLORINDEX to specify an index into a palette instead of using the RGB components.</p>
<p>
The next field of interest is <b>cColorBits</b>. This field is set to the number of bits per pixel (bpp), which determines the number of colors. In GLEasy, I set <b>cColorBits</b> to 24 because I would like 24 colors if the system supports it. An application can use <b>GetDeviceCaps</b> to determine the maximum number of possible colors and choose the bpp value beforehand. Another option is to choose the pixel format you want and see what you actually get. More on choosing the pixel format in a little bit.</p>
<p>
While <b>cColorBits</b> sets the number of bits we want for color information, <b>cDepthBits</b> sets the bpp value for depth information. OpenGL maintains a buffer called the <i>depth buffer</i>. For each pixel, the depth buffer contains the distance between the pixel and the viewer. When OpenGL renders an object, it compares the position of each new pixel to the position stored in the depth buffer. If the new pixel is closer to the viewer, it is placed on the screen, and the depth buffer is updated. If the new pixel is farther away from the viewer, it is not written to the screen. As a result, the depth buffer provides a mechanism for hidden surface removal.</p>
<p>
Currently, the only <b>iLayerType </b>supported is PFD_MAIN_PLANE (the main plane), so I won't go into any more detail on this field.</p>
<h3>Choosing and Setting the Pixel Format</h3>
<p>
After the pixel format descriptor is filled; it is passed to the new Win32 <b>ChoosePixelFormat</b> function. This function compares the generic pixel formats supported by Windows NT and any device pixel formats supported by special hardware accelerators with the pixel format you described, and returns the best match. The return value of <b>ChoosePixelFormat</b> is a one-based index into the possible pixel formats. The index is not unique and can change depending on the current display mode.</p>
<pre><code>&nbsp;&nbsp;&nbsp;int nPixelFormat = ChoosePixelFormat(dc.m_hDC, &amp;pfd);
 &nbsp; if (nPixelFormat == 0)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; TRACE("ChoosePixelFormat Failed %d\r\n",GetLastError()) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return -1 ;
 &nbsp; }
 &nbsp; TRACE("Pixel Format %d\r\n",nPixelFormat) ;
</code></pre>
<p>
You are free to examine the pixel format recommended by <b>ChoosePixelFormat</b> and choose again if you don't like it. If you like the format recommended by <b>ChoosePixelFormat</b>, set the pixel format using the new <b>SetPixelFormat</b> function. <b>SetPixelFormat</b> takes a handle to a device context (DC) as its first parameter, and sets the window associated with this device context to the appropriate pixel format, as shown below:</p>
<pre><code>&nbsp;&nbsp;&nbsp;BOOL bResult = SetPixelFormat (dc.m_hDC, nPixelFormat, &amp;pfd);
 &nbsp; if (!bResult)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; TRACE("SetPixelFormat Failed %d\r\n",GetLastError()) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return -1 ;
 &nbsp; }
</code></pre>
<p>
For more information on describing, selecting, and setting the pixel format, see Dennis Crain's article <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started"</a> in the MSDN Library.</p>
<h3>Creating a Rendering Context</h3>
<p>
We have set the pixel format. Next, we need to create an OpenGL <i>rendering context</i> (GLRC). You can think of a rendering context as a port through which all OpenGL commands must pass. The rendering context you create has the same pixel format as the device context with which it is associated. A rendering context is not the same as a device context: A device context contains information for GDI, while a rendering context contains information for OpenGL. In many ways, however, a rendering context is to OpenGL what a device context is to GDI. You can create multiple rendering contexts in a program.</p>
<p>
To create a rendering context, you use the <b>wglCreateContext</b> function. <b>wglCreateContext</b> is known as a "wiggle" function. The Windows NT implementation of OpenGL includes several wiggle functions, which are used as bridges to get Windows-specific information, such as the current DCs, into or out of the rendering context. </p>
<p>
<b>wglCreateContext</b> returns an HGLRC, which is a handle to the rendering context. In GLEasy, the HGLRC is stored in a member variable, <i>m_hrc</i>, of the view class.</p>
<pre><code>&nbsp;&nbsp;&nbsp;//
 &nbsp; // Create a rendering context.
 &nbsp; //
 &nbsp; m_hrc = wglCreateContext(dc.m_hDC);
 &nbsp; if (!m_hrc)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; TRACE("wglCreateContext Failed %x\r\n", GetLastError()) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return -1;
 &nbsp; }
</code></pre>
<h3>Quick Look at Palettes</h3>
<p>
If the PFD_NEED_PALETTE flag in <b>dwFlags</b> is set in the pixel format returned from <b>ChoosePixelFormat</b>, you need to create a palette. In GLEasy, the <b>CreateRGBPalette</b> function creates a palette for the <b>CGLEasyView</b> member variable <i>CPalette m_Pal</i>. I will not go into much detail about palettes in this article. For more information, read my article <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode"</a> in the MSDN Library.</p>
<p>
Here are a few facts: If the PFD_NEED_PALETTE flag is set, you have to create a palette. For the generic OpenGL pixel formats, this must be a 3-3-2 palette, which means that the 8 bits are divided into 3 bits for red, 3 bits for green, and 2 bits for blue. The <b>CGLEasyView::CreateRGBPalette</b> function creates the palette correctly for OpenGL. Other palettes will result in incorrect colors in pictures rendered by OpenGL. Unless you understand what you are doing (that is, unless you've read my <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode"</a> article), you should use <b>CreateRGBPalette</b>.</p>
<h3>Summary of OnCreate</h3>
<p>
In <b>CGLEasyView::OnCreate</b>, we describe the pixel format we want and give this information to <b>ChoosePixelFormat</b>, which finds the closest match to the format we described. We then pass this format to <b>SetPixelFormat</b>, which sets the window to the correct format. Now we can create a rendering context with <b>wglCreateContext</b> to accept OpenGL commands. The last step is to create a palette, if one is needed.</p>
<h2>OnSize</h2>
<p>
After you create a window, you must size it, so the next area of discussion is <b>CGLEasyView::OnSize</b>. </p>
<p>
When mapping a 3-D coordinate to the 2-D screen, OpenGL must know the size of the client area. In the <b>OnSize </b>function, we set up the transformations needed to map 3-D coordinates to the screen. GDI doesn't know anything about the third dimension, so it is up to OpenGL to set up the 3-D projection.</p>
<h3>wglMakeCurrent</h3>
<p>
A program can have several rendering contexts as well as several device contexts. Before we can draw using GDI, or render using OpenGL, we need to specify the device context or rendering context we are using. GDI and OpenGL have different philosophies on specifying the current context: GDI calls require an explicit device context, while OpenGL calls use an implicit rendering context.</p>
<p>
All GDI functions either take a handle to a device context:</p>
<pre><code>SetViewport(hDC,x,y)
</code></pre>
<p>
or (with MFC) require a <b>CDC</b> object or pointer:</p>
<pre><code>dc.SetViewport(x,y) ;
</code></pre>
<p>
OpenGL, on the other hand, adopts the concept of a <i>current</i> rendering context. Instead of specifying the rendering context as a parameter for every OpenGL call (as GDI does with device contexts), OpenGL writes to the current active rendering context. The <b>wglMakeCurrent</b> function is used to set the current active rendering context: </p>
<pre><code>&nbsp;&nbsp;&nbsp;BOOL bResult = wglMakeCurrent (dc.m_hDC, m_hrc);
 &nbsp; if (!bResult)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; TRACE("wglMakeCurrent Failed %x\r\n", GetLastError() ) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return ;
 &nbsp; }
</code></pre>
<p>
If a rendering context is not made current, the OpenGL calls will do nothing. Each thread can have only one current rendering context, and a rendering context can be current in only one thread at a time. </p>
<h3>Setting Up the World</h3>
<p>
Now that we have a current rendering context, we can start using OpenGL functions. The following functions set up the screen.</p>
<pre><code>&nbsp;&nbsp;&nbsp;GLdouble gldAspect = (GLdouble) cx/ (GLdouble) cy;
 &nbsp; glMatrixMode(GL_PROJECTION);
 &nbsp; glLoadIdentity();
 &nbsp; gluPerspective(30.0, gldAspect, 1.0, 10.0);
 &nbsp; glViewport(0, 0, cx, cy);
</code></pre>
<p>
All OpenGL functions are prefixed with "gl". The OpenGL utility library includes some convenient medium-level functions built from the low-level functions in the OpenGL library. All OpenGL utility functions (for example, <b>gluPerspective</b>) are prefixed with "glu". For portability, OpenGL has its own types, such as <b>GLdouble</b>. </p>
<p>
I won't describe these functions in detail. Instead, I recommend that you read the Red Book—after all, that's why it was written.</p>
<p>
Before drawing with GDI functions, we have to set up our coordinate system. GDI provides functions such as <b>SetMapMode</b>, <b>SetViewportOrg</b>, <b>SetViewportExt</b>, <b>SetWindowOrg</b>, and <b>SetWindowExt</b> for configuring the coordinate system for your application. For many applications, the default settings of the coordinate system are good enough.</p>
<p>
OpenGL applications must also set up their "world," which is complicated by the fact that their world is 3-D. The four functions listed in the code fragment above set up the world. Let's take each one in turn.</p>
<h4>glMatrixMode</h4>
<pre><code>glMatrixMode(GL_PROJECTION);
</code></pre>
<p>
Matrix calculations are heavily used in 3-D graphic programming, and OpenGL is no exception. Matrices are used for transforming (for example, scaling, translating, rotating) objects. Matrices are also used to transform the way information is projected onto the screen. OpenGL maintains two separate transformation matrix stacks: one for transforming objects and the other for transforming the projection of the objects. We want to set up the way we view the objects, so we specify the GL_PROJECTION matrix mode.</p>
<h4>glLoadIdentity</h4>
<pre><code>glLoadIdentity();
</code></pre>
<p>
Transformations are combined mathematically. Any transformation added to the stack is combined with previous transformations. Therefore, the stack must be cleared by loading the identity matrix.</p>
<h4>gluPerspective</h4>
<pre><code>gluPerspective(30.0, gldAspect, 1.0, 10.0);
</code></pre>
<p>
We use the utility library function <b>gluPerspective</b> instead of "gl" functions because it is much simpler. <b>gluPerspective</b>, as called above, sets the field of view to 30 degrees. The aspect ratio is adjusted for the size of the window client area. The near clipping plane is set at 1 unit from the viewpoint, and the far clipping plane is set at 10 units from the viewpoint. The viewpoint is located at (0, 0, 0) facing down the negative <i>z</i> axis, unless we change it (which we don't). <i>Z</i>-axis values that are greater than –1 and less than –10 are clipped from the screen. </p>
<h4>glViewport</h4>
<pre><code>glViewport(0, 0, cx, cy);
</code></pre>
<p>
<b>glViewport</b> instructs OpenGL that it is going to render to the whole client area. If you would like to limit rendering to a specific part of the client area, you can set the parameters accordingly.</p>
<p>
For more information, check out the three articles by Jeff Prosise in the <i>Microsoft Systems Journal</i> (see the bibliography at the end of this article), and read the Red Book, mentioned earlier.</p>
<h3>Finishing up OnSize</h3>
<p>
Before we leave <b>OnSize</b>, we call <b>wglMakeCurrent</b> to deactivate our current rendering context:</p>
<pre><code>&nbsp;&nbsp;&nbsp;wglMakeCurrent(NULL, NULL);
</code></pre>
<p>
This step is not required, but it can help find errors, especially when you are using multiple rendering contexts.</p>
<p>
The <b>CGLEasyView</b> class could be rewritten to make the window's DC current, and then leave it. More on this later.</p>
<h2>OnEraseBkgnd</h2>
<p>
Overloading <b>OnEraseBkgnd </b>and returning TRUE will stop the program from painting the screen white before you render your OpenGL screen. This will make your program look much better because it will eliminate the extra screen flash.</p>
<h2>OnInitialUpdate</h2>
<p>
OpenGL has several tricks for optimizing rendering operations. One trick is to use display lists. A display list is like a metafile; similar to the way a metafile holds GDI commands for later replay, a display list holds OpenGL commands for later replay. When OpenGL builds a display list, it can store the results of its transformation calculations in the list so these calculations do not have to be repeated each time the list is displayed.</p>
<p>
A convenient place to build display lists is in the <b>OnInitialUpdate </b>member function. The display lists are built before we need them in the <b>OnDraw </b>member function.</p>
<p>
In GLEasy, the <b>PrepareScene</b> helper function contains the code for building the display list for the box and the pyramid.</p>
<h2>OnDraw</h2>
<p>
Now is the time to render the picture. This process consists of the following steps:</p>
<p>
Select and realize the palette in the DC.</p>
<p>
Make the rendering context current.</p>
<p>
Draw the scene using OpenGL commands.</p>
<p>
Swap the drawing buffer, if using a double buffering pixel format.</p>
<p>
Select the original palette back into the DC.</p>
<p>
It is important that you select the palette before you call <b>wglMakeCurrent</b>. <b>wglMakeCurrent</b> initializes the rendering context based on the current logical palette.</p>
<p>
The buffers are swapped using a new Win32 GDI function, <b>SwapBuffers</b>. </p>
<p>
The code below implements these steps.</p>
<pre><code>void CGLEasyView::OnDraw(CDC* pDC)
{
 &nbsp;&nbsp; // Select the palette.
 &nbsp;&nbsp; CPalette* ppalOld = pDC-&gt;SelectPalette(&amp;m_Pal, 0);
 &nbsp;&nbsp; pDC-&gt;RealizePalette();

 &nbsp; // Make the HGLRC current.
 &nbsp; BOOL bResult = wglMakeCurrent (pDC-&gt;m_hDC, m_hrc);
 &nbsp; if (!bResult)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; TRACE("wglMakeCurrent Failed %x\r\n", GetLastError() ) ;
 &nbsp; }

 &nbsp; // Draw.
 &nbsp; DrawScene() ;

 &nbsp; // Swap buffers.
 &nbsp; SwapBuffers(pDC-&gt;m_hDC) ;

 &nbsp; // Select old palette. 
 &nbsp; if (ppalOld) pDC-&gt;SelectPalette(ppalOld, 0); 

 &nbsp; wglMakeCurrent(NULL, NULL) ;
}
</code></pre>
<p>
Because <b>wglMakeCurrent </b>can be a time-consuming function, it is often more efficient to call <b>wglMakeCurrent </b>only once in a program. However, this requires keeping a DC around for the entire life of the program. In Windows NT, the number of DCs is limited only by memory, and users running Windows NT have plenty of memory. Dennis Crain discusses how to use DCs in detail in <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started"</a> in the section "Pulling It All Together." MYGL (Dennis Crain's sample) and GENGL (the sample included in the Win32 SDK for Windows NT 3.5) both set the DC at the beginning of the program and keep it around. </p>
<h3>DrawScene</h3>
<p>
<b>CGLEasy::OnDraw </b>doesn't contain any OpenGL commands; all of the OpenGL commands are in the <b>CGLEasy::DrawScene</b> function. In this section, I will explain the functionality of <b>DrawScene</b>. Again, for information on basic OpenGL commands, it's best to refer to the Red Book (Chapter 3 has very good information on the effects of transformations).</p>
<p>
My goal in writing <b>DrawScene</b> was to render an attractive scene while doing the least amount of work possible. Parts of the <b>DrawScene</b> code are listed below. Some of the code has been left out to make the point a little clearer; ellipses mark these deletions.</p>
<pre><code>void CGLEasyView::DrawScene() 
{
 &nbsp; // Set up some colors.
 &nbsp; GLdouble purple[3] = {1.0, 0.14, 0.6667} ; 
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; // Enable lighting calculations.
 &nbsp; glEnable(GL_LIGHTING) ;
 &nbsp; glEnable(GL_LIGHT0) ;

 &nbsp; // Enable depth calculations.
 &nbsp; glEnable(GL_DEPTH_TEST);

 &nbsp; // Clear the color and depth buffers.
 &nbsp; glClearColor(0.0f, 0.0f, 0.0f, 0.0f) ;
 &nbsp; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

 &nbsp; // Set the material color to follow the current color
 &nbsp; glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE) ;
 &nbsp; glEnable(GL_COLOR_MATERIAL) ;

 &nbsp; //
 &nbsp; // Change to model view matrix stack.
 &nbsp; //
 &nbsp; glMatrixMode(GL_MODELVIEW); 
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; //
 &nbsp; // Draw the box.
 &nbsp; //
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; //
 &nbsp; // Draw the pyramid.
 &nbsp; //
 &nbsp; glLoadIdentity();
 &nbsp; glTranslated(-0.7, 0.5, -4.5 );
 &nbsp; glRotated(m_angle[Pyramid].cx, 1.0, 0.0, 0.0);
 &nbsp; glRotated(m_angle[Pyramid].cy, 0.0, 1.0, 0.0);

 &nbsp; glColor3dv(purple) ;
 &nbsp; glCallList(Pyramid) ;

 &nbsp; //
 &nbsp; // Draw the dodecahedron.
 &nbsp; //
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; //
 &nbsp; // Flush the drawing pipeline.
 &nbsp; //
 &nbsp; glFlush ();
}
</code></pre>
<p>
<b>DrawScene</b> starts by enabling lighting calculations. For simplicity, I've used the OpenGL defaults. (Chapter 6 in the Red Book contains some good information on lighting effects.) As an experiment, you can disable the lighting calculations and see what happens. OpenGL supports multiple, separate, and independent lights. <b>glEnable(GL_LIGHT0)</b> turns on the first light.</p>
<p>
<b>glEnable(GL_DEPTH_TEST)</b> enables depth calculations. OpenGL uses the depth buffer for hidden surface removal. For each pixel on the screen, OpenGL keeps track of the distance between the viewport and the object occupying that pixel. If another object wants to write to a particular pixel, the object's distance to the viewport is compared with the distance stored in the depth buffer. The object closest to the viewport is left in the depth buffer and eventually displayed on the screen. <b>glClear </b>clears the drawing buffer and the depth buffer.</p>
<p>
In OpenGL, surfaces have different material properties. These properties change how light affects an object. For example, some materials reflect light while others absorb light, and some materials consist of one color while reflecting another color. Sometimes, understanding why a blue object is green can be confusing. The situation can get even worse if you have several lights with different colors.</p>
<p>
To avoid the trouble of setting up different material properties, I used <b>glColorMaterial</b>. Enabling GL_COLOR_MATERIAL causes OpenGL to use the current color for the material properties of a surface, thus simplifying the situation.</p>
<p>
3-D graphics rely heavily on matrix mathematics. The 3-D transformations (rotation, scaling, and translation) are expressed mathematically in terms of matrices. OpenGL maintains stacks of matrices that it combines to transform an object. There are two matrix stacks: one for transforming objects in a scene, and the other for transforming the scene onto the screen. As you will remember, we used the projection stack in the <b>OnSize</b> function.</p>
<p>
Now we want to transform the box and the pyramid for which we created display lists in <b>OnInitialUpdate</b>. The first step is to switch to the matrix stack for transforming objects, known as the <i>model view stack</i>. <b>glMatrixMode(GL_MODELVIEW)</b> changes the current stack to the model view stack.</p>
<p>
To transform the pyramid, we clear out the matrix stack by putting the identity matrix on top. If we don't put the identity matrix on the stack, the transformations we add to the stack will be combined with the current transformations on the stack. </p>
<p>
Now we can transform the pyramid. Because of the way the math works out, the transformations actually happen in the reverse of the order specified. Therefore, the pyramid is rotated <b>m_angle[Pyramid].cy</b> degrees around the <i>y</i> axis, then rotated <b>m_angle[Pyramid].cx </b>degrees around the <i>x</i> axis. Finally, it is translated to the position (–0.7, 0.5, –4.5).</p>
<p>
The color of the pyramid is set with the <b>glColor3dv</b> command. The three characters at the end of the <b>glColor*</b> command name determine the parameter types the command accepts: for example <b>glColor3dv</b> takes an array of three doubles. The RGB intensities are specified as doubles between 0.0 and 1.0.</p>
<p>
Finally, we can call the display list to render the pyramid for us. The box and dodecahedron are rendered similarly.</p>
<p>
We can now flush the OpenGL command pipeline to make sure that all OpenGL commands are processed before we continue. Once again, see the Red Book for more information.</p>
<h2>OnDestroy</h2>
<p>
In the <b>OnDestroy</b> member function, we clean up after ourselves by deleting the rendering context we created way back in <b>OnCreate</b>:</p>
<pre><code>wglMakeCurrent(NULL, NULL) ;
if (m_hrc)
{
 &nbsp; wglDeleteContext(m_hrc) ;
 &nbsp; m_hrc = NULL ;
}
</code></pre>
<h2>OnIdle</h2>
<p>
You might be interested in how the objects are rotated. When we call <b>CGLEasyApp::OnIdle</b>, this function calls <b>CGLEasyView::Tick</b>. An array of <b>CSize </b>objects, <i>m_angle</i>, keeps track of the rotation around the <i>x</i> axis and <i>y</i> axis for each object. In <b>Tick</b>, the <b>CSize</b> object for the current array is incremented by 10 degrees.</p>
<pre><code>&nbsp;&nbsp;&nbsp;m_angle[m_RotatingObject].cx += 10 ;
 &nbsp; m_angle[m_RotatingObject].cy += 10 ;
 &nbsp; if (m_angle[m_RotatingObject].cx &gt;= 360)
 &nbsp;&nbsp;&nbsp;&nbsp; m_angle[m_RotatingObject].cx = 0 ;
 &nbsp; if (m_angle[m_RotatingObject].cy &gt;= 360)
 &nbsp;&nbsp;&nbsp;&nbsp; m_angle[m_RotatingObject].cy = 0 ;
</code></pre>
<p>
The window is then invalidated so that the scene can be redrawn. This causes the following lines to execute, thus drawing the pyramid (if it is the currently rotating object) with a different rotation:</p>
<pre><code>&nbsp;&nbsp;&nbsp;glRotated(m_angle[Pyramid].cx, 1.0, 0.0, 0.0);
 &nbsp; glRotated(m_angle[Pyramid].cy, 0.0, 1.0, 0.0);
</code></pre>
<p>
The rotation performance is not very impressive. In fact, it's pretty poor on my 66 Mhz. Pentium™ system unless you make the scene smaller. In a future article, I will explain how I was able to optimize <b>GLEasy</b>.</p>
<h2>Conclusion</h2>
<p>
OpenGL is a powerful 3-D graphics library, and GLEasy is a good place to start your investigation of OpenGL. You can extend GLEasy to add more lighting effects, atmospheric effects, and more objects. See the bibliography below for more information on OpenGL.</p>
<h2>Bibliography</h2>
<p>
Crain, Dennis. <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started."</a> April 1994. (MSDN Library, Technical Articles)</p>
<p>
Neider, Jackie, Tom Davis, and Mason Woo. <i>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1993. ISBN 0-201-63274-8. (This book is also known as the "Red Book".)</p>
<p>
OpenGL Architecture Review Board. <i>OpenGL Reference Manual: The Official Reference Document for OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1992. ISBN 0-201-63276-4. (This book is also known as the "Blue Book".)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: Introducing the OpenGL Interface, Part I." <i>Microsoft Systems Journal</i> 9 (October 1994). (MSDN Library Archive Edition, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: The OpenGL Interface, Part II." <i>Microsoft Systems Journal</i> 9 (November 1994). (MSDN Library Archive Edition, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Understanding Modelview Transformations in OpenGL for Windows NT." <i>Microsoft Systems Journal</i> 10 (February 1995). </p>
<p>
Rogerson, Dale. <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode."</a> December 1994. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl3.htm">"OpenGL III: Building an OpenGL C++ Class."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl4.htm">"OpenGL IV: Color Index Mode."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl5.htm">"OpenGL V: Translating Windows DIBs."</a> February 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl6.htm">"OpenGL VI: Rendering on DIBs with PFD_DRAW_TO_BITMAP."</a> April 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl7.htm">"OpenGL VII: Scratching the Surface of Texture Mapping."</a> May 1995. (MSDN Library, Technical Articles)</p>
</BODY>
</HTML>
