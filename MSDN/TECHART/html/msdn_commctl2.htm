<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Win32 Common Controls, Part 2: Status Bars and Toolbars</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_commctl2"></a>Win32 Common Controls, Part 2: Status Bars and Toolbars</h1>
<p>
Nancy Winnick Cluts<br>
Microsoft Developer Network Technology Group</p>
<p>
March 1994</p>
<p>
Revised: June 1995 (<b>TBADDBITMAP32</b> structure and message removed)</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="2305">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the Toolbar sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
The next release of the Microsoft® Windows® operating system (called Windows 95) presents a new set of common controls to developers of Windows-based applications. These controls are provided in a new dynamic-link library (DLL) called COMCTL32.DLL. The controls allow developers to integrate existing applications into the new Windows 95 shell more thoroughly and seamlessly. COMCTL32.DLL is included with Windows 95 and will also be supported in Win32s® (running on Windows version 3.1) and in Windows NT™. Note that these controls are 32-bit only—they will not be supported in 16-bit Windows environments.</p>
<p>
This article describes two new common controls: status bars and toolbars. It is the second in a series of articles introducing the new common controls. The other articles in the series cover the following topics:
<ul type=disc>
<li>
<a href="msdn_commctl1.htm">Part 1: The basics</a><br><br></li>
<li>
<a href="msdn_commctl3.htm">Part 3: Trackbars, progress bars, and up-down controls</a><br><br></li>
<li>
<a href="msdn_commctl4.htm">Part 4: Header windows and list view windows</a><br><br></li>
<li>
<a href="msdn_commctl5.htm">Part 5: Image lists and tree view windows</a><br><br></li>
<li>
<a href="msdn_commctl6.htm">Part 6: Tab controls and property sheets</a></li>
</ul>
<p>
Parts 2–6 of the series have associated code samples that demonstrate the use of the Win32® common controls.</p>
<p class=indent>
<B><b>WARNING</b></B>&nbsp;&nbsp;&nbsp;The Toolbar executable file associated with this article was built and tested using the Windows 95 Preliminary Development Kit. The executable will run only on Windows 95; it will not run under Windows 3.1 or Windows NT 3.5. If you have Windows 95 installed on your machine but you have problems running this sample, copy the project files to your system using the button above, rebuild the project, and run the executable.</p>
<p>
Please note that this article is based on preliminary information that is subject to change before the final version of Windows 95.</p>
<h2>Status Bars</h2>
<p>
A status bar is a horizontal window that is positioned, by default, at the bottom of a parent window. It is used to display status information defined by the application. If you wish to display more than one type of status information, you can divide the status bar into sections.</p>
<p>
To create a status bar, call the <b>CreateWindow</b> or <b>CreateWindowEx</b> function and specify the STATUSCLASSNAME window class. After you create the status bar, you can divide it into sections, set the text for each section, and control the appearance of the window by using status bar messages.</p>
<p>
The default window procedure automatically adjusts the size of the status bar whenever it receives a WM_SIZE message. Figure 1 shows a simple status bar that displays the current mouse position.</p>
<p>
<img src="commctl2_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Example of a simple status bar</b></p>
<p>
I found status bars particularly useful for displaying diagnostic messages when debugging my application. This works well for those times when you don't want to bother with a debugger, and you would normally display a message box showing the value of a particular parameter or indicating whether you reached a certain line in your code. I recommend that you use a status bar for this instead.</p>
<h3>Status Bar Styles and Default Behavior</h3>
<p>
The only new style that was developed specifically for the status bar is the SBS_SIZEGRIP style, which places a sizing grip at the lower-right corner of the status bar. A sizing grip is similar to a sizing border—it is a rectangular area that the user can click and drag to resize the parent window.</p>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;If you decide to include a sizing grip, I recommend against combining the CCS_TOP common control style and the SBS_SIZEGRIP style. Combining the two styles renders the sizing grip nonfunctional. Because the system will still draw the sizing grip in the status bar, the user will try to use it and think that your application is at fault.</p>
<p>
You can set the minimum height of a status bar's drawing area by sending the window a SB_SETMINHEIGHT message and specifying the minimum height in pixels. Note that the drawing area does not include the window's borders. If you want to set the border width for the status bar, you can send an SB_SETBORDERS message. This message passes the address of a three-element array that contains the width of the horizontal border, the width of the vertical border, and the width of the border that separates the sections of the status bar. All widths are specified in pixels. If you want to use the default width, pass a value of –1.</p>
<h3>Creating a Status Bar Window</h3>
<p>
Use the <b>CreateWindowEx</b> function to create a status bar. The default values for the size of a status bar are (–100, –100, 10, 10). The following example creates the status bar that displays the current mouse cursor position (illustrated in Figure 1). The code resides in the window procedure for the status bar's parent window.</p>
<pre><code>switch (message) 
{
 &nbsp; case WM_CREATE:
 &nbsp;&nbsp;&nbsp;&nbsp; hWndStatus = CreateWindowEx( 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0L,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no extended styles
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATUSCLASSNAME,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // status bar
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no text 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_CHILD | WS_BORDER | WS_VISIBLE,&nbsp; // styles
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -100, -100, 10, 10,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // x, y, cx, cy
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hWnd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parent window
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (HMENU)100,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // window ID
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInst,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // instance
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // window data
 &nbsp;&nbsp;&nbsp;&nbsp; if (hWndStatus == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox (NULL, "Status Bar not created!", NULL, MB_OK );
 &nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp; case WM_MOUSEMOVE:
 &nbsp;&nbsp;&nbsp;&nbsp; wsprintf(szBuf, "Mouse position: %d, %d", LOWORD(lParam), HIWORD(lParam));
 &nbsp;&nbsp;&nbsp;&nbsp; SendMessage(hWndStatus, SB_SETTEXT, 0, (LPARAM)(LPSTR)szBuf);
 &nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; .
 &nbsp; .
 &nbsp; .
}
</code></pre>
<p>
In the code above, I used <b>CreateWindowEx</b> to emphasize that these new common controls are all windows—you create them, send messages to them, and receive notifications from them, as you would with any other window. A helper function called <b>CreateStatusWindow</b> allows you to create a status bar at the bottom of your screen. This helper function creates a status bar by calling <b>CreateWindowEx</b> and passing the default size and position as (–100, –100, 10, 10). <b>CreateStatusWindow</b> takes the following parameters:
<ul type=disc>
<li>
<b>LONG</b> <i>style</i>: The window styles you want for the status bar.<br><br></li>
<li>
<b>LPCSTR</b> <i>lpszText</i>: The default text for the status bar.<br><br></li>
<li>
<b>HWND</b> <i>hwndParent</i>: The handle to the parent window.<br><br></li>
<li>
<b>UINT</b> <i>wID</i>: The identifier for the window.</li>
</ul>
<h3>Simple-Mode and Multiple-Part Status Bars</h3>
<p>
A simple-mode status bar has only one section. It is useful for displaying one-line descriptions of menu items as the user highlights each item. To create a simple-mode status bar from a multiple-part status bar, you must send an SB_SIMPLE message to the status bar, but bear in mind that simple-mode status bars do not support owner drawing.</p>
<p>
A multiple-part status bar has multiple sections and can display a different line of text for each section. You can divide a status bar into parts by sending the window an SB_SETPARTS message, specifying the number of sections to create and the address of an integer array containing one element for each section. Each element specifies the client coordinate of the right edge of a section. A status bar can have a maximum of 255 sections.</p>
<p>
The string that a status bar displays in simple mode is maintained separately from the strings it displays when it is not in simple mode. This means you can put the window in simple mode, set its text, and switch back to non-simple mode without having to reset the text.</p>
<h3>Owner-Drawn Status Bars</h3>
<p>
You can customize status bars by adding owner-drawn sections, just as you would customize other built-in controls. Owner drawing allows you to display a bitmap instead of text or use different fonts in the sections of a status bar. To define a section of the status bar as owner-drawn, send the SB_SETTEXT message to the status bar, specifying the part and the SBT_OWNERDRAW drawing technique. When you specify SBT_OWNERDRAW, the <i>lParam</i> parameter becomes a 32-bit application-defined value that the application can use when drawing the part. At this point, you treat the control like any other owner-drawn control: you handle the WM_DRAWITEM message and use the information in the <b>DRAWITEMSTRUCT</b> that is passed along.</p>
<h3>Status Bar Messages</h3>
<p>
This section lists the messages that you can send to status bars. You will notice that many of these messages can also be sent to header windows. In fact, the header window procedure calls the window procedure for status bars. For more information about header window controls, see the <a href="msdn_commctl4.htm">"Win32 Common Controls, Part 4: Header Windows and List View Windows"</a> article in this series.</p>
<p>
Several messages require or return a drawing operation type for the status bar. The values you can use to designate an operation type are listed in Table 1 below.</p>
<p class=label>
<b>Table 1. Status Bar Drawing Operation Types</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Type</b></td>
<td class=label width=76%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=24%>0</td>
<td width=76%>The text is drawn so that it appears as part of the window—that is, the text appears lower than the plane of the window.</td>
</tr>
<tr valign=top>
<td width=24%>SBT_OWNERDRAW</td>
<td width=76%>The application may draw the item (text or bitmap) when it receives a WM_DRAWITEM message. Note that the <b>CtlType</b>, <b>itemState</b>, and <b>itemAction</b> fields of the <b>DRAWITEMSTRUCT</b> structure are undefined for status bars.</td>
</tr>
<tr valign=top>
<td width=24%>SBT_NOBORDERS</td>
<td width=76%>The text is drawn without borders.</td>
</tr>
<tr valign=top>
<td width=24%>SBT_POPOUT</td>
<td width=76%>The text is drawn so that it appears raised, that is, the text appears higher than the plane of the window.</td>
</tr>
<tr valign=top>
<td width=24%>HBT_SPRING</td>
<td width=76%>The item (text or bitmap) "springs"; that is, it has a minimum length but will grow if the window provides extra room. Multiple items (items in multiple-part toolbars) are allowed to spring—the extra room is distributed among the multiple parts. (This type was originally created for header controls, which is why the type name begins with "HBT" instead of "SBT".)</td>
</tr>
</table><br>
<h4>SB_GETBORDERS</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = LPINT)aBorders;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ array that receives border values
</code></pre>
<p>
<b>Description:</b> The SB_GETBORDERS message retrieves the current width of the horizontal and vertical borders of a status or header window. These measurements determine the spacing between the outer edge of the window and the rectangles within the window that contain text, and the spacing between rectangles.</p>
<p>
<b>Parameters:</b> <i>wparam</i> is not used. <i>lparam</i> represents the address of an integer array with three elements. The first element receives the width of the horizontal border, the second receives the width of the vertical border, and the third receives the width of the border between rectangles. </p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>SB_GETPARTS</h4>
<pre><code>wParam = nParts;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ number of parts to retrieve
lParam = (LPINT) aRightCoord;&nbsp;&nbsp;&nbsp;&nbsp; \\ array that receives right edge
</code></pre>
<p>
<b>Description:</b> The SB_GETPARTS message gets the number of parts in a status bar and the coordinate of the right edge of the given number of parts.</p>
<p>
<b>Parameters:</b> <i>wparam</i> identifies the number of parts for which the message will get coordinates. If this parameter is greater than the number of parts in the status bar, the message gets coordinates for the existing parts only. <i>lparam</i> represents the address of an integer array that has the same number of elements as parts specified by <i>wParam</i>. Each element in the array receives the client coordinate of the right edge of the corresponding part. If an element is set to –1, the position of the right edge for that part extends to the right edge of the status bar.</p>
<p>
<b>Return value:</b> The number of parts in the status bar if successful; zero otherwise.</p>
<h4>SB_GETTEXT</h4>
<pre><code>wParam = iPart;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the part
lParam = (LPSTR) szText;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ address of the buffer receiving the string
</code></pre>
<p>
<b>Description:</b> The SB_GETTEXT message retrieves the text from the given part of a status bar or header window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the zero-based index of the part from which the message will retrieve text. <i>lParam</i> is the address of the buffer to receive the text, which is a null-terminated string.</p>
<p>
<b>Return value:</b> SB_GETTEXT returns a 32-bit value consisting of two 16-bit values. The low-order word specifies the length, in characters, of the text. The high-order word specifies the type of operation used to draw the text. If the text has a type of SBT_OWNERDRAW, the message returns the 32-bit value associated with the text instead of the length and type. See Table 1 for a list of values you can use to indicate the operation type.</p>
<h4>SB_GETTEXTLENGTH</h4>
<pre><code>wParam = iPart;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the part
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The SB_GETTEXTLENGTH message retrieves the length, in characters, of the text from the given part of a status bar or header window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the zero-based index of the part from which the message will retrieve text. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> SB_GETTEXTLENGTH returns a 32-bit value consisting of two 16-bit values. The low-order word specifies the length, in characters, of the text. The high-order word specifies the type of operation used to draw the text. See Table 1 for a list of values you can use to indicate the operation type. </p>
<h4>SB_SETBORDERS</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = (LPINT) aBorders;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ array that contains the border values
</code></pre>
<p>
<b>Description:</b> The SB_SETBORDERS message sets the widths of the horizontal and vertical borders of a status bar or header window. These borders determine the spacing between the outer edge of the window and the rectangles within the window that contain text, and the spacing between rectangles.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> is the address of an integer array that has three elements. The first element specifies the width of the horizontal border, the second specifies the width of the vertical border, and the third specifies the width of the border between rectangles. If an element is set to –1, the default width for the border is used.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>SB_SETMINHEIGHT</h4>
<pre><code>wParam = minHeight;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ minimum height, in pixels, of the window
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The SB_SETMINHEIGHT message sets the minimum height for a status bar or header window. The minimum height of the window is the sum of the minimum height (<i>wParam</i>) and the height of the vertical border of the window.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the minimum height, in pixels, of the window. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> None.</p>
<h4>SB_SETPARTS</h4>
<pre><code>wParam = nParts;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ number of parts ( &lt;= 255)
lParam = (LPINT)aWidths;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ address of array containing the widths
</code></pre>
<p>
<b>Description:</b> The SB_SETPARTS message sets the number of parts in a status bar and gets the coordinate of the right edge of each part. </p>
<p>
<b>Parameters:</b> <i>wParam</i> is the number of parts to set. This number cannot be greater than 255. <i>lParam</i> is the address of an integer array that has the same number of elements as parts specified by <i>wParam</i>. Each element in the array specifies the position, in client coordinates, of the right edge of the corresponding part. If an element is –1, the position of the right edge for that part extends to the right edge of the window.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>SB_SETTEXT</h4>
<pre><code>wParam = iPart | uPart;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of part and type of drawing operation
lParam = (LPSTR) szText;&nbsp;&nbsp;&nbsp;&nbsp; \\ address of the buffer receiving the string
</code></pre>
<p>
<b>Description:</b> The SB_SETTEXT message sets the text in the given part of a status bar or header window. This message invalidates the portion of the window that has changed, causing the window to display the new text.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the zero-based index of the part to set and the type of drawing operation, as listed in Table 1. If this value is 255, the status bar is assumed to be a simple window with only one part. <i>lParam</i> is the address of a null-terminated string that specifies the text to set. If <i>wParam</i> is SBT_OWNERDRAW, <i>lparam</i> represents 32 bits of data. The parent window must interpret and draw the data when it receives the WM_DRAWITEM message.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>SB_SIMPLE</h4>
<pre><code>wParam = (BOOL)fSimple;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ TRUE for simple text
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used 
</code></pre>
<p>
<b>Description:</b> The SB_SIMPLE message specifies whether a status bar displays simple text or displays all window parts set by a previous SB_SETPARTS message.</p>
<p>
<b>Parameters:</b> If <i>wParam</i> is TRUE, the status bar displays simple text. If <i>wParam</i> is FALSE, the status bar displays multiple parts. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> FALSE if an error occurs.</p>
<h2>Toolbar Windows</h2>
<p>
A toolbar is a horizontal window with buttons that is located at the top of the parent window. Users choose the toolbar buttons to carry out corresponding commands. You can create a toolbar by using the <b>CreateWindowEx</b> or <b>CreateWindow</b> function. You can add, delete, and manage the buttons in the toolbar by using toolbar messages. If you are familiar with toolbars from the Microsoft Foundation Class Library (MFC) or Visual Basic®, you will find the Win32 toolbar control very familiar. If you are not familiar with toolbars, do not despair—they are very easy to implement. Figure 2 shows a simple toolbar with four buttons. You will notice that the first three buttons (numbered so creatively) are placed side by side. There is a small space between the third button and the button with the open door (that's what it is <i>supposed</i> to look like, anyway). This space is called a <i>separator</i> and is used to logically group buttons on the toolbar.</p>
<p>
<img src="commctl2_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Example of a simple toolbar</b></p>
<h3>Toolbar Styles and Default Behavior</h3>
<p>
The window procedure for the toolbar automatically positions and sets the size of the toolbar window. By default, the toolbar appears at the top of its parent window's client area; however, you can place the toolbar at the bottom of the client area by specifying CCS_BOTTOM.</p>
<p>
The only new window style associated with the new toolbar control is TBSTYLE_TOOLTIPS. This new style allows the toolbar to display ToolTips (that neat little box that pops up when you rest the mouse cursor on a toolbar button). The system will send a WM_NOTIFY message to the toolbar whenever it needs to display text in a pop-up. The code example below shows the implementation of the ToolTips feature.</p>
<h3>Creating a Toolbar Window</h3>
<p>
As mentioned above, creating a toolbar is simple: You fill out a button structure, create a large bitmap containing the buttons, then call the <b>CreateWindowEx</b> function, specifying the TOOLBARCLASSNAME style. Once the toolbar is created, you need to send messages to add the buttons and bitmaps to the toolbar. Then, unless there is something special you want to do, you can just let the system take care of handling the toolbar processing. The following code creates a toolbar, loads the bitmaps for the toolbar, and adds the buttons to the toolbar.</p>
<pre><code>// Fill out a structure describing the buttons in the toolbar.
TBBUTTON tbButtons[] = {
 &nbsp; { 0, IDM_OPT1, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
 &nbsp; { 1, IDM_OPT2, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
 &nbsp; { 2, IDM_OPT3, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
 &nbsp; { 0, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, -1},
 &nbsp; { 3, IDM_EXIT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0}
};

// Declare a bitmap structure if working under Win32.
TBADDBITMAP tbBitamps;

// Initialize the members.
.
.
.
tbBitamps.hInst = hInstance; // current instance
tbBitmaps.nID = IDB_TOOLBAR; // ID of the bitmap resource
.
.
.
// Function that creates a Win32 toolbar.
// Parameters:
//&nbsp;&nbsp;&nbsp; HWND hWndParent - Handle to the parent window.
//&nbsp;&nbsp;&nbsp; LONG lNumBitmaps - Number of bitmaps for the toolbar.
//&nbsp;&nbsp;&nbsp; TBADDBITMAP tbBItmaps - Bitmap structure for Win32.
//&nbsp;&nbsp;&nbsp; LONG lNumButtons - Number of buttons on the toolbar.
//&nbsp;&nbsp;&nbsp; TBBUTON tbButtons - Pointer to button structure.
//&nbsp;&nbsp;&nbsp; DWORD dwStyle - Special toolbar window styles. Can be a combination
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of generic common control styles or specific toolbar styles.
//&nbsp;&nbsp;&nbsp; int iToolBarID - ID for the toolbar window.
// Returns:
//&nbsp;&nbsp;&nbsp; Handle to the toolbar window if successful; otherwise NULL.
//
HWND MyCreateTooolBar ( HWND hWndParent, LONG lNumBitmaps, TBADDBITMAP tbBitmaps, LONG lNumButtons, TBBUTON tbButtons, WORD wStyle, UINT uToolBarID )
{
  HWND hWndToolBar;

  // Create the toolbar control.
  hWndToolBar = CreateWindowEx( 0L,&nbsp;&nbsp; // No extended styles.
 &nbsp;&nbsp; TOOLBARCLASSNAME,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Class name for the toolbar.
 &nbsp;&nbsp; "",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No default text.
 &nbsp;&nbsp; WS_CHILD | WS_BORDER | WS_VISIBLE | dwStyle,&nbsp;&nbsp;&nbsp; // Styles and defaults.
 &nbsp;&nbsp; 0, 0, 100, 30,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Standard toolbar size and position.
 &nbsp;&nbsp; hWndParent,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Parent window of the toolbar.
 &nbsp;&nbsp; (HMENU)iToolBarID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Toolbar ID.
 &nbsp;&nbsp; tbBitmaps-&gt;hInst,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Current instance.
 &nbsp;&nbsp; NULL );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No class data.

  if (hWndToolBar)
  {
 &nbsp;&nbsp; // Load the bitmaps for the toolbar.
 &nbsp;&nbsp; if (SendMessage(hWndToolBar, TB_ADDBITMAP, lNumBitmaps, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LONG) &amp;tbBitmaps) == -1)&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (NULL);
 &nbsp;&nbsp; // Add the buttons to the toolbar.
 &nbsp;&nbsp; SendMessage(hWndToolBar, TB_ADDBUTTONS, lNumButtons, (LONG) &amp;tbButtons);
 &nbsp;&nbsp; // The toolbar was created with the buttons successfully.
 &nbsp;&nbsp; // Return the handle to the toolbar.
 &nbsp;&nbsp; return (hWndToolBar);
  }
  // There was an error creating the toolbar; return NULL.
  return NULL;
}
</code></pre>
<p>
Another method of creating a toolbar is to call the <b>CreateToolBarEx</b> function. This function performs the same actions that I outlined above in <b>MyCreateToolBar</b>. The <b>CreateToolBarEx</b> function takes the following parameters:
<ul type=disc>
<li>
<b>HWND</b> <i>hwnd</i>: Handle to the parent window for the toolbar.<br><br></li>
<li>
<b>DWORD</b> <i>ws</i>: The window styles for the toolbar.<br><br></li>
<li>
<b>WORD</b> <i>wID</i>: The identifier for the toolbar.<br><br></li>
<li>
<b>int</b> <i>nBitmaps</i>: The number of images contained in the bitmap specified by <i>hBMInst</i> and <i>wBMID</i>.<br><br></li>
<li>
<b>HINSTANCE</b> <i>hBMInst</i>: The module instance with the executable file that contains the bitmap resource.<br><br></li>
<li>
<b>WORD</b> <i>wBMID</i>: The resource identifier for the bitmap resource. If <i>hBMInst</i> is NULL, this must be a valid bitmap handle.<br><br></li>
<li>
<b>LPCTTBBUTTON</b> <i>lpButtons</i>: The address of the <b>TBBUTTON</b> structure.<br><br></li>
<li>
<b>int</b> <i>iNumButtons</i>: The number of buttons to add to the toolbar.<br><br></li>
<li>
<b>int</b> <i>dxButton</i>, <i>dyButton</i>: The width and height, in pixels, of the buttons.<br><br></li>
<li>
<b>int</b> <i>dxBitmap</i>, <i>dyBitmap</i>: The width and height, in pixels, of the bitmaps.<br><br></li>
<li>
<b>UINT</b> <i>uStructSize</i>: The size of the <b>TBBUTTON</b> structure.</li>
</ul>
<p>
You can add ToolTips support to your toolbar by specifying the TBSTYLE_TOOLTIPS style and creating a <b>STRINGTABLE</b> that contains the text to display in your .RC file. Once you have done this, you process the WM_NOTIFY message that is sent to the parent window procedure of the toolbar, as shown in the code below.</p>
<pre><code>// This code goes in your .RC file.
STRINGTABLE
BEGIN
 &nbsp;&nbsp; IDM_OPT1, "Option 1"
 &nbsp;&nbsp; IDM_OPT2, "Option 2"
 &nbsp;&nbsp; IDM_OPT3, "Option 3"
 &nbsp;&nbsp; IDM_EXIT, "Exit Tool bar Sample"
END

// This code goes in your .C file.
TOOLINFO tbToolInfo;

// Trap the WM_NOTIFY message.
case WM_NOTIFY:
 &nbsp;&nbsp; lpToolTipText = (LPTOOLTIPTEXT)lParam;
 &nbsp;&nbsp; if (lpToolTipText-&gt;hdr.code ==&nbsp; TTN_NEEDTEXT)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the system needs text, load it from the resource.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadString (hInst, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpToolTipText-&gt;hdr.idFrom,&nbsp;&nbsp;&nbsp; // string ID == cmd ID
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szBuf,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(szBuf));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Point the structure to the string.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpToolTipText-&gt;lpszText = szBuf;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; break;
</code></pre>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="2306">
</OBJECT><a href="javascript:sample2.Click()">To see how the code above behaves, click to open the Toolbar project files and run TOOLBAR.EXE.</a></p>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;The Toolbar executable file was built and tested using the Windows 95 Preliminary Development Kit. The executable will run only on Windows 95; it will not run under Windows 3.1 or Windows NT 3.5. If you have Windows 95 installed on your computer but you have problems running this sample, copy the project files to your system, rebuild the project, and run the executable.</p>
<h3>Toolbar Structures</h3>
<p>
This section describes the new structures that you can use in Win32 to create and manipulate toolbars and their buttons. Each button that you add to a toolbar can have one of the styles listed in the table below. These button styles can be used in combination and are included in the <b>TBBUTTON</b> structure described below.</p>
<p class=label>
<b>Table 2. Toolbar Button Styles</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=31%><b>Style</b></td>
<td class=label width=69%><b>Use</b></td>
</tr>
<tr valign=top>
<td width=31%>TBSTYLE_BUTTON</td>
<td width=69%>Creates a standard button.</td>
</tr>
<tr valign=top>
<td width=31%>TBSTYLE_CHECK</td>
<td width=69%>Creates a button that stays pressed until released.</td>
</tr>
<tr valign=top>
<td width=31%>TBSTYLE_CHECKGROUP</td>
<td width=69%>Creates a checked button that stays pressed until released or until another button in the group is pressed.</td>
</tr>
<tr valign=top>
<td width=31%>TBSTYLE_GROUP</td>
<td width=69%>Creates a checked button that stays pressed until another button in the group is pressed.</td>
</tr>
<tr valign=top>
<td width=31%>TBSTYLE_SEP</td>
<td width=69%>Creates a separator, which provides a small gap between button groups.</td>
</tr>
</table><br>
<p>
Once you specify your toolbar and its buttons, you may need to query the toolbar for information about the current state of a button. The current state is kept in a <b>TBBUTTON</b> structure, as described below. If you need to determine the state of a button dynamically, you can send the TB_GETSTATE message to the toolbar.</p>
<p class=label>
<b>Table 3. Toolbar Button States</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=36%><b>State</b></td>
<td class=label width=64%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=36%>TBSTATE_CHECKED</td>
<td width=64%>The button is checked.</td>
</tr>
<tr valign=top>
<td width=36%>TBSTATE_ENABLED</td>
<td width=64%>The button is enabled.</td>
</tr>
<tr valign=top>
<td width=36%>TBSTATE_HIDDEN</td>
<td width=64%>The button is hidden.</td>
</tr>
<tr valign=top>
<td width=36%>TBSTATE_INDETERMINATE</td>
<td width=64%>The button is indeterminate.</td>
</tr>
<tr valign=top>
<td width=36%>TBSTATE_PRESSED</td>
<td width=64%>The button is pressed.</td>
</tr>
</table><br>
<h4>TBBUTTON </h4>
<pre><code>typedef struct tagTBBUTTON {
 &nbsp;&nbsp; int iBitmap;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the bitmap image of the button
 &nbsp;&nbsp; int idCommand;&nbsp;&nbsp;&nbsp;&nbsp; \\ command identifier of the button
 &nbsp;&nbsp; BYTE fsState;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ button state flags, as listed in Table 3
 &nbsp;&nbsp; BYTE fsStyle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ button style, as listed in Table 2
 &nbsp;&nbsp; DWORD dwData;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ application-defined data
 &nbsp;&nbsp; int iString;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ index of the help text string for the button
} TBBUTTON;
</code></pre>
<p>
The <b>TBBUTTON</b> structure contains information about a button in a toolbar. <b>TBBUTTON</b> includes the following members:
<ul type=disc>
<li>
<b>int</b> <i>iBitmap</i>: Zero-based index that identifies the location of the button image in the bitmap.<br><br></li>
<li>
<b>int</b> <i>idCommand</i>: Command identifier associated with the button. This identifier is used in a WM_COMMAND message when the button is pressed. This member must be zero if the <i>fsStyle</i> member is TBSTYLE_SEP.<br><br></li>
<li>
<b>BYTE</b> <i>fsState</i>: Button state flags. This can be a combination of the values listed in Table 3.<br><br></li>
<li>
<b>BYTE</b> <i>fsStyle</i>: Button style flags. This can be a combination of the values listed in Table 2.<br><br></li>
<li>
<b>DWORD</b> <i>dwData</i>: Application-defined value.<br><br></li>
<li>
<b>int</b> <i>iString</i>: Index of the help text string in the string list for the button.</li>
</ul>
<h4>ADJUSTINFO</h4>
<pre><code>typedef struct tagADJUSTINFO {
 &nbsp;&nbsp; TBBUTTON tbButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ structure containing button information
 &nbsp;&nbsp; char szDescription[1];&nbsp;&nbsp;&nbsp; \\ TBD
};
</code></pre>
<p>
The <b>ADJUSTINFO</b> structure contains information about a button in a toolbar that is being customized by the user. The structure includes the following members:
<ul type=disc>
<li>
<b>TBBUTTON</b> <i>tbButton</i>: A structure that contains information about a button.<br><br></li>
<li>
<b>char</b> <i>szDescription</i>: The use of this member has not been determined yet.</li>
</ul>
<h4>TBADDBITMAP</h4>
<pre><code>typedef struct tagTBADDBITMAP {
 &nbsp;&nbsp; HINSTANCE hInst;&nbsp;&nbsp;&nbsp; \\ handle to the instance containing the bitmaps
 &nbsp;&nbsp; UINT nID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ resource identifier for the bitmap
} TBADDBITMAP;
</code></pre>
<p>
The <b>TBADDBITMAP</b> structure contains information about the bitmaps to add to a toolbar. It is used when writing a Win32 application. <b>TBADDBITMAP</b> includes the following members:
<ul type=disc>
<li>
<b>HINSTANCE</b> <i>hInst</i>: Handle to the instance that contains the bitmaps.<br><br></li>
<li>
<b>UINT</b> <i>nID</i>: Resource identifier for the bitmap.</li>
</ul>
<h3>Toolbar Messages</h3>
<p>
The system and applications send messages to toolbars, just as they send messages to any other window. This section lists the messages that can be sent to toolbar controls and the values for the <i>wParam</i> and <i>lParam</i> for each message. </p>
<h4>TB_ADDBITMAP</h4>
<pre><code>wParam = nButtons;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ number of buttons in the bitmap
lParam = (LPTBADDBITMAP)lptbab;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ handle of the bitmap
</code></pre>
<p>
<b>Description:</b> The TB_ADDBITMAP message adds a new bitmap to the list of bitmaps available for a toolbar. This message is for non-Win32 applications only.</p>
<p>
<b>Parameters:</b> <i>wParam</i> represents the number of buttons in the bitmap. <i>lParam</i> is a pointer to the <b>TBADDBITMAP</b> structure.</p>
<p>
<b>Return value:</b> The low-order word contains the index of the first button bitmap. The high-order word is not used if the call is successful; otherwise, the low-order word is –1.</p>
<h4>TB_ADDBUTTONS</h4>
<pre><code>wParam = nButtons;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ number of buttons
lParam = (LPTBBUTTON)lpButtons;&nbsp;&nbsp; \\ address of array of button structures
</code></pre>
<p>
<b>Description:</b> The TB_ADDBUTTONS message adds one or more buttons to a toolbar.</p>
<p>
<b>Parameters:</b> <i>wParam</i> represents the number of buttons to add to the toolbar. <i>lParam</i> is the address of an array of <b>TBBUTTON</b> structures containing information about the buttons to add. The array must contain the same number of elements as buttons specified by <i>wParam</i>.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>TB_ADDSTRING</h4>
<pre><code>wParam = (HINSTANCE)hInst;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ module instance containing the string
lParam = (MAKELONG)(idString, 0); \\ string identifier or string buffer
</code></pre>
<p>
<b>Description:</b> The TB_ADDSTRING message adds a new string to the list of strings available for a toolbar.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the handle of the module instance with an executable file that contains the string resource. This parameter is zero if <i>lParam</i> points to one or more strings. <i>lParam</i> is the resource identifier for the string resource or the address of a buffer that contains one or more null-terminated strings to add to the list, depending on the value of <i>wParam</i>. The last string must be terminated with two NULL characters.</p>
<p>
<b>Return value:</b> The index of the first new string if successful; otherwise –1.</p>
<h4>TB_AUTOSIZE</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TB_AUTOSIZE message causes a toolbar to be resized. An application sends this message whenever it does something (sets the button or bitmap size or adds strings) to change the size of a toolbar.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> None.</p>
<h4>TB_BUTTONCOUNT</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TB_BUTTONCOUNT message gets a count of the buttons currently in the toolbar.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> The number of buttons in the toolbar.</p>
<h4>TB_BUTTONSTRUCTSIZE</h4>
<pre><code>wParam = cb;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ size of the TBBUTTON structure in bytes
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TB_BUTTONSTRUCTSIZE specifies the size of the <b>TBBUTTON</b> structure. The system uses this size to determine the version of COMMCTRL.DLL that is being used. If an application uses <b>CreateWindow</b> to create the toolbar, it must send this message before adding any buttons to the toolbar. The <b>CreateToolBarEx</b> function automatically sends this message, and the size of the <b>TBBUTTON</b> structure is a parameter to the <b>CreateToolbarEx</b> function.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the size, in bytes, of the <b>TBBUTTON</b> structure. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> None.</p>
<h4>TB_CHECKBUTTON</h4>
<pre><code>wParam = idButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ command identifier of the button to check
lParam = MAKELONG(fCheck, 0);&nbsp; \\ Check flag - TRUE to add, FALSE to remove
</code></pre>
<p>
<b>Description:</b> The TB_CHECKBUTTON message checks or unchecks a given button. When a button has been checked, it appears pressed. </p>
<p>
<b>Parameters:</b> <i>wParam</i> is the command identifier of the button to check. If <i>lParam</i> is TRUE, the check is added; if <i>lParam</i> is FALSE, the check is removed.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>TB_COMMANDTOINDEX</h4>
<pre><code>wParam = idButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ command identifier of the button
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TB_COMMANDTOINDEX message gets the zero-based index for the button associated with the specified command identifier.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the command identifier associated with the button. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> The zero-based index for the button.</p>
<h4>TB_CUSTOMIZE</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TB_CUSTOMIZE message displays the Customize Toolbar dialog box.</p>
<p>
<b>Parameters:</b> <i>wParam</i> and <i>lParam</i> are not used.</p>
<p>
<b>Return value:</b> None.</p>
<h4>TB_DELETEBUTTON</h4>
<pre><code>wParam = iButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ zero-based index of the button to delete
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TB_DELETEBUTTON message deletes a button from the toolbar.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the zero-based index of the button to delete. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>TB_ENABLEBUTTON</h4>
<pre><code>wParam = idButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ command identifier of the button
lParam = MAKELONG(fEnable, 0);&nbsp;&nbsp; \\ flag - TRUE to enable, FALSE to disable
</code></pre>
<p>
<b>Description:</b> The TB_ENABLEBUTTON message enables or disables the specified button. When a button has been enabled, it can be pressed and checked.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the command identifier of the button to enable or disable. If <i>lParam</i> is TRUE, the button is enabled; if <i>lParam</i> is FALSE, the button is disabled.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>TB_GETBUTTON</h4>
<pre><code>wParam = iButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ zero-based index of the button to get
lParam = (LPTBBUTTON)lpButton;&nbsp;&nbsp; \\ buffer that receives the button information
</code></pre>
<p>
<b>Description:</b> The TB_GETBUTTON message retrieves information about the given button.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the zero-based index of the button for which to get information. <i>lParam</i> is the address of the <b>TBBUTTON</b> structure that receives the button information.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>TB_GETITEMRECT</h4>
<pre><code>wParam = iButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ zero-based index of the button
lParam = (LPRECT)lprc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ array that receives the rectangle values
</code></pre>
<p>
<b>Description:</b> The TB_GETITEMRECT message gets the bounding rectangle of a button in a toolbar. This message does not get the bounding rectangle for buttons whose state is set to TBSTATE_HIDDEN. </p>
<p>
<b>Parameters:</b> <i>wParam</i> is the zero-based index of the button for which to get information. <i>lParam</i> is the address of a <b>RECT</b> structure that receives the coordinates of the bounding rectangle.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>TB_GETSTATE</h4>
<pre><code>wParam = idButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ command identifier of the button
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> The TB_GETSTATE message gets information about the state of the button, such as whether it is enabled, pressed, or checked.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the command identifier of the button for which to get information. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> If the call is successful, the message returns the button state information as listed in Table 3. If the call is not successful, the message returns –1.</p>
<h4>TB_HIDEBUTTON</h4>
<pre><code>wParam = idButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ command identifier of the button
lParam = MAKELONG(fShow, 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ TRUE to show and FALSE to hide
</code></pre>
<p>
<b>Description:</b> The TB_HIDEBUTTON message hides or shows the specified button.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the command identifier of the button to hide or show. If <i>lParam</i> is TRUE, the button is hidden; if <i>lParam</i> is FALSE, the button is shown.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise. </p>
<h4>TB_INDETERMINATE</h4>
<pre><code>wParam = idButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ command identifier of the button
lParam = MAKELONG(fIndeterminate, 0);&nbsp; \\ TRUE to set and FALSE to clear
</code></pre>
<p>
<b>Description:</b> The TB_INDETERMINATE message sets or clears the indeterminate state of the specified button.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the command identifier of the button whose indeterminate state is to be set or cleared. If <i>lParam</i> is TRUE, the indeterminate state is set; if <i>lParam</i> is FALSE, the indeterminate state is cleared.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>TB_INSERTBUTTON</h4>
<pre><code>wParam = iButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ zero-based index of the button
lParam = (LPTBBUTTON)lpButton;&nbsp;&nbsp;&nbsp; \\ button information structure
</code></pre>
<p>
<b>Description:</b> The TB_INSERTBUTTON message inserts a button in the toolbar.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the zero-based index of a button. The TB_INSERTBUTTON message inserts the new button in front of the button identified by <i>wParam</i>. <i>lParam</i> is the address of a <b>TBBUTTON</b> structure containing information about the button to insert.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>TB_ISBUTTONCHECKED, TB_ISBUTTONENABLED, TB_ISBUTTONHIDDEN, TB_ISBUTTONINDETERMINATE, TB_ISBUTTONPRESSED</h4>
<pre><code>wParam = idButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ command identifier of the button
lParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
</code></pre>
<p>
<b>Description:</b> These messages determine whether the given button is checked, enabled, hidden, indeterminate, or pressed.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the command identifier of the button. <i>lParam</i> is not used.</p>
<p>
<b>Return value:</b> Nonzero if the button if TRUE; otherwise, returns zero.</p>
<h4>TB_PRESSBUTTON</h4>
<pre><code>wParam = idButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ command identifier of the button
lParam = MAKELONG(fPress, 0);&nbsp;&nbsp;&nbsp;&nbsp; \\ TRUE to press and FALSE to release
</code></pre>
<p>
<b>Description:</b> The TB_PRESSBUTTON message presses or releases the given button.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the command identifier of the button to press or release. If <i>lParam</i> is TRUE, the button is pressed; if <i>lParam</i> is FALSE, the button is released.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>TB_SAVERESTORE</h4>
<pre><code>wParam = (BOOL)fSave;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ TRUE to save and FALSE to restore
lParam = (LPSTR)lpszSectionFile;&nbsp; \\ strings used to save the information
</code></pre>
<p>
<b>Description:</b> The TB_SAVERESTORE message saves or restores the state of the toolbar.</p>
<p>
<b>Parameters:</b> If <i>wParam</i> is TRUE, the information is saved; otherwise, it is restored. <i>lParam</i> is the address of two consecutive null-terminated strings. The first string specifies the name of a section in an initialization file. The second string specifies the name of the initialization file. If the second string is empty, the message uses the WIN.INI file by default.</p>
<p>
<b>Return value:</b> None.</p>
<h4>TB_SETBITMAPSIZE</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = MAKELONG(dxBitmap, dyBitmap);&nbsp;&nbsp; \\ width and height to set
</code></pre>
<p>
<b>Description:</b> The TB_SETBITMAPSIZE message sets the size of the bitmapped images to be added to a toolbar. The size can be set only before adding any bitmaps to the toolbar. If an application does not explicitly set the bitmap size, the size defaults to 16-by-15 pixels.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> is the width and height, in pixels, of the bitmapped images.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>TB_SETBUTTONSIZE</h4>
<pre><code>wParam = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ not used
lParam = MAKELONG(dxButton, dyButton); \\ width and height to set
</code></pre>
<p>
<b>Description:</b> The TB_SETBUTTONSIZE message sets the size of the buttons to be added to a toolbar. You can set the button size only before you add any buttons to the toolbar. If an application does not explicitly set the button size, the size defaults to 24-by-22 pixels.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is not used. <i>lParam</i> is the width and height, in pixels, of the buttons.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h4>TB_SETSTATE</h4>
<pre><code>wParam = idButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ command identifier of the button
lParam = MAKELONG(fState,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ state to set as listed in Table 3
</code></pre>
<p>
<b>Description:</b> The TB_SETSTATE message sets the state for the given button.</p>
<p>
<b>Parameters:</b> <i>wParam</i> is the command identifier of the button. <i>lParam</i> consists of the state flags, as listed in Table 3.</p>
<p>
<b>Return value:</b> TRUE if successful; FALSE otherwise.</p>
<h3>Toolbar Notification Messages</h3>
<p>
This section lists the notification messages that Windows sends to toolbar windows. The parent window of the toolbar receives these messages via a WM_COMMAND message. Unless otherwise noted, Windows ignores the return value from these messages. In all cases, the <i>wParam</i> contains the identifier for the toolbar.</p>
<p class=label>
<b>Table 4. Toolbar Notification Messages</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=28%><b>Message</b></td>
<td class=label width=48%><b>Description</b></td>
<td class=label width=24%><b>lParam</b></td>
</tr>
<tr valign=top>
<td width=28%>TBN_ADJUSTINFO</td>
<td width=48%>Sent when the user is customizing a toolbar. Returns a handle to a global memory object containing an <b>ADJUSTINFO</b> structure.</td>
<td width=24%>Button index</td>
</tr>
<tr valign=top>
<td width=28%>TBN_BEGINADJUST</td>
<td width=48%>Sent when the user begins customizing a toolbar.</td>
<td width=24%>0—not used</td>
</tr>
<tr valign=top>
<td width=28%>TBN_BEGINDRAG</td>
<td width=48%>Sent when the user begins dragging a button in a toolbar.</td>
<td width=24%>Button command ID </td>
</tr>
<tr valign=top>
<td width=28%>TBN_CUSTHELP</td>
<td width=48%>Sent when the user chooses the Help button in the Customize Toolbar dialog box.</td>
<td width=24%>Customize Toolbar dialog box handle</td>
</tr>
<tr valign=top>
<td width=28%>TBN_ENDADJUST</td>
<td width=48%>Sent when the user finishes customizing a toolbar.</td>
<td width=24%>0—not used</td>
</tr>
<tr valign=top>
<td width=28%>TBN_ENDDRAG</td>
<td width=48%>Sent when the user stops dragging a button in a toolbar.</td>
<td width=24%>Button command ID</td>
</tr>
<tr valign=top>
<td width=28%>TBN_QUERYDELETE</td>
<td width=48%>Sent when the user attempts to delete a button while customizing a toolbar. Returns TRUE to delete the button, or FALSE to prevent the button from being deleted.</td>
<td width=24%>Button index</td>
</tr>
<tr valign=top>
<td width=28%>TBN_QUERYINSERT</td>
<td width=48%>Sent when the user attempts to insert a button while customizing a toolbar. Returns TRUE to insert the new button in front of the given button, or FALSE to prevent the button from being inserted.</td>
<td width=24%>Button index</td>
</tr>
<tr valign=top>
<td width=28%>TBN_RESET</td>
<td width=48%>Sent when the user resets a customized toolbar.</td>
<td width=24%>0—not used</td>
</tr>
<tr valign=top>
<td width=28%>TBN_TOOLBARCHANGE</td>
<td width=48%>Sent when the user has customized a toolbar.</td>
<td width=24%>Toolbar handle</td>
</tr>
</table><br>
<h2>Summary</h2>
<p>
Status bars and toolbars are very handy controls that are familiar to users and easy to implement. These controls are built into Windows 95, so you will no longer have to worry about whether your toolbar or status bar conforms to the way the operating system or other companies implement these controls. If you are planning to add status bars or toolbars to your existing application, I suggest that you give these new common controls a try. Adding value to your application can hardly get any easier than this. </p>
</BODY>
</HTML>
