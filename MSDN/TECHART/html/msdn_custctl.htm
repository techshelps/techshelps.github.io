<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Simple Custom Controls for 32-Bit Visual C++ Applications</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_custctl"></a></sup>Simple Custom Controls for 32-Bit Visual C++ Applications</h1>
<p>
Nigel Thompson<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: September 27, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3016">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the FWTEST sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article is a follow-on to my previous article, <a href="msdn_dlgbar.htm">"Using CDialogBar in 32-Bit MDI Applications."</a> It describes a simple way to include custom controls in an application without having to create a separate dynamic-link library (DLL) for each control. Applications built using the techniques described here can be shipped as a single .EXE file without additional DLLs for the controls.</p>
<p>
The FWTEST sample application that accompanies the article includes examples of two different Control Panel-like windows. One window uses standard Microsoft® Windows® controls and is discussed in "Using CDialogBar in 32-Bit MDI Applications." The other window uses a variety of custom controls and is discussed here. The window that uses custom controls also uses a 256-color palette.</p>
<p>
The key points discussed are:
<ul type=disc>
<li>
Owner-drawn buttons<br><br></li>
<li>
Custom controls<br><br></li>
<li>
Handling CBN_SELCHANGE notification messages in combo boxes that have the CBS_DROPDOWNLIST style<br><br></li>
<li>
Using a palette with dialog box panels</li>
</ul>
<h2>Introduction</h2>
<p>
The standard Microsoft® Windows® controls are functional, but rather mundane. If you want controls that look more like those on a scientific instrument, for example, you need to be able to create a custom control of your own design. In the past, creating custom controls has been, shall we say, challenging? OK, let's not. Let's say "very difficult." Part of the problem is that custom controls apparently need to be in separate dynamic-link libraries (DLLs)—one DLL per control. This is not really the case unless you have a need to be able to see the controls correctly in the dialog box editor. If you can tolerate seeing a simple black rectangle in the dialog box editor, you don't need to have your custom controls in separate DLLs at all. They can be built into the application as C++ classes.</p>
<p>
My previous article, <a href="msdn_dlgbar.htm">"Using CDialogBar in 32-Bit MDI Applications,"</a> describes how a variant of the <b>CDialogBar</b> class can be used to create simple control panel windows. Now we'll see how to expand on that work so as to include our own custom controls in those control panels.</p>
<h2>Control Panels with Custom Controls</h2>
<p>
When you look at Figure 1, do you say "Yes, that's the kind of control I need!" or are you more of a "Ho hum, hardware stuff" kind of person? If you belong to the former category, I'm sure you'll be wondering exactly what I'm using this particular control panel for. Well, keep up the Development Library subscriptions, and you'll find out soon. (This part paid for by our marketing department.)</p>
<p>
<img src="custctl_1.gif" border=0></p>
<p class=label>
<b>Figure 1. A control panel that uses several panels and custom controls</b></p>
<p>
The control panel in Figure 1 is constructed from three separate dialog box panels and a separate window class for the screen in the center. The colors in the screen belong to a color cube palette used by the entire application. The control panels use two types of custom controls (one each for the position and scale controls) and an owner-drawn button. So you're really getting your money's worth here! Each panel uses the <b>CDlgPanel </b>class developed in <a href="msdn_dlgbar.htm">"Using CDialogBar in 32-Bit MDI Applications."</a></p>
<p>
Note, too, that the screen and custom controls make use of classes I developed for my animation library. The entire source for this library can be found in the ANIMATE sample.</p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3014">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the ANIMATE library. </a></p>
<p>
The ANIMATE library includes a Help file that documents each class in the library.</p>
<h2>Owner-Drawn Buttons</h2>
<p>
Buttons are extremely useful in any dialog box, but the Windows standard button isn't quite what you might want all of the time. The Microsoft Foundation Class Library (MFC) classes include <b>CBitmapButton</b>, which is a little bit more flexible, but for that all-out approach, we really need to draw our own.</p>
<p>
The oscilloscope in Figure 1 uses owner-drawn buttons for the ground (labeled GND) controls. When pushed, they stay in and light up yellow to show they are on. Users of Tektronix oscilloscopes will have little problem in guessing where I got this idea from. </p>
<p>
The buttons are added to the dialog template using App Studio in the usual way. Check the Owner Draw check box to tell the dialog box manager code that you will be drawing it yourself. All you need to do now is add a handler for WM_DRAWITEM messages to the frame window. The frame window for the oscilloscope in Figure 4 is in the SCOPEFRA.H and SCOPEFRA.CPP files of the FWTEST sample. Here's the code that handles the WM_DRAWITEM messages:</p>
<pre><code>void CScopeFrame::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
 &nbsp;&nbsp; switch (nIDCtl) {
 &nbsp;&nbsp; case IDC_A_GND:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawYButton(&amp;m_A, lpDrawItemStruct);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case IDC_B_GND:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawYButton(&amp;m_B, lpDrawItemStruct);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp; }
}
</code></pre>
<p>
The ID of the control is used to determine which control is being drawn. A generic handler then draws the control:</p>
<pre><code>void CScopeFrame::DrawYButton(YCHANNEL* pCh, DRAWITEMSTRUCT* pDI)
{
 &nbsp;&nbsp; switch (pDI-&gt;itemAction) {
 &nbsp;&nbsp; case ODA_DRAWENTIRE:
 &nbsp;&nbsp; case ODA_SELECT: {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a CDC object.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDC dc;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.Attach(pDI-&gt;hDC);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw the black rectangle around the outside
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and fill the center with either the off or on color.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CBrush brCenter;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pCh-&gt;bGnd) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brCenter.CreateSolidBrush(PALETTERGB(255,255,0));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brCenter.CreateSolidBrush(PALETTERGB(192,192,192));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CBrush* pbrOld = dc.SelectObject(&amp;brCenter);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.Rectangle(pDI-&gt;rcItem.left,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.top,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.right,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.bottom);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Done with the brush now.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.SelectObject(pbrOld);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPen penShadow(PS_SOLID, 1, PALETTERGB(128,128,128));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPen* ppenOld = dc.SelectObject(&amp;penShadow);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pDI-&gt;itemState &amp; ODS_SELECTED) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.MoveTo(pDI-&gt;rcItem.left+1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.bottom-2);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.LineTo(pDI-&gt;rcItem.left+1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.top+1);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.LineTo(pDI-&gt;rcItem.right-2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.top+1);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.MoveTo(pDI-&gt;rcItem.right-2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.top+2);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.LineTo(pDI-&gt;rcItem.right-2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.bottom-2);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.LineTo(pDI-&gt;rcItem.left+1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.bottom-2);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!pCh-&gt;bGnd) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPen penHighlight(PS_SOLID, 1, PALETTERGB(255,255,255));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.SelectObject(&amp;penHighlight);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.MoveTo(pDI-&gt;rcItem.left+1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.bottom-2);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.LineTo(pDI-&gt;rcItem.left+1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.top+1);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.LineTo(pDI-&gt;rcItem.right-2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDI-&gt;rcItem.top+1);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Done with pens.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.SelectObject(ppenOld);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } break;
 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }
}
</code></pre>
<p>
We don't have any keyboard interface to these buttons, so there is no code to draw a focus rectangle. We also don't differentiate between requests to change the selection state and requests to draw the entire control. We always draw the control in the appropriate state, the state of the control being determined by variables in the application (in the <b>YCHANNEL</b> structure in this case). Most of the drawing consists of single-pixel wide lines used to construct the highlights and borders of the control. A <b>Rectangle</b> call draws the center in either gray or yellow, depending on the button state.</p>
<h2>Custom Controls</h2>
<p>
What do you do when a fancy button won't cut it and a combo box is too nerdy? Time for a custom control. In the past, this has also meant that it is also time for a stress pill and a lot of digging through the literature, the best of which is Kyle Marsh's article "Developing Custom Controls for the Dialog Editor” (MSDN Library Archive, Technical Articles)</p>
<p>
In order to have custom controls work with the Dialog Editor, they each had to be in individual DLLs. This is a nightmare if you are shipping a single application with 27 custom controls. So I thought we'd avoid that and find a way that lets you build them all into the application. (Is that cheering I hear?) The only side effect is that, when you insert one of these custom controls into a dialog box template using App Studio, you get a black rectangle instead of the control's image. Figure 2 shows how this looks for one of the oscilloscope's control panels.</p>
<p>
<img src="custctl_2.gif" border=0></p>
<p class=label>
<b>Figure 2. One of the oscilloscope's control panels in App Studio</b></p>
<p>
As you can see from Figure 2, the control has an ID value (in this case, IDC_A_POS) and a specific class (in this case, Rotary). Note that Rotary is <i>not</i> its C++ class name but rather the name of the registered window class for this control. We'll look at how that gets registered later. You can also manually set the style bits of the control if you want something more than the standard Windows child control bits. OK, so this isn't too graceful in the editing sense, but it's not bad, given that we don't need to create a DLL. Now let's look at how the Rotary control is implemented in ROTARY.H and ROTARY.CPP.</p>
<h2>The Rotary Control</h2>
<p>
Just before we get into how the rotary control is implemented, let me point out that, as with the legendary skinning of cats, there is more than one way to implement a rotary control. I wanted the control to be resizable, so I elected to draw the control using scalable GDI operations. You could create a much nicer looking control by using a set of bitmaps created by a paint program or even by scanning a picture of a real control knob. Bitmap images are not (in any practical sense) resizable, so I have not used them here.</p>
<h3>Getting the Class Established</h3>
<p>
The only interesting problem in creating a simple custom control is how to register the Windows class name of the control without a lot of messy code in the class that actually implements the control. The simplest way that I have found is to create a static member of the control's class that gets initialized as the application starts up. The initialization of this member variable is done by a static member function, and it is in this function that we can register the window class. Let's have a look at the parts of the class header file that define these static member items (from ROTARY.H):</p>
<pre><code>class CRotaryCtl : public CWnd
{
 &nbsp; ...
 &nbsp; static BOOL Register();
 &nbsp; ...
 &nbsp; static BOOL m_bRegistered;
 &nbsp; ...
};

#ifdef __cplusplus
extern "C" {
#endif
LRESULT CALLBACK RotaryWndProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
#ifdef __cplusplus
}
#endif
</code></pre>
<p>
As you can see, there is a single static member variable, <b>m_bRegistered</b>, and a single static member function, <b>Register</b>. Also defined is a regular C function, <b>RotaryWndProc</b>, which is the window procedure for the class we will register.</p>
<p>
Now let's see the bits of the code in ROTARY.CPP that handle the initialization:</p>
<pre><code>BOOL CRotaryCtl::m_bRegistered = Register();
</code></pre>
<p>
The first step is to initialize the <b>m_bRegistered</b> variable. The variable itself serves only one purpose: to force the <b>Register</b> function to be called when the application is initialized. So let's see what <b>Register</b> does:</p>
<pre><code>BOOL CRotaryCtl::Register()
{
 &nbsp;&nbsp; // Register the window class of the control.
 &nbsp;&nbsp; WNDCLASS wc;
 &nbsp;&nbsp; wc.style = CS_GLOBALCLASS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CS_HREDRAW | CS_VREDRAW;
 &nbsp;&nbsp; wc.lpfnWndProc = RotaryWndProc;
 &nbsp;&nbsp; wc.cbClsExtra = 0;
 &nbsp;&nbsp; wc.cbWndExtra = 0;
 &nbsp;&nbsp; wc.hInstance = NULL;
 &nbsp;&nbsp; wc.hIcon = NULL;
 &nbsp;&nbsp; wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
 &nbsp;&nbsp; wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
 &nbsp;&nbsp; wc.lpszMenuName = NULL;
 &nbsp;&nbsp; wc.lpszClassName = "Rotary";

 &nbsp;&nbsp; if (!::RegisterClass(&amp;wc)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; } 
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
After so much C++ code and MFC class usage, it's very nostalgic to see this code again! This is the standard procedure for registering a window class. The key points here are the class name, Rotary, and the window procedure that will be used to handle messages sent to windows of this class, <b>RotaryWndProc</b>.</p>
<p>
So far, we've managed to register the window class name. (You will recall that this name is the one we put in the Class box shown in Figure 2.) Now let's see what the window procedure does and how we can manage to write the rest of the class implementation in C++:</p>
<pre><code>LRESULT CALLBACK RotaryWndProc(HWND hWnd, UINT uiMsg, WPARAM wParam,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPARAM lParam)
{
 &nbsp;&nbsp; switch (uiMsg) {
 &nbsp;&nbsp; case WM_NCCREATE: {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a C++ object to handle the messages.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRotaryCtl* pCtl = new CRotaryCtl;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(pCtl);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Attach the window handle to the new object.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL b = pCtl-&gt;SubclassWindow(hWnd);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(b);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } break;

 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ::DefWindowProc(hWnd, uiMsg, wParam, lParam);
 &nbsp;&nbsp; }
}
</code></pre>
<p>
The object of the exercise here is to create a C++ object to handle window messages for the custom control we are creating. To do this, we must first construct a C++ object of the appropriate class and then somehow tell Windows to send all the messages for the control window to the C++ object. The first message sent to any window when it is initially created is WM_NCCREATE. </p>
<p>
When the dialog manager is constructing a dialog box from a template we have created using App Studio (or other tool), it calls <b>::CreateWindow</b> for each control with the class name for the control. Because we registered the class name of our Rotary control and told Windows to send the control's messages to <b>RotaryWndProc</b>, <b>RotaryWndProc</b> will receive the WM_NCCREATE message when the dialog manager is creating a Rotary custom control. </p>
<p>
As you can see from the code above, the only message that <b>RotaryWndProc</b> handles is WM_NCCREATE. All other messages are sent to <b>::DefWindowProc</b>. When <b>RotaryWndProc</b> receives a WM_NCCREATE message, it first creates a new <b>CRotaryCtl</b> object (which is derived from <b>CWnd</b>) and then calls the object's <b>SubclassWindow</b> function, passing the window handle value from the WM_NCCREATE message. The <b>CWnd::SubclassWindow</b> function forces all other messages for the window to be routed through the <b>CRotaryCtl</b> object's message map. So by calling <b>CWnd::SubclassWindow</b>, we have effectively transferred control of the custom control window to an instance of the <b>CRotaryCtl</b> class. </p>
<p>
There are only two more things we must do to ensure that the control will function correctly (other than actually implementing its painting and so on). The first is to provide an implementation of the <b>CWnd::GetSuperWndProcAddr</b> function:</p>
<pre><code>WNDPROC* CRotaryCtl::GetSuperWndProcAddr()
{
 &nbsp;&nbsp; // Provide a place for MFC's subclassing
 &nbsp;&nbsp; // mechanism to store the super-class pointer.
 &nbsp;&nbsp; static WNDPROC NEAR pfnSuper = NULL;
 &nbsp;&nbsp; return &amp;pfnSuper;
}
</code></pre>
<p>
This function is required as a part of the subclassing mechanism and is used to store the class's super window procedure address. Without this, the MFC subclassing code wouldn't be able to pass messages further up the window hierarchy. The final thing to do is to ensure that we tidy up when the class object is destroyed. This is simplest to implement in a handler for the WM_NCDESTROY message, which is the last message any window ever receives. We could do this in <b>RotaryWndProc</b>, but it's simpler to implement in the <b>CRotaryCtl</b> class:</p>
<pre><code>void CRotaryCtl::OnNcDestroy()
{
 &nbsp;&nbsp; CWnd::OnNcDestroy();
 &nbsp;&nbsp; // Make sure the window was destroyed.
 &nbsp;&nbsp; ASSERT(m_hWnd == NULL);
 &nbsp;&nbsp; // Destroy this object because it won't be destroyed otherwise.
 &nbsp;&nbsp; delete this;
}
</code></pre>
<p>
This function is called after <b>::DestroyWindow</b> has been called to destroy the control window. The only thing to do is to ensure that the C++ object is deleted by simply calling <i>delete this</i>. </p>
<h3>Drawing the Control</h3>
<p>
So far all our work has been for the purpose of simply creating a <b>CRotaryCtl</b> object. Now we need to look at how it's drawn, how it responds to the user, and how it notifies its parent of changes. In addition to all of this, you may remember that I decided that all of my custom controls would use a common palette, so we must make provision for that, too. Inasmuch as we can't draw much without some nice colors, let's look at setting the palette first. Remember that we registered a private message to provide the palette pointer. Here's the handler for the DLGPANELMSG_SETPALETTE message:</p>
<pre><code>LRESULT CRotaryCtl::OnSetPalette(WPARAM wParam, LPARAM lParam)
{
 &nbsp;&nbsp; // A message from the parent telling us what palette to use.
 &nbsp;&nbsp; m_pPal = (CPalette*) lParam;
 &nbsp;&nbsp; ASSERT(m_pPal);
 &nbsp;&nbsp; ASSERT(m_pPal-&gt;IsKindOf(RUNTIME_CLASS(CPalette)));
 &nbsp;&nbsp; // Rebuild the image.
 &nbsp;&nbsp; CreateImage();
 &nbsp;&nbsp; return 0;
}
</code></pre>
<p>
All that happens here is that the pointer to the new palette is saved, and the control is rebuilt to reflect any change that altering the palette might cause. So really we're just saving a pointer to the palette. Creating the final image of the control on the screen is a multistage process. In order to aid performance, as much of the control as possible is drawn when the control is first created, or to be a little more precise, it is drawn when the size of the control is first known. Then when we want to draw the control to the screen, we can simply copy the static parts of the control's image and draw the varying part on top. To prevent flicker of the screen image as the control is drawn, we do all the actual drawing to a buffer and then simply copy the final buffer image to the screen.</p>
<p>
That might seem like a lot of work, and it would be if we were doing it all for the first time. But as they say in all the best cooking programs on TV: "I've got one here that I prepared earlier." And true to form, I'm going to cheat a little bit here and use some classes I have already developed for my animation work. The entire library of these classes is elsewhere in the Development Library in the ANIMATE project. Several of my other articles use this library, and I update it with each CD. The library includes a Help file that describes each class and its functions. For a more in-depth discussion of the classes, please see my book <i>Animation Techniques for Win32: A C++ Programmer's Guide to DIBs, Palettes, and Sprites</i>.</p>
<p>
OK, so back to the plot. Because this control is not rectangular (what real control is?), we will need to grab the image of the background window behind the control, so we can put it back around the control when the control is drawn. Figure 3 shows the order in which all the bits of the control are rendered to update the screen image.</p>
<p>
<img src="custctl_3.gif" border=0></p>
<p class=label>
<b>Figure 3. The steps used to render a change in the control image</b>
<ol>
<li>
The background image is copied to the buffer.<br><br></li>
<li>
The static parts of the control are copied on top of the background image in the buffer.<br><br></li>
<li>
The variable parts of the image (the pointer dot) are drawn on top of the static part of the image in the buffer.<br><br></li>
<li>
The buffer image is copied to the screen device context (DC).</li>
</ol>
<p>
Much of the drawing of the control is done with simple GDI operations. Let's take a look at these operations step by step.</p>
<h3>Grabbing the Background Image</h3>
<p>
Because the control is not rectangular, we need to grab the image of the window behind the control, so we can draw back the bits not obscured by the control itself. There is no general solution to do this, but for these types of controls, it's easiest to grab the background image the first time the control is drawn. When the control first gets a WM_PAINT message, only the background will have been drawn, and the control won't yet (rather obviously). So we can add a little code to the <b>OnPaint</b> function to grab the background image the first time around:</p>
<pre><code>void CRotaryCtl::OnPaint()
{
 &nbsp;&nbsp; ...
 &nbsp;&nbsp; // See if we have grabbed the background image yet.
 &nbsp;&nbsp; if (!m_bGotBackground) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Nope, so do it now.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDC* pdcBackground = m_dsBackground.GetDC();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDC* pdcParent = GetParent()-&gt;GetDC();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRect rc;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetClientRect(&amp;rc);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Find the top-left corner coords in the parent window DC.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPoint pt(rc.left, rc.top);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientToScreen(&amp;pt); // Convert our coords to screen coords.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetParent()-&gt;ScreenToClient(&amp;pt); // Convert to parent's coords.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdcBackground-&gt;BitBlt(0, 0, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.right - rc.left, rc.bottom - rc.top,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdcParent,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pt.x, pt.y,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SRCCOPY);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bGotBackground = TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flush the GDI operations queue before we do the next bit. 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::GdiFlush();

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Now render the entire image to the buffer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Render();
 &nbsp;&nbsp; }
 &nbsp;&nbsp; ...
}
</code></pre>
<p>
The background image is held in a <b>CDIBSurface</b> object, which is a C++ object encapsulating a Windows device-independent bitmap (DIB) structure. A <b>CDIBSurface</b> object has its own optimized <b>BitBlt</b> function that makes use of either <b>CreateDIBSection</b> in Windows NT™ version 3.5 or Windows 95, or uses the WinG library in Win32s™. Please see the ANIMATE library for more details of <b>CDIBSection</b>. Note the code that translates the coordinates of the control window to those of the parent window.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Note, too, the call to <b>GdiFlush</b>. Because the <b>CDIBSurface</b> object allows both GDI calls (via its DC) and direct pixel access, we must be sure to flush the GDI queue after GDI operations that precede direct pixel access operations. Some of <b>CDIBSurface</b>'s member functions do direct pixel access, so as a rule, if you do a bunch of GDI operations, call <b>GdiFlush</b> right after them.</p>
<h3>Rendering the Static Parts of the Control</h3>
<p>
Inasmuch as we don't want to needlessly render the parts of the control that never change, we do all the one-time rendering to a static image buffer. We do this when the control changes size. Here's the <b>CreateImage</b> function, which draws the static image:</p>
<pre><code>void CRotaryCtl::CreateImage()
{
 &nbsp;&nbsp; // Start by filling the whole area with the transparency color.
 &nbsp;&nbsp; // We use a system color that isn't used elsewhere in the control.
 &nbsp;&nbsp; CDC* pDC = m_dsImage.GetDC();
 &nbsp;&nbsp; CPalette* ppalOld = NULL;
 &nbsp;&nbsp; CBrush br;
 &nbsp;&nbsp; if (m_pPal) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDC-&gt;SelectPalette(m_pPal, FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDC-&gt;RealizePalette();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; br.CreateSolidBrush(PALETTEINDEX(m_pPal-&gt;GetNearestPaletteIndex(TRANS_COLOR)));
 &nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; br.CreateSolidBrush(TRANS_COLOR);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; CRect rc(0, 0, m_iWidth, m_iHeight);
 &nbsp;&nbsp; pDC-&gt;FillRect(&amp;rc, &amp;br);

 &nbsp;&nbsp; // Compute the center and outer radius of the tick marks.
 &nbsp;&nbsp; m_ptCenter.x = m_iWidth / 2;
 &nbsp;&nbsp; m_ptCenter.y = m_iHeight / 2;
 &nbsp;&nbsp; m_iRadius = min(m_ptCenter.x, m_ptCenter.y) + 1;
 &nbsp;&nbsp; // Make radius an odd number.
 &nbsp;&nbsp; if (m_iRadius &amp; 1 == 0) m_iRadius--;
 &nbsp;&nbsp; // cos(pi/4) = sin (pi/4) = 0.7071 = 7071/10000
 &nbsp;&nbsp; int iOffset = m_iRadius * 7071 / 10000;
 &nbsp;&nbsp; pDC-&gt;MoveTo(m_ptCenter);
 &nbsp;&nbsp; pDC-&gt;LineTo(m_ptCenter.x + iOffset, m_ptCenter.y + iOffset);
 &nbsp;&nbsp; pDC-&gt;MoveTo(m_ptCenter);
 &nbsp;&nbsp; pDC-&gt;LineTo(m_ptCenter.x + m_iRadius, m_ptCenter.y);
 &nbsp;&nbsp; pDC-&gt;MoveTo(m_ptCenter);
 &nbsp;&nbsp; pDC-&gt;LineTo(m_ptCenter.x + iOffset, m_ptCenter.y - iOffset);
 &nbsp;&nbsp; pDC-&gt;MoveTo(m_ptCenter);
 &nbsp;&nbsp; pDC-&gt;LineTo(m_ptCenter.x, m_ptCenter.y - m_iRadius);
 &nbsp;&nbsp; pDC-&gt;MoveTo(m_ptCenter);
 &nbsp;&nbsp; pDC-&gt;LineTo(m_ptCenter.x - iOffset, m_ptCenter.y - iOffset);
 &nbsp;&nbsp; pDC-&gt;MoveTo(m_ptCenter);
 &nbsp;&nbsp; pDC-&gt;LineTo(m_ptCenter.x - m_iRadius, m_ptCenter.y);
 &nbsp;&nbsp; pDC-&gt;MoveTo(m_ptCenter);
 &nbsp;&nbsp; pDC-&gt;LineTo(m_ptCenter.x - iOffset, m_ptCenter.y + iOffset);

 &nbsp;&nbsp; // Draw the knob skirt. Make the pen the transparency color, so we
 &nbsp;&nbsp; // get a slight gap between the skirt and the tick marks.
 &nbsp;&nbsp; int iSkirtRad = m_iRadius * 8 / 10;
 &nbsp;&nbsp; CBrush brBody;
 &nbsp;&nbsp; brBody.CreateSolidBrush(PALETTERGB(102,102,102));
 &nbsp;&nbsp; CPen penTrans(PS_SOLID, 1, TRANS_COLOR);
 &nbsp;&nbsp; CPen* ppenOld = pDC-&gt;SelectObject(&amp;penTrans);
 &nbsp;&nbsp; CBrush* pbrOld = pDC-&gt;SelectObject(&amp;brBody);
 &nbsp;&nbsp; pDC-&gt;Ellipse(m_ptCenter.x - iSkirtRad, m_ptCenter.y - iSkirtRad,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ptCenter.x + iSkirtRad + 1, m_ptCenter.y + iSkirtRad + 1);

 &nbsp;&nbsp; // Draw the center.
 &nbsp;&nbsp; CPen penTop(PS_SOLID, 1, PALETTERGB(51,51,51));
 &nbsp;&nbsp; CBrush brTop;
 &nbsp;&nbsp; brTop.CreateSolidBrush(PALETTERGB(165,165,165));
 &nbsp;&nbsp; pDC-&gt;SelectObject(&amp;penTop);
 &nbsp;&nbsp; pDC-&gt;SelectObject(&amp;brTop);
 &nbsp;&nbsp; int iTopRad = m_iRadius / 2;
 &nbsp;&nbsp; pDC-&gt;Ellipse(m_ptCenter.x - iTopRad, m_ptCenter.y - iTopRad,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ptCenter.x + iTopRad + 1, m_ptCenter.y + iTopRad + 1);


 &nbsp;&nbsp; // Tidy up.
 &nbsp;&nbsp; pDC-&gt;SelectObject(ppenOld);
 &nbsp;&nbsp; pDC-&gt;SelectObject(pbrOld);
 &nbsp;&nbsp; if (ppalOld) pDC-&gt;SelectPalette(ppalOld, FALSE);
}
</code></pre>
<p>
Rather a lot of code, but a quick glance shows it's mostly lines and circles in various colors. Note that the image is held in another <b>CDIBSurface</b> object.</p>
<h3>Rendering the Complete Control Image</h3>
<p>
Each time the control's position changes, it needs to be redrawn using the steps shown in Figure 3. The <b>Render</b> function does the work:</p>
<pre><code>void CRotaryCtl::Render()
{
 &nbsp;&nbsp; // Render the image of the control to the buffer.
 &nbsp;&nbsp; // Start by blting the the background image to the buffer.
 &nbsp;&nbsp; CDC* pDC = m_dsBuffer.GetDC();
 &nbsp;&nbsp; // Don't use CDIB::Draw here as DC operation caching by GDI
 &nbsp;&nbsp; // will mean this op would get done after the next one, which
 &nbsp;&nbsp; // does direct pixel manipulation.
 &nbsp;&nbsp; m_dsBackground.CopyBits(&amp;m_dsBuffer,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dsBackground.GetWidth(),
 &nbsp;&nbsp; m_dsBackground.GetHeight(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0);

 &nbsp;&nbsp; // Now transparently blt the image to the buffer.
 &nbsp;&nbsp; BYTE* p = (BYTE*) m_dsImage.GetPixelAddress(0, 0);
 &nbsp;&nbsp; COLORREF clr = PALETTEINDEX(*p);
 &nbsp;&nbsp; m_dsImage.CopyBits(&amp;m_dsBuffer,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dsImage.GetWidth(), m_dsImage.GetHeight(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clr);

 &nbsp;&nbsp; // Now draw the pointer dot at the correct position.
 &nbsp;&nbsp; ASSERT(m_iMax &gt; m_iMin);
 &nbsp;&nbsp; ASSERT((m_iPos &gt;= m_iMin) &amp;&amp; (m_iPos &lt;= m_iMax));
 &nbsp;&nbsp; double a = -PI/4 + 3*PI/2 * (m_iMax - m_iPos)/(m_iMax - m_iMin);
 &nbsp;&nbsp; int iRad = m_iRadius * 65/100;
 &nbsp;&nbsp; int x = m_ptCenter.x + (int)(iRad * cos(a));
 &nbsp;&nbsp; int y = m_ptCenter.y - (int)(iRad * sin(a));
 &nbsp;&nbsp; CBrush br;
 &nbsp;&nbsp; br.CreateSolidBrush(PALETTERGB(255,255,255));
 &nbsp;&nbsp; CBrush* pbrOld = pDC-&gt;SelectObject(&amp;br);
 &nbsp;&nbsp; CPen pen;
 &nbsp;&nbsp; pen.CreateStockObject(NULL_PEN);
 &nbsp;&nbsp; CPen* ppenOld = pDC-&gt;SelectObject(&amp;pen);
 &nbsp;&nbsp; int iInc = max(2, m_iRadius * 1/10);
 &nbsp;&nbsp; pDC-&gt;Ellipse(x-iInc, y-iInc, x+iInc+1, y+iInc+1);
 &nbsp;&nbsp; pDC-&gt;SelectObject(pbrOld);
 &nbsp;&nbsp; pDC-&gt;SelectObject(ppenOld);
}
</code></pre>
<p>
The main thing to note here is the use of <b>CDIBSurface::CopyBits</b>, which uses direct pixel access to the DIB image to copy only the nontransparent areas from the source to the destination.</p>
<h3>Responding to User Input</h3>
<p>
Most of my controls only respond to mouse input, which is much simpler than using both keyboard and mouse input. However, should you require both, it's easy to add the extra code to what I've done here for mouse input.</p>
<p>
Generally, my user-input handling is all done by using ClassWizard to add handlers for left-mouse-button down and up events and for mouse-move events. Left button down generally causes the mouse to be captured and starts the user interface process:</p>
<pre><code>void CRotaryCtl::OnLButtonDown(UINT nFlags, CPoint point)
{
 &nbsp;&nbsp; ASSERT(!m_bCaptured);
 &nbsp;&nbsp; SetCapture();
 &nbsp;&nbsp; m_bCaptured = TRUE;
 &nbsp;&nbsp; OnMouseMove(nFlags, point);
}
</code></pre>
<p>
Because we generally want some feedback as soon as the mouse button is clicked, I simply call the move event function directly as a part of handling the button-down event. So most of the work is in the function that handles mouse movement:</p>
<pre><code>void CRotaryCtl::OnMouseMove(UINT nFlags, CPoint point)
{
 &nbsp;&nbsp; if (m_bCaptured) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Calculate the new value from the mouse position.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x = point.x - m_ptCenter.x;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int y = m_ptCenter.y - point.y; // make up +ve
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((x == 0) &amp;&amp; (y == 0)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 1;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double a = atan2(y, x); // -PI &lt;= a &lt;= PI
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a &lt; -PI/2) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a += 2*PI;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -PI/2 &lt;= a &lt;= 3PI/2

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Correct points beyond min and max.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a &gt;= 5*PI/4) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_iPos = m_iMin;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (a &lt; -PI/4) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_iPos = m_iMax;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_iPos = m_iMax - (int)((a+PI/4)/(3*PI/2) * (m_iMax - m_iMin));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT((m_iPos &gt;= m_iMin) &amp;&amp; (m_iPos &lt;= m_iMax));

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Redraw the control.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Render();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RedrawWindow();

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Notify parent.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetParent()-&gt;SendMessage(WM_HSCROLL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAKEWPARAM(SB_THUMBTRACK, m_iPos),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPARAM)GetSafeHwnd()); 
 &nbsp;&nbsp; }
}
</code></pre>
<p>
Most of the code here is concerned with calculating where the mouse is and what angle of rotation that maps to for the control—in other words, math. Once the new position has been calculated, the control is redrawn in the new position, and the parent window is notified of the change. I have chosen to use the SB_THUMBTRACK scroll-bar notification message because this most closely corresponds to what the control does and makes it easy to use ClassWizard to add a suitable handler in the parent window.</p>
<p>
When the mouse is released, we need to complete the operation:</p>
<pre><code>void CRotaryCtl::OnLButtonUp(UINT nFlags, CPoint point)
{
 &nbsp;&nbsp; if (m_bCaptured) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReleaseCapture();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bCaptured = FALSE;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Notify parent.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetParent()-&gt;SendMessage(WM_HSCROLL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAKEWPARAM(SB_THUMBPOSITION, m_iPos),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPARAM)GetSafeHwnd()); 
 &nbsp;&nbsp; }
}
</code></pre>
<p>
The mouse is released, and the parent window notified of the final position of the control. There is no need to redraw the control—its position will be whatever it was when the last WM_MOUSEMOVE message was processed.</p>
<h2>The Up-Down Control</h2>
<p>
Figure 1 also shows an up-down control used to change the scale values of the oscilloscope. This control consists of two buttons and a window area that shows the current control value. The control was implemented to work somewhat like a combo box (which it replaced) but with slightly different control functions. I have included the control here because it shows how you can create a custom control that is itself built from other controls. The source code for this control is in UPDNCTL.H and UPDNCTL.CPP. </p>
<h3>Creating the Control</h3>
<p>
The control is built from two standard Windows buttons and an area that the control draws itself. When the control is first created, the buttons must be created as child windows of the control:</p>
<pre><code>int CUpDnCtl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
 &nbsp;&nbsp; if (CWnd::OnCreate(lpCreateStruct) == -1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Create the two buttons.
 &nbsp;&nbsp; m_btnUp.Create("Up",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_CHILD|WS_VISIBLE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRect(0,0,0,0),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDC_UP); 
 &nbsp;&nbsp; m_btnDn.Create("Dn",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WS_CHILD|WS_VISIBLE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRect(0,0,0,0),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDC_DN); 
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return 0;
}
</code></pre>
<p>
Note that you could just as easily use other custom controls here instead of these rather boring buttons.</p>
<h3>Setting Size and Position</h3>
<p>
When the control is resized (or sized for the first time after creation), we need to set the size and position of all the child windows:</p>
<pre><code>void CUpDnCtl::OnSize(UINT nType, int cx, int cy)
{
 &nbsp;&nbsp; CWnd::OnSize(nType, cx, cy);
 &nbsp;&nbsp; if ((cx &lt; 10) || (cy &lt; 10)) return;

 &nbsp;&nbsp; // Resize the screen buffer to occupy the client area.
 &nbsp;&nbsp; m_dsPanel.Create(cx, cy, m_pPal);

 &nbsp;&nbsp; // Save the size.
 &nbsp;&nbsp; m_iWidth = cx;
 &nbsp;&nbsp; m_iHeight = cy;

 &nbsp;&nbsp; // Move the buttons.
 &nbsp;&nbsp; int w = cx/2;
 &nbsp;&nbsp; int h = cy - cy/2;
 &nbsp;&nbsp; m_btnUp.MoveWindow(0, cy/2, w, h);
 &nbsp;&nbsp; m_btnDn.MoveWindow(w, cy/2, cx-w, h);
 &nbsp;&nbsp; // Redraw the lot.
 &nbsp;&nbsp; Render();
 &nbsp;&nbsp; Invalidate();
}
</code></pre>
<p>
We are using a <b>CDIBSurface</b> object for the drawing area, and it needs to have its buffer reset to the size of the drawing area. The buttons need to be placed in the correct part of the parent window, too. Once everything is in place, the image of the control can be rendered, and then the whole window can be redrawn to show the control in its full glory. Here's the image rendering code:</p>
<pre><code>void CUpDnCtl::Render()
{
 &nbsp;&nbsp; // Render the panel image.
 &nbsp;&nbsp; CRect rc;
 &nbsp;&nbsp; m_dsPanel.GetRect(&amp;rc);
 &nbsp;&nbsp; rc.bottom = rc.bottom/2;
 &nbsp;&nbsp; CDC* pDC = m_dsPanel.GetDC();

 &nbsp;&nbsp; // Put black rectangle around the outside, and fill the middle
 &nbsp;&nbsp; // with gray.
 &nbsp;&nbsp; CBrush brSurface;
 &nbsp;&nbsp; brSurface.CreateSolidBrush(PALETTERGB(192,192,192));
 &nbsp;&nbsp; CBrush* pbrOld = pDC-&gt;SelectObject(&amp;brSurface);
 &nbsp;&nbsp; pDC-&gt;Rectangle(&amp;rc);

 &nbsp;&nbsp; // Draw the highlights.
 &nbsp;&nbsp; CPen penShadow(PS_SOLID, 1, PALETTERGB(128,128,128));
 &nbsp;&nbsp; CPen* ppenOld = pDC-&gt;SelectObject(&amp;penShadow);
 &nbsp;&nbsp; pDC-&gt;MoveTo(rc.left+1, rc.bottom-2);
 &nbsp;&nbsp; pDC-&gt;LineTo(rc.left+1, rc.top+1);
 &nbsp;&nbsp; pDC-&gt;LineTo(rc.right-1, rc.top+1);
 &nbsp;&nbsp; CPen penHighlight(PS_SOLID, 1, PALETTERGB(255,255,255));
 &nbsp;&nbsp; pDC-&gt;SelectObject(&amp;penHighlight);
 &nbsp;&nbsp; pDC-&gt;MoveTo(rc.left+2, rc.bottom-2);
 &nbsp;&nbsp; pDC-&gt;LineTo(rc.right-2, rc.bottom-2);
 &nbsp;&nbsp; pDC-&gt;LineTo(rc.right-2, rc.top+1);

 &nbsp;&nbsp; // Now draw the text in the middle.
 &nbsp;&nbsp; rc.InflateRect(-3, -2);
 &nbsp;&nbsp; pDC-&gt;SetBkMode(TRANSPARENT);
 &nbsp;&nbsp; CFont* pfntOld = pDC-&gt;SelectObject(&amp;m_font);
 &nbsp;&nbsp; pDC-&gt;DrawText(m_strCaption, -1, &amp;rc, DT_LEFT|DT_VCENTER);

 &nbsp;&nbsp; // Tidy up.
 &nbsp;&nbsp; pDC-&gt;SelectObject(pfntOld);
 &nbsp;&nbsp; pDC-&gt;SelectObject(pbrOld);
 &nbsp;&nbsp; pDC-&gt;SelectObject(ppenOld);
}
</code></pre>
<p>
Boy, don't you just love all that friendly GDI stuff? Seems like a lot of code for a few highlights and some text, but that's life in GDI-land.</p>
<p>
Drawing the entire control image in response to a WM_PAINT message is trivial:</p>
<pre><code>void CUpDnCtl::OnPaint()
{
 &nbsp;&nbsp; CPaintDC dc(this); // Device context for painting
 &nbsp;&nbsp; // Copy the panel image to the screen DC.
 &nbsp;&nbsp; m_dsPanel.Draw(&amp;dc);
}
</code></pre>
<p>
The <b>CDIBSurface</b> object's <b>Draw</b> function handles the chore of drawing the text part of the image. The buttons draw themselves, of course.</p>
<h3>Responding to User Input</h3>
<p>
The user clicks the buttons to get the selection to change. The selection options are held in a text string with individual items separated by "|" characters. The string is set by calling the control's <b>SetWindowText</b> function. Button clicks are routed to the objects handlers through the message map generated by ClassWizard in the usual way. Here are the Up and Down button-click handlers:</p>
<pre><code>void CUpDnCtl::OnUpClicked()
{
 &nbsp;&nbsp; if (m_iCurSel == 0) return;
 &nbsp;&nbsp; SetCurSel(m_iCurSel - 1);
}

void CUpDnCtl::OnDnClicked()
{
 &nbsp;&nbsp; SetCurSel(m_iCurSel + 1);
}
</code></pre>
<p>
The <b>SetCurSel</b> function does the work of actually changing the displayed selection:</p>
<pre><code>void CUpDnCtl::SetCurSel(int iSel)
{
 &nbsp;&nbsp; ASSERT(iSel &gt;= 0);

 &nbsp;&nbsp; const char* pSet = (const char*) m_strTextSet;
 &nbsp;&nbsp; ASSERT(pSet);
 &nbsp;&nbsp; int i = iSel;
 &nbsp;&nbsp; while (i--) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Move on to the next section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (*pSet != '|') {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSet++;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*pSet == '\0') return; // ran out of string
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSet++;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Set the caption to where we are now.
 &nbsp;&nbsp; m_strCaption = "";
 &nbsp;&nbsp; while (*pSet &amp;&amp; (*pSet != '|')) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_strCaption += *pSet++;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; m_iCurSel = iSel;
 &nbsp;&nbsp; Render();
 &nbsp;&nbsp; RedrawWindow();

 &nbsp;&nbsp; // Notify parent of the change.
 &nbsp;&nbsp; GetParent()-&gt;SendMessage(WM_COMMAND,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAKEWPARAM(GetDlgCtrlID(), CBN_EDITCHANGE),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPARAM(m_hWnd));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
}
</code></pre>
<p>
Rather a lot of ugly string-parsing code (BASIC for C programmers) followed by redrawing the window to show the change and notifying the parent window. I chose to send the parent a CBN_EDITCHANGE notification message because this control is a bit like a combo box.</p>
<h2>Tips</h2>
<p>
As a finishing touch, I thought I'd pass on a few other tips that relate to using the dialog box panels and custom controls.</p>
<p>
Watch out for <b>CWnd::GetDlgItem</b>, which returns a <i>temporary</i> <b>CWnd</b> object pointer, so don't store it for use later; you must get it every time you want it. Because you often want to get a pointer to a control object, you might want to add some helper functions to <b>CDlgPanelFrame</b>, like the <b>GetDlgItem(UINT uiCtlID);</b> function. This saves you from having to use <b>m_wndPanel.GetDlgITem(id);</b> in your frame code.</p>
<p>
Remember that <b>CDlgPanel</b> sends all WM_COMMAND and WM_DRAWITEM messages to its parent. Use ClassWizard to add a handler for the WM_DRAWITEM message to the frame window. To do this, you must change the Class Info message filter type for <b>CScopeFrame</b> from MDI Child Frame to Window in order to see the WM_DRAWITEM message. Change Class Info back to MDI Child Frame when you're done.</p>
<p>
Adding the handler for the BN_CLICKED notification messages is done in ClassWizard, but you must go to App Studio first and open the dialog template and then run ClassWizard. ClassWizard asks for the name of the dialog class to create. Click the Select button, and select <b>CScopeFrame</b> (for example). The <b>CScopeFrame</b> class can then see the dialog items.</p>
<p>
More information on handling user-defined messages, such as the one I used to send palette information to the control windows, can be found in the "User Defined Windows Messages" section of "Technical Note 6: Message Maps" (MSDN Library Archive, Technical Articles, Visual C++ 1.5 (32-bit), MFC 2.5 Technical Notes).</p>
<p>
In creating the Up-Down control, I noticed that you can't use ClassWizard to add a handler for WM_SETTEXT or WM_GETTEXT messages, and <b>CWnd::GetWindowText</b> and <b>CWnd::SetWindowText</b> are not documented as virtual. So we do this one ourselves.</p>
</BODY>
</HTML>
