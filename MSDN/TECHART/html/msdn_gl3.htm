<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OpenGL III: Building an OpenGL C++ Class</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_gl3"></a></sup>OpenGL III: Building an OpenGL C++ Class</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
January 18, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3203">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the EasyGL sample application for this technical article.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="3205">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the GLlib DLL for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article discusses the development of a C++ class library for encapsulating OpenGL™ code. The C++ class presented is for demonstration and educational purposes only. I will expand the class library for future OpenGL articles. The class library is not currently part of the Microsoft® Foundation Class Library (MFC), and there are no plans to add this class to MFC in the future. I assume that the reader has already read the first article in this series, <a href="msdn_gl1.htm">"OpenGL I: Quick Start,"</a> in the MSDN Library. The class library is in the GLlib.DLL file included with this article. The EasyGL sample application, also included with this article, uses the classes in GLlib.DLL.</p>
<h2>Introduction</h2>
<p>
C++ classes make programming simpler by hiding complexity. For example, a C++ class can set up a correct palette using the <b>Create </b>member function. Using a C++ class is much simpler than trying to understand all the discussions in my article <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode"</a> in the MSDN Library. </p>
<p>
However, if you're trying to understand a topic such as OpenGL™, using a class library may actually hinder your learning process. Trying to decipher what the class is doing can become a chore, precisely because the class hides information. For example, a C++ class would set pixel formats using a <b>Create</b> member function, which requires parameters such as PFD_DOUBLE_BUFFER, PFD_TYPE_RGBA, PFD_DRAW_TO_WINDOW, and PFD_SUPPORT_OPENGL. To understand how the pixel format is set, we need to look not only at the code for the <b>Create</b> member function, but also at the code that calls <b>Create</b>. Thus, if you're trying to understand the code, you must dig around in various source files.</p>
<p>
For this reason, I used an "inline" approach with the GLEasy sample application by writing most of the code directly in message handlers such as <b>OnSize</b> and <b>OnCreate</b>. To follow what is happening in GLEasy, simply start with <b>CGLEasyView::OnCreate</b> and follow the source. You will need to understand only a few functions, such as <b>PrepareScene </b>and <b>DrawScene</b>. Because the code is presented inline in GLEasy, I believe the OpenGL beginner will have an easier time learning OpenGL from GLEasy than from a C++ class library.</p>
<p>
However, inline coding takes you only so far. (Otherwise we wouldn't have functions, now would we?) Once you understand <b>PIXELFORMATDESCRIPTOR</b>, <b>ChoosePixelFormat</b>, <b>SetPixelFormat</b>, <b>wglCreateContext</b>, <b>wglMakeCurrent</b>, and palettes, there is no need to keep that code in sight. Therefore, a C++ class can make the code easier to use and reuse.</p>
<p>
I had another motivation for placing the OpenGL code in a C++ class. For my OpenGL article series, I wanted to demonstrate additional OpenGL topics such as color index mode, optimization, and rendering to a bitmap. For this purpose, I created several sample applications, all of which use the same code to initialize OpenGL. I created a shared class so I wouldn't have to fix the same bug in several locations. However, I did have to ensure that the shared code was backward-compatible or make any necessary changes to the earlier samples. </p>
<p>
At first glance, it's difficult to tell which is better: fixing the same bug in multiple locations or ensuring backward compatibility. The compiler is more likely to inform you if your changes break old code than remind you to fix a bug in all of your applications. Therefore, it's better, in general, to ensure backward compatibility and fix bugs in one place.</p>
<p>
In this article, I will describe <b>CGL</b>, which is the C++ class I will use in my future articles on OpenGL. In this article, I will cover the following topics:
<ul type=disc>
<li>
My design goals for <b>CGL</b><br><br></li>
<li>
The architecture of <b>CGL</b> <br><br></li>
<li>
Issues involved in placing <b>CGL</b> in a dynamic-link library (DLL)<br><br></li>
<li>
How to use <b>CGL</b> in your own application<br><br></li>
<li>
Simplifying the use of <b>CGL</b> by adding its own view class, <b>CGLView</b><br><br></li>
<li>
Using <b>CGL</b> and <b>CGLView</b> together in your own application<br><br></li>
<li>
A discussion of the EasyGL sample application</li>
</ul>
<h2>CGL Design Goals</h2>
<p>
All projects, whether they pertain to building programs or flying carpets, require goals. The list below contains some of my design goals for the OpenGL class, <b>CGL</b>. Note that these goals may differ from the goals for a Microsoft Foundation Class Library (MFC) OpenGL class, from the goals for Open Inventor (which is a standard C++ class library for OpenGL), and from your own goals for an OpenGL class.
<ul type=disc>
<li>
Don't hide OpenGL code.<p class=tl>
This may sound like a contradiction, but <b>CGL</b> should not hide or alter OpenGL code. The purpose of my articles and sample applications is to teach programmers how to use OpenGL on a Windows NT™ system. Therefore, I don't want to disguise OpenGL code. I want to be able to cut and paste OpenGL code from applications that don't use <b>CGL</b> into applications that use <b>CGL</b>. For example, I should be able to add OpenGL code from the <i>OpenGL Programming Guide</i> (also called the Red Book; see the bibliography at the end of this article) into my application, and it should work. An example of a class that doesn't follow this guideline is the <b>CDC</b> class in MFC. If you have graphics device interface (GDI) drawing code written in C, it must be converted to use the <b>CDC</b> class.</P></li>
<li>
Hide Windows NT OpenGL implementation details.<p class=tl>
<b>CGL</b> should not hide or change standard OpenGL code, but it should hide the Windows NT implementation details that are not standard across platforms. I want <b>CGL</b> to encapsulate the resource context, the device context, and the palette required by all OpenGL programs. Thus, I would like <b>CGL</b> to be the only class that contains Windows NT OpenGL implementation details. The standard OpenGL code will be placed in a different class.</P></li>
<li>
Follow the programming model used by the auxiliary library.<p class=tl>
Using a programming model similar to that used by the OpenGL auxiliary library may help developers who use the Red Book make the transition from C to C++ and MFC. This does not mean that <b>CGL</b> will require or use the auxiliary library, but only that the auxiliary library has already established a proven way to hide implementation details without hiding OpenGL details.</P></li>
<li>
Reduce the effort of making new OpenGL applications.<p class=tl>
I will need several sample applications for the articles I plan to write about OpenGL. I want to make my job of building new samples as simple as possible. If I succeed, my design will also make your job of building OpenGL applications easier.</P></li>
<li>
Write code that can be shared between sample applications.<p class=tl>
I would like my sample applications to share as much code as possible. I want to fix my bugs in a single location. </P></li>
<li>
Demonstrate how to make an OpenGL class.<p class=tl>
In the process of building <b>CGL</b>, I would like to teach you one way to make an OpenGL class. This will help you when you build your own class, even if you decide to do it differently. (In fact, it may help you decide to build your class differently.)</P></li>
</ul>
<h2>Class Architecture</h2>
<p>
When designing the OpenGL class, I considered two architectures: function encapsulation and structure encapsulation. These architectures are not mutually exclusive, because the function encapsulation method can be part of a structure encapsulation architecture.</p>
<h3>Function Encapsulation</h3>
<p>
Function encapsulation is more "MFC-like" than structure encapsulation. In function encapsulation, the OpenGL functions become member functions in the OpenGL class. These functions are called through an OpenGL class object. Take the following OpenGL code:</p>
<pre><code>&nbsp;&nbsp;&nbsp;glMatrixMode(GL_PROJECTION);
 &nbsp; glLoadIdentity();
 &nbsp; gluPerspective(30.0, gldAspect, 1.0, 10.0);
 &nbsp; glViewport(0, 0, cx, cy);
</code></pre>
<p>
With function encapsulation, this code could become:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CGL gl ;
 &nbsp; gl.glMatrixMode(GL_PROJECTION) ;
 &nbsp; gl.glLoadIdentity() ;
 &nbsp; gl.gluPerspective(30.0, gldAspect, 1.0, 10.0) ;
 &nbsp; gl.glViewport(0, 0, cx, cy) ;
</code></pre>
<p>
or even:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CGL gl ;
 &nbsp; gl.MatrixMode(GL_PROJECTION) ;
 &nbsp; gl.LoadIdentity() ;
 &nbsp; gl.Perspective(30.0, gldAspect, 1.0, 10.0) ;
 &nbsp; gl.Viewport(0, 0, cx, cy) ;
</code></pre>
<p>
Function encapsulation has many benefits, including the following:
<ul type=disc>
<li>
It draws a parallel with the <b>CDC</b> class.<p class=tl>
Function encapsulation makes the OpenGL commands look more like the <b>CDC</b> member functions that MFC already contains.</P></li>
<li>
It makes OpenGL commands appear more object-oriented.<p class=tl>
C++ users like calling functions via objects. In function encapsulation, OpenGL commands become members of a C++ class. The OpenGL commands are called through objects, thus they appear to be more object-oriented.</P></li>
<li>
Through function overloading, it reduces the number of command types. <p class=tl>
OpenGL commands take a variety of parameter types. For example, <b>glColor</b> has many forms, including <b>glColor3b</b>, <b>glColor3d</b>, <b>glColor3i</b>, <b>glColor4f</b>, and <b>glColor4uiv</b>. By using C++ function overloading, you can reduce these forms to a single function: <b>glColor</b> or <b>Color</b>.</P></li>
<li>
It encapsulates functions that take floats, so they can take doubles. <p class=tl>
Many OpenGL commands take floats. By default, the Microsoft Visual C++™ version 2.0 compiler treats floating-point literals as doubles, and issues a warning if you pass a double for a parameter that takes a float. To avoid the warning, you must append the letter "f" to the number. For example, <b>glClearColor(0.0, 0.0, 0.0, 0.0)</b> will generate a warning, but <b>glClearColor(0.0f, 0.0f, 0.0f, 0.0f)</b> will not. You could build versions of these functions that take doubles instead of floats and do the casting for you.</P></li>
<li>
It provides a way to track errors. <p class=tl>
Function encapsulation provides a way to track errors. We could implement debug versions of all OpenGL commands. These debug versions would print out the error messages that they encounter.</P></li>
</ul>
<p>
However, the function encapsulation method also has some serious drawbacks:
<ul type=disc>
<li>
It hides OpenGL syntax.<p class=tl>
The purpose of <b>CGL</b> is to make learning standard OpenGL easier, not to hide OpenGL from the developer. Full encapsulation of OpenGL commands will make using OpenGL easier, but could make learning standard OpenGL more difficult or confusing. I want you to learn standard OpenGL, not my own dialect of OpenGL.</P></li>
<li>
It results in loss of portability.<p class=tl>
Because function encapsulation requires changes in syntax, you cannot paste OpenGL code from other sources to your application. Moreover, you cannot paste the code from your application to another application that doesn't use the same class. </P></li>
<li>
It requires lots of time.<p class=tl>
Building the required function prototypes for all functions in OpenGL takes a lot of time—time I could spend researching another topic or doing something equally productive.</P></li>
</ul>
<p>
Function encapsulation has another, more serious drawback that I will discuss in the next section.</p>
<h3>wglMakeCurrent</h3>
<p>
In the OpenGL implementation for Windows NT, OpenGL commands require a current active rendering context (RC). Without a current active RC, OpenGL commands do nothing. The <b>wglMakeCurrent</b> function makes an RC current. (For more information on <b>wglMakeCurrent</b>, see the <a href="msdn_gl1.htm">"OpenGL I: Quick Start"</a> and <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started"</a> articles in the MSDN Library.) The most efficient way to use <b>wglMakeCurrent</b> is to call it once at the beginning of a program. This method requires keeping a device context (DC) around for the life of the program.</p>
<p>
Let's assume that an application renders two separate OpenGL scenes: one scene in the status bar, and the other scene in the client area. Each scene would have a separate rendering context. It would be tempting to write the following code:</p>
<pre><code>CGL glStatusBar ;
CGL glClientArea ;

glStatusBar.Color(1.0, 0.0, 0.0) ;
glClientArea.Color(0.0, 1.0, 0.0)&nbsp; ;
glStatusBar.CallList(STATUS_BAR) ;
glClientArea.CallList(CLIENT_AREA) ;
</code></pre>
<p>
However, for this code to work, each function (<b>Color</b> and <b>CallList</b>) must call <b>wglMakeCurrent</b>, which results in a loss of performance. These functions must at least check to see whether the current RC is correct:</p>
<pre><code>void CGL::Color(GLdouble r, GLdouble g, GLdouble b) 
{
 &nbsp; if (m_hrc != wglGetCurrentContext())
 &nbsp;&nbsp;&nbsp;&nbsp; wglMakeCurrent(m_pdc-&gt;m_hDC, m_hrc) ;
 &nbsp; glColor3d(r, g, b) ;
}
</code></pre>
<p>
The performance loss is more evident if we must call <b>wglMakeCurrent</b> explicitly instead of having each member function call it implicitly. A <b>CGL::MakeCurrent </b>member function could do the work for us:</p>
<pre><code>glStatusBar.MakeCurrent() ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // RC for glStatus.
glStatusBar.Color(1.0, 0.0, 0.0) ;

glClientArea.MakeCurrent() ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Change to RC for glClientArea.
glClientArea.Color(0.0, 1.0, 0.0)&nbsp; ;

glStatusBar.MakeCurrent() ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Change to RC for glStatus.
glStatusBar.CallList(STATUS_BAR) ;

glClientArea.MakeCurrent() ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Change to RC for glClientArea.
glClientArea.CallList(CLIENT_AREA) ;
</code></pre>
<p>
A performance loss would result even if we reordered the statements as follows:</p>
<pre><code>glStatusBar.MakeCurrent() ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Change to RC for glStatus.
glStatusBar.Color(1.0, 0.0, 0.0) ;
glStatusBar.CallList(STATUS_BAR) ;

glClientArea.MakeCurrent() ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Change to RC for glClientArea.
glClientArea.Color(0.0, 1.0, 0.0)&nbsp; ;
glClientArea.CallList(CLIENT_AREA) ;
</code></pre>
<p>
We don't want to hide the OpenGL code, but we should hide the Windows NT functions, because they are not portable to other systems. The OpenGL programmer shouldn't worry about setting the current context—the <b>CGL</b> class should be responsible for this.</p>
<p>
I described the scenarios above as extreme examples to illustrate the possible performance loss. Although you might not code in this style intentionally, the use of function encapsulation may indirectly lead to the performance loss illustrated in these examples. A better approach would be to design the class correctly from the beginning, using structure encapsulation (see the next section). </p>
<p>
A possible solution to the <b>wglMakeCurrent</b> problem that does not require structure encapsulation does exist: Only one RC can be active per thread; therefore, each instance of <b>CGL</b> could create a thread and make the RC current in this thread. This solution increases the complexity of <b>CGL</b> significantly. The overhead of thread switching may also be greater than the overhead you incur using the <b>if</b> statement and <b>wglGetCurrentContext</b> function. </p>
<h3>Structure Encapsulation</h3>
<p>
In structure encapsulation, the structure of an OpenGL program is encapsulated within the class, hiding the Windows NT implementation details. The individual OpenGL commands are not provided as member functions of the OpenGL class. (Function encapsulation, on the other hand, includes the OpenGL commands as member functions.)</p>
<p>
In the samples associated with my OpenGL articles, I decided to implement structure encapsulation because I felt that function encapsulation was far too time-consuming and offered only syntactic, insignificant benefits.</p>
<p>
You may remember that the GLEasy sample application included OpenGL code in the <b>OnCreate</b>, <b>OnSize</b>, <b>OnInitialUpdate</b>, <b>OnDraw</b>, and <b>OnDestroy </b>functions. Because we are encapsulating the structure of an OpenGL program, it would make sense to include member functions that correspond to those functions in our OpenGL class. A simplified class definition of <b>CGL</b> would look like this:</p>
<pre><code>class CGL
{
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL Create() ;
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL Init() ;
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL Resize() ;
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL Render() ;
 &nbsp;&nbsp;&nbsp;&nbsp; void Destroy() ;
}
</code></pre>
<p>
The member functions are called by the appropriate message handler in the view class. Figure 1 illustrates the process.</p>
<p>
<img src="gl3_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Message handlers in CView call member functions in CGL.</b></p>
<p>
In my design, <b>CGL::Create</b> creates a rendering context, a device context, and (if needed) a palette. <b>CGL::Destroy </b>handles cleanup tasks for the class. <b>CGL::Resize </b>changes the projection of the scene to the screen. <b>CGL::Init </b>initializes the OpenGL parameters and sets up display lists. <b>CGL::Render </b>puts it all on the screen.</p>
<p>
This is very similar to the approach taken by the auxiliary library in the Red Book (see the bibliography at the end of this article). The sample code in the Red Book includes three functions—<b>myinit</b>, <b>myReshape</b>, and <b>display</b>—that parallel <b>CGL::Init</b>, <b>CGL::Resize</b>, and <b>CGL::Render</b>, respectively.</p>
<p>
Now, look at <b>CGLEasyView::OnSize </b>from the GLEasy sample application:</p>
<pre><code>void CGLEasyView::OnSize(UINT nType, int cx, int cy) 
{
 &nbsp; CView::OnSize(nType, cx, cy);
 &nbsp; if ( (cx &lt;= 0) || (cy &lt;= 0) ) return ;
 &nbsp; CClientDC dc(this) ;
 &nbsp; BOOL bResult = wglMakeCurrent(dc.m_hDC, m_hrc);
 &nbsp; if (!bResult)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; TRACE("wglMakeCurrent Failed %x\r\n", GetLastError() ) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return ;
 &nbsp; }
 &nbsp; //
 &nbsp; // Set up the 3-D mapping to screen space.
 &nbsp; //
 &nbsp; GLdouble gldAspect = (GLdouble) cx/ (GLdouble) cy;
 &nbsp; glMatrixMode(GL_PROJECTION); OutputGlError("MatrixMode") ;
 &nbsp; glLoadIdentity();
 &nbsp; gluPerspective(30.0, gldAspect, 1.0, 10.0);
 &nbsp; glViewport(0, 0, cx, cy);
 &nbsp; wglMakeCurrent(NULL, NULL);
}
</code></pre>
<p>
The OpenGL code at the end of the function is specific to GLEasy. We wouldn't want this code in <b>CGL</b>, so we must separate the application-specific OpenGL code from the common OpenGL code. It just happens that the common OpenGL code is the Windows NT implementation code. In the case above, we can encapsulate the <b>wglMakeCurrent</b> function.</p>
<p>
The application-specific code is placed in a class inherited from <b>CGL</b>, as illustrated in Figure 2.</p>
<p>
<img src="gl3_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Specific OpenGL code is placed in derived classes.</b></p>
<p>
The most obvious method would be to define <b>CGL</b>, the derived class, and <b>CScene::Resize</b> as listed below.</p>
<p>
<b>CGL</b>:</p>
<pre><code>class CGL
{
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL Create() ;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL Init() ;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL Resize(int cx, int cy) ;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL Render() ;
 &nbsp;&nbsp;&nbsp;&nbsp; void Destroy() ;
}
</code></pre>
<p>
Derived class:</p>
<pre><code>class CScene : public CGL
{
 &nbsp; protected:
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL Resize(int cx, int cy) ;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL Init() ;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL Render();
}
</code></pre>
<p>
<b>CScene::Resize</b>:</p>
<pre><code>BOOL CScene::Resize(int cx, int cy)
{
 &nbsp; CGL::Resize(cx,cy) ;

 &nbsp; GLdouble gldAspect = (GLdouble) cx/ (GLdouble) cy;
 &nbsp; glMatrixMode(GL_PROJECTION); 
 &nbsp; glLoadIdentity();
 &nbsp; gluPerspective(30.0, gldAspect, 1.0, 10.0);
 &nbsp; glViewport(0, 0, cx, cy);
}
</code></pre>
<p>
However, I didn't do it this way. The <b>Render </b>function must call <b>wglMakeCurrent</b> before, and <b>SwapBuffer</b> after, the application-specific OpenGL code. The approach I took mirrors the MFC <b>CView::OnPaint </b>function, which calls <b>BeginPaint</b> before calling <b>CView::OnDraw</b>, and calls <b>EndPaint </b>afterwards. So <b>Render</b> (a non-virtual function) calls <b>OnRender</b> (a virtual function), which contains the application-specific OpenGL code. Instead of making the <b>Render </b>function different from the other functions, I decided to give all the functions a similar structure.</p>
<p>
Here's a simplified version of the <b>CGL</b> class definition:</p>
<pre><code>class CGL
{
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL Create() ;
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL Init() ;
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL Resize() ;
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL Render() ;
 &nbsp;&nbsp;&nbsp;&nbsp; void Destroy() ;
 &nbsp; protected:
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL OnResize() = 0 ;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL OnInit()&nbsp;&nbsp; = 0 ;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL OnRender() = 0 ;
}
</code></pre>
<p>
We derive a class from <b>CGL</b> and implement the pure virtual functions:</p>
<pre><code>class CScene : public CGL
{
 &nbsp; protected:
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL OnResize() ;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL OnInit() ;
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL OnRender();
}
</code></pre>
<p>
Figure 3 illustrates the program structure.</p>
<p>
<img src="gl3_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Path of execution from CGL to derived class.</b></p>
<p>
The code for <b>CGL::Render</b> looks like this:</p>
<pre><code>BOOL CGL::Render()
{
 &nbsp; // Make the HGLRC current.
 &nbsp; makeCurrent() ;

 &nbsp; // Draw.
 &nbsp; OnRender() ;

 &nbsp; // Swap buffers.
 &nbsp; SwapBuffers(m_pdc-&gt;m_hDC) ;

 &nbsp; return TRUE ;
}
</code></pre>
<h3>wglMakeCurrent</h3>
<p>
<b>CGL</b> encapsulates the <b>wglMakeCurrent</b> function call. <b>CGL</b> makes sure that the rendering context of the instance is current before calling any application-specific OpenGL code. <b>OnResize</b>, <b>OnInit</b>, and <b>OnRender </b>all call <b>CGL::MakeCurrent</b>, which is a member function implemented in the CGL-HELP.CPP file. The code for <b>CGL::MakeCurrent</b> is shown below:</p>
<pre><code>void CGL::MakeCurrent()
{
 &nbsp; ASSERT(m_hrc) ;
 &nbsp; ASSERT(m_pdc) ;

 &nbsp; if (m_pPal)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; m_dc-&gt;SelectPalette(m_pPal, 0) ;
 &nbsp;&nbsp;&nbsp;&nbsp; m_dc-&gt;RealizePalette() ;
 &nbsp; }

 &nbsp; if (m_hrc != wglGetCurrentContext())
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL bResult = wglMakeCurrent(m_pdc-&gt;m_hDC, m_hrc);
 &nbsp;&nbsp;&nbsp;&nbsp; if (!bResult)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("wglMakeCurrent Failed %x\r\n", GetLastError() ) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
}
</code></pre>
<p>
To save time, <b>wglGetCurrentContext </b>checks to see whether the rendering context needs to be changed, and changes it if it does.</p>
<h2>CGL in a DLL</h2>
<p>
Now, I should know better than to ask my colleague Ruediger for his opinions. Ruediger likes doing things the hard way. Don't get me wrong—he doesn't tell you to write a mail merge program as a virtual device driver (VxD), but he does like writing VxDs whenever possible. In fact, he's a happy man when he can write VxDs in hand-assembled machine language while floating on his sea kayak. </p>
<p>
When I asked Ruediger's opinion on how to allow multiple applications to share <b>CGL</b>, he immediately said, "Use a DLL." Now, I used to love DLLs until C++ came along. C++ classes complicate the DLL interface. MFC extension DLLs (AFXDLLs), on the other hand, simplify exporting C++ classes from a DLL. Although the MFC extension DLLs do not solve all of the problems—in fact, they add some of their own—they do make DLLs more usable for the MFC programmer.</p>
<p>
I simply can't pass up a challenge, so I followed Ruediger's advice and put <b>CGL</b> into a DLL called GLlib.DLL. (The debug version is GLlib-d.DLL.) Placing <b>CGL </b>in a DLL didn't solve many problems. The best feature of GLlib.DLL is that I can make changes to the DLL without having to recompile all the applications that use it. Now, this works only if I don't change the DLL interface. The worst feature of GLlib.DLL is that it has to be in the path or directory of any application that calls it. I will tell you more about <b>CGL </b>when I build more sample applications that use it.</p>
<h3>AFX_EXT_CLASS</h3>
<p>
Making MFC extension DLLs is very easy with Visual C++ version 2.0, because AppWizard can now create the framework for a DLL. Exporting classes from the DLL is very simple—just add AFX_EXT_CLASS to the class definition:</p>
<pre><code>class AFX_EXT_CLASS CGLView : public CView
{
.
.
.
};
</code></pre>
<p>
In situations such as the above, where a non-exported class is used as the base class for an exported class, Visual C++ generates the following warning message:</p>
<pre><code>warning C4275: non dll-interface class 'CView' used as base 
for dll-interface class 'CGLView'
</code></pre>
<p>
If the client application called a member function in <b>CGLView</b> that was inherited from <b>CView</b>, the function would not be found because it was not exported. This warning can be ignored because the client application and GLlib share the same version of <b>CView</b> in the MFC DLL. If a client application calls a <b>CView </b>function via <b>CGLView</b>, it will link to the function in the shared MFC DLL. </p>
<p>
For AFX_EXT_CLASS to work, the _AFXEXT preprocessor definition must be defined. AppWizard adds the _AFXDLL preprocessor definition by default, so I removed _AFXDLL from the link line and added _AFXEXT in its place.</p>
<h2>Using CGL</h2>
<p>
In this section, I've listed the steps required to use <b>CGL</b>.</p>
<p>
The following steps involve <b>CGL</b> code directly:
<ol>
<li>
Derive a class from <b>CGL</b>.<br><br></li>
<li>
Implement the <b>OnInit</b>, <b>OnResize</b>, and <b>OnRender</b> member functions.</li>
</ol>
<p>
The next set of steps involve the application framework:
<ol>
<li>
Build the application framework with AppWizard.<br><br></li>
<li>
Add the OpenGL include files (GL\GL.H and GL\GLU.H) to STDAFX.H.<br><br></li>
<li>
Link with the OpenGL library files (OPENGL32.LIB and GLU32.LIB).<br><br></li>
<li>
Link with the <b>CGL</b> library file (GLlib.LIB or GLlib-d.DLL).<br><br></li>
<li>
Add an instance of the class you derived from <b>CGL</b> to the members in your view class.<br><br></li>
<li>
Forward palette messages from the frame to the active view. (See <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode"</a> in the MSDN Library.)<br><br></li>
<li>
Implement handlers for CView::OnPaletteChanged and CView::OnQueryNewPalette.<br><br></li>
<li>
Implement a handler for CView::OnEraseBkgnd.<br><br></li>
<li>
Implement a handler for CView::PreCreateWindow.<br><br></li>
<li>
Add calls to CGL::Create, CGL::Init, CGL::Resize, and so on, to the application's view class.</li>
</ol>
<p>
As you can see, using <b>CGL</b> requires many steps. Most of these steps involve adding <b>CGL</b> to the view class. Too bad there isn't some way to connect a class to a view class automatically. MFC works around this problem by defining specialized view classes or by enabling AppWizard to perform the required steps. Maybe in a future version of Visual C++ we'll be able to add our own customized additions to AppWizard. Until then, it would be nice if using <b>CGL</b> didn't require quite so many steps. </p>
<p>
I decided to add a <b>CGLView </b>class to GLlib.DLL to alleviate this problem. You still have to perform steps 1–6 and a few more steps we'll talk about in a little bit. However, you don't have to implement so many message handlers.</p>
<h2>CGLView</h2>
<p>
I added the <b>CGLView </b>class to GLlib.DLL to simplify the creation of applications that use <b>CGL</b>. The application's view class is derived from <b>CGLView</b>. Figure 4 shows the hierarchy of a typical application that uses the GLlib.DLL classes.</p>
<p>
<img src="gl3_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Class hierarchy of an application that uses GLlib</b></p>
<p>
I decided to use <b>CScene </b>and <b>CSceneView </b>as the names of classes that I inherited from <b>CGL </b>and <b>CGLView</b>. (You can use other names if you wish.) I expect to use the box, pyramid, and dodecahedron from EasyGL in other sample applications, so I will probably copy the classes over to those applications.</p>
<p>
<b>CGLView </b>implements message handlers (for example, <b>OnSize)</b>, so they don't have to be implemented in an application class such as <b>CSceneView</b>.</p>
<pre><code>void CGLView::OnSize(UINT nType, int cx, int cy)
{
 &nbsp; CView::OnSize(nType, cx, cy) ;
 &nbsp; m_pGL-&gt;Resize(cx,cy) ;
}
</code></pre>
<p>
Calling <b>CGL::Resize </b>through a pointer results in a virtual function call to <b>OnResize</b>. If <b>CScene </b>is a derived class of <b>CGL</b>, the pointer <b>m_pGL</b> must point to a <b>CScene </b>type. <b>CGLView</b> needs to get a pointer to the <b>CScene </b>object from <b>CSceneView</b>. The pure virtual function <b>CGLView::GetGLptr</b> performs this function:</p>
<pre><code>class CGLView : public CView 
{
.
.
.
protected:
 &nbsp; virtual CGL* GetGLptr() = 0 ;
 &nbsp; CGL* m_pGL ;
.
.
.
};
</code></pre>
<p>
Because <b>GetGLptr</b> is a pure virtual function, it must be implemented in a derived class of <b>CGLView</b>:</p>
<pre><code>class CSceneView : public CGLView
{
.
.
.
protected:
 &nbsp; CScene aScene ;
 &nbsp; virtual CGL* GetGLptr() {return &amp;aScene;}
.
.
.
}
</code></pre>
<p>
<b>CGLView</b> calls <b>GetGLptr</b> when handling the WM_CREATE message:</p>
<pre><code>int CGLView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
 &nbsp; if (CView::OnCreate(lpCreateStruct) == -1)
 &nbsp;&nbsp;&nbsp;&nbsp; return -1;

 &nbsp; m_pGL = GetGLptr() ;
 &nbsp; BOOL bResult = m_pGL-&gt;Create(this) ;
 &nbsp; if (bResult)
 &nbsp;&nbsp;&nbsp;&nbsp; return 0 ;
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; return -1;
}
</code></pre>
<h3>DYNCREATE and Pure Virtual Functions</h3>
<p>
Pure virtual functions are nice because the compiler will warn you if you don't implement them. However, you can't create instances of a class that contains pure virtual functions. Classes with pure virtual functions will generate errors if they use the <b>DECLARE_DYNCREATE</b> and <b>IMPLEMENT_DYNCREATE</b> macros, because these macros create functions that create instances of the class, which is not allowed with pure virtual functions.</p>
<p>
The workaround is easy: Don't include <b>DECLARE_DYNCREATE</b> and <b>IMPLEMENT_DYNCREATE</b> in <b>CGLView</b>. If you look at GLVIEW.H and GLVIEW.CPP in the GLlib.DLL, you will see that these macros are commented out. We will need to add these macros to the classes derived from <b>CGLView</b>. For example, if we derive <b>CSceneView </b>from <b>CGLView</b>, we will add these macros to <b>CSceneView</b>. <b>CSceneView</b> passes <b>CView</b> instead of <b>CGLView</b> to <b>IMPLEMENT_DYNCREATE</b>, skipping the parent class that does not include <b>IMPLEMENT_DYNCREATE</b>. <b>CSceneView</b> includes the line:</p>
<pre><code>&nbsp;&nbsp;&nbsp;IMPLEMENT_DYNCREATE(CSceneView, <b>CView</b>)
</code></pre>
<p>
instead of:</p>
<pre><code>&nbsp;&nbsp;&nbsp;IMPLEMENT_DYNCREATE(CSceneView, <b>CGLView</b>)
</code></pre>
<p>
For more information, see the Knowledge Base article Q103983, "INF: Serializing an Abstract Base Class."</p>
<h2>EasyGL, CScene, and CSceneView</h2>
<p>
The EasyGL sample application is basically the same as GLEasy, except that EasyGL uses GLlib.DLL and GLEasy doesn't. GLlib.DLL contains all the Windows NT OpenGL implementation code, and the <b>CScene</b> class contains all the OpenGL code. </p>
<h3>CScene</h3>
<p>
<b>CScene </b>is a simple class: It inherits from <b>CGL </b>and implements the <b>OnResize</b>, <b>OnInit</b>, and <b>OnRender</b> member functions. The <b>OnResize </b>code is from <b>CEasyGLView::OnSize</b>, the <b>OnInit </b>code is from <b>CEasyGLView::PrepareScene</b>, and the <b>OnRender</b> code is from <b>CEasyGLView::DrawScene</b>.</p>
<h3>CSceneView</h3>
<p>
<b>CSceneView</b> is a tad more complicated than <b>CScene</b>. I let AppWizard build <b>CSceneView </b>for me, then modified it. The modifications are pretty simple:
<ul type=disc>
<li>
Include GLLIB.H and SCENE.H in SCENEVW.H.<br><br></li>
<li>
Modify <b>CSceneView </b>to inherit from <b>CGLView</b>. <br><br></li>
<li>
Add the following code:<pre><code>CScene aScene ;
virtual CGL* GetGLptr() { return &amp;aScene; }
</code></pre>
</li>
<li>
Pass <b>CView</b> to the <b>IMPLEMENT_DYNCREATE</b> macro:<pre><code>IMPLEMENT_DYNCREATE(CSceneView, CView /* not CGLView */) ;
</code></pre>
</li>
<li>
Comment out <b>CSceneView::OnDraw</b>. <b>CScene::OnRender </b>and <b>CGLView::OnDraw</b> handle the drawing.</li>
</ul>
<p>
By the way, I didn't add the rotation code to EasyGL, but left it as an exercise for the reader. It's pretty easy to do.</p>
<h2>Using CGL and CGLView</h2>
<p>
In this section, I will explain how you can use <b>CGL </b>and <b>CGLView </b>together, starting from scratch. I will build the framework for EasyCI, which uses OpenGL color index mode. See my article <a href="msdn_gl4.htm">"OpenGL IV: Color Index Mode"</a> in the MSDN Library for a discussion of color index mode and the changes I made to <b>CGL</b> to support this mode.
<ul type=disc>
<li>
Create a new MFC application using AppWizard.<p class=tl>
I named my project EasyCI and created a single-document interface (SDI) application without open database connectivity (ODBC) or OLE support. I also decided not to include print preview, the status bar, and the toolbar. GLlib is an MFC extension DLL, so make sure that you link to MFC through the shared DLL (MFC30(D).DLL). MFC extension DLLs link to the shared MFC DLL and require any application that calls them to do the same. For more information, see MFC "Technical Note 33: DLL Version of MFC" in the Visual C/C++ Product Documentation section of the MSDN Library.</P><p class=tl>
I also changed the name of the view class from <b>CEasyCIView</b> to <b>CSceneView</b> (and almost forgot to rename the file). You don't have to rename the view class; I did because I wanted to copy the <b>CScene </b>and <b>CSceneView</b> classes from EasyGL to get the box, pyramid, and dodecahedron.</P></li>
<li>
Add the following .LIB files to the link settings:<pre><code>GLlib.lib
opengl32.lib
glu32.lib
glaux.lib (optional)
</code></pre>
</li>
<li>
Follow the instructions in the "EasyGL, CScene, and CSceneView" section of this article, or copy <b>CScene</b> and <b>CSceneView</b> from EasyGL (from the SCENE.CPP, SCENE.H, SCENEVW.CPP, and SCENEVW.H files). You'll have to change the <b>CEasyglDoc</b> references to <b>CEasyCIDoc</b> in SCENEVW.H and SCENEVW.CPP. Also, change the names of the included files in SCENEVW.CPP. Add <b>CScene</b> to the project.<br><br></li>
<li>
Forward palette messages from the frame to the active view. (See <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode"</a> in the MSDN Library.)<br><br></li>
<li>
Ignore the two C4275 errors that you get when you compile. See the section "CGL in a DLL" earlier in this article for more information about this error message.<br><br></li>
<li>
Make sure that GLlib(-d).DLL is on the path before you try to execute your new program.</li>
</ul>
<p>
That's all there is to it!</p>
<h2>Conclusion</h2>
<p>
<b>CGL </b>is a simple, usable class library for OpenGL. <b>CGL</b> proves that you can build a small C++ class that simplifies the use of OpenGL without changing the OpenGL code itself. Look for <b>CGL </b>to grow as I extend it for my future articles on OpenGL.</p>
<h2>Bibliography</h2>
<p>
Crain, Dennis. <a href="msdn_opengl9.htm">"Windows NT OpenGL: Getting Started."</a> April 1994. (MSDN Library, Technical Articles)</p>
<p>
Microsoft Knowledge Base Q103983. "INF: Serializing an Abstract Base Class." (MSDN Library, Knowledge Base)</p>
<p>
Neider, Jackie, Tom Davis, and Mason Woo. <i>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1993. ISBN 0-201-63274-8. (This book is also known as the "Red Book".)</p>
<p>
OpenGL Architecture Review Board. <i>OpenGL Reference Manual: The Official Reference Document for OpenGL, Release 1</i>. Reading, MA: Addison-Wesley, 1992. ISBN 0-201-63276-4. (This book is also known as the "Blue Book".)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: Introducing the OpenGL Interface, Part I." <i>Microsoft Systems Journal</i> 9 (October 1994). (MSDN Library Archive Edition, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Advanced 3-D Graphics for Windows NT 3.5: The OpenGL Interface, Part II." <i>Microsoft Systems Journal</i> 9 (November 1994). (MSDN Library Archive Edition, Books and Periodicals)</p>
<p>
Prosise, Jeff. "Understanding Modelview Transformations in OpenGL for Windows NT." <i>Microsoft Systems Journal</i> 10 (February 1995).</p>
<p>
Rogerson, Dale. <a href="msdn_gl1.htm">"OpenGL I: Quick Start."</a>. December 1994. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl2.htm">"OpenGL II: Windows Palettes in RGBA Mode"</a>. December 1994. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl4.htm">"OpenGL IV: Color Index Mode."</a> January 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl5.htm">"OpenGL V: Translating Windows DIBs."</a> February 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl6.htm">"OpenGL VI: Rendering on DIBs with PFD_DRAW_TO_BITMAP."</a> April 1995. (MSDN Library, Technical Articles)</p>
<p>
Rogerson, Dale. <a href="msdn_gl7.htm">"OpenGL VII: Scratching the Surface of Texture Mapping."</a> May 1995. (MSDN Library, Technical Articles)</p>
<p>
Microsoft Win32 Software Development Kit (SDK) for Windows NT 3.5 <i>OpenGL Programmer's Reference</i>.</p>
<p>
"Technical Note 33: DLL Version of MFC." (MSDN Library, Developer Products, Visual C/C++ Microsoft Foundation Class Reference, MFC Notes).</p>
</BODY>
</HTML>
