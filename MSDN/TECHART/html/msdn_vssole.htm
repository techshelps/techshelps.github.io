<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft Visual SourceSafe OLE Automation</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_vssole"></a>Microsoft Visual SourceSafe OLE Automation</h1>
<p>
Ken Felder<br>
Microsoft Corporation</p>
<p>
October 1995</p>
<h3>Contents</h3>
<p>
<a href="#vssoleintro">Introduction</a></p>
<p>
<a href="#vssobjmod">The Visual SourceSafe Object Model</a></p>
<p>
<a href="#vssevents">Visual SourceSafe Events (the IVSSEvents Interface)</a></p>
<p>
<a href="#vsserrhandl">Error Handling</a></p>
<h2><a name="vssoleintro"></a>Introduction</h2>
<p>
This specification describes the OLE Automation interfaces to Microsoft® Visual SourceSafe™ version 5.0. Future versions of Visual SourceSafe will attempt to make as few changes as possible to these interfaces. Versions earlier than Visual SourceSafe 5.0 do not support these interfaces in any way.</p>
<p>
A Microsoft Visual Basic® application can get a Visual SourceSafe object and begin executing <i>commands</i> (such as "Get this file" or "Tell me whether this file is currently checked out"). It can also register itself to receive <i>events</i> from Visual SourceSafe. ("Let me know if someone checks this file out.") The two can be used together: for instance, if you programmatically tell Visual SourceSafe to check a file out, an event is triggered, letting Visual SourceSafe add-ins (and your own) know that the file is about to be checked out. Hence, the following code would cause a system hang by creating an endless loop of events.</p>
<pre><code>Sub BeforeCheckout (File as VSSItem, Local as String)
File.Checkout
End Sub
</code></pre>
<p>
Avoiding this kind of loop is the responsibility of the user and only requires a little common sense.</p>
<h3><a name="vssolehook"></a>Hooking Up to Drive Visual SourceSafe</h3>
<p>
Finding a Visual SourceSafe object to drive is similar to&nbsp; finding any other OLE object. A Visual Basic programmer&nbsp; would:</p>
<pre><code>Dim Database as new VSSDatabase 
</code></pre>
<p>
and then call: </p>
<pre><code>Database.Open 
</code></pre>
<p>
A C++ programmer would: </p>
<pre><code>CoCreateInstance 
</code></pre>
<p>
the same object, and once again call the <b>Open</b> method.</p>
<p>
The globally unique identifier (GUID) for the Visual SourceSafe database object, found in the file SSAPI.DLL, is 783CD4E2-9D54-11cf-B8EE-00608CC9A71F. You can view the GUID and other information in the .DLL by using the Object Browser in Visual Basic or the utility OLE2VW32.EXE (which comes with Microsoft Visual C++®).</p>
<h3>Hooking Up to Receive Visual SourceSafe Events</h3>
<p>
To register for Visual SourceSafe events, add your tool to the user's registry so that Visual SourceSafe can <b>CoCreateInstance</b> your event handling object.</p>
<p>
In addition, add yourself to the file SSADDIN.INI. You find this file by looking in the registry under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\SourceSafe\SCCServerPath, which will give the path to a file called SSSCC.DLL. SSADDIN.INI should live in that same directory. Then add a line containing &lt;<i>your ProgID</i>&gt;=1 to this file to register yourself as an add-in.</p>
<p>
As an example, suppose that the registry variable were set to C:\VSS\WIN32\SSSCC.DLL. You would want a file called C:\VSS\WIN32\SSADDIN.INI. If that file did not exist, you would create it; if it did exist, you would open it. Then, supposing your programmatic identifier (ProgID) were "CoolAddIn," you would add the line "CoolAddIn=1" to the file. This would tell Visual SourceSafe to load your add-in based on a registry lookup on that ID.</p>
<p>
Visual SourceSafe connects to your add-in via the standard connection point interfaces. The following is a brief overview of the system; see the OLE reference manuals for more detail.
<ol>
<li>
Visual SourceSafe finds your ProgID in SSADDIN.INI.<br><br></li>
<li>
Based on that, Visual SourceSafe calls <b>CoCreateInstance</b> on your ProgID to instantiate your object.<br><br></li>
<li>
Visual SourceSafe queries your object for an interface called <b>IVSSEventHandler</b>. Your object must support this interface which contains only one method: <b>Init</b>.<br><br></li>
<li>
Visual SourceSafe calls your <b>Init</b> method, passing in a pointer to an interface called <b>IVSS</b> on a Visual SourceSafe object.<br><br></li>
<li>
You then <b>QueryInterface</b> from <b>IVSS</b> to another interface on the same object, called <b>IConnectionPointContainer</b>. This interface supports a method called <b>FindConnectionPoint</b>.<br><br></li>
<li>
From that interface, you call <b>FindConnectionPoint(IID_IVSSEvents)</b>, which returns an interface called <b>IConnectionPoint</b>.<br><br></li>
<li>
From <i>that</i> interface, you call the <b>Advise</b> method, passing a pointer to your own <b>IVSSEvents</b> interface.<br><br></li>
<li>
Visual SourceSafe is then hooked up and will start calling methods in your <b>IVSSEvents</b> interface.</li>
</ol>
<p>
A few notes about this process.
<ul type=disc>
<li>
Your add-in that receives Visual SourceSafe events must be an in-process .DLL. So, if you want to catch Visual SourceSafe events, and then drive Visual SourceSafe based on them, you must put all your driving code into that .DLL or, if it is in a Visual Basic application, set up your own communication from the event handler to the application.<br><br></li>
<li>
Visual SourceSafe may shut down and start up your add-in at will.<br><br></li>
<li>
You should <i>not</i> <b>CoCreateInstance</b> Visual SourceSafe to open another database while you are in the middle of an event. You should only work on the Visual SourceSafe database that triggered the event. You can see information about this database by retrieving the <b>VSSDatabase</b> property from the <b>IVSS</b> interface (which you were handed in step 4 above). From that database interface, you can gain access to all the objects, properties, and methods in the database.</li>
</ul>
<h3>Other Technical Notes</h3>
<p>
A few miscellaneous, but important, remarks:
<ul type=disc>
<li>
The Visual SourceSafe objects are implemented by dual interfaces, meaning that they can be driven by either C++/COM (early bound) or Visual Basic/Automation (late bound) calls. Users calling from Visual Basic must use Visual Basic 5.0 or later, as this interface relies on certain features that were not available in earlier versions.<br><br></li>
<li>
This interface has no direct user interface. Any user interface must be supplied by the programmer.<br><br></li>
<li>
The Visual SourceSafe interfaces are thread safe.<br><br></li>
<li>
You can make multiple calls that access different databases. However, internally, Visual SourceSafe will actually shut down one database and open another when you switch! This can be quite slow, so it should be done judiciously. In addition, certain restrictions apply. You cannot open another database while you are in the middle of enumerating a history and you cannot open a database from within an event call.<br><br></li>
<li>
The Visual SourceSafe objects are served by an in-proc server (a .DLL). The objects can not be aggregated.<br><br></li>
<li>
Once you create a Visual SourceSafe <b>VSSItem</b> (file or project) in memory, that object stays in memory until it is released. It may therefore become out of date! For instance, if you instantiate a <b>VSSItem</b> representing a file, that in-memory item knows whether the file is checked out. But if you ask it an hour later, its information may no longer be correct. So it is not recommended to keep these objects in memory for too long.<br><br></li>
<li>
Similar considerations apply to the <b>VSSItems</b> collection because it never changes in memory. Even if your code deletes a file, that file will not disappear from the collection!</li>
</ul>
<h2><a name="vssobjmod"></a>The Visual SourceSafe Object Model</h2>
<p>
The Visual SourceSafe object model, as seen in Figure 1, is very simple.</p>
<p>
<img src="vssole_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The Visual SourceSafe object model.</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=34%><b>VSSDatabase</b></td>
<td width=66%>A Visual SourceSafe database.</td>
</tr>
<tr valign=top>
<td width=34%><b>VSSItem</b></td>
<td width=66%>A project or file. Note that there is also a <b>VSSItems</b>, which is a collection for all the children in one project.</td>
</tr>
<tr valign=top>
<td width=34%><b>VSSVersion</b></td>
<td width=66%>One way of representing a specific version of a file or project. A <b>VSSVersions</b> is a collection of all the versions of a particular file or project.</td>
</tr>
<tr valign=top>
<td width=34%><b>VSSCheckout</b></td>
<td width=66%> A checkout record on a file. Note that once again there is a collection, because one file may have many simultaneous checkouts.</td>
</tr>
</table><br>
<h3>The VSSDatabase Object and IVSSDatabase</h3>
<p>
The <b>VSSDatabase</b> object represents one Visual SourceSafe database, logged in as one user. It supports the <b>IVSSDatabase</b> interface, which contains the methods and properties described below.</p>
<p>
This interface is very important because it is the starting point of a Visual SourceSafe session. You always start by calling the <b>Open</b> method to login, and then you get a <b>VSSItem</b>, which is the launching point for all Visual SourceSafe commands.</p>
<h4>Database properties</h4>
<pre><code>HRESULT VSSItem ([in]BSTR Spec, [in,defaultvalue(0)]boolean bDeleted, (out,retval)IVSSItem **ppIVSSItem);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
This is the key property in this interface. You pass in a <i>spec,</i> such as "$/A/B" (which represents a Visual SourceSafe project) or "$/A/B/FU.FRM" (which represents a Visual SourceSafe file). This returns a <b>VSSItem</b> object<i> </i>that represents that object. Thereafter, you can perform Visual SourceSafe commands and queries on that object by using the <b>IVSSItem</b> interface. Note that if you pass in a nonzero value for bDeleted, you are asking for a file or project that is <i>deleted</i> inside the Visual SourceSafe database.</li>
</ul>
<pre><code>HRESULT SrcSafeIni ([out,retval]BSTR *pSrcSafeIni);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
Gives you the path and name of the SRCSAFE.INI file (which in turn is associated with a particular Visual SourceSafe database). This is used in conjunction with the <b>Open</b> call in the following way. When you are adding a new project to Visual SourceSafe for the first time, it is valid to call <b>Open</b> without specifying a SRCSAFE.INI file. You then add the project, but you do not know what database it was added to! So you get the <b>SrcSafeIni</b> property of the database and persist it somewhere. The <i>next</i> time you want to work with this project, you call <b>Open</b> and pass in that same SRCSAFE.INI file; this ensures that you have the same database, so you should be able to find the same project.</li>
</ul>
<pre><code>HRESULT DatabaseName ([out,retval]BSTR *pDatabaseName);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
Gives you the user-defined name of the Visual SourceSafe database. This is the name that users see when they select a database to open in Visual SourceSafe.</li>
</ul>
<pre><code>HRESULT UserName ([out,retval]BSTR *pUsername);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
Gives you the currently logged-in user name.</li>
</ul>
<pre><code>HRESULT CurrentProject ([out,retval]BSTR *pPrj);
HRESULT CurrentProject ([in]BSTR Prj);
</code></pre>
<ul type=disc>
<li>
Read-write property.<br><br></li>
<li>
Represents the user's current project, which can be retrieved or changed.</li>
</ul>
<h4>Database methods</h4>
<pre><code>HRESULT Open ([in,defaultvalue(0)]BSTR SrcSafeIni, [in,defaultvalue(0)]BSTR Username, [in,defaultvalue(0)]BSTR Password);
</code></pre>
<p>
This function is how you log into Visual SourceSafe. The first parameter specifies the path and name of a SRCSAFE.INI file to use and is therefore a way of choosing a Visual SourceSafe database. The other parameters specify a user name and password; if you do not specify them, Visual SourceSafe will find the user name from Windows or a user-defined environment variable, if possible. If the user cannot be logged in from this information, the call will fail.</p>
<p>
If you do not pass in a <b>SrcSafeIni</b> parameter, Visual SourceSafe will attempt to find the SRCSAFE.INI file itself, using essentially the same algorithm that the Visual SourceSafe Explorer uses. This is a good thing to do if you just want to use whatever Visual SourceSafe database the user tends to work with; however, note that successive calls to <b>Open</b> may wind up in different databases! One safe way to work is to call <b>Open</b> with no <b>SrcSafeIni</b> variable and add your project to Visual SourceSafe, and then get and save the <b>SrcSafeIni</b> property. The next time you want to find that project again, call <b>Open</b> passing in that <b>SrcSafeIni</b> value, and you will be sure of opening the same database.</p>
<h3>The VSSItem Object and IVSSItem</h3>
<p>
This object can represent either a file or project in Visual SourceSafe, or an <i>old version</i> of a file or project. It exposes the <b>IVSSItem</b> interface, which is where almost all Visual SourceSafe commands and queries are found. (Old versions are discussed in more detail later, in the section on versions.)</p>
<p>
There are two primary ways to get an <b>IVSSItem</b> pointer. One is through a call to <b>IVSSDatabase::VSSItem</b> where you essentially make the very specific request: "give me an <b>IVSSItem</b> pointer for $/My/Web/FU.HTML." The other is through the <b>VSSItems</b> object, which is a collection of all the children of a project: "give me <b>IVSSItem</b> pointers for all the children of $/My/Web."</p>
<h4>Item properties</h4>
<pre><code>HRESULT Spec ([out,retval]BSTR *pSpec);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
Valid for files and projects.<br><br></li>
<li>
Gives you the item's full project spec, such as $/My/Web/FU.HTML. This spec may be how you got to the <b>IVSSItem</b> in the first place. However, if you got to it by enumerating the children of a project, you can then use this property to actually find the names of all the items.</li>
</ul>
<pre><code>HRESULT LocalSpec ([out,retval]BSTR *pLocal);
HRESULT LocalSpec ([in]BSTR Local);
</code></pre>
<ul type=disc>
<li>
Read-write property.<br><br></li>
<li>
Valid to read for files or projects; valid to write for projects and invalid to write for files.<br><br></li>
<li>
Represents the local item that corresponds to this Visual SourceSafe item. For a project, this is the user's <i>working folder</i> for the project. For a file, it is the file name in the working folder for the project.</li>
</ul>
<pre><code>HRESULT Name ([out,retval]BSTR *pName);
HRESULT Name ([in]BSTR Name);
</code></pre>
<ul type=disc>
<li>
Read-write property.<br><br></li>
<li>
Valid for files and projects.<br><br></li>
<li>
Returns the name of a project or file without the path. So if Spec returns $/A/B/FU.CPP, this property will be FU.CPP. Setting this variable is the way to programmatically rename a file or project.</li>
</ul>
<pre><code>HRESULT Parent ([out,retval]IVSSItem **ppIParent);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
Valid for files and projects.<br><br></li>
<li>
Returns a <b>VSSItem</b> interface for the item's parent project. For instance, if you pass this the item that represents $/A/B/FU.CPP, you receive back an item that represents $/A/B.</li>
</ul>
<pre><code>HRESULT Type ([out,retval]int *piType);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
Valid for files and projects.<br><br></li>
<li>
Returns VSSITEM_PROJECT for projects, VSSITEM_FILE for files.</li>
</ul>
<pre><code>HRESULT Deleted ([out,retval]boolean *pbDeleted);
HRESULT Deleted ([in]boolean bDeleted);
</code></pre>
<ul type=disc>
<li>
Read-write property.<br><br></li>
<li>
Valid for files and projects.<br><br></li>
<li>
In Visual SourceSafe, a normal delete simply "tags" the item as deleted. Hence, <i>deleted</i> is simply a flag which can be turned on and off for a particular file or project. When an item is deleted, it will not be returned by most function calls and should not generally be displayed to the user alongside nondeleted files. The only operations that are valid to perform on a deleted item is to <b>Undelete</b> it (by turning off the flag) or <b>Destroy</b> it (which permanently removes the item from the Visual SourceSafe database).</li>
</ul>
<pre><code>HRESULT IsCheckedOut ([out,retval]long *piStatus);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
Valid for files only (invalid for projects).<br><br></li>
<li>
Returns VSSFILE_NOTCHECKEDOUT if the file is not checked out, VSSFILE_CHECKEDOUT if the file is checked out to another user, and VSSFILE_CHECKEDOUT_ME if the file is checked out to the current user. For more detailed information on the checkout status of the file, use the <b>Checkouts</b> property to get a <b>VSSCheckouts</b> for the file.</li>
</ul>
<pre><code>HRESULT IsDifferent ([in,defaultvalue(0)]BSTR Local, [out,retval]boolean *pbDifferent);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
Valid for files only (invalid for projects).<br><br></li>
<li>
If you do not pass in a <i>Local</i>, this compares the file in Visual SourceSafe against its local equivalent. If you do pass in the parameter, this compares the file in Visual SourceSafe against the file that you pass. Either way, it returns a Boolean value indicating whether the two files are different or not.</li>
</ul>
<pre><code>HRESULT Binary ([out,retval]boolean *pbBinary);
HRESULT Binary ([in]boolean bBinary);
</code></pre>
<ul type=disc>
<li>
Read-write property.<br><br></li>
<li>
Valid for files only (invalid for projects).<br><br></li>
<li>
Represents whether a particular file is binary (as opposed to being straight ASCII text).<br><br></li>
</ul>
<pre><code>HRESULT VersionNumber ([out,retval]long *piVersion);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
Valid for files and projects.<br><br></li>
<li>
Represents the current version number of the file or project. In most cases, this means the most recent version number. However, in the case of a <b>VSSItem</b> that represents an old version, this of course returns that version number. More subtly, if the <b>VSSItem</b> represents a <i>pinned file,</i> this returns the version number that is pinned. In all cases, this is the version number of the item that you would receive if you called the <b>Get</b> method on this <b>VSSItem</b>.</li>
</ul>
<h4>Collections that are retrieved as properties of an item</h4>
<pre><code>HRESULT Items ([in,defaultvalue(0)]boolean IncludeDeleted, [out,retval]IVSSItems **ppIItems);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
Valid for projects only (invalid for files).<br><br></li>
<li>
This gives you a collection for all the children (files and subprojects) of a project. It does not work recursively; only direct children are returned, so the user must manually implement recursion (see the description of the <b>VSSItems</b> collection for more information). <b>IncludeDeleted</b> says to return deleted children as well as nondeleted ones.</li>
</ul>
<pre><code>HRESULT Checkouts ([out,retval]IVSSCheckouts **ppICheckouts);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
Valid for files only (invalid for projects).<br><br></li>
<li>
This gives you a collection of all the checkout records of a file. If the file is not checked out, of course, the resulting set will have no elements; if the file is checked out only once, there will be only one element. But in general, one file may have many checkouts at one time.</li>
</ul>
<h4>Item methods</h4>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Many of the methods described here have a parameter called <i>iFlags</i>. The usage of this parameter is described in detail after the list of methods.</p>
<pre><code>HRESULT Add ([in]BSTR Local, [in,defaultvalue(0)]BSTR Comment, [in,defaultvalue(0)]long iFlags, [out,retval]IVSSItem **ppIItem);
</code></pre>
<ul type=disc>
<li>
Valid for projects only (invalid for files).<br><br></li>
<li>
Add the passed file or directory to the project that you are calling the method on. <i>Local</i> is the full local spec of a file or directory to <b>Add</b>; <i>Comment</i> is a comment. The function returns an <b>IVSSItem</b> pointer for the newly added file. <i>iFlags</i> can contain options from each of the following sets: DELTA, RECURS, USERO, KEEPCHECK, BINTYPE, and DEL.</li>
</ul>
<pre><code>HRESULT NewSubproject ([in]BSTR Name, [in,defaultvalue(0)]BSTR Comment, [out,retval]IVSSItem **ppIItem);
</code></pre>
<ul type=disc>
<li>
Valid for projects only (invalid for files).<br><br></li>
<li>
Creates a Visual SourceSafe subproject in the project that you are calling the method on. <i>Name</i> is the name only (not the full spec!) of the project to create. The function returns an <b>IVSSItem</b> pointer for the newly created subproject.<ul type=disc>
</ul>
</li>
</ul>
<pre><code>HRESULT Destroy ();
</code></pre>
<ul type=disc>
<li>
Valid for files and projects.<br><br></li>
<li>
Destroys (permanently removes) the item that you are calling this method on. After you call this method, the <b>VSSItem</b> object now refers to an file or project that no longer exists. You should <b>Release()</b> the <b>VSSItem</b> as soon as possible and should not call any other operations on it.<p class=tl>
<b>Note:</b> This is one of the few methods that can be called validly on a deleted item; whether the item was previously deleted or not, it is gone after this call.</P></li>
</ul>
<pre><code>HRESULT Get ([in,out,defaultvalue(0)]BSTR *Local, [in,defaultvalue(0)]long iFlags);
</code></pre>
<ul type=disc>
<li>
Valid for files and projects.<br><br></li>
<li>
Gets a file or project. <i>Local</i> is the local file name or directory to <b>Get</b> it to. If <i>Local</i> is omitted (in Visual Basic) or set to NULL (in VC++), the function automatically determines the local spec. If <i>Local</i> is an empty string (" "), the file is placed in a unique file name in the temporary directory, and the full path and name of the file is placed in <i>Local</i>. <i>iFlags</i> can contain options from each of the following sets: RECURS, USERO, CMPMETHOD, TIMESTAMP, EOL, REPLACE, and FORCE.</li>
</ul>
<pre><code>HRESULT Checkout ([in,defaultvalue(0)]BSTR Comment, [in,defaultvalue(0)]BSTR Local, [in,defaultvalue(0)]long iFlags);
</code></pre>
<ul type=disc>
<li>
Valid for files and projects.<br><br></li>
<li>
Checks out a file or project. <i>Comment</i> is the <b>Checkout</b> comment; <i>Local</i> is the local spec to retrieve the file to (it works just like <i>Local</i> in <b>Get</b>). <i>iFlags</i> can contain options from each of the following sets: GET, RECURS, USERO, CMPMETHOD, TIMESTAMP, EOL, REPLACE, FORCE, and CHKEXCLUSIVE.</li>
</ul>
<pre><code>HRESULT Checkin ([in,defaultvalue(0)]BSTR Comment, [in,defaultvalue(0)]BSTR Local, [in,defaultvalue(0)] long iFlags);
</code></pre>
<ul type=disc>
<li>
Valid for files and projects.<br><br></li>
<li>
Checks in a checked-out file or project. <i>Comment</i> is the comment; <i>Local</i> is the local file name, with directory path, to check in. If <i>Local</i> is NULL, the function will check in the file from wherever the file is checked out to (which is what you almost always want). However, by setting this parameter you can check a file in from a different directory—or you can specify which, of multiple checkouts that the same user has made, to check in. <i>iFlags</i> can contain options from each of the following sets: RECURS, USERO, CMPMETHOD, TIMESTAMP, EOL, REPLACE, FORCE, KEEPCHECK, DEL, and UPD.</li>
</ul>
<pre><code>HRESULT UndoCheckout ([in,defaultvalue(0)]BSTR Local, [in,defaultvalue(0)]long iFlags);
</code></pre>
<ul type=disc>
<li>
Valid for files and projects.<br><br></li>
<li>
Undoes a <b>Checkout</b> of a file or all files in a project. <i>Local</i> is the local file name or directory path to <b>Undocheckout</b>. <i>Local</i> works exactly as it does in <b>Checkin</b>. <i>iFlags</i> can contain options from each of the following sets: RECURS, USERO, CMPMETHOD, TIMESTAMP, EOL, REPLACE, FORCE, KEEPCHECK, and DEL.</li>
</ul>
<pre><code>HRESULT Share ([in]IVSSItem *pIItem, [in,defaultvalue(0)]BSTR Comment, [in,defaultvalue(0)]long iFlags);
</code></pre>
<ul type=disc>
<li>
Valid for files and projects.<br><br></li>
<li>
Shares the specified item (file or project) into the current project. The comment is used only when sharing a project and as the creation comment for the new project. <i>iFlags</i> can contain options from each of the following sets: RECURS and GET.</li>
</ul>
<pre><code>HRESULT Move ([in]IVSSItem *pINewParent);
</code></pre>
<ul type=disc>
<li>
Valid for projects only (invalid for files).<br><br></li>
<li>
Moves the project into the specified parent project.</li>
</ul>
<pre><code>HRESULT Label ([in]BSTR Label, [in,defaultvalue(0)]BSTR Comment);
</code></pre>
<ul type=disc>
<li>
Valid for files and projects.<br><br></li>
<li>
Puts a label on the file or project. In general, this labels the current version of the file or project; however, if the <b>VSSItem</b> represents an old version<i>,</i> the label is applied to that old version.</li>
</ul>
<pre><code>HRESULT Version ([in,optional]VARIANT Version, [out,retval]IVSSItem **ppIItem);
</code></pre>
<ul type=disc>
<li>
Valid for files and projects.<br><br></li>
<li>
The idea here is that you pass in information about a version and Visual SourceSafe returns a <b>VSSItem</b> that represents that particular version of a file or project. <i>Version</i> is a string that can be in one of three formats. If it is a valid date string (for example, 6/12/96), the version is retrieved based on the state of the file or project at that particular date. If it is a valid numerical string (for example, 12), it represents that particular numbered version of the file or project. If it is neither a date string or a number (for example, 2.00b), it is treated as a label.</li>
</ul>
<pre><code>HRESULT Versions ([in, defaultvalue(0)]long iFlags, [out,retval]IVSSVersions **ppIVersions);
</code></pre>
<ul type=disc>
<li>
Valid for files and projects.<br><br></li>
<li>
Returns a collection of all the versions of a file or project. <i>iFlags</i> is only used when getting the history of a project<i>,</i> and can contain options from each of the following sets:<code> </code>RECURS and HISTIGNOREFILES.</li>
</ul>
<h4>The iFlags parameter</h4>
<p>
Each time there is an <i>iFlags</i> parameter, you can pass zero, which means "do all the default things, as specified by the system and/or the user's SS.INI file." The only time you actually pass any of the flags is when you want to explicitly <i>override</i> a particular behavior, to say "do this thing" or "don't do this thing."</p>
<p>
As an example, for recursion, you can pass zero, meaning "either recurse or don't, depending on the user's settings." Or, you can pass VSSFLAG_RECURSNO, meaning "do not recurse, no matter what the user's settings are" or VSSFLAG_RECURSYES, meaning "do recurse, no matter what the user's settings are." In general, of course, the default (0) settings should be used unless there is some particular reason to override them.</p>
<p>
These flags can be combined by using the <b>Or</b> operator in C++, or simply by adding them in Visual Basic or Visual C++. So you could pass (VSSFLAG_RECURSNO+VSSFLAG_USEROYES), explicitly setting those two settings, but leaving the others to their defaults. Of course, (VSSFLAG_RECURSNO+VSSFLAG_RECURSYES) is invalid.</p>
<p>
The actual flags are described below.</p>
<pre><code>VSSFLAG_USEROYES
VSSFLAG_USERONO
</code></pre>
<p class=indent>
Indicate whether the read-only flag should be used and assumed in the user's local director</p>
<pre><code>VSSFLAG_TIMENOW
VSSFLAG_TIMEMOD
VSSFLAG_TIMEUPD
</code></pre>
<p class=indent>
Indicate what date/time stamp Visual SourceSafe should give the local file: the current time (default), the last modification time, or the last check-in time.</p>
<pre><code>VSSFLAG_EOLCR
VSSFLAG_EOLLF
VSSFLAG_EOLCRLF
</code></pre>
<p class=indent>
Indicate what end-of-line character should be used: carriage-return, line-feed, or carriage-return/line-feed.</p>
<pre><code>VSSFLAG_REPREPLACE
VSSFLAG_REPSKIP
VSSFLAG_REPMERGE
VSSFLAG_REPASK
</code></pre>
<p class=indent>
Indicate what to do if a <b>Get</b> would replace an existing writable file on the user's local drive: replace the file, skip the file, or merge into the file. REPASK means that Visual SourceSafe calls your error handling callback function to find out whether it should replace the file or not.</p>
<pre><code>VSSFLAG_CMPFULL
VSSFLAG_CMPCHECKSUM
VSSFLAG_CMPTIME
</code></pre>
<p class=indent>
Indicate how Visual SourceSafe should determine if a file is out of date. When you <b>Get</b> a file, Visual SourceSafe does not physically copy it over if you already have the correct file. By default, a checksum is used for this comparison.</p>
<pre><code>VSSFLAG_RECURSNO
VSSFLAG_RECURSYES
</code></pre>
<p class=indent>
Indicate whether a command should be recursive, that is, whether it should act on an entire project tree.</p>
<pre><code>VSSFLAG_FORCEDIRNO
VSSFLAG_FORCEDIRYES
</code></pre>
<p class=indent>
When Visual SourceSafe recursively gets a project tree, it can put each subproject into its own working directory (FORCEDIRYES), or create a directory tree, ignoring the working directories of subprojects (FORCEDIRNO).</p>
<pre><code>VSSFLAG_KEEPYES
VSSFLAG_KEEPNO
</code></pre>
<p class=indent>
Indicate whether Visual SourceSafe should keep the file checked out after adding or checking it in.</p>
<pre><code>VSSFLAG_DELYES
VSSFLAG_DELNO
VSSFLAG_DELNOREPLACE
</code></pre>
<p class=indent>
Indicate whether the local file should be deleted after an <b>Add</b>, <b>Checkin</b>, or <b>Undocheckout</b>. The third value—replace the local copy with the Visual SourceSafe copy—is valid only on <b>Undocheckout</b>, where it is the default behavior in general.</p>
<pre><code>VSSFLAG_BINBINARY
VSSFLAG_BINTEXT
</code></pre>
<p class=indent>
Indicate whether a file is text or binary. If neither flag is passed, Visual SourceSafe automatically detects the file type at add-time.</p>
<pre><code>VSSFLAG_DELTAYES
VSSFLAG_DELTANO
</code></pre>
<p class=indent>
Indicate whether the file being added to Visual SourceSafe will store old versions of itself (<i>Deltas</i>) or not.</p>
<pre><code>VSSFLAG_UPDUPDATE
VSSFLAG_UPDUNCH
</code></pre>
<p class=indent>
Indicate whether a file being checked in that has not changed at all should be registered as a <b>Checkin</b> (creating a new version), or an <b>Undocheckout</b>. UPDASK means that Visual SourceSafe calls your error handling callback function to find out whether it should check the file in or not.</p>
<pre><code>VSSFLAG_GETYES
VSSFLAG_GETNO
</code></pre>
<p class=indent>
Indicate whether the file should be retrieved (gotten) on commands that do an automatic <b>Get</b>, such as <b>Checkout</b> and <b>Share</b>.</p>
<pre><code>VSSFLAG_CHKEXCLUSIVE
</code></pre>
<p class=indent>
Indicates whether a checkout should be exclusive. If you do <i>not</i> set this flag, the <b>Checkout</b> may be exclusive anyway due to the administrator's setting or the file type. But if you <i>do</i> set this flag, the <b>Checkout</b> will always be exclusive.</p>
<pre><code>VSSFLAG_HISTIGNOREFILES
</code></pre>
<p class=indent>
This flag is used in only one place—when you retrieve the <b>Versions</b> property of a project. The flag corresponds to the <b>Ignore file checkins</b> in the Visual SourceSafe Explorer project History dialog box, but in reverse. That is, if you do <i>not</i> set this flag, the History returns all the events in the life of the project <i>and all its files. </i>If you do set this flag, file histories are not scanned. Thus, you see only events in the life of the project (such as labels, file adds and deletes, and so on), and iterating through all the versions is much faster.</p>
<h3>The VSSItems Object and IVSSItems</h3>
<p>
When you want to iterate through all the children (files and subprojects) in a project, you get a <b>VSSItems</b> from that project. The <b>VSSItems</b> object is a collection of all the children of that project. It supports the standard properties and methods of a collection object.</p>
<h4>IVSSItems properties</h4>
<pre><code>HRESULT Count ([out,retval]long *piCount);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
The number of children under the project.</li>
</ul>
<h4>IVSSItems methods</h4>
<pre><code>HRESULT Item ([in]VARIANT sItem, [out,retval]IVSSItem **ppIItem);
</code></pre>
<ul type=disc>
<li>
Retrieves one particular item in the collection. The item may be specified as an integer, which represents a one-based index into the collection, or as a name.</li>
</ul>
<pre><code>HRESULT _NewEnum ([out,retval]IUnknown **ppIEnum);
</code></pre>
<ul type=disc>
<li>
Returns an enumerator (an <b>IEnumVariant</b>) that supports the standard <b>Next</b>, <b>Skip</b>, <b>Reset</b>, and <b>Clone</b> methods. This method is used explicitly by Visual C++ programmers; Visual Basic programmers do not call it directly, but use the for-each loop, which relies on the enumerator.</li>
</ul>
<h3>Digression About Handling Versions</h3>
<p>
Before diving into the details of the <b>VSSVersion</b> object, it is worthwhile to discuss how versions are treated in general in Visual SourceSafe OLE Automation.</p>
<h4>Two different objects to represent an old version</h4>
<p>
A specific old version of a file is represented by two different objects: a <b>VSSItem</b> and a <b>VSSVersion</b>. These two objects give you different abilities.</p>
<p>
This article has primarily discussed <b>VSSItems</b> that represent <i>a file in general</i> (with no reference to version): for instance, $/A/FU.HTML. However, a <b>VSSItem</b> can also be used to represent a <i>specific version of a file:</i> for instance, $/A/FU.HTML version 2. In both cases, the <b>VSSItem</b> gives you <i>general properties</i> of the object (such as its name) and <i>methods</i> (such as <b>Get</b>). So if you call <b>Get</b> on a <b>VSSItem</b> that represents $/A/FU.HTML in general, you get the latest version; but if you call <b>Get</b> on a <b>VSSItem</b> that specifically represents version 2 of that file, you get version 2. You should note that some methods and properties of the <b>IVSSItem</b> interface are not valid when acting on an old version. For instance, if you have a <b>VSSItem</b> that represents version 2 of the file, you cannot set the <b>Deleted</b> property on that object, or call the <b>Checkin</b> method. Such actions are only valid on the file in general, not on a specific version.</p>
<p>
The <b>VSSVersion</b> gives you <i>version-specific properties</i> of a specific version, such as the version number and the date/time associated with that change. One of the properties of a <b>VSSVersion</b> is the <b>VSSItem</b> associated with it. So, if you have a <b>VSSVersion</b> that represents version 2 of $/A/FU.HTML and you want to <b>Get</b> that version, you first find a <b>VSSItem</b> from the <b>VSSVersion</b>, and then call the <b>Get</b> method on that <b>VSSItem</b>. Note that you cannot go the other way! That is, there is no way—given a <b>VSSItem</b> that represents an old version—to retrieve a <b>VSSVersion</b> for that version.</p>
<p>
As a final note, projects are treated in the exact same way as files. Hence, version 12 of $/A is also represented by both a <b>VSSItem</b> and a <b>VSSVersion</b> object.</p>
<h4>How you get an old version</h4>
<p>
Suppose you have a <b>VSSItem</b> that represents the file $/A/FU.HTML in general (not version specific). How do you get objects that represent specific versions? There are two different ways.</p>
<p>
The first is the <b>Version</b> property. You retrieve the <b>Version</b> property on your general <b>VSSItem</b>, passing in a version identification string (representing a date, version number, or label), and you receive back a <b>VSSItem</b> representing that particular version of the same file.</p>
<p>
The second way is with the <b>Versions</b> property, which returns a <b>VSSVersions</b> collection on the general <b>VSSItem</b>. You iterate through that collection to list all the versions of the file or project. For each version that you receive, you can get properties to display or a <b>VSSItem</b> to act on.</p>
<p>
Both of these methods are described in more detail later in this article </p>
<h3>The VSSVersion Object and IVSSVersion</h3>
<p>
When you want to iterate through all the versions of a file or project, you use the <b>Versions</b> property of that file or project to get a <b>VSSVersion</b> object. You use that object to iterate through a series of <b>VSSVersion</b> objects, each of which has enough properties to display version information to the user.<i> </i>Using this object, therefore, you could create a display of the entire history of an object.</p>
<p>
However, this object has no methods. If you want to <b>Get</b> an old version, you use the <b>VSSItem</b> property to get a <b>VSSItem</b> that represents that particular version<i>,</i> and then call the <b>Get</b> method on that item.</p>
<h4>Version properties</h4>
<pre><code>HRESULT Username ([out,retval]BSTR *pUsername);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
This function gives you the name of the user who took the action for this version.</li>
</ul>
<pre><code>HRESULT VersionNumber ([out,retval]long *piVersion);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
This function gives you the version number for this version.</li>
</ul>
<pre><code>HRESULT Action ([out,retval]BSTR *pAction);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
This function gives you a string representing the action that caused this version, such as "Checked Into $/A".<p class=tl>
This is the key variable for understanding what this particular version means. It is also the variable that you would use to recreate the Visual SourceSafe history display in your application. Note, however, that this string does not always give you enough information. When you are enumerating the versions of a project, you may get the string above, "Checked Into $/A". How do you know which file was checked in? The only way to get this information is to use the <b>VSSItem</b> property of the <b>Version</b> object to retrieve a <b>VSSItem</b> that represents that version of that file<i>,</i> and then get the <b>Spec</b> or <b>Name</b> property of the <b>VSSItem</b> to find the file.</P></li>
</ul>
<pre><code>HRESULT Date ([out,retval]DATE *pDate);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
This function gives you the date/time that that this version was created.</li>
</ul>
<pre><code>HRESULT Comment ([out,retval]BSTR *pComment);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
This function gives you the comment left by the user who took the action for this version.</li>
</ul>
<pre><code>HRESULT Label ([out,retval]BSTR *pLabel);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
This function gives you the label associated with this version. Note that in Visual SourceSafe, any version of any file or project may be associated with a label. However, the most common scenario is that a new version entry in a project is created simply as a placeholder for the label.</li>
</ul>
<pre><code>HRESULT VSSItem ([out,retval]IVSSItem **ppIItem);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
This function gives you the <b>VSSItem</b> for this particular version. You can then call methods such as <b>Get</b> on that <b>VSSItem</b>.</li>
</ul>
<h3>The VSSVersions Object and IVSSVersions</h3>
<p>
The <b>VSSVersions</b> object is a collection of all the versions of a given file or project. However, it is a very odd collection object in a number of ways. </p>
<p>
The <b>Count</b> property and <b>Item</b> method are not implemented in this collection. The only way to use this collection is to call the <b>_NewEnum</b> method (in C++), or use a for-each loop (in Visual Basic).</p>
<p>
You cannot have more than one Versions enumerator open at once. This means that the <b>Clone</b> method is not implemented on the Versions enumerator. More importantly, it means that if you want to get the <i>recursive history</i> of a project, you should allow Visual SourceSafe to do it for you (by using the VSSFLAG_RECURSYES flag on the <b>Versions</b> property when you first get the collection), rather than doing the recursion manually.</p>
<p>
There is one further important note: not all the versions that you get are actually versions of the object you started with.</p>
<p>
If you are doing a history of $/A/FU.HTML, most of the versions you see will refer to that particular file. However, some of the versions you see will be labels that were applied to the project (not to the file). If you get back the label "2.00b," and then get a <b>VSSItem</b> for that version, you may be getting an item that represents FU.HTML (if the label was applied to the file), or an item that represents $/A (if the label was applied to the project).</p>
<p>
Similarly, if you are doing a history of $/A, you will see all the checkins of FU.HTML. So, once again, although you started with one thing (the project), some of your versions refer to a different thing (the file).</p>
<p>
So, here is a wrong way to use this interface. You want to find FU.HTML as it was on 10/27/93. You get a <b>Versions</b> collection and work your way through it until the date reaches that point; then you get a <b>VSSItem</b> from that version and call the <b>Get</b> method. You may retrieve exactly what you wanted; or, you may be very surprised to discover that you have retrieved the entire project!</p>
<p>
The right way to do that sort of operation is to use the <b>Version</b> method, not the collection. When you ask for the version of FU.HTML with a particular date or label, call <b>Version</b> on FU.HTML, passing in that date or label, and then call <b>Get</b> on that<i>. </i>The <b>Version</b> method, unlike the <b>Versions</b> collection, will always return a version of the item you started with.</p>
<h4>IVSSVersions methods</h4>
<pre><code>HRESULT _NewEnum ([out,retval]IUnknown **ppIEnum);
</code></pre>
<p class=indent>
Returns an enumerator (an <b>IEnumVariant</b>) that supports the standard <b>Next</b>, <b>Skip</b>, and <b>Reset</b> methods (but <i>not</i> <b>Clone</b>, since you can only have one such enumerator open at a time). This method is used explicitly by Visual C++ programmers; Visual Basic programmers do not call it directly, but use the for-each loop, which relies on the enumerator.</p>
<h3>The VSSCheckout Object and IVSSCheckout</h3>
<p>
Each <b>VSSCheckout</b> on a file represents one checkout record for that file. Hence, if the file is checked out five times, you will iterate through five such records in the <b>VSSCheckouts</b> collection. Each record contains information about that particular checkout in the form of seven properties.</p>
<h4>IVSSCheckout properties</h4>
<pre><code>HRESULT Username ([out,retval]BSTR *pUsername);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
The user who checked out the file.</li>
</ul>
<pre><code>HRESULT Date ([out,retval]DATE *pDate);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
The date/time of the file checkout.</li>
</ul>
<pre><code>HRESULT LocalSpec ([out,retval]BSTR *pLocal);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
The file name, with directory path, that the file was checked out to.</li>
</ul>
<pre><code>HRESULT Machine ([out,retval]BSTR *pMachine);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
The machine name that the file was checked out to.</li>
</ul>
<pre><code>HRESULT Project ([out,retval]BSTR *pProject);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
The project that the file was checked out from. This is relevant in the case of shared files. The file is actually checked out in all the projects that share it; however, this property tells you which project the user was working in when he checked the file out.</li>
</ul>
<pre><code>HRESULT Comment ([out,retval]BSTR *pComment);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
The checkout comment left by the user.</li>
</ul>
<pre><code>HRESULT VersionNumber ([out,retval]long *piVersion);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
The version number that the user checked out. Note that if this does not equal the current version number of the file, a merge will be necessary before the file can be checked in.</li>
</ul>
<h3>The VSSCheckouts Object and IVSSCheckouts</h3>
<p>
When you want very basic checkout information for a file, use the <b>IsCheckedOut</b> property. But when you want details, get a <b>VSSCheckouts</b> collection and use it to iterate all the checkouts on that file. You should note that the collection may potentially contain no items (the file is not checked out), one item (the file is checked out), or many items (the file is checked out multiple<i> </i>times<i>)</i>, and that merges will automatically be done on check in).</p>
<p>
The <b>VSSCheckouts</b> supports the standard properties and methods of a collection object.</p>
<h4>IVSSCheckouts properties</h4>
<pre><code>HRESULT Count ([out,retval]long *piCount);
</code></pre>
<ul type=disc>
<li>
Read-only property.<br><br></li>
<li>
The number of times that this file is currently checked out.</li>
</ul>
<h4>IVSSCheckouts methods</h4>
<pre><code>HRESULT Item ([in]VARIANT sItem, [out,retval]IVSSCheckout **ppICheckout);
</code></pre>
<p class=tl>
Retrieves one particular checkout record. The item may be specified in one of two ways: either by using an integer (which represents a one-based index into the collection) or by naming a user name (which returns the checkout record, if any, for that particular user).</P><pre><code>HRESULT _NewEnum ([out,retval]IUnknown **ppIEnum);
</code></pre>
<p class=tl>
Returns an enumerator (an <b>IEnumVariant</b>) that supports the standard <b>Next</b>, <b>Skip</b>, <b>Reset</b>, and <b>Clone</b> methods. This method is used explicitly by Visual C++ programmers; Visual Basic programmers do not call it directly, but use the for-each loop, which relies on the enumerator.</P><h2><a name="vssevents"></a>Visual SourceSafe Events (the IVSSEvents Interface)</h2>
<p>
The section <a href="#vssolehook">Hooking Up to Receive Visual SourceSafe Events</a> describes the steps you go through to register your add-in with Visual SourceSafe. When the process ends, Visual SourceSafe has found your <b>IVSSEvents</b> interface and is ready to start calling you.</p>
<p>
Visual SourceSafe exposes events for a few basic commands to Visual SourceSafe add-ins. All commands described by events are taking place on an individual file, so if a user checks out a project, a separate event will be generated for each file in the project.</p>
<p>
The Before event indicates that the user is about to take an action. It is your opportunity to prevent the command from occurring by setting the <i>*pbContinue</i> variable to <b>FALSE</b> (0). As a rule of thumb, you should use the Before event <i>only</i> for the purpose of possibly preventing the command. You should definitely not take any actions that assume the command will occur, because it is possible that another event after you will actually prevent the command.</p>
<p>
The After event indicates that the user just took an action. This is when it is appropriate for your program to do things that should be synchronized with the user action.</p>
<p>
Note that there is no way for your add-in to tell from where the command is coming. For instance, if you discover that a file is about to be added to Visual SourceSafe, it may be coming from the Visual SourceSafe Explorer, from an integrated development environment (IDE), or even from a Visual SourceSafe add-in using the OLE Automation interface—including your own program! However, it is definitely not coming from the Visual SourceSafe command line because the Visual SourceSafe command line (in version 5.0) does not send events. This unfortunately means that it is possible for a command to happen without your add-in ever getting notified.</p>
<pre><code>HRESULT BeforeAdd ([in]IVSSItem *piPrj, [in]BSTR Local, [out,retval]boolean *pbContinue);
</code></pre>
<p class=indent>
The specified file (<i>Local</i>) is about to be added to the Visual SourceSafe project piPrj.</p>
<pre><code>HRESULT AfterAdd ([in]IVSSItem *pIItem, [in]BSTR Local);
</code></pre>
<p class=indent>
A new file has been added to Visual SourceSafe. <code>*</code><i>piItem</i> is a <b>VSSItem</b> pointer for the newly created file.</p>
<pre><code>HRESULT BeforeCheckout ([in]IVSSItem *pIItem, [in] BSTR Local, [out,retval]boolean *pbContinue);
</code></pre>
<p class=indent>
The specified Visual SourceSafe file is about to be checked out to the specified local file name.</p>
<pre><code>HRESULT AfterCheckout ([in]IVSSItem *pIItem, [in] BSTR Local);
</code></pre>
<p class=indent>
The specified Visual SourceSafe file has been checked out to the specified local file name.</p>
<pre><code>HRESULT BeforeCheckin ([in]IVSSItem *pIItem, [in] BSTR Local, [out,retval]boolean *pbContinue);
</code></pre>
<p class=indent>
The specified Visual SourceSafe file is about to be checked in from the specified local file name.</p>
<pre><code>HRESULT AfterCheckin ([in]IVSSItem *pIItem, [in] BSTR Local);
</code></pre>
<p class=indent>
The specified Visual SourceSafe file has been checked in from the specified local file name.</p>
<pre><code>HRESULT BeforeUndoCheckout ([in]IVSSItem *pIItem, [in] BSTR Local, [out,retval]boolean *pbContinue);
</code></pre>
<p class=indent>
The specified Visual SourceSafe file is about to be unchecked out with the specified local file name.</p>
<pre><code>HRESULT AfterUndoCheckout ([in]IVSSItem *pIItem, [in] BSTR Local);
</code></pre>
<p class=indent>
The specified Visual SourceSafe file has been unchecked out with the specified local file name.</p>
<pre><code>HRESULT BeforeRename ([in]IVSSItem *piItem, [in]BSTR NewName, [out,retval]boolean *pbContinue);
</code></pre>
<p class=indent>
The specified file or project (*<i>piItem</i> ) is about to be renamed to the specified new name.</p>
<pre><code>HRESULT AfterRename ([in]IVSSItem *pIItem, [in]BSTR OldName);
</code></pre>
<p class=indent>
The specified file or project (*<i>piItem</i> ) has been renamed <i>from</i> the specified old name.</p>
<pre><code>HRESULT BeforeBranch ([in]IVSSItem *piItem, [out,retval]boolean *pbContinue);
</code></pre>
<p class=indent>
The specified file is about to be branched.</p>
<pre><code>HRESULT AfterBranch ([in]IVSSItem *pIItem);
</code></pre>
<p class=indent>
The specified file has been branched.</p>
<pre><code>HRESULT BeforeEvent ([in]long iEvent, [in]IVSSItem *piItem, [in]BSTR Str, [in]VARIANT var, [out,retval]boolean *pbContinue);
HRESULT AfterEvent ([in]long iEvent, [in]IVSSItem *piItem, [in]BSTR Str, [in]VARIANT var);
</code></pre>
<p class=indent>
These two events are included as part of the interface definition to allow for some expansion in the future without redefining the interface. If future events are added to the <b>IVSSEvents</b> interface, it will be done by calling <b>BeforeEvent</b> and <b>AfterEvent</b>, with the <i>iEvent</i> parameter designating the specific event, <i>*piItem</i> the file or project, and <i>Str</i> and <i>var</i> filling in any additional information required for the particular event. As of the writing of this spec, no <i>iEvent</i> codes are defined and these events are not used.</p>
<h2><a name="vsserrhandl"></a>Error Handling</h2>
<p>
There are two kinds of errors that can occur during the running of a Visual SourceSafe command: errors and yes/no questions. Because the Visual SourceSafe OLE Automation calls have no user interface component, neither of these can be directly shown to the user. Errors may be returned to the caller as indications that a function call failed. Questions are answered by default; your calling application never even knows the question happened.</p>
<h3>Errors</h3>
<p>
When you get an HRESULT back from a Visual SourceSafe method, you can use the standard OLE <b>FAILED</b> macro on that HRESULT to see if it indicates a failure. <b>FAILED</b> will tell you if an error occurred that was so severe that it prevented the method from completing.</p>
<p>
The following is a list of all the errors that may be returned by Visual SourceSafe OLE Automation. Please note that your application can call the OLE function <b>GetErrorInfo</b> to get an <b>IErrorInfo</b> pointer and use that standard interface to get more information about any returned errors (such as a string to display to the user and on-line help information to display more details). The strings given here are the U.S. English versions and are listed so that you know the meaning of the errors. If you want to display an error, you should always use <b>GetErrorInfo</b> rather than hard-coding these strings.</p>
<p>
Numerical values for these errors are in a file called SSAUTERR.H.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=39%><b>Error Code</b></td>
<td class=label width=61%><b>English String</b></td>
</tr>
<tr valign=top>
<td width=39%>ESS_CORRUPT</td>
<td width=61%>File %s may be corrupt.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_DT_BADDATESTR</td>
<td width=61%>Invalid date string: %s</td>
</tr>
<tr valign=top>
<td width=39%>ESS_DT_INVALID</td>
<td width=61%>Invalid time or date string.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_NOMORE_HANDLES</td>
<td width=61%>Too many file handles open.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_ACCESSDENIED</td>
<td width=61%>Access to file %s denied.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_BADDRIVE</td>
<td width=61%>Invalid drive: %s</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_BADHANDLE</td>
<td width=61%>Invalid handle.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_BADNAME</td>
<td width=61%>Invalid file name: %s</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_BADPARAM</td>
<td width=61%>Invalid access code (bad parameter).</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_BADPATH</td>
<td width=61%>Invalid DOS path: %s</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_CURRENTDIR</td>
<td width=61%>Folder %s is in use.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_DISKFULL</td>
<td width=61%>Disk full.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_EXISTS</td>
<td width=61%>File %s already exists.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_LOCKED</td>
<td width=61%>File %s is locked.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_NOTFOUND</td>
<td width=61%>File %s not found.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_READ</td>
<td width=61%>Error reading from file.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_SHARE</td>
<td width=61%>File %s is already open.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_TOOMANY</td>
<td width=61%>Too many file handles open.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_VOLNOTSAME</td>
<td width=61%>Cannot rename to another volume.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_FILE_WRITE</td>
<td width=61%>Error writing to file.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_INI_BADBOOL</td>
<td width=61%>Initialization variable %s must be set to Yes or No.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_INI_BADLINE</td>
<td width=61%>Invalid syntax on line %d of file %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_INI_BADNUMBER</td>
<td width=61%>Initialization variable %s set to invalid number.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_INI_BADPATH</td>
<td width=61%>Initialization variable %s set to invalid path.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_INI_BADVALUE</td>
<td width=61%>Initialization variable %s set to invalid value.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_INI_NOSUCHVAR</td>
<td width=61%>Cannot find initialization variable %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_INI_NUMRANGE</td>
<td width=61%>Initialization variable %s must be between %d and %d</td>
</tr>
<tr valign=top>
<td width=39%>ESS_INI_TOO_MANY_ENV</td>
<td width=61%>Too many SS.INI environment strings.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_LOCK_TIMEOUT</td>
<td width=61%>Timeout locking file: %s</td>
</tr>
<tr valign=top>
<td width=39%>ESS_MEM_NOMEMORY</td>
<td width=61%>Out of memory.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_NO_TWEAK_CHKDOUT</td>
<td width=61%>You cannot modify the properties of a file that is checked out.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_NOMERGE_BIN_NODELTA</td>
<td width=61%>You cannot perform a merge on a binary file or a file that stores latest version only.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_NOMULTI_BINARY</td>
<td width=61%>Cannot check out %s. It is binary and is already checked out.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_NOMULTI_NODELTA</td>
<td width=61%>%s stores only the latest version and is already checked out.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_OS_NOT_EXE</td>
<td width=61%>Error executing: %s</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_ADDPRJASSOCFILE</td>
<td width=61%>%s is a Visual SourceSafe configuration file and cannot be added.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_ADMIN_LOCKOUT</td>
<td width=61%>The Visual SourceSafe database has been locked by the Administrator.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_BADRENAME</td>
<td width=61%>Unable to rename %s to %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_CANT_FIND_SSINI</td>
<td width=61%>Cannot find SS.INI file for user %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_CHECKED_OUT</td>
<td width=61%>File %s is currently checked out by %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_CHECKED_OUT_YOU</td>
<td width=61%>You currently have file %s checked out.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_CHECKOUT_OLD</td>
<td width=61%>Cannot check out an old version of a file.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_CHKOUT_USER</td>
<td width=61%>File %s is currently checked out by %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_CONFLICTS</td>
<td width=61%>An automatic merge has occurred and there are conflicts. \nEdit %s to resolve them.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_DEL_ROOT</td>
<td width=61%>Cannot delete the root project.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_DEL_SHARED</td>
<td width=61%>A deleted link to %s already exists.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_FILE_NOTFOUND</td>
<td width=61%>File %s not found.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_HISTOPEN</td>
<td width=61%>A history operation is already in progress.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_INSUFRIGHTS</td>
<td width=61%>You do not have access rights to %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_LATERCHKEDOUT</td>
<td width=61%>A more recent version is checked out.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_LOCALRW</td>
<td width=61%>A writable copy of %s already exists.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_MOVE_CHANGENAME</td>
<td width=61%>Move does not change the name of a project.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_MOVE_NOPARENT</td>
<td width=61%>Project %s does not exist.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_MOVE_ROOT</td>
<td width=61%>Cannot move the root project.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_MUST_USE_VERS</td>
<td width=61%>Cannot roll back to the most recent version of %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_NOCOMMANCESTOR</td>
<td width=61%>Files have no common ancestor.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_NOCONFLICTS2</td>
<td width=61%>%s has been merged with no conflicts.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_NODOLLAR</td>
<td width=61%>File %s is invalid. Files may not begin with $.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_NOT_CHKEDOUT</td>
<td width=61%>File %s is not checked out.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_NOT_SHARED</td>
<td width=61%>File %s is not shared by any other projects.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_NOTSEPARATED</td>
<td width=61%>Files are not branched.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_OPEN_LOGGIN</td>
<td width=61%>Unable to open user login file %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_PATHTOOLONG</td>
<td width=61%>Path %s too long.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_RENAME_MOVE</td>
<td width=61%><b>Rename</b> does not move an item to another project.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_RENAME_ROOT</td>
<td width=61%>Cannot rename the root project.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_ROLLBACK_NOTOLD</td>
<td width=61%>Cannot rollback to the most recent version of %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_SHARE_ANCESTOR</td>
<td width=61%>A project cannot be shared under a descendant.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_SHARED</td>
<td width=61%>File %s is already shared by this project.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SSPEC_SYNTAX</td>
<td width=61%>Invalid Visual SourceSafe syntax: %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_UM_BAD_CHAR</td>
<td width=61%>Bad user name syntax: %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_UM_BAD_PASSWORD</td>
<td width=61%>Invalid password.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_UM_BADVERSION</td>
<td width=61%>Incompatible database version.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_UM_DEL_ADMIN</td>
<td width=61%>Cannot delete the Admin user.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_UM_PERM_DENIED</td>
<td width=61%>Permission denied.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_UM_RENAME_ADMIN</td>
<td width=61%>Can not rename the Admin user.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_UM_TOO_LONG</td>
<td width=61%>User name too long.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_UM_USER_EXISTS</td>
<td width=61%>User %s already exists.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_UM_USER_NOT_FOUND</td>
<td width=61%>User %s not found.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_URL_BADPATH</td>
<td width=61%>The URL for project %s was not set properly.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_CHECKED_OUT</td>
<td width=61%>File %s checked out.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_CHILD_NOT_FOUND</td>
<td width=61%>Subproject or file not found.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_COLLISION</td>
<td width=61%>Collision accessing database, please try again.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_EXCLUSIVE_CHECKED_OUT</td>
<td width=61%>File %s is exclusively checked out.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_ITEMEXISTS</td>
<td width=61%>An item with the name %s already exists.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_LONGNAME</td>
<td width=61%>%s is an invalid %s name.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_MOVE_CYCLE</td>
<td width=61%>You can not move a project under itself.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_NO_DELTA</td>
<td width=61%>File %s does not retain old versions of itself.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_NOT_CHECKED_OUT</td>
<td width=61%>File %s cannot be checked into this project.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_NOT_FOUND</td>
<td width=61%>File or project not found.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_PARENT_NOT_FOUND</td>
<td width=61%>Parent not found.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_VERS_NOT_FOUND</td>
<td width=61%>Version not found.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_WANT_FILE</td>
<td width=61%>This command only works on files.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_VS_WANT_PRJ</td>
<td width=61%>This command only works on projects.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_URL_BUFOVERFLOW</td>
<td width=61%>A link in %s was ignored because it was longer than Visual SourceSafe can understand.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_URL_CANTCHECKHTML</td>
<td width=61%>An error occurred while trying to check hyperlinks for %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_SS_ADDINFAILED</td>
<td width=61%>Error loading Visual SourceSafe add-in: %s.</td>
</tr>
<tr valign=top>
<td width=39%>ESS_CANCEL</td>
<td width=61%></td>
</tr>
<tr valign=top>
<td width=39%>ESS_LOADSTRING_FAILED</td>
<td width=61%>Error loading resource string.</td>
</tr>
</table><br>
<h3>Questions</h3>
<p>
The following questions can occur during the invocation of a Visual SourceSafe method. These questions will be answered automatically as indicated—your application will never know they happened. They are listed here, not because you can do anything about them, but so that you know what to expect when you call Visual SourceSafe.</p>
<p>
As an example, consider the following scenario: the user deletes the FU.CPP file in a project, and then attempts to re-add the same file (same name and same contents) to the same project. In the Visual SourceSafe Explorer, when the user attempts to add the file, he will be asked if he wants simply to recover the previously deleted file. When you call the <b>Add</b> method in the Visual SourceSafe OLE Automation, the answer to that question (the first one listed in the table below) is automatically yes; that is, the deleted file is recovered.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=80%><b>Question</b></td>
<td class=label width=20%><b>Answer</b></td>
</tr>
<tr valign=top>
<td width=80%>A deleted copy of this %s file already exists in this project.<p>
Do you want to recover the existing file?</p>
</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>Folder %s not found. Create?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>Have any conflicts in %s been properly resolved?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>File %s is currently checked out by %s. Proceed anyway?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>File %s was checked out to folder %s. Proceed in %s?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>File %s is checked out to project %s, and you are in %s.<p>
Proceed anyway?</p>
</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>File %s is currently checked out by %s. Delete anyway?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>You currently have file %s checked out. Delete anyway?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>An item named %s was already deleted from this project.<p>
Purge the old item and delete this one now?</p>
</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>This version of %s already has a label. Overwrite?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>The label %s is already used. Remove the old label?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>%s has been merged with no conflicts. Check in now?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>Redo the automatic merge?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>Delete local file: %s?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>%s is already checked out. Continue?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>File %s has been destroyed, and cannot be rebuilt. Continue anyway?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>Project $%s has been destroyed and cannot be rebuilt.<p>
Continue anyway?</p>
</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>$%s was moved out of this project and cannot be rebuilt.<p>
Continue anyway?</p>
</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>%s has changed. Undo check out and lose changes?</td>
<td width=20%>Yes</td>
</tr>
<tr valign=top>
<td width=80%>A deleted file of the same name already exists in this Visual SourceSafe project.<p>
Do you want to recover the deleted file instead of adding your local %s?</p>
</td>
<td width=20%>No</td>
</tr>
<tr valign=top>
<td width=80%>%s is writable. Replace?</td>
<td width=20%>No</td>
</tr>
<tr valign=top>
<td width=80%>%s is checked out. Replace?</td>
<td width=20%>No</td>
</tr>
</table><br>
</BODY>
</HTML>
