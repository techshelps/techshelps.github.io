<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIBs and Their Use</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_dibs2"></a></sup>DIBs and Their Use</h1>
<p>
Ron Gery<br>
Microsoft Developer Network Technology Group</p>
<p>
March 20, 1992</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="262">
</OBJECT><a href="javascript:sample1.Click()">Click to view or copy the sample application files for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article discusses the DIB (device-independent bitmap) concept from definition and structure to the API that uses it. Included is a small sample application that illustrates some of the most common methods of using DIBs to display and manipulate digital images. Functions discussed are <b>GetDIBits</b>, <b>SetDIBits</b>, <b>CreateDIBitmap</b>, <b>SetDIBitsToDevice</b>, <b>StretchDIBits</b>, and <b>CreateDIBPatternBrush</b>. This article does not discuss using palettes with DIBs.</p>
<h2>Overview</h2>
<p>
A DIB (device-independent bitmap) is a format used to define device-independent bitmaps in various color resolutions. The main purpose of DIBs is to allow bitmaps to be moved from one device to another (hence, the device-independent part of the name). A DIB is an <i>external </i>format, in contrast to a device-dependent bitmap, which appears in the system as a bitmap object (created by an application using <b>CreateBitmap</b>, <b>CreateCompatibleBitmap</b>, <b>CreateBitmapIndirect</b>, or <b>CreateDIBitmap</b>). A DIB is normally transported in metafiles (usually using the <b>StretchDIBits</b> function), BMP files, and the Clipboard (CF_DIB data format).</p>
<p>
A DIB consists of two parts: the bits themselves and a header that describes the format of the bits. The header contains the color format, a color table, and the size of the bitmap. The current DIB format supports four color resolutions: 1 bit, 4 bit, 8 bit, and 24 bit. In 1-bit, 4-bit, and 8-bit DIBs, the pixels are defined by indexes (of the appropriate bit resolution) into the color table; 24-bit pixels are described as 24-bit values, 1 byte each for red, green, and blue.</p>
<p>
The DIB functions are:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=31%><b>GetDIBits</b></td>
<td width=69%>Translates a device-dependent bitmap into the DIB format</td>
</tr>
<tr valign=top>
<td width=31%><b>SetDIBits</b></td>
<td width=69%>Translates a DIB's information into device-dependent form</td>
</tr>
<tr valign=top>
<td width=31%><b>CreateDIBitmap</b></td>
<td width=69%>Creates a device-dependent bitmap initialized with DIB information</td>
</tr>
<tr valign=top>
<td width=31%><b>SetDIBitsToDevice</b></td>
<td width=69%>Sets a DIB directly to the output surface</td>
</tr>
<tr valign=top>
<td width=31%><b>StretchDIBits</b></td>
<td width=69%>Moves a rectangle from the DIB to a rectangle on the destination surface, stretching or compressing as necessary</td>
</tr>
<tr valign=top>
<td width=31%><b>CreateDIBPatternBrush</b></td>
<td width=69%>Creates a pattern brush using a DIB for the bitmap description</td>
</tr>
</table><br>
<h3>Device Independence—What's It Good For?</h3>
<p>
Transferring color bitmaps from one device to another was not possible in versions of the Microsoft® Windows™ graphical environment earlier than 3.0. With DIBs, each device displays the image to the ability of its color resolution. An application can store an image in the DIB format and then display it, regardless of the output device; an application need no longer create a version of each image for each type of device.</p>
<p>
This image transfer ability can be used to print halftone images. For example, the <b>StretchDIBits </b>function can pass a DIB directly to an intelligent printer driver. Given the full color information of the image instead of simply a monochrome version (the traditional method), the driver can use halftones to print a realistic picture.</p>
<p>
Because the DIB format is publicly defined, an application can manipulate it on the fly. In fact, an application can build an image without any interaction with Windows. If Windows lacks a drawing primitive, the application can simulate it directly into the DIB instead of using the existing graphics device interface (GDI) primitives. Unfortunately, under Windows versions 3.0 and 3.1, GDI cannot perform output operations directly to a DIB.</p>
<h3>BMP File Formats</h3>
<p>
The file extension of a Windows DIB file is BMP. The file consists of a <b>BITMAPFILEHEADER</b> structure followed by the DIB itself. Unfortunately, because the <b>BITMAPFILEHEADER</b> structure is never actually passed to the API, not every application that generates BMP files fills out the data structure carefully. To add to this confusion, the "proper" definition of the structure is at odds with the documentation. Properly, the data structure contains the following fields:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=21%><b>bfType</b></td>
<td width=79%>A <b>WORD</b> that defines the type of file. It must be 'BM'.</td>
</tr>
<tr valign=top>
<td width=21%><b>bfSize</b></td>
<td width=79%>A <b>DWORD</b> that specifies the size of the file in bytes. The Microsoft Windows Software Development Kit (SDK) documentation claims otherwise. To be on the safe side, many applications calculate their own sizes for reading in a file.</td>
</tr>
<tr valign=top>
<td width=21%><b>bfReserved1</b>, <b>bfReserved2</b></td>
<td width=79%><b>WORD</b>s that must be set to 0.</td>
</tr>
<tr valign=top>
<td width=21%><b>bfOffBits</b></td>
<td width=79%>A <b>DWORD</b> that specifies the offset from the beginning of the <b>BITMAPFILEHEADER</b> structure to the start of the actual bits. The DIB header immediately follows the file header, but the actual image bits need not be placed next to the headers in the file.</td>
</tr>
</table><br>
<p>
The DIB header immediately follows the <b>BITMAPFILEHEADER</b> structure.</p>
<p>
For a code sample that reads a BMP file, see the sample program.</p>
<h3>The DIB Header</h3>
<p>
The header actually consists of two adjoining parts: the header proper and the color table. Both are combined in the <b>BITMAPINFO</b> structure, which is what all DIB APIs expect.</p>
<p>
Windows supports two varieties of headers: <b>BITMAPINFOHEADER</b> and <b>BITMAPCOREHEADER</b>. If at all possible, applications should use only <b>BITMAPINFOHEADER</b>s. The <b>BITMAPCOREHEADER</b> definition is based on the bitmap definition from Presentation Manager™ version 1.1 and is supported for compatibility.</p>
<p>
During a DIB setting operation, most fields are already filled in by whoever generated the DIB. Doing a <b>GetDIBits</b> call, however, provides more control. The way the header is filled in for this operation defines the resulting DIB, particularly its color resolution.</p>
<p>
<b>BITMAPINFOHEADER</b> contains the following fields:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=25%><b>biSize </b></td>
<td width=75%>Should be set to <i>sizeof</i>(<b>BITMAPINFOHEADER</b>). This field defines the size of the header (minus the color table). If a new DIB definition is added, it is identified by a new value for the size. This field is also convenient for calculating a pointer to the color table, which immediately follows the <b>BITMAPINFOHEADER</b>.</td>
</tr>
<tr valign=top>
<td width=25%><b>biWidth</b>, <b>biHeight</b> </td>
<td width=75%>Define the width and the height of the bitmap in pixels. They are <b>DWORD</b> values for future expansion, and the code in Windows versions 3.0 and 3.1 ignores the high word (which should be set to 0).</td>
</tr>
<tr valign=top>
<td width=25%><b>biPlanes </b></td>
<td width=75%>Should always be 1. All DIB definitions rely on <b>biBitCount</b> for defining the color resolution.</td>
</tr>
<tr valign=top>
<td width=25%><b>biBitCount</b></td>
<td width=75%>Defines the color resolution (in bits per pixel) of the DIB. Only four values are valid for this field: 1, 4, 8, and 24. New resolutions (16 bit, for example) may be added in the future, but for now only these four define a valid DIB. Choosing the appropriate value when doing a <b>GetDIBits</b> is discussed below. When performing a <b>Set</b> operation, the value should already be defined for the bits.</td>
</tr>
<tr valign=top>
<td width=25%><b>biCompression </b></td>
<td width=75%>Specifies the type of compression. Can be one of three values: BI_RGB, BI_RLE4, or BI_RLE8. The most common and useful choice, BI_RGB, defines a DIB in which all is as it seems. Each block of <b>biBitCount</b> bits defines an index (or RGB value for 24-bit versions) into the color table. The other two options specify that the DIB is stored (or will be stored) using either the 4-bit or the 8-bit run length encoding (RLE) scheme that Windows supports. The RLE formats are especially useful for animation applications and also usually compress the bitmap. BI_RGB format is recommended for almost all purposes. RLE versions, although possibly smaller, are slower to decode, not as widely supported, and extremely painful to band properly.</td>
</tr>
<tr valign=top>
<td width=25%><b>biSizeImage </b></td>
<td width=75%>Contains the size of the bitmap proper in bytes or the value 0. A value of 0 indicates that the DIB is of default size. Calculating the size of a bitmap is not difficult:<p>
<code>biSizeImage = ((((biWidth * biBitCount) + 31) &amp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~31) &gt;&gt; 3) * biHeight:</code></p>
<p>
The crazy roundoffs and shifts account for the bitmap being <b>DWORD</b>-aligned at the end of every scanline. When nonzero, this field tells an application how much storage space the DIB's bits need. The <b>biSizeImage</b> field really becomes useful when dealing with an RLE bitmap, the size of which depends on how well the bitmap was encoded. If an RLE bitmap is to be passed around, the <b>biSizeImage</b> field is mandatory.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><b>biXPelsPerMeter</b>, <b>biYPelsPerMeter</b></td>
<td width=75%>Define application-specified values for the desirable dimensions of the bitmap. This information can be used to maintain the physical dimensions of an image across devices of different resolutions. GDI never touches these fields. When not filled in, they should both be set to 0.</td>
</tr>
<tr valign=top>
<td width=25%><b>biClrUsed</b></td>
<td width=75%>Provides a way for getting smaller color tables. When this field is set to 0, the number of colors in the color table is based on the <b>biBitCount</b> field (1 indicates 2 colors, 4 indicates 16, 8 indicates 256, and 24 indicates no color table). A nonzero value specifies the exact number of colors in the table. So, for example, if an 8-bit DIB uses only 17 colors, then only those 17 colors need to be defined in the table, and <b>biClrUsed</b> is set to 17. Of course, no pixel can have an index pointing past the end of the table.<p>
Note: This field cannot be used during a <b>GetDIBits</b> operation. GDI always fills a full-size color table. The field is therefore more useful for post-processing operations, when an application trims down the contents of the DIB. If nonzero for a 24-bit DIB, it indicates the existence of a color table that the application can use for color reference.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><b>biClrImportant </b></td>
<td width=75%>Specifies that the first <i>x</i> colors of the color table are important to the DIB. If the rest of the colors are not available, the image still retains its meaning in an acceptable manner. biClrImportant is purely for application use; GDI does not touch this value. When this field is set to 0, all the colors are important, or, rather, their relative importance has not been computed.</td>
</tr>
</table><br>
<p>
The color table immediately follows the header information. No color table is defined for 24-bit DIBs. The table consists of an array of <b>RGBQUAD</b> data structures. (The table for the <b>BITMAPCOREINFO</b> format is built with the <b>RGBTRIPLE </b>data<b> </b>structure.) Red, green, and blue bytes are <i>in reverse order</i> (red swaps position with blue) from the Windows convention. This is another leftover from Presentation Manager compatibility.</p>
<p>
The size of the color table depends on the <b>biBitCount</b> value (and can be overwritten using the <b>biClrUsed</b> field; see above):</p>
<pre><code>if (!(nNumColors = biClrUsed))
{
 &nbsp; if (biBitCount != 24)
 &nbsp;&nbsp;&nbsp;&nbsp; nNumColors = 1 &lt;&lt; biBitCount;
}
nTableSize = nNumColors * sizeof(RGBQUAD);
</code></pre>
<p>
Most DIBs floating around currently have <b>biClrUsed</b> set to 0, but if any full-fledged DIB bashing is planned, it is a good idea to set it properly. If <b>biClrUsed</b> is nonzero, a color table with 24-bit DIBs is possible. GDI does not use this color table, but the application can use it to determine the important colors used in the DIB.</p>
<p>
All DIB functions include a <i>wUsage</i> parameter, which can affect the definition of the color table. This article avoids using palettes with DIBs and thereby assumes that <i>wUsage</i> is always set to DIB_RGB_COLORS and that the color table is therefore always composed of RGB values. When DIB_PAL_COLORS is used, the color table consists of <b>WORD</b> values that are indexes into the currently selected logical palette. (This topic is discussed in detail in the "Using DIBs with Palettes" article.) </p>
<h3>Bit Formats</h3>
<p>
The header defines the format of the bits, but all formats share the following rules:
<ul type=disc>
<li>
Every scanline is <b>DWORD</b>-aligned. The scanline is buffered to alignment; the buffering is not necessarily 0.<br><br></li>
<li>
The scanlines are stored upside down, with the first scan (scan 0) in memory being the bottommost scan in the image. This is another artifact of Presentation Manager compatibility. GDI automatically inverts the image during the <b>Set</b> and <b>Get</b> operations.<br><br></li>
<li>
64K segment boundaries are not respected; scanlines can cross such boundaries (unlike the device-dependent bitmap format that is buffered to 64K boundaries).</li>
</ul>
<p>
Each format has the following specifics:
<ul type=disc>
<li>
1-bit DIBs are stored using each bit as an index into the color table. The most significant bit is the leftmost pixel.<br><br></li>
<li>
4-bit DIBs are stored with each 4 bits representing an index into the color table. The most significant nibble is the leftmost pixel.<br><br></li>
<li>
8-bit DIBs are the easiest to store because each byte is an index.<br><br></li>
<li>
24-bit DIBs have every 3 bytes representing a color, using the same ordering as the color table. This format is especially tricky during processing because a 64K boundary can exist in the middle of a color triple—an ugly condition that must be handled with care.</li>
</ul>
<h2>Using the DIB API</h2>
<p>
<b>GetDeviceCaps </b>(<i>hDC</i>, RASTERCAPS) returns a <b>WORD</b> value with flags set indicating which DIB functions the driver supports. RC_DI_BITMAP indicates support of <b>GetDIBits</b> and <b>SetDIBits</b>, RC_DIBTODEV indicates support of <b>SetDIBitsToDevice</b>, and RC_STRETCHDIB indicates support of <b>StretchDIBits</b>. Any function not supported can be simulated, although the simulations are often not as useful as the real thing (mainly because color information is lost). A device may be unable to support the full functionality even if a bit is set. For example, a device could support <b>StretchDIBits</b> but only for integral stretches. Unfortunately, an application has no way to determine the completeness of the implementation. In these cases, GDI simulates the function.</p>
<h3>GetDIBits and SetDIBits</h3>
<p>
These two functions are used to convert device-independent bitmaps into device-dependent bitmaps and vice versa. <b>SetDIBits</b> converts a DIB to a device-dependent bitmap, and <b>GetDIBits</b> generates a DIB from a device-dependent bitmap.</p>
<p>
The device driver referenced by the <i>hDC</i> passed into both calls performs the actual translation. Some device drivers may not have this functionality (for example, a Windows version 2.0 driver or a primitive Windows version 3.0 driver). In this case, GDI simulates the translation, but only in <i>monochrome</i>—color information is converted to black and white. For the most part, though, this is not a concern. All self-respecting display drivers support this functionality, and only a few printer drivers do not provide the translation, usually monochrome drivers for which the GDI simulations suffice.</p>
<p>
The parameters are the same for both <b>GetDIBits</b> and <b>SetDIBits</b>:</p>
<p>
GetDIBits(<i>hDC</i>, <i>hBitmap</i>, <i>nStartScan</i>, <i>nNumScans</i>, <i>lpBits</i>, <i>lpBitmapInfo</i>, <i>wUsage</i>)</p>
<p>
SetDIBits(<i>hDC</i>, <i>hBitmap</i>, <i>nStartScan</i>, <i>nNumScans</i>, <i>lpBits</i>, <i>lpBitmapInfo</i>, <i>wUsage</i>)</p>
<p>
where:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=20%><i>hDC</i></td>
<td width=80%>The device context (DC) responsible for the translation operation. <i>hDC</i> must be compatible with the <i>hBitmap</i> parameter.</td>
</tr>
<tr valign=top>
<td width=20%><i>hBitmap</i></td>
<td width=80%>The device-dependent bitmap from which (<b>Get</b>) or to which (<b>Set</b>) the DIB will be translated. Because of how the simulation code operates, this bitmap should not be currently selected into any DC.</td>
</tr>
<tr valign=top>
<td width=20%><i>nStartScan, nNumScans</i></td>
<td width=80%>Define the contents of <i>lpBits</i>. For example, a <i>StartScan</i> of 5 indicates that <i>lpBits</i> points to the fifth scan of the DIB. A <i>NumScans</i> of 14 indicates that <i>lpBits</i> points to 14 scans of the DIB. Normally, <i>nStartScan</i> is set to 0 and <i>nNumScans</i> is set to <b>biHeight</b> to denote that the whole DIB is pointed to by <i>lpBits</i>.</td>
</tr>
<tr valign=top>
<td width=20%><i>lpBits</i></td>
<td width=80%>The actual bitmap of the DIB. The pixel information is pointed to by this parameter. </td>
</tr>
<tr valign=top>
<td width=20%><i>lpBitmapInfo</i></td>
<td width=80%>The header (with color table) defining the DIB. The height and width in this header <i>must </i>match the height and width of the <i>hBitmap</i> parameter (the translation is always one-to-one). The color resolution of the DIB need not match that of <i>hBitmap</i>.</td>
</tr>
<tr valign=top>
<td width=20%><i>wUsage</i></td>
<td width=80%>For the purposes of this article, assume this to be DIB_RGB_COLORS, indicating RGB colors in the color table.</td>
</tr>
</table><br>
<p>
Using <b>SetDIBits</b> is reasonably straightforward. A DIB is taken from somewhere (for example, from the Clipboard or from a disk file) and is converted to a bitmap object, which can then be selected into a DC and blted to the screen for display. This is the simplest way to display a DIB.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;For many printers that can do halftones, this method is not preferred; <b>StretchDIBits</b> (discussed below) is far more useful.</p>
<p>
The following is a simple display of a DIB to a DC (with no error handling):</p>
<pre><code>HBITMAP hBitmap;
HDC hMemDC;

hBitmap = CreateCompatibleBitmap(hDC, (WORD)lpInfo-&gt;biWidth, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpInfo-&gt;(WORD)biHeight);
hMemDC = CreateCompatibleDC(hDC);
SetDIBits(hDC, hBitmap, 0, (WORD)lpInfo-&gt;biHeight, lpBits, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpInfo, DIB_RGB_COLORS);
hBitmap = SelectObject(hMemDC, hBitmap);
BitBlt(hDC, 0, 0, (WORD)lpInfo-&gt;biWidth, (WORD)lpInfo-&gt;biHeight, 
 &nbsp;&nbsp;&nbsp;&nbsp; hMemDC, 0, 0, SRCCOPY);
DeleteObject(SelectObject(hMemDC, hBitmap));
DeleteDC(hMemDC);
</code></pre>
<p>
Using <b>GetDIBits</b> is more complex because the application can choose <i>what kind </i>of DIB to generate. The size of the source bitmap regulates the DIB's dimensions (a piece can be extracted by blting into a smaller bitmap), but the application's need can dictate the color resolution.</p>
<p>
For <b>GetDIBits</b> to work properly, the application needs to set the following fields in the header: </p>
<p class=indent>
biSize = sizeof(BITMAPINFOHEADER)</p>
<p class=indent>
biWidth = {width of the bitmap}</p>
<p class=indent>
biHeight = {height of the bitmap}</p>
<p class=indent>
biPlanes = 1</p>
<p class=indent>
biBitCount = {desired color resolution (1, 4, 8, or 24)}</p>
<p class=indent>
biCompression = BI_RGB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (For RLE information, see below.)</p>
<p>
Also, the space allocated for the color table must be sufficient to hold a full-size table:</p>
<pre><code>if (biBitCount != 24)
 &nbsp; nSizeTable = (1 &lt;&lt; biBitCount) * sizeof(RGBQUAD)
else
 &nbsp; nSizeTable = 0;
</code></pre>
<p>
The space allocated for <i>lpBits</i> also needs to be large enough to hold <i>nNumScans</i> of data.</p>
<p>
The call fills in the following fields of the structure:
<ul type=disc>
<li>
<b>biSizeImage</b> = size in bytes of the DIB data<br><br></li>
<li>
color table (for non–24-bit case) is filled with appropriate colors<br><br></li>
<li>
<i>lpBits</i> is filled with the DIB data</li>
</ul>
<p>
If <b>GetDIBits</b> is called with <i>lpBits</i> set to NULL, no bits are returned; only <b>biSizeImage</b> and the color table are filled in. This option is useful for DIBs with RLE and is not worthwhile for non-encoded DIBs.</p>
<p>
The application's goals for the DIB determine what color resolution to choose. The usual approach is to generate a DIB that preserves the color information of the source device-dependent bitmap. Choosing a lesser resolution results in a loss of color information, which is usually undesirable. Always using 24-bit resolution is unnecessary, however, because doing so adds no more color resolution if the source has 8-bit or less resolution.</p>
<pre><code>BITMAP bm;
GetObject(hBitmap, sizeof(BITMAP), (LPVOID)&amp;bm);&nbsp; // get information
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; on bitmap
BitmapRes = bm.bmPlanes * bm.bmBitsPixel;
if (BitmapRes == 1)
 &nbsp; biBitCount = 1;
else if (BitmapRes &lt;= 4)
 &nbsp; biBitCount = 4;
else if (BitmapRes &lt;= 8)
 &nbsp; biBitCount = 8;
else
 &nbsp; biBitCount = 24;
</code></pre>
<p>
The bitmap's resolution calculation must take into account that some device-dependent bitmaps are planar (notably EGA and VGA). DIBs, on the other hand, are always "packed pixel," with only one plane per pixel (<b>biPlanes</b> = 1). </p>
<p>
The <i>nStartScan</i> and <i>nNumScans</i> parameters (a residue of Presentation Manager compatibility) are designed to be used for banding. If not enough memory is available to load the entire DIB into memory in one piece, <i>lpBits</i> can be made to point to only a portion of the bits. Consider the following example:</p>
<pre><code>#define MAXREAD 5
WORD ReadXScans(LPSTR, WORD);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read up to X scans; return 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; NumRead
LPSTR lpBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // points to a block of memory for MAXREAD scans
LPBITMAPINFOHEADER lpInfo; 
WORD nStart, nNumRead;

for (nStart = 0; nStart &gt;= (WORD)lpInfo-&gt;biHeight; )
{
 &nbsp; nNumRead = ReadXScans(lpBits, MAXREAD);
 &nbsp; SetDIBits(hDC, hBitmap, nStart, nNumRead, 
 &nbsp;&nbsp;&nbsp;&nbsp; lpBits,lpInfo,DIB_RGB_COLORS);
 &nbsp; nStart += nNumRead;
}
</code></pre>
<p>
The <b>Set</b> code takes the given band, translates it, and puts the translated band in its proper location, accounting at all times for the upside-down nature of DIBs. Notice how <b>biHeight</b> does not change at any time because the band is placed in the bitmap based on the height of the full bitmap. <i>nStart</i> is based on the height of the full image (defined by <b>biHeight</b>).</p>
<h3>CreateDIBitmap</h3>
<p>
The following code demonstrates calling <b>CreateDIBitmap</b> with the usual case:</p>
<pre><code>hBitmap = CreateDIBitmap(hDC, lpInfo, CBM_INIT, lpBits, lpInfo, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wUsage);
</code></pre>
<p>
This is equivalent to:</p>
<pre><code>hBitmap = CreateCompatibleBitmap(hDC, (WORD)lpInfo-&gt;biWidth, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (WORD)lpInfo-&gt;biHeight);
SetDIBits(hDC, hBitmap, 0, (WORD)lpInfo-&gt;biHeight, lpBits, lpInfo, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wUsage);
</code></pre>
<p>
GDI's implementation skips the <b>SetDIBits</b> part if the third parameter is not set with the CBM_INIT flag. This function makes for nice shortcut coding of the conversion from DIB to device-dependent bitmap.</p>
<h3>SetDIBitsToDevice</h3>
<p>
<b>SetDIBitsToDevice</b> allows an application to set a DIB directly to a device surface. Because this function is a holdout from early development, its interface is not as polished as it could be. <b>StretchDIBits</b> is a far more powerful function than <b>SetDIBitsToDevice</b>. <b>StretchDIBits</b> does all that <b>SetDIBitsToDevice</b> does and has a nicer interface. <b>SetDIBitsToDevice</b> is limited in the way it handles metafiles because it does not scale, and banding with the <i>nStartScan</i> and <i>nNumScans</i> parameters is nontrivial at best. <b>StretchDIBits</b> does not allow the banding.</p>
<p>
The following code performs the <b>SetDIBitsToDevice</b> functionality on the full bitmap (no banding) using <b>StretchDIBits</b>:</p>
<pre><code>StretchDIBits(hDC, x, y, (WORD)lpInfo-&gt;biWidth, 
 &nbsp;&nbsp;&nbsp; (WORD)lpInfo-&gt;biHeight, 0, 0, (WORD)lpInfo-&gt;biWidth, 
 &nbsp;&nbsp;&nbsp; (WORD)lpInfo-&gt;biHeight, lpBits, lpInfo, DIB_RGB_COLORS, 
 &nbsp;&nbsp;&nbsp; SRCCOPY)
</code></pre>
<p>
Assuming that <i>nStartScan</i> is set to 0 and that <i>nNumScans</i> is set to <i>lpInfo</i>-&gt;<b>biHeight</b> (that is, no banding), the function is basically a <b>BitBlt</b> with SRCCOPY as the ROP and with a DIB as the source. <i>SrcX</i> and <i>SrcY</i> are in the DIB's space and are therefore upside down in relation to the DC (Y = 0 is at the bottom of the image). </p>
<p>
Dealing with the upside-down DIB is tricky when doing a partial setting. For example, if an application wants to get the bottom third of a DIB that is <i>w</i> by <i>h</i> pixels to the device at (<i>x</i>,<i>y</i>), the call would look something like the following:</p>
<pre><code>SetDIBitsToDevice(hDC, x, y, w, h/3, 0, h/3, 0, 
 &nbsp;&nbsp;&nbsp;&nbsp; (WORD)lpInfo-&gt;biHeight, lpBits, lpInfo, DIB_RGB_COLORS);
</code></pre>
<p>
A device-dependent bitmap would have a <i>SrcY</i> of 2<i>h</i>/3 for the bottom third, but with the upside-down system of the DIB, a <i>SrcY</i> of <i>h</i>/3 points to the proper place relative to Windows coordinates.</p>
<h3>StretchDIBits</h3>
<p>
This function is the do-all darling for displaying a DIB on the surface of a device. It is especially nice for metafiling and for printing, for which the ability to stretch is important.</p>
<p>
The one critical hole in the current implementation of <b>StretchDIBits</b> is that <b>StretchDIBits</b> is supported by printer drivers and not by many display drivers. Therefore, using this function repeatedly to stretch a DIB to the screen is significantly slower than using <b>SetDIBits</b> (to get a device-dependent bitmap) followed by repeated <b>StretchBlt</b> calls.</p>
<p>
The implementation of this function in GDI is very straightforward. If the device driver can handle the call itself, it does. If not, and the call is one-to-one and the device supports <b>SetDIBitsToDevice</b>, the call is converted to a <b>SetDIBitsToDevice</b> call to the driver. (This works only with SRCCOPY as the ROP.) If neither of these methods is possible, <b>CreateDIBitmap</b> is used to make a device-dependent version of the bitmap, and <b>StretchBlt</b> is called to do the actual work.</p>
<p>
The parameters for <b>StretchDIBits</b> are basically the same as for <b>StretchBlt</b> (with the source <i>hDC</i> replaced by <i>lpBits</i> and <i>lpInfo</i>). This function does not have the <i>nStartScan</i> and the <i>nNumScans</i> parameters of the other DIB functions, so <i>lpBits</i> always points to the first scan of the DIB.</p>
<p>
When using this function for anything other than full bitmap stretches, remember that all of the source coordinates (the ones relating to the DIB) are in an upside-down system. The function will appropriately flip the image, but the source rectangle is defined with Y=0 at the bottom and extents going up. Fortunately, the x-coordinates use the same conventions as Windows.</p>
<p>
Printer drivers that do support this functionality (for example, PSCRIPT and HPPCL) usually use a halftone algorithm to output good color images. Therefore, maintaining DIBs at the highest meaningful color resolution possible (usually 8 bit) is desirable even if the output device is monochrome, because the color information is still useful for good output. Unfortunately, most printer drivers do not support any ROP other than SRCCOPY.</p>
<h3>CreateDIBPatternBrush</h3>
<p>
This function allows an application to create a pattern brush by specifying a DIB instead of a device-dependent bitmap, as used in the <b>CreatePatternBrush</b> function. A brush created using this function is used like any other brush. The DIB is turned into a device-dependent bitmap at <b>SelectObject</b> time for use by the device. This brush looks like a standard pattern brush to the device.</p>
<h2>DIBS in the Clipboard</h2>
<p>
Two basic mechanisms for placing DIBs in the Clipboard are using the CF_DIB data format or placing the DIB into a metafile and using the CF_METAFILEPICT data format.</p>
<p>
The CF_DIB format uses a packed DIB, in which the bits follow immediately after the header and the color table. When reading or creating a packed DIB, an application must properly calculate the size of the color table to ensure that the bits are in the proper place. Because all DIB functions expect the DIB as two pointers, one to the header and one to the bits, the bits pointer must be calculated before use. (For color table size computations, see the code sample in the color table description above.)</p>
<p>
The simplest way to place a DIB into a metafile is to use <b>StretchDIBits</b>:</p>
<pre><code>hMetaDC = CreateMetaFile((LPSTR) NULL));
StretchDIBits(hMetaDC, 0, 0, biWidth, biHeight, 0, 0, biWidth, 
 &nbsp;&nbsp;&nbsp; biHeight, lpBits, lpInfo, DIB_RGB_COLORS, SRCCOPY);
hMetafile = CloseMetaFile(hMF);
</code></pre>
<p>
This approach generates a metafile that when played back displays the DIB to the destination. This method also scales the image to fit the current mapping scheme if needed. Using metafiles for transfer enables even applications that are not DIB-aware to paste the contents of the Clipboard without losing the DIB information.</p>
<h2>RLE Formats</h2>
<p>
When the <b>biCompression</b> field in a DIB's header is set to either BI_RLE4 (for <b>biBitCount</b> = 4) or BI_RLE8 (for <b>biBitCount</b> = 8), the image has been run length encoded. A description of the encoding schemes can be found in the SDK <i>Reference</i>—<i>Volume 2 </i>manual, in the "BITMAPINFOHEADER" section of the "Datatypes and Structures" chapter. The basic scheme involves compressing multiple, horizontally adjacent, identical pixels into a run encoding. For example, 10 pixels of color index 17 are encoded as a run of length 10 and of index 17. Codes for end-of-scan and for delta moves are also provided, in which an <i>X</i> and a <i>Y</i> offset are provided for the next pixel.</p>
<p>
This type of encoding usually compresses the bitmap and is also useful for creating sprite-type animations, in which only a small part of an image changes in each frame. The animation capabilities are accomplished by using delta codes to limit the number of pixels actually being set. Pixels skipped by a delta move are left untouched.</p>
<p>
The main limitations of RLE DIBs are that an application can neither easily determine the size of the bitmap in bytes nor point to a certain scanline without decoding the bitmap from the first scan. The <b>biSizeImage</b> field is useful in solving the first problem. Decoding, encoding, and generally manipulating the RLE format is slower and more complicated than the noncompressed (BI_RGB) format. Some applications—for example, Paintbrush—refuse to read RLE DIBs. Although all APIs accept them, RLE DIBs will probably not become a universally supported format. Also, because of the relative rarity of these formats, some device drivers might not have fully tested support for the encoding and decoding processes.</p>
<p>
To generate an RLE DIB, <b>GetDIBits</b> is called with <b>biCompression</b> set to the desired type of encoding. The amount of memory needed to store the bits is not easily computed. If <b>GetDIBits</b> is called with <i>lpBits</i> set to NULL, the amount of memory needed for the bits is returned in <b>biSizeImage</b>. A subsequent call with <i>lpBits</i> pointing to a properly sized block of memory returns an encoded bitmap.</p>
<p>
Translating an RLE DIB into a device-dependent form requires no special processing. Any of the <b>Set</b> functions can be used normally with a header containing the proper <b>biSizeImage</b> and <b>biCompression</b> values to match the bits.</p>
<h2>Shortcomings of DIBS</h2>
<p>
Probably the biggest limitation of DIBs is that they are slower than device-dependent bitmaps. Translating DIBs into a device-dependent form before they can actually be displayed requires extra processing, resulting in additional overhead. In an ideal world, a one-to-one <b>StretchDIBits</b> would be as fast as a <b>BitBlt</b>. This speed would allow an application to operate effectively in the realm of the logical bitmap, with full color and full access to each and every pixel, regardless of the physical device's limitations.</p>
<p>
DIBs are based in a coordinate system that is upside down relative to Windows, making coding a bit frustrating and not intuitive. Always remembering this quirkiness should help limit the number of iterations needed to get bitmaps properly lined up.</p>
<p>
You can get full color using 24-bit DIBs, but they are very slow to decode, read, and write. This is especially true on 8-bit palette devices, in which translation literally can take minutes. Also, the sheer size of 24-bit DIBs makes them a bit unwieldy for general use.</p>
<h2>DIB-Related Problems in Windows Version 3.0</h2>
<p>
Metafile recording of <b>StretchDIBits</b> calls that use <b>BITMAPCOREHEADER</b> causes a UAE. Convert all headers to the <b>BITMAPINFO</b> style to avoid this problem. This workaround is recommended for general DIB processing.</p>
<p>
The <b>SetDIBits</b> simulation code for &gt;64K monochrome DIBs causes crashes or erroneous output when using <b>SetDIBits</b>, <b>SetDIBitsToDevice</b>, or <b>StretchDIBits</b> to a driver that does not support <b>SetDIBits</b>.</p>
</BODY>
</HTML>
