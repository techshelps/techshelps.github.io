<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Performing DDE from a Dynamic-Link Library</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_ddedll"></a></sup>Performing DDE from a Dynamic-Link Library</h1>
<p>
By Herman Rodent, a much-traveled, small, furry animal<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: October 1, 1992</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="270">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the PMGRPAPI sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
Dynamic data exchange (DDE) is normally associated with applications. The basic DDE mechanism uses WM_DDE... messages sent between application window procedures. This article shows how DDE operations can be performed from a dynamic-link library (DLL) using the dynamic data exchange management library (DDEML) to do most of the work. Using DDEML instead of raw DDE messages makes adding DDE functionality to a DLL a trivial exercise.</p>
<p>
PMGRPAPI, the sample code for this article, implements a DLL with an application programming interface (API) to the Microsoft® Windows™ Program Manager for controlling the creation and deletion of groups and items. The application is of use in its own right as an aid to creating setup programs.</p>
<h2>The API Set</h2>
<p>
The following list shows the APIs implemented in the sample code DLL. These calls manipulate groups or group items in the Microsoft® Windows™ Program Manager.</p>
<p class=label>
<b>Table 1. Functions Implemented in PMGRPAPI.DLL</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>API Name</b></td>
<td class=label width=74%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=26%><b>pmCreateGroup</b></td>
<td width=74%>Creates a new group</td>
</tr>
<tr valign=top>
<td width=26%><b>pmDeleteGroup</b></td>
<td width=74%>Deletes a group</td>
</tr>
<tr valign=top>
<td width=26%><b>pmShowGroup</b></td>
<td width=74%>Shows a group</td>
</tr>
<tr valign=top>
<td width=26%><b>pmAddItem</b></td>
<td width=74%>Adds an item to a group</td>
</tr>
<tr valign=top>
<td width=26%><b>pmDeleteItem</b></td>
<td width=74%>Deletes an item from a group</td>
</tr>
<tr valign=top>
<td width=26%><b>pmReplaceItem</b></td>
<td width=74%>Replaces an item in a group</td>
</tr>
<tr valign=top>
<td width=26%><b>pmReload</b></td>
<td width=74%>Removes and reloads an existing group</td>
</tr>
<tr valign=top>
<td width=26%><b>pmExit</b></td>
<td width=74%>Exits from the Program Manager</td>
</tr>
</table><br>
<h2>The Program Manager DDE Interface</h2>
<p>
The Windows Program Manager supports a set of commands that can be sent to it through the DDE execute protocol. The Microsoft Windows version 3.1 Software Development Kit (SDK) <i>Programmer's Reference, Volume 1: Overview</i> has details of the set of commands supported in Section 17.2, "Command-String Interface." </p>
<p>
Each command consists of a leading square bracket, the name of the command, an opening round bracket, a comma-separated parameter list, a closing round bracket, and finally a closing square bracket. As an example, here's the command string required to add an item called Command.com with a caption of "DOS Box":</p>
<pre><code>[AddItem("Command.com","DOS Box")]
</code></pre>
<p>
Note that DDE execute strings are not case-sensitive. Multiple commands may be concatenated together into a single string:</p>
<pre><code>[DeleteGroup(Group1)][DeleteGroup(Group2)]
</code></pre>
<p>
Attempts to send incorrectly formatted commands will simply result in the failure of your request to execute. Currently, no established convention exists to get any error information back from an execute request. Look for an article on this subject in future releases of the Microsoft Developer Network CD.</p>
<p>
Although this example is written specifically to interface with the Windows Program Manager, it also works with the Norton Desktop, which responds to the same set of DDE execute commands.</p>
<h2>How the Sample Application Works</h2>
<p>
The PMGRPAPI sample dynamic-link library functions as a DDE client application. When an application calls one of the APIs in the PMGRPAPI DLL, the API code takes the following steps:
<ol>
<li>
Format the required command string from the parameters passed to the API.<br><br></li>
<li>
Call <b>SendExecCmd</b> to perform the remainder of the operation. <b>SendExecCmd</b> is an internal function in PMGRPAPI.C.</li>
</ol>
<p>
Here's the code for the <b>pmDeleteGroup</b> API:</p>
<pre><code>BOOL FAR PASCAL pmDeleteGroup(LPSTR lpszGroup)
{
 &nbsp;&nbsp; char buf[256];

 &nbsp;&nbsp; if (lpszGroup &amp;&amp; lstrlen(lpszGroup)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wsprintf(buf, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "[DeleteGroup(%s)]",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszGroup);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; return SendExecCmd(buf);
}
</code></pre>
<p>
The <b>SendExecCmd</b> function takes the formatted command string and performs these steps:
<ol>
<li>
Initialize DDEML.<br><br></li>
<li>
Initiate a DDE conversation with the Program Manager.<br><br></li>
<li>
Construct a DDE data handle for the execute string.<br><br></li>
<li>
Send the execute request to the Program Manager.<br><br></li>
<li>
Terminate the conversation with the Program Manager.<br><br></li>
<li>
Close down DDEML.</li>
</ol>
<p>
Here's the code for the <b>SendExecCmd</b> function taken from the PMGRPAPI sample:</p>
<pre><code>static BOOL SendExecCmd(LPSTR lpszCmd)
{
 &nbsp;&nbsp; DWORD dwDDEInst = 0;
 &nbsp;&nbsp; UINT ui;
 &nbsp;&nbsp; HSZ hszProgman;
 &nbsp;&nbsp; HCONV hConv;
 &nbsp;&nbsp; HDDEDATA hExecData;

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Initialize DDEML.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; ui = DdeInitialize(&amp;dwDDEInst,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DDECallback,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CBF_FAIL_ALLSVRXACTIONS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0l);

 &nbsp;&nbsp; if (ui != DMLERR_NO_ERROR) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Initiate a conversation with the PROGMAN service on 
 &nbsp;&nbsp; // the PROGMAN topic.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; hszProgman = DdeCreateStringHandle(dwDDEInst,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "PROGMAN",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CP_WINANSI);

 &nbsp;&nbsp; hConv = DdeConnect(dwDDEInst,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hszProgman,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hszProgman,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Free the HSZ now.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; DdeFreeStringHandle(dwDDEInst, hszProgman);

 &nbsp;&nbsp; if (!hConv) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Create a data handle for the execute string.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; hExecData = DdeCreateDataHandle(dwDDEInst,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpszCmd,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstrlen(lpszCmd)+1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Send the execute request.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; DdeClientTransaction((void FAR *)hExecData,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (DWORD)-1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hConv,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XTYP_EXECUTE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1000, // ms timeout
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Done with the conversation now.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; DdeDisconnect(hConv);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Done with DDEML.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; DdeUninitialize(dwDDEInst);

 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<h2>Why Not Initialize DDEML When the DLL Loads?</h2>
<p>
It seems reasonable that when the DLL was first loaded we would:
<ol>
<li>
Initialize DDEML.<br><br></li>
<li>
Establish a conversation with the Program Manager.</li>
</ol>
<p>
This would make the <b>SendExecCmd</b> function simpler and presumably faster. When the <b>WEP</b> function for the DLL was called just prior to the DLL being unloaded, we would:
<ol>
<li>
Terminate the conversation with the Program Manager.<br><br></li>
<li>
Shut down DDEML.</li>
</ol>
<p>
Unfortunately, although the initialization steps are quite reasonable, the termination steps are not. Because of the way the Windows kernel works, all code in a <b>WEP</b> function needs to be in a fixed segment and so does any code it calls. If this is not the case, it's possible the code would have to be loaded during the time <b>WEP</b> was being called, and this causes all sorts of problems. More information about the <b>WEP</b> procedure can be found by searching the Microsoft Developer Network CD for <i>WEP</i>.</p>
<p>
The best way to control initialization and termination is to provide exported functions to do the initialization and termination procedures and have each client application of the DLL call them. For example, you might provide <b>pmInitialize</b> and <b>pmTerminate</b> functions. An application wanting to use PMGRPAPI.DLL would first call <b>pmInitialize</b>, then call whatever other APIs it needed to call, and finally it would call the <b>pmTerminate </b>function to shut things down. This puts the responsibility of doing it right on the application, which is by no means an ideal situation. It is, however, the only reliable practical solution to the problem of providing a termination procedure in a DLL.</p>
</BODY>
</HTML>
