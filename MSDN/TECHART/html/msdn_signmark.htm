<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Signing and Marking ActiveX Controls</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_signmark"></a></sup>Signing and Marking ActiveX Controls</h1>
<p>
Paul Johns <br>
Developer Trainer, Microsoft Corporation</p>
<p>
October 15, 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5002">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the StopLite sample application referred to in this technical article.</a></p>
<p>
Note that this project requires that you have the new Microsoft® Win32® software development kit (SDK) properly installed on your machine and that you set up Microsoft Visual C++® to search the new Win32 SDK libraries first. The new Win32 SDK is available in the MSDN Professional, Enterprise, and Universal editions. </p>
<h2>Introduction</h2>
<h3>I Don't Want All Those Security Dialog Boxes! </h3>
<p>
If you've used unsigned or unmarked ActiveX™ controls with Microsoft Internet Explorer version 3.0, you may have seen dialog boxes telling you that the control is not signed, the control is not safe for initializing, or the control is not safe for scripting. Or, if you set your security level to high rather than medium, the control did not load or display at all. (Thrill seekers who set security at none won't get any of these behaviors. But they won't have any security, either!) </p>
<p>
Well, you can have your security and use your controls, too! This article tells you how to get rid of those dialog boxes without setting your security level to none. The issue is especially important because Microsoft Internet Explorer defaults to the high security setting. </p>
<p>
These behaviors are due to the Internet Explorer security mechanisms for ActiveX controls. The ActiveX controls you can automatically download over the Internet can do anything—including things that would damage your system. Java attempts to solve this problem by severely limiting what a Java™ applet can do. It can't, for instance, access the client computer's file system. ActiveX controls take a different approach: they demand positive identification of the author of the control, verify that the control hasn't been modified since it was signed, and identify safe controls—kind of like shrink-wrapping a control for download over the Internet. Because of this approach, ActiveX controls can use the full power of the client's system safely. </p>
<h3>What's in this Article?</h3>
<ul type=disc>
<li>
What users experience if you don't sign and mark your control <br><br></li>
<li>
How to sign your control<br><br></li>
<li>
How to mark your control by tweaking the registry<br><br></li>
<li>
How to mark your control by modifying your self-registration code<br><br></li>
<li>
How to modify your control by implementing the <b>IObjectSafety</b> OLE interface<br><br></li>
<li>
A general technique for adding interfaces to the existing Microsoft Foundation Class Library (MFC)</li>
</ul>
<h3>What Happens If You Don't Sign Your Control? </h3>
<p>
If a user attempts to load a Web page that uses a control not already registered on the user's system, Internet Explorer will download the control. But before it does, the browser checks to see if the control has been digitally signed. If not, and security is set to high, the dialog box in Figure 1 appears. </p>
<p>
<img src="signmark_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Warning dialog box when security is set to high</b></p>
<p>
And Figure 2 appears in the Web page instead of the control. </p>
<p>
<img src="signmark_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Placeholder for security-blocked ActiveX control</b></p>
<p>
Note that at high security, there is no option to use the control. </p>
<p>
If security is set to medium, the dialog box in Figure 3 appears. </p>
<p>
<img src="signmark_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Warning dialog box when security is set to medium</b></p>
<p>
If the user clicks yes, the control installs itself normally. If the user clicks no, an error placeholder appears instead of the control, the same as appears with the high security setting. </p>
<p>
If security is set at none, the control works and no dialog box appears. </p>
<p>
Once the control is registered on the user's system, the control no longer invokes code-signing dialog boxes. After a control is installed, it is considered safe even if it was not signed originally. </p>
<p>
If a control is signed, a certificate dialog box appears, displaying information intended to help users decide whether to trust the author of the control (Figure 4). </p>
<p>
<img src="signmark_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Certificate dialog box for a signed ActiveX control</b></p>
<p>
Note the checkboxes at the bottom. When the user checks either box, controls signed by those sources will download with no further interruption. (For software published by individual developers, only the first checkbox is available with Internet Explorer 3.01.) </p>
<h3>What Happens If You Don't Mark Your Control? </h3>
<p>
Once the control is installed, Internet Explorer 3.0 won't check it again to see if it's signed. However, before your Web page initializes the control, Internet Explorer 3.0 will verify that the control is marked as safe for initializing, and, if your Web page scripts the control, whether that control is marked as safe for scripting. </p>
<p>
If the control passes both checks, it loads and runs. If it fails either check, one the following will happen: 
<ul type=disc>
<li>
If security is set on high, you'll get the same "Potential safety violation avoided" dialog as if the control were being installed and hadn't been signed. The control will display and will run, but without initialization and without scripting. Since the control won't be initialized, it will use default values for its persistent properties. Also, if any script refers to the control, the script will fail, displaying a dialog box similar to the one in Figure 5. <p>
<img src="signmark_5.gif" border=0></P><p class=label>
<b>Figure 5. Internet Explorer Script Error dialog box</b>
</li>
<li>
If security is set to medium, the user receives one dialog box for each security check. First, Internet Explorer 3.0 will check to see if the control is safe for initializing. If it's not, the browser will display the dialog box in Figure 6. <p>
<img src="signmark_6.gif" border=0></P><p class=label>
<b>Figure 6. Warning dialog box for initializing</b>
</li>
<li>
If the user selects either of the <b>No</b> buttons, the affected control(s) will not be initialized; it will use default values for the persistent properties. </li>
</ul>
<p>
Next, Internet Explorer 3.0 checks to see if the control is safe for scripting. If not, it displays a dialog box similar to Figure 7. </p>
<p>
<img src="signmark_7.gif" border=0></p>
<p class=label>
<b>Figure 7. Warning Dialog Box for scripting</b></p>
<p>
If the user selects either <b>No</b> button, any script that refers to an affected control will fail, displaying a dialog box similar to Figure 1. </p>
<p>
If security is set to none, everything just works. </p>
<h3>Making Controls Work with Security </h3>
<p>
Two fairly simple steps will eliminate these problems: Sign the control and mark it as safe for scripting and safe for initializing. </p>
<h4>Sign that control </h4>
<p>
To sign your control, you'll need to obtain a certificate from a Certificate Authority such as VeriSign, Inc. Find directions from VeriSign at <a href="http://digitalid.verisign.com/codesign.htm">http://digitalid.verisign.com/codesign.htm.</a> </p>
<p>
There are two classes of digital IDs for Microsoft Authenticode™ technology. Class 2 certificates, for individuals who publish software, cost US$20 per year and require that you provide your name, address, e-mail address, date of birth, and Social Security Number. After VeriSign verifies this information, you will be issued a certificate. </p>
<p>
Class 3 certificates, for commercial software publishers, cost US$400 per year and require a Dun and Bradstreet rating in addition to company name, location, and contacts. </p>
<p>
Once you obtain the certificate, use the SIGNCODE program provided with the ActiveX software development kit (SDK) to sign your code. There are details in <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_sixsteps">
</object><a href=JavaScript:alink_1.Click()>"Six Steps to Signing Your Code."</a> Note that you'll have to re-sign code if you modify it (such as to mark it safe for initializing and scripting). Note also that signatures are only checked when the control is first installed—the signature is not checked every time Internet Explorer uses the control. </p>
<p>
Once your code is signed, even users whose security setting is high will be able to download, install, and register your controls. But they will only be able to use pages that initialize and script these signed controls if you mark them as safe for initializing and safe for scripting. </p>
<p>
Most companies should have one certificate and one group responsible for signing code so that they have control over what's signed. If your company does, follow its procedure, rather than signing the control yourself. </p>
<h4>If it's safe, mark it as safe! </h4>
<p>
So, you've got your control signed—but you still get the safety dialog boxes shown in Figures 7 and 8. How do you get rid of these dialog boxes so that your users will have a seamless browsing experience? </p>
<p>
Simple. Mark your control as safe for initialization and safe for scripting. But only do this if you know the control is actually safe. </p>
<p>
<b>How do you know the control is safe?</b></p>
<p>
Read this section carefully—this is a serious issue. </p>
<p>
Since the marking stays with the control rather than with the Web page, controls marked as safe have to be safe in all possible Web pages. So, a control marked as safe has to be written to protect itself from any unpleasant thing a Web page author might do in either initializing or scripting the control. While it's fairly simple to verify that a particular control is safe when used with a particular Web page, it's far from trivial to verify that the control will always be safe with any Web page. </p>
<p>
If you mark your control as safe for initializing, you are asserting that no matter what values are used to initialize your control, it won't do anything that would damage a user's system or compromise the user's security. </p>
<p>
If you mark your control as safe for scripting, you are asserting that your control won't do anything to damage a user's system or compromise the user's security, regardless of how your control's methods and properties are manipulated by the Web page's script. In other words, it has to accept any method calls (with any parameters) and/or property manipulations in any order without doing anything bad. </p>
<p>
Does this scare you a little? When I was writing the <b>StopLite</b> control (downloadable from the beginning of this article), it sure did scare me—so I took extra care to ensure that my control was in fact safe before I marked it as safe. For instance, I verified that <b>StopLite</b>: 
<ul type=disc>
<li>
Does not manipulate the file system. <br><br></li>
<li>
Does not manipulate the registry (except to register and unregister itself).<br><br></li>
<li>
Does not overindex arrays or otherwise manipulate memory incorrectly. <br><br></li>
<li>
Validates (and corrects) all input, including initialization, method parameters, and property set functions—both in <b>DoPropExchange</b> and in <b>SetColor</b>.<br><br></li>
<li>
Does not misuse any data about the user or provided by the user.<br><br></li>
<li>
Was tested in a variety of circumstances. </li>
</ul>
<p>
This list of do's and don'ts isn't complete, but it's a good start. If you find any security problems with <b>StopLite</b>, please let me know via workshop@microsoft.com.</p>
<p>
It is very important never to mark a control safe that isn't actually safe, as tempting as this might be (if, for instance, you don't have the source code for a control.) Once marked safe, the control will be considered safe by all Web pages, regardless of what the page might actually do to the control. (As of this writing, there is no way to sign a Web page nor mark it as safe; nor is there any way to specify that a control is only marked as safe with certain Web pages.) </p>
<p>
A simple and safe alternative to marking unsafe controls as safe is to write a new safe control that subclasses the unsafe control. Just ensure that your new control's initialization, methods, and properties are safe. </p>
<h4>Ways to mark a control as safe</h4>
<p>
You can mark a control as safe in two basic ways:
<ul type=disc>
<li>
Add the necessary entries to the registry key for the control to mark it as safe. You can do this either by manipulating the registry yourself, perhaps when you install the control, or, better yet, by calling certain functions when the control registers itself. <br><br></li>
<li>
Implement the <b>IObjectSafety</b> OLE interface, which allows the container to query the control's current safety state and to request that it change to safe mode. </li>
</ul>
<p>
Each method has advantages and disadvantages. </p>
<p>
Implementing <b>IObjectSafety</b> allows your control to have a safe mode and an unsafe mode—a spreadsheet control, for instance, could both read and write files when it's in unsafe mode, but perhaps only read from files when it's in safe mode. This would allow the control to be used in very powerful ways when safety wasn't important but still be safe for use in a Web page. Using <b>IObjectSafety</b> also allows a container to determine whether an already-created control is safe without accessing the registry, which can make your control come up faster. Finally, controls that implement <b>IObjectSafety</b> can be safe on some interfaces and unsafe on others, since safety is on an interface-by-interface basis. </p>
<p>
Adding the entries to the registry has the theoretical advantage of allowing a container to check the registry to see if a control is safe before instantiating it. (Checking the registry is expensive, but instantiating controls is even more expensive.) For instance, when an authoring environment such as the Microsoft ActiveX Control Pad or Microsoft Visual Basic® shows you a list of controls you can insert, it can also indicate which controls are safe and which aren't. (This is a theoretical advantage because neither environment currently does this.) If the entries aren't in the registry, the authoring environment will have to instantiate the control in order to use <b>IObjectSafety</b>. </p>
<p>
Because ActiveX controls must be able to register and unregister themselves using <b>DllRegisterServer</b> and <b>DllUnregisterServer</b>, you'll want to do the registry manipulation in your control's code rather than in a setup program. </p>
<p>
There is one situation in which you might want to add the entries to the registry using a setup program or .REG file—when you know the control is safe, but you can't modify the control itself. As mentioned above, we do not recommend this unless you're sure the control is actually safe. (But you can always create a new control that safely subclasses the unsafe control.) If you use this method to mark controls that are automatically installed by Internet Explorer 3.0, you'll need to install your control using an .INF file rather than just supplying the control's executable file. </p>
<p>
The added code necessary to implement <b>IObjectSafety</b> is about the same size as the code to implement self registration—less than 1K. So, from a size perspective, it doesn't matter which you use. </p>
<p>
If your control is always safe, it is possible to use both methods. Using both gives you the best performance, both in secure containers and in authoring environments that check for safety (although no such authoring environments exist as of this writing) but makes your control grow roughly an additional 1K. </p>
<p>
If your control has both safe and unsafe modes, or is only safe on some of its interfaces, you should only implement <b>IObjectSafety</b>—do not add the registry keys, because they imply that your control is always safe on all interfaces. Also, remember that implementing <b>IObjectSafety</b> will give better runtime performance. </p>
<h4>Marking in the registry yourself </h4>
<p>
You can add the necessary keys to mark the control in the registry either when you install the control or later.</p>
<p>
The two keys you need are both of the following form:</p>
<pre><code>\HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\&lt;GUID of control class&gt;\Implemented Categories\&lt;GUID of category&gt;
</code></pre>
<p>
The ActiveX SDK header file ObjSafe.H defines the globally unique identifier (GUID) values for CATID_SafeForInitializing and CATID_SafeForScripting.</p>
<p>
Because, for <b>StopLite</b>, the class GUID is {20048BB3-DB68-11CF-9CAF-00AA006CB425}, the two keys we add are:</p>
<pre><code>REGEDIT4

[HKEY_CLASSES_ROOT\CLSID\{20048BB3-DB68-11CF-9CAF-00AA006CB425}\Implemented Categories]

[HKEY_CLASSES_ROOT\CLSID\{20048BB3-DB68-11CF-9CAF-00AA006CB425}\Implemented Categories\{7DD95801-9882-11CF-9FA9-00AA006C42C4}]

[HKEY_CLASSES_ROOT\CLSID\{20048BB3-DB68-11CF-9CAF-00AA006CB425}\Implemented Categories\{7DD95802-9882-11CF-9FA9-00AA006C42C4}]
</code></pre>
<p>
To have the component categories properly described in the registry, you should also add the following keys:</p>
<pre><code>REGEDIT4

[HKEY_CLASSES_ROOT\Component Categories]

[HKEY_CLASSES_ROOT\Component Categories\{7DD95801-9882-11CF-9FA9-00AA006C42C4}]
"409"="Controls that are safely scriptable"

[HKEY_CLASSES_ROOT\Component Categories\{7DD95802-9882-11CF-9FA9-00AA006C42C4}]
"409"="Controls safely initializable from persistent data"
</code></pre>
<p>
Don't use this method unless you have no other choice, and never use this method to mark as safe controls that aren't really safe. </p>
<h4>Marking the control while self registering </h4>
<p>
If you're going to mark your control by changing the registry, it's far better to add the code to the control's self-registration routine rather than rely on setup routines. Note that the ActiveX control specification requires that ActiveX controls be self-registering.</p>
<p>
The code is relatively simple—four function calls when registering the control. You also need two small helper functions, HELPERS.CPP and HELPERS.H; you can copy these from the ActiveX SDK in the MSDN Professional, Enterprise, and Universal editions.</p>
<p>
Once you have the helper functions, it's easy to add the necessary registry entries to mark the control as safe. When you're registering the control, add these lines:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Mark as safe for scripting—failure OK.
 &nbsp;&nbsp;&nbsp;&nbsp; HRESULT hr = CreateComponentCategory(CATID_SafeForScripting, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L"Controls that are safely scriptable");

 &nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Only register if category exists.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterCLSIDInCategory(m_clsid, CATID_SafeForScripting);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Don't care if this call fails.

 &nbsp;&nbsp;&nbsp;&nbsp; // Mark as safe for data initialization.
 &nbsp;&nbsp;&nbsp;&nbsp; hr = CreateComponentCategory(CATID_SafeForInitializing, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L"Controls safely initializable from persistent data");

 &nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Only register if category exists.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterCLSIDInCategory(m_clsid, CATID_SafeForInitializing);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Don't care if this call fails.
</code></pre>
<p>
If your control is an MFC control, modify the registration branch of your control class's <b>{ControlClass}::{ControlClass}Factory::UpdateRegistry</b> function to include this code. For instance, for the <b>CStopLiteCtrl</b> class, the name of the function is <b>CStopLiteCtrl::CStopLiteCtrlFactory::UpdateRegistry</b>. See how I did this in STOPLITECTL.CPP in the <b>StopLite</b> sample. </p>
<p>
If you're not using MFC, put this code in <b>DllRegisterServer</b>—and be sure to replace <b>m_clsid </b>in the <b>RegisterCLSIDInCategory</b> calls above with the class ID of your control. </p>
<p>
In either case, you'll need to include HELPERS.H (the helper function declaration) and OBJSAFE.H (supplied with the ActiveX SDK). </p>
<p>
Because unregistering the class automatically eliminates the category registration (the implemented categories are a sub key of the control's main key, which unregistering removes completely), and because we don't want to remove the categories (another control might be using them), we don't need to do add any code to the unregistration routine. </p>
<h4>IObjectSafety </h4>
<p>
The most flexible way to "mark" your control is to implement the <b>IObjectSafety</b> interface. This requires you to implement two functions: <b>GetInterfaceSafetyOptions</b> and <b>SetInterfaceSafetyOptions</b>.</p>
<p>
As you might imagine, <b>GetInterfaceSafetyOptions</b> allows your control's container to ask the control whether it's currently safe in each of the two currently supported safety classes (safe for initializing and safe for scripting).</p>
<p>
In addition, it allows the container to ask the control whether it can be safe—and allows the container to ask these questions on an interface-by-interface basis. Check the interface ID in the event that only some of your interfaces are safe.</p>
<p>
Since the <b>StopLite</b> control is always safe on all of its interfaces, my implementation of <b>GetInterfaceSafetyOptions</b> is pretty simple:</p>
<pre><code>const DWORD dwSupportedBits = 
 &nbsp;&nbsp;&nbsp;&nbsp; INTERFACESAFE_FOR_UNTRUSTED_CALLER |
 &nbsp;&nbsp;&nbsp;&nbsp; INTERFACESAFE_FOR_UNTRUSTED_DATA;
const DWORD dwNotSupportedBits = ~ dwSupportedBits;

/////////////////////////////////////////////////////////////////////////////
// CStopLiteCtrl::XObjSafe::GetInterfaceSafetyOptions
// Allows container to query what interfaces are safe for what. We're
// optimizing significantly by ignoring which interface the caller is
// asking for.
HRESULT STDMETHODCALLTYPE 
 &nbsp; CStopLiteCtrl::XObjSafe::GetInterfaceSafetyOptions( 
 &nbsp;&nbsp;&nbsp;&nbsp; /* [in] */ REFIID riid,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions)
{
 &nbsp; METHOD_PROLOGUE(CStopLiteCtrl, ObjSafe)

 &nbsp; HRESULT retval = ResultFromScode(S_OK);

 &nbsp; // Does interface exist?
 &nbsp; IUnknown FAR* punkInterface;
 &nbsp; retval = pThis-&gt;ExternalQueryInterface(&amp;riid, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void * *)&amp;punkInterface);
 &nbsp; if (retval != E_NOINTERFACE) { // interface exists
 &nbsp;&nbsp;&nbsp;&nbsp; punkInterface-&gt;Release(); // release it—just checking!
 &nbsp; }
 &nbsp; 
 &nbsp; // We support both kinds of safety and have always both set,
 &nbsp; // regardless of interface.
 &nbsp; *pdwSupportedOptions = *pdwEnabledOptions = dwSupportedBits;
 &nbsp; return retval; // E_NOINTERFACE if QI failed
}
</code></pre>
<p>
(I'll go into why the name of this function is <b>CStopLiteCtrl::XObjSafe::GetInterfaceSafetyOptions</b>—in other words, why it's in a nested class—in the next section.) The basic work of this function is to return the safety options that the control supports and tell whether the control is currently safe for those options or not. To make the code simpler, <b>StopLite</b> supports the same safety options for all interfaces.</p>
<p>
We do, however, need to return E_NOINTERFACE if the control doesn't support the interface requested. We check to see if we support the interface by calling <b>QueryInterface</b> in the manner necessary for MFC add-on interfaces. Note that we're careful to <b>Release</b> the interface pointer when we're done with it.</p>
<p>
The real work of <b>SetInterfaceSafetyOptions</b> is even simpler: because the object is always safe, we return <b>S_OK</b>. Provided that the interface exists, the options we were asked to set are among the two options we support, and we weren't asked to turn safety off. Here's the code:</p>
<pre><code>/////////////////////////////////////////////////////////////////////////////
// CStopLiteCtrl::XObjSafe::SetInterfaceSafetyOptions
// Since we're always safe, this is a no-brainer—but we do check to make
// sure the interface requested exists and that the options we're asked to
// set exist and are set on (we don't support unsafe mode).
HRESULT STDMETHODCALLTYPE 
 &nbsp; CStopLiteCtrl::XObjSafe::SetInterfaceSafetyOptions( 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* [in] */ REFIID riid,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* [in] */ DWORD dwOptionSetMask,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* [in] */ DWORD dwEnabledOptions)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CStopLiteCtrl, ObjSafe)
 &nbsp; 
 &nbsp; // Does interface exist?
 &nbsp; IUnknown FAR* punkInterface;
 &nbsp; pThis-&gt;ExternalQueryInterface(&amp;riid, (void * *)&amp;punkInterface);
 &nbsp; if (punkInterface) { // interface exists
 &nbsp;&nbsp;&nbsp;&nbsp; punkInterface-&gt;Release(); // release it—just checking!
 &nbsp; }
 &nbsp; else { // Interface doesn't exist.
 &nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode(E_NOINTERFACE);
 &nbsp; }
 &nbsp; // Can't set bits we don't support.
 &nbsp; if (dwOptionSetMask &amp; dwNotSupportedBits) { 
 &nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode(E_FAIL);
 &nbsp; }
 &nbsp; 
 &nbsp; // Can't set bits we do support to zero
 &nbsp; dwEnabledOptions &amp;= dwSupportedBits;
 &nbsp; // (We already know there are no extra bits in mask. )
 &nbsp; if ((dwOptionSetMask &amp; dwEnabledOptions) !=
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwOptionSetMask) {
 &nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode(E_FAIL);
 &nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; 
 &nbsp; // Don't need to change anything since we're always safe.
 &nbsp; return ResultFromScode(S_OK);
}
</code></pre>
<p>
If your control doesn't use MFC, you can still use these functions as a model for implementing your own <b>IObjectSafety</b> interface. </p>
<p>
Since the difference between this version of <b>StopLite</b> and the original is in only two files, we've included the two files in the source code archive for StopLite. Read the ReadMe.Txt file in the SafeAlt subdirectory. </p>
<h2>Adding Interfaces to Existing MFC OLE Objects </h2>
<p>
To add the <b>IObjectSafety</b> interface to an existing MFC OLE object, we had to do a few things in addition to writing the functions above. </p>
<p>
MFC provides most of the framework for adding interfaces to any <b>CCmdTarget</b>-derived object. (All window classes, including <b>COleControl</b>, are derived from <b>CWnd</b>, which is derived from <b>CCmdTarget</b>.) All we have to do is insert some macros into our header file and implementation file and provide functions to implement the interface. </p>
<p>
The code generated by these macros uses the nested class feature of Visual C++ for the implementation class. In the macros, I called my class <b>ObjSafe</b>. MFC prepends an <i>X</i> to the name when making the name of the nested class, so the name of the nested class ended up being CStopLiteCtrl::XObjSafe. The functions we implemented were in that class; thus the funny names <b>CStopLiteCtrl::XObjSafe::GetInterfaceSafetyOptions</b> and <b>CStopLiteCtrl::XObjSafe::SetInterfaceSafetyOptions.</b> </p>
<p>
To add an interface to an existing class, we need to:
<ul type=disc>
<li>
Add <b>DECLARE_INTERFACE_MAP()</b> to the class declaration. <br><br></li>
<li>
Declare each function between <b>BEGIN_INTERFACE_PART</b> and <b>END_INTERFACE_PART</b> macros.<br><br></li>
<li>
Add an <b>INTERFACE_MAP</b> to the implementation file for the class which includes an <b>INTERFACE_PART</b> for each interface to be added to the class. <br><br></li>
<li>
Implement all the functions in the interface, including implementations of the <b>IUnknown</b> functions <b>AddRef</b>,<b> Release</b>,<b> </b>and <b>QueryInterface</b> that simply pass on calls to the control's <b>IUnknown</b> functions. </li>
</ul>
<p>
First, I had to include OBJSAFE.H, which ships with the ActiveX SDK, in order to get the declaration for <b>IObjectSafety</b>. Next, I did the first two steps above with the following code placed in the <b>CStopLiteCtrl</b> class definition in STOPLITECTL.H:</p>
<pre><code>&nbsp;&nbsp;&nbsp;DECLARE_INTERFACE_MAP()
 &nbsp; BEGIN_INTERFACE_PART(ObjSafe, IObjectSafety)
 &nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD_(HRESULT, GetInterfaceSafetyOptions) ( 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* [in] */ REFIID riid,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD_(HRESULT, SetInterfaceSafetyOptions) ( 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* [in] */ REFIID riid,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* [in] */ DWORD dwOptionSetMask,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* [in] */ DWORD dwEnabledOptions
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; END_INTERFACE_PART(ObjSafe);
</code></pre>
<p>
I copied the function declarations from OBJSAFE.H and converted them to macro invocations as described in the technote. Note that I made up a name, <b>ObjSafe</b>, as my identifier for the class and that the <b>BEGIN_INTERFACE_PART</b> macro invocation also specifies <b>IObjectSafety</b> as the base class for my implementation class.</p>
<p>
Next, I modifed STOPLITECTL.CPP to contain an interface map:</p>
<pre><code>/////////////////////////////////////////////////////////////////////////////
// Interface map for IObjectSafety
BEGIN_INTERFACE_MAP( CStopLiteCtrl, COleControl )
 &nbsp; INTERFACE_PART(CStopLiteCtrl, IID_IObjectSafety, ObjSafe)
END_INTERFACE_MAP()
</code></pre>
<p>
and the definitions of all of the functions in the interface. I've already shown you <b>GetInterfaceSafetyOptions</b> and <b>SetInterfaceSafetyOptions</b>,<b> </b>so here are <b>AddRef</b>,<b> Release</b>, and <b>QueryInterface</b>, copied from the technote and edited:</p>
<pre><code>/////////////////////////////////////////////////////////////////////////////
// IObjectSafety member functions
// Delegate AddRef, Release, QueryInterface
ULONG FAR EXPORT CStopLiteCtrl::XObjSafe::AddRef()
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CStopLiteCtrl, ObjSafe)
 &nbsp;&nbsp; return pThis-&gt;ExternalAddRef();
}
ULONG FAR EXPORT CStopLiteCtrl::XObjSafe::Release()
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CStopLiteCtrl, ObjSafe)
 &nbsp;&nbsp; return pThis-&gt;ExternalRelease();
}
HRESULT FAR EXPORT CStopLiteCtrl::XObjSafe::QueryInterface(
 &nbsp;&nbsp; REFIID iid, void FAR* FAR* ppvObj)
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CStopLiteCtrl, ObjSafe)
 &nbsp;&nbsp; return (HRESULT)pThis-&gt;ExternalQueryInterface(&amp;iid, ppvObj);
}
</code></pre>
<p>
Note that functions that call <b>IUnknown</b> functions have a <b>METHOD_PROLOGUE</b> macro invocation near the beginning and use the <b>pThis</b> pointer, set by the <b>METHOD_PROLOGUE</b> macro to call functions called <b>ExternalAddRef</b>, <b>ExternalRelease</b>, and <b>ExternalQueryInterface.</b> Doing this ensures that the object's <b>IUnknown</b> functions are called, allowing for accurate reference counting and automatically correct results from <b>QueryInterface</b>. </p>
<p>
This technique can be used to add any arbitrary OLE interface to an MFC class. </p>
<p>
For a more detailed discussion about the creation of the <b>StopLite </b>control, see <a href="msdn_abcsmfc.htm">"The ABCs of MFC ActiveX Controls."</a></p>
<p>
More detailed directions and a description of how MFC applications and OLE interact are available in "Technical Note 38: MFC/OLE IUnknown Implementation" in the MSDN Library.</p>
<h2>Conclusion: Can You Spare a Moment for Safety? </h2>
<p>
Signing and marking together require only about 4.5 kilobytes (K). At 28.8 kilobits per second (Kbps), that's a second and a half additional download time for the user, hardly a significant burden when you consider the huge gain in safety. So, take the time to sign all your code and mark those controls that are safe. </p>
</BODY>
</HTML>
