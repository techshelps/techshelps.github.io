<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Calling All Members: Member Functions as Callbacks</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_callb"></a></sup>Calling All Members: Member Functions as Callbacks</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: April 30, 1992</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="103">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the CALLB sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
Microsoft® Windows™ version 3.1 has over 30 callback functions that applications can use to enumerate objects, hook into the hardware, and perform a variety of other activities. Due to the prevalence of callbacks, it is only natural to want to handle callbacks with C++ member functions. However, callbacks are prototyped as C functions and, therefore, do not associate data with operations on that data, making the handling of callbacks less straightforward when you use C++ than it initially might appear.</p>
<p>
This article explains why normal member functions cannot be used as callback functions, gives several techniques for handling callbacks, and illustrates these techniques with code fragments. The code fragments are included as the CALLB sample program on the Microsoft Developer Network CD.</p>
<p>
The article and source code are targeted toward Microsoft C/C++ version 7.0, but the ideas presented apply to all C++ compilers, including those by Borland and Zortech.</p>
<p>
The reader should be familiar with Windows callbacks and with C++. A bibliography is supplied at the end of the article.</p>
<h2>The Hidden Parameter, the this Pointer</h2>
<p>
Every callback function has its own prototype, which determines the parameters that the Microsoft® Windows™ operating system passes to the function. For example, <b>EnumObjects</b> is a Windows function that enumerates objects inside of Windows, such as pens and brushes (these objects should not be confused with C++ objects). <b>EnumObjectsProc</b> is the callback for <b>EnumObjects</b> and is prototyped this way: </p>
<pre><code>int FAR PASCAL __export EnumObjectsProc( LPSTR lpLogObject, LPSTR 
 &nbsp;&nbsp;&nbsp;&nbsp; lpData) ;
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;CALLBACK can be used in place of FAR PASCAL above.</p>
<p>
When Windows calls the <b>EnumObjectsProc</b> function, it passes the two parameters—<i>lpLogObject</i> and <i>lpData—</i>to the function.</p>
<p>
The following code attempts to set up a member function as a callback. The code compiles and links successfully but causes a protection fault at run time.</p>
<pre><code>// See CProg1.cpp
// Run nmake -fmake1
class CProg1 {
 &nbsp; private:
 &nbsp;&nbsp;&nbsp;&nbsp; int nCount ;
 &nbsp;&nbsp;&nbsp;&nbsp; // Incorrect callback declaration
 &nbsp;&nbsp;&nbsp;&nbsp; // Use a static or nonmember function.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int FAR PASCAL EXPORT 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EnumObjectsProc( LPSTR lpLogObject, LPSTR lpData) ;
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Constructor
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CProg1() : nCount(0) {};
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Member function
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void enumIt(CDC&amp; dc) ;
};

void CProg1::enumIt(CDC&amp; dc)
{
 &nbsp; // Register callback
 &nbsp;&nbsp;&nbsp;&nbsp; dc.EnumObjects(OBJ_BRUSH, EnumObjectsProc, NULL) ;
}

// Callback handler
int FAR PASCAL EXPORT 
CProg1::EnumObjectsProc( LPSTR lpLogObject, LPSTR pData)
{
 &nbsp; // Process the callback.
 &nbsp;&nbsp;&nbsp;&nbsp; nCount++ ;
 &nbsp;&nbsp;&nbsp;&nbsp; MessageBeep(0) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return 1 ;
}
</code></pre>
<p>
If the Windows <b>::EnumObjects</b> function is called instead of <b>CDC::EnumObjects</b>, as in this line:</p>
<pre><code>::EnumObjects(hdc, OBJ_BRUSH, (FARPROC)EnumObjectsProc, NULL) ;
</code></pre>
<p>
the following error would occur:</p>
<pre><code>cprog1.cpp(13) : error C2643: illegal cast from pointer to member
</code></pre>
<p>
The reason for the above error and protection fault is that C++ member functions have a hidden parameter known as the <b>this</b> pointer. C++ is able to associate a function with a particular instance of an object by means of the <b>this</b> pointer. When C++ compiles the following line:</p>
<pre><code>dc.EnumObjects(OBJ_BRUSH, EnumObjectsProc, NULL) ;
</code></pre>
<p>
it generates a call equivalent to:</p>
<pre><code>CDC::EnumObjects(OBJ_BRUSH, EnumObjectsProc, NULL, (CDC *)&amp;dc) ;
</code></pre>
<p>
The last parameter, (<i>CDC*</i>) <i>&amp;dc</i>, is the <b>this </b>pointer. Member functions access an object's data through the <b>this</b> pointer. C++ handles the <b>this </b>pointer implicitly when accessing member data. In the <b>CProg1::enumIt</b> function, the line:</p>
<pre><code>nCount = 0 ;
</code></pre>
<p>
is actually compiled this way:</p>
<pre><code>this-&gt;nCount = 0 ;
</code></pre>
<p>
Windows passes only two parameters to <b>EnumObjectsProc</b>. It does not call functions through objects and cannot send a <b>this </b>pointer to the callback function. However, as compiled above, <b>EnumObjectsProc</b> expects three parameters instead of two. The result is that a random value on the stack is used as the <b>this </b>pointer, causing a crash. To handle <b>EnumObjectsProc</b> as a member function, the compiler must be told not to expect a <b>this</b> pointer as the last parameter.</p>
<h2>Avoiding the this Pointer</h2>
<p>
Two function types in C++ do not have a <b>this</b> pointer:
<ul type=disc>
<li>
Nonmember functions<br><br></li>
<li>
Static member functions</li>
</ul>
<h3>Nonmember Functions</h3>
<p>
A nonmember function is not part of a C++ class and, therefore, does not have a <b>this</b> pointer. A nonmember function does not have access to the private or protected members of a class. However, a nonmember friend function can access the private and protected class members with which the function is friendly. Using nonmember functions to handle a callback is similar to handling a callback in C. </p>
<h3>Static Member Functions</h3>
<p>
Static member functions are class member functions that do not receive <b>this </b>pointers. As a result:
<ul type=disc>
<li>
An object does not have to be created before a static member function is called or static member data is accessed.<br><br></li>
<li>
The class scope operator can access static members without an object, for example:<pre><code>CFoo::someFunc(someValue)
</code></pre>
</li>
<li>
A static member function cannot access a nonstatic member of its class without an object instance. In other words, all object access must be explicit, such as: <pre><code>object.nonStatFunc(someValue);
// NOT: nonStatFunc(someValue) ;
</code></pre>
<p class=tl>
or an object pointer, such as: </P><pre><code>ptrObject-&gt;nonStatFunc(someValue);
// NOT: nonStatFunc(someValue)&nbsp; ;
</code></pre>
</li>
</ul>
<p>
The last point above is the kicker. Unlike a nonstatic member function, a static member function is not bound to an object. A static function cannot implicitly access nonstatic members. </p>
<p>
For more information on static member functions, see the bibliography at the end of this article.</p>
<h2>Techniques for Handling Callbacks</h2>
<p>
The rest of this article demonstrates techniques for handling callbacks with static member functions. The main concern is linking the callback routine with a particular object by providing a pointer to the object—kind of a pseudo-<b>this</b> pointer. In other words, our goal is to make a static function act like a nonstatic function. You can use the following techniques to achieve this goal:
<ul type=disc>
<li>
Not providing a pointer<br><br></li>
<li>
Providing a pointer in a static member variable<br><br></li>
<li>
Passing a pointer in a parameter for application-supplied data<br><br></li>
<li>
Keeping a pointer in a collection indexed by a return value</li>
</ul>
<p>
The callback being handled will determine the technique to use. Many callbacks do not have a parameter for application-supplied data, nor do they return a unique value.</p>
<h3>Not Providing a Pointer</h3>
<p>
In some cases, object pointers are unnecessary because the callback does not need to access member data. In these cases, the callback operates only on static data. The following code fragment demonstrates the technique.</p>
<pre><code>// See CProg3.cpp
// Run nmake -fmake3
class CProg3 {
 &nbsp; private:
 &nbsp;&nbsp;&nbsp;&nbsp; static int statCount ;
 &nbsp;&nbsp;&nbsp;&nbsp; int nCount ;
 &nbsp;&nbsp;&nbsp;&nbsp; // Use a static member function for callbacks.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int FAR PASCAL EXPORT 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EnumObjectsProc( LPSTR lpLogObject, LPSTR lpData) ;
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; // Constructor
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CProg3() : nCount(0) {};
 &nbsp;&nbsp;&nbsp;&nbsp; // Member function
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void enumIt(CDC&amp; dc) ;
};

// Static data members must be defined.
int CProg3::statCount = 0 ;

// Enumerate the Windows DC objects.
void CProg3::enumIt(CDC&amp; dc)
{
 &nbsp; // Register callback and start enumerating.
 &nbsp;&nbsp;&nbsp;&nbsp; dc.EnumObjects(OBJ_BRUSH, EnumObjectsProc, NULL) ;
}

// Callback handler
int FAR PASCAL EXPORT 
CProg3::EnumObjectsProc( LPSTR lpLogObject, LPSTR pData)
{
 &nbsp; // Process the callback.
 &nbsp;&nbsp;&nbsp;&nbsp; statCount++;
 &nbsp; // nCount++;&nbsp; This line would cause an error if not commented.
 &nbsp;&nbsp;&nbsp;&nbsp; MessageBeep(0) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return 1 ;
}
</code></pre>
<p>
Note that all objects of the CProg3 class above will share the <i>statCount</i> variable. Whether this is good or bad depends on what the application is trying to accomplish. The following code fragment illustrates how the outcome might not be what is expected.</p>
<pre><code>void someFunc(CDC&amp; aDC, CDC&amp; bDC, CDC&amp; cDC)
{
 &nbsp; // Assume that aDC has a = 3 objects.
 &nbsp; // Assume that bDC has b = 4 objects.
 &nbsp; // Assume that cDC has c = 7 objects.
 &nbsp; // Create some objects.
 &nbsp;&nbsp;&nbsp;&nbsp; CProg3 aObject;
 &nbsp;&nbsp;&nbsp;&nbsp; CProg3 bObject;
 &nbsp;&nbsp;&nbsp;&nbsp; CProg3 cObject;
 &nbsp;&nbsp;&nbsp;&nbsp; aObject.enumIt(aDC) ; // statCount = a = 3
 &nbsp;&nbsp;&nbsp;&nbsp; aObject.enumIt(bDC) ; // statCount = a + b = 7
 &nbsp;&nbsp;&nbsp;&nbsp; aObject.enumIt(cDC) ; // statCount = a + b + c = 14 
}
</code></pre>
<p>
There are several ways to avoid the sharing of data between instances of a class. The next sections describe techniques that link the callback function to a particular object by providing a pseudo-<b>this </b>pointer.</p>
<h3>Providing a Pointer in a Static Member Variable</h3>
<p>
The main reason to have a callback as a member function is for accessing class members unique to a particular object (that is, nonstatic members). A callback member function must be a static function and, therefore, can only access static members without using "." or "-&gt;".</p>
<p>
The next listing shows how to use a static member variable to pass an object's <b>this</b> pointer to the callback. The callback can then use the pointer to access object members. To simplify the code, the callback calls a helper function that performs all the work. The helper function is nonstatic and can implicitly access member data through its <b>this</b> pointer.</p>
<pre><code>// See CProg5.cpp
// Run nmake -fmake1
class CProg5 {
 &nbsp; private:
 &nbsp;&nbsp;&nbsp;&nbsp; int nCount ;
 &nbsp;&nbsp;&nbsp;&nbsp; // Use a static variable to pass the this pointer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static CProg5 * pseudoThis ;
 &nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; // Use a static member function for callbacks.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int FAR PASCAL EXPORT 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EnumObjectsProc( LPSTR lpLogObject, LPSTR lpData) ;
 &nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; // Use a nonstatic member function as a helper.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int EnumObjectsHelper( LPSTR lpLogObject, LPSTR lpData);
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; CProg5() : nCount(0) {};
 &nbsp;&nbsp;&nbsp;&nbsp; void enumIt(CDC&amp; dc) ;
};

// Static data members must be defined.
CProg5 * CProg5::pseudoThis = NULL;

// Enumerate the objects.
void CProg5::enum(CDC&amp; dc)
{
 &nbsp; pseudoThis = this ;
 &nbsp; // Register callback and start enumerating.
 &nbsp;&nbsp;&nbsp;&nbsp; dc.EnumObjects(OBJ_BRUSH, EnumObjectsProc, NULL) ;
 &nbsp;&nbsp;&nbsp;&nbsp; pseudoThis = NULL ;
}

// Callback handler
int FAR PASCAL EXPORT 
CProg5::EnumObjectsProc( LPSTR lpLogObject, LPSTR lpData)
{
 &nbsp; if (pseudoThis != (CProg *)NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; return pseudoThis-&gt;EnumObjectsHelper(lpLogObject, lpData) ;
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; return 0 ;
}

int CProg5::EnumObjectsHelper( LPSTR lpLogObject, LPSTR lpData)
{
 &nbsp; // Process the callback.
 &nbsp;&nbsp;&nbsp;&nbsp; nCount++;
 &nbsp;&nbsp;&nbsp;&nbsp; MessageBeep(0) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return 1 ;
}
</code></pre>
<p>
While the above technique works fine in many cases, the objects must coordinate the use of the callback. For callbacks (such as <b>EnumObjects</b>) that do their work and then exit, coordination is not much of a problem. For other callbacks, it may be. The techniques described in the next two sections require less coordination but work only with certain callbacks.</p>
<h3>Passing a Pointer in a Parameter for Application-Supplied Data</h3>
<p>
A close examination of the <b>EnumObjects</b> function reveals that it has an extra 32-bit parameter, <i>lpData</i>, for supplying data to the callback routine. This is a great place to pass a pointer to an object. The following overworked sample demonstrates this technique.</p>
<pre><code>// See CProg6.cpp
// Run nmake -fmake1
class CProg6 {
 &nbsp; private:
 &nbsp;&nbsp;&nbsp;&nbsp; int nCount ;
 &nbsp;&nbsp;&nbsp;&nbsp; // Use a static member function for callbacks.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int FAR PASCAL EXPORT 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EnumObjectsProc( LPSTR lpLogObject, LPSTR lpData) ;
 &nbsp;&nbsp;&nbsp;&nbsp; // Use a nonstatic member function as a helper.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int EnumObjectsHelper( LPSTR lpLogObject) ;
 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; CProg6() : nCount(0) {};
 &nbsp;&nbsp;&nbsp;&nbsp; void enumIt(CDC&amp; dc) ;
};

// Enumerate the objects.
void CProg6::enumIt(CDC&amp; dc)
{
 &nbsp; // Register callback and start enumerating.
 &nbsp;&nbsp;&nbsp;&nbsp; dc.EnumObjects(OBJ_BRUSH, EnumObjectsProc, (LPSTR)this) ;
}

// Callback handler
int FAR PASCAL EXPORT 
CProg6::EnumObjectsProc( LPSTR lpLogObject, LPSTR lpData)
{
 &nbsp;&nbsp;&nbsp;&nbsp; CProg6 * pseudoThis = (CProg6 *)lpData ;
 &nbsp;&nbsp;&nbsp;&nbsp; if ( pseudoThis != (CProg6 *)NULL )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pseudoThis-&gt;EnumObjectsHelper(lpLogObject) ;
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0 ;
}

// Callback helper function.
int CProg6::EnumObjectsHelper( LPSTR lpLogObject)
{
 &nbsp; // Process the callback.
 &nbsp;&nbsp;&nbsp;&nbsp; nCount++;
 &nbsp;&nbsp;&nbsp;&nbsp; MessageBeep(0) ;
 &nbsp;&nbsp;&nbsp;&nbsp; return 1;
}
</code></pre>
<p>
This technique will, of course, only work with callbacks that take application-supplied data. The following list shows those callbacks:
<ul type=disc>
<li>
EnumChildProc <br><br></li>
<li>
EnumChildWindows <br><br></li>
<li>
EnumFontFamProc<br><br></li>
<li>
EnumFontFamilies<br><br></li>
<li>
EnumFontsProc<br><br></li>
<li>
EnumMetaFileProc<br><br></li>
<li>
EnumObjectsProc<br><br></li>
<li>
EnumPropFixedProc<br><br></li>
<li>
EnumPropMovableProc <br><br></li>
<li>
EnumTaskWndProc<br><br></li>
<li>
EnumWindowsProc<br><br></li>
<li>
LineDDAProc</li>
</ul>
<h3>Keeping a Pointer in a Collection Indexed by a Return Value</h3>
<p>
Another technique for linking an object<b> </b>pointer with a callback uses the return value of the function that sets up the callback. This return value is used as an index into a collection of object pointers.</p>
<p>
In the following example, <b>SetTimer</b> sets up a <b>TimerProc</b> callback and returns a unique timer ID. The timer ID is passed to <b>TimerProc</b> each time the function is called. The CTimer class uses the timer ID to find the object pointer in a <b>CMapWordToPtr</b> collection. The CTimer class is an abstract class designed to be inherited by other classes.</p>
<pre><code>// See CTimer.h
// Run nmake -ftmake

// Declaration
class CTimer
{
 &nbsp; private:
 &nbsp;&nbsp;&nbsp;&nbsp; UINT id ;
 &nbsp;&nbsp;&nbsp;&nbsp; static CMapWordToPtr timerList ;
 &nbsp;&nbsp;&nbsp;&nbsp; static void stopTimer(int id) ;
 &nbsp;&nbsp;&nbsp;&nbsp; static void FAR PASCAL EXPORT
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timerProc(HWND hwnd, UINT wMsg, int timerId, DWORD dwTime);

 &nbsp; protected:
 &nbsp;&nbsp;&nbsp;&nbsp; virtual void timer(DWORD dwTime) = 0 ;

 &nbsp; public:
 &nbsp;&nbsp;&nbsp;&nbsp; // Constructor
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CTimer() : id(NULL) {};
 &nbsp;&nbsp;&nbsp;&nbsp; // Destructor
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~CTimer() {stop();};
 &nbsp;&nbsp;&nbsp;&nbsp; // Use
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL start(UINT msec) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void stop() ;
};

// Define statics.
CMapWordToPtr CTimer::timerList ;

// Implementation

BOOL CTimer::start (UINT msecs)
{
 &nbsp; id = SetTimer(NULL,0,msecs,(FARPROC)timerProc);
 &nbsp; if (id != NULL)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; timerList.SetAt(id, this);
 &nbsp;&nbsp;&nbsp;&nbsp; return TRUE ;
 &nbsp; }
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
}

void CTimer::stop()
{
 &nbsp;&nbsp;&nbsp;&nbsp; if (id != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stopTimer(id) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id = NULL ;
 &nbsp;&nbsp;&nbsp;&nbsp; }
}


static void CTimer::stopTimer(int timerId) 
{
 &nbsp;&nbsp; KillTimer(NULL,timerId) ;
 &nbsp;&nbsp; timerList.RemoveKey(timerId) ;
}

static void FAR PASCAL EXPORT
CTimer::timerProc(HWND hwnd, UINT wMsg, int timerId, DWORD dwTime)
{
 &nbsp; CTimer * pseudoThis ;
 &nbsp; if ( timerList.Lookup(timerId, (void*&amp;)pseudoThis))
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if ( pseudoThis != (CTimer *)NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pseudoThis-&gt;timer(dwTime) ;
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stopTimer(timerId) ;
 &nbsp; }
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; KillTimer(NULL,timerId) ;
 }

// Inherit CTimer class in order to use it.
class CMyTimer : public CTimer {
 &nbsp; protected:
 &nbsp;&nbsp;&nbsp;&nbsp; void timer(DWORD dwTimer) { MessageBeep(0); } ;
};
</code></pre>
<h2>Conclusion</h2>
<p>
Static member functions are used in C++ to handle callbacks because they do not have <b>this</b> pointers. Callback functions are not designed to accept <b>this</b> pointers. Because static member functions do not have <b>this</b> pointers and, in many cases, it is desirable to have access to an object, this article has suggested four ways of providing the static member function with a <b>this</b> pointer.</p>
<h2>Bibliography</h2>
<p>
For more information on C++ topics such as the <b>this</b> pointer, friend functions, or static functions, see:
<ul type=disc>
<li>
Stroustrup, Bjarne. <i>The C++ Programming Language</i>. 2d ed. Addison-Wesley, 1991.<br><br></li>
<li>
Ellis and Stroustrup. <i>The Annotated C++ Reference Manual</i>. Addison-Wesley, 1990.<br><br></li>
<li>
Lippman, Stanley B. <i>C++ Primer</i>. 2d ed. Addison-Wesley, 1991.<br><br></li>
<li>
Microsoft C/C++ version 7.0 <i>C++ Language Reference</i>. Microsoft Corporation, 1991.<br><br></li>
<li>
Microsoft C/C++ version 7.0 <i>C++ Class Libraries User's Guide</i>, Microsoft Corporation, 1991.</li>
</ul>
<p>
For information on callbacks, see:
<ul type=disc>
<li>
Microsoft Windows version 3.1 Software Development Kit (SDK) <i>Programmer's Reference, Volume 1: Overview</i>. Microsoft Corporation, 1987-1992.<br><br></li>
<li>
Microsoft Windows version 3.1 SDK <i>Programmer's Reference,</i> <i>Volume 2: Functions</i>. Microsoft Corporation, 1987-1992.<br><br></li>
<li>
Microsoft Windows version 3.1 SDK <i>Guide to Programming</i>. Microsoft Corporation, 1987-1992.<br><br></li>
<li>
Petzold, Charles. <i>Programming Windows</i>. 2d ed. Microsoft Press, 1990.<br><br></li>
<li>
Norton, Peter and Paul Yao. <i>Peter Norton's Windows 3.0 Power Programming Techniques</i>. Bantam Computer Books, 1990.</li>
</ul>
</BODY>
</HTML>
