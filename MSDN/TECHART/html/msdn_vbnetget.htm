<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Visual Basic and the Win32 Internet SDK</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_vbnetget"></a></sup>Visual Basic and the Win32 Internet SDK</h1>
<p>
James Braum<br>
Microsoft Developer Network Technology Group</p>
<p>
September 5, 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5005">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the VBNetGet sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article examines a variety of Microsoft® Win32® Internet (WinInet) functions and illustrates how to use them in a Visual Basic® application. Declaring and using these WinInet functions in a class module allows you to leverage the power of the Win32 Internet API, facilitating rapid development of slick Internet-aware applications in any language. This article does not provide in-depth coverage of the API functions; for that refer to the Microsoft Win32 Internet Programmer's Reference at <a href="http://www.microsoft.com/intdev/sdk/docs/wininet/">http://www.microsoft.com/intdev/sdk/docs/wininet/.</a></p>
<p>
In this article, I develop a sample application (NetGet) that lets you download and view the contents of a Uniform Resource Locator (URL). The application uses a reusable class that is developed along the way. This class encapsulates the calls to the WinInet functions, making it convenient to use in your own projects. (If you are interested in looking at a Visual C++® implementation of the WinInet functions, refer to the article "The Internet API (or How to Get from Here to There)" by Robert Coleridge, elsewhere on this CD.) The raw HTML is put into a text box, and the list of references and images are parsed and loaded into two different <b>list box</b> controls. A third <b>list box</b> control contains the files you can download.</p>
<h2>Introduction</h2>
<p>
Several third-party tools and controls are available for developing Internet-aware applications, including the Microsoft Internet Control Pack, (information available from http://www.microsoft.com/icp/icpmain.htm). It is often more convenient to write straight to an application programming interface (API) to get exactly the functionality you need rather than to plug in a control, because you can pick and choose exactly the set of functions you need to get a particular job done. Programming with the Win32 Internet (WinInet) API gives you just this level of control. Finding the functions you need and placing them in a class module makes sense because you end up with a reusable and robust object. After you have tested the object, you can safely use it in other projects. That's what this article demonstrates.</p>
<p>
WinInet provides a wealth of functionality. Functions for working with Gopher, File Transfer Protocol (FTP), and Hypertext Transfer Protocol (HTTP) abstract the complexities of working with these protocols into an easy-to-use API that can be called from almost any language. Knowledge of Transmission Control Protocol/Internet Protocol (TCP/IP), Windows® Sockets, the inner workings of HTTP, and so forth are not required to use this API. Additionally, because this API offers an abstraction from the actual implementation, you can be sure that as protocols evolve you will not have to rewrite your applications; only the WinInet DLL will need upgrading.</p>
<p>
Consider this article a starting point. Take the ideas presented and apply them to your solution set. If the sample class contains the functionality you need, simply drop it into your project and go to work.</p>
<h2>The WinInet Functions</h2>
<p>
This article examines four WinInet functions: <b>InternetOpen</b>, <b>InternetOpenUrl</b>, <b>InternetReadFile</b>, and <b>InternetCloseHandle</b>.</p>
<p>
Let's dive right in and look at some sample code. The following code reads the contents of a URL into a buffer. It does not take reams of code to get the contents of a URL—you simply open the connection using <b>InternetOpen</b>, call <b>InternetOpenUrl</b> with a URL you would like to read (http://www.microsoft.com/ in this case, but I am sure that you can come up with one on your own), progressively read the file using <b>InternetReadFile</b>, and close both connections with <b>InternetCloseHandle</b>. </p>
<pre><code>Dim hInternetSession&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Dim hUrlFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Long
Dim sReadBuffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As String * 4096&nbsp;&nbsp;&nbsp;&nbsp; ' Grab 4k at a time
Dim sBuffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As String
Dim lNumberOfBytesRead&nbsp;&nbsp;&nbsp;&nbsp; As Long
Dim bDoLoop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Boolean
hInternetSession = InternetOpen("My VB App!", _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0)
hUrlFile = InternetOpenUrl(hInternetSession, _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "http://www.microsoft.com/", vbNullString, 0, INTERNET_FLAG_RELOAD, 0)
bDoLoop = True
While bDoLoop
 &nbsp; sReadBuffer = scBlankStr
 &nbsp;&nbsp;&nbsp;&nbsp; bDoLoop = InternetReadFile(hUrlFile, sReadBuffer, _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Len(sReadBuffer), lNumberOfBytesRead)
 &nbsp;&nbsp;&nbsp;&nbsp; sBuffer = sBuffer &amp; Left$(sReadBuffer, lNumberOfBytesRead)
If Not Cbool(lNumberOfBytesRead) Then bDoLoop = False
Wend
InternetCloseHandle(hUrlFile)
InternetCloseHandle(hInternetSession)
</code></pre>
<h3>InternetOpen</h3>
<p>
This function returns a handle that subsequent WinInet function calls use. The declaration looks like this:</p>
<pre><code>Private Declare Function InternetOpen Lib "wininet.dll" _ 
 &nbsp;&nbsp;&nbsp;&nbsp; Alias "InternetOpenA" (ByVal sAgent As String, _ 
 &nbsp;&nbsp;&nbsp;&nbsp; ByVal lAccessType As Long, ByVal sProxyName As String, _
 &nbsp;&nbsp;&nbsp;&nbsp; ByVal sProxyBypass As String, ByVal lFlags As Long) As Long
</code></pre>
<p>
The <b>InternetOpen</b> function takes five parameters and returns a handle if successful. Look at the <b>LastDLLError</b> property of the <b>Err</b> object if the call fails for a specific error code. Check the Error Codes section in the Microsoft Win32 Internet Programmer's Reference (<a href="http://www.microsoft.com/intdev/sdk/docs/wininet/">http://www.microsoft.com/intdev/sdk/docs/wininet/</a>) for relevant information corresponding to the error codes.</p>
<p>
The <i>sAgent</i> parameter specifies the name of the application or entity calling the Internet functions. This is the user agent in the HTTP protocol. This could be a value such as "My Internet Application" or "Microsoft Internet Explorer." Some Web servers look at this to autodetect the type of client you are using. Think of this as the way you identify yourself to the HTTP server. </p>
<p>
The <i>lAccessType</i> parameter indicates the type of access needed.
<ul type=disc>
<li>
Use <b>INTERNET_OPEN_TYPE_PRECONFIG</b> to instruct the function to interrogate the registry for access information. The registry is automatically configured when you run Microsoft Internet Explorer. Add this declaration to your class module:<pre><code>Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
</code></pre>
</li>
<li>
The <b>INTERNET_OPEN_TYPE_DIRECT</b> flag specifies local resolution of host names. <br><br></li>
<li>
<b>INTERNET_OPEN_TYPE_PROXY</b> allows you to specify a proxy. This leads us to a discussion of the next two parameters: <i>sProxyName</i> and <i>sProxyBypass</i>.</li>
</ul>
<p>
<i>sProxyName</i> is a string specifying the proxy server (or servers) to use if requested. To interrogate the registry for proxy server details, leave this parameter NULL and set the <i>lAccessType</i> to <b>INTERNET_OPEN_TYPE_PROXY.</b></p>
<p>
<i>sProxyBypass</i> is a string containing a list of hosts or Internet Protocol (IP) addresses known locally so they are not passed through to the proxy server. To interrogate the registry for local IP addresses, leave this parameter NULL and use the <b>INTERNET_OPEN_TYPE_PROXY</b> for the <i>lAccessType</i>.</p>
<p>
<i>lFlags</i> specifies if you want asynchronous or synchronous behavior from subsequent WinInet function calls derived from this handle. To get synchronous behavior, you must specify 0 for this flag. </p>
<h3>InternetOpenUrl</h3>
<p>
This function returns a handle to the URL if the connection succeeds. This is the function that actually begins to read from the URL. </p>
<p>
It is important to note that you can use these functions today with Gopher, FTP, and HTTP protocols; they are essentially all-purpose Internet functions. For opening and reading Hypertext Markup Language (HTML) from a HTTP URL, these functions are more than adequate. However, if you need additional functionality, such as querying for the number of bytes the URL will return, look at the HTTP WinInet functions in the Microsoft Win32 Internet Programmer's Reference.</p>
<p>
The declaration looks like this:</p>
<pre><code>Private Declare Function InternetOpenUrl Lib "wininet.dll" _ 
 &nbsp; Alias "InternetOpenUrlA" (ByVal hInternetSession As Long, _ 
 &nbsp; ByVal sUrl As String, ByVal sHeaders As String, _ 
 &nbsp; ByVal lHeadersLength As Long, ByVal lFlags As Long, _ 
 &nbsp; ByVal lContext As Long) As Long
</code></pre>
<p>
<b>InternetOpenUrl</b> takes six parameters and, if successful, returns a handle. After you have finished with the handle returned from this function, close it with the <b>InternetCloseHandle</b> function.</p>
<p>
<i>hInternetSession</i> is the handle obtained from calling <b>InternetOpen</b>. </p>
<p>
<i>sUrl</i> is a string with the URL that you wish to read. The function will parse the URL for you, so just specify the complete URL.</p>
<p>
<i>sHeaders</i> is a string that contains optional headers you may want to send to a HTTP server. <i>lHeadersLength</i> is the length of the optional headers string (if you use one). The request-header fields in HTTP allow the client to pass additional information about the request, and about the client itself, to the server. For example, you could specify a Transfer-Encoding scheme and request that the data be sent in that particular format.</p>
<p>
<i>lFlags</i> is an action flag for the function—it tells the function how to behave. It can be one of these values: 
<ul type=disc>
<li>
The <b>INTERNET_FLAG_RELOAD</b> flag directs the function to read data from the remote service even if it is locally cached.<br><br></li>
<li>
Use <b>INTERNET_FLAG_DONT_CACHE</b> when you don't want to cache data locally. <br><br></li>
<li>
Use <b>INTERNET_FLAG_RAW_DATA</b> to return <b>WIN32_FIND_DATA</b> data structures if you are reading data from an FTP URL. The function defaults to returning HTML.<br><br></li>
<li>
<b>INTERNET_FLAG_SECURE</b> specifies use of Secure Sockets Layer (SSL) for secure HTTP requests with authentication by RSA Data Security, Inc. <br><br></li>
<li>
<b>INTERNET_FLAG_EXISTING_CONNECT</b> tells the function to reuse existing connections if possible. </li>
</ul>
<p>
<i>lContext</i> is passed to callback functions along with the returned handle. Just use 0 for this flag because you are using these functions synchronously.</p>
<h3>InternetReadFile</h3>
<p>
Once you have a handle from <b>InternetOpenUrl</b> you can start reading data. You pass this function a buffer to read the data into and a value indicating the length of the buffer. The function returns <b>TRUE</b> if successful, and <b>FALSE</b> otherwise. An out parameter, <i>lNumberOfBytesRead</i>, indicates how much data was read from the call. If the function returns <b>TRUE</b> and the out parameter indicating the number of bytes read is 0, the function has read all the data corresponding to the URL. </p>
<p>
Here is the declaration:</p>
<pre><code>Private Declare Function InternetReadFile Lib "wininet.dll" _
 &nbsp; (ByVal hFile As Long, ByVal sBuffer As String, _ 
 &nbsp; ByVal lNumberOfBytesToRead As Long, _ 
 &nbsp; lNumberOfBytesRead As Long) As Integer
</code></pre>
<p>
<i>hFile</i> is the handle returned from the call to <b>InternetOpenUrl</b>. </p>
<p>
<i>sBuffer</i> is a string that serves as the buffer. For reading HTML data, this buffer must be large enough to contain the complete HTML headers. Also, if you are reading directories in HTML format, the buffer must be large enough to hold the entire contents of the directory. A 32K buffer will be large enough in most cases. </p>
<p>
<i>lNumberOfBytesToRead</i> specifies the number of bytes you want to read in one call to the function. Make this equal to the length of the buffer, unless you only want to fill a portion of the buffer for each read. </p>
<p>
Finally, <i>lNumberOfBytesRead</i> is the number of bytes the function actually read. It is an out parameter, so this variable will be set by the function. </p>
<h3>InternetCloseHandle</h3>
<p>
This function closes handles opened with WinInet functions and frees resources associated with these functions. If there are outstanding operations on handles that are about to be closed, they will be canceled and the data will be lost. </p>
<p>
The function returns <b>TRUE</b> if the handle was closed successfully, and <b>FALSE</b> otherwise. This is the declaration:</p>
<pre><code>Private Declare Function InternetCloseHandle Lib "wininet.dll" _ 
 &nbsp;&nbsp;&nbsp;&nbsp; (ByVal hInet As Long) As Integer 
</code></pre>
<h2>The NetGet Sample Application</h2>
<p>
Now let's look at the sample Visual Basic® application, which allows us to view the raw HTML from a specified URL and download files. The sample application uses a class module that will encapsulate the WinInet API calls discussed above. You can drop this class into your project and go to work developing Internet-aware applications, or you can copy the <b>declare</b> statements and use the functions in your own classes or modules.</p>
<p>
The NetGet application lets you specify a URL, then view the HTML, references, and images associated with this URL. Double-clicking an image will place a copy of the image in the <b>files</b> list box on the right. The files will be saved to the <b>app.path</b> when you click the Save Files button. The application does some simplistic parsing of the HTML to get the references and images. To find the references, it looks for "&lt;A HREF=", and to find images it looks for "&lt;IMG SRC="; it then continues to read until it reaches the end of the tag. </p>
<p>
<img src="vbnetget_1.gif" border=0></p>
<p class=label>
<b>Figure 1. NetGet References/Images/Files View</b></p>
<p>
NetGet consists of one form and one class module. When the application starts it instantiates an instance of the <b>CNetGet</b> class. You can use this one instance of the object to read multiple URLs.</p>
<h3>How to Use CNetGet</h3>
<p>
The <b>CNetGet</b> object exposes the following methods and properties:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Methods</b></td>
<td class=label width=50%><b>Properties </b></td>
</tr>
<tr valign=top>
<td width=50%><b>ReadURL</b></td>
<td width=50%><b>GetRawHTML</b></td>
</tr>
<tr valign=top>
<td width=50%><b>ParseHTML</b></td>
<td width=50%><b>GetLastError</b></td>
</tr>
<tr valign=top>
<td width=50%><b>Init</b></td>
<td width=50%><b>SetStatusWindow</b></td>
</tr>
<tr valign=top>
<td width=50%><b>Term</b></td>
<td width=50%><b>SetUserAgent</b></td>
</tr>
</table><br>
<ul type=disc>
<li>
The <b>ReadURL</b> method calls the WinInet functions and reads the URL into a private buffer. The method returns <b>TRUE</b> if it successfully allocates a session handle, reads the data, and closes the handles. If there are problems along the way, the method returns <b>FALSE</b>.<br><br></li>
<li>
<b>ParseHTML</b> adds items to a collection object that you pass in with the references, images, or whatever you told it to parse. You can see some of the code corresponding to this method below.<br><br></li>
<li>
<b>Init</b> and <b>Term</b> are the <b>initialize</b> and <b>terminate</b> methods of the object. Once you instantiate the object, invoke the <b>Init</b> method. When you are done with the object, invoke the <b>Term</b> method.<br><br></li>
<li>
<b>SetStatusWindow</b> takes an object where status messages are to be displayed. The method sets the default property of the object passed to it. For instance, you may want the status messages to go to a <b>Status Bar</b> control, so you set the property like this:<pre><code>objNetGet.SetStatusWindow = StatusBar1.Panels(1)
</code></pre>
</li>
<li>
·<b>GetLastError</b> returns the last DLL error from a WinInet function call. If the object receives an error from calling one of the WinInet functions, you can check the error text corresponding to the error message with the property.<br><br></li>
<li>
<b>SetUserAgent</b> allows you to set the <b>user agent</b> property of the object.<br><br></li>
<li>
<b>GetRawHTML</b> returns the HTML that was read from the call to the <b>ReadURL</b> method. </li>
</ul>
<p>
As you can see, the object exposes a few easy-to-use methods and properties that facilitate quick and easy development of Internet-aware applications. Using the object is easy. All it takes is some code like this:</p>
<pre><code>Dim objNetGet&nbsp;&nbsp;&nbsp; As New CNetGet
Dim cRefs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As New Collection
Dim vRef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Variant
objNetGet.Init
If objNetGet.ReadURL("http://www.microsoft.com/") Then
If objNetGet.ParseHTML("A HREF=""", CRefs, " "" &gt; ? # ") Then&nbsp;&nbsp; 
For Each vRef In cRefs
 &nbsp; debug.print vRef
Next vRef
End If
End If
objNetGet.Term
Set objNetGet = Nothing 
</code></pre>
<p>
The <b>GetRawHTML</b> property exposes the interface to the HTML. Clicking the HTML tab gives you a view of the HTML:</p>
<p>
<img src="vbnetget_2.gif" border=0></p>
<p class=label>
<b>Figure 2. NetGet raw HTML view</b></p>
<h3>Implementation of the CNetGet Class Module</h3>
<p>
Now that you have seen the interface to the object, let's look at the implementation.</p>
<p>
The general declarations section of the class module contains the WinInet declarations as well as the following private constants and variables:</p>
<pre><code>Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_FLAG_RELOAD = &amp;H80000000
Private hInternetSession&nbsp;&nbsp;&nbsp; As Long
Private hUrlFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Long
Private sContents&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As String
Private sLastError&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As String
Private sStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As String
Private objWindow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Object
</code></pre>
<p>
The flags and the user agent constant have already been discussed. The other two private variables are for the handles returned from the calls to <b>InternetOpen</b> and <b>InternetOpenUrl</b>. <i>objWindow</i> is the window that you want the object to update. <i>sContents</i> contains the HTML read from the URL.</p>
<p>
The <b>ReadURL</b> method calls the functions necessary to open, read data from, and close an Internet connection. </p>
<pre><code>Public Function ReadUrl(ByVal sUrl As String, Optional vFileName As _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variant) As Boolean
Dim sReadBuffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As String * 2048 ' Bytes to read from one call
Dim lNumberOfBytesRead&nbsp; As Long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Bytes read from call to InternetReadFile
Dim lTotalBytesRead&nbsp;&nbsp;&nbsp;&nbsp; As Long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Total bytes read
Dim bDoLoop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Boolean&nbsp;&nbsp;&nbsp; ' Return value from InternetReadFile
Dim bReadInternetFile&nbsp;&nbsp; As Boolean
Dim bWriteToFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Boolean
On Error GoTo errReadUrl
Screen.MousePointer = vbHourglass
SetStatus "Opening Url..."
If Not IsMissing(vFileName) Then
 &nbsp;&nbsp; Dim iFileNum As Integer
 &nbsp;&nbsp; iFileNum = FreeFile
 &nbsp;&nbsp; Open CStr(vFileName) For Binary As iFileNum
 &nbsp;&nbsp; bWriteToFile = True
End If
hUrlFile = InternetOpenUrl(hInternetSession, sUrl, vbNullString, 0,_
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_FLAG_RELOAD, 0)
If CBool(hUrlFile) Then
 &nbsp;&nbsp; sContents = scBlankStr
 &nbsp;&nbsp; bDoLoop = True
 &nbsp;&nbsp; While bDoLoop
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sReadBuffer = scBlankStr
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bDoLoop = InternetReadFile(hUrlFile, sReadBuffer, Len(sReadBuffer), _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lNumberOfBytesRead)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Not CBool(bDoLoop) Then CheckError
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lTotalBytesRead = lTotalBytesRead + lNumberOfBytesRead
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetStatus "Reading Url: " &amp; CStr(lTotalBytesRead) &amp; " Bytes read..."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If CBool(lNumberOfBytesRead) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If bWriteToFile Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put #iFileNum, , sReadBuffer
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sContents = sContents &amp; Left$(sReadBuffer,lNumberOfBytesRead)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bDoLoop = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bReadInternetFile = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp; Wend
 &nbsp;&nbsp; InternetCloseHandle (hUrlFile)
 &nbsp;&nbsp; ReadUrl = True
Else
 &nbsp;&nbsp; CheckError
End If
If bWriteToFile Then Close
SetStatus "Ready"
Screen.MousePointer = vbDefault
Exit Function
errReadUrl:
sLastError = Error$(Err)
Screen.MousePointer = vbDefault
Exit Function
End Function
</code></pre>
<p>
This function illustrates the order in which you call the WinInet functions. </p>
<p>
If the <b>ReadURL</b> function returns <b>FALSE</b>, check the <b>GetLastError </b>property of the object for a meaningful error message. </p>
<p>
<b>ParseHTML</b> takes a token to search for, such as &lt;A HREF="", a collection, and an optional string that contains a list of delimiters. When the token is found (&lt;A HREF="" in this case) the method scans until it reaches one of the delimiter characters in the delimiter string. Here is a look at a portion of the method:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;lStartPos = 1
 &nbsp;&nbsp; lPosInStr = InStr(lStartPos, sContents, sToken, 1)
 &nbsp;&nbsp; While CBool(lPosInStr)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iCounter = 0
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lPosInStr = lPosInStr + Len(sToken)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Do
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iRetVal = InStr(1, sUseDelimiter, Mid$(sContents, lPosInStr + _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iCounter, 1), 1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iCounter = iCounter + 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Loop While Not CBool(iRetVal)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sAddItem = StripChars(Mid$(sContents, lPosInStr, iCounter - 1))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Len(sAddItem) Then colItems.Add sAddItem, sAddItem
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lStartPos = lPosInStr + iCounter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lPosInStr = InStr(lStartPos, sContents, sToken, 1)
 &nbsp;&nbsp; Wend 
</code></pre>
<p>
The <b>StripChars</b> function removes linefeeds and other unnecessary characters from the strings&nbsp; recognized by the routine.</p>
<p>
This should give you an idea of what you can do once you have read an HTML page. I can think of a number of applications where you would want to read a HTML page and parse the contents. For example, with the references parsed from each page you could construct a Web-traversing robot that could go out and recursively search for pages that contain some particular text.</p>
<h2>Conclusion</h2>
<p>
It is amazingly simple to develop Internet-aware applications using the WinInet functions. Keep in mind that the functions presented in this article are quite generic. The <b>InternetReadUrl</b> function, for instance, is a wrapper to other WinInet functions. If you need to work with the specifics of a particular protocol, such as HTTP or FTP, you should use the more appropriate HTTP or FTP WinInet functions. For reading files from the Internet, however, these functions are very well suited to the task.</p>
</BODY>
</HTML>
