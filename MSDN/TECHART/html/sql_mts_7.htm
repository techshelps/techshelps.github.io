<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Advanced Programming Interfaces and Topics</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Advanced Programming Interfaces and Topics</h1>
<p>
This section contains information about a variety of advanced topics.</p>
<h3>Programming Interfaces for Transaction Server</h3>
<p>
Microsoft Transaction Server supports the following interfaces.</p>
<h4>IObjectContext </h4>
<p>
An <b>ObjectContext</b> does the following: 
<ul type=disc>
<li>
Declares that the work of the object is complete.<br><br></li>
<li>
Prevents a transaction from being committed, either temporarily or permanently.<br><br></li>
<li>
Instantiates other Transaction Server objects and includes their work within the scope of the current object's transaction.<br><br></li>
<li>
Queries for the role of a caller.<br><br></li>
<li>
Queries for the status (enabled or disabled) of security.<br><br></li>
<li>
Queries to find out if an object is executing within a transaction.</li>
</ul>
<p>
You obtain a reference to the <b>IObjectContext</b> interface by calling the <b>GetObjectContext</b> function. As with a COM object, you must release an ObjectContext object when you have finished using it. The <b>IObjectContext</b> interface exposes the following methods.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Method</b></td>
<td class=label width=79%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=21%><b>CreateInstance</b></td>
<td width=79%>Instantiates another Microsoft Transaction Server object.</td>
</tr>
<tr valign=top>
<td width=21%><b>DisableCommit</b></td>
<td width=79%>Declares that the object hasn't finished its work and that its transactional updates are in an inconsistent state. The object retains its state across method calls, and any attempts to commit the transaction before the object calls <b>EnableCommit</b> or <b>SetComplete</b> result in the transaction being aborted.</td>
</tr>
<tr valign=top>
<td width=21%><b>EnableCommit</b></td>
<td width=79%>Declares that the work of the object is not finished, but its transactional updates are in a consistent state. This method allows the transaction to be committed, but the object retains its state across method calls until it calls <b>SetComplete</b> or <b>SetAbort</b>, or until the transaction is complete.</td>
</tr>
<tr valign=top>
<td width=21%><b>IsCallerInRole&nbsp; </b></td>
<td width=79%>Indicates whether the direct caller of the object is in a specified role (either directly or as part of a group).</td>
</tr>
<tr valign=top>
<td width=21%><b>IsInTransaction</b></td>
<td width=79%>Indicates whether the object is executing within a transaction.</td>
</tr>
<tr valign=top>
<td width=21%><b>IsSecurityEnabled</b></td>
<td width=79%>Indicates whether security is enabled. In Microsoft Transaction Server version 1.0, security is enabled unless the object is running in a client process. </td>
</tr>
<tr valign=top>
<td width=21%><b>SetAbort</b></td>
<td width=79%>Declares that the object has completed its work and can be deactivated on return from the currently executing method; however, its transactional updates are in an inconsistent state or an unrecoverable error occurred. The transaction in which the object was executing must be aborted. </td>
</tr>
<tr valign=top>
<td width=21%><b>SetComplete</b></td>
<td width=79%>Declares that the object has completed its work and can be deactivated on return from the currently executing method; its transactional updates can be committed. When an object that is the root of a transaction calls <b>SetComplete</b>, Transaction Server attempts to commit the transaction on return from the current method.</td>
</tr>
</table><br>
<h4>IObjectControl</h4>
<p>
The <b>IObjectControl</b> interface allows you to define context-specific initialization and cleanup procedures for your Microsoft Transaction Server objects and specify whether or not the objects can be recycled. Implementing the <b>IObjectControl</b> interface is optional.</p>
<p>
If you implement the <b>IObjectControl</b> interface in a component, the Microsoft Transaction Server run-time environment automatically calls the <b>IObjectControl</b> methods on the objects at the appropriate times.</p>
<p>
When an object supports the <b>IObjectControl</b> interface, Microsoft Transaction Server calls its <b>Activate</b> method once for each time the object is activated. The <b>Activate</b> method is called before any other methods are called. You can use this method to perform any context-specific initialization an object may require.</p>
<p>
An object context is not available from the object's class factory during object construction, so context-specific initialization cannot be performed in an object constructor.</p>
<p>
Microsoft Transaction Server calls the object <b>Deactivate</b> method each time the object is deactivated. This can be the result of the object returning from a method in which it calls <b>SetComplete</b> or <b>SetAbort</b>, or the root of the object transaction causing the transaction to complete. Use the <b>Deactivate</b> method to clean up state that you initialized in the <b>Activate</b> method.</p>
<p>
After calling the <b>Deactivate</b> method, the Transaction Server run-time environment calls the <b>CanBePooled</b> method. If this method returns <b>true</b>, the deactivated object is placed in an object pool for reuse. If the <b>CanBePooled</b> method returns <b>false</b>, the object is released in the usual way and its destructor is invoked. On systems that do not support object pooling, the value returned by this method is ignored.</p>
<p>
The <b>IObjectControl</b> interface is not accessible to the clients of an object or to the object itself. Only the Microsoft Transaction Server run-time environment can invoke the <b>IObjectControl </b>methods. If a client queries for the <b>IObjectControl</b> interface, <b>QueryInterface</b> returns E_NOINTERFACE.</p>
<p>
The <b>IObjectControl</b> interface exposes the following methods.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=22%><b>Method</b></td>
<td class=label width=78%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=22%><b>Activate</b></td>
<td width=78%>Allows an object to perform context-specific initialization whenever it's activated. This method is called by the Transaction Server run-time environment before any other methods are called on the object.</td>
</tr>
<tr valign=top>
<td width=22%><b>CanBePooled</b></td>
<td width=78%>Allows an object to notify the Transaction Server run-time environment of whether it can be pooled for reuse. Return <b>true</b> to pool instances of this component, <b>false</b> otherwise.</td>
</tr>
<tr valign=top>
<td width=22%><b>Deactivate</b></td>
<td width=78%>Allows an object to perform whatever cleanup is necessary before it's recycled or destroyed. This method is called by the Transaction Server run-time environment whenever an object is deactivated.</td>
</tr>
</table><br>
<h4>ISecurityProperty</h4>
<p>
The <b>ISecurityProperty</b> interface is used to ascertain the security ID of the caller or creator of the current object. This information can then be used to further restrict access or for auditing and logging purposes. </p>
<p>
You obtain a reference to the <b>ISecurityProperty</b> interface of an object by calling <b>QueryInterface</b> on the <b>ObjectContext</b> of the object, for example:</p>
<pre><code>m_pIObjectContext-&gt;QueryInterface (IID_ISecurityProperty, void**)&amp;m_pISecurityProperty));
</code></pre>
<p>
The <b>ISecurityProperty</b> interface provides the following methods.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Method</b></td>
<td class=label width=73%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=27%><b>GetDirectCallerSID</b></td>
<td width=73%>Retrieves the security ID of the external process that called the currently executing method.</td>
</tr>
<tr valign=top>
<td width=27%><b>GetDirectCreatorSID</b></td>
<td width=73%>Retrieves the security ID of the external process that directly created the current object.</td>
</tr>
<tr valign=top>
<td width=27%><b>GetOriginalCallerSID</b></td>
<td width=73%>Retrieves the security ID of the base process that initiated the call sequence from which the current method was called.</td>
</tr>
<tr valign=top>
<td width=27%><b>GetOriginalCreatorSID</b></td>
<td width=73%>Retrieves the security ID of the base process that initiated the activity in which the current object is executing.</td>
</tr>
<tr valign=top>
<td width=27%><b>ReleaseSID</b></td>
<td width=73%>Releases the security ID returned by one of the other <b>ISecurityProperty</b> methods.</td>
</tr>
</table><br>
<h4>ISharedPropertyGroupManager</h4>
<p>
The <b>ISharedPropertyGroupManager</b> interface is used to create shared property groups and to obtain access to existing shared property groups. You can access the <b>ISharedPropertyGroupManager</b> interface by creating an instance of the <b>SharedPropertyGroupManager</b> by using either <b>IObjectContext::CreateInstance</b> or <b>CoCreateInstance</b>.</p>
<p>
The Shared Property Manager is a resource dispenser that you can use to share state among multiple objects within a server process. You cannot use global variables in a distributed environment because of concurrency and name collision issues. The Shared Property Manager eliminates name-collisions by providing shared property groups, which establish unique name spaces for the shared properties they contain. The Shared Property Manager also implements locks and semaphores to protect shared properties from simultaneous access, which could result in lost updates and leave properties in an unpredictable state.</p>
<p>
Shared properties can be shared only by objects running in the same process. If you want instances of different components to share properties, you have to install the components in the same Transaction Server package. Because there is a risk that administrators will move components from one package to another, it's safest to limit the use of a shared property group to instances of components that are defined in the same DLL. </p>
<p>
It's also important for components sharing properties to have the same activation attribute. If two components in the same package have different activation attributes, they generally won't be able to share properties. For example, if one component is configured to run in a client process and the other is configured to run in a server process, their objects will usually run in different processes, even though they're in the same package.</p>
<p>
You should always instantiate the SharedPropertyGroupManager, SharedPropertyGroup, and SharedProperty objects from Transaction Server objects rather than from a base client. If a base client creates shared property groups and properties, the shared properties are inside the base-client process, not in a server process. This means Transaction Server objects cannot share the properties unless the objects, too, are running in the client process (which is generally not a good idea).</p>
<p>
When you set the isolation mode to LockMethod, the Shared Property Manager requires access to the ObjectContext of the calling object. You cannot use this isolation mode to create a shared property group from within the constructor of an object or from a non-Transaction Server object because ObjectContext isn't available during object construction and a non-Transaction Server object doesn't have an ObjectContext.</p>
<p>
The <b>ISharedPropertyGroupManager</b> interface exposes the following methods.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=28%><b>Method</b></td>
<td class=label width=72%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=28%><b>CreatePropertyGroup</b></td>
<td width=72%>Creates a new SharedPropertyGroup with a string identifier. If a group with the specified name already exists, <b>CreatePropertyGroup</b> returns a reference to the existing group.</td>
</tr>
<tr valign=top>
<td width=28%><b>get_Group</b></td>
<td width=72%>Returns a reference to an existing shared property group, given a string by which it can be identified.</td>
</tr>
<tr valign=top>
<td width=28%><b>get__NewEnum</b></td>
<td width=72%>Returns a reference to an enumerator that steps through a list of all shared property groups in a given process.</td>
</tr>
</table><br>
<h4>ISharedPropertyGroup</h4>
<p>
The <b>ISharedPropertyGroup</b> interface is used to create and access the shared properties in a shared property group.</p>
<p>
You can access the <b>ISharedPropertyGroup</b> interface by creating a SharedPropertyGroup object with the<b> ISharedPropertyGroupManager::CreatePropertyGroup</b> method.</p>
<p>
As with any COM object, you must release a SharedPropertyGroup object when you have finished using it.</p>
<p>
The <b>ISharedPropertyGroup</b> interface exposes the following methods.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=32%><b>Method</b></td>
<td class=label width=68%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=32%><b>CreateProperty</b></td>
<td width=68%>Creates a new shared property identified by a string unique within its property group.</td>
</tr>
<tr valign=top>
<td width=32%><b>CreatePropertyByPosition</b></td>
<td width=68%>Creates a new shared property identified by a numeric index within its property group.</td>
</tr>
<tr valign=top>
<td width=32%><b>get_Property&nbsp;&nbsp;&nbsp; </b></td>
<td width=68%>Returns a reference to a shared property, given the string name by which the property is identified.</td>
</tr>
<tr valign=top>
<td width=32%><b>get_PropertyByPosition&nbsp;&nbsp;&nbsp; </b></td>
<td width=68%>Returns a reference to a shared property, given its numeric index in the shared property group.</td>
</tr>
</table><br>
<h4>ISharedProperty</h4>
<p>
The <b>ISharedProperty</b> interface is used to set or retrieve the value of a shared property. A shared property can contain any data type that can be represented by a variant. You can access the <b>ISharedProperty</b> interface by creating a SharedProperty object with the <b>ISharedPropertyGroup::CreateProperty</b> method or the <b>ISharedPropertyGroup::CreatePropertyByPosition</b> method.</p>
<p>
A SharedProperty object can be created or accessed only from within a SharedPropertyGroup. As with any COM object, you must release a SharedProperty object when you have finished using it.</p>
<p>
The <b>ISharedProperty</b> interface exposes the following methods:
<ul type=disc>
<li>
<b>get_Value </b>retrieves the value of a shared property.<br><br></li>
<li>
<b>put_Value</b> sets the value of a shared property. </li>
</ul>
<h4>ITransactionContextEx</h4>
<p>
The <b>ITransactionContextEx</b> interface is used by a base client to compose the work of one or more Microsoft Transaction Server objects into an atomic transaction and to commit or abort the transaction. You use a TransactionContextEx object to scope a transaction from a base client. You begin the transaction by instantiating a TransactionContextEx object, and you end the transaction by calling <b>Commit</b> or <b>Abort</b> on it. The base client itself never executes within the transaction.</p>
<p>
The TransactionContextEx component is a standard Transaction Server component. Its transaction attribute is set to <b>Requires a new transaction</b>, so it is always the root of a transaction. When a base client instantiates an object by using the <b>ITransactionContextEx::CreateInstance</b> method, the new object and its related elements will participate in the transaction of the TransactionContextEx object unless the transaction attribute of the object is set to <b>Requires a new transaction</b> or <b>Does not support transactions</b>.</p>
<p>
To write a TransactionContextEx component, create a component that implements the methods <b>Commit</b>, <b>Abort</b>, and <b>CreateInstance</b>, and set the transaction attribute of the component to <b>Requires a new transaction</b>. The three methods would call <b>GetObjectContext</b> and invoke the <b>SetComplete</b>, <b>SetAbort</b>, and <b>CreateInstance</b> methods of the ObjectContext object.</p>
<p>
Before you use TransactionContextEx to compose the work of existing components in a transaction, consider implementing a separate component that not only composes but encapsulates the work into a reusable unit. This new component would not only serve the needs of the current base client, but other clients could also use it. </p>
<p>
In one approach, the base client instantiates a TransactionContextEx object, calls the <b>CreateInstance</b> method to instantiate other objects, calls various methods on those objects, and finally calls <b>Commit</b> or <b>Abort</b> on the TransactionContextEx object. </p>
<p>
In the other approach, you create a new component that requires a transaction. This new component instantiates the other objects using the <b>CreateInstance</b> method of the ObjectContext of the object, calls the relevant methods on those other objects, and then calls <b>SetComplete</b> or <b>SetAbort</b> on its ObjectContext when it's done. Using this approach, the base client only needs to instantiate this one object, and invoke one method on it; the object does the rest of the work. When other clients require the same functionality, they can reuse the new component.</p>
<p>
You obtain a reference to the <b>ITransactionContextEx</b> interface by creating a TransactionContextEx object with a call to <b>CoCreateInstance</b>. For example:</p>
<pre><code>CoCreateInstance(CLSID_TransactionContextEx, NULL, CLSCTX_INPROC, IID_ITransactionContextEx, (void**)&amp;m_pTransactionContext);
</code></pre>
<p>
The <b>ITransactionContextEx</b> interface exposes the following methods.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=23%><b>Method</b></td>
<td class=label width=77%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=23%><b>Abort</b></td>
<td width=77%>Aborts the work of all Transaction Server objects participating in the current transaction. The transaction is completed on return from this method.</td>
</tr>
<tr valign=top>
<td width=23%><b>Commit</b></td>
<td width=77%>Commits the work of all Transaction Server objects participating in the current transaction. The transaction is completed on return from this method.</td>
</tr>
<tr valign=top>
<td width=23%><b>CreateInstance</b></td>
<td width=77%>Instantiates another Transaction Server object. If the component that provides the object is configured to support or require a transaction, then the new object runs under the transaction of the TransactionContextEx object.</td>
</tr>
</table><br>
<h3>Building Clients</h3>
<p>
Clients provide the first tier to your application; they are the only part that the client sees. There are three widely available choices for communicating with clients:
<ul type=disc>
<li>
<b>Remote automation</b>. Allows 16-bit Windows 3.<i>x</i> applications to access components.<br><br></li>
<li>
<b>HTTP</b>. Requires no client component registration and is the most flexible because clients are simply browsers and are therefore completely cross-platform. You need server software (IIS version 3.0). HTTP is not an easy language to develop a complex user interface in. It is also difficult to pass formatted data, such as result sets, in HTTP.<br><br></li>
<li>
<b>DCOM</b>. Allows for full COM functionality with no special code or software; the best choice for intranets. DCOM is supported only by Windows&nbsp;NT version 4.0 and Windows&nbsp;95. <br><br></li>
<li>
<b>Custom transport</b>. May be required to support legacy clients. Remote Automation is actually a custom transport mechanism. </li>
</ul>
<h3>Deploying Clients</h3>
<p>
This section describes how Transaction Server components are instantiated from a client computer and provides configuration information for client computers to instantiate server components. This section also explores several methods and tools available to configure client computers running Windows&nbsp;NT and Windows-based operating systems.</p>
<p>
To deploy clients in a distributed system, you must provide a model for using objects on different computers. Some applications are inherently distributed, such as multiuser games and discussion forums. Others are distributed because at least two of their components run on different computers. Examples include messaging, workflow, and groupware applications.</p>
<p>
With Microsoft Transaction Server, you can distribute application components to the locations that make the most sense for your users and application while also considering&nbsp; optimal network performance and computer resource usage. After the Transaction Server components are distributed to physical locations, you can configure computers so that they can use the components they need.</p>
<p>
At minimum, a Transaction Server component must conform to the COM specification for a 32-bit in-process DLL server. It must also have cross-process marshaling support. Therefore, if it is a dispatch or dual interface component, then it must describe all of its interfaces in a type library and use automation marshaling support. If it is a custom interface, then it must provide a proxy/stub DLL that uses fully interpreted standard marshaling. To take advantage of&nbsp; the full Transaction Server feature set, components should also implement Transaction Server APIs.</p>
<p>
After components have been distributed to Transaction Server servers as needed (for more information, see the product documentation), they are ready to be used by clients. Sometimes these clients (called base clients) are installed on the same server, but more often than not, they are on remote machines. These remote clients need to use some communication mechanism to invoke the services of the Transaction Server components. There are four primary methods of doing this:
<ul type=disc>
<li>
Distributed Component Object Model (DCOM)<br><br></li>
<li>
Hyper Text Transport Protocol (HTTP) to Internet Information Server (IIS)<br><br></li>
<li>
Visual&nbsp;Basic Remote Automation (RA)<br><br></li>
<li>
Custom transport mechanisms based on remote procedure calls (RPC), Windows Sockets, and so on.</li>
</ul>
<p>
DCOM is currently available on Windows&nbsp;NT 4.0 Server and Workstation, Windows&nbsp;95, Solaris, and should be available on most major platforms in the near future. DCOM will soon encompass HTTP, but for now, HTTP must be treated as a separate entity. Since HTTP currently requires IIS 3.0 with Active Server Pages or a custom ISAPI component to access components, the real base client is IIS. IIS then uses DCOM to communicate with Transaction Server components. Remote Automation and custom transport mechanisms may be necessary to support legacy platforms.</p>
<p>
All of these mechanisms require some form of client configuration. We will discuss configuring clients for DCOM and Remote Automation. </p>
<p>
When you install a component in a package, Transaction Server edits the registry to map a component's class identifier to an absolute server location. Before a component can execute in the Transaction Server run-time environment, it must be registered.</p>
<p>
Transaction Server uses the registry to hold configuration information. For a client computer to instantiate objects on a remote (server) computer, its registry must have the following entries:</p>
<p>
Application identifier (APPID)</p>
<p>
This key has all the Distributed COM-specific configuration information for the component. An example of this entry is:</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; AppID\
 &nbsp;&nbsp;&nbsp;&nbsp; {93618C8D-3E39-11D0-B964-0080C7394688}</code></pre>
<p>
Class identifier (CLSID)</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {93618C8D-3E39-11D0-B964-0080C7394688}
</code></pre>
<p>
Interface identifier (IID)</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {2E93DA21-8DA6-11CF-BE4D-00AA00A2FA25}
</code></pre>
<p>
Proxy/stub CLSID</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {2E93DA21-8DA6-11CF-BE4D-00AA00A2FA25}\ProxyStub32
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {2E93DA21-8DA6-11CF-BE4D-00AA00A2FA25}
</code></pre>
<p>
Components that rely on standard automation marshaling also require a type-library key. A type library interprets functions and parameters so that they can be properly marshaled.</p>
<p class=dt>
Type library identifier (Typelib)</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; TypeLib\
 &nbsp;&nbsp;&nbsp;&nbsp; {93618C92-3E39-11D0-B964-0080C7394688}
HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; TypeLib\{93618C92-3E39-11D0-B964-0080C7394688}
</code></pre>
<p>
If you use Transaction Server Explorer to configure client computers, Transaction Server automatically configures the registry on the client computer with these entries. If your client computer(s) does not have Transaction Server installed, you must use other tools to configure the client registry or configure it manually. </p>
<p>
There are three tools to configure client computers:
<ul type=disc>
<li>
Transaction Server Explorer<br><br></li>
<li>
Distributed COM (DCOM)<br><br></li>
<li>
Remote Automation</li>
</ul>
<p>
The following table indicates which client configuration methods are supported for client computers running Windows&nbsp;NT and Windows-based operating systems.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=43%><b>Operating system on client computer</b></td>
<td class=label width=18%><b>Transaction Server Explorer</b></td>
<td class=label width=16%><b>DCOM</b></td>
<td class=label width=23%><b>Remote Automation</b></td>
</tr>
<tr valign=top>
<td width=43%>Microsoft Windows&nbsp;NT Server</td>
<td width=18%></td>
<td width=16%></td>
<td width=23%></td>
</tr>
<tr valign=top>
<td width=43%>&nbsp;&nbsp;&nbsp;Version 4.0</td>
<td width=18%><font face="Symbol">·</font></td>
<td width=16%><font face="Symbol">·</font></td>
<td width=23%><font face="Symbol">·</font></td>
</tr>
<tr valign=top>
<td width=43%>&nbsp;&nbsp;&nbsp;Version 3.51</td>
<td width=18%></td>
<td width=16%></td>
<td width=23%><font face="Symbol">·</font></td>
</tr>
<tr valign=top>
<td width=43%>Microsoft Windows&nbsp;NT Workstation</td>
<td width=18%></td>
<td width=16%></td>
<td width=23%></td>
</tr>
<tr valign=top>
<td width=43%>&nbsp;&nbsp;&nbsp;Version 4.0</td>
<td width=18%></td>
<td width=16%><font face="Symbol">·</font></td>
<td width=23%><font face="Symbol">·</font></td>
</tr>
<tr valign=top>
<td width=43%>&nbsp;&nbsp;&nbsp;Version 3.51</td>
<td width=18%></td>
<td width=16%></td>
<td width=23%><font face="Symbol">·</font></td>
</tr>
<tr valign=top>
<td width=43%>Microsoft Windows&nbsp;95</td>
<td width=18%></td>
<td width=16%><font face="Symbol">·</font></td>
<td width=23%><font face="Symbol">·</font></td>
</tr>
<tr valign=top>
<td width=43%>Microsoft Windows for Workgroups 3.11</td>
<td width=18%></td>
<td width=16%></td>
<td width=23%><font face="Symbol">·</font></td>
</tr>
<tr valign=top>
<td width=43%>Microsoft Windows 3.<i>x</i></td>
<td width=18%></td>
<td width=16%></td>
<td width=23%><font face="Symbol">·</font></td>
</tr>
</table><br>
<h4>Client Configuration Tools</h4>
<p>
You can use other tools to configure client computers.</p>
<p>
<b>Clireg16.exe and Clireg32.exe</b></p>
<p>
Use these 16-bit and 32-bit client registration files to register a component on a client computer for remote execution. This utility ships with many Microsoft enterprise development tools and uses Visual&nbsp;Basic registration files (.vbr) to register them. Visual&nbsp;Basic produces these files when it builds a component, but other languages may require that they be created by hand. The Client Registration utility can be used to optionally register a type library (.tlb) and set additional component options. </p>
<p>
The syntax for the Client Registration utility is:</p>
<pre><code><b>CLIREG</b>[<b>32</b> | <b>16</b>] 
<i>vbrfile</i> <b>-s</b> <i>server_name</i>  | 
<b>-p</b> <i>network_protocol</i>  | 
<b>-a</b> <i>authentication_level</i>  | 
<b>-t</b> <i>typelib_file</i>  | 
<b>-u</b> | <b>-d</b> | <b>-q </b> | <b>-l</b>  | <b>-nologo</b>  | [<b>-h</b>|<b>?</b>]
</code></pre>
<p>
If you create a Setup program using the Visual&nbsp;Basic Setup Wizard, this utility is automatically included in Setup.lst. When you run the Setup program, it automatically registers the component. For more information about this utility and using the Setup Wizard, see the Microsoft Visual&nbsp;Basic documentation.</p>
<p>
Starting with Visual&nbsp;Basic version 5.0, this utility can be used to configure components for either Remote Automation or DCOM. Previous versions could only configure for Remote Automation. </p>
<p>
<b>Regsvr.exe and Regsvr32.exe</b></p>
<p>
You can use the Regsvr.exe and Regsvr32.exe utilities to manually register and unregister components. </p>
<p>
Regsvr32.exe is part of the Transaction Server installation and is located in the Mtx folder. It can only be used on in-process servers. To use this tool to register a component on a client, the component must be installed on the client. Regsvr32.exe is useful for registering the proxy/stub component. The proxy/stub component provides marshaling support, is implemented as an in-process DLL server, must be installed on the client, and must be registered.</p>
<p>
The syntax for the Regsvr.exe utility is:</p>
<p>
<b>REGSVR</b>[<b>32</b>]&nbsp; [<b>-u</b>] <i>component_name</i>  </p>
<p>
<b>Oleview</b></p>
<p>
The Oleview utility can:
<ul type=disc>
<li>
View the registry entries on each component.<br><br></li>
<li>
Configure DCOM components, including activation and security settings.<br><br></li>
<li>
Enable and disable DCOM.<br><br></li>
<li>
Test a component.<br><br></li>
<li>
Activate components locally and remotely. (This is a great feature for testing a distributed configuration of Transaction Server components.)<br><br></li>
<li>
View the contents of the type library.<br><br></li>
<li>
View methods, properties, and events.</li>
</ul>
<p>
Oleview requires either Windows&nbsp;95 or Windows&nbsp;NT 4.0 and either Internet Explorer version 3.0 or the ActiveX SDK. It is currently available on http://www.microsoft.com/oledev. Oleview allows registration from the user interface only. This is not very useful when providing an automatic client registration but can be handy when troubleshooting.</p>
<p>
<b>DCOM Configuration Tool</b></p>
<p>
You can use the DCOM configuration tool (Dcomcnfg.exe) to view and edit properties for DCOM components as well as to:
<ul type=disc>
<li>
Enable DCOM.<br><br></li>
<li>
Activate and specify where the component runs.<br><br></li>
<li>
Identify which user account can launch, access, and configure this component.</li>
</ul>
<p>
Dcomenfg.exe allows registration from the user interface only. This is not very useful when providing an automatic client registration but can be handy when troubleshooting.</p>
<p>
<b>Remote Automation Connection Manager</b></p>
<p>
The Remote Automation Connection Manger ships with Visual&nbsp;Basic and several of the other enterprise development tools. It can be used to view and edit properties for DCOM and Remote Automation components and to:
<ul type=disc>
<li>
Enable DCOM or Remote Automation.<br><br></li>
<li>
Activate and specify where the component runs.<br><br></li>
<li>
Define custom access permissions for Remote Automation components.</li>
</ul>
<p>
The Remote Automation Connection Manager allows registration from the user interface only. This is not very useful when providing an automatic client registration but can be handy when troubleshooting.</p>
<p>
<b>Registry Editor</b></p>
<p>
Use the Registry Editor (Regedit) to manually edit settings in the system registry. Use this tool carefully. It is easy to introduce an error in the registry that could cause the computer to become unstable. You can use this tool to import registry entries from a registry file (.reg) or to create a registry file by exporting entries. </p>
<p>
You can use any text editor to edit the registration files (.reg) and Visual&nbsp;Basic registration files (.vbr).</p>
<h3>Using DCOM</h3>
<p>
If Microsoft Transaction Server is not installed on the client computer but DCOM is, you can still instantiate a Transaction Server object. </p>
<p>
<b>Platforms. </b>DCOM is currently supported for Microsoft Windows&nbsp;NT 4.0 and&nbsp; Windows&nbsp;95 platforms, and on UNIX and MVS from Software AG (http://www.sagus.com).</p>
<p>
<b>Development Tools. </b>You can use Microsoft Visual&nbsp;Basic, Microsoft Visual&nbsp;C++, Microsoft Visual&nbsp;J++, or any other language that can build a COM component. </p>
<p>
<b>Client Computer Requirements.</b></p>
<p>
For marshaling components:
<ul type=disc>
<li>
For a custom interface, the proxy/stub component is needed. The proxy/stub component must also be registered.<br><br></li>
<li>
For dual interfaces that use early binding, the type library for that component is required. The standard automation marshaling proxy/stub component is used, but the type library is required to interpret the data. The type library must also be registered.<br><br></li>
<li>
For dual interfaces, dispinterfaces, or <b>IDispatch</b>-derived interfaces that use late binding or ID binding, nothing is required. The <b>IDispatch</b> interface is supported by standard COM marshaling.</li>
</ul>
<p>
For Registry entries:
<ul type=disc>
<li>
The CLSID key for the component.<br><br></li>
<li>
 An IID key for all interfaces of that component.<br><br></li>
<li>
The TypeLib key, if it is required for marshaling.<br><br></li>
<li>
The proxy/stub CLSID key, if it is required for marshaling.<br><br></li>
<li>
The ProgID key of the component (optional, but mandatory for Visual&nbsp;Basic clients).<br><br></li>
<li>
The AppID key.</li>
</ul>
<p>
The following keys are required to register the type library. These keys are not required for a custom-marshaled interface. The entire key has the structure:</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; TypeLib\
 &nbsp;&nbsp;&nbsp;&nbsp; {LIBID_of_typelib}
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = human_readable_string 
HKEY_CLASSES_ROOT\
 &nbsp; TypeLib\
 &nbsp;&nbsp;&nbsp;&nbsp; {LIBID_of_typelib}\major.minor\HELPDIR 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = [helpfile_path]
HKEY_CLASSES_ROOT\
 &nbsp; TypeLib\
 &nbsp;&nbsp;&nbsp;&nbsp; {LIBID_of_typelib}\major.minor\Flags 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = typelib_flags
HKEY_CLASSES_ROOT\
 &nbsp; TypeLib\
 &nbsp;&nbsp;&nbsp;&nbsp; {LIBID_of_typelib}\major.minor\lcid\platform 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = localized_typelib_filename
</code></pre>
<p>
The following key sets up the Program Identifier (ProgID) for the component. This key is required for Visual&nbsp;Basic programs. The entire key has the structure:</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; Program_Identifier 
 &nbsp;&nbsp;&nbsp;&nbsp; Default = AppName.ObjectName
HKEY_CLASSES_ROOT\
 &nbsp; Program_Identifier\
 &nbsp;&nbsp;&nbsp;&nbsp; CLSID 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = {CLSID_of_component}
</code></pre>
<p>
The following keys set up the Class Identifier (CLSID) of the component. There are many keys, but these are the most important for MTS components. There needs to be a similar entry for the marshaling proxy/stub component for custom interfaces. The entire key has the structure:</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component} 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = human_readable_string_often_progid
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AppID = {AppID_of_component} 
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\ProgID 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = AppName.ObjectName.VersionNumber
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\VersionIndependentProgID 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = AppName.ObjectName
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\LocalServer[32] 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = filepath[/Automation]
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\InProcServer[32] 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = filepath[/Automation]
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\InProcHandler[32] 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = filepath[/Automation]
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\Programmable
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\TypeLib 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = {LIBID_of_typelib}
</code></pre>
<p>
The following key sets up the Interface Identifier (IID) for the component. There is at least one Interface key per class identifier. The entire key has the structure:</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {IID_of_interface_1} 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = InterfaceName
HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {IID_of_interface_1}\Typelib 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = {LIBID_of_typelib}
HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {IID_of_interface_1}\ProxyStubClsid[32] 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = {CLSID_of_proxy/stub}
HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {IID_of_interface_1}\NumMethods 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = number_of_methods_in_interface
HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {IID_of_interface_1}\BaseInterface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = {CLSID_of_interface_derived_from}
</code></pre>
<p>
The following keys are DCOM-specific keys:</p>
<p>
These keys fill in the AppID entries for the application. The entire key has the structure:</p>
<pre><code>HKEY_LOCAL_MACHINE\
 &nbsp; SOFTWARE\
 &nbsp;&nbsp;&nbsp;&nbsp; Classes\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AppID\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {AppID_of_component}
RemoteServerName = remote_server_name
ActivateAtStorage = activate_on_same_system_as_persistent_storage
LocalService = run_application_as_a_Win32_service
ServiceParameters = parameters_passed_to_a_LocalService_on_invocation
RunAs = run_server_as_a_given_user
LaunchPermission = ACL_for_launch_permissions
AccessPermission =&nbsp; ACL_for_access_permissions
</code></pre>
<p>
These keys set the default DCOM settings. These settings affect the whole computer. The entire key has the structure:</p>
<pre><code>HKEY_LOCAL_MACHINE\
 &nbsp; Software\
 &nbsp;&nbsp;&nbsp;&nbsp; Microsoft\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLE
EnableDCOM = value_that_sets_global_activation_policy
DefaultLaunchPermission = value_that_defines_default_ACL
DefaultAccessPermission = value_that_defines_default_access_permission_list
LegacyAuthenticationLevel = value_that_sets_default_authentication_level
LegacyImpersonationLevel = value_that_sets_default_impersonation_level
LegacyMutualAuthentication = value_that_enables_mutual_authentication
LegacySecureReferences = value_that_secures_IUnknown_methods</code></pre>
<h4>Using Remote Automation</h4>
<p>
Remote Automation (RA) allows clients to access objects on other computers. Like DCOM, RA uses remote procedure calls to communicate between client and server. However, while DCOM allows access for any COM interface across the network (across machine boundaries), RA supports only <b>IDispatch</b> interfaces (dispinterfaces and dual interfaces).</p>
<p>
Remote Automation is a precursor to Distributed COM, is not language-specific, and can be used for both 16-bit and 32-bit Windows platforms. Remote Automation ships with Microsoft Visual&nbsp;Basic 4.0 and later and Microsoft Visual&nbsp;C++ 4.2 Enterprise Edition. </p>
<p>
<b>Platforms</b>. Remote Automation is supported on Windows&nbsp;NT 4.0, Windows&nbsp;NT 3.51, Windows&nbsp;95, Windows for Workgroups 3.11, and Windows 3.1.</p>
<p>
<b>Development Tools</b>. You can use Microsoft Visual&nbsp;Basic, Microsoft Visual&nbsp;C++, Microsoft Visual&nbsp;J++ or any other language that can build a dispinterface or dual-interface component. </p>
<p>
<b>Client Computer Requirements</b>. </p>
<p>
For marshaling components:
<ul type=disc>
<li>
The type library for that component is required. The Remote Automation marshaling proxy/stub component is used and the type library is required for it to interpret data. The type library must also be registered.<br><br></li>
<li>
For dual interfaces, dispinterfaces, or <b>IDispatch</b>-derived interfaces that use late binding or ID binding, nothing is required. The <b>IDispatch</b> interface is supported by standard COM marshaling.</li>
</ul>
<p>
For Registry entries:
<ul type=disc>
<li>
The CLSID key for the component.<br><br></li>
<li>
An IID key for all interfaces of that component.<br><br></li>
<li>
The TypeLib key, if it is required for marshaling.<br><br></li>
<li>
The proxy/stub CLSID key, if it is required for marshaling.<br><br></li>
<li>
The ProgID key of the component (optional, but mandatory for Visual&nbsp;Basic clients).</li>
</ul>
<p>
The following keys are required to register the type library. These keys are not required for a custom marshaled interface. The entire key has the structure:</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; TypeLib\
 &nbsp;&nbsp;&nbsp;&nbsp; {LIBID_of_typelib}
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = human_readable_string 
HKEY_CLASSES_ROOT\
 &nbsp; TypeLib\
 &nbsp;&nbsp;&nbsp;&nbsp; {LIBID_of_typelib}\major.minor\HELPDIR 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = [helpfile_path]
HKEY_CLASSES_ROOT\
 &nbsp; TypeLib\
 &nbsp;&nbsp;&nbsp;&nbsp; {LIBID_of_typelib}\major.minor\Flags 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = typelib_flags
HKEY_CLASSES_ROOT\
 &nbsp; TypeLib\
 &nbsp;&nbsp;&nbsp;&nbsp; {LIBID_of_typelib}\major.minor\lcid\platform 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = localized_typelib_filename
</code></pre>
<p>
The following key sets up the Program Identifier (ProgID) for the component. This key is required for Visual&nbsp;Basic programs. The entire key has the structure:</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; Program_Identifier 
 &nbsp;&nbsp;&nbsp;&nbsp; Default = AppName.ObjectName
HKEY_CLASSES_ROOT\
 &nbsp; Program_Identifier\
 &nbsp;&nbsp;&nbsp;&nbsp; CLSID 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = {CLSID_of_component}
</code></pre>
<p>
The following keys set up the Class Identifier (CLSID) of the component. There are many keys, but these are the most important for MTS components. There needs to be a similar entry for the marshaling proxy/stub component for custom interfaces. The entire key has the structure:</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component} 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = human_readable_string_often_progid
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AppID = {AppID_of_component} 
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\ProgID 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = AppName.ObjectName.VersionNumber
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\VersionIndependentProgID 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = AppName.ObjectName
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\LocalServer[32] 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = filepath[/Automation]
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\InProcServer[32] 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = filepath[/Automation]
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\InProcHandler[32] 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = filepath[/Automation]
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\Programmable
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\TypeLib 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = {LIBID_of_typelib}
</code></pre>
<p>
The following key sets up the Interface Identifier (IID) for the component. There is at least one Interface key per class identifier. The entire key has the structure:</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {IID_of_interface_1} 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = InterfaceName
HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {IID_of_interface_1}\Typelib 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = {LIBID_of_typelib}
HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {IID_of_interface_1}\ProxyStubClsid[32] 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = {CLSID_of_proxy/stub}
HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {IID_of_interface_1}\NumMethods 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = number_of_methods_in_interface
HKEY_CLASSES_ROOT\
 &nbsp; Interface\
 &nbsp;&nbsp;&nbsp;&nbsp; {IID_of_interface_1}\BaseInterface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = {CLSID_of_interface_derived_from}
</code></pre>
<p>
The following keys are RA-specific keys:</p>
<pre><code>HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InprocServer32 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = "C:\WINNT\System32\autprx32.dll"
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp; {CLSID_of_component}\
 &nbsp;&nbsp;&nbsp;&nbsp; InprocServer 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = "C:\WINNT\System\autprx.dll"
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NetworkAddress
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = SampleServer
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AuthenticationLevel 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = some_RPC_auth_level
HKEY_CLASSES_ROOT\
 &nbsp; CLSID\
 &nbsp;&nbsp;&nbsp;&nbsp; {CLSID_of_component}\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProtocolSequence 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default = some_network_protocol
</code></pre>
</BODY>
</HTML>
