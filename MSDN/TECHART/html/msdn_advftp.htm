<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Advanced FTP, or Teaching Fido To Phetch</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_advftp"></a></sup>Advanced FTP, or Teaching <u>F</u>ido <u>T</u>o <u>P</u>hetch</h1>
<p>
Robert Coleridge<br>
Microsoft Developer Network Technology Group</p>
<p>
July 29, 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5008">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the AdvFTP sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This technical article examines the usage of the File Transfer Protocol (FTP) functions contained in the Win32® Internet (WinInet) Software Development Kit (SDK). In order to use these API functions you will need the WinInet dynamic-link libraries (DLLs), which are included with the ActiveX™ SDK, or the newest release of the Win32 SDK. To compile the AdvFTP sample application you will also need Microsoft® Visual C++® version 4.2 or higher. Along with the WinInet FTP functions, this article also touches briefly on Microsoft Foundation Class Library (MFC) multithreading and Win32 synchronization.</p>
<p>
This article demonstrates an MFC-based, multithreaded Internet file transfer program that will retrieve files from a remote FTP server in an asynchronous fashion. Making the program asynchronous dictates that we should be using a multithreading approach. The reason I say "should" is that, although it is quite <i>possible</i> to write a sample application as a single-threaded program, a multithreaded program is far more <i>functional</i> for what we want to accomplish.</p>
<p>
It is assumed that the reader has some working knowledge of the MFC and the Win32 thread and synchronization functions. Although some of these concepts are beyond the scope of this article, I will discuss them briefly when I use them. For further details on any of these functions, see the Win32 SDK documentation (now called the Platform SDK on the MSDN Library) for a fuller explanation. The AdvFTP sample accompanying this article was compiled and tested with the Microsoft Visual C++ compiler version 4.2 under Windows® 95.</p>
<p>
This article examines the following functions: <b>InternetConnect</b>, <b>FtpFindFirstFile</b>, <b>FtpFindNextFile</b>, <b>FtpGetFile</b>, <b>FtpSetCurrentDirectory</b>, <b>FtpGetCurrentDirectory</b>, <b>AfxBeginThread</b>, <b>SetEvent</b>, <b>ResetEvent</b>, <b>CreateEvent</b>, and <b>WaitForSingleObject</b>.</p>
<h2>Introduction</h2>
<p>
With the growth in popularity of the Internet comes a dramatic increase in the availability of information. This wealth of information is useless to us, however, unless we have the means to access it. Fortunately for the majority of programmers, Microsoft has provided an easy way to design and develop programs that can access the information on the Internet. This article examines how to accomplish various Internet FTP functions. Included with this article is a sample application (AdvFTP) that demonstrates these functions.</p>
<p>
This article shows you, in a step-by-step fashion, how to connect to and disconnect from an FTP server. Once connected to the FTP server, you will learn how to enumerate or read that server's directory. Given a list of files in a particular directory, you will be able to retrieve selected files from an FTP server. Although the sample application does not write any files to the server, this article looks at how to do so. Because the files we want may be in different directories on the server, you will also learn how to move around the server's directory tree. Once you have gone through the examples in this article, you will be able to build your own Internet FTP download program.</p>
<h2>Overview of Internet API FTP Functions</h2>
<p>
Given that FTP stands for "File Transfer Protocol," the FTP-related application programming interface (API) functions break down into two general file categories: functions to manipulate directories (file containers) and functions to manipulate the files themselves.</p>
<h3>Functions for Manipulating FTP Directories</h3>
<p>
Following are the four basic directory manipulation functions:
<ul type=disc>
<li>
<b>FtpCreateDirectory</b>—make a directory)<br><br></li>
<li>
<b>FtpRemoveDirectory</b>—delete a directory<br><br></li>
<li>
<b>FtpSetCurrentDirectory</b>—go to a particular directory<br><br></li>
<li>
<b>FtpGetCurrentDirectory</b>—find out where you are in a directory tree</li>
</ul>
<p>
These functions have very simple interfaces. All but the last (<b>FtpGetCurrentDirectory</b>) take two parameters: a handle to a previously started FTP session and a pointer to a string specifying the directory to manipulate. The <b>FtpGetCurrentDirectory</b> function uses one more parameter to specify the size of the buffer that will receive the name of the current directory.</p>
<p>
Two functions are used to enumerate or read an FTP directory: <b>FtpFindFirstFile</b> and <b>FtpFindNextFile</b>. They are identical in functional to the Win32® <b>FindFirstFile</b> and <b>FindNextFile</b> functions.</p>
<h3>Functions for Manipulating FTP Files</h3>
<p>
The Win32® Internet (WinInet) Software Development Kit (SDK) allows you to manipulate remote FTP files in a fashion that is similar to manipulating files locally. There are functions to read and write files (<b>FtpReadFile</b> and <b>FtpWriteFile</b>), to open files (<b>FtpOpenFile</b>), rename or delete files (<b>FtpRenameFile</b>, <b>FtpDeleteFile</b>), and so on. As you can see, most of the work you would do on local files you can also do on remote FTP files.</p>
<p>
The WinInet SDK also supplies us with two functions that encapsulate a very common programming task—that of retrieving or transferring an entire file. The "standard" methodology for transferring entire files is to repetitively read segments of the file and write them to their new destination until the entire file has been read. The WinInet SDK has greatly simplified this task with <b>FtpGetFile</b> and <b>FtpPutFile</b>. These two functions encapsulate this "repetitive loop" for you. All you need to transfer a file is to supply two file specifications: the input location and the output location. With these two parameters, along with a few optional flags, the functions will accomplish the file transfer for you.</p>
<h3>Issues Involving the FTP Functions</h3>
<p>
When manipulating files locally the programmer or user usually has complete control over the process. This, however, is not the case when manipulating files remotely. There are a number of things that can affect the success of the remote transfer, such as poor communications lines; communications lines that are slow due to excessive traffic, and so on.</p>
<h4>Synchronous vs. Asynchronous Communications</h4>
<p>
In communications there are two methods of information exchange: synchronous and asynchronous. Synchronous communication can be compared to a radio transmission, where one person speaks at a time, while asynchronous communication is like using a telephone, where the parties can communicate simultaneously. Each method has its advantages and disadvantages. Synchronous communication, on the one hand, is very easy to implement but may take longer to transfer information and does not guarantee success. Asynchronous communication, on the other hand, is not as easy to implement, but can usually transfer information more quickly and with a higher degree of success. For the purpose of this article I will focus on the asynchronous methodology.</p>
<h4>Single-threaded vs. Multithreaded</h4>
<p>
In any two-way communication it takes time to process what the other party said and respond. This slows down the conversation. Most people communicate and process what they are hearing in a linear fashion. That is, first they talk, then they listen, then they analyze what they heard, then they talk, and so on. This could be called doing a single task at a time, or a single-threaded process, because only one task or "thread" is happening at any one time. For people this works quite well, since it can be rude to talk while another person is talking. With computers, however, this form of communicating is inefficient. There is no real need for one computer to wait for another computer to respond before acting, because today's computers are powerful enough to do more than one task at a time. This ability is called <i>multitasking</i> or <i>multithreading</i>. It is this ability to perform multiple threads of work simultaneously that we will use to do asynchronous FTP.</p>
<p>
With the use of the Win32 SDK and the WinInet SDK this type of scenario is quite easily accomplished, inasmuch as both are designed for this and allow us to create programs that take advantage of this capability.</p>
<h2>Some FTP Functions from a Synchronous Perspective: An In-depth Examination</h2>
<p>
To avoid confusion about some of the complexities of asynchronous processing, this article first examines the FTP functions from a synchronous perspective. Once you have seen how to use each function, I will put them together in a pseudo-program sample. I say <i>pseudo</i> because the sample code is not the best of examples, inasmuch as the FTP functions should really be used asynchronously. The pseudo-sample is given merely to demonstrate the flow of control necessary to use the functions. The section following this one examines rewriting them for asynchronous processing.</p>
<h3>How to Connect to a Remote FTP Server</h3>
<h4>InternetOpen</h4>
<p>
In order to use the WinInet API you must use the <b>InternetOpen</b> function to obtain a handle to a connection to the Internet. The handle returned to the program is needed to do any further work with the SDK.</p>
<p>
For this function to work, you must have an Internet agent or program that will handle the work for you. In this case I will be using the Microsoft Internet Explorer. You will also need to specify the type of access you want and a few optional flags. The sample program uses a proxy server, so you will need to specify the proxy server itself. The function will then return a handle to an Internet session. When you are finished with the connection, you must close it by passing the handle to the <b>InternetCloseHandle</b> function. For example:</p>
<pre><code>HINTERNET hInternetSession; 
hInternetSession = InternetOpen(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Microsoft Internet Explorer",&nbsp;&nbsp; // agent
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_OPEN_TYPE_PROXY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // access
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ftp-gw",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // proxy server
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // defaults
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // synchronous
.
.
.
//Do some processing.
.
.
.
// Close connection.
InternetCloseHandle(hInternetSession);
</code></pre>
<p>
This example connects, via the Internet agent (in this case Microsoft Internet Explorer), to the Internet and returns you a handle to the connection, if successful. By specifying the parameter <i>INTERNET_OPEN_TYPE_PROXY</i> and <i>ftp-gw</i> you have requested that the agent use a proxy server. With one simple call you now have a connection to the Internet. With the returned handle <b>hInternetSession</b> used as a parameter to the other functions, you can start accessing Internet information.</p>
<h4>InternetConnect</h4>
<p>
You use the <b>InternetConnect</b> function to make a connection to a specified FTP server. This function can only be used after a successful call to <b>InternetOpen</b>. The code for this function might look like this:</p>
<pre><code>// Make connection to ftp server.
HINTERNET hFTPSession;
hFTPSession = ::InternetConnect(
 &nbsp;&nbsp;&nbsp;&nbsp; hInternetSession,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle from a previous
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // call to InternetOpen.
 &nbsp;&nbsp;&nbsp;&nbsp; "ftp://ftp.microsoft.com",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Server we wish to connect to.
 &nbsp;&nbsp;&nbsp;&nbsp; INTERNET_INVALID_PORT_NUMBER,&nbsp;&nbsp;&nbsp; // Use appropriate port.
 &nbsp;&nbsp;&nbsp;&nbsp; "anonymous",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Username, can be NULL.
 &nbsp;&nbsp;&nbsp;&nbsp; "robcol@homesite.com",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Password, can be NULL.
 &nbsp;&nbsp;&nbsp;&nbsp; INTERNET_SERVICE_FTP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flag to use FTP services.
 &nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags (see SDK docs).
 &nbsp;&nbsp;&nbsp;&nbsp; (DWORD)0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SEE DISCUSSION ON THIS PARAM.
.
.
.
// Do some processing.
.
.
.
// Close connection.
InternetCloseHandle(hFTPSession);
</code></pre>
<p>
Upon successful completion of this call we now have a handle to the specified FTP server. This is the handle we will use to access the server's files and directories. Even though the function is straightforward to use, several parameters require explanation:
<ul type=disc>
<li>
The first parameter is a handle obtained from a call to the <b>InternetOpen</b> function. <br><br></li>
<li>
The second parameter is self-explanatory. It is simply the name of the FTP site we want to connect to.<br><br></li>
<li>
The third parameter, <i>INTERNET_INVALID_PORT_NUMBER</i>, is actually a flag to the function telling it to use whatever port is appropriate for the required protocol.<br><br></li>
<li>
The fourth parameter is the <i>username</i> used to log on to the FTP server. If this parameter is NULL, the function uses an appropriate default. For the FTP protocol, the default is "anonymous". <br><br></li>
<li>
The fifth parameter is the <i>password</i> used to log on to the FTP server. If both Password and Username are NULL, the function uses the default "anonymous password". In the case of FTP, the default anonymous password is the user's e-mail name. If Password is NULL (or an empty string), but Username is not NULL, the function uses a blank password. The following table describes the behavior for the four possible settings of Username and Password.</li>
</ul>
<p>
<b>Table 1. Settings of Username and Password Parameters</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td width=25%><b><br>
Username</b></td>
<td width=25%><b><br>
Password</b></td>
<td width=25%><b>Username sent to FTP server</b></td>
<td width=25%><b>Password sent to FTP server</b></td>
</tr>
<tr valign=top>
<td width=25%>NULL or ""</td>
<td width=25%>NULL or ""</td>
<td width=25%>"anonymous"</td>
<td width=25%>User's e-mail name</td>
</tr>
<tr valign=top>
<td width=25%>Non-NULL string</td>
<td width=25%>NULL or ""</td>
<td width=25%>Username</td>
<td width=25%>""</td>
</tr>
<tr valign=top>
<td width=25%>NULL</td>
<td width=25%>Non-NULL string</td>
<td width=25%>ERROR</td>
<td width=25%>ERROR</td>
</tr>
<tr valign=top>
<td width=25%>Non-NULL string</td>
<td width=25%>Non-NULL string</td>
<td width=25%>Username</td>
<td width=25%>Password</td>
</tr>
</table><br>
<ul type=disc>
<li>
The sixth parameter tells the API to use FTP services.<br><br></li>
<li>
The seventh parameter is explained fully in the SDK documentation.<br><br></li>
<li>
The eighth parameter is a user-defined value that is passed on to the <b>callback</b> function if asynchronous processing was specified during the <b>InternetOpen</b> call. Please note that this value CANNOT be zero if asynchronous processing is required. Setting this value to zero effectively turns off asynchronous processing.</li>
</ul>
<h3>How to Enumerate or Read an FTP Server's Directory</h3>
<h4>FtpFindFirstFile and FtpFindNextFile</h4>
<p>
Now that you have seen how to connect to the Internet (with the <b>InternetOpen</b> function) and connect to an FTP server (with the <b>InternetConnect</b> function), you need to know the functions required to enumerate that server's directories and files. These two functions are usually used in sequence. That is, in order to use <b>FtpFindNextFile</b> you must first have called <b>FtpFindFirstFile</b>. If the file you are trying to find is not ambiguous, however, you just need to use <b>FtpFindFirstFile</b>. The code to enumerate all .ZIP files might look like the following;</p>
<pre><code>// Find first .ZIP file.
HINTERNET hFileConnection;
WIN32_FIND_DATA sWFD; 
BOOL bResult = TRUE;

hFileConnection = ::FtpFindFirstFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFTPSession,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "*.ZIP",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;sWFD,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);
if (hFileConnection != (HINTERNET)NULL)
 &nbsp; {
 &nbsp; while (bResult)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; //Do something with file (sWFD.cFileName).
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; bResult = ::InternetFindNextFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFileConnection,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;sWFD);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }

// Close connection
InternetCloseHandle(hFileConnection);
</code></pre>
<p>
Note that in this example I introduce the new data type <b>WIN32_FIND_DATA</b>. This is not part of the WinInet SDK, but rather of the standard Win32 SDK. The example above does several things: First, it makes the initial call to <b>FtpFindFirstFile</b>, then the code goes into a loop, processing the returned filespec and getting the next matching file. The loop exits when there are no more files matching the original specification passed in via the <b>FtpFindFirstFile</b> call.</p>
<h3>How to Retrieve Selected Files from an FTP Server</h3>
<h4>FtpGetFile</h4>
<p>
<b>FtpGetFile</b> is one of the easiest functions to use in the WinInet SDK with regard to the sample program. An example might look like:</p>
<pre><code>BOOL bResult;
bResult = ::FtpGetFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFTPSession,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle from an InternetConnect call
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ftp://ftp.mysite.com/reference.doc",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "c:\notes\reference.doc",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE_ATTRIBUTE_NORMAL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTP_TRANSFER_TYPE_BINARY,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);
</code></pre>
<p>
This sample piece of code retrieves the <b>reference.doc</b> file from the <b>mysite.com</b> FTP server and stores it in the <b>C:\notes</b> subdirectory on the local machine. The <b>FILE_ATTRIBUTE_NORMAL</b> flag specifies that the file will have normal attributes upon creation on the local machine. The <b>FTP_TRANSFER_TYPE_BINARY</b> flag specifies that the file being transferred is to be transferred in an "as-is" state (that is, no translation of carriage returns to new lines, and so on).</p>
<h3>How to Store a File on an FTP Server</h3>
<h4>FtpPutFile</h4>
<p>
<b>FtpPutFile</b> is very easy to use. An example might look like this:</p>
<pre><code>BOOL bResult;
bResult = ::FtpGetFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFTPSession,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle from an InternetConnect call
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "c:\notes\reference.doc",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ftp://ftp.mysite.com/reference.doc",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTP_TRANSFER_TYPE_BINARY,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);
</code></pre>
<p>
This sample piece of code sends the <b>c:\notes\reference.doc</b> file to the <b>mysite.com</b> FTP server and stores it under the name of <b>reference.doc</b>. The <b>FTP_TRANSFER_TYPE_BINARY</b> flag specifies that the file being transferred is to be transferred in an "as-is" state (that is, no translation of carriage returns to new lines, and so on).</p>
<h3>How to Move Around an FTP Server's Directory Structure</h3>
<p>
The <b>FtpSetCurrentDirectory</b> and <b>FtpGetCurrentDirectory</b> functions are identical to the <b>SetCurrentDirectory</b> and <b>GetCurrentDirectory</b> Win32 API functions. All these functions do is allow the program to specify which remote directory the program will work with by default. The <b>FtpSetCurrentDirectory</b> might look like this:</p>
<pre><code>FtpSetCurrentDirectory(hFTPSession, "/bin/driver");
</code></pre>
<p>
This would change the current default directory to <b>/bin/driver</b>.</p>
<p>
The <b>FtpGetCurrentDirectory</b> function simply returns to the user the name of the current default directory. For example:</p>
<pre><code>char cBuffer[_MAX_PATH];
DWORD dwSize = _MAX_PATH;
FtpGetCurrentDirectory(hFTPSession, cBuffer, &amp;dwSize);
</code></pre>
<p>
This code retrieves the current directory and stores it in the <b>cBuffer</b> buffer. The <b>dwSize</b> variable initially contains the size of the buffer, and upon successful completion of the function call will contain the size of the returned value in <b>cBuffer</b>.</p>
<h3>Creating a Synchronous Example</h3>
<p>
Suppose that you want to connect to an FTP server called <b>ftp://ftp.infosite.com</b> and copy all of the .ZIP files from its <b>/BIN</b> subdirectory to your local hard drive and store them in your <b>C:\ZIPFILES</b> subdirectory. The sample code might look like this:</p>
<pre><code>HINTERNET hInternetSession;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle to internet connection
HINTERNET hFTPSession;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle to FTP session
HINTERNET hFileConnection;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle to file enumeration
WIN32_FIND_DATA sWFD;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // structure to hold FIND data
BOOL bResult = TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Boolean for return code
CString InputSpec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // variable to hold input spec
Cstring OutputSpec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // variable to hold output spec

hInternetSession = InternetOpen(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Microsoft Internet Explorer",&nbsp;&nbsp;&nbsp;&nbsp; // agent
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_OPEN_TYPE_PROXY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // access
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ftp-gw",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // proxy server
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // defaults
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // synchronous

// Make connection to ftp server.
hFTPSession = ::InternetConnect(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInternetSession,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle from a previous
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // call to InternetOpen.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ftp://ftp.infosite.com",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Server we want to connect to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_INVALID_PORT_NUMBER,&nbsp;&nbsp;&nbsp; // Use appropriate port.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use anonymous for username.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use e-mail name for password
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_SERVICE_FTP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flag to use FTP services
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags (see SDK docs)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Synchronous mode

// Find first .ZIP file.
hFileConnection = ::FtpFindFirstFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFTPSession,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "*.ZIP",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;sWFD,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);
if (hFileConnection != (HINTERNET)NULL)
 &nbsp; {
 &nbsp; ::FtpSetCurrentDirectory(hFTPSession, "/BIN");

 &nbsp; while (bResult)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // Create file specs.
 &nbsp;&nbsp;&nbsp;&nbsp; InputSpec = "ftp://ftp.infosite.com/BIN/";
 &nbsp;&nbsp;&nbsp;&nbsp; InputSpec = InputSpec + sWFD.cFileName;
 &nbsp;&nbsp;&nbsp;&nbsp; OutputSpec = "c:\zipfiles\";
 &nbsp;&nbsp;&nbsp;&nbsp; OutputSpec = OutputSpec + sWFD.cFileName;

 &nbsp;&nbsp;&nbsp;&nbsp; // Transfer the file.
 &nbsp;&nbsp;&nbsp;&nbsp; bResult = ::FtpGetFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFTPSession,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputSpec,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputSpec,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE_ATTRIBUTE_NORMAL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTP_TRANSFER_TYPE_BINARY,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);

 &nbsp;&nbsp;&nbsp;&nbsp; // Get next file.
 &nbsp;&nbsp;&nbsp;&nbsp; bResult = ::InternetFindNextFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFileConnection,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;sWFD);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }

// Close connections.
InternetCloseHandle(hFileConnection);
InternetCloseHandle(hFTPSession);
InternetCloseHandle(hInternetSession);
</code></pre>
<h2>Some FTP Functions from an Asynchronous Perspective: An In-depth Examination</h2>
<p>
In order to process the FTP information from an asynchronous perspective you must add two new concepts to the existing examples. First, you must have some method of telling your code to wait efficiently until certain events have occurred; and second, you must use a <i>callback</i> function.</p>
<p>
The first concept is commonly called a <i>synchronization</i> object. This can be thought of as a fancy traffic signal. It is a mechanism whereby certain events are allowed to occur while others are halted. Although there are several types of synchronization objects available, you will be using the <b>Event</b> object.</p>
<p>
The second concept, the <b>callback</b> function, is simply a function that you have informed the API it can use to "call you back" whenever it needs to notify you of something.</p>
<h3>The Event Object</h3>
<p>
The <b>Event</b> object is a very simple object to create—you simply call the <b>CreateEvent</b> Win32 API function. The function returns to the program a handle to that object. For your purposes you will be creating the simplest form of <b>Event</b> object. (For complete details on the other forms of <b>Event</b> objects see the Win32 documentation.) Creating the simplest form might look like this:</p>
<pre><code>HANDLE hEvent;

hEvent = CreateEvent(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No security descriptor.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We will reset the event ourself.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRUE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Start signaled or "green light" mode.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Nameless event.
.
.
.
//Use the event.
.
.
.
CloseHandle(hEvent);
</code></pre>
<p>
The example above created an <b>Event</b> object. (Note that when you were finished with the event you released it with the <b>CloseHandle</b> API function. This must always be done or else the program will incur resource leakage.) There are two states to an <b>Event</b> object—signaled ("green light") and non-signaled ("red light"). The <i>green light</i> or <i>signaled</i> state allows anyone else who is waiting for the object to proceed, and the <i>red light</i> or <i>non-signaled</i> state prevents anyone who is waiting for the object from proceeding.</p>
<p>
The relevant Win32 API functions are: 
<ul type=disc>
<li>
<b>CreateEvent</b> (creates the <b>Event</b> object)<br><br></li>
<li>
<b>SetEvent</b>(sets the object's state to signaled)<br><br></li>
<li>
<b>ResetEvent</b> (sets the object's state to non-signaled)<br><br></li>
<li>
<b>WaitForSingleObject</b> (efficiently pauses the code until the object is in a signaled state)</li>
</ul>
<p>
The <b>WaitForSingleObject</b> function's second parameter requires some explanation. It is the amount of time, in milliseconds, before the object becomes signaled. The constant <b>INFINITE</b> can be used to cause the function to wait forever. Use this value only when you are positive the object will become signaled eventually. An example of these functions in use (in a multithreaded application) might look like this:</p>
<pre><code>void SomeFunctionName()
 &nbsp; {
 &nbsp; HANDLE hEvent;
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; // Create the Event object.
 &nbsp; hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; // Set up Event object so we will have to wait.
 &nbsp; ResetEvent(hEvent);
 &nbsp; 
 &nbsp; // Now do something that takes time but we don't know how long.
 &nbsp; // Pass in handle to Event object so other procedure can alter it
 &nbsp; // when it is finished (this assumes the code we are calling
 &nbsp; // is running on another thread).
 &nbsp; DoSomeLengthyCalculationOnAnotherThread(hEvent);
 &nbsp; 
 &nbsp; // Now wait until other procedure is finished
 &nbsp; WaitForSingleObject(hEvent, INFINITE);
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; return;
 &nbsp; }

.
.
.
void DoSomeLengthyCalculationOnAnotherThread(HANDLE hEvent)
 &nbsp; {
 &nbsp; // Do something lengthy.
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; // Set Event object's state to a signaled state so other code can
 &nbsp; // continue.
 &nbsp; SetEvent(hEvent);

 &nbsp; // Continue work while other code continues.
 &nbsp; .
 &nbsp; .
 &nbsp; .
 &nbsp; }
</code></pre>
<h3>Monitoring Progress Through Callback Functions</h3>
<p>
What you need to do at this point is to inform the system that you want to use a <b>callback</b> routine and have it notify you when certain events occur. In order to do this you need to make several changes to how you previously used certain WinInet API functions.</p>
<h4>InternetOpen</h4>
<p>
In order to do asynchronous processing you need to supply a new value for one of the parameters (the new value appears in <b>bold type</b>):</p>
<pre><code>HINTERNET hInternetSession;
hInternetSession = InternetOpen(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Microsoft Internet Explorer",&nbsp;&nbsp; // agent
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_OPEN_TYPE_PROXY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // access
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ftp-gw",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // proxy server
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // defaults
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>INTERNET_FLAG_ASYNC</b>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // asynchronous
.
.
.
// Do some processing.
.
.
.
// Close connection.
InternetCloseHandle(hInternetSession);
</code></pre>
<p>
This example does exactly what the synchronous example did, but it now supplies the <b>INTERNET_FLAG_ASYNC</b> parameter. This flag causes the API to do all of its processing asynchronously.</p>
<h4>InternetConnect</h4>
<p>
You use the <b>InternetConnect</b> function much as discussed above, but this time you MUST supply a non-zero context value.</p>
<pre><code>// Make connection to ftp server.
HINTERNET hFTPSession;
DWORD dwContext;

<b>// set context value</b>

<b>dwContext = &amp;SharedDataStructure;&nbsp;&nbsp; // address of some data structure</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // somewhere in memory</b>


// Make connection to ftp server.
hFTPSession = ::InternetConnect(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInternetSession,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle from a previous
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // call to InternetOpen
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ftp://ftp.microsoft.com",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // server we wish to connect to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_INVALID_PORT_NUMBER,&nbsp;&nbsp;&nbsp; // use appropriate port
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "anonymous",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // username, can be NULL
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "robcol@homesite.com",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // password, can be NULL
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_SERVICE_FTP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // flag to use FTP services
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // flags (see SDK docs)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>(DWORD)dwContext</b>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SEE DISCUSSION ON THIS PARAM
.
.
.
// Do some processing.
.
.
.
// Close connection.
InternetCloseHandle(hFTPSession);
</code></pre>
<p>
The parameters are all the same the eighth one. This parameter is a user-defined value that is passed on to the <b>callback</b> function if asynchronous processing was specified during the <b>InternetOpen</b> call. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This value CANNOT be zero if asynchronous processing is required. Setting this value to zero effectively turns off asynchronous processing.</p>
<h4>InternetSetStatusCallback</h4>
<p>
This is the API function that informs the system which function you want it to call when it needs to notify you of something. This is done in a manner similar to the following:</p>
<pre><code>INTERNET_STATUS_CALLBACK dwISC;

// Set up Internet status callback.
dwISC = ::InternetSetStatusCallback(&nbsp;&nbsp; hInternetConnection, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InternetCallback); 

// If you couldn't set up callback, process error.
if (dwISC == INTERNET_INVALID_STATUS_CALLBACK)
 &nbsp; {
 &nbsp; // . . . Process error.
 &nbsp; }
</code></pre>
<p>
The two parameters are: a handle to an Internet session and the address of the <b>callback</b> function. The <b>callback</b> function must be set up with a specific syntax, as we will see in the next section.</p>
<h4>Internet API Callback Function</h4>
<p>
Because this function is critical to the concept of asynchronous processing, I am going to go into quite a bit of detail on it. The code looks like this:</p>
<pre><code>//**********************************************************************
// InternetCallback
//
// Purpose: Internet callback function used during asynchronous calls
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to Wininet
//
// Parameters:
//&nbsp;&nbsp;&nbsp; HINTERNET hInternet - Upon first entry into the callback (during
//&nbsp;&nbsp;&nbsp; the INTERNET_STATUS_HANDLE_CREATED status this value contains the
//&nbsp;&nbsp;&nbsp; handle passed in during the original call to the asynchronous Wininet
//&nbsp;&nbsp;&nbsp; API. Upon INTERNET_STATUS_HANDLE_CREATED this value contains 
//&nbsp;&nbsp;&nbsp; the return value of the asynchronous Wininet API.
//
//&nbsp;&nbsp;&nbsp; DWORD dwContext - an application-defined value associated with
//&nbsp;&nbsp;&nbsp; the callback. For this application, this is a pointer to an
//&nbsp;&nbsp;&nbsp; instance of a CAdvancedFTPDlg class (this).
//
//&nbsp;&nbsp;&nbsp; DWORD dwInternetStatus - status value (INTERNET_STATUS_*)
//
//&nbsp;&nbsp;&nbsp; LPVOID lpvStatusInformation - value returned by callback function
//&nbsp;&nbsp;&nbsp; specific to the STATUS type
//
//&nbsp;&nbsp;&nbsp; DWORD dwStatusInformationLength
//********************************************************************
void CALLBACK InternetCallback(HINTERNET hInternet,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwContext,\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwInternetStatus,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID lpvStatusInformation,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwStatusInformationLength)
 &nbsp; {
 &nbsp; LPINTERNET_ASYNC_RESULT pIar = (LPINTERNET_ASYNC_RESULT)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lpvStatusInformation);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR pStr =&nbsp; (LPSTR) (lpvStatusInformation);

 &nbsp; // Act on status code.
 &nbsp; switch(dwInternetStatus)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; // This value is selected when we are notified that the API is
 &nbsp;&nbsp;&nbsp;&nbsp; // looking up the IP address of the name contained in
 &nbsp;&nbsp;&nbsp;&nbsp; // lpvStatusInformation. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_RESOLVING_NAME:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use pStr to point to the value.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is selected when we are notified that the API has
 &nbsp;&nbsp;&nbsp;&nbsp; // successfully found the IP address of the name contained in
 &nbsp;&nbsp;&nbsp;&nbsp; // lpvStatusInformation. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_NAME_RESOLVED:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use pStr to point to the value.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is selected when we are notified that the API is
 &nbsp;&nbsp;&nbsp;&nbsp; // connecting to the socket address (SOCKADDR) pointed to by
 &nbsp;&nbsp;&nbsp;&nbsp; // lpvStatusInformation. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_CONNECTING_TO_SERVER:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use pStr to point to the value.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is selected when we are notified that the API has
 &nbsp;&nbsp;&nbsp;&nbsp; // successfully connected to the socket address (SOCKADDR)
 &nbsp;&nbsp;&nbsp;&nbsp; // pointed to by lpvStatusInformation. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_CONNECTED_TO_SERVER:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use pStr to point to the value.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is selected when we are notified that the API is
 &nbsp;&nbsp;&nbsp;&nbsp; // sending the information request to the server.
 &nbsp;&nbsp;&nbsp;&nbsp; // The lpvStatusInformation parameter is NULL. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_SENDING_REQUEST:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is selected when we are notified that the API has
 &nbsp;&nbsp;&nbsp;&nbsp; // successfully sent the information request to the server.
 &nbsp;&nbsp;&nbsp;&nbsp; // The lpvStatusInformation parameter is NULL. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_REQUEST_SENT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is selected when we are notified that the API is
 &nbsp;&nbsp;&nbsp;&nbsp; // waiting for the server to respond to a request.
 &nbsp;&nbsp;&nbsp;&nbsp; // The lpvStatusInformation parameter is NULL. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_RECEIVING_RESPONSE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is selected when we are notified that the API has
 &nbsp;&nbsp;&nbsp;&nbsp; // successfully received a response from the server.
 &nbsp;&nbsp;&nbsp;&nbsp; // The lpvStatusInformation parameter is NULL. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_RESPONSE_RECEIVED:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is selected when we are notified that the API is
 &nbsp;&nbsp;&nbsp;&nbsp; // closing the connection to the server.
 &nbsp;&nbsp;&nbsp;&nbsp; // The lpvStatusInformation parameter is NULL. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_CLOSING_CONNECTION:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is selected when we are notified that the API has
 &nbsp;&nbsp;&nbsp;&nbsp; // successfully closed the connection to the server.
 &nbsp;&nbsp;&nbsp;&nbsp; // The lpvStatusInformation parameter is NULL. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_CONNECTION_CLOSED:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is used when a call to InternetConnect has created
 &nbsp;&nbsp;&nbsp;&nbsp; // the new handle. This lets the application call 
 &nbsp;&nbsp;&nbsp;&nbsp; // InternetCloseHandle from another thread
 &nbsp;&nbsp;&nbsp;&nbsp; // if the connection is taking too long. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_HANDLE_CREATED:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use pIar to point to the structure.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is selected when we are notified that the API has
 &nbsp;&nbsp;&nbsp;&nbsp; // closed a handle. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_HANDLE_CLOSING:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp;&nbsp;&nbsp; // An asynchronous operation has been completed.
 &nbsp;&nbsp;&nbsp;&nbsp; // See InternetOpen for details on INTERNET_FLAG_ASYNC.
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_REQUEST_COMPLETE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Check the INTERNET_ASYNC_RESULT structure for error information.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIar = (LPINTERNET_ASYNC_RESULT)(lpvStatusInformation);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do we have an error?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(pIar-&gt;dwResult))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If so, then process it.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (pIar-&gt;dwError)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Standard error returned from FtpFindFirstFile 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //and InternetFindNextFile.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ERROR_NO_MORE_FILES:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ERROR_INTERNET_EXTENDED_ERROR:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Error triggered when the server can pass back
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //more information on what went wrong.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //No problem - this would be a Boolean return value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //representing success.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This would be a good place to check for all the
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //INTERNET_ERROR_* messages (for example, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //INTERNET_ERROR_NAME_NOT_RESOLVED) to give more
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //descriptive output to the user.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; return;
 &nbsp; }
</code></pre>
<p>
For this article we are only interested in knowing when a handle has been created and when a particular request has been fulfilled. So we will focus on the following two values: <b>INTERNET_STATUS_HANDLE_CREATED</b> and <b>INTERNET_STATUS_REQUEST_COMPLETE</b>.</p>
<p>
The <b>INTERNET_STATUS_HANDLE_CREATED</b> value is sent to the <b>callback</b> when the <b>InternetConnect</b> function has successfully created the handle you have requested. The <b>INTERNET_STATUS_REQUEST_COMPLETE</b> value is sent to the <b>callback</b> by the WinInet API when it has finished with a particular request, such as <b>FtpGetFile</b>.</p>
<h3>Setting Up Monitoring on a Separate Thread</h3>
<p>
Setting up a function to run on another thread of execution is quite simple with either the Win32 API or MFC. Because we are writing an MFC application we will use the MFC methodology. The MFC <b>AfxBeginThread</b> function is used to create and, usually, execute the desired function on another thread. An example might look like this:</p>
<pre><code>CWinThread * Callback_Thread;
.
.
.
Callback_Thread = AfxBeginThread(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CallbackThread_Proc,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // function to run on thread
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID)0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // value to pass to function
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THREAD_PRIORITY_NORMAL,&nbsp;&nbsp; // thread's priority
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // stack size
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CREATE_SUSPENDED,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // create susupended thread
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no security attributes
.
.
.
</code></pre>
<p>
The example above creates a "suspended" thread that can be started or resumed later at the program's discretion. You could just as easily have created the thread to begin execution immediately. You resume the thread, at the appropriate time, with the <b>ResumeThread</b> member function of the <b>CWinThread</b> class. This would look like:</p>
<pre><code>Callback_Thread-&gt;ResumeThread();
</code></pre>
<p>
The actual thread function must be defined in a predetermined syntax. An example of this would look like:</p>
<pre><code>UINT CallbackThread_Proc(LPVOID lParm)
 &nbsp; {
 &nbsp; UINT uResult;

 &nbsp; uResult = some processing

 &nbsp; return(uResult);
 &nbsp; }
</code></pre>
<h3>Creating an Asynchronous Example</h3>
<p>
We have examined the <b>callback</b> function, the <b>Event</b> synchronization object, and how to create other threads. Now let's put it all together and look at the changes you need to make to the previous examples in order to create an asynchronous example. The changes are indicated by <b>bold type</b>. A couple of clarifications before you go any further:
<ul type=disc>
<li>
You create two <b>Event</b> objects during initialization. They are <b>hWaitForHandleCreation</b> and <b>hWaitForCompletedRequest</b>. The <b>hWaitForHandleCreation</b> object signals you when the WinInet API has finished creating a requested handle from a call to the <b>InternetConnect</b> API function. The <b>hWaitForCompletedRequest</b> event object signals you when certain Internet requests, for example <b>FtpGetFile</b>, have been completed.<br><br></li>
<li>
You established the "<b>callback</b>" function on a separate thread via <b>AfxBeginThread</b>.</li>
</ul>
<h4>New "Callback" Function</h4>
<p>
Now you need to rewrite part of the <b>callback</b> function to signal you when certain things have happened. The first thing you need to know is when the application has finished creating a handle for you; the second is when a request has been completed. The <b>callback</b> example code now looks like this:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; // This value is used when a call to InternetConnect has created
 &nbsp;&nbsp;&nbsp;&nbsp; // the new handle. This lets the application call 
 &nbsp;&nbsp;&nbsp;&nbsp; // InternetCloseHandle from another thread
 &nbsp;&nbsp;&nbsp;&nbsp; // if the connection is taking too long. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_HANDLE_CREATED:

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use pIar to point to the structure.</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get new handle from structure.</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIar = (LPINTERNET_ASYNC_RESULT)(lpvStatusInformation);</b>


<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Store for future use in global memory or shared memory.</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hResultHandle = (HINTERNET)pIar-&gt;dwResult;</b>


<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Let other code continue.</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::SetEvent(hWaitForHandleCreation);</b>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; // An asynchronous operation has been completed.
 &nbsp;&nbsp;&nbsp;&nbsp; // See InternetOpen for details on INTERNET_FLAG_ASYNC.
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_REQUEST_COMPLETE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Check the INTERNET_ASYNC_RESULT structure for error information.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIar = (LPINTERNET_ASYNC_RESULT)(lpvStatusInformation);
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp; .

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::SetEvent(hWaitForCompletedRequest);</b>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
</code></pre>
<h4>New InternetConnect Example</h4>
<p>
The next piece of code you need to modify is your example of <b>InternetConnect</b>, because you are processing in an asynchronous mode. You need to wait for the INTERNET_STATUS_HANDLE_CREATED message to be received in the callback function. You obtain the handle you need from the parameters passed to you at this time. The code now looks like this:</p>
<pre><code>// Make connection to ftp server.
HINTERNET hFTPSession;

<b>// Set up so you have to wait until the handle is actually created.</b>

<b>::ResetEvent(hWaitForHandleCreation);</b>


// Create connection (actual handle will come back through callback).
hFTPSession = ::InternetConnect(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInternetSession,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle from a previous
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // call to InternetOpen
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ftp://ftp.microsoft.com",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // server we wish to connect to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_INVALID_PORT_NUMBER,&nbsp;&nbsp;&nbsp; // use appropriate port
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "anonymous",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // username, can be NULL
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "robcol@homesite.com",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // password, can be NULL
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_SERVICE_FTP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // flag to use FTP services
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // flags (see SDK docs)

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (DWORD)dwContext);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SEE DISCUSSION ON THIS PARAM.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Assume this value is passed
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to us somehow.

<b>// Wait until handle is created.</b>

<b>::WaitForSingleObject(hWaitForHandleCreation);</b>


<b>// Retrieve actual handle from global memory or shared memory.</b>

<b>hFTPSession = hResultHandle;</b>


.
.
.
// Do some processing.
.
.
.

// Close connections.
InternetCloseHandle(hFTPSession);
</code></pre>
<h4>New FtpGetFile Example</h4>
<p>
The last piece of code you need to change is the piece that gets the files with the <b>FtpGetFile</b> function. This change is necessary because the file being retrieved may be quite large or your physical connection may be slow. Either reason may cause the transfer to take some time and you cannot use the file until it is fully transferred. The new code looks like this:</p>
<pre><code>BOOL bResult;

<b>// Set up so you have to wait until the file is completely transferred.</b>

<b>::ResetEvent(hWaitForCompletedRequest);</b>


bResult = ::FtpGetFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFTPSession,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ftp://ftp.mysite.com/reference.doc",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "c:\notes\reference.doc",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE_ATTRIBUTE_NORMAL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTP_TRANSFER_TYPE_BINARY,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwContext);

<b>// Wait until file is transferred.</b>

<b>::WaitForSingleObject(hWaitForCompletedRequest);</b>
</code></pre>
<h2>Putting It All Together</h2>
<p>
Putting together the examples from the article and creating a "complete" example is not simple. You must keep in mind that there will be TWO threads or tasks running simultaneously for the final example. I will explain what is going on as it happens.</p>
<p>
The first function you will "build" has a single purpose in life: To set up the Internet API's <b>callback</b> function. Doing so in a separate function may seem redundant, but all will be explained.</p>
<pre><code>UINT SetupCallbackFunction(LPVOID lParam)
 &nbsp; {
 &nbsp; INTERNET_STATUS_CALLBACK dwISC;

 &nbsp; // Set up event to wait for program completion.
 &nbsp; ::ResetEvent(hWaitForProgramCompletion);

 &nbsp; // Set up Internet status callback.
 &nbsp; dwISC = ::InternetSetStatusCallback(&nbsp;&nbsp; hInternetConnection,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InternetCallback); 

 &nbsp; // Set up event to wait for program completion.
 &nbsp; ::WaitForSingleObject(hWaitForProgramCompletion, INFINITE);
 &nbsp; }
</code></pre>
<p>
If you recognize the syntax of this function as being the same as that of a thread procedure, you are correct. The reason I decided to launch the Internet API callback AND wait for some signal to terminate the thread was that I want to keep this processing separate from the main application. If you do not do this, the callback routine is viewed by the system as part of the main application and therefore could potentially affect the main program. This is done in the sample application so that the callback routine can cause status display updates in the main program and not have to worry about the two threads conflicting with each other.</p>
<p>
The second function you will build is the one that makes the connection to the FTP server, waits for the real handle via the callback function, and then returns that value. The code looks like this:</p>
<pre><code>HINTERNET ConnectToFtpServer(HINTERNET hInternetConnection,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR pFTPServer,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR pUsername,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPSTR pPassword,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID lpContext)
 &nbsp; {
 &nbsp; // Make connection to ftp server.
 &nbsp; HINTERNET hFTPSession;

 &nbsp; // Set up so you have to wait until the handle is actually created.
 &nbsp; ::ResetEvent(hWaitForHandleCreation);

 &nbsp; // Create connection (actual handle will come back through callback).
 &nbsp; hFTPSession = ::InternetConnect(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hInternetSession,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Handle from a previous
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // call to InternetOpen.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pFTPServer,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Server we want to connect to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_INVALID_PORT_NUMBER,&nbsp;&nbsp;&nbsp; // Use appropriate port
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pUsername,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Username, can be NULL
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPassword,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Password, can be NULL
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_SERVICE_FTP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flag to use FTP services
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags (see SDK docs)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (DWORD) lpContext);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Context for this connection

 &nbsp; // Wait until handle is created.
 &nbsp; ::WaitForSingleObject(hWaitForHandleCreation);

 &nbsp; // Retrieve actual handle from global memory or shared memory.
return(hResultHandle);&nbsp;&nbsp; 
 &nbsp; }
</code></pre>
<p>
The third function you need to write is the actual <b>callback</b> function itself. It looks like this:</p>
<pre><code>void CALLBACK InternetCallback(&nbsp;&nbsp; HINTERNET hInternet,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwContext,\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwInternetStatus,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID lpvStatusInformation,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwStatusInformationLength)
 &nbsp; {
 &nbsp; LPINTERNET_ASYNC_RESULT pIar =&nbsp;&nbsp; (LPINTERNET_ASYNC_RESULT)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lpvStatusInformation);
 &nbsp; LPSTR pStr =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPSTR) (lpvStatusInformation);

 &nbsp; // act upon status code
 &nbsp; switch(dwInternetStatus)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // other values same as in example above (removed for brevity)
 &nbsp;&nbsp;&nbsp;&nbsp; //

 &nbsp;&nbsp;&nbsp;&nbsp; // This value is used when a call to InternetConnect has created
 &nbsp;&nbsp;&nbsp;&nbsp; // the new handle. This lets the application call 
 &nbsp;&nbsp;&nbsp;&nbsp; // InternetCloseHandle from another thread
 &nbsp;&nbsp;&nbsp;&nbsp; // if the connection is taking too long. 
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_HANDLE_CREATED:

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>// Use pIar to point to the structure.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get new handle from structure.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIar = (LPINTERNET_ASYNC_RESULT)(lpvStatusInformation);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Store for future use in global memory or shared memory.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hResultHandle = (HINTERNET)pIar-&gt;dwResult;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Let other code continue.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::SetEvent(hWaitForHandleCreation);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; // An asynchronous operation has been completed.
 &nbsp;&nbsp;&nbsp;&nbsp; // See InternetOpen for details on INTERNET_FLAG_ASYNC.
 &nbsp;&nbsp;&nbsp;&nbsp; case INTERNET_STATUS_REQUEST_COMPLETE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //check the INTERNET_ASYNC_RESULT structure for error information.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIar = (LPINTERNET_ASYNC_RESULT)(lpvStatusInformation);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Other code same as in example above (removed for brevity).
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::SetEvent(hWaitForCompletedRequest);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp; }
</code></pre>
<p>
Now you code up the "main" routine to put it all together:</p>
<pre><code>#include . . . 
#include &lt;WinINet.h&gt; &nbsp;&nbsp;&nbsp;&nbsp; // Header file for WinINet SDK

// "Global" or shared memory
HANDLE hWaitForHandleCreation;
HANDLE hWaitForCompletedRequest;
HANDLE hWaitForProgramCompletion;
HANDLE hResultHandle;
DWORD dwContextValue;

int MainRoutine()
 &nbsp; {
 &nbsp; HINTERNET hInternetSession;
 &nbsp; HINTERNET hFTPSession;
 &nbsp; HINTERNET hFileConnection;
 &nbsp; WIN32_FIND_DATA sWFD; 
 &nbsp; BOOL bResult = TRUE;

 &nbsp; hInternetSession = ::InternetOpen(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Microsoft Internet Explorer",&nbsp;&nbsp; // agent
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTERNET_OPEN_TYPE_PROXY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // access
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ftp-gw",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // proxy server
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // defaults
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // synchronous

 &nbsp; // Create our Event objects.
 &nbsp; hWaitForHandleCreation = ::CreateEvent(NULL, TRUE, TRUE, NULL);
 &nbsp; hWaitForCompletedRequest = ::CreateEvent(NULL, TRUE, TRUE, NULL);
 &nbsp; hWaitForProgramCompletion = ::CreateEvent(NULL, TRUE, TRUE, NULL);

 &nbsp; // Connect to remote FTP server.
 &nbsp; // REMEMBER, THIS ROUTINE WILL NOT RETURN UNTIL YOU HAVE THE ACTUAL
 &nbsp; // HANDLE FROM THE CALLBACK ROUTINE.
 &nbsp; hFTPSession&nbsp; = ConnectToFtpServer(hInternetSession,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ftp.microsoft.com"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use anonymous username
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use e-mail name password
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPVOID)&amp;dwContext);

 &nbsp; // find first .ZIP file
 &nbsp; hFileConnection = ::FtpFindFirstFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFTPSession,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "*.ZIP",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;sWFD,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);
 &nbsp; if (hFileConnection != (HINTERNET)NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; ::FtpSetCurrentDirectory(hFTPSession, "/BIN");

 &nbsp;&nbsp;&nbsp;&nbsp; while (bResult)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create file specs.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputSpec = "ftp://ftp.infosite.com/BIN/";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputSpec = InputSpec + sWFD.cFileName;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputSpec = "c:\zipfiles\";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputSpec = OutputSpec + sWFD.cFileName;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set up so you have to wait until the transfer is complete.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::ResetEvent(hWaitForCompletedRequest);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Transfer the file.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bResult = ::FtpGetFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFTPSession,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputSpec,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputSpec,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE_ATTRIBUTE_NORMAL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTP_TRANSFER_TYPE_BINARY,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Wait until file is transferred.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // REMEMBER, THIS "WAIT" WILL WAIT UNTIL THE CALLBACK
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ROUTINE RECEIVES AN "INTERNET_STATUS_REQUEST_COMPLETE"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // NOTIFICATION.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::WaitForSingleObject(hWaitForCompletedRequest);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get next file.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bResult = ::InternetFindNextFile(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFileConnection,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;sWFD);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp; // Cause callback thread to terminate.
 &nbsp; ::SetEvent(hWaitForProgramCompletion);

 &nbsp; // Close down all connections.
 &nbsp; ::InternetCloseHandle(hFTPSession);
 &nbsp; ::InternetCloseHandle(hInternetSession);

 &nbsp; // Release all Event objects.
 &nbsp; ::CloseHandle(hWaitForHandleCreation); NULL);
 &nbsp; ::CloseHandle(hWaitForCompletedRequest);
 &nbsp; ::CloseHandle(hWaitForProgramCompletion);

 &nbsp; // Return success code.
 &nbsp; return(0);
 &nbsp; }
</code></pre>
<h2>Conclusion</h2>
<p>
That is what it takes to write an asynchronous FTP transfer program. Be warned about the <b>FtpPutFile</b> API function—if used incorrectly, it can fill up someone else's FTP server. The sample included with this article uses the discussed concepts and builds on them to provide you with a fully functional, MFC GUI-based, multithreaded FTP transfer program. Have fun with it. It was certainly fun to write.</p>
</BODY>
</HTML>
