<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Writing Microsoft Transaction Server Resource Dispensers</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_resdispr"></a>Writing Microsoft Transaction Server Resource Dispensers</h1>
<p>
Walter Oliver</p>
<h4><a name="resdispr_contents"></a>Contents</h4>
<p>
<a href="#resdispr_what">What Is a Resource Dispenser?</a><br>
<a href="#resdispr_dev">Development Environment</a><br>
<a href="#resdispr_def">Defining the Resource Dispenser Class</a><br>
<a href="#resdispr_init">Initializing the Resource Dispenser</a><br>
<a href="#resdispr_write">Writing a COM Interface or API for Your RM Proxy</a><br>
<a href="#resdispr_talk">Talking to DispMan Through IHolder</a><br>
<a href="#resdispr_imp">Implementing the IDispenserDriver</a><br>
<a href="#resdispr_rel">Releasing the Resource Dispenser</a><br>
<a href="#resdispr_dll">Implement the DLL EntryPoint and Exports</a><a href="#resdispr_appa">Appendix A: Threading and Marshalling Issues</a><br>
<a href="#resdispr_appb">Appendix B: Registry Entries</a></p>
<h3><a name="resdispr_what"></a>What Is a Resource Dispenser?</h3>
<p>
A resource dispenser (RD) provides the following services:
<ul type=disc>
<li>
The medium through which application components can obtain resources for executing transacted operations. These resources are nondurable and reside in the resource dispenser's memory, that is, they never persist on disk. For example, a connection to a resource manager is a common resource.<br><br></li>
<li>
A resource manager (RM) proxy or RM client-side interface through which applications can access a particular RM.<br><br></li>
<li>
Resource pooling for Microsoft® Transaction Server (MTS) applications so that several resources can be created and kept in an inventory for use among multiple clients. <br><br></li>
<li>
Transactions that can propagate across processes or distributed systems.</li>
</ul>
<h4>When to create a resource dispenser</h4>
<p>
Build an RD if your requirements include:
<ul type=disc>
<li>
Pooling and recycling resources. An RD allows the MTS Dispenser Manager (DispMan) to maintain an inventory of resources that can be reused by applications at run time.<br><br></li>
<li>
Propagating transactions between process boundaries or remote systems on a network. Propagated transactions originate by the client and are executed on the server.</li>
</ul>
<p>
Writing a resource dispenser to pool application component objects is not recommended. Future versions of MTS will use the <b>IobjectControl</b> interface, which can be implemented by application components to achieve object pooling and recycling. Moreover, in those cases where there are a few component objects that can be shared globally, setting up a shared property for each object and using them through the Shared Property Manager may provide the desired result.</p>
<h4>Resource dispensers running under MTS</h4>
<p>
When running under MTS, the Dispenser Manager can automate transactions and resource reclamation. When operating with MTS, your RD interacts with:
<ul type=disc>
<li>
Three MTS components: Dispenser Manager, Holder, and Microsoft Distributed Transaction Coordinator (MS DTC).<br><br></li>
<li>
One or more application components.<br><br></li>
<li>
One resource manager.</li>
</ul>
<p>
These relationships are: 
<ul type=disc>
<li>
<b>RD and DispMan</b>. RD calls the <b>IDispenserManager</b> interface to register resource dispenser.<br><br></li>
<li>
<b>RD and Holder</b>. RD calls the <b>IHolder</b> interface and Holder calls the <b>IDispenserDriver </b>interface.<br><br></li>
<li>
<b>RD and Application Component</b>. The Application Component calls the interface provided by RD<br><br></li>
<li>
<b>RD and Resource Manager</b>. RD calls the interface provided by the Resource Manager.<br><br></li>
<li>
<b>RD and MS DTC</b>. RD calls the <b>ITransaction</b>, <b>ITarnasactionDispenser</b>, <b>IGetDispenser</b>, and <b>ITransactionExport</b> interfaces to propagate transactions to the Resource Manager.<br><br></li>
<li>
<b>RD and OLE Libraries</b>. RD calls the <b>CoCreateInstance</b>, and <b>CoCreateFreeThreadedMarshaler</b> functions and the <b>IGlobalInterfaceTable</b> interface.</li>
</ul>
<h4>Resource dispenser running independently from MTS</h4>
<p>
When running independently from MTS, your RD interacts with all but two of the MTS components: Dispenser Manager and Holder. This implies that the RD will continue to use MS DTC to provide transaction propagation but will not provide MTS pooling (the RD may provide its own pooling mechanism). </p>
<p>
<a href="#resdispr_contents">Return to Contents</a></p>
<h3><a name="resdispr_dev"></a>Development Environment</h3>
<p>
There are many ways of setting up your development environment for writing a resource dispenser. Here is a set of tools and libraries that either are required or can simplify the job:
<ul type=disc>
<li>
Microsoft Visual C++® 5.<i>x </i>programming language, which contains all the development tools such as compilers, linker, and debugger.<br><br></li>
<li>
Active Template Library (ATL), which is ideal for building lightweight Component Object Model (COM) components. It contains the base classes and templates for the resource dispenser class: CComObjectRootEx, CComCoClass, and <b>IDispatchImpl</b>.<br><br></li>
<li>
ATL Application Wizard, which comes with Visual C++ 5.<i>x</i>. This wizard is an easy way to get your project files started since it generates the DLL's entry point and export functions as well as the .def, and .rc files.<br><br></li>
<li>
Microsoft Transaction Server 2.<i>x</i>. provides all the MTS components needed at run time.<br><br></li>
<li>
Microsoft Transaction Server Software Development Kit (SDK) 2.<i>x</i>, which provides the documentation, sample code, header files, and libraries needed to write and compile your resource dispense, such as the header file for the <b>IDispenserDriver </b>interface.<br><br></li>
<li>
Microsoft Windows NT® 4.0 SDK Service Pack 3 or later, which contains the header file for the <b>IGlobalInterfaceTable</b> interface.</li>
</ul>
<p>
<a href="#resdispr_contents">Return to Contents</a></p>
<h3><a name="resdispr_def"></a>Defining the Resource Dispenser Class</h3>
<p>
Define your class simply and easily by using the ATL Object Wizard in VC ++ and choosing the "simple object" option. The following class definition serves as a model for defining your resource dispenser class:</p>
<pre><code>/////////////////////////////////////////////////////////////////////////////
// CResourceDispenser
class ATL_NO_VTABLE CRDisp : 
 &nbsp; public IDispenserDriver, 
 &nbsp; public CComObjectRootEx&lt;CComMultiThreadModel&gt;,
 &nbsp; public CComCoClass&lt;CRDisp, &amp;CLSID_ ResourceDispenser &gt;,
 &nbsp; public IDispatchImpl&lt;IRDisp, &amp;IID_IResourceDispenser, &amp;LIBID_RESDISPLib&gt;
{
private:
 &nbsp; //
 &nbsp; // Member variables needed to make a resource dispenser
 &nbsp; //
 &nbsp; IGlobalInterfaceTable *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pGIT;
 &nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dwRmPtrCookie;
 &nbsp; IHolder *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pHolder;
 &nbsp; IDispenserManager *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pDispMan;
 &nbsp; // A map of Resource handles to export objects
 &nbsp; map&lt;DWORD, ITransactionExport *&gt; m_mapExport;


public:

//
// The resource dispenser must be a singleton object so that
// there is a unique <b>IHolder</b> which maintains the list of 
// resources to be pooled.
//
DECLARE_CLASSFACTORY_SINGLETON(CFileRmPxy);
DECLARE_PROTECT_FINAL_CONSTRUCT();


 &nbsp; // Set pointers to NULL within the constructor.
 &nbsp; CResourceDispenser ();
 &nbsp; ~ CResourceDispenser ();


DECLARE_REGISTRY_RESOURCEID(IDR_RDISP)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CResourceDispenser)
 &nbsp; COM_INTERFACE_ENTRY(IResourceDispenser)
 &nbsp; COM_INTERFACE_ENTRY(IDispatch)
 &nbsp; COM_INTERFACE_ENTRY(IDispenserDriver)&nbsp;&nbsp; 
 &nbsp; COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

 &nbsp; // Do initialization work within this method.
 &nbsp; HRESULT FinalConstruct();

 &nbsp; // Do clean up work within this method.
 &nbsp; void FinalRelease();

 &nbsp; CComPtr&lt;IUnknown&gt; m_pUnkMarshaler;

//
// IResourceDispenser. This is the custom interface that the application
// components call.
//
// Define your custom interface here. The following methods are given as
//examples only, you can choose any names and/or signatures as you deem
// appropriate.
//
 &nbsp; STDMETHOD(Connect)(long *hConnection);
 &nbsp; STDMETHOD(Disconnect)(long hConnection);
 &nbsp; STDMETHOD(SomeMethod_1)(long hConnection, DWORD dwQty );
 &nbsp; STDMETHOD(SomeMethod_2)(long hConnection, BYTE* pData );

//
// <b>IDispenserDriver</b>
//
 &nbsp; // This interface is required to run under MTS.
 &nbsp; STDMETHOD(CreateResource)(&nbsp;&nbsp; /*[in]*/&nbsp; const RESTYPID ResTypId,&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*[out]*/ RESID* pResId, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*[out]*/ TIMEINSECS* SecsFreeBeforeDestroy&nbsp;&nbsp; );
 &nbsp; STDMETHOD(RateResource)(&nbsp;&nbsp; /*[in]*/&nbsp; const RESTYPID ResTypId,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*[in]*/&nbsp; const RESID ResId,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*[in]*/&nbsp; const BOOL fRequiresTransactionEnlistment,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*[out]*/ RESOURCERATING* pRating&nbsp;&nbsp; );
 &nbsp; STDMETHOD(EnlistResource)(/*[in]*/&nbsp; const RESID ResId,/*[in]*/&nbsp; const TRANSID TransId);
 &nbsp; STDMETHOD(ResetResource)(/*[in]*/&nbsp; const RESID ResId);
// Numeric resource ID
 &nbsp; STDMETHOD(DestroyResource)(/*[in]*/&nbsp; const RESID ResId);
// String resource ID
STDMETHOD(DestroyResourceS)(/*[in]*/&nbsp; constSRESID ResId);
};
</code></pre>
<p>
<a href="#resdispr_contents">Return to Contents</a></p>
<h3><a name="resdispr_init"></a>Initializing the Resource Dispenser</h3>
<p>
If you decide to use the ATL library to implement the resource dispenser, the RD class should be derived from CComObjectRootEx. This ATL template provides the <b>FinalContruct</b> method that you should use when initializing. Doing initialization work within this method will allow more flexibility when handling errors since they could be propagated all the way back to the user. This is because the ATL framework has fully created the object by the time it calls <b>FinalContruct</b>.</p>
<p>
When initializing the resource dispenser you need to perform the following steps:
<ol>
<li>
<b>Initialize key member variables</b><p class=tl>
Initialize (to NULL) all member variables that will hold the various interface pointers. This step will help you make some basic decisions down the road, such as finding out whether a pointer should be released or whether the RD object is running under MTS. Perform this task within the default constructor of your class.</P></li>
<li>
<b>Call GetDispenserManager</b><p class=tl>
Call the <b>GetDispenserManager</b> function to get a pointer to the <b>IDisperserManager</b> interface. You must call this function to obtain a successful return code that indicates if the RD object is running under MTS. In addition, the <b>GetDispenserManager</b> function is the only way to obtain a pointer to the <b>IDispenserManager</b> interface. You should store the pointer received in a private member variable so that you can check it to verify if the RD is running under MTS. For example, you can use the following call to check if the RD is running under MTS:</P><pre><code>hr = GetDispenserManager(&amp;m_pDispMan);
</code></pre>
</li>
<li>
<b>Call IDispenserManager::RegisterDispenser</b><p class=tl>
If the previous call succeeded, then call the <b>IDispenserManager::RegisterDispenser</b> method to tell the DispMan that the RD object has started and wants to be connected. This function takes two input parameters and one output parameter. The input parameters are a pointer to the RD's <b>IDispenserDriver</b> interface and a WCHAR pointer containing the friendly name of your resource dispenser. The output parameter is a pointer to the pointer of the <b>IHolder</b> interface. Make sure you store this pointer in a private member variable. You will need it when implementing the resource allocation and freeing functionality (see the section <a href="#resdispr_talk">"Talking to DispMan through IHolder"</a>). For information on <b>IDispenserDriver</b> see the section <a href="#resdispr_imp">"Implementing the IDispenserDriver"</a>.</P><p class=atl>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>The <b>RegisterDispenser</b> method does not add a reference count for the <b>IDispenserDriver</b> interface. This means that before you can call this method you need to obtain a pointer to the <b>IDispenserDriver</b> interface though the <b>IUnknown::QueryInterface</b> method so that the reference is properly added. This issue should be fixed in future releases of MTS.</p><p class=tl>
For example, the following code demonstrates how to obtain a pointer to the <b>IdispenserDriver</b> interface through the <b>IUnknown::QueryInterface</b> method.</P><pre><code>...hr = GetDispenserManager(&amp;m_pDispMan);

...if (SUCCEEDED(hr))
...{
......// Call <b>QueryInterface</b> to get the right reference count.
......IDispenserDriver * pDriver;
......hr = GetUnknown()-&gt;QueryInterface(IID_IDispenserDriver, (void **)&amp;pDriver);
......_ASSERTE(hr == S_OK);

......// Register with DispMan
......hr = m_pDispMan -&gt; RegisterDispenser(pDriver, L"MyDispenser", &amp;m_pHolder);......
......_ASSERTE(hr == S_OK);......
...}
</code></pre>
</li>
<li>
<b>Get a connection to the Resource Manager</b><p class=tl>
Call the particular Resource Manager interface method (or API function) to establish a connection. This is not a resource connection, but the connection your resource dispenser needs for future requests. In other words, you should get back a handle or pointer to the RM, that is, a handle to a name pipe or a pointer to a COM Interface that will enable future calls to create and free resources or to propagate transactions. If the RM provides a COM Interface, call the <b>CoCreateInstance</b> function and pass the RM's CLSID to get a pointer to it.</P><p class=tl>
The following code demonstrates how to make this call:</P><pre><code>hr = CoCreateInstance(...CLSID_CoResourceManager, 
NULL, 
CLSCTX_LOCAL_SERVER, 
IID_IResourceManager , 
(void **)&amp;m_pRm);...
</code></pre>
</li>
<li>
<b><a name="resdispr_git"></a>Use a Global Interface Table (GIT)</b><p class=tl>
Once you acquire a COM interface pointer to the Resource Manager, you should register it with the Global Interface Table (GIT), which allows the RD object to use the RM pointer within the right context even when the application component resides in a different apartment from the one the RM interface was created. In other words, the GIT ensures that the RM pointer will be valid within the particular thread in which it is needed. See <a href="#resdispr_appa">Appendix A</a> for more information on the GIT.</P><p class=tl>
The following code demonstrates how to create an instance of the GIT:</P><pre><code>hr = CoCreateInstance(...CLSID_StdGlobalInterfaceTable,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... IID_IGlobalInterfaceTable,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...(void **)&amp;m_pGIT);
</code></pre>
<p class=tl>
After calling <b>CoCreateInstance</b>, call the <b>IGlobalInterfaceTable::RegisterInterfaceInGlobal</b> method and pass the RM pointer you got earlier along with its GUID. This method returns an out parameter that contains a cookie. From this point on you should always use this cookie when asking for RM pointer by calling <b>IGlobalInterfaceTable::GetInterfaceFromGlobal</b>. You do not need to have a member variable for the RM interface pointer; instead, you must have a member variable for the cookie.</P><p class=tl>
It is strongly recommended that you create a small private method to make the call and check the return value. For example:</P><pre><code>IFileRm * CFileRmPxy::GetResourceManagerPointer()
{
...IResourceManager * pRm =NULL;
...HRESULT hr;
...hr = m_pGIT-&gt;GetInterfaceFromGlobal(...m_dwRmPtrCookie, 
IID_ IResourceManager,
(void **)&amp;pRm);...
..._ASSERTE(pRm);
...return pRm;
}
</code></pre>
</li>
<li>
<b>Call CoCreateFreeThreadedMarshaler</b><p class=tl>
As a final step to your initialization work, call <b>CoCreateFreeThreadedMarshaler</b>. Since your resource dispenser has a threading model value of "Both" (see <a href="#resdispr_appb">Appendix B: Registry Entries</a>), calling this function provides efficient inter-thread marshaling of the RD interface pointer within the same process. This function creates a free-threaded marshaler object and aggregates it to the RD object (refer to <a href="#resdispr_appa">Appendix A</a> for more information on marshalling issues.) The following code demonstrates how this function call is used:</P><pre><code>hr = CoCreateFreeThreadedMarshaler(GetUnknown(), &amp;m_pFreeThreadedMarshaler);
</code></pre>
<p class=tl>
Notice that the first parameter corresponds to the <b>IUknown</b> interface pointer of the resource dispenser object.</P></li>
</ol>
<p>
<a href="#resdispr_contents">Return to Contents</a></p>
<h3><a name="resdispr_write"></a>Writing a COM Interface or API for Your RM Proxy</h3>
<p>
One of the main requirements of your resource dispenser is to act as the Resource Manager's proxy or client-side interface. It is strongly recommended that you implement your RM proxy interface as a COM interface if possible. However, it is not mandatory for this interface to be COM compliant. An example of a resource dispenser that does not provide a COM interface is the Microsoft SQL Server™ ODBC driver. The interface it provides to clients is the standard ODBC API. For an example of a resource dispenser that implements a COM interface see the sample provided in the MTS 2.<i>x</i> SDK.</p>
<p>
By using COM you will be able to group areas of functionality in simple interfaces as opposed to one big API library. For example, if the RM you are working with implements a nonintuitive interface, API, IPC layer, or requires several steps to accomplish one single operational unit, you may want to encapsulate all of the complexity behind one or more well though-out COM interfaces. </p>
<p>
Independent of the interface implementation as a COM interface or API, the RD must accomplish two goals when working as the RM proxy:
<ul type=disc>
<li>
Allow client access to the RM services. This is the most important goal. As stated above, your resource dispenser does not have to run under MTS to work.<br><br></li>
<li>
Interface with MTS to allocate and free resources. This is an optional, yet highly recommended, goal. It is accomplished by interfacing with DispMan through the assigned <b>IHolder</b> interface pointer. Notice that by using <b>IHolder</b>, the RD will be able to automatically participate in MTS declarative transactions. Otherwise, you will have to provide particular methods for your clients to explicitly enlist resources in transactions.</li>
</ul>
<p>
<a href="#resdispr_contents">Return to Contents</a></p>
<h3><a name="resdispr_talk"></a>Talking to DispMan through IHolder</h3>
<p>
The Dispenser Manager provides each resource dispenser (or RM proxy) with a Holder object that implements the <b>IHolder</b> interface. This Holder object works along side the RD to create and keep track of resources. In other words, the Holder object and the RD are part of the mechanism used by MTS to maintain an inventory of the resources provided by the Resource Manager.</p>
<p>
When implementing your RM proxy's interface, you need to use the methods provided in <b>IHolder</b> to allocate and free resources. You should get a pointer to <b>IHolder</b> during initialization of your RM Proxy object by calling <b>IDispenserManager::RegisterDispenser</b> method, as described above.</p>
<h4>Use the IHolder interface</h4>
<p>
Select among the methods of your interface those that will call the various methods of the <b>IHolder</b> interface. Of <b>IHolder</b> methods you will normally use only two: <b>IHolder::AllocResource</b> and <b>IHolder::FreeResource</b>. The other two <b>IHolder::TrackResource</b> and <b>IHolder::UntrackResource</b> are there for future functionality.</p>
<p>
Whatever RD methods you select make sure there is a balance between <b>AllocResource</b> and <b>FreeResource</b> calls. For every call to <b>AllocResource</b> there should be a call to <b>FreeResource</b>. Failing to follow this rule will cause resources to hang around and not be returned to inventory until the object using them terminates or crashes. This behavior could seriously impair the entire system.</p>
<h4><a name="resdispr_ihold"></a>Call IHolder::AllocResource</h4>
<p>
<b>AllocResource</b> should be called when the client requests a resource. In other words, the method that returns the pointer or handle that identifies the resource to the client should call this method to ask the corresponding Holder to allocate a resource.</p>
<p>
Notice that the method that calls <b>AllocResource</b> is not the one that "explicitly" connects to the RM to create the resource. The section <a href="#resdispr_imp">"Implementing the IDispenserDriver"</a> has more detail on which method explicitly connects to the RM for resource creation. </p>
<p>
The <b>AllocResource</b> method takes two parameters: a RESTYPID and a RESID*. You need to decide what these two parameters contain.</p>
<p>
RESTYID is defined as a DWORD. Its purpose is to identify a type of resource not the resource itself. What you store in it is up to you. It could be a constant or a pointer to an object in the RD memory that contains a full description of the type of resource. DispMan does not care about its content. DispMan only uses RESTYPID to refer to a resource type within the resource dispenser.</p>
<p>
RESID is also defined as a DWORD. Its purpose is to identify a particular instance of a resource. You would normally want to store in it a pointer to the resource itself. The section <a href="#resdispr_imp">"Implementing the IDispenserDriver"</a> has more detail on this topic.</p>
<pre><code>&nbsp;&nbsp;&nbsp;// Running under MTS?
 &nbsp; if (m_pDispMan)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; *hConnection = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp; hr = m_pHolder -&gt; AllocResource((RESID)1, (RESID *)hConnection);
 &nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AtlTrace(_T("AllocResource failed! Error code %x\n"), hr);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
</code></pre>
<p>
Notice that hConnenction could be an output parameter declared as "long *hConnection" which would allow the client to get a handle to the resource. The client would then treat this handle as an opaque handle. For a more detailed example see the sample provided with the MTS 2.<i>x</i> SDK.</p>
<p>
As part of the execution of the <b>AllocResource</b> method, DispMan does the following steps to produce a resource:
<ol>
<li>
Searches the pool for a free resource of this RESTYPID, which is already enlisted in the caller's current transaction. DispMan uses the value returned from <b>IDispenserDriver::RateResource</b> as part of the search criteria.<br><br></li>
<li value=1>
.<br><br></li>
<li>
Searches the pool for a free unenlisted resource of this RESTYPID, and then enlists it in the caller's current transaction. Here, DispMan also uses the value returned from <b>IDispenserDriver::RateResource</b>.<br><br></li>
<li>
Creates the resource by calling back to the resource dispenser's <b>IDispenserDriver::CreateResource</b>, and then enlisting it by calling <b>IDispenserDriver::EnlistResource</b>.</li>
</ol>
<p>
If the caller does not have a current transaction, then the enlistment is skipped. Or if the resource dispenser rejects the enlistment (meaning the resource is not transaction capable), then the enlistment is skipped.</p>
<h4>Call IHolder::FreeResource</h4>
<p>
The <b>IHolder::FreeResource</b> method is called when the client application component "frees" a resource previously allocated by <b>AllocResource</b>. For example, in the case of ODBC, <b>FreeResource</b> would be called during the execution of <b>SQLDisconnect</b> API function.</p>
<p>
When calling this function you need to provide the RESID that identifies the resource. This implies that the method that calls <b>FreeResource</b> must have access to it. Normally you would let the client provide you with the RESID in the form of an opaque handle.</p>
<pre><code>&nbsp;&nbsp;&nbsp;HRESULT hr;&nbsp;&nbsp; 
 &nbsp; if (m_pDispMan)
 &nbsp; {&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; hr = m_pHolder -&gt; FreeResource(hConnection);
if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AtlTrace(_T("FreeResource failed! Error code %x\n"), hr);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
</code></pre>
<p>
<a href="#resdispr_contents">Return to Contents</a></p>
<h3><a name="resdispr_imp"></a>Implementing the IDispenserDriver</h3>
<p>
In order to let MTS (in particular DispMan/Holder) communicate with the RD, you need to implement the <b>IDisperserDriver </b>interface. This is required if you want the RD to run under MTS. During the initialization process, you called <b>IDispenserManager::RegisterDispenser</b> and passed a pointer to the RD's <b>IDispenserDriver</b> interface (using the first parameter). The Holder object, which DispMan assigned to the RD instance, uses this interface pointer to communicate with the RD.</p>
<p>
This interface provides the means by which MTS can create and maintain inventory of the resources provided by the RD. The Holder object calls this interface's methods for creating, rating, transaction enlisting, resetting, and destroying resources. The RD implements this interface as any other COM interface (such as the custom interface provided to clients for the RM Proxy functionality; see the section, <a href="#resdispr_write">"Writing a COM Interface or API for Your RM Proxy"</a>).</p>
<h4><a name="resdispr_idisp"></a>Implement IDispenserDriver::CreateResource</h4>
<p>
When it is time to create a new resource, the Holder asks the resource dispenser to create a resource by calling the <b>IDisperserDriver::CreateResource</b> method. In other words, when the RD's RM Proxy custom interface calls <b>IHolder::AllocResource</b> and not resources are available, the Holder object calls this method.</p>
<p>
Follow these steps to implement this method:
<ol>
<li>
Check the RESTYPID input parameter to see if your RD can create this type of resources.<br><br></li>
<li>
<a name="resdispr_step2"></a>Get a pointer to the RM interface. Back in the initialization object you got this pointer and stored it in the Global Interface Table. Now you need to get it back by calling the <b>IGlobalInterfaceTable::GetInterfaceFromGlobal</b> method and passing the cookie stored in a member variable. You may have written a private method to do this; see <b>GetResourceManagerPointer()</b> in the section <a href="#resdispr_git">"Use a Global Interface Table (GIT)"</a>.<pre><code>IResourceManager * pRm = GetResourceManagerPointer();
if (!pRm)
{
return E_UNEXPECTED;
}
</code></pre>
</li>
<li>
Call the RM's method to create the resource. This method should have an output parameter in that the RM stores a handle or pointer to the resource.<pre><code>CComBSTR sRDName = L"SomeResourceDispenser";
hr = pRm -&gt; Connect(sRDName.m_str, (long *)&amp;lHandle);
if (FAILED(hr))
{
pRm-Release();
return hr;
}
</code></pre>
</li>
<li>
Take the resource pointer or handle acquired during step 3 and store it in the output parameter RESID*. This will be the value passed all the way back to the method that called <b>IHolder::AllocResource</b>. This way the resource pointer/handle becomes the resource ID. See the section <a href="#resdispr_ihold">"Call IHolder::AllocResource."</a><pre><code>*pResId = (RESID)lHandle;
</code></pre>
</li>
<li>
Set a timeout value in the output parameter TIMEINSECS*. This indicates to DispMan the number of seconds that this resource will be allowed to remain idle in the pool before DispMan destroys it.<pre><code>//
// Set a 120-second time out.
//
*pSecsFreeBeforeDestroy = 120; 
</code></pre>
<p class=tl>
Release the RM interface pointer.</P><pre><code>if (pRm)
{
pRm -&gt; Release();
pRm = NULL;
}
</code></pre>
</li>
</ol>
<h4>Implement IDispenserDriver::RateResource</h4>
<p>
As part of the process of allocating a resource, the Holder object calls the <b>IDisperserDriver::RateResource</b> method. The Holder object generates a list of candidates among the already created and sometimes enlisted resources. For each of these candidates, the Holder object calls the <b>RateResource</b> method to obtain a value rate (on a scale of 0 to 100) that will determine the "fitness" of the candidate with respect to the RESTYPID and the transaction itself.</p>
<p>
The resource dispenser can terminate the rating loop early by assigning the candidate a resource rating of 100 (a perfect fit). A rating of 100 would normally be reserved for candidate resources that match the RESTYID and are already properly enlisted, unless the resource dispenser concludes that enlistment is an inexpensive operation. If all candidate resources (if any) are rated 0 (unuseable) then a new resource will be created by calling <b>IDispenserDriver::CreateResource</b> (see the section <a href="#resdispr_idisp">"Implement IDispenserDriver::CreateResource"</a>).</p>
<p>
The steps to implement this method are:
<ol>
<li>
Check that the resource passed in the RESID (resource pointer) is a good fit for the resource type required. If the conclusion is negative, return a rate less than 100, 0 may be the appropriate value, in the output parameter RESOURCERATING*. Otherwise continue to Step 2.<br><br></li>
<li>
Check to see if the resource needs enlistment by querying the value of fRequiresTransactionEnlistment. If FALSE, the resource becomes a prime candidate. In that case return 100. If TRUE and enlistment is expensive, rate the resource lower than 100.<pre><code>...if (fRequiresTransactionEnlistment == FALSE)
...{
......*pRating = 100;.........
...}
...else
...{
......// not enlisted
......*pRating = 50;
...}
</code></pre>
</li>
<li>
Return S_OK if successful.</li>
</ol>
<h4>Implement IDispenserDriver::EnlistResource</h4>
<p>
As part of the process of allocating a resource the Holder object may call the <b>IDispenserDriver::EnlistResource</b> method. There are two cases in which this method gets called:
<ul type=disc>
<li>
If the calling application component object is running within a transaction, then Holder calls the resource dispenser and asks it to enlist the resource in the transaction by calling the <b>IDispenserDriver::EnlistResource</b> method.<br><br></li>
<li>
If DispMan requires the particular resource to be unlisted in a transaction, the Holder object calls this method to have the RD certify the case. To indicate this query, Holder passes a value of 0 in the TRANSID input parameter. This case could occur when a transacted object performed the previous use of the resource, and now the current use is by a nontransacted object. To be useful the resource must now be unlisted.</li>
</ul>
<p>
To implement this method, you need to use two of the OLE Transactions objects: the Transaction and Export objects. The Transaction object represents the MS DTC transaction and the Export object represents the connection between an RM proxy (or resource dispenser) and Resource Manager. The Export object contains the name and the location of the Resource Manager's Transaction Manager and is used to propagate transactions between processes or systems.</p>
<p>
Follow these steps to implement this method:
<ol>
<li>
Check the value of TRANSID. If 0 then verify that the resource indicated by RESID is not enlisted in a transaction (this is up to your particular implementation.) If the outcome is TRUE, then return S_OK.<br><br></li>
<li>
If the value of TRANSID is different than 0, cast it to an <b>ITransaction</b> pointer interface (<b>ITransaction*</b>).<pre><code>...ITransaction * pTransaction = (ITransaction*)TransId;
</code></pre>
</li>
<li>
Get a pointer to the Resource Manager interface from the Global Interface Table (see <a href="#resdispr_step2">Step 2</a> in the section "Implement <b>IDispenserDriver::CreateResource</b>").<br><br></li>
<li>
Check to see if you have an <b>ITransactionExport</b> pointer associated to the RESID. It is a good idea to keep a map of RESIDs and <b>ITransactionExport*</b> because it is expensive to create an Export object every time a resource needs to be enlisted. If you do not have an Export object available, create one (see the next section <a href="#resdispr_obtain">"Obtaining an ITransactionExport Interface Pointer"</a> for more information).<pre><code>...pExport = m_mapExport[ResId];
...if (pExport == NULL)
...{
// Create an Export object
hr = GetExportObject(ResId, pTransaction, &amp;pExport);
......if (FAILED(hr))
......{
.........pRm-&gt;Release();
.........return hr;
......}
// Create a map entry between pExport and ResId.
......m_mapExport[ResId] = pExport;
...}
</code></pre>
</li>
<li>
Call <b>ITransactionExport::Export</b> to export the transaction object and get the size of the Transaction Cookie.<pre><code>...ULONG... cbTransactionCookie = 0;
...hr = pExport-&gt;Export (pTransaction, &amp;cbTransactionCookie);
</code></pre>
</li>
<li>
Using the size of the Transaction Cookie, allocate a buffer. You can use the COM function <b>CoTaskMemAlloc</b>. Always check the return value from this function.<pre><code>...rgbTransactionCookie = (BYTE *) CoTaskMemAlloc (cbTransactionCookie);
...if (0 == rgbTransactionCookie)
...{
......pRm-&gt;Release();
......return E_FAIL;
...}
</code></pre>
</li>
<li>
With the Transaction pointer, Transaction Cookie, and Cookie Buffer pointer call <b>ITransactionExport::GetTransactionCookie</b> to get the Transaction Cookie value. This method provides the amount of bytes used for the cookie in an output parameter. Once this method returns, you are ready to propagate the transaction and enlist the resource in it.<pre><code>...hr = pExport-&gt;GetTransactionCookie (...pTransaction, 
..................bTransactionCookie,
..................rgbTransactionCookie,
..................&amp;cbUsed...);
</code></pre>
</li>
<li>
To propagate the transaction all the way to the RM and enlist the resource, you need to call a method within the RM interface. This method should allow the caller to pass a RESID, the bytes used to store the Cookie, and the Transaction Cookie Buffer. This RM's method will import the transaction represented by the cookie and will call MS DTC to get the Transaction object and proceed to enlist the resource.<pre><code>...hr = pRm-&gt;ExportTx (ResId, cbUsed, rgbTransactionCookie);
</code></pre>
</li>
<li>
Finally, free the allocated Cookie buffer and release the pointer to the Resource Manager.<pre><code>...CoTaskMemFree (rgbTransactionCookie);
...pRm-&gt;Release();
</code></pre>
</li>
</ol>
<h4><a name="resdispr_obtain"></a>Obtaining an ITransactionExport Interface Pointer</h4>
<p>
If a resource must be enlisted in a transaction and no Export object pointer (<b>ITransactionExport*</b>) is available for that resource, you must create an Export object.</p>
<p>
Follow these steps to create an Export object:
<ol>
<li>
Get a pointer to the Resource Manager interface from the Global Interface Table (see <a href="#resdispr_step2">Step 2</a> in the section "Implement <b>IDispenserDriver::CreateResource</b>").<br><br></li>
<li>
The RM interface should provide a method to get the "Whereabouts" of the RM. If your RD will be using more than one RM from different locations, you should call this method every time an Export object is needed. Otherwise, call it once and store the "Whereabouts." This method would probably take three parameters: the RESID, a BYTE**, and an ULONG*. In the BYTE** the RM's method should return a pointer to a buffer that contains the RM's "Whereabouts" and in ULONG* the size of this buffer. The RD must call such a method to obtain the RM's location.<pre><code>...hr = pRm-&gt;GetWhereabouts (ResId, &amp;rgbWhereabouts, &amp;cbWhereabouts);
</code></pre>
</li>
<li>
Call the Transaction object's <b>IUknown::QueryInterface</b> to obtain an <b>IGetDispenser</b> interface pointer.<pre><code>...hr = pTransaction-&gt;QueryInterface (IID_IGetDispenser, (LPVOID *) &amp;pIDispenser);
</code></pre>
</li>
<li>
Call the <b>IGetDispenser::GetDispenser</b> method to obtain an <b>ITransactionExportFactory</b> interface pointer.<pre><code>...hr = pIDispenser-&gt;GetDispenser (IID_ITransactionExportFactory, (LPVOID *)&amp;pTxExpFac );
</code></pre>
</li>
<li>
Release the <b>IGetDispenser*</b> you obtained in Step 3.<br><br></li>
<li>
Call the <b>ITransactionExportFactory::Create</b> method and pass the Whereabouts buffer, its size and a pointer to an <b>ITransationExport*</b>. This method will create the Export object and place a pointer to its interface in the output parameter.<pre><code>...hr = pTxExpFac-&gt;Create (cbWhereabouts, rgbWhereabouts, ppExport);
</code></pre>
</li>
<li>
Release the <b>ITransactionExportFactory*</b> you obtained in Step 4.<br><br></li>
<li>
Free the "Whereabouts" buffer by calling <b>CoTaskMemFree</b>.<pre><code>...CoTaskMemFree (rgbWhereabouts);
</code></pre>
</li>
<li>
Finally release the RM interface pointer.</li>
</ol>
<p>
At this point the RD is ready to continue with the enlistment process as depicted in the previous section.</p>
<h4>Implement IDispenserDriver::ResetResource</h4>
<p>
The Holder object calls this method when it is time to put the resource back into general or enlisted inventory. This method prepares the resource before it goes into inventory.</p>
<p>
Follow these steps to implement the method:
<ol>
<li>
Get a pointer to the Resource Manager interface from the Global Interface Table (see <a href="#resdispr_step2">Step 2</a> in the section "Implement <b>IDispenserDriver::CreateResource</b>").<br><br></li>
<li>
Call the particular method within the RM's interface to reset the resource. This method may have a single parameter containing the RESID.<pre><code>...hr = pRm -&gt; ResetConnection((long)ResId);
</code></pre>
</li>
<li>
Clean up any resource specific state data that may have been set while the resource was active.<br><br></li>
<li>
Finally, release the RM interface pointer.</li>
</ol>
<h4>Implement IDispenserDriver::DestroyResource</h4>
<p>
The Holder object calls this method when it is time to destroy the resource.</p>
<p>
The steps to implement this method are:
<ol>
<li>
Get a pointer to the Resource Manager interface from the Global Interface Table (see <a href="#resdispr_step2">Step 2</a> in the section "Implement <b>IDispenserDriver::CreateResource</b>").<br><br></li>
<li>
Call the particular method within the RM's interface to release the resource. This method may have a single parameter containing the RESID.<pre><code>...hr = pRm -&gt; Disconnect((long )ResId);
</code></pre>
</li>
<li>
Release the RM interface pointer.<br><br></li>
<li>
Release the <b>ITransactionExport</b> pointer associated to the RESID.<br><br></li>
<li>
If any map entry was made to keep the RESID and <b>ITransactionExport*</b> association, remove it.</li>
</ol>
<pre><code>&nbsp;&nbsp;&nbsp;ITransactionExport&nbsp;&nbsp; *pExport;
 &nbsp; pExport = m_mapExport[ResId];
 &nbsp; int nElements = m_mapExport.erase(ResId);
</code></pre>
<p>
<a href="#resdispr_contents">Return to Contents</a></p>
<h3><a name="resdispr_rel"></a>Releasing the Resource Dispenser</h3>
<p>
If you are using ATL, you can use the <b>FinalRelease</b> method to undo the "things" did during initialization in the <b>FinalConstruct</b> method and throughout the execution of the resource dispenser.</p>
<p>
To release an instance of the resource dispenser, follow these steps:
<ol>
<li>
Unregister the RM interface pointer from the Global Interface Table by calling the method <b>RevokeInterfaceFromGlobal</b> and pass the cookie you got during initialization.<pre><code>...hr =m_pGIT-&gt;RevokeInterfaceFromGlobal(m_dwRmPtrCookie);
</code></pre>
</li>
<li>
Release the pointer to the GIT interface and set the member variable to NULL.<br><br></li>
<li>
Do Step 2 for the interface pointers to <b>IDispenserManager</b>, <b>IHolder</b>, Resource Manager, and Free-Threaded Marshaler.</li>
</ol>
<p>
<a href="#resdispr_contents">Return to Contents</a></p>
<h3><a name="resdispr_dll"></a>Implement the DLL EntryPoint and Exports</h3>
<p>
There is one EntryPoint function called <b>DllMain</b> and four DLL export functions: <b>DllCanUnloadNow</b>, <b>DllGetClassObject</b>, <b>DllRegisterServer</b>, and <b>DllUnregisterServer</b>. The resource dispenser should implement them all. Normally you want to use the implementation generated by the ATL Wizard in Visual C++ 5.<i>x</i>.</p>
<p>
The ATL Application Wizard generates the following code:</p>
<pre><code>// ResDisp.cpp : Implementation of DLL EntryPoint and Exports.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "ResDisp.h"
#include "dlldatax.h"

#include "ResDisp_i.c"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL EntryPoint

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
 &nbsp; lpReserved;
#ifdef _MERGE_PROXYSTUB
 &nbsp; if (!PrxDllMain(hInstance, dwReason, lpReserved))
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
#endif
 &nbsp; if (dwReason == DLL_PROCESS_ATTACH)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; _Module.Init(ObjectMap, hInstance);
 &nbsp;&nbsp;&nbsp;&nbsp; DisableThreadLibraryCalls(hInstance);
 &nbsp; }
 &nbsp; else if (dwReason == DLL_PROCESS_DETACH)
 &nbsp;&nbsp;&nbsp;&nbsp; _Module.Term();
 &nbsp; return TRUE;&nbsp;&nbsp;&nbsp; // Okay
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
 &nbsp; if (PrxDllCanUnloadNow() != S_OK)
 &nbsp;&nbsp;&nbsp;&nbsp; return S_FALSE;
#endif
 &nbsp; return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
 &nbsp; if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
 &nbsp;&nbsp;&nbsp;&nbsp; return S_OK;
#endif
 &nbsp; return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// <b>DllRegisterServer</b> - adds entries to the system registry.

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
 &nbsp; HRESULT hRes = PrxDllRegisterServer();
 &nbsp; if (FAILED(hRes))
 &nbsp;&nbsp;&nbsp;&nbsp; return hRes;
#endif
 &nbsp; // registers object, typelib and all interfaces in typelib
 &nbsp; return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// <b>DllUnregisterServer</b> - removes entries from the system registry.

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
 &nbsp; PrxDllUnregisterServer();
#endif
 &nbsp; _Module.UnregisterServer();
 &nbsp; return S_OK;
}
</code></pre>
<p>
<a href="#resdispr_contents">Return to Contents</a></p>
<h3><a name="resdispr_appa"></a>Appendix A: Threading and Marshalling Issues</h3>
<h4>The resource dispenser as a singleton object</h4>
<p>
Since the Holder object assigned to the resource dispenser object is the one that maintains the pool of resources, you must have only one instance of the resource dispenser. Otherwise, many instances of the RD would imply more than one Holder object and, consequently, more than one pool of resources. Therefore, the RD must be a singleton object. This means that all client threads will use the same RD object.</p>
<p>
Care should be taken when implementing your RD class. The RD class has to be fully reentrant and thread-safe to be able to provide one single instance of the RD. Moreover, if you plan to provide the same Class factory instance for each calling thread, make sure that thread synchronization code is added to the implementation of the <b>DllGetClassObject</b> export function. Also your class factory itself needs to be carefully written so that it will return the same RD pointer for all its clients. For example, the reference count must be thread safe.</p>
<p>
Fortunately, ATL takes care of these issues with: the CComObjectRootEx template, the DECLARE_CLASSFACTORY_SINGLETON macro, and the CComModule class provided when you run the ATL COM Application Wizard and the ATL Object Wizard.</p>
<h4>Using the Free-threaded Marshaler</h4>
<p>
Supporting both threading models (STA and MTA) implies that by using standard marshalling to accomplish inter-thread marshalling would result in a performance hit that could be easily avoided. When marshalling the RD's interface pointer between different threads in the same process, the client thread should have access to the same address space where the pointer resides. Therefore, the client can call the interface directly. This is a gain in performance as opposed to calling the interface through a proxy, which would be the case with standard marshalling. However, when marshalling across processes, you should use standard marshalling.</p>
<p>
To easily accomplish this switch in marshalling, your RD should call the <b>CoCreateFreeThreadedMarsharler</b> function. This function will aggregate a free-threaded marshaller object to your RD's object. This object will perform either marshalling depending on the context in which the call is made.</p>
<h4>Using the Global Interface Table (GIT)</h4>
<p>
There is one problem when aggregating the free-threaded marshaller. Normally your RD object holds, in its member variables, interface pointers to other objects that reside in other processes or are not free-threaded. The problem becomes apparent when the RD makes any reference to these objects from a thread different to the one where these objects' pointers were stored. Thus, any such call will result in the error RPC_E_WRONG_THREAD or some incorrect result. Clearly, this will be a common scenario for resource dispensers since they hold pointers to at least their Resource Managers and probably other objects.</p>
<p>
To solve this problem, you should use a Global Interface Table object. It allows any apartment (STA or MTA) in a process to get access to an interface implemented on an object in any other apartment in the process. Thus, by using both the free-threaded marshaller and the GIT, your RD will have a better performance than using standard marshalling as the inter-thread marshalling mechanism.</p>
<p>
<a href="#resdispr_contents">Return to Contents</a></p>
<h3><a name="resdispr_appb"></a>Appendix B: Registry Entries</h3>
<p>
The following code is an example of the registry entries needed for a resource dispenser. They are no different from those of any other COM component. If you were planning to have data stored in the registry, this would be the place to make the initial entries with their default values.</p>
<pre><code>HKCR
{
 &nbsp; ResDisp.ResDisp.1 = s 'ResDisp Class'
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CLSID = s '{8A7339E4-5397-11D0-B151-00AA00BA3258}'
 &nbsp; }
 &nbsp; ResDisp. ResDisp = s ' ResDisp Class'
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; CurVer = s ' ResDisp. ResDisp.1'
 &nbsp; }
 &nbsp; NoRemove CLSID
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; ForceRemove {8A7339E4-5397-11D0-B151-00AA00BA3258} = s ' ResDisp Class'
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProgID = s ' ResDisp. ResDisp.1'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VersionIndependentProgID = s ' ResDisp. ResDisp '
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InprocServer32 = s '%MODULE%'
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ThreadingModel = s 'Both'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
}
</code></pre>
<p>
<a href="#resdispr_contents">Return to Contents</a></p>
</BODY>
</HTML>
