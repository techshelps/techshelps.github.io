<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Remote Server Connectivity</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_remote"></a>Remote Server Connectivity</h1>
<p>
<b><i>A First Look at Remote Data Objects and the RemoteData Control</i></b></p>
<p>
William R. Vaughn<br>
Microsoft Corporation</p>
<p>
February 1996</p>
<h2>Abstract</h2>
<p>
More and more Visual Basic® developers are creating front-end applications to remote database servers. In previous versions of Visual Basic, the options available were limited to either Jet Data Access Objects (DAO) or an application programming interface (API) –based interface such as VBSQL. Visual Basic Version 4.0 Enterprise Edition now includes an entirely new way to access data in intelligent servers such as Microsoft® SQL Server: the Remote Data Objects (RDO). Remote Data Objects implement a set of objects to deal with the special requirements of remote data access. RDO implements a thin code layer over the Open Database Connectivity (ODBC) API and driver manager that establishes connections, creates result sets and cursors, and executes complex procedures using minimal workstation resources. Because bound controls sometimes play an important role in these applications, the Enterprise Edition also includes the <b>RemoteData</b> control that takes on the same functionality as the <b>Data</b> control.</p>
<p>
This article provides an overview of the features of the Remote Data Objects programming model and the <b>RemoteData</b> control. This information can help you make a decision regarding which data access programming model to use in your client/server application.</p>
<h2>Introduction</h2>
<p>
With Remote Data Objects (RDO) and the <b>RemoteData</b> control, your applications can access Open Database Connectivity (ODBC) data sources without using a local query processor. This can mean significantly higher performance and more flexibility when accessing remote database engines. Although you can access any ODBC data source with RDO and the <b>RemoteData</b> control, these features are designed to take advantage of database servers, such as Microsoft® SQL Server and Oracle, that use sophisticated query engines.</p>
<p>
By using RDO, you can create simple cursorless result sets, or more complex cursors—even using SQL Server "server-side" cursors. You can also run queries that return any number of result sets, or execute stored procedures that return result sets with or without output parameters and return values. You can limit the number of rows returned or updated and monitor all of the messages and errors generated by the remote data source without compromising the executing query. RDO also permits either synchronous or asynchronous operation so your application doesn't need to be blocked while lengthy queries are executed.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;RDO and the <b>RemoteData</b> control are features of Visual Basic® Version 4.0, Enterprise Edition. You cannot develop code or use the RDO object library or <b>RemoteData</b> control in the Professional or Standard Editions of Visual Basic.</p>
<h3>Client/Server Design Goals</h3>
<p>
RDO and the <b>RemoteData</b> control can help you meet a specific set of client/server requirements. By using these remote data access features, you can:
<ul type=disc>
<li>
<b>Gain high-performance data access</b> against remote ODBC data sources. The ability to quickly retrieve the results from complex queries is a goal of every data access application. RDO provides a level of performance rivaled only by the ODBC application programming interface (API) and VBSQL API programming models. By leveraging the remote data engine, RDO greatly improves response time and user productivity.<br><br></li>
<li>
<b>Manage return codes and both input and output parameters</b> from stored procedures. Output parameters are the only way to extract information from an Oracle stored procedure, and are used heavily for singleton queries and many administrative functions. In many cases, you cannot determine if a stored procedure completed successfully without accessing the procedure's return value. RDO supports access to each of these parameters through the <b>rdoParameter</b> object.<br><br></li>
<li>
<b>Manage multiple result sets.</b> By using a single query that returns several sets of related results, you can use the query processor and system resources more efficiently. You can improve performance by running a single query to gather data to fill multiple data-driven list boxes and menus. In addition, by combining a row-count query with a SELECT query, you can accurately set up scroll bars and progress status bars.<br><br></li>
<li>
<b>Limit the number of returned rows.</b> In situations where users might select more rows than it is practical to handle, RDO implements a query governor to limit the number of rows returned from any data source. This way, you can predict query response time and more easily manage the workstation or server resources required to maintain cursor keysets.<br><br></li>
<li>
<b>Pre-set the fatal-error threshold.</b> Data sources generate a variety of informational and low-severity messages in addition to high-severity messages and error notifications. It is important to differentiate between errors considered fatal that should cause the query to be abandoned, and errors that should be reported, but not considered fatal. With RDO, you can set an error threshold that sets the severity of error that constitutes a fatal error.<br><br></li>
<li>
<b>Use server-side cursors.</b> Some servers, such as Microsoft SQL Server, support cursor keysets that are created on the server, instead of on the workstation. Under the right conditions, this type of cursor management can significantly improve performance. You can choose to use server-side cursors when they are available.<br><br></li>
<li>
<b>Execute queries asynchronously.</b> If a query takes an extended period of time to run, you should have the option of either executing code while the query is being processed or canceling the query in progress. RDO provides an asynchronous query option that you can use when executing any query, as well as a way to cancel an asynchronous query.<br><br></li>
<li>
<b>Expose underlying ODBC handles.</b> In cases where you need more flexibility or control than is available in the object model, you should have a way to directly access the data source. RDO provides access to the ODBC environment, connection, and statement handles.<br><br></li>
<li>
<b>Reduce memory footprint.</b> In many cases, the system that hosts a client/server front-end application is limited in RAM capacity. Because of this, it is important that applications designed for these types of systems economize on their use of RAM and other workstation system resources. The RDO memory footprint is dramatically smaller than other programming models, and it does not require the use of local memory or disk space for its lowest-level cursors.</li>
</ul>
<h3>RDO Compared to Microsoft Jet</h3>
<p>
Basically, you can use the Remote Data Objects in the same way you use the Microsoft Jet database engine Data Access Objects (DAO), and the <b>RemoteData</b> control is similar to the <b>Data</b> control. With RDO, you can submit queries, create a result set or cursor, and process the results from the query using database-independent object-oriented code. Using the <b>RemoteData</b> control, you can create a form containing the same bound controls recognized by the <b>Data</b> control, and process a result set with little or no code. Table 1 lists RDO objects and their equivalent DAO objects.</p>
<p class=label>
<b>Table 1. RDO Objects and Equivalent DAO Objects</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=46%><b>RDO Object</b></td>
<td class=label width=54%><b>Equivalent DAO Object</b></td>
</tr>
<tr valign=top>
<td width=46%>rdoEngine</td>
<td width=54%>DBEngine</td>
</tr>
<tr valign=top>
<td width=46%>Not implemented</td>
<td width=54%>User, Group</td>
</tr>
<tr valign=top>
<td width=46%>rdoEnvironment </td>
<td width=54%>Workspace</td>
</tr>
<tr valign=top>
<td width=46%>rdoConnection</td>
<td width=54%>Database</td>
</tr>
<tr valign=top>
<td width=46%>rdoTable</td>
<td width=54%>TableDef</td>
</tr>
<tr valign=top>
<td width=46%>Not Implemented</td>
<td width=54%>Index</td>
</tr>
<tr valign=top>
<td width=46%>rdoResultset</td>
<td width=54%>Recordset</td>
</tr>
<tr valign=top>
<td width=46%> &nbsp; Not implemented</td>
<td width=54%> &nbsp; Table-type</td>
</tr>
<tr valign=top>
<td width=46%> &nbsp; Keyset-type</td>
<td width=54%> &nbsp; Dynaset-type</td>
</tr>
<tr valign=top>
<td width=46%> &nbsp; Static-type</td>
<td width=54%> &nbsp; Snapshot-type</td>
</tr>
<tr valign=top>
<td width=46%> &nbsp; Dynamic-type</td>
<td width=54%> &nbsp; (none)</td>
</tr>
<tr valign=top>
<td width=46%> &nbsp; Forward-only – type</td>
<td width=54%> &nbsp; Similar to Forward-Only Snapshot</td>
</tr>
<tr valign=top>
<td width=46%>rdoColumn</td>
<td width=54%>Field</td>
</tr>
<tr valign=top>
<td width=46%>rdoPreparedStatement</td>
<td width=54%>QueryDef</td>
</tr>
<tr valign=top>
<td width=46%>rdoParameter</td>
<td width=54%>Parameter</td>
</tr>
</table><br>
<p>
RDO refers to table <i>rows</i> instead of <i>records</i>,<i> </i>and<i> columns</i> instead of<i> fields</i>—the generally accepted terminology for relational databases. The data returned from a query is in the form of <i>result sets</i>, which can contain zero or more data rows composed of one or more columns.</p>
<p>
Some DAO objects, methods, and properties are designed to implement and support the Indexed Sequential Access Method (ISAM) structure of Jet and installable ISAM databases. For example, you can use the <b>Index</b> object and the <b>Seek</b> method to manage ISAM indexes and locate rows based on those indexes. Because the RDO and relational databases manage indexes in an entirely different manner, these objects and methods are not needed.</p>
<p>
Jet also supports the creation and modification of the database schema through DAO methods and properties. RDO does not support any type of schema modification because this is fully supported in the tools and utilities provided with the server systems. You can still run make-table queries or execute action queries that create, modify, or delete databases and tables using native Structured Query Language (SQL, pronounced "sequel") statements. You can also execute complex stored procedures that manage the database schema or perform maintenance operations that are not possible with DAO.</p>
<h2>Using Remote Data Objects</h2>
<p>
In most respects, Remote Data Objects are used like Jet Data Access Objects. This means that, for the most part, you can take your existing applications that use DAO and the <b>Data</b> control and convert them to use RDO and the <b>RemoteData</b> control with a minimum number of changes. There are some differences, however, because of the way RDO is implemented and designed for use in relational databases. RDO has no query processor; it depends on the data source to process all queries and create the result sets. The data objects themselves are built from the result sets and cursors returned by the ODBC driver.</p>
<p>
You can use the <b>RemoteData</b> control to create RDO objects, just as you can use the <b>Data</b> control to create Jet DAO objects. You can also create result sets using RDO methods and pass these to the <b>RemoteData</b> control for management and editing by associated bound controls.</p>
<h3>Understanding the RDO Object Model</h3>
<p>
RDO objects and collections provide a framework for using code to create and manipulate components of a remote ODBC database system. Objects and collections have properties that describe the characteristics of database components and methods that you use to manipulate them. Using the containment framework, you create relationships among objects and collections, and these relationships represent the logical structure of your database system.</p>
<p>
With the exception of the <b>rdoEngine</b> object, each of these objects is maintained in an associated collection. When RDO is initialized on first access, RDO automatically creates an instance of the <b>rdoEngine</b> and the default <b>rdoEnvironments</b>(0).</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;RDO is only supported on 32-bit operating systems (Windows® 95 and Windows NT®). To use the Remote Data Objects, you must set a reference to the Microsoft Remote Data Object 1.0 object library in the Visual Basic References dialog box.</p>
<p>
To establish a physical link to an ODBC data source and a specific database, your code must create an <b>rdoConnection</b> object. You can define the data source by using the <b>rdoRegisterDataSource</b> method in code or by using the ODBC Data Sources settings in the Windows Control Panel. The database associated with the <b>rdoConnection</b> is determined by connect string arguments or the default database assigned to the user.</p>
<p>
Basically, there are two approaches to executing queries and retrieving result sets:
<ul type=disc>
<li>
Use queries that are run only once. In this case, use the <b>OpenResultset</b> or <b>Execute</b> method to execute fixed SQL queries against the <b>rdoConnection</b> object to create <b>rdoResultset</b> objects or execute action queries.<br><br></li>
<li>
Use queries that are run more than once and that might require parameters. Use the <b>CreatePreparedStatement</b> method to create an <b>rdoPreparedStatement</b> object that can be reused as needed, and that allows changes to one or more parameters each time the query is executed. Once the <b>rdoPreparedStatement</b> is created, use the <b>OpenResultset</b> or <b>Execute</b> method against the <b>rdoPreparedStatement</b> to create an <b>rdoResultset</b> or execute an action query. To change the query parameters, change the <b>rdoParameter</b> object settings.</li>
</ul>
<p>
Using arguments of the <b>OpenResultset</b> method or properties of the <b>rdoPreparedStatement</b> object, you can specify the type of cursor (if any) and other attributes of the <b>rdoResultset</b> object.</p>
<p>
You can use the <b>rdoTable</b> object to map the tables and columns of a data source or create <b>rdoResultset</b> objects from all rows in the table—which is not recommended with RDO. There are very few cases in which it is necessary to retrieve all rows from a database table into workstation memory. Many remote database tables are far too large to be downloaded to the workstation.</p>
<p>
To reposition the current row pointer in an <b>rdoResultset</b>, use the <b>Move</b> methods, or the <b>AbsolutePosition</b> and <b>PercentPosition</b> properties. You can also save and use bookmarks to position to selected locations in an <b>rdoResultset</b>. To locate a value in an <b>rdoResultset</b>, refine the WHERE clause and resubmit the query.</p>
<h3>The rdoEngine Object</h3>
<p>
The <b>rdoEngine</b> object represents the remote data source and is created automatically when you make any reference to RDO or the <b>RemoteData</b> control. As the top-level object, it contains all other objects in the hierarchy of Remote Data Objects. The <b>rdoEngine</b> object is a predefined object, therefore you can't create additional <b>rdoEngine</b> objects, and it isn't an element of any collection. You can use the <b>rdoEngine</b> to set data source parameters and the default <b>rdoEnvironment</b>.</p>
<p>
Even though the <b>rdoEngine</b> is shared among applications that use it, the <b>rdoEngine</b> default properties are not shared between multiple applications that are using it. Each instance of your application is provided with its own set of default values that have no effect on other applications that also use RDO or the <b>RemoteData</b> control.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Adding the <b>RemoteData</b> control to your Toolbox does not automatically set a reference to the Microsoft Remote Data Object 1.0 object library. To use the <b>rdoEngine</b> and Remote Data Objects, you must set a reference to the Microsoft Remote Data Object 1.0 object library in the References dialog box (available from the Tools menu); otherwise, you will get compilation errors.</p>
<p>
For more information, search Visual Basic Books Online or online Help for "rdoEngine object".</p>
<h4>Initializing rdoEngine Properties</h4>
<p>
When you create new <b>rdoEnvironment</b>, <b>rdoConnection</b>, or <b>rdoResultset</b> objects, the characteristics of the new objects are determined by the arguments in the <b>rdoCreateEnvironment</b> or <b>OpenResultset</b> method or by the default values in the default properties of the <b>rdoEngine</b>. These properties are listed in Table 2.</p>
<p class=label>
<b>Table 2. Properties of the rdoEngine</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Property</b></td>
<td class=label width=51%><b>Specifies</b></td>
<td class=label width=22%><b>Default</b></td>
</tr>
<tr valign=top>
<td width=27%>rdoDefaultCursorDriver</td>
<td width=51%>Cursor location (ODBC or server-side)</td>
<td width=22%>rdUseIfNeeded</td>
</tr>
<tr valign=top>
<td width=27%>rdoDefaultPassword</td>
<td width=51%>User password</td>
<td width=22%>"" (empty string)</td>
</tr>
<tr valign=top>
<td width=27%>rdoDefaultUser</td>
<td width=51%>User name</td>
<td width=22%>"" (empty string)</td>
</tr>
<tr valign=top>
<td width=27%>rdoDefaultErrorThreshold</td>
<td width=51%>Error severity above which errors are fatal</td>
<td width=22%>-1 (disabled)</td>
</tr>
<tr valign=top>
<td width=27%>rdoDefaultLoginTimeout</td>
<td width=51%>Time to wait before abandoning connection attempt</td>
<td width=22%>15 seconds</td>
</tr>
</table><br>
<p>
You can change any of these default value properties before creating new <b>rdoEnvironment</b>, <b>rdoConnection</b>, or <b>rdoResultset</b> objects. However, <b>rdoEnvironments</b>(0) is created using the defaults shown in Table 2. This is because it is created automatically on the first reference to RDO or the <b>RemoteData</b> control. If the default values are not appropriate for your application, you can change the properties of <b>rdoEnvironments</b>(0) or the <b>rdoEngine</b> before opening a connection.</p>
<h4>Registering a Data Source</h4>
<p>
All RDO operations require that you first connect to a suitable ODBC data source. A data source can be any database system or file that is supported with an ODBC driver. You can access any ODBC data source with RDO; however, a number of optimizations have been made to support specific features of Microsoft SQL Server and Oracle databases. Because of this, some features provided by RDO may not be suitable for use with ISAM or other flat-file data sources.</p>
<p>
Before you can access a data source, you must first use the ODBC Data Sources dialog box in the Windows Control Panel to create a data source entry in the Windows Registry. You can also use the <b>rdoRegisterDataSource</b> method to register a new data source. Registering a data source is a one-time operation that should take place when the application is first installed with Setup.</p>
<h3>Creating an rdoEnvironment</h3>
<p>
If your application expects to support more than one transaction scope, or separate user name and password contexts, you should use the <b>rdoCreateEnvironment</b> method to create a new <b>rdoEnvironment</b> object with specific user name and password values. This method accepts a unique name, a user name, and password. If the name you choose matches the name of an existing member of the <b>rdoEnvironments</b> collection, a trappable error results.</p>
<p>
The default <b>rdoEnvironments</b>(0) is created automatically when the <b>RemoteData</b> control is initialized, or when the first RDO object is referenced in code. The <b>Name</b> property of <b>rdoEnvironments</b>(0) is "Default_Environment<code>"</code>. The user name and password for <b>rdoEnvironments</b>(0) are both zero-length strings ("").</p>
<p>
Newly created <b>rdoEnvironment</b> objects are automatically appended to the <b>rdoEnvironments</b> collection if you provide a unique name. You can also use a zero-length string for the <i>name</i> argument of the <b>rdoCreateEnvironment</b> method. In this case, the new <b>rdoEnvironment</b> is not appended to the <b>rdoEnvironments</b> collection.</p>
<h4>Logon Information</h4>
<p>
The user name and password information from the <b>rdoEnvironment</b> is used to establish the connection if these values are not supplied in the <i>connect</i> argument of the <b>OpenConnection</b> method, or in the <b>Connect</b> property of the <b>RemoteData</b> control. For example, the default user name (Fred) and password (Blond) can be used to establish a connection in the En environment:</p>
<pre><code>Dim En As rdoEnvironment
Set En = rdoCreateEnvironment("", "Fred", "Blond")
</code></pre>
<p>
An <b>rdoEnvironment</b> object logically corresponds to an ODBC environment. You can refer to an <b>rdoEnvironment</b> object by using the ODBC API functions, accessible through the <b>rdoEnvironment</b> object's <b>hEnv</b> property. However, because ODBC allows only one environment handle per application, the actual lifetime of the ODBC environment handle is tied to the lifetime of the <b>rdoEngine</b>. Actual ODBC connections take place only when an <b>rdoConnection</b> object is opened.</p>
<h4>Transaction Scope</h4>
<p>
The <b>rdoEnvironment</b> also determines transaction scope. Committing an <b>rdoEnvironment</b> transaction commits all open <b>rdoConnection</b> databases with pending transactions (which are opened on that <b>rdoEnvironment</b> object, and their corresponding open <b>rdoResultset </b>objects). This does not imply a two-phase commit operation—it simply means that individual <b>rdoConnection</b> objects are instructed to commit any pending transactions.</p>
<p>
Use the <b>rdoEnvironment</b> object to start an additional connection. In an <b>rdoEnvironment</b>, you can open multiple databases, manage transactions, and establish security based on user names and passwords. For example, you can:
<ul type=disc>
<li>
Create an <b>rdoEnvironment</b> object using the <b>Name</b>, <b>Password</b>, and <b>UserName</b> properties to establish a named, password-protected environment. The environment creates a scope in which you can open multiple connections and conduct one instance of ODBC transactions.<br><br></li>
<li>
Use the <b>OpenConnection</b> method to open one or more existing connections in that <b>rdoEnvironment</b>.<br><br></li>
<li>
Use the <b>BeginTrans</b>, <b>CommitTrans</b>, and <b>RollbackTrans</b> methods to manage ODBC transaction processing within an <b>rdoEnvironment</b>.<br><br></li>
<li>
Use several <b>rdoEnvironment</b> objects to conduct multiple, simultaneous, independent, and overlapping transactions.<br><br></li>
<li>
Use the <b>Close</b> method to terminate an environment and the connection.</li>
</ul>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The ODBC transaction model does not support nested transactions. That is, you cannot execute a second <b>BeginTrans</b> method before the previous transaction is either committed or rolled back. However, if your ODBC data source supports it, you can use SQL statements to execute nested transactions.</p>
<p>
When you use ODBC transactions, all databases in the specified <b>rdoEnvironment</b> are affected—even if multiple <b>rdoConnection</b> objects are opened in the <b>rdoEnvironment</b>. For example, if you use a <b>BeginTrans</b> method against one of the databases visible from the connection, you should update several rows in the database, and then delete rows in another <b>rdoConnection</b> database. When you use the <b>RollbackTrans</b> method, both the update and delete operations are rolled back. You can create additional <b>rdoEnvironment</b> objects to manage transactions independently across <b>rdoConnection</b> objects. Transactions executed by multiple <b>rdoEnvironment</b> objects are serialized and are not atomic operations. Because of this, their successes or failures are not interdependent.</p>
<h3>Establishing a Connection</h3>
<p>
Once a data source is identified, you use the <b>OpenConnection</b> method to create an <b>rdoConnection</b> object, with which you establish a physical link to the data source. To establish a connection, the data source entry must identify the network location of the data source, as well as the driver type. Your code provides a number of additional parameters used to log the user onto the data source. By choosing an appropriate <i>prompt</i> argument, you can program the ODBC driver manager to prompt the user for missing arguments and prevent the use of alternate arguments. The <b>OpenConnection</b> method accepts the following arguments:
<ul type=disc>
<li>
The <i>dsName </i>argument indicates the name of the registered data source. You can reference the new <b>rdoConnection</b> object using the data source name (DSN) or the <b>rdoConnection</b>'s ordinal position in the <b>rdoConnections</b> collection.<br><br></li>
<li>
The <i>prompt</i> argument indicates if the user can supply arguments to ODBC connect dialogs. If you do not want the user to supply a different data source name, user name, password, or default database, use the <b>rdDriverNoPrompt</b> constant as the <i>prompt</i> argument.<br><br></li>
<li>
The <i>readonly</i> argument is set to <b>False</b> if the user expects to update data through the connection.<br><br></li>
<li>
The <i>connect</i> string supplies parameters to the ODBC driver manager. These parameters can include user name, password, default database, and DSN (which overrides the value provided in the <i>dsName</i> argument). Different ODBC data sources require different parameters.</li>
</ul>
<p>
For example, you can use the following code to establish a connection to a Microsoft SQL Server database with an existing data source name of MyRemote:</p>
<pre><code>Dim Cn As rdoConnection, En as rdoEnvironment, Conn As String
Set En = rdoEnvironments(0)
Conn$ = "DSN=MyRemote;UID=Holly;PWD=Huskador;DATABASE=MyDb;"
Set Cn = En.OpenConnection("", rdDriverPrompt, False, Conn$)
</code></pre>
<p>
The <i>dsName</i> argument of the <b>OpenConnection</b> method is an empty string. In this case, the data source name is taken from the <i>connect</i> argument.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Each of the RDO methods supports named arguments, so it is possible to specify each argument of the method using the <i>argument:=</i> syntax. For example, the previous <b>OpenConnection</b> method could be coded:</p>
<pre><code>Set Cn = En.OpenConnection(prompt:=rdDriverPrompt, _ 
 &nbsp; readonly:=False,Connect:=Conn$)
</code></pre>
<p>
If you choose to use domain-managed security, you should use empty arguments for the UID and PWD parameters of the <i>connect</i> argument. This type of security passes your Windows NT logon ID and password to the data source. If your database administrator has implemented integrated or mixed security, this technique should permit you to log on to the data source—assuming you have been granted permission to do so. For example, using the preceding sample code, a domain-managed security <i>connect</i> argument is coded as follows:</p>
<pre><code>Conn$ = "DSN=MyRemote;UID=;PWD=;DATABASE=MyDb;"
</code></pre>
<p>
You might be unable to establish a connection for a variety of reasons, including lack of permission on the data source, improper network connection or permissions, or a missing or disabled data source. When connecting to Microsoft SQL Server, Oracle, or other data sources, the number of simultaneous connections permitted might be limited by license agreements, resource constraints, or by database settings. Check with your server administrator if you suspect that all available connections are allocated.</p>
<p>
Once the <b>rdoConnection</b> object is created, you can use it to:
<ul type=disc>
<li>
Create an rdoResultset or rdoPreparedStatement object using the OpenResultset or CreatePreparedStatement method, respectively.<br><br></li>
<li>
Examine database tables and the columns of each table by using the rdoTable and rdoColumn objects in the rdoConnections(0).rdoTables and rdoTables(<i>n</i>).rdoColumns collection.<br><br></li>
<li>
Start, commit, or roll back transactions using the BeginTrans, CommitTrans, and RollbackTrans methods.<br><br></li>
<li>
Disconnect from the data source and free its resources using the Close method.</li>
</ul>
<p>
When using remote data objects against a SQL Server that has case-sensitivity enabled, if your table name contains any upper-case letters the Update method will fail with an 'invalid object &lt;table name&gt;' error. This will occur only when using the ODBC Cursor Library against a case-sensitive SQL Server. To work around this problem you have several options:
<ul type=disc>
<li>
Remove case-sensitivity from the SQL Server.<br><br></li>
<li>
Make your table names all lower-case.<br><br></li>
<li>
Use server-side cursors.</li>
</ul>
<p>
If the above options are not available, you can issue update SQL statements to the server using the <b>Execute</b> method.</p>
<p>
This does not affect Oracle servers.</p>
<h3>Submitting a Query</h3>
<p>
To extract data from the data source, use the <b>OpenResultset</b> method against an <b>rdoConnection</b> object. You can also create <b>rdoResultset</b> objects by using parameterized queries with <b>rdoPreparedStatement.OpenResultset</b>.</p>
<p>
When you use the <b>OpenResultset</b> method against an <b>rdoConnection</b> or <b>rdoPreparedStatement</b>, and assign the result to an existing <b>rdoResultset</b> object, the existing object is maintained and a new <b>rdoResultset</b> object is appended to the <b>rdoResultsets</b> collection. When performing similar operations using the Microsoft Jet database engine, existing recordsets are automatically closed when the variable is assigned, and no two <b>Recordsets</b> collection members can have the same name. For example, using RDO:</p>
<pre><code>Dim rs as rdoResultset
Dim cn as rdoConnection

Set cn = OpenConnection....
Set rs = cn.OpenResultset("Select * from Authors", rdOpenStatic)
Set rs = cn.OpenResultset("Select * from Titles", rdOpenDynamic)
</code></pre>
<p>
This code opens two separate <b>rdoResultset</b> objects; both are stored in the <b>rdoResultsets</b> collection. After this code runs, the second query—which is stored in <b>rdoResultsets</b>(1)—is assigned to the <b>rdoResultset</b> variable <i>rs</i>. The first query is available and its cursor is still available by referencing <b>rdoResultsets</b>(0). Because of this implementation, more than one member of the <b>rdoResultsets</b> collection can have the same name.</p>
<p>
This behavior permits you to maintain existing <b>rdoResultset</b> objects, which are maintained in the <b>rdoResultsets</b> collection, or close them as needed. In other words, you must explicitly close any <b>rdoResultset</b> objects that are no longer needed. Simply assigning another <b>rdoResultset</b> to a <b>rdoResultset</b>-type variable has no affect on the existing <b>rdoResultset</b> formerly referenced by the variable. Note that the procedures and other temporary objects created to manage the <b>rdoResultset</b> are maintained on the remote server as long as the <b>rdoResultset</b> remains open.</p>
<p>
If you write an application that does not close each <b>rdoResultset</b> before opening additional rdoResultset objects, the number of procedures maintained in TempDB or elsewhere on the server increase each time another <b>rdoResultset</b> object is opened. Over time, this behavior can overflow the capacity of the server or workstation resources.</p>
<p>
The <b>OpenResultset</b> method accepts the following arguments when you use it with an <b>rdoConnection</b> object:
<ul type=disc>
<li>
The <i>source</i> argument specifies an SQL query, the name of an <b>rdoPreparedStatement </b>or <b>rdoTable</b> object, or a stored procedure name preceded by "EXEC".<br><br></li>
<li>
The <i>type</i> argument specifies the type of cursor. If you do not indicate a cursor type, a forward-only type of result set is created. You can also specify keyset, dynamic, or static cursor types.<br><br></li>
<li>
The <i>locktype</i> argument specifies the type of locking used to support concurrency. The default is <b>rdReadOnly</b>.<br><br></li>
<li>
The <i>options</i> argument was enhanced at the last minute. It either specifies if the query should be executed asynchronously <i>rdAsyncEnable</i> or if the ODBC driver manager should create a procedure before executing the query (<i>rdExecDirect</i>). The default is no options enabled. In this case, the query is executed synchronously and the driver manager creates a stored procedure to execute the query.</li>
</ul>
<p>
In some cases, when you use the <b>OpenResultset</b> method and the SQL statement specified contains invalid SQL syntax, the ODBC driver fails with an untrappable general protection fault (GPF). Not all syntax errors cause this. The following SQL query <i>does</i> cause this type of GPF:</p>
<pre><code>" Select * from authors where name '%' (?) '%'&nbsp; "
</code></pre>
<p>
To avoid this problem, verify all SQL statements for accuracy and correct syntax before using them in your application. In addition, do not permit users to enter SQL statements directly, because these might be prone to failure.</p>
<h4>Choosing a Cursor Type</h4>
<p>
The <b>rdoResultset</b> is returned either as a forward-only type of result set or as one of the three types of cursors: static, keyset, or dynamic—based on the type available and the capability of the ODBC driver manager and data source driver. Using the <b>CursorDriver</b> property of the <b>rdoEnvironment</b> object, you can also choose where the cursor keyset will be created—on the workstation or on the server.</p>
<p>
<b>Forward-Only Result Sets</b></p>
<p>
In cases where you need to retrieve data quickly with the least amount of overhead, use a forward-only type of <b>rdoResultset</b>. This type of result set can be updatable, but it only exposes one row at a time. No cursor keyset is created, and data values are not updated as they change on the data source. However, because of its efficiency, it might be faster to rebuild a forward-only type of <b>rdoResultset</b> than to build and maintain a keyset type of <b>rdoResultset</b>.</p>
<p>
<b>Static Cursors</b></p>
<p>
A static-type <b>rdoResultset</b> is similar to a Jet snapshot-type <b>Recordset</b> object. Static cursor data appears to be static. The membership, order, and values in the result set used by a static cursor are generally fixed when the cursor is opened. Rows updated, deleted, or inserted by other users (including other cursors in the same application) are not detected by the cursor until it is closed and reopened.</p>
<p>
<b>Keyset Cursors</b></p>
<p>
A keyset-type <b>rdoResultset</b> is similar to a Jet dynaset-type <b>Recordset</b> object. A key is built and saved for each row in the cursor and stored either on the client workstation or on the server machine. When you access each row, the key is used to fetch the current data values from the data source. In a keyset-driven cursor, membership is frozen once the keyset is fully populated, therefore, additions or updates that affect membership are not made a part of the cursor until it is rebuilt.</p>
<p>
On some servers, modifications or additions made directly to keyset cursors using the <b>AddNew</b> and <b>Edit</b> methods are included in the result set, but additions or modifications made using <b>Execute</b> do not affect the cursor. Consult your server manual for details.</p>
<p>
To build a keyset-driven cursor, you must provide sufficient resources on the client or server to hold the keys and a block of buffered data rows.</p>
<p>
<b>Dynamic Cursors</b></p>
<p>
A dynamic-type <b>rdoResultset</b> is identical to a keyset-driven cursor except that membership is not frozen. Because RDO constantly checks that all qualified rows are included in the membership, this type of cursor carries the largest burden of overhead. However, a dynamic cursor may be faster to initiate than a keyset cursor, because the keyset cursor carries the overhead of building the initial keyset.</p>
<p>
When a keyset-type or static-type <b>rdoResultset</b> is first created, the <b>RowCount</b> property is set to the number of rows in the result set if rows are returned, 0 if no rows are returned by the query, or -1 if <b>RowCount</b> is not available. <b>RowCount</b> is not applicable to dynamic cursors where the number of rows can change, or to forward-only result sets that expose only one row.</p>
<p>
<b>Sequencing Operations</b></p>
<p>
If there is an unpopulated <b>rdoResultset</b> pending on a data source that can only support a single operation on an <b>rdoConnection</b> object, you can neither create additional <b>rdoPreparedStatement</b> or <b>rdoResultset</b> objects, nor use the <b>Refresh</b> method on the <b>rdoTable</b> object until the <b>rdoResultset</b> is flushed, closed, or fully populated. For example, when using SQL Server 4.2 as a data source, you cannot create an additional <b>rdoResultset</b> object until you move to the last row of the current <b>rdoResultset</b> object. To populate the result set, use the <b>MoreResults</b> method to move through all pending result sets, or use the <b>Cancel</b> or <b>Close</b> method on the <b>rdoResultset</b> to flush all pending result sets.</p>
<p>
For more information, search Visual Basic Books Online or online Help for "rdoResultset object", "understanding cursors", and "OpenResultset method".</p>
<h4>Positioning the Current Row Pointer</h4>
<p>
At any given time, only one row in an <b>rdoResultset</b> is exposed for data retrieval or modification—the row addressed by the current row pointer. You can move the current row pointer by using the <b>Move</b> methods, or the <b>AbsolutePosition</b> and <b>PercentPosition</b> properties. The <b>rdoResultset</b> object supports bookmarks that can be used to save the current location in a <b>Variant</b> variable. You can subsequently go back to a saved location in the <b>rdoResultset</b> by setting the <b>Bookmark</b> property with a bookmark.</p>
<p>
When using the forward-only type of <b>rdoResultset</b> objects, you can only use the <b>MoveNext</b> method—not the <b>MovePrevious</b>, <b>MoveFirst</b>, or <b>Move</b> method with a negative argument.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This is a change from the documentation and help file, which says you can use any of the forward-moving methods on a Forward-Only type cursor. The ODBC driver does not support anything but the <b>MoveNext</b> method—not even <b>MoveLast</b>.</p>
<p>
When positioning the current row pointer, it is possible to go past either end of the result set or to a row that has been deleted. RDO may also leave the current row pointer positioned over an invalid row, as when a row is deleted. Be sure to check the <b>EOF</b> and <b>BOF</b> properties to determine if the current row is positioned beyond the end or beginning of the result set. When using the <b>Bookmark</b> property to reposition the current row, it is possible to go to a row that has been deleted by another user. If this occurs, a trappable error results.</p>
<p>
For more information, search Visual Basic Books Online or online Help for "BOF property", "EOF property", "AbsolutePosition property", "PercentPosition property", and "Move".</p>
<h4>Changing Data</h4>
<p>
You can use the <b>rdoResultset</b> object to change columns in a specific row, add a row, or delete a row. Data columns can be changed if the <b>Updatable</b> property is <b>True</b> for both the <b>rdoResultset</b> and <b>rdoColumn</b> objects.</p>
<p>
To change columns in a specific data row in the <b>rdoResultset</b>: 
<ol>
<li>
Position the pointer on the row using one of the <b>Move</b> methods or the <b>AbsolutePosition</b> or <b>PercentPosition</b> property.<br><br></li>
<li>
Use the <b>Edit</b> method to activate the row to be altered. All data is copied into a temporary row buffer.<br><br></li>
<li>
Provide a new value for each column that you need to modify.<br><br></li>
<li>
Use the <b>Update</b> method to save the row buffer to the data source. The current row is deleted and the buffered row replaces it.</li>
</ol>
<p>
If you move the current row pointer to another row before using the <b>Update</b> method, any changes are abandoned. You can also abandon an edit and refresh the current row by using the <b>Move</b> method with a 0 argument or by using the <b>CancelUpdate</b> method. After the edit, the current row pointer is positioned on the modified row—which might be located at the end of the <b>rdoResultset</b>. To revisit the row that was just changed, use the bookmark provided in the <b>LastModified</b> property.</p>
<p>
If you use the <b>BeginTrans</b> method, changes made to the database with the <b>Update</b> method are deferred until you use the <b>CommitTrans</b> method to save the changes, or the <b>RollbackTrans</b> method to discard the changes.</p>
<p>
In addition to changing columns in a specific row, you can add a row to an <b>rdoResultset</b>.</p>
<p>
To add a row to an <b>rdoResultset</b>:
<ol>
<li>
Use the <b>AddNew</b> method to create a row buffer to hold the new row to be added.<br><br></li>
<li>
Provide a new value for each column you need to modify.<br><br></li>
<li>
Use the <b>Update</b> method to save the row to the data source.</li>
</ol>
<p>
After the row is added, the current row pointer is positioned on the row that was current before the new row was added. You can use the <b>LastModified</b> bookmark to move to the newly added row at the end of the <b>rdoResultset</b>.</p>
<p>
Once you've added rows, you can also delete them from the result set.</p>
<p>
To delete a specific row in an <b>rdoResultset</b>:
<ol>
<li>
Position the pointer on the row using one of the <b>Move</b> methods or the <b>AbsolutePosition</b> or <b>PercentPosition</b> property.<br><br></li>
<li>
Use the <b>Delete</b> method to delete the row from the cursor (if any) and the data source.</li>
</ol>
<p>
Once a row is deleted, the current row is no longer valid, so you must reposition to another valid row in the <b>rdoResultset</b>.</p>
<h4>Managing Concurrency </h4>
<p>
You can control how the data source manages locking while you make changes to the data by changing the <i>LockType</i> option of the <b>OpenResultset</b> method. Table 3 describes the four types of locking.</p>
<p class=label>
<b>Table 3. Four LockType Options</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=19%><b>LockType option</b></td>
<td class=label width=81%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=19%> &nbsp; rdConcurLock</td>
<td width=81%>Pessimistic concurrency. This technique uses the lowest level of locking sufficient to ensure that the row can be updated. This option locks the row or the data page containing the row(s) as soon as the <b>Edit</b> or <b>AddNew</b> method is executed, and holds it until the <b>Update</b> method has written the changes to the data source.</td>
</tr>
<tr valign=top>
<td width=19%>rdConcurRowver</td>
<td width=81%>Optimistic concurrency using row versions. The ODBC cursor library and the data source compare row ID or TIMESTAMP values to determine if the row has changed.</td>
</tr>
<tr valign=top>
<td width=19%>rdConcurValues</td>
<td width=81%>Optimistic concurrency using row values. The ODBC cursor library and the data source compare data values.</td>
</tr>
<tr valign=top>
<td width=19%>rdReadOnly</td>
<td width=81%>(Default) The cursor is read-only. No updates are permitted.</td>
</tr>
</table><br>
<p>
When values or row versions are compared to test concurrency, the original row as it was prior to the <b>Edit</b> or <b>AddNew</b> method is compared with the row as it exists in the database prior to being changed by the <b>Update</b> method. If the row data changed in this timeframe, a trappable error results. At this point, your temporary row buffer is lost. To carry out the changes, you must refresh the current row using the <b>Move</b>0 technique, use the <b>Edit</b> or <b>AddNew</b> method, fill in the new values, and repeat the <b>Update</b> method again.</p>
<h4>Making Changes with Action Queries</h4>
<p>
An alternative to using the <b>Edit</b>, <b>AddNew</b>, <b>Delete</b>, and <b>Update</b> methods is to use the <b>Execute</b> method. By executing a SQL query that contains one or more UPDATE, INSERT, or DELETE statements, you can make changes to the database without using the RDO methods. Depending on the type of data source, and its ability to support complex multi-statement operations, these SQL statements can contain logic that performs so-called "make-table" or SELECT INTO queries that create new permanent or temporary tables, or perform other complex operations. You must manage the errors and concurrency yourself. You can also submit transaction statements that bind the operations into one or more atomic sets using the SQL syntax supported by your data source.</p>
<p>
The <b>Execute</b> method is not designed to execute queries that return rows. If you execute a stored procedure that performs a mix of "action" operations and row-returning operations, you must use the <b>OpenResultset</b> method and parse the result sets that are generated.</p>
<h4>Using Server-Side Cursors</h4>
<p>
If your data source supports server-side cursors, the remote database engine builds cursor keysets on the server and extends the SQL dialect to support creation and management of data using cursors. Microsoft SQL Server 6.0 supports server-side cursors, but not all data sources do. Use the <b>rdoDefaultCursorDriver</b> property of the <b>rdoEngine</b> or the <b>CursorDriver</b> property of the <b>rdoEnvironment</b> object to choose the type of cursor driver to use. Table 4 describes the options available with these properties.</p>
<p class=label>
<b>Table 4. Options Available to CursorDriver or rdoDefaultCursorDriver</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Option</b></td>
<td class=label width=79%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=21%>rdUseIfNeeded</td>
<td width=79%>(Default) The ODBC driver chooses the appropriate style of cursor and uses server-side cursors if available.</td>
</tr>
<tr valign=top>
<td width=21%>rdUseODBC</td>
<td width=79%>RDO will use the ODBC cursor library. This gives better performance for small result sets, but degrades quickly for larger result sets.</td>
</tr>
<tr valign=top>
<td width=21%>rdUseServer</td>
<td width=79%>Server-side cursors are always used if available.</td>
</tr>
</table><br>
<p>
Server-side cursors reduce the amount of memory and disk space required on the client machines, but shift that load to the server. For Microsoft SQL Server 6.0, cursor keysets are maintained in the TempDB database on the server, so it must be sized to meet the needs of additional temporary cursor keysets generated by multiple clients.</p>
<h4>Working with BLOB or Chunk Datatypes</h4>
<p>
Many DBMSs, including Microsoft SQL Server, support Binary Large Object (BLOB) data types. These types are most often used to store large amounts of text or image data. Due to limitations in the ODBC cursor library, special rules apply to the use of these kinds of data types when using ODBC cursors.</p>
<p>
The <b>ColumnSize</b> property on the <b>rdoColumn</b> object represents the actual length of the data in a BLOB column. When using the ODBC cursor library, this value will always be -1, indicating that the data length is not available. When using server-side cursors, the <b>ColumnSize</b> property will always return the actual data length of a BLOB column.</p>
<p>
To get the data from a BLOB column, the user must use the <b>GetChunk</b> methods, which take a number of bytes to retrieve at a time. When using server-side cursors, the user can pass the value of the <b>ColumnSize</b> property as the number of bytes to retrieve to get all the data at once. Because the <b>ColumnSize</b> property is not available when using the ODBC cursor library, the user should call <b>GetChunk</b> repeatedly until no more data is returned. Following is a code sample that shows how to do this:</p>
<pre><code>Dim s As String
Dim sTemp As String
Dim lColSize As Long

lColSize = MyResultset!MyBLOBColumn.ColumnSize
If lColSize = -1 Then
 &nbsp; ' Column size is not available.
 &nbsp; ' Loop getting chunks until no more data.
 &nbsp; sTemp = MyResultset!MyBLOBColumn.GetChunk(50)
 &nbsp; Do
 &nbsp;&nbsp;&nbsp;&nbsp; s = s &amp; sTemp
 &nbsp;&nbsp;&nbsp;&nbsp; sTemp = MyResultset!MyBLOBColumn.GetChunk(50)
 &nbsp; Loop While Len(sTemp) &gt; 0
Else
' Get all of it.
 &nbsp; If lColSize &gt; 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp; s = MyResultset!MyBLOBColumn.GetChunk(lColSize)
 &nbsp; End If

End If
</code></pre>
<p>
In addition, when using ODBC cursor library and BLOB data types, you must select at least one non-BLOB column in your result set so that RDO can use <b>SQLExtendedFetch</b> to retrieve the data. This would be the common case anyway, because you need to include a key field in the result set if you want to update the data.</p>
<h4>Setting Limits</h4>
<p>
You can limit the number of rows returned by a query by creating an <b>rdoPreparedStatement</b> and setting the <b>MaxRows</b> property. Once the query processor returns <b>MaxRows</b> rows, it stops working on the query. You can also limit the amount of time the query processor works on a query by setting the <b>QueryTimeout</b> property on the <b>rdoConnection</b> or <b>rdoPreparedStatement</b>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;When the SQL_MAX_ROWS ODBC statement option is set to a nonzero value, the maximum number of rows processed by Microsoft SQL Server is limited to <i>n</i> rows. This means that only <i>n</i> rows are returned by a query, or only <i>n</i> rows are inserted, updated, or deleted by an action query. SQL_MAX_ROWS is set indirectly by using the <b>rdoPreparedStatement</b> object's <b>MaxRows</b> property. If you share the <b>hStmt</b> created for an <b>rdoPreparedStatement</b> that has <b>MaxRows</b> set, the operations executed against the <b>hStmt</b> are also affected by the limitation imposed by SQL_MAX_ROWS on both the number of rows returned from a query and the number of rows processed in an action query. </p>
<p class=indent>
In addition, if you reuse an <b>rdoPreparedStatement</b> that has <b>MaxRows</b> set, the number of rows affected by any update, delete, or insert action query will be limited to <i>n</i> rows.</p>
<h4>Processing Multiple Result Sets</h4>
<p>
Any SQL statement can include multiple SELECT statements or stored procedures that invoke one or more SELECT statements. Each SELECT statement generates a result set that must be processed by your code or discarded before the RDO resources are released and the next result set is made available.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;When executing Remote Data Object (RDO) queries that return more than one set of results, you can use only the ODBC cursor drivers. The Microsoft SQL Server server-side cursors do not support result sets that return more than a single set of results. To enable the ODBC cursor driver, set the <b>rdoEnvironment</b> object's <b>CursorDriver</b> property to <b>rdUseODBC</b> before creating the cursor.</p>
<p>
Action queries also generate row-less result sets that must also be processed. For example, if you submit a query that includes four SELECT queries to populate four local <b>ListBox</b> controls, and a stored procedure that updates a table, your code must deal with at least five result sets. Because you might not know how many result sets can be generated by a stored procedure, your code must be prepared to process <i>n</i> sets of results.</p>
<p>
There are two approaches to executing queries with multiple result sets:
<ul type=disc>
<li>
Execute the <b>OpenResultset</b> directly against a connection.<br><br></li>
<li>
Use the <b>OpenResultset</b> against an <b>rdoPreparedStatement</b>.</li>
</ul>
<p>
Both are processed in similar ways, but if you use the <b>rdoPreparedStatement</b>, you can examine the <b>RowsAffected</b> property to determine the number of rows affected by action queries. Although it is possible to execute a multiple result set query using the <b>Execute</b> method, it is not possible to retrieve the rows affected from individual statements, and a trappable error results if any of the queries returns rows.</p>
<p>
<b>Multiple Result Sets: An Example</b></p>
<p>
This section takes you through a step-by-step procedure that demonstrates how to execute a query with multiple result sets by using the <b>rdoPreparedStatement</b>.
<ol>
<li>
Create your SQL statement and place it in a string variable—for instance, <i>MySQL</i>. For SQL Server, multiple statements must be separated by semi-colons.<pre><code>Dim MySQL As String
MySQL = "Select Name from Authors; "
MySQL = MySQL &amp; " Select City from Publishers; "
MySQL = MySQL &amp; " Update MyTable Set Age = 16 Where Name = 'Fred' "
</code></pre>
</li>
<li>
Use an existing <b>rdoPreparedStatement</b> from the <b>rdoPreparedStatements</b> collection, or create a new <b>rdoPreparedStatement</b> and set a variable declared as <b>rdoPreparedStatement</b> and multiple result sets to this object—in this case, <i>MyPs</i>. The example assumes an <b>rdoConnection</b> object (<b>Cn</b>) already exists. Although it is possible to pass the SQL statement to the <b>CreatePreparedStatement</b> method, this example sets the SQL property <i>after</i> creating an instance of the object. This technique is also used if the <b>rdoPreparedStatement</b> is already created and referenced by its name or ordinal number in the <b>rdoPreparedStatements</b> collection.<pre><code>Dim MyPs As rdoPreparedStatement
Set MyPs = Cn.CreatePreparedStatement("MyPS1", "")
MyPs.SQL = MySQL
</code></pre>
</li>
<li>
Execute the query by using the <b>OpenResultset</b> method against the <b>rdoPreparedStatement</b> object. If you do not need the extra properties and the ability to pass parameters to the query, you can use the <b>OpenResultset</b> method directly against the <b>rdoConnection</b> object. The arguments you use here affect all result sets fetched from this query. For example, if you need to use a cursor on the second result set, you must specify a cursor type when the first result set is opened.<pre><code>Dim MyRs As rdoResultset
Set MyRs = MyPs.OpenResultset(rdOpenForwardOnly, rdConcurReadOnly)
</code></pre>
</li>
<li>
You are now ready to process the first result set. Note that the <b>rdAsyncEnable</b> <i>options</i> argument was not set. Because of this, control is not returned to the application until the first row of the first result set is ready for processing. If the current <b>rdoResultset</b> contains rows, the <b>RowCount</b> property is set to a value &gt;0, and the <b>EOF</b> and <b>BOF</b> properties are both <b>False</b>. Depending on the driver and data source, the <b>RowCount</b> property returns either -1 to indicate that the number of rows is not available, or 0 to indicate that no rows were returned by the <b>rdoResultset</b>.<p class=tl>
The following example fills a <b>ListBox</b> control called NameList1 with the results of the query:</P></li>
</ol>
<pre><code>While Not MyRs.EOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Loop through all rows.
NameList1.AddItem = MyRs(0)&nbsp; ' Use the first column.
MyRs.MoveNext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Position to the next row in the result set.
Wend
</code></pre>
<ol>
<li>
The first result set is now at the end-of-file (<b>EOF</b>) position. Use the <b>MoreResults</b> method to activate the next result set. Once you execute <b>MoreResults</b>, the first set of rows is no longer available—even if you used one of the cursor options to create it.<pre><code>' Activate the next set of results.
If (MyRs.MoreResults) Then ...
</code></pre>
</li>
<li>
You are now ready to process the second result set. This example uses only the first few names and discards the remaining rows.<pre><code>' Loop through some rows.
Do While Not MyRs.EOF and MyRs(0) &lt; "B"
' Use the first column.
NameList1.AddItem = MyRs(0)
MyRs.MoveNext
Loop
' Activate the next set of results and discard remaining rows.
If (MyRs.MoreResults) Then ...
</code></pre>
</li>
<li>
You are now ready to process the last set of results. Because this is an UPDATE statement, there are no rows to be returned, but you can determine the number of rows affected by using the <b>RowsAffected</b> property. The <b>MoreResults</b> method is used for the last time to release all resources connected with this query.<pre><code>If MyPs.RowsAffected = 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp; MsgBox "No rows were updated"
End If
' Activate the next set of results.
If (MyRs.MoreResults) Then ...
</code></pre>
</li>
</ol>
<p>
When you use the <b>MoreResults</b> method against the last result set, it should return <b>False</b> and other resources required to process the query are released. At this point the <b>rdoPreparedStatement</b> object can be reused. If you use the <b>Close</b> method against the <b>rdoPreparedStatement</b>, the <b>rdoPreparedStatement</b> is removed from the <b>rdoPreparedStatements</b> collection.</p>
<h3>Creating Parameter Queries</h3>
<p>
If the SQL query you need to execute includes one or more parameters, it is necessary to create a new <b>rdoPreparedStatement</b> or use an existing <b>rdoPreparedStatement</b> to run the query. In addition, the SQL statement you submit must use ODBC SQL syntax that includes special arguments that act as placeholders for input and output query parameters. RDO parses these parameters, which you can manipulate with the <b>rdoParameter</b> objects.</p>
<p>
You can use a parameter as either an input, output, or both input and output parameter. For example, to execute the sp_password procedure (which can be used in Microsoft SQL Server systems to change a user's password), use the Transact-SQL statement as follows:</p>
<pre><code>execute sp_password clyde, framis
</code></pre>
<p>
This procedure query accepts two input parameters and passes back a return value. You could use the <b>Execute</b> method to run this query, but the return value would be lost. To capture the return value, and create an <b>rdoPreparedStatement</b> that can be used repeatedly to change user passwords, write code like the following:</p>
<pre><code>Dim CPw As rdoPreparedStatement, QSQL As String
QSQL$ = "{ ? = call sp_password (?, ?) }"
</code></pre>
<p>
The ODBC syntax for the parameter query uses question marks as placeholders for both the input and the output parameters. ODBC syntax requires the use of <b>call</b> rather than the commonly used <b>execute</b> keyword. Stored procedure calls should be surrounded by braces ({}) as shown in the preceding code fragment. Failure to use the correct syntax may not prevent the procedure from being executed; however, unless this syntax is used, ODBC may not be able to identify the parameter positions or markers.</p>
<p>
The next line of code creates the <b>rdoPreparedStatement</b> and names it SetPassword. The <b>SQL</b> property is set with the ODBC syntax SQL query. You only need to execute this line once. The new <b>rdoPreparedStatement</b> object is automatically appended to the <b>rdoPreparedStatements</b> collection where it can be recalled later.</p>
<pre><code>Set CPw = cn.CreatePreparedStatement("SetPassword",QSQL$)
</code></pre>
<p>
When the ODBC interface executes a SQL statement, it creates one or more stored procedures on the server. These procedures contain the SQL statement specified in the <b>rdoPreparedStatement</b> object or the <b>OpenResultset</b> method and are designed to accept any parameters that might be specified for the statement. Depending on the version of the server, these procedures are either created in the current database or in the TempDB database. In some cases, several stored procedures can be created for a single statement. Generally, these procedures are not released until you close the connection or end the application. Ending the application in design mode does not clear these statements. In this case, only ending Visual Basic clears these temporary procedures.</p>
<p>
To avoid the creation of these procedures in the first place, specify the <b>rdExecDirect</b> option when using the <b>OpenResultset</b> method. For example,</p>
<pre><code>Set rs = cn.OpenResultset("Select * from Authors", rdOpenStatic, _
rdConcurValues, rdExecDirect)
</code></pre>
<p>
By using the <b>rdExecDirect</b> option, the ODBC interface does not create a procedure that is used to subsequently run the SQL statement. In some cases, this can be somewhat faster to execute, but only if the statement is used infrequently.</p>
<p>
The next step is to set the value of each input parameter and set the <b>Direction</b> property to indicate that the parameter is used for input, output, or both. The default <b>Direction</b> is <b>rdParamInput</b>. The ordinal number of the parameters is a function of the order in which they appear in the SQL statement. In this case, the "0th" parameter is the return value (? = ), the "1st" is the first input parameter, and the "2nd" is the second input parameter. The <b>rdoParameters</b> collection is zero-based. It is not necessary to set the <b>Direction</b> property on the input parameters because the default <b>Direction</b> is <b>rdParamInput</b>.</p>
<pre><code>Cpw.rdoParameters(0).Direction = rdParamReturnValue
Cpw.rdoParameters(2).Direction = rdParamInput

Cpw.rdoParameters(1) = "clyde"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Set the first input parameter.
Cpw.rdoParameters(2) = "framis"&nbsp;&nbsp;&nbsp;&nbsp; ' Set the second input parameter.
</code></pre>
<p>
Once the parameter direction and values are set, you can use the <b>Execute</b> method to run the query if it does not return rows, or the <b>OpenResultset</b> method if the procedure contains one or more SELECT statements:</p>
<pre><code>Cpw.Execute()
</code></pre>
<p>
Once the procedure is executed, you can examine the <b>rdoParameters</b> collection for the returned value:</p>
<pre><code>If Cpw.rdoParameters(0) &lt;&gt; 0<b> </b>Then
 &nbsp; Msgbox "Could not change password"
End If
</code></pre>
<h4>Using Parameter Queries in SELECT Statements</h4>
<p>
You can also use the same technique to pass parameters into a SQL statement. For example, if you want to create a query to look up authors by name from the Pubs sample database, you could create an ODBC SQL statement like this:</p>
<pre><code>SELECT * FROM Authors WHERE Au_Lname = ? 
</code></pre>
<p>
You can then set up a query using the following code, which passes the value entered by the user in Text1.Text into the query:</p>
<pre><code>QSQL$ = "SELECT * FROM Authors WHERE Au_Lname = ?"}
Set PSAuthors = cn.CreatePreparedStatement("",QSQL$)
PSAuthors.rdoParameters(0) = Text1.Text
Set MyRs = PSAuthors.OpenResultset()
</code></pre>
<p>
If the user changes the value in Text1.Text, you can re-execute the query by using the <b>Requery</b> method against the <b>rdoResultset</b> (MyRs).</p>
<pre><code>PSAuthors.rdoParameters(0) = Text1.Text
MyRs.Requery
</code></pre>
<p>
When RDO executes the <b>Requery</b> method, it refreshes the parameter value(s) in the <b>rdoParameters</b> collection, builds a new SQL statement, flushes the current result set, sends the query to the data source for execution, and creates a new <b>rdoResultset</b>.</p>
<p>
For more information, search Visual Basic Books Online or online Help for "rdoPreparedStatement object", "rdoParameter object", "Requery method", and "OpenResultset method".</p>
<h4>Capturing Output Parameters</h4>
<p>
Using the same technique used with parameter queries in SELECT statements, you can also capture the output parameters from a procedure.</p>
<p>
<b>To capture output parameters:</b>
<ol>
<li>
Use ODBC escape syntax to establish placeholders for the output and input parameters and return values.<br><br></li>
<li>
Set the <b>Direction</b> property of the <b>rdoParameter</b> object to indicate how the parameter is used.<br><br></li>
<li>
Execute the query.</li>
</ol>
<p>
When the query has completed processing, retrieve the output parameter values from the <b>rdoParameters</b> collection.</p>
<p>
The final example in the online Help topic "Creating Parameter Queries" is coded incorrectly. A correct example is shown below. Note that you use the variable set to the created <b>rdoPreparedStatement</b> to create the <b>rdoResultset</b>, which is not shown correctly in the Help example. This example executes a stored procedure that expects two input parameters and returns two output parameters along with a return value argument.</p>
<pre><code>Dim SQL As String, MyOutputVal1 As Variant
Dim MyOutputVal2 As Variant, MyRetVal As Variant
Dim cn As rdoConnection, rs As rdoResultset

rdoEnvironments(0).CursorDriver = rdUseOdbc
' To permit execution on SQL Server 6.0 Set 
' cn=rdoEnvironments(0).OpenConnection(dsname:="MyDSN",
' Prompt:=rdDriverNoPrompt)

' Use ODBC parameter argument syntax.
SQL = "{ ? = call MyProcName (?, ?,?,?) }"

Dim Ps As rdoPreparedStatement&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
' Create reusable rdoPreparedStatement.

Set Ps = cn.CreatePreparedStatement("PsTest",SQL)

' Set Parameter "direction" types for each parameter,
' both input and output.
Ps(0).Direction = rdParamReturnValue
Ps(1).Direction = rdParamInput
Ps(2).Direction = rdParamInput
Ps(3).Direction = rdParamOutput
Ps(4).Direction = rdParamOutput

' Set the input argument values.
Ps.rdoParameters(1) = "Test%"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Ps.rdoParameters(2) = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 


' Create the result set and populate the Ps values.
Set rs = Ps.OpenResultset(rdOpenStatic)

MyRetVal = Ps(0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Contains the return value argument.
MyOutputVal1 = Ps(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Contains the first output parameter.
MyOutputVal2 = Ps(4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Contains the second output parameter.
</code></pre>
<h3>Using the rdoTable Object</h3>
<p>
If you need to examine the tables exposed by a data source or column detail, you can use the <b>rdoTables</b> collection. To improve performance, no table meta-data is requested from the data source until the <b>rdoTables</b> collection is referenced. Once an <b>rdoConnection</b> is open, you can enumerate the tables and place their names in a <b>ListBox</b> control, as in the following example:</p>
<pre><code>Dim tb As rdoTable
For Each tb in cn.rdoTables
 &nbsp; List1.AddItem tb.Name
Next
</code></pre>
<p>
Each <b>rdoTable</b> object contains an <b>rdoColumns</b> collection that contains details about the data type and size of each column. Although it is possible to create an <b>rdoResultset</b> against the <b>rdoTable</b> object, this query can only return all of the rows and is not recommended.</p>
<h3>Using ODBC API Functions</h3>
<p>
Each <b>rdoEnvironment</b>, <b>rdoConnection</b>, <b>rdoPreparedStatement</b>, and <b>rdoResultset</b> object includes support for an ODBC handle that you can use to manipulate the object using the ODBC API. The <b>hEnv</b>, <b>hDbc</b>, and <b>hStmt</b> properties correspond to the <b>rdoEnvironment</b>, <b>rdoConnection</b>, and <b>rdoResultset</b> objects, respectively.</p>
<p>
Table 5 lists the ODBC handles that are created by RDO. You can use these handles in your own ODBC API code.</p>
<p class=label>
<b>Table 5. ODBC Handles Created by RDO</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=34%><b>RDO object property</b></td>
<td class=label width=66%><b>Handle created by the ODBC API</b></td>
</tr>
<tr valign=top>
<td width=34%><b>rdoEnvironment.hEnv </b></td>
<td width=66%>SQLAllocEnv</td>
</tr>
<tr valign=top>
<td width=34%><b>rdoConnection.hDbc</b></td>
<td width=66%>SQLAllocConnect, SQLDriverConnect</td>
</tr>
<tr valign=top>
<td width=34%><b>rdoResultset.hStmt</b></td>
<td width=66%>SQLAllocStmt</td>
</tr>
</table><br>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;Although it is possible to use the ODBC API with the RDO ODBC handles, you are cautioned that incorrect use of the ODBC API can cause unpredictable behavior. For example, if you close connections or deallocate any of these handles using ODBC API code, the <b>RemoteData</b> control or RDO can behave unpredictably. The ODBC handles should not be saved for future use, inasmuch as they are subject to change without notice.</p>
<h3>Managing Errors and Messages</h3>
<p>
Each time the ODBC driver manager is used to carry out an RDO request, an error can be generated. These errors can be of varying severity and, in some cases, may cause the query to be canceled or abandoned. As errors are generated, they are placed in the <b>rdoErrors</b> collection. You can examine the individual members of the <b>rdoErrors</b> collection for details on what caused the error.</p>
<p>
Visual Basic also produces a trappable error when an error occurs. In your <b>On Error</b> handler you can examine the <b>rdoErrors</b> collection to determine what action should be taken. To change the severity of error that can trip a fatal error, set the <b>rdoDefaultErrorThreshold</b> or the <b>ErrorThreshold</b> property.</p>
<p>
Informational messages returned from the data source do not trigger a trappable error. These messages do appear in the <b>rdoErrors</b> collection, which can be manually cleared with the <b>Clear</b> method.</p>
<p>
For more information, search Visual Basic Books Online or online Help for "rdoError object" or "rdoDefaultErrorThreshold property".</p>
<h2>Using the RemoteData Control</h2>
<p>
The <b>RemoteData</b> control is similar to the Visual Basic <b>Data</b> control. Both the <b>Data</b> control and the <b>RemoteData</b> control are designed to connect data-aware bound controls to a data source. The primary difference is that the <b>RemoteData </b>control uses RDO to connect to the ODBC driver manager, while the <b>Data</b> control uses the Microsoft Jet database engine and DAO to connect to the ODBC driver manager. Even though both controls use the same ODBC driver manager and data source entries, the RDO and Jet engines cannot share data source connections, data objects, or other resources.</p>
<p>
Without a <b>RemoteData</b> control, a <b>Data</b> control, or its equivalent, data-aware (bound) controls on a form can't automatically access data. You can perform most remote data access operations using the <b>RemoteData</b> control without writing any code at all. Data-aware controls bound to a <b>RemoteData</b> control automatically display data from one or more columns for the current row or, in some cases, for a set of rows on either side of the current row. The <b>RemoteData</b> control performs all operations on the current row.</p>
<p>
If the <b>RemoteData</b> control is instructed to move to a different row, all bound controls automatically pass any changes to the <b>RemoteData</b> control to be saved by the ODBC data source. The <b>RemoteData</b> control then moves to the requested row and passes back data from the current row to the bound controls, where it is displayed.</p>
<p>
The <b>RemoteData</b> control automatically handles a number of contingencies, including empty result sets, adding new rows, editing and updating existing rows, and handling some types of errors. However, in more sophisticated applications, you need to trap some error conditions that the <b>RemoteData</b> control can't handle. For example, if the remote server has a problem accessing the data source, doesn't have permission, or can't execute the query as coded, a trappable error results. If the error occurs before your application procedures start, or because of some internal errors, the Error event is triggered.</p>
<p>
When accessing an empty, updatable result set with the <b>RemoteData</b> control (RDC), you cannot depend on the <b>EOFAction</b> property to force the control to switch to <b>AddNew</b> mode. To add the first record to an empty result set, you must use the <b>AddNew</b> method against the <b>RemoteData</b> <b>Resultset</b> property. This will be corrected in a later release of the control.</p>
<p>
The <b>RemoteData</b> control uses and creates the same RDO objects discussed in this chapter. When the appropriate <b>RemoteData</b> control properties are set, the <b>RemoteData</b> control can create an <b>rdoResultset</b> that can be manipulated in code like any other <b>rdoResultset</b>. You can also create an <b>rdoResultset</b> in code and set the <b>RemoteData</b> control's <b>Resultset</b> property to point to this object.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;To use the <b>RemoteData</b> control, you need to add it to the Visual Basic Toolbox. To add the <b>RemoteData</b> control to your Toolbox, use the Custom Controls dialog box (available from the Tools menu), and select "Microsoft Remote Data Control" from the list of custom controls.</p>
<p class=indent>
RDO is only supported on 32-bit operating systems (Windows 95 and Windows NT). To use the Remote Data Objects, you must set a reference to the Microsoft Remote Data Object 1.0 object library in the Visual Basic References dialog box.</p>
<h3>Understanding RemoteData Control Operations</h3>
<p>
Once your application begins, if sufficient properties have been set at design time, Visual Basic uses the <b>RemoteData</b> control to establish a connection to the ODBC data source. This creates an <b>rdoConnection</b> object by using the <b>DataSourceName</b>, <b>UserName</b>, <b>Password</b>, <b>Options</b>, <b>Type</b>, and <b>Connect</b> properties.</p>
<p>
If insufficient information is provided in the <b>RemoteData</b> control properties, the ODBC driver manager exposes a dialog box to gather missing parameters. If the connection is established, the <b>RemoteData</b> control sets or resets the <b>Environment</b>, <b>Connection</b>, <b>DataSourceName</b>, <b>Transactions</b>, and <b>Connect</b> properties, based on the values used to establish the connection.</p>
<p>
Once the connection is established, the <b>RemoteData</b> control runs a query against the data source using the <b>SQL</b>, <b>CursorDriver</b>, <b>Options</b>, <b>LockType</b>, <b>ErrorThreshold</b>, and <b>ResultsetType</b> properties. This creates an <b>rdoResultset</b> object and sets the <b>Resultset</b>, <b>ResultsetType</b>, and <b>Updatable</b> properties. By default, a read-only, forward-only type of <b>rdoResultset</b> is created. The <b>StillExecuting</b> property is set to <b>True</b> while the <b>rdoResultset</b> is created. If you choose to cancel the query, and the <b>rdAsyncEnable</b> option is set, you can use the <b>Cancel</b> method against the <b>rdoResultset</b> to terminate processing of the query.</p>
<p>
<b>Note:</b> A known bug prevents complete use of <b>Image</b> or <b>PictureBox</b> controls with the <b>RemoteData</b> control. Although it is possible to read TEXT and IMAGE datatypes using the <b>RemoteData</b> control, it is not possible to update this type of column. It is possible to update these columns using RDO code or with the <b>Data</b> control.</p>
<p>
<b>Note</b> also that graphics columns created by Microsoft Access must be accessed with OLE controls, not <b>Picture</b> or <b>Image</b> controls.</p>
<p>
Once the first row of the <b>rdoResultset</b> is available, the <b>StillExecuting</b> property is set to <b>False</b> and the <b>RemoteData</b> control passes column data to each bound control requesting data. The <b>rdoResultset</b>.<b>RowCount</b> property is set to a non-zero value if any rows resulted from the query. If no data is returned by the <b>rdoResultset</b>, the <b>RemoteData</b> control's behavior is determined by the <b>EOFAction</b> property.</p>
<p>
<b>Note:</b> Make sure that each bound control's <b>DataField</b> property corresponds to the <b>Name</b> property of the <b>rdoColumn</b> object returned by the <b>rdoResultset</b>. If the <b>DataField</b> property does not match the <b>Name</b> property of one of the <b>rdoColumn</b> objects in the <b>rdoResultset</b>, a trappable error occurs.</p>
<h3>Positioning the Current Row Pointer</h3>
<p>
Users can manipulate the <b>RemoteData</b> control with the mouse. They can move from row to row, or to the beginning or end of the <b>rdoResultset</b> by clicking the control. As the user manipulates the <b>RemoteData</b> control buttons, the current row pointer is repositioned in the <b>rdoResultset</b>. The <b>RemoteData</b> control doesn't permit the user to move off either end of the <b>rdoResultset</b> using the mouse. You can't set focus to the <b>RemoteData</b> control.</p>
<p>
Keep the following guidelines in mind when writing code that will reposition to the current row pointer:
<ul type=disc>
<li>
Before repositioning, the bound controls are queried for new data for the current row. If the data changes, the Validate event is invoked, and, if not canceled by the action argument, the data source is updated.<br><br></li>
<li>
After the <b>RemoteData</b> control is positioned on a new row in the data source, column data is passed to the bound controls and the Reposition event is invoked.<br><br></li>
<li>
Once either end of the <b>rdoResultset</b> is reached, the <b>RemoteData</b> control's behavior is determined by the <b>EOFAction</b> and <b>BOFAction</b> properties.<br><br></li>
<li>
You can use the <b>MoreResults</b> method against the <b>rdoResultset</b> to complete processing of the current result set and determine if additional result sets are available. If <b>MoreResults</b> returns <b>True</b>, the process of handling the <b>rdoResultset</b> is restarted—just as if a new query had been executed. The previous result set is no longer available.</li>
</ul>
<h3>Programmatic Operation</h3>
<p>
To create an <b>rdoResultset</b> programmatically with the <b>RemoteData</b> control:
<ol>
<li>
Set the <b>RemoteData</b> control properties to determine the characteristics of the <b>rdoResultset</b>.<br><br></li>
<li>
Use the <b>Refresh</b> method to begin the automated process or create the new <b>rdoResultset</b>. Any existing <b>rdoResultset</b> is discarded.</li>
</ol>
<p>
You can manipulate all of the <b>RemoteData</b> control properties and the new <b>rdoResultset</b> object independently of the <b>RemoteData</b> control—with or without bound controls. The <b>rdoConnection</b> and <b>rdoResultset</b> objects each have properties and methods of their own that you can use with your procedures.</p>
<p>
For example, the <b>MoveNext</b> method of an <b>rdoResultset</b> object moves the current row to the next row in the <b>rdoResultset</b>. To invoke this method with an <b>rdoResultset</b> created by a <b>RemoteData</b> control, you could use this code:</p>
<pre><code>RemoteData1.rdoResultset.MoveNext
</code></pre>
<p>
If you need to execute a parameter query using the <b>RemoteData</b> control, first create an <b>rdoResultset</b> based on an <b>rdoPreparedStatement</b>, and then set the <b>RemoteData</b> control <b>Resultset</b> property to the newly created <b>rdoResultset</b>. You can also use this technique to access another <b>rdoEnvironment</b>.</p>
<h3>Asynchronous Operation</h3>
<p>
If you set the <b>Options</b> property to <b>rdAsyncEnable</b> before the <b>RemoteData</b> control creates the <b>rdoResultset</b>, control returns to your application before the <b>rdoResultset</b> contains rows. Check the <b>StillExecuting</b> property of the <b>rdoResultset</b> object to determine when the first data row is available. To cancel the query, use the <b>rdoResultset.Cancel</b> method. Once the query is complete, the <b>QueryCompleted</b> event is invoked, which indicates that new data is now available from the <b>rdoResultset</b>.</p>
<p>
If you do not specify asynchronous operation with <b>rdAsyncEnable</b>, no other Visual Basic operations or events can occur until the first data row of the <b>rdoResultset</b> is fetched. However, other Windows-based applications can continue executing while the <b>rdoResultset</b> is being created.</p>
<p>
When you use a <b>RemoteData</b> control to create an <b>rdoResultset</b> object, the remote database engine automatically populates the <b>rdoResultset</b> object as a background task. As a result, any existing bookmarks are saved, the user doesn't need to manipulate the <b>RemoteData</b> control, and you don't need to invoke the <b>MoveLast</b> method in code. In addition, page locks used to create the <b>rdoResultset</b> are released more quickly, making it possible for other <b>rdoResultset</b> objects to access the same data.</p>
<p>
You can also create an <b>rdoResultset</b> object using the <b>OpenResultset</b> method and set the <b>Resultset</b> property to the new <b>rdoResultset</b>. If this is done, all other appropriate <b>RemoteData</b> control properties are reset to reflect the new <b>rdoResultset</b> and <b>rdoConnection</b>.</p>
<h3>Validation</h3>
<p>
Use the Validate event and the <b>DataChanged</b> property to perform last-minute checks on the rows being written to the database. The Validate event is invoked before each repositioning of the current row pointer. If the data changes, the Validate event is invoked, and, if not canceled by the <i>action</i> argument, the data source is updated.</p>
<p>
For more information, search Visual Basic Books Online or online Help for "Validate event".</p>
</BODY>
</HTML>
