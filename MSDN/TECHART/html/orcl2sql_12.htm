<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Procedural Program Units</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Procedural Program Units</h1>
<p>
This section describes how to replace PL/SQL procedures and functions with Transact-SQL stored procedures.</p>
<h3>Stored Procedures</h3>
<p>
Transact-SQL procedures offer the same capabilities as PL/SQL procedures and functions. PL/SQL style packages are not supported. Transact-SQL procedures can accept and return user-supplied parameters. Integer values can also be returned using the RETURN statement. They are created using the CREATE PROCEDURE statement:</p>
<pre><code>CREATE PROCedure [owner.]procedure_name[;number]'
 &nbsp; [(parameter1 [, parameter2]...[parameter255])]
[{FOR REPLICATION} | {WITH RECOMPILE}
</code></pre>
<p>
Except for temporary procedures, you can only create a stored procedure in the current database. Temporary procedures are created in the <b>tempdb</b> database. A temporary procedure is created by preceding the <i>procedure_name</i> with a single number sign (<b>#<i>procedure_name</i></b>) for local temporary procedures and a double number sign (<b>##<i>procedure_name</i></b>) for global temporary procedures.</p>
<p>
A local temporary procedure can only be used by the user who created it. Permission to execute a local temporary procedure cannot be granted to other users. Local temporary procedures are automatically dropped at the end of the user session.</p>
<p>
A global temporary procedure is available to all SQL Server users. If a global temporary procedure is created, all users can access it, and permissions cannot be explicitly revoked. Global temporary procedures are dropped at the end of the last user session using the procedure.</p>
<p>
The nesting of Transact-SQL stored procedures is allowed. The nesting level is incremented when the called procedure starts execution, and it is decremented when the called procedure finishes execution. Exceeding the maximum of 16 levels of nesting causes the whole calling procedure chain to fail.</p>
<p>
The following example demonstrates how a Transact-SQL stored procedure can be used to replace a packaged function. The Transact-SQL version is much simpler because of SQL Server's ability to return result sets directly from SELECT statements in a stored procedure, without using a cursor.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=56%><b>Oracle</b></td>
<td class=label width=44%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=56%>CREATE OR REPLACE PACKAGE STUDENT_ADMIN.P1 AS<br>
&nbsp;&nbsp;&nbsp;&nbsp;ROWCOUNT NUMBER :=0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;CURSOR C1 RETURN STUDENT%ROWTYPE;<br>
&nbsp;&nbsp;&nbsp;&nbsp;FUNCTION SHOW_RELUCTANT_STUDENTS<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WORKVAR OUT VARCHAR2) RETURN NUMBER;<br>
END P1;<br>
/<br>
<br>
CREATE OR REPLACE PACKAGE BODY STUDENT_ADMIN.P1 AS<br>
&nbsp;&nbsp;&nbsp;&nbsp;CURSOR C1 RETURN STUDENT%ROWTYPE IS<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM STUDENT_ADMIN.STUDENT <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE NOT EXISTS<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SELECT 'X' FROM STUDENT_ADMIN.GRADE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE GRADE.SSN=STUDENT.SSN) ORDER BY SSN;<br>
<br>
FUNCTION SHOW_RELUCTANT_STUDENTS<br>
&nbsp;&nbsp;&nbsp;&nbsp;(WORKVAR OUT VARCHAR2) RETURN NUMBER IS<br>
&nbsp;&nbsp;&nbsp;&nbsp;WORKREC STUDENT%ROWTYPE;<br>
&nbsp;&nbsp;&nbsp;&nbsp;BEGIN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF NOT C1%ISOPEN THEN OPEN C1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROWCOUNT :=0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FETCH C1 INTO WORKREC;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (C1%NOTFOUND) THEN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CLOSE C1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROWCOUNT :=0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WORKVAR := WORKREC.FNAME||' '||WORKREC.LNAME||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;', social security number '||WORKREC.SSN||' is not enrolled <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in any classes!';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROWCOUNT := ROWCOUNT + 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF;<br>
RETURN(ROWCOUNT);<br>
<br>
EXCEPTION<br>
&nbsp;&nbsp;&nbsp;&nbsp;WHEN OTHERS THEN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF C1%ISOPEN THEN CLOSE C1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROWCOUNT :=0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RAISE_APPLICATION_ERROR(-20001,SQLERRM);<br>
END SHOW_RELUCTANT_STUDENTS;<br>
END P1;<br>
/</td>
<td width=44%>CREATE PROCEDURE<br>
STUDENT_ADMIN.SHOW_RELUCTANT_STUDENTS <br>
AS SELECT FNAME+'' +LNAME+', social security <br>
&nbsp;&nbsp;&nbsp;&nbsp;number'+&nbsp; SSN+' is not enrolled in any classes!'<br>
FROM STUDENT_ADMIN.STUDENT S<br>
WHERE NOT EXISTS<br>
&nbsp;&nbsp;&nbsp;&nbsp;(SELECT 'X' FROM STUDENT_ADMIN.GRADE G<br>
&nbsp;&nbsp;&nbsp;&nbsp;WHERE G.SSN=S.SSN)<br>
ORDER BY SSN<br>
RETURN@@ROWCOUNT<br>
GO </td>
</tr>
</table><br>
<h3>Table Triggers</h3>
<p>
PL/SQL offers row and statement level triggers that can be executed before or after the execution of an INSERT, UPDATE, or DELETE statement. Any number of triggers can be attached to a table. A Transact-SQL trigger is activated only once per statement, even if it affects multiple rows. A complex query containing a WHILE loop can repeat an UPDATE, DELETE, or INSERT many times, and the trigger is activated each time. Constraints are checked prior to trigger execution. If constraints are violated, the trigger is not run.</p>
<p>
Transact-SQL provides the <b>INSERTED</b> and <b>DELETED</b> table(s) to track row-level changes. These two tables remove the requirement for row-level triggers. When an INSERT, UPDATE, or DELETE statement is executed, rows are added to the trigger table and to the <b>INSERTED</b> and <b>DELETED</b> table(s) at the same time.</p>
<p>
The <b>INSERTED</b> and <b>DELETED</b> tables are identical to the trigger table. They have the same column names and the same data types. For example, if a trigger is placed on the <b>GRADE </b>table, the <b>INSERTED</b> and <b>DELETED</b> tables have this structure.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=35%><b>GRADE</b></td>
<td class=label width=32%><b>INSERTED</b></td>
<td class=label width=33%><b>DELETED</b></td>
</tr>
<tr valign=top>
<td width=35%><b>SSN CHAR(9)</b><br>
<b>CCODE VARCHAR(4)</b><br>
<b>GRADE VARCHAR(2)</b></td>
<td width=32%><b>SSN CHAR(9)</b><br>
<b>CCODE VARCHAR(4)</b><br>
<b>GRADE VARCHAR(2)</b></td>
<td width=33%><b>SSN CHAR(9)</b><br>
<b>CCODE VARCHAR(4)</b><br>
<b>GRADE VARCHAR(2)</b></td>
</tr>
</table><br>
<p>
The <b>INSERTED</b> and <b>DELETED</b> tables can be examined by the trigger to determine what types of trigger actions should be carried out. The <b>INSERTED</b> table is used with the INSERT and UPDATE statements. The <b>DELETED</b> table is used with DELETE and UPDATE statements. </p>
<p>
The UPDATE statement uses both the <b>INSERTED</b> and <b>DELETED</b> tables because SQL Server always deletes the old row and inserts a new row whenever an UPDATE operation is performed. Consequently, whenever an UPDATE is performed, the rows in the <b>INSERTED</b> table are always duplicates of the rows in the <b>DELETED</b> table.</p>
<p>
The following example uses the <b>INSERTED</b> and <b>DELETED</b> tables to replace a PL/SQL row-level trigger. Notice that a full outer join is used to bring back all rows from either table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>CREATE TRIGGER&nbsp;&nbsp;&nbsp;&nbsp; STUDENT_ADMIN.TRACK_GRADES<br>
AFTER<br>
INSERT OR UPDATE OR DELETE<br>
ON STUDENT_ADMIN.GRADE<br>
FOR EACH ROW<br>
BEGIN<br>
INSERT INTO GRADE_HISTORY(<br>
&nbsp;&nbsp;&nbsp;&nbsp;TABLE_USER, ACTION_DATE,<br>
&nbsp;&nbsp;&nbsp;&nbsp;OLD_SSN, OLD_CCODE, OLD_GRADE,<br>
&nbsp;&nbsp;&nbsp;&nbsp;NEW_SSN, NEW_CCODE, NEW_GRADE)<br>
VALUES (USER, SYSDATE,<br>
&nbsp;&nbsp;&nbsp;&nbsp;:OLD.SSN, :OLD.CCODE, :OLD.GRADE,<br>
&nbsp;&nbsp;&nbsp;&nbsp;:NEW.SSN, :NEW.CCODE, :NEW.GRADE),<br>
END;</td>
<td width=51%>CREATE TRIGGER STUDENT_ADMIN.TRACK_GRADES<br>
ON STUDENT_ADMIN.GRADE<br>
FOR INSERT, UPDATE, DELETE<br>
AS<br>
INSERT INTO GRADE_HISTORY(<br>
&nbsp;&nbsp;&nbsp;&nbsp;TABLE_USER, ACTION_DATE,<br>
&nbsp;&nbsp;&nbsp;&nbsp;OLD_SSN, OLD_CCODE, OLD_GRADE<br>
&nbsp;&nbsp;&nbsp;&nbsp;NEW_SSN, NEW_CCODE, NEW_GRADE)<br>
SELECT USER, GETDATE(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;OLD.SSN, OLD.CCODE, OLD.GRADE,<br>
&nbsp;&nbsp;&nbsp;&nbsp;NEW.SSN, NEW.CCODE, NEW.GRADE<br>
FROM INSERTED NEW FULL OUTER JOIN <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DELETED OLD ON NEW.SSN = OLD.SSN </td>
</tr>
</table><br>
<p>
A table is allowed one trigger for INSERT, one for UPDATE, and one for DELETE. If a trigger is defined for an operation (insert, update, or delete) that already has a trigger association, the existing trigger is replaced. No warning message is given before the replacement occurs. However, the same trigger action can be defined for more than one user action (for example, INSERT and UPDATE) in the same CREATE TRIGGER statement.</p>
<p>
You can create a trigger only in the current database. A trigger is allowed to reference objects outside the current database. If you use an owner name to qualify a trigger, qualify the table name the same way.</p>
<p>
Triggers can be nested 16 levels deep. If a trigger changes a table on which there is another trigger, the second trigger is activated and can then call a third trigger, and so on. If any trigger in the chain sets off an infinite loop, the nesting level has been exceeded and the trigger is canceled.</p>
<p>
A trigger does not call itself in response to a second update to the same table within the trigger. For example, if an update trigger on one column of a table results in an update to another column, the update trigger is activated only once.</p>
<p>
SQL Server declarative referential integrity (DRI) does not provide cross-database referential integrity. If cross-database referential integrity is required, use triggers for this purpose.</p>
<p>
The following SQL statements are not allowed in a trigger:
<ul type=disc>
<li>
All CREATE statements (DATABASE, TABLE, INDEX, PROCEDURE, DEFAULT, RULE, TRIGGER, and VIEW)<br><br></li>
<li>
All DROP statements<br><br></li>
<li>
ALTER TABLE and ALTER DATABASE<br><br></li>
<li>
TRUNCATE TABLE<br><br></li>
<li>
GRANT and REVOKE<br><br></li>
<li>
UPDATE STATISTICS<br><br></li>
<li>
RECONFIGURE<br><br></li>
<li>
LOAD DATABASE and LOAD TRANSACTION<br><br></li>
<li>
All DISK statements<br><br></li>
<li>
SELECT INTO (because it creates a table)</li>
</ul>
<p>
For more information about triggers, see the <i>Microsoft SQL Server Transact-SQL Reference</i>.</p>
</BODY>
</HTML>
