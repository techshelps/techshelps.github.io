<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How to Build Microsoft Transaction Server Components</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>How to Build Microsoft Transaction Server Components</h1>
<p>
When using Microsoft Transaction Server, think of an application in terms of components or objects. <i>Component</i> is the code that implements a COM object. This section describes classes, methods, and other object-oriented terms.</p>
<h3>Overview of Object-Oriented Programming</h3>
<p>
Traditional languages, such as COBOL and C, represent a procedural approach to application development. These programs consist of two components, data and code. To improve maintenance, code is compartmentalized into procedures. As applications become more complex over time, each procedure can manipulate any part of the data. The interrelationships become hard to maintain and enhance. In the C language, for example, units of code are called functions, while data are referred to as structures. Because functions and structures are not formally connected in C, a C function can operate on more than one type of structure, and more than one function can operate on the same structure.</p>
<p>
<img src="sql_mts_4.gif" border=0></p>
<p>
Object-oriented programming takes the procedural approach and refines it so that data and code form a single, indivisible <i>object</i>. This is called <i>data encapsulation</i>; the data is compartmentalized with the procedures for manipulating that data. Languages, such as Visual&nbsp;Basic 5, C++, Smalltalk, and Java, are examples of object-oriented languages. </p>
<p>
By providing this modularity, programs are divided into distinct objects for specific tasks and data. Also, programmers can simultaneously work on the same project, assembling the components at milestones for testing. This is possible because all communication processing between objects is done using <i>messages</i>, which define the interface to the object. The <i>interface</i> is a group of logically related operations that provide access to a component object. For example, the spellchecker bundled with Microsoft&nbsp;Word can be accessed by other software, such as Microsoft&nbsp;Excel, the Microsoft&nbsp;PowerPoint®presentation graphics program, and Microsoft&nbsp;Exchange, by using its interface. Everything an object can do is represented by its message interface.</p>
<p>
<img src="sql_mts_5.gif" border=0></p>
<p>
After being defined and tested, objects are not modified. Doing so would alter how the object works. For example, changing one object could cause a program to fail because other objects expect it to have certain characteristics. Providing access to an object only through its messages reduces effort, improves maintenance, and speeds debugging.</p>
<p>
An object is specified using its <i>class</i>. A class defines object properties and methods used to control the object's behavior. Objects are individual instances of a class. For example, an object called Car is an individual instance of the class of Transportation. The Transportation class defines what it is to be a Car object, and all the car-related messages a car object can act upon. </p>
<p>
You can make more than one object of this class, and call them Car, Truck, and so on. The Transportation class defines messages that the Transportation objects understand, such as "start," "stop," and "turn left." When a message is a set to execute an action, the executed code is called a <i>method</i>.</p>
<p>
Object-oriented programming also allows you to define new classes of objects that build on the behavior of existing classes. This is called <i>inheritance</i> or subclassing. The new class inherits all the existing messages, and therefore, all the behavior of the original class. This promotes reuse, not only reducing the amount of code to write but the time to debug as well. For example, after creating the class Car, you might make a subclass called Sportscar that defines some sportscar-specific messages. </p>
<p>
There are also times when you will need different classes to respond to the same message, but not in the same way. This is called <i>polymorphism</i>, and increases the flexibility of an application without increasing its complexity. Objects can also receive messages from a program as it executes. For example, every Windows application can copy and paste within and across applications. Any number of software programs can support these functions by calling the appropriate class.</p>
<h3>Beyond COM</h3>
<p>
Microsoft Transaction Server components are distinguished from other COM components in that they execute in the Transaction Server run-time environment. Transaction Server also imposes specific requirements on components beyond those required by COM. For example, Visual&nbsp;C++ components are implemented as classes. Likewise, Visual&nbsp;Basic components are implemented by class modules. To begin with, the component must be a dynamic-link library (DLL). Components that are implemented as executable files (.exe files) cannot execute in the Transaction Server run-time environment. </p>
<p>
This means that if you have a Visual&nbsp;Basic Remote Automation server executable file, it must be rebuilt as a DLL for use by Microsoft Transaction Server.</p>
<p>
For Visual&nbsp;C++ components, there are additional requirements:
<ul type=disc>
<li>
The component must have a standard class factory; the latter implements the <b>IClassFactory</b>&nbsp;interface so objects can be created of a specific class. <br><br></li>
<li>
The component DLL must also implement and export the standard <b>DllGetClassObject</b> function&nbsp;and support the&nbsp;<b>IClassFactory</b> interface.&nbsp;Transaction Server uses this interface&nbsp;to create objects. <br><br></li>
<li>
The component must only export interfaces that can be standard marshaled; this is the process of packaging and sending interface method parameters across thread or process boundaries. All component interfaces must either be described by a type library&nbsp;or have a proxy-stub DLL. You must: <ol>
<li>
Build the proxy-stub DLL with MIDL version 3.00.44 or later (provided with the Win32 SDK for the Microsoft Windows&nbsp;NT version 4.0 operating system). <br><br></li>
<li>
Use the&nbsp; <b>-oicf</b> compiler switch. <br><br></li>
<li>
Link the DLL with the Mtxih.lib library provided by Microsoft Transaction Server. The Mtxih.lib library must be the first file that you link into your proxy-stub DLL. </li>
</ol>
</li>
</ul>
<p>
Unlike other TP monitors, Microsoft Transaction Server leverages existing Microsoft ActiveX APIs, familiar to desktop developers, to lower training costs and shorten ramp-up time. Simple APIs make it quick to learn and implement:
<ul type=disc>
<li>
Visual&nbsp;Basic programmers invoke Transaction Server applications by using <b>Create Object</b>.<br><br></li>
<li>
Visual&nbsp;C++ programmers call Transaction Server applications by using <b>CoCreateInstance</b>.</li>
</ul>
<p>
Transaction Server has only two new APIs, <b>GetObjectContext</b> and <b>SafeRef</b>. Most Transaction Server applications can be built using just one new API and one new interface.</p>
<h3>Component Packaging</h3>
<p>
After you have written the software components, you must assemble them into a single solution. Microsoft Transaction Server introduces the concept of <i>component packages</i> to enable the easy integration of different software components into a single application. These packages are created and deployed by using Microsoft Transaction Server Explorer, a graphical administration tool for components. </p>
<p>
Packages enable components to be grouped and distributed as a solution, which provides a high degree of performance, load balancing, and fault isolation. Components in a package:
<ul type=disc>
<li>
Execute together in the same process space.<br><br></li>
<li>
Share common security.<br><br></li>
<li>
Can be deployed as a single unit.</li>
</ul>
<p>
Transaction Server also makes it easy to build distributed applications by providing location transparency. Transaction Server assumes responsibility for loading the component into a process environment. A Transaction Server component can be loaded into a client application process (in-process component or DLL), or into a separate surrogate server process environment, either on the client's computer (local component) or on another computer (remote component). </p>
<p>
Every Transaction Server component&nbsp;has a transaction attribute recorded in the Transaction Server catalog. The catalog maintains configuration information for components, packages, and roles. To administer the catalog, use Microsoft Transaction Server Explorer.</p>
<p>
Every Microsoft Transaction Server component&nbsp;has a transaction attribute, which is set in Explorer. Transaction Server uses this attribute during object creation to determine whether the object should be created to execute within a transaction, and whether a transaction is required or optional. </p>
<p>
You set the Transaction Attribute as part of a component definition in Explorer. You can also set a transaction attribute at development time using values defined in Mtxattr.h. You can specify these values in an ODL file to encode them into the component type library, which contains standard descriptions of data types, modules, and interfaces that can be used to fully expose objects with ActiveX technology. Visual&nbsp;Basic automatically generates a type library and developers must use Explorer to set the transaction attribute.</p>
<p>
After the component is built, Microsoft Transaction Server Explorer builds the package file to deploy the components. The package contains information about the components and roles (security) of a package. When you create a prebuilt package, the associated component files (DLLs, type libraries, and proxy-stub DLLs, if implemented) are copied to the same directory where the package file was created.</p>
<p>
Components that make updates to multiple transactional resources (for example, database records) can ensure that their objects are always created within a transaction. If the object is created from a context (the identity of the object's creator) that has a transaction, the new object inherits that context and transaction; otherwise, the system automatically initiates a transaction for the new object. An object's context is similar in concept to the process context that an operating system maintains for an executing program. The Microsoft Transaction Server run-time environment manages a context for each object.</p>
<p>
Components that only do a single transactional update can be declared to support, but not require, transactions. If the object is created from a context that has a transaction, the context of the new object inherits that transaction. This allows the work of multiple objects to be composed into a single atomic transaction. If the object is created from a context that doesn't have a transaction, the object can rely on the resource manager to ensure that the single update is atomic. </p>
<h3>How Work Is Associated with a Transaction</h3>
<p>
An object has an associated context object that indicates whether the object is executing within a transaction and, if so, the identity of the transaction. Resource dispensers&nbsp;can use the context object to provide transaction-based services to the Transaction Server object. For example, when an object executing within a transaction allocates a database connection by using the ODBC resource dispenser, the connection is automatically enlisted on the transaction. All database updates using this connection become part of the transaction, and are either atomically committed or aborted. </p>
<p>
Like any COM&nbsp;object, Transaction Server objects&nbsp;can maintain internal state across multiple interactions with a client. An object that has this behavior is <i>stateful</i>. Transaction Server objects can also be <i>stateless</i>, which means the object doesn't hold an intermediate state while waiting for the next call from a client. </p>
<p>
When a transaction is either committed or aborted, all the objects involved in the transaction are deactivated, causing them to lose any state they acquired during the course of the transaction. This helps ensure transaction isolation&nbsp;and database consistency; it also frees server resources for use in other transactions. </p>
<p>
Completing a transaction enables Transaction Server to deactivate an object and reclaim its resources, thus increasing the scalability of the application. Maintaining state on an object requires the object to remain activated, holding potentially valuable resources, such as database connections. Stateless objects are more efficient and are recommended. </p>
<h3>How Objects Can Participate in Transaction Outcome</h3>
<p>
The <b>IObjectContext</b>&nbsp;interface has methods that enable a Transaction Server object to participate in determining a transaction outcome. The <b>SetComplete</b>, <b>SetAbort</b>, <b>EnableCommit</b>, and <b>DisableCommit</b>&nbsp;methods work in conjunction with the component transaction attribute to allow one or more objects to be simply and safely composed within transactions. 
<ul type=disc>
<li>
<b>SetComplete</b>&nbsp;indicates the object has successfully completed its work for the transaction. The object is deactivated upon return from the method that first entered the context. <br><br></li>
<li>
<b>SetAbort</b>&nbsp;indicates the work of the object can never be committed. The object is deactivated upon return from the method that first entered the context. <br><br></li>
<li>
<b>EnableCommit</b>&nbsp;indicates the work of the object isn't necessarily done, but that its transactional updates can be committed in their current form. <br><br></li>
<li>
<b>DisableCommit</b>&nbsp;indicates the transactional updates of the object can't be committed in their current form. </li>
</ul>
<p>
Both&nbsp;<b>SetComplete</b>&nbsp;and <b>SetAbort</b> deactivate the object on return from the method. The object is reactivated on the next call that requires object execution. Objects that need to retain state across multiple calls from a client can protect themselves from having their work committed prematurely by the client. By calling <b>DisableCommit</b>&nbsp;before returning control to the client, the object can guarantee that its transaction cannot be successfully committed without the object doing its remaining work and calling <b>EnableCommit</b>. These options can be set during development or when a component is brought into Explorer for registration in the Microsoft Transaction Server run-time environment.</p>
<h3>Client-Controlled vs. Automatic Transactions</h3>
<p>
Transactions can either be controlled directly, by the client, or automatically, by the Transaction Server run-time environment. </p>
<p>
Clients&nbsp;can have direct control over transactions by using a transaction context object. The client uses the <b>ITransactionContext</b> interface to create Transaction Server objects that execute within the client's transactions and to commit or abort the transactions. </p>
<p>
Transactions can be automatically initiated by the Transaction Server run-time environment to satisfy the component's transaction expectations. Transaction Server components can be declared so that their objects always execute within a transaction, regardless of how the objects are created. This simplifies component development because application logic doesn't have to be written to handle the special case of an object created by a client not using transactions. </p>
<p>
This also reduces the burden on client applications. Clients don't need to initiate a transaction simply because the component they're using requires them. </p>
<p>
Transaction Server automatically initiates transactions as needed to satisfy a component's requirements. This occurs, for example, when a client that isn't using transactions creates an object in a Transaction Server component that's declared to require transactions. </p>
<p>
Transaction Server completes automatic transactions when the Transaction Server object that triggered its creation has completed its work. This occurs when returning from the object after it has called <b>SetComplete</b>&nbsp;or <b>SetAbort</b>. The former causes the transaction to be committed; the latter causes it to be aborted. </p>
<p>
A transaction cannot be committed while any method is executing in an object that is participating in the transaction. The system behaves as if the object disables the commit for the duration of each method call.</p>
<h3>Good Component Design and Resource Sharing </h3>
<p>
You can build a component for use in Microsoft Transaction Server with any language capable of building COM in process. This list includes, but is not limited to:
<ul type=disc>
<li>
Visual&nbsp;Basic<br><br></li>
<li>
Visual&nbsp;C++<br><br></li>
<li>
Visual&nbsp;J++<br><br></li>
<li>
Borland Delphi<br><br></li>
<li>
Microfocus COBOL<br><br></li>
<li>
Powersoft PowerBuilder<br><br></li>
<li>
Digital STDL<br><br></li>
<li>
Any other 32-bit C++ compiler</li>
</ul>
<p>
In a server application, resource sharing is extremely important. (Imagine what would happen if 3,000 clients asked for 3,000 separate processes with 3,000 database connections.) Transaction Server manages most resource allocation by using memory allocation, component allocation, and recycling, thread pooling, and ODBC connection pooling. </p>
<p>
A component designer must consider other potential problems as well. For example, a computer could ask for resources and hold on to them for long periods. Or, if a component does some automation to Excel, each instance could request an instance of Excel. That would mean one process per client request! </p>
<p>
There are other things to consider. A scalable application makes use of stateless servers. Therefore, a well-designed component should be stateless. When a given client is finished with an object, the object forgets all state. When the next request comes in, all state must be gathered until the client is finished and commits the transaction. </p>
<p>
To a desktop programmer, keeping state is efficient. In a desktop world, that is true, but in a server world, that is false. The overhead associated with keeping state is tremendous. With a single-user desktop application, keeping 256K of data is nothing, but if you have 1000 concurrent users accessing a system, 256K per client is approximately 256 MB. State should be kept only in the resource manager.</p>
<p>
It is also important to minimize network traffic. This is a difficult thing to do. The common object-oriented approach is to have an object that has some data that we access through small, clear properties and methods. This does not work well in a server world. Every method call or property get/set is a network roundtrip that passes the minimum number of packets, filled or not. It is therefore important to minimize the number of method calls and property get/sets. Currently, the only way to do this is to use method calls that pass and receive all of the data back and forth by value. It is not enough just to use large methods. Unseen marshaling can be a performance nightmare, so do not pass pointers or object references if it is at all possible.</p>
<p>
Transaction duration is another possible performance killer. Keep transactions as short as possible because transaction locks cause serialization and blocking. </p>
<h3>ODBC Performance</h3>
<p>
Each time an object uses a method, it obtains, uses, and then releases its database connection. A database connection is a valuable resource. The most efficient model for resource usage in scalable applications is to use them sparingly—acquire resources only when needed, and return them as soon as possible. </p>
<p>
Historically, acquiring resources has been an expensive operation in terms of system performance. Many programs acquire resources and hold onto them until program termination. While this strategy is effective for single-user systems, building scalable server applications requires sharing resources. </p>
<p>
Microsoft Transaction Server provides an architecture for resource sharing through its Resource Dispenser Manager and resource dispensers. The Resource Dispenser Manager works with specific resource dispensers to automatically pool and recycle resources. The ODBC version 3.0 Driver Manager is a Microsoft Transaction Server resource dispenser, also referred to as the ODBC resource dispenser. </p>
<p>
When you create a component, it has not implemented any Transaction Server–specific APIs. But when you run it, Transaction Server uses the ODBC resource dispenser. This happens automatically when a method uses Remote Data Objects (RDO) to access the database because RDO uses ODBC. Whenever any component running in the Transaction Server run-time environment uses ODBC directly or indirectly, the component automatically uses the ODBC resource dispenser. </p>
<p>
When the object releases the database connection, the connection is returned to a pool. When the method is called again, it requests the same database connection. Instead of creating a new connection, the ODBC resource dispenser recycles the pooled connection, which saves time and server resources.</p>
</BODY>
</HTML>
