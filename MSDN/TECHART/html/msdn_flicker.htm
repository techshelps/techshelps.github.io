<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Flicker-Free Displays Using an Off-Screen DC</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_flicker"></a></sup>Flicker-Free Displays Using an Off-Screen DC</h1>
<p>
Herman Rodent<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: April 5, 1993</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="1319">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the Flicker sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes a technique for drawing to a window device context (DC) in such a way that the screen does not flicker. The technique is very simple and easy to implement.</p>
<h2>Introduction</h2>
<p>
I often see Microsoft® Windows™-based applications that maintain status information such as the current time in a small control window that flickers very annoyingly each time it's updated. All the standard Windows controls flicker if updated at frequent intervals. The solution to this problem is to implement a simple control yourself and use an off-screen DC to construct the image, which is then copied in total to the client area of the control window. The net result is a control that can be updated without any flicker.</p>
<p>
Flicker, the sample application included with this article, has window procedures for two controls—one of these flickers; the other one doesn't. The application creates an instance of each of these controls and updates the window text ten times every second to show how one flickers and the other doesn't. The controls both support the system text color, window background color, and the WM_SETTEXT and WM_SETFONT messages.</p>
<h2>A Control That Flickers</h2>
<p>
Let's start by looking at the window procedure of the control class that flickers. After that, we can go on to see how this is changed to prevent flickering. Here's the window procedure for the control:</p>
<pre><code>LRESULT CALLBACK FlickerWndProc(HWND hWnd, UINT msg,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WPARAM wParam, LPARAM lParam)
{
 &nbsp;&nbsp; PAINTSTRUCT ps;

 &nbsp;&nbsp; switch(msg) {
 &nbsp;&nbsp; case WM_SETTEXT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstrcpy(szCaption, (LPSTR)lParam);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InvalidateRect(hWnd, NULL, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case WM_SETFONT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hfnt = (HFONT) wParam;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case WM_PAINT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BeginPaint(hWnd, &amp;ps);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Paint(hWnd, &amp;ps);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EndPaint(hWnd, &amp;ps);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DefWindowProc(hWnd, msg, wParam, lParam);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return NULL;
}
</code></pre>
<p>
The window supports WM_SETTEXT, WM_SETFONT, and WM_PAINT messages. When it receives a WM_SETTEXT message, the window copies the text to a local buffer and then invalidates the entire window to force the sending of a WM_PAINT message. When the window receives a WM_SETFONT message, it saves the font handle for use in its paint routine. Most of the work is done by the paint routine, which is shown here:</p>
<pre><code>static void Paint(HWND hWnd, LPPAINTSTRUCT lpPS)
{
 &nbsp;&nbsp; RECT rc;
 &nbsp;&nbsp; HFONT hfntOld = NULL;

 &nbsp;&nbsp; GetClientRect(hWnd, &amp;rc);
 &nbsp;&nbsp; SetBkMode(lpPS-&gt;hdc, TRANSPARENT);

 &nbsp;&nbsp; if (hfnt) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hfntOld = SelectObject(lpPS-&gt;hdc, hfnt);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; SetTextColor(lpPS-&gt;hdc, GetSysColor(COLOR_WINDOWTEXT));

 &nbsp;&nbsp; DrawText(lpPS-&gt;hdc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szCaption,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;rc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DT_CENTER);

 &nbsp;&nbsp; if (hfntOld) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SelectObject(lpPS-&gt;hdc, hfntOld);
 &nbsp;&nbsp; }
}
</code></pre>
<p>
At the start of the procedure, we get the client rectangle information that tells us where we can draw. The background mode is set to transparent, and if a WM_SETFONT message has provided a specific font handle, it is selected into the DC provided in the paint message. <b>DrawText</b> is then used to render the text into the DC and to restore the font, if it has been changed, to what it originally was.</p>
<p>
What makes this window flicker when we update it frequently? The answer is that Windows asks the window procedure to repaint the window as a two-step process. First, it sends a WM_ERASEBKGND message and then a WM_PAINT message. The default handling for the WM_ERASEBKGND message is to fill the area with the current window background color. So the sequence of events is first to fill the area with solid color and then to draw the text on top. The net result of doing this frequently is that the window state alternates between its erased state and its drawn state—it flickers.</p>
<h2>A Control That Doesn't Flicker</h2>
<p>
To prevent the control from flickering when we update it frequently, we need to make two changes to how the control handles messages. First, we need to prevent Windows from providing the default handling of WM_ERASEBKGND messages. Secondly, we need to handle WM_PAINT messages so that the background is painted with the window background color and so that the changes to the control's client area happen at once. Here's the new window procedure:</p>
<pre><code>LRESULT CALLBACK NoFlickerWndProc(HWND hWnd, UINT msg,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WPARAM wParam, LPARAM lParam)
{
 &nbsp;&nbsp; PAINTSTRUCT ps;

 &nbsp;&nbsp; switch(msg) {
 &nbsp;&nbsp; case WM_SETTEXT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstrcpy(szCaption, (LPSTR)lParam);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InvalidateRect(hWnd, NULL, TRUE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case WM_SETFONT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hfnt = (HFONT) wParam;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case WM_ERASEBKGND:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (LRESULT)1; // Say we handled it.

 &nbsp;&nbsp; case WM_PAINT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BeginPaint(hWnd, &amp;ps);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Paint(hWnd, &amp;ps);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EndPaint(hWnd, &amp;ps);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DefWindowProc(hWnd, msg, wParam, lParam);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return NULL;
}
</code></pre>
<p>
The only change here is that we now process the WM_ERASEBKGND message by returning a nonzero value, which tells Windows that we have taken care of it. This prevents the <b>DefWindowProc</b> function from performing the default action, which would normally erase the client area. The other changes are made in the paint routine shown here:</p>
<pre><code>static void Paint(HWND hWnd, LPPAINTSTRUCT lpPS)
{
 &nbsp;&nbsp; RECT rc;
 &nbsp;&nbsp; HDC hdcMem;
 &nbsp;&nbsp; HBITMAP hbmMem, hbmOld;
 &nbsp;&nbsp; HBRUSH hbrBkGnd;
 &nbsp;&nbsp; HFONT hfntOld;

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Get the size of the client rectangle.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; GetClientRect(hWnd, &amp;rc);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Create a compatible DC.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; hdcMem = CreateCompatibleDC(lpPS-&gt;hdc);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Create a bitmap big enough for our client rectangle.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; hbmMem = CreateCompatibleBitmap(lpPS-&gt;hdc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.right-rc.left,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.bottom-rc.top);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Select the bitmap into the off-screen DC.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; hbmOld = SelectObject(hdcMem, hbmMem);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Erase the background.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; hbrBkGnd = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
 &nbsp;&nbsp; FillRect(hdcMem, &amp;rc, hbrBkGnd);
 &nbsp;&nbsp; DeleteObject(hbrBkGnd);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Select the font.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; if (hfnt) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hfntOld = SelectObject(hdcMem, hfnt);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Render the image into the offscreen DC.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; SetBkMode(hdcMem, TRANSPARENT);
 &nbsp;&nbsp; SetTextColor(hdcMem, GetSysColor(COLOR_WINDOWTEXT));
 &nbsp;&nbsp; DrawText(hdcMem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szCaption,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;rc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DT_CENTER);

 &nbsp;&nbsp; if (hfntOld) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SelectObject(hdcMem, hfntOld);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Blt the changes to the screen DC.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; BitBlt(lpPS-&gt;hdc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.left, rc.top,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc.right-rc.left, rc.bottom-rc.top,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hdcMem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SRCCOPY);

 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Done with off-screen bitmap and DC.
 &nbsp;&nbsp; //

 &nbsp;&nbsp; SelectObject(hdcMem, hbmOld);
 &nbsp;&nbsp; DeleteObject(hbmMem);
 &nbsp;&nbsp; DeleteDC(hdcMem);

}
</code></pre>
<p>
As you can see, quite a lot has changed here. The new window procedure obtains the client rectangle coordinates as before and then creates a memory DC that is compatible with the DC supplied in the paint message. We can't draw to this DC with any effect yet because, by default, it has only a 1-by-1 monochrome bitmap associated with it. The next thing to do, therefore, is create a bitmap that has the same color organization as the DC we want to draw in and select that bitmap into the memory DC. Now we can draw on the memory DC, which will affect the bits in the bitmap selected in it. In other words, the bitmap will save the image of whatever we draw on the DC.</p>
<p>
When the bitmap was created, nothing was done to any of the pixels in it, and consequently, we need to set them all to a known state. To do this, we fill the area with background color by creating a brush of that color and then using the <b>FillRect</b> function to do the work.</p>
<p>
Once this has been done, we can perform the same operations that were performed in the flickering version: Set the background mode, select the font to use, and call <b>DrawText</b> to generate the text image. At this point the memory DC has the image of what we want to appear in the client area of the control window, and we can transfer the image from the memory DC to the window DC by calling <b>BitBlt</b>. This copies the entire rectangle (background and text image) in one go—and that's what stops you from seeing any flickering effect.</p>
<p>
Once the blt is done, we can free the memory bitmap and DC, and exit the paint procedure.</p>
<h2>Further Improvements</h2>
<p>
If performance is an issue for your application, you can do further optimizations.</p>
<h3>Maintaining a Permanent Bitmap</h3>
<p>
Instead of creating a compatible bitmap each time the window is painted, you might consider creating the bitmap when the window is created and storing the handle to it in an extra word of window information created by setting the <b>cbWndExtra</b> field to sizeof(HBITMAP) when the window class is registered. At WM_CREATE time, allocate local memory for the bitmap and save the handle to it in the extra window word.</p>
<p>
In processing the WM_PAINT message, you can quickly get the bitmap handle and proceed as before. This ensures that you cannot run out of local memory at paint time trying to allocate the bitmap, but does mean that you must also destroy and recreate the bitmap each time the window size changes.</p>
<h3>Updating Only the Out-of-Date Regions</h3>
<p>
You may commonly find part of a large window area overlapped by another window, and consequently, much of what you might be painting is hidden. The PAINTSTRUCT information in the WM_PAINT message contains a clipping rectangle. You can use this information to work out what bits of your image need to be repainted and thus avoid repainting the entire thing needlessly. This is most effective when the paint procedure has a lot of work to do and least effective if the paint procedure has something simple like a blt to do.</p>
<h2>Summary</h2>
<p>
Using an off-screen DC is simple to do and greatly enhances the visual impression of controls that have constantly changing data.</p>
</BODY>
</HTML>
