<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Visual C++ 5.0 to Build Microsoft Transaction Server Components</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Using Visual C++ 5.0 to Build Microsoft Transaction Server Components</h1>
<p>
<img src="sql_mts_11.gif" border=0></p>
<p>
To create a Microsoft Transaction Server component with Microsoft Visual&nbsp;C++ version 5.0, you must create an Active Template Library (ATL). An ATL is a set of template-based C++ classes with which you can easily create small, fast COM objects. It has unique support for key COM features including: stock implementations of <b>IUnknown</b>, <b>IClassFactory</b>, <b>IClassFactory2</b> and <b>Idispatch </b>interfaces; dual interfaces; standard COM enumerator interfaces; connection points; tear-off interfaces; and ActiveX controls. </p>
<p>
ATL provides built-in support for many fundamental COM interfaces and can be used to create single-thread objects, apartment-model objects, free-thread–model objects, or both free-thread and apartment-model objects. ATL allows you to create COM objects as well as an Automation server and ActiveX controls. </p>
<p>
Template libraries, such as ATL, differ from traditional C++ class libraries in that they are typically supplied only as source code (or as source code with some supporting run time) and are not inherently or necessarily hierarchical in nature. Rather than deriving functionality from a class, you instantiate a class from a template.
<ul type=disc>
<li>
To begin, start a new project, click <b>ATL COM AppWizard</b>, and then click <b>OK</b>.<p>
<img src="sql_mts_12.gif" border=0></P></li>
<li>
There are several options to select from. For Microsoft Transaction Server, you must create a DLL. Adding support for MFC and proxt/stub code is optional. Click <b>Finish</b>; the AppWizard generates the object.<p>
<img src="sql_mts_13.gif" border=0></P><p class=tl>
At this point, you have a project but must still create the component. You can use the ATL Object Wizard to do this. The object wizard contains many types of objects and controls. Some of these objects are already optimized for specific situations—for example, the Transaction Server Object is preset with a lot of the options required by Microsoft Transaction Server, including threading, aggregation, and using the correct headers/libraries.</P></li>
<li>
On the Insert menu, click ATL Object Wizard, and then click Transaction Server Object.<p>
<img src="sql_mts_14.gif" border=0></P></li>
<li>
By specifying the name property, Visual&nbsp;C++ generates names for the associated interfaces. You can also set some Microsoft Transaction Server options on the <b>MTX</b> tab. Two of the most important options are pooling and recycling. To generate an implementation of the <b>IObjectControl</b> interface, select these. <p>
<img src="sql_mts_15.gif" border=0></P></li>
<li>
The next step is to add a method to the object. Visual&nbsp;C++ 5.0 provides COM editing support through dialog boxes; you do not need to edit manually. To add a method to the object, right click the object, and then click <b>Add Method</b>.<p>
<img src="sql_mts_16.gif" border=0></P><p class=tl>
In this instance, the method name is specified and it has two parameters, <b>lAccountID</b>, which is of type long and the password, which is of type BSTR.</P><p>
<img src="sql_mts_17.gif" border=0></P></li>
<li>
With the method now added, you can add the implementation for it. First, add the code for the database connection. You use ODBC code; it manages the HDBC and HSTMT handles. Most developers have this code already done and can paste it in. You can use this code or your own and insert it by clicking <b>Project</b>, <b>Add to Project</b>, <b>Files</b>.</li>
</ul>
<h3>Code Sample</h3>
<pre><code>// Connect.cpp
#include "stdafx.h"
#include "connect.h"

CConnection::CConnection()
{
 &nbsp; m_hEnv = NULL;
 &nbsp; m_hDBC = NULL;
 &nbsp; m_hStmt = NULL;
}

CConnection::~CConnection()
{
 &nbsp; if ((m_hStmt != NULL) || (m_hDBC != NULL) || (m_hEnv != NULL))
 &nbsp;&nbsp;&nbsp;&nbsp; FreeConnection();
}

BOOL CConnection::InitConnection()
{
 &nbsp; RETCODE rc;

 &nbsp; ::SQLAllocEnv(&amp;m_hEnv);
 &nbsp; ::SQLAllocConnect(m_hEnv, &amp;m_hDBC);
 &nbsp; ::SQLConnect(m_hDBC, (UCHAR FAR*) "VCEESamples", SQL_NTS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UCHAR FAR*) "sa", SQL_NTS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, SQL_NTS);
 &nbsp; rc = ::SQLAllocStmt(m_hDBC, &amp;m_hStmt);

 &nbsp; if (rc == SQL_SUCCESS)
 &nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
}

BOOL CConnection::FreeConnection()
{
 &nbsp; RETCODE rc = SQL_SUCCESS;

 &nbsp; if (m_hStmt != NULL)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; ::SQLFreeStmt(m_hStmt, SQL_DROP);
 &nbsp;&nbsp;&nbsp;&nbsp; m_hStmt = NULL;
 &nbsp; }

 &nbsp; if (m_hDBC != NULL)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; ::SQLDisconnect(m_hDBC);
 &nbsp;&nbsp;&nbsp;&nbsp; ::SQLFreeConnect(m_hDBC);
 &nbsp;&nbsp;&nbsp;&nbsp; m_hDBC = NULL;
 &nbsp; }

 &nbsp; if (m_hEnv != NULL)
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; rc = ::SQLFreeEnv(m_hEnv);
 &nbsp;&nbsp;&nbsp;&nbsp; m_hEnv = NULL;
 &nbsp; }

 &nbsp; if (rc == SQL_SUCCESS)
 &nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
}
// Connect.h : declarations for simple ODBC connection 
//

#ifndef ___CONNECTION___
#define ___CONNECTION___

#include "stdafx.h"

class CConnection
{
// Constructors and Destructors
public:
 &nbsp; CConnection();
 &nbsp; ~CConnection();

// Attributes
protected:
 &nbsp; HENV&nbsp;&nbsp;&nbsp; m_hEnv;
 &nbsp; HDBC&nbsp;&nbsp;&nbsp; m_hDBC;
 &nbsp; HSTMT&nbsp;&nbsp; m_hStmt;

public:
 &nbsp; HSTMT&nbsp;&nbsp; GetStatement() { return m_hStmt; };


// Operations
public:
 &nbsp; BOOL InitConnection();
 &nbsp; BOOL FreeConnection();
};

#endif // ___CONNECTION___
</code></pre>
<p>
Because you will use ODBC, you must add SQL headers to the Stdafx.h file and the Odbc32.lib file to the link line.</p>
<pre><code>// stdafx.h: Include file for standard system include files
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or project-specific include files that are used frequently
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; but changed infrequently.

#if !defined(AFX_STDAFX_H__7AD7B931_FC53_11D0_971C_00C04FB907A0__INCLUDED_)
#define AFX_STDAFX_H__7AD7B931_FC53_11D0_971C_00C04FB907A0__INCLUDED_

#if _MSC_VER &gt;= 1000
#pragma once
#endif // _MSC_VER &gt;= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include &lt;atlbase.h&gt;
//You can derive a class from CComModule and use it if you want 
//to override something, but do not change the name of 
//_Module extern CComModule _Module;
#include &lt;atlcom.h&gt;

//{{AFX_INSERT_LOCATION}}
//Microsoft Developer Studio will insert additional declarations
//immediately before the previous line.

#endif 
//!defined(AFX_STDAFX_H__7AD7B931_FC53_11D0_971C_00C04FB907A0__INCLUDED)
</code></pre>
<p>
To add Odbc32.lib, click <b>Project</b>, <b>Settings</b>, <b>All Configurations</b>, and then the<b> Link</b> tab, and add Odbc32.lib in the <b>Libraries </b>line.</p>
<p>
To implement this method, first declare and initialize the connection to the database. The <b>InitConnection</b> function connects to the database.</p>
<p>
Because you will use Microsoft Transaction Server, you disconnect from the database as soon as you are finished with the operation. MTS, through the ODBC version 3.0 driver manager, will automatically pool this connection. If the application requires the connection again, it will be set up from the pool. </p>
<pre><code>rc = ::SQLPrepare(connection.GetStatement(), 
 &nbsp;&nbsp;&nbsp;&nbsp; (SQLCHAR*)"{call sp_validaccount2(?,?)}", SQL_NTS);
rc = ::SQLBindParameter(connection.GetStatement(), 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &amp;lAccountID, 0, &amp;cbAccountID);
rc = ::SQLBindParameter(connection.GetStatement(), 2, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_VARCHAR, 4, 0, &amp;szPin[0], _tcslen(&amp;szPin[0]), &amp;cbPin);

rc = ::SQLExecute(connection.GetStatement());
connection.FreeConnection();

if ((rc != SQL_SUCCESS) &amp;&amp; (rc != SQL_SUCCESS_WITH_INFO))
{
 &nbsp; m_spObjectContext-&gt;SetAbort();
 &nbsp; return E_FAIL;
}

m_spObjectContext-&gt;SetComplete();
return S_OK;
</code></pre>
<p>
The <b>SQLPrepare</b> and <b>SQLexecute</b> functions are the only implementation required. After you have completed coding, you generate the DDL with Visual&nbsp;C++ and then use Microsoft Transaction Server Explorer to build a package and register it with the Microsoft Transaction Server run-time environment.</p>
<h3>Debugging Tip</h3>
<p>
Visual&nbsp;C++ allows for debugging of transaction components either locally or from a remote server. When you use Microsoft Transaction Server Explorer, the run-time environment allocates a transaction context. As an optimization, MTS won't allocate transactions unless it has to. By specifying that the component will run as an in-process server, you can then debug the component. To do this, click the <b>Activation</b> tab and select <b>In the creator's process</b>. You can leave <b>In a server process</b> selected as well.</p>
<p>
To prevent deadlocking, MTS terminates a transaction after a preset amount of time. While debugging your component, you could easily exceed the default time of 60 seconds. To disable this, click the properties for the computer and set its transaction timeout to zero seconds. This allows you to stop on breakpoints properly.</p>
<p>
To do this, right click <b>My Computer</b>, and then click <b>Properties</b>. Select options, and then set the transaction timeout to 0 seconds.</p>
<p>
Here are a few other things you should remember when creating MTS components and applications:
<ul type=disc>
<li>
State and resource usage. Always release resources as soon as possible. Allow the component to recycle itself. Resource usage has a big impact on scalability. Microsoft Transaction Server automatically manages resources to optimum efficiency.<br><br></li>
<li>
Build components using high performance/low resource tools, such as ATL. A regular ATL COM component has only about 12 bytes of instance data per object. This makes a big difference when creating a small, fast, MTS component.</li>
</ul>
</BODY>
</HTML>
