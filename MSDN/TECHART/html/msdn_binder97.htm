<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>New OLE Interfaces for the Office 97 Binder</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_binder97"></a>New OLE Interfaces for the Office 97 Binder </h1>
<p>
by Vinod Anantharaman</p>
<p>
August 26, 1996</p>
<h2>Abstract</h2>
<p>
This article describes two interesting new container interfaces supported by the Office 97 Binder. The first set of interfaces is used to support common headers and footers across Binder sections, while the second is used to print preview sections contained in a Binder. Third party applications can implement the corresponding <i>server side</i> interfaces to take advantage of these features when they are contained as sections within an Office 97 Binder.</p>
<h2>1. Binder Headers and Footers</h2>
<p>
The Office 97 Binder allows common headers and footers across multiple heterogeneous sections contained in the Binder. The user interface for the Binder header/footer feature is accessed from the Binder Page Setup dialog on the File menu. Users can apply the Binder header/footer to sections created with Word 97, Excel 97 and Powerpoint 97. The shared header/footer can also be applied to third party applications that implement the necessary server interfaces described in this section.</p>
<p>
Binder and server applications will communicate through two new interfaces: <code>IMsoHdrFtrProvider</code>, implemented by Binder, and <code>IMsoHdrFtrClient</code>, implemented by the server application. (In order to minimize the number of interfaces to be implemented by the server application, we decided against using <code>IDataObject</code> and <code>IAdviceSink</code> for the necessary data transfer.) </p>
<p>
The header/footer interfaces and data structures are as follows:</p>
<pre><code>/* Header footer item types */
typedef enum {
 &nbsp; MSOHFIT_TEXT,
 &nbsp; MSOHFIT_FACE,
 &nbsp; MSOHFIT_SIZE,
 &nbsp; MSOHFIT_EFFECTS,
 &nbsp; MSOHFIT_PAGENUM,
 &nbsp; MSOHFIT_TOTALPAGES,
 &nbsp; MSOHFIT_SECTIONNUM,
 &nbsp; MSOHFIT_SECTIONNAME,
 &nbsp; MSOHFIT_BINDERNAME,
 &nbsp; MSOHFIT_DATE,
 &nbsp; MSOHFIT_TIME
 &nbsp; MSOHFIT_BITMAP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not currently used
} <b>MSOHFIT</b>;

/* Supported style flags */
typedef enum 
{
 &nbsp; MSOEFFECT_BOLD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x00000001,
 &nbsp; MSOEFFECT_ITALIC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x00000002,
 &nbsp; MSOEFFECT_UNDERLINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x00000004,
 &nbsp; MSOEFFECT_STRIKEOUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x00000008
} <b>MSOEFFECT</b>;

/* Used in IMsoHdrFtrProvider::GetFieldValues() */
typedef struct tagHDRFTRFIELD
{
/* msohfit can be one of {MSOHFIT_PAGENUM, MSOHFIT_TOTALPAGES, MSOHFIT_SECTIONNUM, MSOHFIT_SECTIONNAME, MSOHFIT_BINDERNAME, MSOHFIT_DATE, MSOHFIT_TIME} */
 &nbsp; MSOHFIT msohfit;

 &nbsp; ULONG cwActual;
 &nbsp; ULONG cwBuf;&nbsp;&nbsp; /* size in wide chars of the buffer for text */
 &nbsp; wchar_t *wz;&nbsp;&nbsp; /* Ptr to buffer into which callee writes the text */
} <b>HDRFTRFIELD</b>;

/* This structure represents one ‘item’ of hdr/ftr data.&nbsp; It can hold a piece of text, a style definition, a font name, a font size, or a binder field. */
typedef struct&nbsp; tagHDRFTRITEM
{
DWORD msohfit;
union 
{
/* Applies if msohfit is MSOHFIT_SIZE or MSOHFIT_EFFECTS.
If msohfit is MSOHFIT_SIZE, dwParam holds the font size in twips.
If msohfit is MSOHFIT_ EFFECTS, dwParam is a set of MSOEFFECT flags */
DWORD dwParam;

/* Applies if msohfit is MSOHFIT_TEXT or MSOHFIT_FACE. pvParam is a pointer to the text or the font name. dwParamLen holds the number of bytes pointed to by pvParam, including the string terminator. */
struct&nbsp; 
{
 &nbsp; DWORD dwParamLen;
 &nbsp; byte *pvParam;
};

/* for other values of msohfit, there are no parameters */
};
} <b>HDRFTRITEM</b>;

/* A hdr/ftr section is a block of hdr/ftr data.&nbsp; It can hold the left hdr, center hdr, right hdr, left ftr, center ftr or right ftr.&nbsp; It is made up of an array of hdr/ftr items. */
typedef struct tagHDRFTRSECTION
{
 &nbsp; DWORD dwCount;&nbsp;&nbsp; // number of items pointed to by pItems.
 &nbsp; HDRFTRITEM *pItems;
} <b>HDRFTRSECTION</b>;

/* Implemented by Binder. */
interface <b>IMsoHdrFtrProvider</b> : IUnknown
{
 &nbsp; typedef IMsoHdrFtrProvider *LPMSOHDRFTRPROVIDER;

/* Called by the server to get the string value of some fields.&nbsp; cFields specifies the number of fields. hffFields is an array of cField HDRFTRFIELD structs. */
 &nbsp; HRESULT GetFieldValues(
 &nbsp;&nbsp;&nbsp;&nbsp; ULONG cFields,
 &nbsp;&nbsp;&nbsp;&nbsp; HDRFTRFIELD hffFields[]);

/* Called by the server to tell binder whether this section is to use the global header/footer. Binder will change the state of ‘Apply binder header/footer to’ box appropriately. UseGlobalHeaderFooter(FALSE) is called by the server when the user decides to use custom headers/footers through the server’s UI. UseGlobalHeaderFooter(TRUE) will normally not be called. */
 &nbsp; HRESULT UseGlobalHeaderFooter(
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL fUseGlobal);
}

/* Implemented by the server application */
interface <b>IMsoHdrFtrClient</b> : IUnknown
{
 &nbsp; typedef IMsoHdrFtrClient *LPMSOHDRFTRCLIENT;

/* Called initially by binder to give its IMsoHeaderFooterProvider pointer to the server */
 &nbsp; HRESULT SetProvider(
 &nbsp;&nbsp;&nbsp;&nbsp; IMsoHdrFtrProvider *pmsohfp);

/* Called by binder to tell the server whether it should use the global headers/footers as&nbsp;&nbsp; opposed to custom ones. Binder will call this when the user changes the state of the section in the ‘Apply binder header/footer to’ box. */
 &nbsp; HRESULT UseGlobalHeaderFooter(
 &nbsp;&nbsp;&nbsp;&nbsp; BOOL fUseGlobal);

/* Called by binder to to give the hdr/ftr data to the server.&nbsp; The entries are in the order {left hdr,center hdr, right hdr, left ftr, center ftr, right ftr} */
 &nbsp; HRESULT SetData(
 &nbsp;&nbsp;&nbsp;&nbsp; HDRFTRSECTION rghfs[6]);
}
</code></pre>
<h3>How does it work?</h3>
<p>
The general communication path between Binder and a server application for Binder header and footer is described below:</p>
<p>
When a section object is run, Binder queries the server for <code>IMsoHdrFtrClient</code>.&nbsp; If it cannot get this interface pointer, then the section will not use the header/footer feature.</p>
<p>
If Binder successfully obtains an <code>IMsoHdrFtrClient</code> pointer, it calls the <code>IMsoHdrFtrClient::SetProvider</code> method, passing a pointer to its implementation of <code>IMsoHdrFtrProvider</code>.</p>
<p>
The server saves the interface pointer it got from <code>SetProvider</code>.</p>
<p>
Whenever the header/footer information changes in Binder (as a result of the user bringing up the ‘Binder Page Setup’ dialog), Binder calls <code>IMsoHdrFtrClient::SetData</code>, and passes all the data to the server.</p>
<p>
If the user changes the ‘Apply binder header/footer to’ settings through the ‘Binder Page Setup’ dialog, Binder will call <code>IMsoHeaderFooterClient::UseGlobalHeaderFooter</code> to tell the server whether it should be using the global headers and footers, or its own custom version.</p>
<p>
Similarly, when the user tells the server (through whatever UI the server provides) whether it should use the global headers and footers, the server calls <code>IMsoHeaderFooterProvider::UseGlobalHeaderFooter</code>.&nbsp; Binder needs this information to properly display the state of the sections in the ‘Apply binder header/footer to’ box.</p>
<h2>2. Binder Print Preview</h2>
<p>
The Office 97 Binder allows in-place print preview across multiple heterogeneous sections contained in the Binder. The print preview command is accessed from the Binder File menu. Sections created using Word 97 and Excel 97 support print previews inside Office 97 Binder. Third party applications that implement the necessary server interfaces described in this section can also make use of this feature.</p>
<p>
In order to support print preview, server applications need to implement the <code>IInplacePrintPreview</code> interface, which has 3 methods: <code>StartPrintPreview</code>, <code>EndPrintPreview</code>, and <code>QueryStatus</code>, all of which are input-sync. The container (Binder) implements the <code>IPreviewCallback</code> interface. </p>
<p>
The print preview interfaces and data structures are shown below:</p>
<pre><code>interface <b>IInplacePrintPreview</b> : IUnknown
{
 &nbsp; typedef [unique] IInplacePrintPreview *LPPRINTPREVIEW;

 &nbsp; typedef enum
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; PREVIEWFLAG_MAYBOTHERUSER&nbsp;&nbsp;&nbsp; = 1,
 &nbsp;&nbsp;&nbsp;&nbsp; PREVIEWFLAG_PROMPTUSER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2,
 &nbsp;&nbsp;&nbsp;&nbsp; PREVIEWFLAG_USERMAYCHANGEPRINTER&nbsp; = 4,
 &nbsp;&nbsp;&nbsp;&nbsp; PREVIEWFLAG_RECOMPOSETODEVICE&nbsp;&nbsp; = 8,
 &nbsp; } PREVIEWFLAG;

 &nbsp; HRESULT __stdcall StartPrintPreview(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] DWORD grfFlags,
 &nbsp;&nbsp;&nbsp;&nbsp; [in] DVTARGETDEVICE *pptd,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] IPreviewCallback *ppCallback,
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; LONG nFirstPage);

 &nbsp; [input_sync] 
 &nbsp; HRESULT __stdcall EndPrintPreview([in] BOOL fForceClose);
 &nbsp;&nbsp; 
 &nbsp; [input_sync] 
 &nbsp; HRESULT QueryStatus();
}
 &nbsp; 
interface <b>IPreviewCallback</b> : IUnknown
{
 &nbsp; typedef [unique] IPreviewCallback *LPPREVIEWCALLBACK;

 &nbsp; typedef enum
 &nbsp; {
 &nbsp;&nbsp; NOTIFY_FINISHED = 1,
 &nbsp;&nbsp; NOTIFY_BUSY = 2,
 &nbsp;&nbsp; NOTIFY_IDLE = 4,
 &nbsp;&nbsp; NOTIFY_DISABLERESIZE = 8,
 &nbsp;&nbsp; NOTIFY_QUERYCLOSEPREVIEW = 16,
 &nbsp;&nbsp; NOTIFY_FORCECLOSEPREVIEW&nbsp; = 32,
 &nbsp;&nbsp; NOTIFY_UIACTIVE&nbsp;&nbsp;&nbsp;&nbsp; = 64,
 &nbsp;&nbsp; NOTIFY_UNABLETOPREVIEW&nbsp;&nbsp;&nbsp;&nbsp; = 128
 &nbsp; } NOTIFICATIONFLAG;

 &nbsp; [input_sync] 
 &nbsp; HRESULT Notify(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] DWORD wStatus, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] LONG nLastPage, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in, unique] wchar_t * pwszPreviewStatus);
}
</code></pre>
<h3>Print preview interface description</h3>
<p>
The grfFlags in the call to StartPrintPreview&nbsp; maybe a combination of the following&nbsp; -PREVIEWFLAG_RECOMPOSETODEVICE, PREVIEWFLAG_PROMPTUSER, PREVIEWFLAG_MAYBOTHERUSER, PREVIEWFLAG_USERMAYCHANGEPRINTER. Binder uses the first 2 flags mentioned above.</p>
<p>
The caller creates a target device and passes a pointer to the target device to the&nbsp; <code>StartPrintPreview</code> method. A pointer to <code>IPreviewCallback</code> implemented by the caller is also passed in through <code>StartPrintPreview</code> so the callee can callback into the caller with notifications on preview status. The callee must <code>AddRef</code> the latter. The last parameter is the starting page number. </p>
<p>
<code>IPreviewCallback</code> is implemented by the caller.&nbsp; This interface has one method – <code>Notify</code>. The first parameter to the <code>Notify</code> function&nbsp; is the status – which is any one of the enumerated types in&nbsp; <code>NOTIFICATIONFLAG</code>. The most commonly used one is when the callee has exited&nbsp; from print preview – <code>NOTIFY_FINISHED</code>.&nbsp; Binder will pull down its preview toolbar, re-enable its menu items, and show its left pane when it receives this notification from the section that is in preview mode. Binder is in a fairly modal state during print preview. Other notifications are - <code>NOTIFY_UNABLETOPREVIEW</code> -&nbsp; when the section normally supports the <code>IInplacePrintPreview</code> interface but is unable at that time to go into preview (for instance Excel will fail print preview when it has nothing to print, in which case it notifies Binder via this callback. Binder displays that section as a thumbnail instead of exiting print preview).</p>
<p>
Binder calls <code>EndPrintPreview</code> when the user hits the ‘Exit’ button on the preview toolbar.&nbsp; The section is then expected to&nbsp; take itself out of print preview and then notify Binder via the <code>IPreviewCallback::Notify</code> function with <code>NOTIFY_FINISHED</code>.&nbsp; </p>
<p>
Binder calls the <code>QueryStatus</code> method to find out if the section is able to support PrintPreview at a given time. This is useful for sections that normally support <code>IInplacePrintPreview</code>, but may be unable to when they are in specific states.</p>
<p>
Based on the result from <code>QueryStatus</code> Binder will decide to enable or disable the Print Preview command on the Binder Section menu.&nbsp; Given that a section supports <code>IInplacePrintPreview</code>, Binder will first call <code>QueryStatus</code>, if that succeeds Binder will call <code>StartPrintPreview</code> with the appropriate parameters. Finally to end the preview, Binder will call <code>EndPrintPreview</code>.</p>
<p>
If the section does not support the <code>IInplacePrintPreview</code> interface, Binder unloads the section to the loaded state and shows it in thumbnail mode.&nbsp; The user can still use the Previous, Next and Exit buttons on Binder’s preview toolbar.&nbsp; </p>
<p>
Print preview&nbsp; is similarly implemented at the <i>section level</i>, except only the active section will be put in preview mode. Binder’s preview toolbar will not be shown in this case and the user cannot navigate across sections in this mode.&nbsp; The server’s preview toolbar button is implemented via the <code>IMsoCommandTarget</code> interface.&nbsp; The inplace section has to call Binder’s <code>IMsoCommandTarget::Exec</code> with <code>MSOCMDID_PRINTPREVIEW</code>.&nbsp;&nbsp; Binder will put only the active section into preview without showing Binder’s preview toolbar.</p>
</BODY>
</HTML>
