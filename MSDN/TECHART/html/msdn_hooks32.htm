<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Win32 Hooks</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_hooks32"></a>Win32 Hooks</h1>
<p>
Kyle Marsh<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: July 29, 1993</p>
<p>
Revised: February 1994<br>
Added exception for journal hooks in "Filter functions in DLLs" section.<br>
Added .EXE file to where filters can reside in "WH_JOURNALRECORD" and "WH_JOURNALPLAYBACK" sections.<br>
Changed HIWORD and LOWORD to HIBYTE and LOBYTE in "HC_ACTION" section.</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="1566">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the Hooks sample application.</a></p>
<h2>Abstract</h2>
<p>
This article describes hooks and their use in the Microsoft® Win32™ application programming interface (API). It discusses hook functions, filter functions, and the following types of hooks:
<ul type=disc>
<li>
WH_CALLWNDPROC<br><br></li>
<li>
WH_CBT<br><br></li>
<li>
WH_DEBUG<br><br></li>
<li>
WH_FOREGROUNDIDLE<br><br></li>
<li>
WH_GETMESSAGE<br><br></li>
<li>
WH_JOURNALPLAYBACK<br><br></li>
<li>
WH_JOURNALRECORD<br><br></li>
<li>
WH_KEYBOARD<br><br></li>
<li>
WH_MOUSE<br><br></li>
<li>
WH_MSGFILTER<br><br></li>
<li>
WH_SHELL <br><br></li>
<li>
WH_SYSMSGFILTER</li>
</ul>
<p class=indent>
<B><b>Terminology&nbsp;&nbsp;&nbsp;</b></B>In this article, the term <i>Windows</i> refers to the Windows family of operating systems, that is, 16-bit Windows, Windows NT™, and Windows for Workgroups. Likewise, <i>Windows 3.1</i> refers to the 3.1 version of these operating systems.</p>
<h2>Introduction</h2>
<p>
In the Microsoft® Windows™ operating system, a hook is a mechanism by which a function can intercept events (messages, mouse actions, keystrokes) before they reach an application. The function can act on events and, in some cases, modify or discard them. Functions that receive events are called <i>filter functions</i> and are classified according to the type of event they intercept. For example, a filter function might want to receive all keyboard or mouse events. For Windows to call a filter function, the filter function must be installed—that is, attached—to a Windows hook (for example, to a keyboard hook). Attaching one or more filter functions to a hook is known as <i>setting</i> a hook. If a hook has more than one filter function attached, Windows maintains a chain of filter functions. The most recently installed function is at the beginning of the chain, and the least recently installed function is at the end.</p>
<p>
When a hook has one or more filter functions attached and an event occurs that triggers the hook, Windows calls the first filter function in the filter function chain. This action is known as <i>calling</i> the hook. For example, if a filter function is attached to the CBT hook and an event that triggers the hook occurs (for example, a window is about to be created), Windows calls the CBT hook by calling the first function in the filter function chain.</p>
<p>
To maintain and access filter functions, applications use the <b>SetWindowsHookEx</b> and the <b>UnhookWindowsHookEx</b> functions.</p>
<p>
Hooks provide powerful capabilities for Windows-based applications. These applications can use hooks to:
<ul type=disc>
<li>
Process or modify all messages meant for all the dialog boxes, message boxes, scroll bars, or menus for an application (WH_MSGFILTER).<br><br></li>
<li>
Process or modify all messages meant for all the dialog boxes, message boxes, scroll bars, or menus for the system (WH_SYSMSGFILTER).<br><br></li>
<li>
Process or modify all messages (of any type) for the system whenever a <b>GetMessage</b> or a <b>PeekMessage</b> function is called (WH_GETMESSAGE).<br><br></li>
<li>
Process or modify all messages (of any type) whenever a <b>SendMessage</b> function is called (WH_CALLWNDPROC).<br><br></li>
<li>
Record or play back keyboard and mouse events (WH_JOURNALRECORD, WH_JOURNALPLAYBACK).<br><br></li>
<li>
Process, modify, or remove keyboard events (WH_KEYBOARD).<br><br></li>
<li>
Process, modify, or discard mouse events (WH_MOUSE).<br><br></li>
<li>
Respond to certain system actions, making it possible to develop computer-based training (CBT) for applications (WH_CBT).<br><br></li>
<li>
Prevent another filter from being called (WH_DEBUG).</li>
</ul>
<p>
Applications have used hooks to:
<ul type=disc>
<li>
Provide F1 help key support to menus, dialog boxes, and message boxes (WH_MSGFILTER).<br><br></li>
<li>
Provide mouse and keystroke record and playback features, often referred to as <i>macros</i>. For example, the Windows Recorder accessory program uses hooks to supply record and playback functionality (WH_JOURNALRECORD, WH_JOURNALPLAYBACK).<br><br></li>
<li>
Monitor messages to determine which messages are being sent to a particular window or which actions a message generates (WH_GETMESSAGE, WH_CALLWNDPROC). The Spy utility program in the Win32™ Software Development Kit (SDK) for Windows NT™ uses hooks to perform these tasks. The source for Spy is available in the SDK.<br><br></li>
<li>
Simulate mouse and keyboard input (WH_JOURNALPLAYBACK). Hooks provide the only reliable way to simulate these activities. If you try to simulate these events by sending or posting messages, Windows internals do not update the keyboard or mouse state, which can lead to unexpected behavior. If hooks are used to play back keyboard or mouse events, these events are processed exactly like real keyboard or mouse events. Microsoft Excel uses hooks to implement its SEND.KEYS macro function.<br><br></li>
<li>
Provide CBT for applications that run in the Windows environment (WH_CBT). The WH_CBT hook makes developing CBT applications much easier.</li>
</ul>
<h2>How to Use Hooks</h2>
<p>
To use hooks, you need to know:
<ul type=disc>
<li>
How to use the Windows hook functions to add and remove filter functions to and from a hook's filter function chain.<br><br></li>
<li>
What action the filter function you are installing will be required to perform.<br><br></li>
<li>
What kinds of hooks are available, what they can do, and what information (parameters) they pass to your filter function.</li>
</ul>
<h2>Windows Hook Functions</h2>
<p>
Windows-based applications use the <b>SetWindowsHookEx</b>, <b>UnhookWindowsHookEx</b>, and <b>CallNextHookEx</b> functions to manage the hooks filter function chain. Before version 3.1, Windows implemented hook management with the <b>SetWindowsHook</b>, <b>UnhookWindowsHook</b>, and <b>DefHookProc</b> functions. Although these functions are implemented in Win32, they have fewer capabilities than the new (<b>Ex</b>) versions. Please convert your existing code to the new versions of these functions, and always use the new functions for new code.</p>
<p>
<b>SetWindowsHookEx</b> and <b>UnhookWindowsHookEx</b> are described below. See "Calling the next function in the filter function chain" for a discussion of <b>CallNextHookEx</b>.</p>
<h3>SetWindowsHookEx</h3>
<p>
The <b>SetWindowsHookEx</b> function adds a filter function to a hook. This function takes four arguments:
<ul type=disc>
<li>
An integer code describing the hook to which to attach the filter function, and the address of the filter function. These codes are defined in WINUSER.H and are described later.<br><br></li>
<li>
The address of the filter function. The filter function must be exported by including it in the <b>EXPORTS</b> statement in the module definition file for the application or dynamic-link library (DLL), or by using the appropriate compiler flags.<br><br></li>
<li>
The instance handle of the module containing the filter function. In Win32 (unlike Win16), this value should be NULL when installing a thread-specific hook (see below), but does not have to be NULL as the documentation states. When you install a systemwide hook or a thread-specific hook for a thread in another process, you must use the instance handle of the DLL where the filter function resides.<br><br></li>
<li>
The thread ID for which the hook is to be installed. If the thread ID is not zero, the installed filter function will be called only in the context of the specified thread. If the thread ID is zero, the installed filter function has system scope and may be called in the context of any thread in the system. An application or library can use the <b>GetCurrentThreadId</b> function to obtain the thread handle for hooking the current thread.<p class=tl>
Some hooks may be set with system scope only; some may be set only for a specific thread; and others may have either system or thread scope, as shown in the following table.</P></li>
</ul>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Hook</b></td>
<td class=label width=50%><b>Scope</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_CALLWNDPROC</td>
<td width=50%>Thread or System</td>
</tr>
<tr valign=top>
<td width=50%>WH_CBT</td>
<td width=50%>Thread or System</td>
</tr>
<tr valign=top>
<td width=50%>WH_DEBUG</td>
<td width=50%>Thread or System</td>
</tr>
<tr valign=top>
<td width=50%>WH_GETMESSAGE</td>
<td width=50%>Thread or System</td>
</tr>
<tr valign=top>
<td width=50%>WH_JOURNALRECORD</td>
<td width=50%>System Only</td>
</tr>
<tr valign=top>
<td width=50%>WH_JOURNALPLAYBACK</td>
<td width=50%>System Only</td>
</tr>
<tr valign=top>
<td width=50%>WH_FOREGROUNDIDLE</td>
<td width=50%>Thread or System</td>
</tr>
<tr valign=top>
<td width=50%>WH_SHELL</td>
<td width=50%>Thread or System</td>
</tr>
<tr valign=top>
<td width=50%>WH_KEYBOARD</td>
<td width=50%>Thread or System</td>
</tr>
<tr valign=top>
<td width=50%>WH_MOUSE</td>
<td width=50%>Thread or System</td>
</tr>
<tr valign=top>
<td width=50%>WH_MSGFILTER</td>
<td width=50%>Thread or System</td>
</tr>
<tr valign=top>
<td width=50%>WH_SYSMSGFILTER</td>
<td width=50%>System Only</td>
</tr>
</table><br>
<p class=tl>
For a given hook type, thread hooks are called first, followed by system hooks.</P><p class=tl>
It is a good idea to use thread hooks instead of system hooks for several reasons. Thread hooks:</P><ul type=disc>
<li>
Do not incur a systemwide overhead in applications that are not interested in the call.<br><br></li>
<li>
Do not cause all events for a hook to be serialized. For example, if an application installs a systemwide keyboard hook, all keyboard messages for all applications will be funneled through that application's keyboard filter function, effectively wasting the system's multiple input queue functionality. If that filter function stops processing keyboard events, the system will appear stopped to the user, but it will not really be stopped. The user can always use the CTRL+ALT+DEL key combination to log out and solve the problem, but he or she will probably not be happy with all this hassle. Also, users may not realize that they can reset the system with the logout/logon sequence.<br><br></li>
<li>
Do not require packaging the filter function implementation in a separate DLL. All systemwide hooks and hooks for threads in different applications must reside in DLLs.<br><br></li>
<li>
Do not need to share data within a DLL that is attached to different processes. A systemwide filter function, which must reside in a DLL, must also share any data that it needs with other processes. Since this is not default DLL behavior, you must be careful when implementing systemwide filter functions. If a filter function is not correctly developed to share data and uses data in a process in which the data is invalid, the process may crash.</li>
</ul>
<p>
<b>SetWindowsHookEx</b> returns a handle to the installed hook (an HHOOK). The application or library must use this handle to identify this hook later when it calls the <b>UnhookWindowsHookEx</b> function. <b>SetWindowsHookEx</b> returns NULL if it is unable to add the filter function to the hook. <b>SetWindowsHookEx</b> also sets the last error to one of the values listed below to indicate why the function failed.
<ul type=disc>
<li>
ERROR_INVALID_HOOK_FILTER: The hook code is invalid.<br><br></li>
<li>
ERROR_INVALID_FILTER_PROC: The filter function is invalid.<br><br></li>
<li>
ERROR_HOOK_NEEDS_HMOD: A global hook is being set with a NULL <i>hInstance</i> parameter or a thread-specific hook is being set for a thread that is not in the setting application.<br><br></li>
<li>
ERROR_GLOBAL_ONLY_HOOK: A hook that can only be a system hook is being installed to a specific thread.<br><br></li>
<li>
ERROR_INVALID_PARAMETER: The thread ID is invalid.<br><br></li>
<li>
ERROR_JOURNAL_HOOK_SET: There is already a hook set for a journal hook type. Only one journal record or journal playback hook can be installed at one time. This code can also be set if an application tries to set a journal hook while a screen saver is running.<br><br></li>
<li>
ERROR_MOD_NOT_FOUND: The <i>hInstance</i> parameter for a global hook was not a library. (Actually, this value simply means that User was unable to locate the module handle in its list of modules.)<br><br></li>
<li>
Any other value: Security does not allow this hook to be set, or the system is out of memory.</li>
</ul>
<p>
Windows keeps the filter function chain internally (see the figure below) and does not rely on the filter functions to store the address of the next filter function in the chain correctly (as versions of Windows before 3.1 did). Thus, hooks are much more robust in Windows version 3.1 than they were in previous versions. In addition, performance is enhanced significantly because the filter function chain is kept internally.</p>
<p>
<img src="hooks32_1.gif" border=0></p>
<p class=label>
<b>The filter function chain in Windows 3.1</b></p>
<h3>UnhookWindowsHookEx</h3>
<p>
To remove a filter function from a hook's chain, call the <b>UnhookWindowsHookEx</b> function. This function takes the hook handle returned from <b>SetWindowsHookEx</b> and returns a value indicating whether the hook was removed. <b>UnhookWindowsHookEx</b> always returns TRUE at this time.</p>
<h2>Filter Functions</h2>
<p>
Filter (<i>hook</i>) functions are functions that are attached to a hook. Because filter functions are called by Windows and not by an application, they are sometimes referred to as <i>callback functions</i>. For consistency, this article uses the term <i>filter functions.</i></p>
<p>
All filter functions must have the following form:</p>
<pre><code>LRESULT CALLBACK FilterFunc( nCode, wParam, lParam )int nCode;
WORD wParam;
DWORD lParam;
</code></pre>
<p>
All filter functions should return a <b>LONG</b>. <i>FilterFunc </i>is a placeholder for the actual filter function name.</p>
<h3>Parameters</h3>
<p>
Filter functions receive three parameters: <i>ncode</i> (the hook code), <i>wParam</i>, and <i>lParam</i>. The hook code is an integer code that informs the filter function of any additional data it should know. For example, the hook code might indicate what action is causing the hook to be called.</p>
<p>
In previous versions of Windows (before 3.1), the hook code indicated whether the filter function should process the event or call <b>DefHookProc</b>. If the hook code is less than zero, the filter function should not process the event; it should call <b>DefHookProc</b>, passing the three parameters it was passed without any modification. Windows used these negative codes to maintain the filter function chain, with help from the applications.</p>
<p>
Windows 3.1 still requires that if Windows sends a filter function a negative hook code, the filter function must call <b>CallNextHookEx</b> with the parameters Windows passed to the filter function. The filter function must also return the value returned by <b>CallNextHookEx</b>. Windows 3.1 never sends negative hook codes to filter functions.</p>
<p>
The second parameter passed to the filter function, <i>wParam</i>, is a <b>WPARAM</b>, and the third parameter, <i>lParam</i>, is an <b>LPARAM</b>. These parameters pass information needed by the filter function. Each hook attaches different meanings to <i>wParam</i> and <i>lParam</i>. For example, filter functions attached to the WH_KEYBOARD hook receive a virtual-key code in <i>wParam</i>, and <i>lParam</i> contains bit fields that describe the state of the keyboard at the time of the key event. Filter functions attached to the WH_MSGFILTER hook receive a NULL value in <i>wParam</i> and a pointer to a message structure in <i>lParam</i>. Some hooks attach different meanings for <i>wParam</i> and <i>lParam</i> depending on the event that causes the hook to be called. For a complete list of arguments and their meanings for each hook type, see the filter functions listed below in Win32 SDK for Windows NT.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Hook</b></td>
<td class=label width=50%><b>Filter function documentation</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_CALLWNDPROC</td>
<td width=50%><b>CallWndProc</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_CBT</td>
<td width=50%><b>CBTProc</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_DEBUG</td>
<td width=50%><b>DebugProc</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_GETMESSAGE</td>
<td width=50%><b>GetMsgProc</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_JOURNALRECORD</td>
<td width=50%><b>JournalRecordProc</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_JOURNALPLAYBACK</td>
<td width=50%><b>JournalPlaybackProc</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_SHELL</td>
<td width=50%><b>ShellProc</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_KEYBOARD</td>
<td width=50%><b>KeyboardProc</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_MOUSE</td>
<td width=50%><b>MouseProc</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_MSGFILTER</td>
<td width=50%><b>MessageProc</b></td>
</tr>
<tr valign=top>
<td width=50%>WH_SYSMSGFILTER</td>
<td width=50%><b>SysMsgProc</b></td>
</tr>
</table><br>
<h4>Calling the next function in the filter function chain</h4>
<p>
When a hook is set, Windows calls the first function in the hook's filter function chain, and the responsibility of Windows ends. The filter function is responsible for ensuring that the next filter function in the chain is called. Windows supplies <b>CallNextHookEx</b> to enable a filter function to call the next filter in the filter function chain. <b>CallNextHookEx</b> takes four parameters.</p>
<p>
The first parameter is the value returned from the <b>SetWindowsHookEx</b> call. This value is currently ignored by Windows, but this behavior may change in the future.</p>
<p>
The next three parameters—<i>nCode</i>, <i>wParam</i>, and <i>lParam</i>—are the parameters that Windows passed to the filter function.</p>
<p>
Windows stores the filter function chain internally and keeps track of which filter function it is calling. When <b>CallNextHookEx</b> is called, Windows determines the next filter function in the chain and calls that function.</p>
<p>
At times, a filter function may not want to pass an event to the other hook functions on the same chain. In particular, when a hook allows a filter function to discard an event and the filter function decides to do so, the function must not call <b>CallNextHookEx</b>. When a filter function modifies a message, it may decide not to pass the message to the rest of the filter function chain.</p>
<p>
Because filter functions are not installed in any particular order, you cannot be sure where your function is in the filter function chain at any moment except at the moment of installation, when it is the first function in the chain. As a result, you are never absolutely certain that you will get every event that occurs. A filter function installed ahead of your filter function in the chain—a function that was installed after your function timewise—might not pass the event to your filter function.</p>
<h4>Filter functions in DLLs</h4>
<p>
Systemwide filter functions must reside in a DLL. In Win16 it was possible (although not recommended) to install a systemwide hook to a filter function in an application. This does not work in Win32. Do not install systemwide filter functions that are not in DLLs, even if it does seem to work on a particular system. The journal hooks, WH_JOURNALRECORD and WH_JOURNALPLAYBACK, are exceptions to this rule. Because of the way Windows calls these hooks, their filter functions do not have to be in a DLL.</p>
<p>
Filter functions for systemwide hooks must be prepared to share any data they need across the different processes they are running from. A DLL is mapped into the address space of each of its client processes. Global variables within the DLL will be instance specific unless they are placed in a shared data section. For example, the HOOKSDLL.DLL library in the Hooks sample application needs to share two data items:
<ul type=disc>
<li>
The window handle to display messages.<br><br></li>
<li>
The height of the text lines in that window.</li>
</ul>
<p>
To share this data, HOOKSDLL puts these data items in a shared data section. Here are the steps HOOKSDLL takes to share the data:
<ul type=disc>
<li>
Use pragmas to place the data in a named data segment. Note that the data must be initialized for this to work.<pre><code>// Shared DATA
#pragma data_seg(".SHARDATA")
static HWND&nbsp;&nbsp; hwndMain = NULL;&nbsp; // Main hwnd. We will get this from the app.
static int&nbsp;&nbsp;&nbsp; nLineHeight = 0;&nbsp; // Height of lines in window.
#pragma data_seg()
</code></pre>
</li>
<li>
Add a SECTIONS statement to the DLL's .DEF file:<pre><code>SECTIONS
 &nbsp; .SHARDATA&nbsp;&nbsp; Read Write Shared
</code></pre>
</li>
<li>
Create an .EXP file from the .DEF file:<pre><code>hooksdll.exp: hooksdll.obj hooksdll.def
 &nbsp;&nbsp; $(implib) -machine:$(CPU)&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp; -def:hooks.def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp; hooksdll.obj&nbsp; \
 &nbsp; -out:hooksdll.lib
</code></pre>
</li>
<li>
Link with the HOOKSDLL.EXP file:<pre><code>hooksdll.dll: hooksdll.obj hooksdll.def hooksdll.lib hooksdll.exp
 &nbsp;&nbsp; $(link) $(linkdebug)&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp; -base:0x1C000000&nbsp; \
 &nbsp;&nbsp; -dll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp; -entry:LibMain$(DLLENTRY)&nbsp;&nbsp;&nbsp;&nbsp; \
 &nbsp; -out:hooksdll.dll&nbsp;&nbsp;&nbsp; \
 &nbsp; hooksdll.exp hooksdll.obj hooksdll.rbj \
 &nbsp; $(guilibsdll)
</code></pre>
</li>
</ul>
<h2>Types of Hooks</h2>
<h3>WH_CALLWNDPROC</h3>
<p>
Windows calls this hook whenever the Windows <b>SendMessage</b> function is called. The filter functions receive a hook code from Windows indicating whether the message was sent from the current thread and receive a pointer to a structure containing the actual message.</p>
<p>
The CWPSTRUCT structure has the following form:</p>
<pre><code>typedef struct tagCWPSTRUCT {
 &nbsp;&nbsp; LPARAM&nbsp; lParam;
 &nbsp;&nbsp; WPARAM&nbsp; wParam;
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; message;
 &nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp; hwnd;
} CWPSTRUCT, *PCWPSTRUCT, NEAR *NPCWPSTRUCT, FAR *LPCWPSTRUCT;
</code></pre>
<p>
Filters can process the message, but cannot modify the message (this was possible in 16-bit Windows). The message is sent to the Windows function for which it was intended. This hook is a significant drain on system performance, especially when it is installed as a systemwide hook, so use it only as a development or debugging tool.</p>
<h3>WH_CBT</h3>
<p>
To write a CBT application, the developer must coordinate the CBT application with the application for which it is written. Windows supplies the WH_CBT hook to make this possible. Windows passes a hook code to the filter function, indicating which event has occurred and the appropriate data for the event.</p>
<p>
A filter function attached to the WH_CBT hook needs to be aware of ten hook codes:
<ul type=disc>
<li>
HCBT_ACTIVATE<br><br></li>
<li>
HCBT_CREATEWND<br><br></li>
<li>
HCBT_DESTROYWND<br><br></li>
<li>
HCBT_MINMAX<br><br></li>
<li>
HCBT_MOVESIZE<br><br></li>
<li>
HCBT_SYSCOMMAND<br><br></li>
<li>
HCBT_CLICKSKIPPED<br><br></li>
<li>
HCBT_KEYSKIPPED<br><br></li>
<li>
HCBT_SETFOCUS<br><br></li>
<li>
HCBT_QS</li>
</ul>
<h4>HCBT_ACTIVATE</h4>
<p>
Windows calls the WH_CBT hook with this hook code when any window is about to be activated. In the case of thread-specific hooks, the window must be owned by the thread. If the filter function returns TRUE, the window is not activated.</p>
<p>
The <i>wParam</i> parameter contains the handle to the window being activated. The <i>lParam</i> parameter contains a far pointer to <b>CBTACTIVATESTRUCT</b>, which has the following structure:</p>
<pre><code>typedef struct tagCBTACTIVATESTRUCT
{
 &nbsp; BOOL&nbsp;&nbsp;&nbsp; fMouse;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TRUE if activation results from a 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; mouse click; otherwise FALSE. 
 &nbsp; HWND&nbsp;&nbsp;&nbsp; hWndActive;&nbsp;&nbsp;&nbsp;&nbsp; // Contains the handle to the 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; currently active window. 
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;
</code></pre>
<h4>HCBT_CREATEWND</h4>
<p>
Windows calls the WH_CBT hook with this hook code when a window is about to be created. In the case of thread-specific hooks, the thread must be creating the window. The WH_CBT hook is called before Windows sends the WM_GETMINMAXINFO, WM_NCCREATE, or WM_CREATE messages to the window. Thus, the filter function can return TRUE and not allow the window to be created.</p>
<p>
The <i>wParam</i> parameter contains the handle to the window being created. The <i>lParam</i> parameter contains a pointer to the following structure.</p>
<pre><code>/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
struct CBT_CREATEWND
{
 &nbsp;&nbsp; struct tagCREATESTRUCT *lpcs;&nbsp;&nbsp;&nbsp;&nbsp; // The create parameters for the 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; new window.
 &nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwndInsertAfter;&nbsp;&nbsp; // The window this window will
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; be added after, in Z-order.
} CBT_CREATEWND, *LPCBT_CREATEWND;
</code></pre>
<p>
A filter function can alter the <i>hwndInsertAfter</i> value or the values in <i>lpcs</i>.</p>
<h4>HCBT_DESTROYWND</h4>
<p>
Windows calls the WH_CBT hook with this hook code when Windows is about to destroy any window. In the case of thread-specific hooks, the thread must own the window. Windows calls the WH_CBT hook before the WM_DESTROY message is sent. If the filter function returns TRUE, the window is not destroyed.</p>
<p>
The <i>wParam</i> parameter contains the handle to the window being destroyed. The <i>lParam</i> parameter contains 0L.</p>
<h4>HCBT_MINMAX</h4>
<p>
Windows calls the WH_CBT hook with this hook code when Windows is about to minimize or maximize a window. In the case of thread-specific hooks, the thread must own the window. If the filter function returns TRUE, the action does not occur.</p>
<p>
The <i>wParam</i> parameter contains the handle to the window being minimized or maximized. The <i>lParam</i> is any one of the SW_* values defined in WINUSER.H specifying the operation that is taking place.</p>
<h4>HCBT_MOVESIZE</h4>
<p>
Windows calls the WH_CBT hook with this hook code when Windows is about to move or size a window, and the user has just finished selecting the new window position or size. In the case of thread-specific hooks, the thread must own the window. If the filter function returns TRUE, the action does not occur.</p>
<p>
The <i>wParam</i> parameter contains the handle to the window being moved or sized. The <i>lParam</i> parameter contains an <b>LPRECT</b> that points to the drag rectangle.</p>
<h4>HCBT_SYSCOMMAND</h4>
<p>
Windows calls the WH_CBT hook with this hook code when Windows processes a system command. In the case of a thread-specific hook, the thread must own the window whose System menu is being used. The WH_CBT hook is called from within <b>DefWindowsProc</b>. If an application does not send the WH_SYSCOMMAND message to <b>DefWindowsProc</b>, this hook is not called. If the filter function returns TRUE, the system command is not processed.</p>
<p>
The <i>wParam</i> parameter contains the system command (SC_TASKLIST, SC_HOTKEY, and so on) that is about to be performed. If <i>wParam</i> is SC_HOTKEY, the LOWORD of <i>lParam</i> contains the handle to the window for which the hot key applies. If <i>wParam</i> contains any value other than SC_HOTKEY and if the System menu command is selected with the mouse, the LOWORD of <i>lParam</i> contains the horizontal position of the cursor and the HIWORD of <i>lParam</i> contains the vertical position of the cursor.</p>
<p>
The following system commands trigger this hook from within <b>DefWindowProc</b>:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=25%>SC_CLOSE</td>
<td width=75%>Close the window. </td>
</tr>
<tr valign=top>
<td width=25%>SC_HOTKEY</td>
<td width=75%>Activate the window associated with the application-specified hot key.</td>
</tr>
<tr valign=top>
<td width=25%>SC_HSCROLL</td>
<td width=75%>Scroll horizontally. </td>
</tr>
<tr valign=top>
<td width=25%>SC_KEYMENU</td>
<td width=75%>Retrieve a menu through a keystroke.</td>
</tr>
<tr valign=top>
<td width=25%>SC_MAXIMIZE</td>
<td width=75%>Maximize the window. </td>
</tr>
<tr valign=top>
<td width=25%>SC_MINIMIZE </td>
<td width=75%>Minimize the window.</td>
</tr>
<tr valign=top>
<td width=25%>SC_MOUSEMENU</td>
<td width=75%>Retrieve a menu through a mouse click.</td>
</tr>
<tr valign=top>
<td width=25%>SC_MOVE</td>
<td width=75%>Move the window. </td>
</tr>
<tr valign=top>
<td width=25%>SC_NEXTWINDOW</td>
<td width=75%>Move to the next window.</td>
</tr>
<tr valign=top>
<td width=25%>SC_PREVWINDOW</td>
<td width=75%>Move to the previous window.</td>
</tr>
<tr valign=top>
<td width=25%>SC_RESTORE</td>
<td width=75%>Save the previous coordinates (checkpoint). </td>
</tr>
<tr valign=top>
<td width=25%>SC_SCREENSAVE</td>
<td width=75%>Execute the screen-save application.</td>
</tr>
<tr valign=top>
<td width=25%>SC_SIZE</td>
<td width=75%>Size the window.</td>
</tr>
<tr valign=top>
<td width=25%>SC_TASKLIST</td>
<td width=75%>Execute or activate the Windows Task Manager application.</td>
</tr>
<tr valign=top>
<td width=25%>SC_VSCROLL</td>
<td width=75%>Scroll vertically.</td>
</tr>
</table><br>
<h4>HCBT_CLICKSKIPPED</h4>
<p>
Windows calls the WH_CBT hook with this hook code when a mouse event is removed from a thread's input queue and the mouse hook is set. Windows will call a systemwide hook when a mouse event is removed from any input queue and either a systemwide mouse hook or a thread-specific hook for the current thread is installed. This hook code is not generated unless a filter function is attached to the WH_MOUSE hook. Despite its name, HCBT_CLICKSKIPPED is called not only for skipped mouse events but also whenever a mouse event is removed from the system queue. Its main use is to install a WH_JOURNALPLAYBACK hook in response to a mouse event. (See the "WM_QUEUESYNC" section below for more information.)</p>
<p>
The <i>wParam</i> parameter contains the message identifier for the mouse message—for example, the WM_LBUTTONDOWN or any WM_?BUTTON* messages. The <i>lParam</i> parameter contains a far pointer to <b>MOUSEHOOKSTRUCT</b>, which has the following structure:</p>
<pre><code>typedef struct tagMOUSEHOOKSTRUCT {
 &nbsp;&nbsp; POINT&nbsp;&nbsp; pt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Location of mouse in screen coordinates
 &nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp; hwnd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Window that receives this message
 &nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp; wHitTestCode;&nbsp;&nbsp; // The result of hit-testing (HT_*)
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; dwExtraInfo;&nbsp;&nbsp;&nbsp; // Extra info associated with the current message 
} MOUSEHOOKSTRUCT, FAR *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;
</code></pre>
<h4>HCBT_KEYSKIPPED</h4>
<p>
Windows calls the WH_CBT hook with this hook code when a keyboard event is removed from the system queue and the keyboard hook is set. Windows will call a systemwide hook when a keyboard event is removed from any input queue and either a systemwide keyboard hook or a thread-specific hook for the current thread is installed. This hook code is not generated unless a filter function is attached to the WH_KEYBOARD hook. Despite its name, HCBT_KEYSKIPPED is called not only for skipped keyboard events but also whenever a keyboard event is removed from the system queue. Its main use is to install a WH_JOURNALPLAYBACK hook in response to a keyboard event. (See the "WM_QUEUESYNC" section below for more information.)</p>
<p>
The <i>wParam</i> parameter contains the virtual-key code—the same value as <i>wParam</i> of <b>GetMessage</b> or <b>PeekMessage</b> for WM_KEY* messages. The <i>lParam</i> parameter contains the same value as the <i>lParam</i> parameter of <b>GetMessage</b> or <b>PeekMessage</b> for WM_KEY* messages.</p>
<p>
<b>WM_QUEUESYNC</b></p>
<p>
While executing, a CBT application often must react to events in the main application. Keyboard or mouse events usually trigger these events. For example, a user clicks an OK button in a dialog box, after which the CBT application wants to play a series of keystrokes to the main application. The CBT application can use a mouse hook to determine whether the OK button was clicked. Upon determining that it wants to play some keystrokes to the main application, the CBT application must wait until the main application completes the processing of the OK button before beginning to play the new keystrokes. The CBT application would not want to apply the keystrokes to the dialog box.</p>
<p>
The CBT application can use the WM_QUEUESYNC message to monitor the main application and determine when an action is completed. The CBT application monitors the main application with a mouse or a keyboard hook and looks for events to which it must respond. By watching the main application with a mouse or a keyboard hook, the CBT application becomes aware of when an event that needs a response begins. The CBT application must wait until the event is completed before responding to it.</p>
<p>
To determine when the action is complete, the CBT application takes these steps:
<ol>
<li>
The CBT application waits until it receives the WH_CBT hook with an HCBT_CLICKSKIPPED or an HCBT_KEYSKIPPED hook code from Windows. This happens when the event that is causing the action in the main application is removed from the system queue. <br><br></li>
<li>
The CBT application installs a WH_JOURNALPLAYBACK hook. The CBT application cannot install this hook until it receives either the HCBT_CLICKSKIPPED or the HCBT_KEYSKIPPED hook code. The WH_JOURNALPLAYBACK hook plays a WM_QUEUESYNC message to the CBT application. When the CBT application receives this message, it can respond to the original event. For example, the CBT application might play some keystrokes to the main application.</li>
</ol>
<h4>HCBT_SETFOCUS</h4>
<p>
Windows calls the WH_CBT hook with this hook code when Windows is about to set the focus to any window. In the case of thread-specific hooks, the window must belong to the thread. If the filter function returns TRUE, the focus does not change.</p>
<p>
The <i>wParam</i> parameter contains the handle to the window that receives the focus. The <i>lParam</i> parameter contains the handle to the window that loses the focus.</p>
<h4>HCBT_QS</h4>
<p>
Windows calls the WH_CBT hook with this hook code when a WM_QUEUESYNC message is removed from the system queue while a window is being resized or moved. The hook is not called at any other time. In the case of thread-specific hooks, the window must belong to the thread.</p>
<p>
Both the <i>wParam</i> and <i>lParam</i> parameters contain zero.</p>
<h3>WH_DEBUG</h3>
<p>
Windows calls this hook when Windows is about to call a filter function. Filters cannot modify the values for the hook but can stop Windows from calling the original filter function by returning a nonzero value.</p>
<p>
The <i>wParam</i> parameter contains the ID of the hook to be called, for example, WH_MOUSE. The <i>lParam</i> parameter contains a pointer to the following structure:</p>
<pre><code>typedef struct tagDEBUGHOOKINFO
{
 &nbsp;&nbsp; DWORD&nbsp;&nbsp; idThread;&nbsp; // The thread ID for the current thread
 &nbsp;&nbsp; LPARAM&nbsp; reserved;
 &nbsp;&nbsp; LPARAM&nbsp; lParam;&nbsp;&nbsp;&nbsp; // The lParam for the target filter function
 &nbsp;&nbsp; WPARAM&nbsp; wParam;&nbsp;&nbsp;&nbsp; // The wParam for the target filter function
 &nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO, NEAR *NPDEBUGHOOKINFO, FAR* LPDEBUGHOOKINFO;
</code></pre>
<h3>WH_FOREGROUNDIDLE</h3>
<p>
Windows calls this hook when there is no user input to process for the current thread. In the case of thread-specific hooks, Windows calls the hook only when that thread is the current thread and there is no input for the thread. This is a notification-only hook; both the <i>wParam</i> and <i>lParam</i> parameters are zero.</p>
<h3>WH_GETMESSAGE</h3>
<p>
Windows calls this hook when the <b>GetMessage</b> or the <b>PeekMessage</b> function is about to return a message. The filter functions receive a pointer to a structure containing the actual message from Windows. The message, including any modifications, is sent to the application that originally called <b>GetMessage</b> or <b>PeekMessage</b>. The <i>lParam</i> parameter contains a pointer to a MSG structure:</p>
<pre><code>typedef struct tagMSG {&nbsp;&nbsp;&nbsp;&nbsp; /* msg */
 &nbsp;&nbsp; HWND&nbsp;&nbsp; hwnd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ The window whose Winproc will receive the message
 &nbsp;&nbsp; UINT&nbsp;&nbsp; message;&nbsp;&nbsp; \\ The message number
 &nbsp;&nbsp; WPARAM wParam;
 &nbsp;&nbsp; LPARAM lParam;
 &nbsp;&nbsp; DWORD&nbsp; time;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ The time the message was posted
 &nbsp;&nbsp; POINT&nbsp; pt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\ The cursor position in screen coordinates 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\&nbsp; of the message
} MSG;
</code></pre>
<h3>WH_HARDWARE</h3>
<p>
This hook is not currently implemented in Win32.</p>
<h3>Journal Hooks</h3>
<p>
Journal hooks are used to record and playback events. They are available only as systemwide hooks and should, therefore, be used as little as possible. These hooks affect all Windows-based applications; although the desktop allows no other hooks, journal hooks can record and play back events from and to the desktop. Another side-effect of journal hooks is that all system input queues are attached though the thread that installed the hook. This means that all system input must pass through this one point of execution.</p>
<p>
Win32 takes special steps to allow a user to cancel a journal hook so that it does not lock the system. Windows will uninstall a record or playback journal hook when the user presses CTRL+ESC, ALT+ESC, or CTRL+ALT+DEL. Windows then notifies the application that had a journal hook installed by posting a WM_CANCELJOURNAL message.</p>
<h4>WM_CANCELJOURNAL</h4>
<p>
This message is posted with a NULL window handle so that it is not dispatched to a window procedure. The best way to catch this message is to install a WH_GETMESSAGE filter function that watches for the message. The Win32 documentation also mentions that an application can catch the WM_CANCELJOURNAL message between a call to <b>GetMessage</b> (or <b>PeekMessage</b>) and <b>DispatchMessage</b>. Although the message can be caught at this point, the application may not be there when the message is sent. For example, if the application is in a dialog box, its main message loop will not be called.</p>
<p>
The CTRL+ESC, ALT+ESC, and CTRL+ALT+DEL key combinations are built into the system so the user can always stop a journal hook. It would be nice if every application that uses a journal hook could also supply a way for the user to stop journalling. The suggested way to stop journalling is by using VK_CANCEL (CTRL+BREAK).</p>
<h4>WH_JOURNALRECORD</h4>
<p>
Windows calls this hook when it removes an event from the system queue. Thus, these filters are called for all mouse and keyboard events except for those played back by a journal playback hook. Filters may process the message (that is, record or save the event in memory or on disk or both), but cannot modify or discard the message. Filters for this hook may reside in a DLL or an .EXE file. Only the HC_ACTION hook code is implemented in Win32.</p>
<p>
<b>HC_ACTION</b></p>
<p>
Windows calls the WH_JOURNALRECORD hook with this hook code when it takes an event from the system queue. The hook code signals the filter function that this is a normal event. The <i>lParam</i> parameter to the filter function contains a pointer to an <b>EVENTMSG</b> structure. The usual recording procedure is to take all <b>EVENTMSG</b> structures passed to the hook and store them in memory or, if events exceed memory storage capacity, write them to disk.</p>
<p>
The <b>EVENTMSG</b> structure is defined in WINDOWS.H and has the following structure:</p>
<pre><code>typedef struct tagEVENTMSG {
 &nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp; message;
 &nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp; paramL;
 &nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp; paramH;
 &nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp; time;
 &nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp;&nbsp; hwnd;
} EVENTMSG;

typedef struct tagEVENTMSG *PEVENTMSG, NEAR *NPEVENTMSG, FAR *LPEVENTMSG;
</code></pre>
<p>
The message element of the <b>EVENTMSG</b> structure is the message ID for the message, the WM_* value. The <i>paramL</i> and <i>paramH</i> values depend on whether the event is a mouse or a keyboard event. If it is a mouse event, the values contain the <i>x </i>and <i>y</i> coordinates of the event. If it is a keyboard event, <i>paramL</i> contains the scan code in the HIBYTE and the virtual-key code in the LOBYTE, and <i>paramH</i> contains the repeat count. Bit 15 of the repeat count specifies whether the event is an extended key. The time element of the <b>EVENTMSG</b> structure contains the system time (when the event occurred), which it obtained from the return value of <b>GetTickCount</b>. The <i>hwnd</i> is the window handle for the event.</p>
<p>
The amount of time between events is determined by comparing the time element of an event with the time of subsequent events. This time delta is needed when playing back the recorded events.</p>
<h4>WH_JOURNALPLAYBACK</h4>
<p>
This hook is used to provide mouse and keyboard messages to Windows as if they were inserted in the system queue. This hook is generally used to play back events recorded with the WH_JOURNALRECORD hook, but also provides the best way to send events to another application. Whenever a filter function is attached to this hook, Windows calls the first filter function in the function chain to get events. Windows discards any mouse moves while WH_JOURNALPLAYBACK is installed. All other keyboard and mouse input is queued until the WH_JOURNALPLAYBACK hook has no filter functions attached. Filters for this hook may reside in a DLL or an .EXE file. A filter function attached to this hook needs to be aware of the following hook codes:
<ul type=disc>
<li>
HC_GETNEXT<br><br></li>
<li>
HC_SKIP</li>
</ul>
<p>
<b>HC_GETNEXT</b></p>
<p>
Windows calls the WH_JOURNALPLAYBACK hook with this hook code when it accesses a thread's input queue. In most cases, Windows makes this call many times for the same message. The <i>lParam</i> parameter to the filter function contains a pointer to an <b>EVENTMSG</b> structure (see above). The filter function must put the message, the <i>paramL</i> value, and the <i>paramH</i> value into the <b>EVENTMSG</b> structure. These are usually copied directly from the recorded event made during WH_JOURNALRECORD.</p>
<p>
The filter function must tell Windows when to process the message that the filter function is giving Windows. Windows needs two values for its scheduling: (1) the amount of time Windows should wait before processing the message; (2) the time at which the message is to be processed. The usual method of calculating the time to wait before processing is to subtract the <b>EVENTMSG</b> time element of the previous message from the <b>EVENTMSG</b> time element of the current message. This technique plays back messages at the speed at which they were recorded. If the message is to be processed immediately for much faster playback, the amount of time returned from the function is zero.</p>
<p>
The time at which the message should be processed is usually obtained by adding the amount of time Windows should wait before processing the message to the current system time obtained from <b>GetTickCount</b>. For immediate playback, use the value returned from <b>GetTickCount</b>.</p>
<p>
If the system is not otherwise active, Windows uses the values that the filter function has supplied to process the event. If the system is active, Windows examines the system queue. Each time it does, it asks for the same event with an HC_GETNEXT hook code. Each time the filter function receives HC_GETNEXT, it should return the new amount of time to wait, assuming that time elapsed between calls. The time element of the <b>EVENTMSG</b> structure and of the message, the <i>paramH</i> value, and the <i>paramL</i> value will probably not need changing between calls.</p>
<p>
<b>HC_SKIP</b></p>
<p>
Windows calls the WH_JOURNALPLAYBACK hook with this hook code when it has completed processing a message it received from WH_JOURNALPLAYBACK. This occurs at the time that Windows would have removed the event from the system queue, if the event had been in the system queue instead of being generated by a WH_JOURNALPLAYBACK hook. This hook code signals to the filter function that the event that the filter function returned on the prior HC_GETNEXT call has been returned to an application. The filter function should prepare to return the next event on the next HC_GETEVENT call. When the filter function determines that it has no more events to play back, it should unhook itself during this HC_SKIP call.</p>
<h3>WH_KEYBOARD</h3>
<p>
Windows calls this hook when the <b>GetMessage</b> or the <b>PeekMessage</b> function is about to return a WM_KEYUP, WM_KEYDOWN, WM_SYSKEYUP, WM_SYSKEYDOWN, or WM_CHAR message. In the case of thread-specific hooks, the message must be from the thread's input queue. The filter function receives the virtual-key code and the state of the keyboard at the time of the keyboard hook. Filters can tell Windows to discard the message. A filter function attached to this hook needs to be aware of the following two hook codes:
<ul type=disc>
<li>
HC_ACTION<br><br></li>
<li>
HC_NOREMOVE</li>
</ul>
<h4>HC_ACTION</h4>
<p>
Windows calls the WH_KEYBOARD hook with this hook code when an event is being removed from the system queue.</p>
<h4>HC_NOREMOVE</h4>
<p>
Windows calls the WH_KEYBOARD hook with this hook code when there is a keyboard event that is not being removed because an application is calling <b>PeekMessage</b> with the PM_NOREMOVE option. If this hook code is passed, the key-state table will not accurately reflect the previous key state. An application needs to be aware of the existence of this condition.</p>
<h3>WH_MOUSE</h3>
<p>
Windows calls this hook when a <b>GetMessage</b> or a <b>PeekMessage</b> function is called and Windows has a mouse message to process. Like the WH_KEYBOARD hook, this filter function receives a hook code, which indicates whether the message is being removed (HC_NOREMOVE), an identifier specifying the mouse message, and the <i>x</i> and <i>y </i>coordinates of the mouse. Filters can tell Windows to discard the message. Filters for this hook must reside in a DLL.</p>
<h3>WH_MSGFILTER</h3>
<p>
Windows calls this hook when a dialog box, a message box, a scroll bar, or a menu retrieves a message, or when the user presses the ALT+TAB or ALT+ESC keys while the application that set the hook is active. This hook is thread specific, so it is always safe for its filter functions to reside in an application or in a DLL. The filter receives the following hook codes:
<ul type=disc>
<li>
MSGF_DIALOGBOX: The message is for a dialog box or a message box.<br><br></li>
<li>
MSGF_MENU: The message is for a menu.<br><br></li>
<li>
MSGF_SCROLLBAR: The message is for a scroll bar.<br><br></li>
<li>
MSGF_NEXTWINDOW: The next window action is about to take place.</li>
</ul>
<p>
There are other MSGF_ values defined in WINUSER.H but they are not used in WH_MSGFILTER hooks at this time.</p>
<p>
The <i>lParam</i> parameter contains a pointer to a structure containing the message. The WH_SYSMSGFILTER hooks are called before the WH_MSGFILTER hooks. If any of the WH_SYSMSGFILTER hook functions return TRUE, the WH_MSGFILTER hooks are not called.</p>
<h3>WH_SHELL</h3>
<p>
Windows calls this hook when actions occur to top-level (that is, unowned) windows. In the case of thread-specific hooks, Windows calls this hook only for windows that belong to the thread. This is a notification-only hook, so the filter function cannot modify or discard the event. The <i>wParam</i> parameter contains the handle to the window; the <i>lParam</i> parameter is not used. Three hook codes are defined in WINUSER.H for this hook:
<ul type=disc>
<li>
HSHELL_WINDOWCREATED: Windows calls the WH_SHELL hook when a top-level window is created. The window already exists when this hook is called.<br><br></li>
<li>
HSHELL_WINDOWDESTROYED: Windows calls the WH_SHELL hook when a top-level window is about to be destroyed.<br><br></li>
<li>
HSHELL_ACTIVATESHELLWINDOW: This hook code is not used at this time.</li>
</ul>
<h3>WH_SYSMSGFILTER</h3>
<p>
This hook is identical to WH_MSGFILTER except that it is a systemwide hook. Windows calls this hook when a dialog box, a message box, a scroll bar, or a menu retrieves a message, or when the user presses the ALT+TAB or ALT+ESC keys. The filter receives the same hook code as WH_MSGFILTER.</p>
<p>
The <i>lParam</i> parameter contains a pointer to a structure containing the message. The WH_SYSMSGFILTER hooks are called before the WH_MSGFILTER hooks. If any of the WH_SYSMSGFILTER hook functions return TRUE, the WH_MSGFILTER hooks are not called.</p>
</BODY>
</HTML>
