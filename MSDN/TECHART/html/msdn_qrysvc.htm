<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Visual Basic Classes to Query Windows NT Services</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_qrysvc"></a></sup>Using Visual Basic Classes to Query Windows NT Services </h1>
<p>
Steve Kirk<br>
MSDN Content Development Group</p>
<p>
March 1997</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="5055">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the QRYSVC sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article demonstrates how to create a pair of classes in Microsoft® Visual Basic® version 5.0 that query Windows NT® services according to type and status and present the results as a collection of service objects. A detailed description of each service is provided through the properties of the service class. You can package these class modules as a Component Object Model (COM) server or just include them in your project. </p>
<p>
These Visual Basic 5.0 classes provide an object interface for programs that need to know what Windows NT services are installed on a machine or that need detailed information about a particular service. A client using these classes can query system services by type or status and receive the results as a collection of service objects. Read on for a description of how to build the classes.</p>
<h2>Object Model </h2>
<p>
The administrative class CServiceAdmin provides a container for the Services collection as well as the supporting filter properties and the <b>FillServices</b> method. CServiceAdmin also provides the primary interface for client programs. See Table 1.</p>
<p class=label>
<b>Table 1. CServiceAdmin Class</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Property</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><b>Services</b></td>
<td width=75%>A collection of service objects that fit the filter specified by the <b>ServiceType</b> and <b>ServiceState</b> properties. The collection has a <b>Count</b> property and each member has a key of the service display name. </td>
</tr>
<tr valign=top>
<td width=25%><b>ServiceType</b></td>
<td width=75%>A bit field that controls which services are included in the Services collection. The value supplied must be one or both of the following values that are defined by the server:<p>
SERVICE_WIN32</p>
<p>
SERVICE_DRIVER</p>
</td>
</tr>
<tr valign=top>
<td width=25%><b>ServiceState</b></td>
<td width=75%>A bit field that controls which services are included in the Services collection. The value supplied must be one or both of the following values that are defined by the server:<p>
SERVICE_ACTIVE</p>
<p>
SERVICE_INACTIVE</p>
</td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Method</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><b>FillServices</b></td>
<td width=75%>Refreshes the Services collection based on the filter specified by the <b>ServiceType</b> and <b>ServiceState</b> properties.</td>
</tr>
</table><br>
<p>
CserviceClass describes a service by name and publishes type and state information and control codes that the service will accept and process. See Table 2.</p>
<p class=label>
<b>Table 2. CService Class</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Property</b></td>
<td class=label width=71%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=29%><b>ServiceName</b></td>
<td width=71%>The name of the service. </td>
</tr>
<tr valign=top>
<td width=29%><b>DisplayName</b></td>
<td width=71%>The friendly name for the service. </td>
</tr>
<tr valign=top>
<td width=29%><b>OwnProcess</b></td>
<td width=71%>True/False indicates the service runs in its own process.</td>
</tr>
<tr valign=top>
<td width=29%><b>ShareProcess</b></td>
<td width=71%>True/False indicates the service runs in a process shared with other services.</td>
</tr>
<tr valign=top>
<td width=29%><b>DeviceDriver</b></td>
<td width=71%>True/False indicates a Windows NT device driver.</td>
</tr>
<tr valign=top>
<td width=29%><b>FileSystemDriver</b></td>
<td width=71%>True/False indicates a Windows NT file system driver.</td>
</tr>
<tr valign=top>
<td width=29%><b>InteractsWithDesktop</b></td>
<td width=71%>True/False indicates a service process that can interact with the desktop.</td>
</tr>
<tr valign=top>
<td width=29%><b>Stopped</b></td>
<td width=71%>True/False indicates the service is not running.</td>
</tr>
<tr valign=top>
<td width=29%><b>StartPending</b></td>
<td width=71%>True/False indicates the service is starting.</td>
</tr>
<tr valign=top>
<td width=29%><b>StopPending</b></td>
<td width=71%>True/False indicates the service is stopping.</td>
</tr>
<tr valign=top>
<td width=29%><b>Running</b></td>
<td width=71%>True/False indicates the service is running.</td>
</tr>
<tr valign=top>
<td width=29%><b>ContinuePending</b></td>
<td width=71%>True/False indicates the service continue is pending.</td>
</tr>
<tr valign=top>
<td width=29%><b>PausePending</b></td>
<td width=71%>True/False indicates the service pause is pending.</td>
</tr>
<tr valign=top>
<td width=29%><b>Paused</b></td>
<td width=71%>True/False indicates the service is paused.</td>
</tr>
<tr valign=top>
<td width=29%><b>AcceptStop</b></td>
<td width=71%>True/False indicates the service can be stopped.</td>
</tr>
<tr valign=top>
<td width=29%><b>AcceptPauseContinue</b></td>
<td width=71%>True/False indicates the service can be paused and continued.</td>
</tr>
<tr valign=top>
<td width=29%><b>AcceptShutdown</b></td>
<td width=71%>True/False indicates the service is notified when system shutdown occurs. </td>
</tr>
<tr valign=top>
<td width=29%><b>Win32ExitCode</b></td>
<td width=71%>Long specifies a Win32 error code that the service uses to report an error that occurs when it is starting or stopping. Indicates that the error code is contained at the <b>ServiceSpecificExitCode</b> property when set to ERROR_SERVICE_SPECIFIC_ERROR.</td>
</tr>
<tr valign=top>
<td width=29%><b>ServiceSpecificExitCode</b></td>
<td width=71%>Long contains an error code returned by the service during stopping or starting if the <b>Win32ExitCode</b> property is set to ERROR_SERVICE_SPECIFIC_ERROR.</td>
</tr>
</table><br>
<h2>Using the Underlying Win32 API</h2>
<p>
The core Win32® function used is <b>EnumServicesStatus</b>. This function returns information about the services that match the supplied <i>dwServiceType</i> and <i>dwServiceState</i> parameters into an array of ENUM_SERVICE_STATUS structures that each describe a service.</p>
<pre><code>Private Declare Function EnumServicesStatus Lib "advapi32.dll" _
 &nbsp; Alias _"EnumServicesStatusA" _ 
 &nbsp; (ByVal hSCManager As Long, _
 &nbsp; ByVal dwServiceType As Long, _
 &nbsp; ByVal dwServiceState As Long, _
 &nbsp; ByVal lpBufAddress As Long, _
 &nbsp; ByVal cbBufSize As Long, _
 &nbsp; pcbBytesNeeded As Long, _
 &nbsp; lpServicesReturned As Long, _
 &nbsp; lpResumeHandle As Long) As Long
</code></pre>
<p>
The ENUM_SERVICE_STATUS structure contains the service name and display name as well as a SERVICE_STATUS structure that contains type, status, and control descriptions. </p>
<pre><code>Private Type ENUM_SERVICE_STATUS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpServiceName As Long
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpDisplayName As Long
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ServiceStatus As SERVICE_STATUS
End Type
Private Type SERVICE_STATUS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwServiceType As Long
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwCurrentState As Long
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwControlsAccepted As Long
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwWin32ExitCode As Long
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwServiceSpecificExitCode As Long
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwCheckPoint As Long
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwWaitHint As Long
End Type
</code></pre>
<p>
The Win32 <b>OpenSCManager</b> function opens the service control manager database and returns a handle that is used by <b>EnumServiceStatus.</b> <b>CloseServiceHandle</b> closes the database and releases the handle.</p>
<pre><code>Private Declare Function OpenSCManager Lib "advapi32.dll" Alias "OpenSCManagerA"&nbsp;&nbsp;&nbsp; (ByVal lpMachineName As String, _
 &nbsp; ByVal lpDatabaseName As String, _
 &nbsp; ByVal dwDesiredAccess As Long) As Long _
Private Declare Function CloseServiceHandle Lib "advapi32.dll" _
 &nbsp; (ByVal hSCObject As Long) As Long
</code></pre>
<p>
You will also use other procedures from Win32, including <b>lstrcpy</b> and <b>lstrlen</b>. See the QRYSVC sample code for declarations of these more general procedures.</p>
<h2>Getting the Services</h2>
<p>
The <b>FillServices</b> method is the heart of the CServiceAdmin class. It uses <b>EnumServicesStatus</b> to get the services and place them in an array of ENUM_SERVICE_STATUS structures in a memory buffer. The following code segments from <b>FillServices</b> show how this is done.</p>
<pre><code>Public Sub FillServices()
 &nbsp; Dim vEnumServiceStatus As ENUM_SERVICE_STATUS
 &nbsp; Dim vEnumServiceStatus() As ENUM_SERVICE_STATUS
 &nbsp; Dim sDisplayName As String * 256
 &nbsp; Dim sServiceName As String * 256
</code></pre>
<p>
The first task is to initialize the Services collection.</p>
<pre><code>&nbsp;&nbsp;&nbsp;Set m_services = Nothing
 &nbsp; Set m_services = New Collection
</code></pre>
<p>
The <b>OpenSCManager</b> function returns a handle to the Service Control Manager (SCM). Empty strings for <i>sMachineName</i> and <i>sDatabaseName</i> open the active database on the local computer. If <b>OpenSCManager</b> fails and returns a 0, report the error using <b>Err.Raise</b>.</p>
<pre><code>hSCM = OpenSCManager(sMachineName, sDatabaseName, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SC_MANAGER_ENUMERATE_SERVICE)
If hSCM = 0 Then
 &nbsp;&nbsp; lLastError = GetLastError
 &nbsp;&nbsp; On Error GoTo 0
 &nbsp;&nbsp; Err.Raise vbObjectError + lLastError, Trim$(App.Title
 &nbsp;&nbsp; Exit Sub
End If
</code></pre>
<p>
It is impossible to know how many services will be returned, so you should dimension <b>vEnumServices()</b> to a reasonable size and let <b>EnumServicesStatus</b> return services at the rate of a bufferful at a time. Youll stay in the following loop until all of the services have been retrieved from the SCM and added to the Services collection. If the buffer specified is too small for all of the services, <b>EnumServiceStatus</b> will return a successful <b>lRetVal</b> but will set the value that is returned by Err.<b>LastDllError</b> to ERROR_MORE_DATA. <b>EnumServicesStatus</b> keeps track of its place with <b>lResumehandle</b>, so it will pick up where it left off each time around.</p>
<pre><code>lBytesNeeeded = 0
lServicesReturned = 0
lResumeHandle = 0
bResult = True
ReDim vEnumServiceStatus(256) As ENUM_SERVICE_STATUS
While bResult
 &nbsp; lRetVal = EnumServicesStatus(hSCM, _
 &nbsp;&nbsp;&nbsp;&nbsp; m_ServiceType, _
 &nbsp;&nbsp;&nbsp;&nbsp; m_ServiceState, _
 &nbsp;&nbsp;&nbsp;&nbsp; vEnumServiceStatus(0), _
 &nbsp;&nbsp;&nbsp;&nbsp; 256, _
 &nbsp;&nbsp;&nbsp;&nbsp; lBytesNeeeded, _
 &nbsp;&nbsp;&nbsp;&nbsp; lServicesReturned, _
 &nbsp;&nbsp;&nbsp;&nbsp; lResumeHandle)
</code></pre>
<p>
If there are more services to retrieve than fit in the buffer, <b>Err.LastDllError</b> will return ERROR_MODE_DATA and you will stay in the loop. If not, you can exit the loop.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;GLE = Err.LastDllError
 &nbsp;&nbsp; If lRetVal = 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If GLE = ERROR_MORE_DATA Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bResult = True
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bResult = False
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bResult = True
 &nbsp;&nbsp; End If
</code></pre>
<p>
This section walks through <b>vEnumServiceStatus()</b> and adds a service object to the Services collection for each service returned. Use <b>lstrcpy</b> to copy pointers to <i>ServiceName</i> and <i>DisplayName</i> into fixed-length string variables and then trim them to the null terminator with help from <b>lstrlen</b>. Then fill in the numerical properties of <i>oService</i> and add it to the Services collection.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;For lNdx = 0 To lServicesReturned - 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set oService = New CService
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Resolve ServiceName and DisplayName from pointers.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lResult = lstrcpy(sServiceName, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vEnumServiceStatus(lNdx).lpServiceName)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lResult = lstrcpy(sDisplayName, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vEnumServiceStatus(lNdx).lpDisplayName)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oService.ServiceName = Mid$(sServiceName, 1, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstrlen(sServiceName))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oService.DisplayName = Mid$(sDisplayName, 1, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lstrlen(sDisplayName))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Resolve Service Status.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oService.ServiceType = _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vEnumServiceStatus(lNdx).ServiceStatus.dwServiceType
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Add the service to the services collection.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_services.Add oService, oService.DisplayName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set oService = Nothing
 &nbsp;&nbsp; Next
 &nbsp;&nbsp; Wend
 &nbsp;&nbsp; 'Close the service control manager.
 &nbsp;&nbsp; CloseServiceHandle (hSCM)
End Sub
</code></pre>
<p>
Done! The services collection has been filled with service objects that match the <b>ServiceType</b> and <b>ServiceStatus</b> properties. The rest of the class module code is straightforward. You can get that by downloading the qrysvc sample that accompanies this article. </p>
</BODY>
</HTML>
