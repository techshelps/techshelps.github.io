<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Defining Database Objects</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Defining Database Objects</h1>
<p>
This section highlights the significant differences between the Oracle and SQL Server database management systems.</p>
<h3>Basic Statistics</h3>
<p>
Oracle database objects (tables, views, and indexes) can be migrated to SQL Server quite easily because each DBMS closely follows the ANSI standard regarding object definitions. To convert Oracle SQL table, index, and view definitions to SQL Server table, index, and view definitions requires relatively simple syntax changes.</p>
<p>
However, it is recommended that you understand the advantages SQL Server has to offer.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=37%><b>Category</b></td>
<td class=label width=38%><b>SQL Server</b></td>
<td class=label width=25%><b>Oracle</b></td>
</tr>
<tr valign=top>
<td width=37%>Number of columns</td>
<td width=38%>250</td>
<td width=25%>254</td>
</tr>
<tr valign=top>
<td width=37%>Row size</td>
<td width=38%>1962 bytes (this does not include text or image columns)</td>
<td width=25%>Unlimited (only one long or long raw allowed per row)</td>
</tr>
<tr valign=top>
<td width=37%>Maximum number of rows</td>
<td width=38%>Unlimited</td>
<td width=25%>Unlimited</td>
</tr>
<tr valign=top>
<td width=37%>Blob type storage</td>
<td width=38%>Any number of image or text columns per row, only 16-byte pointer stored with row, data stored on other data pages</td>
<td width=25%>One long or long raw per table, must be at end of row, data stored on same block(s) with row</td>
</tr>
<tr valign=top>
<td width=37%>Clustered table indexes</td>
<td width=38%>1 per table</td>
<td width=25%>0</td>
</tr>
<tr valign=top>
<td width=37%>Nonclustered table indexes</td>
<td width=38%>249 per table</td>
<td width=25%>Unlimited</td>
</tr>
<tr valign=top>
<td width=37%>Maximum number of indexed columns in single index</td>
<td width=38%>16</td>
<td width=25%>16</td>
</tr>
<tr valign=top>
<td width=37%>Table naming convention</td>
<td width=38%>[[database.]owner.]table_name</td>
<td width=25%>[schema.]table_name</td>
</tr>
<tr valign=top>
<td width=37%>View naming convention</td>
<td width=38%>[[database.]owner.]table_name</td>
<td width=25%>[schema.]table_name</td>
</tr>
<tr valign=top>
<td width=37%>Index naming convention</td>
<td width=38%>[[database.]owner.]table_name</td>
<td width=25%>[schema.]table_name</td>
</tr>
</table><br>
<h3>Configuring SQL Server Objects to Match Oracle Objects</h3>
<p>
It is assumed that you are starting with an Oracle SQL script or program that is used to create your database objects. Simply copy this script or program and make the following modifications. Each change is discussed throughout the rest of this section. The examples have been taken from the sample application scripts Oratable.sql and Sstable.sql.</p>
<p>
This process is performed as follows:
<ol>
<li>
Change all of your object identifiers to match SQL Servers naming conventions. In most cases you only need to change the names of indexes.<br><br></li>
<li>
Modify the data storage parameters to work with SQL Server. If you are using RAID, no storage parameters are required.<br><br></li>
<li>
Modify Oracle constraint definitions to work in SQL Server. Create triggers to support the foreign key DELETE CASCADE option if necessary. If tables cross databases, use triggers to enforce foreign key relationships.<br><br></li>
<li>
Modify the CREATE INDEX statements to take advantage of clustered indexes.<br><br></li>
<li>
Change Oracle data types to appropriate SQL Server data types using the recommended conversion table provided later in this paper.<br><br></li>
<li>
Remove any CREATE SEQUENCE statements. Replace the use of sequences with identity columns.<br><br></li>
<li>
Modify CREATE VIEW statements if necessary.<br><br></li>
<li>
Remove any reference to public or private synonyms.<br><br></li>
<li>
Evaluate the use of SQL Server temporary tables and their applicability in your application.<br><br></li>
<li>
Change any Oracle CREATE TABLE…AS SELECT commands to SQL Server SELECT…INTO statements.<br><br></li>
<li>
Evaluate the potential use of user-defined rules, data types, and defaults.<br><br></li>
<li>
Verify that all object permission GRANT statements are correct and modify if necessary (make sure you are granting to groups rather than roles).</li>
</ol>
<h3>Changing Object Identifiers</h3>
<p>
The object naming conventions are similar for each DBMS. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Oracle</b></td>
<td class=label width=50%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=50%>1-30 characters in length (Oracle database names can be a maximum of 8 characters, database link names can be a maximum of 128 characters.)</td>
<td width=50%>1-30 characters in length (temporary objects names should not exceed 13 characters in length.)</td>
</tr>
<tr valign=top>
<td width=50%>Identifier names must begin with an alphabetic character and contain alphanumeric characters, or the characters _, $, and #.</td>
<td width=50%>Identifier names must begin with an alphabetic character or one of three symbols (_, @, #), and contain alphanumeric characters, or the characters _, $, and #. Additionally, an object beginning with @ is defined as a local variable; an object beginning with a single # defines a local temporary object, and an object beginning with two ## defines a global temporary object.</td>
</tr>
<tr valign=top>
<td width=50%>Tablespace names must be unique.</td>
<td width=50%>Database names must be unique.</td>
</tr>
<tr valign=top>
<td width=50%>Identifier names must be unique within user accounts (schemas), and column names must be unique within tables and views.</td>
<td width=50%>Identifier names must be unique within database user accounts, and column names must be unique within tables and views.</td>
</tr>
<tr valign=top>
<td width=50%>Index names must be unique within a users schema.</td>
<td width=50%>Index names must be unique within database table names.</td>
</tr>
</table><br>
<p>
In most cases, you do not need to change the names of your objects when migrating to SQL Server. SQL Server indexes are the exception (unlike Oracle, the index name is associated directly with the table). </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Oracle</b></td>
<td class=label width=50%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=50%>CREATE INDEX <b>STUDENT_ADMIN.</b>STUDENT_<br>
MAJOR_IDX <br>
ON STUDENT_ADMIN.STUDENT(MAJOR) </td>
<td width=50%>CREATE <b>NONCLUSTERED</b> INDEX STUDENT_<br>
MAJOR_IDX<br>
ON STUDENT_ADMIN.STUDENT (MAJOR)</td>
</tr>
</table><br>
<h3>Qualifying Tables</h3>
<p>
When accessing tables that exist in your Oracle user account, the table can be simply selected by its unqualified name (for example, SELECT * FROM STUDENT). When accessing tables that exist in other schemas, the schema name must be prefixed to the table name with a single period (SELECT * FROM STUDENT_ADMIN.STUDENT).</p>
<p>
A public or private synonym is often used to eliminate the need to specify a username when requesting a table in another schema. Synonyms, however, can slow the performance of a query, because Oracle must perform additional queries against the data dictionary to resolve the table name.</p>
<p>
Synonyms cause additional problems. If you own a table called <b>STUDENT</b> in your account, and there is a public synonym for the <b>STUDENT</b> table owned by another schema, you may not get the data you expect. If you request the table by its unqualified name (SELECT * FROM STUDENT) you get data from your own table. It is often necessary to fully qualify a requested table name even when a public synonym exists.</p>
<p>
It is also important to note that SQL Server does not provide public or private synonyms. SQL Server uses a slightly different convention when it references tables. Keep in mind that one SQL Server login account can create a table by the same name in multiple databases. Therefore, the following convention is required when requesting access to tables: </p>
<pre><code>[[database_name.]owner_name.]table_name
</code></pre>
<p>
This is an example of the syntax:</p>
<pre><code>SELECT * FROM USER_DB.STUDENT_ADMIN.STUDENT
</code></pre>
<p>
Using the database name and username is optional. When a table is referenced only by name (for example, <b>STUDENT</b>), SQL Server searches for that table in the current users account in the current database.</p>
<p>
Every connection to SQL Server has a current database context, set at login time and changed using the USE statement. For example, if the ENDUSER1 account is currently logged into the <b>USER_DB</b> database, SQL Server searches for the table <b>ENDUSER1.STUDENT</b>. If SQL Server finds the table <b>STUDENT</b> in the ENDUSER1 account, it returns data from the table (<b>USER_DB.ENDUSER1.STUDENT</b>). If the table is not found in the ENDUSER1 database account, SQL Server searches for the table in the DBO account for that database. If it is found, data is returned from that table (<b>USER_DB.DBO.STUDENT</b>).</p>
<p>
If the table is not found in either of these accounts, SQL Server returns an error message indicating the table does not exist. If the table was created in another user's account in the <b>USER_DB</b> database, (for example, <b>DEPT_ADMIN</b>), the table name must be prefixed with the database user's name (<b>DEPT_ADMIN.STUDENT</b>).</p>
<p>
If the referenced table exists in another database, the database name must be used as part of the reference. For example, if the ENDUSER1 account owned the table <b>STUDENT</b> in the <b>OTHER_DB</b> database, the database name must be included as part of the request (<b>OTHER_DB.ENDUSER1.STUDENT</b>).</p>
<p>
When this type of reference is used, SQL Server looks for the table <b>STUDENT</b> in the ENDUSER1 account in the <b>DEPT_DB</b> database. If it finds it, data is returned from the table. Note the syntax and its usage. The database and usernames are optional. If the database name and table names are provided separated by two periods (<b>STUDENT_DB..STUDENT</b>), SQL Server first searches the database user's account corresponding to the current login ID, and the DBO account second.</p>
<p>
It is important to note that table names must be unique within a user's account within a database. The same SQL Server login account can potentially use the same object name across multiple databases. For example, the ENDUSER1 account may own the following database objects:
<ul type=disc>
<li>
<b>USER_DB.ENDUSER1.STUDENT</b><br><br></li>
<li>
<b>OTHER_DB.ENDUSER1.STUDENT</b></li>
</ul>
<p>
At the same time, other users in these databases may own objects by the same name:
<ul type=disc>
<li>
<b>USER_DB.DBO.STUDENT</b><br><br></li>
<li>
<b>USER_DB.DEPT_ADMIN.STUDENT</b><br><br></li>
<li>
<b>USER_DB.STUDENT_ADMIN.STUDENT</b><br><br></li>
<li>
<b>OTHER_DB.DBO.STUDENT</b></li>
</ul>
<p>
Therefore, when an object name is referenced, it is recommended that you include the owner name as part of the reference. If the application involves multiple separate databases, the database name should also be included as part of the reference.</p>
<p>
If the application involves only a single database, omitting the database name from an object reference makes it easy to migrate the application to another database with a different name. This is useful when you want to maintain a test database and a production database on the same server.&nbsp;&nbsp; </p>
<h3>Create Table Syntax</h3>
<p>
The CREATE TABLE syntax for each DBMS is similar. Both Oracle and SQL Server support ANSI-standard naming conventions for identifying DBMS objects. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Oracle</b></td>
<td class=label width=52%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=48%>CREATE TABLE<br>
[<i>schema</i>.]<i>table_name<br>
</i>(<i><br>
</i>{<i>col_name column_properties</i> <br>
[<i>default_expression</i>] [<i>constraint</i> [<i>constraint</i> <br>
[...<i>constraint</i>]]]| [[,] <i>constraint</i>]}<i><br>
</i>[[,] {<i>next_col_name</i> | <i>next_constraint</i>}...]<i><br>
</i>)<br>
[Oracle Specific Data Storage Parameters]</td>
<td width=52%>CREATE TABLE [<i>database</i>.[<i>owner</i>].]<i>table_name</i> <br>
(<br>
{<i>col_name column_properties</i>[<i>constraint</i> <br>
[<i>constraint</i> [...<i>constraint</i>]]]| [[,] <i>constraint</i>]}<br>
[[,] {<i>next_col_name</i> | <i>next_constraint</i>}...]<br>
)<br>
[ON <i>segment_name</i>]</td>
</tr>
</table><br>
<p>
When referring to objects in Oracle, the use of case is not important. This can cause potential problems when converting Oracle applications. In SQL Server, table and column names can be case sensitive, depending on the character sort order that is installed. When SQL Server is first set up, the default sort order is dictionary order, case-insensitive. (This can be configured differently using SQL Server Setup.)</p>
<p>
In SQL Server, the case (upper- or lowercase) of letters can influence object names and should be considered when developing applications. It is recommended that you capitalize all table and column names in both Oracle and SQL Server to avoid problems.</p>
<h3>Modifying Data Storage Parameters</h3>
<p>
The primary difference between Oracle and SQL Server is how each uses data storage parameters when creating tables and indexes. The parameters used by Oracle are not supported by SQL Server, and vice versa. However, in SQL Server, using RAID usually simplifies the table- and index-definition process. The SQL Server table simply uses RAID to control its placement. Note that a clustered index is integrated into the structure of the table. A separate, nonclustered index is also defined for the table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Oracle</b></td>
<td class=label width=50%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=50%>CREATE TABLE DEPT_ADMIN.DEPT (<br>
DEPT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>VARCHAR2</b>(4) NOT NULL,<br>
DNAME&nbsp;&nbsp;&nbsp;&nbsp;<b>VARCHAR2</b>(30) NOT NULL,<br>
CONSTRAINT DEPT_DEPT_PK<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY KEY (DEPT)<br>
<b>USING INDEX TABLESPACE USER_DATA<br>
PCTFREE 0 STORAGE (INITIAL 10K NEXT 10K<br>
MINEXTENTS 1 MAXEXTENTS UNLIMITED),<br>
</b>CONSTRAINT DEPT_DNAME_UNIQUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNIQUE (DNAME)<br>
<b>USING INDEX TABLESPACE USER_DATA<br>
PCTFREE 0 STORAGE (INITIAL 10K NEXT 10K<br>
MINEXTENTS 1 MAXEXTENTS UNLIMITED)<br>
</b>)<br>
<b>PCTFREE 10&nbsp;&nbsp;&nbsp;&nbsp;PCTUSED 40<br>
TABLESPACE USER_DATA<br>
STORAGE (INITIAL 10K NEXT 10K<br>
MINEXTENTS 1 MAXEXTENTS UNLIMITED<br>
FREELISTS 1)</b></td>
<td width=50%>CREATE TABLE <b>USER_DB.</b>DEPT_ADMIN.DEPT (<br>
DEPT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>VARCHAR</b>(4) NOT NULL,<br>
DNAME&nbsp;&nbsp;&nbsp;&nbsp;<b>VARCHAR</b>(30) NOT NULL,<br>
CONSTRAINT DEPT_DEPT_PK<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY KEY <b>CLUSTERED</b> (DEPT),<br>
CONSTRAINT DEPT_DNAME_UNIQUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNIQUE <b>NONCLUSTERED</b> (DNAME)<br>
)</td>
</tr>
</table><br>
<h3>Referential Integrity Considerations</h3>
<p>
The table provides a comparison of the syntax used to define referential integrity constraints.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Constraint</b></td>
<td class=label width=42%><b>Oracle</b></td>
<td class=label width=37%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=21%>PRIMARY KEY</td>
<td width=42%>[CONSTRAINT <i>constraint_name</i>]<br>
PRIMARY KEY (<i>col_name</i> [, <i>col_name2</i> [..., <i>col_name16</i>]])<br>
[USING INDEX <i>storage_parameters</i>]</td>
<td width=37%>[CONSTRAINT <i>constraint_name</i>]<br>
PRIMARY KEY [CLUSTERED | NONCLUSTERED] (<i>col_name</i> [, <i>col_name2</i> [..., <i>col_name16</i>]])<br>
[ON <i>segment_name</i>]<br>
[NOT FOR REPLICATION]</td>
</tr>
<tr valign=top>
<td width=21%>UNIQUE</td>
<td width=42%>[CONSTRAINT <i>constraint_name</i>]<br>
UNIQUE (<i>col_name</i> [, <i>col_name2</i> [..., <i>col_name16</i>]])<br>
[USING INDEX <i>storage_parameters</i>]</td>
<td width=37%>[CONSTRAINT <i>constraint_name</i>]<br>
UNIQUE [CLUSTERED | NONCLUSTERED](<i>col_name</i> [, <i>col_name2</i> [..., <i>col_name16</i>]])<br>
[ON <i>segment_name</i>]<br>
[NOT FOR REPLICATION]</td>
</tr>
<tr valign=top>
<td width=21%>FOREIGN KEY</td>
<td width=42%>[CONSTRAINT <i>constraint_name</i>]<br>
[FOREIGN KEY (<i>col_name</i> [, <i>col_name2</i> [..., <i>col_name16</i>]])]<br>
REFERENCES [<i>owner</i>.]<i>ref_table</i> [(<i>ref_col</i> [, <i>ref_col2</i> [..., <i>ref_col16</i>]])]<br>
[ON DELETE CASCADE]</td>
<td width=37%>[CONSTRAINT <i>constraint_name</i>]<br>
[FOREIGN KEY (<i>col_name</i> [, <i>col_name2</i> [..., <i>col_name16</i>]])]<br>
REFERENCES [<i>owner</i>.]<i>ref_table</i> [(<i>ref_col</i> [, <i>ref_col2</i> [..., <i>ref_col16</i>]])]<br>
[NOT FOR REPLICATION]</td>
</tr>
<tr valign=top>
<td width=21%>DEFAULT</td>
<td width=42%>Column property, not a constraint<br>
DEFAULT (<i>constant_expression</i>)</td>
<td width=37%>[CONSTRAINT <i>constraint_name</i>]<br>
DEFAULT {<i>constant_expression</i> | <i>niladic-function</i> | NULL}<br>
[FOR <i>col_name</i>]<br>
[NOT FOR REPLICATION]</td>
</tr>
<tr valign=top>
<td width=21%>CHECK</td>
<td width=42%>[CONSTRAINT <i>constraint_name</i>]<br>
CHECK (<i>expression</i>)</td>
<td width=37%>[CONSTRAINT <i>constraint_name</i>]<br>
CHECK [NOT FOR REPLICATION] (<i>expression</i>)</td>
</tr>
<tr valign=top>
<td width=21%>NULL, <br>
NOT NULL</td>
<td width=42%>[CONSTRAINT <i>constraint_name</i>]<br>
NULL | NOT NULL</td>
<td width=37%>Column property, not a constraint</td>
</tr>
</table><br>
<p>
The NOT FOR REPLICATION clause is used to suspend column-level, FOREIGN KEY, and CHECK constraints during replication. For more information, see "SQL Server Replication" later in this paper.</p>
<h3>Adding and Removing Constraints</h3>
<p>
Disabling constraints can improve performance and streamline the data replication processes. For example, when you rebuild or replicate table data at a remote site, you do not have to repeat constraint checks, because the integrity of the data was checked when it was originally entered into the table. If your Oracle application currently disables and enables constraints (except for PRIMARY KEYand UNIQUE), this process can be easily duplicated in SQL Server using the CHECK and WITH NOCHECK options with the ALTER TABLE statement.</p>
<p>
This illustration shows a comparison of this process.</p>
<p>
<img src="orcl2sql_16.gif" border=0></p>
<p>
You can defer all constraints for the table, including the CHECK and FOREIGN KEY constraints, by using the ALL keyword. However, you cannot defer PRIMARY KEY and UNIQUE constraints because these constraints must be dropped.</p>
<p>
If your Oracle application disables or drops PRIMARY KEYor UNIQUE constraints using the CASCADE option, you may need to rewrite some of your program code. This is because the CASCADE option disables or drops both the parent and any related child integrity constraints. </p>
<p>
This is an example of the syntax:</p>
<pre><code>DROP CONSTRAINT DEPT_DEPT_PK CASCADE
</code></pre>
<p>
SQL Server does not support this cascading capability. The SQL Server application must be modified to first drop the child constraints followed by the parent constraints. For example, in order to drop the PRIMARY KEY constraint on the <b>DEPT</b> table, the foreign keys for the columns <b>STUDENT.MAJOR</b> and <b>CLASS.DEPT</b> must be dropped. This is an example of the syntax:</p>
<pre><code>ALTER TABLE STUDENT
DROP CONSTRAINT STUDENT_MAJOR_FK

ALTER TABLE CLASS
DROP CONSTRAINT CLASS_DEPT_FK

ALTER TABLE DEPT
DROP CONSTRAINT DEPT_DEPT_PK
</code></pre>
<p>
The ALTER TABLE syntax that is used to add and drop constraints is almost identical for Oracle and SQL Server. If care is taken, you can write program code that works with both Oracle and SQL Server and requires minimal modification.</p>
<h3>Naming Constraints</h3>
<p>
Regardless of the DBMS you are using, it is recommended that you always name your constraints. The constraint naming convention is the same for Oracle and SQL Server:</p>
<pre><code>CONSTRAINT constraint_name
</code></pre>
<p>
If you do not name your constraints, each DBMS names them for you. Because Oracle and SQL Server use different default naming conventions, the differences can unnecessarily complicate your migration process. The discrepancy would appear when dropping or disabling constraints, because they must be dropped by name (see the previous section, "Adding and Removing Constraints").</p>
<h3>PRIMARY KEY and UNIQUE Constraints</h3>
<p>
The ANSI standard requires that all values in a primary key are unique and that it does not allow null values. Both Oracle and SQL Server enforce uniqueness by automatically creating unique indexes whenever a PRIMARY KEY or UNIQUE constraint is defined. Additionally, primary key columns are automatically defined as NOT NULL. Only one primary key is allowed per table.</p>
<p>
A SQL Server clustered index is created by default for a primary key. A nonclustered index can also be requested. The Oracle index can be removed by either dropping or disabling the constraint, whereas the SQL Server index can only be removed by dropping the constraint.</p>
<p>
In either DBMS, alternate keys can be defined using a UNIQUE constraint. Multiple UNIQUE constraints can be defined on any table. UNIQUE constraint columns can be nullable. In SQL Server, a nonclustered index is created by default, unless specified otherwise.</p>
<p>
When migrating your application, it is important to note that SQL Server allows only one row to contain the value NULL for the complete unique key (single or multiple column index), while Oracle allows any number of rows to contain the value NULL for the complete unique key.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=51%><b>Oracle</b></td>
<td class=label width=49%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=51%>CREATE TABLE DEPT_ADMIN.DEPT<br>
(DEPT <b>VARCHAR2</b>(4) NOT NULL,<br>
DNAME <b>VARCHAR2</b>(30) NOT NULL,<br>
CONSTRAINT DEPT_DEPT_PK<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>PRIMARY KEY (DEPT)<br>
&nbsp;&nbsp;&nbsp;&nbsp;USING INDEX TABLESPACE USER_DATA<br>
&nbsp;&nbsp;&nbsp;&nbsp;PCTFREE 0 STORAGE (<br>
&nbsp;&nbsp;&nbsp;&nbsp;INITIAL 10K NEXT 10K<br>
&nbsp;&nbsp;&nbsp;&nbsp;MINEXTENTS 1 MAXEXTENTS UNLIMITED),<br>
</b>CONSTRAINT DEPT_DNAME_UNIQUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>UNIQUE (DNAME)<br>
&nbsp;&nbsp;&nbsp;&nbsp;USING INDEX TABLESPACE USER_DATA<br>
&nbsp;&nbsp;&nbsp;&nbsp;PCTFREE 0 STORAGE (<br>
&nbsp;&nbsp;&nbsp;&nbsp;INITIAL 10K NEXT 10K<br>
&nbsp;&nbsp;&nbsp;&nbsp;MINEXTENTS 1 MAXEXTENTS UNLIMITED)<br>
</b>)</td>
<td width=49%>CREATE TABLE <b>USER_DB.</b>DEPT_ADMIN.DEPT<br>
(DEPT&nbsp;&nbsp;&nbsp;&nbsp;<b>VARCHAR</b>(4) NOT NULL,<br>
DNAME&nbsp;&nbsp;&nbsp;&nbsp;<b>VARCHAR</b>(30) NOT NULL,<br>
CONSTRAINT DEPT_DEPT_PK<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>PRIMARY KEY CLUSTERED (DEPT),</b><br>
CONSTRAINT DEPT_DNAME_UNIQUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>UNIQUE NONCLUSTERED (DNAME)</b><br>
)</td>
</tr>
</table><br>
<h3>DEFAULTS and CHECK Constraints</h3>
<p>
Oracle treats a default as a column property, while SQL Server treats a default as a constraint. The SQL Server DEFAULT constraint can contain constant values, built-in functions that do not take arguments (niladic-functions), or NULL.</p>
<p>
Because you cannot apply a constraint name to the Oracle DEFAULT column property, it is recommended that you define DEFAULT constraints at the column level in SQL Server and do not apply constraint names to them. SQL Server simply generates a unique name for each DEFAULT constraint.</p>
<p>
The syntax used to define CHECK constraints is the same in Oracle and SQL Server. The search condition must evaluate to a Boolean expression and cannot contain subqueries. A column-level CHECK constraint can reference only the constrained column, and a table-level check constraint can reference only columns of the constrained table.</p>
<p>
Multiple CHECK constraints can be defined for a table. Unlike Oracle, SQL Server can define only one column-level CHECK constraint per column per CREATE TABLE statement (although each column constraint can have multiple conditions).</p>
<p>
Converting the DBMS-specific syntax is the fundamental issue in migrating these constraints.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=51%><b>Oracle</b></td>
<td class=label width=49%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=51%>CREATE TABLE STUDENT_ADMIN.STUDENT (<br>
SSN CHAR(9) NOT NULL,<br>
FNAME <b>VARCHAR2</b>(12) NULL,<br>
LNAME <b>VARCHAR2</b>(20) NOT NULL,<br>
GENDER CHAR(1) NOT NULL<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>CONSTRAINT STUDENT_GENDER_CK<br>
&nbsp;&nbsp;&nbsp;&nbsp;CHECK (GENDER IN ('M','F')),</b><br>
MAJOR <b>VARCHAR2</b>(4)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>DEFAULT 'Undc' NOT NULL,</b><br>
BIRTH_DATE <b>DATE</b> NULL,<br>
TUITION_PAID <b>NUMBER</b>(12,2) NULL,<br>
TUITION_TOTAL <b>NUMBER</b>(12,2) NULL,<br>
START_DATE <b>DATE</b> NULL,<br>
GRAD_DATE <b>DATE</b> NULL,<br>
LOAN_AMOUNT <b>NUMBER</b>(12,2) NULL,<br>
DEGREE_PROGRAM CHAR(1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>DEFAULT 'U' NOT NULL<br>
&nbsp;&nbsp;&nbsp;&nbsp;CONSTRAINT STUDENT_DEGREE_CK CHECK<br>
&nbsp;&nbsp;&nbsp;&nbsp;(DEGREE_PROGRAM IN ('U', 'M', 'P', 'D')),</b><br>
<b>...</b></td>
<td width=49%>CREATE TABLE <b>USER_DB.</b>STUDENT<br>
&nbsp;&nbsp;&nbsp;&nbsp;_ADMIN.STUDENT (<br>
SSN CHAR(9) NOT NULL,<br>
FNAME <b>VARCHAR</b>(12) NULL,<br>
LNAME <b>VARCHAR</b>(20) NOT NULL,<br>
GENDER CHAR(1) NOT NULL<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>CONSTRAINT STUDENT_GENDER_CK<br>
&nbsp;&nbsp;&nbsp;&nbsp;CHECK (GENDER IN ('M','F')),</b><br>
MAJOR <b>VARCHAR</b>(4)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>DEFAULT 'Undc' NOT NULL,</b><br>
BIRTH_DATE <b>DATETIME</b> NULL,<br>
TUITION_PAID <b>NUMERIC</b>(12,2) NULL,<br>
TUITION_TOTAL <b>NUMERIC</b>(12,2) NULL,<br>
START_DATE <b>DATETIME</b> NULL,<br>
GRAD_DATE <b>DATETIME</b> NULL,<br>
LOAN_AMOUNT <b>NUMERIC</b>(12,2) NULL,<br>
DEGREE_PROGRAM CHAR(1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>DEFAULT 'U' NOT NULL<br>
&nbsp;&nbsp;&nbsp;&nbsp;CONSTRAINT STUDENT_DEGREE_CK <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK<br>
&nbsp;&nbsp;&nbsp;&nbsp;(DEGREE_PROGRAM IN ('U', 'M', 'P', 'D')),</b><br>
<b>...</b></td>
</tr>
</table><br>
<h3>NULL and NOT NULL</h3>
<p>
SQL Server considers NULL and NOT NULL to be column properties, while Oracle considers them to be column constraints. You cannot duplicate the Oracle NULL/NOT NULL constraint names in your migrated SQL Server application.</p>
<p>
An Oracle table column always defaults to NULL, unless specified in the CREATE TABLE or ALTER TABLE statements. In SQL Server, database and session settings can influence and possibly override the nullability of the data type used in a column definition. When not explicitly specified, column nullability follows these rules:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Null Setting</b></td>
<td class=label width=70%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=30%>Column is defined with a user-defined data type</td>
<td width=70%>SQL Server uses the nullability specified when the data type was created. Use the <b>sp_help</b> system stored procedure to get the data type's default nullability. </td>
</tr>
<tr valign=top>
<td width=30%>Column is defined with a system-supplied data type</td>
<td width=70%>If the system-supplied data type has only one option, it takes precedence. Currently, the <b>bit</b> data type can be defined only as NOT NULL.<br>
If any session settings are ON (turned on with the SET), then:<br>
&nbsp;&nbsp;&nbsp;&nbsp;If ANSI_NULL_DFLT_ON is <b>ON</b>,&nbsp;&nbsp;&nbsp;&nbsp; NULL is assigned.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If ANSI_NULL_DFLT_OFF is <b>ON</b>, NOT NULL is assigned.<br>
If any database settings are configured (changed with the <b>sp_dboption</b> system stored procedure), then:<br>
&nbsp;&nbsp;&nbsp;&nbsp;If <b>ANSI null default</b> is <b>true</b>, NULL is assigned.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If <b>ANSI null default</b> is <b>false</b>, NOT NULL is assigned.</td>
</tr>
<tr valign=top>
<td width=30%>NULL/NOT NULL <br>
Not Defined</td>
<td width=70%>When not explicitly defined (neither of the ANSI_NULL_DFLT options are set), the session has not been changed and the database is set to the default (<b>ANSI null default</b> is <b>false</b>), then the SQL Server default of NOT NULL is assigned.</td>
</tr>
</table><br>
<p>
To avoid possible confusion when migrating between each DBMS, it is recommended that all of your SQL scripts (whether Oracle or SQL Server) explicitly define both NULL and NOT NULL. To see how this strategy is implemented, see Oratable.sql and Sstable.sql, the sample table creation scripts included with this paper.</p>
<h3>Foreign Keys</h3>
<p>
The rules for defining foreign keys are similar in each DBMS. The number of columns and data types of each column specified in the foreign key clause must identically match the references clause. A non-null value entered in this column(s) must exist in the table and column(s) defined in the references clause, and the referenced table's columns must have a PRIMARY KEY or UNIQUE constraint.</p>
<p>
It is important to note the SQL Server constraints can reference only tables within the same database. Table-based triggers must be used to simulate referential integrity across databases.</p>
<p>
Both Oracle and SQL Server support self-referenced tables. These are tables in which a reference (foreign key) can be placed against one or more columns on the very same table. For example, the column <b>PREREQ</b> in the <b>CLASS</b> table may make a reference to the column <b>CCODE</b> in the <b>CLASS</b> table. This can be done to ensure that a valid course code is entered as a course prerequisite.</p>
<p>
Regardless of DBMS, foreign key constraints do not create an index. For performance reasons, it is recommended that you index all of your foreign keys. This allows for quicker execution times when a referenced key is modified or used for join purposes.</p>
<p>
The Oracle CASCADE DELETE references option is not available with SQL Server. This option is used in situations where both the parent and child values are deleted when a parent row is deleted. In SQL Server, this option must be enforced with table triggers. For an example, see the "SQL Language Support" section later in this paper.</p>
<h3>Using Clustered and Nonclustered Indexes</h3>
<p>
This is syntax for both the Oracle and SQL Server CREATE INDEX statement.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=47%><b>Oracle</b></td>
<td class=label width=53%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=47%>CREATE [UNIQUE] INDEX [<i>schema</i>].<i>index_name</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;ON [<i>schema</i>.]<i>table_name</i> (<i>column_name</i> [, <i>column_name</i>]...)<br>
[INITRANS <i>n</i>]<br>
[MAXTRANS <i>n</i>]<br>
[TABLESPACE <i>tablespace_name</i>]<br>
[STORAGE <i>storage_parameters</i>]<br>
[PCTFREE <i>n</i>]<br>
[NOSORT]</td>
<td width=53%>CREATE [UNIQUE] [CLUSTERED |<br>
NONCLUSTERED] INDEX <i>index_name</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;ON [[<i>database</i>.]<i>owner</i>.]<i>table_name</i><br>
(<i>column_name</i> [,<i>column_name</i>]...)<br>
[WITH&nbsp;&nbsp;&nbsp;&nbsp; [PAD_INDEX] [FILLFACTOR = <i>x</i>]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[[,] IGNORE_DUP_KEY]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[[,]{SORTED_DATA |<br>
SORTED_DATA_REORG}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[[,]{IGNORE_DUP_ROW |<br>
ALLOW_DUP_ROW}]]<br>
[ON <i>segment_name</i>]</td>
</tr>
</table><br>
<h3>B-tree Indexes</h3>
<p>
SQL Server offers both clustered and nonclustered index structures. These indexes are made up of pages that form a branching structure known as a B-tree (similar to the Oracle B-tree index structure). The starting page (root level) specifies ranges of values within the table. Each range on the root level page points to another page (decision node) which contains a more limited range of values for the table. In turn, these decision nodes can point to other decision nodes, further narrowing the search range. The final level in the branching structure is called the leaf level.</p>
<p>
<img src="orcl2sql_17.gif" border=0></p>
<h3>Nonclustered Indexes</h3>
<p>
Nonclustered indexes resemble Oracle indexes. The index and the table are physically separated from each other, and each are considered separate database objects. Because these objects are separate, the physical order of the table rows is not the same as their indexed order. The leaf pages on nonclustered indexes contain the indexed value and the row address for the row within the table. A table can have up to 249 nonclustered indexes. Each index can provide access to the data in a table in different sorted order.</p>
<p>
<img src="orcl2sql_18.gif" border=0></p>
<p>
Because of the similarity in design, you can translate Oracle index definitions to SQL Server nonclustered index definitions (as shown in the following example). For performance reasons, however, you may want to consider using clustered indexes. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=53%><b>Oracle</b></td>
<td class=label width=47%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=53%>CREATE INDEX<br>
<b>STUDENT_ADMIN.</b>STUDENT_MAJOR_IDX<br>
ON STUDENT_ADMIN.STUDENT (MAJOR)<br>
TABLESPACE USER_DATA<br>
<b>PCTFREE 0<br>
STORAGE (INITIAL 10K NEXT 10K<br>
&nbsp;&nbsp;&nbsp;&nbsp;MINEXTENTS 1 MAXEXTENTS UNLIMITED)</b></td>
<td width=47%>CREATE <b>NONCLUSTERED </b>INDEX<br>
STUDENT_MAJOR_IDX<br>
ON <b>USER_DB.</b>STUDENT_ADMIN.STUDENT&nbsp;&nbsp;&nbsp;&nbsp; (MAJOR)</td>
</tr>
</table><br>
<h3>Clustered Indexes</h3>
<p>
A clustered index is an index that has been physically merged with a table. The table and index share the same storage area. The clustered index physically rearranges the rows of data in indexed order, forming the intermediate decision nodes. The leaf pages of the index contain the actual table data. This type of architecture permits only one clustered index per table.</p>
<p>
<img src="orcl2sql_19.gif" border=0></p>
<p>
Clustered indexes can be useful for:
<ul type=disc>
<li>
Primary keys.<br><br></li>
<li>
Columns that are not updated.<br><br></li>
<li>
Queries that return a range of values, using operators such as BETWEEN, &gt;, &gt;=, &lt;, and &lt;=:<pre><code>SELECT * FROM STUDENT WHERE GRAD_DATE
BETWEEN '1/1/97' AND '12/31/97'</code></pre>
</li>
<li>
Queries that return large result sets:<pre><code>SELECT * FROM STUDENT WHERE LNAME = 'SMITH'</code></pre>
</li>
<li>
Columns that are used in sort operations (ORDER BY, GROUP BY).<p class=tl>
For example, on the <b>STUDENT</b> table, it might be helpful to include a nonclustered index on the primary key of <b>SSN</b>, while the clustered index could be created on <b>lname</b>, <b>fname</b>, (last name, first name), because this is how students are often grouped.</P></li>
</ul>
<p>
To avoid <i>hot spots</i>, clustered indexes can sometimes be used to spread out update activity in a table. The common cause of hot spots is multiple users inserting into a table with an ascending key. This application scenario, however, is best addressed by the new insert row-lock table option in SQL Server 6.5 (see the "Insert Row-level Locking (IRL)" section later in this paper) rather than attempting to spread out the inserts with a clustered index on a non-key column. </p>
<p>
Dropping and re-creating a clustered index is a common technique for reorganizing a table in SQL Server. It is an easy way to ensure that data pages are contiguous on disk and to reestablish some free space in the table. This is similar to exporting, dropping, and importing a table in Oracle.</p>
<p>
A SQL Server clustered index is not at all like an Oracle cluster. An Oracle cluster is a physical grouping of two or more tables that share the same data blocks and use common columns as a cluster key. SQL Server does not have a structure that is similar to an Oracle cluster. </p>
<p>
As a rule, you should always have a clustered index defined on a table. Doing so improves SQL Server performance and space management. If you don't know the query or update patterns for a given table, you can default to using the clustered index on the primary key. Later analysis of application bottlenecks may lead you to change the clustered index on specific tables to better support frequently used range queries. </p>
<p>
An excerpt from the sample application source code is shown. Note the use of the SQL Server clustered index.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Oracle</b></td>
<td class=label width=50%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=50%>CREATE TABLE STUDENT_ADMIN.GRADE (<br>
SSN&nbsp;&nbsp;&nbsp;&nbsp;CHAR(9) NOT NULL,<br>
CCODE&nbsp;&nbsp;&nbsp;&nbsp;VARCHAR2(4) NOT NULL,<br>
GRADE&nbsp;&nbsp;&nbsp;&nbsp;VARCHAR2(2) NULL,<br>
CONSTRAINT GRADE_SSN_CCODE_PK<br>
&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY KEY (SSN, CCODE)<br>
CONSTRAINT GRADE_SSN_FK<br>
&nbsp;&nbsp;&nbsp;&nbsp;FOREIGN KEY (SSN) REFERENCES<br>
&nbsp;&nbsp;&nbsp;&nbsp;STUDENT_ADMIN.STUDENT (SSN),<br>
CONSTRAINT GRADE_CCODE_FK<br>
&nbsp;&nbsp;&nbsp;&nbsp;FOREIGN KEY (CCODE) REFERENCES<br>
&nbsp;&nbsp;&nbsp;&nbsp;DEPT_ADMIN.CLASS (CCODE)<br>
)</td>
<td width=50%>CREATE TABLE STUDENT_ADMIN.GRADE (<br>
SSN&nbsp;&nbsp;&nbsp;&nbsp;CHAR(9) NOT NULL,<br>
CCODE&nbsp;&nbsp;&nbsp;&nbsp;VARCHAR(4) NOT NULL,<br>
GRADE&nbsp;&nbsp;&nbsp;&nbsp;VARCHAR(2) NULL,<br>
CONSTRAINT GRADE_SSN_CCODE_PK<br>
&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY KEY <b>CLUSTERED</b> (SSN,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCODE),<br>
CONSTRAINT GRADE_SSN_FK<br>
&nbsp;&nbsp;&nbsp;&nbsp;FOREIGN KEY (SSN) REFERENCES<br>
&nbsp;&nbsp;&nbsp;&nbsp;STUDENT_ADMIN.STUDENT (SSN),<br>
CONSTRAINT GRADE_CCODE_FK<br>
&nbsp;&nbsp;&nbsp;&nbsp;FOREIGN KEY (CCODE) REFERENCES<br>
&nbsp;&nbsp;&nbsp;&nbsp;DEPT_ADMIN.CLASS (CCODE)<br>
)</td>
</tr>
</table><br>
<h3>Fill Factor</h3>
<p>
The FILLFACTOR option functions in much the same way as the PCTFREE variable does in Oracle. As tables grow in size, index pages split to accommodate new data. The index must reorganize itself to accommodate new data values.</p>
<p>
The FILLFACTOR option (values are 1 through 100) controls how much space is left on an index page when the index is initially created. The default fill factor of 0 completely fills index leaf pages and leaves space on each decision node page for at least one entry (two for non-unique clustered indexes). Note that the fill factor percentage is only used when the index is created, and is not maintained afterwards.</p>
<p>
<img src="orcl2sql_20.gif" border=0></p>
<p>
A lower fill factor value initially reduces the splitting of index pages and increases the number of levels in the B-tree index structure. A higher fill factor uses index page space more efficiently, requires fewer disk I/O's to access index data, and reduces the number of levels in the B-tree index structure.</p>
<p>
The PAD_INDEX<b> </b>option<b> </b>specifies that the fill factor setting be applied to the decision node pages as well as to the data pages in the index. </p>
<p>
While it may be necessary to adjust the PCTFREE<b> </b>parameter for optimal performance in Oracle, it is seldom necessary to include the FILLFACTOR option in a CREATE INDEX statement. The fill factor is provided for fine-tuning performance. It is useful only when creating a new index on a table with existing data, and then it is useful only when you can accurately predict future changes in that data.</p>
<p>
If you have set the PCTFREE parameter to 0 for Oracle indexes, consider using a fill factor of 100. This is used when there will be no inserts or updates occurring in the table (a read-only table). When fill factor is set to 100, SQL Server creates indexes with each page 100 percent full.</p>
<h3>Ignoring Duplicate Keys</h3>
<p>
The default operation of a unique index in Oracle and SQL Server is virtually identical. You cannot insert duplicate values for a uniquely indexed column or columns. An attempt to do so generates an error message. </p>
<p>
This default operation can be changed when the IGNORE_DUP_KEY option is set when the index is created. In this case, when an INSERT or UPDATE attempts to duplicate a currently existing indexed value, the statement is ignored and no error message is returned.</p>
<p>
The purpose of IGNORE_DUP_KEY (and of the IGNORE_DUP_ROW option) is to allow a transaction to proceed although duplicates are present. In order to ensure maximum compatibility with your Oracle applications, do not set these options when you create indexes. For more information about these options, see the <i>Microsoft SQL Server Transact-SQL Reference </i>or Microsoft SQL Server Books Online. </p>
<h3>Other Index Considerations</h3>
<p>
Oracle and SQL Server allow up to 16 columns to be defined in an index. However, the sum of the lengths of the columns that make up a SQL Server composite index cannot exceed 900 bytes (versus approximately one-half the block size in Oracle).</p>
<p>
In Oracle, an index name must be unique within a user account. In SQL Server, an index name must be unique within a table name, but it does not have to be unique within a user account or database. For example:</p>
<pre><code>CREATE INDEX DEMO_IDX ON USER_DB.STUDENT_ADMIN.STUDENT (LNAME)
</code></pre>
<p>
If these same statements are issued in Oracle, you receive this error message: "ORA-00955: name is already used by an existing object."</p>
<p>
When dropping an index in SQL Server, you must specify both the table name and the index name. Additionally, the DROP INDEX statement can be used to drop multiple indexes at one time:</p>
<pre><code>DROP INDEX USER_DB.STUDENT.DEMO_IDX, USER_DB.GRADE.DEMO_IDX
</code></pre>
<p>
For more information about managing indexes, see the <i>Microsoft SQL Server Transact-SQL Reference</i>.</p>
<h3>Data Type Conversions</h3>
<p>
SQL Server has a much more robust selection of data types than Oracle. There are many possible conversions between the Oracle and SQL Server data types. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Oracle</b></td>
<td class=label width=79%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=21%>CHAR</td>
<td width=79%><b>char</b> is recommended. <b>char</b> type columns are accessed somewhat faster than <b>varchar</b> columns because they use a fixed storage length.</td>
</tr>
<tr valign=top>
<td width=21%>VARCHAR2 <br>
and LONG</td>
<td width=79%><b>varchar</b> or <b>text</b>. (If the length of the data values in your Oracle column is 255 bytes of less, use <b>varchar</b>; otherwise, you must use <b>text.</b>)</td>
</tr>
<tr valign=top>
<td width=21%>RAW and <br>
LONG RAW</td>
<td width=79%><b>varbinary</b> or <b>image</b>. (If the length of the data values in your Oracle column is 255 bytes of less, use <b>varbinary</b>; otherwise, you must use <b>image</b>.)</td>
</tr>
<tr valign=top>
<td width=21%>NUMBER</td>
<td width=79%>If integer between 1 and 255, use <b>tinyint</b>.<br>
If integer between -32768 and 32767, use <b>smallint</b>.<br>
If integer between -2,147,483,648 and 2,147,483,647 use <b>int</b>.<br>
If you require a float type number, use <b>numeric </b>(has precision and scale).<br>
Note: Do not use <b>float</b> or <b>real</b>, because rounding may occur (Oracle NUMBER and SQL Server <b>numeric</b> do not round).<br>
If you are not sure, use <b>numeric</b>; it most closely resembles Oracle NUMBER data type.</td>
</tr>
<tr valign=top>
<td width=21%>DATE</td>
<td width=79%><b>datetime</b>.</td>
</tr>
<tr valign=top>
<td width=21%>ROWID</td>
<td width=79%>Use the <b>identity</b> column type.</td>
</tr>
<tr valign=top>
<td width=21%>CURRVAL, NEXTVAL</td>
<td width=79%>Use the <b>identity</b> column type, and <b>@@identity global</b> variable, IDENT_SEED() and IDENT_INCR() functions.</td>
</tr>
<tr valign=top>
<td width=21%>SYSDATE</td>
<td width=79%>GETDATE()</td>
</tr>
<tr valign=top>
<td width=21%>USER</td>
<td width=79%>USER</td>
</tr>
</table><br>
<p>
For more information about SQL Server data types, see the <i>Microsoft SQL Server Transact-SQL Reference.</i></p>
<h3>timestamp Columns</h3>
<p>
The <b>timestamp </b>columns enable BROWSE-mode updates and make cursor update operations more efficient. The <b>timestamp</b> is a data type that is automatically updated every time a row containing a <b>timestamp</b> column is inserted or updated.</p>
<p>
Values in <b>timestamp</b> columns are not <b>datetime</b> data, but <b>binary(8)</b> or <b>varbinary(8)</b> data, indicating the sequence of SQL Server activity on the row. A table can have only one <b>timestamp</b> column. The <b>timestamp</b> data type is not related to the system time. It is a sequentially increasing counter whose values are always unique within a database.</p>
<p>
For more information, see <i>Microsoft SQL Server Programming DB-Library for C</i>.</p>
<h3>Sequences and the IDENTITY Property</h3>
<p>
If your Oracle application currently uses sequences to generate sequential numeric values, it can be easily altered to take advantage of the SQL Server IDENTITY property. The primary difference between SQL Server and Oracle is that the IDENTITY property is actually part of the column, while a sequence is independent of any tables or columns.</p>
<p>
The SQL Server IDENTITY property generates incremental values for new rows based on IDENT_SEED and IDENT_INCR parameters. The IDENT_SEED parameter, which is similar to the sequence START WITH parameter, specifies the starting number. The IDENT_INCR parameter, which is similar to the sequence INCREMENT BY parameter, specifies the interval that will be applied to each subsequent value. By default, both IDENT_SEED and IDENT_INCR default to the value of 1.</p>
<p>
The IDENTITY property must be assigned to a <b>tinyint</b>, <b>smallint</b>, <b>int</b>, <b>decimal</b>(<b>p,0</b>), or <b>numeric</b>(<b>p,0</b>) column that does not allow null values. Only one column per table can be defined as an IDENTITY column. Defaults and DEFAULT constraints cannot be bound to an IDENTITY column, and an identity value cannot be updated.</p>
<p>
The keyword IDENTITYCOL can be used in place of a column name when referencing a column that has the IDENTITY property. The IDENTITYCOL keyword can be used with SELECT, INSERT, UPDATE, and DELETE statements.</p>
<p>
Two system functions return identity information for an object containing an IDENTITY column.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=33%><b>Function</b></td>
<td class=label width=67%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=33%>IDENT_SEED('table_name')</td>
<td width=67%>This returns the seed value specified during creation of an identity column.</td>
</tr>
<tr valign=top>
<td width=33%>IDENT_INCR('table_name')</td>
<td width=67%>This returns the increment value specified during creation of an identity column.</td>
</tr>
</table><br>
<p>
The global variable <b>@@IDENTITY</b> contains the value of the IDENTITY column for the most recently inserted row for a user connection. </p>
<h3>Views</h3>
<p>
The syntax used to create views in SQL Server is similar to the syntax used in Oracle.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=47%><b>Oracle</b></td>
<td class=label width=53%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=47%>CREATE [OR REPLACE] [FORCE | <br>
NOFORCE] VIEW [<i>schema</i>.]<i>view_name</i><br>
[(<i>column_name</i> [, <i>column_name</i>]...)]<br>
AS <i>select_statement</i><br>
[WITH CHECK OPTION [CONSTRAINT <i>name</i>]]<br>
[WITH READ ONLY]</td>
<td width=53%>CREATE VIEW [<i>owner</i>.]<i>view_name</i><br>
[(<i>column_name</i> [, <i>column_name</i>]...)]<br>
[WITH ENCRYPTION]<br>
AS <i>select_statement</i> [WITH CHECK OPTION]</td>
</tr>
</table><br>
<p>
SQL Server views require that the tables exist and that the view owner has privileges to access the requested tables(s) specified in the SELECT statement. This performs the same as the Oracle FORCE option.</p>
<p>
By default, data modification statements on views are not checked to determine whether the rows affected are within the scope of the view. If all modifications should be checked, use the WITH CHECK OPTION. The primary difference between the WITH CHECK OPTION is that Oracle defines it as a constraint, while SQL Server does not. Otherwise, it functions the same in both.</p>
<p>
SQL Server does not offer the WITH READ ONLY option when defining views. The same result can be obtained, however, by granting only SELECT permission to all users of the view.</p>
<p>
Both SQL Server and Oracle views support derived columns, using arithmetic expressions, functions, and constant expressions. Some of the specific SQL Server differences are:
<ul type=disc>
<li>
Data modification statements (INSERT or UPDATE) are allowed on multitable views if the data modification statement affects only one base table. Data modification statements cannot be used on more than one table in a single statement.<br><br></li>
<li>
You cannot use READTEXT or WRITETEXT on <b>text</b> or <b>image</b> columns in views.<br><br></li>
<li>
You cannot include ORDER BY, COMPUTE, or COMPUTE BY clauses.<br><br></li>
<li>
You cannot include the INTO keyword.<br><br></li>
<li>
You cannot reference a temporary table.</li>
</ul>
<p>
If you define a SQL Server view with an outer join and then query the view with a qualification on a column from the inner table of the outer join, the results can differ from what is expected. All rows from the inner table are returned. Rows that do not meet the qualification show a null value in the appropriate columns for those rows.</p>
<p>
In most cases, Oracle views are easily translated into SQL Server views. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>CREATE VIEW STUDENT_ADMIN.STUDENT_GPA<br>
(SSN, GPA)<br>
AS SELECT SSN, ROUND(AVG<b>(DECODE(grade<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'A', 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'A+', 4.3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'A-', 3.7<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'B', 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'B+', 3.3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'B-', 2.7<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'C', 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'C+', 2.3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'C-', 1.7<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'D', 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'D+', 1.3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,'D-', 0.7<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ,0)</b>),2)<br>
FROM STUDENT_ADMIN.GRADE<br>
GROUP BY SSN</td>
<td width=51%>CREATE VIEW STUDENT_ADMIN.STUDENT_GPA<br>
(SSN, GPA)<br>
AS SELECT SSN, ROUND(AVG<b>(CASE grade<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'A' THEN 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'A+' THEN 4.3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'A-' THEN 3.7<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'B' THEN 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'B+' THEN 3.3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'B-' THEN 2.7<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'C' THEN 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'C+' THEN 2.3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'C-' THEN 1.7<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'D' THEN 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'D+' THEN 1.3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHEN 'D-' THEN 0.7<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END</b>),2)<br>
FROM STUDENT_ADMIN.GRADE<br>
GROUP BY SSN</td>
</tr>
</table><br>
<h3>Using Temporary Tables</h3>
<p>
An Oracle application may have to create tables that exist for short periods. The application must ensure that all tables that are created for this purpose are dropped at some point. If the application fails to do this, tablespaces can quickly become cluttered and unmanageable.</p>
<p>
This is not the case in SQL Server. SQL Server allows temporary tables to be created for just such a purpose. Regardless of the user, these tables are created in the <b>tempdb</b> database. The naming convention used with these tables controls how long they reside within the <b>tempdb</b> database.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Table name</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><b>#table_name</b></td>
<td width=75%>This local temporary table only exists for the duration of a user session or the procedure that created it. It is automatically dropped when the user logs off or the procedure that created the table completes. These tables cannot be shared between multiple users. No other database users can access this table. Permissions cannot be granted or revoked on this table.</td>
</tr>
<tr valign=top>
<td width=25%><b>##table_name</b></td>
<td width=75%>This global temporary table also typically exists for the duration of a user session or procedure that created it. This table can be shared among multiple users. It is automatically dropped when the last user session referencing it disconnects. All other database users can access this table. Permissions cannot be granted or revoked on this table.</td>
</tr>
<tr valign=top>
<td width=25%><b>tempdb..table_name</b></td>
<td width=75%>This table will continue to exist until it is dropped or SQL Server is restarted. Permissions can be granted and revoked against this table. To create this table, the database user must have CREATE TABLE permission in the <b>tempdb</b> database.</td>
</tr>
</table><br>
<p>
Indexes can be defined for temporary tables. Views can only be defined on tables explicitly created in <b>tempdb</b> without the # or ## prefix. The following example shows the creation of a temporary table and its associated index. When the user exits, the table and index are automatically dropped.</p>
<pre><code>SELECT SUM(ISNULL(TUITION_PAID,0)) SUM_PAID, MAJOR INTO #SUM_STUDENT
FROM USER_DB.STUDENT_ADMIN.STUDENT GROUP BY MAJOR


CREATE UNIQUE INDEX SUM STUDENT IDX ON #SUM STUDENT (MAJOR)
</code></pre>
<p>
To ensure complete compatibility with an Oracle application, you may not want to use temporary tables. However, you may find that the benefits associated with using them justify a slight revision in program code.</p>
<h3>Creating Tables Using SELECT Statements</h3>
<p>
In Oracle, a table can be created using any valid SELECT statement. For example, the following syntax is used to create the table <b>student_backup</b>:</p>
<pre><code>create table student_backup as select * from student_admin.student
</code></pre>
<p>
SQL Server allows you to do the same thing. However, the syntax is slightly changed:</p>
<pre><code>select * into student_backup from ser_db.student_admin.student
</code></pre>
<p>
It is important to note that a SELECT…INTO does not work unless the database in which this is done has the <b>select into/bulkcopy</b> option set to <b>true</b>. Only the DBO can set this option using SQL Enterprise Manager or the <b>sp_dboption</b> system stored procedure.</p>
<p>
The <b>sp_helpdb</b> system stored procedure can be used to check the status of the database. If <b>select into/bulkcopy</b> is not set to <b>true</b>, you can still use a SELECT statement to copy into a temporary table:</p>
<pre><code>select * into #student_backup from user_db.student_admin.student
</code></pre>
<p>
As in Oracle, when a table is copied in SQL Server, the referential integrity definitions are not copied to the new table.</p>
<p>
The need to have the <b>select into/bulkcopy</b> set to <b>true</b> may complicate the migration process. If you need to copy data into tables using a SELECT statement, consider creating the table first and then using the insert INTO…SELECT statement to load the table. This method is compatible between Oracle and SQL Server, and does not require that any database option be set. However, this method is slower in SQL Server because every row is logged.</p>
<h3>User-defined Data Types, Rules, and Defaults</h3>
<p>
SQL Server offers three database objects that do not exist in Oracle: user-defined data types, rules, and defaults. If you require strict compatibility between your SQL Server and Oracle applications, do not use these objects. However, they are extremely useful and provide a level of extensibility that is simply not available in Oracle.</p>
<h4>User-defined Data Types</h4>
<p>
Use system data types (supplied by SQL Server) and user-defined data types (custom data types based on system data types) to enforce data integrity. </p>
<p>
User-defined data types are created with the <b>sp_addtype</b> system stored procedure. When creating user-defined data types, supply three parameters: the name of the data type, the system data type upon which the new data type is based, and the data type's nullability (whether it allows null values: if defined explicitly, NULL or NOT NULL). When nullability is not explicitly defined, it is assigned based on the ANSI null default setting for the database or connection. </p>
<p>
After a user data type is created, use it in the CREATE TABLE and ALTER TABLE statements, as well as bind defaults and rules to it. If nullability is explicitly defined when the user-defined data type is used during table creation, it takes precedence over the defined nullability. For more information, see the <i>Microsoft SQL Server</i> <i>Transact-SQL Reference</i>.</p>
<p>
This example shows how to create a user-defined data type:</p>
<pre><code>sp_addtype gender_type, 'varchar(1)', 'not null'
go
</code></pre>
<p>
This capability may initially appear to solve the problem of migrating Oracle table creation scripts to SQL Server. For example, it is quite easy to add the Oracle DATE data type:</p>
<pre><code>sp_addtype date, datetime
</code></pre>
<p>
This does not work with data types that require variable sizes, for example the Oracle data type NUMBER. An error message is returned indicating that a length must also be specified:</p>
<pre><code>sp_addtype varchar2, varchar
Go
Msg 15091, Level 16, State 1
You must specify a length with this physical type.
</code></pre>
<h4>User-defined Rules</h4>
<p>
User-defined <i>rules</i> are database objects that specify the acceptable values that can be inserted into a column. They are created with the CREATE RULE statement. A rule must be bound to a column or a user-defined data type using the <b>sp_bindrule</b> system stored procedure. When a rule is bound to a column, it does not apply itself to data already within the table (this is similar in operation to a trigger). Rules can only be defined within the context of one database.</p>
<p>
When bound directly to a column, rules provide much of the same function as a CHECK constraint. The use of CHECK constraints to restrict column data is preferred because CHECK constraints follow ANSI standard SQL. Additionally, multiple CHECK constraints can be defined on a column or on multiple columns, whereas a column can have only one rule associated with it.</p>
<p>
However, rules are especially useful when bound to user-defined data types. A rule bound to a user-defined data type is automatically inherited by any table that includes a column of that type. The rule can be changed in one place, and the change applies to all instances of the data type. </p>
<p>
How to create and bind a rule to a user-defined data type is shown in this example:</p>
<pre><code>create rule gender_rule as @gender in ('M','F')
go
sp_bindrule gender_rule, gender_type
go
</code></pre>
<p>
For more information about the CREATE RULE statement, see the <i>Microsoft SQL Server Transact-SQL Reference</i>.</p>
<h4>User-defined Defaults</h4>
<p>
The CREATE DEFAULT statement creates a user-defined default. The DEFAULT constraint is the recommended method for restricting column data because the constraint definition is expressed in the ANSI-standard CREATE TABLE and ALTER TABLE statements. Like rules, however, a user-defined default is especially useful when bound to a user-defined data type and used in multiple tables.</p>
<p>
The <b>sp_binddefault</b> system stored procedure is used to bound a user-defined default to either a column in a table or a user-defined data type. This example shows how to create and bind a user-defined default on a user-defined data type:</p>
<pre><code>create default gender_dflt as 'F'
go
sp_bindefault gender_dflt, gender_type
go
</code></pre>
<p>
For more information about the CREATE DEFAULT statement, see the <i>Microsoft SQL Server Transact-SQL Reference</i>. </p>
<h3>Object-level Permissions</h3>
<p>
The syntax of the GRANT statement is identical in Oracle and SQL Server.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Oracle</b></td>
<td class=label width=52%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=48%>GRANT {ALL [PRIVILEGES][<i>column_list</i>] | <i>permission_list</i> [<i>column_list</i>]}<br>
ON {<i>table_name</i> [(<i>column_list</i>)]<br>
 | <i>view_name</i> [(<i>column_list</i>)]<br>
 | <i>stored_procedure_name</i>}<br>
TO {PUBLIC | <i>name_list</i> }<br>
[WITH GRANT OPTION] </td>
<td width=52%>GRANT {ALL [PRIVILEGES][<i>column_list</i>] | <i>permission_list</i> [<i>column_list</i>]}<br>
ON {<i>table_name</i> [(<i>column_list</i>)]<br>
 | <i>view_name</i> [(<i>column_list</i>)]<br>
 | <i>stored_procedure_name</i>}<br>
TO {PUBLIC | <i>name_list</i> }<br>
[WITH GRANT OPTION] </td>
</tr>
</table><br>
<p>
SQL Server object privileges can be granted to other database users, database groups, and the public group. SQL Server does not allow an object owner to grant ALTER TABLE and CREATE INDEX privileges for the object as Oracle does. Those privileges must remain with the object owner.</p>
<p>
In Oracle, the REFERENCES privilege can only be granted to a user. SQL Server allows the REFERENCES privilege to be granted to both database users and database groups. The INSERT, UPDATE, DELETE, and SELECT privileges are granted the same way in each DBMS.</p>
</BODY>
</HTML>
