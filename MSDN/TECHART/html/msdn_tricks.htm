<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The C/C++ Compiler Learns New Tricks</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_tricks"></a></sup>The C/C++ Compiler Learns New Tricks</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: August 28, 1992<br>
Revised: January 27, 1993 <br>
The section on simplified building was removed. (This method links all programs with the /NOI option enabled, which causes problems.)</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="104">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the Back sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
<b>WinMain</b>, <b>GlobalAlloc</b>, and mixed-model programming—these are just some of the conventions C programmers had to accept when they started programming for the Microsoft® Windows™ operating system. Microsoft C/C++ version 7.0 can now hide these conventions so that programmers can use standard C practices; applications thus become much easier to develop and port. This article provides an overview of programming conventions that C/C++ programmers no longer need and a discussion of the new programming practices in C/C++ version 7.0. A bibliography of suggested reading material is included at the end of this article.</p>
<p>
A sample application called Back (BACK.EXE) and its accompanying dynamic-link library (DLL) called Trace (TRACE.DLL) demonstrate many of the ideas in this article. See the "Notes on the Sample Application" section for more information about Back and Trace.</p>
<p>
<b>Note:</b> The information in this article is valid only for Microsoft Windows version 3.<i>x</i> standard and enhanced modes.</p>
<h2>Introduction</h2>
<p>
The Microsoft® C/C++ version 7.0 compiler and run-time libraries were designed for the Microsoft Windows™ operating system. For this reason, programmers no longer have to follow many of the conventions that differentiated Windows-based programs from MS-DOS®–based programs. For example, C/C++ programmers can now use:
<ul type=disc>
<li>
Large-model programming instead of mixed-model programming.<br><br></li>
<li>
The <b>main</b> function instead of the <b>WinMain</b> function.<br><br></li>
<li>
<b>_fmalloc</b> instead of <b>GlobalAlloc</b>.<br><br></li>
<li>
<b>GlobalAllocPtr</b> instead of <b>GlobalAlloc</b>.<br><br></li>
<li>
Dynamic-link libraries (DLLs) with default <b>LibMain</b> and <b>WEP</b>.</li>
</ul>
<p>
The following sections discuss each of these topics in detail.</p>
<h2>Large Model vs. Mixed Model</h2>
<p>
One of the first weird conventions that programmers moving to Windows face is mixed-model programming. Mixed-model programming brings out the worst in segmented processor architectures. Some pointers are near while others are far. Some variables default to near while others default to far. Source code becomes a confused mass with near and far casts strewn throughout. In Windows protected modes, large model is now the model of choice.</p>
<h3>Single Instances</h3>
<p>
The behavior of Microsoft C version 6.0 was one reason why programmers were reluctant to use the large model. C version 6.0 built large-model applications with multiple read/write data segments. Windows forces an application that uses multiple read/write data segments to be single instance; therefore, applications built by C version 6.0 would run only single instance.</p>
<p>
If you want to build a single-instance application, the Microsoft C/C++ compiler's large model gives it to you for free. There is no need to check <i>hPrevInstance</i>—Windows does all the work for you, including putting up an informative dialog box that tells the user that only one instance can run.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you are not using the Microsoft C/C++ compiler, you should check the documentation for your C compiler to see which options will generate multiple read/write data segments.</p>
<h3>Multiple Instances</h3>
<p>
It is possible to get multiple instances with a large-model application. If you use Borland® C++ or Microsoft C/C++ version 7.0, it is easy to get a single 64K read/write data segment. For the Microsoft C/C++ compiler, the <b>/Gx</b> and <b>/Gt<i>nnn</i></b> options will do the trick; for the Borland C++ compiler, a single data segment is the default.</p>
<p>
For more information, see the "Programming at Large" and "Allocating Memory the Newfangled Way: The <i>new</i> Operator" technical articles on the Microsoft Developer Network CD (Technical Articles, C/C++ Articles).</p>
<h3>Performance</h3>
<p>
Many programmers are concerned about the amount of overhead in a large-model application compared with a small-model or mixed-model application. Performance is never free. Just using the mixed model instead of the large model never makes an application significantly faster. The best method is to use a profiler to determine which code gets executed the most, and optimize that code.</p>
<p>
It is preferable to optimize code using portable techniques. If you spend a week making functions near and using other optimizations specific to a segmented architecture, the optimizations (and your week of work) will be lost when you port the code to Windows NT™. Instead, you could spend the week reworking the algorithms used in the code that is executed the most. These improvements will impact performance more significantly than which language, compiler, or compiler options you use.</p>
<p>
However, if your marketing department changes specifications faster than an 80486 can prefetch an instruction, algorithms often change overnight. In this situation, a programmer must often use the compiler (sometimes blindly) to try to speed up code instead of optimizing the code itself.</p>
<h2>main vs. WinMain</h2>
<p>
The Microsoft C/C++ startup code first checks for a function labeled <b>main</b> in a Windows-based program. If it cannot find <b>main</b>, it tries to locate a function called <b>WinMain</b>. The gist of this wonderful information is that a Windows-based application can use <b>main</b> instead of <b>WinMain</b> as its entry point, just like an MS-DOS C program. One of the standard ways to declare <b>main</b> is:</p>
<pre><code>void main(int argc, char *argv[], char **envp)
{
}
</code></pre>
<p>
Why would a program want to use <b>main</b>? Possibly for portability or to use a common source between Windows and MS-DOS or UNIX®. Using <b>main</b> also allows programmers to build upon their MS-DOS knowledge for handling the command line and the environment.</p>
<p>
Not to be outdone by any old application, DLLs can also use <b>main</b> instead of <b>LibMain</b> as an entry point. However, in C/C++ version 7.0, the Windows libraries include a default <b>LibMain</b>, so most DLLs will not need a <b>main</b> or <b>LibMain</b> function. This is covered later in the "Using DLLs" section.</p>
<p>
The above information was found in plain and public display in the DETAILS.TXT file, which is provided with the Microsoft C/C++ compiler. Those interested in reading code should check out the SOURCE\STARTUP\WIN directory for the STUBMAIN.ASM and CRT0.ASM files.</p>
<h3>Getting to hInstance</h3>
<p>
The careful reader will be wondering where the program is going to get its instance handle. Why, from <i>_hInstance</i>, of course! <i>_hInstance</i> is an undocumented feature of the C/C++ startup code.</p>
<p>
When Windows calls the startup code, the instance handle is passed to the startup code in the DI register, as documented in the Microsoft Windows version 3.1 Software Development Kit (SDK) <i>Programmer's Reference, Volume 1: Overview</i>, in Chapter 22.</p>
<p>
The instance handle is then placed in a global variable called <i>_hInstance</i>. To access this variable, you must declare it first:</p>
<pre><code>extern const HINSTANCE _hInstance;
</code></pre>
<p>
The startup code also includes the following global variables for the other parameters normally passed to <b>WinMain</b>:
<ul type=disc>
<li>
_<i>hPrevInstance</i><br><br></li>
<li>
<i>_lpszCmdLine</i><br><br></li>
<li>
<i>_cmdShow</i></li>
</ul>
<p>
You can access these variables by using the following declarations:</p>
<pre><code>extern const HINSTANCE _hPrevInstance;
extern const LPSTR _lpszCmdLine;
extern const int _cmdShow;
</code></pre>
<p>
The parameters passed to a DLL are different from parameters passed to an application. The following global variables are defined in the startup code for a DLL:
<ul type=disc>
<li>
<i>_hModule</i><br><br></li>
<li>
<i>_lpszCmdLine</i><br><br></li>
<li>
<i>_wDataSeg</i><br><br></li>
<li>
<i>_wHeapSize</i></li>
</ul>
<p>
The following declarations will give you access to these variables:</p>
<pre><code>extern const HINSTANCE _hModule ;
extern const LPSTR _lpszCmdLine ;
extern const WORD _wDataSeg ;
extern const WORD _wHeapSize ;
</code></pre>
<p>
A quick look into the startup code uncovered the above information. The startup code is included with Microsoft C/C++ version 7.0; look in the SOURCE\STARTUP directory. For more information on the startup code and what it does, see "A Comprehensive Examination of the Microsoft C Version 6.0 Startup Code" in the <i>Microsoft Systems Journal</i>, Vol. 7, No. 1, on the Microsoft Developer Network CD. The article examines C version 6.0 startup code for MS-DOS, but most of the information is also valid for version 7.0. This article explains the work the startup code must perform and provides background information for reading the source code.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The startup source code is subject to change between compiler releases. The inclusion of specific startup variables or functions is not guaranteed in future releases.</p>
<h2>_fmalloc vs. GlobalAlloc</h2>
<p>
The big problem with <b>GlobalAlloc</b> is that it consumes a selector for each call. A selector is a limited resource in Windows version 3.<i>x</i>, so <b>GlobalAlloc</b> is inappropriate for allocating small blocks of memory such as nodes in a linked list. The solution is to implement a subsegment allocation scheme in which one segment is allocated with <b>GlobalAlloc</b> and divided up into small blocks.</p>
<p>
Fortunately, Microsoft C/C++ version 7.0 includes a subsegment allocation scheme called <b>_fmalloc</b>. <b>_fmalloc</b> is the large-model or model-independent version of <b>malloc</b>. When you compile with the large model, <b>malloc</b> is mapped to <b>_fmalloc</b>. In other memory models, <b>malloc</b> must explicitly be called <b>_fmalloc</b>.</p>
<p>
<b>_fmalloc</b> manages its own heap on top of the Windows global heap. When <b>_fmalloc</b> is called, it first checks whether it can satisfy the memory request by simply returning a pointer to an unused block inside its heap. If it can't, <b>_fmalloc</b> takes one of the following actions:
<ul type=disc>
<li>
If the 64K limit of the block is reached or no memory had been allocated, <b>_fmalloc</b> allocates a segment with <b>GlobalAlloc</b>.<br><br></li>
<li>
If more room is needed, <b>_fmalloc</b> enlarges a segment with <b>GlobalReAlloc</b>.</li>
</ul>
<p>
You use <b>_ffree</b> to free the memory blocks allocated by <b>_fmalloc</b>. However, <b>_ffree</b> does not call <b>GlobalFree</b>. Instead, <b>_ffree</b> marks a block as unused, and <b>_fmalloc</b> tries to satisfy future requests for memory with these unused blocks by reusing them. The <b>_heapmin</b> function releases unused blocks back to Windows.</p>
<p>
For more information on using <b>malloc</b> in a Windows-based program, see the "Allocating Memory the Old-Fashioned Way: _fmalloc and Applications for Windows" technical article on the Microsoft Developer Network CD (Technical Articles, C/C++ Articles).</p>
<h2>GlobalAllocPtr vs. GlobalAlloc</h2>
<p>
If you don't want to use <b>_fmalloc</b>, at least use <b>GlobalAllocPtr</b> instead of <b>GlobalAlloc</b>. <b>GlobalAllocPtr</b> is a macro defined in WINDOWSX.H that allocates the memory, locks the handle, and returns a pointer to the allocated memory. To free the memory, use <b>GlobalFreePtr</b>. There is no need to retain memory handles or lock and unlock memory blocks.</p>
<p>
What makes this possible is the <b>GlobalHandle</b> function, which takes a pointer and returns the handle to it. <b>GlobalHandle</b> removes the need for saving and tracking handles, resulting in incredible savings in time, memory, and complexity.</p>
<p>
Other convenient memory macros in WINDOWSX.H are:
<ul type=disc>
<li>
<b>GlobalPtrHandle</b><br><br></li>
<li>
<b>GlobalLockPtr</b><br><br></li>
<li>
<b>GlobalUnlockPtr</b><br><br></li>
<li>
<b>GlobalReAllocPtr</b></li>
</ul>
<p>
If these macros were C functions, they would be prototyped as follows: </p>
<pre><code>void FAR * GlobalAllocPtr(UINT flags, DWORD size) ;
 &nbsp;&nbsp;&nbsp;&nbsp; // Allocates and locks a block of <b>size</b> bytes with the
 &nbsp;&nbsp;&nbsp;&nbsp; // <b>flags</b> set.

BOOL GlobalFreePtr(void FAR* lp) ;
 &nbsp;&nbsp;&nbsp;&nbsp; // Unlocks and frees the block pointer by <b>lp</b>;
 &nbsp;&nbsp;&nbsp;&nbsp; // returns a non-zero on success.

void FAR * GlobalReAllocPtr(void FAR* lp, DWORD size, UINT flags) ;
 &nbsp;&nbsp;&nbsp;&nbsp; // Reallocates the block pointed to by <b>lp</b> to <b>size</b> bytes with
 &nbsp;&nbsp;&nbsp;&nbsp; // the <b>flags</b> set.
 &nbsp;&nbsp;&nbsp;&nbsp; // The return value is the pointer to the reallocated block.

HGLOBAL GlobalPtrHandle(void FAR* lp) ;
 &nbsp;&nbsp;&nbsp;&nbsp; // Gets global handle pointed to by <b>lp</b> from FAR pointer.

BOOL GlobalLockPtr(void FAR* lp) ;
 &nbsp;&nbsp;&nbsp;&nbsp; // Locks the block <b>lp</b> points to.
 &nbsp;&nbsp;&nbsp;&nbsp; // If successful, returns a non-zero value.

BOOL GlobalUnlockPtr(void FAR* lp) ;
 &nbsp;&nbsp;&nbsp;&nbsp; // Unlocks the block <b>lp</b> points to.
 &nbsp;&nbsp;&nbsp;&nbsp; // If successful, returns a non-zero value.
</code></pre>
<p>
For the curious, here are the definitions of <b>GlobalAllocPtr</b> and <b>GlobalFreePtr</b>:</p>
<pre><code>#define GlobalAllocPtr(flags, cb)&nbsp; \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (GlobalLock(GlobalAlloc((flags), (cb))))

#define GlobalFreePtr(lp)&nbsp;&nbsp;&nbsp; \
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (GlobalUnlockPtr(lp),(BOOL)GlobalFree(GlobalPtrHandle(lp)))
</code></pre>
<h2>Using DLLs</h2>
<p>
Microsoft C/C++ version 7.0 run-time libraries provide better support for building DLLs. Two changes that simplify building DLLs are:
<ul type=disc>
<li>
A default <b>LibMain</b> function<br><br></li>
<li>
A default <b>WEP</b> function</li>
</ul>
<p>
Most of the information for this section can be found in the DETAILS.TXT file, which is included with the Microsoft C/C++ compiler.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The library files that do not include the C run-time functions (for example, <i>x</i>NOCRTDW.LIB, where <i>x</i> is the memory model) do not have a default <b>LibMain</b> or <b>WEP</b> function. You must provide your own <b>LibMain</b> and <b>WEP</b> functions if you use these libraries.</p>
<h3>LibMain</h3>
<p>
Many DLLs are collections of functions that do not need to perform initialization and therefore do nothing in the <b>LibMain</b> function. If a function does not do anything, it would be nice if the developer did not have to worry about it. The C run-time libraries now include a version of LIBENTRY.OBJ and a default <b>LibMain</b> function. So, if the DLL links to the C run-time functions, it does not have to link to LIBENTRY.OBJ or provide its own <b>LibMain</b> function.</p>
<p>
The default <b>LibMain</b> function is very clever. It does nothing.</p>
<h3>WEP</h3>
<p>
It is no longer necessary to include a dummy <b>WEP</b> function in your DLL code. The C run-time libraries now include a default version of the <b>WEP</b> function. The default <b>WEP</b> performs the following functions:
<ol>
<li>
Calls the optional user termination function <b>_WEP </b>(see next section).<br><br></li>
<li>
Performs C exit processing (calls <b>_cexit</b>).<br><br></li>
<li>
Returns to Windows the value returned by <b>_WEP</b>.</li>
</ol>
<p>
Placing <b>WEP</b> in a fixed segment ensures that it will exist in memory in case of error. For proper placement of <b>WEP</b>, include the following lines in the .DEF file:</p>
<pre><code>SEGMENTS 'WEP_TEXT' FIXED PRELOAD

EXPORTS
 &nbsp; WEP @1 RESIDENTNAME
</code></pre>
<p>
The source code for the default <b>WEP</b> function is included with the Microsoft C/C++ version 7.0 compiler. Look in the SOURCE\STARTUP\WIN directory for a file called WEP.ASM.</p>
<h3>_WEP</h3>
<p>
To add your own processing to the default <b>WEP</b> function, add a <b>_WEP</b> function to your DLL. (Note the leading underscore character.) Here is an example:</p>
<pre><code>int FAR PASCAL _WEP(int nExitType);

// Put _WEP code into same fixed segment as the WEP function.
#pragma alloc_text(WEP_TEXT, _WEP)

int FAR PASCAL _WEP(int nExitType)
{
 &nbsp; //
 &nbsp; // Exit cleanup code goes here. 
 &nbsp; //
 &nbsp; return nExitType ;
}
</code></pre>
<p>
The <b>_WEP</b> function is optional; use this function for cleanup tasks that you want done when the DLL is unloaded. If you do not provide a <b>_WEP</b> function, the default <b>WEP</b> function calls the default <b>_WEP</b> function, which simply returns a one (1). To verify for yourself, check the source in the STUBWEP.ASM file included with the Microsoft C/C++ compiler in the SOURCE\STARTUP\WIN directory.</p>
<p>
Avoid the following in a <b>_WEP</b> function:
<ul type=disc>
<li>
Do not use deep stacks (that is, do not use recursion or call a bunch of functions).<br><br></li>
<li>
Do not use operating system requests.<br><br></li>
<li>
Do not use file I/O.<br><br></li>
<li>
Do not call functions that are not in a FIXED segment.</li>
</ul>
<p>
Building DLLs becomes much easier with the default <b>WEP</b> and <b>LibMain</b> functions. It is almost possible to cut functions from an application and simply recompile them to get a DLL. Using the large model for both the DLL and the application simplifies this process.</p>
<h2>Notes on the Sample Application</h2>
<p>
The sample application, Back, demonstrates some of the concepts presented in this article. Back lists command-line options and environment variables. It can be built for MS-DOS or for Windows. The MKWIN.BAT batch file builds the Windows version, while the MKDOS.BAT batch file builds the MS-DOS version.The code for the sample application is simple and straightforward.</p>
<p>
To display the output, the MS-DOS version of Back uses <b>printf</b> and the Windows version uses <b>trace</b>, which is a function exported from a DLL called TRACE.DLL. <b>trace</b> performs <b>printf</b>-like printing to the debug monitor. It demonstrates how to export a <b>CDECL</b> variable argument function from a DLL and shows how simple a DLL can be.</p>
<p>
To view the BACK.C and TRACE.C files, click the sample application button at the beginning of this article.</p>
<h2>Conclusions</h2>
<p>
Microsoft C/C++ version 7.0 introduces new programming practices that facilitate the development of applications for Windows version 3.1 in protected mode. Programmers can now:
<ul type=disc>
<li>
Use the large memory model.<p class=tl>
Large-model programs are compatible with the protected modes of Windows version 3.1 and can have multiple instances.</P></li>
<li>
Use <b>_fmalloc.</b><p class=tl>
With C/C++, <b>_fmalloc</b>, which is the large or model-independent version of <b>malloc</b>, performs subsegment allocation and conserves selector usage.</P></li>
<li>
Use the run-time version of <b>LibMain</b>.<p class=tl>
DLLs no longer have to link to LIBMAIN.OBJ because the C/C++ run-time libraries include a default <b>LibMain</b>.</P></li>
<li>
Use the run-time version of <b>WEP</b>.<p class=tl>
You no longer need a dummy <b>WEP</b> function because the C/C++ run-time libraries include a default <b>WEP</b> function. To add your own exit processing, use a <b>_WEP</b> function.</P></li>
</ul>
<h2>Bibliography</h2>
<h3>Technical Articles</h3>
<p>
All of the articles below are available on the Microsoft Developer Network CD (Technical Articles, C/C++ Articles):
<ul type=disc>
<li>
"Microsoft Windows and the C Compiler Options"<br><br></li>
<li>
"Allocating Memory the Old-Fashioned Way: _fmalloc and Applications for Windows"<br><br></li>
<li>
"Allocating Memory the Newfangled Way: The <i>new</i> Operator"<br><br></li>
<li>
"Programming at Large"</li>
</ul>
<h3>Product Documentation</h3>
<p>
On the Microsoft Developer Network CD, you can find the following books under <i>C/C++ 7.0</i> in the Product Documentation section of the Source index:
<ul type=disc>
<li>
<i>Programming Techniques</i><br><br></li>
<li>
<i>Environment and Tools</i></li>
</ul>
<p>
See the following book under <i>Windows 3.1 SDK</i> in the Product Documentation section of the Source index:
<ul type=disc>
<li>
<i>Programmer's Reference, Volume 1: Overview</i></li>
</ul>
<h3>Other</h3>
<ul type=disc>
<li>
DETAILS.TXT included with Microsoft C/C++ version 7.0</li>
</ul>
</BODY>
</HTML>
