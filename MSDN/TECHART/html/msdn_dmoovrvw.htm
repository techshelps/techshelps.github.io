<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQL-DMO: What It Is and How to Use It</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_dmoovrvw"></a></sup>SQL-DMO: What It Is and How to Use It</h1>
<p>
Ken Bergmann<br>
Microsoft Developer Network Technology Group</p>
<p>
November 12, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4581">
</OBJECT><a href="javascript:sample1.Click()">Click to view or copy the files for the SQLDMO sample application.</a></p>
<h2>Abstract</h2>
<p>
This technical article illuminates the functionality present in the SQL-DMO server architecture. It explains how an OLE Automation controller can use the functionality provided by SQL-DMO to automate and customize Microsoft® SQL Server objects or processes. This article assumes knowledge of how to use an in-process OLE server from Visual Basic®. It also assumes basic knowledge of the Microsoft SQL Server Relational Database System.</p>
<h2>What Is SQL-DMO?</h2>
<p>
SQL-DMO is the abbreviation for the Microsoft® SQL Server Distributed Management Object. SQL-DMO is a Component Object Model (COM) object representation of the standard SQL Server internal objects. That means that the SQL-DMO is an in-process OLE server. This OLE server exposes representations of Microsoft SQL Server database objects (tables, stored procedures, server properties, and so on), many of which are usually modified through Transact-SQL (T-SQL). Using these new OLE server objects, you can now manipulate any SQL Server database object from any OLE Automation controller. Specifically, this document uses the Basic language in examples and illustrations.</p>
<p>
SQL-DMO is physically a set of dynamic-link libraries (DLLs) with a type library. The normal setup registers the information in the type library for use by OLE Automation clients. If you do have problems during the installation, the type library information can be registered using an included registry (.REG) file. Once you have the libraries properly installed in your environment, SQL-DMO can be used just like any other OLE server. This article provides information about the object model that makes up SQL-DMO and how to use the objects and functionality exposed in the OLE server.</p>
<p>
The SQL-DMO OLE server model is very robust and includes an intelligent use of collection objects. Because a good interface model <i>can</i> be more important than the functionality it exposes, the clean design of this model is one of the best reasons to consider using SQL-DMO for administrative tasks. Figure 1 shows the top level of the model.</p>
<p>
<img src="dmoovrvw_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The Application object and other system-level objects in the SQL-DMO model</b></p>
<p>
The top-level objects are objects that are available in other parts of the model. For example, several objects have a <b>Names</b> collection, and almost every object has a collection of <b>Property</b> objects exposed. So, for simplicity, I will say that the objects in Figure 1, from the <b>Backup</b> object on down, are exposed objects that are defined but not required to be explicitly instantiated. The difference is that by instantiating a SQL Server object, you have access to a collection of <b>Database</b> objects. On the other hand, only at certain times can you use a <b>Registry</b>, <b>Language</b>, or <b>Permission</b> object. This is usually because these objects are normally returned from or passed to other methods of other objects.</p>
<p>
The SQL Server object is the most heavily used of the SQL-DMO objects. The SQL Server's list of exposed objects is also one of the largest in the whole model. Essentially, everything that can be configured or populated in a SQL Server above the database level is exposed here. As you become familiar with the model, notice the heavy use of object collections (Figure 2). This type of clean exposure is a large part of what is so beautiful about this model.</p>
<p>
<img src="dmoovrvw_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The Microsoft SQL Server-level objects in the SQL-DMO model</b></p>
<p>
Now that you have all of the different objects outlined, let's see what you can accomplish using a few of these objects from Visual Basic®.</p>
<h2>The "BASICs" of Using SQL-DMO</h2>
<p>
There can be many uses for SQL-DMO that will make it easier to manage a client-server system. In some situations, the everyday processing of a system may be easier to create by building around these objects, instead of providing custom processing. An example would be using the <b>Task</b> objects to execute batch processors instead of using the /AT command line or similar schedulers. By using these objects instead of SQL or command-line interfaces, you can use the functionality of the built-in Event Log to track successes and failures, or you can use the pager and e-mail notification processes that are also built into Microsoft SQL Server. Neither of these services (pager and e-mail) requires you as the developer to provide much, if anything.</p>
<p>
But now, let's see some code. This piece of code shows how to manipulate the <b>Properties</b> collection of the primary SQL Server object. Feel free to lick your lips over the plethora of information you can get with just a few lines.</p>
<pre><code>Dim oSQLServer As New SQLOLE.SQLServer

oSQLServer.DisConnect&nbsp; 'Not required, just good form.
Err.Number = 0
oSQLServer.Connect CStr(txtServer), CStr(txtLogin), CStr(txtPassword)
With txtOut
 &nbsp; If Err.Number = 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = ""
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = "ServerName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; oSQLServer.Name &amp; NL
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = .Text &amp; "HostName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; oSQLServer.HostName &amp; NL
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = .Text &amp; "Language&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; oSQLServer.Language &amp; NL
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = .Text &amp; "Login&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; oSQLServer.Login &amp; NL
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = .Text &amp; "Password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; oSQLServer.Password &amp; NL
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = .Text &amp; "LoginSecure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; oSQLServer.LoginSecure &amp; NL
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = .Text &amp; "SaLogin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; oSQLServer.SaLogin &amp; NL
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = .Text &amp; "TrueLogin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; oSQLServer.TrueLogin &amp; NL
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = .Text &amp; "TrueName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; oSQLServer.TrueName &amp; NL
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = .Text &amp; "QueryTimeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; oSQLServer.QueryTimeout &amp; NL
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = .Text &amp; "CommandTerminator : " &amp; oSQLServer.CommandTerminator &amp; NL
 &nbsp;&nbsp;&nbsp;&nbsp; .Text = .Text &amp; "AutoReConnect&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; oSQLServer.AutoReConnect
 &nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp; lblStatus = Err.Source &amp; " Error " &amp; Err.Number - vbObjectError &amp; ":"
 &nbsp;&nbsp;&nbsp;&nbsp; lblStatus = lblStatus &amp; "&nbsp;&nbsp;&nbsp; " &amp; Err.Description
 &nbsp; End If
End With
</code></pre>
<p>
That's it! I kept it simple and just spit the data out into a text box, but you get the idea. Let's upgrade things a bit and get out of first gear. The following snippet assumes you still have the server variable in scope. It uses a <b>ListView</b> control to show the databases that are in the current server. If you aren't familiar with the <b>ListView</b> control, the important lines are in bold. They show you how to walk through the collection of databases for a SQL Server object.</p>
<pre><code>Dim oTask&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Task&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Notice the specific object names.
Dim oDB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Database&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Early binding, what a concept.
Dim liTemp&nbsp;&nbsp;&nbsp;&nbsp; As ListItem
Dim chTemp&nbsp;&nbsp;&nbsp;&nbsp; As ColumnHeader
Dim iIndex&nbsp;&nbsp;&nbsp;&nbsp; As Integer

Err.Number = 0
With lvDatabase
 &nbsp; If Err.Number = 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp; .ListItems.Clear
 &nbsp;&nbsp;&nbsp;&nbsp; Set chTemp = .ColumnHeaders.Add(, "Name", "Name", 800)
 &nbsp;&nbsp;&nbsp;&nbsp; Set chTemp = .ColumnHeaders.Add(, "Size", "Size", 350)
 &nbsp;&nbsp;&nbsp;&nbsp; Set chTemp = .ColumnHeaders.Add(, "SpaceAvailable", "SpaceAvailable",1010)
 &nbsp;&nbsp;&nbsp;&nbsp; Set chTemp = .ColumnHeaders.Add(, "DataSpaceUsage", "DataSize", 600)
 &nbsp;&nbsp;&nbsp;&nbsp; Set chTemp = .ColumnHeaders.Add(, "IndexSpaceUsage", "IndexSize", 600)
 &nbsp;&nbsp;&nbsp;&nbsp; Set chTemp = .ColumnHeaders.Add(, "SystemObject", "System", 420)
 &nbsp;&nbsp;&nbsp;&nbsp; Set chTemp = .ColumnHeaders.Add(, "CreateDate", "CreateDate", 1550)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 

<b> &nbsp;&nbsp;&nbsp;&nbsp; For Each oDB In oSQLServer.Databases</b>

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set liTemp = .ListItems.Add()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With liTemp
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Icon = 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .SmallIcon = 1

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>.Text =<b> oDB.Name</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>.SubItems(1) =<b> oDB.Size</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>.SubItems(2) =<b> Format$(oDB.SpaceAvailableInMB, "0.00") &amp; " mb"</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>.SubItems(3) =<b> Format$(oDB.DataSpaceUsage, "0.00") &amp; " mb"</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>.SubItems(4) =<b> Format$(oDB.IndexSpaceUsage, "0.00") &amp; " mb"</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>.SubItems(5) =<b> oDB.SystemObject</b>

<b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>.SubItems(6) = <b>oDB.CreateDate</b>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End With
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next
 &nbsp;&nbsp; End If
End With
</code></pre>
<p>
Okay, so we have gone over the basics. Now let's use one of those generic, top-level objects that we talked about at the beginning. For grins, I will stay with the <b>Permission</b> object. This piece of code will walk through the <b>Permissions</b> collection for a particular database:</p>
<pre><code>Dim pl As SQLObjectList&nbsp; 'In VB this provides early binding. I included 
Dim p&nbsp; As Permission&nbsp;&nbsp;&nbsp;&nbsp; 'it so you could see the types.

Set db = ss.Databases("pubs")
Set pl = db.ListObjectPermissions() 'This is a function that returns a list.
For Each p In pl
 &nbsp;&nbsp; 'This walks through the list you obtained.
 &nbsp;&nbsp; 'For each object in the list, interrogate properties for that object.
 &nbsp;&nbsp; 'In this case, the objects in the list were Permission objects.
 &nbsp;&nbsp; Debug.Print "Object Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : " &amp; p.ObjectName
 &nbsp;&nbsp; Debug.Print "Object Type Name&nbsp;&nbsp; : " &amp; p.ObjectTypeName
 &nbsp;&nbsp; Debug.Print "Privilege Type Name: " &amp; p.PrivilegeTypeName
 &nbsp;&nbsp; Debug.Print "Privilege Granted&nbsp; : " &amp; p.Granted
Next
</code></pre>
<p>
This code also shows an important concept in the use of SQL-DMO. The designers of this object model have exposed a cool construct called a <i>list</i>. A list is essentially a read-only collection. You can obtain lists from many places in the model. But in this case you get the whole collection returned as a static snapshot, not just a reference to a bunch of faraway objects. (Can you say <i>speed</i>, ladies and gents?) The difference is subtle, but can be important. Essentially, whenever you call a <b>List<i>x</i></b> method, you get a unique type of collection back. But be warned: When you use a list or enumeration that returns a list of <b>DBObject</b> objects, it may contain more than one type of object.</p>
<p>
Moving on, I want to point out how some of the more-often-used methods can be called. This little routine will run through all the tables in a database and do some maintenance on each one. This is a simple example, but it shows how to do some common tasks:</p>
<pre><code>Dim oTable&nbsp;&nbsp;&nbsp; As Table&nbsp;&nbsp; 'In VB this provides early binding. 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'I included it so you could see the types.

Set db = ss.Databases("pubs")
For Each oTable In db.Tables
 &nbsp;&nbsp; 'This walks through the Tables collection.
 &nbsp;&nbsp; oTable.CheckTable
 &nbsp;&nbsp; oTable.ReCompileReferences
 &nbsp;&nbsp; oTable.RecalcSpaceUsage
 &nbsp;&nbsp; oTable.UpdateStatistics
Next
</code></pre>
<p>
To show some more advanced code, this example generates scripts for every table in a database. I have set some flags on the types of script that are generated. Notice that these flags can be added together, much like the flags for other application programming interfaces (APIs) you may be familiar with. In this case, I have requested the script to contain the DROP statements that will ensure the table is dropped before attempting to recreate it. I have also requested the default options on a script, as well as to have headers, indexes, and any bindings included in the generated script. There are several other types of options that can be set for this, which means that your script generation can be highly customized.</p>
<pre><code>Dim lScriptType&nbsp;&nbsp; As Long
Dim sFileName&nbsp;&nbsp;&nbsp;&nbsp; As String
Dim sNewTableName As String
Dim oTable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Table

Set db = ss.Databases("pubs")
For Each oTable In db.Tables
 &nbsp;&nbsp; 'This walks through the Tables collection.
 &nbsp;&nbsp; lScriptType = SQLOLEScript_Drops + SQLOLEScript_Default + _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQLOLEScript_IncludeHeaders + SQLOLEScript_Indexes + _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQLOLEScript_Bindings
 &nbsp;&nbsp; sFileName = Trim$(oTable.Name) &amp; ".sql"
 &nbsp;&nbsp; sNewTableName = "New" &amp; Trim$(oTable.Name)
 &nbsp;&nbsp; 'This line generates the file
 &nbsp;&nbsp; oTable.Script ScriptType:=lScriptType, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScriptFilePath:=sFileName, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewName:=sNewTableName
Next oTable
</code></pre>
<p>
Following is an example of how to add a column to an existing table. This illustrates how modifications are done, as well as how new objects are created.</p>
<pre><code>Dim oTable&nbsp; As Table
Dim oCol&nbsp;&nbsp;&nbsp; As Column

Set db = ss.Databases("pubs")
For Each oTable In db.Tables
 &nbsp;&nbsp; 'This walks through the Tables collection.
 &nbsp;&nbsp; Set oCol = New Column
 &nbsp;&nbsp; oCol.AllowNulls = True
 &nbsp;&nbsp; oCol.Datatype = "varchar"
 &nbsp;&nbsp; oCol.Length = 30
 &nbsp;&nbsp; oCol.Name = "NewCol"
 &nbsp;&nbsp; oTable.BeginAlter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'This starts the change process.
 &nbsp;&nbsp; oTable.InsertColumn oCol, ""&nbsp; 'Say what you want done.
 &nbsp;&nbsp; oTable.DoAlter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Commit the changes when you are done.
Next oTable
</code></pre>
<p>
Essentially, if you want to modify, let's say, a table, you call the <b>BeginAlter</b> method of the object, then perform your changes. When you are finished setting properties or options, you call <b>DoAlter</b>. Following this method commits to the server any changes made since executing <b>BeginAlter</b>. In this case, I was simply adding a column to a table. However, I could have been changing the options for an <b>Alert</b> or a <b>Task</b>. For most objects, modifying the properties directly performs the updates, but for the following objects the <b>BeginAlter</b> and <b>DoAlter</b> mechanisms must be used:
<ul type=disc>
<li>
<b>Alert</b><br><br></li>
<li>
<b>AlertSystem</b><br><br></li>
<li>
<b>Article</b><br><br></li>
<li>
<b>Executive</b><br><br></li>
<li>
<b>Operator</b><br><br></li>
<li>
<b>Publication</b><br><br></li>
<li>
<b>RemoteServer</b><br><br></li>
<li>
<b>SubscriberInfo</b><br><br></li>
<li>
<b>Subscription</b><br><br></li>
<li>
<b>Table</b><br><br></li>
<li>
<b>Task</b></li>
</ul>
<p>
Because you may not know how to clean up after you have used these objects, I included the following two lines. It's pretty simple, but I am providing them just in case they were hard to find in the sample.</p>
<pre><code>oSQLServer.DisConnect
oSQLServer.Close
</code></pre>
<p>
That pretty much covers the essentials of how to use the SQL-DMO objects. Everything else is really just some variation on the techniques described and illustrated above. You can find a few different variations in the SQLDMO sample that accompanies this article.</p>
</BODY>
</HTML>
