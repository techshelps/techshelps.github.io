<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Designing Client/Server Applications for Enterprise Database Connectivity</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_csappent"></a></sup>Designing Client/Server Applications for Enterprise Database Connectivity</h1>
<p>
Christopher Moffatt</p>
<p>
Created: June 1992<br>
Revised: February 1994<br>
(Volume 4, Number 7)</p>
<h2>Abstract</h2>
<p>
Client/server computing is moving into the mainstream of corporate information systems. With this move comes the need for client/server applications that can access enterprise-wide data. Much of this data is currently stored in mainframe- and mini-computer databases, and one of the challenges facing implementers of client/server technology today is how to bring this mission-critical data to the desktop and integrate it with the functional, easy-to-use graphical user interfaces (GUIs) that are associated with PC-based tools.</p>
<p>
The purpose of this technical article is to outline the database connectivity solutions Microsoft has developed to allow client/server applications to access enterprise-wide data. This technical article identifies some of the basic problems involved in accessing heterogeneous databases and outlines general approaches to achieving heterogeneous database access. The database connectivity solutions developed by Microsoft are discussed in depth, with an emphasis on how these products relate to each other. Finally, this article provides some general guidelines for designing applications for enterprise database connectivity using Microsoft® SQL Server and Microsoft database connectivity products.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Unless otherwise noted, information in this technical note applies to Microsoft SQL Server on both the Windows NT™ and OS/2® platforms.</p>
<h2>Heterogeneous Database Access Issues</h2>
<p>
Think of accessing heterogeneous databases as a subset of using distributed databases. The technical challenges of delivering fully distributed database management systems (DBMSs) in commercial products are difficult and have not yet been completely solved. These problems include distributed query processing, distributed transaction management, replication, location independence, as well as heterogeneous database access issues. The ability to access <i>heterogeneous databases</i> (that is, data that reside on different hardware platforms, different operating systems, different network operating systems, and different databases) is a fundamental need today, and it can be addressed without having to wait for fully distributed databases to arrive.</p>
<p>
When thinking about the problems involved in accessing heterogeneous databases, it is useful to consider the problems at different levels. Figure 1 identifies some of the levels and interfaces encountered when accessing data in a client/server environment.</p>
<p>
<img src="csapp1.gif" border=0></p>
<p class=label>
<b>Figure 1. Levels and interfaces in a client/server environment</b></p>
<p>
Some of the areas that need to be addressed when attempting to access heterogeneous databases are application programming interfaces (APIs), data stream protocols, interprocess communication (IPC) mechanisms, network protocols, system catalogs, and structured query language (SQL) syntax.</p>
<h3>Application Programming Interfaces</h3>
<p>
Each back-end database typically has its own application programming interface (API), through which it communicates with clients. A client application that must access multiple back-end databases therefore requires the ability to transform requests and data transfers into the API interface supported by each back-end database it needs to access.</p>
<h3>Data Stream Protocols</h3>
<p>
Each DBMS uses a data stream protocol that enables the transfer of requests, data, status, error messages, and so on between the DBMS and its clients. Think of this as a "logical" protocol. The API uses interprocess communication (IPC) mechanisms supported by the operating system and network to package and transport this logical protocol. The Microsoft® SQL Server data stream protocol is called Tabular Data Stream (TDS). Each database's data stream protocol is typically a proprietary one that has been developed and optimized to work exclusively with that DBMS. This means that an application accessing multiple databases must use multiple data stream protocols.</p>
<h3>Interprocess Communication Mechanisms</h3>
<p>
Depending on the operating system and network it is running on, different interprocess communication (IPC) mechanisms might be used to transfer requests and data between a DBMS and its clients. For example, Microsoft SQL Server on OS/2® uses named pipes as its IPC mechanism, SYBASE® SQL Server on UNIX® uses transmission control protocol/internet protocol (TCP/IP) sockets, and SYBASE on VMS® uses DECnet® sockets. Microsoft SQL Server for Windows NT can use multiple IPC mechanisms simultaneously, including named pipes, TCP/IP sockets, SPX, and Banyan® Vines®. The choice of IPC mechanism is constrained by the operating system and network being used, and it is therefore likely that multiple IPC mechanisms will be involved in a heterogeneous environment.</p>
<h3>Network Protocols</h3>
<p>
A network protocol is used to transport the data stream protocol over a network. It can be considered the "plumbing" that supports the IPC mechanisms used to implement the data stream protocol, as well as supporting basic network operations such as file transfers and print sharing. Popular network protocols include NetBEUI, TCP/IP, DECnet, and SPX/IPX.</p>
<p>
Back-end databases can reside on a local-area network (LAN) that connects it with the client application, or they can reside at a remote site, connected via a wide-area network (WAN) and/or gateway. In both cases, it is possible that the network protocol(s) and/or physical network supported by the various back-end databases are different from that supported by the client or each other. In these cases, a client application must use different network protocols to communicate with various back-end databases.</p>
<h3>System Catalogs</h3>
<p>
A relational database management system (RDBMS) uses system catalogs to hold <i>metadata </i>(information about the data being stored). Typically, system catalogs hold information about objects, permissions, data types, and so on. Each RDBMS product has an incompatible set of system catalogs with inconsistent table names and definitions. Many client tools and applications use system catalog information for displaying or processing data. For example, system catalog information can be used to offer a list of available tables, or to build forms based on the data types of the columns in a table. An application that makes specific reference to the SQL Server system catalog tables will not work with another RDBMS such as DB2® or Oracle®.</p>
<h3>SQL Syntax and Semantics</h3>
<p>
Structured query language (SQL) is the standard way to communicate with relational databases. In a heterogeneous environment, two main problems arise with respect to SQL syntax and semantics. First, different database management systems can have different implementations of the same SQL functionality, both syntactically and semantically (for example, data retrieved by a SQL statement might be sorted using ASCII in one DBMS and EBCDIC in another; or the implementation of the UNION operator in different database management systems might yield different result sets). Second, each implementation of SQL has its own extensions and/or deficiencies with respect to the ANSI/ISO SQL standards. This includes support for different data types, referential integrity, stored procedures, and so on. An application that needs to access multiple back-end databases must implement a lowest common denominator of SQL, or it must determine what back-end it is connected to so that it can exploit the full functionality supported.</p>
<h2>Heterogeneous Database Access Approaches</h2>
<p>
When thinking about heterogeneous database access issues, it is helpful to classify possible solutions into three classes: the common interface approach, the common gateway approach, and the common protocol approach, as defined by Richard Hackathorn in his article "Emerging Architecture for Database Connectivity" in <i>InfoDB</i>, January 1991.</p>
<h3>Common Interface Architecture</h3>
<p>
A common interface architecture, shown in Figure 2, focuses on providing a common API at the client side that enables access to multiple back-end databases. Client applications rely on the API to manage the heterogeneous data access issues discussed earlier. Typically, a common API would load back-end–specific drivers to obtain access to different databases.</p>
<p>
An example of a common interface architecture is Microsoft Open Database Connectivity (ODBC), discussed later in this article.</p>
<p>
<img src="csapp2.gif" border=0></p>
<p class=label>
<b>Figure 2. Common interface architecture</b></p>
<h3>Common Gateway Architecture</h3>
<p>
A common gateway architecture, shown in Figure 3, relies on a gateway to manage the communication with multiple back-end databases.</p>
<p>
An example of a common gateway architecture is found in a gateway based on Microsoft Open Data Services, discussed later in this article.</p>
<p>
<img src="csapp3.gif" border=0></p>
<p class=label>
<b>Figure 3. Common gateway architecture</b></p>
<p>
In his book <i>Introduction to Database Systems</i>, C.J. Date states: ". . . there are clearly significant problems involved in providing satisfactory gateways, especially if the target system is not relational. However, the potential payoff is dramatic, even if the solutions are less than perfect. We can therefore expect to see gateway technology become a major force in the marketplace over the next few years." (page 635)</p>
<h3>Common Protocol Architecture</h3>
<p>
The common protocol approach, shown in Figure 4, focuses on a common data protocol between the client and server interfaces. Conceptually, this is perhaps the most elegant way of addressing the problem of heterogeneous data access.</p>
<p>
<img src="csapp4.gif" border=0></p>
<p class=label>
<b>Figure 4. Common protocol architecture</b></p>
<p>
Two common data protocol architectures are the proposed ANSI/ISO Relational Data Access (RDA) standard, and the IBM® Distributed Relational Database Architecture (DRDA™). Both of these architectures are in their infancy, and it is too early to determine how well they will function as commercial products.</p>
<p>
It is important to note that these approaches to enabling heterogeneous database access are not exclusive. For example, an ODBC driver might connect through an Open Data Services gateway to a back-end database. Alternatively, an ODBC driver or Open Data Services gateway that "speaks" DRDA or RDA is possible.</p>
<h2>Achieving Heterogeneous Database Access</h2>
<p>
We have looked at the basic issues involved in accessing heterogeneous databases, and generalized ways of approaching solutions. We will now look at specific connectivity products from Microsoft that enable heterogeneous data access. The SQL Server building blocks to data access—Tabular Data Stream (TDS) and the Net-Library® architecture—are an integral part of products enabling connectivity to heterogeneous databases. We then discuss Microsoft ODBC, Microsoft Open Data Services, and Microsoft SQL Bridge, and we address some of the ways in which Open Data Services and ODBC work together. Finally, we make recommendations to help you decide which API, DB-Library® or ODBC, to use when developing client applications.</p>
<h3>SQL Server Building Blocks (TDS and Net-Library)</h3>
<p>
Tabular Data Stream (TDS) and Net-Library are part of the core SQL Server technology that Microsoft connectivity products build on to integrate SQL Server–based applications into heterogeneous environments. Figure 5 shows how TDS and Net-Library fit into the client/server architecture of SQL Server–based applications.</p>
<p>
<img src="csapp5.gif" border=0></p>
<p class=label>
<b>Figure 5. SQL Server building blocks</b></p>
<p>
TDS is the data stream protocol that SQL Server uses to transfer requests and responses between client and server. Because TDS can be considered as a logical data stream protocol, it needs to be supported by a physical network IPC mechanism; this is where the Net-Library architecture comes in. A DB-Library application makes calls to the generic Net-Library interface. Depending on which Net-Library is loaded, communication with SQL Server is achieved using named pipes, TCP/IP sockets, DECnet sockets, SPX, and so on.</p>
<p>
The Net-Library architecture provides a transparent interface to DB-Library and a method of sending TDS across a physical network connection. Net-Libraries are linked in dynamically at run time. With the Microsoft Windows™, Windows NT, and OS/2 operating systems, Net-Libraries are implemented as dynamic-link libraries (DLLs), and multiple Net-Libraries can be loaded simultaneously. With the MS-DOS® operating system, Net-Libraries are implemented as terminate-and-stay-resident (TSR) programs and only one can be loaded at any given time.</p>
<p class=indent>
&nbsp;&nbsp;<b><B>Note</B>&nbsp;&nbsp;&nbsp;</b> The SQL Server Driver for ODBC also uses Net-Libraries and the TDS protocol to communicate with SQL Server and Open Data Services.</p>
<h3>Microsoft Open Database Connectivity</h3>
<p>
Open Database Connectivity (ODBC) is a database connectivity API based on the SQL Access Group's Call Level Interface (CLI) specification. The SQL Access Group is a consortium of leading hardware and software database vendors. ODBC is an open, vendor-neutral API that enables applications to access heterogeneous databases. ODBC takes the "common API" approach, discussed earlier, to achieving heterogeneous data access.</p>
<p>
The ODBC architecture consists of three components:
<ul type=disc>
<li>
<b>Application.</b> Performs processing and calls ODBC functions to submit SQL statements and retrieve results.<br><br></li>
<li>
<b>Driver Manager.</b> Loads drivers on behalf of an application.<br><br></li>
<li>
<b>Driver.</b> A DLL that processes ODBC function calls, submits SQL requests to a specific database, and returns results to the application. If necessary, the driver modifies an application's request so that the request conforms to syntax supported by the associated DBMS.</li>
</ul>
<p>
The Driver Manager and driver appear to an application as one unit that processes ODBC function calls.</p>
<p>
Figure 6 shows the components of the ODBC architecture.</p>
<p>
<img src="csapp6.gif" border=0></p>
<p class=label>
<b>Figure 6. The ODBC model</b></p>
<p>
Each ODBC driver supports a set of core ODBC functions and data types and, optionally, one or more extended functions or data types, defined as extensions:
<ul type=disc>
<li>
Core functions and data types are based on the X/Open and SQL Access Group CLI specification. If a driver supports all core functions, it is said to conform to X/Open and SQL Access Group core functionality.<br><br></li>
<li>
Extended functions and data types support additional features, including date, time, and timestamp literals, scrollable cursors, and asynchronous execution of function calls. Extended functions might not be supported by a specific driver. Extended functions are divided into two conformance designations, Level 1 and Level 2, each of which is a superset of the core functions.</li>
</ul>
<p>
ODBC can be used in different configurations, depending on the database being accessed. It can be used in one-, two-, or three-tiered implementations.</p>
<h4>One-tiered drivers</h4>
<p>
Figure 7 shows a one-tiered implementation. The database being accessed is a file and is processed directly by the ODBC driver. The driver itself contains the functionality to parse a SQL request, because a flat file is not able to do this. An example of a one-tiered implementation is a driver that manipulates an xBase file.</p>
<p>
<img src="csapp7.gif" border=0></p>
<p class=label>
<b>Figure 7. One-tiered drivers</b></p>
<h4>Two-tiered drivers</h4>
<p>
Figure 8 shows a two-tiered configuration. The driver sends SQL statements to a server that processes the SQL requests. The application, driver, and Driver Manager reside on one system, and the software that controls access to the database typically resides on another system. An example of a two-tiered configuration would be accessing a SQL Server from a client on the LAN.</p>
<p>
<img src="csapp8.gif" border=0></p>
<p class=label>
<b>Figure 8. Two-tiered drivers</b></p>
<h4>Three-tiered drivers</h4>
<p>
Figure 9 shows a three-tiered configuration. The ODBC driver passes requests to a gateway instead of a DBMS, and then the gateway process sends the requests to the database. An example of a gateway process involved in a three-tiered configuration is an Open Data Services–based gateway that supports access to DEC® RDB or IBM DB2 databases.</p>
<p>
<img src="csapp9.gif" border=0></p>
<p class=label>
<b>Figure 9. Three-tiered drivers</b></p>
<h4>SQL Server and Open Data Services drivers for ODBC</h4>
<p>
ODBC drivers for Microsoft SQL Server and Open Data Services are included in the SQL Server product. These drivers use the Net-Library architecture and the TDS protocol to access Microsoft and SYBASE SQL Servers, Microsoft SQL Bridge, and Open Data Services–based gateways and applications. The ODBC driver conforms to Level 1 APIs and implements many of the Level 2 APIs as well.</p>
<p>
For more information about ODBC, see the Microsoft ODBC Software Development Kit (SDK) <i>Programmer's Reference</i>.</p>
<h3>Microsoft Open Data Services</h3>
<p>
Microsoft Open Data Services is a server-side development platform that provides application services to complement the client-side APIs discussed earlier. Open Data Services provides the foundation for multithreaded server applications to communicate with DB-Library or ODBC clients over the network. When the client application requests data, Open Data Services passes the request to user-defined routines, and then routes the reply back to the client application over the network. The reply looks to the client as if the data were coming from SQL Server. Figure 10 illustrates how Open Data Services integrates into an enterprise.</p>
<p>
<img src="csapp10.gif" border=0></p>
<p class=label>
<b>Figure 10. Open Data Services and an enterprise</b></p>
<p>
Open Data Services is a server-based library that can receive, break apart, reform, and send TDS packets from many simultaneous clients. It uses the native multithreading facilities of the underlying operating system to handle simultaneous requests in a fast, memory-efficient way. The Open Data Services developer need only focus on the actions required to respond to individual requests; Open Data Services and the operating system handle and schedule multiple simultaneous requests.</p>
<p>
Open Data Services is also used to develop extended stored procedure DLLs for use with Microsoft SQL Server for Windows NT.</p>
<h4>General-purpose gateways</h4>
<p>
The classic application for Open Data Services is a server-based gateway to another relational database—one that can handle any ad hoc SQL request from a DB-Library or ODBC client. Database Gateway from Micro Decisionware®, for example, implements a general-purpose gateway into DB2. It receives SQL requests from SQL Server clients on the LAN and forwards them to the mainframe for processing against a DB2 database. Because the results it then returns to the client look exactly like a results set from SQL Server, the client applications can handle the data in the same way. A component that understands the SQL language and can act on SQL requests is essential to the operation of a general-purpose gateway. This SQL interpreter usually resides in the back-end database itself (as is the case with DB2), but it can also be implemented in the gateway.</p>
<h4>Custom gateways</h4>
<p>
Not all data server applications need to understand and respond to SQL requests (for example, a data server application that returns the contents of a specific flat file as a results set). This type of application could be designed to respond to only one particular procedure call (such as <b>GetFileA</b>). The Open Data Services application would define the column names and the data types of the fields in the flat file, and then return the records in the file to the requesting client as rows of data. Because this results set would look exactly like a SQL Server results set, the client could process it.</p>
<p>
Nearly any set of data values that needs to be shared on a network can be described in terms of rows and columns, so this capability is relevant to many LAN applications. In particular, specific data needed by LAN users is often maintained by an established application that does not use a relational database. Rather than attempting to move this entire application to a relational database, you can use an application-specific gateway to extract from the existing system the precise information required. This approach works when the information required from the existing system is well defined, not ad hoc in nature. For ad hoc queries, the better approach is to extract the data from the existing system and load it into a relational database.</p>
<h4>Catalog stored procedures</h4>
<p>
Microsoft has developed the catalog stored procedure specification to address the problem of catalog incompatibilities between different DBMS products. Open Data Services gateways that support the catalog stored procedures will allow DB-Library–based applications to access these gateways and obtain catalog information about different back-end databases.</p>
<p class=indent>
<b><B>Note</B>&nbsp;&nbsp;&nbsp;</b>The problem of incompatible system catalog access is addressed in ODBC through the provision of API calls. The Microsoft catalog stored procedures map to these ODBC API calls, supporting the access of Open Data Services gateways by ODBC clients.</p>
<p>
The implementation of the catalog stored procedures will vary, based on the underlying DBMS being accessed by the Open Data Services–based gateway. For example, in the case of SQL Server, an actual stored procedure definition has been written for each catalog stored procedure; the DB2 Gateway from Micro Decisionware implements these stored procedures as CICS transactions in the host environment; and a gateway that accesses Oracle could implement the catalog stored procedures as PL/SQL code, executed by the gateway itself.</p>
<p>
The main advantages to be gained by a DB-Library client application using the stored procedure interface instead of accessing the system catalogs directly are:
<ul type=disc>
<li>
The catalog access interface is the same for all databases.<br><br></li>
<li>
Catalog access through stored procedures is more efficient. For example, with the DB2 Gateway, CICS transactions involving static SQL can be used instead of executing dynamic SQL statements.<br><br></li>
<li>
The stored procedure interface can be implemented against non-relational databases.</li>
</ul>
<p>
There are limitations to the catalog stored procedures. In particular, they do not synthesize all information present in the system catalogs for every possible gateway target, nor are they intended to replace the system catalogs in SQL Server or any other DBMS product. A client application, such as a database administration tool, that uses all information unique to a particular server must use the underlying system catalogs. On the other hand, the catalog stored procedures represent the general information that most "generic" database front-ends need in order to interact with a particular database.</p>
<p>
The following table lists the catalog stored procedures and gives a brief description of the information returned:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Stored Procedure</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=50%><b>sp_column_privileges</b></td>
<td width=50%>Returns column privilege information for a single table in the current DBMS environment.</td>
</tr>
<tr valign=top>
<td width=50%><b>sp_columns</b></td>
<td width=50%>Returns column information for single objects that can be queried in the current DBMS environment.</td>
</tr>
<tr valign=top>
<td width=50%><b>sp_databases</b></td>
<td width=50%>Lists databases present in the SQL Server installation or accessible through a database gateway.</td>
</tr>
<tr valign=top>
<td width=50%><b>sp_datatype_info</b></td>
<td width=50%>Returns information about data types supported by the current DBMS environment.</td>
</tr>
<tr valign=top>
<td width=50%><b>sp_fkeys</b></td>
<td width=50%>Returns logical foreign key information for the current DBMS environment.</td>
</tr>
<tr valign=top>
<td width=50%><b>sp_pkeys</b></td>
<td width=50%>Returns primary key information for the current DBMS environment.</td>
</tr>
<tr valign=top>
<td width=50%><b>sp_server_info</b></td>
<td width=50%>Returns a list of attribute names and matching values for SQL Server or for the database gateway and/or underlying data source.</td>
</tr>
<tr valign=top>
<td width=50%><b>sp_special_columns</b></td>
<td width=50%>Returns the optimal set of columns that uniquely identify a row in the table and columns that are automatically updated when any value in the row is updated by a transaction.</td>
</tr>
<tr valign=top>
<td width=50%><b>sp_statistics</b></td>
<td width=50%>Returns a list of all indexes on a single table.</td>
</tr>
<tr valign=top>
<td width=50%><b>sp_stored_procedures</b></td>
<td width=50%>Returns a list of stored procedures in the current DBMS environment.</td>
</tr>
<tr valign=top>
<td width=50%><b>sp_table_privileges</b></td>
<td width=50%>Returns table privilege information for a single table in the current DBMS environment.</td>
</tr>
<tr valign=top>
<td width=50%><b>sp_tables</b></td>
<td width=50%>Returns a list of objects that can be queried in the current DBMS environment.</td>
</tr>
</table><br>
<p>
For more information, see the <i>Microsoft SQL Server 4.2 Language Reference</i>, or the <i>Microsoft SQL Server for Windows NT Transact-SQL Reference</i>, where the catalog stored procedures are described in detail.</p>
<h4>Writing Open Data Services applications</h4>
<p>
The power and versatility of Open Data Services leads to the question, <i>How difficult is it to implement an Open Data Services–based application</i>? The vast range of application possibilities with Open Data Services makes it impossible to give an estimate, because the scale of complexity varies greatly. In general, however, the potential complexity of developing Open Data Services–based applications lies in the target environment. The Open Data Services API is small and easy to use. Implementing simple user-defined functionality, such as an auditing or logging function, is a straightforward exercise. However, if you are developing a gateway to a host database, complexity is introduced through the need to understand the communication environment with the host, and the level of generality required in the gateway. A full-featured gateway to a host database would need to implement a sophisticated parser, map data types, translate syntactic differences between SQL implementations, and so on.</p>
<p>
In summary, the Open Data Services library provides a very simple foundation on which to implement multithreaded server applications. The client interface, data stream protocol, thread management, and multiuser support is provided by Open Data Services and DB-Library or the SQL Server ODBC driver. The requirements of the user-defined portion of the server application define the level of difficulty. Figure 11 illustrates how the complexity of Open Data Services applications is dependent on the scope of the application.</p>
<p>
<img src="csapp11.gif" border=0></p>
<p class=label>
<b>Figure 11. Building Open Data Services applications</b></p>
<p>
For more information about Open Data Services, see the technical note <i>Microsoft Open Data Services: Application Sourcebook.</i></p>
<h3>Microsoft SQL Bridge</h3>
<p>
Microsoft SQL Bridge is designed to provide interoperability between Microsoft and SYBASE environments by linking databases, clients, and gateways across UNIX, VMS, Macintosh®, and PC networks.</p>
<p>
Figure 12 shows how SQL Bridge works.</p>
<p>
<img src="csapp12a.gif" border=0></p>
<p>
<img src="csapp12b.gif" border=0></p>
<p class=label>
<b>Figure 12. SQL Bridge and multiple environments</b></p>
<p>
SQL Server for the OS/2 operating system can “listen” for client connections using only named pipes. In order for clients using other protocols (such as TCP/IP sockets) to connect to SQL Server, the client requests must go through SQL Bridge. SQL Bridge accepts the socket (or other IPC) requests from the clients, and passes those requests on to SQL Server using named pipes. It receives named pipes requests from SQL Server, and passes those on to the clients using sockets (or other IPC). In addition, it allows Microsoft SQL Server clients using native network protocols and IPC methods to access SYBASE SQL Servers using sockets and TCP/IP.</p>
<p>
SQL Server for Windows NT has multi-protocol support built in, enabling it to listen for client connection on many different protocols, such as named pipes, TCP/IP sockets, IPX/SPX, and Banyan VINES SPP. Therefore, SQL Bridge is not necessary for clients using those protocols to communicate with SQL Server for Windows NT. In this environment, SQL Bridge is primarily useful for Microsoft SQL Server clients to use native network protocols and IPC methods to access SYBASE SQL Servers using sockets and TCP/IP. This eliminates the need to purchase, load, and configure multiple network protocols and Net-Libraries for each client.</p>
<p>
Interoperability between Microsoft and Sybase environments is enabled in three areas:
<ul type=disc>
<li>
SQL Bridge extends Microsoft SQL Server for OS/2 to support UNIX, VMS, and Macintosh clients based on the SYBASE Open Client interface.<br><br></li>
<li>
SQL Bridge connects PC LAN clients (with Windows, Windows NT, MS-DOS, and OS/2) to SYBASE databases, with network protocol conversion handled by SQL Bridge.<br><br></li>
<li>
SQL Bridge enables remote stored procedure communication between Microsoft and SYBASE SQL Servers.</li>
</ul>
<p>
This two-way interoperability allows you to mix clients and servers for more efficient information exchange, without requiring a common network protocol across different networks and without installing multiple protocols and Net-Libraries on every client.</p>
<h3>Architecture</h3>
<p>
Microsoft SQL Bridge is a server application based on Open Data Services; it can be thought of as a "protocol router." SQL Bridge uses the Net-Library architecture to support the IPC mechanisms used by SQL Server running on the OS/2, Windows NT, UNIX, or VMS platforms. Each instance of SQL Bridge "listens" for TDS messages from clients using a particular IPC mechanism (named pipes, TCP/IP sockets, DECnet sockets), and then routes the TDS message to SQL Server using a potentially different IPC mechanism. Results are received from SQL Server, translated to the client IPC protocol, and sent to the client.</p>
<p>
The use of SQL Bridge in environments where communication is required between Microsoft and SYBASE clients and servers can greatly reduce cost and maintenance overhead, as well as free up resources on each client because it is not necessary to load multiple network protocols and Net-Libraries. SQL Bridge is a highly efficient application and does not incur the overhead usually associated with the word "gateway." Its only function is to "listen" for TDS messages coming in and to reroute them using a different IPC mechanism. Because SQL Bridge uses the Net-Library architecture to support the various IPC mechanisms, it can be configured and extended.</p>
<p>
An example of running multiple instances of SQL Bridge is shown below (Figure 13).</p>
<p>
<img src="csapp13.gif" border=0></p>
<p class=label>
<b>Figure 13. Using multiple instances of SQL Bridge</b></p>
<p>
You can configure and run multiple instances of SQL Bridge. Each instance is a separate gateway that runs as a separate process on a single Windows NT–based computer, and each is identified by a logical <i>instance</i> name. Each instance can listen on multiple Net-Libraries for client connections but can connect to only a single SQL Server. You must configure at least one instance to use SQL Bridge.</p>
<h2>Designing Applications for Heterogeneous Database Access</h2>
<p>
This section gives general guidelines to follow when developing applications for enterprise database connectivity using Microsoft SQL Server and the Microsoft database connectivity products discussed in the previous section.</p>
<h3>Choice of Database API (ODBC or DB-Library)</h3>
<p>
With the availability of the ODBC and DB-Library APIs for accessing SQL Server and Open Data Services–based applications, the question arises as to which API to use. Following are some general guidelines.</p>
<p>
ODBC is appropriate for:
<ul type=disc>
<li>
Microsoft Windows operating system universal data access.<p class=tl>
ODBC is the Microsoft strategic direction for access to relational databases from the Windows platform. New Windows-based client/server applications should use ODBC as their database access API. In the future, Microsoft will also support ODBC on the Macintosh and other platforms.</P></li>
<li>
Flexible heterogeneous data access.<p class=tl>
ODBC was designed as an API for heterogeneous database access, and so offers some key functionality over DB-Library. Two key factors that differentiate ODBC are:</P><ul type=disc>
<li>
ODBC preserves the semantics of the target DBMS data types.<br><br></li>
<li>
ODBC provides a connection model that is generic and extensible to allow for different networks, security systems, and DBMS options.</li>
</ul>
</li>
<li>
Access to "local" data.<p class=tl>
ODBC enables easy access to local data such as xBase or Paradox®.</P></li>
</ul>
<p>
DB-Library is appropriate for:
<ul type=disc>
<li>
Maintaining and enhancing existing applications.<p class=tl>
Existing DB-Library applications do not have to be rewritten using ODBC. DB-Library will continue to be supported. Open Data Services and Microsoft catalog stored procedures open up heterogeneous data access to existing DB-Library applications.</P></li>
<li>
Multiplatform clients (MS-DOS, Windows, Windows NT, OS/2).<p class=tl>
Currently, only Windows-based applications can use the ODBC API. An application that also requires client support for MS-DOS and/or OS/2 should use DB-Library. DB-Library is also equivalent to the SYBASE Open Client interface on UNIX, VMS, and Macintosh systems.</P></li>
<li>
SQL Server–specific applications.<p class=tl>
An application that is specifically tied to SQL Server, such as a bulk data loader, should be built with DB-Library.</P></li>
</ul>
<h3>Using Gateways or the Direct-Connect Approach</h3>
<p>
In a number of instances, applications will be able to access a back-end database through a direct-connect (two-tiered) ODBC driver loaded at the workstation, or by connecting to an Open Data Services–based gateway using ODBC or DB-Library (a three-tiered solution). If the database involved resides on the same local-area network as the application and uses the same network protocol, the choice obviously will be to use a two-tiered ODBC driver. However, when access to the database is complicated by different network protocols, wide-area network, and so on, it is beneficial to consider using a gateway.</p>
<p>
ODBC and Open Data Services can integrate well in three-tiered configurations to solve enterprise-wide data access issues. Consider using the Open Data Services ODBC driver and a single network protocol at the client in the following cases:
<ul type=disc>
<li>
When communication to DBMS might not be practical in Windows. For example, full LU6.2 support to IBM mainframes is costly to support on every desktop but works very well in a gateway configuration.<br><br></li>
<li>
When multiple protocols are involved. For example, when LAN Manager or Novell® clients need to access TCP/IP or DECnet-based products, it might make sense to go through a LAN-based gateway.<br><br></li>
<li>
When no two-tiered driver is available to access a particular DBMS.</li>
</ul>
<p>
Figure 14 illustrates a LAN with applications using both DB-Library and ODBC to connect to SQL Server and Open Data Services-based gateways.</p>
<p>
<img src="csapp14.gif" border=0></p>
<p class=label>
<b>Figure 14. Applications using DB-Library or ODBC to connect to SQL Server and Open Data Services</b></p>
<h3>System Catalog Access</h3>
<p>
To enable applications that work the same across different back-end databases, ODBC–based applications should use the ODBC system catalog APIs when retrieving information from system catalogs. DB-Library–based applications that access Open Data Services–based gateways should use Microsoft catalog stored procedures instead of issuing queries that directly access system tables.</p>
<h3>SQL Syntax and Semantics</h3>
<p>
The decision as to whether to use "generic" SQL that is common to all databases being accessed, or to "sense" the back-end being accessed and make use of SQL extensions such as stored procedures, depends on the type of application being developed.</p>
<p>
The decision on the level of "generic" versus "specific" SQL to use depends, among other things, on:
<ul type=disc>
<li>
The set of features you want to access from your applications, including features that may not be available from all data sources.<br><br></li>
<li>
How much interoperability you want to provide.<br><br></li>
<li>
How much conditional code you want to include to determine whether a function or data type is supported by the data source.<br><br></li>
<li>
Performance requirements. In general, performance is increased through the use of specific back-end data source features, and it can be adversely affected if you use a minimum set of SQL common to all databases.</li>
</ul>
<h4>Using ODBC as the client API</h4>
<p>
If you use ODBC as the client API, you can rely on the ODBC driver to take care of some of the differences in SQL syntax and semantics. Each ODBC driver supports at least one or two sets of SQL statements:
<ul type=disc>
<li>
The <i>minimum set</i>,<i> </i>a set of SQL statements that can be implemented by single-tiered drivers.<br><br></li>
<li>
The <i>core set</i>,<i> </i>based on the X/Open and SQL Access Group draft CAE specification (1991).</li>
</ul>
<p>
In addition to the core and minimum sets, ODBC defines SQL syntax for data literals, outer joins, and SQL scalar functions. The core and minimum sets of SQL statements supported by ODBC do not restrict the set of statements that can be supported. A driver can support additional syntax that is unique to the associated data source; this is referred to as <i>extended functionality.</i></p>
<p>
The following table provides guidelines for selecting a functionality set to match the functionality and interoperability needs of an client application developed using ODBC.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>To communicate with</b></td>
<td class=label width=50%><b>Choose</b></td>
</tr>
<tr valign=top>
<td width=50%>Single-tiered and multiple-tiered drivers, with maximum interoperability and the least amount of application work.</td>
<td width=50%>Minimum functionality. All drivers support core ODBC functions and minimum SQL statements.</td>
</tr>
<tr valign=top>
<td width=50%>Single-tiered and multiple-tiered drivers, with maximum interoperability and maximum functionality.</td>
<td width=50%>Check before you issue core or extended functions. If supported, use them. If not, perform equivalent work using minimum functions.</td>
</tr>
<tr valign=top>
<td width=50%>Single-tiered drivers.</td>
<td width=50%>Minimum functionality.</td>
</tr>
<tr valign=top>
<td width=50%>Multiple-tiered drivers only, with maximum interoperability and least amount of application work.</td>
<td width=50%>Core functionality.</td>
</tr>
<tr valign=top>
<td width=50%>Multiple-tiered drivers only, with maximum interoperability, maximum functionality, and maximum performance.</td>
<td width=50%>Extended functionality. Check functions and, if not available, perform equivalent work using core functions.</td>
</tr>
</table><br>
<h4>Using DB-Library as the client API</h4>
<p>
If you use DB-Library as the client API and access heterogeneous data sources through Open Data Services–based gateways, you cannot rely on the client API to resolve SQL syntax and semantic incompatibilities. Instead, the system catalog stored procedures specification and the gateways themselves provide some aid in addressing incompatible SQL syntax and semantics.</p>
<p>
The system catalog stored procedures allow transparent catalog access, as well as the ability to query a back-end data source about support for specific functionality.
<ul type=disc>
<li>
The<b> sp_server_info</b> catalog stored procedure returns, among other things, information about capabilities of the database gateway and/or underlying data source.<br><br></li>
<li>
The <b>sp_dataype_info</b> catalog stored procedure returns information about the datatypes supported by the DBMS.</li>
</ul>
<p>
When using DB-Library and Open Data Service–based gateways to access heterogeneous data sources, read the documentation for the gateway(s) that you will be accessing to identify features supported, SQL mapping transformed, unsupported features, and so on.</p>
<h2>Summary</h2>
<p>
This technical article has addressed some of the issues involved in enabling client/server applications to access enterprise data stored in a wide variety of heterogeneous databases. The database connectivity products from Microsoft—ODBC, Open Data Services, and SQL Bridge—enable client/server applications in general, and those built around Microsoft SQL Server in particular, to access to these important databases.</p>
<h2>References</h2>
<p>
Date, C.J. <i>An Introduction to Database Systems, </i>Volume 1 (5th edition). Addison-Wesley, 1990.</p>
<p>
Hackathorn, Richard. "Emerging Architectures for Database Connectivity." <i>InfoDB</i>, January 1991.</p>
<h2>Related Readings</h2>
<p>
<a href="msdn_opendata.htm">“Microsoft Open Data Services: Application Sourcebook.”</a> MSDN Library, Technical Articles.</p>
<p>
Moffatt, Christopher. <a href="msdn_sqlintgr.htm">"Microsoft SQL Server Network Integration Architecture."</a> MSDN Library, Technical Articles.</p>
<p>
Narayanan, Suriya. <a href="msdn_mxprfsql.htm">"Maximizing Performance Using Binary Columns and Bitwise Operations in Microsoft SQL Server for Windows NT."</a> MSDN Library, Technical Articles.</p>
<p>
<a href="msdn_qryoptim.htm">"Query Optimization Techniques."</a> MSDN Library, Technical Articles.</p>
<p>
Schroeder, Gary. <a href="msdn_backup.htm">"Backup and Recovery Guidelines for Microsoft SQL Server."</a> MSDN Library, Technical Articles.</p>
<h2>Additional Information</h2>
<p>
To receive more information about Microsoft SQL Server, or to have other technical notes faxed to you, call Microsoft Developer Services Fax Request at (206) 635-2222.</p>
</BODY>
</HTML>
