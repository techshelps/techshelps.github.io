<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Appendix B</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1><a name="ole4odbc_appendixb"></a><sup></sup>Appendix B</h1>
<p>
The following is a complete source code listing for the example presented in "Handling Long Data Types." The example selects the <b>Notes</b> column (LONG_VARCHAR) from the <b>Employees </b>table of the <b>Access Northwind </b>sample database. The database is shipped with the OLE DB SDK and is installed as the ODBC data source <i>OLE_DB_NWind_Jet.</i></p>
<p>
To build the file using Microsoft Visual C++ 4.0 or later:
<ol>
<li>
Create a new console application.<br><br></li>
<li>
Copy the following code to a new .cpp file.<br><br></li>
<li>
Ensure that your build directory settings reference the OLE DB SDK include directory.<br><br></li>
<li>
Alter the build link settings to include linking to Oledb.lib.</li>
</ol>
<pre><code>/********************************************************************
* Using ISequentialStream to retrieve LONG_VARCHAR/ LONG_VARBINARY
* (BLOB) data
********************************************************************/
#define UNICODE
#define _UNICODE
#define DBINITCONSTANTS
#define INITGUID

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#include &lt;oledb.h&gt;  // OLE DB include files
#include &lt;oledberr.h&gt;
#include &lt;msdasql.h&gt; 

#define&nbsp; BLOCK_SIZE&nbsp;&nbsp;&nbsp;&nbsp; 250

// Prototypes
HRESULT myInitDSO(IDBInitialize** ppIDBI);
HRESULT mySetInitProps(IDBInitialize*&nbsp; pIDBInitialize);
HRESULT myCommand(IDBInitialize* pIDBI, IRowset** ppIRowset);
void&nbsp;&nbsp;&nbsp; myGetBLOBData(IRowset* pIRowset);
void&nbsp;&nbsp;&nbsp; DumpError(LPSTR lpStr);

IMalloc*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_pIMalloc = NULL;

/********************************************************************
* OLE DB application main()
********************************************************************/
int main()
 &nbsp;&nbsp; {
 &nbsp;&nbsp; IDBInitialize*&nbsp; pIDBInitialize = NULL;
 &nbsp;&nbsp; IRowset*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIRowset = NULL;

 &nbsp;&nbsp; //Init OLE and set up the DLLs.
 &nbsp;&nbsp; CoInitialize(NULL);

 &nbsp;&nbsp; // Get the task memory allocator.
 &nbsp;&nbsp; if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;g_pIMalloc)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto EXIT;

 &nbsp;&nbsp; // Connect to the data source.
 &nbsp;&nbsp; if (FAILED(myInitDSO(&amp;pIDBInitialize)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto EXIT;

 &nbsp;&nbsp; // Get a session, set and execute a command.
 &nbsp;&nbsp; if (FAILED(myCommand(pIDBInitialize, &amp;pIRowset)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto EXIT;

 &nbsp;&nbsp; myGetBLOBData(pIRowset);

EXIT:
 &nbsp;&nbsp; if (pIRowset != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIRowset-&gt;Release();

 &nbsp;&nbsp; if (pIDBInitialize != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(pIDBInitialize-&gt;Uninitialize()))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Uninitialize is not required, but it will fail if an
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // interface has not been released. We can use it for 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // debugging.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DumpError("Someone forgot to release something!");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIDBInitialize-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; if (g_pIMalloc != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_pIMalloc-&gt;Release();

 &nbsp;&nbsp; CoUninitialize();
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return (0);
 &nbsp;&nbsp; }


/********************************************************************
* Initialize the data source.
********************************************************************/
HRESULT myInitDSO
 &nbsp;&nbsp; (
 &nbsp;&nbsp; IDBInitialize** ppIDBInitialize&nbsp;&nbsp;&nbsp; // [out]
 &nbsp;&nbsp; )
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Create an instance of the MSDASQL (ODBC) provider.
 &nbsp;&nbsp; CoCreateInstance(CLSID_MSDASQL, NULL, CLSCTX_INPROC_SERVER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IDBInitialize, (void**)ppIDBInitialize);

 &nbsp;&nbsp; if (*ppIDBInitialize == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; if (FAILED(mySetInitProps(*ppIDBInitialize)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; if (FAILED((*ppIDBInitialize)-&gt;Initialize()))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DumpError("IDBInitialze-&gt;Initialize failed.");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (E_FAIL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; return (NOERROR);
 &nbsp;&nbsp; }

/********************************************************************
* Set initialization properties on a data source.
********************************************************************/
HRESULT mySetInitProps
 &nbsp;&nbsp; (
 &nbsp;&nbsp; IDBInitialize*&nbsp; pIDBInitialize&nbsp;&nbsp;&nbsp; // [in]
 &nbsp;&nbsp; )
 &nbsp;&nbsp; {
 &nbsp;&nbsp; const ULONG&nbsp;&nbsp;&nbsp;&nbsp; nProps = 4;
 &nbsp;&nbsp; IDBProperties*&nbsp; pIDBProperties;
 &nbsp;&nbsp; DBPROP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitProperties[nProps];
 &nbsp;&nbsp; DBPROPSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgInitPropSet;
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr;

 &nbsp;&nbsp; // Initialize common property options.
 &nbsp;&nbsp; for (ULONG i = 0; i &lt; nProps; i++ )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VariantInit(&amp;InitProperties[i].vValue);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitProperties[i].dwOptions = DBPROPOPTIONS_REQUIRED;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitProperties[i].colid = DB_NULLID;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Level of prompting that will be done to complete the
 &nbsp;&nbsp; // connection process
 &nbsp;&nbsp; InitProperties[0].dwPropertyID = DBPROP_INIT_PROMPT;
 &nbsp;&nbsp; InitProperties[0].vValue.vt = VT_I2;
 &nbsp;&nbsp; InitProperties[0].vValue.iVal = DBPROMPT_NOPROMPT;&nbsp;&nbsp;&nbsp;&nbsp; 

 &nbsp;&nbsp; // Data source name--see the sample source included with the OLE
 &nbsp;&nbsp; // DB SDK.
 &nbsp;&nbsp; InitProperties[1].dwPropertyID = DBPROP_INIT_DATASOURCE;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; InitProperties[1].vValue.vt = VT_BSTR;
 &nbsp;&nbsp; InitProperties[1].vValue.bstrVal = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SysAllocString(OLESTR("OLE_DB_NWind_Jet"));

 &nbsp;&nbsp; // User ID
 &nbsp;&nbsp; InitProperties[2].dwPropertyID = DBPROP_AUTH_USERID;
 &nbsp;&nbsp; InitProperties[2].vValue.vt = VT_BSTR;
 &nbsp;&nbsp; InitProperties[2].vValue.bstrVal = SysAllocString(OLESTR(""));

 &nbsp;&nbsp; // Password
 &nbsp;&nbsp; InitProperties[3].dwPropertyID = DBPROP_AUTH_PASSWORD;
 &nbsp;&nbsp; InitProperties[3].vValue.vt = VT_BSTR;
 &nbsp;&nbsp; InitProperties[3].vValue.bstrVal = SysAllocString(OLESTR(""));

 &nbsp;&nbsp; rgInitPropSet.guidPropertySet = DBPROPSET_DBINIT;
 &nbsp;&nbsp; rgInitPropSet.cProperties = nProps;
 &nbsp;&nbsp; rgInitPropSet.rgProperties = InitProperties;

 &nbsp;&nbsp; // Set initialization properties.
 &nbsp;&nbsp; pIDBInitialize-&gt;QueryInterface(IID_IDBProperties, (void**) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pIDBProperties);
 &nbsp;&nbsp; hr = pIDBProperties-&gt;SetProperties(1, &amp;rgInitPropSet);

 &nbsp;&nbsp; SysFreeString(InitProperties[1].vValue.bstrVal);
 &nbsp;&nbsp; SysFreeString(InitProperties[2].vValue.bstrVal);
 &nbsp;&nbsp; SysFreeString(InitProperties[3].vValue.bstrVal);

 &nbsp;&nbsp; pIDBProperties-&gt;Release();

 &nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DumpError("Set properties failed.");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }

/********************************************************************
* Execute a command selecting Notes from Employees.
********************************************************************/
HRESULT myCommand
 &nbsp;&nbsp; (
 &nbsp;&nbsp; IDBInitialize*&nbsp; pIDBInitialize, // [in]
 &nbsp;&nbsp; IRowset**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ppIRowset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [out]
 &nbsp;&nbsp; ) 
 &nbsp;&nbsp; {
 &nbsp;&nbsp; IDBCreateSession*&nbsp;&nbsp; pIDBCreateSession;
 &nbsp;&nbsp; IDBCreateCommand*&nbsp;&nbsp; pIDBCreateCommand;
 &nbsp;&nbsp; IRowset*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIRowset;
 &nbsp;&nbsp; ICommandText*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pICommandText;
 &nbsp;&nbsp; LPCTSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wSQLString = OLESTR("SELECT Notes ")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OLESTR("FROM Employees");
 &nbsp;&nbsp; LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRowsAffected;
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr;

 &nbsp;&nbsp; // Set for failure
 &nbsp;&nbsp; *ppIRowset = NULL;

 &nbsp;&nbsp; // Get the DB session object.
 &nbsp;&nbsp; hr = pIDBInitialize-&gt;QueryInterface(IID_IDBCreateSession,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**) &amp;pIDBCreateSession);
 &nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DumpError("Session initialization failed.");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (hr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; // Create the session.
 &nbsp;&nbsp; hr = pIDBCreateSession-&gt;CreateSession(NULL, IID_IDBCreateCommand,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (IUnknown**) &amp;pIDBCreateCommand);
 &nbsp;&nbsp; pIDBCreateSession-&gt;Release();
 &nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DumpError("Create session failed.");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (hr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; // Create the command object.
 &nbsp;&nbsp; hr = pIDBCreateCommand-&gt;CreateCommand(NULL, IID_ICommandText,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (IUnknown**) &amp;pICommandText);
 &nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DumpError("Create command failed.");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (hr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; pIDBCreateCommand-&gt;Release();

 &nbsp;&nbsp; // The command requires the actual text as well as an indicator
 &nbsp;&nbsp; // of its language and dialect.
 &nbsp;&nbsp; pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wSQLString);

 &nbsp;&nbsp; // Execute the command.
 &nbsp;&nbsp; hr = pICommandText-&gt;Execute(NULL, IID_IRowset, NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;cRowsAffected, (IUnknown**) &amp;pIRowset);
 &nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DumpError("Command execution failed.");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; pICommandText-&gt;Release();

 &nbsp;&nbsp; *ppIRowset = pIRowset;
 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }

/********************************************************************
* Retrieve data from an ODBC LONG_VARCHAR column (Notes in
* Employees).
********************************************************************/
void myGetBLOBData
 &nbsp;&nbsp; (
 &nbsp;&nbsp; IRowset*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIRowset&nbsp;&nbsp;&nbsp; // [in]
 &nbsp;&nbsp; )
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DBOBJECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectStruct;&nbsp;&nbsp;&nbsp; // For binding, retrieve an
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object pointer.
 &nbsp;&nbsp; DBBINDING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgBinding[1];&nbsp;&nbsp;&nbsp; // Bind a single column.

 &nbsp;&nbsp; IAccessor*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIAccessor = NULL;&nbsp;&nbsp;&nbsp;&nbsp; // Accessor creation
 &nbsp;&nbsp; HACCESSOR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hAccessor = NULL;
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ulErrorBinding;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; void*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bound consumer buffer
 &nbsp;&nbsp; HROW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rghRows[1];
 &nbsp;&nbsp; HROW*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pRows = &amp;rghRows[0];
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRows;

 &nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szNotes[BLOCK_SIZE + 1];// Text data from "Notes"
 &nbsp;&nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbRead;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Count of bytes read
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Set up the object structure for accessor creation. Ask the
 &nbsp;&nbsp; // provider to return an ISequentialStream interface for reading.
 &nbsp;&nbsp; ObjectStruct.dwFlags = STGM_READ; 
 &nbsp;&nbsp; ObjectStruct.iid = IID_ISequentialStream;

 &nbsp;&nbsp; // Set up the binding struct for the accessor.
 &nbsp;&nbsp; rgBinding[0].iOrdinal = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Only one column
 &nbsp;&nbsp; rgBinding[0].obValue&nbsp; = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Offset to data
 &nbsp;&nbsp; rgBinding[0].obLength = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ignore length 
 &nbsp;&nbsp; rgBinding[0].obStatus = sizeof(IUnknown*);&nbsp; // Offset to status 
 &nbsp;&nbsp; rgBinding[0].pTypeInfo = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
 &nbsp;&nbsp; rgBinding[0].pObject&nbsp; = &amp;ObjectStruct;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Our interface 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // request
 &nbsp;&nbsp; rgBinding[0].pBindExt = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
 &nbsp;&nbsp; rgBinding[0].dwPart&nbsp;&nbsp; = DBPART_VALUE |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get both VALUE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPART_STATUS;&nbsp; // and STATUS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // parts.
 &nbsp;&nbsp; rgBinding[0].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
 &nbsp;&nbsp; rgBinding[0].eParamIO = DBPARAMIO_NOTPARAM;
 &nbsp;&nbsp; rgBinding[0].cbMaxLen = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not applicable
 &nbsp;&nbsp; rgBinding[0].dwFlags&nbsp; = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
 &nbsp;&nbsp; rgBinding[0].wType = DBTYPE_IUNKNOWN;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Type 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DBTYPE_IUNKNOWN
 &nbsp;&nbsp; rgBinding[0].bPrecision = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not applicable
 &nbsp;&nbsp; rgBinding[0].bScale = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not applicable

 &nbsp;&nbsp; // Get the accessor interface and create the accessor.
 &nbsp;&nbsp; pIRowset-&gt;QueryInterface(IID_IAccessor, (void**) &amp;pIAccessor);

 &nbsp;&nbsp; if (FAILED(pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, 1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgBinding, sizeof(IUnknown*) + sizeof(ULONG), &amp;hAccessor,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;ulErrorBinding)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DumpError("CreateAccessor failed.");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; // Allocate memory for the returned pointer and the status field. 
 &nbsp;&nbsp; // The first sizeof(IUnknown*) bytes are for the pointer to the 
 &nbsp;&nbsp; // object; the next sizeof(ULONG) bytes are for the status.
 &nbsp;&nbsp; pData = new BYTE[sizeof(IUnknown*) + sizeof(ULONG)];

 &nbsp;&nbsp; while (TRUE)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the next row.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(pIRowset-&gt;GetNextRows(NULL, 0, 1, &amp;cRows, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pRows)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DumpError("GetNextRows failed.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cRows == 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the row data, the pointer to an ISequentialStream*.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(pIRowset-&gt;GetData(*pRows, hAccessor, pData)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DumpError("GetData failed.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Read and process BLOCK_SIZE bytes at a time.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((ULONG)((BYTE*)pData)[rgBinding[0].obStatus] == 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBSTATUS_S_ISNULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Process NULL data.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("&lt;null&gt;");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((ULONG)((BYTE*)pData)[rgBinding[0].obStatus] == 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBSTATUS_S_OK)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*((ISequentialStream**) pData))-&gt;Read(szNotes, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLOCK_SIZE, &amp;cbRead);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cbRead &gt; 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // process data
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szNotes[cbRead] = (char) NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(szNotes);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (cbRead &gt;= BLOCK_SIZE);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*((ISequentialStream**) pData))-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\n\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIRowset-&gt;ReleaseRows(cRows, pRows, NULL, NULL, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; // Clean up.
 &nbsp;&nbsp; pIAccessor-&gt;ReleaseAccessor(hAccessor, NULL);
 &nbsp;&nbsp; pIAccessor-&gt;Release();

 &nbsp;&nbsp; delete [] pData;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
/********************************************************************
* Dump an error to the console.
********************************************************************/
void DumpError(LPSTR lpStr)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; printf(lpStr);
 &nbsp;&nbsp; printf("\n");
 &nbsp;&nbsp; }
</code></pre>
</BODY>
</HTML>
