<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing OLE Automation Collections</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_collect"></a></sup>Implementing OLE Automation Collections</h1>
<p>
Charlie Kindel<br>
Program Manager/OLE Evangelist, Microsoft Developer Relations Group</p>
<p>
Created: March 10, 1994<br>
Revised: October 18, 1994</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="2393">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the XRTFrame sample application</a></p>
<h2>Abstract</h2>
<p>
This article describes how to design and implement OLE Automation collections using the Microsoft® Foundation Classes (MFC). A precise definition of collections is given, followed by the definition of an OLE Automation collection.</p>
<p>
Throughout this article, code fragments are given in both C++/MFC and Visual Basic®. It is assumed that the reader is familiar with both. The XRTFRAME sample application is an MFC application that illustrates the OLE Automation collection concepts presented in this article.</p>
<h2>Definition of an Automation Collection</h2>
<p>
The Microsoft® Excel version 5.0 <i>Visual Basic Programmer's Guide</i> defines OLE Automation collections as follows:</p>
<p class=indent>
<i>"A group of objects. An object's position in the collection can change whenever a change occurs in the collection. Therefore, the position of any specific object in the collection is unpredictable. This unpredictability distinguishes a collection from an array."</i></p>
<p>
This article, and the associated sample code, uses this definition.</p>
<p>
The defining characteristic of a collection is the ability to iterate over the items contained in the collection. An <i>item</i> is any thing that can be accessed via an OLE Automation interface. Examples of items in a typical Microsoft Windows®-based application are multiple-document interface (MDI) child windows, a cell in a spreadsheet, and a button on the toolbar. Examples of collections are the cells in a worksheet, the open worksheets, the windows containing those worksheets, and the buttons on the toolbars.</p>
<h2>Collections vs. Arrays</h2>
<p>
Initially, it seems to make sense to think of the set of open windows in an application as an array of windows, where it is possible to access any given window via an index. This implies that each window has some fixed indices relative to some starting point (the first window created?). However, a typical Windows-based application changes the z-order of existing windows and may dynamically create and destroy other windows. While it is not difficult to implement an array whose upper bound can grow and shrink, it is awkward to remove items from the middle of an array. Therefore, it is often more convenient to use collections instead of arrays. This paradigm of having no guaranteed order or size is ideally suited to the use of collections. A collection can be implemented as an array, but in many (if not most) cases, it is easier to implement them as linked lists, where items can be added, removed, and moved around at will. It is still useful to be able to access individual windows in the list by name or index, and even iterate over all of the windows. Collections provide a mechanism for doing just this. In a sense, the term <i>collection</i> is a non-computer science way of describing a linked list.</p>
<p>
Typically (but not always), an arbitrary item or object in an application can be identified through both a human-readable name and some sort of indexing. For example, a user could find a window in a collection using its name (typically a string representing its caption) or by using a number (representing its position in the z-order).</p>
<h2>OLE Automation Collections</h2>
<p>
OLE Automation collections are collections that are exposed through a standard OLE interface.</p>
<p>
A collection is exposed from OLE Automation through a collection object. There is no "collection object" type. Collection objects can be <i>pseudo-objects</i>; that is, it is reasonable for collection objects to exist only while a client is iterating over the collection.</p>
<p>
The following table shows the standard properties and methods of a collection object. Note that some are optional:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=33%><b>Member</b></td>
<td class=label width=33%><b>Description</b></td>
<td class=label width=34%><b>Optional?</b></td>
</tr>
<tr valign=top>
<td width=33%><b>Add method</b></td>
<td width=33%>Adds the indicated item to the collection.</td>
<td width=34%>Yes</td>
</tr>
<tr valign=top>
<td width=33%><b>Count property</b></td>
<td width=33%>Returns the number of items in the collection.</td>
<td width=34%>No</td>
</tr>
<tr valign=top>
<td width=33%><b>Item method</b></td>
<td width=33%>Returns the indicated item in the collection, or VT_EMPTY if the item does not exist.</td>
<td width=34%>No</td>
</tr>
<tr valign=top>
<td width=33%><b>_NewEnum property</b></td>
<td width=33%>Returns an OLE object that supports IEnumVARIANT. This method is not visible to users.</td>
<td width=34%>No</td>
</tr>
<tr valign=top>
<td width=33%><b>Remove method</b></td>
<td width=33%>Removes the specified item from the collection.</td>
<td width=34%>Yes</td>
</tr>
</table><br>
<h2>The Six Commandments of OLE Automation Collections</h2>
<p>
There are basically six rules that an OLE Automation collection must abide by in order to be called a collection. These six "commandments" define what methods and properties a collection must support and the semantics of the object.</p>
<h3>The First Commandment</h3>
<p>
<i>A property or method that returns a collection must be named with the plural name for the items in the collection. If the plural name for the item is the same as the singular name, "Collection" should be appended to the singular name to obtain the name for the property.</i></p>
<p>
Examples of this first commandment of collections are given below:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Name of an item in the collection</b></td>
<td class=label width=27%><b>Type of the item in the collection</b></td>
<td class=label width=43%><b>Name of the collection object</b></td>
</tr>
<tr valign=top>
<td width=30%>Word</td>
<td width=27%>Word object</td>
<td width=43%>Words</td>
</tr>
<tr valign=top>
<td width=30%>Item</td>
<td width=27%>Item object</td>
<td width=43%>Items</td>
</tr>
<tr valign=top>
<td width=30%>Document</td>
<td width=27%>Document object</td>
<td width=43%>Documents</td>
</tr>
<tr valign=top>
<td width=30%>Foot</td>
<td width=27%>Foot object</td>
<td width=43%>Feet</td>
</tr>
<tr valign=top>
<td width=30%>Vertex</td>
<td width=27%>Point object</td>
<td width=43%>Vertices</td>
</tr>
</table><br>
<h3>The Second Commandment</h3>
<p>
<i>All collection objects must have an _NewEnum property.</i></p>
<h4>_NewEnum property</h4>
<p>
<b>Name</b>: _NewEnum. (Both NewEnum and _NewEnum are frequently used. However, the name of this method is not important because it is always<i> </i>accessed via a special DISPID: DISPID_NEWENUM.)</p>
<p>
<b>Description</b>: Points to an object that supports IEnumVARIANT.</p>
<p>
<b>Parameters</b>: None.</p>
<p>
<b>Return type</b>: VT_UNKNOWN. (The <i>OLE Automation Reference</i> indicates that the return type should be VT_DISPATCH. However, this does not make sense because the return is a pointer to an IEnumVARIANT interface, not an IDispatch interface.)</p>
<p>
<b>Usage example</b>: None. End users do not know about the <b>NewEnum</b> method.</p>
<p>
<b>Note</b>: <b>_NewEnum</b> will not be accessible to users. The <b>_NewEnum</b> method must have a special DISPID: DISPID_NEWENUM.</p>
<p>
The defining characteristic of a collection is the provision to allow&nbsp; a user to iterate over the items in it. The <b>NewEnum</b> method is the primary mechanism for doing this. In programming languages such as Visual Basic® for Applications, the _NewEnum property is used internally by the implementation to support constructs that iterate over collections. However, some languages do not have built-in support for collections (Visual Basic 3.0 and the DispTest tool are examples).</p>
<pre><code>For Each w In words
 &nbsp; MsgBox w.Definition
Next
</code></pre>
<p>
OLE Automation controllers that support "for each"-like constructs for iterating over collections will retrieve the _NewEnum property from the collection object and then <b>QueryInterface</b> to get the IEnumVARIANT pointer. <b>IEnumVariant::Next</b> is used to iterate over the collection by the Automation controller.</p>
<p>
The _NewEnum property is "restricted". Restricted properties and methods are not accessible to end users. (TypeLibrary creators can specify that a property or method is restricted by using the "restricted" attribute for the property or method in the ODL specification that is used by MKTYPLIB.EXE to generate a type library.) The underscore in the name of property indicates that it will not be visible to users that use a type library browser, such as the Object Browser in Microsoft Excel 5.0. In MFC, the DISP_PROPERTY_EX_ID macro should be used to define the dispatch map for the <b>NewEnum</b> method:</p>
<pre><code>DISP_PROPERTY_EX_ID(CWords, "_NewEnum", DISPID_NEWENUM, _NewEnum, SetNotSupported, VT_UNKNOWN)
</code></pre>
<p>
Note that ClassWizard is not capable of automatically generating DISP_PROPERTY_EX_ID entries in a class dispatch map; you must add this entry manually.</p>
<p>
The _NewEnum property should be declared in a collection's type information as follows:</p>
<pre><code>#define DISPID_NEWENUM -4

properties:
 &nbsp;&nbsp;&nbsp;&nbsp; [id(DISPID_NEWENUM)] IUnknown* _NewEnum ;
</code></pre>
<p>
The name of the <b>NewEnum</b> method need not be localized because end users will never see it.</p>
<h3>The Third Commandment</h3>
<p>
<i>All collection objects must have a Count property.</i></p>
<h4>Count property</h4>
<p>
<b>Name</b>: Count.</p>
<p>
<b>Description</b>: The count of items in the collection.</p>
<p>
<b>Access</b>: Read-only.</p>
<p>
<b>Data type</b>: VT_I4.</p>
<p>
<b>Usage example</b>: </p>
<pre><code>Print Words.Count
For i = 1 To Words.Count
 &nbsp; Print Words(i).Definition
Next i
</code></pre>
<p>
The Count property provides a second means for iterating over the objects in a collection. It is most useful in languages that do not directly support collections (that is, languages that do not support the _NewEnum property) such as Visual Basic 3.0.</p>
<p>
The fact that the position of an item in a collection may change whenever items are added or removed from the collection can cause some confusion when the Count property is used to iterate over a collection. For example, the following code will not work correctly with most collection objects:</p>
<pre><code>For i = 1 To Words.Count
 &nbsp; Words.Remove(i)
Next i
</code></pre>
<p>
However, the following code will work just fine:</p>
<pre><code>For i = 1 To Words.Count
 &nbsp; Words.Remove(0)
Next I
</code></pre>
<p>
or:</p>
<pre><code>For I = Words.Count to 1
 &nbsp; Words.Remove(0)
Next I
</code></pre>
<p>
(Both examples assume that the collection object Words implements the optional <b>Remove</b> method.)</p>
<p>
Note that some collections are zero-indexed and some are indexed starting at 1. It is recommended that new collections be designed such that indexing starts at 1.</p>
<h3>The Fourth Commandment</h3>
<p>
<i>All collection objects must support at least one form of indexing by implementing the <b>Item</b> method.</i></p>
<h4>Item method</h4>
<p>
<b>Name</b>: Item.</p>
<p>
<b>Description</b>: Returns the indicated item in the collection, or VT_EMPTY if the item does not exist.</p>
<p>
<b>Parameters</b>: Varies.</p>
<p>
<b>Return type</b>: VT_DISPATCH.</p>
<p>
<b>Usage example</b>:</p>
<pre><code>Print Words(3).Definition
Print Words("fox").Definition
Print Words.Item(3).Definition
Print Words.Item("fox").Definition
Print Cells.Item(1,1).Text
Print Cells.Item("R1C1").TEXT
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The <b>Item</b> method must be the default member for the object. In MFC, the dispatch map macro DISP_DEFVALUE(CMyObject, "Item") denotes the <b>Item</b> method as the default member for the <b>CMyObject</b> object by assigning to the dispatch map the DISPID of 0.</p>
<p>
Most collections support one or more forms of indexing. The following code shows how a collection object can support indexing using both an index and a string. This example prints the definition of the third word in the Words collection and then prints the definition of "dog".</p>
<pre><code>Print Words(3).Definition
Print Words("dog").Definition
</code></pre>
<p>
The statements above are equivalent to: </p>
<pre><code>Print Words.Item(3).Definition
Print Words.Item("dog").Definition
</code></pre>
<p>
because Item is the default member (DISPID_DEFVALUE) of the Words collection object.</p>
<p>
Collections that support indexing must use the <b>Item</b> method to implement indexing. Collections that support several types of indexing should implement an <b>Item</b> method that takes one or more VARIANTs as index parameters.</p>
<p>
In MFC, the <b>Item</b> method should have a dispatch map entry that looks like this:</p>
<pre><code>DISP_FUNCTION(CDataItems, "Item", GetItem, VT_DISPATCH, VTS_VARIANT)
DISP_DEFVALUE(CDataItems, "Item")
</code></pre>
<p>
The ODL statement for the <b>Item</b> should look like this:</p>
<pre><code>methods:
 &nbsp; [id(0)] IDispatch* Item(VARIANT Index);
</code></pre>
<h3>The Fifth Commandment</h3>
<p>
<i>Collections that support manual addition of objects should consider doing so using the standard <b>Add</b> method.</i></p>
<h4>Add method</h4>
<p>
<b>Name</b>: Add.</p>
<p>
<b>Suggested syntax</b>: Add obj [, index][, before][, after]</p>
<p>
where<i> index </i>is a string property that can later be used as a string index, and <i>before</i> and <i>after </i>(one or the other, not both) control the placement of the object in the collection.</p>
<p>
<b>Description</b>: Adds the indicated item to the collection. If an object is created as a result of the addition, that object should be returned.</p>
<p>
<b>Parameters</b>: Varies.</p>
<p>
<b>Return type</b>: VARIANT, the type of which varies with the implementation. If the <b>Add</b> method cannot add the item to the collection, it should raise an exception. If an object is created as a result of the <b>Add</b>, the return value should be of type VT_DISPATCH.</p>
<p>
Here is an example that illustrates many of the ways in which the <b>Add</b> method can be used:</p>
<pre><code>Set MyDict = CreateObject("Diction.Application")

Set dog = CreateObject("Diction.Word)
dog.Letters = "dog"
dog.Definition = "Man's best friend."
MyDict.Add dog, Index =: dog.Letters

Set cat = CreateObject("Diction.Word)
cat.Letters = "cat"
cat.Definition = "Dog's best friend."
MyDict.Add cat, Index =: cat.Letters, After := dog
</code></pre>
<p>
The above example assumes that the implementation of <b>Add</b> follows the suggested syntax given above.</p>
<p>
The <b>Add</b> method is not appropriate for all collections, so it is not required. For many application-created collections, objects are automatically added to the collection for the user. If a collection object's <b>Add</b> method sometimes creates an object, the return type of the method can be IDispatch*. When an object is created, a pointer to the object is returned; when an object is not created, NULL is returned.</p>
<h3>The Sixth Commandment</h3>
<p>
<i>Collections that support manual removal of objects should consider doing so using the standard <b>Remove</b> method.</i></p>
<h4>Remove method </h4>
<p>
<b>Name</b>: Remove.</p>
<p>
<b>Description</b>: Removes the specified item from the collection.</p>
<p>
<b>Parameters</b>: Varies.</p>
<p>
<b>Return type</b>: VT_EMPTY.</p>
<p>
<b>Example</b>:</p>
<pre><code>MyDict.Remove("fox")
Set x = MyDict.Item(5)
MyDict.Remove(5)
Print x.Definition
</code></pre>
<p>
The object is not deleted; it is simply removed from the collection.</p>
<p>
<b>Remove</b> should support the same kinds of indexing as the <b>Item() </b>method for the same collection.</p>
<p>
The <b>Remove</b> method is not appropriate for all collections, so it is not required. For many application-created collections, objects are automatically removed from the collection for the user.</p>
<h2>Implementing Collections in MFC</h2>
<p>
The OLE Automation support found in MFC version 2.5 and higher greatly reduces the amount of code you need to write to support Automation in your applications. This makes it much easier to implement OLE Automation collections. This section describes how to implement collections using MFC. The COLLECT sample found in the software library (sample #S14424) shows how to implement OLE Automation collections without using MFC.</p>
<h3>Collection Design Decisions</h3>
<p>
In most applications, collections can be classified into two categories:
<ul type=disc>
<li>
<b>Real collection objects.</b> These objects actually contain the data they are iterating over. The items represented in the collection cannot exist if the collection itself does not exist.<br><br></li>
<li>
<b>Pseudo collection objects.</b> These objects are created only when it is necessary to iterate over a set of items. For example, a "Windows" collection that iterates over the MDI child windows of an MDI application does not actually contain the MDI child windows, but simply uses the <b>EnumWindows</b> method.</li>
</ul>
<p>
It is important to determine the category of a collection before implementing one.</p>
<h3>Properties That Are Collections</h3>
<p>
While it certainly possible for a top-level object (an object that can be created via an <b>IClassFactory::CreateInstance</b> implementation) to be a collection object, it is more likely that collection objects will be sub-objects. For example, the Documents property of the Application object in Microsoft Excel 5.0 returns is a sub-object of Application.</p>
<pre><code>Set docs = Application.Documents
For Each doc in docs
 &nbsp; MsgBox doc.Title
Next
</code></pre>
<p>
We call the Documents property a <i>collection property</i>. Collection properties always have a type of IDispatch* (or a type derived from IDispatch*) and are usually read-only. "Read-only" is used because it is possible for an application to design a collection object that is passed around.</p>
<p>
The Application object might implement the Documents property as follows:</p>
<pre><code>// In APP.ODL
...
 &nbsp;&nbsp;&nbsp; properties:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [id(3)] IDispatch* Documents;
...

// In APP.CPP
...
DISP_PROPERTY(CApplication, "Documents", GetDocuments, SetNotSupported, VT_DISPATCH)
...
LPDISPATCH CApplication::GetDocuments()
{
 &nbsp; CDocuments* pDocs = new CDocuments ;
 &nbsp; ASSERT(pDocs) ;
 &nbsp; if (pDocs == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; AfxThrowOleDispatchException(0,"Out of memory")
 &nbsp; return pDocs-&gt;GetIDispatch(FALSE) ;
}
</code></pre>
<p>
This function simply creates an instance of the Documents collection object and returns its IDispatch pointer. In this case, CDocuments is a pseudo object in that the collection is created only when a collection pointer is requested. Note the call to pDocs-&gt;GetIDispatch(FALSE). The parameter is FALSE in this function because the act of creating a new instance of CDocuments automatically gives the object a reference count of 1. When the caller releases the pointer (by calling pDocs -&gt; Release()), the object should delete itself because the only thing that has a pointer to the newly created pseudo collection object is the caller.</p>
<p>
If the application were structured such that CDocuments actually was the container of all document objects, the <b>GetDocuments</b> method would look like this:</p>
<pre><code>LPDISPATCH CApplication::GetDocuments()
{
 &nbsp; return m_Docs.GetIDispatch(TRUE) ;
}
</code></pre>
<p>
In this case, we are assuming that CApplication has a member (m_Docs) of type CDocuments. Note that here we pass the <b>::GetIDispatch</b> function a TRUE parameter to indicate that the object's reference count should be increased. This way, when the caller calls <b>Release</b> on the returned IDispatch pointer, m_Doc won't try to delete itself.</p>
<p>
One last point regarding properties that are collections: Remember what the first commandment of OLE Automation collections says: "A property or method that returns a collection must be named with the plural name for the items in the collection. If the plural name for the item is the same as the singular name, "Collection" should be appended to the singular name to obtain the name for the property."</p>
<h3>Implementing _NewEnum and IEnumVARIANT</h3>
<p>
The second commandment of OLE Automation collections says that each collection object must implement the _NewEnum property. The whole point of the _NewEnum property is to allow OLE Automation controllers to iterate or enumerate over the items in the collection using language features such as the For Each construct in Visual Basic.</p>
<p>
To illustrate how _NewEnum works, consider the following Visual Basic code:</p>
<pre><code>Set docs = Application.Documents
For Each doc in docs
 &nbsp; MsgBox doc.Title
Next
</code></pre>
<p>
The above code enumerates through all of the open documents in the application, and for each document found, pops up a message box indicating the title. The following steps are performed by Visual Basic when it encounters a For Each clause similar to the one above:
<ul type=disc>
<li>
Step 1: Retrieve the value of docs._NewEnum into punk (remember that _NewNum is of type IUnknown*). <br><br></li>
<li>
Step 2: QueryInterface on punk for IEnumVARIANT (pUnk-&gt;QueryInterface( IID_IEnumVARIANT, &amp;penum)). Release punk.<br><br></li>
<li>
Step 3: While penum-&gt;Next returns a valid VARIANT, execute the code within the For Each clause, using the IDispatch pointer stored in the variant for all references to "doc".<br><br></li>
<li>
Step 4: Release penum.</li>
</ul>
<p>
So, in short, _NewEnum points to an enumerator object that knows how to enumerate over the items in the collection. An enumerator object is really just an object that implements the IEnumVARIANT interface. See the <i>OLE Programmer's Reference</i> (MSDN Library, Product Documentation, SDKs, OLE 2) for details on IEnum interfaces.</p>
<p>
You can choose to implement IEnumVARIANT on the same object as your collection's IDispatch, or you can create a separate object that only implements IUnknown and IEnumVARIANT. In either case, if you are using MFC, you will need to implement the IEnumVARIANT interface on <i>some</i> object. The following section illustrates how to do this. (Note that the discussion below applies to implementing <i>any</i> interface on an MFC CCmdTarget derived class.)</p>
<h4>Adding IEnumVARIANT to a CCmdTarget derived class</h4>
<p>
MFC's OLE implementation uses nested classes to implement Component Object Model (COM) interfaces. All objects that expose COM interfaces in MFC have classes derived from the CCmdTarget class. CCmdTarget provides a rich implementation of IUnknown (and IDispatch, but the IDispatch implementation is only enabled if <b>CCmdTarget::EnableAutomation</b> is called) that allows for aggregation and other COM concepts. </p>
<p>
To add a COM interface such as IEnumVARIANT to a CCmdTargetClass, first use the BEGIN_INTERFACE_PART and END_INTERFACE_PART macros in your class declaration as follows.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Please look at the XRTFRAME sample application for a more complete example of implementing OLE Automation collections in MFC.</p>
<pre><code>class CDocuments : public CCmdTarget
{
...
  BEGIN_INTERFACE_PART(EnumVARIANT, IEnumVARIANT)
 &nbsp;&nbsp; STDMETHOD(Next)(THIS_ unsigned long celt, VARIANT FAR* rgvar, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long FAR* pceltFetched);
 &nbsp;&nbsp; STDMETHOD(Skip)(THIS_ unsigned long celt) ;
 &nbsp;&nbsp; STDMETHOD(Reset)(THIS) ;
 &nbsp;&nbsp; STDMETHOD(Clone)(THIS_ IEnumVARIANT FAR* FAR* ppenum) ;
 &nbsp;&nbsp; XEnumVARIANT() ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // constructor to set m_posCurrent
 &nbsp;&nbsp; POSITION m_posCurrent ; // Next() requires we keep track of our current item
  END_INTERFACE_PART(EnumVARIANT)&nbsp;&nbsp;&nbsp; 
  
  DECLARE_INTERFACE_MAP()
...
};
</code></pre>
<p>
These macros are expanded out by the C++ preprocessor to the following:</p>
<pre><code>class CDocuments : public CCmdTarget
{
...
  class FAR XEnumVARIANT : public IEnumVARIANT
  {
  public:
 &nbsp;&nbsp; STDMETHOD_(ULONG, AddRef)(); 
 &nbsp;&nbsp; STDMETHOD_(ULONG, Release)();
 &nbsp;&nbsp; STDMETHOD(QueryInterface)(REFIID iid, LPVOID far* ppvObj); 
 &nbsp;&nbsp; STDMETHOD(Next)(THIS_ unsigned long celt, VARIANT FAR* rgvar,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long FAR* pceltFetched);
 &nbsp;&nbsp; STDMETHOD(Skip)(THIS_ unsigned long celt) ;
 &nbsp;&nbsp; STDMETHOD(Reset)(THIS) ;
 &nbsp;&nbsp; STDMETHOD(Clone)(THIS_ IEnumVARIANT FAR* FAR* ppenum) ;
 &nbsp;&nbsp; XEnumVARIANT() ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // constructor to set m_posCurrent
 &nbsp;&nbsp; POSITION m_posCurrent ; // Next() requires we keep track of our current item
  } m_xEnumVARIANT ;
  friend class XEnumVARIANT ;
  
  DECLARE_INTERFACE_MAP()
...
};
</code></pre>
<p>
In other words, by using the INTERFACE_PART macros, you are adding a nested class to your class and you are declaring a member of that class (m_xEnumVARIANT). In the example above, you can see that a pointer to m_xEnumVARIANT <i>is</i> a pointer to an IEnumVARIANT interface.</p>
<p>
You must declare an interface map in your class definition by using the DECLARE_INTEFACE_MAP() macro as shown above.</p>
<p>
In your implementation file, you need to add the actual interface map data; this is accomplished with the BEGIN_INTERFACE_MAP, INTERFACE_PART, and END_INTERFACE_MAP macros:</p>
<pre><code>BEGIN_INTERFACE_MAP(CDocuments, CCmdTarget)
 &nbsp;&nbsp; INTERFACE_PART(CDocuments, IID_IEnumVARIANT, EnumVARIANT)
END_INTERFACE_MAP()
</code></pre>
<p>
The next step is to implement the member functions of <b>CDocuments::XEnumVARIANT</b>. The implementation found in the MFCOLL sample is given below.</p>
<pre><code>CDocuments::XEnumVARIANT::XEnumVARIANT()
{&nbsp;&nbsp;&nbsp; m_posCurrent = NULL ;&nbsp; }

STDMETHODIMP_(ULONG) CDocuments::XEnumVARIANT::AddRef()
{&nbsp;&nbsp; 
 &nbsp;&nbsp; METHOD_PROLOGUE(CDocuments, EnumVARIANT)
 &nbsp;&nbsp; return pThis-&gt;ExternalAddRef() ;
}&nbsp;&nbsp; 

STDMETHODIMP_(ULONG) CDocuments::XEnumVARIANT::Release()
{&nbsp;&nbsp; 
 &nbsp;&nbsp; METHOD_PROLOGUE(CDocuments, EnumVARIANT)
 &nbsp;&nbsp; return pThis-&gt;ExternalRelease() ;
}&nbsp;&nbsp; 

STDMETHODIMP CDocuments::XEnumVARIANT::QueryInterface( REFIID iid, void FAR* FAR* ppvObj )
{&nbsp;&nbsp; 
 &nbsp;&nbsp; METHOD_PROLOGUE(CDocuments, EnumVARIANT)
 &nbsp;&nbsp; return (HRESULT)pThis-&gt;ExternalQueryInterface( (void FAR*)&amp;iid, ppvObj) ;
}&nbsp;&nbsp; 

// IEnumVARIANT::Next
// 
STDMETHODIMP CDocuments::XEnumVARIANT::Next( ULONG celt, VARIANT FAR* rgvar, ULONG FAR* pceltFetched)
{
 &nbsp;&nbsp; // This sets up the "pThis" pointer so that it points to our
 &nbsp;&nbsp; // containing CDocuments instance
 &nbsp;&nbsp; //
 &nbsp;&nbsp; METHOD_PROLOGUE(CDocuments, EnumVARIANT)

 &nbsp;&nbsp; HRESULT hr;
 &nbsp;&nbsp; ULONG&nbsp;&nbsp; l ;
 &nbsp;&nbsp; CDocument*&nbsp; pItem = NULL ;
 &nbsp;&nbsp; POSITION pos = theApp.m_templateList.GetHeadPosition() ;
 &nbsp;&nbsp; CDocTemplate* pTemplate =(CDocTemplate*)theApp.m_templateList.GetNext(pos) ;

 &nbsp;&nbsp; // pceltFetched can legally == 0
 &nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; if (pceltFetched != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pceltFetched = 0;
 &nbsp;&nbsp; else if (celt &gt; 1)
 &nbsp;&nbsp; {&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode( E_INVALIDARG ) ;&nbsp;&nbsp; 
 &nbsp;&nbsp; }

 &nbsp;&nbsp; for (l=0; l &lt; celt; l++)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VariantInit( &amp;rgvar[l] ) ;

 &nbsp;&nbsp; // Retrieve the next celt elements.
 &nbsp;&nbsp; hr = NOERROR ;
 &nbsp;&nbsp; for (l = 0 ; m_posCurrent != NULL &amp;&amp; celt != 0 ; l++)
 &nbsp;&nbsp; {&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pItem = pTemplate-&gt;GetNextDoc( m_posCurrent ) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; celt-- ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pItem)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgvar[l].vt = VT_DISPATCH ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgvar[l].pdispVal = pItem-&gt;GetIDispatch( TRUE ) ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pceltFetched != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*pceltFetched)++ ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode( E_UNEXPECTED ) ;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (celt != 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = ResultFromScode( S_FALSE ) ;

 &nbsp;&nbsp; return hr ;
}

// IEnumVARIANT::Skip
//
STDMETHODIMP CDocuments::XEnumVARIANT::Skip(unsigned long celt) 
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CDocuments, EnumVARIANT)
 &nbsp;&nbsp; POSITION pos = theApp.m_templateList.GetHeadPosition() ;
 &nbsp;&nbsp; CDocTemplate* pTemplate=(CDocTemplate*)theApp.m_templateList.GetNext(pos) ;

 &nbsp;&nbsp; while (m_posCurrent != NULL &amp;&amp; celt--)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTemplate-&gt;GetNextDoc( m_posCurrent ) ;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; return (celt == 0 ? NOERROR : ResultFromScode( S_FALSE )) ;
}

STDMETHODIMP CDocuments::XEnumVARIANT::Reset()
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CDocuments, EnumVARIANT)
 &nbsp;&nbsp; POSITION pos = theApp.m_templateList.GetHeadPosition() ;
 &nbsp;&nbsp; CDocTemplate* pTemplate=(CDocTemplate*)theApp.m_templateList.GetNext(pos);
 &nbsp;&nbsp; m_posCurrent = pTemplate-&gt;GetFirstDocPosition() ;
 &nbsp;&nbsp; return NOERROR ;
}

STDMETHODIMP CDocuments::XEnumVARIANT::Clone(IEnumVARIANT FAR* FAR* ppenum) 
{
 &nbsp;&nbsp; METHOD_PROLOGUE(CDocuments, EnumVARIANT)&nbsp;&nbsp; 
 &nbsp;&nbsp; CDocuments* p = new CDocuments ;
 &nbsp;&nbsp; if (p)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;m_xEnumVARIANT.m_posCurrent = m_posCurrent ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NOERROR ;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ResultFromScode( E_OUTOFMEMORY ) ;
}
</code></pre>
<p>
The <i>OLE Programmer's Reference</i> (MSDN Library, Product Documentation, SDKs, OLE 2) does a more than adequate job of explaining how the IEnum family of interfaces work, so we won't go into great detail about how the above code works. However, there is one very interesting point that is worth mentioning. You'll note that the first statement in each member function is:</p>
<pre><code>METHOD_PROLOGUE(CDocuments, EnumVARIANT)&nbsp;&nbsp; 
</code></pre>
<p>
The METHOD_PROLOGUE macro facilitates getting a pointer to the containing class from within a nested class. The above example is expanded by the C++ preprocessor to:</p>
<pre><code>CDocuments* pThis = ((CDocuments*)((BYTE*)this - 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CDocuments, m_xEnumVARIANT))); 
</code></pre>
<p>
After this code executes, <i>pThis</i> is pointing to the instance of the containing class. This is a handy way of being able to access a containing class's members from a nested class.</p>
<h2>Collection Samples</h2>
<p>
The following examples illustrate the implementation of OLE Automation collections:
<ul type=disc>
<li>
The XRTFRAME sample, available from the beginning of this article, illustrates implementing OLE Automation collections in MFC.<br><br></li>
<li>
The COLLECT sample in the Microsoft Software Library illustrates implementing collections in straight C++ (sample #S14424).</li>
</ul>
</BODY>
</HTML>
