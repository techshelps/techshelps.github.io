<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Classy Windows</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_classy"></a></sup>Classy Windows</h1>
<p>
Kyle Marsh<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: June 23, 1993</p>
<h2>Abstract</h2>
<p>
Most developers consider window classes a necessary evil. They grab the <b>RegisterClass</b> function from GENERIC or from another starter application, fiddle with the values a little, and then move on. In this article, we will explore the features of window classes and explain how they can benefit an application.</p>
<p>
Specifically, we will discuss:
<ul type=disc>
<li>
What window classes are.<br><br></li>
<li>
What differences exist between system global, application global, and application local classes.<br><br></li>
<li>
What information a class stores.<br><br></li>
<li>
How this information affects the window's behavior.<br><br></li>
<li>
What an application can do with window classes.</li>
</ul>
<h2>Introduction</h2>
<p>
A window class contains information that determines how a window looks and behaves. Every window belongs to a window class. Before you create a window, you must register a class for the window. You may register a window class for exclusive use by your application or for general use by all applications in the system. The Microsoft® Windows™ operating system also registers classes that can be used by all applications in the system.</p>
<h2>Types of Classes</h2>
<p>
Windows provides for three types of window classes:
<ul type=disc>
<li>
System global classes<br><br></li>
<li>
Application global classes<br><br></li>
<li>
Application local classes</li>
</ul>
<h3>System Global Classes</h3>
<p>
When Windows starts, it creates the system global classes for all applications. These classes contain the following familiar standard controls:
<ul type=disc>
<li>
Edit<br><br></li>
<li>
Listbox<br><br></li>
<li>
ComboBox<br><br></li>
<li>
ScrollBar<br><br></li>
<li>
Button<br><br></li>
<li>
Static</li>
</ul>
<p>
The system global classes also include some less familiar classes:
<ul type=disc>
<li>
The class for menus.<br><br></li>
<li>
The class for the desktop window.<br><br></li>
<li>
The class for dialog boxes.<br><br></li>
<li>
The class for the task switch window.<br><br></li>
<li>
The class for icon titles.<br><br></li>
<li>
ComboLBox: The class for the drop-down list box contained in a combo box.<br><br></li>
<li>
MDIClient: The class for multiple-document interface (MDI) client windows.</li>
</ul>
<p>
All Windows-based applications can use the system global classes. An application cannot add classes to, or remove classes from, the system global classes. An application can globally subclass a system class, but subclassing is not recommended because it affects all applications in the system. System global classes are destroyed when Windows shuts down.</p>
<h3>Application Global Classes</h3>
<p>
Application global classes are registered by a dynamic-link library (DLL) or an application, and are available to all applications. These classes are frequently used in the creation of custom controls. When a DLL implements a custom control, it registers an application global class that can be used by all of its client applications. When an application or DLL that registers an application global class exits or is unloaded, the class is automatically removed. Application global classes are registered with the CS_GLOBALCLASS style.</p>
<h3>Application Local Classes</h3>
<p>
The most frequently used window classes are application local classes, which are available only to the application or DLL that registers them. Application local classes are registered without the CS_GLOBALCLASS style.</p>
<h2>What's in a Class and What Use Is It?</h2>
<p>
Let's look at the information a class stores. Here is the window class structure:</p>
<pre><code>typedef struct tagWNDCLASS {&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style;
 &nbsp;&nbsp; WNDPROC&nbsp;&nbsp; lpfnWndProc;
 &nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbClsExtra;
 &nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbWndExtra;
 &nbsp;&nbsp; HINSTANCE hInstance;
 &nbsp;&nbsp; HICON&nbsp;&nbsp;&nbsp;&nbsp; hIcon;
 &nbsp;&nbsp; HCURSOR&nbsp;&nbsp; hCursor;
 &nbsp;&nbsp; HBRUSH&nbsp;&nbsp;&nbsp; hbrBackground;
 &nbsp;&nbsp; LPCSTR&nbsp;&nbsp;&nbsp; lpszMenuName;
 &nbsp;&nbsp; LPCSTR&nbsp;&nbsp;&nbsp; lpszClassName;
} WNDCLASS;
</code></pre>
<p>
where:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Field</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><b>style</b></td>
<td width=75%>Defines features such as window alignment, display context allocation, and double-click processing.</td>
</tr>
<tr valign=top>
<td width=25%><b>lpfnWndProc</b></td>
<td width=75%>Points to the window procedure that processes messages for the windows in the class.</td>
</tr>
<tr valign=top>
<td width=25%><b>cbClsExtra</b></td>
<td width=75%>Specifies the amount of extra memory, in bytes, that Windows should reserve for the class.</td>
</tr>
<tr valign=top>
<td width=25%><b>cbWndExtra</b></td>
<td width=75%>Specifies the amount of extra memory, in bytes, that Windows should reserve for each window in the class.</td>
</tr>
<tr valign=top>
<td width=25%><b>hInstance</b></td>
<td width=75%>Identifies the application or DLL that registered the class.</td>
</tr>
<tr valign=top>
<td width=25%><b>hIcon</b></td>
<td width=75%>Defines the icon Windows displays when a window belonging to the class is minimized.</td>
</tr>
<tr valign=top>
<td width=25%><b>hCursor</b></td>
<td width=75%>Defines the cursor for windows belonging to the class.</td>
</tr>
<tr valign=top>
<td width=25%><b>hbrBackground</b></td>
<td width=75%>Defines the color and pattern Windows uses to fill the client area when the application opens or paints a window belonging to the class.</td>
</tr>
<tr valign=top>
<td width=25%><b>lpszMenuName</b></td>
<td width=75%>Specifies the default menu for windows in the class that do not explicitly define menus.</td>
</tr>
<tr valign=top>
<td width=25%><b>lpszClassName</b></td>
<td width=75%>Identifies the name of the class.</td>
</tr>
</table><br>
<p>
These fields are discussed at length in the following sections.</p>
<h3>Class Styles (style)</h3>
<p>
The <b>style</b> field in the <b>WNDCLASS</b> structure assigns class styles. These styles determine the behavior of windows created from that class. You can use any combination of the values described in the following sections.</p>
<h4>CS_BYTEALIGNCLIENT and CS_BYTEALIGNWINDOW</h4>
<p>
When you use these styles, Windows aligns the windows belonging to the class so that either the client area of the window (<b>CS_BYTEALIGNCLIENT</b>) or the entire window (<b>CS_BYTEALIGNWINDOW</b>) is aligned on byte boundaries. That is, Windows adjusts the horizontal position of the window so that either the client area's or the entire window's left coordinate is evenly divisible by 8. For example, let's see where Windows would place a window with a sizing frame that is 4 pixels wide:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Original window location</b></td>
<td class=label width=37%><b>Placement with CS_BYTEALIGNWINDOW</b></td>
<td class=label width=38%><b>Placement with CS_BYTEALIGNCLIENT</b></td>
</tr>
<tr valign=top>
<td width=25%>0,y</td>
<td width=37%>0,y</td>
<td width=38%>4,y</td>
</tr>
<tr valign=top>
<td width=25%>1,y</td>
<td width=37%>0,y</td>
<td width=38%>4,y</td>
</tr>
<tr valign=top>
<td width=25%>2,y</td>
<td width=37%>0,y</td>
<td width=38%>4,y</td>
</tr>
<tr valign=top>
<td width=25%>3,y</td>
<td width=37%>0,y</td>
<td width=38%>4,y</td>
</tr>
<tr valign=top>
<td width=25%>4,y</td>
<td width=37%>8,y</td>
<td width=38%>4,y</td>
</tr>
<tr valign=top>
<td width=25%>5,y</td>
<td width=37%>8,y</td>
<td width=38%>4,y</td>
</tr>
<tr valign=top>
<td width=25%>6,y</td>
<td width=37%>8,y</td>
<td width=38%>4,y</td>
</tr>
<tr valign=top>
<td width=25%>7,y</td>
<td width=37%>8,y</td>
<td width=38%>4,y</td>
</tr>
<tr valign=top>
<td width=25%>8,y</td>
<td width=37%>8,y</td>
<td width=38%>12,y</td>
</tr>
<tr valign=top>
<td width=25%>9,y</td>
<td width=37%>8,y</td>
<td width=38%>12,y</td>
</tr>
<tr valign=top>
<td width=25%>10,y</td>
<td width=37%>8,y</td>
<td width=38%>12,y</td>
</tr>
<tr valign=top>
<td width=25%>11,y</td>
<td width=37%>8,y</td>
<td width=38%>12,y</td>
</tr>
<tr valign=top>
<td width=25%>12,y</td>
<td width=37%>16,y</td>
<td width=38%>12,y</td>
</tr>
<tr valign=top>
<td width=25%>13,y</td>
<td width=37%>16,y</td>
<td width=38%>12,y</td>
</tr>
<tr valign=top>
<td width=25%>14,y</td>
<td width=37%>16,y</td>
<td width=38%>12,y</td>
</tr>
<tr valign=top>
<td width=25%>15,y</td>
<td width=37%>16,y</td>
<td width=38%>12,y</td>
</tr>
<tr valign=top>
<td width=25%>16,y</td>
<td width=37%>16,y</td>
<td width=38%>20,y</td>
</tr>
</table><br>
<p>
The CS_BYTEALIGNCLIENT and CS_BYTEALIGNWINDOW styles have no effect under two circumstances:
<ul type=disc>
<li>
If the display driver uses 8 or more bits per pixel, byte alignment provides no benefits. In this case, Windows ignores the CS_BYTEALIGNCLIENT and CS_BYTEALIGNWINDOW styles when moving or creating a window.<br><br></li>
<li>
If you use the <b>SetWindowPos</b> function to change the window's position, the function bypasses the alignment check that enforces the CS_BYTEALIGNCLIENT and CS_BYTEALIGNWINDOW styles. The documentation for WM_WINDOWPOSCHANGING in the Windows version 3.1 Software Development Kit (SDK) is misleading; it says:<p class=tl>
"For a window with the WS_OVERLAPPED or WS_THICKFRAME style, the <b>DefWindowProc</b> function handles a WM_WINDOWPOSCHANGING message by sending a WM_GETMINMAXINFO message to the window. This is done to validate the new size and position of the window and <i>to enforce the CS_BYTEALIGNCLIENT and CS_BYTEALIGN </i>[sic]<i> client styles</i>." (Italics are mine.)</P><p class=tl>
When <b>DefWindowProc</b> receives a WM_WINDOWPOSCHANGING message, it does send the window a WM_GETMINMAXINFO message, but does not enforce the byte alignment styles. To ensure byte alignment with the CS_BYTEALIGNCLIENT and CS_BYTEALIGNWINDOW styles, an application must adjust its horizontal position whenever:</P><ul type=disc>
<li>
Windows sends the window a WM_WINDOWPOSITIONCHANGING message.<br><br></li>
<li>
Windows sends the window a WM_GETMINMAXINFO message.<br><br></li>
<li>
The application calls <b>SetWindowPos</b> to position the window.</li>
</ul>
</li>
</ul>
<p>
CS_BYTEALIGNCLIENT and CS_BYTEALIGNWINDOW were once instrumental in getting the best performance for an application, especially in versions of Windows before 3.0. In those days, the system fonts all had fixed widths, and Windows could optimize text display on byte-aligned windows. This benefit vanished with Windows version 3.0.</p>
<p>
An application that uses the <b>BitBlt</b> function to copy pixels from one window to another window or from a source rectangle in a window to a target rectangle in the same window can set the CS_BYTEALIGNCLIENT style for better performance. By aligning the client area on a byte boundary, the application can ensure that <b>BitBlt</b> operations occur on byte-aligned rectangles. <b>BitBlt</b> operations on byte-aligned rectangles are considerably faster than <b>BitBlt</b> operations on rectangles that are not byte aligned. However, byte alignment affects only the left side of a window. To take maximum advantage of byte alignment, the application must also byte-align the width of the window.</p>
<p>
As the number of displays and video cards that are capable of 256 or more colors increases, the need for byte alignment diminishes. 256-color display drivers are already byte aligned. In fact, some 16-color drivers are byte aligned as well. One of my computers has an ATI Graphics Ultra Pro display driver. While researching the byte-alignment style bits, I set my driver to 16 colors and expected to see the position of my window change depending on the style bits I used. Much to my suprise, the alignment bits had no effect. After much bewilderment, I discovered that the ATI video driver uses 8 bits per pixel for its 16-color mode. Switching to the standard VGA 16-color driver produced the window-alignment positioning I expected. I don't know how common using 8 bits per pixel for 16-color mode is, but this is an indication that the byte-alignment styles are losing their importance.</p>
<p>
If you use both styles, CS_BYTEALIGNWINDOW overrides CS_BYTEALIGNCLIENT. The dialog class has the CS_BYTEALIGNWINDOW style.</p>
<h4>CS_OWNDC, CS_CLASSDC, and CS_PARENTDC</h4>
<p>
These styles determine the default display context for the windows created from a class.
<ul type=disc>
<li>
If you use the CS_OWNDC style for a class, each window in that class has its own display context (called a <i>private display context</i>). Windows stores each display context in GDI's (graphics device interface) local heap, which is limited to 64K. Each window instance that has the CS_OWNDC style takes up about 800 bytes of this precious memory space, so you should use the CS_OWNDC class style sparingly. The private display context is unique to a window instance, so an application needs to obtain the context handle only once, by calling either <b>GetDC</b> or <b>BeginPaint</b>. Windows initializes each window's display context and saves any changes the application makes. The <b>ReleaseDC</b> and <b>EndPaint</b> functions are not needed because other applications cannot access the display context. When CS_OWNDC is in effect, an application should be careful about changing the mapping mode. When Windows erases a background for a window, it assumes that the current mapping mode is MM_TEXT. If the mapping mode for the private display context is different, the area that Windows erases may not be visible.<br><br></li>
<li>
If you use the CS_CLASSDC style for a class, the windows in that class share the same display context (called the <i>class display context</i>). Class display contexts offer some of the benefits of private display contexts but save resources because you use a single display context for all windows in a class instead of separate display contexts with 800 bytes per window instance. Each window instance retrieves the context handle with <b>GetDC</b> or <b>BeginPaint</b> but does not have to release the context with <b>ReleaseDC</b> or <b>EndPaint</b> until another window instance needs the display context. Changes that one window instance makes to the selections in the display context are effective for all other window instances except for the clipping region and device origin, which are adjusted for each window during a call to <b>GetWindowDC</b>, <b>GetDC</b>, <b>GetDCEx</b>, or <b>BeginPaint</b>. As with CS_OWNDC, you must ensure that the mapping mode is MM_TEXT; otherwise, the background area erased by Windows may not be visible.<br><br></li>
<li>
If you use the CS_PARENTDC style for a class, each window in that class uses its parent window's display context. CS_PARENTDC is similar to CS_CLASSDC in that multiple windows share one display context. In CS_PARENTDC, however, the windows that share the display context need not belong to the same class. All standard Window controls have the CS_PARENTDC style. Thus, an edit control and list box in a dialog box share the same display context—that of the dialog box itself. The benefits of CS_PARENTDC can be summed up with one word: speed. Windows keeps five common display contexts in memory (see the next paragraph). When a window (for example, a dialog box) has more than five child windows (let's say it has six edit controls), the display context cache loses its effectiveness. For each child window, the application must reinitialize a display context with the clipping region and device origin. If the child windows share their parent's display context, the display context will be found in the cache more often. This saves a lot of time and is why standard Windows controls use CS_PARENTDC. Another outcome of the CS_PARENTDC style is that child windows can draw anywhere in their parent's client area as well as drawing in their own client area. The CTL3D library, which creates 3-D effects around edit controls and list boxes, relies on this behavior. An application should not use CS_PARENTDC if it needs to adjust the mapping modes for different child windows. This will negate much of the benefit and could cause problems ensuring that each child window has the correct mapping mode set.<br><br></li>
<li>
If you do not use CS_OWNDC, CS_CLASSDC, or CS_PARENTDC for a class, the windows in that class use one of the <i>common display contexts</i> Windows keeps cached for general use. Common display contexts are retrieved and released with each use. Each context is initialized with the default selections each time a display context is retrieved, unless the display context for the window is still in the Windows display context cache. In this case, the clipping region and device origin need not be reinitialized, thus saving time.</li>
</ul>
<p>
To bypass the default display context for a window, applications can use the <b>GetDCEx</b> function and specify a flag of DCX_CACHE. This function overrides the CS_OWNDC and CS_CLASSDC styles and returns a common display context.</p>
<p>
The <b>ScrollWindow</b> and <b>ScrollWindowEx</b> functions handle display contexts in different ways:
<ul type=disc>
<li>
<b>ScrollWindow</b> uses the default display context for a window. Thus, if a window has the CS_OWNDC or CS_CLASSDC style, <b>ScrollWindow</b> uses the appropriate display context. The coordinates passed to <b>ScrollWindow</b> must be in the correct mapping mode for the display context.<br><br></li>
<li>
<b>ScrollWindowEx</b> always uses a common display context, regardless of the window style in effect. The coordinates passed to <b>ScrollWindowEx</b> must always be in client coordinates from the default MM_TEXT mapping mode.</li>
</ul>
<h4>CS_DBLCLKS</h4>
<p>
The CS_DBLCLKS style causes Windows to detect a double-click (the user clicking the left mouse button twice in quick succession) for an application. Here is how Windows responds to a double-click event:
<ul type=disc>
<li>
If a window does not have the CS_DBLCLKS style, Windows sends the following message sequence to the window: WM_LBUTTONDOWN, WM_LBUTTONUP, WM_LBUTTONDOWN, and WM_LBUTTONUP.<br><br></li>
<li>
If a window does have the CS_DBLCLKS style, Windows sends the following message sequence: WM_LBUTTONDOWN, WM_LBUTTONUP, WM_LBUTTONDBLCLK, and WM_LBUTTONUP. That is, the second WM_LBUTTONDOWN message is replaced by a WM_LBUTTONDBLCLK message.</li>
</ul>
<p>
Other messages may be mixed within these message sequences, so an application should not rely on the messages being contiguous.</p>
<p>
An application can detect a double-click event without using the CS_DBLCLKS style. See Dr. GUI's "Simulating Mouse Button Clicks" article on the Microsoft Developer Network CD (Technical Articles, Ask Dr. GUI, Ask Dr. GUI #5).</p>
<p>
All standard Windows controls have the CS_DBLCLKS style except for static controls, the dialog class, and the desktop class. Custom controls must have this style in order to work with the Dialog Editor.</p>
<h4>CS_GLOBALCLASS</h4>
<p>
CS_GLOBALCLASS is the only style that applies only to the window class and not to individual windows created from the class. Windows stores classes with the CS_GLOBALCLASS style as application global classes. These classes are available to all applications and DLLs; they are not available exclusively to the application or DLL that registered the class. An application global class is most commonly used for custom controls that are implemented in a DLL. The class is destroyed when the application or DLL that created the class exits or is unloaded, or when the <b>UnregisterClass</b> function is called. All windows created from an application global class must be closed before the application that registered the class exits (this happens automatically for DLLs).</p>
<h4>CS_HREDRAW and CS_VREDRAW</h4>
<p>
The CS_HREDRAW style causes a window to be completely redrawn whenever its horizontal size (width) changes. The CS_VREDRAW style causes a window to be completely redrawn whenever its vertical size (height) changes. Buttons and scroll bars have these styles.</p>
<h4>CS_NOCLOSE</h4>
<p>
A window that belongs to a class with the CS_NOCLOSE style does not have the Close command in its System menu. In Windows version 3.0, multiple-document interface (MDI) child windows ignore the CS_NOCLOSE style. This problem was fixed in Windows version 3.1.</p>
<h4>CS_SAVEBITS</h4>
<p>
Menus, dialog boxes, and combo list boxes have the CS_SAVEBITS style. When you use this style for a window, Windows saves a bitmap copy of the screen image that the window obscures. First, Windows asks the display driver to save the bits. If the display driver has enough memory, it saves the bits for Windows. If the display driver does not have enough memory, Window saves the bits itself as a bitmap in global memory and also uses some of User's local heap for housekeeping structures for each window. When the application removes the window, Windows can restore the screen image quickly by using the stored bits.</p>
<p>
The effectiveness of the CS_SAVEBITS style can be difficult to gauge. CS_SAVEBITS improves performance for temporary windows such as menus and dialog boxes. However, a significant amount of overhead is involved in storing the bits, especially if Windows stores the bits instead of the display driver. The benefit to using CS_SAVEBITS really depends on what happens to the area under the window. If the area is complex and requires a lot of effort to redraw, storing the bits is probably easier than redrawing the screen. On the other hand, if the area under the window can be redrawn quickly or changes a lot while it is obscured, the effort to save the bits can hurt overall performance.</p>
<h3>The Window Procedure (lpfnWndProc)</h3>
<p>
The <b>lpfnWndProc</b> field in the <b>WNDCLASS</b> structure contains the address of the window procedure for all windows belonging to the class. Windows sends all messages pertaining to windows created from the class to this procedure. The window procedure provides the functionality for these windows. An application can use the <b>SetClassLong</b> function to change the window procedure address for all classes. This process is called <i>subclassing</i> (more specifically, <i>global subclassing</i>). When an application changes the address, all windows created after the <b>SetClassLong</b> call use the new window procedure address. Windows created before the <b>SetClassLong</b> call continue to use the original window procedure, and are unaffected by the global subclass.</p>
<p>
When an application or DLL subclasses a window or set of windows, it must export the new window procedure in its module definition file. An application must use <b>MakeProcInstance</b> to get the procedure address and pass it to <b>SetClassLong</b>. An application can also use compiler switches on newer compilers (for example, the C/C++ version 7.0 or Visual C++ version 1.0 compiler) to export window procedures without calling <b>MakeProcInstance</b>.</p>
<h3>Extra Class and Window Bytes (cbClsExtra and cbWndExtra)</h3>
<p>
The <b>cbClsExtra</b> and <b>cbWndExtra</b> fields in the <b>WNDCLASS</b> structure specify the number of extra bytes Windows will allocate for each class (<b>cbClsExtra</b>) and for each instance of a window from the class (<b>cbWndExtra</b>). These fields must be set to zero if an application does not require extra class or window bytes. If you accidentally use an unreasonably large value for one of these fields, Windows uses that value to allocate extra bytes. I suggest that you use no more than 4 extra bytes per class or window. If you use a higher value, Windows will allocate the extra bytes from User's heap, and will thus run out of system resources quickly. If your application needs more space, you should allocate a block from either the local heap or the global heap, and then store a pointer or handle to the block in the extra bytes. For example, the toolbar sample uses the following code to store the data for each toolbar instance:</p>
<pre><code>#ifdef WIN32
#define SETWINDOWPOINTER(hwnd, name, p)&nbsp;&nbsp;&nbsp; SetWindowLong(hwnd, 0, (WORD)p)
#define GETWINDOWPOINTER(hwnd, name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((name)GetWindowLong(hwnd, 0))
#define ALLOCWINDOWPOINTER(name, size)&nbsp;&nbsp;&nbsp; ((name)malloc(size))
#define FREEWINDOWPOINTER(p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(p)
#else
#define SETWINDOWPOINTER(hwnd, name, p)&nbsp;&nbsp; SetWindowWord(hwnd, 0, (WORD)p)
#define GETWINDOWPOINTER(hwnd, name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((name)GetWindowWord(hwnd, 0))
#define ALLOCWINDOWPOINTER(name, size)&nbsp;&nbsp;&nbsp; ((name)LocalAlloc(LPTR, size))
#define FREEWINDOWPOINTER(p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalFree((HLOCAL)p)
#endif

LRESULT CALLBACK ToolbarWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPARAM lParam)
{
 &nbsp;&nbsp; BOOL fSameButton;
 &nbsp;&nbsp; PTBBUTTON ptbButton;
 &nbsp;&nbsp; PTBHDR pTBHdr;
 &nbsp;&nbsp; int iPos;
 &nbsp;&nbsp; BYTE fsState;

 &nbsp;&nbsp; pTBHdr = GETWINDOWPOINTER(hWnd, PTBHDR);

 &nbsp;&nbsp; switch (wMsg) {
 &nbsp;&nbsp; case WM_CREATE:

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
      &nbsp;&nbsp;&nbsp; // Create the state data for this toolbar. 

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTBHdr = ALLOCWINDOWPOINTER(PTBHDR, sizeof(TBHDR)-sizeof(TBBUTTON));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!pTBHdr)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The structure is initialized to all NULL when created.

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTBHdr-&gt;hwndCommand = lpcs-&gt;hwndParent;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SETWINDOWPOINTER(hWnd, PTBHDR, pTBHdr);
 &nbsp; break;

 &nbsp;&nbsp; case WM_DESTROY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pTBHdr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FREEWINDOWPOINTER(pTBHdr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SETWINDOWPOINTER(hWnd, PTBHDR, 0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
 &nbsp; break;

 &nbsp; case WM_PAINT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ToolbarPaint(hWnd, pTBHdr);
 &nbsp; break;
.
.
.
}
</code></pre>
<p>
If an application registers a dialog box created with the <b>CLASS</b> statement, it must set <b>cbWndExtra</b> to DLGWINDOWEXTRA—the Dialog Manager requires these extra bytes.</p>
<h3>Instance Handle (hInstance)</h3>
<p>
The <b>hInstance</b> field in the <b>WNDCLASS</b> structure identifies the module for the class. This field must be an instance handle and must not be NULL.</p>
<h3>Class Icon (hIcon)</h3>
<p>
The <b>hIcon</b> field in the <b>WNDCLASS</b> structure identifies the icon for the class. An application generally uses <b>LoadIcon</b> to retrieve a handle either to a standard Windows icon (such as IDI_APPLICATION) or to a custom icon. If <b>hIcon</b> is set to NULL, the application draws its own icon when Windows sends the application a WM_ICONERASEBKGND message.</p>
<h3>Class Cursor (hCursor)</h3>
<p>
The <b>hCursor</b> field in the <b>WNDCLASS</b> structure specifies the cursor for all windows belonging to the class. When you use this field, Windows changes the system cursor to the class cursor whenever the system cursor moves into a window from the class. An application generally uses the <b>LoadCursor</b> function to load either a standard system cursor (normally IDC_ARROW) or a custom cursor for the application. Applications can change cursors whenever required by calling the <b>SetCursor</b> function. If the class is not assigned a cursor (that is, <b>hCursor</b> is set to NULL), the application must set the cursor whenever the system cursor moves into the window.</p>
<h3>Class Background Brush (hbrBackground)</h3>
<p>
The <b>hbrBackground</b> field in the <b>WNDCLASS</b> structure identifies the class background brush. You can specify either a handle to the physical brush to be used for painting the background or a color value. If you assign a color value, you must use one of the standard system colors listed below plus 1. (For example, COLOR_BACKGROUND + 1 specifies the system background color.)</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=44%>COLOR_ACTIVEBORDER</td>
<td width=56%>COLOR_HIGHLIGHTTEXT </td>
</tr>
<tr valign=top>
<td width=44%>COLOR_ACTIVECAPTION</td>
<td width=56%>COLOR_INACTIVEBORDER </td>
</tr>
<tr valign=top>
<td width=44%>COLOR_APPWORKSPACE</td>
<td width=56%>COLOR_INACTIVECAPTION </td>
</tr>
<tr valign=top>
<td width=44%>COLOR_BACKGROUND</td>
<td width=56%>COLOR_INACTIVECAPTIONTEXT </td>
</tr>
<tr valign=top>
<td width=44%>COLOR_BTNFACE</td>
<td width=56%>COLOR_MENU</td>
</tr>
<tr valign=top>
<td width=44%>COLOR_BTNSHADOW</td>
<td width=56%>COLOR_MENUTEXT </td>
</tr>
<tr valign=top>
<td width=44%>COLOR_BTNTEXT</td>
<td width=56%>COLOR_SCROLLBAR</td>
</tr>
<tr valign=top>
<td width=44%>COLOR_CAPTIONTEXT</td>
<td width=56%>COLOR_WINDOW </td>
</tr>
<tr valign=top>
<td width=44%>COLOR_GRAYTEXT</td>
<td width=56%>COLOR_WINDOWFRAME</td>
</tr>
<tr valign=top>
<td width=44%>COLOR_HIGHLIGHT</td>
<td width=56%>COLOR_WINDOWTEXT</td>
</tr>
</table><br>
<p>
If you assign a color value, you must cast it to an HBRUSH type:</p>
<pre><code>cls.hbrBackground&nbsp;&nbsp; = (HBRUSH)(COLOR_WINDOW+1);
</code></pre>
<p>
When the <b>hbrBackground</b> field is set to NULL, the application must paint its own background whenever Windows sends it a WM_PAINT message. The application can determine when the background needs painting by processing the WM_ERASEBKGND message or by testing the <b>fErase</b> member of the <b>PAINTSTRUCT</b> structure filled by the <b>BeginPaint</b> function.</p>
<h3>Class Menu (lpszMenuName)</h3>
<p>
The <b>lpszMenuName</b> field in the <b>WNDCLASS</b> structure identifies the menu for the class. The class menu is added to each window created from the class unless another menu is specified when the window is created with <b>CreateWindow</b> or <b>CreateWindowEx</b>. The <b>lpszMenuName</b> field points to a null-terminated string that specifies the resource name of the class menu (as the name appears in the resource file). If an integer is used to identify the menu, the application can use the MAKEINTRESOURCE macro. If <b>lpszMenuName</b> is NULL, windows belonging to this class have no default menu.</p>
<h3>Class Name (lpszClassName)</h3>
<p>
The <b>lpszClassName</b> field in the <b>WNDCLASS</b> structure identifies the class name. Class names must be unique within each class type for an application. Thus, all local classes within an application must have unique names, but two applications may have local classes with the same name. For example, two applications can have separate "MainWnd" classes. Global class names must be unique across global classes and system classes. For example, an application can register a local class with the name "Edit", but cannot create a global class with that name.</p>
<h2>How Does Windows Locate a Class?</h2>
<p>
When an application creates a window with a specified class, Windows uses the following procedure to find the class:
<ol>
<li>
Windows searches for a local class with the specified name.<br><br></li>
<li>
If Windows does not find a local class with the name, it searches the global class list.<br><br></li>
<li>
If Windows does not find the name in the global class list, it searches the system class list.</li>
</ol>
<p>
Windows uses this procedure for all windows created by the application, including windows created by Windows on the application's behalf, such as dialog boxes. It is possible, then, to override system global classes without affecting other applications. (I will discuss this in the "Local Superclassing" section later in this article.)</p>
<h2>What Can I Do with Classes?</h2>
<p>
Once you register a class, there is usually little you need to do with it except create windows from the class. However, you may want to access class information, subclass the class, or superclass the class, as described in the following sections.</p>
<h3>Class Access Functions</h3>
<p>
If you want to examine or change the information for a class, you may use the following functions:
<ul type=disc>
<li>
<b>GetClassLong</b> reads a long value (for example, the class window procedure address) from the class information.<br><br></li>
<li>
<b>SetClassLong</b> writes a long value to the class information. For example, writing a new class window procedure subclasses the class.<br><br></li>
<li>
<b>GetClassWord</b> reads a word value from the class information. For example, the following call returns the number of extra bytes for a class:<pre><code>nClassExtra = GetClassWord(hwnd, GCW_CBCLSEXTRA );
</code></pre>
</li>
<li>
<b>SetClassWord</b> writes a word value to the class information, for example, to change the class icon.<br><br></li>
<li>
<b>GetClassName</b> retrieves the name of a class.<br><br></li>
<li>
<b>GetClassInfo</b> retrieves all the information about a class except the class name and the class menu name.</li>
</ul>
<h3>Subclassing</h3>
<p>
The term <i>subclassing</i> describes the process of substituting one window procedure for another. <i>Instance subclassing</i> (or subclassing a window) uses the <b>SetWindowLong</b> function to change the window procedure for a particular window instance. <i>Global subclassing</i> (or subclassing a class) uses the <b>SetClassLong</b> function to substitute a new window procedure for the window procedure in a class.</p>
<h3>Superclassing</h3>
<p>
<i>Superclassing</i> involves creating a new class that uses the window procedure of an existing class for basic functionality.</p>
<p>
For more information on subclassing and superclassing, see the "Safe Subclassing" article on the Microsoft Developer Network CD (Technical Articles, Windows Articles, Window Manager Articles).</p>
<h3>Local Superclassing</h3>
<p>
You can use superclassing to effectively subclass all windows in a global class for an application. (This aspect of superclassing is not discussed in the "Safe Subclassing" article.) For example, if an application needs to subclass all of the list boxes it creates, it must call <b>SetWindowLong</b> after creating each list box. Determining where an application creates a list box can involve significant code and effort. Moreover, if the need to subclass the list boxes is eliminated, all the subclassing code must be ripped out.</p>
<p>
Another way to accomplish the same objective is to superclass the list box class. Normally, superclassing registers a class with a new name so that the application can create windows from either the new superclass or the original class. In local superclassing, however, the application registers a new local class with the original class name ("Listbox"), which is actually a system class name. In this case, Windows searches local classes for "Listbox" before searching global or system classes. As a result, Windows creates all list boxes for the application from the local class, effectively subclassing all list boxes for the application. The following code illustrates local superclassing for an edit control:</p>
<pre><code>WNDPROC lpfnEditClassProc = NULL;

LRESULT CALLBACK LocalEdit_WndProc(HWND hwnd, UINT msg, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WPARAM wParam, LPARAM lParam)
{
 &nbsp; if (msg == WM_CHAR ) {
 &nbsp;&nbsp;&nbsp; MessageBeep(-1);
 &nbsp; }
 &nbsp; return CallWindowProc(lpfnEditClassProc, hwnd, msg, wParam, lParam);
}

BOOL CreateLocalEditClass()
{
 &nbsp; WNDCLASS wc;

 &nbsp; if ( lpfnEditClassProc == NULL ) {
 &nbsp;&nbsp;&nbsp;&nbsp; GetClassInfo(NULL, "Edit", &amp;wc);
 &nbsp;&nbsp;&nbsp;&nbsp; lpfnEditClassProc = (WNDPROC) wc.lpfnWndProc;
 &nbsp;&nbsp;&nbsp;&nbsp; wc.lpfnWndProc = LocalEdit_WndProc;
 &nbsp;&nbsp;&nbsp;&nbsp; wc.lpszClassName&nbsp;&nbsp; = "Edit";
 &nbsp;&nbsp;&nbsp;&nbsp; wc.hInstance = _hInstance;
 &nbsp;&nbsp;&nbsp;&nbsp; if (!RegisterClass(&amp;wc))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;

 &nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
 &nbsp; }
}

void DeleteLocalEditClass()
{
 &nbsp; if ( lpfnEditClassProc != NULL ) {
 &nbsp;&nbsp;&nbsp;&nbsp; UnregisterClass("Edit", _hInstance);
 &nbsp;&nbsp;&nbsp;&nbsp; lpfnEditClassProc = NULL;
 &nbsp; }
}
</code></pre>
<p>
Note that none of the style bits needed changing because the system classes do not have the CS_GLOBALCLASS style set. Windows manages these classes differently from classes registered by other applications. If an application locally superclasses an application global class, the CS_GLOBALCLASS style must be removed.</p>
<p>
The edit control represents a special case for local superclassing. Edit controls can be created with a different instance handle that is passed to <b>CreateWindow</b> or <b>CreateWindowEx</b>. Individual instance handles allow each edit control to have a separate local heap, so it can accommodate the maximum number of characters. If you use a different instance handle for an edit control, Windows creates the control from the system class—not from the local superclass. By default, a dialog box uses a different instance handle for edit controls. The dialog box must use the DS_LOCALEDIT dialog style as follows to superclass its edit controls locally:</p>
<pre><code>IDD_LOCAL DIALOG DISCARDABLE&nbsp; 0, 0, 241, 108
STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | 
 &nbsp;&nbsp;&nbsp;&nbsp; WS_CAPTION | WS_SYSMENU | DS_LOCALEDIT
CAPTION "Local SuperClassed Controls"
FONT 8, "MS Sans Serif"
BEGIN
 &nbsp;&nbsp; DEFPUSHBUTTON&nbsp;&nbsp; "OK",IDOK,185,6,50,14
 &nbsp;&nbsp; PUSHBUTTON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Cancel",IDCANCEL,185,23,50,14
 &nbsp;&nbsp; EDITTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDC_EDIT1,65,5,115,14,ES_AUTOHSCROLL
 &nbsp;&nbsp; LTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Numbers",IDC_STATIC,30,5,30,8
 &nbsp;&nbsp; EDITTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDC_EDIT2,65,31,115,14,ES_AUTOHSCROLL
 &nbsp;&nbsp; LTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Letters",IDC_STATIC,36,31,24,8
 &nbsp;&nbsp; EDITTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDC_EDIT3,65,57,115,14,ES_AUTOHSCROLL
 &nbsp;&nbsp; LTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Both",IDC_STATIC,44,57,16,8
 &nbsp;&nbsp; EDITTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDC_EDIT4,65,83,115,14,ES_AUTOHSCROLL
 &nbsp;&nbsp; LTEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Regular",IDC_STATIC,33,83,27,8
END
</code></pre>
<p>
If an application wants to locally superclass edit controls that do not appear in a dialog box, the application must create the edit controls with the application's instance.</p>
<h3>The Perils of Local Superclassing</h3>
<p>
If you're using local superclassing in your application, you should be aware of the following issues:
<ul type=disc>
<li>
<b>Access screen readers.</b> Some handicapped access screen readers check the class name or class atom of windows to identify the standard Windows controls. When they find a standard Windows control, the access screen reader can give the blind user additional information from the control. For example, these devices know how Windows draws default buttons and they add this information when voicing the button's contents. They can also voice the selected item and the focus item for list boxes. Users may lose this benefit if you re-register the control class.<br><br></li>
<li>
<b>Parameter validation.</b> When the new local superclass procedure calls the control's original window procedure, Windows does not validate the parameters because parameter validation for window procedures is implemented in <b>SendMessage</b>. Normally, when an application sends a messsage to a Windows control, Windows validates the parameters for all messages that have a WM_USER or higher identifier to prevent GP faults. When a class is locally superclassed, <b>SendMessage</b> determines that the control isn't a standard Windows control, so no validation is performed.<br><br></li>
<li>
<b>Freeing memory.</b> When an application exits or GP faults, Windows does not automatically free all the memory used by the application for standard controls. Normally, if an application terminates without explicitly destroying a window, Windows will free any memory allocated in its heaps for controls it knows about. For example, an edit control allocates memory in User's data segment for its own use. When an application exits, this memory is freed. However, if the edit control is locally superclassed, the memory will not be freed unless the application calls <b>DestroyWindow</b> for the locally superclassed edit control or one of its parents. This is especially a problem when an application GP faults, because the application is unable to call <b>DestroyWindow</b>.</li>
</ul>
</BODY>
</HTML>
