<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>An Extended Introduction to Schedule+ OLE Automation Programming</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_schpext"></a>An Extended Introduction to Schedule+ OLE Automation Programming</h1>
<p>
Ken Lassesen<br>
Microsoft Developer Network Technology Group</p>
<p>
January 23, 1996</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4589">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the SPLFORM sample application.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4590">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files in the SPMFORM sample application.</a></p>
<p>
<OBJECT id=sample3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4588">
</OBJECT><a href="javascript:sample3.Click()">Click to open or copy the files in the SAUFORM sample application.</a></p>
<h2>Abstract</h2>
<p>
This article describes the Microsoft® Schedule+ 95 OLE Automation server using Microsoft Visual Basic® for Applications. Three sample applications accompany the article.</p>
<h2>Turbo-Charged Schedule+</h2>
<p>
The most important features of Microsoft® Schedule+ for Windows® 95 are the result of its design as an OLE Automation–centric application. These features include the use of recursive and overloaded objects. Features? Am I using the term in the sense familiar to programmers—as another way of saying "bugs"?</p>
<p>
When I started working with Schedule+, I found the product extremely frustrating. I assumed that it would work like other OLE Automation servers such as Microsoft Excel, the Data Access Object (DAO), or Microsoft SQL Distributed Data Management Objects (SQL-DMO). After redecorating my office walls with the impression of my forehead, I began to understand that this OLE Automation server was different—and perhaps better. If a <i>bug</i> is anything in a program that frustrates a developer, a <i>feature</i> is anything that makes it possible to do more than expected. This article explains these OLE Automation features of Schedule+ and their logic. So get a latte, put up your feet, and get ready to learn.</p>
<h3>Types of OLE Automation Servers</h3>
<p>
Traditionally, OLE Automation servers have centered on the user interface (UI). Some OLE Automation servers (for example, DAO and SQL-DMO) are pure servers without a UI. Schedule+ is neither of these types; instead, it is an OLE Automation–centric application server. </p>
<p>
By <i>UI-centric application</i> I mean an application in which the OLE Automation command set is a subset of the capabilities available in the UI. OLE Automation is added <i>after</i> the application is created. The command set mimics user keystrokes or dynamic data exchange (DDE) commands.</p>
<p>
Pure servers have no UI independent of OLE Automation. Pure servers usually reside in dynamic-link libraries (DLLs) and are in-process servers. </p>
<p>
The UI of OLE Automation–centric servers is created <i>after</i> the OLE Automation engine. The UI becomes a shell around the OLE Automation server. Typically this results in the UI capabilities being a subset of the OLE Automation command set. In other words, you can do things with OLE Automation that you can never see in the UI or change from the UI. Schedule+ is an OLE Automation–centric server.</p>
<p>
A hybrid server is also possible but is rarely seen. Figure 1 shows the relationship between the OLE Automation capabilities and the UI capabilities.</p>
<p>
<img src="schpext_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Relationships between the UI and OLE Automation capabilities of applications</b></p>
<h3>Recursive and Overloaded Objects</h3>
<p>
Schedule+ uses object overloading (one class is used for many named objects) to create a single OLE Automation server. Many of the objects in the Schedule+ OLE Automation model are represented by the overloaded <b>Item</b> object or the <b>Table</b> class. I refer to these overloaded objects as the <b>Item</b> class and <b>Table</b> class (these objects could also be called <i>object types </i>or <i>object classes</i>). The term <i>class</i> helps to distinguish objects from Schedule+ objects. The Microsoft Exchange Server Software Development Kit (SDK) documentation describes objects named as <b>Contact</b> or <b>Project</b> with different lists of properties. Actually, <b>Contact </b>and <b>Project</b> objects are both <b>Item </b>classes with identical sets of properties. </p>
<p>
The Exchange SDK documentation describes some <b>Item</b> classes as having <b>Exceptions</b> objects and <b>Attendees </b>objects. These objects are <b>Table</b> classes that consist of <b>Item</b> classes. Because all <b>Item</b> classes include <b>Table </b>classes, <b>Item</b> classes and <b>Table</b> classes are recursive. Figure 2 illustrates this recursion with the abstract classes and some Schedule+ objects.</p>
<p>
<img src="schpext_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Examples of recursion in Schedule+</b></p>
<p>
You may jump to the conclusion that Schedule+ is a hierarchical database. It is not a classic hierarchical database: Hierarchical databases have a finite depth of child elements, whereas Schedule+ has no bounds on the depth of child elements. Hierarchical databases have a static number of fields in a record; Schedule+ has a dynamic number of fields (accessed through the oxymoronic <b>Properties </b><i>method</i>). </p>
<p>
<img src="schpext_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Data map of a Schedule+ Table</b></p>
<p>
Figure 3 illustrates the internal data map of a Schedule+ <b>Table.</b> This type of structure cannot be easily implemented in Microsoft Access or Microsoft SQL Server. The structure is closer to that of an object-oriented database.</p>
<p>
The structural design of Schedule+ allows for elegant and powerful solutions. This power, however, requires a few changes in how developers think about OLE Automation. In order to understand the design, we must look at three extended maps of Schedule+.</p>
<h3>Extended Maps of Schedule+</h3>
<p>
The Schedule+ OLE Automation server has three views, each represented by a different map. These maps are: 
<ul type=disc>
<li>
The Schedule+ object library (SPL) extended map<br><br></li>
<li>
The Schedule+ OLE Automation server extended map, programming model (PM)<br><br></li>
<li>
The Schedule+ OLE Automation server extended map, internal objects (IO)</li>
</ul>
<h4>The Schedule+ Object Library Extended Map</h4>
<p>
The Schedule+ object library (SPL) exposes only five objects, as shown in Figure 4. These objects are a distillation of the entire server. The SPL is intended for use by Microsoft Visual C++ programmers and experienced Microsoft Visual Basic for Applications developers. The SPL provides constants and should always be included in your references. The SPL lacks named properties<i> </i>on <b>Item</b> classes but provides the <b>Properties </b><i>method </i>to obtain all of the <b>Property </b>classes. See <a href="msdn_mapspl95.htm">"Mapping the Schedule+ 7.0 Object Library: SPL 7.0"</a> for an extended map of this type library.</p>
<p>
<img src="schpext_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Map of the Schedule+ object library</b></p>
<h4>The Schedule+ OLE Automation Server Extended Map, Programming Model</h4>
<p>
Figure 5 illustrates how the Schedule+ OLE Automation documentation describes Schedule+ in terms of the traditional view of OLE Automation servers. This extended map is designed for the developer who wishes to work with the UI capabilities only. Programming model (PM) objects have properties and methods like other OLE Automation servers, but PM objects such as the <b>Contacts</b> table and <b>Tasks</b> table have <i>different sets of properties </i>(remember that both of these objects are the <b>Item</b> class). Most of these properties are visible in the Schedule+ application. For an extended map, see <a href="msdn_mapschpm.htm">"Mapping the Schedule+ OLE Automation Server: Programming Model."</a></p>
<p>
<img src="schpext_5.gif" border=0></p>
<p class=label>
<b>Figure 5. Map of the Schedule+ programming model</b></p>
<h4>The Schedule+ OLE Automation Server Extended Map, Internal Objects</h4>
<p>
The third view is of Schedule+ internal objects (IO). The Schedule+ IO map is designed for the developer who wishes to use the full potential of Schedule+. The object overloading is seen in the <i>identical sets of properties</i> in the <b>Tasks</b> table and the <b>Contacts</b> table. The IO map shows that all of the <b>Property</b> objects are available on all <b>Item</b> objects. For an extended map of internal objects, see "Mapping the Schedule 95 OLE Automation Server: Internal Objects."</p>
<p>
<img src="schpext_6.gif" border=0></p>
<p class=label>
<b>Figure 6. Map of the Schedule+ 95 internal objects</b></p>
<p>
The relationships between the named objects (<b>Projects, Project, Schedule, </b>and <b>Roles</b>) and the object type or class is shown in Table 1. The type library describes the classes and not the named objects.</p>
<p class=label>
<b>Table 1. Values Returned by TypeName on Schedule+ Instances</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=70%><b>Instance of object</b></td>
<td class=label width=30%><b>TypeName() returned</b></td>
</tr>
<tr valign=top>
<td width=70%>Application</td>
<td width=30%>Application</td>
</tr>
<tr valign=top>
<td width=70%></td>
<td width=30%></td>
</tr>
<tr valign=top>
<td width=70%>Schedule</td>
<td width=30%>Schedule</td>
</tr>
<tr valign=top>
<td width=70%></td>
<td width=30%></td>
</tr>
<tr valign=top>
<td width=70%>AccessControls, AlarmsToRing, Appointments, Attendees, Contacts, DeletedItems, Events, Exceptions, Projects, RecurringAppointments, RecurringEvents, RecurringTasks, Tasks, SingleAppointments, SingleEvents, SingleTasks</td>
<td width=30%>Table</td>
</tr>
<tr valign=top>
<td width=70%></td>
<td width=30%></td>
</tr>
<tr valign=top>
<td width=70%>Access, Alarm, Appointment, Attendees, Contact, DeletedItem, Event, Exception, Project, RecurringAppointment, RecurringEvent, RecurringTask, SingleAppointment, SingleEvent, SingleTask, Task</td>
<td width=30%>Item</td>
</tr>
<tr valign=top>
<td width=70%></td>
<td width=30%></td>
</tr>
</table><br>
<h3>Code, Code, Code</h3>
<p>
Now that you've finished that latte, it's time to start reviewing code. In the following sections I will be building several sample applications that display the same objects and information in the Schedule+ file in very different ways. Each application illustrates some aspect of the three views above, coding issues, or performance factors. Read and run all of them before you start Schedule+ programming.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The code in this article assumes that you have the latest beta version of Schedule+ installed from the Microsoft Developer Network Development Platform. The Schedule+ type library that shipped with Windows 95 is broken and will not bind.</p>
<p>
The key factors shown are listed in Table 2.</p>
<p class=label>
<b>Table 2. Samples and Points Illustrated</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Sample Name</b></td>
<td class=label width=76%><b>Points</b></td>
</tr>
<tr valign=top>
<td width=24%>SPLFORM</td>
<td width=76%>Uses type-library classes only. Illustrates the use of <b>Item.Properties</b>. Exposes <b>Table,</b> <b>Item, </b>and <b>Property</b> classes.</td>
</tr>
<tr valign=top>
<td width=24%>SPMFORM</td>
<td width=76%>Uses the programming model and the type library. Illustrates the use of <b>Table.GetRows</b>. Improves performance by a factor of 1,000.</td>
</tr>
<tr valign=top>
<td width=24%>SAUFORM</td>
<td width=76%>Extends the SPMFORM sample by supporting the addition, modification, and deletion of objects. </td>
</tr>
</table><br>
<h2>Using the Type Library: SPLFORM</h2>
<p>
In the SPLFORM sample, I create a viewer that shows all of the information existing in a Schedule+ Schedule. The viewer, shown in Figure 7, uses the <b>Item.Properties</b> method to obtain all of the <b>Property </b>classes and <b>Table </b>classes. It uses generic routines that operate on the <b>Schedule </b>object, the <b>Table </b>class (class), and the <b>Item</b> object (class).</p>
<p>
<img src="schpext_7.gif" border=0></p>
<p class=label>
<b>Figure 7. SPLFORM application form showing the structure of Schedule+ objects</b></p>
<p>
Figure 7 shows <b>Application</b> (as the root object) and its descendants. The bottom object is a <b>Property </b>class (for example, <b>StartDate</b>) comprised of data members. Although the tool is slow, it allows for comprehensive exploration of the Schedule+ object (every object that exists can be obtained).</p>
<p>
I need to create an instance of Schedule+ and to open a Schedule+ document (the <b>Schedule</b> object). The following code allows me to access my local Schedule+ file:</p>
<pre><code>'The Exchange version of SP7EN32.OLB must be installed.
'The version shipped with Windows 95 is broken.
Global SPlusApplication As SPL.Application
Global scdSchedule As SPL.Schedule

Sub SchedulePlus_Init()
Set SPlusApplication = CreateObject("Schedule+.Application")
If SPlusApplication.LoggedOn = False Then
 &nbsp;&nbsp; SPlusApplication.Logon
End If
Set scdSchedule = SPlusApplication.ScheduleLogged
End Sub
</code></pre>
<p>
After initializing Schedule+, I start filling a <b>TreeView</b> control with the root <b>Application</b> object and <b>Schedule </b>object. I use a Visual Basic collection to link the <b>TreeView</b> items with the Schedule+ objects via a common key. The resulting links give me a <b>TreeView</b> with objects available for each item (instead of the traditional <b>ItemData </b>available in a list box). Clicking any item in the <b>TreeView</b> gives me the associated object with the following code:</p>
<pre><code>Private Sub TreeView_NodeClick(ByVal Node As Node)
Set SelectedObject = TreeCollection(Node.Key)
'other code
End Sub
</code></pre>
<p>
The <b>TreeView</b>'s <b>Nodes</b> collection is considerably richer in methods and properties than the Visual Basic collection, with such elements as <b>Key</b>, <b>Sorted</b>, <b>Child</b>, <b>Parent</b>, <b>FirstSibling</b>, and <b>LastSibling</b>. The <b>Nodes</b> collection, unlike the Visual Basic collection, also can be hierarchical.</p>
<p>
The implementation is simple: create a key, add it to the <b>Nodes</b> by key, and then add it to the Visual Basic collection by key. This is shown in <b>OutlineSPlusApplication</b> below:</p>
<pre><code>Sub OutlineSPlusApplication()
treSPlus.Nodes.Add , , "SPLUSAPPLICATION", "Application"
TreeCollection.Add Item:=SPlusApplication, Key:="SPLUSAPPLICATION"

treSPlus.Nodes.Add "SPLUSAPPLICATION", tvwChild, "A", _
 &nbsp;&nbsp; TypeName(scdSchedule) &amp; ": " &amp; scdSchedule.Name
TreeCollection.Add Item:=scdSchedule, Key:="A"
'TreeView does not support named arguments.
</code></pre>
<p>
The next routine, <b>OutlineAddTables,</b> is a generic routine that works on any <b>Item</b> or <b>Schedule</b> class. This routines show the child objects of the passed object. After verifying the object passed, the following occurs:
<ul type=disc>
<li>
A properties node is added to the <b>TreeView</b> control. All <b>Property </b>classes will eventually be listed here.<br><br></li>
<li>
All of the items returned are examined for any <b>Table </b>classes. Each <b>Table </b>class found is added to the <b>TreeView</b> control.</li>
</ul>
<p>
As was the case in the previous example, the items in the <b>TreeView</b> control and the objects in our collection are linked with a common key (<b>TableKey</b>). I did not enumerate the properties for performance reasons (see later in this section).</p>
<pre><code>Sub OutlineAddTables(OTL As Control, ScdItem As Object, ByVal ParentKey$)
If OTL.Nodes(ParentKey$).Children &gt; 0 Then
 &nbsp;&nbsp; Exit Sub 'Control already populated
End If
Screen.MousePointer = 11
If TypeName(ScdItem) = "Item" Or TypeName(ScdItem) = "Schedule" Then
 &nbsp;&nbsp; OTL.Nodes.Add ParentKey$, tvwChild, "P_" &amp; ParentKey$, "Properties"
 &nbsp;&nbsp; For p% = 0 To ScdItem.Properties - 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If TypeName(ScdItem.Properties(p%)) = "Table" Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TableKey = ParentKey$ &amp; p%
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set TblNode = OTL.Nodes.Add(ParentKey$, tvwChild, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TableKey, "Table: " &amp; ScdItem.Properties(p%).Name)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TblNode.EnsureVisible
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TreeCollection.Add ScdItem.Properties(p%), TableKey
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp; Next p%
End If
Screen.MousePointer = 0
End Sub
</code></pre>
<p>
At this point the viewer contains items you can explore. Click an item to see the next level of its components. Three procedures may be called in <b>treSPlus_NodeClick</b>, the <b>TreeView</b> Click event:
<ul type=disc>
<li>
<b>OutlineShowItems </b>(if you click a <b>Table</b> item)<br><br></li>
<li>
<b>OutlineAddTables </b>(if you click an <b>Item</b> item)<br><br></li>
<li>
<b>OutlineAddProperties </b>(if you click a <b>Property</b> item)</li>
</ul>
<p>
The <b>OutlineAddTables</b> procedure is described above. The <b>OutlineAddProperties</b> procedure similarly walks the objects returned by the <b>Properties</b> method and explodes each <b>Property </b>class found, as shown below. The <b>Property </b>class may have multiple values, so the value of <b>Property.Count</b> must be tested. Because all of the properties (<b>ChangeNumber, Class, Count, Name, </b>and <b>Value</b>) of the <b>Property </b>class are data members (instead of objects), we do not add them to the collection. The <b>Property </b>class is added to the collection although it is not needed (unless you plan to update this object). </p>
<pre><code>Sub OutlineAddProperties(OTL As Control, ScdItem As Object, ByVal ParentKey$)
If OTL.Nodes(ParentKey$).Children &gt; 0 Then
 &nbsp;&nbsp; Exit Sub 'Control already populated
End If
Screen.MousePointer = 11
On Error Resume Next
If TypeName(ScdItem) = "Item" Or TypeName(ScdItem) = "Schedule" Then
 &nbsp;&nbsp; For p% = 0 To ScdItem.Properties - 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If TypeName(ScdItem.Properties(p%)) = "Property" Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropKey$ = ParentKey$ &amp; p%
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set TblNode = OTL.Nodes.Add(ParentKey$, tvwChild, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropKey$, ScdItem.Properties(p%).Name)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TreeCollection.Add ScdItem.Properties(p%), PropKey$ 'Optional
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TblNode.EnsureVisible
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OTL.Nodes.Add PropKey$, tvwChild, , _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ChangeNumber: " &amp; ScdItem.Properties(p%).ChangeNumber
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OTL.Nodes.Add PropKey$, tvwChild, , _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Class: " &amp; ScdItem.Properties(p%).Class
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OTL.Nodes.Add PropKey$, tvwChild, , _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Count: " &amp; ScdItem.Properties(p%).Count
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OTL.Nodes.Add PropKey$, tvwChild, , _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Name: " &amp; ScdItem.Properties(p%).Name 'Nothing
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If ScdItem.Properties(p%).Count &gt; 1 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValueParent = PropKey$ &amp; "V"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set PropNode = OTL.Notes.Add(PropKey$, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tvwChild, ValueParent, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " Value" &amp; vbTab &amp; ScdItem.Properties(p%).Value)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For i% = 0 To ScdItem.Properties(p%).Count - 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OTL.Notes.Add ValueParent, tvwChild, , _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Value(" &amp; i% &amp; ")" &amp; vbTab &amp; ScdItem.Properties(p%).Value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next i%
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OTL.Nodes.Add PropKey$, tvwChild, , _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Value: " &amp; ScdItem.Properties(p%).Value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TreeCollection.Add ScdItem.Properties(p%), PropKey$
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp; Next p%
End If
On Error GoTo 0
Screen.MousePointer = 0
End Sub
</code></pre>
<p>
The <b>OutlineShowItems </b>procedure is different because it names the <b>Item </b>classes in a <b>Table</b>. The first <b>Item</b> class in the <b>Table</b> is obtained by calling the <b>Reset</b> method; this class is then added to the <b>TreeView</b> control and our collection. The next record is obtained by calling the <b>Skip </b>method until the <b>IsEndOfTable</b> property is True. </p>
<pre><code>Sub OutlineShowItems(OTL As Control, ScdTable As Table, ByVal ParentKey$)
If OTL.Nodes(ParentKey$).Children &gt; 0 Then
 &nbsp;&nbsp; Exit Sub 'Control already populated
End If
If TypeName(ScdTable) &lt;&gt; "Table" Then Exit Sub
ScdTable.Reset
i% = 0
While Not ScdTable.IsEndOfTable
 &nbsp;&nbsp; NewKey$ = ParentKey$ &amp; i%
 &nbsp;&nbsp; Set NewNode = OTL.Nodes.Add(ParentKey$, tvwChild, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewKey$, "Item " &amp; ScdTable.Item.Name &amp; i%)
 &nbsp;&nbsp; NewNode.EnsureVisible
 &nbsp;&nbsp; TreeCollection.Add ScdTable.Item, NewKey$
 &nbsp;&nbsp; i% = i% + 1
 &nbsp;&nbsp; ScdTable.Skip
Wend
End Sub
</code></pre>
<h4>Summary</h4>
<p>
The fact that the <b>TreeView</b> fills very slowly is not the fault of the code nor of Schedule+. The slowness occurs because of the large number of OLE Automation calls being done across processes. Schedule+ is an out-of-process OLE Automation server, so each call may take one-tenth of a second on slower computers. This is the time it takes to move the data across the interface, regardless of the size of the data or the speed of the code at either end. An <b>Item </b>class with 60 properties may take 60 seconds to fully display. Examine the <b>OutlineAddProperties</b> procedure above and you will find that 60 properties require 600 out-of-process calls.</p>
<p>
This code, although it is simple and illustrates well the structure of Schedule+, is too slow for most practical uses. This leads us to our second sample, SPMFORM.</p>
<h2>Using the Program Model: SPMFORM</h2>
<p>
In the SPMFORM sample, I create another viewer that shows most of the information existing in a Schedule+ <b>Schedule</b>. I select a subset of relevant information only. Low-level information such as <b>Property.ChangeNumber</b> or <b>Property.Class </b>cannot be obtained. The viewer uses the <b>Table.GetRows</b> method to obtain all of the <i>values</i> of the <b>Property </b>classes. The <b>Table </b>classes are obtained explicitly by examining the value of <b>Table.Rows</b>. The viewer similarly uses generic routines that operate on the <b>Schedule </b>object, the <b>Table </b>class (class), and the <b>Item</b> object (class). </p>
<p>
The same general logic used in the SPLFORM sample applies here, except that the code in each procedure is different. This application, illustrated in Figure 8, appears slightly different.</p>
<p>
<img src="schpext_8.gif" border=0></p>
<p class=label>
<b>Figure 8. SPMFORM application form showing the structure of Schedule+ objects</b></p>
<p>
Figure 8 shows <b>Application</b> as the root object and its descendants. The bottom objects are data members<b> </b>of<b> Property </b>classes (for example, <b>StartDate</b>) comprised of name, value, and data type. This is a faster but more selective tool for exploring the Schedule+ object (only some data members can be obtained).</p>
<p>
The <b>OutlineSPlusApplication</b> and <b>SchedulePlus_Init</b> procedures are identical. The <b>OutlineAddTables </b>procedure does not check to see which <b>Table </b>classes exist via the <b>Properties </b>method; instead, it checks the count of items in the table (the count is 0 if the <b>Table </b>class does not exist). The amount of code is many times larger than the code we needed above (I wished for COBOL's classic Perform Corresponding instruction). The difference in performance is great. For any <b>Item </b>class, this procedure takes only 14 out-of-process calls to obtain all of the seven possible <b>Table </b>classes, whereas the same procedure above required 2 * (number of Tables) + 2 * (number of properties), a major improvement! </p>
<pre><code>Sub OutlineAddTables(OTL As Control, ScdItem As Object, ByVal ParentKey$)
'This is a selection of the procedure.

If TypeName(ScdItem) = "Item" Or TypeName(ScdItem) = "Schedule" Then
 &nbsp; '...Code below is repeated for each Table that is unique to Schedule object.
 &nbsp;&nbsp; KeyCounter = KeyCounter + 1: NewKey = ParentKey$ &amp; ":" &amp; KeyCounter
 &nbsp;&nbsp; OTL.Nodes.Add ParentKey$, tvwChild, NewKey, "Roles:" &amp; ScdItem.Roles.Rows &amp; " Records"
 &nbsp;&nbsp; TreeCollection.Add ScdItem.Roles, NewKey
End If

If TypeName(ScdItem) = "Item" Then
 &nbsp; '...Code Above repeated for each Table common to all Items...
End If
End Sub
</code></pre>
<p>
The <b>OutlineAddProperties</b> procedure is merged into the <b>OutlineShowItems </b>procedure. As with the <b>OutlineAddTables </b>procedure above, I ask for the value instead of getting <b>Property </b>classes and then the <b>Value</b> data member of this object. I must enumerate the names of the properties as shown in the code below. The <b>Table.GetRows</b> method is limited to 100 rows and 31 values per rows in one out-of-process call (versus 6,200 out-of-process calls that the method above could require). We have just jumped to Warp speed!</p>
<pre><code>Sub OutlineShowItems(OTL As Control, ScdTable As Table, ByVal ParentKey$)
Dim arrData As Variant
Const nFieldNames = 22
Dim FieldNames$(1 To nFieldNames)
If OTL.Nodes(ParentKey$).Children &gt; 0 Then Exit Sub
If TypeName(ScdTable) &lt;&gt; "Table" Then Exit Sub
FieldNames$(1) = "CreatorName"&nbsp;&nbsp; 'Enumerate names of Properties
'More similar lines 
FieldNames$(22) = "IsRecurringInstance"
ScdTable.Reset 
I% = 0
On Error Resume Next
' If no rows -&gt; skip
' if error -&gt; no rows -&gt; skip
Clipcnt% = ScdTable.Rows
On Error GoTo 0
While Not ScdTable.IsEndOfTable And Clipcnt% &gt; 0
 &nbsp;&nbsp; If ScdTable.Rows - I% &gt; 100 Then 'Only 100 rows may be obtained at a time
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Clipcnt% = 100
 &nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Clipcnt% = ScdTable.Rows - I%
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; arrData = Array(Clipcnt% - 1, nFieldNames)
 &nbsp;&nbsp; I% = I% + Clipcnt%
 &nbsp;&nbsp; 'ItemID is FIRST since it always exists
 &nbsp;&nbsp; arrData = ScdTable.GetRows(Clipcnt%, "ItemId", _
 &nbsp;&nbsp; FieldNames$(1), [Lots of arguments omitted] FieldNames$(22))
 &nbsp;&nbsp; 'On Error Resume Next
 &nbsp;&nbsp; For r% = 0 To Clipcnt% - 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rp&amp; = rp&amp; + 1 'RowPosition
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ItemKey$ = "I" &amp; ParentKey$ &amp; "-" &amp; rp&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OTL.Nodes.Add ParentKey$, tvwChild, ItemKey$, arrData(r%, 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For c% = 1 To nFieldNames
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Not IsError(arrData(r%, c%)) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OTL.Nodes.Add ItemKey$, tvwChild, , _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FieldNames$(c%) &amp; ":" &amp; arrData(r%, c%) _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; "[" &amp; TypeName(arrData(r%, c%)) &amp; "]"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next c%
 &nbsp;&nbsp; Next r%
 &nbsp;&nbsp; On Error GoTo 0

Wend
End Sub
</code></pre>
<p>
All of the values of the <b>Property </b>classes could be obtained via multiple passes through the <b>Table </b>class. The <b>GetRows</b> method advances the pointer to the end of the records read. If I wanted to read 80 values per <b>Item </b>class, I would go through the tables three times, obtaining 62 (2 x 31) values on the first two passes and 18 values on the last pass. </p>
<p>
You can easily get information about any <b>Table </b>classes in an <b>Item</b> class. If the <b>Table.Name</b> is used as an argument in the <b>Table.GetRows </b>or <b>Item.GetProperties </b>methods and there is an empty <b>Table</b> class, an error (<b>IsError</b>) is returned. If the <b>Table </b>class is not empty, a valid data type is returned (<b>TypeName</b> reports Empty, Binary, or Date). There is no need to walk the <b>Item </b>classes of the <b>Table </b>class testing for possible child <b>Table </b>classes.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Data members are <i>not</i> retrievable by <b>Table.GetRows </b>or <b>Item.GetProperties</b>. Fortunately, data members only occur in the <b>Schedule</b> object. There are no data members in the <b>Item </b>class.</p>
<h4>Summary</h4>
<p>
This second sample results in a significant performance increase over our first sample: the new sample is literally 1,000 times faster! This sample does <i>not</i> add any <b>Item </b>classes or <b>Property </b>classes to our collection, so our ability to update easily is lost. In the next sample, I examine the problems of updating and adding objects.</p>
<h2>Updating and Adding Objects: SUAFORM</h2>
<p>
In the SUAFORM sample, I modify the SPMFORM sample to add and update Schedule+ objects. The term <i>add </i>bears explaining. The developer also can add new <b>Item </b>classes to a <b>Table </b>class. The developer can add <b>Property </b>classes to an <b>Item </b>class by assigning a value to the <b>Property.Value</b>. I refer to this process as <i>adding</i> because the <b>Property </b>class will be included in the objects returned by the <b>Properties</b> method as a result. Similarly, by adding an <b>Item</b> to an empty child, <b>Table </b>class adds the <b>Table </b>class<b> </b>to the <b>Item </b>class<b>. </b></p>
<p>
An important cosmetic change to the SPMFORM sample is the addition of icons in the <b>TreeView</b> as shown in Figure 9.</p>
<p>
<img src="schpext_9.gif" border=0> </p>
<p class=label>
<b>Figure 9. SAUFORM application form showing the structure of Schedule+ objects with icons</b></p>
<p>
Figure 9 shows two different icons for <b>Item </b>classes—a cloud and a sun. The cloud icon represents an <b>Item </b>class that exists but the application does not have its object included in its Visual Basic collection. The sun icon represents an <b>Item </b>class that exists and its object is included in the application's collection. These icons will help you understand the program logic described next.</p>
<p>
My first modification of the SPMFORM sample allows me to selectively get Schedule+ objects. I do not wish to get all of them because that will take a long time (remember Schedule+ is an out-of-process OLE Automation server). The only objects I obtained in the SPMFORM sample are the <b>Schedule</b> object and its child <b>Table </b>classes. I will modify the code to obtain all of the <b>Item </b>(and <b>Item.Table</b>) classes on an as-needed basis. The information displayed on the form are <i>values</i> of the <b>Property </b>classes available directly through these <b>Item </b>classes (instead of retrieving each <b>Property </b>class).</p>
<p>
The code is simple because of our use of the <b>TreeView</b> control combined with a collection, as the following code fragment shows. The <b>TreeView</b> control gives us a collection with a key that can be updated. The first character of the key determines whether the associated object has been placed in the object collection. In the sample code, an <b>Item</b> item (in the <b>TreeView</b>) is found. This item gives us the key of its parent in the object collection and the Schedule+ <b>ItemID</b> (stored in <b>Node.Text</b>) for the <b>Item </b>class. Combining the two results in the <b>Item </b>class being retrieved and added to our object collection. </p>
<pre><code>Private Sub treSPlus_NodeClick(ByVal Node As Node)
' code extract
Select Case Left(Node.Key, 1)
Case Const_ItemNoObject
 &nbsp; 'Change Key to show Object is in Collection
 &nbsp;&nbsp; Node.Key = KeyItemObject$ &amp; Mid$(Node.Key, 2)
 &nbsp;&nbsp; 'Add to Collection
 &nbsp;&nbsp; TreeCollection.Add TreeCollection.Item(Node.Parent.Key).Item(Node.Text), _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node.Key
'Change the image to show a Sun
 &nbsp;&nbsp; Node.Image = "Item"
</code></pre>
<p>
Making similar modifications to other code adds all of the <b>Table</b> and <b>Item </b>classes to our collection. </p>
<p>
My second modification allows me to edit the value of any <b>Item </b>class's <b>Property </b>class. Again, I exploit the <b>TreeView</b> control to produce compact code below:</p>
<pre><code>Private Sub treSPlus_NodeClick(ByVal Node As Node)
Select Case Left(Node.Parent.Key, 1)
Case Const_ItemNoObject
'The following forces the Parent into the Tree Collection.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; treSPlus_NodeClick Node.Parent
' code extract
Case Const_Property 'We have a Property
 &nbsp;&nbsp; NameIs$ = Left(Node.Text, InStr(Node.Text, ":") - 1)
 &nbsp;&nbsp; SetPropertyValue AnItem:=TreeCollection(Node.Parent.Key), NameIs:=NameIs$
 &nbsp;&nbsp; 'We must put (()) around variables in this call to be ByVal[BUG]
 &nbsp;&nbsp; ValueIs = TreeCollection(Node.Parent.Key).GetProperty((NameIs$))
 &nbsp;&nbsp; Node.Text = NameIs$ &amp; ":" &amp; ValueIs &amp; "(" &amp; TypeName(ValueIs) &amp; ")"
</code></pre>
<p>
In the code above, I use the node's key to tell me that the object is a <b>Property </b>class (so I do not waste time making an out-of-process OLE Automation call). If the <b>Item </b>class associated with this property has <i>not</i> been placed in the collection of objects, I force this <b>Item </b>class to be retrieved by calling the <b>treSPlus_NodeClick</b> procedure passing the node's parent. The edit is done by the <b>SetPropertyValue </b>procedure. The text in the <b>TreeView</b> control is then updated to reflect any changes.</p>
<p>
The <b>SetPropertyValue </b>procedure is a long procedure that enumerates all the properties you intend to modify. The code below shows the general structure:</p>
<pre><code>Sub SetPropertyValue(ByVal NameIs$, AnItem As Object)
'We CANNOT use "As Item", because of SetProperties method BUG
OldValue = AnItem.GetProperty((NameIs$))
If IsError(OldValue) Then OldValue = "{new}"
ValueIs = InputBox("New Value for " &amp; NameIs$ &amp; " is", _ 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Simplified Input", OldValue)
If Len(ValueIs) = 0 Then Exit Sub 'No value do not Delete
Select Case NameIs$
Case "AlarmTypeUnit"
 &nbsp;&nbsp; AnItem.SetProperties AlarmTypeUnit:=ValueIs
Case "Text"
 &nbsp;&nbsp; AnItem.SetProperties Text:=ValueIs
'a lot more Case statements 
End Select
'Make sure file is updated
AnItem.Flush
</code></pre>
<p>
This procedure uses a variant. Visual Basic will do any needed automatic type conversion when I set the value of the <b>Property </b>object by calling the <b>Item.SetProperties </b>method. (I could also use <b>TypeName</b> on <b>OldValue</b> to convert the result into the appropriate data type.) You are not restricted to one field when you call the <b>Item.SetProperties </b>method but may update all the fields that appear on a form that are part of a single <b>Item </b>class. The <b>Item.Flush</b> method flushes the data out of any cache back to the Schedule+ file.</p>
<p>
My third modification is the ability to add <b>Items</b>. There are three types of additions that may occur:
<ul type=disc>
<li>
Adding a <b>Table </b>class.<br><br></li>
<li>
Adding an <b>Item </b>class.<br><br></li>
<li>
Adding a <b>Property </b>class.</li>
</ul>
<p>
Adding a <b>Table </b>class is simple (assuming that you have the key of the <b>Item </b>class it will be added to, <b>KeyLastItem$</b>). From the collection I obtain the <b>Item </b>class, then call the <b>NameToTable</b> function (another long <b>Select Case</b> procedure) to get the appropriate <b>Table </b>class. The <b>Table </b>class <i>requires</i> a child <b>Item </b>class to come into existence so I create an <b>Item </b>class and set its <b>Text</b> <b>Property </b>class value to today's date. I then click this table to enumerate its <b>Item </b>classes in the <b>TreeView</b>:</p>
<pre><code>Private Sub mnuTables_Click(Index As Integer)
Set a = NameToTable(TreeCollection(KeyLastItem$), mnuTables(Index).Caption)
Set X = a.New
X.Text = Date$
X.Flush
treSPlus_NodeClick (treSPlus.Nodes(KeyLastItem$).Parent)
End Sub
</code></pre>
<p>
Similarly, adding an <b>Item </b>class is simple if you have the <b>Table </b>class key:</p>
<pre><code>Private Sub mnuAddItem_Click()
Set X = TreeCollection(KeyLastTable$).New
 &nbsp;&nbsp; X.Text = "New Item"
 &nbsp;&nbsp; X.Flush
 &nbsp;&nbsp; treSPlus_NodeClick treSPlus.Nodes(KeyLastTable$)
End Sub
</code></pre>
<p>
And adding a <b>Property </b>class only requires setting its value:</p>
<pre><code>Private Sub MnuProperty_Click(Index As Integer)
 &nbsp;&nbsp; SetPropertyValue NameIs$, TreeCollection(KeyLastItem$)
 &nbsp;&nbsp; ValueIs = TreeCollection(KeyLastItem$).GetProperty((NameIs$))
 &nbsp;&nbsp; PropKey$ = Const_Property + NewKey$()
 &nbsp;&nbsp; treSPlus.Nodes.Add KeyLastItem$, tvwChild, PropKey$, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NameIs$ &amp; ":" &amp; ValueIs &amp; "[" &amp; TypeName(ValueIs) &amp; "]", _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Property"
End Sub
</code></pre>
<p>
Deleting <b>Item</b>, <b>Table</b>, and <b>Property</b> classes is simple and is shown in the sample.</p>
<h3>What's Missing</h3>
<p>
I did not cover the more mundane aspects of Schedule+ OLE Automation in this article. The samples in the documentation address these aspects well. I have focused on the architecture of Schedule+ because it is very different from the older OLE Automation servers.</p>
<p>
There are a few bugs in the version that I am using. These may or may not be corrected by the final released version. In case they are not, here is a short table of the more significant ones.</p>
<p class=label>
<b>Table 3. Significant Bugs in Schedule+ OLE Automation </b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Element</b></td>
<td class=label width=31%><b>Description</b></td>
<td class=label colspan=2 width=39%><b>Solution</b></td>
</tr>
<tr valign=top>
<td width=30%><b>Item.SetProperties</b></td>
<td width=31%>Cannot specify property name if early bound object.</td>
<td colspan=2 width=39%>Object may not be "As Item" but must be late bound "As Object."</td>
</tr>
<tr valign=top>
<td width=30%></td>
<td width=31%></td>
<td colspan=2 width=39%></td>
</tr>
<tr valign=top>
<td width=30%><b>Item.GetProperty<br>
Item.GetProperties</b></td>
<td width=31%>Type mismatch on variable.</td>
<td colspan=2 width=39%>You must put an extra set of () around the variable so that it is passed by value.</td>
</tr>
<tr valign=top>
<td width=30%></td>
<td width=31%></td>
<td colspan=2 width=39%></td>
</tr>
<tr valign=top>
<td width=30%><b>References</b></td>
<td width=31%>Type library does not bind.</td>
<td colspan=2 width=39%>The original Windows 95 and early beta type libraries have errors. Install current version.</td>
</tr>
<tr valign=top>
<td width=30%></td>
<td width=31%></td>
<td colspan=2 width=39%></td>
</tr>
<tr valign=top>
<td width=30%><b>Item.GetProperties<br>
Item.SetProperties</b></td>
<td width=31%>Cannot list enough arguments.</td>
<td colspan=2 width=39%>Documentation is incorrect. The limit is 31 property names.</td>
</tr>
<tr valign=top>
<td width=30%></td>
<td width=31%></td>
<td colspan=2 width=39%></td>
</tr>
<tr valign=top>
<td width=30%><b>Table.GetRows</b></td>
<td width=31%>An <b>Item </b>class is skipped.</td>
<td colspan=2 width=39%>The second and subsequent calls to <b>Table.GetRows</b> method cause an extra <b>Skip</b> to occur. Read all of the records on the first call to the <b>GetRows </b>method if <b>TableRows</b> property is less than 100, or add a "Skip -1" after the first call to the <b>GetRows</b> method.</td>
</tr>
<tr valign=top>
<td width=30%></td>
<td width=31%></td>
<td colspan=2 width=39%></td>
</tr>
<tr valign=top>
<td width=30%><b>For Each</b></td>
<td width=31%>Does not work on <b>Table </b>classes.</td>
<td colspan=2 width=39%>The <b>Table </b>class is not a collection. The <b>For Each</b> command would be very slow if implemented.</td>
</tr>
<tr valign=top>
<td width=30%></td>
<td width=31%></td>
<td colspan=2 width=39%></td>
</tr>
<tr valign=top>
<td width=30%><b>Schedule.Top<br>
Schedule.Left<br>
Schedule.Width<br>
Schedule.Height</b></td>
<td width=31%>Does not exist.</td>
<td colspan=2 width=39%>Oops—forgotten elements! You must walk the processes to get the <b>hWnd</b> of the Schedule+ window and then use a <b>SendMessage</b> to move.</td>
</tr>
<tr valign=top>
<td width=30%></td>
<td width=31%></td>
<td colspan=2 width=39%></td>
</tr>
<tr valign=top>
<td width=30%><b>Schedule.GetProperties<br>
Schedule.GetProperty</b></td>
<td width=31%>Fail on data members (<b>CanUndo, SupportedOperations, Timezone, Usage, UserAddress, UserEntryID, UserName, UserSearchKey, Visible</b>).</td>
<td colspan=2 width=39%>These methods only work on <b>Property </b>classes.</td>
</tr>
<tr valign=top>
<td colspan=3 width=75%></td>
<td width=25%></td>
</tr>
</table><br>
<h2>Summary</h2>
<p>
The Schedule+ Automation servers allow developers to produce powerful and customizable personal information managers (PIMs). Microsoft applications such as Word, Microsoft Excel, Microsoft Access, and Microsoft Project can be integrated within an enterprise-class PIM that will meet the needs of corporate developers and their clients. This different, extensible OLE Automation–centric view of OLE Automation allows better information flow across the corporation.</p>
<h2>Bibliography</h2>
<p>
Lassesen, Ken. "A Hot Date: How OLE Automation Boosts Functionality in Schedule+." <i>Developer Network News</i>, March 1996. (Available on <i>Developer Network News Online</i> at <a href="http://www.microsoft.com/devnews/">http://www.microsoft.com/devnews/.</a>)</p>
<p>
Lassesen, Ken. <a href="msdn_mapschio.htm">"Mapping the Schedule+ OLE Automation Server: Internal Objects."</a> (MSDN Library, Technical Articles)</p>
<p>
Lassesen, Ken. <a href="msdn_mapschpm.htm">"Mapping the Schedule+ OLE Automation Server: Programming Model."</a> (MSDN Library, Technical Articles)</p>
<p>
Lassesen, Ken. <a href="msdn_mapspl95.htm">"Mapping the Schedule+ 7.0 Object Library: SPL 7.0."</a> (MSDN Library, Technical Articles)</p>
<p>
Lassesen, Ken. <a href="msdn_ole2soln.htm">"Using Microsoft OLE Automation Servers to Develop Solutions."</a> (MSDN Library, Technical Articles)</p>
<p>
Microsoft Exchange Server SDK <i>Microsoft Schedule+ Programmer's Guide.</i> </p>
</BODY>
</HTML>
