<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The New U: What's New in USER32</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_user32"></a></sup>The New U: What's New in USER32</h1>
<p>
Kyle Marsh<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: September 29, 1993</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="1818">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files in the THRD32 sample application.</a></p>
<h2>Abstract</h2>
<p>
This article discusses some of the new features available in USER32, the 32-bit version of USER found in the 32-bit versions of the Microsoft® Windows® operating system. Porting issues from Win16, asynchronous input queues, thread-localized input states, single-instance applications, window classes, and Windows hooks are among the topics discussed.</p>
<h2>Introduction</h2>
<p>
Windows NT™ has been released, Win32s™ is now available for Microsoft® Windows® version 3.1, and the next version of Windows (called Windows 95) is on its way. 32-bit environments for Windows are available now, and in a matter of months all Windows platforms will become 32-bit platforms. Now is the time to build new 32-bit applications and to port your existing 16-bit applications to 32 bits.</p>
<p>
USER32 handles the window manager chores—for example, windows, menus, controls, hooks, and dialog boxes—for Windows. In 16-bit versions of Windows, USER16 handles these tasks. This article will discuss some of the differences between USER16 and USER32.</p>
<h2>Porting Issues</h2>
<p>
Developers of 16-bit applications will find that one of the best features of USER32 is the ease in porting from USER16 to USER32.</p>
<h3>Widened Functions</h3>
<p>
USER32 runs on the 32-bit versions of Windows, which use the Win32® application programming interface (API). This means that a number of data items that used to be 16 bits are now 32 bits. Handles are the most noticeable of these: All window handles are now 32-bit handles instead of 16-bit handles. Although this sounds like a significant change, it has almost no effect on most applications. All functions that took window handles still take window handles; the window handles just happen to be different now. The <b>SetWindowText</b> call still looks like this:</p>
<pre><code>SetWindowText(HWND hWnd, LPSTR text) 
</code></pre>
<p>
What about the <b>LPSTR</b> argument? Doesn't that need to be changed for Win32? Well, yes and no. In Win32 environments, all pointers are the same. There is no concept of near or far pointers, so <b>LPSTR</b> has the same meaning as <b>NPSTR</b>. Actually, you should replace all references to <b>LPSTR</b> and <b>NPSTR</b> with <b>PSTR</b>, which is a pointer to a string. Because this requires a lot of work for developers, the Win32 Software Development Kit (SDK) for Windows NT defines the following macros:</p>
<pre><code>#define LPSTR PSTR
#define NPSTR PSTR
</code></pre>
<p>
These macros eliminate the need for developers to change their source code for Win32 while leaving the source compatible with Win16. However, when Win32 becomes the norm, the references to <b>LPSTR</b> will be out of place. I prefer to use <b>PSTR</b> only for new applications I develop for Win32; I use <b>LPSTR</b> for existing applications and for applications that require 16-bit and 32-bit executables.</p>
<p>
As a result, although most USER16 functions were widened to take 32-bit arguments, the application developer does not need to worry about any of them. Your USER16 calls for 16-bit applications will work just fine for USER32.</p>
<p>
One area where the widening of arguments to 32 bits does affect your application is in window procedures. These procedures take four arguments, the third of which is often defined as:</p>
<pre><code>WORD wParam
</code></pre>
<p>
The name <i>wParam</i> implies a <b>WORD</b> in Hungarian notation. In Win32, this value changes to a 32-bit value and is defined as:</p>
<pre><code>UINT uParam
</code></pre>
<p>
Actually, the <b>UINT</b> type is portable between Win16 and Win32 because it is defined as an unsigned integer on both systems. Using this data type will leave your source code compatible with both 16-bit and 32-bit versions of Windows.</p>
<p>
The application developer has to decide how to deal with the new <i>wParam</i>. Changing the name of the parameter to <i>uParam</i> provides a visual clue in a ported (or new) application that the code was ported from (or developed for) the Win32 environment. It also complies with Hungarian notation. However, many developers prefer to continue using Windows 3.1 argument names, so they use:</p>
<pre><code>UINT wParam
</code></pre>
<p>
To simplify matters, the Windows header files define a macro that allows the developer to keep the old name, maintain consistency with Hungarian notation, and ensure portability between 16-bit and 32-bit applications:</p>
<pre><code>WPARAM wParam
</code></pre>
<p>
where <b>WPARAM</b> is defined as:</p>
<pre><code>typedef UINT WPARAM
</code></pre>
<p>
in both Win16 and Win32.</p>
<h3>Removed and Obsolete Functions</h3>
<p>
The first thing to note when moving to USER32 is that any undocumented functions your application may be using will probably not work in USER32. </p>
<p>
The following functions were eliminated in Win32. Applications that call these functions will need to remove the references from the source code.
<ul type=disc>
<li>
<b>CloseComm </b><br><br></li>
<li>
<b>DefDriverProc </b><br><br></li>
<li>
<b>EnableCommNotification </b><br><br></li>
<li>
<b>ExitWindowsExec </b><br><br></li>
<li>
<b>FlushComm </b><br><br></li>
<li>
<b>GetCommError </b><br><br></li>
<li>
<b>GetCommEventMask </b><br><br></li>
<li>
<b>GetDriverInfo </b><br><br></li>
<li>
<b>GetFreeSystemResources </b><br><br></li>
<li>
<b>GetNextDriver </b><br><br></li>
<li>
<b>LockInput </b><br><br></li>
<li>
<b>OpenComm</b><br><br></li>
<li>
<b>ReadComm </b><br><br></li>
<li>
<b>SetCommEventMask </b><br><br></li>
<li>
<b>UngetCommChar </b><br><br></li>
<li>
<b>WriteComm </b></li>
</ul>
<h3>Functions Replaced by Macros</h3>
<p>
Some of the functions that Win32 made obsolete can be simulated by calling other functions in USER32. The Win32 header files define the following macros to make this transition easier and to increase source code compatibility between Win16 and Win32:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=39%><b>Obsolete function</b></td>
<td class=label width=61%><b>New function referenced by macro</b></td>
</tr>
<tr valign=top>
<td width=39%><b>AnsiLower </b></td>
<td width=61%><b>CharLower</b></td>
</tr>
<tr valign=top>
<td width=39%><b>AnsiLowerBuff </b></td>
<td width=61%><b>CharLowerBuff</b></td>
</tr>
<tr valign=top>
<td width=39%><b>AnsiNext</b></td>
<td width=61%><b>CharNext</b></td>
</tr>
<tr valign=top>
<td width=39%><b>AnsiPrev </b></td>
<td width=61%><b>CharPrev</b></td>
</tr>
<tr valign=top>
<td width=39%><b>AnsiUpper</b></td>
<td width=61%><b>CharUpper</b></td>
</tr>
<tr valign=top>
<td width=39%><b>AnsiUpperBuff </b></td>
<td width=61%><b>CharUpperBuff</b></td>
</tr>
<tr valign=top>
<td width=39%><b>CopyCursor</b></td>
<td width=61%><b>CopyIcon</b></td>
</tr>
<tr valign=top>
<td width=39%><b>DefHookProc</b></td>
<td width=61%><b>CallNextHookEx</b></td>
</tr>
<tr valign=top>
<td width=39%><b>EnumTaskWindows</b></td>
<td width=61%><b>EnumThreadWindows</b></td>
</tr>
<tr valign=top>
<td width=39%><b>GetNextWindow</b></td>
<td width=61%><b>GetWindow</b></td>
</tr>
<tr valign=top>
<td width=39%><b>GetSysModalWindow</b></td>
<td width=61%>Defined to NULL</td>
</tr>
<tr valign=top>
<td width=39%><b>GetWindowTask</b></td>
<td width=61%><b>GetWindowThreadProcessId</b></td>
</tr>
<tr valign=top>
<td width=39%><b>PostAppMessage</b></td>
<td width=61%><b>PostThreadMessage</b></td>
</tr>
<tr valign=top>
<td width=39%><b>SetSysModalWindow</b></td>
<td width=61%>Defined to NULL </td>
</tr>
</table><br>
<h3>Functions Moved out of USER32</h3>
<p>
The following functions were moved out of USER32 and into other components of Windows NT:
<ul type=disc>
<li>
<b>BuildCommDCB</b><br><br></li>
<li>
<b>ClearCommBreak </b><br><br></li>
<li>
<b>CloseDriver </b><br><br></li>
<li>
<b>EscapeCommFunction</b><br><br></li>
<li>
<b>GetCommState </b><br><br></li>
<li>
<b>GetCurrentTime </b><br><br></li>
<li>
<b>GetDriverModuleHandle</b><br><br></li>
<li>
<b>GetTickCount</b><br><br></li>
<li>
<b>GlobalAddAtom</b><br><br></li>
<li>
<b>GlobalFindAtom</b><br><br></li>
<li>
<b>GlobalGetAtomName</b><br><br></li>
<li>
<b>lstrcmp</b><br><br></li>
<li>
<b>lstrcmpi</b><br><br></li>
<li>
<b>OpenDriver </b><br><br></li>
<li>
<b>SendDriverMessage </b><br><br></li>
<li>
<b>SetCommBreak </b><br><br></li>
<li>
<b>SetCommState</b><br><br></li>
<li>
<b>TransmitCommChar </b><br><br></li>
<li>
<b>WnetAddConnection </b></li>
</ul>
<h3>Functions Moved into USER32</h3>
<p>
The dynamic-data exchange (DDE) functions, which had been in a separate dynamic-link library (DLL), have been moved into USER32.</p>
<h3>Changed Messages</h3>
<p>
The move to 32 bits made it necessary to change the way some messages used <i>wParam</i> and <i>lParam</i>. In Win16, <i>wParam</i> and <i>lParam</i> consisted of three 16-bit locations for data items. Some messages would then pack three data items into these locations. Win32 has four 16-bit locations. The additional location does not require a change to data item packaging, but some of the data items have changed from 16 bits to 32 bits, so they no longer fit where they used to. Most commonly, handles were packed into the <i>lParam</i> argument. For example, the WM_COMMAND message in Win16 uses <i>wParam</i> and <i>lParam</i> as follows:
<ul type=disc>
<li>
<i>wParam</i>: ID<br><br></li>
<li>
<i>lParam</i>: <i>hWnd</i> in the <b>LOWORD</b>, command in the <b>HIWORD</b></li>
</ul>
<p>
In Win32, WM_COMMAND now uses:
<ul type=disc>
<li>
<i>uParam</i>: ID in the <b>LOWORD</b>, command in the <b>HIWORD</b><br><br></li>
<li>
<i>lParam</i>: <i>hWnd</i></li>
</ul>
<p>
This change was required because the <i>hWnd</i> now needs the entire <i>lParam</i> argument.</p>
<p>
In the following messages, <i>wParam</i> and <i>lParam</i> were repackaged to take the 32-bit data types into account.
<ul type=disc>
<li>
EM_GETSEL<br><br></li>
<li>
EM_LINESCROLL<br><br></li>
<li>
EM_SETSEL<br><br></li>
<li>
WM_ACTIVATE<br><br></li>
<li>
WM_CHANGECBCHAIN<br><br></li>
<li>
WM_CHARTOITEM<br><br></li>
<li>
WM_COMMAND<br><br></li>
<li>
WM_DDE_ACK<br><br></li>
<li>
WM_DDE_ADVISE<br><br></li>
<li>
WM_DDE_DATA<br><br></li>
<li>
WM_DDE_EXECUTE<br><br></li>
<li>
WM_DDE_POKE<br><br></li>
<li>
WM_HSCROLL<br><br></li>
<li>
WM_MDIACTIVATE<br><br></li>
<li>
WM_MDISETMENU<br><br></li>
<li>
WM_MENUCHAR<br><br></li>
<li>
WM_MENUSELECT<br><br></li>
<li>
WM_PARENTNOTIFY<br><br></li>
<li>
WM_VKEYTOITEM<br><br></li>
<li>
WM_VSCROLL</li>
</ul>
<p>
The WM_CTLCOLOR message had three 16-bit data items that could not be repacked into the two 32-bit parameters available. In this case, Win32 replaces the WM_CTLCOLOR message with the following messages:
<ul type=disc>
<li>
WM_CTLCOLORBTN<br><br></li>
<li>
WM_CTLCOLORDLG<br><br></li>
<li>
WM_CTLCOLOREDIT<br><br></li>
<li>
WM_CTLCOLORLISTBOX<br><br></li>
<li>
WM_CTLCOLORMSGBOX<br><br></li>
<li>
WM_CTLCOLORSCROLLBAR<br><br></li>
<li>
WM_CTLCOLORSTATIC</li>
</ul>
<h3>Window and Class Words</h3>
<p>
Many applications use the <b>GetClassWord</b>, <b>SetClassWord</b>, <b>GetWindowWord</b>, and <b>SetWindowWord</b> functions to get and set information for classes and windows. These functions still exist in USER32, but the data values for which they were used have become 32-bit data types. As a result, the long versions of the <b>GetClassLong</b>, <b>SetClassLong</b>, <b>GetWindowLong</b>, and <b>SetWindowLong</b> functions must be used with the new constants defined for the offsets.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>USER16 word constants</b></td>
<td class=label width=50%><b>USER32 long constants</b></td>
</tr>
<tr valign=top>
<td width=50%>GCW_CBCLSEXTRA</td>
<td width=50%>GCL_CBCLSEXTRA</td>
</tr>
<tr valign=top>
<td width=50%>GCW_CBWNDEXTRA</td>
<td width=50%>GCL_CBWNDEXTRA</td>
</tr>
<tr valign=top>
<td width=50%>GCW_HBRBACKGROUND</td>
<td width=50%>GCL_HBRBACKGROUND</td>
</tr>
<tr valign=top>
<td width=50%>GCW_HCURSOR</td>
<td width=50%>GCL_HCURSOR</td>
</tr>
<tr valign=top>
<td width=50%>GCW_HICON</td>
<td width=50%>GCL_HICON</td>
</tr>
<tr valign=top>
<td width=50%>GCW_HMODULE</td>
<td width=50%>GCL_HMODULE</td>
</tr>
<tr valign=top>
<td width=50%>GCW_STYLE</td>
<td width=50%>GCL_STYLE</td>
</tr>
<tr valign=top>
<td width=50%>GWW_HINSTANCE</td>
<td width=50%>GWL_HINSTANCE</td>
</tr>
<tr valign=top>
<td width=50%>GWW_HWNDPARENT</td>
<td width=50%>GWL_HWNDPARENT</td>
</tr>
<tr valign=top>
<td width=50%>GWW_ID</td>
<td width=50%>GWL_ID</td>
</tr>
</table><br>
<h2>The New USER32 Functions</h2>
<p>
When the USER32 API was being finalized, Windows 3.1 was also in the finalization stage. As a result, the functions for USER32 and USER16 are very similar. Many new Win32 functions were added to Windows 3.1:
<ul type=disc>
<li>
<b>ActivateKeyboardLayout </b><br><br></li>
<li>
<b>AttachThreadInput </b><br><br></li>
<li>
<b>CharLowerBuff </b><br><br></li>
<li>
<b>CharNext </b><br><br></li>
<li>
<b>CharPrev </b><br><br></li>
<li>
<b>CharToOem </b><br><br></li>
<li>
<b>CharToOemBuff </b><br><br></li>
<li>
<b>CharUpperBuff </b><br><br></li>
<li>
<b>CopyAcceleratorTable </b><br><br></li>
<li>
<b>CreateAcceleratorTable </b><br><br></li>
<li>
<b>CreateIconFromResource </b><br><br></li>
<li>
<b>CreateIconIndirect </b><br><br></li>
<li>
<b>CreateMDIWindow </b><br><br></li>
<li>
<b>DestroyAcceleratorTable </b><br><br></li>
<li>
<b>EnumPropsEx </b><br><br></li>
<li>
<b>EnumThreadWindows </b><br><br></li>
<li>
<b>GetForegroundWindow </b><br><br></li>
<li>
<b>GetIconInfo </b><br><br></li>
<li>
<b>GetKeyboardLayoutName </b><br><br></li>
<li>
<b>GetProcessWindowStation </b><br><br></li>
<li>
<b>GetThreadDesktop </b><br><br></li>
<li>
<b>GetUserObjectSecurity </b><br><br></li>
<li>
<b>GetWindowThreadProcessId </b><br><br></li>
<li>
<b>IsWindowUnicode </b><br><br></li>
<li>
<b>LoadKeyboardLayout </b><br><br></li>
<li>
<b>LookupIconIdFromDirectory </b><br><br></li>
<li>
<b>MessageBoxEx </b><br><br></li>
<li>
<b>MsgWaitForMultipleObjects </b><br><br></li>
<li>
<b>OemToChar </b><br><br></li>
<li>
<b>OemToCharBuff </b><br><br></li>
<li>
<b>PostThreadMessage </b><br><br></li>
<li>
<b>RegisterHotKey </b><br><br></li>
<li>
<b>SendMessageCallback </b><br><br></li>
<li>
<b>SendMessageTimeout </b><br><br></li>
<li>
<b>SendNotifyMessage </b><br><br></li>
<li>
<b>SetDebugErrorLevel</b><br><br></li>
<li>
<b>SetForegroundWindow </b><br><br></li>
<li>
<b>SetUserObjectSecurity </b><br><br></li>
<li>
<b>ToUnicode </b><br><br></li>
<li>
<b>UnloadKeyboardLayout </b><br><br></li>
<li>
<b>UnregisterHotKey </b><br><br></li>
<li>
<b>WaitForInputIdle </b><br><br></li>
<li>
<b>WindowFromDC </b></li>
</ul>
<p>
In addition, USER32 was enhanced with dynamic data exchange management library (DDEML) functionality, so it contains a number of DDE functions that were not included in USER16.</p>
<h2>Single-Instance Applications</h2>
<p>
One difference that developers will notice between Win16 and Win32 is that all Win32 applications run as single instances, even if another instance of the application is running. This is because all applications have separate address spaces under Win32. As a result, the <i>hPrevInstance</i> parameter passed to an application's WinMain procedure will always be NULL. </p>
<p>
Generally, this makes life easier for the application developer. In Win16, the developer had to be aware of whether multiple instances of the application were necessary and take precautions to ensure that the application would work correctly when these instances shared the application's code segments. In Win32, the developer doesn't need to worry about multiple instances. No precautions are necessary to ensure that the application runs correctly.</p>
<p>
Actually, the above statement is not completely true. No precautions are necessary for memory access, USER32, or GDI32, but the developer must still be cautious. For example, if the application accesses a data file, the developer must ensure that two instances of the application will be able to access the file concurrently or use serialized access. To avoid this effort, the developer can use the <b>FindWindow</b> function to ensure that only one instance of the application is running:</p>
<pre><code>if (hWndApp = FindWindow(szAppMainWindowClassName, NULL)) {
 &nbsp; hWndPopup = GetLastActivePopup(hWndApp);

 &nbsp; BringWindowToTop(hWndApp);
 &nbsp; if ( IsIconic(hWndPopup) )
 &nbsp;&nbsp;&nbsp;&nbsp; ShowWindow(hWndPopup, SW_RESTORE);
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; SetForegroundWindow(hWndPopup);

 &nbsp; return FALSE;
}
</code></pre>
<p>
This works fine for Win32s applications, but Windows NT introduces an additional problem. In Windows NT, an application can be launched multiple times, in rapid succession. For example, if you start an application from a batch file using the <b>start</b> command, Windows NT starts the processes one after another, but so quickly that one process starts before the previous process has finished initializing. In this case, the <b>FindWindow</b> function will not find another occurrence of the window class, although another instance of the application exists. To avoid this, the application must use a WIN32 synchronization object such as Mutex, as follows:</p>
<pre><code>hMutex = CreateMutex(NULL, FALSE, "ThreadSampleMutex" );
if ( WaitForSingleObject(hMutex, 10000) == WAIT_TIMEOUT ) {
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // There is another instance out there, but it is taking too long to
 &nbsp;&nbsp; // locate, just exit.
 &nbsp;&nbsp; return FALSE;
}

if (hWndApp = FindWindow(szAppMainWindowClassName, NULL)) {
 &nbsp; hWndPopup = GetLastActivePopup(hWndApp);

 &nbsp; BringWindowToTop(hWndApp);
 &nbsp; if ( IsIconic(hWndPopup) )
 &nbsp;&nbsp;&nbsp;&nbsp; ShowWindow(hWndPopup, SW_RESTORE);
 &nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; SetForegroundWindow(hWndPopup);

 &nbsp; ReleaseMutex(hMutex);
 &nbsp; CloseHandle(hMutex);
 &nbsp; return FALSE;
}

if (!Init(hInstance, cmdShow)) {
 &nbsp; ReleaseMutex(hMutex);
 &nbsp; CloseHandle(hMutex);
 &nbsp; return 1;
}

ReleaseMutex(hMutex);
CloseHandle(hMutex);
</code></pre>
<h2>Asynchronous Input Queues</h2>
<p>
One of the best features of USER32 is its input processing model. Unfortunately, this feature is currently available only in Windows NT. </p>
<h3>The Bad Old Days</h3>
<p>
The 16-bit versions of Windows supplied their own multitasking capabilities because the underlying operating system, MS-DOS®, did not supply any. Two design decisions limited the capabilities of Windows:
<ol>
<li>
Windows was designed as a non-preemptive operating system. This means that Windows did not interrupt an application to allow another application to run. <br><br></li>
<li>
Windows had only one input queue. This single input queue held all the input from the user until an application removed the events from the queue. </li>
</ol>
<p>
While limiting the power of Windows, these decisions did make sense for the processors available when Windows was first released. At the time, the 8088 was the most common PC processor, and it was overwhelmed quickly. The non-preemptive environment eliminated the need for the processor to do a lot of overhead work, such as keeping track of which process should be running, when it should be interrupted, and switching between processes. Only a minimum amount of switching was necessary to support the interrupts generated by input devices such as the mouse and keyboard. Having a single input queue simplified the requirements for managing the input while another process was running. It also kept the overhead to a minimum and improved the performance of the system. </p>
<p>
This design also made type-ahead functionality very easy to implement. Because all events were placed into the system queue as they occurred and were taken out of the queue by their target applications in the same order, a perfect type-ahead capability was always available. </p>
<p>
Windows implemented multitasking by requiring applications to process messages by calling <b>GetMessage</b> or <b>PeekMessage</b> and to get input from the user as well as from other events. When Windows was executing <b>GetMessage</b> or <b>PeekMessage</b>, the system would perform any task-switching that was necessary. At any given time, only one application (the application that had a <b>GetMessage</b> or <b>PeekMessage</b> function return) would be running. All other applications were blocked until one of these functions returned. </p>
<p>
<img src="user32_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Event Processing in Win16</b></p>
<p>
The main problem with this design was its lack of robustness. If one application stopped processing messages, the whole system would grind to a halt. This could happen when an application initiated a long process such as reading a set of database records, printing, repaginating, saving a file, reading a file, or any number of other operations. The real problem was that when an application hung, it stopped processing messages, so the whole system hung. Later versions of Windows added the capability to detect applications that had stopped processing messages, but this was not always successful. </p>
<p>
Another problem was that if events came in while an application was slow in processing messages, the queue could fill up and Windows could not store any new messages.</p>
<p>
To prevent the system from being brought to its knees, applications had to be very careful when they handled long processes. The most common solution was to put a long process in a <b>PeekMessage</b> loop. <b>PeekMessage</b> would be called throughout the long process so that other applications and the system could have a chance to run and do their own processing. These loops were sometimes very troublesome to develop. Because of the development burden, some developers would just go ahead with their long processes and allow the system to be unresponsive to the user. </p>
<h3>Happy Days Are Here Again</h3>
<p>
USER32 had two input-processing goals:
<ol>
<li>
No application should be able to interfere with USER32's ability to direct input to any application. This means that:<ul type=disc>
<li>
An application can hang or perform a long process with the thread that is the primary input processor without hanging the system.<br><br></li>
<li>
USER32 can direct input to any application at any time.</li>
</ul>
</li>
<li>
The input processing semantics must be compatible with the Win16 semantics.</li>
</ol>
<p>
USER32 has achieved these goals, and Win32 is much more robust than Win16. An application cannot bring the whole system to a halt when it hangs or goes into a long process. To make this goal a reality, USER32 takes advantage of the preemptive features of Windows NT.</p>
<p>
Windows NT was designed from the very beginning to include preemptive multitasking. The target processors for this operating system are much more powerful than the old 8088, so they can handle the background requirements of a preemptive system. In Windows NT, the basic processing unit is called a <i>thread</i>. Every process running on Windows NT has at least one thread. The way USER32 interacts with these threads allows the system to be more robust. </p>
<p>
When a thread calls a USER32 or GDI32 function, the system creates an input queue for the thread. The thread may or may not use the input queue, but the overhead to create the input queue is incurred at this time. The advantage is that no overhead is incurred if the thread does not call USER32 or GDI32 functions.</p>
<p>
USER32 also takes advantage of Windows NT's threads by creating a high-priority thread, known as the <i>raw input thread</i>, which is always running to process the user's keyboard and mouse input. The user's events are placed into a system queue by the device drivers, just as they are in Win16, and the raw input thread immediately transfers the events to the thread input queue for which the input was intended. Unlike in Win16, thread input queues are dynamically resized so they can store new messages for an application even if the application is currently processing messages. The number of messages that can be stored is limited only by the amount of available memory in the system. An application can process messages whenever convenient without affecting USER32's ability to direct input to another thread's input queue. The user can always switch away from an application that is hung or performing a long process and do other things. For example, a user can switch to a mail program and check mail while a spreadsheet is printing. This is possible regardless of how the spreadsheet is programmed. If an application hangs, the user simply switches to the task list and ends the task from there.</p>
<p>
<img src="user32_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Input processing in Win32</b></p>
<p>
Asynchronous input queues make the system robust, which is what they were intended to do. An application developer may never have to write another <b>PeekMessage</b> loop. No matter how an application is implemented, the system will continue to react to the user, other applications will be able to process, and everything will be great. A badly written application may, however, slow the system down considerably, leading the user to think that the application is hung. The robustness of Windows NT means that a badly written application will not stop the system from running, but it doesn't mean that the system will run well. The difference between badly written applications in Windows NT and Windows 3.1 is that the application's impact on the system is not fatal in Windows NT because asynchronous input queues prevent the system from hanging when an application hangs.</p>
<p>
Applications must handle long processes correctly for two reasons:
<ul type=disc>
<li>
To be responsive to the user.<br><br></li>
<li>
To allow the system to share the processor at all times.</li>
</ul>
<h4>Being responsive to the user</h4>
<p>
When an application does not process input from the user, the user may think that the application is hung. Users like to get constant feedback to ensure that their applications are still working. Even when an application displays its status (and the user knows that the application is working), the user needs a way to interrupt, cancel, or change the parameters of the process (for example, cancel a print job). For this reason, applications should always be able to accept some kind of user input, even if this merely means supporting a cancel button while printing a document.</p>
<p>
Another problem that may occur when an application stops processing input is that the appearance of the application may get out of date. The user can switch to another application while a long process is being performed, making it possible for other windows to be drawn over the unresponsive application's window. As the user moves and closes other windows, areas of the unresponsive application's window will need repainting, but because the application is not processing messages, it cannot process the WM_PAINT messages it receives from Windows. This can make the screen appear very confusing. USER32 will eventually detect applications that are not processing messages and will repaint these applications' windows with a border and clean background, but without a menu or any other information. USER32's repainting of the window makes the screen appear less confused and draws the user's attention to the inactive application, but may make the unresponsive application look bad. </p>
<h4>Allowing the system to share the processor</h4>
<p>
By default, Windows NT is configured so that all the threads belonging to the application that owns the foreground window (the window to which the user is directing input) have a higher priority than threads belonging to other applications. All of the threads that belong to the application that owns the foreground window are <i>foreground threads</i>. (Note that the Win32 SDK for Windows NT incorrectly defines the foreground thread as only the thread that owns the foreground window.) All other threads in the system are known as <i>background threads</i>.</p>
<p>
The system can become most responsive to the user's input if the foreground threads' base priority is boosted from 7 to 9. The user can disable this feature by using the Control Panel's System application and changing the tasking options. I don't expect many users to change these tasking parameters because these changes are not very intuitive.</p>
<p>
If a foreground thread goes into a long process and stops handling messages, the rest of the system will practically stop, because lower priority threads do not receive much processor time when a higher priority thread has processing to do. In fact, my results showed that background threads received a time slice only about once a minute. This certainly has an adverse effect on the way the system performs many tasks. To see how a foreground thread affects the system when it stops handling messages, see the THRD32 sample application that accompanies this technical article. </p>
<p>
Start two instances of THRD32. Arrange the instances so you can see both windows at the same time. When you start THRD32, it is in its <b>PeekMessage</b> mode. This mode displays the number of milliseconds between <b>PeekMessage</b> returns as its bottom number and the longest time between <b>PeekMessage </b>returns as its top number. Click one of the THRD32 windows to make that window the foreground window. Now choose Hog the System from the State menu to set the state of that window. This causes THRD32 to go into a long process, displaying 1 to 500 in the top number and the time taken (in milliseconds) in the bottom number. The code it is running looks like this:</p>
<pre><code>for (i=0; i &lt; 500; i++ ) {
 &nbsp; sprintf(buf, "%7.0d", i);
 &nbsp; SetWindowText(hwndFilter, buf);

 &nbsp; NowTime = (double)timeGetTime();
 &nbsp; Interval = NowTime-LastTime;
 &nbsp; sprintf(buf, "%7.0lf", Interval);
 &nbsp; SetWindowText(hwndNoFilter, buf);

 &nbsp; NoFlickUpdate(hwndNoFilter);
 &nbsp; NoFlickUpdate(hwndFilter);
}
</code></pre>
<p>
The <b>NoFlickUpdate</b> routine simply paints the current window text to the screen. At no point in this loop does THRD32 handle messages. </p>
<p>
When running the hogging instance of THRD32, you will see that the timing instance stops displaying numbers. If you do not switch between applications, everything will wait either until the hogging THRD32 finishes its process or until about a minute has passed without any other thread getting processor time. The Windows NT scheduler will give lower priority threads some processor time after about a minute has passed without any, but the time will be short and this won't happen again for another minute. (I know this sounds confusing, but you'll understand what I mean when you run the hogging instance of THRD32.) When the hogging THRD32 finishes, the timing THRD32 will again display numbers, but the longest time between <b>PeekMessage</b>s will be about the same as the hogging THRD32 took to complete its process, or about 60,000 milliseconds, whichever is less. Set the hogging THRD32 off again, but this time switch to the other THRD32 before the hog finishes. As soon as you switch, the timing THRD32 starts displaying numbers again because the timing THRD32 is now the foreground window. Notice, however, that the hogging THRD32 also displays numbers. This is because THRD32 is in a <b>PeekMessage</b> loop when timing <b>PeekMessage</b>s, which allows other processes to run as they do in Win16. This is basically the same old <b>PeekMessage</b> loop used in Win16:</p>
<pre><code>// I am taking some comments out of this fragment to make it easier to 
// read here. For the full source, look at MAIN.C in the THRD32 sample.
do {
 &nbsp;&nbsp; if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (msg.message == WM_QUIT) break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!TranslateAccelerator(hwndMain, hAccTable, &amp;msg)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslateMessage(&amp;msg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DispatchMessage(&amp;msg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp; if ( nState == PEEKLOOP )&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double Interval;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double NowTime;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NowTime = (double) timeGetTime();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Interval = NowTime-LastTime;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(buf, "%7.0lf", Interval);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowText(hwndNoFilter, buf);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( Interval &lt;= LastInterval ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Interval = LastInterval;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(buf, "%7.0lf", Interval);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowText(hwndFilter, buf);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LastTime=NowTime;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LastInterval = Interval;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WaitMessage();
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
} while (1);
</code></pre>
<h4>Other ways to handle long processes</h4>
<p>
In USER32, using the <b>PeekMessage</b> loop as described above is not the only way to handle long processes. The code shown above works fine, which means that all applications that have gone to the trouble of being well behaved in Win16 will remain well behaved in Win32. For new code, however, there are other ways to handle the situation. The sections below describe three methods to handle a long process: using the <b>Sleep</b> function, adding a <b>PeekMessage</b> loop to the process itself, and using a thread.</p>
<p>
<b>Using Sleep</b></p>
<p>
One way to handle a long process is simply to give other applications a chance to run. The easiest method I have seen for doing this uses the <b>Sleep</b> function. Calling this function with a value of 1 millisecond will give threads that are running with a lower priority some processor time. Try the hogging THRD32, but this time use the Hog with Sleep state. Notice that the timing THRD32 continues to display numbers, and the hogging THRD32 runs slower than it did in the Hog the System state. This is expected because the timing THRD32 now shares the processor with the other threads. Change the size of the hogging window to measure the effect of the <b>Sleep</b> function call on the performance of THRD32. Small windows run faster than large windows. If you make the window very large, you will see how a longer process might be affected by <b>Sleep</b>. The effect of <b>Sleep</b> is actually determined by how the function is called. In this case, THRD32 calls <b>Sleep</b> 500 times during its processing:</p>
<pre><code>for (i=0; i &lt; 500; i++ ) {
 &nbsp; sprintf(buf, "%7.0d", i);
 &nbsp; SetWindowText(hwndFilter, buf);

 &nbsp; NowTime = (double)timeGetTime();
 &nbsp; Interval = NowTime-LastTime;
 &nbsp; sprintf(buf, "%7.0lf", Interval);
 &nbsp; SetWindowText(hwndNoFilter, buf);

 &nbsp; NoFlickUpdate(hwndNoFilter);
 &nbsp; NoFlickUpdate(hwndFilter);
 &nbsp; Sleep(1);
}
</code></pre>
<p>
The disadvantage of this technique is that the application that performs the process will not be responsive to the user. The application will still seem dead, which should be avoided if possible.</p>
<p>
<b>Using a PeekMessage loop</b></p>
<p>
Another way to handle a long process is to add a <b>PeekMessage</b> loop to the process itself:</p>
<pre><code>for (i=0; i &lt; 500; i++ ) {
 &nbsp; if ( PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE) ) {
 &nbsp;&nbsp;&nbsp;&nbsp; TranslateMessage (&amp;msg);
 &nbsp;&nbsp;&nbsp;&nbsp; DispatchMessage (&amp;msg);
 &nbsp; }
 &nbsp; sprintf(buf, "%7.0d", i);
 &nbsp; SetWindowText(hwndFilter, buf);

 &nbsp; NowTime = (double)timeGetTime();
 &nbsp; Interval = NowTime-LastTime;
 &nbsp; sprintf(buf, "%7.0lf", Interval);
 &nbsp; SetWindowText(hwndNoFilter, buf);

 &nbsp; NoFlickUpdate(hwndNoFilter);
 &nbsp; NoFlickUpdate(hwndFilter);
}
</code></pre>
<p>
This technique allows other processes to get processor time, and also lets the current application respond to user input. With the code above, however, you must make sure that the application does not exit until the long process is finished. This can happen if the application gets a WM_CLOSE message and calls <b>DestroyWindow</b> or <b>DefWindowProc</b> without checking to see if the long process is finished. The THRD32 sample keeps a variable, <i>nState</i>, which it checks before calling <b>DestroyWindow</b>. If <i>nState</i> indicates that a long process has not completed, THRD32 does not call <b>DestroyWindow</b>.</p>
<pre><code>case WM_CLOSE:
 &nbsp;&nbsp; if ( nState &gt;= HOG ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBeep(0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hWnd);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; break;
</code></pre>
<p>
If the application exits before the code above completes its long process, the process will be left on the system <i>(a)</i> forever, <i>(b)</i> until the system is shut down, or <i>(c)</i> until the user uses the PVIEW application to kill the process. This is because the application exits from the <b>PeekMessage</b> loop in the long process, but does not exit from its main <b>GetMessage</b> or <b>PeekMessage</b> loop in WinMain. All of the windows belonging to the process are destroyed, but the process itself remains. This is actually not new to Win32; if the same situation occurred in Win16, the task would also be left running forever.</p>
<p>
<b>Using a thread</b></p>
<p>
The last method I will describe for handling a long process involves using a thread to perform the task while the original thread continues to respond to the user. First, I tried to use <b>CreateThread</b> to create a new thread that would perform the long process while the original thread continued with user-interface processing. I made sure that the application did not exit while the thread was running. In fact, I used the same mechanism I described for the <b>PeekMessage</b> loop in the previous section. You might notice that although I had two threads accessing the same global data element, I did not use a synchronization object for it. In this case, this is OK because once the thread is started, only the thread will change the value of the data element. In your own application, you should always check to make sure that multiple threads can access global objects without any problems. Having coded all that, I went ahead and launched the application. When I started the hogging instance's Hog with Thread state, I was surprised to see that it had the same effect as not using a thread: The rest of the system stopped while the long process was running. I had thought that putting the processing into a background thread would solve my problem. Actually it does, but I was not using a background thread. Remember that the system raises the priority of all threads in the foreground process, so what I was starting was merely another foreground thread. This is important to remember: If your application uses a second thread to perform a long task, and that thread doesn't allow lower priority threads to run, the background threads will be starved for processor time.</p>
<p>
To solve the problem, I could have added a call to <b>Sleep</b> as shown in the "Using Sleep" section above. I tried something different instead. I used <b>SetThreadPriority</b> to lower my thread's priority. This effectively made my thread a background thread, because it lost its foreground priority boost. I ran the application again, and this time things looked much better until I switched to another application. When I switched away from my application, all the threads in it lost their foreground boost. This gave my self-made background thread an even lower priority. As a result, it was starved for processor time. In some cases, this may be the desired behavior. For example, if the user is not entering text into a word-processing application, there is not much need to repaginate the document in the background. In many other instances, however, dropping into this much lower priority is not desired. To fix this, I added code to handle the WM_ACTIVATEAPP message and to set the priority of my background thread depending on whether my application was the foreground or a background application. Here is the final code that worked for THRD32:</p>
<pre><code>&nbsp;&nbsp;&nbsp;case WM_ACTIVATEAPP:
 &nbsp;&nbsp;&nbsp;&nbsp; if ( nState == HOGTHREAD ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( uParam ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetThreadPriority(hThread, THREAD_PRIORITY_LOWEST );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetThreadPriority(hThread, THREAD_PRIORITY_NORMAL );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DefWindowProc(hWnd, msg, uParam, lParam);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp; case IDM_HOGTHREAD:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( nState &gt;= HOG ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBeep(0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nState = HOGTHREAD;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LastTime = (double)timeGetTime();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LastInterval = 0.0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWindowText(hWnd,"Hog the System - Thread");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hThread = CreateThread(NULL, 0, HogThread, hWnd, 0, &amp;idThread);
 &nbsp;&nbsp;&nbsp;&nbsp; break;

LRESULT HogThread(HWND hWnd)
{
 &nbsp; int i;
 &nbsp; double Interval;
 &nbsp; double NowTime;

 &nbsp; SetThreadPriority(hThread, THREAD_PRIORITY_LOWEST );

 &nbsp; for (i=0; i &lt; 500; i++ ) {
 &nbsp;&nbsp;&nbsp;&nbsp; sprintf(buf, "%7.0d", i);
 &nbsp;&nbsp;&nbsp;&nbsp; SetWindowText(hwndFilter, buf);

 &nbsp;&nbsp;&nbsp;&nbsp; NowTime = (double)timeGetTime();
 &nbsp;&nbsp;&nbsp;&nbsp; Interval = NowTime-LastTime;
 &nbsp;&nbsp;&nbsp;&nbsp; sprintf(buf, "%7.0lf", Interval);
 &nbsp;&nbsp;&nbsp;&nbsp; SetWindowText(hwndNoFilter, buf);

 &nbsp;&nbsp;&nbsp;&nbsp; NoFlickUpdate(hwndNoFilter);
 &nbsp;&nbsp;&nbsp;&nbsp; NoFlickUpdate(hwndFilter);
 &nbsp; }
 &nbsp; nState = 0;

 &nbsp; SetWindowText(hwndFilter, "Done");

 &nbsp; NowTime = (double)timeGetTime();
 &nbsp; Interval = NowTime-LastTime;
 &nbsp; sprintf(buf, "%7.0lf", Interval);
 &nbsp; SetWindowText(hwndNoFilter, buf);

 &nbsp; ExitThread(0);
 &nbsp; return 0;
}
</code></pre>
<h3>A Comment on Asynchronous Input Queues</h3>
<p>
Asynchronous input queues are a great feature in Windows NT. They allow the system to deal cleanly with a badly written or hung application. They are not, however, a cure-all for badly written applications. Badly written applications will affect the overall performance of Windows NT just as they affected the performance of 16-bit versions of Windows. However, the effect will not be as catastrophic as before, and it will never be fatal.</p>
<h2>Thread Localized Input States</h2>
<p>
In Windows NT, input from the user is assigned to the correct thread when the input is generated by the user. This means that there can be input available for more than one application at any point in time. In fact, multiple applications can process input simultaneously. Each application needs its input state, the focus window, keyboard state, mouse capture, and active window to reflect the state that existed when the input is generated. Win16 had only one input queue, so the input state functions reflected the state of that queue, effectively giving a global perspective of the input state. Now that Win32 has many input queues, the input state functions must work specifically for each thread instead of working for the whole system. This means that each input queue owned by an individual thread has its own focus state, keyboard state, mouse capture state, and active window state.</p>
<p>
As a result, the input-state functions now work differently on Windows NT than they did on 16-bit versions of Windows:
<ul type=disc>
<li>
<b>GetActiveWindow</b> will return NULL if the thread that calls <b>GetActiveWindow</b> does not have an active window. In Win16, this function returned the active window for the system.<br><br></li>
<li>
<b>SetActiveWindow</b> should always be used with care. Generally, the user should decide which window is active. This function can be used to set the active window to a window owned by another thread, but in this case a subsequent call to <b>GetActiveWindow</b> will return NULL.<br><br></li>
<li>
<b>GetFocus</b> will return NULL if the thread that calls <b>GetFocus</b> does not have a window with focus. In Win16, this function returned the window that had focus no matter which task owned the window.<br><br></li>
<li>
<b>SetFocus </b>can be used to set the focus to a window owned by another thread, but in this case a subsequent call to <b>GetFocus</b> will return NULL. <br><br></li>
<li>
<b>GetCapture </b>will return NULL if the calling thread does not have a window that captures the mouse. In Win16, this function returned a window that captured the mouse no matter which task owned the window.<br><br></li>
<li>
<b>SetCapture </b>can be used only to set the capture for a window owned by the thread. <br><br></li>
<li>
<b>ReleaseCapture</b> will release the capture of any window owned by the thread.</li>
</ul>
<h3>Mouse Capture</h3>
<p>
In Win16, only one window in the system could set the mouse capture at any given time. In Win32, only one window in a thread can have the capture, but another thread can also capture the mouse. In Win16, all mouse events were sent to the capture window. In Win32, only mouse events that occur over the windows owned by the thread that set the mouse capture are sent to the capture window. In other words, an application cannot use <b>SetCapture</b> to get mouse messages meant for other applications.</p>
<h2>16-Bit Applications in Windows NT</h2>
<p>
Asynchronous input queues are a foundation of USER32, and the Windows on Windows (WOW) box uses them like any other application. However, because the purpose of the WOW box is to emulate the behavior of Win16 on Windows NT, the WOW box does not present the asynchronous input queues to the 16-bit Windows applications it runs. Instead, it emulates the Win16 system queue using its thread input queue.</p>
<p>
<img src="user32_3.gif" border=0></p>
<p class=label>
<b>Figure 3. The Win16 system queue in Windows NT</b></p>
<h2>Window Classes</h2>
<p>
Win16 has three types of classes: system global, application global, and application local. For compatibility, these classes appear to exist in Win32; however, all Win32 classes are actually local classes for the application. Even if an application uses a custom control that registers itself as an application global class, the class is really local to the application. This is because each process has its own address space and any DLLs the application uses are mapped into that address space.</p>
<p>
For the most part, this discrepancy will not affect applications because classes will work exactly as they did in Win16. There is one important difference, however. In Win16, if you subclassed a system global class, all windows created from that class would be subclassed regardless of the application that created them. This is not the case in Win32. Subclassing a system global class—for example, the EDIT class—affects the edit controls for the application only. This can be a very handy capability in Win32. Let's assume that you want to add some capability to every edit control in your application. In Win16, you need to keep track of where each edit control was created or create a superclass of the edit control. You could also locally superclass the edit control, but that is not recommended. In Win32, you can simply subclass the class itself, and the problem is solved.</p>
<h2>Subclassing Window Instances</h2>
<p>
Subclassing a window instance works as it did in Win16 with one major exception: You cannot subclass windows that do not belong to your application because of the separate address spaces Windows NT uses. There are a few ways to get around this; they all involve getting a procedure in the address space of the other process, for example, by using a DLL with a systemwide hook. The address of your subclass procedure will have no meaning in the address space of another application, and the <b>SetWindowLong</b> function will not allow the subclassing to take place.</p>
<h2>Windows Hooks</h2>
<p>
Win32 hooks incorporate a number of changes, including the following:
<ul type=disc>
<li>
A new hook called WH_FOREGROUNDIDLE has been added.<br><br></li>
<li>
The WH_HARDWARE hook is not implemented.<br><br></li>
<li>
An application cannot hook events for the desktop, even with a systemwide hook.<br><br></li>
<li>
All systemwide hooks must be in a DLL. (This was supposed to be true for Win16, but Win16 hooks did work if they were in an application.) <br><br></li>
<li>
Journal hooks can be canceled when the user presses <small>ctrl</small>+<small>esc</small>, <small>alt+esc</small>, or <small>ctrl+alt+del</small>.<br><br></li>
<li>
Win32 sends a new message (WM_CANCELJOURNAL) to notify an application that a user has canceled a journal hook.</li>
</ul>
<p>
For more information on how hooks work in Win32, see the <a href="msdn_hooks32.htm">"Win32 Hooks"</a> article on the Microsoft Developer Network CD.</p>
<h2>What Else Is New?</h2>
<p>
This article just touched on the most important new features of USER32. In upcoming articles, I will go into more detail on some of these features, such as using threads with USER32, and will introduce additional new USER32 features such as Unicode™.</p>
</BODY>
</HTML>
