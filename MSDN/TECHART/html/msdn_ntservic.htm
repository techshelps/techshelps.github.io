<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating a Simple Windows NT Service in C++</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_ntservic"></a>Creating a Simple Windows NT Service in C++</h1>
<p>
Nigel Thompson<br>
Microsoft Developer Network Technology Group</p>
<p>
November 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4479">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files for the NTService sample application.</a></p>
<p>
<OBJECT id=sample2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4481">
</OBJECT><a href="javascript:sample2.Click()">Click to open or copy the files for the NTServCpl sample application.</a></p>
<p>
<OBJECT id=sample3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4483">
</OBJECT><a href="javascript:sample3.Click()">Click to open or copy the files for the NTServCtrl sample application.</a></p>
<h2>Abstract</h2>
<p>
This article describes how to create simple Microsoft® Windows NT™ services using Microsoft Visual C++™. The services are created using a single C++ class that provides a simple interface between your service and the operating system. Using this class approach, your own implementation is simply a matter of overriding a few virtual functions in the base class. Three sample applications accompany this article:
<ul type=disc>
<li>
The NTService sample is a simple Windows NT service built using the method described in this article.<br><br></li>
<li>
The NTServCpl sample is a Control Panel applet that controls the NTService service. This application was built using the techniques described in the <a href="msdn_ntcplapp.htm">"Creating Win32 Control Panel Applets with Visual C++"</a> technical article in the MSDN Library.<br><br></li>
<li>
The NTServCtrl sample application is an example of a stand-alone application that can be used to control and monitor a Windows NT service.</li>
</ul>
<h2>Introduction</h2>
<p>
A service in Microsoft® Windows NT™ is a program that runs whenever the computer is running the operating system. It does not require a user to be logged on. Services are needed to perform user-independent tasks such as directory replication, process monitoring, or services to other machines on a network, such as support for the Internet HTTP protocol.</p>
<p>
Creating a service for Windows NT is not particularly hard. Debugging a service is, however, a little more difficult. For my own work I prefer to create my applications in C++ using Microsoft Visual C++™. Most Windows NT service samples are in C, so I thought it would be interesting to see if I could create a C++ class to perform the rudimentary functions of a Windows NT service. As it turns out, one can create Windows NT services in C++ quite simply. The base class I developed for this should be an adequate starting point for your own work.</p>
<p>
Creating a service involves a bit more that just the service code. Additionally, you must write code to:
<ul type=disc>
<li>
Report warnings and errors in the system or application logs. You typically can't use output to the screen since there may be no user logged on.<br><br></li>
<li>
Control the service through either a separate application or a Control Panel applet. This involves implementing a communication mechanism for your service.<br><br></li>
<li>
Install and remove the service from the system.</li>
</ul>
<p>
Most other service examples use one program to install the service and another to remove it. I built these functions into the service itself so you have only one .EXE to distribute. You can run the service application directly from the command line and ask it to install, uninstall, or report its version information. The NTService sample supports the following command-line arguments:
<ul type=disc>
<li>
<b>-v</b>, which reports the name and version number of the service<br><br></li>
<li>
<b>-i</b>, which installs the service <br><br></li>
<li>
<b>-u</b>, which removes the service</li>
</ul>
<p>
By default, when the system starts the service there will be no command-line arguments passed to it.</p>
<h2>Creating the Application Framework</h2>
<p>
I have been creating applications based on the Microsoft Foundation Class Library (MFC) for too long. When I initially set out to build my Windows NT service, I started with the Visual C++ AppWizard and created an SDI/MFC application. I intended to remove the document and view classes, icons, and so on and just leave the framework. As it turns out, by the time you've removed all that stuff and the main window (since we can't have one), there isn't anything left. Very silly. So I went back to AppWizard and created a Console Application project with a single source file that would contain the <b>main</b> entry point function. I called this file NTServApp.cpp. I used the <i>cpp</i> extension rather than just <i>c</i> because I wanted to write the entire project using C++ rather than straight C. We'll look at the implementation of the code in this file later.</p>
<p>
Since I wanted to build my service from a C++ class, I created the NTService.h and NTService.cpp files in which I would implement the <b>CNTService</b> base class. I also created the MyService.h and MyService.cpp files in which I would implement my own service class (<b>CMyService</b>) derived from <b>CNTService</b>. Again, well look at the code a bit later.</p>
<p>
When I start a new project, I like to get something working as soon as possible, so I decided that the first thing my service should do is make some entries in the system's application log file. Having implemented a mechanism for making these entries, I'd be able to track when the service was started, stopped, and so on; I'd also have a way to record any errors that might occur in the service. Making log entries turned out to be much more complicated than I thought.</p>
<h2>Making Log Entries</h2>
<p>
I figured that since the log files were a part of the operating system, there would be some application programming interface (API) support for making entries into them. So I broke out my trusty MSDN CD and dug around until I found the <b>ReportEvent</b> function. Now if you don't know about this stuff, you'd probably think that this function would need to know in which log file you want to make the entry, and the text of the message you want to insert. Well, that's sort of what it does, but to simplify internationalization of error messages, this function takes a message ID and looks up the message in a message table you provide. So the problem is not so much what message you want to put in the log, as how to add these messages to your application. Here's a step-by-step guide:
<ol>
<li>
Create a text file with the extension .MC containing the descriptions of the messages. I called mine NTServMsg.mc. The format is very specific and is covered in the "Compiling Messages" section of the Win32® Software Development Kit (SDK) <i>Tools User's Guide</i>.<br><br></li>
<li>
Run the message compiler (MC.EXE) against your source file, which by default creates an output file called MSG00001.BIN. The compiler also creates a header file (in my case NTServMsg.h) and an .RC file (NTServMsg.rc). You need to repeat this step any time you change the .MC file in your project, so it's handy to add a tool entry in your Visual C++ menu to do this.<br><br></li>
<li>
Create an .RC file for your project and <b>#include</b> in it the WINDOWS.H file and the .RC file produced by the message compiler.<br><br></li>
<li>
Include the header file produced by the message compiler in your main project header file so all modules have access to the symbolic message names.</li>
</ol>
<p>
Let's look at some of these files in more detail so you can see what you need to create and what the message compiler creates for you. We won't look at the entire set of messages, just one or two to show you how it works. Here's the first part of my message source file, NTServMsg.mc:</p>
<pre><code>MessageId=100
SymbolicName=EVMSG_INSTALLED
Language=English
The %1 service was installed.
.

MessageId=
SymbolicName=EVMSG_REMOVED
Language=English
The %1 service was removed.
.

MessageId=
SymbolicName=EVMSG_NOTREMOVED
Language=English
The %1 service could not be removed.
.
</code></pre>
<p>
Each entry has an ID value that, if not specifically set, is simply one more than the value assigned to the message before it. Each entry also has a symbolic name for use in your code, a language identifier, and the text of the actual message. Messages can span more than one line and are terminated by a line containing a single period on its own.</p>
<p>
The message compiler outputs a binary file to be used as a resource in the application and two files for inclusion in your source code. Here's my .RC file:</p>
<pre><code>// NTServApp.rc
#include &lt;windows.h&gt;

// Include the message table resource script 
// generated by the message compiler (MC).
#include "NTServMsg.rc"
</code></pre>
<p>
Here's the .RC file the message compiler generated:</p>
<pre><code>LANGUAGE 0x9,0x1
1 11 MSG00001.bin
</code></pre>
<p>
As you can see, there's not a lot of text in these files!</p>
<p>
The last file generated by the message compiler is a header file for you to include in your code. Here's just a part of the one generated for the sample:</p>
<pre><code>&nbsp;[..........]
//
// MessageId: EVMSG_INSTALLED
//
// MessageText:
//
//&nbsp; The %1 service was installed.
//
#define EVMSG_INSTALLED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000064L

//
// MessageId: EVMSG_REMOVED
//
// MessageText:
//
//&nbsp; The %1 service was removed.
//
#define EVMSG_REMOVED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000065L
[...........]
</code></pre>
<p>
You might have noticed that several of my messages include argument substitution items (%1 and so on). Let's see how these are used in the code when we actually want to write a message to one of the system's log files. For an example, let's look at the part of the installation code that records successful installation in the event log. This is part of my <b>CNTService::IsInstalled</b> function:</p>
<pre><code>&nbsp;[....]
LogEvent(EVENTLOG_INFORMATION_TYPE, EVMSG_INSTALLED, m_szServiceName);
[....]
</code></pre>
<p>
<b>LogEvent</b> is another <b>CNTService</b> function that uses the type of event (information, warning, or error), the ID of the event message, and up to three argument substitution strings to form the log message:</p>
<pre><code>// This function makes an entry into the application event log.
void CNTService::LogEvent(WORD wType, DWORD dwID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* pszS1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* pszS2,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* pszS3)
{
 &nbsp;&nbsp; const char* ps[3];
 &nbsp;&nbsp; ps[0] = pszS1;
 &nbsp;&nbsp; ps[1] = pszS2;
 &nbsp;&nbsp; ps[2] = pszS3;

 &nbsp;&nbsp; int iStr = 0;
 &nbsp;&nbsp; for (int i = 0; i &lt; 3; i++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ps[i] != NULL) iStr++;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Check to see if the event source has been registered,
 &nbsp;&nbsp; // and if not then register it now.
 &nbsp;&nbsp; if (!m_hEventSource) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_hEventSource = ::RegisterEventSource(NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // local machine
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_szServiceName); // source name
 &nbsp;&nbsp; }

 &nbsp;&nbsp; if (m_hEventSource) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::ReportEvent(m_hEventSource,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wType,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp; // sid
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);
 &nbsp;&nbsp; }
}
</code></pre>
<p>
As you can see, the majority of the work is handled by the <b>ReportEvent</b> system function.</p>
<p>
So now we have a way to record events in the system event log by calling <b>CNTService::LogEvent</b>. Now we can move on to creating some of the code for the service itself.</p>
<h2>Writing the Service Code</h2>
<p>
The Win32 SDK "Overviews" section has a subsection called "System Services." This section contains most of what you need to know in order to construct a simple Windows NT service. The sample code in the section is in C and is quite easy to follow. I based my <b>CNTService</b> class on the material in this code.</p>
<p>
A service contains three major functions:
<ul type=disc>
<li>
A <b>main</b> function that is the entry point of the code. This is where we parse any command-line arguments and get the service installed, removed, started, and so on.<br><br></li>
<li>
A function that provides the entry point for the actual service code. In the examples this function is called <b>ServiceMain</b>, but you can call it anything you like. You pass the address of this function to the service manager when the service is first started.<br><br></li>
<li>
A function that processes command messages from the service manager. In the examples this function is called <b>Handler</b>, but you can name it anything you like.</li>
</ul>
<h3>Service Callback Functions</h3>
<p>
Since the <b>ServiceMain</b> and <b>Handler</b> functions are called from the system, they must conform to the parameter-passing scheme and calling convention of the operating system. This means they can't simply be member functions of a C++ class. This is slightly inconvenient, since we want to encapsulate the functionality of a Windows NT service in a single C++ class. To get around this problem, I created my <b>ServiceMain</b> and <b>Handler</b> functions as <i>static</i> members of my <b>CNTService</b> class. This enabled me to create functions that are callable by the operating system. This doesn't provide a complete solution, however, because the system does not allow passing any form of user data to the called functions, so we have no way to identify a call to either <b>ServiceMain</b> or <b>Handler</b> with a specific instance of a C++ object. I use a very simple but limiting solution to this problem. I create a static variable that contains a pointer to the C++ object. The variable is initialized when the object is first created. This limits you to one C++ object per service application. I did not consider this to be too restrictive. Here's the declaration in the NTService.h file:</p>
<pre><code>class CNTService
{
 &nbsp; [...]
 &nbsp; // static data
 &nbsp;&nbsp; static CNTService* m_pThis;&nbsp;&nbsp; // nasty hack to get object ptr
  [...]
};
</code></pre>
<p>
Here's how the <b>m_pThis</b> pointer gets initialized:</p>
<pre><code>CNTService::CNTService(const char* szServiceName)
{
 &nbsp;&nbsp; // Copy the address of the current object so we can access it from
 &nbsp;&nbsp; // the static member callback functions.
 &nbsp;&nbsp; // WARNING: This limits the application to only one CNTService object. 
 &nbsp;&nbsp; m_pThis = this;
 &nbsp; [...]
}
</code></pre>
<h2>The CNTService Class</h2>
<p>
When I create C++ objects to encapsulate groups of Microsoft Windows® functions, I try to do more than just make a member function for each Windows API I'm encapsulating. I try to make the object easy to use, and I try to help reduce the number of lines of code needed to implement a particular section of a project. So my object designs are based on "what do I want to do with this object?" rather than "what does Windows do with this set of APIs?".</p>
<p>
The <b>CNTService</b> class contains member functions to parse a command line, to handle installing and removing the service, and to log events, and a set of virtual functions that you can override in your derived class to handle requests from the service control manager. We'll look at the use of most of these functions as we go through the implementation of the sample service.</p>
<p>
If you want to create the simplest possible service, you need only override <b>CNTService::Run</b>, which is where you write the code to perform whatever task your service provides. You also need to implement the <b>main</b> function. If your service needs to perform some initialization, such as reading data from the registry, it also needs to override <b>CNTService::OnInit</b>. If you need to be able to send command messages to your service, you can do this by using the <b>ControlService</b> system function and handling the requests in the service by overriding <b>CNTService::OnUserControl</b>.</p>
<h3>Using CNTService in the Sample Application</h3>
<p>
The NTService sample implements most of its functionality in the <b>CMyService</b> class, which is derived from <b>CNTService</b>. Here's the MyService.h header file:</p>
<pre><code>// myservice.h

#include "ntservice.h"

class CMyService : public CNTService
{
public:
 &nbsp; CMyService();
 &nbsp; virtual BOOL OnInit();
 &nbsp;&nbsp;&nbsp;&nbsp; virtual void Run();
 &nbsp;&nbsp;&nbsp;&nbsp; virtual BOOL OnUserControl(DWORD dwOpcode);

 &nbsp;&nbsp;&nbsp;&nbsp; void SaveStatus();

 &nbsp; // Control parameters
 &nbsp; int m_iStartParam;
 &nbsp; int m_iIncParam;

 &nbsp; // Current state
 &nbsp; int m_iState;
};
</code></pre>
<p>
As you can see, <b>CMyService</b> overrides <b>OnInit</b>, <b>Run</b>, and <b>OnUserControl</b> from <b>CNTService</b>. It also has a function called <b>SaveStatus</b> that is used to write data to the registry, and some member variables to hold the current state. The sample service increments an integer variable at regular intervals. The start value and increment value are both held as parameters in the registry. Not very exciting, but easy for you to follow. Let's move on now to see how the service is implemented.</p>
<h2>Implementing the main Function</h2>
<p>
Having derived <b>CMyService</b> from <b>CNTService</b>, it's now a simple matter to implement the <b>main</b> function (in NTServApp.cpp):</p>
<pre><code>int main(int argc, char* argv[])
{
 &nbsp;&nbsp; // Create the service object.
 &nbsp;&nbsp; CMyService MyService;
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Parse for standard arguments (install, uninstall, version, etc).
 &nbsp;&nbsp; if (!MyService.ParseStandardArgs(argc, argv)) {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Didn't find any standard args so start the service.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Uncomment the DebugBreak line below to enter the debugger
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // when the service is started.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //DebugBreak();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyService.StartService();
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // When we get here, the service has been stopped.
 &nbsp;&nbsp; return MyService.m_Status.dwWin32ExitCode;
}
</code></pre>
<p>
Not much code to look at here, but an awful lot happens when it's executed, so let's go through it step by step. First of all, we create an instance of the <b>MyService</b> class. The constructor sets the initial state and name of the service (MyService.cpp):</p>
<pre><code>CMyService::CMyService()
:CNTService("NT Service Demonstration")
{
 &nbsp; m_iStartParam = 0;
 &nbsp; m_iIncParam = 1;
 &nbsp; m_iState = m_iStartParam;
}
</code></pre>
<p>
A call is then made to <b>ParseStandardArgs</b> to see if the command line contains a request to install the service (<b>-i</b>), remove it (<b>-u</b>), or report its version number (<b>-v</b>). <b>CNTService::ParseStandardArgs</b> calls <b>CNTService::IsInstalled</b>, <b>CNTService::Install</b>, and <b>CNTService::Uninstall</b> to process these requests. If no recognizable command-line arguments are found, it is assumed that the service control manager is trying to start the service and a call is made to <b>StartService</b>. This function does not return until the service stops running. The call to <b>DebugBreak</b> causes a break into the debugger when the service is first started. When you are done debugging the code, you can comment out or delete this line.</p>
<h3>Installing and Removing the Service</h3>
<p>
Installing the service is handled by <b>CNTService::Install</b>, which registers the service with the Windows NT service manager and makes entries in the registry to support logging messages when the service is running.</p>
<p>
Removing the service is handled by <b>CNTService::Uninstall</b>, which simply informs the service manager that the service is no longer required. <b>CNTService::Uninstall</b> does not remove the actual service executable file.</p>
<h2>Writing Your Service Code</h2>
<p>
Now we need to write the code that actually implements your service. For the NTService sample there are three major functions to write. These cover initialization, actually running the service, and responding to control requests.</p>
<h3>Initialization</h3>
<p>
The registry has a location for services to store their parameters: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services. This is where I chose to store the configuration data for my service. I created a Parameters key and under that stored the values I wanted to save. So when the service starts, the <b>OnInit</b> function is called; it reads the initial settings from this place in the registry.</p>
<pre><code>BOOL CMyService::OnInit()
{
  // Read the registry parameters.
 &nbsp;&nbsp; // Try opening the registry key:
 &nbsp;&nbsp; // HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\&lt;AppName&gt;\Parameters
 &nbsp;&nbsp; HKEY hkey;
  char szKey[1024];
  strcpy(szKey, "SYSTEM\\CurrentControlSet\\Services\\");
  strcat(szKey, m_szServiceName);
  strcat(szKey, "\\Parameters");
 &nbsp;&nbsp; if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szKey,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KEY_QUERY_VALUE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hkey) == ERROR_SUCCESS) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Yes we are installed.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwType = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwSize = sizeof(m_iStartParam);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegQueryValueEx(hkey,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Start",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwType,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (BYTE*)&amp;m_iStartParam,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwSize);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwSize = sizeof(m_iIncParam);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegQueryValueEx(hkey,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Inc",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwType,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (BYTE*)&amp;m_iIncParam,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dwSize);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegCloseKey(hkey);
 &nbsp;&nbsp; }

  // Set the initial state.
  m_iState = m_iStartParam;

  return TRUE;
}
</code></pre>
<p>
Now that we have the service parameters, we are ready to run the service.</p>
<h3>Running the Service</h3>
<p>
The main body of the service code is executed when the <b>Run</b> function is called. My sample is rather simple:</p>
<pre><code>void CMyService::Run()
{
 &nbsp;&nbsp; while (m_bIsRunning) {

 &nbsp;&nbsp; // Sleep for a while.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DebugMsg("My service is sleeping (%lu)...", m_iState);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sleep(1000);

 &nbsp;&nbsp; // Update the current state.
 &nbsp;&nbsp; m_iState += m_iIncParam;
 &nbsp;&nbsp; }
}
</code></pre>
<p>
Note that this function does not exit until the service is stopped. The <b>CNTService::m_bIsRunning</b> flag is set to FALSE when a request is made to stop the service. You can also override <b>OnStop</b> and/or <b>OnShutdown</b> if you need to perform cleanup when your service terminates.</p>
<h3>Responding to Control Requests</h3>
<p>
You can communicate with your service in whatever way suits you—named pipes, thought transference, sticky notes, and so on—but for simple requests the system function <b>ControlService</b> is very easy to use. <b>CNTService</b> provides a handler for non-standard (that is, user) messages sent through the <b>ControlService</b> function. My sample uses a single message to save the current state of the service in the registry so that other applications can inspect it. I'm not proposing this as the best way to monitor a service, just one that was easy to implement and interesting to code. User messages sent by means of <b>ControlService</b> must be in the range 128 to 255. I defined a constant, SERVICE_CONTROL_USER, as the base value (128). Messages in the user range are sent to <b>CNTService:: OnUserControl</b> and are handled in the sample service this way:</p>
<pre><code>BOOL CMyService::OnUserControl(DWORD dwOpcode)
{
 &nbsp;&nbsp; switch (dwOpcode) {
 &nbsp;&nbsp; case SERVICE_CONTROL_USER + 0:

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Save the current status in the registry.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SaveStatus();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;

 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return FALSE;&nbsp;&nbsp; // say not handled
}
</code></pre>
<p>
<b>SaveStatus</b> is a local function that saves the service state in the registry.</p>
<h2>Debugging a Windows NT Service</h2>
<p>
The <b>main</b> function contains a call to <b>DebugBreak</b>, which causes the system debugger to be activated when the service is first started. You can monitor the debug messages from the service in the debugger's command window. You can use <b>CNTService::DebugMsg</b> from your service to report events of interest during debugging.</p>
<p>
You'll need to install the system debugger (<b>WinDbg</b>) from the Win32 SDK in order to debug your service code.</p>
<p>
One important point to note is that you really can't stop the service and single-step it when it's being controlled by the service manager, because the service manager will time out requests to the service and terminate the service thread. So you can really only get your service to spit out messages to track its progress and watch them in the debugger window.</p>
<p>
When the service is started (for example, from the Services applet in Control Panel), the debugger will start with the service thread halted. You need to let the thread run by clicking the GO button or pressing the F5 key. Then you can observe the service's progress in the debugger window.</p>
<p>
The following text shows an example of starting and stopping the service:</p>
<pre><code>Module Load: WinDebug/NTService.exe&nbsp; (symbol loading deferred)
Thread Create:&nbsp; Process=0, Thread=0
Module Load: C:\NT351\system32\NTDLL.DLL&nbsp; (symbol loading deferred)
Module Load: C:\NT351\system32\KERNEL32.DLL&nbsp; (symbol loading deferred)
Module Load: C:\NT351\system32\ADVAPI32.DLL&nbsp; (symbol loading deferred)
Module Load: C:\NT351\system32\RPCRT4.DLL&nbsp; (symbol loading deferred)
Thread Create:&nbsp; Process=0, Thread=1
*** WARNING: symbols checksum is wrong 0x0005830f 0x0005224f for C:\NT351\symbols\dll\NTDLL.DBG
Module Load: C:\NT351\symbols\dll\NTDLL.DBG&nbsp; (symbols loaded)
Thread Terminate:&nbsp; Process=0, Thread=1, Exit Code=0
Hard coded breakpoint hit
Hard coded breakpoint hit
[](130): CNTService::CNTService()
Module Load: C:\NT351\SYSTEM32\RPCLTC1.DLL&nbsp; (symbol loading deferred)
[NT Service Demonstration](130): Calling StartServiceCtrlDispatcher()
Thread Create:&nbsp; Process=0, Thread=2
[NT Service Demonstration](174): Entering CNTService::ServiceMain()
[NT Service Demonstration](174): Entering CNTService::Initialize()
[NT Service Demonstration](174): CNTService::SetStatus(3026680, 2)
[NT Service Demonstration](174): Sleeping...
[NT Service Demonstration](174): CNTService::SetStatus(3026680, 4)
[NT Service Demonstration](174): Entering CNTService::Run()
[NT Service Demonstration](174): Sleeping...
[NT Service Demonstration](174): Sleeping...
[NT Service Demonstration](174): Sleeping...
[NT Service Demonstration](130): CNTService::Handler(1)
[NT Service Demonstration](130): Entering CNTService::Stop()
[NT Service Demonstration](130): CNTService::SetStatus(3026680, 3)
[NT Service Demonstration](130): Leaving CNTService::Stop()
[NT Service Demonstration](130): Updating status (3026680, 3)
[NT Service Demonstration](174): Leaving CNTService::Run()
[NT Service Demonstration](174): Leaving CNTService::Initialize()
[NT Service Demonstration](174): Leaving CNTService::ServiceMain()
[NT Service Demonstration](174): CNTService::SetStatus(3026680, 1)
Thread Terminate:&nbsp; Process=0, Thread=2, Exit Code=0
[NT Service Demonstration](130): Returned from StartServiceCtrlDispatcher()
Module Unload: WinDebug/NTService.exe
Module Unload: C:\NT351\system32\NTDLL.DLL
Module Unload: C:\NT351\system32\KERNEL32.DLL
Module Unload: C:\NT351\system32\ADVAPI32.DLL
Module Unload: C:\NT351\system32\RPCRT4.DLL
Module Unload: C:\NT351\SYSTEM32\RPCLTC1.DLL
Thread Terminate:&nbsp; Process=0, Thread=0, Exit Code=0
Process Terminate:&nbsp; Process=0, Exit Code=0
&gt;
</code></pre>
<h2>Summary</h2>
<p>
Perhaps C++ isn't ideal for creating a Windows NT service, but having a single class from which you can derive your own service certainly makes it easy to get your own service started. As usual, if you or your relatives, friends, pets, or acquaintances have comments or suggestions, please mail them to me: nigelt@microsoft.com.</p>
</BODY>
</HTML>
