<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Calling COM Objects with Interface Wrappers</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_comwrap"></a></sup>Calling COM Objects with Interface Wrappers</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
October 24, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="4477">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the files for the WrapUser sample application.</a></p>
<h2>Abstract</h2>
<p>
Wrapping a Component Object Model (COM) interface in a C++ class simplifies using the COM object and improves program readability and correctness.</p>
<p>
A sample application, WrapUser, accompanies this article. Make sure that you add the COM object called SimpleObject to the registration database before attempting to run WrapUser.</p>
<h2>Introduction</h2>
<p>
In the technical article <a href="msdn_smart.htm">"Calling COM Objects with Smart Interface Pointers,"</a> I said that I didn't like the un-C++-like nature of smart pointers. Smart pointers are not the same as native C++ pointers, but they are close enough to cause confusion for users of smart pointers. In that article, I said I preferred using interface wrappers instead of smart interface pointers.</p>
<p>
This article will explore the use of COM interface wrappers, covering the following topics:
<ul type=disc>
<li>
What are interface wrappers?<br><br></li>
<li>
Implementing an interface wrapper.<br><br></li>
<li>
Using an interface wrapper.<br><br></li>
<li>
Interface wrappers vs. smart interfaces.</li>
</ul>
<p>
For those who need justification for using wrappers, I will defer the issue to James Coplien's excellent book <i>Advanced C++ Programming Styles and Idioms</i>. James uses the terms <i>envelope</i> <i>class</i> and <i>letter class</i> in his book. The envelope class wraps or contains the letter class. The envelope/letter idiom provides several benefits, including reducing the impact of change and providing more run-time support. The envelope/letter idiom is the basis for most of the advanced techniques presented in the book.</p>
<h2>WrapUser Sample Application</h2>
<p>
The WrapUser sample application demonstrates how to use Component Object Model (COM) interface wrappers. COM interface wrappers are classes that contain a pointer to a COM interface and forward calls to the COM object. The interface wrappers are implemented in CInterfaceWrap.h, which includes implementations for <b>CInterfaceWrap</b> and <b>CUnknownWrap</b>. <b>CSimpleWrap</b> implements the interface wrapper for the <b>ISimple </b>interface and inherits from <b>CInterfaceWrap</b>. The <b>ISimple</b> interface is implemented in the SimpleObject.dll.</p>
<p>
WrapUser allows you to create SimpleObject COM objects, call the <b>Inc</b> function in the <b>ISimple</b> interface, and <b>Release</b> the object (see Figure 1). Select the object in the list box to see its current count, then increment the count or release the object.</p>
<p>
<img src="comwrap_1.gif" border=0></p>
<p class=label>
<b>Figure 1. WrapUser interface</b></p>
<p>
Before WrapUser will work, you must register the SimpleObject object. First, edit the paths in SimpleObject.reg to point to the location of the SimpleObject.dll. Then double-click SimpleObject.reg to add it to the registry.</p>
<h2>What Are Interface Wrappers?</h2>
<p>
For the purposes of this article, a wrapper is defined as <i>a C++ class that contains an object to which the C++ class provides an interface</i>. A wrapper can wrap C functions, functions exported from a dynamic-link library (DLL), another C++ class, an OLE automation interface, an OLE control, a COM object, or any other set of functions (see Figure 2). This article is only concerned with wrapping COM objects.</p>
<p>
<img src="comwrap_2.gif" border=0></p>
<p class=label>
<b>Figure 2. A wrapper is a C++ class that wraps an object.</b></p>
<p>
Given the <b>ISimple</b> interface below:</p>
<pre><code>class ISimple : public IUnknown
{
public:
 &nbsp; virtual void __stdcall&nbsp; SetCount(int count) = 0 ;
 &nbsp; virtual int __stdcall&nbsp;&nbsp; GetCount() = 0 ;
 &nbsp; virtual void __stdcall&nbsp; Inc() = 0 ;
};
</code></pre>
<p>
the C++ wrapper class might look like this:</p>
<pre><code>class CSimpleWrap
{
public:
 &nbsp;&nbsp; CSimpleWrap(ISimple* m_pI) ;

 &nbsp; void SetCount(int count)
 &nbsp;&nbsp;&nbsp;&nbsp; { m_pI-&gt;SetCount(count) ;}

 &nbsp; int GetCount()
 &nbsp;&nbsp;&nbsp;&nbsp; { m_pI-&gt;GetCount(count) ;}

 &nbsp; void Inc()
 &nbsp;&nbsp;&nbsp;&nbsp; { m_pI-&gt;Inc() ;}

protected:
 &nbsp;&nbsp; ISimple* m_pI ;
};
</code></pre>
<p>
The process is rather simple: The class has an inline member function for each of the functions in the COM interface. These member functions call or wrap the functions in the COM interface.</p>
<p>
The smart pointer method didn't require the implementation of each of these member functions, because <b>operator-&gt; </b>was overloaded. <b>operator-&gt; </b>delegates the calls to the contained object automatically. Below is a simplified example of a smart interface pointer class:</p>
<pre><code>class CSimpleSmartInteface
{
public:
 &nbsp;&nbsp; CSimpleSmartInterface(ISimple* m_pI) ;

 &nbsp;&nbsp; ISimple* operator-&gt;()
 &nbsp;&nbsp;&nbsp;&nbsp; { return m_pI ;} 

protected:
 &nbsp;&nbsp; ISimple* m_pI ;
};
</code></pre>
<p>
The code generated for the two methods is the same. </p>
<pre><code>CSimpleWrap WISimple(pISimple) ;
WISimple.Inc() ;

CSimpleSmartInterface SISImple(pISimple) ;
SISimple-&gt;Inc() ;
</code></pre>
<p>
For the interface wrapper method, the compiler replaces <b>WISimple.Inc()</b> with <b>WISimple.m_pI-&gt;Inc()</b>; for the smart interface method it replaces <b>SISimple-&gt;Inc()</b> with <b>SISimple.m_pI-&gt;Inc()</b>.</p>
<h2>Implementing the Interface Wrapper</h2>
<p>
The CInterfaceWrap.h file in the WrapUser sample application contains the implementation for <b>CInterfaceWrap</b> and <b>CUnknownWrap</b>. The following is the definition for <b>CInterfaceWrap</b>:</p>
<pre><code>template &lt;class I, const IID* pIID&gt;
class CInterfaceWrap 
{
public:
 &nbsp;&nbsp; CInterfaceWrap(); 
 &nbsp;&nbsp; ~CInterfaceWrap();

 &nbsp; HRESULT CreateObject(const CLSID&amp; rCLSID);

 &nbsp; operator I*() ;

 &nbsp; void Attach(IUnknown* pI) ;
 &nbsp; void Attach(I* pI) ;

 &nbsp; void Detach() ;

 &nbsp; BOOL IsOK() const { return m_pI != NULL; }

protected:
 &nbsp;&nbsp; I* m_pI ;

};
</code></pre>
<p>
You will notice that this class is similar to the <b>CSmartInterface</b> class. Both are template classes that use the contained interface pointer as one of the template arguments. Both define various ways to connect to interface pointers. </p>
<p>
The main difference between <b>CSmartInterface</b> and <b>CInterfaceWrap</b> is that <b>CSmartInterface</b> overloads the dereference operator, <b>operator-&gt;</b>. The other difference is that, as a class, <b>CSmartInterface</b> makes heavy use of operator overloading while <b>CInterfaceWrap</b> uses a more traditional function approach. I decided to make <b>CInterfaceWrap </b>much easier for the beginning C++ programmer to read and use. If you so choose, you can extend <b>CInterfaceWrap </b>to use <b>operator=</b> instead of <b>Attach</b>. I personally don't like my delicate little operators doing heavy work. You could also extend <b>CInterfaceWrap</b> to have multiple constructors in addition to the <b>Attach</b> functions.</p>
<h3>The Conversion Operator</h3>
<p>
The one operator that I did define was the conversion operator:</p>
<pre><code>template &lt;class I, const IID* pIID&gt; inline
CInterfaceWrap&lt;I,pIID&gt;::operator I*()
{
 &nbsp; return m_pI ;
}
</code></pre>
<p>
The conversion operator converts from a <b>CInterface&lt;I, pIID&gt;</b> to an <b>I*</b>. Using the conversion operator means that I don't have to define another <b>Attach</b> function to take a <b>CInterface&lt;I,&nbsp;pIID&gt;</b> object. With the conversion operator, the following code is possible:</p>
<pre><code>CSimpleWrap WISimple ;
WISmple.CreateObject(CLSID_Simple) ;

CUnknownWrap WIUnknown ;
WIUnknown.Attach(WISimple) ;
</code></pre>
<p>
This is much more convenient than using a function call such as:</p>
<pre><code>WIUnknown.Attach(WISimple.GetPtr()) ;
</code></pre>
<h3>The Attach Function</h3>
<p>
There are two versions of <b>Attach</b>. The first one, which is used to copy interface pointers of the same type as the wrapper, just does an <b>AddRef </b>on the new pointer:</p>
<pre><code>template &lt;class I, const IID* pIID&gt; inline
void CInterfaceWrap&lt;I,pIID&gt;::Attach(I* pI)
{
 &nbsp; if (m_pI != pI) // Optimization
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; Detach() ;
 &nbsp;&nbsp;&nbsp;&nbsp; m_pI = pI ;

 &nbsp;&nbsp;&nbsp;&nbsp; if (m_pI != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pI-&gt;AddRef() ;
 &nbsp; }
}
</code></pre>
<p>
The other <b>Attach</b> function is used when the interface to connect to is different from the type the wrapper contains. This <b>Attach</b> must call <b>QueryInterface</b> to get an interface pointer of the correct type.</p>
<pre><code>template &lt;class I, const IID* pIID&gt; inline
void CInterfaceWrap&lt;I,pIID&gt;::Attach(IUnknown* pI)
{
 &nbsp; if (m_pI != pI) // Optimization
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; Detach() ;
 &nbsp;&nbsp;&nbsp;&nbsp; if (pI != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get controlling Unknown.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pI-&gt;QueryInterface(*pIID, (void**)&amp;m_pI) ;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pI = NULL ;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
}
</code></pre>
<h3>CUnknownWrap</h3>
<p>
CInterfaceWrap.h also includes the definition of <b>CUnknownWrap</b>, which is a specific case of <b>CInterfaceWrap</b>. A separate <b>CUnknownWrap</b> is required because</p>
<pre><code>CInterfaceWrap&lt;IUnknown, &amp;IID_IUnknown&gt; WIUnknown ;
</code></pre>
<p>
would result in two <b>Attach(IUnknown* pI)</b> functions, which is illegal. This would also be true for <b>CSmartInterface</b> if it defined <b>operator=(IUnknown*)</b> in addition to <b>operator=(I*)</b>.</p>
<p>
Fans of C++ know that you can also use an explicit specialization of <b>CInterfaceWrap</b> to handle this class:</p>
<pre><code>class CInterfaceWrap&lt;IUnknown,+IID_Unknown&gt;
{
 public:
 .
 .
 .
 &nbsp; void Attach(IUnknown* pI) ;
}
</code></pre>
<p>
It is also possible to use inheritance to implement <b>CInterfaceWrap</b> and <b>CUnknownWrap</b>; however, I found the resulting complexity to be more trouble than it is worth.</p>
<h2>Using the Interface Wrapper</h2>
<p>
Interface wrappers are very easy to use. First, you wrap the interfaces that you are going to use:</p>
<pre><code>#include "SimpleObject\GUIDS.h"
#include "SimpleObject\ISimple.h"
#include "CInterfaceWrap.h"

typedef CInterfaceWrap&lt;ISimple, &amp;IID_ISimple&gt; CSimpleWrapBase ;

class CSimpleWrap : public CSimpleWrapBase
{
public:
 &nbsp; CSimpleWrap() {}

 &nbsp; void SetCount(int count)
 &nbsp;&nbsp;&nbsp;&nbsp; {ASSERT(m_pI); m_pI-&gt;SetCount(count) ;}
 &nbsp; int GetCount()
 &nbsp;&nbsp;&nbsp;&nbsp; {ASSERT(m_pI); return m_pI-&gt;GetCount() ;}
 &nbsp; void Inc()&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp; {ASSERT(m_pI); m_pI-&gt;Inc();}
};
</code></pre>
<p>
You can then use the interface wrappers as objects.</p>
<pre><code>&nbsp;&nbsp;&nbsp;CSimpleWrap WISimple;
 &nbsp; WISimple.CreateObject(CLSID_SimpleObject) ;
 &nbsp; if (!WISimple.IsOK())
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("ISimple not supported");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp; }
 &nbsp; WISimple.SetCount(10) ;
 &nbsp; WISimple.Inc() ;
</code></pre>
<p>
There is no need to call <b>Release</b> because the destructor will automatically release the object when it falls out of scope.</p>
<p>
You can also use interface wrappers as pointers.</p>
<pre><code>&nbsp;&nbsp;&nbsp;CSimpleWrap* pWISimple = new CSimpleWrap ;
 &nbsp; pWISimple-&gt;CreateObject(CLSID_SimpleObject) ;
 &nbsp; if (!pWISimple-&gt;IsOK())
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("ISimple not supported");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete pWISimple ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp; }
 &nbsp; pWISimple-&gt;SetCount(10) ;
 &nbsp; pWISimple-&gt;Inc() ;
 &nbsp; delete pWISimple ;
</code></pre>
<p>
In this case, you have to call <b>delete</b> both to free up the interface wrapper object and to release the object. If you don't want to release the interface wrapper, you can use the <b>Detach</b> method, which calls <b>Release</b> on the contained interface pointer. </p>
<p>
The conversion operator lets you connect an interface wrapper to an existing operator.</p>
<pre><code>&nbsp;&nbsp;&nbsp;CUnknownWrap WIUnknown ;
 &nbsp; WIUnknown.CreateObject(CLSID_SimpleObject) ;
 &nbsp; if (!WIUnknown.IsOK())
 &nbsp;&nbsp;&nbsp;&nbsp; return ;

 &nbsp; CSimpleWrap* pWISimple = new CSimpleWrap ;

 &nbsp; // Attach the ISimple wrapper to the IUnknown wrapper's object.
 &nbsp; pWISimple-&gt;Attach(WIUnknown) ;
 &nbsp; if (!pWISimple-&gt;IsOK())
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRACE("ISimple not supported");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete pWISimple ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
 &nbsp; }
</code></pre>
<p>
You can see that using interface wrappers makes dealing with COM objects similar to dealing with C++ objects.</p>
<h2>Interface Wrappers vs. Smart Interface Pointers</h2>
<p>
Nothing is perfect. Both interface wrappers and smart interface pointers have their good points and their bad points. Choosing between the two is a matter of personal taste and will depend on the applications you are writing.</p>
<h3>Why Interface Wrappers Are Better</h3>
<p>
I prefer using interface wrappers over smart interface pointers for several reasons: Interface wrappers are normal C++ classes. They are not a hybrid like smart interface pointers. Smart interface pointers are not really pointers, but they don't really act like normal C++ objects either.</p>
<p>
If <b>CSmartInterface</b> had an <b>IsOK</b> member function, the code using it would look weird:</p>
<pre><code>CSmartInterface&lt;ISimple,&amp;IID_Simple&gt; SISimple(pISimple) ;
if (SISimple.IsOK())
{
 &nbsp; SISimple-&gt;SetCount(10) ;
 &nbsp; SISimple-&gt;Inc() ;
}
</code></pre>
<p>
Notice how the code mixes the dereference operator with the member access operator. It's very confusing code.</p>
<p>
An interface wrapper gives you more control over the COM object you are calling. If you desire, you can add code before and after calling the COM object. You can also leave calls out. You can call <b>Release</b> using <b>CSmartInterface</b>. You can't call <b>Release</b> with <b>CInterfaceWrap</b> because it is not defined for the object. Converting an application from using straight interface pointers to using smart interface pointers can result in bugs, if calls to <b>Release</b> aren't removed.</p>
<p>
Another reason I like <b>CInterfaceWrap</b> is that I can use it easily as a pointer or an object. Using pointers to smart interface pointers is mentally confusing and the code isn't as readable either.</p>
<p>
Coplien (see Bibliography) supplies other justifications for separating the interface of a class from its implementation.</p>
<h3>Why Smart Interface Pointers Might Be Better</h3>
<p>
The biggest drawback to interface wrappers is that they must be built by hand from the COM interface. To use an interface wrapper, you have to implement the individual member functions that call the contained interface. This is a real pain for applications that use many interfaces and for objects that have large interfaces with many functions.</p>
<p>
When a COM interface changes, the wrapper class must be changed to stay in sync. This can be a real nuisance in an application with many COM objects. However, it is unlikely that this will cause a bug, because the C++ compiler will catch the differences between the wrapper class and the COM interface.</p>
<p>
The smart interface doesn't have this problem. You don't have to implement a separate class for every interface you use, which in some applications could be a lot of extra classes. The interface definition is enough for the C++ compiler, which takes care of delegating the calls to the contained object.</p>
<p>
One possible workaround to this problem could be to create a tool (as part of the build process) that takes a typelib and generates the header file automatically. Such an approach would be a powerful solution.</p>
<p>
Because COM interfaces are fixed and do not change once they are published, this drawback isn't nearly as bad as it could be—the problem of maintaining the interface wrapper exists only while the COM interface is in development. Also, in many cases the extra flexibility and control provided by the interface wrapping approach can make up for the extra work. Inheritance has made many a C++ developer very lazy.</p>
<h2>Conclusion</h2>
<p>
Using interface wrappers makes dealing with COM interfaces easier and more type-safe. Interface wrappers make programs more robust and help prevent bugs at compile time. Interface wrappers can be treated like any standard C++ class, unlike smart interface pointers, which aren't really pointers and aren't really normal objects. The biggest drawback to using interface wrappers is that they must be changed whenever the COM interface they wrap changes. Because smart interface pointers delegate the contained object, they automatically track changes. Luckily, COM interfaces don't change once they are published. Whichever method you choose, your applications will be easier to write and debug.</p>
<h2>Bibliography</h2>
<p>
Coplien, James O. <i>Advanced C++ Programming Styles and Idioms</i>. Reading, MA: Addison-Wesley, 1991. ISBN 0-201-54855-0. (Look under "Delegation" in the index.)</p>
</BODY>
</HTML>
