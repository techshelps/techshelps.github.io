<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Diagnosing and Profiling Applications</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Diagnosing and Profiling Applications</h1>
<p>
Programmers can use several tools to trace the SQL statements received and generated by the SQL&nbsp;Server ODBC driver. They can also use the Windows&nbsp;NT Performance Monitor and SQL&nbsp;Server ODBC driver profiling features to analyze the performance of the driver.</p>
<h3>Tracing SQL Statements</h3>
<p>
Microsoft SQL&nbsp;Server and ODBC offer several points at which users can trace the SQL statements on their journey from the application to SQL&nbsp;Server, as shown in the following illustration:</p>
<p>
<img src="odbcsql_3.gif" border=0></p>
<h4>ODBC Driver Manager Trace</h4>
<p>
The ODBC Driver Manager trace facility is available on all ODBC clients and is started from ODBC Administrator.</p>
<p>
<b>To start trace from ODBC Administrator</b>
<ol>
<li>
In the ODBC Administrator window, click <b>Options</b>.<br><br></li>
<li>
Click the trace options you want.</li>
</ol>
<p>
The ODBC trace facility traces all calls made to any ODBC data source on the client. It records ODBC calls immediately after they come into the Driver Manager from the application. This is helpful in debugging problems that the Driver Manager may have when connecting to a driver. </p>
<p>
This is a fairly minimal trace, however, and is used only when the second tool, ODBCSpy, is not available.</p>
<p>
Here's an example of an ODBC Driver Manager trace output:</p>
<pre><code>SQLAllocEnv (phenv00145E08);
SQLAllocConnect (henv00145E08, phdbc00145878);
SQLDriverConnect (hdbc00145878, hwnd00870544, "DSN=ab60def;UID=sa;PWD=;", -3, szConnStrOut,0, pcbConnStrOut, 1);
SQLError(henv00000000,hdbc00145878,hstmt00000000, szSQLState, pfNativeError, szErrorMsg, 512, pcbErrorMsg);
SQLAllocStmt(hdbc00145878, phstmt0014A990);
SQLExecDirect(hstmt0014A990, "select * from discounts",&nbsp;&nbsp;&nbsp; -3);
</code></pre>
<p>
A lot of information is missing from this output. There is no indication of the return code for each function call. There is no way to tell if the <b>SQLDriverConnect</b> call was successful; however, the fact that the next call was to <b>SQLError</b> could indicate some problem. Since the trace does not show what <i>szErrorMsg</i> string or <i>SQLStat</i>e value was returned by <b>SQLError</b>, there is no way to tell what the problem might have been. The fact that the application went on to allocate a statement handle and execute a statement seems to show that no major problem was encountered.</p>
<p>
When Driver Manager tracing is on, all calls to ODBC drivers on that client are traced. There is no way to trace only a specific data source.</p>
<h4>ODBCSpy Trace</h4>
<p>
The ODBCSpy utility ships with the ODBC SDK and can be used to get an informative trace of all the ODBC calls made to a specific ODBC data source. ODBCSpy traces calls as they are passed from the Driver Manager to the ODBC driver. It shows all of the parameters passed for each call to the driver and the information returned from the driver. If an error is encountered, ODBCSpy calls <b>SQLError</b> for all error messages returned and logs all information about the errors in the trace.</p>
<p>
Here's an ODBCSpy trace of the same <b>SQLError</b> call traced in the example above:</p>
<pre><code>SQLError
 &nbsp; NULL
 &nbsp; 0x01010000
 &nbsp; NULL
 &nbsp; [5]01000
 &nbsp; 5701
 &nbsp; [85][Microsoft][ODBC SQL&nbsp;Server Driver] 
 &nbsp;&nbsp;&nbsp;&nbsp; [SQL&nbsp;Server] Changed database context to 'master'
 &nbsp; 512
 &nbsp; 85
 &nbsp; SQL_SUCCESS
</code></pre>
<p>
This trace output includes more useful information. It shows that the <b>SQLError</b> function itself returned SQL_SUCCESS. (The entry for <b>SQLDriverConnect</b> would have shown that it returned SQL_SUCCESS_WITH_INFO, not SQL_ERROR.) The trace also shows that <b>SQLError</b> returned a <i>SQLState</i> of 01000, a <i>pfNative</i> of 5701, and a <i>szErrorMsg</i> string that indicates SQL&nbsp;Server has changed the connection context to the <b>master</b> database.</p>
<p>
There are also third-party ODBC tracing tools available.</p>
<h4>SQL Trace</h4>
<p>
SQL Trace, a trace utility introduced in SQL&nbsp;Server 6.5, uses Open Data Services to intercept and trace all SQL statements coming in to SQL&nbsp;Server. SQL Trace is extremely valuable for determining if a problem is due to the Transact-SQL statements the driver generates to support the ODBC commands coming from the application. A programmer can use ODBCSpy to see exactly what comes from the application to the SQL&nbsp;Server ODBC driver, and then use SQL Trace to see what the driver actually sends to the server.</p>
<p>
If an application does:</p>
<pre><code>SQLExecDirect(hstmt, "exec sp_helpdb 'pubs' ", SQL_NTS);
</code></pre>
<p>
SQL Trace shows:</p>
<pre><code>-- 1/29/97 17:13:23.530 SQL (ID=3, SPID=12, User=sa(MyDomain\MyNTAccount), App='Microsoft ODBC SDK v2.0', Host='MyServer'(d3) )
exec sp_helpdb 'pubs'
go
</code></pre>
<p>
SQL Trace can be used to dynamically trace statements coming in from different clients to a server. Sites that have servers earlier than SQL&nbsp;Server 6.5 can use an older, unsupported version of the utility called SQLEye. SQLEye is available on the Microsoft TechNet compact disc.</p>
<h4>SQL&nbsp;Server Trace Flags</h4>
<p>
SQL&nbsp;Server has a DBCC trace flag (4032) that causes the server to trace incoming SQL statements. SQL Trace is much easier to use, so sites that have SQL Trace or SQLEye generally use those tools instead of the trace flags.</p>
<p>
When a user sets the 4032 trace flag, the user also generally sets a couple of other trace flags to control the trace: 
<ul type=disc>
<li>
For the 3605 flag, SQL&nbsp;Server traces SQL statements to the SQL&nbsp;Server error log (C:\Mssql\Log\Errorlog). <br><br></li>
<li>
For the 3604 flag, the trace output is returned to the application that set the flags. <br><br></li>
<li>
For the -1 flag, SQL&nbsp;Server traces all SQL statements coming into the server, not just the ones from the connection that set the flags. </li>
</ul>
<p>
To have SQL&nbsp;Server trace all SQL statements from all clients to the error log:</p>
<pre><code>SQLExecDirect(hstmt, "dbcc traceon(3605, 4032, -1)", SQL_NTS);
</code></pre>
<p>
For more information about trace flags, see the SQL&nbsp;Server documentation.</p>
<h3>Windows&nbsp;NT Performance Monitor</h3>
<p>
Windows&nbsp;NT Performance Monitor is a powerful tool for profiling the performance of SQL&nbsp;Server applications. SQL&nbsp;Server installs several counters in Performance Monitor (for more information, see the <i>Microsoft SQL&nbsp;Server Administrator's Companion</i>). In SQL&nbsp;Server 6.5, users can also add up to 10 user-defined counters (for more information, see <i>What's New in SQL&nbsp;Server 6.5</i>). To get a better idea of how your query impacts the operation of the server, use the SQL&nbsp;Server counters in Performance Monitor to track the resources used by your application.</p>
<h3>ODBC Driver Profiling Features</h3>
<p>
The SQL&nbsp;Server ODBC driver version 2.65.0201 and later offers a couple of features that aid in analyzing performance of ODBC applications: 
<ul type=disc>
<li>
The driver can trace all queries where the server's response exceeds a specified time interval, allowing programmers to easily target long-running queries for analysis.<br><br></li>
<li>
The driver can log performance statistics that summarize the performance of the system.</li>
</ul>
<h4>Logging Long-Running Queries</h4>
<p>
Applications can request that the driver write all queries whose response exceeds a specified time limit to a file for later analysis by the programmer and database administrator. The log can be turned on in two ways.
<ul type=disc>
<li>
When an application connects using a data source that specifies long query profiling, the SQL&nbsp;Server ODBC driver will log long-running queries from the time the application connects until it disconnects. For more information, see "Setup and Connecting."<br><br></li>
<li>
Use <b>SQLSetConnectOption</b> to set logging on and off dynamically.</li>
</ul>
<p>
An application dynamically setting the profiling options first specifies the file to use for the log by executing:</p>
<pre><code>SQLSetConnectOption(hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_COPT_SS_PERF_QUERY_LOG,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ULONG)"c:\\odbcqry.log");
</code></pre>
<p>
It then sets the interval by executing:</p>
<pre><code>SQLSetConnectOption(hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_COPT_SS_PERF_QUERY_INTERVAL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1);
</code></pre>
<p>
The number specified is in seconds, so the call shown above causes all queries that do not return within one second to be logged.</p>
<p>
Note: The query profiling interval in a data source is specified in units of milliseconds.</p>
<p>
After these options are enabled, the application can turn logging on and off dynamically by executing:</p>
<pre><code>SQLSetConnectOption(hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_COPT_SS_PERF_QUERY,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_PERF_START);
SQLSetConnectOption(hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_COPT_SS_PERF_QUERY,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_PERF_STOP);
</code></pre>
<p>
Note that this option is global to the application; therefore, after the option has been started for any of the SQL&nbsp;Server ODBC connections, long-running queries from all SQL&nbsp;Server ODBC connections open from the application are logged.</p>
<h4>Logging Performance Data</h4>
<p>
Applications can request that the driver log performance data for the driver. As with long-running query logging, the performance log can be turned on either by the application or by specifying performance logging in the data source using ODBC Administrator. For more information, see "Setup and Connecting."</p>
<p>
When dynamically turning on performance logging by calling <b>SQLSetConnectOption</b>, applications can either write the performance data to a log file or read the data into the application using a <b>sqlperf</b> structure defined in the Odbcss.h header file.</p>
<p>
The following commands start and stop performance-data gathering:</p>
<pre><code>SQLSetConnectOption(hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_COPT_SS_PERF_DATA,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_PERF_START);
SQLSetConnectOption(hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_COPT_SS_PERF_DATA,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_PERF_STOP);
</code></pre>
<p>
Performance statistics are recorded in a data structure named <b>sqlperf</b> (for an explanation of the <b>sqlperf</b> variables, see the appendix). The statistics are global for all connections made through the driver by the application. For example, if the application starts the performance statistics and opens three connections, the statistics are global for all three connections.</p>
<p>
If an application wants to log performance data to a file, the following command creates the log file:</p>
<pre><code>SQLSetConnectOption(hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_COPT_SS_PERF_DATA_LOG,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ULONG)"c:\\odbcperf.log");
</code></pre>
<p>
The log file is a tab-delimited text file that can be opened in Microsoft Excel (specify tab delimited in the wizard that appears). Most other spreadsheet products also support opening a tab-delimited text file.</p>
<p>
The following command writes a record to the performance log, with the current contents of the data structure recording the performance data:</p>
<pre><code>SQLSetConnectOption(hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_COPT_SS_PERF_DATA_LOG_NOW,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ULONG)NULL);
</code></pre>
<p>
The application does not need to set up a performance log; it could instead pull the performance data by using <b>SQLGetConnectOption</b> to get a pointer to the <b>sqlperf</b> structure. This structure is declared in a typedef in the Odbcss.h header file. The following statements are an example of pulling the statistics into the application:</p>
<pre><code>SQLPERF *PerfPtr;
// Initialize PerfPtr with pointer to performance data.
SQLGetConnectOption(hdbc,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_COPT_SS_PERF_DATA,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;PerfPtr);
printf("SQLSelects = %d, SQLSelectRows = %d\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PerfPtr-&gt;SQLSelects, PerfPtr-&gt;SQLSelectRows);
</code></pre>
<p>
If the application uses a data source that has the performance-statistics profiling option activated, the driver writes the statistics header information to the log file and starts accumulating the statistics in its internal data structure when the application makes its first connection using the driver. When the last connection to the SQL&nbsp;Server ODBC driver from the application is closed, the driver writes out the global, accumulated, performance statistics.</p>
<h4>Profiling Considerations</h4>
<p>
The fact that profiling is global to the driver governs the behavior of the log files. When an application connects to a data source that specifies profiling, the driver starts a log file and begins logging information from all connections active from the application to the SQL&nbsp;Server ODBC driver from that point forward. Even connections to SQL&nbsp;Server data sources that do not specify profiling are recorded because the profiling is done globally for the driver.</p>
<p>
If the application does a <b>SQLFreeEnv</b>, the ODBC Driver Manager unloads the driver. At this point, both the long-running query log and the performance statistics logs hold the information from the old connections. If the application then makes another connection to the data source that specifies profiling, the driver is reloaded, and it overwrites the old copy of the log file.</p>
<p>
If an application connects to a data source that specifies profiling, and then a second application connects to the same data source, the second application does not get control of the log file and therefore is not able to log any performance statistics or long-running queries. If the second application makes the connection after the first application disconnects, the driver overwrites the first application's log file with the one for the second application.</p>
<p>
Note that if an application connects to a data source that has either the long-running query or performance statistics enabled, the driver returns SQL_ERROR if the application calls <b>SQLSetConnectOption</b> to enable logging.&nbsp; A call to <b>SQLError</b> then returns the following message:</p>
<pre><code>SQLState: 01000, pfNative = 0
szErrorMsg: [Microsoft][ODBC SQL&nbsp;Server Driver]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An error has occurred during an attempt to access
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the log file, logging disabled.
</code></pre>
</BODY>
</HTML>
