<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Win32 Window Hierarchy and Styles</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_styles32"></a>Win32 Window Hierarchy and Styles</h1>
<p>
Kyle Marsh<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: September 29, 1993</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Technical Articles Sample">
<PARAM name="Item2" value="1806">
</OBJECT><a href="javascript:sample1.Click()">Click to view or copy the Styles sample application files for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This article describes the desktop, top-level, and child windows provided in the Win32® versions of the Microsoft® Windows™ operating system and their hierarchical relationships. It explains how applications can navigate the window structure and control the style and appearance of a window on the desktop.</p>
<h2>Window Hierarchy</h2>
<p>
The basic building block for displaying information in the Microsoft® Windows™ graphical environment is the window. Microsoft Windows manages how each window relates to all other windows in terms of visibility, ownership, and parent/child relationship. Windows uses this relationship information when creating, destroying, or displaying a window. The Windows window manager controls how windows relate to one another and stores the relationship information it needs by linking the window instance information of each window into a hierarchy known as the <i>window manager's list</i>.</p>
<p>
Within each window's instance information structure are four elements that the window manager uses to build the window manager's list:
<ul type=disc>
<li>
A handle to the window's child window<br><br></li>
<li>
A handle to the next window in the list of child windows (the next sibling)<br><br></li>
<li>
A handle to the window's parent<br><br></li>
<li>
A handle to the window's owner</li>
</ul>
<p>
<img src="styles32_1.gif" border=0></p>
<p class=label>
<b>Figure 1.</b></p>
<p>
When Windows initializes, it creates a window, known as the <i>desktop window</i>, that is sized to cover the entire display area and upon which all other windows are displayed. The window manager uses the desktop window as the top of the window manager's list. Thus, the desktop window is the top of the window hierarchy.</p>
<p>
Windows that form the next level of the window hierarchy are called <i>top-level windows</i>. A top-level window is any window that is not a child window. Top-level windows do not have the WS_CHILD style. The window manager connects top-level windows to the desktop window by connecting the top-level windows into a linked list with the head of the link list stored in the desktop window's child window handle, and by using each top-level window's next sibling handle to form the list. The linked list is known as a <i>child window list</i> because it is attached to the child window handle of a window. All windows connected to a child window list are considered siblings; therefore, all top-level windows are siblings of one another. The order of the child window list (first to last) also denotes the top to bottom order (the Z order) of the windows as seen on the display. The window manager uses this Z order to decide which windows and which parts of windows are visible on the display and which windows or parts of windows are hidden by other windows. When a window appears on the display below another window, it appears after that window in the child window list.</p>
<p>
All top-level windows are also connected to the desktop window through the parent window handle in the window instance information. Top-level windows are connected to the desktop window as if they were child windows of the desktop, and can be considered children of the desktop in that parent/child navigation techniques can be used to move between a top-level window and the desktop window.</p>
<p>
The window manager places top-level windows at the top of the Z order when they are created, and thus the entire window is visible. The window manager inserts the window at the head of the desktop window's child window list. An extended style, WS_EX_TOPMOST, controls where the window manager places a newly created window in the window manager's list. The window manager places windows without the WS_EX_TOPMOST style after any windows that have the WS_EX_TOPMOST style. Thus, windows with the WS_EX_TOPMOST style always display above windows without the WS_EX_TOPMOST style.</p>
<p>
<img src="styles32_2.gif" border=0></p>
<p class=label>
<b>Figure 2.</b></p>
<p>
Another type of relationship can exist between top-level windows: Top-level windows can own or be owned by other top-level windows. An owned window is always above its owner in the Z order and is hidden when its owner is minimized. Owned windows are not hidden when their owner is hidden. Thus, if Window A owns Window B, which in turn owns Window C, and if Window A is minimized, Window B is hidden but Window C remains visible. An application creates an owned window relationship by passing the window handle to the owner window in the <i>hwndParent</i> parameter of the <b>CreateWindow</b> (or <b>CreateWindowEx</b>) function when the application creates the owned window. If the window whose handle is in <i>hwndParent</i> is not a top-level window, Windows finds the top-level window for the given window and makes that top-level window the owner of the created window. The passed-in window is stored in the owned window's instance data parent field, and the top-level owner of the window is stored in the owner field. Windows creates dialog boxes as owned windows unless an application specifically declares a dialog box to be a child window.</p>
<p>
<img src="styles32_3.gif" border=0></p>
<p class=label>
<b>Figure 3.</b></p>
<p>
The desktop window occupies the first level of the windows hierarchy and top-level windows occupy the second level. <i>Child windows</i>, which are windows created with the WS_CHILD style, occupy all other levels. The window manager connects child windows to their parent window in the same way it connects top-level windows to the desktop window.</p>
<p>
<img src="styles32_4.gif" border=0></p>
<p class=label>
<b>Figure 4.</b></p>
<p>
Child windows are displayed within the client area of their parent. The window manager uses the first-to-last order of the child window list to determine the Z order of child windows. This method is the same as that used for top-level windows. All top-level windows are displayed in the client area of the desktop window and thus behave as if they were children of the desktop for display purposes.</p>
<h2>So What's Different in Win32?</h2>
<p>
The relationships among the desktop window, top-level windows, owned windows, and child windows described in the previous section are identical in Win32® and Win16. This ensures a high degree of compatibility between Win16 and Win32, and allows applications that take advantage of the windows hierarchy to work in both environments. The two differences between the Win16 and Win32 environments involve security and multiple threads.</p>
<p>
Windows NT™ adds a new level to the window hierarchy: Each computer that runs Windows NT has a corresponding object called the <i>WindowStation object</i>. This object forms the first level of security for a workstation and is the source of inheritable security for all user objects. A WindowStation object can, in turn, have any number of desktop objects. Each desktop object is a desktop window, as described in the previous section. Windows NT uses two desktops: One desktop handles the logon screen, CTRL+ALT+DEL screen, locked workstation screen, and screen saver, and the other desktop is used for the rest of the system. Currently, applications cannot create or delete desktops.</p>
<p>
Another difference between Win16 and Win32 involves using multiple threads. Win16 does not support multiple threads, so the application developer does not need to consider threading when an application creates a window. In Win32, whenever a parent/child or owner/owned relationship exists between windows, the threads that own the windows share an input queue. The developer must remember that sharing an input queue counteracts the benefits of using threads—only one thread can process a message at any given time, while other threads sharing the input queue must wait for <b>GetMessage</b> or <b>PeekMessage</b> to return. Wherever possible, make sure that parent/child windows or owner/owned windows belong to the same thread.</p>
<p>
Win32 defines two new window types that are not part of the window hierarchy: <i>foreground windows</i> and <i>background windows</i>. The foreground window is the window that the user is currently working in. All other windows are background windows. Developers should normally let the user set the foreground window; however, Win32 does supply two functions to handle the foreground window, <b>SetForegroundWindow</b> and <b>GetForegroundWindow</b>.</p>
<h2>Navigating the Window Manager's List</h2>
<p>
An application navigates the window manager's list by getting the owner, parent, child, or next window from the window manager or by having Windows call an application-supplied callback function for a set of windows. The functions listed below navigate the window manager's list.</p>
<h3>EnumChildWindows</h3>
<p>
An application can use this function to have Windows call an application-supplied callback function for each child window of a given window. Windows enumerates all child windows, including children of child windows. Windows does not call the callback function for any child windows created after <b>EnumChildWindows</b> is called but before it returns.</p>
<h3>EnumThreadWindows</h3>
<p>
An application can use this function to have Windows call an application-supplied callback function for each window belonging to a given thread. Windows enumerates all top-level windows for a thread, including owned and non-owned top-level windows, child windows, and children of child windows. Windows does not call the callback function for windows created after <b>EnumTaskWindows</b> is called but before it returns.</p>
<h3>EnumWindows</h3>
<p>
An application can use this function to have Windows call an application-supplied callback function for each top-level window. Windows enumerates all top-level windows, including owned and non-owned windows. Windows does not call the callback function for any top-level windows created after <b>EnumWindows</b> is called but before it returns.</p>
<h3>FindWindow</h3>
<p>
An application can use this function to locate the first top-level window in the Z order that matches the given class and window title. The application can specify a particular class, a particular title, both, or neither. If the application specifies neither a class name nor a window title, the <b>FindWindow</b> function returns the top-level window, which is the highest in the Z order. An application cannot use the <b>FindWindow</b> function to locate windows farther down in the Z order after the first matching window is found.</p>
<h3>GetDesktopWindow</h3>
<p>
This function returns the handle to the desktop window.</p>
<h3>GetNextWindow</h3>
<p>
Win16 defined this function separately from <b>GetWindow</b> (see below). Win32 does not implement this function, but the winuser.h header file defines a macro that replaces calls to <b>GetNextWindow</b> with <b>GetWindow</b>.</p>
<h3>GetParent</h3>
<p>
This function returns a handle to a given window's parent, if a parent exists. If the window is a child window, the function returns the handle to the parent window. If the window is a top-level window, the function returns the handle to the window's owner, if an owner exists. To find the handle to the window that was passed to <b>CreateWindow</b> or to <b>CreateWindowEx</b> when an owned window was created, use <b>GetWindowWord</b>(GWW_HWNDPARENT). This window handle is different from the value returned by <b>GetParent</b> if the window whose handle was passed to <b>CreateWindow</b> or <b>CreateWindowEx</b> was not a top-level window. This situation occurs when a dialog box is created with a child window in its <i>hwndParent</i> parameter to <b>CreateWindow</b> or <b>CreateWindowEx</b>.</p>
<h3>GetThreadDesktop</h3>
<p>
This function returns the handle to the desktop for the given thread.</p>
<h3>GetTopWindow</h3>
<p>
This function returns the given window's first child. The first child window is always at the top of the Z order for the given window. If no window is specified, the passed-in window handle is NULL, and this function returns the highest top-level window in the Z order.</p>
<h3>GetWindow</h3>
<p>
An application can use this function to navigate the window manager's list. <b>GetWindow</b> takes two parameters—a handle to a window (<b>HWND</b>) and <i>fwRel</i> (<b>WORD</b>)—specifying the relationship from the given window to the desired window. The following relationships can be obtained:
<ul type=disc>
<li>
<b>GW_HWNDNEXT:</b> <b>GetWindow</b> returns the handle to the given window's next sibling. When an application calls <b>GetWindow</b> with GW_HWNDNEXT, it receives the same result that calling <b>GetNextWindow</b> with GW_HWNDNEXT returns.<br><br></li>
<li>
<b>GW_HWNDFIRST:</b> <b>GetWindow</b> returns the handle to the given window's topmost sibling in the Z order. This is the most visible sibling window. When an application calls <b>GetWindow</b> with GW_HWNDFIRST, it receives the same result that calling <b>GetTopWindow</b> returns.<br><br></li>
<li>
<b>GW_HWNDLAST:</b> <b>GetWindow</b> returns the given window's bottommost sibling in the Z order. This is the least visible sibling.<br><br></li>
<li>
<b>GW_HWNDPREV:</b> <b>GetWindow</b> returns the handle to the given window's previous sibling. When an application calls <b>GetWindow</b> with GW_HWNDPREV, it receives the same result that calling <b>GetNextWindow</b> with GW_HWNDPREV returns.<br><br></li>
<li>
<b>GW_OWNER:</b> <b>GetWindow</b> returns the handle to the given window's owner. If the given window has no owner, <b>GetWindow</b> returns NULL.<br><br></li>
<li>
<b>GW_CHILD:</b> <b>GetWindow</b> returns the handle to the given window's first child window. The first child window is at the top of the given window's Z order. If the given window has no child window, the <b>GetWindow</b> function returns NULL.</li>
</ul>
<h3>IsChild</h3>
<p>
<b>IsChild</b> takes two handles to windows as its arguments: <i>hWndParent</i> and <i>hWnd</i>. <b>IsChild</b> returns TRUE if <i>hWnd</i> is a child or another descendant of <i>hWndParent</i>. <i>hWnd</i> is a descendant of <i>hWndParent</i> if <i>hWndParent</i> is found by stepping from a given window's parent to its parent, and so on. <b>IsChild</b> returns FALSE if <i>hWnd</i> is the same as <i>hWndParent</i>.</p>
<h2>Window Styles</h2>
<p>
When an application creates a window with the <b>CreateWindow</b> or <b>CreateWindowEx</b> function, it assigns the window certain style attributes in the <i>dwStyle</i> parameter. The style attributes determine the type of window, the functionality of the window, and the initial state of the window. Win32 contains no new, changed, or deleted styles; Win32 styles are identical to Win16 styles.</p>
<h3>Window Type Styles</h3>
<h4>WS_OVERLAPPED</h4>
<p>
Overlapped windows are top-level windows and are connected to the desktop window's child windows list. Applications usually use overlapped windows as their main window. Overlapped windows always have a caption, even if WS_CAPTION is not specified. Because an overlapped window always has a caption, it also always has a border. See WS_CAPTION below for more information about border styles. Overlapped windows may own other top-level windows or be owned by other top-level windows or both. All overlapped windows have the WS_CLIPSIBLINGS style, even if it was not specified.</p>
<p>
Windows can set the initial size and position for overlapped windows. To have Windows set the window's initial position, an application uses CW_USEDEFAULT for the <i>X</i> parameter to <b>CreateWindow</b> or <b>CreateWindowEx</b>. When an application uses CW_USEDEFAULT to set an overlapped window's position and uses the WS_VISIBLE style to have the window visible when it is created, Windows passes the <i>Y</i> parameter of <b>CreateWindow</b> or <b>CreateWindowEx</b> to <b>ShowWindow</b>. Thus, when an application uses CW_USEDEFAULT for the <i>X</i> parameter to <b>CreateWindow</b> or <b>CreateWindowEx</b>, the <i>Y</i> parameter must be one of the following:
<ul type=disc>
<li>
SW_HIDE<br><br></li>
<li>
SW_SHOWNORMAL<br><br></li>
<li>
SW_NORMAL<br><br></li>
<li>
SW_SHOWMINIMIZED<br><br></li>
<li>
SW_SHOWMAXIMIZED<br><br></li>
<li>
SW_MAXIMIZE<br><br></li>
<li>
SW_SHOWNOACTIVATE<br><br></li>
<li>
SW_SHOW<br><br></li>
<li>
SW_MINIMIZE<br><br></li>
<li>
SW_SHOWMINNOACTIVE<br><br></li>
<li>
SW_SHOWNA<br><br></li>
<li>
SW_RESTORE</li>
</ul>
<p>
Usually an application should use SW_SHOW for the <i>Y</i> parameter because SW_SHOW allows the proper functioning for WS_MAXIMIZE and WS_MINIMIZE styles.</p>
<p>
To have Windows set the window's initial size, an application uses CW_USEDEFAULT for the <i>nWidth</i> parameter to <b>CreateWindow</b> or <b>CreateWindowEx</b>. When an application uses CW_USEDEFAULT to have Windows set the window's initial size, the <i>nHeight</i> parameter to <b>CreateWindow</b> or <b>CreateWindowEx</b> is ignored.</p>
<h4>WS_POPUP</h4>
<p>
Pop-up windows are top-level windows and are connected to the desktop window's child windows list. Applications usually use pop-up windows for dialog boxes. The main difference between pop-up and overlapped windows is that pop-up windows need not have captions and overlapped windows must have captions. When a pop-up window does not have a caption, it can be created without a border. Pop-up windows may own other top-level windows or be owned by other top-level windows or both. All pop-up windows have the WS_CLIPSIBLINGS style, even if it was not specified. Pop-up windows must not be created with the CW_USEDEFAULT value for either the position or the size of the window. Pop-up windows that use CW_USEDEFAULT will exist but will have no size or no position or both.</p>
<h4>WS_CHILD</h4>
<p>
Child windows must have a parent window and are confined to the client area of their parent. This is the major distinction between child windows and overlapped and pop-up windows. Child window parents can be top-level windows or other child windows. Child windows are positioned from their parent window's upper-left corner and not from the upper-left of the screen as are top-level windows. Child windows are clipped to the client area of their parent. Controls in a dialog box are child windows whose parent is the dialog box. Child windows must not be created with the CW_USEDEFAULT value for either the position or size of the window. Child windows that use CW_USEDEFAULT will exist but will have no size or position or both.</p>
<h3>Window Functional and Appearance Styles</h3>
<h4>WS_CAPTION</h4>
<p>
When this style is enabled, Windows assigns a rectangular area at the top of the window to display the window's text or title. Overlapped windows always have a caption. The application can assign the window's text in the <b>CreateWindow</b> or <b>CreateWindowEx</b> function and can change the text by calling the <b>SetWindowText</b> function. If a window has a caption, it can also have a maximize box (WS_MAXIMIZEBOX), a minimize box (WS_MINIMIZEBOX), and a System menu (WS_SYSMENU). If a window does not have a caption, Windows does not create these elements even if they are explicitly specified.</p>
<p>
Windows without captions cannot have menus because the menu system relies on the caption's existence to place the menu. </p>
<p>
When a window has a caption, the user can move the window with a mouse. If the window does not have a caption, the user cannot move the window because a System menu is required to move the window and a System menu cannot exist without the window having a caption. </p>
<p>
Windows with captions always have either a regular single-line border or a thick sizable border. If neither a WS_BORDER (single line) nor a WS_THICKFRAME (sizable) border is specified, the window gets the single-line border. The WS_CAPTION constant is actually the combination of WS_BORDER and WS_DLGFRAME constants (WS_BORDER | WS_DLGFRAME), which makes it impossible to distinguish between a thin border and a dialog border for windows with captions. As a result, windows with captions cannot have the dialog box border style unless the WS_EX_DLGMODALFRAME extended style is used.</p>
<h4>WS_MINIMIZEBOX</h4>
<p>
When this style is enabled, Windows places the minimize box bitmap in the upper-right corner of the window. If a maximize box exists for the window, Windows places the minimize button to the left of the maximize box. The minimize box cannot exist unless the window has a caption. When the minimize box exists, the user can minimize the window by clicking on the minimize bitmap or by using the System menu. If the minimize box does not exist, the user cannot minimize the window.</p>
<h4>WS_MAXIMIZEBOX</h4>
<p>
When this style is enabled, Windows places the maximize box bitmap in the upper-right corner of the window. The maximize box cannot exist unless the window has a caption. When the maximize box exists, the user can maximize the window by clicking the bitmap or by using the System menu. If the maximize box does not exist, the user cannot maximize the window.</p>
<h4>WS_SYSMENU</h4>
<p>
When this style is enabled, Windows places the System menu bitmap at the upper-left corner of the window. The System menu provides an interface for the user to perform the following system commands:
<ul type=disc>
<li>
Restore a minimized window<br><br></li>
<li>
Move the window with the keyboard<br><br></li>
<li>
Size the window with the keyboard<br><br></li>
<li>
Minimize the window<br><br></li>
<li>
Maximize the window<br><br></li>
<li>
Close the window<br><br></li>
<li>
Switch to another task</li>
</ul>
<p>
When a window has a System menu, the user can bring up the System menu by clicking the menu bitmap, by entering the ALT+SPACEBAR combination on the keyboard, or by clicking the window's icon when the window is minimized. If a window does not have a System menu, the user cannot use the keyboard to perform system commands unless the application provides a specific keyboard interface to do so.</p>
<p>
The System menu is also important for maximized windows that take up the entire screen. When a maximized window that takes up the entire screen has a System menu, the window cannot be moved until the window is restored to its previous nonmaximized size. If the window does not have a System menu, it can be moved without restoring the window's previous nonmaximized size when the window is maximized to the size of the screen. When a window is maximized to the size of the screen, Windows disables the Move, Size, and Maximize items on the System menu to prevent their use. Thus, when a window with a System menu is maximized to the entire screen, it cannot be moved; when a window without a System menu is maximized to the entire screen, it can be moved.</p>
<h4>WS_HSCROLL</h4>
<p>
When this style is enabled, Windows places a horizontal scroll bar along the bottom of the window. Windows does not automatically scroll the window. For a window to allow horizontal scrolling, the window procedure for the window must process the WM_HSCROLL messages, and the window must be created with the WS_HSCROLL style.</p>
<h4>WS_VSCROLL</h4>
<p>
When this style is enabled, Windows places a vertical scroll bar along the right side of the window. Windows does not automatically scroll the window. For a window to allow vertical scrolling, the window procedure for the window must process the WM_VSCROLL messages, and the window must be created with the WS_VSCROLL style.</p>
<h4>WS_BORDER</h4>
<p>
When this style is enabled, Windows draws a single-line border around the window. If no border style is specified, Windows uses a single-line border for all windows that have a caption. Windows created with this style cannot be sized with either the mouse or the keyboard.</p>
<h4>WS_DLGFRAME</h4>
<p>
When this style is enabled, Windows draws a dialog frame, a single line, and a thick colored line around the window. This border style is normally associated with a dialog box, but it can be used on any window that does not have a caption. The dialog frame style can be used for a window with a caption only if the WS_EX_DLGMODALFRAME extended style is specified. Windows created with this style cannot be sized with either the mouse or the keyboard.</p>
<h4>WS_THICKFRAME</h4>
<p>
When this style is enabled, Windows draws a sizable frame, a thick colored line between two single lines, around the window. This border style is usually used for an application's main window. Windows created with this style can be sized with the mouse and through the System menu with the keyboard.</p>
<h4>WS_CLIPCHILDREN</h4>
<p>
This style is used on a window that has child windows and causes Windows to clip the area that a child window occupies from the client area of the parent. Drawing performed by the parent window does not overwrite any of the window's child windows. Windows created without the WS_CLIPCHILDREN style can overwrite any of the window's child windows. Performance degrades slightly; so do not use this style if the application does not draw to the window.</p>
<h4>WS_CLIPSIBLINGS</h4>
<p>
When this style is enabled, Windows clips the client areas of sibling windows from one another. Thus, a window cannot draw in the client area of any of the window's siblings. Windows forces the WS_CLIPSIBLINGS style on all top-level windows (pop-up and overlapped windows), so top-level windows cannot draw on any other top-level window. By default, Windows does not clip sibling windows, thus allowing one child window to draw on another. Performance degrades slightly; so do not use this style if sibling windows cannot draw over one another.</p>
<h3>Window Initial State Styles</h3>
<h4>WS_VISIBLE</h4>
<p>
When this style is enabled, Windows makes the window visible when it is created. By default, the application must call the <b>ShowWindow</b> function to make a window visible.</p>
<h4>WS_DISABLED</h4>
<p>
When this style is enabled, Windows creates a window that is initially disabled. The window cannot accept user input until it is enabled. The application must provide a method to enable the window. This style is usually used for control windows.</p>
<h4>WS_MAXIMIZE</h4>
<p>
When this style is enabled, Windows creates a window of maximum size. An application can control the maximum size for the window by responding to the WM_GETMINMAXINFO message. By default, Windows sets the maximum size of top-level windows to be the size of the screen and the maximum size of child windows to be the size of the child window's parent's client area. An application must also ensure that <b>ShowWindow</b> is correctly called for the WS_MAXIMIZE style to be effective. </p>
<h4>WS_MINIMIZE (WS_ICONIC)</h4>
<p>
When this style is enabled, Windows creates a window of minimum size, that is, an iconic window. An application must also ensure that <b>ShowWindow</b> is correctly called for the WS_MINIMIZE style to be effective. </p>
<h3>Window Standard Styles</h3>
<p>
The Microsoft Windows Software Development Kit (SDK) supplies some standard styles for window types. These styles are usually combinations of the basic styles. Using them can be easier than specifying each style individually. </p>
<h4>WS_CHILDWINDOW</h4>
<p>
This style is equivalent to WS_CHILD. Usually, child windows should be created with the WS_CLIPSIBLINGS style as well as with WS_CHILD or WS_CHILDWINDOW.</p>
<h4>WS_OVERLAPPEDWINDOW</h4>
<p>
This style is equivalent to WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX. This is the style usually used for the main window for applications.</p>
<h4>WS_POPUPWINDOW</h4>
<p>
This style is equivalent to WS_POPUP | WS_BORDER | WS_SYSMENU. Even though this style includes the WS_SYSMENU style, the System menu cannot be added to a window unless it has a caption (WS_CAPTION).</p>
<h3>Extended Window Styles</h3>
<p>
Extended window styles were added to Windows starting with Windows version 3.0. To create a window with extended styles, an application must use the <b>CreateWindowEx</b> function instead of the <b>CreateWindow</b> function.</p>
<h4>WS_EX_DLGMODALFRAME</h4>
<p>
When this style is enabled, Windows uses a dialog border on a window that has a caption. When used, the WS_EX_DLGMODALFRAME style overrides the WS_BORDER and WS_THICKFRAME styles, producing a window with a dialog frame. This extended style is normally used on dialog boxes, but it can be used for any window to get a dialog frame. </p>
<h4>WS_EX_NOPARENTNOTIFY</h4>
<p>
This style is used for child windows. When this style is enabled, Windows does not send WM_NOTIFY messages to the child window's parent. By default, Windows sends WM_NOTIFY messages to a child window's parent when a child window is created or destroyed.</p>
<p>
The following extended Window styles were added starting with Windows version 3.1.</p>
<h4>WS_EX_TOPMOST</h4>
<p>
This style applies only to top-level windows; it is ignored for child windows. When this style is enabled, Windows places the window above any windows that do not have the WS_EX_TOPMOST style. Beginning with Windows version 3.1, there are two classes of top-level windows: topmost top-level windows and top-level windows. Topmost top-level windows always appear above top-level windows in the Z order. Top-level windows can be made topmost top-level windows by calling the <b>SetWindowPos</b> function with the handle to the window and –1 for the <i>hwndInsertAfter</i> parameter. Topmost top-level windows can become regular top-level windows by calling <b>SetWindowPos</b> with the window handle and 1 for the <i>hwndInsertAfter</i> parameter.</p>
<h4>WS_EX_ACCEPTFILES</h4>
<p>
Windows that can accept dragged objects must be created with this style so that Windows can determine that the window will accept objects and can change the drag/drop cursor as the user drags an object over the window. </p>
<h4>WS_EX_TRANSPARENT</h4>
<p>
The WS_EX_TRANSPARENT style makes a window transparent; that is, the window can be seen through, and anything under the window is still visible. Transparent windows are not transparent to mouse or keyboard events. A transparent window receives paint messages when anything under it changes. Transparent windows are useful for drawing drag handles on top of other windows or for implementing "hot-spot" areas without having to hit test because the transparent window receives click messages. </p>
</BODY>
</HTML>
