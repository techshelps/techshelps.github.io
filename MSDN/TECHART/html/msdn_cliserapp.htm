<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Client/Server Applications Using Data Access Objects</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_cliserapp"></a>Client/Server Applications Using Data Access Objects</h1>
<p>
Michael Mee<br>
Jet Program Manager, Microsoft Corporation</p>
<p>
Created: January 1995</p>
<h2>Abstract</h2>
<p>
This article describes techniques for creating client-server applications and offers tips for optimizing performance. It was written to accompany the VBITS '94 talk on "Visual Basic's Database Programming Interface." This article contains a greater level of detail than there will be time to cover in the talk; however, the accompanying talk also covers general database programming tips that are not addressed in this article.</p>
<p>
Much of the material found in this paper is derived from a manual in the Microsoft® Access 2.0 Developer's Toolkit. Other sections of those manuals provide similarly useful information about the database access objects (DAOs) found in Microsoft Visual Basic® and Access.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;All the material in this paper assumes that you're using Jet 2.0—that is, the Visual Basic Compatibility Layer has been installed.</p>
<p>
Prerequisites for understanding this article include advanced database coding skills and intermediate client-server knowledge.</p>
<h2>Connecting to a Server Using Visual Basic</h2>
<p>
There are three ways to connect to a server using Microsoft® Visual Basic®. You can:
<ul type=disc>
<li>
Attach tables and views from the server.<br><br></li>
<li>
Use pass-through queries to send SQL statements straight to the server.<br><br></li>
<li>
Directly access the server.</li>
</ul>
<p>
This section describes each of these methods and their time and memory requirements on both the client and the server.</p>
<h3>Attaching Tables and Views from a Server</h3>
<p>
The most common and most efficient way to access data on a server is to attach tables from the server. With few exceptions, you can use attached tables in your application just as you would Microsoft Jet tables. Microsoft Jet automatically connects to the server when you use an attached table.</p>
<p>
Microsoft Jet stores field and index information for the tables you attach, which improves performance when you open the tables. Note, however, that you must reattach remote tables if you make changes to fields or indexes on the server.</p>
<h4>Attaching SQL views and creating an index specification</h4>
<p>
If your server supports the creation of structured query language (SQL) views, you can attach them to your local database. Microsoft Jet treats an attached view exactly like an attached table with no indexes. The processing defined in a view is always performed by the server, no matter what is executed locally.</p>
<p>
If your server allows you to update data using views, you need to tell Microsoft Jet which field or fields uniquely specify a record returned by the view by creating an <i>index specification</i> on the attachment. Although not actually an index, this specification enables Microsoft Jet to create an updatable dynaset on the view, which can be used by forms and queries.</p>
<p>
For example, suppose you attach an SQL view named SeptOrdersView that returns a subset of records in the remote Orders table, and you name the attachment SeptemberOrders. The OrderID field is still unique within the view, so you would run a data-definition query (not a pass-through query) by executing the following SQL statement:</p>
<pre><code>CREATE UNIQUE INDEX index1 ON SeptemberOrders (OrderID)
</code></pre>
<p>
This doesn't create an index on the server, nor does it take any extra space in your local database. It simply tells Microsoft Jet that the OrderID field is the primary key of the attached view.</p>
<h2>Connecting to a Server Using Visual Basic</h2>
<p>
There are three ways to connect to a server using Microsoft® Visual Basic®. You can:
<ul type=disc>
<li>
Attach tables and views from the server.<br><br></li>
<li>
Use pass-through queries to send SQL statements straight to the server.<br><br></li>
<li>
Directly access the server.</li>
</ul>
<p>
This section describes each of these methods and their time and memory requirements on both the client and the server.</p>
<h3>Attaching Tables and Views from a Server</h3>
<p>
The most common and most efficient way to access data on a server is to attach tables from the server. With few exceptions, you can use attached tables in your application just as you would Microsoft Jet tables. Microsoft Jet automatically connects to the server when you use an attached table.</p>
<p>
Microsoft Jet stores field and index information for the tables you attach, which improves performance when you open the tables. Note, however, that you must reattach remote tables if you make changes to fields or indexes on the server.</p>
<h4>Attaching SQL views and creating an index specification</h4>
<p>
If your server supports the creation of structured query language (SQL) views, you can attach them to your local database. Microsoft Jet treats an attached view exactly like an attached table with no indexes. The processing defined in a view is always performed by the server, no matter what is executed locally.</p>
<p>
If your server allows you to update data using views, you need to tell Microsoft Jet which field or fields uniquely specify a record returned by the view by creating an <i>index specification</i> on the attachment. Although not actually an index, this specification enables Microsoft Jet to create an updatable dynaset on the view, which can be used by forms and queries.</p>
<p>
For example, suppose you attach an SQL view named SeptOrdersView that returns a subset of records in the remote Orders table, and you name the attachment SeptemberOrders. The OrderID field is still unique within the view, so you would run a data-definition query (not a pass-through query) by executing the following SQL statement:</p>
<pre><code>CREATE UNIQUE INDEX index1 ON SeptemberOrders (OrderID)
</code></pre>
<p>
This doesn't create an index on the server, nor does it take any extra space in your local database. It simply tells Microsoft Jet that the OrderID field is the primary key of the attached view.</p>
<h3>Using Pass-Through Queries</h3>
<p>
In many applications, you'll use both ordinary Microsoft Jet queries (that is, queries optimized by the Microsoft Jet database engine) based on attached remote tables and pass-through queries. With an ordinary query, Microsoft Jet compiles and runs the query, combining the power of the server with the capabilities of the Jet database engine. With a pass-through query, you enter a SQL statement that Microsoft Jet sends directly to the server without stopping to compile the query. </p>
<p>
Pass-through queries offer the following advantages over other queries:
<ul type=disc>
<li>
You don't need to consider how much of your pass-through query is being sent to the server for processing because the query is sent as you enter it. This means that more processing occurs on the server and less data is exchanged over the network.<br><br></li>
<li>
Pass-through queries can use server-specific functionalities—such as stored procedures and server-based intrinsic functions—that have no Visual Basic equivalent.<br><br></li>
<li>
Pass-through queries can log informational messages returned by the server, such as warnings and statistics.<br><br></li>
<li>
Pass-through queries enable you to use nonstandard SQL extensions supported by the server, as well as data-definition and server administration and security commands.<br><br></li>
<li>
You must use a pass-through query if you want to join tables from different databases on a server (if the server supports multiple databases). Because each database is a separate open database connectivity (ODBC) data source, an ordinary query would consider the join to be heterogeneous and would execute at least part of the query locally.<br><br></li>
<li>
Update, delete, and append pass-through action queries are faster than action queries based on attached remote tables, especially when many records are affected. However, a pass-through action query cannot partially succeed as an ordinary action query can. (In addition, you are limited to action queries that your server can run; if an action query uses multiple tables, you may have no choice but to use an ordinary query.)</li>
</ul>
<p>
On the other hand, pass-through queries do have several disadvantages:
<ul type=disc>
<li>
A pass-through query always returns a snapshot, which can't be updated. An ordinary query usually returns a dynaset, which reflects other users' changes and can be updated.<br><br></li>
<li>
To create a pass-through query, you must know the exact SQL syntax supported by your server. SQL syntax and conventions often vary from server to server, particularly outer join syntax, intrinsic function names, wildcard characters, and the use of single versus double quotation marks. All ordinary Microsoft Jet queries use the same syntax, regardless of where the data is stored. Microsoft Jet automatically translates intrinsic functions, wildcard characters, and other elements into the appropriate ODBC syntax.<br><br></li>
<li>
You can parameterize an ordinary query, which makes the query much more flexible and re-usable. In contrast, pass-through queries can't be parameterized in this manner.</li>
</ul>
<h4>Using stored procedures</h4>
<p>
In some environments, your access to server data is limited to a set of server-based stored procedures. All data requests and updates are carried out through these stored procedures; you have no direct access to the remote tables. In such an environment, you must use pass-through queries exclusively. If you don't need to update data and only want to retrieve data, you can create a pass-through query for each stored procedure you want to call. You can then base other queries and forms on these queries as if they were attached tables.</p>
<p>
However, if you need to update data in this type of environment, you must collect the user's input locally and then execute a pass-through query to send the data to the server, calling the appropriate stored procedure. Here are two approaches you might use:
<ul type=disc>
<li>
You can create a form based on a local holding table in which records are temporarily stored before being sent to the server. You add code to the data control's Validate event procedure that calls the data-updating stored procedures for each record in the holding table.<br><br></li>
<li>
You can create an unbound form to collect data and add command buttons to the form for saving the data. You can then use the values in the form's unbound controls when you call the data-updating stored procedures.</li>
</ul>
<p>
In either case, you need to write code that constructs a pass-through query using the name of the stored procedure and the values to be supplied.</p>
<h3>Directly Accessing the Server</h3>
<p>
The third way to connect to a server is to access it directly in code by using <b>OpenDatabase</b> with an ODBC connection string. This approach has several disadvantages, however. Although it's possible to directly open snapshots and dynasets on a remote database, this is always much less efficient than using attached tables. When you attach remote tables, the Jet database engine caches a great deal of information about these tables locally, including field information, index information, and server capabilities. In contrast, when you access the remote tables directly, Microsoft Jet has to ask the server for this information every time you run a query.</p>
<p>
For best performance, don't access the server directly (except when preconnecting, as described in the "Preconnecting" section below). Using attached tables and pass-through queries is faster and simpler and provides more functionality. Pass-through queries don't have any of the disadvantages of this type of direct server access; because Microsoft Jet doesn't interpret pass-through queries, it doesn't need any field or index information.</p>
<h2>Connection Strategies</h2>
<p>
Establishing a connection takes time and memory on both the client and the server. This section describes several ways you can limit connections and thus reduce the resources your application uses.</p>
<h3>Preconnecting</h3>
<p>
Using the connection-management capabilities of the Jet database engine, you can log a user onto a server when your application starts without waiting until the first form opens. Microsoft Jet caches the connection and authentication information, and reuses them as needed.</p>
<p>
One way to preconnect is to create a form to gather user and password information, construct a connection string containing the values, and use <b>OpenDatabase</b>. For example, the following procedure connects to a server called MyServer and opens a database:</p>
<pre><code>Sub PreConnect (UserName As String, Password As String)
 &nbsp;&nbsp; Dim MyDB As Database, ConnStr As String
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ConnStr = "ODBC;DSN=MyServer;DATABASE=MyDatabase;"
 &nbsp;&nbsp; ConnStr = ConnStr &amp; "UID=" &amp; UserName &amp; ";"
 &nbsp;&nbsp; ConnStr = ConnStr &amp; "PWD=" &amp; Password &amp; ";"
 &nbsp;&nbsp; Set MyDB = OpenDatabase("", False, False, ConnStr)
 &nbsp;&nbsp; MyDB.Close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Close database but keep connection.
End Sub
</code></pre>
<p>
If you're not sure which ODBC data source to connect to, you can display a dialog box listing all registered data sources by using "ODBC;" for the connection string argument. Then you can access the actual connection string using the Connect property, which connects you to the server, as in the following example. You can then use the <i>ConnStr</i> value when you create pass-through queries or attach tables.</p>
<pre><code>Sub PreConnect ()
 &nbsp;&nbsp; Dim MyDB As Database, ConnStr As String

 &nbsp;&nbsp; Set MyDB = OpenDatabase("", False, False, "ODBC;")
 &nbsp;&nbsp; ConnStr = MyDB.Connect
 &nbsp;&nbsp; MyDB.Close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Close database but keep connection.
End Sub
</code></pre>
<p>
In both examples, the <b>Close</b> method doesn't disconnect from the server—instead, Microsoft Jet caches the connection internally.</p>
<h2>Reducing Connection Use</h2>
<p>
Some servers support powerful connections that can handle multiple partially completed queries at the same time (ORACLE Server is one example). Other servers provide connections requiring fewer resources, but each connection can process only one query at a time (Microsoft SQL Server and Sybase® SQL Server™ are examples). However, regardless of the server's capabilities, the Jet database engine allows multiple queries and manages your connections automatically.</p>
<p>
If your server supports multiple queries on a single connection, you generally won't have to worry about connection usage because Microsoft Jet uses just one connection to the server for the entire application. However, if your server doesn't support such queries, you should try to reduce the number of connections your application requires. This section describes ways to limit your use of connections.</p>
<h3>Limiting Dynasets to 100 Records</h3>
<p>
If your server uses multiple connections to process more than one query at the same time, you can reduce connection use by limiting dynasets to 100 records. A dynaset containing 100 or fewer records requires only a single connection. In contrast, a dynaset containing more than 100 records requires two connections: Microsoft Jet uses one connection to fetch the key values from the server and another to fetch the data associated with those keys for the records visible on screen. Other dynasets can share the second connection but can't share the first, because not all key values may have been retrieved from the server. </p>
<p>
As an example, three dynasets containing more than 100 records each require a total of four connections. When all of the key values for any of these dynasets have been fetched, or when the dynaset is closed, the corresponding connection is released. In contrast, three dynasets containing 100 or fewer records each require only one connection.</p>
<h3>Releasing Connections</h3>
<p>
Another way to reduce the number of connections is to close connections your application is no longer using. You can cause a recordset to finish execution and thereby close connections by doing one of the following:
<ul type=disc>
<li>
Leave the RecordSource of the data control blank, and place the following code in the Load event procedure of the form:<pre><code>Dim MyRS As Dynaset
Data1.RecordSource = "SELECT ... FROM ..."
Data1.Refresh
Set MyRS = Data1.Recordset.Clone
MyRS.MoveLast
MyRS.Close
</code></pre>
</li>
<li>
Use a TOP 100 PERCENT query to return 100 percent of the records. (This is especially useful for filling list boxes and combo boxes.) For more information, search Help for <i>TOP (SQL)</i> in the Microsoft Access help file.</li>
</ul>
<p>
Although they reduce connection usage, these techniques cause forms to open more slowly, and you may want to temporarily change the cursor to an hourglass. This isn't recommended if your recordsets are very large.</p>
<h3>Setting Connection Timeout</h3>
<p>
Regardless of the type of server you're using, if someone is running your application but hasn't taken any action for a long time, you may want to close connections to the server. By default, connections are closed after 600 seconds (10 minutes) of idle time. You can change this interval by setting the ConnectionTimeout entry in the [ODBC] section of the initialization file (VB.INI or <i>APPLICATION</i>.INI) to the number of seconds you want to wait before closing idle connections. Microsoft Jet closes connections even if data controls and forms displaying remote data are still open, and then automatically reconnects when the connection is needed again.</p>
<p>
Even if the idle time has expired, Microsoft Jet cannot close a connection if:
<ul type=disc>
<li>
There is a pending transaction on the connection. You must commit or roll back the transaction before the connection can be closed.<br><br></li>
<li>
Results of a query are pending. Microsoft Jet will not close a connection if it is in the process of fetching query results from a server.</li>
</ul>
<h2>Optimizing Client-Server Performance</h2>
<p>
In addition to functional differences between local and remote tables, there are often considerable performance differences. Elements of your application that performed acceptably with local data may be significantly slower when the data is on a server, causes too much network traffic, or uses excessive server resources. This section discusses techniques you can use to improve the performance of client/server applications. Additional information on optimizing is included in Chapter 6, "Writing SQL Queries."</p>
<h3>Speeding Up Queries</h3>
<p>
The best way to improve the performance of queries on remote data is to have the server execute as much of the query as possible. Microsoft Jet attempts to send the entire query to the server but evaluates locally any query clauses and expressions that aren't supported by servers in general or by your server in particular. Some information about server capability is available when you attach a remote table.</p>
<p>
If a query contains expressions that can't be evaluated by your server, more or less of the query is evaluated locally, depending on where the expressions occur. Queries with such expressions in the SELECT clause are still evaluated on the server, unless they occur in a totals query, a DISTINCT query, or a UNION query, in which case they are evaluated locally. Such expressions in other clauses (for example, WHERE, ORDER BY, and GROUP BY clauses) cause at least part of the query to be evaluated locally.</p>
<p>
The following section describes how to design queries that maximize the use of the server and thereby improve query performance.</p>
<h4>Using supported functionality</h4>
<p>
If possible, don't design queries that use functionality not generally supported by servers. The following sections identify some areas of functionality that aren't generally supported and others that usually are.</p>
<p>
<b>Functionality not supported by most servers</b></p>
<p>
Most servers don't support the following:
<ul type=disc>
<li>
Operations that can't be expressed in a single SQL statement—for example, when a query's FROM clause contains a totals query or DISTINCT query. Often you can rearrange your queries to calculate totals or apply the DISTINCT predicate after all other operations.<br><br></li>
<li>
Operations that are Microsoft Jet–specific extensions to SQL, such as complex crosstab queries and TOP queries.<br><br></li>
<li>
Expressions that contain operators or functions specific to Visual Basic. For example, the Visual Basic financial and statistical aggregate functions have no server equivalents.<br><br></li>
<li>
Mixing text and numeric data types in expressions or UNION queries. Most servers lack the data type leniency of Visual Basic. If you need to mix data types, use explicit conversion functions.<br><br></li>
<li>
Heterogeneous joins between local tables and remote tables, or between remote tables in different ODBC data sources. </li>
</ul>
<p>
<b>Functionality supported by some servers</b></p>
<p>
Servers differ in certain areas of functionality. Some servers support the following:
<ul type=disc>
<li>
Outer joins. (Note that Microsoft Jet doesn't send multiple outer joins to a server, although many inner joins can accompany a single outer join.)<br><br></li>
<li>
Numeric, string, and date/time functions (such as <b>Log</b>, <b>Mid$</b>, and <b>DatePart</b>).<br><br></li>
<li>
Conversion functions (such as <b>CInt</b>, <b>CStr</b>, and <b>CVDate</b>).</li>
</ul>
<p>
If the operation is supported, it's sent to the server for processing; otherwise, it's performed locally.</p>
<h4>Splitting WHERE clause restrictions</h4>
<p>
If a query's SQL statement includes a WHERE clause that the server can't evaluate completely, Microsoft Jet splits the clause into its conjuncts (linked by AND) and sends as many conjuncts to the server as possible. For example, suppose you run the following query:</p>
<pre><code>SELECT field1, field2, field3
FROM table1
WHERE (field1 = 100 OR field1 = 200)
 &nbsp;&nbsp; AND IIF(field2 = 0, field4, field5) &gt; 100
 &nbsp;&nbsp; AND field3 LIKE "A*"
</code></pre>
<p>
Microsoft Jet sends the following query to the server and evaluates</p>
<pre><code>IIF(field2 = 0, field4, field5) &gt; 100 
</code></pre>
<p>
locally on the records returned:</p>
<pre><code>SELECT field1, field2, field3
FROM table1
WHERE (field1 = 100 OR field1 = 200) 
 &nbsp;&nbsp; AND field3 LIKE "A*"
</code></pre>
<p>
If you need to use a WHERE clause restriction that your server can't process, you can limit the amount of data that Microsoft Jet requests by providing additional restrictions that your server can process. For maximum efficiency, these restrictions should involve fields indexed on the server.</p>
<h4>Optimizing expressions containing Microsoft Jet-specific elements</h4>
<p>
If expressions in your queries contain domain aggregate functions and other elements specific to Visual Basic (such as <b>IIf</b> and <b>Choose</b>), they can't be completely executed by a server. If an expression using one of these elements involves remote data fields, Microsoft Jet executes the expression locally and retrieves all necessary data from the server. If such an expression involves only constants and query parameters, however, Microsoft Jet evaluates it just once and sends the result to the server as a query parameter. Whenever possible, you should structure your queries to take advantage of this optimization by avoiding references to remote fields in expressions that can't be evaluated by the server.</p>
<p>
As an example, suppose you have a remote Tasks table with a Status field containing code numbers (1 means unfinished and 2 means completed). The following query requires a user to supply a value of 1 or 2, which isn't very intuitive:</p>
<pre><code>SELECT * FROM Tasks WHERE Status = [What Status?]
</code></pre>
<p>
In contrast, the next query allows the user to supply <b>Unfinished</b> or <b>Complete</b> when prompted:</p>
<pre><code>SELECT * FROM Tasks
WHERE [What Status?] = IIf(Status=1,'Unfinished','Complete')
</code></pre>
<p>
However, because the <b>IIf</b> function uses the remote Status field, Microsoft Jet sends the first part of the statement (SELECT * FROM Tasks) to the server and evaluates the restriction on each record.</p>
<p>
The following query also allows the user to supply words instead of numbers:</p>
<pre><code>SELECT * FROM Tasks
WHERE Status = IIf([What Status?]='Unfinished',1,2)
</code></pre>
<p>
However, because the return value of the <b>IIf</b> function is effectively constant, Microsoft Jet evaluates it once locally and sends the following statement to the server, supplying this part of the expression as a parameter value:</p>
<pre><code>SELECT * FROM Tasks WHERE Status = ?
</code></pre>
<p>
This method is more efficient and reduces network traffic.</p>
<h4>Heterogeneous joins</h4>
<p>
To perform a join between local and remote tables, or a <i>heterogeneous join</i>, Microsoft Jet either:
<ul type=disc>
<li>
Requests all the records in the remote table or tables and performs the join locally.<br><br></li>
<li>
Performs a <i>remote index join</i>. This means that for each key in the local table, Microsoft Jet asks the server for just the records with a matching key value.</li>
</ul>
<p>
Microsoft Jet uses a remote index join only if the remote field being joined is indexed and if the local table is considerably smaller than the remote table. For example, to join a local table called Employees containing 10 records and a remote table called Tasks containing 50 records on the EmployeeID field, Microsoft Jet retrieves the 50 records from the Tasks table on the server and processes the join locally. However, if the remote table contained 1000 records, Microsoft Jet would send 10 of the following queries to the server, supplying each EmployeeID value from the local Employees table as a parameter value:</p>
<pre><code>SELECT EmployeeID, TaskID
FROM Tasks
WHERE EmployeeID = ?
</code></pre>
<p>
This is generally much faster than retrieving all 1000 records.</p>
<p>
You should always index the remote join field to enable Microsoft Jet to perform a remote index join when appropriate. Regardless of whether or not Microsoft Jet can perform a remote index join, you can improve the performance of a query that uses a heterogeneous join by supplying additional restrictions on remote fields. Microsoft Jet sends these restrictions to the server, limiting the amount of data requested for the join.</p>
<h2>Improving the Performance of Updates and Deletions</h2>
<p>
Probably the simplest way to improve the performance of updates and deletions—especially if your remote table has many fields—is to add a version<i> </i>field (sometimes called a <i>timestamp) </i>to the remote table. A version field is maintained by the server, and its value automatically changes each time the record is updated. Typically, you can't read the contents of a version field, but its behavior enables Microsoft Jet to detect changes to records.</p>
<p>
When updating or deleting a record, Microsoft Jet checks to see if the version field has changed; if it has, the update or deletion would overwrite another user's changes, so it's canceled. If the table doesn't have a version field, Microsoft Jet compares all the old field values with their current values to determine if data has changed. This is less efficient and generates more network traffic. Moreover, when Microsoft Jet checks values, in certain cases data that hasn't changed will appear as if it had, either because of inaccuracies inherent in comparing floating-point numbers, or because Memo and OLE Object fields aren't compared at all.</p>
<p>
To add a version field to a remote table, you can use the ALTER TABLE statement. For example, the following command adds a version field to a SQL Server table:</p>
<pre><code>ALTER TABLE RemoteTable ADD VersionCol TIMESTAMP
</code></pre>
<p>
You can run this statement as a pass-through query in Visual Basic. However, you must reattach the remote table to inform Microsoft Jet of the new field's existence. For more information on the ALTER TABLE statement, search Help for <i>ALTER </i>TABLE (SQL).</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Not all servers support version<i> </i>fields. To see if yours does, check the server's documentation.</p>
<h2>Initialization File Settings</h2>
<p>
When you design a client/server application, you can change its performance by adjusting the following settings in the [ODBC] section of the initialization file (VB.INI or APPLICATION.INI):</p>
<h3>TraceSQLMode</h3>
<p>
If queries on remote data are taking too long to complete, set this option to 1 to inspect the SQL statements being sent to the server. If some of the statement's clauses or restrictions aren't being sent, you could be using functionality provided by the Jet database engine but not supported by the server.</p>
<h3>TryJetAuth</h3>
<p>
If your application doesn't use Microsoft Jet security, you should set this entry to 0 to prevent Microsoft Jet from attempting to log on to the server using the default user name Admin. On some servers, a failed logon can take time and slow the server down.</p>
<h3>PreparedInsert and PreparedUpdate</h3>
<p>
These options determine whether Microsoft Jet inserts or updates data in all fields (including inserting <b>Null</b> values and updating unchanged fields). If you don't have triggers or defaults on your tables, setting these options to 1 can speed up insertions and updates marginally.</p>
<h3>FastRequery</h3>
<p>
If you use parameterized queries and aren't concerned about the number of connections you use, you can set this option to 1. This may use more connections, but it marginally improves the speed of requerying operations.</p>
<h2>References</h2>
<p>
The Microsoft Developers Network CD-ROM has many articles of interest to database programmers. Some of these are also available in other forms directly from Microsoft (often from one of their download services, including the Internet server at FTP.MICROSOFT.COM). These include the following:</p>
<p>
Black, Neil, and Stephen Hecht. "Jet Database Engine ODBC Connectivity." (MSDN Library Archive, Backgrounders) This describes in great detail how Microsoft Jet uses ODBC to retrieve server data. Required reading for anyone using DAO to write significant server applications.</p>
<p>
Lambert, Colleen. <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_odbcperf">
</object><a href=JavaScript:alink_1.Click()>"ODBC: Architecture, Performance, and Tuning"</a>. This paper provides a good overview of how ODBC works and addresses performance issues in a realistic and useful fashion.</p>
<p>
Nelson, Greg, and Roger Jennings. "A Client-Server Application: From Concept to Reality." (MSDN Library Archive, Conference and Seminar Papers)</p>
<p>
Some books are also starting to appear covering relevant topics:</p>
<p>
Watterson, Karen. <i>Visual Basic Database Programming</i>. Published by Addison-Wesley. This is a good overview of all aspects of database programming from Visual Basic.</p>
<h2>Support</h2>
<p>
Free support for all the products detailed in this paper is available on CompuServe®.</p>
<p>
DAO/Jet/Visual Basic support is available from the MSBASIC forum of CompuServe, Section 3, "Data Access Objects," and Section 4, "The Data Control." If you're willing to move your frame of reference to Microsoft Access, you will find excellent support for specific database questions in the MSACCESS forum. Unlike the Visual Basic support engineers, the Access engineers live and breathe databases and hence sometimes are able to answer questions that stump the Visual Basic support folks. Don't expect Access support to know anything about Visual Basic's data control, however.</p>
<p>
Paid support is also available direct from Microsoft. Call (800) 936-3500 for details. You may also be able to find a local Microsoft Solution Provider (SP) that can help you. Call (800) SOL-PROV for details or referrals to a local SP.</p>
<h2>Where Do I Get It?</h2>
<p>
The Visual Basic Compatibility Layer (VBCL<b>)</b> is included both in the Microsoft Access Distribution Kit and the Office Developers Kit. It can also be downloaded from the usual Microsoft download points.</p>
<p>
Note that with the VBCL you will also need a copy of the Jet 2.0 engine, which is currently available either with Microsoft Access 2.0 or the Microsoft Access Distribution Kit. Given that you'll need Access 2.0 to set up some of the new Jet 2.0 features (such as cascading relationships or pass-through queries), buying Access 2.0 is probably the best way to obtain Jet 2.0.</p>
</BODY>
</HTML>
