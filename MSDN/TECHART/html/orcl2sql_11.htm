<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Cursors</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>Cursors</h1>
<p>
Oracle always requires using cursors with SELECT statements, regardless of the number of rows requested from the database. In SQL Server, a SELECT statement that is not disclosed on a cursor returns rows to the client as a default result set. This is an efficient way to return data to a client application. </p>
<p>
SQL Server provides two interfaces for cursor functions. When using cursors in Transact-SQL batches or stored procedures, ANSI-standard SQL syntax has been added for declaring, opening, and fetching from cursors as well as positioned updates and deletes. When using cursors from a DB-Library or ODBC program, the SQL Server client libraries transparently call built-in server functions to handle cursors more efficiently.</p>
<p>
When porting a PL/SQL procedure from Oracle, first determine whether cursors are needed to do the same function in Transact-SQL. If the cursor is used just to return a set of rows to the client application, use a noncursor SELECT statement in Transact-SQL to a return default result set. If the cursor is used to load data a row at a time into local procedure variables, then you must use cursors in Transact-SQL. </p>
<h3>Syntax</h3>
<p>
The following table shows the syntax for using cursors.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=22%><b>Operation</b></td>
<td class=label width=38%><b>PL/SQL</b></td>
<td class=label width=40%><b>Transact-SQL</b></td>
</tr>
<tr valign=top>
<td width=22%>Declaring a cursor</td>
<td width=38%><b>CURSOR <i>cursor_name</i> [(<i>cursor_parameter(s)</i>)]<br>
IS <i>select_statement</i>;</b></td>
<td width=40%><b>DECLARE <i>cursor_name</i> [INSENSITIVE] [SCROLL] CURSOR FOR <i>select_statement</i> <br>
[FOR {READ ONLY | UPDATE [OF <i>column_list</i>]}]</b></td>
</tr>
<tr valign=top>
<td width=22%>Opening a cursor</td>
<td width=38%>OPEN <i>cursor_name</i> <b>[(<i>cursor_parameter(s)</i>)];</b></td>
<td width=40%>OPEN <i>cursor_name</i></td>
</tr>
<tr valign=top>
<td width=22%>Fetching from cursor</td>
<td width=38%><b>FETCH <i>cursor_name</i> INTO <i>variable(s)</i></b></td>
<td width=40%><b>FETCH [[NEXT | PRIOR | FIRST | LAST | ABSOLUTE {<i>n</i> | @nvar} | RELATIVE {<i>n</i> | @nvar}]<br>
FROM] <i>cursor_name</i><br>
[INTO @variable(s)] </b></td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=22%><b>Operation</b></td>
<td class=label width=38%><b>PL/SQL</b></td>
<td class=label width=40%><b>Transact-SQL</b></td>
</tr>
<tr valign=top>
<td width=22%>Update fetched row</td>
<td width=38%>UPDATE <i>table_name</i><br>
SET <i>statement(s)…</i><br>
WHERE CURRENT OF <i>cursor_name</i>;</td>
<td width=40%>UPDATE <i>table_name</i><br>
SET <i>statement(s)…</i><br>
WHERE CURRENT OF <i>cursor_name</i></td>
</tr>
<tr valign=top>
<td width=22%>Delete fetched row</td>
<td width=38%>DELETE FROM <i>table_name</i> <br>
WHERE CURRENT OF <i>cursor_name</i>;</td>
<td width=40%>DELETE FROM <i>table_name</i> <br>
WHERE CURRENT OF <i>cursor_name</i></td>
</tr>
<tr valign=top>
<td width=22%>Closing cursor</td>
<td width=38%>CLOSE <i>cursor_name</i>;</td>
<td width=40%>CLOSE <i>cursor_name</i></td>
</tr>
<tr valign=top>
<td width=22%>Remove cursor data structures</td>
<td width=38%><b>N/A</b></td>
<td width=40%><b>DEALLOCATE <i>cursor_name</i></b></td>
</tr>
</table><br>
<h3>Declaring a Cursor</h3>
<p>
The Transact-SQL DECLARE CURSOR statement is more robust than the PL/SQL statement, and has many additional capabilities. Although it does not support the use of cursor arguments, it can include local variables. The values of these local variables are used in the cursor at open time. </p>
<p>
The INSENSITIVE option is used to define a cursor that makes a temporary copy of the data to be used by the cursor. All of the requests to the cursor are answered from this temporary table. Consequently, modifications made to base tables are not reflected in the data returned by fetches made to this cursor. Data accessed by this type of cursor cannot be modified.</p>
<p>
The cursor automatically becomes an insensitive cursor if any of the following conditions exist:
<ul type=disc>
<li>
Any of the queried tables does not have a unique index.<br><br></li>
<li>
DISTINCT, UNION, GROUP BY, or HAVING is used.<br><br></li>
<li>
An outer join is used.<br><br></li>
<li>
A constant expression is included as a column in the SELECT statement.</li>
</ul>
<p>
The SCROLL option allows backward, absolute, and relative fetches in addition to forward fetches. A scroll cursor uses a keyset cursor model in which committed deletes and updates made to the underlying tables by any user are reflected in subsequent fetches. This is only true if the cursor is not declared with the INSENSITIVE option.</p>
<p>
If the READ ONLY option is chosen, updates are prevented from occurring against any row within the cursor. This option overrides the default capability of a cursor to be updated.</p>
<p>
The UPDATE [OF <i>column_list</i>] statement is used to define updatable columns within the cursor. If [OF <i>column_list</i>] is supplied, only the columns listed will allow modifications. If no list is supplied, all of the columns can be updated unless the cursor has been defined as READ ONLY.</p>
<p>
It is important to note that the name scope for a SQL Server cursor is the connection itself. This is different from the name scope of a local variable. A second cursor with the same name as an existing cursor on the same user connection cannot be declared until the first cursor is deallocated.</p>
<h3>Opening a Cursor</h3>
<p>
Transact-SQL does not support the passing of arguments to a cursor when it is opened, unlike PL/SQL. When a Transact-SQL cursor is opened, the result set membership and ordering are fixed. Updates and deletes that have been committed against the base tables of the cursor by other users are reflected in fetches made against all cursors defined without the INSENSITIVE option. In the case of an INSENSITIVE cursor, a temporary table is generated.</p>
<h3>Fetching Data</h3>
<p>
Oracle cursors can only move in a forward direction. There is no backward or relative scrolling capability. SQL Server cursors can scroll forward and backwards using the fetch options shown in the following table. These fetch options can be used only when the cursor is declared using the SCROLL option.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Scroll option</b></td>
<td class=label width=80%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=20%>NEXT</td>
<td width=80%>Returns the first row of the result set if this is the first fetch against the cursor; otherwise, it moves the cursor one row within the result set. NEXT is the primary method used to move through a result set. NEXT is the default cursor fetch.</td>
</tr>
<tr valign=top>
<td width=20%>PRIOR</td>
<td width=80%>Returns the previous row within the result set.</td>
</tr>
<tr valign=top>
<td width=20%>FIRST</td>
<td width=80%>Moves the cursor to the first row within the result set and returns the first row.</td>
</tr>
<tr valign=top>
<td width=20%>LAST</td>
<td width=80%>Moves the cursor to the last row within the result set and returns the last row.</td>
</tr>
<tr valign=top>
<td width=20%>ABSOLUTE<i> n</i></td>
<td width=80%>Returns the <i>n</i>th row within the result set. If <i>n</i> is a negative value, the returned row is the nth row counting backward from the last row of the result set.</td>
</tr>
<tr valign=top>
<td width=20%>RELATIVE <i>n</i></td>
<td width=80%>Returns the <i>n</i>th row after the currently fetched row. If <i>n</i> is a negative value, the returned row is the <i>n</i>th row counting backward from the relative position of the cursor.</td>
</tr>
</table><br>
<p>
The Transact-SQL FETCH statement does not require the INTO clause. If return variables are not specified, the row is automatically returned to the client as a single-row result set. However, if your procedure just needs to get the rows to the client, a noncursor SELECT statement is much more efficient.</p>
<p>
The INTO option fetches cursor rows into local procedure variables for further processing. If this option is used, each of the variables must match the returned column data type. Errors occur when the data types are incompatible. Unlike Oracle, implicit data type conversions are not provided here.</p>
<p>
The <b>@@fetch_status</b> global variable is updated following each FETCH. It is similar in use to the CURSOR_NAME%FOUND and CURSOR_NAME%NOTFOUND variables used with PL/SQL. The <b>@@fetch_status</b> variable is set to the value of 0 following a successful FETCH. If the FETCH tries to read beyond the end of the cursor, a value of –1 is returned. If the requested row has been deleted from the table after the cursor was opened, the <b>@@fetch_status</b> variable returns –2. The value of –2 usually only occurs in a cursor declared with the SCROLL option. This variable must be checked following each fetch to ensure the validity of the data.</p>
<p>
SQL Server does not support Oracle's cursor FOR loop syntax.</p>
<h3>CURRENT OF Clause</h3>
<p>
The syntax for updates and deletes using the CURRENT OF clause is the same in both PL/SQL and Transact-SQL. This clause works the same way regardless of DBMS. A positioned UPDATE or DELETE is performed against the current row within the specified cursor.</p>
<h3>Closing a Cursor</h3>
<p>
The Transact-SQL CLOSE CURSOR statement closes the cursor but leaves the data structures accessible for reopening. The PL/SQL CLOSE CURSOR statement closes and releases all data structures.</p>
<p>
Transact-SQL requires the use of the DEALLOCATE CURSOR statement to remove the cursor data structures. The DEALLOCATE CURSOR statement is different from CLOSE CURSOR in that a closed cursor can be reopened. The DEALLOCATE CURSOR statement releases all data structures associated with the cursor and removes the definition of the cursor. </p>
<h4>Cursor Example</h4>
<p>
The example compares the cursor statements required to achieve the same program result in both PL/SQL and Transact-SQL:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=51%><b>Oracle</b></td>
<td class=label width=49%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=51%>DECLARE<br>
VSSN CHAR(9);<br>
VFNAME VARCHAR(12);<br>
VLNAME VARCHAR(20);<br>
CURSOR CUR1 IS<br>
SELECT SSN, FNAME, LNAME<br>
FROM STUDENT ORDER BY LNAME;<br>
BEGIN<br>
&nbsp;&nbsp;&nbsp;&nbsp;OPEN CUR1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;FETCH CUR1 INTO VSSN, VFNAME, VLNAME;<br>
&nbsp;&nbsp;&nbsp;&nbsp;WHILE (CUR1%FOUND) LOOP<br>
&nbsp;&nbsp;&nbsp;&nbsp;FETCH CUR1 INTO VSSN, VFNAME, VLNAME;<br>
END LOOP;<br>
CLOSE CUR1;<br>
END;</td>
<td width=49%>DECLARE<br>
@VSSN CHAR(9),<br>
@VFNAME VARCHAR(12),<br>
@VLNAME VARCHAR(20)<br>
DECLARE curl CURSOR FOR<br>
&nbsp;&nbsp;&nbsp;&nbsp;SELECT SSN, FNAME, LNAME<br>
&nbsp;&nbsp;&nbsp;&nbsp;FROM STUDENT ORDER BY SSN<br>
OPEN CUR1<br>
FETCH NEXT FROM CUR1<br>
&nbsp;&nbsp;&nbsp;&nbsp;INTO @VSSN, @VFNAME, @VLNAME<br>
WHILE (@@FETCH_STATUS &lt;&gt; -1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;BEGIN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FETCH NEXT FROM CUR1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INTO @VSSN, @VFNAME, @VLNAME<br>
&nbsp;&nbsp;&nbsp;&nbsp;END<br>
CLOSE CUR1<br>
DEALLOCATE CUR1</td>
</tr>
</table><br>
</BODY>
</HTML>
