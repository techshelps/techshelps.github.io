<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Explanation and Examples of Non-Visual Classes</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_nonvis"></a></sup>Explanation and Examples of Non-Visual Classes</h1>
<p>
Microsoft Corporation</p>
<h2>Abstract</h2>
<p>
Many products that support object-oriented programming only do so for the creation of graphical user interface (GUI) objects. In Microsoft® Visual FoxPro™, an entire universe of classes lies beneath the surface of the user interface, just waiting for our imagination and skill to bring them to light. These classes are the <i>non-visual </i>classes.</p>
<h2>Non-Visual Classes Defined</h2>
<p>
A non-visual class is any class that is not designed primarily for display. For example, a command button is a class that is specifically designed to display on a form. A timer class, on the other hand, does not show on a form at all.</p>
<p>
Non-visual classes in Visual FoxPro are typically descendants of the Custom or Timer classes and often will have no display component attached to them at all. However, as we will see later, non-visual classes may have a visual component attached to them.</p>
<h2>Why Create Non-Visual Classes?</h2>
<p>
There are many reasons why a non-visual class may be created. In fact, there are as many reasons to create non-visual classes as there are to create visual ones. Principally, the reasons are:
<ul type=disc>
<li>
Code maintenance<br><br></li>
<li>
Code reuse<br><br></li>
<li>
Functionality enhancement</li>
</ul>
<p>
So what's the difference between non-visual and visual classes? The basic difference lies in the <i>kind</i> of classes we will create. While visual classes typically center on the user interface, non-visual classes play key roles in management functions. Non-visual classes also incorporate the type of classes that are most often neglected in discussions of object orientation in systems development: business classes.</p>
<h2>Types of Non-Visual Classes</h2>
<h3>Wrapper Classes</h3>
<p>
When we talk about classes written for management roles, there are many different aspects of management we will want to create a class for. One type of management would be to manage the interface between one program and another. A good example of this would be the management of the interface between Visual FoxPro code and DLLs, FLLs, or other function libraries. These classes are created to make it easier to use these sources' functions, to enhance their capabilities, and to encapsulate the definition, loading, and error trapping required when working with the function library.</p>
<p>
This process is known as <i>wrapping a class</i> around some existing functionality. Appropriately, we call these classes <i>wrapper classes</i>.</p>
<h3>Manager Classes</h3>
<p>
Another typical non-visual class would be a class that manages other classes, for example a class that handles multiple instances of forms. Such a class would allow us to create "tile all windows" functions and the like. These classes are known as <i>manager classes</i>.</p>
<h3>Business Classes</h3>
<p>
A <i>business class</i> is a class that is designed to model an entity in a business environment. A good example would be a customer class. These classes are a combination of information and actions designed to do what a business entity needs to do within the context of the problem domain (that is, the environment being modeled and automated).</p>
<p>
The responsibilities of a business class are often determined after careful analysis and design. Business class responsibilities can be very abstract in nature and require careful modeling before implementation. Some common responsibilities might be to:
<ul type=disc>
<li>
Retrieve its information from the database.<br><br></li>
<li>
Print itself.<br><br></li>
<li>
Save itself to the database.</li>
</ul>
<p>
Business classes are a little more difficult to classify as visual or non-visual. Business classes may, and often do, have visual components. Or it might be based on a visual class (for example, a form class) with the appropriate properties and methods added to the form. Which category does it belong in? It depends on how the object is created.</p>
<p>
Let's look at a sample wrapper class first.</p>
<h2>Wrapper Classes</h2>
<p>
The purpose of a wrapper class, as we discussed earlier, is to create a class that manages and perhaps even enhances the functionality of some other code. Any code can be wrapped into a class. If you have an old procedure library written in prior versions of FoxPro®, you could wrap a class around it if you like. The tough part is deciding when it is appropriate to wrap a class around something.</p>
<p>
The best reason to wrap a class around something is to make it easier and better to use. A perfect example of a candidate for a wrapper class would be a .DLL or .FLL. These function libraries can be obscure, their parameters difficult to determine, and their error-handling requirements rather extensive. For example, if you are using an .FLL library, such as FOXTOOLS.FLL, what do you do if someone else's code unloads it accidentally with SET LIBRARY TO? Can you rely on the fact that the library is there all the time? Take the example of calling some of the Windows® application programming interface (API) functions, such as the functions to write and read from .INI files. These can be difficult to learn to use.</p>
<p>
When a class is wrapped around some other piece of code, the class developer has the ability to control which portions of the .DLL or .FLL are available to the outside world, how they are called, and even what values are returned.</p>
<p>
Wrapper classes carry a myriad of benefits with them. First of all, if a .DLL or .FLL is used with a wrapper class, the developers who use that class do not have to know anything about the .DLL or .FLL that serves as the basis for the class. They also do not have to be concerned with issues of loading the .DLL or .FLL or registering the functions contained therein. </p>
<p>
In effect, the result is a much reduced learning curve and coding time for all concerned.</p>
<p>
Let's look at the following example of a wrapper class. This class is a wrapper around a library of functions that ships with Visual FoxPro called FOXTOOLS.FLL.</p>
<pre><code>*&nbsp; Program...........: FTOOLS.PRG
*&nbsp; Author............: Menachem Bazian, CPA
*&nbsp; Copyright.........: (c) Flash Creative Management, Inc. 1994, 95
*&nbsp; Project...........: COMMON
*&nbsp; Created...........: 11/29/1994
*) Description.......: Wrapper class for FoxTools
*&nbsp; Major change list.:

*-- This is a wrapper class for FoxTools. The following functions have been
*-- added as methods to this class:
*--
*-- DriveType
*-- JustPath
*-- JustDrive
*-- AddBs
*-- CleanDir
*--
*-- A couple of quick notes here:
*--
*-- JustPath has been modified to add a backslash where necessary to the return
*-- value.
*--
*-- CleanDir deals with the issue of directories specified with ..\. It returns
*-- an "adjusted" directory name.
*--
*-- In all cases when running a FoxTools function, the class will check to make 
*-- sure that FoxTools is still loaded (the user may have released on their 
*-- own). If this class loads FoxTools, it released it when the object is
*-- released.

DEFINE CLASS ftools AS custom
 &nbsp;&nbsp; PROTECTED lLoaded

 &nbsp;&nbsp; PROCEDURE init
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.lLoaded = .F.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.loadlib()
 &nbsp;&nbsp; ENDPROC

 &nbsp;&nbsp; PROCEDURE destroy
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF this.lLoaded
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RELEASE LIBRARY (SYS(2004)+"foxtools.fll")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp; ENDPROC

 &nbsp;&nbsp; PROCEDURE loadlib
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF !"FOXTOOLS" $ SET("library")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET LIBRARY TO (SYS(2004)+"FOXTOOLS")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.lLoaded = .T.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp; ENDPROC

 &nbsp;&nbsp; FUNCTION drivetype(tcDrive)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOCAL lnRetVal
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lnRetVal = (drivetype(tcDrive))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN lnRetVal
 &nbsp;&nbsp; ENDFUNC

 &nbsp;&nbsp; FUNCTION justpath(tcString)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOCAL lcRetVal
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lcRetVal = (this.addbs(justpath(tcString)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN lcRetVal
 &nbsp;&nbsp; ENDFUNC

 &nbsp;&nbsp; FUNCTION addbs(tcString)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOCAL lcRetVal
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lcRetVal = (addbs(tcString))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN lcRetVal
 &nbsp;&nbsp; ENDFUNC

 &nbsp;&nbsp; FUNCTION cleandir(tcString)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN(UPPER(sys(2027, tcString)))
 &nbsp;&nbsp; ENDFUNC

 &nbsp;&nbsp; PROCEDURE error (tnError, tcMethod, tnLine)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOCAL lcMessage

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcMethod = UPPER(tcMethod)

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO CASE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE tnError = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; File not found 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; Cause by the library not loaded
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.loadlib()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETRY

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OTHERWISE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?? CHR(7)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lcMessage = "An error has occurred:" + CHR(13) + ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Error Number: " + PADL(tnError,5) + CHR(13) + ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Method: " + tcMethod + CHR(13) + ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " Line Number: " + PADL(tnLine,5)

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =MESSAGEBOX(lcMessage, 48, "Ftools Error")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDCASE
 &nbsp;&nbsp; ENDPROC
ENDDEFINE
</code></pre>
<p>
This class shows the various purposes of a wrapper. Let's look at each one individually:</p>
<h3>Ease of Use: Encapsulating Error Trapping</h3>
<p>
When a library is loaded within Visual FoxPro, it can be unloaded by other objects by issuing one command. The FTOOLS class automatically loads FOXTOOLS.FLL (if it is not already loaded) when the object is instantiated. If the library is released by another module or object and a FoxTools function is called, Visual FoxPro will generate an error #1 (File Not Found). In that case, the error method calls the LoadLib method to reload the library. This provides developers with a simple way to use FoxTools without having to worry whether someone else's code unloaded the library.</p>
<h3>Enhancing Existing Functionality</h3>
<p>
The JustPath function in FoxTools calculates what portion of a filename string is the path designation and returns that path as a string. The string may or may not have a backslash at the end. In order to promote consistency, the method that calls JustPath also calls the AddBs method to add a backslash at the end of the string if one doesn't already exist. This is an example of enhanced functionality that provides developers with a simple and consistent return value.</p>
<h3>Adding Functionality</h3>
<p>
The CleanDir method is designed to adjust a path string for "backsteps." For example, a path string of "C:\WINAPPS\VFP\SAMPLES\DATA\...\GRAPHICS\" would adjust to "C:\WINAPPS\VFP\SAMPLES\ GRAPHICS\". This function does not call FoxTools at all; however, its functionality is related to the other functions included in this class. By adding a method for this function, we are giving developers access to related functionality in one place, without requiring them to load multiple classes.</p>
<p>
The ability to create and use wrapper classes is a major benefit to software development. Since the complexity of working with something can be hidden within a class without compromising the functionality, developers who use the wrapper will immediately notice an increase in their productivity by having it in their arsenals, without the cost of learning its intricacies.</p>
<h2>Manager Classes</h2>
<p>
A second type of non-visual class that is often created is a manager class. This class will typically manage instances of another class. A good example is the management of multiple instances of a form to ensure that subsequent instances are properly placed on the screen with a header that is identifiable (for example, Document1, Document2, and so on).</p>
<p>
This next example deals with that issue and shows a manager class along with a simple form class to manage.</p>
<pre><code>*&nbsp; Program...........: MANAGER.PRG
*&nbsp; Author............: Menachem Bazian, CPA
*&nbsp; Copyright.........: (c) Flash Creative Management, Inc. 95
*&nbsp; Created...........: 05/03/95
*) Description.......: Sample Manager Class with Managed Form Class
*&nbsp; Major change list.:

*-- This class is designed to manage a particular form class and make
*-- sure that when the forms are run they are "tiled" properly.

DEFINE CLASS FormManager AS Custom
 &nbsp;&nbsp; DECLARE aForms[1]
 &nbsp;&nbsp; nInstance = 0

 &nbsp;&nbsp; PROCEDURE RunForm
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *-- This method runs the form. The instance of the form class
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *-- is created in the aForms[] member array.
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOCAL lnFormLeft, llnFormTop, lcFormCaption
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nInstance = ALEN(THIS.aForms)

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *-- Set the Top and Left Properties to Cascade the new Form.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF nInstance &gt; 1 AND TYPE('THIS.aForms[nInstance -1]') = 'O' ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND NOT ISNULL(THIS.aForms[nInstance -1])
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lnFormTop = THIS.aForms[nInstance -1].Top + 20
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lnFormLeft = THIS.aForms[nInstance -1].Left + 10
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lnFormTop = 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lnFormLeft = 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *-- Set the caption to reflect the instance number.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lcFormCaption = "Instance " + ALLTRIM(STR(nInstance))

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *-- Instantiate the form and assign the object variable 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *-- to the array element.

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.aForms[nInstance] = CREATEOBJECT("TestForm")
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.aForms[nInstance].top = lnFormTop
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.aForms[nInstance].left = lnFormLeft
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.aForms[nInstance].caption = lcFormCaption
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THIS.aForms[nInstance].show()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *-- Redimension the array so that more instances of 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *-- the form can be launched.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION THIS.aforms[nInstance + 1]
 &nbsp;&nbsp; ENDPROC
ENDDEFINE

*-- This class is a form class that is designed to work with 
*-- the manager class.

DEFINE CLASS TestForm AS form
 &nbsp;&nbsp; Top = 0
 &nbsp;&nbsp; Left = 0
 &nbsp;&nbsp; Height = 87
 &nbsp;&nbsp; Width = 294
 &nbsp;&nbsp; DoCreate = .T.
 &nbsp;&nbsp; BackColor = RGB(192,192,192)
 &nbsp;&nbsp; BorderStyle = 2
 &nbsp;&nbsp; Caption = "Form1"
 &nbsp;&nbsp; Name = "Form1"

 &nbsp;&nbsp; ADD OBJECT label1 AS label WITH ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FontName = "Courier New", ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FontSize = 30, ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackStyle = 0, ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Caption = (time()), ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Height = 61, ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left = 48, ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Top = 12, ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Width = 205, ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name = "Label1"
ENDDEFINE
</code></pre>
<p>
Note that forms are instantiated through the RUNFORM method rather than directly with a CREATEOBJECT function. This allows the manager class to maintain control over the objects it instantiates.</p>
<p>
Manager classes are very useful. They allow a simple way to encapsulate code that would normally have to be duplicated every time an object is instantiated into one single place.</p>
<h2>Business Classes</h2>
<p>
Business classes are object oriented representations of business entities (a Customer, for example). The responsibilities of these classes will vary depending on the behavior of a particular object within the problem domain.</p>
<p>
The purpose of a business class is multifold. At an abstract level, it is possible to determine what the basic functionality of a business object would typically be and then to create a class around it. For example, the basic responsibilities of a business object might be to:
<ul type=disc>
<li>
Retrieve itself from the database.<br><br></li>
<li>
Move within the database tables (First, Last, Prev, Next).<br><br></li>
<li>
Display itself.<br><br></li>
<li>
Print itself.</li>
</ul>
<p>
These functions could be abstracted in a class as follows: </p>
<pre><code>DEFINE CLASS BaseBusiness AS custom
 &nbsp;&nbsp; cAlias = ""
 &nbsp;&nbsp; oData = .NULL.
 &nbsp;&nbsp; 
 &nbsp;&nbsp; PROCEDURE INIT
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF !EMPTY(this.cAlias) AND !USED(this.cAlias)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =MessageBox("Alias is not open!", 16)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp; ENDPROC

 &nbsp;&nbsp; PROCEDURE next
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT (this.cAlias)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SKIP 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF EOF()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO BOTTOM
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.readrecord()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF
 &nbsp;&nbsp; ENDPROC

 &nbsp;&nbsp; *-- Additional methods here for movement would mimic 
 &nbsp;&nbsp; *-- procedure NEXT.

 &nbsp;&nbsp; PROCEDURE readrecord
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *-- This procedure is initially empty.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCATTER NAME this.oData
 &nbsp;&nbsp; ENDPROC

 &nbsp;&nbsp; *-- Additional methods for saving would follow mimicing
 &nbsp;&nbsp; *-- procedure readrecord.

ENDDEFINE
</code></pre>
<p>
In order to create a customer object, for example, all we would need to do is subclass it as follows: </p>
<pre><code>DEFINE CLASS customer AS basebusiness
 &nbsp;&nbsp; cAlias = "Customer"
ENDDEFINE
</code></pre>
<p>
The fields in the customer alias would be automatically added as members of oData. Thus, if an object called oCust were instantiated from the customer class, the cName field would be held in oCust.oData.cName.</p>
<p>
Of course, the beauty of this method of development is that there is little coding to do from one business class to another. In effect, all you do is code by exception.</p>
<h2>Conclusion</h2>
<p>
Object-oriented programming (OOP) goes well beyond the world of the graphical user interface in Visual FoxPro. Non-visual classes represent a powerful weapon in our OOP arsenal for rapid, bug-free systems development.</p>
<h2>Acknowledgments</h2>
<p>
We acknowledge the help of Flash Creative Management, Inc., Hackensack, NJ, in providing portions of this material.</p>
</BODY>
</HTML>
