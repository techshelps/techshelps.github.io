<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Developing Applications Using Microsoft Distributed Transaction Coordinator</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_dtcapps"></a></sup>Developing Applications Using Microsoft Distributed Transaction Coordinator</h1>
<p>
Suriya Narayanan<br>
Principal Consultant<br>
Microsoft Consulting Services</p>
<p>
Updated: May 1996</p>
<h2>Introduction</h2>
<p>
Distributed applications are becoming a reality. Transactions are the fundamental units of processing in applications, and just about any operation in an application can be considered as a transaction. Therefore, in a distributed applications environment, it is necessary to have the tools and techniques to create, destroy, monitor, and manage transactions. In addition, having these tools and techniques available within a unifying architecture such as OLE and on commodity hardware and software enables developing distributed applications using the component object model and using commodity software components.</p>
<p>
This white paper explains writing applications using the Microsoft Distributed Transaction Coordinator Technology. A rudimentary knowledge of C, C++ programming, and transactions is assumed.</p>
<h2>Transactions</h2>
<p>
The word <i>transaction</i> is said to be derived from the phrase "transformation action<i>.</i>"<i> </i>A transaction is an action or series of actions that transform the system from one consistent state to another. For example, if I go the bank and transfer $50 from my checking account to my savings account, then I had performed a transaction; in that process, I had transformed (changed) the balances of my checking and savings accounts. Transactions are characterized by their ACID (atomicity, consistency, isolation, durability) properties:
<ul type=disc>
<li>
<b>Atomicity.</b> Atomicity refers to the all or nothing property of a transaction. When a transaction consists of a series of actions, either all the actions complete successfully or none of them complete successfully. If a transaction were to fail midway before completion, all the work it had done so far must be undone (rolled back).<br><br></li>
<li>
<b>Consistency.</b> The transaction transforms the system from one consistent state to another. Consistency of the system is dependent on the business rules and the semantics of the system and is enforced by the applications.<br><br></li>
<li>
<b>Isolation.</b> Even though multiple transactions can be executed concurrently, each transaction runs as if it is the only transaction on the system. It appears to each transaction that the other transactions are executed either before or after it. The effects of the transaction are not visible to the other transactions until the transaction either successfully completes (commits) or fails (aborts).<br><br></li>
<li>
<b>Durability.</b> Transactions, once they are committed are durable—the effects of the transaction are permanent despite system or network failures.</li>
</ul>
<p>
A Transaction Processing System can be viewed (see Figure 1) as consisting of three distinct components—<i>application programs</i>, the <i>transaction manager</i>, and <i>resource manager</i>s. These different components are not necessarily confined to independent nodes on the network. All these components, including the transaction manager, can be distributed across multiple nodes on the network. Resource managers own the objects affected by the transactions and are responsible for the persistent storage of the resource objects. Resource managers also guarantee the ACID properties of the transactions within themselves. Examples of resource managers include database systems such as Microsoft® SQL Server™ and ORACLE, and file systems such as Object File System in Windows NT®. An application can be an independent, self contained component by itself (with every piece of functionality, business rules and logic), or it can be a collection of cooperating components.</p>
<p>
<img src="dtcapps_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Generalized view of a transaction processing system</b></p>
<h3>Two-Phase Commit Protocol</h3>
<p>
Guaranteeing the ACID properties of the transaction is a relatively straightforward process when the actions of a transaction are confined to a single resource manager. Facilities such as logging and locking are examples of features provided by resource managers to guarantee the ACID properties. However, when more than one resource manager is involved in a transaction, guaranteeing the ACID properties is more involved and requires an additional protocol—the <i>two-phase commit protocol</i>. In the absence of a transaction manager, the application program must implement the two-phase commit protocol within itself. The protocol has two distinct phases—the <i>Prepare phase</i> and the <i>Commit phase</i>. The application program chooses a controlling agent—the <i>Commit Agent</i>. The Commit Agent can be one of the participating resource managers or another resource manager. The application program performs the actions on the resource managers normally. After completing the actions, the application enters the Prepare phase by sending a Prepare message to the resource managers. The resource managers record the fact that they are in Prepare phase and respond to the application program with Prepared messages. If, for some reason, any of the resource managers are not able to complete the Prepare phase, then the application must abort the transaction. After receiving Prepared messages from each of the participating resource managers, the application enters the Commit phase, by sending a Commit message to the Commit Agent. The Commit Agent records this fact. Then the application program must send the Commit message to each of the participating resource managers. If any of the participating resource managers fail to commit, then the application must abort the transaction in all the resource managers.</p>
<p>
<img src="dtcapps_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Two-phase commit protocol</b></p>
<p>
The two-phase commit protocol is a complex sequence of operations, and as the number of participating resource managers increase, the complexity of the two-phase commit protocol increases exponentially. Therefore, it is very difficult to write good application programs obeying the two-phase commit protocol rules, when several resource managers are involved. Having the transaction manager implement the two-phase commit protocol and handle all the relevant coordination issues enables simpler and easier to implement applications.</p>
<h2>What Is the Distributed Transaction Coordinator?</h2>
<p>
The Microsoft Distributed Transaction Coordinator (MSDTC) is an exciting new technology from Microsoft that provides one of the main foundations for transaction processing. The Microsoft Distributed Transaction Coordinator is characterized by the following key capabilities:
<ul type=disc>
<li>
MSDTC provides features to create, destroy, manage, and monitor transactions. Transactions are represented by <i>transaction objects</i>, and any application program following the rules of the DTC programming model can create transaction objects and perform operations on them.<br><br></li>
<li>
MSDTC is built within the architectural framework of the OLE Component Object Model. Application programs written using the OLE Component Object Model seamlessly integrate with MSDTC.<br><br></li>
<li>
Since MSDTC is implemented as OLE objects and interfaces, any programming language supporting the OLE calling conventions can be used to develop application programs.<br><br></li>
<li>
MSDTC itself exposes various OLE interfaces for applications and the resource managers to interact with MSDTC.<br><br></li>
<li>
MSDTC runs as a multithreaded Windows NT service.<br><br></li>
<li>
In a distributed environment, with several nodes each running MSDTC, the MSDTC instances on the various nodes cooperate and exchange messages when committing a transaction spanning many nodes.<br><br></li>
<li>
Any node running the MSDTC service can be the primary transaction coordinator.<br><br></li>
<li>
Transactions can be initiated from application programs running on client PCs or from server components residing in resource managers (such as Microsoft SQL Server Stored Procedures).<br><br></li>
<li>
Initially, MSDTC will be released with Microsoft SQL Server version 6.5.</li>
</ul>
<h2>Application Model Using Distributed Transaction Coordinator</h2>
<p>
Let us briefly examine the evolution of the application models. While the following treatise on the application models is not exact, it is a sufficient approximation to understand the application model when involving Distributed Transaction Coordinator.</p>
<p>
In the beginning, there were (and still are) these single-tier, highly monolithic programs containing everything from the user interface definitions, the business logic, business rules, and database operations. These monolithic programs have very limited structure, except the programming structures offered by the programming language of their implementation. Some of the very early COBOL programs doing extremely mission critical operations fall under this category.</p>
<p>
<img src="dtcapps_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Evolution of the Application Model</b></p>
<p>
As these early applications increased in number, size, and complexity, the connections to the databases from the application programs became too many and the connection management became expensive. A model involving a TP monitor evolved in order to optimally allocate the connections to the database and multiplex them across many application programs. This model assumed a central TP monitor such as CICS and IMS and divided the application into client and server parts. The server parts of the applications handled the database operations, business logic, and so forth, while the client parts of the applications handled the user interface using the dumb-terminal commands.</p>
<p>
The arrival of intelligent personal computers and relational database systems propelled this application model into another variation—the client-server two-tier model—where parts of the application residing on the client PC control the user interfaces and interact with the other parts of the applications running on the database server. Usually, these parts of the application running on the database servers performed all the database operations, as well as some limited set of business logic and rules. Using products such as Tuxedo, transaction processing principles were applied to this model as well.</p>
<p>
Three-tier models where the user interface, business logic, and database operations are confined to distinct layers of hardware and software evolved during this time as well. A good example of such an application model is the SAP business application software.</p>
<p>
The object-oriented methods of design and development matured, and the concept of the application as a collection of cooperating objects was born. The maturity of the object model combined with the maturity of technologies, such as remote procedure calls, facilitated true distributed applications, where the cooperating objects of the application can be distributed across nodes in the network. The object-oriented model of the application does not confine the application objects to specific tiers. However, it is very convenient to classify the application objects into three different categories—<i>user services</i>, <i>business services</i>, and <i>data services</i>.</p>
<p>
The Distributed Transaction Coordinator extends the object-oriented model of the application with objects required for transaction processing. DTC provides objects to create, destroy, manage, and monitor transaction objects. These transaction objects can in turn be operated upon by the application programs and resource managers. The application objects can use the services provided by the DTC objects, when transaction processing is desired by the application. Transactions are characterized by their ACID properties. The DTC objects guarantee the atomicity of the transactions when their actions span multiple resource managers using the two-phase commit protocol. The other characteristics—consistency, isolation, and durability—of the transaction are guaranteed by the resource managers participating in the transaction.</p>
<h2>Programming Models</h2>
<p>
As discussed in the application model, the role of the Distributed Transaction Coordinator in an application is to guarantee the atomicity of the transactions. The transactions must be initiated by some other component of the application. The component that initiates the transaction will receive a pointer to the transaction; the component cannot pass this pointer to another component. Therefore, DTC requires that the transaction be completed by the same component that initiated it.</p>
<h3>Two-Tier Programming Model</h3>
<p>
The two-tier model refers to the classical client-server model of programming, where a client PC provides the user interfaces for an application and interacts with other components on the database server. The business rules can be in the client application program, in the database server components such as stored procedures, or in both. The client application program uses APIs such as DBLIB or ODBC to communicate with the database server. While this is not the modern object-oriented model of the application, there are numerous applications that were written around this model. The Distributed Transaction Coordinator can be used in this model very effectively. When introducing DTC into this programming model, the transaction can be initiated and committed in two different places—the client application program and the database server stored procedure.</p>
<h4>Client-initiated transactions</h4>
<p>
There are four general steps involved in processing a transaction when the client application program initiates the transaction:
<ol>
<li>
Establish a Primary Distribution Transaction Coordinator<br><br></li>
<li>
Initiate a Transaction<br><br></li>
<li>
Enlist the Resource Managers<br><br></li>
<li>
Commit or Abort the Transaction</li>
</ol>
<p>
In order to use DTC, the client application program must establish a connection to the DTC service. The DTC service can be running on either the same node as the application program or on another node on the network. Once the connection to the DTC is established, this instance of DTC becomes the primary DTC for this transaction. Other instances of DTC running on resource managers participating in the transaction become subordinate DTCs. As the application program begins and commits transactions, the primary and subordinate DTC exchange messages and cooperate to guarantee atomicity.</p>
<p>
Opening a connection to the Primary DTC is done using the DtcGetTransactionManager helper API call. Using this helper API, the application program can obtain a pointer to the ITransactionDispenser interface. After opening a connection to the Primary DTC, the application program can then proceed with usual API calls to open ODBC or DBLIB connections to the resource managers. The application program can initiate the transaction using the BeginTransaction member function in the ITransactionDispenser interface, obtaining a pointer to the ITransaction interface. The pointer to the ITransaction interface represents the transaction object. The application program must enlist the participating resource managers to the transaction object in order to tie the transaction object and the resource managers together. The enlistment is done via the function <b>dbenlisttrans</b> for DBLIB and the <b>SQLSetConnectOption</b> function call for ODBC. After the enlistment of the participating resource managers is complete, the application can continue to send commands to the resource managers for actions within the transaction. When the application is ready to commit the transaction, it calls the <b>Commit</b> member function of the transaction object. Or, the <b>Abort</b> member function of the transaction object can be called to roll back or abort the transaction. The transaction and the transaction dispenser objects can be released at this time.</p>
<h4>Database Server Stored Procedure Initiated Transactions</h4>
<p>
The programming model is simpler for stored procedure initiated transactions. The Microsoft SQL Server 6.5 Transasct SQL syntax has been enhanced to support the <b>BEGIN DISTRIBUTED TRANSACTION</b> statement. Microsoft SQL server recognizes this statement and performs the appropriate transaction initiation and enlistment steps on behalf of the application program. Any TRANSACT SQL commands enclosed by the <b>BEGIN DISTRIBUTED TRANSACTION</b> and the <b>COMMIT TRANSACTION</b> statements constitute the transaction. When it is necessary to involve another SQL Server (resource manager) in the transaction, remote stored procedure calls are used. When a remote stored procedure call to another SQL server is performed within a stored procedure, the SQL Server will automatically enlist the remote SQL server on the application program's behalf. SQL server will use the DTC services to commit the transaction when it executes <b>COMMIT TRANSACTION</b>.</p>
<p>
In addition to using the <b>BEGIN DISTRIBUTED TRANSACTION</b> statement, the SQL server can be configured to use DTC services for the transaction every time a <b>BEGIN TRANSACTION</b> statement is encountered. All the remote stored procedure calls within a transaction will use DTC transaction services. The new server configuration option <b>remote proc trans</b> is introduced in SQL Server. Turning this option on by using the <b>sp_configure</b> system procedure will enable SQL Server to use DTC transaction services server-wide.</p>
<p>
Application programs can also temporarily turn on using the DTC transaction services by using the <b>SET REMOTE_PROCEDURE_TRANSACTIONS ON</b> statement.</p>
<p>
Having the database server or the resource manager stored procedures initiate the transactions reduce the likelihood of "in doubt" transactions. In doubt transactions result when the participating resource managers completed the Prepare phase, but they never hear back from the Commit Agent because either the Commit Agent itself may have crashed or the network might have disconnected. Since the resource managers can neither commit nor abort the transaction, the transaction status is in question; therefore, they are called in doubt transactions. Since a resource manager node is more likely to be running a DTC instance as well (as the resource managers usually run on more powerful hardware), it is very likely that the DTC instance running on the resource manager acts as the primary transaction coordinator. Having a local DTC instance as the primary coordinator reduces the number of DTC-DTC messages across the network and therefore can increase the performance throughput as well.</p>
<h3>Three-Tier Programming Model</h3>
<p>
As discussed earlier, the Distributed Transaction Coordinator fits very well within the object-oriented model, where the application is viewed as a collection of cooperating objects, distributed across the nodes in the network. Using the convenient classification of these objects into user services, business services, and data services, the DTC objects are very likely to fit within the business services layer, although they provide supporting services such as creation, management, and coordination of transaction objects. Any application component can initiate a transaction, although it is very likely to be the business services object. The above discussions and programming models on client-initiated and server-initiated transactions are valid in the three-tier context as well.</p>
<h2>Example Application</h2>
<p>
A sample application using the Distributed Transaction Services can be implemented using two SQL servers, one managing a database of orders and the other managing a database of customers. The business problem is that whenever an order is entered, the order gets approved only if the customer has adequate credit limit and the credit limit should be updated after the order is approved. The business transaction and the application are shown in Figure 4.</p>
<p>
<img src="dtcapps_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Example application and transaction</b></p>
<p>
This sample application is implemented by using the Distributed Transaction Coordinator Services using all the different programming models discussed earlier.</p>
<h3>Client-Initiated Transactions Using DBLIB</h3>
<pre><code>#define&nbsp;&nbsp;&nbsp; INITGUID
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;txdtc.h&gt;
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;xolehlp.h&gt;

#define&nbsp;&nbsp;&nbsp;&nbsp; DBNTWIN32
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;stdio.h&gt;
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;windows.h&gt;
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;sqlfront.h&gt;
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;sqldb.h&gt;

#include&nbsp;&nbsp;&nbsp; "OrderEntry.h"

// Forward declarations of the error handler and message handler. 
int err_handler(PDBPROCESS, INT, INT, INT, LPCSTR, LPCSTR);
int msg_handler(PDBPROCESS, DBINT, INT, INT, LPCSTR, LPCSTR,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPCSTR, DBUSMALLINT);
 
main(int argc, char **argv)
{
 &nbsp;&nbsp; // Transaction Dispenser and Transaction Objects

 &nbsp;&nbsp; ITransactionDispenser *pTransactionDispenser;
 &nbsp;&nbsp; ITransaction *pTransaction;

 &nbsp;&nbsp; 
 &nbsp;&nbsp; HRESULT hr;
 &nbsp;&nbsp; RETCODE rc;
 &nbsp;&nbsp; PDBPROCESS pdb1, pdb2;
 &nbsp;&nbsp; PLOGINREC&nbsp;&nbsp; login;&nbsp;&nbsp;&nbsp;&nbsp; // The login information. 

 &nbsp;&nbsp; ORDER_HEADER&nbsp;&nbsp;&nbsp; OrderHeader;
 &nbsp;&nbsp; ORDER_LINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderLine[100];
 &nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; NumberLines = 0;
 &nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; CustomerNumber;
 &nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; OrderTotal;

 &nbsp;&nbsp; // Open a connection to the Distributed Transaction Coordinator.

 &nbsp;&nbsp; hr = DtcGetTransactionManager(
NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DTC Host name - this host
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Transaction Manager Name
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_ITransactionDispenser,&nbsp;&nbsp;&nbsp; // Interface needed
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void *)NULL,&nbsp;&nbsp;&nbsp; // Also Reserved
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void **)&amp;pTransactionDispenser);&nbsp;&nbsp;&nbsp; 
// Ptr to Interface

 &nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Can't init Transaction Manager\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (0);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Initialize DB-Library.
 &nbsp;&nbsp; dbinit ();

 &nbsp;&nbsp; // Set up Error and Message handlers
dberrhandle (err_handler);
 &nbsp;&nbsp; dbmsghandle (msg_handler);

 &nbsp;&nbsp; login = dblogin ();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get a LOGINREC.
 &nbsp;&nbsp; DBSETLUSER (login, SQL_USER_ID);
 &nbsp;&nbsp; DBSETLPWD (login, SQL_PASSWORD);
 &nbsp;&nbsp; DBSETLAPP (login, "DTCApp");

 &nbsp;&nbsp; // Open Connections to the Database servers
 &nbsp;&nbsp; pdb1 = dbopen (login, SQL_SERVER_1);
 &nbsp;&nbsp; pdb2 = dbopen (login, SQL_SERVER_2);

 &nbsp;&nbsp; // Get the Order Data from the user. This is where the 
 &nbsp;&nbsp; // Order Entry UI will get involved. For the time being, it is 
 &nbsp;&nbsp; // a simple function which returns a set of pre-defined records

 &nbsp;&nbsp; GetOrderRecords(&amp;CustomerNumber, &amp;OrderHeader, OrderLine, &amp;NumberLines);

 &nbsp;&nbsp; // Compute the Order totals
 &nbsp;&nbsp; GetOrderTotals(OrderLine, NumberLines, &amp;OrderTotal);

 &nbsp;&nbsp; // Create a Transaction object using
 &nbsp;&nbsp; // the BeginTransaction call.
 &nbsp;&nbsp; hr = pTransactionDispenser-&gt;BeginTransaction (
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Controlling Iunknown Interface
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISOLATIONLEVEL_BROWSE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Isolation level
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Isolation Flags
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pTransaction);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ptr to Transaction Object
 &nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Can't BeginTrans\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(0);
 &nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; // Enlist the SQL servers in the transaction

 &nbsp;&nbsp; rc = dbenlisttrans(pdb1, pTransaction);
 &nbsp;&nbsp; rc = dbenlisttrans(pdb2, pTransaction);

 &nbsp;&nbsp; // Complete the Order Entry process

 &nbsp;&nbsp; if (InsertSaleOrder(pdb1, pdb2, CustomerNumber, &amp;OrderHeader, 
OrderLine, NumberLines, OrderTotal) == FAIL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the Order Entry does not succeed, then abort 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the transaction
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTransaction-&gt;Abort(FALSE, FALSE, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Transaction Aborted\n");
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Order entry is successful, Commit the transaction
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTransaction-&gt;Commit(0,0,0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Transaction Committed\n");
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Close the Resource Manager connections
 &nbsp;&nbsp; dbclose (pdb1);
 &nbsp;&nbsp; dbclose (pdb2);
 &nbsp;&nbsp; return (0);
}

// Get order data from possibly the user interface.
void GetOrderRecords (long *pCustomerNumber, ORDER_HEADER *pOrderHeader,
ORDER_LINE *pOrderLine, long *pNumberLines)
{
 &nbsp;&nbsp; // Hard code the Order data for now.

 &nbsp;&nbsp; *pCustomerNumber = 100;

 &nbsp;&nbsp; pOrderHeader-&gt;OrderNumber = 102;
 &nbsp;&nbsp; strcpy (pOrderHeader-&gt;OrderDate, "11/22/1995");
 &nbsp;&nbsp; strcpy (pOrderHeader-&gt;ShipAddress1, "100 Main Street");
 &nbsp;&nbsp; strcpy (pOrderHeader-&gt;ShipAddress2, "Bellevue");
 &nbsp;&nbsp; strcpy (pOrderHeader-&gt;ShipState, "WA");
 &nbsp;&nbsp; strcpy (pOrderHeader-&gt;ShipZip, "12345-111");

 &nbsp;&nbsp; *pNumberLines = 5;

 &nbsp;&nbsp; for (long i = 1; i &lt;= *pNumberLines; i++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;OrderNumber = 102;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;LineNumber = i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;ProductNumber = 2 * i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;Quantity = i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;UnitPrice = 10 + i;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine++;
 &nbsp;&nbsp; }
}

// Compute the Order Total
void&nbsp;&nbsp;&nbsp; GetOrderTotals(ORDER_LINE *pOrderLine, long NumberLines, long *pOrderTotal)
{

 &nbsp;&nbsp; *pOrderTotal = 0;
 &nbsp;&nbsp; for (long i = 0 ; i &lt; NumberLines ;i++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pOrderTotal += pOrderLine-&gt;Quantity * 
pOrderLine-&gt;UnitPrice;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine++;
 &nbsp;&nbsp; }
}

// Query the Customer database server and retrieve the available 
// credit

void GetAvailableCredit(long CustomerNumber, PDBPROCESS pDB, long *pAvailCredit)
{
 &nbsp;&nbsp; RETCODE rc;

 &nbsp;&nbsp; // Assemble the command line to retrieve the credit limit.
 &nbsp;&nbsp; rc = dbfcmd (pDB, 
 &nbsp;&nbsp; "select AvailableCredit from Customer where CustomerNumber = %ld",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustomerNumber);

 &nbsp;&nbsp; // Run the command on the Customer database server
 &nbsp;&nbsp; rc = dbsqlexec(pDB);

 &nbsp;&nbsp; // Process the results and retrieve the credit limit
 &nbsp;&nbsp; rc = dbresults(pDB);

 &nbsp;&nbsp; // Bind column data to program variables 
 &nbsp;&nbsp; rc = dbbind(pDB, 1, INTBIND, (DBINT) 0, (BYTE *) pAvailCredit);

 &nbsp;&nbsp; // Process rows. There should be only one row for this query.
 &nbsp;&nbsp; while (dbnextrow(pDB) != NO_MORE_ROWS)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dbnextrow(pDB);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; rc = dbresults(pDB);&nbsp;&nbsp;&nbsp; // Should return NO_MORE_RESULTS
}

// Insert the Order Lines into the Orders database server and update 
// the credit limit on the customer database server

RETCODE InsertSaleOrder(PDBPROCESS pdb1, PDBPROCESS pdb2, 
long CustomerNumber, ORDER_HEADER *pOrderHeader, 
ORDER_LINE *pOrderLine, long NumberLines, long OrderTotal)
{
 &nbsp;&nbsp; RETCODE rc;
 &nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; AvailCredit;

 &nbsp;&nbsp; // Reduce the available credit in the customer database server
 &nbsp;&nbsp; // Assemble the command and send it.

 &nbsp;&nbsp; dbfcmd (pdb2, 
"update Customer set AvailableCredit = AvailableCredit - %ld where\
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustomerNumber = %ld\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderTotal, CustomerNumber);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Run the command in the customer database server
 &nbsp;&nbsp; rc = dbsqlexec(pdb2);

 &nbsp;&nbsp; if (rc == FAIL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (FAIL);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // No results are expected, again.
 &nbsp;&nbsp; while (dbresults(pdb2) != NO_MORE_RESULTS)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (dbnextrow(pdb2) != NO_MORE_ROWS)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // To ensure that the customer&nbsp; has the credit 
 &nbsp;&nbsp; // read the credit limit and make sure it is 
 &nbsp;&nbsp; // greater than 0

 &nbsp;&nbsp; GetAvailableCredit(CustomerNumber,&nbsp; pdb2, &amp;AvailCredit);

 &nbsp;&nbsp; if (AvailCredit &lt;= 0L)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Not Enough Credit For the Order\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (FAIL);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Insert Header - Assemble the command line and send it to 
 &nbsp;&nbsp; // the server
 &nbsp;&nbsp; rc = dbfcmd (pdb1, 
"insert into OrderHeader(OrderNumber, OrderDate, \
CustomerNumber,ShipAddress1, ShipAddress2,\
ShipState, ShipZip) values(%ld, \'%s\',\
%ld,\'%s\',\'%s\',\'%s\',\'%s\')\n",
pOrderHeader-&gt;OrderNumber, pOrderHeader-&gt;OrderDate,
CustomerNumber, pOrderHeader-&gt;ShipAddress1,
pOrderHeader-&gt;ShipAddress2, pOrderHeader-&gt;ShipState,
pOrderHeader-&gt;ShipZip) ;

 &nbsp;&nbsp; // Insert the detail lines. Assemble the command lines and 
 &nbsp;&nbsp; // send them
 &nbsp;&nbsp; for (long i = 0; i &lt;NumberLines ; i++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dbfcmd(pdb1, 
"Insert into OrderLine(OrderNumber, LineNumber, \
ProductNumber, Quantity, UnitPrice) values(\
%ld, %ld, %ld, %ld, %ld)\n",
pOrderLine-&gt;OrderNumber,
pOrderLine-&gt;LineNumber,
pOrderLine-&gt;ProductNumber,
pOrderLine-&gt;Quantity,
pOrderLine-&gt;UnitPrice) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine++;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // All the SQL command lines to enter the order has been 
// sent. Run them.

 &nbsp;&nbsp; rc = dbsqlexec(pdb1);

 &nbsp;&nbsp; if (rc == FAIL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (FAIL);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // No results are expected from the server

 &nbsp;&nbsp; while (dbresults(pdb1) != NO_MORE_RESULTS)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (dbnextrow(pdb1) != NO_MORE_ROWS)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }

 &nbsp;&nbsp; return (SUCCEED);
}

// Error and Message handler procedures for the DB Library

int err_handler (PDBPROCESS dbproc, INT severity,
 &nbsp;&nbsp; INT dberr, INT oserr, LPCSTR dberrstr, LPCSTR oserrstr)
{
 &nbsp;&nbsp; printf ("DB-Library Error %i: %s\n", dberr, dberrstr);
 &nbsp;&nbsp; if (oserr != DBNOERR)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ("Operating System Error %i: %s\n", oserr, oserrstr);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return (INT_CANCEL);
}

int msg_handler (PDBPROCESS dbproc, DBINT msgno, INT msgstate,
 &nbsp;&nbsp; INT severity, LPCSTR msgtext, LPCSTR server,
 &nbsp;&nbsp; LPCSTR procedure, DBUSMALLINT line)
{
 &nbsp;&nbsp; printf ("SQL Server Message %ld: %s\n", msgno, msgtext);
 &nbsp;&nbsp; return (0);
}
Client Initiated Transactions Using ODBC
#define&nbsp;&nbsp;&nbsp; INITGUID
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;txdtc.h&gt;
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;xolehlp.h&gt;

#define&nbsp;&nbsp;&nbsp;&nbsp; DBNTWIN32
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;stdio.h&gt;
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;windows.h&gt;

#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;SQL.h&gt;
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;SQLEXT.h&gt;
#include&nbsp;&nbsp;&nbsp;&nbsp; "odbcss.h"
#include&nbsp;&nbsp;&nbsp;&nbsp; &lt;ODBCINST.h&gt;

#include&nbsp;&nbsp;&nbsp; "OrderEntry.h"

void ProcessRC(LPTSTR pszFuncName, RETCODE rc, HDBC hDbc, HSTMT hStmt);
void DoSQLError(HDBC hDbc, HSTMT hStmt);

HENV&nbsp;&nbsp;&nbsp; hEnv = SQL_NULL_HENV;

main(int argc, char **argv)
{
 &nbsp;&nbsp; // Declare the Transaction Dispenser and Transaction Objects

 &nbsp;&nbsp; ITransactionDispenser *pTransactionDispenser;
 &nbsp;&nbsp; ITransaction *pTransaction;
 &nbsp;&nbsp; HRESULT hr;
 &nbsp;&nbsp; HDBC&nbsp;&nbsp;&nbsp; hDbc1, hDbc2;

 &nbsp;&nbsp; ORDER_HEADER&nbsp;&nbsp;&nbsp; OrderHeader;
 &nbsp;&nbsp; ORDER_LINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderLine[100];
 &nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; NumberLines = 0;
 &nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; CustomerNumber,OrderTotal;
 &nbsp;&nbsp; RETCODE rc = 0;

 &nbsp;&nbsp; // Open a connection to the Distributed Transaction Coordinator
 &nbsp;&nbsp; hr = DtcGetTransactionManager(
NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DTC Host name - This Host
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DTC Name
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_ITransactionDispenser,&nbsp;&nbsp;&nbsp;&nbsp; // Interface needed
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved Params
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void *)NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void **)&amp;pTransactionDispenser);
// Ptr to Interface

 &nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Can't init Transaction Manager\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (0);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Initialize ODBC
 &nbsp;&nbsp; rc =&nbsp; SQLAllocEnv(&amp;hEnv);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ProcessRC("SQLAllocEnv", rc, SQL_NULL_HDBC, SQL_NULL_HSTMT);

 &nbsp;&nbsp; // Allocate Connections to the Database Servers
 &nbsp;&nbsp; rc = SQLAllocConnect(hEnv, &amp;hDbc1);
 &nbsp;&nbsp; ProcessRC("SQLAllocConnect-1", rc, SQL_NULL_HDBC, SQL_NULL_HSTMT);

 &nbsp;&nbsp; rc = SQLAllocConnect(hEnv, &amp;hDbc2);
 &nbsp;&nbsp; ProcessRC("SQLAllocConnect-2", rc, SQL_NULL_HDBC, SQL_NULL_HSTMT);

 &nbsp;&nbsp; // Establish Connections to Database Servers
 &nbsp;&nbsp; rc = SQLConnect(hDbc1, (unsigned char*)SQL_SERVER_1, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned char *)SQL_USER_ID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned char *)SQL_PASSWORD,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );

 &nbsp;&nbsp; ProcessRC("SQLConnect-1",rc, hDbc1, SQL_NULL_HSTMT);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; rc = SQLConnect(hDbc2, (unsigned char *)SQL_SERVER_2, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned char *)SQL_USER_ID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned char *)SQL_PASSWORD,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );

 &nbsp;&nbsp; ProcessRC("SQLConnect-2",rc, hDbc2, SQL_NULL_HSTMT);

 &nbsp;&nbsp; // Get the Order detail. This is the place for the UI to get 
 &nbsp;&nbsp; // involved. For the time being, hard code some generic 
 &nbsp;&nbsp; // order data

 &nbsp;&nbsp; GetOrderRecords(&amp;CustomerNumber, &amp;OrderHeader, OrderLine, 
&amp;NumberLines);

 &nbsp;&nbsp; // Compute Order total
 &nbsp;&nbsp; GetOrderTotals(OrderLine, NumberLines, &amp;OrderTotal);

 &nbsp;&nbsp; // Create a Transaction Object using the BeginTransaction Call

 &nbsp;&nbsp; hr = pTransactionDispenser-&gt;BeginTransaction (
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Controlling IUnknown
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISOLATIONLEVEL_BROWSE,&nbsp;&nbsp;&nbsp; // Isolation level
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Isolation Flags
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pTransaction);&nbsp;&nbsp;&nbsp; // Ptr to the Transaction Object

 &nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Can't BeginTrans\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(0);
 &nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; // Enlist the SQL servers in the transaction
 &nbsp;&nbsp; // Note the syntax difference from DBLIB

 &nbsp;&nbsp; rc = SQLSetConnectOption(hDbc1, SQL_COPT_SS_ENLIST_IN_DTC, 
UDWORD(pTransaction));
 &nbsp;&nbsp; rc = SQLSetConnectOption(hDbc2, SQL_COPT_SS_ENLIST_IN_DTC, 
UDWORD(pTransaction));
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Process the Order

 &nbsp;&nbsp; if (InsertSaleOrder(hDbc1, hDbc2, CustomerNumber, &amp;OrderHeader, 
OrderLine, NumberLines, OrderTotal) == FALSE)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the Order entry failed for some reason, abort 
// the transaction
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTransaction-&gt;Abort(FALSE, FALSE, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Transaction Aborted\n");
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Order entry was successful, commit the transaction.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTransaction-&gt;Commit(0,0,0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Transaction Committed\n");
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Free the ODBC connections to the databases

 &nbsp;&nbsp; rc = SQLDisconnect(hDbc1);
 &nbsp;&nbsp; rc = SQLDisconnect(hDbc2);
 &nbsp;&nbsp; rc = SQLFreeConnect(hDbc1);
 &nbsp;&nbsp; rc = SQLFreeConnect(hDbc2);
 &nbsp;&nbsp; rc = SQLFreeEnv(hEnv);

 &nbsp;&nbsp; return (0);
}


// Get the Order records. This is the place to involve the UI, but 
// for the time being hard code the data in the code itself

void GetOrderRecords (long *pCustomerNumber, ORDER_HEADER *pOrderHeader, ORDER_LINE *pOrderLine, long *pNumberLines)
{
 &nbsp;&nbsp; *pCustomerNumber = 100;

 &nbsp;&nbsp; pOrderHeader-&gt;OrderNumber = 102;
 &nbsp;&nbsp; strcpy (pOrderHeader-&gt;OrderDate, "11/22/1995");
 &nbsp;&nbsp; strcpy (pOrderHeader-&gt;ShipAddress1, "100 Main Street");
 &nbsp;&nbsp; strcpy (pOrderHeader-&gt;ShipAddress2, "Bellevue");
 &nbsp;&nbsp; strcpy (pOrderHeader-&gt;ShipState, "WA");
 &nbsp;&nbsp; strcpy (pOrderHeader-&gt;ShipZip, "12345-111");

 &nbsp;&nbsp; *pNumberLines = 5;

 &nbsp;&nbsp; for (long i = 1; i &lt;= *pNumberLines; i++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;OrderNumber = 102;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;LineNumber = i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;ProductNumber = 2 * i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;Quantity = i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;UnitPrice = 10 + i;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine++;
 &nbsp;&nbsp; }
}

// Compute the Order totals

void&nbsp;&nbsp;&nbsp; GetOrderTotals(ORDER_LINE *pOrderLine, long NumberLines, long *pOrderTotal)
{

 &nbsp;&nbsp; *pOrderTotal = 0;
 &nbsp;&nbsp; for (long i = 0 ; i &lt; NumberLines ;i++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pOrderTotal += pOrderLine-&gt;Quantity * 
pOrderLine-&gt;UnitPrice;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine++;
 &nbsp;&nbsp; }
}

// Query the Customer Database Server for the customer's avialable
// credit limit

void GetAvailableCredit(long CustomerNumber, HDBC hDbc, 
long *pAvailCredit)
{
 &nbsp;&nbsp; RETCODE rc;
 &nbsp;&nbsp; HSTMT&nbsp;&nbsp;&nbsp; hStmt;
 &nbsp;&nbsp; char cmdBuf[500];

 &nbsp;&nbsp; SDWORD cbAvailCredit;

 &nbsp;&nbsp; rc = SQLAllocStmt(hDbc, &amp;hStmt);
 &nbsp;&nbsp; ProcessRC("SQLAllocStmt", rc, hDbc, hStmt);

 &nbsp;&nbsp; // Assemble the command line and send it to the server
 &nbsp;&nbsp; sprintf (cmdBuf, 
 &nbsp;&nbsp; "select AvailableCredit from Customer where CustomerNumber = %ld",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustomerNumber );

 &nbsp;&nbsp; rc = SQLExecDirect(hStmt, (UCHAR *)cmdBuf, SQL_NTS);
 &nbsp;&nbsp; ProcessRC("SQLExecDirect", rc, hDbc, hStmt);

 &nbsp;&nbsp; // Prepare to process the results from the server
 &nbsp;&nbsp; rc = SQLBindCol(hStmt, 1, SQL_C_SLONG, pAvailCredit,0,
 &amp;cbAvailCredit);
 &nbsp;&nbsp; ProcessRC("SQLBindCol", rc, hDbc, hStmt);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; rc = SQLFetch(hStmt);
 &nbsp;&nbsp; ProcessRC("SQLFetch", rc, hDbc, hStmt);

 &nbsp;&nbsp; rc = SQLFreeStmt(hStmt, SQL_DROP);

}

// Perform the Order Entry transaction. Insert the Order data into 
// the Order Database tables and reduce the customer's credit limit 
// on the customer database server.

BOOL InsertSaleOrder(HDBC hDbc1, HDBC hDbc2, long CustomerNumber, ORDER_HEADER *pOrderHeader, ORDER_LINE *pOrderLine, long NumberLines, long OrderTotal)
{
 &nbsp;&nbsp; RETCODE rc;
 &nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; cmdBuf[500];
 &nbsp;&nbsp; HSTMT&nbsp;&nbsp;&nbsp; hStmt1, hStmt2;
 &nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; AvailCredit;

 &nbsp;&nbsp; // Reduce the credit limit - assemble the SQL command for this 
 &nbsp;&nbsp; // and send it

 &nbsp;&nbsp; rc = SQLAllocStmt(hDbc2, &amp;hStmt2);
 &nbsp;&nbsp; ProcessRC("SQLAllocStmt", rc, hDbc2, hStmt2);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; sprintf (cmdBuf, 
"update Customer set AvailableCredit = AvailableCredit - %ld where \
CustomerNumber = %ld\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderTotal, CustomerNumber);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; rc = SQLExecDirect(hStmt2, (UCHAR *)cmdBuf, SQL_NTS);
 &nbsp;&nbsp; if (rc == SQL_ERROR || rc == SQL_SUCCESS_WITH_INFO)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (FALSE);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // To ensure that the customer has the
 &nbsp;&nbsp; // credit, read the credit limit and make sure it is 
 &nbsp;&nbsp; // greater than 0

 &nbsp;&nbsp; GetAvailableCredit(CustomerNumber, hDbc2, &amp;AvailCredit);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; if (AvailCredit &lt;= 0L)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Not Enough Credit for the Order\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (FALSE);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; SQLFreeStmt(hStmt2, SQL_DROP);

 &nbsp;&nbsp; rc = SQLAllocStmt(hDbc1, &amp;hStmt1);
 &nbsp;&nbsp; ProcessRC("SQLAllocStmt", rc, hDbc1, hStmt1);

 &nbsp;&nbsp; // Insert Header - Assemble the commands and send it.

 &nbsp;&nbsp; sprintf (
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdBuf,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "insert into OrderHeader(OrderNumber, OrderDate, \
CustomerNumber,ShipAddress1, ShipAddress2,\
ShipState, ShipZip) values(%ld, \'%s\',\
%ld,\'%s\',\'%s\',\'%s\',\'%s\')\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderHeader-&gt;OrderNumber, pOrderHeader-&gt;OrderDate,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustomerNumber, pOrderHeader-&gt;ShipAddress1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderHeader-&gt;ShipAddress2, pOrderHeader-&gt;ShipState,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderHeader-&gt;ShipZip) ;

 &nbsp;&nbsp; rc = SQLExecDirect(hStmt1, (UCHAR *)cmdBuf, SQL_NTS);
 &nbsp;&nbsp; if (rc == SQL_ERROR || rc == SQL_SUCCESS_WITH_INFO)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (FALSE);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Insert the line items - assemble the SQL commands and send it.
 &nbsp;&nbsp; for (long i = 0; i &lt;NumberLines ; i++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf (cmdBuf, 
"Insert into OrderLine(OrderNumber, LineNumber, \
ProductNumber, Quantity, UnitPrice) values(\
%ld, %ld, %ld, %ld, %ld)\n",
pOrderLine-&gt;OrderNumber,
pOrderLine-&gt;LineNumber,
pOrderLine-&gt;ProductNumber,
pOrderLine-&gt;Quantity,
pOrderLine-&gt;UnitPrice) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = SQLExecDirect(hStmt1, (UCHAR *)cmdBuf, SQL_NTS);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rc == SQL_ERROR || rc == SQL_SUCCESS_WITH_INFO)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine++;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; SQLFreeStmt(hStmt1, SQL_DROP);

 &nbsp;&nbsp; return (TRUE);
}

// Process the return code from the ODBC API functions

void ProcessRC(LPTSTR pszFuncName, RETCODE rc, HDBC hDbc, HSTMT hStmt)
{
 &nbsp;&nbsp; switch (rc)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp; case SQL_SUCCESS:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%s succeeded\n",pszFuncName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case SQL_SUCCESS_WITH_INFO:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%s succeeded with info\n",pszFuncName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DoSQLError(hDbc, hStmt);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case SQL_ERROR:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%s Failed - see more info\n",pszFuncName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DoSQLError(hDbc, hStmt);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1); // need better cleanup mechanism later....
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case SQL_INVALID_HANDLE:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%s Failed - SQL_INVALID_HANDLE\n",pszFuncName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1); // need better cleanup mechanism later....
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case SQL_NO_DATA_FOUND:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%s Failed - SQL_NO_DATA_FOUND\n",pszFuncName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case SQL_STILL_EXECUTING:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%s Failed - SQL_STILL_EXECUTING\n",pszFuncName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; case SQL_NEED_DATA:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%s Failed - SQL_NEED_DATA\n",pszFuncName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%s Failed - unexpected error, rc = %x\n",pszFuncName,rc);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DoSQLError(hDbc, hStmt);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1); // need better cleanup mechanism later....
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp; }
}

void DoSQLError(HDBC hDbc, HSTMT hStmt)
{

 &nbsp;&nbsp; const&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; MSG_BUF_SIZE = 300;
 &nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp; szSqlState[MSG_BUF_SIZE];
 &nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp; szErrorMsg[MSG_BUF_SIZE];
 &nbsp;&nbsp; 
 &nbsp;&nbsp; SQLINTEGER /* SWORD&nbsp;&nbsp;&nbsp; */ fNativeError&nbsp;&nbsp;&nbsp; = 0;
 &nbsp;&nbsp; SWORD&nbsp;&nbsp;&nbsp; cbErrorMsg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = MSG_BUF_SIZE;
 &nbsp;&nbsp; RETCODE&nbsp;&nbsp;&nbsp; rc;

 &nbsp;&nbsp; rc = SQLError(hEnv,hDbc,hStmt,szSqlState,&amp;fNativeError,szErrorMsg,MSG_BUF_SIZE,&amp;cbErrorMsg);
 &nbsp;&nbsp; if (rc != SQL_NO_DATA_FOUND || rc != SQL_ERROR)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("SQLError info:\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("SqlState: %s, fNativeError: %x\n",szSqlState,fNativeError);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error Message: %s\n",szErrorMsg);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("SQLError() failed: %x, NO_DATA_FOUND OR SQL_ERROR\n",rc);
 &nbsp;&nbsp; }

}
</code></pre>
<h3>Server-Initiated Transactions Using ODBC</h3>
<p>
The client application program runs stored procedures on the Order Entry SQL Server. The stored procedures, in turn, will run other remote stored procedures on the Customer database SQL server as and when required. The client application program need not know anything about Distributed Transaction Coordinator at all. Since SQL Server stored procedures do not take arrays as parameters, it is necessary to hold the multiple order lines temporarily on the Order Entry SQL Server before processing the order. The order lines are held in a table temporarily. Each order line record is passed to the Order Entry SQL server using a stored procedure, which in turn loads them into the holding table.</p>
<h4>Client application program</h4>
<pre><code>#define&nbsp;&nbsp;&nbsp; INITGUID

#define DBNTWIN32
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

#include &lt;SQL.h&gt;
#include &lt;SQLEXT.h&gt;
#include "odbcss.h"
#include &lt;ODBCINST.h&gt;

#include&nbsp;&nbsp;&nbsp; "OrderEntry.h"

void ProcessRC(LPTSTR pszFuncName, RETCODE rc, HDBC hDbc, HSTMT hStmt);
void DoSQLError(HDBC hDbc, HSTMT hStmt);

HENV&nbsp;&nbsp;&nbsp; hEnv = SQL_NULL_HENV;

main(int argc, char **argv)
{
 &nbsp;&nbsp; HDBC&nbsp;&nbsp;&nbsp; hDbc;

 &nbsp;&nbsp; ORDER_HEADER&nbsp;&nbsp;&nbsp; OrderHeader;
 &nbsp;&nbsp; ORDER_LINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderLine[100];
 &nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; NumberLines = 0;
 &nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; CustomerNumber;
 &nbsp;&nbsp; RETCODE rc = 0;

 &nbsp;&nbsp; rc =&nbsp; SQLAllocEnv(&amp;hEnv);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ProcessRC("SQLAllocEnv", rc, SQL_NULL_HDBC, SQL_NULL_HSTMT);

 &nbsp;&nbsp; rc = SQLAllocConnect(hEnv, &amp;hDbc);
 &nbsp;&nbsp; ProcessRC("SQLAllocConnect-1", rc, SQL_NULL_HDBC, SQL_NULL_HSTMT);

 &nbsp;&nbsp; // The client application program needs to open a connection 
 &nbsp;&nbsp; // only to to the Order Entry database server. This program 
 &nbsp;&nbsp; // does not even know that the order entry server updates 
 &nbsp;&nbsp; // the customer's credit limit on the customer database server

 &nbsp;&nbsp; rc = SQLConnect(hDbc, (unsigned char*)SQL_SERVER_1, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned char *)SQL_USER_ID,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned char *)SQL_PASSWORD,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );

 &nbsp;&nbsp; ProcessRC("SQLConnect-1",rc, hDbc, SQL_NULL_HSTMT);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; // Get the Order data records. This is the place to have the 
 &nbsp;&nbsp; // UI involved

 &nbsp;&nbsp; GetOrderRecords(&amp;CustomerNumber, &amp;OrderHeader, OrderLine, &amp;NumberLines);

 &nbsp;&nbsp; // Process the Order Entry transaction.
 &nbsp;&nbsp; InsertSaleOrder(hDbc, CustomerNumber, &amp;OrderHeader, OrderLine, NumberLines);

 &nbsp;&nbsp; // Close connections to the database and exit
 &nbsp;&nbsp; rc = SQLDisconnect(hDbc);
 &nbsp;&nbsp; rc = SQLFreeConnect(hDbc);
 &nbsp;&nbsp; rc = SQLFreeEnv(hEnv);

 &nbsp;&nbsp; return (0);
}

// Process an order entry transaction by running appropriate 
// stored procedures

void InsertSaleOrder(HDBC hDbc, long CustomerNumber, ORDER_HEADER *pOrderHeader, ORDER_LINE *pOrderLine, long NumberLines)
{
 &nbsp;&nbsp; RETCODE rc;
 &nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; cmdBuf[500];
 &nbsp;&nbsp; HSTMT&nbsp;&nbsp;&nbsp; hStmt;

 &nbsp;&nbsp; rc = SQLAllocStmt(hDbc, &amp;hStmt);
 &nbsp;&nbsp; ProcessRC("SQLAllocStmt", rc, hDbc, hStmt);

 &nbsp;&nbsp; // Insert the Order Lines into the work table in the database
 &nbsp;&nbsp; // Pass the line items to the database server using a 
 &nbsp;&nbsp; // stored procedure call.
 &nbsp;&nbsp; // Assemble the SQL command line to run the stored procedure 
 &nbsp;&nbsp; // and run it.

 &nbsp;&nbsp; for (long i = 0; i &lt;NumberLines ; i++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf (
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdBuf, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "execute InsertOrderLineWorkTable %ld, %ld, %ld, %ld\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;LineNumber,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;ProductNumber,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;Quantity,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine-&gt;UnitPrice
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) ;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = SQLExecDirect(hStmt, (UCHAR *)cmdBuf, SQL_NTS);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessRC("SQLExecDirect", rc, hDbc, hStmt);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rc == SQL_ERROR)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Error saving the Order Lines\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderLine++;
 &nbsp;&nbsp; }

 &nbsp;&nbsp; // Run a stored procedure to process the order. 
 &nbsp;&nbsp; // Assemble the command line and run it. 
 &nbsp;&nbsp; sprintf (
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdBuf,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "execute SaveOrder %ld, \'%s\', %ld, \'%s\',\'%s\',\'%s\',\'%s\'\n", 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderHeader-&gt;OrderNumber, pOrderHeader-&gt;OrderDate,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustomerNumber, pOrderHeader-&gt;ShipAddress1,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderHeader-&gt;ShipAddress2, pOrderHeader-&gt;ShipState,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOrderHeader-&gt;ShipZip) ;

 &nbsp;&nbsp; rc = SQLExecDirect(hStmt, (UCHAR *)cmdBuf, SQL_NTS);
 &nbsp;&nbsp; ProcessRC("SQLExecDirect", rc, hDbc, hStmt);
 &nbsp;&nbsp; if (rc == SQL_ERROR)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Error saving the Order Lines\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);
 &nbsp;&nbsp; }

 &nbsp;&nbsp; SQLFreeStmt(hStmt, SQL_DROP);
 &nbsp;&nbsp; 
 &nbsp;&nbsp; printf ("Transaction Committed");
}
</code></pre>
<h4>Server stored procedures</h4>
<pre><code>/*
* Procedure InsertOrderLineWorkTable inserts an Order Line Item 
* record into a work table for future use by the SaveOrder Procedure
*/

CREATE PROCEDURE InsertOrderLineWorkTable (
 &nbsp;&nbsp; @LineNumber int,
 &nbsp;&nbsp; @ProductNumber int,
 &nbsp;&nbsp; @Quantity int,
 &nbsp;&nbsp; @UnitPrice int
) AS

 &nbsp;&nbsp; insert into TempOrderLine 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SPID, LineNumber, ProductNumber, Quantity, UnitPrice)

values (@@SPID, @LineNumber, @ProductNumber, @Quantity, 
@UnitPrice)
GO

/*
*
* SaveOrder - Order Transaction Stored Procedure. Order Header elements * are passed as parameters while the line items are in the
* TempOrderLines Table identified by the Server process Id
*
*/

CREATE PROCEDURE&nbsp; SaveOrder 
(
 &nbsp;&nbsp; @OrderNumber int, 
 &nbsp;&nbsp; @OrderDate datetime,
 &nbsp;&nbsp; @CustomerNumber int,
 &nbsp;&nbsp; @ShipAddress1&nbsp;&nbsp;&nbsp; char(40),
 &nbsp;&nbsp; @ShipAddress2&nbsp;&nbsp;&nbsp; char(40),
 &nbsp;&nbsp; @ShipState&nbsp;&nbsp;&nbsp; char(2),
 &nbsp;&nbsp; @ShipZip&nbsp;&nbsp;&nbsp; char(10)
 &nbsp;&nbsp; ) AS

 &nbsp;&nbsp; declare&nbsp;&nbsp;&nbsp;&nbsp; @OrderTotal int
 &nbsp;&nbsp; declare&nbsp;&nbsp;&nbsp; @AvailCredit int
 &nbsp;&nbsp; declare&nbsp;&nbsp;&nbsp; @NewCredit int


/*
* BEGIN Distributed Transaction automatically initiates the 
* transaction using the distributed transaction coordinator
*/

 BEGIN DISTRIBUTED TRANSACTION 

 &nbsp;&nbsp; /* Compute the Order Total */

 &nbsp;&nbsp; select @OrderTotal = SUM(Quantity * UnitPrice) 
 &nbsp;&nbsp; from TempOrderLine 
 &nbsp;&nbsp; where
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPID = @@SPID

/*
* Reduce the available credit for this customer by running
* a remote stored procedure on the Customer Database SQL server.
* MOUNTROAD is the name of the Customer Database SQL Server.
* Ensure that the Updated Credit Limit is &gt; 0. Other transactions may 
* have reduced the credit limit while this order was being processed.
* Since we had begun a DISTRIBUTED TRANSACTION, this stored
* procedure call and the update performed by the stored procedure
* will be part of the same transaction using two phase commit
* protocol.
*/

 &nbsp;&nbsp; execute MOUNTROAD.TESTDB2.dbo.ReduceAvailableCredit
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @CustomerNumber, @OrderTotal, 
@NewCreditLimit = @NewCredit OUTPUT

 &nbsp;&nbsp; if (@@ERROR != 0)
 &nbsp;&nbsp; begin
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROLLBACK TRANSACTION 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RAISERROR 32752 "Error updating credit limt"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN
 &nbsp;&nbsp; end

 &nbsp;&nbsp; if (@NewCredit &lt;= 0)
 &nbsp;&nbsp; begin
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROLLBACK TRANSACTION 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RAISERROR 32750 "Not enough credit for the order"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN
 &nbsp;&nbsp; end

/*
* Insert the Order header and detail records
*/
 &nbsp;&nbsp; insert into OrderHeader
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (OrderNumber, OrderDate, CustomerNumber, ShipAddress1, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShipAddress2, ShipState, ShipZip)
 &nbsp;&nbsp; values( @OrderNumber, @OrderDate, @CustomerNumber, @ShipAddress1, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @ShipAddress2, @ShipState, @ShipZip)

 &nbsp;&nbsp; insert into OrderLine
 &nbsp;&nbsp; select&nbsp;&nbsp;&nbsp; @OrderNumber, LineNumber, ProductNumber, 
Quantity, UnitPrice
 &nbsp;&nbsp; from&nbsp;&nbsp;&nbsp;&nbsp; TempOrderLine
 &nbsp;&nbsp; where
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPID = @@SPID

 &nbsp;&nbsp; if (@@ROWCOUNT = 0)
 &nbsp;&nbsp; begin
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROLLBACK TRANSACTION
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RAISERROR 32751 "No Line Items for this Order"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN
 &nbsp;&nbsp; end

 &nbsp;&nbsp; delete from TempOrderLine where SPID = @@SPID

 &nbsp;&nbsp; COMMIT TRANSACTION

 &nbsp;&nbsp; RETURN
GO

/*
* Reduce the Available Credit for a given customer by a given amount
* and return the new credit limit
*/

CREATE PROCEDURE ReduceAvailableCredit (
 &nbsp;&nbsp; @CustomerNumber int,
 &nbsp;&nbsp; @ByAmount&nbsp;&nbsp;&nbsp; int,
 &nbsp;&nbsp; @NewCreditLimit&nbsp;&nbsp;&nbsp; int OUTPUT
) AS

 &nbsp;&nbsp; update Customer set AvailableCredit = AvailableCredit - @ByAmount
 &nbsp;&nbsp; where&nbsp;&nbsp;&nbsp; CustomerNumber = @CustomerNumber

 &nbsp;&nbsp; select @NewCreditLimit = AvailableCredit 
 &nbsp;&nbsp; from Customer
 &nbsp;&nbsp; where CustomerNumber = @CustomerNumber
GO
</code></pre>
<h3>Server Database Tables</h3>
<h4>Customer database</h4>
<pre><code>CREATE TABLE dbo.Customer (
 &nbsp;&nbsp; CustomerNumber int NOT NULL ,
 &nbsp;&nbsp; CustomerName char (100) NOT NULL ,
 &nbsp;&nbsp; CreditLimit money NOT NULL ,
 &nbsp;&nbsp; AvailableCredit money NOT NULL 
)
GO
</code></pre>
<h4>Order Database</h4>
<pre><code>CREATE TABLE dbo.OrderHeader (
 &nbsp;&nbsp; OrderNumber int NOT NULL ,
 &nbsp;&nbsp; OrderDate datetime NOT NULL ,
 &nbsp;&nbsp; CustomerNumber int NOT NULL ,
 &nbsp;&nbsp; ShipAddress1 char (40) NOT NULL ,
 &nbsp;&nbsp; ShipAddress2 char (40) NOT NULL ,
 &nbsp;&nbsp; ShipState char (2) NOT NULL ,
 &nbsp;&nbsp; ShipZip char (10) NOT NULL 
)
GO

CREATE TABLE dbo.OrderLine (
 &nbsp;&nbsp; OrderNumber int NOT NULL ,
 &nbsp;&nbsp; LineNumber int NOT NULL ,
 &nbsp;&nbsp; ProductNumber int NOT NULL ,
 &nbsp;&nbsp; Quantity int NOT NULL ,
 &nbsp;&nbsp; UnitPrice int NULL 
)
GO

CREATE TABLE dbo.TempOrderLine (
 &nbsp;&nbsp; SPID int NOT NULL ,
 &nbsp;&nbsp; LineNumber int NOT NULL ,
 &nbsp;&nbsp; ProductNumber int NOT NULL ,
 &nbsp;&nbsp; Quantity int NOT NULL ,
 &nbsp;&nbsp; UnitPrice int NULL 
)
GO
</code></pre>
<h2>References</h2>
<p>
Gray, Jim, and Andreas Reuter. <i>Transaction Processing.</i> San Francisco, California: Morgan Kaufmann Publishers, 1993.</p>
<p>
Microsoft Distributed Transaction Coordinator, version 0.1. Resource Manager Implementation Guide.</p>
</BODY>
</HTML>
