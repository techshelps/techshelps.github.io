<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE Controls: Understanding Events</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_events"></a></sup>OLE Controls: Understanding Events</h1>
<p>
Dale Rogerson<br>
Microsoft Developer Network Technology Group</p>
<p>
Created: October 5, 1994</p>
<h2>Abstract</h2>
<p>
This article explores the purpose and use of OLE Control events, using the Spindial application source code to illustrate concepts. Spindial is included in the OLE Control Developer's Kit (CDK), which is provided with Visual C++™ version 2.0. This article is intended for Microsoft® Foundation Class Library (MFC) programmers who may not have any knowledge of OLE beyond the MFC OLE classes.</p>
<h2>Introduction</h2>
<p>
When my colleague Ruediger Asche reviewed a draft copy of my article <a href="msdn_ocx1.htm">"OLE Controls: State of the Union"</a> for the July 1994 edition of the Microsoft® Developer Network (MSDN) Library, he jotted in the margin: "What's an event? Define it." To answer his question, I dug through the vast amount of information in the MSDN Library looking for the definition of an event. Here's a sampling of what I found:</p>
<p>
In "OLE Comes to Custom Controls" (<i>Microsoft Developer Network News</i>, May 1994, Number 3, May Features):</p>
<p class=indent>
<i>"[Events are] actions triggered by the control in response to some external actions on the control, such as clicking a mouse button or pressing a key. . . . To work properly with controls, the container also implements an IDispatch interface for managing a control's events . . . ."</i></p>
<p class=indent>
Solveig Whittle </p>
<p>
In "OLE Custom Controls Backgrounder" (MSDN Library Archive, Backgrounders and White Papers, Operating System Extensions):</p>
<p class=indent>
<i>"The OLE custom control architecture also adds support for events, a standard way for the control to invoke a call back in its container."</i></p>
<p>
In "Developing OLE Custom Controls" (MSDN Library Archive, Conferences and Seminars, Tech*Ed, March 1994, Visual C++):</p>
<p class=indent>
<i>"Each control defines its own events that it will trigger when things happen to the control; each event is a function with parameters. When the control wants to fire an event, it invokes this IDispatch::Invoke with its own dispatch ID and appropriate parameters. By default, the container will do nothing with these events unless it has been specifically programmed with knowledge of those events and has something to do with them. . . .</i></p>
<p class=indent>
<i>. . . Note that control events, while defined by the control and described in its type library, are handled through the events IDispatch in the container. The control itself does not implement any events in its own IDispatch interface."</i></p>
<p class=indent>
Scott Randell</p>
<p>
As you can see, one of the definitions (see first quotation above) is so vague as to be useless, while another (see third quotation above) seems to require a doctoral degree in OLE. In the <a href="msdn_ocx1.htm">"OLE Controls: State of the Union"</a> article, I took the easy road—I pretended that the reader was familiar with OLE Control events. Well, the question has been haunting me. Just before I fall asleep at night, I hear this strange disembodied voice (Ruediger's) repeating over and over: "What is an OLE Control event?" </p>
<p>
The product of my insomnia is this article you are now reading. In this article, we will together explore OLE Control events. We will start with the Microsoft Foundation Class Library (MFC) code generated by ControlWizard and ClassWizard and head towards the depths of the native OLE code found in the MFC OLE Control classes. In the process, you will learn about MFC, OLE Controls, and OLE. You will also understand Scott Randell's words on the <b>IDispatch</b> interface in the quotation above.</p>
<p>
In our quest, we will look at:
<ul type=disc>
<li>
Event maps<br><br></li>
<li>
The <b>COleControl::FireEvent</b> function<br><br></li>
<li>
The type library</li>
</ul>
<p>
I will be using Spindial, a sample application included with the OLE Control Developer's Kit (CDK), which is provided in Visual C++™ version 2.0, to illustrate an OLE Control event. Spindial is a simple OLE Control. It looks like an ellipse with four tick marks (Figure 1).</p>
<p>
<img src="events_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Spindial control as it appears in the Test Container</b></p>
<p>
Clicking the Spindial control sends a <b>SpinPositive</b> event to the control and moves the line 90 degrees clockwise (Figure 2).</p>
<p>
<img src="events_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Spindial control after single click</b></p>
<p>
As you can see, the control doesn't do much, but it illustrates the concepts I'll be discussing in this article.</p>
<h2>Event Maps</h2>
<p>
Our journey starts with the CDK sample application Spindial. Like all OLE Controls created by ControlWizard, Spindial has an event map. An event map is to OLE Control events what a message map is to messages. The event map and message map from SPINDIAL.H are shown below. You can see how similar the two types of maps are.</p>
<pre><code>// Message maps
 &nbsp; //{{AFX_MSG(CSpindialCtrl)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
 &nbsp; //}}AFX_MSG
 &nbsp; DECLARE_MESSAGE_MAP()

// Event maps
 &nbsp; //{{AFX_EVENT(CSpindialCtrl)
 &nbsp; void FireSpinPositive()
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {FireEvent(eventidSpinPositive,EVENT_PARAM(VTS_NONE));}
 &nbsp; //}}AFX_EVENT
 &nbsp; DECLARE_EVENT_MAP()
</code></pre>
<p>
The event map above defines and implements the <b>FireSpinPositive</b> function. To fire a <b>SpinPositive</b> event from our control, we would call <b>FireSpinPositive</b>. ClassWizard wraps <b>FireEvent </b>to implement <b>FireSpinPositive</b>. It is important to note the difference between the event map and the message map: The message map defines functions that respond to messages; the event map defines functions that generate events.</p>
<p>
<b>FireEvent </b>takes an event ID and a list of parameters. The <b>SpinPositive</b> event does not have any associated parameters. Its ID is defined below.</p>
<pre><code>// Dispatch and event IDs
public:
 &nbsp; enum {
 &nbsp; //{{AFX_DISP_ID(CSpindialCtrl)
 &nbsp; dispidNeedlePosition = 1L,
 &nbsp; eventidSpinPositive = 1L,
 &nbsp; //}}AFX_DISP_ID
 &nbsp; };
</code></pre>
<p>
We will come back and look at the implementation of <b>COleControl::FireEvent</b> and event IDs later. First, let's finish with the event map. DECLARE_EVENT_MAP is next on our journey. It adds the following code to the class:</p>
<pre><code>&nbsp;private: 
 &nbsp; static AFX_DATA AFX_EVENTMAP_ENTRY BASED_CODE _eventEntries[];
protected: 
 &nbsp; static AFX_DATA AFX_EVENTMAP BASED_CODE eventMap; 
 &nbsp; virtual AFX_EVENTMAP FAR* GetEventMap() const;
</code></pre>
<p>
This is nothing new. It is the same as DECLARE_MESSAGE_MAP except that the names have been changed to protect the innocent. The macros declare an array of event map entries (<b>_eventEntries</b>), a variable to hold a pointer to the event maps of the current class and the base class (<b>eventMap</b>), and a function to get a pointer to an event map (<b>GetEventMap</b>). The DECLARE_MESSAGE_MAP macro is expanded below to provide a comparison.</p>
<pre><code>private: 
 &nbsp; static AFX_MSGMAP_ENTRY BASED_CODE _messageEntries[];
protected: 
 &nbsp; static AFX_MSGMAP AFXAPP_DATA messageMap; 
 &nbsp; virtual AFX_MSGMAP* GetMessageMap() const;
</code></pre>
<p>
The variables and functions declared by DECLARE_EVENT_MAP and DECLARE_MESSAGE_MAP are implemented in the SPINCTL.CPP file. This code is listed below.</p>
<pre><code>BEGIN_EVENT_MAP(CSpindialCtrl, COleControl)
 &nbsp; //{{AFX_EVENT_MAP(CSpindialCtrl)
 &nbsp; EVENT_CUSTOM("SpinPositive", FireSpinPositive, VTS_NONE)
 &nbsp; //}}AFX_EVENT_MAP
END_EVENT_MAP()
</code></pre>
<p>
The macros above can be expanded as follows:</p>
<pre><code>AFX_EVENTMAP FAR* CSpindialCtl::GetEventMap() const 
{ 
 &nbsp; return &amp;eventMap; 
} 

AFX_DATADEF AFX_EVENTMAP BASED_CODE CSpindialCtl::eventMap = 
{ 
 &nbsp; &amp;(COleControl::eventMap), 
 &nbsp; CSpindialCtl::_eventEntries 
}; 

AFX_DATADEF AFX_EVENTMAP_ENTRY BASED_CODE CSpindialCtl::_eventEntries[] = 
{
 &nbsp; { afxEventCustom, DISPID_UNKNOWN, _T("SpinPositive"), VTS_NONE},
 &nbsp; { afxEventCustom, DISPID_UNKNOWN, NULL, NULL }, 
 };
</code></pre>
<p>
The VTS_NONE parameter means that the <b>SpinPositive </b>event does not take any parameters.</p>
<p>
Thus, we have a function (<b>GetEventMap</b>) that gets a pointer to the event map, a variable (<b>eventMap)</b> that has a pointer to the event maps of the current class and the base class, and an array of event entries (<b>_eventEntries</b>) that contain the name and parameter list for a custom event. <b>FireSpinPositive</b> is not included in the <b>_eventEntries</b> array; it is included as a parameter for EVENT_CUSTOM for documentation purposes. The system does not need to keep track of how an event is fired—it only needs to track the events that make up the event set.</p>
<p>
Grepping (that means "searching," for those without a UNIX® background) the code reveals that the <b>_eventEntries</b> array is used only for initializing stock events. The code currently steps over events with DISPID_UNKNOWN. Another interesting anomaly is that we know the event ID for SpinPositive: <b>eventidSpinPositive</b>, although we use DISPID_UNKNOWN.</p>
<p>
Now, that didn't get us very far, so it's time to go back and look at <b>COleControl::FireEvent</b>.</p>
<h2>The COleControl::FireEvent Function</h2>
<p>
In SPINDIAL.H, Spindial declares its event map. The firing function, <b>FireSpinPositive</b>, is defined in the event map:</p>
<pre><code>void FireSpinPositive()
{
 &nbsp; FireEvent(eventidSpinPositive,EVENT_PARAM(VTS_NONE));
}
</code></pre>
<p>
Again, our control calls <b>FireSpinPositive</b> whenever it wants to send an event to its container. The Spindial control translates mouse button click events into <b>SpinPositive</b> events by calling <b>FireSpinPositive</b> after a mouse button click.</p>
<p>
The first parameter to <b>FireEvent</b> is a DISPID. What's a DISPID? Like Ruediger's simple question that prompted this article, this question isn't all that simple. If you search the MSDN Library for "DISPID", you won't find a simple, straightforward definition. A DISPID is a 32-bit identifier (sometimes called a "magic cookie") that describes a method or property in a dispatch interface. For a particular dispatch interface, each method or property has a unique DISPID. Different dispatch interfaces may have methods or properties with the same DISPID. In other words, a DISPID is not universally unique; it is unique only within its own dispatch interface. If you are familiar with dynamic-link libraries (DLLs), a DISPID is similar to an ordinal for an exported function. </p>
<p>
In the SpinControl, the DISPID for <b>eventidSpinPositive</b> was generated for us by MFC and happens to be one (1). See MFC Technical Note 39, "MFC/OLE Automation Implementation" (MSDN Library Archive, Technical Articles, Visual C++ 1.5 [16-bit] Articles, MFC 2.5 Technical Notes) for more information on DISPIDs and how MFC assigns a DISPID to a method or property.</p>
<h3>Dispatch Interface</h3>
<p>
What's a dispatch interface? (See how one question leads to another?) OLE Automation defines a process by which one application, the automation server, can expose an interface to another application, the automation client. The automation client can control the automation server programmatically through an interface, which is called the <i>dispatch interface</i>.</p>
<p>
Properties and methods exposed by OLE Controls are implemented using dispatch interfaces. In MFC, dispatch interfaces are implemented through dispatch maps. The following is Spindial's declaration of a dispatch map:</p>
<pre><code>// Dispatch maps
 &nbsp; //{{AFX_DISPATCH(CSpindialCtrl)
 &nbsp; afx_msg short GetNeedlePosition();
 &nbsp; afx_msg void SetNeedlePosition(short nNewValue);
 &nbsp; //}}AFX_DISPATCH
 &nbsp; DECLARE_DISPATCH_MAP()
</code></pre>
<p>
Spindial exposes the <b>NeedlePosition </b>property. It implements <b>NeedlePosition</b> using <b>get</b> and <b>set</b> methods so it can track changes to this property and act accordingly.</p>
<p>
Spindial implements the dispatch map as follows:</p>
<pre><code>BEGIN_DISPATCH_MAP(CSpindialCtrl, COleControl)
 &nbsp; //{{AFX_DISPATCH_MAP(CSpindialCtrl)
 &nbsp; DISP_PROPERTY_EX(CSpindialCtrl, "NeedlePosition", 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetNeedlePosition, SetNeedlePosition, VT_I2)
 &nbsp; DISP_DEFVALUE(CSpindialCtrl, "NeedlePosition")
 &nbsp; //}}AFX_DISPATCH_MAP
 &nbsp; DISP_FUNCTION_ID(CSpindialCtrl, "AboutBox", 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()
</code></pre>
<p>
For efficiency, OLE Automation uses the 32-bit DISPID instead of the string name to reference properties and methods in a dispatch interface. The careful reader will notice that the DISPID is not listed in the dispatch map. To see where the DISPID is paired with a dispatch method or property, we need to look at the type library, which we'll discuss later. Now that we know what a DISPID is, let's examine the code for <b>FireEvent</b>.</p>
<h3>Back to FireEvent</h3>
<p>
The CTLEVENT.CPP file contains the code for <b>COleControl::FireEvent</b>. (When you install the OLE Control Developer's Kit, you'll find this file in the \CDK16\SRC or \CDK32\SRC directory.) I will not trace this code in detail in this article. Basically, <b>FireEvent </b>gets a pointer to the dispatch interface in the control container and executes <b>IDispatch::Invoke</b> on the DISPID passed in its first parameter. Now we're getting somewhere!</p>
<p>
"Wait a minute," I hear MFC programmers who are unfamiliar with OLE saying, "What is <b>IDispatch::Invoke</b>?" In OLE, an interface is prefixed by the letter "l", so <b>IDispatch</b> is the OLE interface for manipulating dispatch interfaces. </p>
<p>
You can think of an OLE interface as a C++ class. (Actually, there are differences between the way OLE interfaces and C++ classes operate, but this analogy will do for now. See <i>Inside OLE 2</i> by Kraig Brockschmidt [MSDN Library, Books] for more information.) So, <b>IDispatch::Invoke</b> is a function that executes a method exposed in an OLE dispatch interface.</p>
<p>
Therefore, <b>FireSpinPositive</b> executes the <b>SpinPositive </b>dispatch method in the control container by calling <b>IDispatch::Invoke </b>with the DISPID <b>eventidSpinPositive</b>. </p>
<p>
The upshot of all of this is that the OLE Control <i>defines </i>a dispatch interface (<b>dispinterface</b>) as its events list. The OLE Control container then <i>implements </i>this dispatch interface. You can think of an event as an outgoing dispatch method. By defining a dispatch interface, the control says, "Here are some methods you can call to control me." By defining an event list, the control tells the container, "Here are some methods I can call to tell you what is happening to me." Figure 3 illustrates this concept: The control defines an event. The container implements an event handler. The control fires the event.</p>
<p>
<img src="events_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Firing an OLE control event</b></p>
<p>
Note how this process differs from OLE Automation, where the automation methods are defined and implemented by the automation server and called by the automation client. As far as events are concerned, an OLE Control is like an automation client that defines the interface to the automation server.</p>
<p>
Scott Randell's words should now make a little more sense.</p>
<h2>The Type Library</h2>
<p>
In addition to adding, changing, and modifying the message maps, ControlWizard and ClassWizard also maintain the .ODL file, which contains an object description language script. The MkTypLib tool provided in Visual C++ compiles an .ODL script into a type library. The type library for an OLE Control contains descriptions of the dispatch interfaces supported by the control, including the event dispatch interface. The type library is manipulated by the <b>ITypeLib</b> interface.</p>
<p>
The .ODL file for the Spindial control is shown below. You can see the dispatch interface <b>_DSpindial</b> and the event dispatch interface <b>_DSpindialEvents</b>. The DISPID for these events is assigned by ClassWizard. The <b>NeedlePosition</b> property has a DISPID of 1, which is generated by the ODL script <b>[id(1)]</b>. </p>
<pre><code>#include &lt;olectl.h&gt;

[ uuid(06889608-B8D0-101A-91F1-00608CEAD5B3), version(1.0),
  helpstring("Spindial OLE Custom Control module") ]
library SpindialLib
{
 &nbsp; importlib(STDOLE_TLB);
 &nbsp; importlib(STDTYPE_TLB);

 &nbsp; //&nbsp; Primary dispatch interface for CSpindialCtrl

 &nbsp; [ uuid(37446B89-5870-101B-B57B-00608CC96AFA),
 &nbsp;&nbsp;&nbsp; helpstring("Dispatch interface for Spindial Control") ]
 &nbsp; dispinterface <b>_DSpindial</b>
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; properties:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // NOTE - ClassWizard will maintain property information here.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; Use extreme caution when editing this section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //{{AFX_ODL_PROP(CSpindialCtrl)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [id(1)] short NeedlePosition;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}}AFX_ODL_PROP

 &nbsp;&nbsp;&nbsp;&nbsp; methods:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // NOTE - ClassWizard will maintain method information here.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; Use extreme caution when editing this section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //{{AFX_ODL_METHOD(CSpindialCtrl)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}}AFX_ODL_METHOD

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [id(DISPID_ABOUTBOX)] void AboutBox();
 &nbsp; };

 &nbsp; //&nbsp; Event dispatch interface for CSpindialCtrl

 &nbsp; [ uuid(37446B8A-5870-101B-B57B-00608CC96AFA),
 &nbsp;&nbsp;&nbsp; helpstring("Event interface for Spindial Control") ]
 &nbsp; dispinterface <b>_DSpindialEvents</b>
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; properties:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Event interface has no properties.

 &nbsp;&nbsp;&nbsp;&nbsp; methods:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // NOTE - ClassWizard will maintain event information here.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; Use extreme caution when editing this section.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //{{AFX_ODL_EVENT(CSpindialCtrl)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [id(1)] void SpinPositive();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}}AFX_ODL_EVENT
 &nbsp; };

 &nbsp; //&nbsp; Class information for CSpindialCtrl

 &nbsp; [ uuid(06889605-B8D0-101A-91F1-00608CEAD5B3),
 &nbsp;&nbsp;&nbsp; helpstring("Spindial Control") ]
 &nbsp; coclass Spindial
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; [default] dispinterface _DSpindial;
 &nbsp;&nbsp;&nbsp;&nbsp; [default, <b>source</b>] dispinterface _DSpindialEvents;
 &nbsp; };

 &nbsp; //{{AFX_APPEND_ODL}}
};
</code></pre>
<p>
A type library contains information not only about interfaces, but also about a class. The interfaces supported by the Spindial class are listed at the end of Spindial's .ODL file. An event dispatch interface is differentiated from a normal dispatch interface by the <b>source</b> attribute, which indicates that the control is a source for these events. To handle these events, a container would define the events dispatch interface without the <b>source</b> attribute.</p>
<h2>Conclusion</h2>
<p>
Now that we've explored OLE Control events in detail, it's time to bite the bullet and give you a definition of an OLE Control event:</p>
<p class=indent>
An OLE Control event is a method that is defined in a source dispatch interface in an OLE Control and implemented in a dispatch interface in the OLE Control container. The OLE Control fires events that are handled by the OLE Control container.</p>
<h2>Bibliography</h2>
<p>
Brockschmidt, Kraig. <i>Inside OLE 2</i>. (MSDN Library, Books)</p>
<p>
Brockschmidt, Kraig. <a href="msdn_contcntr.htm">"Notes on Implementing an OLE Control Container"</a>. January 1995.</p>
<p>
Microsoft Foundation Class Library Technical Notes. "Technical Note 39: "MFC/OLE Automation Implementation." (MSDN Library Archive, Technical Articles, Visual C++ 1.5 Articles, MFC 2.5 Technical Notes)</p>
<p>
Microsoft OLE Control Developer's Kit (CDK). <i>User's Guide and Reference</i>. (MSDN Library Archive, Product Documentation, Languages)</p>
<p>
Microsoft Visual C++ version 1.5 <i>OLE 2 Classes. Tutorial</i>. Chapter 6, "Autoclik: Creating an Automation Server." (MSDN Library Archive, Product Documentation, Languages)</p>
<p>
<i>OLE 2.0 Programmer's Reference</i>. Vol. 2, Overview of OLE Automation.</p>
</BODY>
</HTML>
