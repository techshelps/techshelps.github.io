<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQL Language Support</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>SQL Language Support</h1>
<p>
This section outlines the similarities and differences between Transact-SQL and PL/SQL language syntax and discusses conversion strategies.</p>
<h3>Recommended Conversion Strategy</h3>
<p>
You should use the following checklist when migrating your Oracle DML statements and PL/SQL programs:
<ol>
<li>
Verify that the syntax for of all SELECT, INSERT, UPDATE, and DELETE statements is valid. Make any modifications that are required.<br><br></li>
<li>
Change all outer joins to ANSI standard outer join syntax.<br><br></li>
<li>
Replace Oracle functions with the appropriate SQL Server functions.<br><br></li>
<li>
Check all comparison operators. <br><br></li>
<li>
Replace the "||" string concatenation operators with the "+" string concatenation operators.<br><br></li>
<li>
Replace PL/SQL programs with Transact-SQL programs.<br><br></li>
<li>
Change all PL/SQL cursors to either noncursor SELECT statements or Transact-SQL cursors.<br><br></li>
<li>
Replace PL/SQL procedures, functions, and packages with Transact-SQL procedures.<br><br></li>
<li>
Convert PL/SQL triggers to Transact-SQL triggers.<br><br></li>
<li>
Use the SET SHOWPLAN statement to performance tune your queries.</li>
</ol>
<h3>INSERT Statements</h3>
<p>
INSERT statements require minimal revision because Oracle's syntax is similar to SQL Server's.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>INSERT INTO<br>
{<i>table_name</i> | <i>view_name</i> | <b><i>select_statement</i></b>} [(<i>column_list</i>)]<br>
{<b><i>values_list</i></b> | <i>select_statement</i>}</td>
<td width=51%>INSERT INTO<br>
{<i>table_name</i> | <i>view_name</i>}<br>
[(<i>column_list</i>)]<br>
{<i>values_list</i> | <i>select_statement</i> | <br>
<b><i>DEFAULT VALUES</i></b> | <br>
<b><i>default</i></b> | <b><i>EXECute</i></b>{ <b><i>procedure_name</i></b>}</td>
</tr>
</table><br>
<p>
The Transact-SQL language supports inserts into tables and views, but does not support INSERT operations into SELECT&nbsp;&nbsp;&nbsp;&nbsp; statements. If your Oracle application code performs inserts into SELECT statements, this must be changed.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Oracle</b></td>
<td class=label width=50%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=50%>INSERT INTO<b> (SELECT SSN, CCODE, GRADE&nbsp;&nbsp;&nbsp;&nbsp;</b>  <b>FROM GRADE)</b><br>
VALUES ('111111111', '1111',NULL)</td>
<td width=50%>INSERT INTO <b>GRADE (SSN, CCODE, GRADE)</b><br>
VALUES ('111111111', '1111',NULL)</td>
</tr>
</table><br>
<p>
Because Transact-SQL supports inserts into views, you can also create a view based on the SELECT statement.</p>
<p>
The Transact-SQL <i>values_list</i> parameter offers the keyword DEFAULT, which is not available with Oracle. This keyword specifies that the default value for the column be used when an insert is performed. If a default value does not exist for the specified column, a NULL is inserted. If the column does not allow nulls, an error message is returned. If the column is defined as a <b>timestamp</b> data type, the next sequential value is inserted.</p>
<p>
The DEFAULT keyword cannot be used with an identity column. In order to generate the next sequential number, columns with the IDENTITY property must not be listed in the <i>column_list</i> or <i>values_clause</i>. You do not need to use the DEFAULT keyword to obtain the default value for a column. Just as in Oracle, if the column is not referenced in the <i>column_list</i> and it has a default value, the default value is placed into the column. This is the most compatible approach to use when performing the migration.</p>
<p>
One interesting Transact-SQL option (EXECute <i>procedure_name</i>) is the capability to execute a procedure and effectively pipe its output into a target table or view. Oracle does not allow you to do this.</p>
<h3>UPDATE Statements</h3>
<p>
Because Transact-SQL supports most of the syntax used with the Oracle UPDATE statement, minimum revision is required.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>UPDATE<br>
{<i>table_name</i> | <i>view_name</i> | <b><i>select_statement</i></b>}<br>
SET [<i>column_name(s)</i> = {<i>constant_value</i> | <i>expression</i> | <i>select_statement</i> | <i>column_list</i> |<br>
<b><i>variable_list</i></b>]<br>
{<i>where_statement</i>}</td>
<td width=51%>UPDATE<br>
{<i>table_name</i> | <i>view_name</i>}<br>
SET [<i>column_name(s)</i> = {<i>constant_value</i> | <i>expression</i> | <i>select_statement</i> | <i>column_list</i> |<br>
<b><i>default</i> | <i>variable_list</i>]<br>
[FROM <br>
{<i>table_name</i> | <i>view_name</i>}[(<i>optimizer_hints</i>)}]</b><br>
[<i>where_statement</i>}</td>
</tr>
</table><br>
<p>
The Transact-SQL UPDATE statement does not support update operations against SELECT statements. If your Oracle application code performs updates against SELECT statements, you can turn the SELECT statement into a view, and then use the view name in the SQL Server UPDATE statement. See the example shown previously in the "INSERT Statements" section.</p>
<p>
The Oracle UPDATE statement can only use program variables from within a PL/SQL block. The Transact-SQL language does not require the use of blocks to use variables.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>DECLARE<br>
<b>VAR1 NUMBER(10,2);<br>
BEGIN<br>
&nbsp;&nbsp;&nbsp;&nbsp;VAR1 := 2500;<br>
</b>&nbsp;&nbsp;&nbsp;&nbsp;UPDATE STUDENT_ADMIN.STUDENT<br>
&nbsp;&nbsp;&nbsp;&nbsp;SET TUITION_TOTAL = <b>VAR1;</b><br>
<b>END;</b></td>
<td width=51%>DECLARE<br>
@<b>VAR1 NUMERIC(10,2)<br>
SELECT @VAR1 = 2500</b><br>
UPDATE STUDENT_ADMIN.STUDENT<br>
SET TUITION_TOTAL=<b>@VAR1</b></td>
</tr>
</table><br>
<p>
The keyword DEFAULT can be used to set a column to its default value. You cannot set a column to a default value with the Oracle UPDATE statement.</p>
<p>
Transact-SQL and Oracle SQL support the use of subqueries in an UPDATE statement.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>UPDATE STUDENT_ADMIN.STUDENT S<br>
SET TUITION_TOTAL = 1500<br>
WHERE SSN IN (SELECT SSN <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM GRADE G<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE G.SSN = S.SSN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND G.CCODE = '1234')</td>
<td width=51%>UPDATE STUDENT_ADMIN.STUDENT S<br>
SET TUITION_TOTAL = 1500<br>
WHERE SSN IN (SELECT SSN <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM GRADE G<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE G.SSN = S.SSN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND G.CCODE = '1234')</td>
</tr>
</table><br>
<p>
The Transact-SQL FROM clause can be used to turn an UPDATE based on a subquery into an UPDATE based on a join. This capability makes your UPDATE syntax more readable and in some cases can improve performance:</p>
<pre><code>UPDATE STUDENT_ADMIN.STUDENT S
SET TUITION_TOTAL = 1500
FROM GRADE G
WHERE S.SSN = G.SSN
 &nbsp; AND G.CCODE = '1234'
</code></pre>
<h3>DELETE Statements</h3>
<p>
In most cases, you do not need to modify DELETE statements. If you perform deletes against SELECT statements, the syntax must be modified because it is not supported by Transact-SQL.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=49%><b>Oracle</b></td>
<td class=label width=51%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=49%>DELETE [FROM]<br>
{<i>table_name</i> | <i>view_name</i> | <b><i>select_statement</i></b>}<br>
[WHERE clause] </td>
<td width=51%>DELETE [FROM]<br>
{<i>table_name</i> | <i>view_name</i>}<br>
<b>[FROM<br>
{<i>table_name</i> | <i>view_name</i>}[(<i>optimizer_hints</i>)}]</b><br>
[WHERE clause]</td>
</tr>
</table><br>
<p>
Transact-SQL supports the use of subqueries when performing deletes. However, using the FROM clause can produce more efficient statements. See the example shown previously in the "UPDATE Statements" section.</p>
<h3>TRUNCATE TABLE Statement</h3>
<p>
The TRUNCATE TABLE statement is quite similar between Oracle and SQL Server. It is used to remove all of the rows from a table. The table structure and all of its indexes will continue to exist. It cannot be rolled back. Delete triggers will not be executed. If a table is referenced by a FOREIGN KEY constraint, it cannot be truncated. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=56%><b>Oracle</b></td>
<td class=label width=44%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=56%>TRUNCATE TABLE <i>table_name</i><br>
<b>[{DROP | REUSE} STORAGE]</b></td>
<td width=44%>TRUNCATE TABLE <i>table_name</i></td>
</tr>
</table><br>
<p>
In SQL Server, this statement can only be issued by the table owner. In Oracle, this command can be issued if you are the table owner or have the DELETE TABLE system privilege.</p>
<p>
The Oracle TRUNCATE TABLE command can be directed to release or keep the storage space occupied by the rows in the table. The SQL Server TRUNCATE TABLE statement always reclaims space occupied by the table data and its associated indexes.</p>
<h3>Manipulating Data in Identity and timestamp Columns</h3>
<p>
Oracle sequences are not directly related to any given table. Therefore, Oracle does not enforce any rules when working with sequences. However, SQL Server is quite strict when using identity columns: the DEFAULT keyword cannot be used when working with identity columns. Additionally, values in identity columns cannot be updated.</p>
<p>
By default, data cannot be inserted directly into an identity column. The identity column automatically generates a unique, sequential number for each new row inserted in the table. This default can be overridden using the following SET statement:</p>
<pre><code>SET IDENTITY_INSERT table_name ON
</code></pre>
<p>
With IDENTITY_INSERT set to ON, the user is allowed to insert any value into a new row with an identity column. To prevent the entry of duplicate numbers, a unique index must be created against the column. The purpose of this statement is to allow a user to re-create a value for a row that has been accidentally deleted. The <b>@@IDENTITY</b> global variable can be used to obtain the last identity value.</p>
<p>
The TRUNCATE TABLE statement resets an identity column to its original SEED value. This can affect any type of synchronization that exists with Oracle tables using sequences, because sequences are not reset following the TRUNCATE TABLE command.</p>
<p>
If you do not want to reset the identity value for a column, use the DELETE statement without a WHERE clause instead of the TRUNCATE TABLE statement.</p>
<p>
You can perform only inserts or deletes when working with <b>timestamp</b> columns. If you attempt to update a <b>timestamp</b> column, you receive the following error message:</p>
<pre><code>Msg 272, Level 16, State 1 Can't update a TIMESTAMP column.
</code></pre>
<h3>text and image Columns</h3>
<p>
When you migrate to SQL Server, you use <b>text</b> and <b>image</b> columns in place of LONG and LONG RAW columns. In Oracle, UPDATE and INSERT statements are used to change values in LONG and LONG RAW columns. In SQL Server, you can use standard UPDATE and INSERT statements, or you can use the UPDATETEXT and WRITETEXT statements. Both UPDATETEXT and WRITETEXT allow a nonlogged option, and UPDATETEXT allows for partial updating of a <b>text</b> or <b>image</b> column.</p>
<p>
The UPDATETEXT statement can be used to replace existing data, delete existing data, or insert new data. Newly inserted data can be a constant value, table name, column name, or text pointer.</p>
<p>
The WRITETEXT statement completely overwrites any existing data in the column it affects. Use WRITETEXT to replace text data and UPDATETEXT to modify text data. The UPDATETEXT statement is more flexible because it changes only a portion of a text of image value rather than the entire value.</p>
<p>
For more information, see the <i>Microsoft SQL Server Transact-SQL</i> <i>Reference</i>.</p>
<h3>SELECT Statements</h3>
<p>
The SELECT statement syntax is quite similar in each DBMS. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=47%><b>Oracle</b></td>
<td class=label width=53%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=47%>SELECT<b> [/*+ optimizer_hints*/]</b> <br>
 [ALL | DISTINCT] <i>select_list</i><br>
 [FROM<br>
{<i>table_name</i> | <i>view_name</i> | <i>select_statement</i>}]<br>
[WHERE clause] <br>
[GROUP BY clause]<br>
[HAVING clause]<br>
<b>[START WITH … CONNECT BY]</b><br>
[{UNION | UNION ALL<b> | INTERSECT |</b><br>
 &nbsp; <b>MINUS</b>} SELECT …]<br>
[ORDER BY clause]<br>
<b>[FOR UPDATE]</b></td>
<td width=53%>SELECT<br>
[ALL | DISTINCT] <i>select_list</i> <br>
<b>[INTO [<i>new_table_name</i>]]</b> <br>
[FROM<br>
{<i>table_name</i> | <i>view_name</i> | <i>select_statement</i>}<br>
<b>[JOIN {<i>table_name</i> | <i>view_name</i> | <i>select_statement</i>}&nbsp;&nbsp;&nbsp;&nbsp; ON <i>search_conditions</i>]<br>
[(<i>optimizer_hints</i>)]</b> <br>
 [WHERE clause] <br>
[GROUP BY clause]<br>
[HAVING clause]<br>
[{UNION | UNION ALL} SELECT …]<br>
[ORDER BY clause]<br>
<b>[COMPUTE clause] [FOR BROWSE]</b></td>
</tr>
</table><br>
<p>
Oracle-specific cost-based optimizer hints are not supported by SQL Server. They must be removed from your statement code. For more information, see "Tuning SQL Statements" later in this paper. However, the recommended technique is to assume that the default SQL Server cost-based optimization will work fine, because it usually does.</p>
<p>
SQL Server does not support the Oracle START WITH…CONNECT BY clause. If your application currently takes advantage of this hierarchical reporting capability, those statements that include this clause must be rewritten. You could potentially replace this in SQL Server with a user-written procedure that performs the same task.</p>
<p>
The INTERSECT and MINUS set operators are not supported by SQL Server. However, the EXISTS and NOT EXISTS clauses can be used to accomplish the same result.</p>
<p>
The following example uses the INTERSECT operator to find the course code and course name for all classes that have students. Notice how the EXISTS operator replaces the use of the INTERSECT operator. The data that is returned is identical, regardless of query. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=46%><b>Oracle</b></td>
<td class=label width=54%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=46%>SELECT CCODE, CNAME<br>
FROM DEPT_ADMIN.CLASS<br>
<b>INTERSECT<br>
SELECT C.CCODE, C.CNAME<br>
FROM STUDENT_ADMIN.GRADE G,<br>
DEPT_ADMIN.CLASS C<br>
WHERE C.CCODE = G.CCODE</b></td>
<td width=54%>SELECT CCODE, CNAME<br>
FROM DEPT_ADMIN.CLASS <b>C</b><br>
<b>WHERE EXISTS<br>
(SELECT 'X' FROM STUDENT_ADMIN.GRADE&nbsp;&nbsp;&nbsp;&nbsp;</b> <b>G<br>
WHERE C.CCODE = G.CCODE)</b></td>
</tr>
</table><br>
<p>
This example uses the MINUS operator to find those classes that do not have any students. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=46%><b>Oracle</b></td>
<td class=label width=54%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=46%>SELECT CCODE, CNAME<br>
FROM DEPT_ADMIN.CLASS<br>
<b>MINUS<br>
SELECT C.CCODE, C.CNAME<br>
FROM STUDENT_ADMIN.GRADE G,<br>
DEPT_ADMIN.CLASS C<br>
WHERE C.CCODE = G.CCODE</b></td>
<td width=54%>SELECT CCODE, CNAME<br>
FROM DEPT_ADMIN.CLASS<b>C</b><br>
<b>WHERE</b> <b>NOT EXISTS<br>
(SELECT 'X' FROM STUDENT_ADMIN.GRADE <br>
</b>&nbsp;&nbsp;&nbsp;&nbsp;<b>G<br>
WHERE C.CCODE = G.CCODE)</b></td>
</tr>
</table><br>
<h3>Locking Requested Rows</h3>
<p>
Oracle uses the FOR UPDATE clause to lock rowsspecified in the SELECT statement. Usually you don't need to use the equivalent clause in SQL Server. Don't confuse the FOR BROWSE and the FOR UPDATE clause. The FOR BROWSE clause is a specialized facility for use in client application programs that need additional metadata at run time. </p>
<h3>Row Aggregates and the Compute Clause</h3>
<p>
The SQL Server COMPUTE clause is used to generate row aggregate functions (SUM, AVG, MIN, MAX, and COUNT), which appear as additional rows in the query results. It allows you to see detail and summary rows in one set of results. You can calculate summary values for subgroups, and you can calculate more than one aggregate function for the same group.</p>
<p>
The Oracle SELECT statement syntax does not support the COMPUTE clause. It is worth noting that the COMPUTE clause works just like the COMPUTE command found in the Oracle SQL*Plus query tool.</p>
<h3>Join Clauses</h3>
<p>
SQL Server allows up to 16 tables to be joined in a join clause. This includes both temporary and permanent tables. There is no join limit in Oracle.</p>
<p>
When using outer joins in Oracle, the outer join operator (+) is typically placed next to the child (foreign key) column in the join. The (+) identifies the column with fewer unique values. This always occurs unless the foreign key allows nulls, in which case the outer join operator (+) may be placed on the parent (PRIMARY KEY or UNIQUE constraint) column. You cannot place the outer join operator (+) on both sides of the equal sign (=).</p>
<p>
When using SQL Server, you can use the *= and =* outer join operators. The * is used to identify the column that has more unique values. If the child (foreign key) column does not allow nulls, the * is placed on the parent (PRIMARY KEY or UNIQUE constraint) column side of the equal sign. The placement of the * is essentially reversed in Oracle. You cannot place the * on both sides of the equal sign (=).</p>
<p>
The *= and =* are considered legacy join operators. SQL Server supports the ANSI-standard join operators, and it is recommended that you use this syntax. The ANSI-standard syntax is more powerful and has fewer restrictions than the <b>* </b>operators. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Join operation</b></td>
<td class=label width=79%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=21%>CROSS JOIN</td>
<td width=79%>This is the cross product of two tables. It returns the same rows as if no WHERE clause was specified in an old-style join. This type of join is called a Cartesian-join in Oracle.</td>
</tr>
<tr valign=top>
<td width=21%>INNER</td>
<td width=79%>This join specifies that all inner rows be returned. Any unmatched rows are discarded. This is identical to a standard Oracle table join.</td>
</tr>
<tr valign=top>
<td width=21%>LEFT [OUTER]</td>
<td width=79%>This type of join specifies that all of the left table outer rows be returned, even if no column matches are found. This operates just like an Oracle outer join (+).</td>
</tr>
<tr valign=top>
<td width=21%>RIGHT [OUTER]</td>
<td width=79%>This type of join specifies that all of the right table outer rows be returned, even if no column matches are found. This operates just like an Oracle outer join (+).</td>
</tr>
<tr valign=top>
<td width=21%>FULL [OUTER]</td>
<td width=79%>If a row from either table does not match the selection criteria, specifies the row be included in the result set and its output columns that correspond to the other table be set to NULL. This would be the same as placing the Oracle outer join operator on both sides of the "=" sign (col1(+) = col2(+)), which is not allowed.</td>
</tr>
</table><br>
<p>
The code examples return listings of classes taken by all students. Outer joins are defined between the student and grade tables that allow all students to appear, even those who are not enrolled in any classes. Outer joins are also added to the class table in order to return the class names. If outer joins are not added to the class tables, those students who are not enrolled in any classes are not returned because they have null course codes (CCODE). Notice how the syntax differs between Oracle and SQL Server.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Oracle</b></td>
<td class=label width=50%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=50%>SELECT S.SSN AS SSN,<br>
FNAME, LNAME<br>
<b>FROM STUDENT_ADMIN.STUDENT S,<br>
DEPT_ADMIN.CLASS C,<br>
STUDENT_ADMIN.GRADE G<br>
WHERE S.SSN = G.SSN(+)<br>
AND G.CCODE = C.CCODE(+)</b></td>
<td width=50%>SELECT S.SSN AS SSN,<br>
FNAME, LNAME<br>
<b>FROM STUDENT_ADMIN.GRADE G<br>
RIGHT OUTER JOIN<br>
STUDENT_ADMIN.STUDENT S<br>
ON G.SSN = S.SSN<br>
LEFT OUTER JOIN<br>
DEPT_ADMIN.CLASS C<br>
ON G.CCODE = C.CCODE</b></td>
</tr>
</table><br>
<h3>Using SELECT Statements as Table Names</h3>
<p>
SQL Server and Oracle support the use of SELECT statements as table names when performing queries. However, it is important to note that an alias must be provided with the SQL Server SELECT statement, while an alias is optional with Oracle.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Oracle</b></td>
<td class=label width=50%><b>SQL Server</b></td>
</tr>
<tr valign=top>
<td width=50%>SELECT SSN, LNAME, FNAME,<br>
TUITION_PAID, SUM_PAID<br>
FROM STUDENT_ADMIN.STUDENT,<br>
<b>(SELECT SUM(TUITION_PAID) SUM_PAID<br>
FROM STUDENT_ADMIN.STUDENT)</b></td>
<td width=50%>SELECT SSN, LNAME, FNAME,<br>
TUITION_PAID, SUM_PAID<br>
FROM STUDENT_ADMIN.STUDENT,<br>
<b>(SELECT SUM(TUITION_PAID) SUM_PAID<br>
FROM STUDENT_ADMIN.STUDENT) SUM_STUDENT</b></td>
</tr>
</table><br>
<h3>Reading text and image Columns</h3>
<p>
In Oracle, you use a SELECT statement to query the values in LONG and LONG RAW columns. Because the LONG or LONG RAW column is part of a queried row, no specialized functions are required to access this information.</p>
<p>
In SQL Server, you can use a standard SQL statement or the specialized READTEXT statement to read data in <b>text</b> and <b>image</b> columns. It is important to note that the READTEXT statement allows you to read partial sections of a <b>text</b> or <b>image</b> column. Oracle does not provide an equivalent statement for working with LONG and LONG RAW columns.</p>
<p>
The READTEXT statement makes use of a <i>text_pointer</i>, which can be obtained using the TEXTPTR function. The TEXTPTR function returns a pointer to the <b>text</b> or <b>image</b> column in the specified row or to the <b>text</b> or <b>image</b> column in the last row returned by the query if more than one row is returned. Because the TEXTPTR function returns a 16-byte binary string, it is best to declare a local variable to hold the text pointer and then use the variable with READTEXT.</p>
<p>
The READTEXT statement specifies how many bytes to return. The value in the global variable <b>@@textsize</b>, which is the limit on the number of bytes of data to be returned, supersedes the size specified by the READTEXT statement if it is less than the specified size for READTEXT.</p>
<p>
The SET statement can be used with the TEXTSIZE parameter to specify the size, in bytes, of text data to be returned with a SELECT statement. If you specify a TEXTSIZE of zero, the size is reset to the default (4K). Setting the TEXTSIZE parameter affects the global variable <b>@@textsize</b>. The SQL Server ODBC driver automatically sets the TEXTSIZE parameter when the SQL_MAX_LENGTH statement option is changed.</p>
</BODY>
</HTML>
