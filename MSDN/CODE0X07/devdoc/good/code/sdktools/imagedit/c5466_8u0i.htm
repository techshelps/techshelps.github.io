<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ICCLIP.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5472"></a>ICCLIP.C</h2>
<pre><code>/*************************************************************************** <br>     *                                                                         * <br>     *  MODULE      : ICClip.C                                                 * <br>     *                                                                         * <br>     *  DESCRIPTION : Clipboard functions for ImagEdit                         * <br>     *                                                                         * <br>     *  FUNCTIONS   : CopyImageClip ()  - Copies selected portion of image to  * <br>     *                                    the clipboard.                       * <br>     *                                                                         * <br>     *                PasteImageClip () - Pastes the clipboard image to        * <br>     *                                    selected portion of edit image.      * <br>     *                                                                         * <br>     *                                                                         * <br>     *  HISTORY     : 6/21/89 - created by LR                                  * <br>     *                                                                         * <br>     ***************************************************************************/ <br>     <br>    #include "imagedit.h" <br>    #include "dialogs.h" <br>    #include "iehelp.h" <br>     <br> #include &lt;windowsx.h&gt; <br>     <br>    /*========================================================================== <br>      |ImagEdit's clipboard data is in two formats:                              | <br>      |        a) a standard CF_BITMAP format  and                               | <br>      |        b) a private ImagEdit format described below.                     | <br>      |                                                                          | <br>      |The private ImagEdit format data consists of:                             | <br>      |   1.  a DWORD describing screen color when image was sent to clipboard   | <br>      |       followed by...                                                     | <br>      |   2.  the DIB bits of the monochrome AND image (in ghdcANDMask).         | <br>      |                                                                          | <br>      |The CF_BITMAP format consists of the image bitmap (the combined XOR and   | <br>      |AND images in ghdcImage for icons and cursors).                           | <br>      |                                                                          | <br>      |This information is sufficient to re-create the image correctly during    | <br>      |paste even if the screen viewing color is subsequently changed.           | <br>      |                                                                          | <br>      |Both formats are created if the image being edited is an icon or a cursor.| <br>      |Only the CF_BITMAP format is created if a bitmap is being edited.         | <br>      ==========================================================================*/ <br>     <br>    /**************************************************************************** <br>     *                                                                          * <br>     *  FUNCTION   : BOOL PASCAL CopyImageClip(fBitmap)                         * <br>     *                                                                          * <br>     *  PURPOSE    : Copies the information from the selected area of image to  * <br>     *               the clipboard.                                             * <br>     *                                                                          * <br>     *  SIDE EFFECTS: may change contents of the clipboard. The "pick" or clip  * <br>     *                rectangle is reset to cover the entire image.             * <br>     *                                                                          * <br>     ****************************************************************************/ <br>     <br>    BOOL CopyImageClip(VOID) <br>    { <br>        HCURSOR hcurOld; <br>        HBITMAP hStdBitmap; <br>        HBITMAP hPrivBitmap; <br>        HDC hStdDC; <br>        HDC hPrivDC; <br>        HANDLE hOldSObj; <br>        HANDLE hOldPObj; <br>        HANDLE hPriv; <br>        LPSTR lpPriv; <br>     <br>        hcurOld = SetCursor(hcurWait); <br>     <br>        /* create a temp. bitmap and DC for the standard clipboard format <br>         * along the same lines as the image bitmap <br>         */ <br>        hStdDC = CreateCompatibleDC(ghdcImage); <br>        hStdBitmap = MyCreateBitmap(ghdcImage, gcxPick, gcyPick, 16); <br>        hOldSObj = SelectObject(hStdDC, hStdBitmap); <br>     <br>        /* blt the image bits into standard format DC */ <br>        BitBlt(hStdDC, 0, 0, gcxPick, gcyPick, ghdcImage, <br>                grcPick.left, grcPick.top, SRCCOPY); <br>        SelectObject(hStdDC, hOldSObj); <br>     <br>        if (giType != FT_BITMAP) { <br>            /* for icons and cursors, create a temp. DC and bitmap for the AND <br>            * mask and blt the mask bits into it. <br>            */ <br>            hPrivDC = CreateCompatibleDC(ghdcANDMask); <br>            hPrivBitmap = CreateCompatibleBitmap(ghdcANDMask, gcxPick, gcyPick); <br>            hOldPObj = SelectObject(hPrivDC, hPrivBitmap); <br>            BitBlt(hPrivDC, 0, 0, gcxPick, gcyPick, ghdcANDMask, <br>                    grcPick.left, grcPick.top, SRCCOPY); <br>     <br>            /* Allocate a buffer for the private ImagEdit format */ <br>            hPriv = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, <br>                    (DWORD)((gcxPick + 31) &gt;&gt; 3) * gcyPick + sizeof(DWORD)); <br>            if (!hPriv) { <br>                DeleteDC(hStdDC); <br>                DeleteObject(hStdBitmap); <br>                DeleteDC(hPrivDC); <br>                DeleteObject(hPrivBitmap); <br>                return FALSE; <br>            } <br>     <br>            lpPriv = (LPSTR)GlobalLock(hPriv); <br>     <br>            /* Fill in the first DWORD with the screen color information */ <br>            *((DWORD FAR *)lpPriv) = grgbScreen; <br>     <br>            /* Get the mask bits into the buffer */ <br>            GetBitmapBits(hPrivBitmap, (DWORD)((gcxPick + 31) &gt;&gt; 3) * gcyPick, <br>                    (LPSTR)lpPriv + sizeof(DWORD)); <br>     <br>            SelectObject(hPrivDC, hOldPObj); <br>            DeleteObject(hPrivBitmap); <br>            DeleteDC(hPrivDC); <br>        } <br>     <br>        /* Open clipboard and clear it of it's contents */ <br>        if (!OpenClipboard(ghwndMain)) { <br>            DeleteDC(hStdDC); <br>            return(FALSE); <br>        } <br>        EmptyClipboard(); <br>     <br>        if (giType != FT_BITMAP) { <br>            /* set the private ImagEdit format data into the clipboard */ <br>            if (!SetClipboardData(ClipboardFormat, hPriv)) { <br>                DeleteDC(hStdDC); <br>                GlobalUnlock(hPriv); <br>                GlobalFree(hPriv); <br>                CloseClipboard(); <br>                return(FALSE); <br>            } <br>            GlobalUnlock(hPriv); <br>        } <br>        /* set the standard CF_BITMAP format data in the clipboard */ <br>        if (!SetClipboardData(CF_BITMAP, hStdBitmap)) { <br>            DeleteDC(hStdDC); <br>            GlobalFree(hPriv);  //   hPriv may not have been initialized (if giType == BITMAP). <br>            CloseClipboard(); <br>            return(FALSE); <br>        } <br>     <br>        CloseClipboard(); <br>        DeleteDC(hStdDC); <br>     <br>        /* <br>         * Reset pick rectangle to cover entire image. <br>         */ <br>        PickSetRect(0, 0, gcxImage - 1, gcyImage - 1); <br>     <br>        /* <br>         * Erase the drag rectangle. <br>         */ <br>        WorkUpdate(); <br>     <br>        SetCursor(hcurOld); <br>     <br>        return TRUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PasteImageClip <br>    * <br>    * Pastes an image from the clipboard to the current image. <br>    * <br>    * It is assumed that this routine will not be called unless an <br>    * image is currently being edited. <br>    * <br>    * The pick rectangle is reset to cover the entire image if the <br>    * paste is successful. <br>    * <br>    * Basic outline of how Paste is done in ImagEdit. <br>    * <br>    * Find out what format is available in the clipboard: <br>    *    a. CF_BITMAP only <br>    *       -------------- <br>    *       case 1: Pasting to an icon or cursor <br>    *                 * We don't have any screen color information. <br>    *                   Make the mask bits opaque and blt. the bitmap to <br>    *                   ghdcImage. <br>    * <br>    *       case 2: Pasting to a bitmap <br>    *                 * Blt the bitmap to the image DC. <br>    * <br>    *    b. both ImagEdit and CF_BITMAP <br>    *       --------------------------- <br>    *       case 1: Pasting to an icon or cursor <br>    *                 * Recover the image from the AND and screen color <br>    *                   data (in ImagEdit) and the combined image bitmap <br>    *                   (in CF_BITMAP). Use the information to make the <br>    *                   neccessary changes if the screen viewing color was <br>    *                   changed between Copy and Paste. <br>    * <br>    *       case 2: Pasting to a bitmap <br>    *                 * Blt the CF_BITMAP data to the image DC. <br>    * <br>    * If the destination image differs in dimensions from <br>    * source image, the source image is stretched or clipped to that of <br>    * destination, depending on preference <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL PasteImageClip(VOID) <br>    { <br>        HCURSOR hcurOld; <br>        INT cxClip; <br>        INT cyClip; <br>        INT cxTarget; <br>        INT cyTarget; <br>        INT cxSource; <br>        INT cySource; <br>        DWORD rgbClipScreen; <br>        BOOL fIEFormatFound; <br>        HANDLE hClipData; <br>        LPSTR lpClipData; <br>        BITMAP bmClip; <br>        HDC hdcClip; <br>        HBITMAP hbmClip; <br>        HBITMAP hbmClipOld; <br>        HDC hdcClipAND; <br>        HBITMAP hbmClipAND; <br>        HBITMAP hbmClipANDOld; <br>        HDC hdcClipAND16; <br>        HBITMAP hbmClipAND16; <br>        HBITMAP hbmClipAND16Old; <br>        HDC hdcTarget; <br>        HBITMAP hbmTarget; <br>        HBITMAP hbmTargetOld; <br>        HDC hdcTargetAND16; <br>        HBITMAP hbmTargetAND16; <br>        HBITMAP hbmTargetAND16Old; <br>        HDC hdcTargetAND; <br>        HBITMAP hbmTargetAND; <br>        HBITMAP hbmTargetANDOld; <br>     <br>        hcurOld = SetCursor(hcurWait); <br>     <br>        if (!OpenClipboard(ghwndMain)) { <br>            Message(MSG_NOCLIPBOARD); <br>            goto Error1; <br>        } <br>     <br>        if (!(hbmClip = GetClipboardData(CF_BITMAP))) { <br>            Message(MSG_NOCLIPBOARDFORMAT); <br>            goto Error2; <br>        } <br>     <br>        GetObject(hbmClip, sizeof(BITMAP), (LPSTR)&amp;bmClip); <br>        cxClip = (INT)bmClip.bmWidth; <br>        cyClip = (INT)bmClip.bmHeight; <br>     <br>        /* <br>         * If the dimensions of the current pick rectangle don't match <br>         * the bitmap being pasted, ask the user if they want to stretch <br>         * or clip the pasted image. <br>         */ <br>        cxTarget = gcxPick; <br>        cyTarget = gcyPick; <br>        cxSource = cxClip; <br>        cySource = cyClip; <br>        if (gcxPick != cxClip || gcyPick != cyClip) { <br>            if (DlgBox(DID_PASTEOPTIONS, (WNDPROC)PasteOptionsDlgProc) == IDCANCEL) { <br>                goto Error2; <br>            } <br>     <br>            /* <br>             * If clipping and the clipboard dimensions differ from the <br>             * selected pick rectangle, then either the target dimensions <br>             * or the source dimensions need to be sized down. <br>             */ <br>            if (!fStretchClipboardData) { <br>                if (cxClip &lt; gcxPick) <br>                    cxTarget = cxClip; <br>                else <br>                    cxSource = gcxPick; <br>     <br>                if (cyClip &lt; gcyPick) <br>                    cyTarget = cyClip; <br>                else <br>                    cySource = gcyPick; <br>            } <br>        } <br>     <br>        /* <br>         * Update the undo buffer now that we are committed to the paste. <br>         */ <br>        ImageUpdateUndo(); <br>     <br>        /* <br>         * Determine if the private ImagEdit clipboard format is available. <br>         */ <br>        fIEFormatFound = IsClipboardFormatAvailable(ClipboardFormat); <br>     <br>        if (giType != FT_BITMAP &amp;&amp; fIEFormatFound) { <br>            /* <br>             * Get the AND mask bitmap and the old screen color out of <br>             * the private format. <br>             */ <br>            hClipData = GetClipboardData(ClipboardFormat); <br>            lpClipData = (LPSTR)GlobalLock(hClipData); <br>            rgbClipScreen = *((DWORD FAR *)lpClipData); <br>            hdcClipAND = CreateCompatibleDC(ghdcImage); <br>            hbmClipAND = CreateBitmap(cxClip, cyClip, (BYTE)1, (BYTE)1, <br>                    (LPSTR)lpClipData + sizeof(DWORD)); <br>            hbmClipANDOld = SelectObject(hdcClipAND, hbmClipAND); <br>     <br>            /* <br>             * Create a color bitmap for temporary use. <br>             */ <br>            hdcClipAND16 = CreateCompatibleDC(ghdcImage); <br>            hbmClipAND16 = MyCreateBitmap(ghdcImage, cxSource, cySource, 16); <br>            hbmClipAND16Old = SelectObject(hdcClipAND16, hbmClipAND16); <br>     <br>            /* <br>             * Blt the AND mask onto the color bitmap. <br>             */ <br>            BitBlt(hdcClipAND16, 0, 0, cxSource, cySource, hdcClipAND, <br>                    0, 0, SRCCOPY); <br>     <br>            /* <br>             * Create the color target AND mask bitmap. <br>             */ <br>            hdcTargetAND16 = CreateCompatibleDC(ghdcImage); <br>            hbmTargetAND16 = MyCreateBitmap(ghdcImage, cxTarget, cyTarget, 16); <br>            hbmTargetAND16Old = SelectObject(hdcTargetAND16, hbmTargetAND16); <br>     <br>            /* <br>             * StretchBlt from the color AND mask bitmap to the color target <br>             * AND mask bitmap.  The blt must be done from a color bitmap to <br>             * a color bitmap, and the stretch blt mode must be set to <br>             * COLORONCOLOR.  All this is necessary so that the AND mask <br>             * stays exactly in sync with the stretch blt of the color <br>             * (XOR) mask.  If these steps are not done correctly, shrinking <br>             * an image with screen colored pixels in it can cause problems, <br>             * because the stretch blt will use a slightly different <br>             * algorithm to compress the monochrome AND mask and the color <br>             * XOR mask. <br>             */ <br>            SetStretchBltMode(hdcTargetAND16, COLORONCOLOR); <br>            SetStretchBltMode(hdcClipAND16, COLORONCOLOR);     // <br>            StretchBlt(hdcTargetAND16, 0, 0, cxTarget, cyTarget, hdcClipAND16, <br>                    0, 0, cxSource, cySource, SRCCOPY); <br>     <br>            /* <br>             * Create the monochrome target AND mask bitmap. <br>             */ <br>            hdcTargetAND = CreateCompatibleDC(ghdcImage); <br>            hbmTargetAND = MyCreateBitmap(ghdcImage, cxTarget, cyTarget, 2); <br>            hbmTargetANDOld = SelectObject(hdcTargetAND, hbmTargetAND); <br>     <br>            /* <br>             * Blt the color AND mask onto the monochrome AND mask. <br>             * The monochrome AND mask is the one that we will use <br>             * later.  It must be monochrome or the ImageDCSeparate <br>             * and ImageDCCombine functions will not work properly. <br>             */ <br>            BitBlt(hdcTargetAND, 0, 0, cxTarget, cyTarget, hdcTargetAND16, <br>                    0, 0, SRCCOPY); <br>     <br>            /* <br>             * Cleanup. <br>             */ <br>            SelectObject(hdcTargetAND16, hbmTargetAND16Old); <br>            DeleteObject(hbmTargetAND16); <br>            DeleteDC(hdcTargetAND16); <br>            SelectObject(hdcClipAND16, hbmClipAND16Old); <br>            DeleteObject(hbmClipAND16); <br>            DeleteDC(hdcClipAND16); <br>            SelectObject(hdcClipAND, hbmClipANDOld); <br>            DeleteObject(hbmClipAND); <br>            DeleteDC(hdcClipAND); <br>            GlobalUnlock(hClipData); <br>        } <br>     <br>        /* <br>         * Get the clipboard bitmap into a DC. <br>         */ <br>        hdcClip = CreateCompatibleDC(ghdcImage); <br>        hbmClipOld = SelectObject(hdcClip, hbmClip); <br>     <br>        /* <br>         * Create the target bitmap. <br>         */ <br>        hdcTarget = CreateCompatibleDC(ghdcImage); <br>        hbmTarget = MyCreateBitmap(ghdcImage, cxTarget, cyTarget, 16); <br>        hbmTargetOld = SelectObject(hdcTarget, hbmTarget); <br>     <br>        /* <br>         * StretchBlt the bitmap onto the target. <br>         */ <br>        SetStretchBltMode(hdcTarget, COLORONCOLOR); <br>        SetStretchBltMode(hdcClip, COLORONCOLOR);     // <br>        StretchBlt(hdcTarget, 0, 0, cxTarget, cyTarget, hdcClip, 0, 0, <br>                cxSource, cySource, SRCCOPY); <br>     <br>        /* <br>         * Handle some special cases. <br>         */ <br>        if (giType == FT_BITMAP || !fIEFormatFound) { <br>            /* <br>             * The image we are pasting into is either a bitmap, or <br>             * there does not exist an AND mask in the clipboard. <br>             */ <br>            if (gnColors == 2) { <br>                /* <br>                 * We are pasting to a mono image.  We must convert the <br>                 * colors in the clipboard bitmap into monochrome. <br>                 */ <br>                ImageDCMonoBlt(hdcTarget, cxTarget, cyTarget); <br>            } <br>        } <br>        else { <br>            /* <br>             * We are pasting into an icon or cursor image and we have <br>             * available an AND mask.  Is the current image monochrome? <br>             */ <br>            if (gnColors == 2) { <br>                /* <br>                 * Remove the old screen/inverse colors from the image, <br>                 * convert it to monochrome, then put back in the <br>                 * current screen/inverse colors. <br>                 */ <br>                ImageDCSeparate(hdcTarget, cxTarget, cyTarget, hdcTargetAND, <br>                        rgbClipScreen); <br>                ImageDCMonoBlt(hdcTarget, cxTarget, cyTarget); <br>                ImageDCCombine(hdcTarget, cxTarget, cyTarget, hdcTargetAND); <br>            } <br>            /* <br>             * Does the screen color specified in the clipboard <br>             * differ from the current screen color? <br>             */ <br>            else if (rgbClipScreen != grgbScreen) { <br>                /* <br>                 * Remove the old screen/inverse colors, then put back <br>                 * in the current ones. <br>                 */ <br>                ImageDCSeparate(hdcTarget, cxTarget, cyTarget, hdcTargetAND, <br>                        rgbClipScreen); <br>                ImageDCCombine(hdcTarget, cxTarget, cyTarget, hdcTargetAND); <br>            } <br>        } <br>     <br>        /* <br>         * Blt the clipboard image to the proper rectangle in the current image. <br>         */ <br>        BitBlt(ghdcImage, grcPick.left, grcPick.top, <br>                cxTarget, cyTarget, hdcTarget, 0, 0, SRCCOPY); <br>     <br>        /* <br>         * If the current image is an icon or cursor, we must take care <br>         * of the AND mask also. <br>         */ <br>        if (giType != FT_BITMAP) { <br>            /* <br>             * Is there an AND mask in the clipboard to use? <br>             */ <br>            if (fIEFormatFound) { <br>                /* <br>                 * Blt it into the current image's AND mask. <br>                 */ <br>                BitBlt(ghdcANDMask, grcPick.left, grcPick.top, <br>                        cxTarget, cyTarget, hdcTargetAND, 0, 0, SRCCOPY); <br>            } <br>            else { <br>                /* <br>                 * Make the AND mask opaque, because there is no <br>                 * screen color information. <br>                 */ <br>                PatBlt(ghdcANDMask, grcPick.left, grcPick.top, <br>                        cxTarget, cyTarget, BLACKNESS); <br>            } <br>        } <br>     <br>        /* <br>         * Cleanup. <br>         */ <br>        SelectObject(hdcTarget, hbmTargetOld); <br>        DeleteObject(hbmTarget); <br>        DeleteDC(hdcTarget); <br>     <br>        if (giType != FT_BITMAP &amp;&amp; fIEFormatFound) { <br>            SelectObject(hdcTargetAND, hbmTargetANDOld); <br>            DeleteObject(hbmTargetAND); <br>            DeleteDC(hdcTargetAND); <br>        } <br>     <br>        SelectObject(hdcClip, hbmClipOld); <br>        DeleteDC(hdcClip); <br>     <br>        CloseClipboard(); <br>     <br>        /* <br>         * Update the View and workspace windows. <br>         */ <br>        ViewUpdate(); <br>     <br>        /* <br>         * Reset pick rectangle to cover entire image. <br>         */ <br>        PickSetRect(0, 0, gcxImage - 1, gcyImage - 1); <br>     <br>        fImageDirty = TRUE; <br>     <br>        SetCursor(hcurOld); <br>     <br>        return TRUE; <br>     <br>    Error2: <br>        CloseClipboard(); <br>     <br>    Error1: <br>        SetCursor(hcurOld); <br>     <br>        return FALSE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PasteOptionsDlgProc <br>    * <br>    * Proc for the dialog that asks the user whether they want to clip <br>    * or stretch the bitmap being pasted in. <br>    * <br>    * Upon return with an IDOK value, the fStretchClipboardData global <br>    * will be TRUE if they want to stretch, or FALSE if they want to clip. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    DIALOGPROC PasteOptionsDlgProc( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        switch (msg) { <br>            case WM_INITDIALOG: <br>                CheckRadioButton(hwnd, DID_PASTEOPTIONSSTRETCH, <br>                        DID_PASTEOPTIONSCLIP, <br>                        fStretchClipboardData ? <br>                        DID_PASTEOPTIONSSTRETCH : DID_PASTEOPTIONSCLIP); <br>     <br>                CenterWindow(hwnd); <br>     <br>                break; <br>     <br>            case WM_COMMAND: <br>                switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                    case IDOK : <br>                        if (IsDlgButtonChecked(hwnd, DID_PASTEOPTIONSSTRETCH)) <br>                            fStretchClipboardData = TRUE; <br>                        else <br>                            fStretchClipboardData = FALSE; <br>     <br>                        EndDialog(hwnd, IDOK); <br>                        break; <br>     <br>                    case IDCANCEL: <br>                        EndDialog(hwnd, IDCANCEL); <br>                        break; <br>     <br>                    case IDHELP: <br>                        WinHelp(ghwndMain, gszHelpFile, HELP_CONTEXT, <br>                                HELPID_PASTEOPTIONS); <br>                        break; <br>                } <br>     <br>                break; <br>     <br>            default: <br>                return FALSE; <br>        } <br>     <br>        return TRUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PickSetRect <br>    * <br>    * Sets the globals for the picking rectangle size.  This affects <br>    * what is copied into the clipboard. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID PickSetRect( <br>        INT xLeft, <br>        INT yTop, <br>        INT xRight, <br>        INT yBottom) <br>    { <br>        SetRect(&amp;grcPick, xLeft, yTop, xRight, yBottom); <br>        gcxPick = (grcPick.right - grcPick.left) + 1; <br>        gcyPick = (grcPick.bottom - grcPick.top) + 1; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
