<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTIL.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5490"></a>UTIL.C</h2>
<pre><code>/****************************************************************************/ <br>    /*                                                                          */ <br>    /*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>    /*                           All Rights Reserved                            */ <br>    /*                                                                          */ <br>    /****************************************************************************/ <br>    /****************************** Module Header ******************************* <br>    * Module Name: util.c <br>    * <br>    * Contains miscellaneous utility functions for ImagEdit. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    #include "imagedit.h" <br>     <br>    #include &lt;stdio.h&gt; <br>    #include &lt;stdarg.h&gt; <br>     <br>    #define CBOVERHEAD      (sizeof(INT)+sizeof(INT)+sizeof(INT)) <br>    #define MEMSIGHEAD      0x1234 <br>    #define MEMSIGTAIL      0x5678 <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * MyAlloc <br>    * <br>    * <br>    * <br>    * History: <br>    *  25-Jul-1989   - Created <br>    ****************************************************************************/ <br>     <br>    VOID *MyAlloc( <br>        INT cbAlloc) <br>    { <br>        register HANDLE hMem; <br>     <br>        if (hMem = LocalAlloc(LMEM_FIXED, cbAlloc)) { <br>            return (VOID *)hMem; <br>        } <br>        else { <br>            MessageBeep(0); <br>            Message(MSG_OUTOFMEMORY); <br>     <br>            return NULL; <br>        } <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * MyRealloc <br>    * <br>    * <br>    * <br>    * History: <br>    *  25-Jul-1989   - Created <br>    ****************************************************************************/ <br>     <br>    VOID *MyRealloc( <br>        VOID *npMem, <br>        INT cbNewAlloc) <br>    { <br>        npMem = (VOID *)LocalReAlloc((HANDLE)npMem, cbNewAlloc, LMEM_MOVEABLE); <br>     <br>        if (!npMem) { <br>            MessageBeep(0); <br>            Message(MSG_OUTOFMEMORY); <br>     <br>            return NULL; <br>        } <br>     <br>        return npMem; <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * MyFree <br>    * <br>    * <br>    * History: <br>    *  25-Jul-1989   - Created <br>    ****************************************************************************/ <br>     <br>    VOID *MyFree( <br>        VOID *npMem) <br>    { <br>        if (LocalFree((HANDLE)npMem)) { <br>            MessageBeep(0); <br>            Message(MSG_MEMERROR); <br>     <br>            return npMem; <br>        } <br>     <br>        return NULL; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * Message <br>    * <br>    * This function puts up a message box.  The message is described in <br>    * the gamdMessages table. <br>    * <br>    * Arguments: <br>    *   UINT idMsg - Index to the message. <br>    *   ...        - Optional arguments. <br>    * <br>    * Returns: <br>    *     What MessageBox returns. <br>    * <br>    ************************************************************************/ <br>     <br>    INT Message( <br>        UINT idMsg, <br>        ...) <br>    { <br>        va_list marker; <br>        INT RetCode; <br>        CHAR szT[CCHTEXTMAX]; <br>     <br>        va_start(marker, idMsg); <br>        vsprintf(szT, ids(gamdMessages[idMsg].ids), marker); <br>     <br>        RetCode = MessageBox(NULL, szT, ids(IDS_PGMTITLE), <br>                gamdMessages[idMsg].fMessageBox | MB_TASKMODAL); <br>     <br>        va_end(marker); <br>     <br>        return RetCode; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * CenterWindow <br>    * <br>    * This function centers the given window over its owner.  It ensures <br>    * that the window is entirely within the visible screen, however. <br>    * If the window does not have an owner, it is centered over the <br>    * desktop. <br>    * <br>    * Arguments: <br>    *   HWND hwnd - The window to center. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID CenterWindow( <br>        HWND hwnd) <br>    { <br>        RECT rc; <br>        RECT rcOwner; <br>        RECT rcCenter; <br>        HWND hwndOwner; <br>     <br>        GetWindowRect(hwnd, &amp;rc); <br>     <br>        if (!(hwndOwner = GetWindow(hwnd, GW_OWNER))) <br>            hwndOwner = GetDesktopWindow(); <br>     <br>        GetWindowRect(hwndOwner, &amp;rcOwner); <br>     <br>        /* <br>         *  Calculate the starting x,y for the new <br>         *  window so that it would be centered. <br>         */ <br>        rcCenter.left = rcOwner.left + <br>                (((rcOwner.right - rcOwner.left) - <br>                (rc.right - rc.left)) <br>                / 2); <br>     <br>        rcCenter.top = rcOwner.top + <br>                (((rcOwner.bottom - rcOwner.top) - <br>                (rc.bottom - rc.top)) <br>                / 2); <br>     <br>        rcCenter.right = rcCenter.left + (rc.right - rc.left); <br>        rcCenter.bottom = rcCenter.top + (rc.bottom - rc.top); <br>     <br>        FitRectToScreen(&amp;rcCenter); <br>     <br>        SetWindowPos(hwnd, NULL, rcCenter.left, rcCenter.top, 0, 0, <br>                SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * FitRectToScreen <br>    * <br>    * This function ensures that the given rectangle is entirely within <br>    * the visible screen, adjusting it if necessary. <br>    * <br>    * Arguments: <br>    *   PRECT prc - The rectangle. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID FitRectToScreen( <br>        PRECT prc) <br>    { <br>        INT cxScreen; <br>        INT cyScreen; <br>        INT delta; <br>     <br>        cxScreen = GetSystemMetrics(SM_CXSCREEN); <br>        cyScreen = GetSystemMetrics(SM_CYSCREEN); <br>     <br>        if (prc-&gt;right &gt; cxScreen) { <br>            delta = prc-&gt;right - prc-&gt;left; <br>            prc-&gt;right = cxScreen; <br>            prc-&gt;left = prc-&gt;right - delta; <br>        } <br>     <br>        if (prc-&gt;left &lt; 0) { <br>            delta = prc-&gt;right - prc-&gt;left; <br>            prc-&gt;left = 0; <br>            prc-&gt;right = prc-&gt;left + delta; <br>        } <br>     <br>        if (prc-&gt;bottom &gt; cyScreen) { <br>            delta = prc-&gt;bottom - prc-&gt;top; <br>            prc-&gt;bottom = cyScreen; <br>            prc-&gt;top = prc-&gt;bottom - delta; <br>        } <br>     <br>        if (prc-&gt;top &lt; 0) { <br>            delta = prc-&gt;bottom - prc-&gt;top; <br>            prc-&gt;top = 0; <br>            prc-&gt;bottom = prc-&gt;top + delta; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ids <br>    * <br>    * This function will return a string, given the string id.  If this is <br>    * the first time that the string has been retrieved, memory will be <br>    * allocated for it and it will be loaded.  After it is loaded once, it <br>    * is then cached in a PSTR array and is available for later without <br>    * having to load it again. <br>    * <br>    * Arguments: <br>    *   UINT idString - String ID of the string to retrieve. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    PSTR ids( <br>        UINT idString) <br>    { <br>        static PSTR apstr[CSTRINGS];        // String resource array cache. <br>        PSTR pstr; <br>        INT cch; <br>     <br>        if (apstr[idString]) <br>            return apstr[idString]; <br>     <br>        if (!(pstr = MyAlloc(CCHTEXTMAX))) <br>            return ""; <br>     <br>        if (!(cch = LoadString(ghInst, idString, pstr, CCHTEXTMAX))) { <br>            MyFree(pstr); <br>            return ""; <br>        } <br>     <br>        apstr[idString] = pstr = MyRealloc(pstr, cch + 1); <br>     <br>        return (pstr ? pstr : ""); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * MyCreateBitmap <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    HBITMAP MyCreateBitmap( <br>        HDC hdc, <br>        INT cx, <br>        INT cy, <br>        INT nColors) <br>    { <br>        BITMAPINFOHEADER bmih; <br>     <br>        if (nColors == 2) { <br>            return CreateBitmap(cx, cy, 1, 1, NULL); <br>        } <br>        else { <br>            bmih.biSize = sizeof(BITMAPINFOHEADER); <br>            bmih.biWidth = cx; <br>            bmih.biHeight = cy; <br>            bmih.biPlanes = 1;              // 1 plane, 4 bpp is <br>            bmih.biBitCount = 4;            // 16 colors. <br>     <br>            bmih.biCompression = <br>            bmih.biSizeImage = <br>            bmih.biXPelsPerMeter = <br>            bmih.biYPelsPerMeter = <br>            bmih.biClrUsed = <br>            bmih.biClrImportant = 0; <br>     <br>            return CreateDIBitmap(hdc, &amp;bmih, 0L, NULL, NULL, 0); <br>        } <br>    } <br>     <br>     <br>     <br>    #if defined(DBG) &amp;&amp; defined(WIN16) <br>    /**************************************************************************** <br>    * DBGStackReport <br>    * <br>    * This debugging function reports how much stack is used by a program. <br>    * To use it, call it with fInit == TRUE right at the beginning of the <br>    * program and then with fInit == FALSE just before the program exits. <br>    * The stack space used during the current run of the program will be <br>    * displayed on the debug terminal. <br>    * <br>    * It is implemented by filling the stack with a certain value down to <br>    * the bottom of the stack (if fInit is TRUE).  When it is called with <br>    * fInit == FALSE, it starts at the bottom of the stack and looks for <br>    * where this "signature" value has been overwritten with data, then <br>    * does a little math to compute the used stack. <br>    * <br>    * Arguments: <br>    *   BOOL fInit - TRUE if the stack should be initialized, FALSE to <br>    *                print out the report. <br>    * <br>    * History: <br>    *  28-Aug-1990  - Created <br>    ****************************************************************************/ <br>     <br>    /* <br>     * This signature byte will be used to fill the stack. <br>     */ <br>    #define STACKSIG    'A' <br>     <br>    /* <br>     * This is a C runtime global that is always at the very end of the <br>     * global data.  Taking its address is a way that the "bottom" of the <br>     * stack can be found. <br>     */ <br>    extern CHAR end; <br>     <br>    VOID DBGStackReport( <br>        BOOL fInit) <br>    { <br>        static PBYTE pbStackTop; <br>        PBYTE pb; <br>        BYTE bDummy; <br>     <br>        if (fInit) { <br>            /* <br>             * The address of one of this functions local variables is <br>             * taken and considered the "top" of the stack.  This means <br>             * that it will work best when it is called first thing in <br>             * the program. <br>             */ <br>            pbStackTop = pb = &amp;bDummy; <br>     <br>            /* <br>             * Fill the stack up. <br>             */ <br>            while (pb &gt; &amp;end) <br>                *pb-- = STACKSIG; <br>        } <br>        else { <br>            /* <br>             * Start at the bottom of the stack and search upwards. <br>             */ <br>            pb = &amp;end; <br>            while (*(++pb) == STACKSIG &amp;&amp; pb &lt; pbStackTop) <br>                ; <br>     <br>            /* <br>             * Display the results. <br>             */ <br>            DBGprintf("ImagEdit stack used: %d bytes.", pbStackTop - pb); <br>        } <br>    } <br>    #endif <br>     <br>     <br>     <br>    #ifdef DBG <br>    /**************************************************************************** <br>    * DBGBltImage <br>    * <br>    * This debugging function blits out the given image in the specified <br>    * DC to the screen.  Every time that it is called, it will blit the <br>    * image to the right of the last one, starting at the top of the <br>    * screen.  It assumes that each image is 32x32 pixels. <br>    * <br>    * Arguments: <br>    *   HDC hdc - The DC with the image to blit.  If this is NULL, the <br>    *             current XOR and AND images are blit'd, with the AND <br>    *             image below the XOR image. <br>    * <br>    * History: <br>    *  16-Sep-1991  - Created <br>    ****************************************************************************/ <br>     <br>    VOID DBGBltImage( <br>        HDC hdc) <br>    { <br>        static INT x; <br>        HDC hdcScreen; <br>     <br>        hdcScreen = GetDC(NULL); <br>     <br>        if (hdc) { <br>            BitBlt(hdcScreen, x, 0, 32, 32, hdc, 0, 0, SRCCOPY); <br>        } <br>        else { <br>            BitBlt(hdcScreen, x, 0, 32, 32, ghdcImage, 0, 0, SRCCOPY); <br>            BitBlt(hdcScreen, x, 32 + 1, 32, 32, ghdcANDMask, 0, 0, SRCCOPY); <br>        } <br>     <br>        ReleaseDC(NULL, hdcScreen); <br>        x += 32 + 1; <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * DBGprintf <br>    * <br>    * This debugging function prints out a string to the debug output. <br>    * An optional set of substitutional parameters can be specified, <br>    * and the final output will be the processed result of these combined <br>    * with the format string, just like printf.  A newline is always <br>    * output after every call to this function. <br>    * <br>    * Arguments: <br>    *   PSTR fmt - Format string (printf style). <br>    *   ...      - Variable number of arguments. <br>    * <br>    * History: <br>    *  28-Aug-1990  - Created <br>    ****************************************************************************/ <br>     <br>    VOID DBGprintf(PSTR fmt, ...) <br>    { <br>        va_list marker; <br>        CHAR szBuf[CCHTEXTMAX]; <br>     <br>        va_start(marker, fmt); <br>        vsprintf(szBuf, fmt, marker); <br>        va_end(marker); <br>     <br>        OutputDebugString(szBuf); <br>        OutputDebugString("\r\n"); <br>    } <br>    #endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
