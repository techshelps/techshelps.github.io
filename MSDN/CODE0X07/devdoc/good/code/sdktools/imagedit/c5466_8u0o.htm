<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMAGEDIT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5478"></a>IMAGEDIT.C</h2>
<pre><code>/*************************************************************************** <br>     *                                                                         * <br>     *  MODULE      : imagedit.c                                               * <br>     *                                                                         * <br>     *  DESCRIPTION : Contains main entry-level routine for ImagEdit.          * <br>     *                                                                         * <br>     *  FUNCTIONS   : WinMain ()        -  Program entry point.                * <br>     *                                                                         * <br>     *  HISTORY     : 3/14/89 - LR                                             * <br>     *                                                                         * <br>     ***************************************************************************/ <br>     <br>    #include "imagedit.h" <br>    #include "dialogs.h" <br>    #include "ids.h" <br>     <br>    #include &lt;string.h&gt; <br>    #include &lt;stdlib.h&gt; <br> <br> #include &lt;windowsx.h&gt; <br>    #include &lt;commdlg.h&gt; <br>     <br>     <br>    /* <br>     * External declarations for the Windows variables that contain <br>     * command line information. <br>     */ <br>    extern INT __argc; <br>    extern CHAR **__argv; <br>     <br>     <br>    STATICFN BOOL NEAR InitApplication(VOID); <br>    STATICFN BOOL NEAR InitInstance(LPSTR lpCmdLine, INT cmdShow); <br>    STATICFN VOID NEAR PenWinRegister(VOID); <br>    STATICFN VOID NEAR ReadEnv(VOID); <br>    STATICFN VOID NEAR WriteEnv(VOID); <br>    STATICFN VOID NEAR SizeRibbons(HWND hwnd); <br>    STATICFN VOID NEAR CleanUp(VOID); <br>     <br>    static RECT grcAppPos;              // Saves the app's window pos. <br>    static WORD gmsgHelp;               // Registered help msg from commdlg.dll <br>    static BOOL fStartAsIcon = FALSE;   // TRUE if app is started minimized. <br>     <br>    /* <br>     * Contains the address of the Pen Windows callback. <br>     */ <br>    typedef VOID ( APIENTRY *LPFNPENWIN)(WORD, BOOL); <br>    static LPFNPENWIN lpfnRegisterPenApp; <br>     <br>     <br>     <br>    /**************************************************************************** <br>     *                                                                          * <br>     *  FUNCTION :int PASCAL WinMain(hInstance,hPrevInstance,lpCmdLine,cmdShow) * <br>     *                                                                          * <br>     *  PURPOSE  :Serves as program entry point and contains message loop       * <br>     *                                                                          * <br>     ****************************************************************************/ <br>     <br>    INT WINAPI <br>    WinMain( <br>        HINSTANCE hInstance, <br>        HINSTANCE hPrevInstance, <br>        LPSTR lpCmdLine, <br>        INT nCmdShow) <br>    { <br>        MSG msg; <br>     <br>        DBGStackReport(TRUE); <br>     <br>        ghInst = hInstance; <br>     <br>        /* if this is the first instance then call initialization procedure */ <br>        if (!hPrevInstance) { <br>            if (!InitApplication()) <br>                return FALSE; <br>        } <br>     <br>        if (!InitInstance(lpCmdLine, nCmdShow)) <br>            return FALSE; <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) { <br> <br>                if (!TranslateAccelerator(ghwndMain, haccelTbl, &amp;msg)) { <br>                    TranslateMessage(&amp;msg); <br>                    DispatchMessage(&amp;msg); <br>                } <br>    } <br>     <br>        DBGStackReport(FALSE); <br>     <br>        /* <br>         * Return the value from PostQuitMessage. <br>         */ <br>        return msg.wParam; <br>    } <br>     <br>     <br>    /**************************************************************************** <br>     *                                                                          * <br>     *  FUNCTION   : InitApplication()                                          * <br>     *                                                                          * <br>     *  PURPOSE    : To create all ImagEdit's window classes, namely those of   * <br>     *               the parent window, edit window, mode window and "palette"  * <br>     *               window.                                                    * <br>     *                                                                          * <br>     *  RETURNS    : TRUE if class registration was successful, FALSE otherwise * <br>     *                                                                          * <br>     *  SIDE EFFECTS: All class variables affected for all windows.             * <br>     *                                                                          * <br>     ****************************************************************************/ <br>     <br>    STATICFN BOOL NEAR InitApplication(VOID) <br>    { <br>        WNDCLASS wc; <br>     <br>        /* assign values and register the parent window class */ <br>        wc.style = 0; <br>        wc.lpfnWndProc = MainWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = ghInst; <br>        wc.hIcon = LoadIcon(ghInst, MAKEINTRESOURCE(IDICON_IMAGEDIT)); <br>        wc.hCursor =  LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>        wc.lpszMenuName = "imagedit"; <br>        wc.lpszClassName = szMainClass; <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>     <br>        wc.style = CS_DBLCLKS; <br>        wc.lpfnWndProc = ColorBoxWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = ghInst; <br>        wc.hIcon = NULL; <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = GetStockObject(LTGRAY_BRUSH); <br>        wc.lpszMenuName = (LPSTR)NULL; <br>        wc.lpszClassName = szColorBoxClass; <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>     <br>        wc.style = 0; <br>        wc.lpfnWndProc = ColorLRWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = ghInst; <br>        wc.hIcon = NULL; <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = GetStockObject(LTGRAY_BRUSH); <br>        wc.lpszMenuName = (LPSTR)NULL; <br>        wc.lpszClassName = szColorLRClass; <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>     <br>        wc.style = CS_DBLCLKS; <br>        wc.lpfnWndProc = WorkWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = ghInst; <br>        wc.hIcon = NULL; <br>        wc.hCursor = (HCURSOR)NULL; <br>        wc.hbrBackground = (HBRUSH)NULL; <br>        wc.lpszMenuName  = (LPSTR)NULL; <br>        wc.lpszClassName = szWorkClass; <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>     <br>        wc.style = 0; <br>        wc.lpfnWndProc = ToolboxWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = ghInst; <br>        wc.hIcon = NULL; <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = GetStockObject(LTGRAY_BRUSH); <br>        wc.lpszMenuName = NULL; <br>        wc.lpszClassName = szToolboxClass; <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>     <br>        wc.style = 0; <br>        wc.lpfnWndProc = ToolBtnWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = ghInst; <br>        wc.hIcon = NULL; <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName = NULL; <br>        wc.lpszClassName = szToolBtnClass; <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>     <br>        wc.style = 0; <br>        wc.lpfnWndProc = ViewWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = ghInst; <br>        wc.hIcon = NULL; <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = GetStockObject(LTGRAY_BRUSH); <br>        wc.lpszMenuName = NULL; <br>        wc.lpszClassName = szViewClass; <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>     <br>        return TRUE; <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>     *                                                                          * <br>     *  FUNCTION   : InitInstance(lpCmdLine, cmdShow)                           * <br>     *                                                                          * <br>     *  PURPOSE    : Load strings from resource file, make procedure instances  * <br>     *               of all dialog functions, create ImagEdit's windows, color  * <br>     *               "palettes", tool cursors and do a variety of other initial-* <br>     *               izations. Also prepare ImagEdit if started up from cmd line* <br>     *               with an argument. Some of these may be redundant, since a  * <br>     *               lot of pBrush stuff has been retained here.                * <br>     *                                                                          * <br>     *  SIDE EFFECTS: numerous                                                  * <br>     *                                                                          * <br>     ****************************************************************************/ <br>     <br>    STATICFN BOOL NEAR InitInstance( <br>        LPSTR lpCmdLine, <br>        INT cmdShow) <br>    { <br>        INT i; <br>        INT iScrollBarWidth;        /* width of vertical scrollbar */ <br>        INT iScrollBarHeight;       /* height of horizontal scrollbar */ <br>        INT iScreenWid; <br>        INT iScreenHgt;             /* full screen width and height */ <br>        INT x; <br>        INT y; <br>        INT cx; <br>        INT cy; <br>        BOOL fMaximized; <br>        RECT rcColor; <br>        RECT rcClient; <br>        RECT rc; <br>        POINT pt; <br>     <br>        /* <br>         * Load the "Out of memory." string now, since we may not be able to <br>         * load it if/when it needs to be displayed. <br>         */ <br>        ids(IDS_OUTOFMEMORY); <br>     <br>        /* <br>         * Register for Pen Windows, if it is present. <br>         */ <br>        PenWinRegister(); <br>     <br>        /* register private ImagEdit clipboard format for icons and cursors */ <br>        if (!(ClipboardFormat = RegisterClipboardFormat("ImagEdit"))) <br>            return FALSE; <br>     <br>        if (!(haccelTbl = LoadAccelerators(ghInst, "imagedit"))) <br>            return FALSE; <br>     <br>        hcurWait = LoadCursor(NULL, IDC_WAIT); <br>        gaTools[TOOL_PENCIL].hcur = <br>                LoadCursor(ghInst, MAKEINTRESOURCE(IDCUR_PENCIL)); <br>        gaTools[TOOL_BRUSH].hcur = <br>                LoadCursor(ghInst, MAKEINTRESOURCE(IDCUR_BRUSH)); <br>        gaTools[TOOL_SELECT].hcur = <br>        gaTools[TOOL_LINE].hcur = <br>        gaTools[TOOL_RECT].hcur = <br>        gaTools[TOOL_SOLIDRECT].hcur = <br>        gaTools[TOOL_CIRCLE].hcur = <br>        gaTools[TOOL_SOLIDCIRCLE].hcur = <br>                LoadCursor(ghInst, MAKEINTRESOURCE(IDCUR_CROSS)); <br>        gaTools[TOOL_FLOODFILL].hcur = <br>                LoadCursor(ghInst, MAKEINTRESOURCE(IDCUR_FLOOD)); <br>        gaTools[TOOL_HOTSPOT].hcur = <br>                LoadCursor(ghInst, MAKEINTRESOURCE(IDCUR_HOTSPOT)); <br>     <br>        /* <br>         * Select the default tool.  Since the toolbox is not created yet, <br>         * this just sets up some globals. <br>         */ <br>        ToolboxSelectTool(TOOL_FIRST); <br>     <br>        /* <br>         * Create a dark gray pen for use in borders later. <br>         */ <br>        if (!(hpenDarkGray = CreatePen(PS_SOLID, 1, RGB_DARKGRAY))) <br>            return FALSE; <br>     <br>        /* <br>         * Initialize the two color palettes to the default colors. <br>         */ <br>        for (i = 0; i &lt; COLORSMAX; i++) { <br>            gargbColor[i] = gargbDefaultColor[i]; <br>            gargbMono[i] = gargbDefaultMono[i]; <br>        } <br>     <br>        /* get some system parameters */ <br>        iScrollBarWidth  = GetSystemMetrics(SM_CXVSCROLL); <br>        iScrollBarHeight = GetSystemMetrics(SM_CYHSCROLL); <br>        iScreenWid       = GetSystemMetrics(SM_CXFULLSCREEN); <br>        iScreenHgt       = GetSystemMetrics(SM_CYFULLSCREEN); <br>        gcyBorder = GetSystemMetrics(SM_CYBORDER); <br>     <br>        /* <br>         * Build the help file name path.  Assume the help file is in the <br>         * same directory as the executable. <br>         */ <br>        GetModuleFileName(ghInst, gszHelpFile, CCHMAXPATH); <br>        *FileInPath(gszHelpFile) = '\0'; <br>        lstrcat(gszHelpFile, ids(IDS_HELPFILE)); <br>     <br>        /* <br>         * Register the message for help from the common dialogs. <br>         */ <br>        gmsgHelp = RegisterWindowMessage(HELPMSGSTRING); <br>     <br>        /* <br>         * Hook the message filter stream so that we can detect F1 keystrokes. <br>         */ <br>        lpfnMsgFilterHookFunc = <br>                MakeProcInstance((FARPROC)MsgFilterHookFunc, ghInst); <br>        ghhkMsgFilter = <br>                SetWindowsHook(WH_MSGFILTER, (HOOKPROC)lpfnMsgFilterHookFunc); <br>     <br>        if (!ReadWindowPos(szAppPos, &amp;x, &amp;y, &amp;cx, &amp;cy, &amp;fMaximized)) { <br>            x = 2 * iScrollBarWidth; <br>            y = iScrollBarHeight; <br>            cx = min(iScreenWid - (4 * iScrollBarWidth), MAXDEFAULTAPPCX); <br>            cy = min(iScreenHgt - (6 * iScrollBarHeight), MAXDEFAULTAPPCY); <br>            fMaximized = FALSE; <br>        } <br>     <br>        /* create parent window */ <br>        ghwndMain = CreateWindow(szMainClass, ids(IDS_PGMTITLE), <br>                WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, <br>                x, y, cx, cy, NULL, NULL, ghInst, NULL); <br>     <br>        if (ghwndMain == NULL) { <br>            Message(MSG_OUTOFMEMORY); <br>            return FALSE; <br>        } <br>     <br>        /* <br>         * Read the preferences data saved in the ini file. <br>         */ <br>        ReadEnv(); <br>     <br>        /* <br>         * Create the Toolbox and the View window (invisible). <br>         */ <br>        ToolboxCreate(); <br>        ViewCreate(); <br>     <br>        lpfnColorDlgProc = (WNDPROC)MakeProcInstance( <br>                (FARPROC)ColorDlgProc, ghInst); <br>        ghwndColor = CreateDialog(ghInst, MAKEINTRESOURCE(DID_COLOR), <br>                ghwndMain, lpfnColorDlgProc); <br>     <br>        ghwndWork = CreateWindow(szWorkClass, NULL, <br>                WS_CHILD | WS_BORDER, <br>                0, 0, 0, 0, <br>                ghwndMain, <br>                NULL, ghInst, NULL); <br>     <br>        /* <br>         * Build the device table. <br>         */ <br>        InitDeviceList(); <br>     <br>        SetColorPalette(gnColors, giType, TRUE); <br>        SetScreenColor(grgbScreenDefault); <br>     <br>        if (!ReadWindowPos(szColorPos, &amp;x, &amp;y, &amp;cx, &amp;cy, &amp;fMaximized)) { <br>            /* <br>             * The previous position of the Color palette couldn't be found. <br>             * Position the palette just below the bottom left corner of the <br>             * client area of the editor, but make sure it is completely <br>             * visible. <br>             */ <br>            GetWindowRect(ghwndColor, &amp;rcColor); <br>            GetClientRect(ghwndMain, &amp;rcClient); <br>            cx = rcColor.right - rcColor.left; <br>            cy = rcColor.bottom - rcColor.top; <br>            pt.x = rcClient.left + (2 * PALETTEMARGIN); <br>            pt.y = rcClient.bottom + (2 * PALETTEMARGIN); <br>            ClientToScreen(ghwndMain, &amp;pt); <br>            SetRect(&amp;rc, pt.x, pt.y, pt.x + cx, pt.y + cy); <br>            FitRectToScreen(&amp;rc); <br>            x = rc.left; <br>            y = rc.top; <br>        } <br>     <br>        SetWindowPos(ghwndColor, NULL, x, y, 0, 0, <br>                SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER); <br>     <br>        SetFileName(NULL); <br>     <br>        /* <br>         * If the app was saved when maximized (and they didn't start it up <br>         * with some kind of an option to have it minimized or in some <br>         * other funny initial state from the shell), then cause it to <br>         * be maximized when shown. <br>         */ <br>        if (fMaximized &amp;&amp; (cmdShow == SW_SHOWNORMAL || cmdShow == SW_SHOW)) <br>            cmdShow = SW_SHOWMAXIMIZED; <br>     <br>        ShowWindow(ghwndMain, cmdShow); <br>        UpdateWindow(ghwndMain); <br>     <br>        /* <br>         * Did the user start this app minimized from the program manager? <br>         */ <br>        if (IsIconic(ghwndMain)) { <br>            /* <br>             * Set a flag.  The showing of the palettes will be deferred <br>             * until the app is restored. <br>             */ <br>            fStartAsIcon = TRUE; <br>        } <br>        else { <br>            /* <br>             * If they had the Toolbox/Color Palette before, show them now. <br>             */ <br>            ToolboxShow(gfShowToolbox); <br>            ColorShow(gfShowColor); <br>        } <br>     <br>        /* <br>         * If there was a command line argument specified, try and open <br>         * it as the initial file. <br>         */ <br>        if (__argc &gt; 1) <br>            OpenCmdLineFile(__argv[1]); <br>     <br>        return TRUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PenWinRegister <br>    * <br>    * This function will register for Pen Windows, if it is present. <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR PenWinRegister(VOID) <br>    { <br>        HANDLE hmod; <br>     <br>        if (!(hmod = (HANDLE)GetSystemMetrics(SM_PENWINDOWS))) <br>            return; <br>     <br>        if (lpfnRegisterPenApp = <br>                (LPFNPENWIN)GetProcAddress(hmod, "RegisterPenApp")) <br>            (*lpfnRegisterPenApp)(1, TRUE);     // Be Pen-Enhanced! <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * MainWndProc <br>    * <br>    * Main window procedure for ImagEdit. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    WINDOWPROC MainWndProc( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        switch (msg) { <br>            case WM_CREATE: <br>                { <br>                    RECT rc; <br>     <br>                    /* <br>                     * Create the PropBar window. <br>                     */ <br>                    lpfnPropBarDlgProc = (WNDPROC)MakeProcInstance( <br>                            (FARPROC)PropBarDlgProc, ghInst); <br>                    CreateDialog(ghInst, MAKEINTRESOURCE(DID_PROPBAR), hwnd, <br>                            lpfnPropBarDlgProc); <br>     <br>                    /* <br>                     * Save away its height for sizing later (like when <br>                     * the app is minimized then restored). <br>                     */ <br>                    GetWindowRect(ghwndPropBar, &amp;rc); <br>                    gcyPropBar = rc.bottom - rc.top; <br>                } <br>     <br>                break; <br>     <br>            case WM_NCCALCSIZE: <br>                /* <br>                 * Save away what is going to be the new window position. <br>                 */ <br>                if (!IsIconic(hwnd) &amp;&amp; !IsZoomed(hwnd)) <br>                    grcAppPos = *((LPRECT)lParam); <br>     <br>                /* <br>                 * Now let the DefWindowProc calculate the client area normally. <br>                 */ <br>                goto DoDefault; <br>     <br>            case WM_ACTIVATE: <br>                /* <br>                 * If the main window is getting activated, there is no <br>                 * currently active dialog. <br>                 */ <br>                if (GET_WM_ACTIVATE_STATE(wParam, lParam)) <br>                    gidCurrentDlg = 0; <br>     <br>                goto DoDefault; <br>     <br>            case WM_INITMENU: <br>                if (GetMenu(ghwndMain) == (HMENU)wParam) <br>                    InitMenu((HMENU)wParam); <br>     <br>                break; <br>     <br>            case WM_COMMAND: <br>                MenuCmd(GET_WM_COMMAND_ID(wParam, lParam)); <br>                break; <br>     <br>            case WM_SIZE: <br>                SizeRibbons(hwnd); <br>     <br>                if (wParam != SIZEICONIC) <br>                    WorkReset(); <br>     <br>                /* <br>                 * Did the app start minimized and is it being restored <br>                 * for the first time?  If so, show the palettes as <br>                 * the user has requested. <br>                 */ <br>                if (fStartAsIcon &amp;&amp; !IsIconic(hwnd)) { <br>                    ToolboxShow(gfShowToolbox); <br>                    ColorShow(gfShowColor); <br>                    fStartAsIcon = FALSE; <br>                } <br>     <br>                break; <br>     <br>            case WM_MENUSELECT: <br>                if (GET_WM_MENUSELECT_FLAGS(wParam, lParam) &amp; <br>                        (MF_POPUP | MF_SYSMENU)) <br>                    gMenuSelected = 0; <br>                else <br>                    gMenuSelected = GET_WM_MENUSELECT_CMD(wParam, lParam); <br>     <br>                break; <br>     <br>            case WM_CLOSE: <br>                if (VerifySaveFile()) { <br>                    DestroyWindow(hwnd); <br>                    CleanUp(); <br>                } <br>     <br>                break; <br>     <br>            case WM_DESTROY: <br>                /* <br>                 * Save the position of the app's window. <br>                 */ <br>                WriteWindowPos(&amp;grcAppPos, IsZoomed(hwnd), szAppPos); <br>     <br>                WinHelp(ghwndMain, gszHelpFile, HELP_QUIT, 0L); <br>     <br>                PostQuitMessage(0); <br>     <br>                break; <br>     <br>            case WM_QUERYENDSESSION: <br>                return VerifySaveFile(); <br>     <br>            default: <br>                /* <br>                 * Is this the registered help message from one of the common <br>                 * dialogs?  If so, show the help for it. <br>                 * <br>                 * The check to be sure gmsgHelp is non-zero is just in <br>                 * case the call to register the help message failed <br>                 * (it will return zero) and there happens to be a zero <br>                 * message that gets sent to this window somehow. <br>                 */ <br>                if (msg == gmsgHelp &amp;&amp; gmsgHelp) { <br>                    ShowHelp(FALSE); <br>                    return 0; <br>                } <br>     <br>            DoDefault: <br>                return DefWindowProc(hwnd, msg, wParam, lParam); <br>        } <br>     <br>        return 0; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ReadWindowPos <br>    * <br>    * This function retrieves the saved window position for a window and <br>    * returns it in the specified variables.  It is used between sessions <br>    * to restore the application windows to the position they had when <br>    * the editor was last exited. <br>    * <br>    * Returns TRUE if the position could be read, or FALSE otherwise. <br>    * If FALSE is returned, the values in the specified variables are <br>    * not valid!  The caller must be able to handle a FALSE return and <br>    * supply a default position for the window. <br>    * <br>    * Arguments: <br>    *   PSTR pstrKeyName  - KeyName the position was saved under. <br>    *   PINT px           - Saved x position. <br>    *   PINT py           - Saved y position. <br>    *   PINT pcx          - Saved width. <br>    *   PINT pcy          - Saved height. <br>    *   BOOL *pfMaximized - Set to TRUE if window was maximized when saved. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL ReadWindowPos( <br>        PSTR pstrKeyName, <br>        PINT px, <br>        PINT py, <br>        PINT pcx, <br>        PINT pcy, <br>        BOOL *pfMaximized) <br>    { <br>        static CHAR szSep[] = " ,"; <br>        CHAR szBuf[CCHTEXTMAX]; <br>        PSTR pstr; <br>     <br>        if (!GetPrivateProfileString(ids(IDS_APPNAME), <br>                pstrKeyName, "", szBuf, CCHTEXTMAX, ids(IDS_IMAGEDITINI))) <br>            return FALSE; <br>     <br>        if (!(pstr = strtok(szBuf, szSep))) <br>            return FALSE; <br>     <br>        *px = atoi(pstr); <br>     <br>        if (!(pstr = strtok(NULL, szSep))) <br>            return FALSE; <br>     <br>        *py = atoi(pstr); <br>     <br>        if (!(pstr = strtok(NULL, szSep))) <br>            return FALSE; <br>     <br>        *pcx = atoi(pstr); <br>     <br>        if (!(pstr = strtok(NULL, szSep))) <br>            return FALSE; <br>     <br>        *pcy = atoi(pstr); <br>     <br>        /* <br>         * If there is a "1" following the coordinates, the window was <br>         * maximized when it was saved. <br>         */ <br>        *pfMaximized = FALSE; <br>        if ((pstr = strtok(NULL, szSep)) &amp;&amp; atoi(pstr) == 1) <br>            *pfMaximized = TRUE; <br>     <br>        /* <br>         * Don't allow a zero sized window. <br>         */ <br>        if (*pcx == 0 || *pcy == 0) <br>            return FALSE; <br>     <br>        /* <br>         * Return success. <br>         */ <br>        return TRUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * WriteWindowPos <br>    * <br>    * This function writes the position of a window to the <br>    * editor's profile file under the specified keyname. <br>    * The ReadWindowPos function is the counterpart of this <br>    * function. <br>    * <br>    * Arguments: <br>    *   PRECT prc        - Rectangle for the "restored" window size. <br>    *   BOOL fMaximized  - TRUE if the window is maximized. <br>    *   PSTR pstrKeyName - KeyName to save the position under. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID WriteWindowPos( <br>        PRECT prc, <br>        BOOL fMaximized, <br>        PSTR pstrKeyName) <br>    { <br>        CHAR szBuf[CCHTEXTMAX]; <br>     <br>        wsprintf(szBuf, "%d %d %d %d", prc-&gt;left, prc-&gt;top, <br>                prc-&gt;right - prc-&gt;left, prc-&gt;bottom - prc-&gt;top); <br>     <br>        if (fMaximized) <br>            strcat(szBuf, " 1"); <br>     <br>        WritePrivateProfileString(ids(IDS_APPNAME), <br>                pstrKeyName, szBuf, ids(IDS_IMAGEDITINI)); <br>    } <br>     <br>     <br>     <br>    /************************************************************************* <br>    * ReadEnv <br>    * <br>    * This function initializes variables from their counterparts <br>    * in the private profile file for ImagEdit.  The application <br>    * merely needs to construct an array of INIENTRY structures <br>    * to describe the variables that must be initialized. <br>    * <br>    * Note that the original value read from the profile is saved when <br>    * it is read.  This allows us to optimize what needs to be written <br>    * out with WriteEnv. <br>    * <br>    * History: <br>    * <br>    *************************************************************************/ <br>     <br>    STATICFN VOID NEAR ReadEnv(VOID) <br>    { <br>        register INT i; <br>        HDC hdc; <br>        CHAR szBuf[CCHTEXTMAX]; <br>        DWORD rgb; <br>     <br>        for (i = 0; gaie[i].pstrKeyName; i++) { <br>            *gaie[i].pnVar = gaie[i].nSave = <br>                    GetPrivateProfileInt(ids(IDS_APPNAME), <br>                    gaie[i].pstrKeyName, gaie[i].nDefault, <br>                    ids(IDS_IMAGEDITINI)); <br>        } <br>     <br>        /* <br>         * Look for the saved screen color. <br>         */ <br>        if (GetPrivateProfileString(ids(IDS_APPNAME), szrgbScreen, "", <br>                szBuf, CCHTEXTMAX, ids(IDS_IMAGEDITINI))) { <br>            rgb = (DWORD)atol(szBuf); <br>        } <br>        else { <br>            /* <br>             * The last screen color was not found.  The default will be <br>             * the current system screen background color. <br>             */ <br>            rgb = GetSysColor(COLOR_BACKGROUND); <br>        } <br>     <br>        /* <br>         * Make the ImagEdit default screen color a solid color. <br>         */ <br>        hdc = GetDC(ghwndMain); <br>        grgbScreenDefault = GetNearestColor(hdc, rgb); <br>        ReleaseDC(ghwndMain, hdc); <br>    } <br>     <br>     <br>     <br>    /************************************************************************* <br>    * WriteEnv <br>    * <br>    * This function is the counterpart to ReadEnv.  It saves values <br>    * in the profile file. <br>    * <br>    * History: <br>    * <br>    *************************************************************************/ <br>     <br>    STATICFN VOID NEAR WriteEnv(VOID) <br>    { <br>        register INT i; <br>        CHAR szBuf[CCHTEXTMAX]; <br>     <br>        for (i = 0; gaie[i].pstrKeyName; i++) { <br>            /* <br>             * Has the user changed the value since it was read? <br>             */ <br>            if (gaie[i].nSave != *gaie[i].pnVar) { <br>                /* <br>                 * If the new value is the same as the default value, <br>                 * erase the entry from the ini file.  Otherwise, <br>                 * write the user-specified value out. <br>                 */ <br>                if (*gaie[i].pnVar == gaie[i].nDefault) { <br>                    WritePrivateProfileString(ids(IDS_APPNAME), <br>                            gaie[i].pstrKeyName, NULL, ids(IDS_IMAGEDITINI)); <br>                } <br>                else { <br>                    itoa(*gaie[i].pnVar, szBuf, 10); <br>                    WritePrivateProfileString(ids(IDS_APPNAME), <br>                            gaie[i].pstrKeyName, szBuf, ids(IDS_IMAGEDITINI)); <br>                } <br>            } <br>        } <br>     <br>        /* <br>         * Save the current screen color. <br>         */ <br>        ltoa((LONG)grgbScreen, szBuf, 10); <br>        WritePrivateProfileString(ids(IDS_APPNAME), <br>                szrgbScreen, szBuf, ids(IDS_IMAGEDITINI)); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * SizeRibbons <br>    * <br>    * This function positions and sizes the child ribbons in the editor. <br>    * It needs to be called any time the size of the main windows changes. <br>    * <br>    * Arguments: <br>    *   HWND hwnd - Parent window handle. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR SizeRibbons( </code></pre>
<p>
</p>
<pre><code>HWND hwnd) <br>    { <br>        RECT rcClient; <br>     <br>        if (ghwndPropBar &amp;&amp; !IsIconic(hwnd)) { <br>            /* <br>             * Get the client area. <br>             */ <br>            GetClientRect(hwnd, &amp;rcClient); <br>     <br>            /* <br>             * Size/move the PropBar window to fit <br>             * the new client area. <br>             */ <br>            SetWindowPos(ghwndPropBar, NULL, <br>                    0, 0, <br>                    rcClient.right - rcClient.left, <br>                    min(rcClient.bottom - rcClient.top, gcyPropBar), <br>                    SWP_NOACTIVATE | SWP_NOZORDER); <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * CleanUp <br>    * <br>    * Cleans up all the resources allocated by the editor. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR CleanUp(VOID) <br>    { <br>        WriteEnv(); <br>     <br>        if (ghdcANDMask) { <br>            DeleteDC(ghdcANDMask); <br>            DeleteObject(ghbmANDMask); <br>        } <br>        if (ghdcImage) { <br>            DeleteDC(ghdcImage); <br>            DeleteObject(ghbmImage); <br>        } <br>     <br>        ImageFreeUndo(); <br>     <br>        if (hpenDarkGray) <br>            DeleteObject(hpenDarkGray); <br>     <br>        if (ghbrLeft) <br>            DeleteObject(ghbrLeft); <br>     <br>        if (ghbrLeftSolid) <br>            DeleteObject(ghbrLeftSolid); <br>     <br>        if (ghbrRight) <br>            DeleteObject(ghbrRight); <br>     <br>        if (ghbrRightSolid) <br>            DeleteObject(ghbrRightSolid); <br>     <br>        if (ghbrScreen) <br>            DeleteObject(ghbrScreen); <br>     <br>        if (ghbrInverse) <br>            DeleteObject(ghbrInverse); <br>     <br>        if (ghpenLeft) <br>            DeleteObject(ghpenLeft); <br>     <br>        if (ghpenRight) <br>            DeleteObject(ghpenRight); <br>     <br>        ImageLinkFreeList(); <br>     <br>        if (lpfnMsgFilterHookFunc) { <br>            UnhookWindowsHook(WH_MSGFILTER, (HOOKPROC)lpfnMsgFilterHookFunc); <br>            FreeProcInstance(lpfnMsgFilterHookFunc); <br>        } <br>     <br>        if (lpfnPropBarDlgProc) <br>            FreeProcInstance((FARPROC)lpfnPropBarDlgProc); <br>     <br>        if (lpfnColorDlgProc) <br>            FreeProcInstance((FARPROC)lpfnColorDlgProc); <br>    } <br> <br>/**************************************************************************** <br>    My_mbschr:  strchr() DBCS version <br>****************************************************************************/ <br>unsigned char * _CRTAPI1 My_mbschr( <br>    unsigned char *psz, unsigned short uiSep) <br>{ <br>    while (*psz != '\0' &amp;&amp; *psz != uiSep) { <br>        psz = CharNext(psz); <br>    } <br>    if (*psz == '\0' &amp;&amp; uiSep != '\0') { <br>        return NULL; <br>    } else { <br>        return psz; <br>    } <br>} <br>/**************************************************************************** <br>    My_mbstok:  strtok() DBCS version <br>****************************************************************************/ <br>unsigned char * _CRTAPI1 My_mbstok( <br>    unsigned char *pszSrc, unsigned char *pszSep) <br>{ <br>    static char *pszSave = NULL; <br>    char *pszHead; <br>    char *psz; <br> <br>    if (pszSrc == NULL) { <br>        if (pszSave == NULL) { <br>            return NULL; <br>        } else { <br>            psz = pszSave; <br>        } <br>    } else { <br>        psz = pszSrc; <br>    } <br> <br>    /*********************************************/ <br>    /* Skip delimiters to find a head of a token */ <br>    /*********************************************/ <br>    while (*psz) { <br>        if (IsDBCSLeadByte(*psz)) { <br>            break; <br>        } else if (NULL == My_mbschr(pszSep, *psz)) { <br>            break; <br>        } <br>        psz++; <br>    } <br>    if (*psz == '\0') { <br>        //No more token <br>        return (pszSave = NULL); <br>    } <br>    pszHead = psz; <br> <br>    /******************************/ <br>    /* Search a Tail of the token */ <br>    /******************************/ <br>    while (*psz) { <br>        if (IsDBCSLeadByte(*psz)) { <br>            psz += 2; <br>            continue; <br>        } else if (NULL != My_mbschr(pszSep, *psz)) { <br>            break; <br>        } <br>        psz++; <br>    } <br>    if (*psz == '\0') { <br>        pszSave = NULL; <br>    } else { <br>        //Found next delimiter <br>        pszSave = psz + 1; <br>        *psz = '\0'; <br>    } <br>    return pszHead; <br>} <br>/**************************************************************************** <br>    My_mbsncat: <br>****************************************************************************/ <br>unsigned char * _CRTAPI1 My_mbsncat( <br>    unsigned char *psz1, const unsigned char *psz2, size_t Length) <br>{ <br>    int nLen = (int)Length; <br>    unsigned char *pszSv = psz1; <br> <br>    while ('\0' != *psz1) { <br>        psz1++; <br>    } <br> <br>    while (0 &lt; nLen) { <br>        if (*psz2 == '\0') { <br>            *psz1++ = '\0'; <br>            nLen--; <br>        } else if (IsDBCSLeadByte(*psz2)) { <br>            if (nLen == 1) { <br>                *psz1 = '\0'; <br>            } else { <br>                *psz1++ = *psz2++; <br>                *psz1++ = *psz2++; <br>            } <br>            nLen -= 2; <br>        } else { <br>            *psz1++ = *psz2++; <br>            nLen--; <br>        } <br>    } <br>    return pszSv; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
