<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MENUCMD.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5483"></a>MENUCMD.C</h2>
<pre><code>/****************************************************************************/ <br>    /*                                                                          */ <br>    /*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>    /*                           All Rights Reserved                            */ <br>    /*                                                                          */ <br>    /****************************************************************************/ <br>    /****************************** Module Header ******************************* <br>    * Module Name: menucmd.c <br>    * <br>    * Contains routines to dispatch the menu commands. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    #include "imagedit.h" <br>    #include "dialogs.h" <br>    #include "ids.h" <br>     <br>    #include &lt;direct.h&gt; <br>    #include &lt;string.h&gt; <br>     <br>    STATICFN INT GetHelpContext(INT idSubject, PHELPMAP phmap); <br>     <br>     <br>     <br>    /************************************************************************ <br>    * InitMenu <br>    * <br>    * This function grays/enables and checks/unchecks the menu items <br>    * appropriately for the given state. <br>    * <br>    * Arguments: <br>    *   HMENU hMenu - The menu handle. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID InitMenu( <br>        HMENU hMenu) <br>    { <br>        BOOL fEnable; <br>        INT i; <br>     <br>        MyEnableMenuItem(hMenu, MENU_FILE_SAVE, fImageDirty || fFileDirty); <br>        MyEnableMenuItem(hMenu, MENU_FILE_SAVEAS, gpImageHead); <br>        MyEnableMenuItem(hMenu, MENU_FILE_LOADCOLORS, gnColors != 2); <br>        MyEnableMenuItem(hMenu, MENU_FILE_SAVECOLORS, gnColors != 2); <br>     <br>        /* <br>         * Only enable the option to restore the default colors if this <br>         * is not a monochrome palette and at least one of the colors <br>         * has been changed. <br>         */ <br>        fEnable = FALSE; <br>        if (gnColors != 2) { <br>            for (i = 0; i &lt; COLORSMAX; i++) { <br>                if (gargbColor[i] != gargbDefaultColor[i]) { <br>                    fEnable = TRUE; <br>                    break; <br>                } <br>            } <br>        } <br>     <br>        MyEnableMenuItem(hMenu, MENU_FILE_DEFAULTCOLORS, fEnable); <br>     <br>        MyEnableMenuItem(hMenu, MENU_EDIT_UNDO, ghbmUndo); <br>        MyEnableMenuItem(hMenu, MENU_EDIT_RESTORE, <br>                gpImageCur &amp;&amp; gpImageCur-&gt;DIBPtr &amp;&amp; fImageDirty); <br>        MyEnableMenuItem(hMenu, MENU_EDIT_COPY, gpImageCur); <br>        MyEnableMenuItem(hMenu, MENU_EDIT_PASTE, <br>                gpImageCur &amp;&amp; IsClipboardFormatAvailable(CF_BITMAP)); <br>        MyEnableMenuItem(hMenu, MENU_EDIT_CLEAR, gpImageCur); <br>     <br>        /* <br>         * We can add new images if the current image is not a bitmap, <br>         * and we have possible new images to add, and there is a current <br>         * file being edited.  This last case is checked by looking to <br>         * see that there is either a current file name, or there is a <br>         * current image (the case for new files). <br>         */ <br>        MyEnableMenuItem(hMenu, MENU_EDIT_NEWIMAGE, <br>                giType != FT_BITMAP &amp;&amp; <br>                ((giType == FT_ICON) ? <br>                (gnImages &lt; gnIconDevices) : (gnImages &lt; gnCursorDevices)) &amp;&amp; <br>                (gpImageCur || gpszFileName)); <br>     <br>        MyEnableMenuItem(hMenu, MENU_EDIT_SELECTIMAGE, <br>                giType != FT_BITMAP &amp;&amp; gnImages &gt; 0); <br>        MyEnableMenuItem(hMenu, MENU_EDIT_DELETEIMAGE, <br>                giType != FT_BITMAP &amp;&amp; gnImages &gt; 0); <br>     <br>        MyCheckMenuItem(hMenu, MENU_OPTIONS_GRID, gfGrid); <br>        MyCheckMenuItem(hMenu, MENU_OPTIONS_BRUSH2, gnBrushSize == 2); <br>        MyCheckMenuItem(hMenu, MENU_OPTIONS_BRUSH3, gnBrushSize == 3); <br>        MyCheckMenuItem(hMenu, MENU_OPTIONS_BRUSH4, gnBrushSize == 4); <br>        MyCheckMenuItem(hMenu, MENU_OPTIONS_BRUSH5, gnBrushSize == 5); <br>        MyCheckMenuItem(hMenu, MENU_OPTIONS_SHOWCOLOR, gfShowColor); <br>        MyCheckMenuItem(hMenu, MENU_OPTIONS_SHOWVIEW, gfShowView); <br>        MyCheckMenuItem(hMenu, MENU_OPTIONS_SHOWTOOLBOX, gfShowToolbox); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * MenuCmd <br>    * <br>    * Dispatches all the menu commands. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID MenuCmd( <br>        INT item) <br>    { <br>        switch (item) { <br>     <br>            /* <br>             * File menu ---------------------------------------------------- <br>             */ <br>     <br>            case MENU_FILE_OPEN: <br>                if (VerifySaveFile()) <br>                    OpenAFile(); <br>     <br>                break; <br>     <br>            case MENU_FILE_NEW: <br>                if (VerifySaveFile()) { <br>                    if (DlgBox(DID_RESOURCETYPE, <br>                            (WNDPROC)ResourceTypeDlgProc) == IDOK) { <br>                        /* <br>                         * Clear out the current resource. <br>                         */ <br>                        ClearResource(); <br>     <br>                        if (iNewFileType == FT_BITMAP) <br>                            DlgBox(DID_BITMAPSIZE, (WNDPROC)BitmapSizeDlgProc); <br>                        else <br>                            ImageNewDialog(iNewFileType); <br>                    } <br>                } <br>     <br>                break; <br>     <br>            case MENU_FILE_SAVE: <br>                SaveFile(FALSE); <br>                break; <br>     <br>            case MENU_FILE_SAVEAS: <br>                SaveFile(TRUE); <br>                break; <br>     <br>            case MENU_FILE_LOADCOLORS: <br>                LoadColorFile(); <br>                break; <br>     <br>            case MENU_FILE_SAVECOLORS: <br>                SaveColorFile(); <br>                break; <br>     <br>            case MENU_FILE_DEFAULTCOLORS: <br>                RestoreDefaultColors(); <br>                break; <br>     <br>            case MENU_FILE_EXIT: <br>                SendMessage(ghwndMain, WM_SYSCOMMAND, SC_CLOSE, 0L); <br>                break; <br>     <br>            /* <br>             * Edit menu ---------------------------------------------------- <br>             */ <br>     <br>            case MENU_EDIT_UNDO: <br>                ImageUndo(); <br>                break; <br>     <br>            case MENU_EDIT_RESTORE: <br>                /* <br>                 * Reopen the most recently retained image (without <br>                 * prompting for a save). <br>                 */ <br>                ImageOpen2(gpImageCur); <br>                break; <br>     <br>            case MENU_EDIT_COPY: <br>                CopyImageClip(); <br>                break; <br>     <br>            case MENU_EDIT_PASTE: <br>                PasteImageClip(); <br>                break; <br>     <br>            case MENU_EDIT_CLEAR: <br>                ImageUpdateUndo(); <br>                ImageDCClear(); <br>                ViewUpdate(); <br>                break; <br>     <br>            case MENU_EDIT_NEWIMAGE: <br>                ImageNewDialog(giType); <br>                break; <br>     <br>            case MENU_EDIT_SELECTIMAGE: <br>                ImageSelectDialog(); <br>                break; <br>     <br>            case MENU_EDIT_DELETEIMAGE: <br>                ImageDelete(); <br>                break; <br>     <br>            /* <br>             * Options menu ------------------------------------------------- <br>             */ <br>     <br>            case MENU_OPTIONS_GRID: <br>                /* <br>                 * Toggle the grid state. <br>                 */ <br>                gfGrid ^= TRUE; <br>     <br>                /* <br>                 * Repaint the workspace window to show/remove the grid. <br>                 */ <br>                WorkUpdate(); <br>     <br>                break; <br>     <br>            case MENU_OPTIONS_BRUSH2: <br>            case MENU_OPTIONS_BRUSH3: <br>            case MENU_OPTIONS_BRUSH4: <br>            case MENU_OPTIONS_BRUSH5: <br>                switch (item) { <br>                    case MENU_OPTIONS_BRUSH2: <br>                        gnBrushSize = 2; <br>                        break; <br>     <br>                    case MENU_OPTIONS_BRUSH3: <br>                        gnBrushSize = 3; <br>                        break; <br>     <br>                    case MENU_OPTIONS_BRUSH4: <br>                        gnBrushSize = 4; <br>                        break; <br>     <br>                    case MENU_OPTIONS_BRUSH5: <br>                        gnBrushSize = 5; <br>                        break; <br>                } <br>     <br>                break; <br>     <br>            case MENU_OPTIONS_SHOWCOLOR: <br>                /* <br>                 * Toggle the state of the color palette. <br>                 */ <br>                gfShowColor = gfShowColor ? FALSE : TRUE; <br>                ColorShow(gfShowColor); <br>                break; <br>     <br>            case MENU_OPTIONS_SHOWVIEW: <br>                /* <br>                 * Toggle the state of the view window. <br>                 */ <br>                gfShowView = gfShowView ? FALSE : TRUE; <br>                ViewShow(gfShowView); <br>                break; <br>     <br>            case MENU_OPTIONS_SHOWTOOLBOX: <br>                /* <br>                 * Toggle the state of the Toolbox. <br>                 */ <br>                gfShowToolbox = gfShowToolbox ? FALSE : TRUE; <br>                ToolboxShow(gfShowToolbox); <br>                break; <br>     <br>            /* <br>             * Help menu ---------------------------------------------------- <br>             */ <br>     <br>            case MENU_HELP_CONTENTS: <br>                WinHelp(ghwndMain, gszHelpFile, HELP_CONTENTS, 0L); <br>                break; <br>     <br>            case MENU_HELP_SEARCH: <br>                /* <br>                 * Tell winhelp to be sure this app's help file is current, <br>                 * then invoke a search with an empty starting key. <br>                 */ <br>                WinHelp(ghwndMain, gszHelpFile, HELP_FORCEFILE, 0); <br>                WinHelp(ghwndMain, gszHelpFile, HELP_PARTIALKEY, (DWORD)(LPSTR)""); <br>                break; <br>     <br>            case MENU_HELP_ABOUT: <br>                DlgBox(DID_ABOUT, (WNDPROC)AboutDlgProc); <br>                break; <br>     <br>            /* <br>             * Hidden menu commands (accessed by accelerators) -------------- <br>             */ <br>     <br>            case MENU_HIDDEN_TOCOLORPAL: <br>                if (IsWindowVisible(ghwndColor)) <br>                    SetFocus(ghwndColor); <br>     <br>                break; <br>     <br>            case MENU_HIDDEN_TOVIEW: <br>                if (IsWindowVisible(ghwndView)) <br>                    SetFocus(ghwndView); <br>     <br>                break; <br>     <br>            case MENU_HIDDEN_TOTOOLBOX: <br>                if (IsWindowVisible(ghwndToolbox)) <br>                    SetFocus(ghwndToolbox); <br>     <br>                break; <br>     <br>            case MENU_HIDDEN_TOPROPBAR: <br>                SetFocus(ghwndPropBar); <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * MsgFilterHookFunc <br>    * <br>    * This is the exported message filter function that is hooked into <br>    * the message stream for detecting the pressing of the F1 key, at <br>    * which time it calls up the appropriate help. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    DWORD  APIENTRY MsgFilterHookFunc( <br>        INT nCode, <br>        WPARAM wParam, <br>        LPMSG lpMsg) <br>    { <br>        if ((nCode == MSGF_MENU || nCode == MSGF_DIALOGBOX) &amp;&amp; <br>                (lpMsg-&gt;message == WM_KEYDOWN &amp;&amp; lpMsg-&gt;wParam == VK_F1)) { <br>            /* <br>             * Display help. <br>             */ <br>            ShowHelp((nCode == MSGF_MENU) ? TRUE : FALSE); <br>     <br>            /* <br>             * Tell Windows to swallow this message. <br>             */ <br>            return 1; <br>        } <br>     <br>        return DefHookProc(nCode, wParam, (LONG)lpMsg, &amp;ghhkMsgFilter); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ShowHelp <br>    * <br>    * This function is called when the user has requested help.  It will <br>    * look at the menu state (if fMenuHelp is TRUE) or which dialog <br>    * is currently up to determine the help topic, then it calls WinHelp. <br>    * <br>    * Arguments: <br>    *   BOOL fMenuHelp - TRUE if this help is for a menu (help was requested <br>    *                    in the menu modal loop).  If FALSE, general help <br>    *                    or help for a dialog is assumed. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID ShowHelp( <br>        BOOL fMenuHelp) <br>    { <br>        INT nHelpContext = 0; <br>        HWND hwndFocus; <br>     <br>        if (fMenuHelp) { <br>            nHelpContext = GetHelpContext(gMenuSelected, gahmapMenu); <br>        } <br>        else { <br>            /* <br>             * Look for help for the current dialog. <br>             */ <br>            if (gidCurrentDlg) { <br>                nHelpContext = GetHelpContext(gidCurrentDlg, gahmapDialog); <br>            } <br>            else { <br>                /* <br>                 * There is no current dialog.  Is the window with the <br>                 * focus a control on the Properties Bar? <br>                 */ <br>                if ((hwndFocus = GetFocus()) &amp;&amp; IsChild(ghwndPropBar, hwndFocus)) <br>                    nHelpContext = GetHelpContext(DID_PROPBAR, gahmapDialog); <br>            } <br>        } <br>     <br>        /* <br>         * If there is help context, display it.  Otherwise display <br>         * the Contents screen. <br>         */ <br>        if (nHelpContext) <br>            WinHelp(ghwndMain, gszHelpFile, HELP_CONTEXT, nHelpContext); <br>        else <br>            WinHelp(ghwndMain, gszHelpFile, HELP_CONTENTS, 0L); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * GetHelpContext <br>    * <br>    * This function takes a subject and returns its matching help <br>    * context id from the given HELPMAP table. <br>    * <br>    * Arguments: <br>    *   INT idSubject   - ID of the subject to find the help context for. <br>    *   PHELPMAP phmap  - The help map table.  It is assumed that the <br>    *                     last entry in the table has a NULL subject id. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN INT GetHelpContext( <br>        INT idSubject, <br>        PHELPMAP phmap) <br>    { <br>        while (phmap-&gt;idSubject) { <br>            if (phmap-&gt;idSubject == idSubject) <br>                return phmap-&gt;HelpContext; <br>     <br>            phmap++; <br>        } <br>     <br>        return 0; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * AboutDlgProc <br>    * <br>    * This is the About Box dialog procedure. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    DIALOGPROC AboutDlgProc( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        switch (msg) { <br>            case WM_INITDIALOG: <br>                { <br>                    CHAR szVersion[CCHTEXTMAX]; <br>     <br>                    strcpy(szVersion, ids(IDS_VERSION)); <br>                    strcat(szVersion, ids(IDS_VERSIONMINOR)); <br>     <br>    #ifdef DBG <br>                    strcat(szVersion, " (debug)"); <br>    #endif <br>     <br>                    SetDlgItemText(hwnd, DID_ABOUTVERSION, szVersion); <br>                    CenterWindow(hwnd); <br>                } <br>     <br>                return TRUE; <br>     <br>            case WM_COMMAND: <br>                EndDialog(hwnd, IDOK); <br>                return TRUE; <br>     <br>            default: <br>                return FALSE; <br>        } <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
