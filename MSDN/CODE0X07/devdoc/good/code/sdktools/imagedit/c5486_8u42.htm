<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WORKWP.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5492"></a>WORKWP.C</h2>
<pre><code>/*************************************************************************** <br>     *                                                                         * <br>     *  MODULE      : WorkWP.c                                                 * <br>     *                                                                         * <br>     *  DESCRIPTION : Functions controlling the workspace window.              * <br>     *                                                                         * <br>     *  HISTORY     : 6/21/89 LR                                               * <br>     *                                                                         * <br>     ***************************************************************************/ <br>     <br>    #include "imagedit.h" <br>     <br>    #include &lt;stdlib.h&gt; <br>     <br>     <br>    /* <br>     * This structure is used in conjunction with DeltaGenInit() and DeltaGen(). <br>     */ <br>    typedef struct _DELTAGEN { /* dg */ <br>        BOOL fSwap; <br>        INT xf; <br>        INT yf; <br>        INT dx; <br>        INT dy; <br>        INT d; <br>        INT incx; <br>        INT incy; <br>        INT inc1; <br>        INT inc2; <br>    } DELTAGEN; <br>    typedef DELTAGEN *PDELTAGEN; <br>     <br>     <br>    STATICFN VOID NEAR WorkPaint(HWND hwnd); <br>    STATICFN VOID WorkButtonDown(HWND hwnd, UINT msg, PPOINT ppt); <br>    STATICFN VOID WorkButtonMouseMove(HWND hwnd, UINT msg, PPOINT ppt); <br>    STATICFN VOID WorkButtonUp(HWND hwnd, UINT msg, PPOINT ppt); <br>    STATICFN VOID NEAR SnapPointToGrid(PPOINT ppt); <br>    STATICFN VOID DrawToPoint(HWND hwnd, PPOINT ppt, BOOL fBrush); <br>    STATICFN BOOL NEAR DeltaGenInit(PDELTAGEN pdg, INT x0, INT y0, <br>        INT xf, INT yf, PINT px, PINT py); <br>    STATICFN BOOL NEAR DeltaGen(PDELTAGEN pdg, PINT px, PINT py); <br>    STATICFN VOID DrawPoint(HWND hwnd, PPOINT ppt, BOOL fBrush); <br>    STATICFN VOID NEAR RubberBandLine(BOOL fFirstTime); <br>    STATICFN VOID NEAR RectDPDraw(HWND hwnd); <br>    STATICFN VOID NEAR RubberBandRect(BOOL fFirstTime); <br>    STATICFN VOID NEAR CircleDPDraw(HWND hwnd); <br>    STATICFN VOID NEAR RubberBandCircle(BOOL fFirstTime); <br>    STATICFN VOID NEAR MarkHotSpotPosition(INT x, INT y); <br>    STATICFN VOID NEAR StartRubberBanding(HWND hwnd); <br>    STATICFN VOID NEAR EndRubberBanding(HWND hwnd); <br>     <br>     <br>    static BOOL fDrawing = FALSE;           // TRUE if mouse button is down. <br>    static BOOL fLeftButtonDown;            // TRUE if left button was pressed. <br>    static POINT ptStart;                   // Saves the starting point. <br>    static POINT ptEnd;                     // Saves the ending point. <br>    static POINT ptPrev;                    // Saves the previous point. <br>    static HDC hdcRubberBand;               // DC used during rubber banding. <br>    static BOOL fRubberBanding = FALSE;     // Tracking is in progress. <br>     <br>     <br>     <br>    /**************************************************************************** <br>     * WorkWndProc <br>     *                                                                          * <br>     * purpose: Processes basic create and size and paint messages for the      * <br>     *          workspace window. <br>     *                                                                          * <br>     ****************************************************************************/ <br>     <br>    WINDOWPROC WorkWndProc( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        LPCREATESTRUCT cs; <br>        POINT pt; <br>     <br>        switch (msg) { <br>            case WM_CREATE: <br>                /* set up image variables */ <br>                cs = (LPCREATESTRUCT)lParam; <br>                gcxWorkSpace = cs-&gt;cx; <br>                gcyWorkSpace = cs-&gt;cy; <br>                break; <br>     <br>            case WM_SIZE: <br>                gcxWorkSpace = LOWORD(lParam); <br>                gcyWorkSpace = HIWORD(lParam); <br>     <br>                break; <br>     <br>            case WM_PAINT: <br>                WorkPaint(hwnd); <br>                break; <br>     <br>            case WM_MOUSEMOVE: <br>                ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>                WorkButtonMouseMove(hwnd, msg, &amp;pt); <br>                break; <br>     <br>            case WM_RBUTTONDOWN: <br>            case WM_LBUTTONDOWN: <br>                ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>                WorkButtonDown(hwnd, msg, &amp;pt); <br>                break; <br>     <br>            case WM_LBUTTONUP: <br>            case WM_RBUTTONUP: <br>                ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>                WorkButtonUp(hwnd, msg, &amp;pt); <br>                break; <br>     <br>            case WM_KEYDOWN: <br>                switch (wParam) { <br>                    case VK_ESCAPE: <br>                        if (fDrawing) { <br>                            if (fRubberBanding) { <br>                                EndRubberBanding(hwnd); <br>                                WorkUpdate(); <br>                            } <br>     <br>                            PropBarClearSize(); <br>                            ReleaseCapture(); <br>                            fDrawing = FALSE; <br>                        } <br>     <br>                        break; <br>                } <br>     <br>                break; <br>     <br>            default: <br>                return DefWindowProc(hwnd, msg, wParam, lParam); <br>        } <br>     <br>        return 0; <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * WorkPaint <br>    * <br>    * Handles WM_PAINT for the workspace window. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    STATICFN VOID NEAR WorkPaint(    HWND hwnd) <br>    { <br>        register INT i; <br>        PAINTSTRUCT ps; <br>        HCURSOR hcurOld; <br>        HDC hdcTemp; <br>        HBITMAP hbmTemp; <br>     <br>        hcurOld = SetCursor(hcurWait); <br>        BeginPaint(hwnd, &amp;ps); <br>     <br>        /* <br>         * Do they want a grid and is there enough room to show the lines? <br>         */ <br>        if (gfGrid &amp;&amp; gZoomFactor &gt; 1) { <br>            /* <br>             * Stretch the bits onto a temporary DC. <br>             */ <br>            hdcTemp = CreateCompatibleDC(ghdcImage); <br>            hbmTemp = CreateCompatibleBitmap(ghdcImage, <br>                    gcxWorkSpace, gcyWorkSpace); <br>            SelectObject(hdcTemp, hbmTemp); <br>            StretchBlt(hdcTemp, 0, 0, gcxWorkSpace, gcyWorkSpace, <br>                    ghdcImage, 0, 0, gcxImage, gcyImage, SRCCOPY); <br>     <br>            /* <br>             * Draw the grid lines on the temp DC. <br>             */ <br>            for (i = gZoomFactor - 1; i &lt; gcxWorkSpace; i += gZoomFactor) <br>                PatBlt(hdcTemp, i, 0, 1, gcyWorkSpace, BLACKNESS); <br>            for (i = gZoomFactor - 1; i &lt; gcyWorkSpace; i += gZoomFactor) <br>                PatBlt(hdcTemp, 0, i, gcxWorkSpace, 1, BLACKNESS); <br>     <br>            /* <br>             * Copy the bits to the screen. <br>             */ <br>            BitBlt(ps.hdc, 0, 0, gcxWorkSpace, gcyWorkSpace, <br>                    hdcTemp, 0, 0, SRCCOPY); <br>     <br>            DeleteDC(hdcTemp); <br>            DeleteObject(hbmTemp); <br>        } <br>        else { <br>            /* <br>             * No grid.  Just stretch the image to the screen. <br>             */ <br>            StretchBlt(ps.hdc, 0, 0, gcxWorkSpace, gcyWorkSpace, <br>                    ghdcImage, 0, 0, gcxImage, gcyImage, SRCCOPY); <br>        } <br>     <br>        EndPaint(hwnd, &amp;ps); <br>        SetCursor(hcurOld); <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * WorkUpdate <br>    * <br>    * This function updates the workspace window. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID WorkUpdate(VOID) <br>    { <br>        /* <br>         * Invalidate the workspace window.  Because the image will be <br>         * be blt'ed onto it, we do not need to force the background to <br>         * be cleared first. <br>         */ <br>        InvalidateRect(ghwndWork, NULL, FALSE); <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * WorkReset <br>    * <br>    * This function reset the workspace window.  It should be called <br>    * any time that a new image is loaded (because the size could <br>    * change) or the size of the main window changes (because the <br>    * workspace window needs to be resized to fit). <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID WorkReset(VOID) <br>    { <br>        RECT rcClient; <br>        INT cx; <br>        INT cy; <br>        INT xScale; <br>        INT yScale; <br>        INT cxBorder; <br>        INT cyBorder; <br>     <br>        cxBorder = GetSystemMetrics(SM_CXBORDER); <br>        cyBorder = GetSystemMetrics(SM_CYBORDER); <br>     <br>        if (!gcxImage || !gcyImage) { <br>            gZoomFactor = 1; <br>        } <br>        else { <br>            GetClientRect(ghwndMain, &amp;rcClient); <br>            cx = rcClient.right - (2 * PALETTEMARGIN) - (2 * cxBorder); <br>            cy = rcClient.bottom - (2 * PALETTEMARGIN) - (2 * cyBorder) - <br>                    gcyPropBar; <br>     <br>            xScale = cx / gcxImage; <br>            yScale = cy / gcyImage; <br>     <br>            if (xScale &gt; 0 &amp;&amp; yScale &gt; 0) <br>                gZoomFactor = min(xScale, yScale); <br>            else <br>                gZoomFactor = 1; <br>        } <br>     <br>        SetWindowPos(ghwndWork, NULL, <br>                PALETTEMARGIN, PALETTEMARGIN + gcyPropBar, <br>                (gZoomFactor * gcxImage) + (2 * cxBorder), <br>                (gZoomFactor * gcyImage) + (2 * cyBorder), <br>                SWP_NOACTIVATE | SWP_NOZORDER); <br>        WorkUpdate(); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * WorkButtonDown <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID WorkButtonDown( <br>        HWND hwnd, <br>        UINT msg, <br>        PPOINT ppt) <br>    { <br>        /* <br>         * If the other button is already down, just ignore this one. <br>         */ <br>        if (fDrawing) <br>            return; <br>     <br>        SetFocus(hwnd); <br>        fLeftButtonDown = (msg == WM_LBUTTONDOWN) ? TRUE : FALSE; <br>     <br>        SnapPointToGrid(ppt); <br>        ptStart = ptPrev = ptEnd = *ppt; <br>     <br>        if (fLeftButtonDown) { <br>            ghbrDraw = ghbrLeft; <br>            ghbrDrawSolid = ghbrLeftSolid; <br>            gfDrawMode = gfModeLeft; <br>            ghpenDraw = ghpenLeft; <br>        } <br>        else { <br>            ghbrDraw = ghbrRight; <br>            ghbrDrawSolid = ghbrRightSolid; <br>            gfDrawMode = gfModeRight; <br>            ghpenDraw = ghpenRight; <br>        } <br>     <br>        /* <br>         * If this tool draws on the down-click, update the undo <br>         * buffer now. <br>         */ <br>        if (gaTools[gCurTool].fDrawOnDown) <br>            ImageUpdateUndo(); <br>     <br>        SetCapture(ghwndWork); <br>        fDrawing = TRUE; <br>     <br>        (*gpfnDrawProc)(hwnd, msg, *ppt); <br>     <br>        PropBarSetSize(ptStart, ptEnd); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * WorkButtonMouseMove <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID WorkButtonMouseMove( <br>        HWND hwnd, <br>        UINT msg, <br>        PPOINT ppt) <br>    { <br>        static POINT ptNZLast;  // Saves the last point (non-zoomed). <br>        POINT ptNZ; <br>     <br>        SetCursor(gaTools[gCurTool].hcur); <br>     <br>        SnapPointToGrid(ppt); <br>     <br>        /* <br>         * Calculate the point as it would be on the actual image <br>         * (non-zoomed). <br>         */ <br>        ptNZ.x = ppt-&gt;x / gZoomFactor; <br>        ptNZ.y = ppt-&gt;y / gZoomFactor; <br>     <br>        /* <br>         * Only call the drawing proc if the point changed enough to <br>         * jump over a zoomed pixels width (it jumped a grid square). <br>         * This prevents calling the DrawProc for a mouse move of <br>         * a single pixel (unless the zoom factor is 1, of course). <br>         */ <br>        if (ptNZLast.x != ptNZ.x || ptNZLast.y != ptNZ.y) { <br>            ptEnd = *ppt; <br>            (*gpfnDrawProc)(hwnd, msg, *ppt); <br>            ptPrev = ptEnd; <br>     <br>            PropBarSetPos(ptNZ.x, ptNZ.y); <br>     <br>            if (fDrawing) <br>                PropBarSetSize(ptStart, ptEnd); <br>     <br>            ptNZLast = ptNZ; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * WorkButtonUp <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID WorkButtonUp( <br>        HWND hwnd, <br>        UINT msg, <br>        PPOINT ppt) <br>    { <br>        /* <br>         * Pass this on to the draw procs, but only if we are still drawing. <br>         * The drawing could have been cancelled by the Escape key, in <br>         * which case we just ignore the button up message. <br>         */ <br>        if (fDrawing) { <br>            SnapPointToGrid(ppt); <br>     <br>            /* <br>             * If this tool draws on the up-click, update the undo <br>             * buffer now. <br>             */ <br>            if (gaTools[gCurTool].fDrawOnUp) <br>                ImageUpdateUndo(); <br>     <br>            (*gpfnDrawProc)(hwnd, msg, *ppt); <br>     <br>            ReleaseCapture(); <br>            fDrawing = FALSE; <br>        } <br>    } <br>     <br>     <br>     <br>    /****************************************************************************** <br>     * SnapPointToGrid <br>     * <br>     * PURPOSE : Snap the current mouse coordinate to the nearest grid intersection. <br>     * <br>     * PARAMS  : PPOINT ppt : current mouse coordinates <br>     * <br>     *****************************************************************************/ <br>     <br>    STATICFN VOID NEAR SnapPointToGrid( <br>        PPOINT ppt) <br>    { <br>        /* <br>         * Scale the point down (this gridizes it at the same time). <br>         */ <br>        ppt-&gt;x = ppt-&gt;x / gZoomFactor; <br>        ppt-&gt;y = ppt-&gt;y / gZoomFactor; <br>     <br>        /* <br>         * Limit the point to within the image. <br>         */ <br>        if (ppt-&gt;x &lt; 0) <br>            ppt-&gt;x = 0; <br>     <br>        if (ppt-&gt;y &lt; 0) <br>            ppt-&gt;y = 0; <br>     <br>        if (ppt-&gt;x &gt;= gcxImage) <br>            ppt-&gt;x = gcxImage - 1; <br>     <br>        if (ppt-&gt;y &gt;= gcyImage) <br>            ppt-&gt;y = gcyImage - 1; <br>     <br>        /* <br>         * Finally, scale it back up to the workspace window size. <br>         */ <br>        ppt-&gt;x *= gZoomFactor; <br>        ppt-&gt;y *= gZoomFactor; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PencilDP <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID PencilDP( <br>        HWND hwnd, <br>        UINT msg, <br>        POINT ptNew) <br>    { <br>        switch (msg) { <br>            case WM_LBUTTONDOWN: <br>            case WM_RBUTTONDOWN: <br>                DrawPoint(hwnd, &amp;ptNew, FALSE); <br>                break; <br>     <br>            case WM_MOUSEMOVE: <br>                if (fDrawing) <br>                    DrawToPoint(hwnd, &amp;ptNew, FALSE); <br>     <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * BrushDP <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID BrushDP( <br>        HWND hwnd, <br>        UINT msg, <br>        POINT ptNew) <br>    { <br>        switch (msg) { <br>            case WM_LBUTTONDOWN: <br>            case WM_RBUTTONDOWN: <br>                DrawPoint(hwnd, &amp;ptNew, TRUE); <br>                break; <br>     <br>            case WM_MOUSEMOVE: <br>                if (fDrawing) <br>                    DrawToPoint(hwnd, &amp;ptNew, TRUE); <br>     <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * DrawToPoint <br>    * <br>    * This function draws from the previous point to the given point. <br>    * This includes all points between. <br>    * <br>    * The global ptPrev must have been initialized prior to the  first time <br>    * this function is called during a drawing operation. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID DrawToPoint( <br>        HWND hwnd, <br>        PPOINT ppt, <br>        BOOL fBrush) <br>    { <br>        DELTAGEN dg; <br>        BOOL fContinue; <br>        POINT pt; <br>        INT x; <br>        INT y; <br>     <br>        x = ppt-&gt;x / gZoomFactor; <br>        y = ppt-&gt;y / gZoomFactor; <br>        DeltaGenInit(&amp;dg, ptPrev.x / gZoomFactor, ptPrev.y / gZoomFactor, <br>                ppt-&gt;x / gZoomFactor, ppt-&gt;y / gZoomFactor, &amp;x, &amp;y); <br>        do { <br>            pt.x = x * gZoomFactor; <br>            pt.y = y * gZoomFactor; <br>            DrawPoint(hwnd, &amp;pt, fBrush); <br>            fContinue = DeltaGen(&amp;dg, &amp;x, &amp;y); <br>        } while (fContinue); <br>    } <br>     <br>     <br>     <br>    /***************************** Public  Function ****************************\ <br>    * DeltaGenInit <br>    * <br>    * This routine initializes the pdg, px and py in preparation for using <br>    * DeltaGen().  Returns fContinue. <br>    * <br>    * Algorithm derived from BRESENHAM line algorighm on p. 435 of Fund. of <br>    * interactive computer graphics, Foley/VanDam, addison-wesley 1983. <br>    * <br>    * History: <br>    *       3/7/89  sanfords        created <br>    \***************************************************************************/ <br>     <br>    STATICFN BOOL NEAR DeltaGenInit( <br>        PDELTAGEN pdg, <br>        INT x0, <br>        INT y0, <br>        INT xf, <br>        INT yf, <br>        PINT px, <br>        PINT py) <br>    { <br>        INT nT; <br>     <br>        pdg-&gt;xf = xf; <br>        pdg-&gt;yf = yf; <br>     <br>        if (x0 == xf &amp;&amp; y0 == yf) <br>            return FALSE; <br>     <br>        if (xf &gt;= x0) <br>            pdg-&gt;incx = 1; <br>        else <br>            pdg-&gt;incx = -1; <br>     <br>        if (yf &gt;= y0) <br>            pdg-&gt;incy = 1; <br>        else <br>            pdg-&gt;incy = -1; <br>     <br>        pdg-&gt;dx = (xf - x0) * pdg-&gt;incx; <br>        pdg-&gt;dy = (yf - y0) * pdg-&gt;incy; <br>     <br>        if (pdg-&gt;dy &gt; pdg-&gt;dx) { <br>            nT = pdg-&gt;dy; <br>            pdg-&gt;dy = pdg-&gt;dx; <br>            pdg-&gt;dx = nT; <br>            nT = pdg-&gt;incx; <br>            pdg-&gt;incx = pdg-&gt;incy; <br>            pdg-&gt;incy = nT; <br>            pdg-&gt;fSwap = TRUE; <br>        } <br>        else { <br>            pdg-&gt;fSwap = FALSE; <br>        } <br>     <br>        pdg-&gt;inc1 = pdg-&gt;dy * 2; <br>        pdg-&gt;inc2 = (pdg-&gt;dy - pdg-&gt;dx) * 2; <br>        pdg-&gt;d = pdg-&gt;inc1 - pdg-&gt;dx; <br>     <br>        pdg-&gt;xf = xf; <br>        pdg-&gt;yf = yf; <br>     <br>        *px = x0; <br>        *py = y0; <br>     <br>        return TRUE; <br>    } <br>     <br>     <br>     <br>    /***************************** Public  Function ****************************\ <br>    * DeltaGen <br>    * <br>    * This routine generates the next coordinates for px,py assuming that this <br>    * point is proceeding linearly from x0,y0 to xf, yf.  It returns FALSE only <br>    * if *px == xf and *py == yf on entry.  (ie returns fContinue)  pdg should <br>    * have been previously set by DeltaGenInit(). <br>    * <br>    * Algorithm derived from BRESENHAM line algorighm on p. 435 of Fund. of <br>    * interactive computer graphics, Foley/VanDam, addison-wesley 1983. <br>    * <br>    * History: <br>    *       3/7/89  sanfords        created <br>    \***************************************************************************/ <br>     <br>    STATICFN BOOL NEAR DeltaGen( <br>        PDELTAGEN pdg, <br>        PINT px, <br>        PINT py) <br>    { <br>        PINT pnT; <br>     <br>        if ((*px == pdg-&gt;xf) &amp;&amp; (*py == pdg-&gt;yf)) <br>            return FALSE; <br>     <br>        if (pdg-&gt;fSwap) { <br>            pnT = px; <br>            px = py; <br>            py = pnT; <br>        } <br>     <br>        *px += pdg-&gt;incx; <br>        if (pdg-&gt;d &lt; 0) { <br>            pdg-&gt;d += pdg-&gt;inc1; <br>        } <br>        else { <br>            *py += pdg-&gt;incy; <br>            pdg-&gt;d += pdg-&gt;inc2; <br>        } <br>     <br>        return TRUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * DrawPoint <br>    * <br>    * This function is called to draw a point on the image.  It is used <br>    * by the Pencil and Brush tools. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID DrawPoint( <br>        HWND hwnd, <br>        PPOINT ppt, <br>        BOOL fBrush) <br>    { <br>        HDC hDC; <br>        HBRUSH hbrOld; <br>        INT wx; <br>        INT wy; <br>        INT iStartY; <br>        INT wStep; <br>        INT i; <br>        INT j; <br>        INT nBrushSize; <br>     <br>        if (ppt-&gt;x &lt; 0 || ppt-&gt;y &lt; 0) <br>            return; <br>     <br>        hDC = GetDC(hwnd); <br>     <br>        /* <br>         * If this is a point from the brush tool, use the current <br>         * brush width.  Otherwise, draw a single pixel point. <br>         */ <br>        if (fBrush) <br>            nBrushSize = gnBrushSize; <br>        else <br>            nBrushSize = 1; <br>     <br>        /* <br>         * Determine some starting factors, then draw the point in <br>         * the workspace window. <br>         */ <br>        hbrOld = SelectObject(hDC, ghbrDrawSolid); <br>        wy = iStartY = ppt-&gt;y - (ppt-&gt;y % gZoomFactor) <br>                -(nBrushSize / 2) * gZoomFactor; <br>        wx = ppt-&gt;x - (ppt-&gt;x % gZoomFactor) <br>                -(nBrushSize / 2) * gZoomFactor; <br>        wStep = gZoomFactor; <br>     <br>        if (gfGrid &amp;&amp; gZoomFactor &gt; 1) <br>            wStep -= 1; <br>     <br>        for (i = 0; i &lt; nBrushSize; i++, wx += gZoomFactor) { <br>            wy = iStartY; <br>            for (j = 0; j &lt; nBrushSize; j++, wy += gZoomFactor) <br>                PatBlt(hDC, wx, wy, wStep, wStep, PATCOPY); <br>        } <br>     <br>        SelectObject(hDC, hbrOld); <br>        ReleaseDC(hwnd, hDC); <br>     <br>        /* <br>         * Set the point in the bitmap directly as an optimization. <br>         */ <br>        wx = ppt-&gt;x / gZoomFactor; <br>        wy = ppt-&gt;y / gZoomFactor; <br>        if (wx &lt; gcxImage &amp;&amp; wy &lt; gcyImage) { <br>            hbrOld = SelectObject(ghdcImage, ghbrDrawSolid); <br>            PatBlt(ghdcImage, wx - nBrushSize / 2, wy - nBrushSize / 2, <br>                    nBrushSize, nBrushSize, PATCOPY); <br>     <br>            if (giType != FT_BITMAP) { <br>                /* <br>                 * If in color mode, set the mask bits black.  Otherwise make <br>                 * them white. <br>                 */ <br>                PatBlt(ghdcANDMask, wx - nBrushSize / 2, wy - nBrushSize / 2, <br>                        nBrushSize, nBrushSize, <br>                        (gfDrawMode == MODE_COLOR) ? BLACKNESS : WHITENESS); <br>            } <br>     <br>            SelectObject(ghdcImage, hbrOld); <br>     <br>            /* <br>             * Draw the point in the view window directly as an optimization. <br>             */ <br>            if (ghwndView) <br>                ViewSetPixel(wx, wy, nBrushSize); <br>        } <br>     <br>        /* <br>         * Mark the image as changed. <br>         */ <br>        fImageDirty = TRUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PickDP <br>    * <br>    * Drawing proc that selects a rectangular portion of the image. <br>    * It updates the global picking rectangle. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID PickDP( <br>        HWND hwnd, <br>        UINT msg, <br>        POINT ptNew) <br>    { <br>        POINT ptTL;         // Top-Left point. <br>        POINT ptBR;         // Bottom-Right point <br>     <br>        switch (msg) { <br>            case WM_LBUTTONDOWN: <br>            case WM_RBUTTONDOWN: <br>                /* erase any previous ghost rectangle */ <br>                WorkUpdate(); <br>                UpdateWindow(ghwndWork); <br>     <br>                /* <br>                 * Initialize the pick rectangle to cover the entire screen. <br>                 */ <br>                PickSetRect(0, 0, gcxImage - 1, gcyImage - 1); <br>     <br>                StartRubberBanding(hwnd); <br>                RubberBandRect(TRUE); <br>                break; <br>     <br>            case WM_MOUSEMOVE: <br>                if (fRubberBanding) <br>                    RubberBandRect(FALSE); <br>     <br>                break; <br>     <br>            case WM_LBUTTONUP: <br>            case WM_RBUTTONUP: <br>                EndRubberBanding(hwnd); <br>     <br>                /* <br>                 * Flip the points (if needed) and scale down. <br>                 */ <br>                ptTL = ptStart; <br>                ptBR = ptEnd; <br>                NormalizePoints(&amp;ptTL, &amp;ptBR); <br>                ptTL.x /= gZoomFactor; <br>                ptTL.y /= gZoomFactor; <br>                ptBR.x /= gZoomFactor; <br>                ptBR.y /= gZoomFactor; <br>     <br>                PickSetRect(ptTL.x, ptTL.y, ptBR.x, ptBR.y); <br>     <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /****************************************************************************** <br>     * VOID LineDP(hwnd, msg, ptNew) <br>     * <br>     * PURPOSE: Draw a straight line according to tracking line. <br>     * <br>     * PARAMS : HWND   hwnd : handle to dest. DC <br>     *          unsigned msg  : Upper left corner of rect; <br>     *          POINT  ptNew   : end pt. of line <br>     * <br>     * SIDE EFFECTS: may change bits in image DC <br>     * <br>     *****************************************************************************/ <br>     <br>    VOID LineDP( <br>        HWND hwnd, <br>        UINT msg, <br>        POINT ptNew) <br>    { <br>        INT sx; <br>        INT sy; <br>        INT ex; <br>        INT ey; <br>        HPEN hpen; <br>        HPEN hpenOld; <br>        HBRUSH hbrOld; <br>     <br>        switch (msg) { <br>            case WM_RBUTTONDOWN: <br>            case WM_LBUTTONDOWN: <br>                StartRubberBanding(hwnd); <br>                RubberBandLine(TRUE); <br>                break; <br>     <br>            case WM_MOUSEMOVE: <br>                if (fRubberBanding) <br>                    RubberBandLine(FALSE); <br>     <br>                break; <br>     <br>            case WM_LBUTTONUP: <br>            case WM_RBUTTONUP: <br>                EndRubberBanding(hwnd); <br>     <br>                /* transform selected coordinates to those of actual image */ <br>                sx = ptStart.x / gZoomFactor; <br>                sy = ptStart.y / gZoomFactor; <br>                ex = ptEnd.x / gZoomFactor; <br>                ey = ptEnd.y / gZoomFactor; <br>     <br>                hpenOld = SelectObject(ghdcImage, ghpenDraw); <br>                MoveToEx(ghdcImage, sx, sy, NULL); <br>                LineTo(ghdcImage, ex, ey); <br>                SelectObject(ghdcImage, hpenOld); <br>     <br>                if (giType != FT_BITMAP) { <br>                    /* for icons and cursors draw the line on the AND DC (memory) <br>                     * in black (if in color mode) or white (otherwise) <br>                     */ <br>                    hpen = CreatePen(PS_INSIDEFRAME, 1, <br>                            (gfDrawMode == MODE_COLOR) ? RGB_BLACK : RGB_WHITE); <br>                    hpenOld = SelectObject(ghdcANDMask, hpen); <br>                    hbrOld = SelectObject(ghdcANDMask, GetStockObject(NULL_BRUSH)); <br>                    MoveToEx(ghdcANDMask, sx, sy, NULL); <br>                    LineTo(ghdcANDMask, ex, ey); <br>                    SelectObject(ghdcANDMask, hbrOld); <br>                    SelectObject(ghdcANDMask, hpenOld); <br>                    DeleteObject(hpen); <br>                } <br>     <br>                /* <br>                 * Because the LineTo function does not draw the ending <br>                 * point, we must do it manually here. <br>                 */ <br>                DrawPoint(hwnd, &amp;ptEnd, FALSE); <br>     <br>                fImageDirty = TRUE; <br>     <br>                ViewUpdate(); <br>     <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * RubberBandLine <br>    * <br>    * This function erases the old line and draws the new tracking line <br>    * when using the "Line" tool. <br>    * <br>    * Arguments: <br>    *   BOOL fFirstTime - TRUE if starting to track the line (it doesn't <br>    *                     need to erase the old line). <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR RubberBandLine( <br>        BOOL fFirstTime) <br>    { <br>        INT nOffset; <br>     <br>        /* <br>         * Set the raster-op to invert. <br>         */ <br>        SetROP2(hdcRubberBand, R2_NOT); <br>     <br>        /* <br>         * If we are magnifying the image at all, the line needs to be <br>         * slightly offset so that it will be draw exactly in between <br>         * the grid lines. <br>         */ <br>        if (gZoomFactor &gt; 1) </code></pre>
<p>
</p>
<pre><code>nOffset = -1; <br>        else <br>            nOffset = 0; <br>     <br>        if (!fFirstTime) { <br>            /* <br>             * Erase the old line. <br>             */ <br>             <br>            MoveToEx(hdcRubberBand, ptStart.x + (gZoomFactor / 2) + nOffset, <br>                    ptStart.y + (gZoomFactor / 2) + nOffset, NULL); <br>            LineTo(hdcRubberBand, ptPrev.x + (gZoomFactor / 2) + nOffset, <br>                    ptPrev.y + (gZoomFactor / 2) + nOffset); <br>        } <br>     <br>        /* <br>         * Draw the new one. <br>         */ <br>         <br>        MoveToEx(hdcRubberBand, ptStart.x + (gZoomFactor / 2) + nOffset, <br>                ptStart.y + (gZoomFactor / 2) + nOffset, NULL); <br>        LineTo(hdcRubberBand, ptEnd.x + (gZoomFactor / 2) + nOffset, <br>                ptEnd.y + (gZoomFactor / 2) + nOffset); <br>    } <br>     <br>     <br>     <br>    /****************************************************************************** <br>     * VOID RectDP(hwnd, msg, ptNew) <br>     * <br>     * PURPOSE: Draw a rectangle (filled/hollow) in the area specified <br>     * <br>     * PARAMS : HWND   hwnd : handle to dest. DC <br>     *          WORD   msg  : <br>     *          POINT  ptNew   : end pt. of line <br>     * <br>     * SIDE EFFECTS: may change bits in image DC <br>     * <br>     *****************************************************************************/ <br>     <br>    VOID RectDP( <br>        HWND hwnd, <br>        UINT msg, <br>        POINT ptNew) <br>    { <br>        switch (msg) { <br>            case WM_RBUTTONDOWN: <br>            case WM_LBUTTONDOWN: <br>                StartRubberBanding(hwnd); <br>                RubberBandRect(TRUE); <br>                break; <br>     <br>            case WM_MOUSEMOVE: <br>                if (fRubberBanding) <br>                    RubberBandRect(FALSE); <br>     <br>                break; <br>     <br>            case WM_LBUTTONUP: <br>            case WM_RBUTTONUP: <br>                RectDPDraw(hwnd); <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * RectDPDraw <br>    * <br>    * Does the final drawing of a rectangle when using the Rectangle tool. <br>    * <br>    * Arguments: <br>    *   HWND hwnd - Window handle to the workspace. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR RectDPDraw( <br>        HWND hwnd) <br>    { <br>        POINT ptTL;         // Top-Left point. <br>        POINT ptBR;         // Bottom-Right point <br>        HBRUSH hbr; <br>        HBRUSH hbrOld; <br>        HPEN hpen; <br>        HPEN hpenOld; <br>        INT nOutset; <br>     <br>        EndRubberBanding(hwnd); <br>     <br>        /* <br>         * Flip the points (if needed) and scale down. <br>         */ <br>        ptTL = ptStart; <br>        ptBR = ptEnd; <br>        NormalizePoints(&amp;ptTL, &amp;ptBR); <br>        ptTL.x /= gZoomFactor; <br>        ptTL.y /= gZoomFactor; <br>        ptBR.x /= gZoomFactor; <br>        ptBR.y /= gZoomFactor; <br>     <br>        if (gCurTool == TOOL_RECT) { <br>            hpen = ghpenDraw; <br>            hbr = GetStockObject(NULL_BRUSH); <br>            nOutset = 1; <br>        } <br>        else { <br>            hpen = GetStockObject(NULL_PEN); <br>            hbr = ghbrDraw; <br>            nOutset = 2; <br>        } <br>     <br>        hpenOld = SelectObject(ghdcImage, hpen); <br>        hbrOld = SelectObject(ghdcImage, hbr); <br>        Rectangle(ghdcImage, ptTL.x, ptTL.y, <br>                ptBR.x + nOutset, ptBR.y + nOutset); <br>        SelectObject(ghdcImage, hpenOld); <br>        SelectObject(ghdcImage, hbrOld); <br>     <br>        if (giType != FT_BITMAP) { <br>            /* for icons and cursors draw the shape on the AND DC (memory) <br>             * in black (if in color mode) or white (otherwise) <br>             */ <br>            if (gCurTool == TOOL_RECT) { <br>                hpen = CreatePen(PS_INSIDEFRAME, 1, <br>                        (gfDrawMode == MODE_COLOR) ? RGB_BLACK : RGB_WHITE); <br>                hbr = GetStockObject(NULL_BRUSH); <br>            } <br>            else { <br>                hpen = GetStockObject(NULL_PEN); <br>                hbr = GetStockObject((gfDrawMode == MODE_COLOR) ? <br>                        BLACK_BRUSH : WHITE_BRUSH); <br>            } <br>     <br>            hpenOld = SelectObject(ghdcANDMask, hpen); <br>            hbrOld = SelectObject(ghdcANDMask, hbr); <br>            Rectangle(ghdcANDMask, ptTL.x, ptTL.y, <br>                    ptBR.x + nOutset, ptBR.y + nOutset); <br>            SelectObject(ghdcANDMask, hpenOld); <br>            SelectObject(ghdcANDMask, hbrOld); <br>     <br>            if (gCurTool == TOOL_RECT) <br>                DeleteObject(hpen); <br>        } <br>     <br>        fImageDirty = TRUE; <br>     <br>        ViewUpdate(); <br>    } <br>     <br>     <br>     <br>    /****************************************************************************** <br>     * VOID PASCAL RubberBandRect() <br>     * <br>     * PURPOSE: Draw rubberbanding rect. <br>     * <br>     * PARAMS : HANDLE hDst : handle to dest. DC <br>     * <br>     *****************************************************************************/ <br>     <br>    STATICFN VOID NEAR RubberBandRect( <br>        BOOL fFirstTime) <br>    { <br>        POINT ptTL;         // Top-Left point. <br>        POINT ptBR;         // Bottom-Right point <br>     <br>        /* <br>         * Set the raster-op to invert. <br>         */ <br>        SetROP2(hdcRubberBand, R2_NOT); <br>     <br>        if (!fFirstTime) { <br>            /* <br>             * Erase the old rectangle. <br>             */ <br>            ptTL = ptStart; <br>            ptBR = ptPrev; <br>            NormalizePoints(&amp;ptTL, &amp;ptBR); <br>            Rectangle(hdcRubberBand, ptTL.x, ptTL.y, <br>                    ptBR.x + gZoomFactor, ptBR.y + gZoomFactor); <br>        } <br>     <br>     <br>        /* <br>         * Draw the new one. <br>         */ <br>        ptTL = ptStart; <br>        ptBR = ptEnd; <br>        NormalizePoints(&amp;ptTL, &amp;ptBR); <br>        Rectangle(hdcRubberBand, ptTL.x, ptTL.y, <br>                ptBR.x + gZoomFactor, ptBR.y + gZoomFactor); <br>    } <br>     <br>     <br>     <br>    /****************************************************************************** <br>     * VOID CircleDP(hwnd, msg, ptNew) <br>     * <br>     * PURPOSE: Draw an ellipse (filled/hollow) in the area specified. <br>     * <br>     * PARAMS : HWND   hwnd : handle to dest. DC <br>     *          unsigned msg  : Upper left corner of rect; <br>     *          POINT  ptNew   : end pt. of line <br>     * <br>     * SIDE EFFECTS: may change bits in image DC <br>     * <br>     *****************************************************************************/ <br>     <br>    VOID CircleDP( <br>        HWND hwnd, <br>        UINT msg, <br>        POINT ptNew) <br>    { <br>        switch (msg) { <br>            case WM_RBUTTONDOWN: <br>            case WM_LBUTTONDOWN: <br>                StartRubberBanding(hwnd); <br>                RubberBandCircle(TRUE); <br>                break; <br>     <br>            case WM_MOUSEMOVE: <br>                if (fRubberBanding) <br>                    RubberBandCircle(FALSE); <br>     <br>                break; <br>     <br>            case WM_LBUTTONUP: <br>            case WM_RBUTTONUP: <br>                CircleDPDraw(hwnd); <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * CircleDPDraw <br>    * <br>    * Does the final drawing of an ellipse when using the Ellipse tool. <br>    * <br>    * Arguments: <br>    *   HWND hwnd - Window handle to the workspace. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR CircleDPDraw( <br>        HWND hwnd) <br>    { <br>        POINT ptTL;         // Top-Left point. <br>        POINT ptBR;         // Bottom-Right point <br>        HBRUSH hbr; <br>        HBRUSH hbrOld; <br>        HPEN hpen; <br>        HPEN hpenOld; <br>        INT nOutset; <br>     <br>        EndRubberBanding(hwnd); <br>     <br>        /* <br>         * Flip the points (if needed) and scale down. <br>         */ <br>        ptTL = ptStart; <br>        ptBR = ptEnd; <br>        NormalizePoints(&amp;ptTL, &amp;ptBR); <br>        ptTL.x /= gZoomFactor; <br>        ptTL.y /= gZoomFactor; <br>        ptBR.x /= gZoomFactor; <br>        ptBR.y /= gZoomFactor; <br>     <br>    #ifdef WIN16 <br>        /* <br>         * The win 3.x code does not properly draw an ellipse if it <br>         * has a NULL pen selected in (to not draw the border).  For <br>         * this platform, we must select in the drawing pen.  This is <br>         * not necessary for NT (we can use a NULL pen to avoid <br>         * drawing the solid border). <br>         */ <br>     <br>        if (gCurTool == TOOL_CIRCLE) <br>            hbr = GetStockObject(NULL_BRUSH); <br>        else <br>            hbr = ghbrDraw; <br>     <br>        hpenOld = SelectObject(ghdcImage, ghpenDraw); <br>        hbrOld = SelectObject(ghdcImage, hbr); <br>        Ellipse(ghdcImage, ptTL.x, ptTL.y, ptBR.x + 1, ptBR.y + 1); <br>        SelectObject(ghdcImage, hbrOld); <br>        SelectObject(ghdcImage, hpenOld); <br>     <br>        if (giType != FT_BITMAP) { <br>            /* for icons and cursors draw the shape on the AND DC (memory) <br>             * in black (if in color mode) or white (otherwise) <br>             */ <br>            hpen = CreatePen(PS_INSIDEFRAME, 1, <br>                    (gfDrawMode == MODE_COLOR) ? RGB_BLACK : RGB_WHITE); <br>     <br>            if (gCurTool == TOOL_CIRCLE) <br>                hbr = GetStockObject(NULL_BRUSH); <br>            else <br>                hbr = GetStockObject((gfDrawMode == MODE_COLOR) ? <br>                        BLACK_BRUSH : WHITE_BRUSH); <br>     <br>            hpenOld = SelectObject(ghdcANDMask, hpen); <br>            hbrOld = SelectObject(ghdcANDMask, hbr); <br>            Ellipse(ghdcANDMask, ptTL.x, ptTL.y, ptBR.x + 1, ptBR.y + 1); <br>            SelectObject(ghdcANDMask, hpenOld); <br>            SelectObject(ghdcANDMask, hbrOld); <br>            DeleteObject(hpen); <br>        } <br>     <br>    #else <br>     <br>        if (gCurTool == TOOL_CIRCLE) { <br>            hpen = ghpenDraw; <br>            hbr = GetStockObject(NULL_BRUSH); <br>            nOutset = 1; <br>        } <br>        else { <br>            hpen = GetStockObject(NULL_PEN); <br>            hbr = ghbrDraw; <br>            nOutset = 2; <br>        } <br>     <br>        hpenOld = SelectObject(ghdcImage, hpen); <br>        hbrOld = SelectObject(ghdcImage, hbr); <br>        Ellipse(ghdcImage, ptTL.x, ptTL.y, ptBR.x + nOutset, ptBR.y + nOutset); <br>        SelectObject(ghdcImage, hpenOld); <br>        SelectObject(ghdcImage, hbrOld); <br>     <br>        if (giType != FT_BITMAP) { <br>            /* for icons and cursors draw the shape on the AND DC (memory) <br>             * in black (if in color mode) or white (otherwise) <br>             */ <br>            if (gCurTool == TOOL_CIRCLE) { <br>                hpen = CreatePen(PS_INSIDEFRAME, 1, <br>                        (gfDrawMode == MODE_COLOR) ? RGB_BLACK : RGB_WHITE); <br>                hbr = GetStockObject(NULL_BRUSH); <br>            } <br>            else { <br>                hpen = GetStockObject(NULL_PEN); <br>                hbr = GetStockObject((gfDrawMode == MODE_COLOR) ? <br>                        BLACK_BRUSH : WHITE_BRUSH); <br>            } <br>     <br>            hpenOld = SelectObject(ghdcANDMask, hpen); <br>            hbrOld = SelectObject(ghdcANDMask, hbr); <br>            Ellipse(ghdcANDMask, ptTL.x, ptTL.y, ptBR.x + nOutset, ptBR.y + nOutset); <br>            SelectObject(ghdcANDMask, hpenOld); <br>            SelectObject(ghdcANDMask, hbrOld); <br>     <br>            if (gCurTool == TOOL_CIRCLE) <br>                DeleteObject(hpen); <br>        } <br>     <br>    #endif <br>     <br>        fImageDirty = TRUE; <br>     <br>        ViewUpdate(); <br>    } <br>     <br>     <br>     <br>    /****************************************************************************** <br>     * VOID PASCAL RubberBandCircle() <br>     * <br>     * PURPOSE: Draw rubberbanding circle <br>     * <br>     * <br>     *****************************************************************************/ <br>     <br>    STATICFN VOID NEAR RubberBandCircle( <br>        BOOL fFirstTime) <br>    { <br>        POINT ptTL;         // Top-Left point. <br>        POINT ptBR;         // Bottom-Right point <br>     <br>        /* <br>         * Set the raster-op to invert. <br>         */ <br>        SetROP2(hdcRubberBand, R2_NOT); <br>     <br>        if (!fFirstTime) { <br>            /* <br>             * Erase the old circle. <br>             */ <br>            ptTL = ptStart; <br>            ptBR = ptPrev; <br>            NormalizePoints(&amp;ptTL, &amp;ptBR); <br>            Ellipse(hdcRubberBand, ptTL.x, ptTL.y, <br>                    ptBR.x + gZoomFactor, ptBR.y + gZoomFactor); <br>        } <br>     <br>     <br>        /* <br>         * Draw the new one. <br>         */ <br>        ptTL = ptStart; <br>        ptBR = ptEnd; <br>        NormalizePoints(&amp;ptTL, &amp;ptBR); <br>        Ellipse(hdcRubberBand, ptTL.x, ptTL.y, <br>                ptBR.x + gZoomFactor, ptBR.y + gZoomFactor); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * FloodDP <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID FloodDP( <br>        HWND hwnd, <br>        UINT msg, <br>        POINT ptNew) <br>    { <br>        HDC dc; <br>        HDC bwdc; <br>        HBRUSH hbrOld; <br>        HBITMAP bwbit; <br>        HCURSOR hcurSave; <br>     <br>        switch (msg) { <br>            case WM_RBUTTONDOWN: <br>            case WM_LBUTTONDOWN: <br>                hcurSave = SetCursor(hcurWait); <br>     <br>                dc = GetDC(hwnd); <br>                /* create temporary DC */ <br>                bwdc = CreateCompatibleDC(dc); <br>     <br>                /* create temporary monochrome bitmap */ <br>                if (!(bwbit = CreateBitmap(gcxImage, gcyImage, 1, 1, NULL))) { <br>                    DeleteDC(bwdc); <br>                    ReleaseDC(hwnd, dc); <br>                    Message(MSG_OUTOFMEMORY); <br>                    return; <br>                } <br>                SelectObject(bwdc, bwbit); <br>     <br>                /*  Set background color of image DC to desired floodfill color.*/ <br>                SetBkColor(ghdcImage, <br>                        GetPixel(ghdcImage, (ptNew.x / gZoomFactor), <br>                        (ptNew.y / gZoomFactor))); <br>     <br>                /******* OPERATION 0 ******/ <br>                /* First create a monochrome mask of the image after setting background <br>                 * color to the floodfill color. This will make the region to be <br>                 * flooded white(background), and it's boundary black (foreground) in the <br>                 * mask. <br>                 */ <br>                BitBlt(bwdc, 0, 0, gcxImage, gcyImage, ghdcImage, 0, 0, SRCCOPY); <br>     <br>                /******* OPERATION 1 ******/ <br>                /* floodfill selected region in mask (which is white bounded by black) <br>                 * with black. <br>                 */ <br>                SelectObject(bwdc, GetStockObject(BLACK_BRUSH)); <br>                ExtFloodFill(bwdc, ptNew.x / gZoomFactor, <br>                        ptNew.y / gZoomFactor, RGB_BLACK, FLOODFILLBORDER); <br>     <br>                /******* OPERATION 2 ******/ <br>                /* Now XOR the original image on the mask , inverting the <br>                 * flood-filled pixels on mask (black --&gt; white). <br>                 */ <br>                BitBlt(bwdc, 0, 0, gcxImage, gcyImage, ghdcImage, 0, 0, SRCINVERT); <br>     <br>                /* the AND mask needs to be updated only if in screen or inverse mode */ <br>                if ((giType == FT_CURSOR) || (giType == FT_ICON)) { <br>                    if (gfDrawMode == MODE_COLOR) { <br>                        SetBkColor(ghdcANDMask, RGB(0, 0, 0)); <br>                        BitBlt(ghdcANDMask, 0, 0, gcxImage, gcyImage, bwdc, <br>                                0, 0, ROP_DSna); <br>                        SelectObject(ghdcANDMask, GetStockObject(BLACK_BRUSH)); <br>                        BitBlt(ghdcANDMask, 0, 0, gcxImage, gcyImage, bwdc, <br>                                0, 0, ROP_DSPao); <br>                    } <br>                    else { <br>                        SetBkColor(ghdcANDMask, RGB(0xff, 0xff, 0xff));                    BitBlt(ghdcANDMask, 0, 0, gcxImage, gcyImage, bwdc, <br>                                0, 0, ROP_DSna); <br>                        SelectObject(ghdcANDMask, GetStockObject(WHITE_BRUSH)); <br>                        BitBlt(ghdcANDMask, 0, 0, gcxImage, gcyImage, bwdc, <br>                                0, 0, ROP_DSPao); <br>                    } <br>                } <br>     <br>                SetBkColor(ghdcImage, RGB_WHITE); <br>                /****** OPERATION 3 ******/ <br>                /* The following operation turns the flooded area on-screen black, <br>                 * on the image, preserving the rest of the it. <br>                 */ <br>                BitBlt(ghdcImage, 0, 0, gcxImage, gcyImage, bwdc, 0, 0, ROP_DSna); <br>     <br>                /****** OPERATION 4 ******/ <br>                /* Rop_DSPao ANDs the pattern (current brush which is the floodfill <br>                 * color) on the source making flooded area (which was white as a <br>                 * result of operation 2 ) the current brush color, and keeps the rest <br>                 * of the source black. The source is then ORed into the original image <br>                 * (whose flooded area is black as a result of operation 3) to get <br>                 * the desired end result. <br>                 */ <br>                hbrOld = SelectObject(ghdcImage, ghbrDraw); <br>                BitBlt(ghdcImage, 0, 0, gcxImage, gcyImage, bwdc, 0, 0, ROP_DSPao); <br>                SelectObject(ghdcImage, hbrOld); <br>     <br>                /* clean up */ <br>                DeleteDC(bwdc); <br>                DeleteObject(bwbit); <br>                ReleaseDC(hwnd, dc); <br>     <br>                /* <br>                 * Mark the image as changed. <br>                 */ <br>                fImageDirty = TRUE; <br>     <br>                ViewUpdate(); <br>     <br>                SetCursor(hcurSave); <br>     <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /****************************************************************************** <br>     * VOID HotSpotDP(hwnd, msg, ptNew) <br>     * <br>     * PURPOSE: Sets the hotspot. <br>     * <br>     * PARAMS : HWND   hwnd : handle to dest. DC <br>     *          WORD   msg  : <br>     *          POINT  ptNew   : end pt. <br>     * <br>     *****************************************************************************/ <br>     <br>    VOID HotSpotDP( <br>        HWND hwnd, <br>        UINT msg, <br>        POINT ptNew) <br>    { <br>        switch (msg) { <br>            case WM_LBUTTONDOWN: <br>                PropBarSetHotSpot(ptNew.x / gZoomFactor, ptNew.y / gZoomFactor); <br>                break; <br>     <br>            case WM_MOUSEMOVE: <br>                if (fDrawing &amp;&amp; fLeftButtonDown) <br>                    PropBarSetHotSpot(ptNew.x / gZoomFactor, <br>                            ptNew.y / gZoomFactor); <br>     <br>                break; <br>     <br>            case WM_LBUTTONUP: <br>                MarkHotSpotPosition(ptNew.x / gZoomFactor, ptNew.y / gZoomFactor); <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * MarkHotSpotPosition <br>    * <br>    * Updates the hotspot location in the currently selected cursor image. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR MarkHotSpotPosition( <br>        INT x, <br>        INT y) <br>    { <br>        gpImageCur-&gt;iHotspotX = x; <br>        gpImageCur-&gt;iHotspotY = y; <br>        PropBarSetHotSpot(x, y); <br>     <br>        /* <br>         * Mark the image as changed. <br>         */ <br>        fImageDirty = TRUE; <br>    } <br>     <br>     <br>     <br>    /****************************************************************************** <br>     * NormalizePoints <br>     * <br>     * PURPOSE : interchange start and end pts <br>     *           if start point is &gt; end point. <br>     * <br>     *****************************************************************************/ <br>     <br>    VOID NormalizePoints( <br>        PPOINT pptStart, <br>        PPOINT pptEnd) <br>    { <br>        INT n; <br>     <br>        if (pptStart-&gt;x &gt; pptEnd-&gt;x) { <br>            n = pptEnd-&gt;x; <br>            pptEnd-&gt;x = pptStart-&gt;x; <br>            pptStart-&gt;x = n; <br>        } <br>     <br>        if (pptStart-&gt;y &gt; pptEnd-&gt;y) { <br>            n = pptEnd-&gt;y; <br>            pptEnd-&gt;y = pptStart-&gt;y; <br>            pptStart-&gt;y = n; <br>        } <br>    } <br>     <br>     <br>     <br>    /****************************************************************************** <br>     * HDC PASCAL StartRubberBanding(hwnd) <br>     * <br>     * PURPOSE: Sets up rubberbanding for all tools. <br>     * <br>     * PARAMS : HANDLE hDst : handle to box DC <br>     * <br>     * RETURNS :handle to destination display context <br>     * <br>     * SIDE EFFECTS: alters a few global flags for tracking <br>     * <br>     *****************************************************************************/ <br>     <br>    STATICFN VOID NEAR StartRubberBanding( <br>        HWND hwnd) <br>    { <br>        hdcRubberBand = GetDC(hwnd); <br>     <br>        /* <br>         * Select a white pen, and a null brush (prevents drawing the <br>         * interior of rectangles and ellipses). <br>         */ <br>        SelectObject(hdcRubberBand, GetStockObject(WHITE_PEN)); <br>        SelectObject(hdcRubberBand, GetStockObject(NULL_BRUSH)); <br>     <br>        fRubberBanding = TRUE; <br>    } <br>     <br>     <br>     <br>    /****************************************************************************** <br>     * VOID PASCAL EndRubberBanding() <br>     * <br>     * PURPOSE: Stops rubberbanding rect. and cleans up <br>     * <br>     *****************************************************************************/ <br>     <br>    STATICFN VOID NEAR EndRubberBanding( <br>        HWND hwnd) <br>    { <br>        ReleaseDC(hwnd, hdcRubberBand); <br>        fRubberBanding = FALSE; <br>    } <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
