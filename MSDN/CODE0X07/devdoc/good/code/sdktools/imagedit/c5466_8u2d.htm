<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COLORWP.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5485"></a>COLORWP.C</h2>
<pre><code>/*************************************************************************** <br>     *                                                                         * <br>     *  MODULE      : ColorWP.c                                                * <br>     *                                                                         * <br>     *  DESCRIPTION : Window function for the colors window and related fns.   * <br>     *                                                                         * <br>     *  FUNCTIONS   : ColorWP ()            - Window function for colors       * <br>     *                                        window.                          * <br>     *                                                                         * <br>     *                ComputeInverseColor() - Gets the inverse RGB of a given  * <br>     *                                        RGB value                        * <br>     *                                                                         * <br>     *  HISTORY     : 6/21/89 - adapted from pBrush - LR                       * <br>     *                                                                         * <br>     ***************************************************************************/ <br>     <br>    #include "imagedit.h" <br>    #include "dialogs.h" <br> <br> #include &lt;windowsx.h&gt; <br>    #include &lt;commdlg.h&gt; <br>     <br>     <br>    STATICFN VOID NEAR ColorInit(HWND hwnd); <br>    STATICFN VOID NEAR ColorProcessCommand(HWND hwnd, INT idCtrl, INT NotifyCode); <br>    STATICFN VOID NEAR ColorBoxPaint(HDC hdc); <br>    STATICFN VOID NEAR DrawColorRect(HDC hdc, DWORD rgb, INT x, INT y, <br>        INT cx, INT cy, HDC hdcMem, BOOL fMonoOK); <br>    STATICFN VOID NEAR MyRectangle(HDC hdc, INT left, INT top, INT right, <br>        INT bottom, HDC hdcMem, BOOL fMonoOK); <br>    STATICFN VOID NEAR ColorBoxClicked(UINT msg, PPOINT ppt); <br>    STATICFN BOOL NEAR ColorBoxHitTest(PPOINT ppt, PINT piColor, PINT pfMode); <br>    STATICFN VOID NEAR ColorLRPaint(HWND hwnd, HDC hdc); <br>    STATICFN VOID NEAR ColorLRDrawSamples(HDC hdc, PRECT prc, BOOL fLeft); <br>    STATICFN VOID NEAR ColorLRUpdate(BOOL fLeft); <br>    STATICFN VOID NEAR ColorEdit(VOID); <br>    STATICFN VOID NEAR SetLeftColor(INT iColor, INT iMode); <br>    STATICFN VOID NEAR SetRightColor(INT iColor, INT iMode); <br>    STATICFN HBRUSH NEAR MyCreateSolidBrush(DWORD rgb); <br>    STATICFN DWORD NEAR MyGetNearestColor(DWORD rgb, BOOL fMonoOK); <br>    STATICFN DWORD NEAR ComputeInverseColor(DWORD rgb); <br>     <br>    /* <br>     * Width/height of a single color square. <br>     */ <br>    static INT gcxColorBox; <br>     <br>    /* <br>     * Vertical offset within the color box control to where to start the <br>     * top row of color squares (the color squares are vertically centered <br>     * within the color box control). <br>     */ <br>    static INT gyColorBoxStart; <br>     <br>    /* <br>     * Number of colors and image type.  These globals are used by the <br>     * the color palette routines to know what mode the color palette <br>     * is in. <br>     */ <br>    static INT gnColorPalColors; <br>    static INT giColorPalType; <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ColorShow <br>    * <br>    * This function shows or hides the color palette. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID ColorShow( <br>        BOOL fShow) <br>    { <br>        if (fShow) <br>            ShowWindow(ghwndColor, SW_SHOWNA); <br>        else <br>            ShowWindow(ghwndColor, SW_HIDE); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorDlgProc <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    DIALOGPROC ColorDlgProc( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        switch (msg) { <br>            case WM_INITDIALOG: <br>                ColorInit(hwnd); <br>     <br>                /* <br>                 * Return TRUE so that the dialog manager does NOT set the focus <br>                 * for me.  This prevents the status window from initially having <br>                 * the focus when the editor is started. <br>                 */ <br>                return TRUE; <br>     <br>            case WM_ACTIVATE: <br>                if (GET_WM_ACTIVATE_STATE(wParam, lParam)) <br>                    gidCurrentDlg = DID_COLOR; <br>     <br>                break; <br>     <br>            case WM_CTLCOLORBTN: <br>            case WM_CTLCOLORDLG: <br>            case WM_CTLCOLORSTATIC: <br>                switch (GET_WM_CTLCOLOR_TYPE(wParam, lParam, msg)) { <br>                    case CTLCOLOR_BTN: <br>                    case CTLCOLOR_DLG: <br>                        return (BOOL)GetStockObject(LTGRAY_BRUSH); <br>     <br>                    case CTLCOLOR_STATIC: <br>                        SetBkColor(GET_WM_CTLCOLOR_HDC(wParam, lParam, msg), <br>                                RGB_LIGHTGRAY); <br>                        return (BOOL)GetStockObject(LTGRAY_BRUSH); <br>                } <br>     <br>                return (BOOL)NULL; <br>     <br>            case  WM_PAINT: <br>                { <br>                    HDC hdc; <br>                    PAINTSTRUCT ps; <br>     <br>                    hdc = BeginPaint(hwnd, &amp;ps); <br>                    DrawMarginBorder(hwnd, hdc); <br>                    EndPaint(hwnd, &amp;ps); <br>                } <br>     <br>                break; <br>     <br>            case WM_COMMAND: <br>                ColorProcessCommand(hwnd, <br>                        GET_WM_COMMAND_ID(wParam, lParam), <br>                        GET_WM_COMMAND_CMD(wParam, lParam)); <br>                break; <br>     <br>            case WM_CLOSE: <br>                /* <br>                 * The user closed the color palette from the system menu. <br>                 * Hide the window (we don't actually destroy it so <br>                 * that it will appear in the same spot when they show <br>                 * it again). <br>                 */ <br>                ColorShow(FALSE); <br>                gfShowColor = FALSE; <br>                break; <br>     <br>            case WM_DESTROY: <br>                { <br>                    RECT rc; <br>     <br>                    /* <br>                     * Save the position of the color palette. <br>                     */ <br>                    GetWindowRect(hwnd, &amp;rc); <br>                    WriteWindowPos(&amp;rc, FALSE, szColorPos); <br>     <br>                    /* <br>                     * Null out the global window handle for the color palette <br>                     * for safety's sake. <br>                     */ <br>                    ghwndColor = NULL; <br>                } <br>     <br>                break; <br>     <br>            default: <br>                return FALSE; <br>        } <br>     <br>        return FALSE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorInit <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>    STATICFN VOID NEAR ColorInit( <br>        HWND hwnd) <br>    { <br>        RECT rc; <br>     <br>        /* <br>         * Get the dimension of a single color square, and the vertical <br>         * offset to where the top of the squares are. <br>         */ <br>        GetWindowRect(GetDlgItem(hwnd, DID_COLORBOX), &amp;rc); <br>        gcxColorBox = (rc.right - rc.left) / COLORCOLS; <br>        gyColorBoxStart = ((rc.right - rc.left) - (gcxColorBox * COLORCOLS)) / 2; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorProcessCommand <br>    * <br>    * <br>    * Arguments: <br>    *   HWND hwnd        - The window handle. <br>    *   INT idCtrl       - The id of the control the WM_COMMAND is for. <br>    *   INT NotifyCode   - The control's notification code. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR ColorProcessCommand( <br>        HWND hwnd, <br>        INT idCtrl, <br>        INT NotifyCode) <br>    { <br>        switch (idCtrl) { <br>            case DID_COLOREDIT: <br>                ColorEdit(); <br>                break; <br>     <br>            case DID_COLORDEFAULT: <br>                if (gfModeLeft == MODE_COLOR) { <br>                    gargbColor[giColorLeft] = gargbDefaultColor[giColorLeft]; <br>                    InvalidateRect(GetDlgItem(ghwndColor, DID_COLORBOX), <br>                            NULL, TRUE); <br>                    SetLeftColor(giColorLeft, gfModeLeft); <br>                } <br>     <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorBoxWndProc <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    WINDOWPROC ColorBoxWndProc( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        POINT pt; <br>        HDC hdc; <br>        PAINTSTRUCT ps; <br>        INT iColor; <br>        INT iMode; <br>     <br>        switch (msg) { <br>            case WM_PAINT: <br>                hdc = BeginPaint(hwnd, &amp;ps); <br>                ColorBoxPaint(hdc); <br>                EndPaint(hwnd, &amp;ps); <br>                break; <br>     <br>            case WM_LBUTTONDOWN: <br>            case WM_RBUTTONDOWN: <br>                ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>                ColorBoxClicked(msg, &amp;pt); <br>                break; <br>     <br>            case WM_LBUTTONDBLCLK: <br>                ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>                if (ColorBoxHitTest(&amp;pt, &amp;iColor, &amp;iMode)) <br>                    ColorEdit(); <br>     <br>                break; <br>     <br>            default: <br>                return DefWindowProc(hwnd, msg, wParam, lParam); <br>        } <br>     <br>        return 0; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorBoxPaint <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR ColorBoxPaint( <br>        HDC hdc) <br>    { <br>        HDC hdcMem; <br>        HBITMAP hbmMem; <br>        INT i; <br>        INT x; <br>        INT y; <br>        INT cx = gcxColorBox + 1; <br>        INT cy = gcxColorBox + 1; <br>     <br>        if (giColorPalType != FT_BITMAP) { <br>            x = 0; <br>            y = gyColorBoxStart; <br>            DrawColorRect(hdc, grgbScreen, x, y, cx, cy, NULL, FALSE); <br>            y += gcxColorBox; <br>            DrawColorRect(hdc, grgbInverse, x, y, cx, cy, NULL, FALSE); <br>        } <br>     <br>        if (!(hdcMem = CreateCompatibleDC(hdc))) <br>            return; <br>     <br>        /* <br>         * Create a bitmap.  It will have the same number of colors as the <br>         * current image. <br>         */ <br>        if (!(hbmMem = MyCreateBitmap(hdc, cx, cy, gnColorPalColors))) { <br>            DeleteDC(hdcMem); <br>            return; <br>        } <br>     <br>        SelectObject(hdcMem, hbmMem); <br>     <br>        x = gcxColorBox * 2; <br>        y = gyColorBoxStart; <br>     <br>        for (i = 1; i &lt;= COLORSMAX; i++) { <br>            DrawColorRect(hdc, gargbCurrent[i - 1], x, y, cx, cy, hdcMem, TRUE); <br>     <br>            if (i % COLORROWS) { <br>                y += gcxColorBox; <br>            } <br>            else { <br>                x += gcxColorBox; <br>                y = gyColorBoxStart; <br>            } <br>        } <br>     <br>        DeleteDC(hdcMem); <br>        DeleteObject(hbmMem); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * DrawColorRect <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR DrawColorRect( <br>        HDC hdc, <br>        DWORD rgb, <br>        INT x, <br>        INT y, <br>        INT cx, <br>        INT cy, <br>        HDC hdcMem, <br>        BOOL fMonoOK) <br>    { <br>        HBRUSH hbr; <br>        HBRUSH hbrOld; <br>     <br>        hbr = CreateSolidBrush(rgb); <br>        hbrOld = SelectObject(hdc, hbr); <br>        MyRectangle(hdc, x, y, x + cx, y + cy, hdcMem, fMonoOK); <br>        SelectObject(hdc, hbrOld); <br>        DeleteObject(hbr); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * MyRectangle <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR MyRectangle( <br>        HDC hdc, <br>        INT left, <br>        INT top, <br>        INT right, <br>        INT bottom, <br>        HDC hdcMem, <br>        BOOL fMonoOK) <br>    { <br>        HBITMAP hbmMem; <br>        HBRUSH hbr; <br>        HPEN hpen; <br>        HBRUSH hbrOld; <br>        HPEN hpenOld; <br>        BOOL fDCCreated = FALSE; <br>        INT cx = right - left; <br>        INT cy = bottom - top; <br>        INT nColors; <br>     <br>        /* <br>         * Do they want us to create the memory DC and bitmap for them? <br>         */ <br>        if (!hdcMem) { <br>            if (!(hdcMem = CreateCompatibleDC(hdc))) <br>                return; <br>     <br>            /* <br>             * Create a bitmap.  It will be monochrome if in 2 color mode <br>             * and monochrome is ok, otherwise it will be 16 color. <br>             */ <br>            nColors = gnColorPalColors; <br>            if (!fMonoOK) <br>                nColors = 16; <br>     <br>            if (!(hbmMem = MyCreateBitmap(hdc, cx, cy, nColors))) { <br>                DeleteDC(hdcMem); <br>                return; <br>            } <br>     <br>            SelectObject(hdcMem, hbmMem); <br>            fDCCreated = TRUE; <br>        } <br>     <br>        /* <br>         * Extract the current pen and brush out of the passed in DC. <br>         */ <br>        hbr = SelectObject(hdc, GetStockObject(NULL_BRUSH)); <br>        hpen = SelectObject(hdc, GetStockObject(NULL_PEN)); <br>     <br>        /* <br>         * Select them into the memory DC. <br>         */ <br>        hbrOld = SelectObject(hdcMem, hbr); <br>        hpenOld = SelectObject(hdcMem, hpen); <br>     <br>        /* <br>         * Draw the rectangle in the memory bitmap. <br>         */ <br>        Rectangle(hdcMem, 0, 0, cx, cy); <br>     <br>        /* <br>         * Unselect the pen and brush from the memory DC. <br>         */ <br>        SelectObject(hdcMem, hbrOld); <br>        SelectObject(hdcMem, hpenOld); <br>     <br>        /* <br>         * Restore the pen and brush to the original DC. <br>         */ <br>        SelectObject(hdc, hbr); <br>        SelectObject(hdc, hpen); <br>     <br>        /* <br>         * Blit the memory image to the passed in DC. <br>         */ <br>        BitBlt(hdc, left, top, cx, cy, hdcMem, 0, 0, SRCCOPY); <br>     <br>        if (fDCCreated) { <br>            DeleteDC(hdcMem); <br>            DeleteObject(hbmMem); <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorBoxClicked <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR ColorBoxClicked( <br>        UINT msg, <br>        PPOINT ppt) <br>    { <br>        INT iColor; <br>        INT iMode; <br>     <br>        if (ColorBoxHitTest(ppt, &amp;iColor, &amp;iMode)) { <br>            switch (msg) { <br>                case WM_LBUTTONDOWN: <br>                    SetLeftColor(iColor, iMode); <br>                    break; <br>     <br>                case WM_RBUTTONDOWN: <br>                    SetRightColor(iColor, iMode); <br>                    break; <br>            } <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorBoxHitTest <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN BOOL NEAR ColorBoxHitTest( <br>        PPOINT ppt, <br>        PINT piColor, <br>        PINT pfMode) <br>    { <br>        INT iCol; <br>        INT iRow; <br>        INT iBox; <br>     <br>        if (ppt-&gt;y &lt; gyColorBoxStart) <br>            return FALSE; <br>     <br>        iCol = ppt-&gt;x / gcxColorBox; <br>        iRow = (ppt-&gt;y - gyColorBoxStart) / gcxColorBox; <br>     <br>        if (iCol &gt;= (COLORSMAX / COLORROWS) + 2 || iRow &gt;= COLORROWS) <br>            return FALSE; <br>     <br>        iBox = iRow + (iCol * COLORROWS); <br>     <br>        switch (iBox) { <br>            case 0: <br>                if (giColorPalType == FT_BITMAP) <br>                    return FALSE; <br>     <br>                *piColor = 0; <br>                *pfMode = MODE_SCREEN; <br>                return TRUE; <br>     <br>            case 1: <br>                if (giColorPalType == FT_BITMAP) <br>                    return FALSE; <br>     <br>                *piColor = 0; <br>                *pfMode = MODE_INVERSE; <br>                return TRUE; <br>     <br>            case 2: <br>            case 3: <br>                return FALSE; <br>     <br>            default: <br>                *piColor = iBox - (COLORROWS * 2); <br>                *pfMode = MODE_COLOR; <br>                return TRUE; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorLRWndProc <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    WINDOWPROC ColorLRWndProc( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        HDC hdc; <br>        PAINTSTRUCT ps; <br>     <br>        switch (msg) { <br>            case WM_PAINT: <br>                hdc = BeginPaint(hwnd, &amp;ps); <br>                ColorLRPaint(hwnd, hdc); <br>                EndPaint(hwnd, &amp;ps); <br>                break; <br>     <br>            default: <br>                return DefWindowProc(hwnd, msg, wParam, lParam); <br>        } <br>     <br>        return 0; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorLRPaint <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR ColorLRPaint( <br>        HWND hwnd, <br>        HDC hdc) <br>    { <br>        RECT rc; <br>     <br>        GetClientRect(hwnd, &amp;rc); <br>        DrawSunkenRect(&amp;rc, hdc); <br>        ColorLRDrawSamples(hdc, &amp;rc, TRUE); <br>        ColorLRDrawSamples(hdc, &amp;rc, FALSE); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorLRDrawSamples <br>    * <br>    * Draws the sample colors in the Color Left-Right control. <br>    * <br>    * Arguments: <br>    *   HDC hdc    - DC to draw into. <br>    *   PRECT prc  - Rectangle of color sample control.  The samples will <br>    *                be centered within this with an appropriate margin. <br>    *   BOOL fLeft - TRUE if the left sample is to be drawn, FALSE for the right. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR ColorLRDrawSamples( <br>        HDC hdc, <br>        PRECT prc, <br>        BOOL fLeft) <br>    { <br>        INT xLeftStart; <br>        INT xRightStart; <br>        INT ySolidStart; <br>        INT yDitherStart; <br>        INT cx; <br>        INT cy; <br>        HBRUSH hbrOld; <br>        HPEN hpenOld; <br>        BOOL fMonoOK; <br>     <br>        /* <br>         * The width and height of each square includes the border. <br>         */ <br>        cx = ((prc-&gt;right - prc-&gt;left) - (6 * PALETTEMARGIN)) / 2; <br>        cy = ((prc-&gt;bottom - prc-&gt;top) - (4 * PALETTEMARGIN)) / 2; <br>     <br>        xLeftStart = prc-&gt;left + (PALETTEMARGIN * 2) + 1; <br>        xRightStart = xLeftStart + cx + (PALETTEMARGIN * 2); <br>     <br>        ySolidStart = prc-&gt;top + (PALETTEMARGIN * 2) + 1; <br>        yDitherStart = ySolidStart - 1 + cy; <br>     <br>        /* <br>         * Draw either the left or the right color sample. <br>         */ <br>        if (fLeft) { <br>            fMonoOK = (gfModeLeft == MODE_COLOR) ? TRUE : FALSE; <br>     <br>            /* <br>             * Draw the solid color. <br>             */ <br>            hbrOld = SelectObject(hdc, ghbrLeftSolid); <br>            hpenOld = SelectObject(hdc, GetStockObject(NULL_PEN)); <br>            MyRectangle(hdc, xLeftStart, ySolidStart, <br>                    xLeftStart + cx, yDitherStart + 1, NULL, fMonoOK); <br>     <br>            /* <br>             * Draw the true color (may be dithered). <br>             */ <br>            SelectObject(hdc, ghbrLeft); <br>            MyRectangle(hdc, xLeftStart, yDitherStart, <br>                    xLeftStart + cx, yDitherStart + cy, NULL, fMonoOK); <br>        } <br>        else { <br>            fMonoOK = (gfModeRight == MODE_COLOR) ? TRUE : FALSE; <br>     <br>            hbrOld = SelectObject(hdc, ghbrRightSolid); <br>            hpenOld = SelectObject(hdc, GetStockObject(NULL_PEN)); <br>            MyRectangle(hdc, xRightStart, ySolidStart, <br>                    xRightStart + cx, yDitherStart + 1, NULL, fMonoOK); <br>     <br>            SelectObject(hdc, ghbrRight); <br>            MyRectangle(hdc, xRightStart, yDitherStart, <br>                    xRightStart + cx, yDitherStart + cy, NULL, fMonoOK); <br>        } <br>     <br>        /* <br>         * Now draw the outline rectangle. <br>         */ <br>        SelectObject(hdc, GetStockObject(BLACK_PEN)); <br>        SelectObject(hdc, GetStockObject(NULL_BRUSH)); <br>     <br>        if (fLeft) { <br>            Rectangle(hdc, xLeftStart - 1, ySolidStart - 1, <br>                    xLeftStart + cx, yDitherStart + cy); <br>        } <br>        else { <br>            Rectangle(hdc, xRightStart - 1, ySolidStart - 1, <br>                    xRightStart + cx, yDitherStart + cy); <br>        } <br>     <br>        /* <br>         * Clean up. <br>         */ <br>        SelectObject(hdc, hpenOld); <br>        SelectObject(hdc, hbrOld); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorLRUpdate <br>    * <br>    * Called when the left or right color has been changed.  This function <br>    * will cause the specified color sample to be updated in the color palette. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR ColorLRUpdate( <br>        BOOL fLeft) <br>    { <br>        RECT rc; <br>        HWND hwndLR; <br>        HDC hdc; <br>     <br>        hwndLR = GetDlgItem(ghwndColor, DID_COLORLR); <br>        GetClientRect(hwndLR, &amp;rc); <br>        hdc = GetDC(hwndLR); <br>        ColorLRDrawSamples(hdc, &amp;rc, fLeft); <br>        ReleaseDC(hwndLR, hdc); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ColorEdit <br>    * <br>    * This function calls the standard color chooser dialog to get a <br>    * new color for the selected palette entry. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR ColorEdit(VOID) <br>    { <br>        /* <br>         * This array of custom colors is initialized to all white colors. <br>         * The custom colors will be remembered between calls, but not <br>         * between sessions. <br>         */ <br>        static DWORD argbCust[16] = { <br>            RGB(255, 255, 255), RGB(255, 255, 255), <br>            RGB(255, 255, 255), RGB(255, 255, 255), <br>            RGB(255, 255, 255), RGB(255, 255, 255), <br>            RGB(255, 255, 255), RGB(255, 255, 255), <br>            RGB(255, 255, 255), RGB(255, 255, 255), <br>            RGB(255, 255, 255), RGB(255, 255, 255), <br>            RGB(255, 255, 255), RGB(255, 255, 255), <br>            RGB(255, 255, 255), RGB(255, 255, 255) <br>        }; <br>        CHOOSECOLOR cc; <br>        DWORD rgbOld; <br>        BOOL fResult; <br>        INT idPrevDlg; <br>     <br>        switch (gfModeLeft) { <br>            case MODE_COLOR: <br>                /* <br>                 * The monochrome palette cannot be edited. <br>                 */ <br>                if (gnColorPalColors == 2) <br>                    return; <br>     <br>                rgbOld = gargbCurrent[giColorLeft]; <br>                break; <br>     <br>            case MODE_SCREEN: <br>                rgbOld = grgbScreen; <br>                break; <br>     <br>            case MODE_INVERSE: <br>                rgbOld = grgbInverse; <br>                break; <br>        } <br>     <br>        cc.lStructSize = sizeof(CHOOSECOLOR); <br>        cc.hwndOwner = ghwndMain; <br>        cc.hInstance = ghInst; <br>        cc.rgbResult = rgbOld; <br>        cc.lpCustColors = argbCust; <br>        cc.Flags = CC_RGBINIT | CC_SHOWHELP; <br>        cc.lCustData = 0; <br>        cc.lpfnHook = NULL; <br>        cc.lpTemplateName = NULL; <br>     <br>        EnteringDialog(DID_COMMONFILECHOOSECOLOR, &amp;idPrevDlg, TRUE); <br>        fResult = ChooseColor(&amp;cc); <br>        EnteringDialog(idPrevDlg, NULL, FALSE); <br>     <br>        if (fResult &amp;&amp; rgbOld != cc.rgbResult) { <br>            switch (gfModeLeft) { <br>                case MODE_COLOR: <br>                    gargbCurrent[giColorLeft] = cc.rgbResult; <br>                    break; <br>     <br>                case MODE_SCREEN: <br>                    SetScreenColor(cc.rgbResult); <br>                    break; <br>     <br>                case MODE_INVERSE: <br>                    SetScreenColor(ComputeInverseColor(cc.rgbResult)); <br>                    break; <br>            } <br>     <br>            SetLeftColor(giColorLeft, gfModeLeft); <br>            InvalidateRect(GetDlgItem(ghwndColor, DID_COLORBOX), NULL, TRUE); <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * SetLeftColor <br>    * <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR SetLeftColor( <br>        INT iColor, <br>        INT iMode) <br>    { <br>        DWORD rgbSolid; <br>        BOOL fEnableDefault = FALSE; <br>        BOOL fEnableEdit = FALSE; <br>     <br>        if (ghbrLeft) <br>            DeleteObject(ghbrLeft); <br>     <br>        if (ghbrLeftSolid) <br>            DeleteObject(ghbrLeftSolid); <br>     <br>        if (ghpenLeft) <br>            DeleteObject(ghpenLeft); <br>     <br>        switch (iMode) { <br>            case MODE_COLOR: <br>                ghbrLeft = MyCreateSolidBrush(gargbCurrent[iColor]); <br>                rgbSolid = MyGetNearestColor(gargbCurrent[iColor], TRUE); <br>                ghbrLeftSolid = CreateSolidBrush(rgbSolid); <br>                ghpenLeft = CreatePen(PS_INSIDEFRAME, 1, rgbSolid); <br>                giColorLeft = iColor; <br>     <br>                /* <br>                 * We will enable the "Default" button if the current color <br>                 * on the left button is not the default color, and we are <br>                 * not in monochrome mode. <br>                 */ <br>                if (gargbColor[giColorLeft] != gargbDefaultColor[giColorLeft] &amp;&amp; <br>                        gnColorPalColors &gt; 2) <br>                    fEnableDefault = TRUE; <br>     <br>                /* <br>                 * For non-screen colors, the Edit button will be enabled <br>                 * if we are not in monochrome mode. <br>                 */ <br>                if (gnColorPalColors &gt; 2) <br>                    fEnableEdit = TRUE; <br>     <br>                break; <br>     <br>            case MODE_SCREEN: <br>                ghbrLeft = CreateSolidBrush(grgbScreen); <br>                ghbrLeftSolid = CreateSolidBrush(grgbScreen); <br>                ghpenLeft = CreatePen(PS_INSIDEFRAME, 1, grgbScreen); <br>                giColorLeft = 0; <br>                fEnableEdit = TRUE; <br>                break; <br>     <br>            case MODE_INVERSE: <br>                ghbrLeft = CreateSolidBrush(grgbInverse); <br>                ghbrLeftSolid = CreateSolidBrush(grgbInverse); <br>                ghpenLeft = CreatePen(PS_INSIDEFRAME, 1, grgbInverse); <br>                giColorLeft = 0; <br>                fEnableEdit = TRUE; <br>                break; <br>        } <br>     <br>        EnableWindow(GetDlgItem(ghwndColor, DID_COLORDEFAULT), fEnableDefault); <br>        EnableWindow(GetDlgItem(ghwndColor, DID_COLOREDIT), fEnableEdit); <br>     <br>        gfModeLeft = iMode; <br>        ColorLRUpdate(TRUE); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * SetRightColor <br>    * <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR SetRightColor( <br>        INT iColor, <br>        INT iMode) <br>    { <br>        DWORD rgbSolid; <br>     <br>        if (ghbrRight) <br>            DeleteObject(ghbrRight); <br>     <br>        if (ghbrRightSolid) <br>            DeleteObject(ghbrRightSolid); <br>     <br>        if (ghpenRight) <br>            DeleteObject(ghpenRight); <br>     <br>        switch (iMode) { <br>            case MODE_COLOR: <br>                ghbrRight = MyCreateSolidBrush(gargbCurrent[iColor]); <br>                rgbSolid = MyGetNearestColor(gargbCurrent[iColor], TRUE); <br>                ghbrRightSolid = CreateSolidBrush(rgbSolid); <br>                ghpenRight = CreatePen(PS_INSIDEFRAME, 1, rgbSolid); <br>                giColorRight = iColor; <br>                break; <br>     <br>            case MODE_SCREEN: <br>                ghbrRight = CreateSolidBrush(grgbScreen); </code></pre>
<p>
</p>
<pre><code>ghbrRightSolid = CreateSolidBrush(grgbScreen); <br>                ghpenRight = CreatePen(PS_INSIDEFRAME, 1, grgbScreen); <br>                giColorRight = 0; <br>                break; <br>     <br>            case MODE_INVERSE: <br>                ghbrRight = CreateSolidBrush(grgbInverse); <br>                ghbrRightSolid = CreateSolidBrush(grgbInverse); <br>                ghpenRight = CreatePen(PS_INSIDEFRAME, 1, grgbInverse); <br>                giColorRight = 0; <br>                break; <br>        } <br>     <br>        gfModeRight = iMode; <br>        ColorLRUpdate(FALSE); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * SetScreenColor <br>    * <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID SetScreenColor( <br>        DWORD rgb) <br>    { <br>        DWORD rgbInverse; <br>        HDC hdcTemp; <br>        HBITMAP hbmOld; <br>        HDC hdcANDTemp; <br>        HBITMAP hbmANDOld; <br>     <br>        rgb = MyGetNearestColor(rgb, FALSE); <br>     <br>        /* <br>         * Because we are about to change the screen color, separate <br>         * out the XOR mask (but only for icons/cursors). <br>         */ <br>        if (giColorPalType != FT_BITMAP) { <br>            if (gpImageCur) { <br>                ImageDCSeparate(ghdcImage, gcxImage, gcyImage, ghdcANDMask, <br>                        grgbScreen); <br>     <br>                /* <br>                 * Is there a pending undo buffer?  If so, it must be <br>                 * changed as well or an undo that is done after a screen <br>                 * color change will restore the wrong colors! <br>                 */ <br>                if (ghbmUndo) { <br>                    /* <br>                     * Create some temporary DC's to use when separating <br>                     * out the undo buffer's masks.  These will be deleted <br>                     * a little later. <br>                     */ <br>                    hdcTemp = CreateCompatibleDC(ghdcImage); <br>                    hbmOld = SelectObject(hdcTemp, ghbmUndo); <br>                    hdcANDTemp = CreateCompatibleDC(ghdcANDMask); <br>                    hbmANDOld = SelectObject(hdcANDTemp, ghbmUndoMask); <br>     <br>                    /* <br>                     * Separate out the undo buffer's colors, before <br>                     * changing the screen color.  It will be combined <br>                     * later. <br>                     */ <br>                    ImageDCSeparate(hdcTemp, gcxImage, gcyImage, hdcANDTemp, <br>                            grgbScreen); <br>                } <br>            } <br>        } <br>     <br>        if (ghbrScreen) <br>            DeleteObject(ghbrScreen); <br>     <br>        ghbrScreen = CreateSolidBrush(rgb); <br>        grgbScreen = rgb; <br>     <br>        if (ghbrInverse) <br>            DeleteObject(ghbrInverse); <br>     <br>        rgbInverse = ComputeInverseColor(rgb); <br>        ghbrInverse = CreateSolidBrush(rgbInverse); <br>        grgbInverse = rgbInverse; <br>     <br>        /* <br>         * For icons and cursors, we might need to update a few more things. <br>         */ <br>        if (giColorPalType != FT_BITMAP) { <br>            /* <br>             * Recombine the XOR and AND images now that there is a new screen <br>             * color.  This updates the image DC with the new color properly. <br>             */ <br>            if (gpImageCur) { <br>                ImageDCCombine(ghdcImage, gcxImage, gcyImage, ghdcANDMask); <br>     <br>                /* <br>                 * Is there a pending undo buffer?  If so, it has to be <br>                 * recombined with the new screen color. <br>                 */ <br>                if (ghbmUndo) { <br>                    ImageDCCombine(hdcTemp, gcxImage, gcyImage, hdcANDTemp); <br>     <br>                    /* <br>                     * Clean up the DC's that were allocated a little earlier. <br>                     */ <br>                    SelectObject(hdcANDTemp, hbmANDOld); <br>                    DeleteDC(hdcANDTemp); <br>                    SelectObject(hdcTemp, hbmOld); <br>                    DeleteDC(hdcTemp); <br>                } <br>            } <br>     <br>            /* <br>             * Reset the colors on the mouse buttons, just in case a screen <br>             * or inverse screen color was assigned to either of them. <br>             */ <br>            SetLeftColor(giColorLeft, gfModeLeft); <br>            SetRightColor(giColorRight, gfModeRight); <br>     <br>            InvalidateRect(GetDlgItem(ghwndColor, DID_COLORBOX), NULL, TRUE); <br>        } <br>     <br>        ViewUpdate(); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * MyCreateSolidBrush <br>    * <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN HBRUSH NEAR MyCreateSolidBrush( <br>        DWORD rgb) <br>    { <br>        HDC hdc; <br>        HDC hdcMem; <br>        HBRUSH hbr; <br>        HBRUSH hbrOld; <br>        HBITMAP hbmPat; <br>        HBITMAP hbmOld; <br>     <br>        /* <br>         * First, create a brush for the given RGB value. <br>         */ <br>        hbr = CreateSolidBrush(rgb); <br>     <br>        /* <br>         * Create a temporary memory DC. <br>         */ <br>        hdc = GetDC(ghwndMain); <br>        hdcMem = CreateCompatibleDC(hdc); <br>     <br>        /* <br>         * Create a temporary bitmap. <br>         */ <br>        hbmPat = MyCreateBitmap(hdc, 8, 8, gnColorPalColors); <br>        ReleaseDC(ghwndMain, hdc); <br>     <br>        /* <br>         * Draw the (possibly) dithered pattern on the temporary bitmap. <br>         */ <br>        hbmOld = SelectObject(hdcMem, hbmPat); <br>        hbrOld = SelectObject(hdcMem, hbr); <br>        PatBlt(hdcMem, 0, 0, 8, 8, PATCOPY); <br>        SelectObject(hdcMem, hbrOld); <br>        SelectObject(hdcMem, hbmOld); <br>        DeleteDC(hdcMem); <br>     <br>        /* <br>         * Delete the first brush. <br>         */ <br>        DeleteObject(hbr); <br>     <br>        /* <br>         * Now create a pattern brush out of the (dithered) bitmap. <br>         */ <br>        hbr = CreatePatternBrush(hbmPat); <br>     <br>        DeleteObject(hbmPat); <br>     <br>        /* <br>         * Return the pattern brush. <br>         */ <br>        return hbr; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * MyGetNearestColor <br>    * <br>    * This function returns the RGB value of the nearest color to the <br>    * specified RGB value.  If fMonoOK is TRUE, it takes into account <br>    * the number of colors of the current image being edited.  In other <br>    * words, it will return the nearest solid color for a device that <br>    * has the number of colors of the current image. <br>    * <br>    * Arguments: <br>    *   DWORD rgb    - RGB value of the color. <br>    *   BOOL fMonoOK - TRUE if the returned color should be mapped to a <br>    *                  color in a monochrome palette, if the current image <br>    *                  is monochrome.  A value of FALSE will return a <br>    *                  color mapped to the closest color in a 16 color <br>    *                  palette. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN DWORD NEAR MyGetNearestColor( <br>        DWORD rgb, <br>        BOOL fMonoOK) <br>    { <br>        HDC hdc; <br>        HDC hdcMem; <br>        DWORD rgbNearest; <br>        HBITMAP hbmMem; <br>        HBITMAP hbmOld; <br>     <br>        hdc = GetDC(ghwndMain); <br>        hdcMem = CreateCompatibleDC(hdc); <br>        hbmMem = MyCreateBitmap(hdc, 1, 1, (fMonoOK) ? gnColorPalColors : 16); <br>        hbmOld = SelectObject(hdcMem, hbmMem); <br>        rgbNearest = GetNearestColor(hdcMem, rgb); <br>        SelectObject(hdcMem, hbmOld); <br>        DeleteObject(hbmMem); <br>        DeleteDC(hdcMem); <br>        ReleaseDC(ghwndMain, hdc); <br>     <br>        return rgbNearest; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ComputeInverseColor <br>    * <br>    * Computes the inverse value of a given rgb color. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN DWORD NEAR ComputeInverseColor( <br>        DWORD rgb) <br>    { <br>        HBITMAP hTempBit1; <br>        HBITMAP hTempBit2; <br>        HDC hTempDC1; <br>        HDC hTempDC2; <br>        HDC hdc; <br>        HANDLE hOldObj1; <br>        HANDLE hOldObj2; <br>        DWORD rgbInv; <br>     <br>        hdc = GetDC(ghwndMain); <br>        hTempDC1 = CreateCompatibleDC(hdc); <br>        hTempDC2 = CreateCompatibleDC(hdc); <br>     <br>        /* create two temporary 1x1, 16 color bitmaps */ <br>        hTempBit1 = MyCreateBitmap(hdc, 1, 1, 16); <br>        hTempBit2 = MyCreateBitmap(hdc, 1, 1, 16); <br>     <br>        ReleaseDC(ghwndMain, hdc); <br>     <br>        hOldObj1 = SelectObject(hTempDC1, hTempBit1); <br>        hOldObj2 = SelectObject(hTempDC2, hTempBit2); <br>     <br>        /* method for getting inverse color : set the given pixel (rgb) on <br>         * one DC. Now blt it to the other DC using a SRCINVERT rop. <br>         * This yields a pixel of the inverse color on the destination DC <br>         */ <br>        SetPixel(hTempDC1, 0, 0, rgb); <br>        PatBlt(hTempDC2, 0, 0, 1, 1, WHITENESS); <br>        BitBlt(hTempDC2, 0, 0, 1, 1, hTempDC1, 0, 0, SRCINVERT); <br>        rgbInv = GetPixel(hTempDC2, 0, 0); <br>     <br>        /* clean up ... */ <br>        SelectObject(hTempDC1, hOldObj1); <br>        SelectObject(hTempDC2, hOldObj2); <br>        DeleteObject(hTempBit1); <br>        DeleteObject(hTempBit2); <br>        DeleteDC(hTempDC1); <br>        DeleteDC(hTempDC2); <br>     <br>        /* ...and return the inverted RGB value */ <br>        return rgbInv; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * SetColorPalette <br>    * <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID SetColorPalette( <br>        INT nColors, <br>        INT iType, <br>        BOOL fForce) <br>    { <br>        /* <br>         * Quit if nothing changed (unless they are forcing it to be updated). <br>         */ <br>        if (!fForce &amp;&amp; nColors == gnColorPalColors &amp;&amp; iType == giColorPalType) <br>            return; <br>     <br>        /* <br>         * Set the globals that all the color palette routines use. <br>         */ <br>        gnColorPalColors = nColors; <br>        giColorPalType = iType; <br>     <br>        if (gnColorPalColors == 2) <br>            gargbCurrent = gargbMono; <br>        else <br>            gargbCurrent = gargbColor; <br>     <br>        ShowWindow(GetDlgItem(ghwndColor, DID_COLORSCREENLABEL), <br>                (giColorPalType == FT_BITMAP) ? SW_HIDE : SW_SHOW); <br>        ShowWindow(GetDlgItem(ghwndColor, DID_COLORINVERSELABEL), <br>                (giColorPalType == FT_BITMAP) ? SW_HIDE : SW_SHOW); <br>     <br>        SetLeftColor(1, MODE_COLOR); <br>        SetRightColor(0, MODE_COLOR); <br>     <br>        InvalidateRect(GetDlgItem(ghwndColor, DID_COLORBOX), NULL, TRUE); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * RestoreDefaultColors <br>    * <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID RestoreDefaultColors(VOID) <br>    { <br>        INT i; <br>     <br>        for (i = 0; i &lt; COLORSMAX; i++) <br>            gargbColor[i] = gargbDefaultColor[i]; <br>     <br>        SetColorPalette(16, giColorPalType, TRUE); <br>    } <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
