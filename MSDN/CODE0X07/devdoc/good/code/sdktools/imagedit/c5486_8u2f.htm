<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RWICOCUR.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5487"></a>RWICOCUR.C</h2>
<pre><code>/****************************************************************************/ <br>    /*                                                                          */ <br>    /*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>    /*                           All Rights Reserved                            */ <br>    /*                                                                          */ <br>    /****************************************************************************/ <br>    /****************************** Module Header ******************************* <br>    * Module Name: rwicocur.c <br>    * <br>    * Routines to read and write icon and cursor files. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    #include "imagedit.h" <br>     <br>    #include &lt;io.h&gt; <br>    #include &lt;fcntl.h&gt;                          // For NT fstat(). <br>    #include &lt;sys\types.h&gt;                      // For fstat() types. <br>    #include &lt;sys\stat.h&gt;                       // For fstat() function. <br>     <br>     <br>     <br>    /************************************************************************ <br>    * LoadIconCursorFile <br>    * <br>    * Loads the specified icon or cursor file.  It reads the images into <br>    * a list, then prompts for which one to open initially. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL LoadIconCursorFile( <br>        PSTR pszFullFileName, <br>        BOOL fIcon) <br>    { <br>        HFILE hf; <br>        INT i; <br>        PIMAGEINFO pImage; <br>        LPBITMAPINFO lpBitmapInfo; <br>        HANDLE hDIB;                    // Handle to DIB bits. <br>        OFSTRUCT OfStruct; <br>        struct stat FileStatus; <br>        ICOCURSORHDR hdr;               // Header structure of icon/cursor file. <br>        INT nImages; <br>        PICOCURSORDESC aIcoCurDesc;     // Array of ico/cur descriptors. <br>        DWORD dwFilePos; <br>        DWORD dwFileSize; <br>        INT iType; <br>     <br>        if ((hf = (HFILE)OpenFile(pszFullFileName, (LPOFSTRUCT)&amp;OfStruct, OF_READ)) <br>                == (HFILE)-1) { <br>            Message(MSG_CANTOPEN, pszFullFileName); <br>            return FALSE; <br>        } <br>     <br>        fstat((INT)_open_osfhandle((long)(hf), (int)(O_RDONLY)), &amp;FileStatus); <br>        dwFileSize = (DWORD)FileStatus.st_size; <br>     <br>        ImageLinkFreeList(); <br>     <br>        if (fIcon) <br>            iType = FT_ICON; <br>        else <br>            iType = FT_CURSOR; <br>     <br>        /* <br>         * Read the Icon/Cursor File header. <br>         */ <br>        if (!MyFileRead(hf, (LPSTR)&amp;hdr, sizeof(ICOCURSORHDR), <br>                pszFullFileName, iType)) <br>            goto Error1; <br>     <br>        if (hdr.iReserved != 0) { <br>            Message(MSG_BADICOCURFILE, pszFullFileName); <br>            goto Error1; <br>        } <br>     <br>        /* <br>         * Get number of images in the file. <br>         */ <br>        nImages = hdr.iResourceCount; <br>     <br>        if (!nImages || nImages &gt; MAXIMAGES) { <br>            Message(MSG_BADICOCURFILE, pszFullFileName); <br>            goto Error1; <br>        } <br>     <br>        if (hdr.iResourceType != 1 &amp;&amp; hdr.iResourceType != 2) { <br>            Message(MSG_BADICOCURFILE, pszFullFileName); <br>            goto Error1; <br>        } <br>     <br>        /* <br>         * Allocate room for the descriptor records. <br>         */ <br>        if (!(aIcoCurDesc = (PICOCURSORDESC)MyAlloc( <br>                sizeof(ICOCURSORDESC) * nImages))) <br>            goto Error1; <br>     <br>        /* <br>         * Read in the descriptor records. <br>         */ <br>        if (!MyFileRead(hf, (LPSTR)aIcoCurDesc, sizeof(ICOCURSORDESC) * nImages, <br>                pszFullFileName, iType)) <br>            goto Error2; <br>     <br>        /* <br>         * Get the current file position (after the descriptors).  This <br>         * should be the start of the DIB's. <br>         */ <br>        dwFilePos = (DWORD)SetFilePointer((HANDLE)hf, 0, NULL, (DWORD)1); <br>     <br>        /* <br>         * Validate the descriptor records. <br>         */ <br>        for (i = 0; i &lt; nImages; i++) { <br>            /* <br>             * Make sure the DIB's are sequential (not overlapping) <br>             * and they all fit within the file. <br>             */ <br>            if (aIcoCurDesc[i].DIBOffset != dwFilePos || <br>                    dwFilePos + aIcoCurDesc[i].DIBSize &gt; dwFileSize) { <br>                Message(MSG_BADICOCURFILE, pszFullFileName); <br>                goto Error2; <br>            } <br>     <br>            /* <br>             * Jump to the next DIB. <br>             */ <br>            dwFilePos += aIcoCurDesc[i].DIBSize; <br>        } <br>     <br>        for (i = 0; i &lt; nImages; i++) { <br>            pImage = ImageLinkAlloc(NULL, 0, 0, <br>                    aIcoCurDesc[i].iHotspotX, aIcoCurDesc[i].iHotspotY, <br>                    (aIcoCurDesc[i].iColorCount == (BYTE)8) ? <br>                    aIcoCurDesc[i].iColorCount : 0); <br>     <br>            if (!pImage) <br>                goto Error3; <br>     <br>            /* <br>             * Allocate space for the DIB for this image. <br>             */ <br>            if (!(hDIB = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, <br>                    (DWORD)aIcoCurDesc[i].DIBSize))) { <br>                Message(MSG_OUTOFMEMORY); <br>                goto Error3; <br>            } <br>     <br>            pImage-&gt;DIBSize = aIcoCurDesc[i].DIBSize; <br>            pImage-&gt;DIBhandle = hDIB; <br>            pImage-&gt;DIBPtr = (LPSTR)GlobalLock(hDIB); <br>        } <br>     <br>        for (pImage = gpImageHead; pImage != NULL; pImage = pImage-&gt;pImageNext) { <br>            if (!MyFileRead(hf, pImage-&gt;DIBPtr, (DWORD)pImage-&gt;DIBSize, <br>                    pszFullFileName, iType)) <br>                goto Error3; <br>     <br>            lpBitmapInfo = (LPBITMAPINFO)pImage-&gt;DIBPtr; <br>     <br>            if (!IsValidDIB(lpBitmapInfo, pImage-&gt;DIBSize, TRUE)) { <br>                Message(MSG_BADICOCURFILE, pszFullFileName); <br>                goto Error3; <br>            } <br>     <br>            /* <br>             * Fill the x and y size fields in image node from <br>             * information in the DIB header. <br>             */ <br>            pImage-&gt;cx = (INT)lpBitmapInfo-&gt;bmiHeader.biWidth; <br>            pImage-&gt;cy = (INT)lpBitmapInfo-&gt;bmiHeader.biHeight / 2; <br>            if (pImage-&gt;nColors == 0) <br>                pImage-&gt;nColors = (1 &lt;&lt; lpBitmapInfo-&gt;bmiHeader.biBitCount); <br>     <br>            pImage-&gt;pDevice = DeviceLinkFind( <br>                    fIcon ? gpIconDeviceHead : gpCursorDeviceHead, <br>                    pImage-&gt;nColors, pImage-&gt;cx, pImage-&gt;cy); <br>        } <br>     <br>        _lclose((HFILE)hf); <br>     <br>        fFileDirty = FALSE; <br>        SetFileName(pszFullFileName); <br>        giType = iType; <br>     <br>        gnImages = nImages; <br>     <br>        /* <br>         * Update the PropBar and the Toolbox so that they show <br>         * information about the opened file.  We do this now just <br>         * in case the user cancels out of the Image Select Dialog. <br>         */ <br>        PropBarUpdate(); <br>        ToolboxUpdate(); <br>     <br>        /* <br>         * Open up an image.  If there are multiple images in the file, <br>         * show the Image Select dialog.  We also show the Image Select <br>         * dialog if the file only has one image but it is not for a known <br>         * device. <br>         */ <br>        if (gnImages &gt; 1 || !gpImageHead-&gt;pDevice) <br>            ImageSelectDialog(); <br>        else <br>            ImageOpen2(gpImageHead); <br>     <br>        return TRUE; <br>     <br>    Error3: <br>        ImageLinkFreeList(); <br>     <br>    Error2: <br>        MyFree(aIcoCurDesc); <br>     <br>    Error1: <br>        _lclose((HFILE)hf); <br>     <br>        return FALSE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * IsValidDIB <br>    * <br>    * This function determines if the given DIB is valid or not.  It does <br>    * this without touching memory outside the bounds of the cbDIBSize <br>    * passed in or the size of a BITMAPINFOHEADER, whichever is smaller. <br>    * Note that even if the DIB is valid, however, the current image <br>    * editor might not be able to edit it (the size might be too big, for <br>    * instance). <br>    * <br>    * Arguments: <br>    *   LPBITMAPINFO pDIB - Points to the DIB. <br>    *   DWORD cbDIBSize   - The size of the DIB. <br>    *   BOOL fIcoCur      - TRUE if this is an icon or cursor.  This effects <br>    *                       whether an AND mask is expected to be in the DIB. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL IsValidDIB( <br>        LPBITMAPINFO pDIB, <br>        DWORD cbDIBSize, <br>        BOOL fIcoCur) <br>    { <br>        DWORD cbANDMask; <br>        DWORD cbXORMask; <br>        DWORD cbColorTable; <br>        DWORD nHeight; <br>     <br>        if (cbDIBSize &lt; sizeof(BITMAPINFOHEADER)) <br>            return FALSE; <br>     <br>        if (pDIB-&gt;bmiHeader.biSize != sizeof(BITMAPINFOHEADER)) <br>            return FALSE; <br>     <br>        if (pDIB-&gt;bmiHeader.biPlanes != 1) <br>            return FALSE; <br>     <br>        if (pDIB-&gt;bmiHeader.biBitCount != 1 &amp;&amp; <br>                pDIB-&gt;bmiHeader.biBitCount != 4 &amp;&amp; <br>                pDIB-&gt;bmiHeader.biBitCount != 8 &amp;&amp; <br>                pDIB-&gt;bmiHeader.biBitCount != 24) <br>            return FALSE; <br>     <br>        if (fIcoCur) { <br>            nHeight = pDIB-&gt;bmiHeader.biHeight / 2; <br>            cbANDMask = (((pDIB-&gt;bmiHeader.biWidth + 31) &amp; 0xffffffe0) &gt;&gt; 3) * <br>                    nHeight; <br>        } <br>        else { <br>            nHeight = pDIB-&gt;bmiHeader.biHeight; <br>            cbANDMask = 0; <br>        } <br>     <br>        cbColorTable = (1 &lt;&lt; pDIB-&gt;bmiHeader.biBitCount) * sizeof(RGBQUAD); <br>        cbXORMask = ((((pDIB-&gt;bmiHeader.biWidth * pDIB-&gt;bmiHeader.biBitCount) + <br>                31) &amp; 0xffffffe0) &gt;&gt; 3) * nHeight; <br>     <br>        /* <br>         * Check the size field in the header.  This must be either zero <br>         * or a valid size. <br>         */ <br>        if (pDIB-&gt;bmiHeader.biSizeImage &amp;&amp; <br>                pDIB-&gt;bmiHeader.biSizeImage != cbXORMask + cbANDMask) <br>            return FALSE; <br>     <br>        if (cbDIBSize != sizeof(BITMAPINFOHEADER) + cbColorTable + <br>                cbXORMask + cbANDMask) <br>            return FALSE; <br>     <br>        return TRUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * SaveIconCursorFile <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * Returns: <br>    *   TRUE if successful, FALSE otherwise. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL SaveIconCursorFile( <br>        PSTR pszFullFileName, <br>        INT iType) <br>    { <br>        ICOCURSORHDR IcoCurHdr;     // Header structure of icon/cursor file. <br>        ICOCURSORDESC IcoCurDesc;   // Icon/cursor descriptor struct. <br>        HCURSOR hcurOld;            // Handle to old cursor. <br>        PIMAGEINFO pImage;          // Pointer to node in image list. <br>        DWORD iBitsOffset;          // Offset of the actual DIB bits for image. <br>        HFILE hf; <br>        OFSTRUCT OfStruct; <br>     <br>        hcurOld = SetCursor(hcurWait); <br>     <br>        /* <br>         * Save the bits of the current image. <br>         */ <br>        ImageSave(); <br>     <br>        /* <br>         * Open the file for writing. <br>         */ <br>        if ((hf = (HFILE)OpenFile(pszFullFileName, &amp;OfStruct, OF_CREATE | OF_READWRITE)) <br>                == (HFILE)-1) { <br>            Message(MSG_CANTCREATE, pszFullFileName); <br>            goto Error1; <br>        } <br>     <br>        /* <br>         * This is crucial since this helps distinguish a 3.0 icon/cursor <br>         * from an old, old (2.1 format) icon/cursor, which has meaningful <br>         * information in this WORD. <br>         */ <br>        IcoCurHdr.iReserved = (WORD)0; <br>     <br>        if (iType == FT_ICON) <br>            IcoCurHdr.iResourceType = 1;        // Icon type. <br>        else <br>            IcoCurHdr.iResourceType = 2;        // Cursor type. <br>     <br>        IcoCurHdr.iResourceCount = (WORD)gnImages; <br>     <br>        /* <br>         * Write the header to disk. <br>         */ <br>        if (!MyFileWrite(hf, (LPSTR)&amp;IcoCurHdr, sizeof(ICOCURSORHDR), <br>                pszFullFileName)) <br>            goto Error2; <br>     <br>        /* <br>         * Write all the descriptors. <br>         */ <br>        iBitsOffset = sizeof(ICOCURSORHDR) + (gnImages * sizeof(ICOCURSORDESC)); <br>        for (pImage = gpImageHead; pImage; pImage = pImage-&gt;pImageNext) { <br>            IcoCurDesc.iWidth = (BYTE)pImage-&gt;cx; <br>            IcoCurDesc.iHeight = (BYTE)pImage-&gt;cy; <br>            IcoCurDesc.iColorCount = (giType == FT_ICON) ? <br>                    (BYTE)pImage-&gt;nColors : (BYTE)0; <br>            IcoCurDesc.iUnused = 0; <br>            IcoCurDesc.iHotspotX = (WORD)pImage-&gt;iHotspotX; <br>            IcoCurDesc.iHotspotY = (WORD)pImage-&gt;iHotspotY; <br>            IcoCurDesc.DIBSize = pImage-&gt;DIBSize; <br>            IcoCurDesc.DIBOffset = iBitsOffset; <br>     <br>            if (!MyFileWrite(hf, (LPSTR)&amp;IcoCurDesc, sizeof(ICOCURSORDESC), <br>                    pszFullFileName)) <br>                goto Error2; <br>     <br>            iBitsOffset += IcoCurDesc.DIBSize; <br>        } <br>     <br>        /* <br>         * Now write the DIB's. <br>         */ <br>        for (pImage = gpImageHead; pImage; pImage = pImage-&gt;pImageNext) { <br>            if (!MyFileWrite(hf, (LPSTR)pImage-&gt;DIBPtr, <br>                    (DWORD)pImage-&gt;DIBSize, pszFullFileName)) <br>                goto Error2; <br>        } <br>     <br>        _lclose((HFILE)hf); <br>     <br>        fFileDirty = FALSE; <br>        SetFileName(pszFullFileName); <br>     <br>        SetCursor(hcurOld); <br>     <br>        return TRUE; <br>     <br>    Error2: <br>        _lclose((HFILE)hf); <br>     <br>    Error1: <br>        SetCursor(hcurOld); <br>     <br>        return FALSE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
