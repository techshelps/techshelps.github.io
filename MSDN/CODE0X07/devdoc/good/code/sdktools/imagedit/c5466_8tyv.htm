<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DEVINFO.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5467"></a>DEVINFO.C</h2>
<pre><code>/****************************************************************************/ <br>    /*                                                                          */ <br>    /*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>    /*                           All Rights Reserved                            */ <br>    /*                                                                          */ <br>    /****************************************************************************/ <br>    /****************************** Module Header ******************************* <br>    * Module Name: devinfo.c <br>    * <br>    * Contains routines for manipulating the linked list of known target <br>    * devices for icons and cursors. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    #include "imagedit.h" <br>     <br>    #include &lt;stdio.h&gt; <br>    #include &lt;stdlib.h&gt; <br>    #include &lt;string.h&gt; <br>     <br>     <br>    STATICFN VOID ProcessDeviceSection(INT iType); <br>    STATICFN BOOL ParseDeviceLine(PSTR pszLine, PINT pnColors, PINT pcx, <br>        PINT pcy); <br>     <br>     <br>     <br>    /************************************************************************ <br>    * InitDeviceList <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID InitDeviceList(VOID) <br>    { <br>        /* <br>         * Allocate the standard icon devices. <br>         */ <br>        DeviceLinkAlloc(FT_ICON, ids(IDS_ICONDEVNAMEEGAVGA), 16, 32, 32); <br>        DeviceLinkAlloc(FT_ICON, ids(IDS_ICONDEVNAMEMONO), 2, 32, 32); <br>        DeviceLinkAlloc(FT_ICON, ids(IDS_ICONDEVNAMECGA), 2, 32, 16); <br>     <br>        ProcessDeviceSection(FT_ICON); <br>     <br>        /* <br>         * Allocate the standard cursor devices. <br>         */ <br>        DeviceLinkAlloc(FT_CURSOR, ids(IDS_CURDEVNAMEVGAMONO), 2, 32, 32); <br>        DeviceLinkAlloc(FT_CURSOR, ids(IDS_CURDEVNAMEVGACOLOR), 16, 32, 32); <br>     <br>        ProcessDeviceSection(FT_CURSOR); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ProcessDeviceSection <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID ProcessDeviceSection( <br>        INT iType) <br>    { <br>        PSTR pszSectionName; <br>        CHAR szValueBuf[CCHTEXTMAX]; <br>        CHAR szKeyNameBuf[CCHTEXTMAX]; <br>        PSTR pszKeyName; <br>        INT nColors; <br>        INT cx; <br>        INT cy; <br>     <br>        if (iType == FT_ICON) { <br>            pszSectionName = ids(IDS_ICONINISECTION); <br>        } <br>        else { <br>            pszSectionName = ids(IDS_CURSORINISECTION); <br>        } <br>     <br>        if (!GetPrivateProfileString(pszSectionName, NULL, "", <br>                szKeyNameBuf, sizeof(szKeyNameBuf), ids(IDS_IMAGEDITINI))) <br>            return; <br>     <br>        pszKeyName = szKeyNameBuf; <br>        while (*pszKeyName) { <br>            if (GetPrivateProfileString(pszSectionName, pszKeyName, "", <br>                    szValueBuf, sizeof(szValueBuf), ids(IDS_IMAGEDITINI))) { <br>                if (ParseDeviceLine(szValueBuf, &amp;nColors, &amp;cx, &amp;cy)) <br>                    DeviceLinkAlloc(iType, pszKeyName, nColors, cx, cy); <br>            } <br>     <br>            pszKeyName += strlen(pszKeyName) + 1; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ParseDeviceLine <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN BOOL ParseDeviceLine( <br>        PSTR pszLine, <br>        PINT pnColors, <br>        PINT pcx, <br>        PINT pcy) <br>    { <br>        static CHAR szSep[] = " ,"; <br>        PSTR pstr; <br>     <br>        if (!(pstr = strtok(pszLine, szSep))) <br>            return FALSE; <br>     <br>        *pnColors = atoi(pstr); <br>     <br>        if (!(pstr = strtok(NULL, szSep))) <br>            return FALSE; <br>     <br>        *pcx = atoi(pstr); <br>     <br>        if (!(pstr = strtok(NULL, szSep))) <br>            return FALSE; <br>     <br>        *pcy = atoi(pstr); <br>     <br>        return TRUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * DeviceLinkAlloc <br>    * <br>    * Allocates a DEVICE structure, initializes it with the given values <br>    * and adds it to the appropriate linked list.  Because these are <br>    * specified only at init time, there is no need to ever free them. <br>    * <br>    * There is a special case if the image type is FT_BITMAP.  Because <br>    * there is only one type of bitmap image device at any one time, <br>    * this routine does not really allocate a link for these.  Instead, <br>    * it uses a static structure for bitmaps.  It will be set to the <br>    * given values and a pointer to it will be returned.  This means <br>    * that for bitmaps, this function must be called every time that <br>    * the current bitmap image changes to set up the proper values in <br>    * the structure. <br>    * <br>    * Arguments: <br>    *   INT iType    - Type of image.  FT_* constant. <br>    *   PSTR pszName - Device name ("VGA", for example). <br>    *   INT nColors  - Number of colors. <br>    *   INT cx       - Width of image. <br>    *   INT cy       - Height of image. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    PDEVICE DeviceLinkAlloc( <br>        INT iType, <br>        PSTR pszName, <br>        INT nColors, <br>        INT cx, <br>        INT cy) <br>    { <br>        static DEVICE DeviceBitmap;     // Device structure for bitmaps. <br>        PDEVICE pDevice; <br>        PDEVICE pDeviceT; <br>        PDEVICE *ppDeviceHead; <br>     <br>        /* <br>         * Currently we only support 1 and 4 plane devices. <br>         */ <br>        if (nColors != 2 &amp;&amp; nColors != 16) { <br>            Message(MSG_BADDEVICECOLORS); <br>            return NULL; <br>        } <br>     <br>        /* <br>         * There is a limit to the size of image we will edit.  For icons <br>         * and cursors, the field that carries the dimensions is a byte, <br>         * so the size cannot be greater than 256.  This is also what <br>         * we limit bitmaps to. <br>         */ <br>        if (cx &lt; 1 || cx &gt; MAXIMAGEDIM || cy &lt; 1 || cy &gt; MAXIMAGEDIM) { <br>            Message(MSG_BADDEVICESIZE, MAXIMAGEDIM); <br>            return NULL; <br>        } <br>     <br>        /* <br>         * For bitmaps, don't really allocate a link, just reuse the <br>         * static DEVICE structure used for bitmaps. <br>         */ <br>        if (iType == FT_BITMAP) { <br>            pDevice = &amp;DeviceBitmap; <br>        } <br>        else { <br>            if (!(pDevice = (PDEVICE)MyAlloc(sizeof(DEVICE)))) <br>                return NULL; <br>     <br>            switch (iType) { <br>                case FT_ICON: <br>                    ppDeviceHead = &amp;gpIconDeviceHead; <br>                    gnIconDevices++; <br>                    break; <br>     <br>                case FT_CURSOR: <br>                    ppDeviceHead = &amp;gpCursorDeviceHead; <br>                    gnCursorDevices++; <br>                    break; <br>            } <br>        } <br>     <br>        pDevice-&gt;pDeviceNext = NULL; <br>        pDevice-&gt;iType = iType; <br>        pDevice-&gt;nColors = nColors; <br>        pDevice-&gt;cx = cx; <br>        pDevice-&gt;cy = cy; <br>     <br>        if (pszName) { <br>            strcpy(pDevice-&gt;szName, pszName); <br>            wsprintf(pDevice-&gt;szDesc, "%s %d-Color %dx%d",  //   hardcoded strings! <br>                    (LPSTR)pszName, nColors, cx, cy); <br>        } <br>        else { <br>            *pDevice-&gt;szName = '\0'; <br>            wsprintf(pDevice-&gt;szDesc, "%d-Color %dx%d", nColors, cx, cy); <br>        } <br>     <br>        /* <br>         * Because there is only one bitmap link, there is no need <br>         * for a list for these, only icons and cursors. <br>         */ <br>        if (iType != FT_BITMAP) { <br>            /* <br>             * Insert the link in the specified list. <br>             */ <br>            if (!(*ppDeviceHead)) { <br>                /* <br>                 * This is the first one.  Start the list. <br>                 */ <br>                *ppDeviceHead = pDevice; <br>            } <br>            else { <br>                /* <br>                 * Find the end of the list and tack on the new link. <br>                 */ <br>                for (pDeviceT = *ppDeviceHead; pDeviceT-&gt;pDeviceNext; <br>                        pDeviceT = pDeviceT-&gt;pDeviceNext) <br>                    ; <br>     <br>                pDeviceT-&gt;pDeviceNext = pDevice; <br>            } <br>        } <br>     <br>        return pDevice; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * DeviceLinkFind <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    PDEVICE DeviceLinkFind( <br>        PDEVICE pDeviceHead, <br>        INT nColors, <br>        INT cx, <br>        INT cy) <br>    { <br>        PDEVICE pDevice; <br>     <br>        /* <br>         * Search the specified list. <br>         */ <br>        for (pDevice = pDeviceHead; pDevice; pDevice = pDevice-&gt;pDeviceNext) { <br>            /* <br>             * Is this a match? <br>             */ <br>            if (pDevice-&gt;nColors == nColors &amp;&amp; pDevice-&gt;cx == cx &amp;&amp; <br>                    pDevice-&gt;cy == cy) <br>                break; <br>        } <br>     <br>        return pDevice; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * DeviceLinkUsed <br>    * <br>    * This function returns TRUE if the specified device is used in <br>    * the current image list. <br>    * <br>    * Arguments: <br>    *   PDEVICE pDevice - Device to look for. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL DeviceLinkUsed( <br>        PDEVICE pDevice) <br>    { <br>        PIMAGEINFO pImage; <br>     <br>        for (pImage = gpImageHead; pImage; pImage = pImage-&gt;pImageNext) { <br>            if (pImage-&gt;pDevice == pDevice) <br>                return TRUE; <br>        } <br>     <br>        return FALSE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
