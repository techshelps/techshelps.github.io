<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOOLBOX.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5489"></a>TOOLBOX.C</h2>
<pre><code>/****************************************************************************/ <br>    /*                                                                          */ <br>    /*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>    /*                           All Rights Reserved                            */ <br>    /*                                                                          */ <br>    /****************************************************************************/ <br>    /****************************** Module Header ******************************* <br>    * Module Name: toolbox.c <br>    * <br>    * Contains routines that handle the toolbox. <br>    * <br>    * History: <br>    * <br>    * 04/30/91 - Copied from DlgEdit. <br>    * <br>    ****************************************************************************/ <br>     <br>    #include "imagedit.h" <br>    #include "dialogs.h" <br> <br> #include &lt;windowsx.h&gt; <br>     <br>    #define TOOLBOXCOLUMNS  2       // Columns in the Toolbox. <br>     <br>    /* <br>     * Style of the toolbox window. <br>     */ <br>    #define TOOLBOXSTYLE    (WS_POPUP | WS_CLIPSIBLINGS | WS_CAPTION | WS_SYSMENU) <br>     <br>     <br>    STATICFN VOID NEAR ToolboxDrawBitmap(HDC hDC, INT tool); <br>     <br>     <br>    /* <br>     * Dimensions of a tool button bitmap. <br>     */ <br>    static INT cxToolBtn; <br>    static INT cyToolBtn; <br>     <br>    /* <br>     * Index to the last available tool.  If tools at the end of the <br>     * toolbox are disabled, this number gets lowered. <br>     */ <br>    static INT iToolLast = CTOOLS - 1; <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ToolboxCreate <br>    * <br>    * This function creates the toolbox window. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID ToolboxCreate(VOID) <br>    { <br>        BITMAP bmp; <br>        INT i; <br>        INT x; <br>        INT y; <br>        INT cx; <br>        INT cy; <br>        INT cxDummy; <br>        INT cyDummy; <br>        RECT rc; <br>        RECT rcClient; <br>        POINT pt; <br>        BOOL fMaximized; <br>     <br>        /* <br>         * Load the bitmaps. <br>         */ <br>        for (i = 0; i &lt; CTOOLS; i++) { <br>            if (!(gaTools[i].hbmToolBtnUp = LoadBitmap(ghInst, <br>                    MAKEINTRESOURCE(gaTools[i].idbmToolBtnUp)))) <br>                return; <br>     <br>            if (!(gaTools[i].hbmToolBtnDown = LoadBitmap(ghInst, <br>                    MAKEINTRESOURCE(gaTools[i].idbmToolBtnDown)))) <br>                return; <br>        } <br>     <br>        /* <br>         * Get the dimensions of the tool button bitmaps. <br>         */ <br>        GetObject(gaTools[0].hbmToolBtnUp, sizeof(BITMAP), (PSTR)&amp;bmp); <br>        cxToolBtn = bmp.bmWidth; <br>        cyToolBtn = bmp.bmHeight; <br>     <br>        /* <br>         * Calculate the required window size for the client area <br>         * size we want.  The size leaves room for a margin, and <br>         * assumes that adjacent buttons overlap their borders by <br>         * one pixel. <br>         */ <br>        rc.left = 0; <br>        rc.top = 0; <br>        rc.right = PALETTEMARGIN + ((cxToolBtn - 1) * 2) + 1 + PALETTEMARGIN; <br>        rc.bottom = PALETTEMARGIN + ((cyToolBtn - 1) * <br>                (CTOOLS / 2)) + 1 + PALETTEMARGIN; <br>        AdjustWindowRect(&amp;rc, TOOLBOXSTYLE, FALSE); <br>        cx = rc.right - rc.left; <br>        cy = rc.bottom - rc.top; <br>     <br>        /* <br>         * Get the saved position of the Toolbox.  Note that we throw away <br>         * the size fields, because we just calculated the required size. <br>         */ <br>        if (!ReadWindowPos(szTBPos, &amp;x, &amp;y, &amp;cxDummy, &amp;cyDummy, &amp;fMaximized)) { <br>            /* <br>             * The previous position of the Toolbox couldn't be found. <br>             * Position the toolbox to the upper right corner of the <br>             * client area of the editor, but make sure it is completely <br>             * visible. <br>             */ <br>            GetClientRect(ghwndMain, &amp;rcClient); <br>            pt.x = rcClient.right - cx - (2 * PALETTEMARGIN); <br>            pt.y = rcClient.top + gcyPropBar + (2 * PALETTEMARGIN); <br>            ClientToScreen(ghwndMain, &amp;pt); <br>            SetRect(&amp;rc, pt.x, pt.y, pt.x + cx, pt.y + cy); <br>            FitRectToScreen(&amp;rc); <br>            x = rc.left; <br>            y = rc.top; <br>        } <br>     <br>        if (!(ghwndToolbox = CreateWindow(szToolboxClass, NULL, TOOLBOXSTYLE, <br>                x, y, cx, cy, ghwndMain, NULL, ghInst, NULL))) <br>            return; <br>     <br>        /* <br>         * Create the buttons. <br>         */ <br>        x = PALETTEMARGIN; <br>        y = PALETTEMARGIN; <br>        for (i = 0; i &lt; CTOOLS; i++) { <br>            CreateWindow(szToolBtnClass, NULL, <br>                    WS_CHILD | WS_VISIBLE, <br>                    x, y, cxToolBtn, cyToolBtn, <br>                    ghwndToolbox, (HMENU)i, ghInst, NULL); <br>     <br>            if (x == PALETTEMARGIN) { <br>                x += cxToolBtn - 1; <br>            } <br>            else { <br>                x = PALETTEMARGIN; <br>                y += cyToolBtn - 1; <br>            } <br>        } <br>     <br>        ToolboxUpdate(); <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ToolboxShow <br>    * <br>    * This function shows or hides the toolbox window. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID ToolboxShow( <br>        BOOL fShow) <br>    { <br>        if (fShow) <br>            ShowWindow(ghwndToolbox, SW_SHOWNA); <br>        else <br>            ShowWindow(ghwndToolbox, SW_HIDE); <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ToolboxUpdate <br>    * <br>    * This function updates the toolbox.  It should be called any time that <br>    * a new file is opened/created for editing. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID ToolboxUpdate(VOID) <br>    { <br>        if (!ghwndToolbox) <br>            return; <br>     <br>        if (giType == FT_CURSOR) { <br>            ShowWindow(GetDlgItem(ghwndToolbox, TOOL_HOTSPOT), SW_SHOWNA); <br>            iToolLast = CTOOLS - 1; <br>        } <br>        else { <br>            ShowWindow(GetDlgItem(ghwndToolbox, TOOL_HOTSPOT), SW_HIDE); <br>            iToolLast = TOOL_HOTSPOT - 1; <br>            if (gCurTool == TOOL_HOTSPOT) <br>                ToolboxSelectTool(TOOL_FIRST); <br>        } <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ToolboxWndProc <br>    * <br>    * This is the window procedure for the toolbox window. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    WINDOWPROC ToolboxWndProc( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        switch (msg) { <br>            case WM_CREATE: <br>                { <br>                    HMENU hmenu = GetSystemMenu(hwnd, FALSE); <br>     <br>                    RemoveMenu(hmenu, 7, MF_BYPOSITION);    // Second separator. <br>                    RemoveMenu(hmenu, 5, MF_BYPOSITION);    // First separator. <br>     <br>                    RemoveMenu(hmenu, SC_RESTORE, MF_BYCOMMAND); <br>                    RemoveMenu(hmenu, SC_SIZE, MF_BYCOMMAND); <br>                    RemoveMenu(hmenu, SC_MINIMIZE, MF_BYCOMMAND); <br>                    RemoveMenu(hmenu, SC_MAXIMIZE, MF_BYCOMMAND); <br>                    RemoveMenu(hmenu, SC_TASKLIST, MF_BYCOMMAND); <br>                } <br>     <br>                return 0; <br>     <br>            case WM_KEYDOWN: <br>                { <br>                    INT iToolNext; <br>     <br>                    switch (wParam) { <br>                        case VK_UP: <br>                            if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                    (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                                break; <br>     <br>                            /* <br>                             * Go up a row, but don't go beyond the top. <br>                             */ <br>                            iToolNext = gCurTool - TOOLBOXCOLUMNS; <br>                            if (iToolNext &lt; 0) <br>                                break; <br>     <br>                            ToolboxSelectTool(iToolNext); <br>     <br>                            break; <br>     <br>                        case VK_DOWN: <br>                            if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                    (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                                break; <br>     <br>                            /* <br>                             * Go down a row, but don't go beyond the bottom. <br>                             */ <br>                            iToolNext = gCurTool + TOOLBOXCOLUMNS; <br>                            if (iToolNext &gt; iToolLast) <br>                                break; <br>     <br>                            ToolboxSelectTool(iToolNext); <br>     <br>                            break; <br>     <br>                        case VK_LEFT: <br>                            if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                    (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                                break; <br>     <br>                            /* <br>                             * Already at left edge. <br>                             */ <br>                            if (!(gCurTool % TOOLBOXCOLUMNS)) <br>                                break; <br>     <br>                            /* <br>                             * Go left a column. <br>                             */ <br>                            ToolboxSelectTool(gCurTool - 1); <br>     <br>                            break; <br>     <br>                        case VK_RIGHT: <br>                            if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                    (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                                break; <br>     <br>                            /* <br>                             * Already at right edge. <br>                             */ <br>                            if ((gCurTool % TOOLBOXCOLUMNS) == TOOLBOXCOLUMNS - 1) <br>                                break; <br>     <br>                            /* <br>                             * Don't go off the end of the available tools. <br>                             */ <br>                            if (gCurTool + 1 &gt; iToolLast) <br>                                break; <br>     <br>                            /* <br>                             * Go right a column. <br>                             */ <br>                            ToolboxSelectTool(gCurTool + 1); <br>     <br>                            break; <br>     <br>                        case VK_TAB: <br>                            if (GetKeyState(VK_CONTROL) &amp; 0x8000) <br>                                break; <br>     <br>                            /* <br>                             * Is the shift key pressed also? <br>                             */ <br>                            if (GetKeyState(VK_SHIFT) &amp; 0x8000) { <br>                                if (gCurTool == TOOL_FIRST) <br>                                    iToolNext = iToolLast; <br>                                else <br>                                    iToolNext = gCurTool - 1; <br>                            } <br>                            else { <br>                                if (gCurTool == iToolLast) <br>                                    iToolNext = TOOL_FIRST; <br>                                else <br>                                    iToolNext = gCurTool + 1; <br>                            } <br>     <br>                            ToolboxSelectTool(iToolNext); <br>     <br>                            break; <br>     <br>                        case VK_END: <br>                            if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                    (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                                break; <br>     <br>                            ToolboxSelectTool(iToolLast); <br>     <br>                            break; <br>     <br>                        case VK_HOME: <br>                        case VK_ESCAPE: <br>                            if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                    (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                                break; <br>     <br>                            ToolboxSelectTool(TOOL_FIRST); <br>     <br>                            break; <br>                    } <br>                } <br>     <br>                break; <br>     <br>            case WM_ACTIVATE: <br>                if (GET_WM_ACTIVATE_STATE(wParam, lParam)) <br>                    gidCurrentDlg = DID_TOOLBOX; <br>     <br>                break; <br>     <br>            case  WM_PAINT: <br>                { <br>                    HDC hdc; <br>                    PAINTSTRUCT ps; <br>     <br>                    hdc = BeginPaint(hwnd, &amp;ps); <br>                    DrawMarginBorder(hwnd, hdc); <br>                    EndPaint(hwnd, &amp;ps); <br>                } <br>     <br>                break; <br>     <br>            case WM_CLOSE: <br>                /* <br>                 * The user closed the toolbox from the system menu. <br>                 * Hide the toolbox (we don't actually destroy it so <br>                 * that it will appear in the same spot when they show <br>                 * it again). <br>                 */ <br>                ToolboxShow(FALSE); <br>                gfShowToolbox = FALSE; <br>                break; <br>     <br>            case WM_DESTROY: <br>                { <br>                    INT i; <br>                    RECT rc; <br>     <br>                    for (i = 0; i &lt; CTOOLS; i++) { <br>                        DeleteObject(gaTools[i].hbmToolBtnUp); <br>                        gaTools[i].hbmToolBtnUp = NULL; <br>                        DeleteObject(gaTools[i].hbmToolBtnDown); <br>                        gaTools[i].hbmToolBtnDown = NULL; <br>                    } <br>     <br>                    /* <br>                     * Save the position of the toolbox. <br>                     */ <br>                    GetWindowRect(hwnd, &amp;rc); <br>                    WriteWindowPos(&amp;rc, FALSE, szTBPos); <br>     <br>                    /* <br>                     * Null out the global window handle for the toolbox <br>                     * for safety's sake. <br>                     */ <br>                    ghwndToolbox = NULL; <br>                } <br>     <br>                break; <br>     <br>            default: <br>                return DefWindowProc(hwnd, msg, wParam, lParam); <br>        } <br>     <br>        return 0; <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ToolBtnWndProc <br>    * <br>    * This is the window procedure for the buttons in the toolbox window. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    WINDOWPROC ToolBtnWndProc( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        switch (msg) { <br>            case WM_LBUTTONDOWN: <br>                /* <br>                 * Select the tool that was clicked on. <br>                 */ <br>                ToolboxSelectTool((UINT)GetWindowLong((hwnd), GWL_ID)); <br>     <br>                break; <br>     <br>            case WM_PAINT: <br>                { <br>                    HDC hDC; <br>                    PAINTSTRUCT ps; <br>     <br>                    hDC = BeginPaint(hwnd, &amp;ps); <br>                    ToolboxDrawBitmap(hDC, (UINT)GetWindowLong((hwnd), GWL_ID)); <br>                    EndPaint(hwnd, &amp;ps); <br>                } <br>     <br>                break; <br>     <br>            default: <br>                return DefWindowProc(hwnd, msg, wParam, lParam); <br>        } <br>     <br>        return 0; <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ToolboxDrawBitmap <br>    * <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    STATICFN VOID NEAR ToolboxDrawBitmap( <br>        HDC hDC, <br>        INT tool) <br>    { <br>        HDC hMemDC; <br>        HBITMAP hbmOld; <br>     <br>        /* <br>         * Draw the image. <br>         */ <br>        hMemDC = CreateCompatibleDC(hDC); <br>        hbmOld = SelectObject(hMemDC, (tool == gCurTool) ? <br>                gaTools[tool].hbmToolBtnDown : gaTools[tool].hbmToolBtnUp); <br>        BitBlt(hDC, 0, 0, cxToolBtn, cyToolBtn, hMemDC, 0, 0, SRCCOPY); <br>        SelectObject(hMemDC, hbmOld); <br>        DeleteDC(hMemDC); <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ToolboxSelectTool <br>    * <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID ToolboxSelectTool( <br>        INT tool) <br>    { <br>        if (gCurTool != tool) { <br>            if (ghwndToolbox) { <br>                InvalidateRect(GetDlgItem(ghwndToolbox, gCurTool), NULL, FALSE);            InvalidateRect(GetDlgItem(ghwndToolbox, tool), NULL, FALSE); <br>            } <br>     <br>            gCurTool = tool; <br>            gpfnDrawProc = gaTools[gCurTool].pfnDrawProc; <br>        } <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
