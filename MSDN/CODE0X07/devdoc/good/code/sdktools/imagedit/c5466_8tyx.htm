<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILE.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5469"></a>FILE.C</h2>
<pre><code>/****************************************************************************/ <br>    /*                                                                          */ <br>    /*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>    /*                           All Rights Reserved                            */ <br>    /*                                                                          */ <br>    /****************************************************************************/ <br>    /****************************** Module Header ******************************* <br>    * Module Name: file.c <br>    * <br>    * Contains routines for handling files. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    #include "imagedit.h" <br>    #include "dialogs.h" <br>     <br>    #include &lt;string.h&gt; <br> <br> #include &lt;windowsx.h&gt; <br>    #include &lt;commdlg.h&gt; <br>     <br>     <br>    #ifdef WIN16 <br>    typedef BOOL (APIENTRY *LPOFNHOOKPROC) (HWND, UINT, WPARAM, LONG); <br>    #endif <br>     <br>     <br>    STATICFN VOID NEAR AddFilterString(PSTR pszBuf, PSTR pszType, PSTR pszExt, <br>        BOOL fFirst); <br>    STATICFN PSTR NEAR DefExtFromFilter(INT index, PSTR pszFilter); <br>    STATICFN BOOL NEAR LoadFile(PSTR pszFullFileName); <br>    STATICFN INT NEAR GetTypeFromExt(PSTR pszFileName); <br>    STATICFN VOID NEAR FileCat(PSTR pchName, PSTR pchCat); <br>     <br>     <br>    static OPENFILENAME ofn; <br>     <br>     <br>     <br>    /************************************************************************ <br>    * SetFileName <br>    * <br>    * Updates the globals that contain the file name of the currently <br>    * loaded file.  This routine will also cause the title bar to <br>    * be udpated with the new name. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID SetFileName( <br>        PSTR pszFullFileName) <br>    { <br>        CHAR szTitle[CCHMAXPATH]; <br>        WIN32_FIND_DATA ffbuf; <br>        CHAR *pch; <br>     <br>        if (pszFullFileName) { <br>            HANDLE hfind; <br>            strcpy(gszFullFileName, pszFullFileName); <br>            gpszFileName = FileInPath(gszFullFileName); <br>     <br>            if((hfind = FindFirstFile( pszFullFileName, &amp;ffbuf)) != <br>                    INVALID_HANDLE_VALUE) { <br>     <br>                strcpy(gpszFileName, ffbuf.cFileName); <br>                FindClose(hfind); <br>            } <br>     <br>        } <br>        else { <br>            *gszFullFileName = '\0'; <br>            gpszFileName = NULL; <br>        } <br>     <br>        strcpy(szTitle, ids(IDS_PGMTITLE)); <br>        strcat(szTitle, " - "); <br>        pch = gpszFileName ? gpszFileName : ids(IDS_UNTITLED); <br>        strncat(szTitle, pch, sizeof(szTitle) - strlen(szTitle)); <br>        szTitle[CCHMAXPATH-1] = '\0'; <br>        SetWindowText(ghwndMain, szTitle); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * FileInPath <br>    * <br>    * This function takes a path and returns a pointer to the file name <br>    * portion of it.  For instance, it will return a pointer to <br>    * "abc.res" if it is given the following path: "c:\windows\abc.res". <br>    * <br>    * Arguments: <br>    *   PSTR pstrPath - Path to look through. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    PSTR FileInPath( <br>        PSTR pstrPath) <br>    { <br>        PSTR pstr; <br>     <br>        pstr = pstrPath + strlen(pstrPath); <br>        while (pstr &gt; pstrPath) { <br>            pstr = FAR2NEAR(AnsiPrev(pstrPath, pstr)); <br>            if (*pstr == '\\' || *pstr == ':' || *pstr == '/') { <br>                pstr = FAR2NEAR(AnsiNext(pstr)); <br>                break; <br>            } <br>        } <br>     <br>        return pstr; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ClearResource <br>    * <br>    * Resets the editor back to a neutral state before editing any image. <br>    * This function can be called before starting to edit a new file <br>    * (but not just a new image).  Files should be saved before calling <br>    * this routine, because the entire image list is destroyed. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID ClearResource(VOID) <br>    { <br>        ImageLinkFreeList(); <br>     <br>        SetFileName(NULL); <br>     <br>        gnImages = 0; <br>        fImageDirty = FALSE; <br>        fFileDirty = FALSE; <br>        gpImageCur = NULL; <br>     <br>        /* <br>         * Hide the workspace and view windows. <br>         */ <br>        ShowWindow(ghwndWork, SW_HIDE); <br>        ViewShow(FALSE); <br>     <br>        /* <br>         * Destroy the image DC's. <br>         */ <br>        ImageDCDelete(); <br>     <br>        /* <br>         * Update the properties bar. <br>         */ <br>        PropBarClearPos(); <br>        PropBarClearSize(); <br>        PropBarUpdate(); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * OpenDlg <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL OpenDlg( <br>        PSTR pszFileName, <br>        INT iType) <br>    { <br>        BOOL fGotName; <br>        INT idDlg; <br>        INT idPrevDlg; <br>        CHAR szFilter[CCHTEXTMAX]; <br>     <br>        pszFileName[0] = '\0'; <br>     <br>        switch (iType) { <br>            case FT_BITMAP: <br>            case FT_ICON: <br>            case FT_CURSOR: <br>                AddFilterString(szFilter, ids(IDS_BMPFILTER), <br>                        ids(IDS_BMPFILTEREXT), TRUE); <br>                AddFilterString(szFilter, ids(IDS_ICOFILTER), <br>                        ids(IDS_ICOFILTEREXT), FALSE); <br>                AddFilterString(szFilter, ids(IDS_CURFILTER), <br>                        ids(IDS_CURFILTEREXT), FALSE); <br>                AddFilterString(szFilter, ids(IDS_ALLFILTER), <br>                        ids(IDS_ALLFILTEREXT), FALSE); <br>     <br>                ofn.nFilterIndex = iType + 1; <br>                idDlg = DID_COMMONFILEOPEN; <br>     <br>                break; <br>     <br>            case FT_PALETTE: <br>                AddFilterString(szFilter, ids(IDS_PALFILTER), <br>                        ids(IDS_PALFILTEREXT), TRUE); <br>                AddFilterString(szFilter, ids(IDS_ALLFILTER), <br>                        ids(IDS_ALLFILTEREXT), FALSE); <br>     <br>                ofn.nFilterIndex = 1; <br>                idDlg = DID_COMMONFILEOPENPAL; <br>     <br>                break; <br>        } <br>     <br>        ofn.lStructSize = sizeof(OPENFILENAME); <br>        ofn.hwndOwner = ghwndMain; <br>        ofn.hInstance = NULL; <br>        ofn.lpstrFilter = szFilter; <br>        ofn.lpstrCustomFilter = NULL; <br>        ofn.nMaxCustFilter = 0; <br>        ofn.lpstrFile = pszFileName; <br>        ofn.nMaxFile = CCHMAXPATH; <br>        ofn.lpstrFileTitle = NULL; <br>        ofn.nMaxFileTitle = 0; <br>        ofn.lpstrInitialDir = NULL; <br>        ofn.lpstrTitle = NULL; <br>        ofn.Flags = OFN_HIDEREADONLY | OFN_SHOWHELP | OFN_FILEMUSTEXIST | <br>                OFN_ENABLEHOOK; <br>        ofn.nFileOffset = 0; <br>        ofn.nFileExtension = 0; <br>        ofn.lpstrDefExt = (LPCSTR)DefExtFromFilter((INT)ofn.nFilterIndex - 1, <br>                (PSTR)ofn.lpstrFilter); <br>        ofn.lCustData = 0; <br>        ofn.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance( <br>                (FARPROC)GetOpenFileNameHook, ghInst); <br>        ofn.lpTemplateName = NULL; <br>     <br>        EnteringDialog(idDlg, &amp;idPrevDlg, TRUE); <br>        fGotName = GetOpenFileName(&amp;ofn); <br>        EnteringDialog(idPrevDlg, NULL, FALSE); <br>     <br>        FreeProcInstance((FARPROC)ofn.lpfnHook); <br>     <br>        return fGotName; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * SaveAsDlg <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL SaveAsDlg( <br>        PSTR pszFileName, <br>        INT iType) <br>    { <br>        INT idDlg; <br>        BOOL fGotName; <br>        INT idPrevDlg; <br>        CHAR szFilter[CCHTEXTMAX]; <br>     <br>        switch (iType) { <br>            case FT_BITMAP: <br>                AddFilterString(szFilter, ids(IDS_BMPFILTER), <br>                        ids(IDS_BMPFILTEREXT), TRUE); <br>     <br>                ofn.lpstrDefExt = ids(IDS_DEFEXTBMP); <br>                idDlg = DID_COMMONFILESAVE; <br>     <br>                break; <br>     <br>            case FT_ICON: <br>                AddFilterString(szFilter, ids(IDS_ICOFILTER), <br>                        ids(IDS_ICOFILTEREXT), TRUE); <br>     <br>                ofn.lpstrDefExt = ids(IDS_DEFEXTICO); <br>                idDlg = DID_COMMONFILESAVE; <br>     <br>                break; <br>     <br>            case FT_CURSOR: <br>                AddFilterString(szFilter, ids(IDS_CURFILTER), <br>                        ids(IDS_CURFILTEREXT), TRUE); <br>     <br>                ofn.lpstrDefExt = ids(IDS_DEFEXTCUR); <br>                idDlg = DID_COMMONFILESAVE; <br>     <br>                break; <br>     <br>            case FT_PALETTE: <br>                AddFilterString(szFilter, ids(IDS_PALFILTER), <br>                        ids(IDS_PALFILTEREXT), TRUE); <br>     <br>                ofn.lpstrDefExt = ids(IDS_DEFEXTPAL); <br>                idDlg = DID_COMMONFILESAVEPAL; <br>     <br>                break; <br>        } <br>     <br>        ofn.lStructSize = sizeof(OPENFILENAME); <br>        ofn.hwndOwner = ghwndMain; <br>        ofn.hInstance = NULL; <br>        ofn.lpstrFilter = szFilter; <br>        ofn.lpstrCustomFilter = NULL; <br>        ofn.nMaxCustFilter = 0; <br>        ofn.nFilterIndex = 1; <br>        ofn.lpstrFile = pszFileName; <br>        ofn.nMaxFile = CCHMAXPATH; <br>        ofn.lpstrFileTitle = NULL; <br>        ofn.nMaxFileTitle = 0; <br>        ofn.lpstrInitialDir = NULL; <br>        ofn.lpstrTitle = NULL; <br>        ofn.Flags = OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY | OFN_SHOWHELP; <br>        ofn.nFileOffset = 0; <br>        ofn.nFileExtension = 0; <br>        ofn.lCustData = 0; <br>        ofn.lpfnHook = NULL; <br>        ofn.lpTemplateName = NULL; <br>     <br>        EnteringDialog(idDlg, &amp;idPrevDlg, TRUE); <br>        fGotName = GetSaveFileName(&amp;ofn); <br>        EnteringDialog(idPrevDlg, NULL, FALSE); <br>     <br>        return fGotName; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * GetOpenFileNameHook <br>    * <br>    * This function is the hook function for the Common Dialogs <br>    * GetOpenFileName funtion.  It is used to be sure the default <br>    * extension that is used when the function exits is the same <br>    * as the image file type that the user specifies they want <br>    * opened. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    DIALOGPROC GetOpenFileNameHook( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        switch (msg) { <br>            case WM_INITDIALOG: <br>                /* <br>                 * Tell Windows to set the focus for me. <br>                 */ <br>                return TRUE; <br>     <br>            case WM_COMMAND: <br>                /* <br>                 * Did they change the type of file from the File Type <br>                 * combo box? <br>                 */ <br>                if (GET_WM_COMMAND_ID(wParam, lParam) == DID_COMMDLG_TYPECOMBO &amp;&amp; <br>                        GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE) { <br>                    INT iSelect; <br>     <br>                    /* <br>                     * Get the selected file type, then change the default <br>                     * extension field of the ofn structure to match it. <br>                     * This ensures that the proper default extension <br>                     * gets added to the end of the file name if the user <br>                     * does not specify an extension explicitly. <br>                     */ <br>                    if ((iSelect = (INT)SendDlgItemMessage(hwnd, <br>                            DID_COMMDLG_TYPECOMBO, CB_GETCURSEL, 0, 0L)) <br>                            != CB_ERR) { <br>                        ofn.lpstrDefExt = (LPCSTR)DefExtFromFilter( <br>                                iSelect, (PSTR)ofn.lpstrFilter); <br>                    } <br>                } <br>     <br>                break; <br>        } <br>     <br>        /* <br>         * Process the message normally. <br>         */ <br>        return FALSE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * AddFilterString <br>    * <br>    * This function adds a filter string pair to a filter string for <br>    * use by the common dialog open/save file functions.  The string <br>    * pair will be added to the end of the given filter string, unless <br>    * fFirst is TRUE, in which case it will be written out to the <br>    * start of the buffer.  A double null will always be written out <br>    * at the end of the filter string. <br>    * <br>    * Arguments: <br>    *   PSTR pszBuf  - Buffer to write to. <br>    *   PSTR pszType - Type string.  Something like "Icon files (*.ico)". <br>    *   PSTR pszExt  - Extension string.  Something like "*.ico". <br>    *   BOOL fFirst  - TRUE if this is the first filter string in the <br>    *                  buffer.  If FALSE, the new filter string pair will <br>    *                  be added to the end of pszBuf. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR AddFilterString( <br>        PSTR pszBuf, <br>        PSTR pszType, <br>        PSTR pszExt, <br>        BOOL fFirst) <br>    { <br>        PSTR psz; <br>     <br>        psz = pszBuf; <br>     <br>        /* <br>         * If this is not the first filter string pair, skip to the <br>         * terminating double null sequence. <br>         */ <br>        if (!fFirst) { <br>            while (*psz || *(psz + 1)) <br>                psz++; <br>     <br>            psz++; <br>        } <br>     <br>        strcpy(psz, pszType); <br>        psz += strlen(pszType) + 1; <br>        strcpy(psz, pszExt); <br>        psz += strlen(pszExt) + 1; <br>        *psz = '\0'; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * DefExtFromFilter <br>    * <br>    * This function returns the default extension for the given index <br>    * from the specified filter string chain.  The filter string chain <br>    * is in the format expected by the GetSaveFileName function. <br>    * <br>    * It will return NULL if the filter extension found is "*.*". <br>    * <br>    * Arguments: <br>    *   INT index      - Zero based index to the filter string. <br>    *   PSTR pszFilter - Pointer to the start of the filter chain. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN PSTR NEAR DefExtFromFilter( <br>        INT index, <br>        PSTR pszFilter) <br>    { <br>        if (!pszFilter) <br>            return NULL; <br>     <br>        /* <br>         * Skip to the specified filter string pair. <br>         */ <br>        while (index--) { <br>            pszFilter += strlen(pszFilter) + 1; <br>            pszFilter += strlen(pszFilter) + 1; <br>        } <br>     <br>        /* <br>         * Skip the first string, then skip the '*' and the '.'. <br>         */ <br>        pszFilter += strlen(pszFilter) + 1 + 1 + 1; <br>     <br>        /* <br>         * If the string found was "*.*", return NULL for the default <br>         * extension. <br>         */ <br>        if (*pszFilter == '*') <br>            return NULL; <br>     <br>        /* <br>         * Return a pointer to the default extension.  This will be <br>         * something like "bmp" or "ico". <br>         */ <br>        return pszFilter; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * VerifySaveFile <br>    * <br>    * Prompts the user if they want to save the current file to disk. <br>    * If Yes, calls the appropriate save routine. <br>    * <br>    * Returns: <br>    *   Returns TRUE if either the file was not dirty (no save was done) <br>    *   or if it was and the user did not want to save it or the file <br>    *   was dirty and the user wanted to save it and the save was <br>    *   successful. <br>    * <br>    *   Returns FALSE if the user cancelled the operation, or an error <br>    *   occured with the save. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL VerifySaveFile(VOID) <br>    { <br>        if (fImageDirty || fFileDirty) { <br>            switch (Message(MSG_SAVEFILE, <br>                    gpszFileName ? gpszFileName : ids(IDS_UNTITLED))) { <br>                case IDYES: <br>                    return SaveFile(FALSE); <br>     <br>                case IDNO: <br>                    fImageDirty = FALSE; <br>                    break; <br>     <br>                case IDCANCEL: <br>                    return FALSE; <br>            } <br>        } <br>     <br>        return TRUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * SaveFile <br>    * <br>    * Does a save of the current file.  If the file is untitled, it <br>    * will ask the user for a file name. <br>    * <br>    * Arguments: <br>    *   BOOL fSaveAs - TRUE to force a Save As operation (always prompts <br>    *                  for the file name). <br>    * <br>    * Returns: <br>    *   Returns TRUE if the save was successful. <br>    * <br>    *   Returns FALSE if the user cancelled the operation, or an error <br>    *   occured with the save. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL SaveFile( <br>        BOOL fSaveAs) <br>    { <br>        CHAR szFileName[CCHMAXPATH]; <br>     <br>        if (gnImages == 0) { <br>            Message(MSG_NOIMAGES); <br>            return FALSE; <br>        } <br>     <br>        if (gpszFileName) <br>            strcpy(szFileName, gszFullFileName); <br>        else <br>            *szFileName = '\0'; <br>     <br>        if (fSaveAs || !gpszFileName) { <br>            if (!SaveAsDlg(szFileName, giType)) <br>                return FALSE; <br>        } <br>     <br>        switch (giType) { <br>            case FT_BITMAP: <br>                return SaveBitmapFile(szFileName); <br>     <br>            case FT_ICON: <br>            case FT_CURSOR: <br>                return SaveIconCursorFile(szFileName, giType); <br>        } <br>     <br>        return FALSE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * OpenAFile <br>    * <br>    * Prompts for a file name to open and then does the loading of it. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL OpenAFile(VOID) <br>    { <br>        CHAR szFileName[CCHMAXPATH]; <br>     <br>        if (OpenDlg(szFileName, giType)) { <br>            /* <br>             * Clear out the current resource. <br>             */ <br>            ClearResource(); <br>     <br>            LoadFile(szFileName); <br>     <br>            return TRUE; <br>        } <br>        else { <br>            return FALSE; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * LoadFile <br>    * <br>    * Loads the specified file for editing. <br>    * <br>    * Arguments: <br>    *   PSTR pszFullFileName - Full path name to the file to load. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN BOOL NEAR LoadFile( <br>        PSTR pszFullFileName) <br>    { <br>        switch (GetTypeFromExt(pszFullFileName)) { <br>            case FT_BITMAP: <br>                return LoadBitmapFile(pszFullFileName); <br>     <br>            case FT_ICON: <br>                return LoadIconCursorFile(pszFullFileName, TRUE); <br>     <br>            case FT_CURSOR: <br>                return LoadIconCursorFile(pszFullFileName, FALSE); <br>        } <br>     <br>        return FALSE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * GetTypeFromExt <br>    * <br>    * Returns the type of file based on it's file name extension. <br>    * <br>    * Arguments: <br>    *   PSTR pszFileName - File name to check. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN INT NEAR GetTypeFromExt( <br>        PSTR pszFileName) <br>    { <br>        PSTR pszExt; <br>     <br>        pszExt = pszFileName + strlen(pszFileName) - 3; <br>     <br>        if (strcmpi(pszExt, ids(IDS_DEFEXTICO)) == 0) <br>            return FT_ICON; <br>        else if (strcmpi(pszExt, ids(IDS_DEFEXTCUR)) == 0) <br>            return FT_CURSOR; <br>        else <br>            return FT_BITMAP; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * OpenCmdLineFile <br>    * <br>    * Handles opening of the file specified on the command line. <br>    * <br>    * History: <br>    * Nov 7, 1989   Byron Dazey - Created <br>    * <br>    ************************************************************************/ <br>     <br>    VOID OpenCmdLineFile( <br>        PSTR pstrFileName) <br>    { <br>        CHAR szFullPath[CCHMAXPATH]; <br>        OFSTRUCT OfStruct; <br>     <br>        strcpy(szFullPath, pstrFileName); <br>     <br>        /* <br>         * If the file name does not already have an extension, <br>         * assume it is a bitmap file and add a .BMP extension <br>         * to it. <br>         */ <br>        FileCat(szFullPath, ids(IDS_DOTBMP)); <br>     <br>        if ((HFILE)OpenFile(szFullPath, &amp;OfStruct, OF_EXIST) == (HFILE)-1) { <br>            Message(MSG_CANTOPEN, pstrFileName); <br>        } <br>        else { <br>            LoadFile(OfStruct.szPathName); <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * FileCat <br>    * <br>    * This function checks for an extension on the give file name. <br>    * If an extension is not found, the extension specified by <br>    * pchCat is added to the file name. <br>    * <br>    * Arguments: <br>    *     PSTR pch          = The file spec to "cat" the extension to. <br>    *     PSTR pchCat       = The extension to "cat" on to pch, <br>    *                         including the '.' <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR FileCat( <br>        PSTR pchName, <br>        PSTR pchCat) <br>    { <br>        PSTR pch; <br>     <br>        pch = pchName + strlen(pchName); <br>        pch = FAR2NEAR(AnsiPrev(pchName, pch)); <br>     <br>        /* back up to '.' or '\\' */ <br>        while (*pch != '.') { <br>            if (*pch == '\\' || pch &lt;= pchName) { <br>                /* no extension, add one */ <br>                strcat(pchName, pchCat); <br>                return; <br>            } <br>     <br>            pch = FAR2NEAR(AnsiPrev(pchName, pch)); <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * MyFileRead <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL MyFileRead( <br>        HFILE hf, <br>        LPSTR lpBuffer, <br>        UINT nBytes, <br>        PSTR pszFileName, <br>        INT iType) <br>    { <br>        register UINT cb; <br>     <br>        cb = _lread((HFILE)hf, lpBuffer, nBytes); <br>     <br>        if (cb == -1) { <br>            Message(MSG_READERROR, pszFileName); <br>            return FALSE; <br>        } <br>        else if (cb != nBytes) { <br>            Message((iType == FT_BITMAP) ? MSG_BADBMPFILE : MSG_BADICOCURFILE, <br>                pszFileName); <br>            return FALSE; <br>        } <br>        else { <br>            return TRUE; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * MyFileWrite <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL MyFileWrite( <br>        HFILE hf, <br>        LPSTR lpBuffer, <br>        UINT nBytes, <br>        PSTR pszFileName) <br>    { <br>        register UINT cb; <br>     <br>        cb = _lwrite((HFILE)hf, lpBuffer, nBytes); <br>     <br>        if (cb == -1 || cb != nBytes) { <br>            Message(MSG_WRITEERROR, pszFileName); <br>            return FALSE; <br>        } <br>        else { <br>            return TRUE; <br>        } <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
