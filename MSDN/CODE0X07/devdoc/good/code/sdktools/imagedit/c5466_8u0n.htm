<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMAGEDC.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5477"></a>IMAGEDC.C</h2>
<pre><code>/****************************************************************************/ <br>    /*                                                                          */ <br>    /*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>    /*                           All Rights Reserved                            */ <br>    /*                                                                          */ <br>    /****************************************************************************/ <br>    /****************************** Module Header ******************************* <br>    * Module Name: image.c <br>    * <br>    * Routines for manipulating images. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    #include "imagedit.h" <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ImageDCCreate <br>    * <br>    * Allocates the image DC's and bitmaps used to hold the current image <br>    * being edited.  This includes ghdcImage and ghbmImage.  For icons and <br>    * cursors, also allocates the DC and bitmap that holds the AND mask <br>    * that contains information about whether any given pixel is screen <br>    * color, inverted screen color or a true color.  These globals are <br>    * ghdcANDMask and ghbmANDMask. <br>    * <br>    * The image DC will contain the image as it will appear when displayed. <br>    * For icons and cursors, this means that it is the combined XOR and AND <br>    * portions of the image.  When the icon/cursor file is saved, the bits <br>    * will be separated back out, but having them combined in the image <br>    * makes it fast to display the image while editing.  Because of this, <br>    * however, care must be taken when changing the screen color because <br>    * it is not possible to determine from the image DC alone whether a <br>    * pixel is screen color or simply a true color that happens to be the <br>    * same as the current screen color.  The AND mask is very important for <br>    * keeping this straight and must be properly updated when drawing on <br>    * the image DC with any of the drawing tools! <br>    * <br>    * Arguments: <br>    *   INT iType     - Type of image. <br>    *   INT cx        - Width of the image. <br>    *   INT cy        - Height of the image. <br>    *   INT nColors   - Number of colors. <br>    * <br>    * Returns TRUE if successful, or FALSE if an error occurs. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL ImageDCCreate( <br>        INT iType, <br>        INT cx, <br>        INT cy, <br>        INT nColors) <br>    { <br>        HDC hdcParent; <br>     <br>        /* <br>         * Delete the old image DC's. <br>         */ <br>        ImageDCDelete(); <br>     <br>        hdcParent = GetDC(ghwndMain); <br>     <br>        if (!(ghdcImage = CreateCompatibleDC(hdcParent))) <br>            goto Error1; <br>     <br>        if (!(ghbmImage = MyCreateBitmap(hdcParent, cx, cy, 16))) <br>            goto Error2; <br>     <br>        SelectObject(ghdcImage, ghbmImage); <br>     <br>        /* <br>         * If image is an icon or cursor, also allocate the AND mask <br>         * DC and bitmap.  Note that this cannot be a DIB (must use <br>         * CreateBitmap) or the ImageDCSeparate() code will fail. <br>         */ <br>        if (iType == FT_ICON || iType == FT_CURSOR) { <br>            if (!(ghdcANDMask = CreateCompatibleDC(hdcParent))) <br>                goto Error2; <br>     <br>            if (!(ghbmANDMask = CreateBitmap(cx, cy, (BYTE)1, (BYTE)1, NULL))) <br>                goto Error3; <br>     <br>            SelectObject(ghdcANDMask, ghbmANDMask); <br>        } <br>     <br>        ReleaseDC(ghwndMain, hdcParent); <br>     <br>        /* <br>         * Set some globals. <br>         */ <br>        gcxImage = cx; <br>        gcyImage = cy; <br>        gnColors = nColors; <br>     <br>        /* <br>         * Initialize the bits. <br>         */ <br>        ImageDCClear(); <br>     <br>        return TRUE; <br>     <br>    Error3: <br>        DeleteDC(ghdcANDMask); <br>        ghdcANDMask = NULL; <br>     <br>    Error2: <br>        DeleteDC(ghdcImage); <br>        ghdcImage = NULL; <br>     <br>    Error1: <br>        ReleaseDC(ghwndMain, hdcParent); <br>     <br>        return FALSE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ImageDCDelete <br>    * <br>    * Deletes the current image DC.  For icons and cursors, also deletes the <br>    * mask DC.  Finally, it destroys the undo buffers. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID ImageDCDelete(VOID) <br>    { <br>        if (ghdcImage) { <br>            DeleteDC(ghdcImage); <br>            ghdcImage = NULL; <br>            DeleteObject(ghbmImage); <br>            ghbmImage = NULL; <br>        } <br>     <br>        if (ghdcANDMask) { <br>            DeleteDC(ghdcANDMask); <br>            ghdcANDMask = NULL; <br>            DeleteObject(ghbmANDMask); <br>            ghbmANDMask = NULL; <br>        } <br>     <br>        /* <br>         * Destroy the undo buffer. <br>         */ <br>        ImageFreeUndo(); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ImageDCClear <br>    * <br>    * Clears the image DC.  Sets it to completely white.  For icons and <br>    * cursors, sets the image mask to be fully opaque also. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID ImageDCClear(VOID) <br>    { <br>        PatBlt(ghdcImage, 0, 0, gcxImage, gcyImage, WHITENESS); <br>     <br>        /* <br>         * For icons and cursors, set all the mask bits to zero. <br>         */ <br>        if (ghdcANDMask) <br>            PatBlt(ghdcANDMask, 0, 0, gcxImage, gcyImage, BLACKNESS); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ImageDCSeparate <br>    * <br>    * This function separates out the XOR mask in hdcImage so that it does <br>    * not have any pixels that are screen/inverse color.  This must be done <br>    * prior to saving the image (or changing the screen color) because <br>    * normally the hdcImage contains the image as it will be displayed, <br>    * which is really a combined view of the XOR and AND masks.  The function <br>    * ImageDCCombine can be used after this function to combine the masks <br>    * back together. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID ImageDCSeparate( <br>        HDC hdcImage, <br>        INT cx, <br>        INT cy, <br>        HDC hdcANDMask, <br>        DWORD rgbScreen) <br>    { <br>        HBITMAP hbmTemp; <br>        HDC hdcTemp; <br>        HBITMAP hbmOld; <br>     <br>        /* <br>         * Create a temporary bitmap and DC for the mask bits and <br>         * select bitmap into the DC. <br>         */ <br>        hdcTemp = CreateCompatibleDC(hdcImage); <br>        hbmTemp = CreateCompatibleBitmap(hdcImage, cx, cy); <br>        hbmOld = SelectObject(hdcTemp, hbmTemp); <br>     <br>        /* <br>         * Background color of temporary DC is set to the specified <br>         * screen (transparent) color. The bits from mask DC (mono) are <br>         * transferred to temp. DC (color). Thus the 1s in the mask (corresp. <br>         * to "screen" and "inverse" portions) become "screen" colored pixels <br>         * in temporary DC. <br>         */ <br>        SetBkColor(hdcTemp, rgbScreen); <br>        BitBlt(hdcTemp, 0, 0, cx, cy, hdcANDMask, 0, 0, SRCCOPY); <br>     <br>        /* <br>         * The bits in the temporary DC are XORed against the bits in the image <br>         * DC to recover the true XOR mask in hdcImage.  The AND mask is already <br>         * in hdcANDMask. <br>         */ <br>        BitBlt(hdcImage, 0, 0, cx, cy, hdcTemp, 0, 0, SRCINVERT); <br>     <br>        SelectObject(hdcTemp, hbmOld); <br>        DeleteDC(hdcTemp); <br>        DeleteObject(hbmTemp); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ImageDCCombine <br>    * <br>    * This function takes the raw XOR mask in hdcImage and combines <br>    * it with the AND mask in hdcANDMask to put into hdcImage the <br>    * current image as it will be displayed.  This needs to be done after <br>    * it is separated (just prior to saving the file and also when changing <br>    * the screen color) and when the image is first opened. <br>    * <br>    * The current screen color in ghbrScreen is used when combining the <br>    * image in this routine. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID ImageDCCombine( <br>        HDC hdcImage, <br>        INT cx, <br>        INT cy, <br>        HDC hdcANDMask) <br>    { <br>        HBITMAP hbmTemp; <br>        HDC hdcTemp; <br>        HBITMAP hbmOld; <br>        HBRUSH hbrOld; <br>     <br>        /* <br>         * Make a copy of the image DC with the XOR mask in it. <br>         */ <br>        hdcTemp = CreateCompatibleDC(hdcImage); <br>        hbmTemp = CreateCompatibleBitmap(hdcImage, cx, cy); <br>        hbmOld = SelectObject(hdcTemp, hbmTemp); <br>        BitBlt(hdcTemp, 0, 0, cx, cy, hdcImage, 0, 0, SRCCOPY); <br>     <br>        /* <br>         * Clear the image DC to the current screen color. <br>         */ <br>        hbrOld = SelectObject(hdcImage, ghbrScreen); <br>        PatBlt(hdcImage, 0, 0, cx, cy , PATCOPY); <br>        SelectObject(hdcImage, hbrOld); <br>     <br>        /* <br>         * Reconstruct the image by superimposing the XOR and AND masks. <br>         */ <br>        BitBlt(hdcImage, 0, 0, cx, cy, hdcANDMask, 0, 0, SRCAND); <br>        BitBlt(hdcImage, 0, 0, cx, cy, hdcTemp, 0, 0, SRCINVERT); <br>     <br>        SelectObject(hdcTemp, hbmOld); <br>        DeleteDC(hdcTemp); <br>        DeleteObject(hbmTemp); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ImageDCMonoBlt <br>    * <br>    * This function blts an image onto a monochrome bitmap, then back <br>    * again.  This converts it to a monochrome image. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID ImageDCMonoBlt( <br>        HDC hdcImage, <br>        INT cx, <br>        INT cy) <br>    { <br>        HBITMAP hbmTemp; <br>        HDC hdcTemp; <br>        HBITMAP hbmOld; <br>     <br>        /* <br>         * Create a temporary monochrome bitmap and dc. <br>         */ <br>        hdcTemp = CreateCompatibleDC(hdcImage); <br>        hbmTemp = MyCreateBitmap(hdcImage, cx, cy, 2); <br>        hbmOld = SelectObject(hdcTemp, hbmTemp); <br>     <br>        /* <br>         * Blt the image to the mono bitmap, then back again. <br>         */ <br>        BitBlt(hdcTemp, 0, 0, cx, cy, hdcImage, 0, 0, SRCCOPY); <br>        BitBlt(hdcImage, 0, 0, cx, cy, hdcTemp, 0, 0, SRCCOPY); <br>     <br>        /* <br>         * Cleanup. <br>         */ <br>        SelectObject(hdcTemp, hbmOld); <br>        DeleteObject(hbmTemp); <br>        DeleteDC(hdcTemp); <br>    } <br>     <br>     <br>     <br>     </code></pre>
<p>&nbsp;</p></body>
</HTML>
