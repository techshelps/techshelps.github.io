<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROPBAR.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5484"></a>PROPBAR.C</h2>
<pre><code>/****************************************************************************/ <br>    /*                                                                          */ <br>    /*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>    /*                           All Rights Reserved                            */ <br>    /*                                                                          */ <br>    /****************************************************************************/ <br>    /****************************** Module Header ******************************* <br>    * Module Name: propbar.c <br>    * <br>    * Support for the Properties Bar. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    #include "imagedit.h" <br>    #include "dialogs.h" <br> <br> #include &lt;windowsx.h&gt; <br>     <br>    #define IMPOSSIBLEVALUE     0x7FFF <br>     <br>    STATICFN VOID NEAR PropBarProcessCommand(HWND hwnd, INT idCtrl, <br>        INT NotifyCode); <br>     <br>    /* <br>     * Cache variables.  These cache the values of some displayed fields. <br>     * The field is updated only if the value changes, which avoids flicker. <br>     * They are initialized to a large value so that the first "set" to <br>     * any value will always cause the field to be updated. <br>     */ <br>    static INT xSave = IMPOSSIBLEVALUE; <br>    static INT ySave = IMPOSSIBLEVALUE; <br>    static INT cxSave = IMPOSSIBLEVALUE; <br>    static INT cySave = IMPOSSIBLEVALUE; <br>    static INT xHotSpotSave = IMPOSSIBLEVALUE; <br>    static INT yHotSpotSave = IMPOSSIBLEVALUE; <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PropBarDlgProc <br>    * <br>    * This is the dialog procedure for the PropBar ribbon window. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    DIALOGPROC PropBarDlgProc( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        switch (msg) { <br>            case WM_INITDIALOG: <br>                /* <br>                 * Set this global right away.  Other routines that <br>                 * might be called before CreateDialog returns depend <br>                 * on this global. <br>                 */ <br>                ghwndPropBar = hwnd; <br>     <br>                PropBarUpdate(); <br>     <br>                /* <br>                 * Return TRUE so that the dialog manager does NOT <br>                 * set the focus for me.  This prevents the PropBar <br>                 * window from initially having the focus when the <br>                 * editor is started. <br>                 */ <br>                return TRUE; <br>     <br>            case WM_PAINT: <br>                { <br>                    HDC hdc; <br>                    RECT rc; <br>                    PAINTSTRUCT ps; <br>                    HPEN hpenWindowFrame; <br>     <br>                    /* <br>                     * Draw our border lines. <br>                     */ <br>                    GetClientRect(hwnd, &amp;rc); <br>                    hdc = BeginPaint(hwnd, &amp;ps); <br>     <br>                    SelectObject(hdc, GetStockObject(WHITE_PEN)); <br>                    MoveToEx(hdc, rc.left, rc.top, NULL); <br>                    LineTo(hdc, rc.right, rc.top); <br>     <br>                    SelectObject(hdc, hpenDarkGray); <br>                    MoveToEx(hdc, rc.left, (rc.top + gcyPropBar) - gcyBorder - 1, NULL); <br>                    LineTo(hdc, rc.right, (rc.top + gcyPropBar) - gcyBorder - 1); <br>     <br>                    hpenWindowFrame = CreatePen(PS_SOLID, gcyBorder, <br>                            GetSysColor(COLOR_WINDOWFRAME)); <br>                    SelectObject(hdc, hpenWindowFrame); <br>                    MoveToEx(hdc, rc.left, (rc.top + gcyPropBar) - gcyBorder, NULL); <br>                    LineTo(hdc, rc.right, (rc.top + gcyPropBar) - gcyBorder); <br>     <br>                    EndPaint(hwnd, &amp;ps); <br>                    DeleteObject(hpenWindowFrame); <br>                } <br>     <br>                break; <br>     <br>            case WM_CTLCOLORBTN: <br>            case WM_CTLCOLORDLG: <br>            case WM_CTLCOLORLISTBOX: <br>            case WM_CTLCOLORSTATIC: <br>                switch (GET_WM_CTLCOLOR_TYPE(wParam, lParam, msg)) { <br>                    case CTLCOLOR_BTN: <br>                    case CTLCOLOR_DLG: <br>                    case CTLCOLOR_LISTBOX: <br>                        return (BOOL)GetStockObject(LTGRAY_BRUSH); <br>     <br>                    case CTLCOLOR_STATIC: <br>                        SetBkColor(GET_WM_CTLCOLOR_HDC(wParam, lParam, msg), <br>                                RGB_LIGHTGRAY); <br>                        return (BOOL)GetStockObject(LTGRAY_BRUSH); <br>                } <br>     <br>                return (BOOL)NULL; <br>     <br>            case WM_COMMAND: <br>                PropBarProcessCommand(hwnd, <br>                        GET_WM_COMMAND_ID(wParam, lParam), <br>                        GET_WM_COMMAND_CMD(wParam, lParam)); <br>                break; <br>     <br>            case WM_DESTROY: <br>                /* <br>                 * Null out the global window handle for the prop bar <br>                 * for safety's sake. <br>                 */ <br>                ghwndPropBar = NULL; <br>     <br>                break; <br>     <br>            default: <br>                return FALSE; <br>        } <br>     <br>        return FALSE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PropBarProcessCommand <br>    * <br>    * <br>    * Arguments: <br>    *   HWND hwnd        - The window handle. <br>    *   INT idCtrl       - The id of the control the WM_COMMAND is for. <br>    *   INT NotifyCode   - The control's notification code. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR PropBarProcessCommand( <br>        HWND hwnd, <br>        INT idCtrl, <br>        INT NotifyCode) <br>    { <br>        INT iSelect; <br>        PIMAGEINFO pImage; <br>     <br>        switch (idCtrl) { <br>            case DID_PROPBARIMAGE: <br>                if (NotifyCode == CBN_SELCHANGE) { <br>                    if ((iSelect = (INT)SendDlgItemMessage(hwnd, <br>                            DID_PROPBARIMAGE, CB_GETCURSEL, 0, 0L)) != CB_ERR) { <br>                        /* <br>                         * Get a pointer to the selected image (stored in the <br>                         * listbox items data field). <br>                         */ <br>                        pImage = (PIMAGEINFO)SendDlgItemMessage(hwnd, <br>                                DID_PROPBARIMAGE, CB_GETITEMDATA, iSelect, 0L); <br>     <br>                        /* <br>                         * Open the image.  If it fails, be sure to set the <br>                         * combobox selection back to the current image. <br>                         */ <br>                        if (!ImageOpen(pImage)) { <br>                            PropBarSetImage(gpImageCur); <br>                            break; <br>                        } <br>     <br>                        SetFocus(ghwndMain); <br>                    } <br>                } <br>     <br>                break; <br>     <br>            case IDOK: <br>            case IDCANCEL: <br>                SetFocus(ghwndMain); <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PropBarUpdate <br>    * <br>    * This function updates the Properties Bar for the selection of a <br>    * new image or file.  It fills the Image combo with the names of <br>    * the images in the current file and shows/hides the HotSpot display. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID PropBarUpdate(VOID) <br>    { <br>        HWND hwndCombo; <br>        PIMAGEINFO pImage; <br>        INT idLabel; <br>        INT i; <br>     <br>        if (gpImageCur || gpszFileName) { <br>            switch (giType) { <br>                case FT_BITMAP: <br>                    idLabel = IDS_BITMAPIMAGELABEL; <br>                    break; <br>     <br>                case FT_ICON: <br>                    idLabel = IDS_ICONIMAGELABEL; <br>                    break; <br>     <br>                case FT_CURSOR: <br>                    idLabel = IDS_CURSORIMAGELABEL; <br>                    break; <br>            } <br>        } <br>        else { <br>            idLabel = IDS_NULL; <br>        } <br>     <br>        SetDlgItemText(ghwndPropBar, DID_PROPBARIMAGELABEL, ids(idLabel)); <br>     <br>        /* <br>         * Get the handle to the combo box and clear out all items. <br>         */ <br>        hwndCombo = GetDlgItem(ghwndPropBar, DID_PROPBARIMAGE); <br>        SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0); <br>     <br>        /* <br>         * Fill the combo box with the images. <br>         */ <br>        for (pImage = gpImageHead; pImage; pImage = pImage-&gt;pImageNext) { <br>            i = (INT)SendMessage(hwndCombo, CB_INSERTSTRING, (WPARAM)-1, <br>                    pImage-&gt;pDevice ? <br>                    (DWORD)(LPSTR)pImage-&gt;pDevice-&gt;szDesc : <br>                    (DWORD)(LPSTR)ids(IDS_UNKNOWNIMAGEFORMAT)); <br>     <br>            SendMessage(hwndCombo, CB_SETITEMDATA, i, (DWORD)(LPSTR)pImage); <br>        } <br>     <br>        /* <br>         * Select the current image. <br>         */ <br>        PropBarSetImage(gpImageCur); <br>     <br>        /* <br>         * Show/Hide the HotSpot info depending on whether this is <br>         * a cursor or not. <br>         */ <br>        if (giType == FT_CURSOR) { <br>            if (gpImageCur) <br>                PropBarSetHotSpot(gpImageCur-&gt;iHotspotX, gpImageCur-&gt;iHotspotY); <br>            else <br>                PropBarClearHotSpot(); <br>     <br>            PropBarShowHotSpot(TRUE); <br>        } <br>        else { <br>            PropBarShowHotSpot(FALSE); <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PropBarSetImage <br>    * <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID PropBarSetImage( <br>        PIMAGEINFO pImage) <br>    { <br>        if (pImage) <br>            SendDlgItemMessage(ghwndPropBar, DID_PROPBARIMAGE, CB_SELECTSTRING, <br>                    (WPARAM)-1, (DWORD)(LPSTR)pImage-&gt;pDevice-&gt;szDesc); <br>        else <br>            SendDlgItemMessage(ghwndPropBar, DID_PROPBARIMAGE, CB_SETCURSEL, <br>                    (WPARAM)-1, 0); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PropBarSetPos <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID PropBarSetPos( <br>        INT x, <br>        INT y) <br>    { <br>        CHAR szBuf[CCHTEXTMAX]; <br>     <br>        if (x != xSave || y != ySave) { <br>            wsprintf(szBuf, "%d, %d", x, y); <br>            SetDlgItemText(ghwndPropBar, DID_PROPBARPOS, szBuf); <br>     <br>            /* <br>             *  Save them for the next time. <br>             */ <br>            xSave = x; <br>            ySave = y; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PropBarClearPos <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID PropBarClearPos(VOID) <br>    { <br>        SetDlgItemText(ghwndPropBar, DID_PROPBARPOS, ""); <br>     <br>        /* <br>         * Reset the cache variables so that the next "set" of <br>         * the position is sure to update the display fields. <br>         */ <br>        xSave = IMPOSSIBLEVALUE; <br>        ySave = IMPOSSIBLEVALUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PropBarSetSize <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID PropBarSetSize( <br>        POINT pt1, <br>        POINT pt2) <br>    { <br>        CHAR szBuf[CCHTEXTMAX]; <br>        INT cx; <br>        INT cy; <br>     <br>        NormalizePoints(&amp;pt1, &amp;pt2); <br>        cx = ((pt2.x - pt1.x) / gZoomFactor) + 1; <br>        cy = ((pt2.y - pt1.y) / gZoomFactor) + 1; <br>     <br>        if (cx != cxSave || cy != cySave) { <br>            wsprintf(szBuf, "%dx%d", cx, cy); <br>            SetDlgItemText(ghwndPropBar, DID_PROPBARSIZE, szBuf); <br>     <br>            /* <br>             *  Save them for the next time. <br>             */ <br>            cxSave = cx; <br>            cySave = cy; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PropBarClearSize <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID PropBarClearSize(VOID) <br>    { <br>        SetDlgItemText(ghwndPropBar, DID_PROPBARSIZE, ""); <br>     <br>        /* <br>         * Reset the cache variables so that the next "set" of <br>         * the position is sure to update the display fields. <br>         */ <br>        cxSave = IMPOSSIBLEVALUE; <br>        cySave = IMPOSSIBLEVALUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PropBarSetHotSpot <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID PropBarSetHotSpot( <br>        INT xHotSpot, <br>        INT yHotSpot) <br>    { <br>        CHAR szBuf[CCHTEXTMAX]; <br>     <br>        if (xHotSpot != xHotSpotSave || yHotSpot != yHotSpotSave) { <br>            wsprintf(szBuf, "%d, %d", xHotSpot, yHotSpot); <br>            SetDlgItemText(ghwndPropBar, DID_PROPBARHOTSPOT, szBuf); <br>     <br>            /* <br>             *  Save them for the next time. <br>             */ <br>            xHotSpotSave = xHotSpot; <br>            yHotSpotSave = yHotSpot; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PropBarClearHotSpot <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID PropBarClearHotSpot(VOID) <br>    { <br>        SetDlgItemText(ghwndPropBar, DID_PROPBARHOTSPOT, ""); <br>     <br>        /* <br>         * Reset the cache variables so that the next "set" of <br>         * the hotspot is sure to update the display fields. <br>         */ <br>        xHotSpotSave = IMPOSSIBLEVALUE; <br>        yHotSpotSave = IMPOSSIBLEVALUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * PropBarShowHotSpot <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>    VOID PropBarShowHotSpot( <br>        BOOL fShow) <br>    { <br>        ShowWindow(GetDlgItem(ghwndPropBar, DID_PROPBARHOTSPOTLABEL), <br>                fShow ? SW_SHOWNA : SW_HIDE); <br>        ShowWindow(GetDlgItem(ghwndPropBar, DID_PROPBARHOTSPOT), <br>                fShow ? SW_SHOWNA : SW_HIDE); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
