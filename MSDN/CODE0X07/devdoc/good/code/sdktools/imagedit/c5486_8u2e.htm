<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RWBMP.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5486"></a>RWBMP.C</h2>
<pre><code>/****************************************************************************/ <br>    /*                                                                          */ <br>    /*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>    /*                           All Rights Reserved                            */ <br>    /*                                                                          */ <br>    /****************************************************************************/ <br>    /****************************** Module Header ******************************* <br>    * Module Name: rwbmp.c <br>    * <br>    * Routines for reading and writing bitmap files. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    #include "imagedit.h" <br>     <br>    #include &lt;stdio.h&gt; <br>    #include &lt;io.h&gt; <br>    #include &lt;fcntl.h&gt;                          // For NT fstat(). <br>    #include &lt;sys\types.h&gt;                      // For fstat() types. <br>    #include &lt;sys\stat.h&gt;                       // For fstat() function. <br>     <br>     <br>     <br>    /************************************************************************ <br>    * LoadBitmapFile <br>    * <br>    * Loads the specified bitmap file.  With ImagEdit, this must be a <br>    * Windows 3.0 DIB. <br>    * <br>    * Arguments: <br>    *   PSTR pszFullFileName - Name of the bitmap file to load. <br>    * <br>    * Returns: <br>    *   TRUE if successful, FALSE otherwise. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL LoadBitmapFile( <br>        PSTR pszFullFileName) <br>    { <br>        HFILE hf; <br>        OFSTRUCT OfStruct; <br>        struct stat FileStatus; <br>        DWORD dwFileSize; <br>        DWORD dwDIBSize; <br>        BITMAPFILEHEADER bfh; <br>        BITMAPINFOHEADER bih; <br>        PIMAGEINFO pImage; <br>        INT nColors; <br>        HANDLE hDIB; <br>        PDEVICE pDevice; <br>     <br>        if ((hf = (HFILE)OpenFile(pszFullFileName, (LPOFSTRUCT)&amp;OfStruct, OF_READ)) <br>                == (HFILE)-1) { <br>            Message(MSG_CANTOPEN, pszFullFileName); <br>            return FALSE; <br>        } <br>     <br>        fstat((INT)_open_osfhandle((long)(hf), (int)(O_RDONLY)), &amp;FileStatus); <br>        dwFileSize = (DWORD)FileStatus.st_size; <br>     <br>        ImageLinkFreeList(); <br>     <br>        /* <br>         * Read the Bitmap File Header. <br>         */ <br>        if (!MyFileRead(hf, (LPSTR)&amp;bfh, sizeof(BITMAPFILEHEADER), <br>                pszFullFileName, FT_BITMAP)) <br>            goto Error1; <br>     <br>        /* <br>         * Check for the "BM" at the start of the file, and the file size <br>         * in the header must match the real file size. <br>         */ <br>        if (bfh.bfType != 0x4D42 || bfh.bfSize != dwFileSize) { <br>            Message(MSG_BADBMPFILE, pszFullFileName); <br>            goto Error1; <br>        } <br>     <br>        /* <br>         * Read the Bitmap Info Header. <br>         */ <br>        if (!MyFileRead(hf, (LPSTR)&amp;bih, sizeof(BITMAPINFOHEADER), <br>                pszFullFileName, FT_BITMAP)) <br>            goto Error1; <br>     <br>        /* <br>         * The DIB size should be the size of the file less the bitmap <br>         * file header. <br>         */ <br>        dwDIBSize = dwFileSize - sizeof(BITMAPFILEHEADER); <br>     <br>        if (!IsValidDIB((LPBITMAPINFO)&amp;bih, dwDIBSize, FALSE)) { <br>            Message(MSG_BADBMPFILE, pszFullFileName); <br>            goto Error1; <br>        } <br>     <br>        /* <br>         * There is a limit to the size of image we will edit.  For icons <br>         * and cursors, the field that carries the dimensions is a byte, <br>         * so the size cannot be greater than 256.  This is also what <br>         * we limit bitmaps to. <br>         */ <br>        if (bih.biWidth &gt; MAXIMAGEDIM || bih.biHeight &gt; MAXIMAGEDIM) { <br>            Message(MSG_BADBMPSIZE, MAXIMAGEDIM, MAXIMAGEDIM); <br>            goto Error1; <br>        } <br>     <br>        switch (bih.biBitCount) { <br>            case 1: <br>                nColors = 2; <br>                break; <br>     <br>            case 4: <br>                nColors = 16; <br>                break; <br>     <br>            default: <br>                Message(MSG_NOTSUPPORT); <br>                goto Error1; <br>        } <br>     <br>        if (!(pDevice = DeviceLinkAlloc(FT_BITMAP, NULL, nColors, <br>                (INT)bih.biWidth, (INT)bih.biHeight))) { <br>            goto Error1; <br>        } <br>     <br>        if (!(pImage = ImageLinkAlloc(pDevice, <br>                (INT)bih.biWidth, (INT)bih.biHeight, 0, 0, nColors))) <br>            goto Error1; <br>     <br>        /* <br>         * Allocate space for the DIB for this image. <br>         */ <br>        if (!(hDIB = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, dwDIBSize))) { <br>            Message(MSG_OUTOFMEMORY); <br>            goto Error2; <br>        } <br>     <br>        pImage-&gt;DIBSize = dwDIBSize; <br>        pImage-&gt;DIBhandle = hDIB; <br>        pImage-&gt;DIBPtr = (LPSTR)GlobalLock(hDIB); <br>     <br>        /* <br>         * Jump back to the start of the DIB. <br>         */ <br>        SetFilePointer((HANDLE)hf, sizeof(BITMAPFILEHEADER), NULL, (DWORD)0); <br>     <br>        /* <br>         * Read the entire DIB (including info and color table) into <br>         * the allocated memory for it. <br>         */ <br>        if (!MyFileRead(hf, pImage-&gt;DIBPtr, (DWORD)pImage-&gt;DIBSize, <br>                pszFullFileName, FT_BITMAP)) <br>            goto Error2; <br>     <br>        _lclose((HFILE)hf); <br>     <br>        fFileDirty = FALSE; <br>        SetFileName(pszFullFileName); <br>        giType = FT_BITMAP; <br>     <br>        /* <br>         * Bitmaps only have one "image" in the file. <br>         */ <br>        gnImages = 1; <br>     <br>        ImageOpen2(pImage); <br>     <br>        return TRUE; <br>     <br>    Error2: <br>        ImageLinkFreeList(); <br>     <br>    Error1: <br>        _lclose((HFILE)hf); <br>     <br>        return FALSE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * SaveBitmapFile <br>    * <br>    * <br>    * <br>    * Arguments: <br>    * <br>    * Returns: <br>    *   TRUE if successful, FALSE otherwise. <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL SaveBitmapFile( <br>        PSTR pszFullFileName) <br>    { <br>        HCURSOR hcurOld; <br>        BITMAPFILEHEADER bfh; <br>        HFILE hf; <br>        OFSTRUCT OfStruct; <br>     <br>        hcurOld = SetCursor(hcurWait); <br>     <br>        /* <br>         * Save the bits of the current image. <br>         */ <br>        ImageSave(); <br>     <br>        /* <br>         * Open the file for writing. <br>         */ <br>        if ((hf = (HFILE)OpenFile(pszFullFileName, &amp;OfStruct, OF_CREATE | OF_READWRITE)) <br>                == (HFILE)-1) { <br>            Message(MSG_CANTCREATE, pszFullFileName); <br>            goto Error1; <br>        } <br>     <br>        bfh.bfType = 0x4D42; <br>        bfh.bfSize = sizeof(BITMAPFILEHEADER) + gpImageCur-&gt;DIBSize; <br>        bfh.bfReserved1 = 0; <br>        bfh.bfReserved2 = 0; <br>        bfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + <br>                (gpImageCur-&gt;nColors * sizeof(RGBQUAD)); <br>     <br>        /* <br>         * Write the header to disk. <br>         */ <br>        if (!MyFileWrite(hf, (LPSTR)&amp;bfh, sizeof(BITMAPFILEHEADER), <br>                pszFullFileName)) <br>            goto Error2; <br>     <br>        /* <br>         * Now write the DIB (a bitmap file only has one). <br>         */ <br>        if (!MyFileWrite(hf, (LPSTR)gpImageCur-&gt;DIBPtr, <br>                (DWORD)gpImageCur-&gt;DIBSize, pszFullFileName)) <br>            goto Error2; <br>     <br>        _lclose((HFILE)hf); <br>     <br>        fFileDirty = FALSE; <br>        SetFileName(pszFullFileName); <br>     <br>        SetCursor(hcurOld); <br>     <br>        return TRUE; <br>     <br>    Error2: <br>        _lclose((HFILE)hf); <br>     <br>    Error1: <br>        SetCursor(hcurOld); <br>     <br>        return FALSE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
