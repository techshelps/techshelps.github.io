<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMAGUNDO.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5482"></a>IMAGUNDO.C</h2>
<pre><code>/****************************************************************************/ <br>/*                                                                          */ <br>/*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>/*                           All Rights Reserved                            */ <br>/*                                                                          */ <br>/****************************************************************************/ <br>/****************************** Module Header ******************************* <br>* Module Name: imagundo.c <br>* <br>* Contains routines for handling the Undo buffers. <br>* <br>* History: <br>* <br>****************************************************************************/ <br> <br>#include "imagedit.h" <br> <br> <br>STATICFN VOID NEAR ImageAllocUndo(VOID); <br> <br> <br> <br>/************************************************************************ <br>* ImageUndo <br>* <br>* Undoes the last editing operation by restoring the image to the <br>* saved undo buffer. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID ImageUndo(VOID) <br>{ <br>    HDC hdcTemp; <br>    HBITMAP hbmOld; <br> <br>    /* <br>     * Is there anything to undo? <br>     */ <br>    if (!ghbmUndo) <br>        return; <br> <br>    hdcTemp = CreateCompatibleDC(ghdcImage); <br>    hbmOld = SelectObject(hdcTemp, ghbmUndo); <br>    BitBlt(ghdcImage, 0, 0, gcxImage, gcyImage, hdcTemp, 0, 0, SRCCOPY); <br> <br>    /* <br>     * For icons and cursors, restore the AND mask also. <br>     */ <br>    if (giType != FT_BITMAP) { <br>        SelectObject(hdcTemp, ghbmUndoMask); <br>        BitBlt(ghdcANDMask, 0, 0, gcxImage, gcyImage, hdcTemp, 0, 0, SRCCOPY); <br>    } <br> <br>    SelectObject(hdcTemp, hbmOld); <br>    DeleteDC(hdcTemp); <br> <br>    fImageDirty = TRUE; <br> <br>    /* <br>     * Delete the undo buffer, now that it has been used. <br>     */ <br>    ImageFreeUndo(); <br> <br>    ViewUpdate(); <br>} <br> <br> <br> <br>/************************************************************************ <br>* ImageUpdateUndo <br>* <br>* Makes a snapshot of the current image and places it in the undo <br>* buffer. <br>* <br>* Arguments: <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID ImageUpdateUndo(VOID) <br>{ <br>    HDC hdcTemp; <br>    HBITMAP hbmOld; <br> <br>    /* <br>     * If there are currently no undo buffers, allocate them now. <br>     */ <br>    if (!ghbmUndo) <br>        ImageAllocUndo(); <br> <br>    hdcTemp = CreateCompatibleDC(ghdcImage); <br>    hbmOld = SelectObject(hdcTemp, ghbmUndo); <br>    BitBlt(hdcTemp, 0, 0, gcxImage, gcyImage, ghdcImage, 0, 0, SRCCOPY); <br> <br>    /* <br>     * For icons and cursors, update the undo AND mask also. <br>     */ <br>    if (giType != FT_BITMAP) { <br>        SelectObject(hdcTemp, ghbmUndoMask); <br>        BitBlt(hdcTemp, 0, 0, gcxImage, gcyImage, ghdcANDMask, 0, 0, SRCCOPY); <br>    } <br> <br>    SelectObject(hdcTemp, hbmOld); <br>    DeleteDC(hdcTemp); <br>} <br> <br> <br> <br>/************************************************************************ <br>* ImageAllocUndo <br>* <br>* Allocates buffers for an undo operation.  For icons and cursors, <br>* this includes an AND mask undo buffer.  This function does not <br>* initialize the bits.  The function ImageFreeUndo frees the buffers <br>* allocated by this function. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN VOID NEAR ImageAllocUndo(VOID) <br>{ <br>    ImageFreeUndo(); <br> <br>    /* <br>     * Allocate an undo bitmap of the specified size. <br>     */ <br>    if (!(ghbmUndo = MyCreateBitmap(ghdcImage, gcxImage, gcyImage, 16))) { <br>        Message(MSG_OUTOFMEMORY); <br>        return; <br>    } <br> <br>    /* <br>     * For icons and cursors, allocate an undo AND mask also. <br>     */ <br>    if (giType != FT_BITMAP) { <br>        if (!(ghbmUndoMask = CreateBitmap(gcxImage, gcyImage, <br>                (BYTE)1, (BYTE)1, NULL))) { <br>            ImageFreeUndo(); <br>            Message(MSG_OUTOFMEMORY); <br>            return; <br>        } <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* ImageFreeUndo <br>* <br>* Free's the undo buffers. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID ImageFreeUndo(VOID) <br>{ <br>    if (ghbmUndo) { <br>        DeleteObject(ghbmUndo); <br>        ghbmUndo = NULL; <br>    } <br> <br>    if (ghbmUndoMask) { <br>        DeleteObject(ghbmUndoMask); <br>        ghbmUndoMask = NULL; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
