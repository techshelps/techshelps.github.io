<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMAGLINK.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5481"></a>IMAGLINK.C</h2>
<pre><code>/****************************************************************************/ <br>/*                                                                          */ <br>/*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>/*                           All Rights Reserved                            */ <br>/*                                                                          */ <br>/****************************************************************************/ <br>/****************************** Module Header ******************************* <br>* Module Name: imaglink.c <br>* <br>* Contains routines for managing the linked list of images. <br>* <br>* History: <br>* <br>****************************************************************************/ <br> <br>#include "imagedit.h" <br> <br> <br> <br>/************************************************************************ <br>* ImageLinkAlloc <br>* <br>* Allocates an image link.  This is a node in the linked list of <br>* images for the current file.  This link will be added to the <br>* current linked list of images. <br>* <br>* Arguments: <br>*   PDEVICE pDevice  - Pointer to the device structure. <br>*   INT cx           - Width of the image. <br>*   INT cy           - Height of the image. <br>*   INT xHotSpot     - X location of the hotspot (cursors only). <br>*   INT yHotSpot     - Y location of the hotspot (cursors only). <br>*   INT nColors      - Number of colors (2 or 16). <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>PIMAGEINFO ImageLinkAlloc( <br>    PDEVICE pDevice, <br>    INT cx, <br>    INT cy, <br>    INT xHotSpot, <br>    INT yHotSpot, <br>    INT nColors) <br>{ <br>    PIMAGEINFO pImage; <br>    PIMAGEINFO pImageT; <br> <br>    if (!(pImage = (PIMAGEINFO)MyAlloc(sizeof(IMAGEINFO)))) <br>        return NULL; <br> <br>    pImage-&gt;pDevice = pDevice; <br>    pImage-&gt;cx = cx; <br>    pImage-&gt;cy = cy; <br>    pImage-&gt;iHotspotX = xHotSpot; <br>    pImage-&gt;iHotspotY = yHotSpot; <br>    pImage-&gt;nColors = nColors; <br>    pImage-&gt;DIBSize = 0; <br>    pImage-&gt;DIBhandle = NULL; <br>    pImage-&gt;DIBPtr = NULL; <br>    pImage-&gt;pImageNext = NULL; <br> <br>    /* <br>     * Insert the link in the list. <br>     */ <br>    if (!gpImageHead) { <br>        /* <br>         * This is the first one.  Start the list. <br>         */ <br>        gpImageHead = pImage; <br>    } <br>    else { <br>        /* <br>         * Find the end of the list and tack on the new link. <br>         */ <br>        for (pImageT = gpImageHead; pImageT-&gt;pImageNext; <br>                pImageT = pImageT-&gt;pImageNext) <br>            ; <br> <br>        pImageT-&gt;pImageNext = pImage; <br>    } <br> <br>    return pImage; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ImageLinkFree <br>* <br>* Free's the specified image link and closes up the hole <br>* in the linked list. <br>* <br>* Arguments: <br>*   PIMAGEINFO pImageFree - The image link to free. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID ImageLinkFree( <br>    PIMAGEINFO pImageFree) <br>{ <br>    PIMAGEINFO pImage; <br>    PIMAGEINFO pImagePrev; <br> <br>    /* <br>     * Find the existing link and get it's previous link. <br>     */ <br>    for (pImage = gpImageHead, pImagePrev = NULL; <br>            pImage &amp;&amp; pImage != pImageFree; <br>            pImagePrev = pImage, pImage = pImage-&gt;pImageNext) <br>        ; <br> <br>    /* <br>     * Was the image link found? <br>     */ <br>    if (pImage) { <br>        /* <br>         * Close up the linked list. <br>         */ <br>        if (pImagePrev) <br>            pImagePrev-&gt;pImageNext = pImageFree-&gt;pImageNext; <br>        else <br>            gpImageHead = pImageFree-&gt;pImageNext; <br> <br>        /* <br>         * Unlock and free the allocated DIB image. <br>         */ <br>        if (pImageFree-&gt;DIBhandle) { <br>            GlobalUnlock(pImageFree-&gt;DIBhandle); <br>            GlobalFree(pImageFree-&gt;DIBhandle); <br>        } <br> <br>        /* <br>         * Free the link itself. <br>         */ <br>        MyFree(pImageFree); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* ImageLinkFreeList <br>* <br>* Free's all the nodes in the current image list (if there is one). <br>* <br>* Arguments: <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID ImageLinkFreeList(VOID) <br>{ <br>    while (gpImageHead) <br>        ImageLinkFree(gpImageHead); <br>} <br> <br> <br> <br>/************************************************************************ <br>* ImageDelete <br>* <br>* Deletes the current image (for icons/cursors).  If there are other images, <br>* the first one is opened.  If the last image was just deleted, the <br>* entire editor will be reset (if the file was untitled) or if there <br>* is currently a file opened, some other things will happen, such as <br>* hiding the workspace and view windows, etc. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID ImageDelete(VOID) <br>{ <br>    PIMAGEINFO pImage; <br> <br>    ImageDCDelete(); <br>    ImageLinkFree(gpImageCur); <br>    gpImageCur = NULL; <br>    fFileDirty = TRUE; <br>    fImageDirty = FALSE; <br>    gnImages--; <br> <br>    /* <br>     * Look for the first remaining image that has a valid device <br>     * (which means it is editable). <br>     */ <br>    for (pImage = gpImageHead; pImage &amp;&amp; !pImage-&gt;pDevice; <br>            pImage = pImage-&gt;pImageNext) <br>        ; <br> <br>    /* <br>     * If there are other editable images, open the first one. <br>     * Otherwise, clear out some more things. <br>     */ <br>    if (pImage) { <br>        ImageOpen2(pImage); <br>    } <br>    else { <br>        /* <br>         * Is this a file off of disk? <br>         */ <br>        if (gpszFileName) { <br>            /* <br>             * Hide the Workspace and View windows. <br>             */ <br>            ShowWindow(ghwndWork, SW_HIDE); <br>            ViewShow(FALSE); <br> <br>            /* <br>             * Update the properties bar (refill the images combo). <br>             */ <br>            PropBarUpdate(); <br>        } <br>        else { <br>            /* <br>             * Since this file was opened new and they deleted the <br>             * last image present in it, just reset everything. <br>             */ <br>            ClearResource(); <br>        } <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
