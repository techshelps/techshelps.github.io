<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIEWWP.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5491"></a>VIEWWP.C</h2>
<pre><code>/****************************************************************************/ <br>    /*                                                                          */ <br>    /*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>    /*                           All Rights Reserved                            */ <br>    /*                                                                          */ <br>    /****************************************************************************/ <br>    /****************************** Module Header ******************************* <br>    * Module Name: viewwp.c <br>    * <br>    * Contains routines that handle the View window. <br>    * <br>    * History: <br>    * <br>    * 07/17/91 -  - Created. <br>    * <br>    ****************************************************************************/ <br>     <br>    #include "imagedit.h" <br>    #include "dialogs.h" <br> <br> #include &lt;windowsx.h&gt; <br>     <br>    /* <br>     * Style of the view window. */ <br>    #define VIEWSTYLE       (WS_POPUP | WS_CLIPSIBLINGS | WS_CAPTION | WS_SYSMENU) <br>     <br>     <br>    STATICFN VOID NEAR ViewChar(UINT uiChar); <br>     <br>     <br>    static INT gViewBackMargin;     // Margin of background within view window. <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ViewCreate <br>    * <br>    * This function creates the View window. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID ViewCreate(VOID) <br>    { <br>        INT x; <br>        INT y; <br>        INT cxDummy; <br>        INT cyDummy; <br>        RECT rc; <br>        BOOL fMaximized; <br>     <br>        gViewBackMargin = GetSystemMetrics(SM_CXVSCROLL) / 2; <br>     <br>        /* <br>         * Get the saved position of the Toolbox.  Note that we throw away <br>         * the size fields, because we will calculate the required size <br>         * later based on the image size. <br>         */ <br>        if (!ReadWindowPos(szViewPos, &amp;x, &amp;y, &amp;cxDummy, &amp;cyDummy, &amp;fMaximized)) { <br>            /* <br>             * The previous position of the View window couldn't be found. <br>             * Position the window to the right side of the editor, just <br>             * below the Toolbox. <br>             */ <br>            if (ghwndToolbox) { <br>                GetWindowRect(ghwndToolbox, &amp;rc); <br>                x = rc.left; <br>                y = rc.bottom + (2 * PALETTEMARGIN); <br>            } <br>            else { <br>                /* <br>                 * Last resort.  Position it in the upper left corner <br>                 * of the screen if the Toolbox cannot be found.  This <br>                 * is unlikely because if the previous position of the <br>                 * View window could not be found, this implies that <br>                 * the editor has not been run before on this machine. <br>                 * If this is true, the toolbox will come up by default <br>                 * before this routine is called.  But just in case... <br>                 */ <br>                x = 2 * PALETTEMARGIN; <br>                y = 2 * PALETTEMARGIN; <br>            } <br>        } <br>     <br>        if (!(ghwndView = CreateWindow(szViewClass, NULL, VIEWSTYLE, <br>                x, y, 0, 0, ghwndMain, NULL, ghInst, NULL))) <br>            return; <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ViewShow <br>    * <br>    * This function shows or hides the view window. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID ViewShow( <br>        BOOL fShow) <br>    { <br>        if (fShow) { <br>            /* <br>             * Only show it if there is an image to display! <br>             */ <br>            if (gpImageCur) <br>                ShowWindow(ghwndView, SW_SHOWNA); <br>        } <br>        else { <br>            ShowWindow(ghwndView, SW_HIDE); <br>        } <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ViewUpdate <br>    * <br>    * This function updates the view window.  It should be called any time that <br>    * the image changes (is drawn upon). <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID ViewUpdate(VOID) <br>    { <br>        InvalidateRect(ghwndView, NULL, TRUE); <br>     <br>        /* <br>         * Update the workspace window also, because it must always <br>         * match the state of the View window. <br>         */ <br>        WorkUpdate(); <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ViewReset <br>    * <br>    * This function resets the view window, sizing it to fit a new <br>    * image.  It should be called any time that the current image <br>    * is changed to another one. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID ViewReset(VOID) <br>    { <br>        RECT rc; <br>        RECT rcT; <br>     <br>        GetWindowRect(ghwndView, &amp;rc); <br>     <br>        rcT.left = 0; <br>        rcT.top = 0; <br>        rcT.right = PALETTEMARGIN + gViewBackMargin + <br>                gpImageCur-&gt;cx + gViewBackMargin + PALETTEMARGIN; <br>        rcT.bottom = PALETTEMARGIN + gViewBackMargin + <br>                gpImageCur-&gt;cy + gViewBackMargin + PALETTEMARGIN; <br>        AdjustWindowRect(&amp;rcT, VIEWSTYLE, FALSE); <br>     <br>        rc.right = rc.left + (rcT.right - rcT.left); <br>        rc.bottom = rc.top + (rcT.bottom - rcT.top); <br>        FitRectToScreen(&amp;rc); <br>     <br>        SetWindowPos(ghwndView, NULL, rc.left, rc.top, <br>                rc.right - rc.left, rc.bottom - rc.top, <br>                SWP_NOACTIVATE | SWP_NOZORDER); <br>     <br>        /* <br>         * If the user wants it, show the View window now. <br>         */ <br>        if (gfShowView) <br>            ViewShow(TRUE); <br>     <br>        ViewUpdate(); <br>     <br>        /* <br>         * Clear out the propbar size and position fields, because they <br>         * probably show the wrong information now. <br>         */ <br>        PropBarClearPos(); <br>        PropBarClearSize(); <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ViewWndProc <br>    * <br>    * This is the window procedure for the view window. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    WINDOWPROC ViewWndProc( <br>        HWND hwnd, <br>        UINT msg, <br>        WPARAM wParam, <br>        LPARAM lParam) <br>    { <br>        switch (msg) { <br>            case WM_CREATE: <br>                { <br>                    HMENU hmenu = GetSystemMenu(hwnd, FALSE); <br>     <br>                    RemoveMenu(hmenu, 7, MF_BYPOSITION);    // Second separator. <br>                    RemoveMenu(hmenu, 5, MF_BYPOSITION);    // First separator. <br>     <br>                    RemoveMenu(hmenu, SC_RESTORE, MF_BYCOMMAND); <br>                    RemoveMenu(hmenu, SC_SIZE, MF_BYCOMMAND); <br>                    RemoveMenu(hmenu, SC_MINIMIZE, MF_BYCOMMAND); <br>                    RemoveMenu(hmenu, SC_MAXIMIZE, MF_BYCOMMAND); <br>                    RemoveMenu(hmenu, SC_TASKLIST, MF_BYCOMMAND); <br>                } <br>     <br>                return 0; <br>     <br>            case  WM_PAINT: <br>                { <br>                    HDC hdc; <br>                    PAINTSTRUCT ps; <br>                    HBRUSH hbrOld; <br>                    RECT rc; <br>     <br>                    hdc = BeginPaint(hwnd, &amp;ps); <br>     <br>                    /* <br>                     * The view window should not be showing if there <br>                     * is not an image to view! <br>                     */ <br>                    if (gpImageCur) { <br>                        DrawMarginBorder(hwnd, hdc); <br>     <br>                        GetClientRect(hwnd, &amp;rc); <br>                        hbrOld = SelectObject(hdc, ghbrScreen); <br>                        PatBlt(hdc, PALETTEMARGIN + 1, PALETTEMARGIN + 1, <br>                                rc.right - (PALETTEMARGIN * 2) - 2, <br>                                rc.bottom - (PALETTEMARGIN * 2) - 2, <br>                                PATCOPY); <br>                        SelectObject(hdc, hbrOld); <br>     <br>                        BitBlt(hdc, PALETTEMARGIN + gViewBackMargin, <br>                                PALETTEMARGIN + gViewBackMargin, <br>                                gcxImage, gcyImage, ghdcImage, 0, 0, SRCCOPY); <br>                    } <br>     <br>                    EndPaint(hwnd, &amp;ps); <br>                } <br>     <br>                break; <br>     <br>            case WM_ACTIVATE: <br>                if (GET_WM_ACTIVATE_STATE(wParam, lParam)) <br>                    gidCurrentDlg = DID_VIEW; <br>     <br>                break; <br>     <br>            case WM_LBUTTONDOWN: <br>                SetScreenColor(gargbCurrent[giColorLeft]); <br>                break; <br>     <br>            case WM_CHAR: <br>                ViewChar(wParam); <br>                break; <br>     <br>            case WM_CLOSE: <br>                /* <br>                 * The user closed the view window from the system menu. <br>                 * Hide the window (we don't actually destroy it so <br>                 * that it will appear in the same spot when they show <br>                 * it again). <br>                 */ <br>                ViewShow(FALSE); <br>                gfShowView = FALSE; <br>                break; <br>     <br>            case WM_DESTROY: <br>                { <br>                    RECT rc; <br>     <br>                    /* <br>                     * Save the position of the toolbox. <br>                     */ <br>                    GetWindowRect(hwnd, &amp;rc); <br>                    WriteWindowPos(&amp;rc, FALSE, szViewPos); <br>     <br>                    /* <br>                     * Null out the global window handle for the view window <br>                     * for safety's sake. <br>                     */ <br>                    ghwndView = NULL; <br>                } <br>     <br>                break; <br>     <br>            default: <br>                return DefWindowProc(hwnd, msg, wParam, lParam); <br>        } <br>     <br>        return 0; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ViewChar <br>    * <br>    * Handles WM_CHAR messages for the view window.  Currently this just <br>    * includes the '+' and '-' keys, which are used to cycle through all <br>    * the possible screen colors. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    STATICFN VOID NEAR ViewChar( <br>        UINT uiChar) <br>    { <br>        INT i; <br>        INT iNext; <br>     <br>        switch (uiChar) { <br>            /* <br>             * Advance to the next screen color. <br>             */ <br>            case '+': <br>                iNext = 0; <br>                for (i = 0; i &lt; 16; i++) { <br>                    if (grgbScreen == gargbDefaultColor[i]) { <br>                        iNext = i + 1; <br>                        break; <br>                    } <br>                } <br>     <br>                if (iNext &gt;= 16) <br>                    iNext = 0; <br>     <br>                SetScreenColor(gargbDefaultColor[iNext]); <br>     <br>                break; <br>     <br>            /* <br>             * Back up to the prior screen color. <br>             */ <br>            case '-': <br>                iNext = 16 - 1; <br>                for (i = 0; i &lt; 16; i++) { <br>                    if (grgbScreen == gargbDefaultColor[i]) { <br>                        iNext = i - 1; <br>                        break; <br>                    } <br>                } <br>     <br>                if (iNext &lt; 0) <br>                    iNext = 16 - 1; <br>     <br>                SetScreenColor(gargbDefaultColor[iNext]); <br>     <br>                break; <br>        } <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * ViewSetPixel <br>    * <br>    * This function colors a pixel in the View window directly.  It is <br>    * provided as an optimization when drawing a point.  The ghdcImage <br>    * bitmap must be updated as well or the image on the screen will <br>    * get out of synch with it. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID ViewSetPixel( <br>        INT x, <br>        INT y, <br>        INT nBrushSize) <br>    { <br>        HDC hDC; <br>        HBRUSH hbrOld; <br>        INT Size; <br>        INT SizeX; <br>        INT SizeY; <br>     <br>        hDC = GetDC(ghwndView); <br>        hbrOld = SelectObject(hDC, ghbrDrawSolid); <br>        SizeX = x - nBrushSize / 2; <br>        SizeY = y - nBrushSize / 2; <br>        PatBlt(hDC, PALETTEMARGIN + gViewBackMargin + (SizeX &gt;= 0 ? SizeX : 0), <br>                PALETTEMARGIN + gViewBackMargin + (SizeY &gt;=  0 ? SizeY :  0), <br>                ((Size = gcxImage - SizeX) &gt;= nBrushSize ? <br>                nBrushSize : Size), <br>                ((Size = gcyImage - SizeY) &gt;= nBrushSize ? <br>                nBrushSize : Size), PATCOPY); <br>        SelectObject(hDC, hbrOld); <br>        ReleaseDC(ghwndView, hDC); <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * DrawMarginBorder <br>    * <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID DrawMarginBorder( <br>        HWND hwnd, <br>        HDC hdc) <br>    { <br>        HBRUSH hbrOld; <br>        HPEN hpenOld; <br>        RECT rc; <br>     <br>        GetClientRect(hwnd, &amp;rc); <br>        hpenOld = SelectObject(hdc, GetStockObject(BLACK_PEN)); <br>        hbrOld = SelectObject(hdc, GetStockObject(NULL_BRUSH)); <br>        Rectangle(hdc, PALETTEMARGIN, PALETTEMARGIN, <br>                rc.right - PALETTEMARGIN, <br>                rc.bottom - PALETTEMARGIN); <br>        SelectObject(hdc, hpenOld); <br>        SelectObject(hdc, hbrOld); <br>    } <br>     <br>     <br>     <br>    /**************************************************************************** <br>    * DrawSunkenRect <br>    * <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    VOID DrawSunkenRect( <br>        PRECT prc, <br>        HDC hdc) <br>    { <br>        HPEN hpenOld; <br>     <br>        hpenOld = SelectObject(hdc, hpenDarkGray); <br>        MoveToEx(hdc, prc-&gt;left, prc-&gt;top, NULL); <br>        LineTo(hdc, prc-&gt;right - 1, prc-&gt;top); <br>        MoveToEx(hdc, prc-&gt;left, prc-&gt;top, NULL); <br>        LineTo(hdc, prc-&gt;left, prc-&gt;bottom - 1); <br>     <br>        SelectObject(hdc, GetStockObject(WHITE_PEN)); <br>        MoveToEx(hdc, prc-&gt;left + 1, prc-&gt;bottom - 1, NULL); <br>        LineTo(hdc, prc-&gt;right, prc-&gt;bottom - 1); <br>        MoveToEx(hdc, prc-&gt;right - 1, prc-&gt;top + 1, NULL); <br>        LineTo(hdc, prc-&gt;right - 1, prc-&gt;bottom - 1); <br>     <br>        SelectObject(hdc, hpenOld); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
