<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMAGE.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5476"></a>IMAGE.C</h2>
<pre><code>/****************************************************************************/ <br>    /*                                                                          */ <br>    /*                 Copyright (C) 1987-1996 Microsoft Corp.                */ <br>    /*                           All Rights Reserved                            */ <br>    /*                                                                          */ <br>    /****************************************************************************/ <br>    /****************************** Module Header ******************************* <br>    * Module Name: image.c <br>    * <br>    * Routines for opening and saving images. <br>    * <br>    * History: <br>    * <br>    ****************************************************************************/ <br>     <br>    #include "imagedit.h" <br>     <br>    #include &lt;stdio.h&gt; <br>    #include &lt;string.h&gt; <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ImageNew <br>    * <br>    * Creates a new image for the specified device. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL ImageNew( <br>        PDEVICE pDevice) <br>    { <br>        PIMAGEINFO pImage; <br>     <br>        if (!(pImage = ImageLinkAlloc(pDevice, pDevice-&gt;cx, pDevice-&gt;cy, <br>                0, 0, pDevice-&gt;nColors))) <br>            return FALSE; <br>     <br>        /* <br>         * Allocate work space for the new image. <br>         */ <br>        if (!ImageDCCreate(pDevice-&gt;iType, pImage-&gt;cx, pImage-&gt;cy, <br>                pImage-&gt;nColors)) { <br>            ImageLinkFree(pImage); <br>            return FALSE; <br>        } <br>     <br>        gpImageCur = pImage; <br>        gnImages++; <br>        giType = pDevice-&gt;iType; <br>     <br>        /* <br>         * Initialize the pick rectangle to encompass the entire image. <br>         */ <br>        PickSetRect(0, 0, gcxImage - 1, gcyImage - 1); <br>     <br>        /* <br>         * Mark the newly created image as dirty to be sure it gets saved. <br>         */ <br>        fImageDirty = TRUE; <br>     <br>        /* <br>         * Update the palettes. <br>         */ <br>        SetColorPalette(gnColors, giType, FALSE); <br>        PropBarUpdate(); <br>        ToolboxUpdate(); <br>        ViewReset(); <br>     <br>        /* <br>         * Reset the workspace window and then show it. <br>         */ <br>        WorkReset(); <br>        ShowWindow(ghwndWork, SW_SHOWNORMAL); <br>     <br>        return TRUE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ImageNewBitmap <br>    * <br>    * Creates a new bitmap image given a set of characteristics.  After <br>    * device link is created for those characteristics, ImageNew() is <br>    * called to do the actual work. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL ImageNewBitmap( <br>        INT cx, <br>        INT cy, <br>        INT nColors) <br>    { <br>        PDEVICE pDevice; <br>     <br>        if (!(pDevice = DeviceLinkAlloc(FT_BITMAP, NULL, nColors, cx, cy))) <br>            return FALSE; <br>     <br>        return ImageNew(pDevice); <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ImageOpen <br>    * <br>    * Determines what has to be done to open the specified image.  If it <br>    * is not already the current image, it will save the current image <br>    * then will call ImageOpen2() to open the new one. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL ImageOpen( <br>        PIMAGEINFO pImage) <br>    { <br>        /* <br>         * New image is already current.  Return success. <br>         */ <br>        if (pImage == gpImageCur) <br>            return TRUE; <br>     <br>        /* <br>         * Is this an image for a known device? <br>         */ <br>        if (pImage-&gt;pDevice) { <br>            /* <br>             * Save away the current image. <br>             */ <br>            ImageSave(); <br>     <br>            /* <br>             * Do the real open of the new image. <br>             */ <br>            return ImageOpen2(pImage); <br>        } <br>        else { <br>            Message(MSG_CANTEDITIMAGE); <br>            return FALSE; <br>        } <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ImageOpen2 <br>    * <br>    * Unconditionally opens up the specified image for editing.  This involves <br>    * parsing the DIB into various globals, putting the bits onto the screen <br>    * and updating the different palettes appropriately. <br>    * <br>    * Arguments: <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    BOOL ImageOpen2( <br>        PIMAGEINFO pImage) <br>    { <br>        HCURSOR hcurOld; <br>        LPBITMAPINFO lpbi; <br>        INT iBitCount; <br>        INT cx; <br>        INT cy; <br>        INT nColors; <br>        DWORD cbColorTable; <br>        DWORD cbBits; <br>        LPBYTE lpDIBBits; <br>        HBITMAP hbmMono; <br>        HBITMAP hbmImage; <br>        PBITMAPINFO pbi; <br>     <br>        hcurOld = SetCursor(hcurWait); <br>     <br>        lpbi = (LPBITMAPINFO)pImage-&gt;DIBPtr; <br>        iBitCount = lpbi-&gt;bmiHeader.biBitCount; <br>     <br>        cx = (INT)lpbi-&gt;bmiHeader.biWidth; <br>        cy = (INT)lpbi-&gt;bmiHeader.biHeight; <br>        if (giType != FT_BITMAP) <br>            cy /= 2; <br>     <br>        nColors = pImage-&gt;nColors; <br>     <br>        /* <br>         * Allocate work space for the image. <br>         */ <br>        if (!ImageDCCreate(giType, cx, cy, nColors)) <br>            goto Error1; <br>     <br>        /* <br>         * Create a temporary bitmap. <br>         */ <br>        if (!(hbmMono = CreateBitmap(1, 1, 1, 1, NULL))) { <br>            Message(MSG_OUTOFMEMORY); <br>            goto Error2; <br>        } <br>     <br>        cbColorTable = (1 &lt;&lt; iBitCount) * sizeof(RGBQUAD); <br>        lpDIBBits = (LPSTR)lpbi + sizeof(BITMAPINFOHEADER) + cbColorTable; <br>        cbBits = (((((DWORD)cx * iBitCount) + 31) &amp; 0xffffffe0) &gt;&gt; 3) * cy; <br>     <br>        /* <br>         * Make a copy of the info header and color table. <br>         */ <br>        if (!(pbi = (PBITMAPINFO)MyAlloc( <br>                sizeof(BITMAPINFOHEADER) + (INT)cbColorTable))) <br>            goto Error3; <br>     <br>        memcpy((LPBYTE)pbi, lpbi, sizeof(BITMAPINFOHEADER) + (INT)cbColorTable); <br>     <br>        /*     * Adjust some fields.  The size field in an icon/cursor dib <br>         * includes the AND mask bits, which we don't want to include <br>         * right now. <br>         */ <br>        pbi-&gt;bmiHeader.biHeight = cy; <br>        pbi-&gt;bmiHeader.biSizeImage = cbBits; <br>     <br>        /* <br>         * Set the bits into the XOR mask. <br>         */ <br>        hbmImage = SelectObject(ghdcImage, hbmMono); <br>        SetDIBits(ghdcImage, hbmImage, 0, cy, lpDIBBits, pbi, DIB_RGB_COLORS); <br>        SelectObject(ghdcImage, hbmImage); <br>     <br>        /* <br>         * If we are editing an icon or cursor, we need to set the bits <br>         * for the AND mask also now. <br>         */ <br>        if (giType != FT_BITMAP) { <br>            /* <br>             * Skip past the XOR mask bits to the AND bits that follow. <br>             */ <br>            lpDIBBits += cbBits; <br>     <br>            cbColorTable = 2 * sizeof(RGBQUAD); <br>     <br>            /* <br>             * Adjust some fields in the copy of the bitmap info structure, <br>             * then copy a monochrome color table into it.  Note that we <br>             * are using the same allocated copy, which is ok because there <br>             * will always be enough room allocated for the monochrome <br>             * color table. <br>             */ <br>            pbi-&gt;bmiHeader.biBitCount = 1; <br>            pbi-&gt;bmiHeader.biSizeImage = <br>                    cy * ((((DWORD)cx + 31) &amp; 0xffffffe0) &gt;&gt; 3); <br>            pbi-&gt;bmiHeader.biClrImportant = 0; <br>            pbi-&gt;bmiHeader.biClrUsed = 0; <br>            memcpy((PBYTE)pbi-&gt;bmiColors, (PBYTE)gargbColorTable2, <br>                    (INT)cbColorTable); <br>     <br>            /* <br>             * Set the bits into the AND mask. <br>             */ <br>            hbmImage = SelectObject(ghdcANDMask, hbmMono); <br>            SetDIBits(ghdcANDMask, hbmImage, 0, cy, lpDIBBits, pbi, <br>                    DIB_RGB_COLORS); <br>            SelectObject(ghdcANDMask, hbmImage); <br>     <br>            /* <br>             * Combine the XOR and AND masks into a viewable image. <br>             */ <br>            ImageDCCombine(ghdcImage, gcxImage, gcyImage, ghdcANDMask); <br>        } <br>     <br>        MyFree(pbi); <br>        DeleteObject(hbmMono); <br>     <br>        /* <br>         * Set the current image pointer. <br>         */ <br>        gpImageCur = pImage; <br>        fImageDirty = FALSE; <br>        /* <br>         * Initialize the pick rectangle to encompass the entire image. <br>         */ <br>        PickSetRect(0, 0, gcxImage - 1, gcyImage - 1); <br>     <br>        SetColorPalette(gnColors, giType, FALSE); <br>     <br>        /* <br>         * Update the properties bar info and toolbox. <br>         */ <br>        PropBarUpdate(); <br>        ToolboxUpdate(); <br>     <br>        ViewReset(); <br>     <br>        /* <br>         * Reset the workspace window and then show it. <br>         */ <br>        WorkReset(); <br>        ShowWindow(ghwndWork, SW_SHOWNORMAL); <br>     <br>        SetCursor(hcurOld); <br>     <br>        return TRUE; <br>     <br>    Error3: <br>        DeleteObject(hbmMono); <br>     <br>    Error2: <br>        ImageDCDelete(); <br>     <br>    Error1: <br>        SetCursor(hcurOld); <br>     <br>        return FALSE; <br>    } <br>     <br>     <br>     <br>    /************************************************************************ <br>    * ImageSave <br>    * <br>    * Saves the state of the current image into the image list (if it <br>    * is dirty). <br>    * <br>    * History: <br>    * <br>    ************************************************************************/ <br>     <br>    VOID ImageSave(VOID) <br>    { <br>        HCURSOR hcurOld; <br>        INT iBitCount; <br>        DWORD cbColorTable; <br>        DWORD cbXORBits; <br>        DWORD cbANDBits; <br>        HANDLE hDIB; <br>        DWORD dwDIBSize; <br>        LPBITMAPINFOHEADER lpbih; <br>        LPBYTE lpBits; <br>        HBITMAP hbmMono; <br>        HBITMAP hbmImage; <br>     <br>        if (!fImageDirty) <br>            return; <br>     <br>        hcurOld = SetCursor(hcurWait); <br>     <br>        /* <br>         * Separate out the XOR and AND masks for ico/cur images. <br>         */ <br>        if (giType != FT_BITMAP) <br>            ImageDCSeparate(ghdcImage, gcxImage, gcyImage, ghdcANDMask, grgbScreen); <br>     <br>        /* <br>         * Create a temporary bitmap. <br>         */ <br>        if (!(hbmMono = CreateBitmap(1, 1, 1, 1, NULL))) { <br>            Message(MSG_OUTOFMEMORY); <br>            goto Error1; <br>        } <br>     <br>        switch (gpImageCur-&gt;nColors) { <br>            case 2: <br>                iBitCount = 1; <br>                break; <br>     <br>            case 16: <br>                iBitCount = 4; <br>                break; <br>        } <br>     <br>        cbColorTable = (DWORD)gpImageCur-&gt;nColors * sizeof(RGBQUAD); <br>        cbXORBits = (((((DWORD)gpImageCur-&gt;cx * iBitCount) + 31) <br>                &amp; 0xffffffe0) &gt;&gt; 3) * gpImageCur-&gt;cy; <br>     <br>        switch (giType) { <br>            case FT_BITMAP: <br>                cbANDBits = 0; <br>                break; <br>     <br>            case FT_ICON: <br>            case FT_CURSOR: <br>                cbANDBits = (DWORD)gpImageCur-&gt;cy * <br>                        ((((DWORD)gpImageCur-&gt;cx + 31) &amp; 0xffffffe0) &gt;&gt; 3); <br>                break; <br>        } <br>     <br>        dwDIBSize = sizeof(BITMAPINFOHEADER) + cbColorTable + cbXORBits + <br>                cbANDBits; <br>     <br>        /* <br>         * Allocate space for the DIB for this image. <br>         */ <br>        if (!(hDIB = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, dwDIBSize))) { <br>            Message(MSG_OUTOFMEMORY); <br>            goto Error2; <br>        } <br>     <br>        lpbih = (LPBITMAPINFOHEADER)GlobalLock(hDIB); <br>     <br>        /* <br>         * For icons and cursors, we need to get the AND mask bits first. <br>         */ <br>        if (giType != FT_BITMAP) { <br>            /* <br>             * Point to where the AND bits should go. <br>             */ <br>            lpBits = (LPBYTE)lpbih + sizeof(BITMAPINFOHEADER) + <br>                    cbColorTable + cbXORBits; <br>     <br>            /* <br>             * Fill in the bitmap info header for getting the AND bits. <br>             */ <br>            lpbih-&gt;biSize          = sizeof(BITMAPINFOHEADER); <br>            lpbih-&gt;biWidth         = gpImageCur-&gt;cx; <br>            lpbih-&gt;biHeight        = gpImageCur-&gt;cy; <br>            lpbih-&gt;biPlanes        = 1; <br>            lpbih-&gt;biBitCount      = 1; <br>            lpbih-&gt;biCompression   = BI_RGB; <br>            lpbih-&gt;biSizeImage     = cbANDBits; <br>            lpbih-&gt;biXPelsPerMeter = 0; <br>            lpbih-&gt;biYPelsPerMeter = 0; <br>            lpbih-&gt;biClrImportant  = 0; <br>            lpbih-&gt;biClrUsed       = 0; <br>     <br>            /* <br>             * Get the bits from the AND mask. <br>             */ <br>            hbmImage = SelectObject(ghdcANDMask, hbmMono); <br>            GetDIBits(ghdcANDMask, hbmImage, 0, gpImageCur-&gt;cy, lpBits, <br>                    (LPBITMAPINFO)lpbih, DIB_RGB_COLORS); <br>            SelectObject(ghdcANDMask, hbmImage); <br>        } <br>     <br>        /* <br>         * Fill in the bitmap info header for getting the XOR bits. <br>         */ <br>        lpbih-&gt;biSize          = sizeof(BITMAPINFOHEADER); <br>        lpbih-&gt;biWidth         = gpImageCur-&gt;cx; <br>        lpbih-&gt;biHeight        = gpImageCur-&gt;cy; <br>        lpbih-&gt;biPlanes        = 1; <br>        lpbih-&gt;biBitCount      = iBitCount; <br>        lpbih-&gt;biCompression   = BI_RGB; <br>        lpbih-&gt;biSizeImage     = cbXORBits; <br>        lpbih-&gt;biXPelsPerMeter = 0; <br>        lpbih-&gt;biYPelsPerMeter = 0; <br>        lpbih-&gt;biClrImportant  = 0; <br>        lpbih-&gt;biClrUsed       = 0; <br>     <br>        /* <br>         * Point to where the XOR bits should go. <br>         */ <br>        lpBits = (LPBYTE)lpbih + sizeof(BITMAPINFOHEADER) + cbColorTable; <br>     <br>        /* <br>         * Get the bits from the XOR mask. <br>         */ <br>        hbmImage = SelectObject(ghdcImage, hbmMono); <br>        GetDIBits(ghdcImage, hbmImage, 0, gpImageCur-&gt;cy, lpBits, <br>                (LPBITMAPINFO)lpbih, DIB_RGB_COLORS); <br>        SelectObject(ghdcImage, hbmImage); <br>     <br>        /* <br>         * For icons and cursors, we have a few extra steps. <br>         */ <br>        if (giType != FT_BITMAP) { <br>            /* <br>             * Set the fields in the info structure to their final <br>             * values.  The saved value in the bitmap info header for the <br>             * height in an icon/cursor DIB is really twice the height of <br>             * the image, and the size of the image is the size of both <br>             * the XOR and the AND mask bits. <br>             */ <br>            lpbih-&gt;biHeight *= 2; <br>            lpbih-&gt;biSizeImage = cbXORBits + cbANDBits; <br>     <br>            /* <br>             * Recombine the XOR and AND masks now that we have their bits. <br>             */ <br>            ImageDCCombine(ghdcImage, gcxImage, gcyImage, ghdcANDMask); <br>        } <br>     <br>        /* <br>         * Free any old DIB. <br>         */ <br>        if (gpImageCur-&gt;DIBhandle) { <br>            GlobalUnlock(gpImageCur-&gt;DIBhandle); <br>            GlobalFree(gpImageCur-&gt;DIBhandle); <br>        } <br>     <br>        /* <br>         * Set the image structure to point to the newly created DIB. <br>         */ <br>        gpImageCur-&gt;DIBSize = dwDIBSize; <br>        gpImageCur-&gt;DIBhandle = hDIB; <br>        gpImageCur-&gt;DIBPtr = (LPBYTE)lpbih; <br>     <br>        fFileDirty = TRUE; <br>        fImageDirty = FALSE; <br>     <br>    Error2: <br>        DeleteObject(hbmMono); <br>     <br>    Error1: <br>        SetCursor (hcurOld); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
