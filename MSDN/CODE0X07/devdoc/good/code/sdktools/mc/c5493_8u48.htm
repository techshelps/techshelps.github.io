<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MCPARSE.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5498"></a>MCPARSE.C</h2>
<pre><code>/*++ <br> <br>Copyright 1991-1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    mcparse.c <br> <br>Abstract: <br> <br>    This file contains the parse logic for the Win32 Message Compiler (MC) <br> <br> <br>--*/ <br> <br>#include "mc.h" <br> <br>BOOLEAN <br>McParseFile( void ) <br>{ <br>    unsigned int t; <br>    BOOLEAN FirstMessageDefinition = TRUE; <br>    PNAME_INFO p; <br> <br>    if (!McOpenInputFile()) { <br>        fprintf( stderr, "MC: Unable to open %s for input\n", MessageFileName ); <br>        return( FALSE ); <br>        } <br> <br>    fprintf( stderr, "MC: Compiling %s\n", MessageFileName ); <br>    while ((t = McGetToken( TRUE )) != MCTOK_END_OF_FILE) { <br>        switch (t) { <br>        case MCTOK_MSGIDTYPE_KEYWORD: <br>            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) { <br>                if ((t = McGetToken( FALSE )) == MCTOK_NAME) { <br>                    MessageIdTypeName = McMakeString( TokenCharValue ); <br>                    } <br>                else { <br>                    McInputError( "Symbol name must follow %s=", TRUE, TokenKeyword-&gt;Name ); <br>                    return( FALSE ); <br>                    } <br>                } <br>            else { <br>                McInputError( "Equal sign must follow %s", TRUE, TokenKeyword-&gt;Name ); <br>                return( FALSE ); <br>                } <br>            break; <br> <br>        case MCTOK_SEVNAMES_KEYWORD: <br>            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) { <br>                if ((t = McGetToken( FALSE )) == MCTOK_LEFT_PAREN) { <br>                    if (!McParseNameList( &amp;SeverityNames, FALSE, 0x3L )) { <br>                        return( FALSE ); <br>                        } <br>                    } <br>                else { <br>                    McInputError( "Left parenthesis name must follow %s=", TRUE, TokenKeyword-&gt;Name ); <br>                    return( FALSE ); <br>                    } <br>                } <br>            else { <br>                McInputError( "Equal sign must follow %s", TRUE, TokenKeyword-&gt;Name ); <br>                return( FALSE ); <br>                } <br>            break; <br> <br>        case MCTOK_FACILITYNAMES_KEYWORD: <br>            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) { <br>                if ((t = McGetToken( FALSE )) == MCTOK_LEFT_PAREN) { <br>                    if (!McParseNameList( &amp;FacilityNames, FALSE, 0xFFFL )) { <br>                        return( FALSE ); <br>                        } <br>                    } <br>                else { <br>                    McInputError( "Left parenthesis name must follow %s=", TRUE, TokenKeyword-&gt;Name ); <br>                    return( FALSE ); <br>                    } <br>                } <br>            else { <br>                McInputError( "Equal sign must follow %s", TRUE, TokenKeyword-&gt;Name ); <br>                return( FALSE ); <br>                } <br>            break; <br> <br>        case MCTOK_LANGNAMES_KEYWORD: <br>            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) { <br>                if ((t = McGetToken( FALSE )) == MCTOK_LEFT_PAREN) { <br>                    if (!McParseNameList( &amp;LanguageNames, TRUE, 0xFFFFL )) { <br>                        return( FALSE ); <br>                        } <br>                    } <br>                else { <br>                    McInputError( "Left parenthesis name must follow %s=", TRUE, TokenKeyword-&gt;Name ); <br>                    return( FALSE ); <br>                    } <br>                } <br>            else { <br>                McInputError( "Equal sign must follow %s", TRUE, TokenKeyword-&gt;Name ); <br>                return( FALSE ); <br>                } <br>            break; <br> <br>        case MCTOK_MESSAGEID_KEYWORD: <br>            McUnGetToken(); <br>            if (FirstMessageDefinition) { <br>                FirstMessageDefinition = FALSE; <br>                McFlushComments(); <br>                fprintf( HeaderFile, "//\r\n" ); <br>                fprintf( HeaderFile, "//  Values are 32 bit values layed out as follows:\r\n" ); <br>                fprintf( HeaderFile, "//\r\n" ); <br>                fprintf( HeaderFile, "//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1\r\n" ); <br>                fprintf( HeaderFile, "//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\r\n" ); <br>                fprintf( HeaderFile, "//  +---+-+-+-----------------------+-------------------------------+\r\n" ); <br>                fprintf( HeaderFile, "//  |Sev|C|R|     Facility          |               Code            |\r\n" ); <br>                fprintf( HeaderFile, "//  +---+-+-+-----------------------+-------------------------------+\r\n" ); <br>                fprintf( HeaderFile, "//\r\n" ); <br>                fprintf( HeaderFile, "//  where\r\n" ); <br>                fprintf( HeaderFile, "//\r\n" ); <br>                fprintf( HeaderFile, "//      Sev - is the severity code\r\n" ); <br>                fprintf( HeaderFile, "//\r\n" ); <br>                fprintf( HeaderFile, "//          00 - Success\r\n" ); <br>                fprintf( HeaderFile, "//          01 - Informational\r\n" ); <br>                fprintf( HeaderFile, "//          10 - Warning\r\n" ); <br>                fprintf( HeaderFile, "//          11 - Error\r\n" ); <br>                fprintf( HeaderFile, "//\r\n" ); <br>                fprintf( HeaderFile, "//      C - is the Customer code flag\r\n" ); <br>                fprintf( HeaderFile, "//\r\n" ); <br>                fprintf( HeaderFile, "//      R - is a reserved bit\r\n" ); <br>                fprintf( HeaderFile, "//\r\n" ); <br>                fprintf( HeaderFile, "//      Facility - is the facility code\r\n" ); <br>                fprintf( HeaderFile, "//\r\n" ); <br>                fprintf( HeaderFile, "//      Code - is the facility's status code\r\n" ); <br>                fprintf( HeaderFile, "//\r\n" ); <br> <br>                fprintf( HeaderFile, "//\r\n" ); <br>                fprintf( HeaderFile, "// Define the facility codes\r\n" ); <br>                fprintf( HeaderFile, "//\r\n" ); <br>                p = FacilityNames; <br>                while( p ) { <br>                    if (p-&gt;Value) { <br>                        fprintf( HeaderFile, GenerateDecimalValues ? <br>                                             "#define %-32s %ld\r\n" : <br>                                             "#define %-32s 0x%lX\r\n", <br>                                 p-&gt;Value, p-&gt;Id <br>                               ); <br>                        } <br> <br>                    p = p-&gt;Next; <br>                    } <br>                fprintf( HeaderFile, "\r\n" ); <br>                fprintf( HeaderFile, "\r\n" ); <br> <br>                fprintf( HeaderFile, "//\r\n" ); <br>                fprintf( HeaderFile, "// Define the severity codes\r\n" ); <br>                fprintf( HeaderFile, "//\r\n" ); <br>                p = SeverityNames; <br>                while( p ) { <br>                    if (p-&gt;Value) { <br>                        fprintf( HeaderFile, GenerateDecimalValues ? <br>                                             "#define %-32s %ld\r\n" : <br>                                             "#define %-32s 0x%lX\r\n", <br>                                 p-&gt;Value, p-&gt;Id <br>                               ); <br>                        } <br> <br>                    p = p-&gt;Next; <br>                    } <br>                fprintf( HeaderFile, "\r\n" ); <br>                fprintf( HeaderFile, "\r\n" ); <br>                } <br> <br>            if (!McParseMessageDefinition()) { <br>                return( FALSE ); <br>                } <br>            break; <br> <br>        default: <br>            McInputError( "Invalid message file token - '%s'", TRUE, TokenCharValue ); <br>            return( FALSE ); <br>            break; <br>        } <br>    } <br> <br>    McFlushComments(); <br>    return( TRUE ); <br>} <br> <br> <br>BOOLEAN <br>McParseMessageDefinition( void ) <br>{ <br>    unsigned int t; <br>    PMESSAGE_INFO MessageInfo; <br>    BOOLEAN MessageIdSeen; <br>    PMESSAGE_INFO MessageInfoTemp; <br> <br>    McFlushComments(); <br> <br>    MessageInfo = malloc( sizeof( *MessageInfo ) ); <br>    MessageInfo-&gt;Next = NULL; <br>    MessageInfo-&gt;Id = 0; <br>    MessageInfo-&gt;Method = MSG_PLUS_ONE; <br>    MessageInfo-&gt;SymbolicName = NULL; <br>    MessageInfo-&gt;EndOfLineComment = NULL; <br>    MessageInfo-&gt;MessageText = NULL; <br>    MessageIdSeen = FALSE; <br> <br>    while ((t = McGetToken( TRUE )) != MCTOK_END_OF_FILE) { <br>        switch (t) { <br>        case MCTOK_MESSAGEID_KEYWORD: <br>            if (MessageIdSeen) { <br>                McInputError( "Invalid message definition - text missing.", TRUE, NULL ); <br>                return( FALSE ); <br>                } <br> <br>            MessageIdSeen = TRUE; <br>            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) { <br>                if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) { <br>                    MessageInfo-&gt;Id = TokenNumericValue; <br>                    MessageInfo-&gt;Method = MSG_ABSOLUTE; <br>                    } <br>                else <br>                if (t == MCTOK_PLUS) { <br>                    if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) { <br>                        MessageInfo-&gt;Id = TokenNumericValue; <br>                        MessageInfo-&gt;Method = MSG_PLUS_VALUE; <br>                        } <br>                    else { <br>                        McInputError( "Number must follow %s=+", TRUE, TokenKeyword-&gt;Name ); <br>                        return( FALSE ); <br>                        } <br>                    } <br>                else { <br>                    McUnGetToken(); <br>                    } <br> <br>                } <br>            else { <br>                McInputError( "Equal sign must follow %s", TRUE, TokenKeyword-&gt;Name ); <br>                return( FALSE ); <br>                } <br>            break; <br> <br>        case MCTOK_SEVERITY_KEYWORD: <br>            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) { <br>                if (!McParseName( SeverityNames, &amp;CurrentSeverityName )) { <br>                    return( FALSE ); <br>                    } <br>                } <br>            else { <br>                McInputError( "Equal sign must follow %s", TRUE, TokenKeyword-&gt;Name ); <br>                return( FALSE ); <br>                } <br>            break; <br> <br>        case MCTOK_FACILITY_KEYWORD: <br>            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) { <br>                if (!McParseName( FacilityNames, &amp;CurrentFacilityName )) { <br>                    return( FALSE ); <br>                    } <br>                } <br>            else { <br>                McInputError( "Equal sign must follow %s", TRUE, TokenKeyword-&gt;Name ); <br>                return( FALSE ); <br>                } <br>            break; <br> <br>        case MCTOK_SYMBOLNAME_KEYWORD: <br>            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) { <br>                if ((t = McGetToken( FALSE )) == MCTOK_NAME) { <br>                    MessageInfo-&gt;SymbolicName = McMakeString( TokenCharValue ); <br>                    } <br>                else { <br>                    McInputError( "Symbol name must follow %s=+", TRUE, TokenKeyword-&gt;Name ); <br>                    return( FALSE ); <br>                    } <br>                } <br>            else { <br>                McInputError( "Equal sign must follow %s", TRUE, TokenKeyword-&gt;Name ); <br>                return( FALSE ); <br>                } <br>            break; <br> <br> <br>        case MCTOK_END_OF_LINE_COMMENT: <br>            MessageInfo-&gt;EndOfLineComment = McMakeString( TokenCharValue ); <br>            break; <br> <br>        case MCTOK_LANGUAGE_KEYWORD: <br>            McUnGetToken(); <br> <br> <br>            if (MessageInfo-&gt;Method == MSG_PLUS_ONE) { <br>                MessageInfo-&gt;Id = CurrentFacilityName-&gt;LastId + 1; <br>                } <br>            else <br>            if (MessageInfo-&gt;Method == MSG_PLUS_VALUE) { <br>                MessageInfo-&gt;Id = CurrentFacilityName-&gt;LastId + MessageInfo-&gt;Id; <br>                } <br> <br>            if (MessageInfo-&gt;Id &gt; 0xFFFFL) { <br>                McInputError( "Message Id value (%lx) too large", TRUE, (PVOID)MessageInfo-&gt;Id ); <br>                return( FALSE ); <br>                } <br> <br>            MessageInfo-&gt;Id |= (CurrentSeverityName-&gt;Id &lt;&lt; 30) | <br>                               CustomerMsgIdBit | <br>                               (CurrentFacilityName-&gt;Id &lt;&lt; 16); <br> <br>            fprintf( HeaderFile, "//\r\n" ); <br>            if (MessageInfo-&gt;SymbolicName) { <br>                fprintf( HeaderFile, "// MessageId: %s\r\n", <br>                                     MessageInfo-&gt;SymbolicName <br>                       ); <br>                } <br>            else { <br>                fprintf( HeaderFile, "// MessageId: 0x%08lXL (No symbolic name defined)\r\n", <br>                                     MessageInfo-&gt;Id <br>                       ); <br>                } <br> <br>            fprintf( HeaderFile, "//\r\n" ); <br>            fprintf( HeaderFile, "// MessageText:\r\n" ); <br>            fprintf( HeaderFile, "//\r\n" ); <br> <br>            if (McParseMessageText( MessageInfo )) { <br>                fprintf( HeaderFile, "//\r\n" ); <br>                if (MessageInfo-&gt;SymbolicName) { <br> <br>                    if (MessageIdTypeName != NULL) { <br>                        fprintf( HeaderFile, GenerateDecimalValues ? <br>                                             "#define %-32s ((%s)%ldL)" : <br>                                             "#define %-32s ((%s)0x%08lXL)", <br>                                             MessageInfo-&gt;SymbolicName, <br>                                             MessageIdTypeName, <br>                                             MessageInfo-&gt;Id <br>                               ); <br>                        } <br>                    else { <br>                        fprintf( HeaderFile, GenerateDecimalValues ? <br>                                             "#define %-32s %ldL" : <br>                                             "#define %-32s 0x%08lXL", <br>                                             MessageInfo-&gt;SymbolicName, <br>                                             MessageInfo-&gt;Id <br>                               ); <br>                        } <br>                    } <br> <br>                if (MessageInfo-&gt;EndOfLineComment) { <br>                    fprintf( HeaderFile, "    %s", MessageInfo-&gt;EndOfLineComment ); <br>                    } <br>                else { <br>                    fprintf( HeaderFile, "\r\n" ); <br>                    } <br>                fprintf( HeaderFile, "\r\n" ); <br> <br>                if (Messages == NULL) { <br>                    Messages = MessageInfo; <br>                    } <br>                else { <br>                    MessageInfoTemp = Messages; <br> <br>                    // <br>                    //  Scan the existing messages to see if this message <br>                    //  exists in the message file. <br>                    // <br>                    //  If it does, generate and error for the user. <br>                    // <br> <br>                    while (MessageInfoTemp != NULL) { <br> <br>                        if (MessageInfoTemp-&gt;Id == MessageInfo-&gt;Id) { <br>                            McInputError( "Duplicate message ID - 0x%lx", FALSE, (PVOID)MessageInfo-&gt;Id ); <br>                            } <br> <br>                        MessageInfoTemp = MessageInfoTemp-&gt;Next; <br>                        } <br> <br>                    CurrentMessage-&gt;Next = MessageInfo; <br>                    } <br> <br>                CurrentMessage = MessageInfo; <br>                CurrentFacilityName-&gt;LastId = MessageInfo-&gt;Id &amp; 0xFFFF; <br>                return( TRUE ); <br>                } <br>            else { <br>                return( FALSE ); <br>                } <br> <br>        default: <br>            McInputError( "Invalid message definition token - '%s'", TRUE, TokenCharValue ); <br>            return( FALSE ); <br>            } <br>        } <br> <br>    return( FALSE ); <br>} <br> <br> <br>char MessageTextBuffer[ 8192 ]; <br> <br>BOOLEAN <br>McParseMessageText( <br>    PMESSAGE_INFO MessageInfo <br>    ) <br>{ <br>    PLANGUAGE_INFO MessageText, *pp; <br>    char *src, *dst; <br>    unsigned int t, n; <br>    BOOLEAN FirstLanguageProcessed; <br> <br>    pp = &amp;MessageInfo-&gt;MessageText; <br> <br>    FirstLanguageProcessed = FALSE; <br>    while ((t = McGetToken( TRUE )) != MCTOK_END_OF_FILE) { <br>        if (t == MCTOK_LANGUAGE_KEYWORD) { <br>            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) { <br>                if (!McParseName( LanguageNames, &amp;CurrentLanguageName )) { <br>                    return( FALSE ); <br>                    } <br>                } <br>            else { <br>                McInputError( "Equal sign must follow %s", TRUE, TokenKeyword-&gt;Name ); <br>                return( FALSE ); <br>                } <br>            } <br>        else { <br>            McUnGetToken(); <br>            break; <br>            } <br> <br>        MessageText = malloc( sizeof( *MessageText ) ); <br>        MessageText-&gt;Next = NULL; <br>        MessageText-&gt;Id = CurrentLanguageName-&gt;Id; <br>        MessageText-&gt;Length = 0; <br>        MessageText-&gt;Text = NULL; <br> <br>        dst = MessageTextBuffer; <br>        while (src = McGetLine()) { <br>            if (!strcmp( src, ".\r\n" )) { <br>                if (MessageText-&gt;Length == 0) { <br>                    if (MessageInfo-&gt;SymbolicName) { <br>                        strcpy( dst, MessageInfo-&gt;SymbolicName ); <br>                        } <br>                    else { <br>                        sprintf( dst, "No symbolic name defined for0x%08lXL" ); <br>                        } <br> <br>                    strcat( dst, "\r\n" ); <br>                    if (!FirstLanguageProcessed) { <br>                        fprintf( HeaderFile, "//  %s", dst ); <br>                        } <br> <br>                    n = strlen( dst ); <br>                    dst += n; <br>                    MessageText-&gt;Length += n; <br>                    } <br> <br>                McSkipLine(); <br>                break; <br>                } <br>            else <br>            if (!strnicmp( src, "LanguageId=", 11 ) || <br>                !strnicmp( src, "MessageId=", 10 ) <br>               ) { <br>                McInputError( "Unterminated message definition", TRUE, NULL ); <br>                return( FALSE ); <br>                } <br> <br>            if (!FirstLanguageProcessed) { <br>                fprintf( HeaderFile, "//  %s", src ); <br>                } <br> <br>            n = strlen( src ); <br>            if (MessageText-&gt;Length + n &gt; sizeof( MessageTextBuffer )) { <br>                McInputError( "Message text too long - &gt; %ld", TRUE, <br>                              (PVOID)(ULONG)sizeof( MessageTextBuffer ) <br>                            ); <br>                return( FALSE ); <br>                } <br> <br>            strcpy( dst, src ); <br>            dst += n; <br>            MessageText-&gt;Length += n; <br>            } <br>        *dst = '\0'; <br> <br>        n = ((USHORT)MessageText-&gt;Length)+1; <br>        MessageText-&gt;Text = malloc( n ); <br>        memcpy( MessageText-&gt;Text, MessageTextBuffer, n ); <br>        *pp = MessageText; <br>        pp = &amp;MessageText-&gt;Next; <br>        FirstLanguageProcessed = TRUE; <br>        } <br> <br>    return( TRUE ); <br>} <br> <br> <br>BOOLEAN <br>McParseNameList( <br>    PNAME_INFO *NameListHead, <br>    BOOLEAN ValueRequired, <br>    ULONG MaximumValue <br>    ) <br>{ <br>    unsigned int t; <br>    PNAME_INFO p; <br>    char *Name; <br>    ULONG Id; <br>    PVOID Value; <br> <br>    while ((t = McGetToken( FALSE )) != MCTOK_END_OF_FILE) { <br>        if (t == MCTOK_RIGHT_PAREN) { <br>            return( TRUE ); <br>            } <br> <br>        if (t == MCTOK_NAME) { <br>            Name = McMakeString( TokenCharValue ); <br>            Id = 0; <br>            Value = NULL; <br>            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) { <br>                if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) { <br>                    Id = TokenNumericValue; <br>                    if ((t = McGetToken( FALSE )) == MCTOK_COLON) { <br>                        if ((t = McGetToken( FALSE )) == MCTOK_NAME) { <br>                            Value = McMakeString( TokenCharValue ); <br>                            } <br>                        else { <br>                            McInputError( "File name must follow =%ld:", TRUE, (PVOID)Id ); <br>                            return( FALSE ); <br>                            } <br>                        } <br>                    else { <br>                        if (ValueRequired) { <br>                            McInputError( "Colon must follow =%ld", TRUE, (PVOID)Id ); <br>                            return( FALSE ); <br>                            } <br> <br>                        McUnGetToken(); <br>                        } <br>                    } <br>                else { <br>                    McInputError( "Number must follow %s=", TRUE, Name ); <br>                    return( FALSE ); <br>                    } <br>                } <br>            else { <br>                McInputError( "Equal sign name must follow %s", TRUE, Name ); <br>                return( FALSE ); <br>                } <br> <br>            if (Id &gt; MaximumValue) { <br>                McInputError( "Value is too large (&gt; %lx)", TRUE, (PVOID)MaximumValue ); <br>                return( FALSE ); <br>                } <br> <br>            p = McAddName( NameListHead, Name, Id, Value ); <br>            free( Name ); <br>            } <br>        } <br> <br>    return( FALSE ); <br>} <br> <br>BOOLEAN <br>McParseName( <br>    PNAME_INFO NameListHead, <br>    PNAME_INFO *Result <br>    ) <br>{ <br>    unsigned int t; <br>    PNAME_INFO p; <br> <br>    if ((t = McGetToken( FALSE )) == MCTOK_NAME) { <br>        p = McFindName( NameListHead, TokenCharValue ); <br>        if (p != NULL) { <br>            *Result = p; <br>            return( TRUE ); <br>            } <br>        else { <br>            McInputError( "Invalid name - %s", TRUE, TokenCharValue ); <br>            } <br>        } <br>    else { <br>        McInputError( "Missing name after %s=", TRUE, TokenKeyword-&gt;Name ); <br>        } <br> <br>    return( FALSE ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
