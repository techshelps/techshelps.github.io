<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MCLEX.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5496"></a>MCLEX.C</h2>
<pre><code>/*++ <br> <br>Copyright 1991-1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    mclex.c <br> <br>Abstract: <br> <br>    This file contains the input lexer for the Win32 Message Compiler (MC) <br> <br>--*/ <br> <br> <br>#include "mc.h" <br> <br>char LineBuffer[ 256 ]; <br>char *CurrentChar; <br>BOOLEAN ReturnCurrentToken; <br> <br>PNAME_INFO KeywordNames; <br> <br>typedef struct _COMMENT_INFO { <br>    struct _COMMENT_INFO *Next; <br>    char Text[ 1 ]; <br>} COMMENT_INFO, *PCOMMENT_INFO; <br> <br>PCOMMENT_INFO Comments, CurrentComment; <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This fills in the Key words associated with the Message file format <br> <br>Return Value: <br> <br>    TRUE <br> <br>--*/ <br> <br> <br> <br>BOOLEAN <br>McInitLexer( void ) <br>{ <br>    ReturnCurrentToken = FALSE; <br>    McAddName( &amp;KeywordNames, "MessageIdTypedef",   MCTOK_MSGIDTYPE_KEYWORD,  NULL ); <br>    McAddName( &amp;KeywordNames, "SeverityNames",      MCTOK_SEVNAMES_KEYWORD,   NULL ); <br>    McAddName( &amp;KeywordNames, "FacilityNames",      MCTOK_FACILITYNAMES_KEYWORD,  NULL ); <br>    McAddName( &amp;KeywordNames, "LanguageNames",      MCTOK_LANGNAMES_KEYWORD,  NULL ); <br>    McAddName( &amp;KeywordNames, "MessageId",          MCTOK_MESSAGEID_KEYWORD,  NULL ); <br>    McAddName( &amp;KeywordNames, "Severity",           MCTOK_SEVERITY_KEYWORD,   NULL ); <br>    McAddName( &amp;KeywordNames, "Facility",           MCTOK_FACILITY_KEYWORD,   NULL ); <br>    McAddName( &amp;KeywordNames, "SymbolicName",       MCTOK_SYMBOLNAME_KEYWORD, NULL ); <br>    McAddName( &amp;KeywordNames, "Language",           MCTOK_LANGUAGE_KEYWORD,   NULL ); <br>    return( TRUE ); <br>} <br> <br> <br> <br>BOOLEAN <br>McOpenInputFile( void ) <br>{ <br>    char SavedChar, *s, *FileName; <br>    BOOLEAN Result; <br> <br>    s = MessageFileName; <br>    FileName = s; <br>    SavedChar = '\0'; <br>    while (*s) { <br>        if (*s == '.') { <br>            SavedChar = '.'; <br>            *s = '\0'; <br>            break; <br>            } <br> <br>        if (*s == ':' || *s == '\\' || *s == '/') { <br>            FileName = s+1; <br>            } <br> <br>        s = CharNext(s); <br>} <br> <br>    strcat( HeaderFileName, FileName ); <br>    strcat( HeaderFileName, ".h" ); <br>    strcat( RcInclFileName, FileName ); <br>    strcat( RcInclFileName, ".rc" ); <br> <br>    if (SavedChar == '\0') { <br>        strcpy( s, ".mc" ); <br>        } <br>    else { <br>        *s = SavedChar; <br>        } <br> <br>    Result = FALSE; <br>    MessageFileLineNumber = 0; <br>    LineBuffer[ 0 ] = '\0'; <br>    CurrentChar = NULL; <br> <br>    MessageFile = fopen( MessageFileName, "rb" ); <br>    if (MessageFile == NULL) { <br>        McInputError( "unable to open input file", TRUE, NULL ); <br>        } <br>    else { <br>        HeaderFile = fopen( HeaderFileName, "wb" ); <br>        if (HeaderFile == NULL) { <br>            McInputError( "unable to open output file - %s", TRUE, HeaderFileName ); <br>            } <br>        else { <br>            RcInclFile = fopen( RcInclFileName, "wb" ); <br>            if (RcInclFile == NULL) { <br>                McInputError( "unable to open output file - %s", TRUE, RcInclFileName ); <br>                } <br>            else { <br>                Result = TRUE; <br>                } <br>            } <br>        } <br> <br>    if (!Result) { <br>        McCloseInputFile(); <br>        McCloseOutputFiles(); <br>        } <br>    else { <br>        return( TRUE ); <br>        } <br>} <br> <br> <br> <br>void <br>McCloseInputFile( void ) <br>{ <br>    if (MessageFile != NULL) { <br>        fclose( MessageFile ); <br>        MessageFile = NULL; <br>        CurrentChar = NULL; <br>        LineBuffer[ 0 ] = '\0'; <br>        } <br>} <br> <br> <br> <br>void <br>McCloseOutputFiles( void ) <br>{ <br>    if (HeaderFile != NULL) { <br>        fclose( HeaderFile ); <br>        } <br> <br>    if (RcInclFile != NULL) { <br>        fclose( RcInclFile ); <br>        } <br>} <br> <br> <br>void <br>McInputError( <br>    char *Message, <br>    BOOLEAN Error, <br>    PVOID Argument <br>    ) <br>{ <br>    fprintf( stderr, <br>             "%s (%d) : %s: ", <br>             MessageFileName, <br>             MessageFileLineNumber, <br>             Error ? "Error" : "Warning" <br>           ); <br> <br>    fprintf( stderr, Message, Argument ); <br>    fprintf( stderr, "\n" ); <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>   This retrieves the current line then moves down to the <br>   next line in the message file. <br> <br>Return Value: <br> <br>   Returns the current line of in the file. <br> <br>--*/ <br> <br> <br>char * <br>McGetLine( void ) <br>{ <br>    char *s; <br> <br>    if (MessageFile == NULL || feof( MessageFile )) { <br>        return( NULL ); <br>        } <br> <br>    if (fgets( LineBuffer, sizeof( LineBuffer ), MessageFile ) == NULL) { <br>        return( NULL ); <br>        } <br> <br>    s = LineBuffer + strlen( LineBuffer ); <br>    if (s &gt; LineBuffer &amp;&amp; *--s == '\n') { <br>        if (s &gt; LineBuffer &amp;&amp; *--s != '\r') { <br>            *++s = '\r'; <br>            *++s = '\n'; <br>            *++s = '\0'; <br>            } <br>        } <br> <br>    MessageFileLineNumber++; <br>    return( CurrentChar = LineBuffer ); <br>} <br> <br> <br>void <br>McSkipLine( void ) <br>{ <br>    CurrentChar = NULL; <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>   This retrieves the character at the current position of the line <br>   buffer then advances to the next position. If the end of the line <br>   is reached another line is retrieve. If the end of the file is reached <br>   this returns with a NULL character. One is optionally able to flush <br>   the white space from the line. <br> <br>Arguments: <br> <br>   A boolean specifying whether whitespace should be consider significant. <br> <br>Return Value: <br> <br>   Returns the character in the current line. <br> <br>--*/ <br> <br> <br> <br> <br>char <br>McGetChar( <br>    BOOLEAN SkipWhiteSpace <br>    ) <br>{ <br>    BOOLEAN SawWhiteSpace; <br>    BOOLEAN SawNewLine; <br>    PCOMMENT_INFO p; <br> <br>    SawWhiteSpace = FALSE; <br> <br>tryagain: <br>    SawNewLine = FALSE; <br>    if (CurrentChar == NULL) { <br>        McGetLine(); <br>        if (CurrentChar == NULL) { <br>            return( '\0' ); <br>            } <br> <br>        SawNewLine = TRUE; <br>        } <br> <br>    if (SkipWhiteSpace) { <br>        while (*CurrentChar &lt;= ' ') { <br>            SawWhiteSpace = TRUE; <br>            if (!*CurrentChar++) { <br>                CurrentChar = NULL; <br>                break; <br>                } <br>            } <br>        } <br> <br>    if (SawNewLine) { <br>        if (CurrentChar != NULL &amp;&amp; *CurrentChar == MCCHAR_END_OF_LINE_COMMENT) { <br>            p = malloc( sizeof( *p ) + strlen( ++CurrentChar ) ); <br>            p-&gt;Next = NULL; <br>            strcpy( p-&gt;Text, CurrentChar ); <br>            if (CurrentComment == NULL) { <br>                Comments = p; <br>                } <br>            else { <br>                CurrentComment-&gt;Next = p; <br>                } <br>            CurrentComment = p; <br> <br>            CurrentChar = NULL; <br>            } <br>        } <br> <br>    if (CurrentChar == NULL &amp;&amp; SkipWhiteSpace) { <br>        goto tryagain; <br>        } <br> <br>    if (SawWhiteSpace) { <br>        return( ' ' ); <br>        } <br>    else { <br>        return( *CurrentChar++ ); <br>        } <br>} <br> <br> <br>void <br>McFlushComments( void ) <br>{ <br>    PCOMMENT_INFO p; <br> <br>    while (p = Comments) { <br>        fprintf( HeaderFile, "%s", p-&gt;Text ); <br> <br>        Comments = Comments-&gt;Next; <br>        free( p ); <br>        } <br>    Comments = NULL; <br>    CurrentComment = NULL; <br> <br>    fflush( HeaderFile ); <br>    return; <br>} <br> <br> <br>void <br>McUnGetChar( <br>    char c <br>    ) <br>{ <br>    if (CurrentChar &gt; LineBuffer) { <br>        *--CurrentChar = c; <br>        } <br>    else { <br>        LineBuffer[ 0 ] = c; <br>        LineBuffer[ 1 ] = '\0'; <br>        CurrentChar = LineBuffer; <br>        } <br>} <br> <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Breaks input line into "tokens values" as defined in MC.H. <br> <br>Arguments: <br> <br>    A boolean designating whether keywords are required. <br> <br>Return Value: <br> <br>   Returns the the token corresponding to the "token value" For example <br>   with a token of type MCTOK_NUMBER the value would be a string <br>   representation of an integer. <br> <br>--*/ <br> <br> <br>unsigned int <br>McGetToken( <br>    BOOLEAN KeywordExpected <br>    ) <br>{ <br>    char c, *dst; <br> <br>    if (ReturnCurrentToken) { <br>        ReturnCurrentToken = FALSE; <br>        if (Token == MCTOK_NAME &amp;&amp; KeywordExpected) { <br>            TokenKeyword = McFindName( KeywordNames, TokenCharValue ); <br>            if (TokenKeyword == NULL) { <br>                McInputError( "expected keyword - %s", TRUE, TokenCharValue ); <br>                Token = MCTOK_END_OF_FILE; <br>                } <br>            else { <br>                Token = (unsigned int)TokenKeyword-&gt;Id; <br>                } <br>            } <br> <br>        return( Token ); <br>        } <br> <br>    Token = MCTOK_END_OF_FILE; <br>    dst = TokenCharValue; <br>    *dst = '\0'; <br>    TokenNumericValue = 0L; <br> <br>    while (TRUE) { <br>        c = McGetChar( (BOOLEAN)(Token == MCTOK_END_OF_FILE) ); <br>        if (Token == MCTOK_NUMBER) { <br>            if (isdigit( c ) || <br>                c == 'x' || <br>                (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || <br>                (c &gt;= 'A' &amp;&amp; c &lt;= 'F') <br>               ) { <br>                *dst++ = c; <br>                } <br>            else { <br>                McUnGetChar( c ); <br>                *dst = '\0'; <br> <br>                if (!McCharToInteger( TokenCharValue, 0, &amp;TokenNumericValue )) { <br>                    McInputError( "invalid number - %s", TRUE, TokenCharValue ); <br>                    Token = MCTOK_END_OF_FILE; <br>                    } <br>                else { <br>                    return( Token ); <br>                    } <br>                } <br>            } <br>        else <br>        if (Token == MCTOK_NAME) { <br>            if (iscsym( c )) { <br>                *dst++ = c; <br>                } <br>            else { <br>                McUnGetChar( c ); <br>                *dst = '\0'; <br> <br>                if (KeywordExpected) { <br>                    TokenKeyword = McFindName( KeywordNames, TokenCharValue ); <br>                    if (TokenKeyword == NULL) { <br>                        McInputError( "expected keyword - %s", TRUE, TokenCharValue ); <br>                        Token = MCTOK_END_OF_FILE; <br>                        } <br>                    else { <br>                        Token = (unsigned int)TokenKeyword-&gt;Id; <br>                        } <br>                    } <br>                return( Token ); <br>                } <br>            } <br>        else <br>        if (isdigit( c )) { <br>            *dst++ = c; <br>            Token = MCTOK_NUMBER; <br>            } <br>        else <br>        if (iscsymf( c )) { <br>            *dst++ = c; <br>            Token = MCTOK_NAME; <br>            } <br>        else <br>        if (c == '=') { <br>            *dst++ = c; <br>            *dst = '\0'; <br>            Token = MCTOK_EQUAL; <br>            return( Token ); <br>            } <br>        else <br>        if (c == '(') { <br>            *dst++ = c; <br>            *dst = '\0'; <br>            Token = MCTOK_LEFT_PAREN; <br>            return( Token ); <br>            } <br>        else <br>        if (c == ')') { <br>            *dst++ = c; <br>            *dst = '\0'; <br>            Token = MCTOK_RIGHT_PAREN; <br>            return( Token ); <br>            } <br>        else <br>        if (c == ':') { <br>            *dst++ = c; <br>            *dst = '\0'; <br>            Token = MCTOK_COLON; <br>            return( Token ); <br>            } <br>        else <br>        if (c == '+') { <br>            *dst++ = c; <br>            *dst = '\0'; <br>            Token = MCTOK_PLUS; <br>            return( Token ); <br>            } <br>        else <br>        if (c == ' ') { <br>            } <br>        else <br>        if (c == MCCHAR_END_OF_LINE_COMMENT) { <br>            Token = MCTOK_END_OF_LINE_COMMENT; <br>            strcpy( TokenCharValue, CurrentChar ); <br>            CurrentChar = NULL; <br>            return( Token ); <br>            } <br>        else <br>        if (c == '\0') { <br>            return( Token ); <br>            } <br>        else { <br>            McInputError( "invalid character '%c'", TRUE, (PVOID)(ULONG)(UCHAR)c ); <br>            } <br>        } <br>} <br> <br> <br>void <br>McUnGetToken( void ) <br>{ <br>    ReturnCurrentToken = TRUE; <br>} <br> <br>char * <br>McSkipWhiteSpace( <br>    char *s <br>    ) <br>{ <br>    while (*s &lt;= ' ') { <br>        if (!*s++) { <br>            s = NULL; <br>            break; <br>            } <br>        } <br> <br>    return( s ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
