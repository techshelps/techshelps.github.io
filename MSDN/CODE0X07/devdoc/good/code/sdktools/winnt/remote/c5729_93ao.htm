<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PIPEEX.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5730"></a>PIPEEX.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1995 - 1997 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    pipeex.c <br> <br>Abstract: <br> <br>    CreatePipe-like function that lets one or both handles be overlapped <br> <br>Author: <br> <br>    Dave Hart  Summer 1997 <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>ULONG PipeSerialNumber; <br> <br>BOOL <br>APIENTRY <br>MyCreatePipeEx( <br>    OUT LPHANDLE lpReadPipe, <br>    OUT LPHANDLE lpWritePipe, <br>    IN LPSECURITY_ATTRIBUTES lpPipeAttributes, <br>    IN DWORD nSize, <br>    DWORD dwReadMode, <br>    DWORD dwWriteMode <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    The CreatePipeEx API is used to create an anonymous pipe I/O device. <br>    Unlike CreatePipe FILE_FLAG_OVERLAPPED may be specified for one or <br>    both handles. <br>    Two handles to the device are created.  One handle is opened for <br>    reading and the other is opened for writing.  These handles may be <br>    used in subsequent calls to ReadFile and WriteFile to transmit data <br>    through the pipe. <br> <br>Arguments: <br> <br>    lpReadPipe - Returns a handle to the read side of the pipe.  Data <br>        may be read from the pipe by specifying this handle value in a <br>        subsequent call to ReadFile. <br> <br>    lpWritePipe - Returns a handle to the write side of the pipe.  Data <br>        may be written to the pipe by specifying this handle value in a <br>        subsequent call to WriteFile. <br> <br>    lpPipeAttributes - An optional parameter that may be used to specify <br>        the attributes of the new pipe.  If the parameter is not <br>        specified, then the pipe is created without a security <br>        descriptor, and the resulting handles are not inherited on <br>        process creation.  Otherwise, the optional security attributes <br>        are used on the pipe, and the inherit handles flag effects both <br>        pipe handles. <br> <br>    nSize - Supplies the requested buffer size for the pipe.  This is <br>        only a suggestion and is used by the operating system to <br>        calculate an appropriate buffering mechanism.  A value of zero <br>        indicates that the system is to choose the default buffering <br>        scheme. <br> <br>Return Value: <br> <br>    TRUE - The operation was successful. <br> <br>    FALSE/NULL - The operation failed. Extended error status is available <br>        using GetLastError. <br> <br>--*/ <br> <br>{ <br>    HANDLE ReadPipeHandle, WritePipeHandle; <br>    DWORD dwError; <br>    UCHAR PipeNameBuffer[ MAX_PATH ]; <br> <br>    // <br>    // Only one valid OpenMode flag - FILE_FLAG_OVERLAPPED <br>    // <br> <br>    if ((dwReadMode | dwWriteMode) &amp; (~FILE_FLAG_OVERLAPPED)) { <br>        SetLastError(ERROR_INVALID_PARAMETER); <br>        return FALSE; <br>    } <br> <br>    // <br>    //  Set the default timeout to 120 seconds <br>    // <br> <br>    if (nSize == 0) { <br>        nSize = 4096; <br>        } <br> <br>    sprintf( PipeNameBuffer, <br>             "\\\\.\\Pipe\\RemoteExeAnon.%08x.%08x", <br>             GetCurrentProcessId(), <br>             PipeSerialNumber++ <br>           ); <br> <br>    ReadPipeHandle = CreateNamedPipeA( <br>                         PipeNameBuffer, <br>                         PIPE_ACCESS_INBOUND | dwReadMode, <br>                         PIPE_TYPE_BYTE | PIPE_WAIT, <br>                         1,             // Number of pipes <br>                         nSize,         // Out buffer size <br>                         nSize,         // In buffer size <br>                         120 * 1000,    // Timeout in ms <br>                         lpPipeAttributes <br>                         ); <br> <br>    if (! ReadPipeHandle) { <br>        return FALSE; <br>    } <br> <br>    WritePipeHandle = CreateFileA( <br>                        PipeNameBuffer, <br>                        GENERIC_WRITE, <br>                        0,                         // No sharing <br>                        lpPipeAttributes, <br>                        OPEN_EXISTING, <br>                        FILE_ATTRIBUTE_NORMAL | dwWriteMode, <br>                        NULL                       // Template file <br>                      ); <br> <br>    if (INVALID_HANDLE_VALUE == WritePipeHandle) { <br>        dwError = GetLastError(); <br>        CloseHandle( ReadPipeHandle ); <br>        SetLastError(dwError); <br>        return FALSE; <br>    } <br> <br>    *lpReadPipe = ReadPipeHandle; <br>    *lpWritePipe = WritePipeHandle; <br>    return( TRUE ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
