<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REMOTEDS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5733"></a>REMOTEDS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1995 - 1997 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>// <br>// remoteds.c, a "directory service" for the limited job of <br>// finding remote.exe servers on the same domain/workgroup. <br>// <br>// Dave Hart written summer 1997. <br>// <br>// Copyright 1997 Microsoft Corp. <br>// <br>// <br>// A handy way to use this program is under remote on a single <br>// or a few machines: <br>// <br>//    remote /s remoteds FindRemote <br>// <br>// Clients connect with remote /c machinename FindRemote <br>// <br>// Only remote.exe's running debuggers or with /V+ are visible <br>// via remoteds, as with remote /q. <br>// <br>// Remote clients notify remoteds using mailslots, see srvad.c. <br>// <br>// <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;process.h&gt; <br> <br>typedef char RECEIVEBUF[1024]; <br> <br>typedef struct tagSERVERENTRY { <br>    int     nPID;                   // zero PID means unused slot <br>    union { <br>        FILETIME FileTime; <br>        LARGE_INTEGER liTime; <br>    }; <br>    char   *pszMachine; <br>    char   *pszPipe; <br>    char   *pszChildCmd; <br>} SERVERENTRY; <br> <br>#define TABLE_INITIAL_ALLOC 1 // 128       // beginning table size <br>#define TABLE_ALLOC_DELTA   1 // 16        // grows by this many units <br> <br>HANDLE       hTableHeap; <br>SERVERENTRY *Table; <br>int          nTableSize; <br>int          nTableHiWater;          // highest used slot so far <br>CRITICAL_SECTION csTable; <br> <br>char szPrompt[] = "remote server search&gt; "; <br> <br> <br> <br>unsigned WINAPI     InteractThread(void * UnusedParm); <br>unsigned WINAPI     CleanupThread(void * UnusedParm); <br>VOID     __fastcall UpdateTimeStamp(LPFILETIME lpFileTime); <br>VOID     __fastcall ReallocTable(int nNewTableSize); <br> <br> <br>int <br>main( <br>    int argc, <br>    char **argv <br>    ) <br>{ <br>    char *      pszMailslot = "\\\\.\\MAILSLOT\\REMOTE\\DEBUGGERS"; <br>    HANDLE      hMailslot; <br>    BOOL        b; <br>    HANDLE      hThread; <br>    DWORD       dwTID; <br>    char *      pszMachine; <br>    int         cchMachine; <br>    char *      pszPID; <br>    int         nPID; <br>    char *      pszPipe; <br>    int         cchPipe; <br>    char *      pszChildCmd; <br>    int         i; <br>    int         nFirstAvailable; <br>    BOOL        fStopping; <br>    BOOL        fFound; <br>    int         cb; <br>    char *      pchStrings; <br>    char *      pch; <br>    DWORD       cbRead; <br>    DWORD       iBuf; <br>    DWORD       rgcbBuf[2]; <br>    RECEIVEBUF  rgBuf[2]; <br>    RECEIVEBUF  szBuf; <br>    char        szRemoteCmd[512]; <br> <br>    InitializeCriticalSection(&amp;csTable); <br> <br>    ReallocTable(TABLE_INITIAL_ALLOC); <br> <br>    hMailslot = <br>        CreateMailslot( <br>            pszMailslot, <br>            0, <br>            MAILSLOT_WAIT_FOREVER, <br>            NULL <br>            ); <br> <br>    if (INVALID_HANDLE_VALUE == hMailslot) { <br> <br>        DWORD dwErr = GetLastError(); <br> <br>        if (ERROR_ALREADY_EXISTS == dwErr) { <br>            printf("Cannot receive on %s,\n" <br>                   "is remoteds or rdsrelay already running on this machine?\n", <br>                   pszMailslot); <br>        } else { <br>            printf("CreateMailslot(%s) failed error %d\n", <br>                    pszMailslot, <br>                    dwErr); <br>        } <br>        return 2; <br>    } <br> <br> <br>    hThread = (HANDLE) _beginthreadex( <br>                                      NULL, <br>                                      0, <br>                                      InteractThread, <br>                                      NULL, <br>                                      0, <br>                                      &amp;dwTID <br>                                     ); <br> <br>    if ( ! hThread) { <br>        printf("Can't start InteractThread %d\n", GetLastError()); <br>        return 3; <br>    } <br> <br>    CloseHandle(hThread); <br> <br>    hThread = (HANDLE) _beginthreadex( <br>                                      NULL, <br>                                      0, <br>                                      CleanupThread, <br>                                      NULL, <br>                                      0, <br>                                      &amp;dwTID <br>                                     ); <br> <br> <br>    if ( ! hThread) { <br>        printf("Can't start CleanupThread %d\n", GetLastError()); <br>        return 3; <br>    } <br> <br>    CloseHandle(hThread); <br> <br> <br>    // <br>    // loop reading and processing mailslot messsages <br>    // <br> <br>    iBuf = 0; <br>    ZeroMemory(rgcbBuf, sizeof(rgcbBuf)); <br>    ZeroMemory(rgBuf, sizeof(rgBuf)); <br> <br>    while(TRUE) <br>    { <br>        b = ReadFile( <br>                hMailslot, <br>                rgBuf[ iBuf ], <br>                sizeof(rgBuf[ iBuf ]) - 1,  // so I can null terminate if needed <br>                &amp;rgcbBuf[ iBuf ], <br>                NULL <br>                ); <br> <br>        if ( ! b) { <br>            printf("ReadFile(hMailslot) failed error %d\n", GetLastError()); <br>            return 4; <br>        } <br> <br>        // <br>        // It's the nature of mailslots and multiple transports <br>        // that we'll get the identical message several times in <br>        // quick succession.  Don't waste time searching the table <br>        // for these duplicates. <br>        // <br> <br>        if ( rgcbBuf[0] == rgcbBuf[1] &amp;&amp; <br>             ! memcmp(rgBuf[0], rgBuf[1], rgcbBuf[0])) { <br> <br>            continue;               // duplicate <br>        } <br> <br>        // <br>        // Make a working copy into szBuf/cbRead that we can <br>        // modify so the original buffer is available for <br>        // detecting received duplicates. <br>        // <br> <br>        cbRead = rgcbBuf[ iBuf ]; <br>        CopyMemory(szBuf, rgBuf[ iBuf ], cbRead); <br> <br>        // <br>        // Toggle buffers for the next read. <br>        // <br> <br>        iBuf = !iBuf; <br> <br>        if (szBuf[ cbRead - 1 ]) { <br>            printf("Received string not null terminated.\n"); <br>            szBuf[cbRead] = 0; <br>        } <br> <br>        pszMachine = szBuf; <br> <br>        pch = strchr(szBuf, '\t'); <br> <br>        if (!pch) { <br>            printf("Received string no 1st tab\n"); <br>            continue; <br>        } <br>        *pch = '\0'; <br> <br>        pszPID = ++pch; <br> <br>        pch = strchr(pch, '\t'); <br> <br>        if (!pch) { <br>            printf("Received string no 2nd tab\n"); <br>            continue; <br>        } <br>        *pch = '\0'; <br> <br>        pszPipe = ++pch; <br> <br>        pch = strchr(pch, '\t'); <br> <br>        if (!pch) { <br>            printf("Received string no 3nd tab\n"); <br>            continue; <br>        } <br>        *pch = '\0'; <br> <br>        pszChildCmd = ++pch; <br> <br>        // <br>        // If it ends with ^B it's going away. <br>        // <br> <br>        pch = strchr(pch, '\x2'); <br> <br>        if (pch) { <br>            *pch = 0; <br>            fStopping = TRUE; <br>        } else { <br>            fStopping = FALSE; <br>        } <br> <br> <br>        nPID = strtol(pszPID, NULL, 10); <br>        _strlwr(pszMachine); <br>        _strlwr(pszPipe); <br> <br>        if (fStopping) { <br> <br>            // <br>            // display the ending remote's info <br>            // <br> <br>            sprintf(szRemoteCmd, "remote /c %s %s", pszMachine, pszPipe); <br>            printf("\r%-36s %-20s   [stop]\n%s", szRemoteCmd, pszChildCmd, szPrompt); <br>            fflush(stdout); <br>        } <br> <br>        EnterCriticalSection(&amp;csTable); <br> <br>        nFirstAvailable = -1; <br> <br>        for (i = 0, fFound = FALSE; <br>             i &lt;= nTableHiWater; <br>             i++) { <br> <br>            if (-1 == nFirstAvailable &amp;&amp; 0 == Table[i].nPID) { <br>                nFirstAvailable = i; <br>            } <br> <br>            if (Table[i].nPID == nPID &amp;&amp; <br>                ! strcmp(Table[i].pszMachine, pszMachine) &amp;&amp; <br>                ! strcmp(Table[i].pszPipe, pszPipe)) { <br> <br>                fFound = TRUE; <br>                break; <br>            } <br>        } <br> <br> <br>        if (fFound) { <br> <br>            if (fStopping) { <br> <br>                // <br>                // Remove it from the table <br>                // <br> <br>                free(Table[i].pszMachine); <br>                ZeroMemory(&amp;Table[i], sizeof(Table[i])); <br> <br>                if (nTableHiWater == i) { <br>                    nTableHiWater--; <br>                } <br> <br>            } else { // starting <br> <br>                // printf("Found at slot %d\n", i); <br>                // timestamp is updated below <br>            } <br> <br>        } else if ( ! fStopping) { <br> <br>            // <br>            // we have a new entry, display it <br>            // <br> <br>            sprintf(szRemoteCmd, "remote /c %s %s", pszMachine, pszPipe); <br>            printf("\r%-36s %-20s   [start]\n%s", szRemoteCmd, pszChildCmd, szPrompt); <br>            fflush(stdout); <br> <br>            // <br>            // Does it fit in the table or do we need to grow it? <br>            // <br> <br>            if (-1 == nFirstAvailable) { <br> <br>                if (++nTableHiWater &gt;= nTableSize) { <br>                    ReallocTable(nTableSize + TABLE_ALLOC_DELTA); <br>                } <br> <br>                i = nTableHiWater; <br> <br>            } else { <br> <br>                i = nFirstAvailable; <br>            } <br> <br> <br>            // <br>            // Fill in a server entry in table, if we can <br>            // allocate memory for the strings. <br>            // <br> <br>            cb = (cchMachine  = strlen(pszMachine) + 1) + <br>                 (cchPipe     = strlen(pszPipe) + 1) + <br>                 (              strlen(pszChildCmd) + 1); <br> <br>            pchStrings = malloc(cb); <br> <br>            if (pchStrings) { <br> <br>                Table[i].nPID = nPID; <br>                UpdateTimeStamp(&amp;Table[i].FileTime); <br> <br>                Table[i].pszMachine = pchStrings; <br>                strcpy(Table[i].pszMachine, pszMachine); <br> <br>                Table[i].pszPipe = Table[i].pszMachine + cchMachine; <br>                strcpy(Table[i].pszPipe, pszPipe); <br> <br>                Table[i].pszChildCmd = Table[i].pszPipe + cchPipe; <br>                strcpy(Table[i].pszChildCmd, pszChildCmd); <br>            } <br> <br>        } <br> <br>        UpdateTimeStamp(&amp;Table[i].FileTime); <br> <br>        LeaveCriticalSection(&amp;csTable); <br> <br>    }   // while (TRUE) <br> <br>    return 0;    // never executed <br>} <br> <br> <br>// <br>// InteractThread lets the user query the list of remote servers. <br>// <br> <br>unsigned WINAPI InteractThread(void * UnusedParm) <br>{ <br>    char szQuery[1024]; <br>    char szLowerQuery[1024]; <br>    char szRemoteCmd[400]; <br>    int  i; <br>    BOOL fAll; <br> <br> Help: <br>    printf("Enter a string to search for, a machine or pipe name or command.\n"); <br>    printf("Enter * to list all remote servers.\n"); <br>    printf("Exit with ^B.\n"); <br> <br>    while (TRUE) { <br> <br>        fputs(szPrompt, stdout); <br>        fflush(stdout); <br>        gets(szQuery); <br>        _strlwr( strcpy(szLowerQuery, szQuery) ); <br> <br>        if (!strlen(szLowerQuery) || <br>            !strcmp(szLowerQuery, "?") || <br>            !strcmp(szLowerQuery, "h") || <br>            !strcmp(szLowerQuery, "help")) { <br> <br>            goto Help; <br>        } <br> <br>        if (2 == szLowerQuery[0]) {           // ^B <br> <br>            ExitProcess(0); <br>        } <br> <br>        fAll = ! strcmp(szLowerQuery, "*"); <br> <br>        EnterCriticalSection(&amp;csTable); <br> <br>        for (i = 0; i &lt;= nTableHiWater; i++) { <br>            if (Table[i].nPID) { <br>                if (fAll || <br>                    strstr(Table[i].pszMachine, szLowerQuery) || <br>                    strstr(Table[i].pszPipe, szLowerQuery) || <br>                    strstr(Table[i].pszChildCmd, szLowerQuery)) { <br> <br>                    sprintf(szRemoteCmd, "remote /c %s %s", Table[i].pszMachine, Table[i].pszPipe); <br>                    printf("%-40s %s\n", szRemoteCmd, Table[i].pszChildCmd); <br>                } <br>            } <br>        } <br> <br>        LeaveCriticalSection(&amp;csTable); <br> <br>    } <br> <br>    return 0;    // never executed <br>} <br> <br> <br>// <br>// CleanupThread scavenges for old entries and frees them. <br>// remote /s sends a broadcast at least every 2 hours. <br>// We get some of them.  Age out entries after 12 hours. <br>// <br> <br>unsigned WINAPI CleanupThread(void * UnusedParm) <br>{ <br>    LARGE_INTEGER liNow; <br>    LARGE_INTEGER liTimeout; <br>    int i; <br>    char szRemoteCmd[400]; <br> <br>    liTimeout.QuadPart = (LONGLONG)10000000 * 60 * 60 * 12;  // 12 hours <br> <br>    while (TRUE) { <br> <br>        Sleep(15 * 60 * 1000);    // 10 minutes <br> <br>        UpdateTimeStamp((LPFILETIME)&amp;liNow); <br> <br>        EnterCriticalSection(&amp;csTable); <br> <br>        for (i = nTableHiWater; i &gt;= 0; i--) { <br> <br>            if (Table[i].nPID) { <br> <br>                if (liNow.QuadPart - Table[i].liTime.QuadPart &gt; liTimeout.QuadPart) { <br> <br>                    // <br>                    // display the ending remote's info <br>                    // <br> <br>                    sprintf(szRemoteCmd, "remote /c %s %s", Table[i].pszMachine, Table[i].pszPipe); <br>                    printf("\r%-36s %-20s   [aged out]\n%s", szRemoteCmd, Table[i].pszChildCmd, szPrompt); <br>                    fflush(stdout); <br> <br>                    free(Table[i].pszMachine); <br>                    ZeroMemory(&amp;Table[i], sizeof(Table[i])); <br> <br>                    if (nTableHiWater == i) { <br>                        nTableHiWater--; <br>                    } <br>                } <br> <br>            } <br> <br>        } <br> <br>        LeaveCriticalSection(&amp;csTable); <br>    } <br> <br>    return 0;    // never executed <br>} <br> <br> <br>VOID __fastcall UpdateTimeStamp(LPFILETIME lpFileTime) <br>{ <br>    SYSTEMTIME SystemTime; <br> <br>    GetSystemTime(&amp;SystemTime); <br>    SystemTimeToFileTime(&amp;SystemTime, lpFileTime); <br>} <br> <br> <br>VOID __fastcall ReallocTable(int nNewTableSize) <br>{ <br>    SERVERENTRY *pTableSave = Table; <br> <br>    EnterCriticalSection(&amp;csTable); <br> <br>    nTableSize = nNewTableSize; <br> <br>    if ( ! hTableHeap) { <br> <br>        hTableHeap = HeapCreate( <br>                         HEAP_NO_SERIALIZE, <br>                         (TABLE_INITIAL_ALLOC + 1) * sizeof(Table[0]),  // size <br>                         50000 * sizeof(Table[0])                       // max <br>                         ); <br>        Table = HeapAlloc( <br>                    hTableHeap, <br>                    HEAP_ZERO_MEMORY, <br>                    nTableSize * sizeof(Table[0]) <br>                    ); <br>    } else { <br> <br>        Table = HeapReAlloc( <br>                    hTableHeap, <br>                    HEAP_ZERO_MEMORY, <br>                    Table, <br>                    nTableSize * sizeof(Table[0]) <br>                    ); <br>    } <br> <br>    if (!Table) { <br>        printf("\nremoteds: Out of memory allocating remote server table\n"); <br>        exit(ERROR_NOT_ENOUGH_MEMORY); <br>    } <br> <br> <br>    LeaveCriticalSection(&amp;csTable); <br> <br>    if (Table != pTableSave &amp;&amp; pTableSave) { <br>        printf("\nremoteds:  remote server table moved in HeapRealloc from %x to %x.\n", pTableSave, Table); <br>        fflush(stdout); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
