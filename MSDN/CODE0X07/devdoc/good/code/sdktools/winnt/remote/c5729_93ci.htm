<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SRVQUERY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5742"></a>SRVQUERY.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1995 - 1997 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    SrvQuery.c <br> <br>Abstract: <br> <br>    The server component of Remote.   Respond to client <br>    "remote /q" requests to list available remote servers <br>    on this machine. <br> <br> <br>Author: <br> <br>    Dave Hart  30 May 1997 <br>        derived from code by Mihai Costea in server.c. <br> <br>Environment: <br> <br>    Console App. User mode. <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;process.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;string.h&gt; <br>#include "Remote.h" <br>#include "Server.h" <br> <br> <br>VOID <br>FASTCALL <br>InitializeQueryServer( <br>    VOID <br>    ) <br>{ <br>    // <br>    // hQPipe is the handle to the listening query pipe, <br>    // if we're serving it. <br>    // <br> <br>    hQPipe = INVALID_HANDLE_VALUE; <br> <br>    QueryOverlapped.hEvent = <br>        CreateEvent( <br>            NULL,       // security <br>            TRUE,       // manual-reset <br>            FALSE,      // initially nonsignaled <br>            NULL        // unnamed <br>            ); <br> <br>    rghWait[WAITIDX_QUERYSRV_WAIT] = <br>        CreateMutex( <br>            &amp;saPublic,   // security <br>            FALSE,       // not owner in case we open not create <br>            "MS RemoteSrv Q Mutex" <br>            ); <br> <br>    if (INVALID_HANDLE_VALUE == rghWait[WAITIDX_QUERYSRV_WAIT]) { <br> <br>        ErrorExit("Remote: Unable to create/open query server mutex.\n"); <br>    } <br>} <br> <br> <br>VOID <br>FASTCALL <br>QueryWaitCompleted( <br>    VOID <br>    ) <br>{ <br>    HANDLE hWait; <br>    DWORD dwThreadId; <br>    BOOL b; <br>    DWORD dwRead; <br> <br>    // <br>    // The remote server (not us) which was servicing the query <br>    // pipe has left the arena.  Or someone has connected. <br>    // <br> <br>    hWait = rghWait[WAITIDX_QUERYSRV_WAIT]; <br> <br>    if (hWait == QueryOverlapped.hEvent) { <br> <br>        // <br>        // We're the query server and someone has connected. <br>        // Start a thread to service them. <br>        // <br> <br>        b = GetOverlappedResult(hQPipe, &amp;QueryOverlapped, &amp;dwRead, TRUE); <br> <br> <br>        if ( !b &amp;&amp; ERROR_PIPE_CONNECTED != GetLastError()) { <br> <br>            TRACE(QUERY,("Connect Query Pipe returned %d\n", GetLastError())); <br> <br>            if (INVALID_HANDLE_VALUE != hQPipe) { <br> <br>                CloseHandle(hQPipe); <br>                hQPipe = INVALID_HANDLE_VALUE; <br>            } <br> <br>        } else { <br> <br>            TRACE(QUERY, ("Client connected to query pipe.\n")); <br> <br>            ResetEvent(hWait); <br> <br>            CloseHandle( (HANDLE) <br>                _beginthreadex( <br>                        NULL,             // security <br>                        0,                // default stack size <br>                        QueryHandlerThread, <br>                        (LPVOID) hQPipe,  // parameter <br>                        0,                // not suspended <br>                        &amp;dwThreadId <br>                        )); <br> <br>            hQPipe = INVALID_HANDLE_VALUE; <br>        } <br> <br>    } else { <br> <br>        TRACE(QUERY, ("Remote server entered query mutex, will handle queries.\n")); <br> <br>        rghWait[WAITIDX_QUERYSRV_WAIT] = QueryOverlapped.hEvent; <br>    } <br> <br> <br>    // <br>    // Either a client has connected and we've handed that pipe <br>    // off to a query thread to deal with, or we're just starting <br>    // to serve the query pipe, or we had an error from <br>    // ConnectNamedPipe.  In any case we want to create another <br>    // query pipe instance and start listening on it. <br>    // <br> <br>    ASSERT(INVALID_HANDLE_VALUE == hQPipe); <br> <br>    StartServingQueryPipe(); <br>} <br> <br> <br> <br>VOID <br>FASTCALL <br>StartServingQueryPipe( <br>    VOID <br>    ) <br>{ <br>    BOOL  b; <br>    DWORD dwThreadId; <br>    char  fullname[BUFFSIZE]; <br> <br>    sprintf(fullname, QUERY_DEBUGGERS_PIPE, "."); <br> <br>    do {      // hand off each pipe as connected until IO_PENDING <br>     <br>        hQPipe = <br>            CreateNamedPipe( <br>                fullname, <br>                PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED, <br>                PIPE_TYPE_BYTE | PIPE_WAIT, <br>                PIPE_UNLIMITED_INSTANCES, <br>                0, <br>                0, <br>                0, <br>                &amp;saPublic <br>                ); <br>         <br>        if (INVALID_HANDLE_VALUE == hQPipe) { <br> <br>            ErrorExit("Unable to create query server pipe."); <br>        } <br> <br>        b = ConnectNamedPipe(hQPipe, &amp;QueryOverlapped); <br> <br> <br>        if ( ! b &amp;&amp; ERROR_PIPE_CONNECTED == GetLastError()) { <br> <br>            b = TRUE; <br>        } <br> <br>        if (b) { <br> <br>            // <br>            // That was fast. <br>            // <br> <br>            TRACE(QUERY, ("Client connected quickly to query pipe.\n")); <br> <br>            CloseHandle( (HANDLE) <br>                _beginthreadex( <br>                    NULL,              // security <br>                    0,                 // default stack size <br>                    QueryHandlerThread, <br>                    (LPVOID) hQPipe,   // parameter <br>                    0,                 // not suspended <br>                    &amp;dwThreadId <br>                    )); <br> <br>            hQPipe = INVALID_HANDLE_VALUE; <br> <br> <br>        } else if (ERROR_IO_PENDING == GetLastError()) { <br> <br>            // <br>            // The main thread will call QueryWaitCompleted when <br>            // someone connects. <br>            // <br> <br>            TRACE(QUERY, ("Awaiting query pipe connect\n")); <br> <br>        } else { <br> <br>            sprintf(fullname, "Remote: error %d connecting query pipe.\n", GetLastError()); <br> <br>            OutputDebugString(fullname); <br>            ErrorExit(fullname); <br>        } <br> <br>    } while (b); <br>} <br> <br> <br>DWORD <br>WINAPI <br>QueryHandlerThread( <br>    LPVOID   lpvArg <br>    ) <br>{ <br>    HANDLE hQueryPipe = (HANDLE) lpvArg; <br>    DWORD cb; <br>    BOOL  b; <br>    OVERLAPPED ol; <br>    QUERY_MESSAGE QData; <br>    char  pIn[1]; <br> <br> <br>    ZeroMemory(&amp;ol, sizeof(ol)); <br> <br>    ol.hEvent = <br>        CreateEvent( <br>            NULL,       // security <br>            TRUE,       // manual-reset <br>            FALSE,      // initially nonsignaled <br>            NULL        // unnamed <br>            ); <br> <br> <br>    // get command <br> <br>    b = ReadFileSynch( <br>            hQueryPipe, <br>            pIn, <br>            1, <br>            &amp;cb, <br>            0, <br>            &amp;ol <br>            ); <br> <br>    if ( ! b || 1 != cb ) { <br>        TRACE(QUERY, ("Query server unable to read byte from query pipe.\n")); <br>        goto failure; <br>    } <br> <br>    TRACE(QUERY, ("Query server read command '%c'\n", pIn[0])); <br> <br>        // <br>        // !!!!!! <br>        // REMOVE 'h' support, it's only here for transitional compatibility <br>        // with 1570+ remote /q original server implementation. <br>        // <br> <br>        if(pIn[0] == 'h') { <br> <br>            DWORD dwMinusOne = (DWORD) -1; <br> <br>            b = WriteFileSynch( <br>                    hQueryPipe, <br>                    &amp;dwMinusOne, <br>                    sizeof(dwMinusOne), <br>                    &amp;cb, <br>                    0, <br>                    &amp;ol <br>                    ); <br> <br>            if ( !b || sizeof(dwMinusOne) != cb ) <br>            { <br>                goto failure; <br>            } <br>        } <br> <br>    if(pIn[0] == 'q') { <br> <br>        QData.size  = 0; <br>        QData.allocated = 0; <br>        QData.out   = NULL; <br>                 <br>        EnumWindows(EnumWindowProc, (LPARAM)&amp;QData); <br> <br>        b = WriteFileSynch( <br>                hQueryPipe, <br>                &amp;QData.size, <br>                sizeof(QData.size), <br>                &amp;cb, <br>                0, <br>                &amp;ol <br>                ); <br> <br>        if ( ! b || sizeof(int) != cb) { <br> <br>            TRACE(QUERY, ("Remote: Can't write query length\n")); <br>            goto failure; <br>        } <br>         <br>        if (QData.size) {         // anything to say? <br> <br>            b = WriteFileSynch( <br>                     hQueryPipe, <br>                     QData.out, <br>                     QData.size * sizeof(char), <br>                     &amp;cb, <br>                     0, <br>                     &amp;ol <br>                     ); <br> <br>            free(QData.out); <br> <br>            if ( ! b || QData.size * sizeof(char) != cb) { <br> <br>                TRACE(QUERY, ("Remote: Can't write query")); <br>                goto failure; <br>            } <br> <br> <br>            TRACE(QUERY, ("Sent query response\n")); <br>        } <br>    } <br>             <br>    FlushFileBuffers(hQueryPipe); <br> <br>  failure: <br>    DisconnectNamedPipe(hQueryPipe); <br>    CloseHandle(hQueryPipe); <br>    CloseHandle(ol.hEvent); <br> <br>    return 0; <br>} <br> <br> <br> <br> <br> <br> <br>BOOL <br>CALLBACK <br>EnumWindowProc( <br>    HWND hWnd, <br>    LPARAM lParam <br>    ) <br>{ <br>    #define MAX_TITLELEN 200 <br>    QUERY_MESSAGE *pQm; <br>    int titleLen; <br>    char title[MAX_TITLELEN]; <br>    char* tmp; <br> <br>    pQm = (QUERY_MESSAGE*)lParam; <br> <br>    if(titleLen = GetWindowText(hWnd, title, sizeof(title)/sizeof(title[0]))) <br>    { <br>        // <br>        // search for all windows that are visible  <br>        // <br> <br>        if (strstr(title, "] visible") &amp;&amp; <br>            strstr(title, "[Remote ")) <br>        { <br>            if(pQm-&gt;size)                           // if message not empty <br>                pQm-&gt;out[(pQm-&gt;size)++] = '\n';     // overwrite ending null with \n <br>            else <br>            {                                        <br>                pQm-&gt;out  = (char*)malloc(MAX_TITLELEN);     // first allocation <br>                if(!pQm-&gt;out) <br>                { <br>                    printf("\nOut of memory\n"); <br>                    return FALSE; <br>                } <br>                pQm-&gt;allocated = MAX_TITLELEN;                                <br>            } <br> <br>            // fill the result <br>             <br>            if((pQm-&gt;size + titleLen) &gt;= pQm-&gt;allocated) <br>            {    <br>                tmp = (char*)realloc(pQm-&gt;out, pQm-&gt;allocated + MAX_TITLELEN); <br>                if(!tmp) <br>                { <br>                    printf("\nOut of memory\n"); <br>                    free(pQm-&gt;out); <br>                    pQm-&gt;size = 0;                     <br>                    return FALSE; <br>                } <br>                pQm-&gt;out = tmp;             <br>                pQm-&gt;allocated += MAX_TITLELEN; <br>            } <br>            strcpy(pQm-&gt;out + pQm-&gt;size, title); <br>            pQm-&gt;size += titleLen;                 <br>        } <br>    } <br>     <br>    return TRUE; <br>    #undef MAX_TITLELEN <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
