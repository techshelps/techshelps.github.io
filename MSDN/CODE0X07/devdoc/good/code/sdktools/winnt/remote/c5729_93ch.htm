<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SRVMAIN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5741"></a>SRVMAIN.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1995 - 1997 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    SrvMain.c <br> <br>Abstract: <br> <br>    The server component of Remote. It spawns a child process <br>    and redirects the stdin/stdout/stderr of child to itself. <br>    Waits for connections from clients - passing the <br>    output of child process to client and the input from clients <br>    to child process. <br> <br>    This version uses overlapped I/O to do in one thread what <br>    the original uses 9 for.  Almost.  Because there is no way to <br>    get overlapped stdin/stdout handles, two threads sit around <br>    doing blocking I/O on stdin and stdout.  3 is better than 9. <br> <br>    Unfortunately there's no CreatePipe() <br>    or equivalent option to open an overlapped handle to an anonymous <br>    pipe, so I stole the source for NT CreatePipe and hacked it to <br>    accept flags indicating overlapped for one or both ends of the <br>    anonymous pipe.  In our usage the child end handles are not <br>    overlapped but the server end handles are. <br> <br> <br>Author: <br> <br>    Dave Hart  30 May 1997 after Server.c by <br>    Rajivendra Nath  2-Jan-1992 <br> <br>Environment: <br> <br>    Console App. User mode. <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;process.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;string.h&gt; <br>#if DBG <br>    #undef NDEBUG           // so asserts work on chk builds <br>#endif <br>#include "Remote.h" <br>#define SERVER_H_NOEXTERN <br>#include "Server.h" <br> <br> <br>DWORD cbRemoteClient = sizeof(REMOTE_CLIENT);  // for debugging <br> <br> <br> <br>/*************************************************************/ <br>int <br>OverlappedServer(                    //Main routine for server. <br>    char* pszChildCmd, <br>    char* pszPipeNameArg <br>    ) <br>{ <br>    int    i; <br>    BOOL   b; <br>    DWORD  cWait; <br>    DWORD  dwWait; <br>    PREMOTE_CLIENT pClientRemove; <br> <br>#if DBG <br>    // Trace = -1;   // all TR_ bits on (and then some) <br>#endif <br> <br>    // <br>    // Initialize globals <br>    // <br> <br>    pszPipeName = pszPipeNameArg; <br> <br>    dwNextClientID = 1;           // local client will be 1 <br>    cConnectIns = CONNECT_COUNT; <br>    cWait = MAX_WAIT_HANDLES; <br> <br>    hHeap = HeapCreate( <br>                0, <br>                3 * sizeof(REMOTE_CLIENT),    // initial size <br>                3000 * sizeof(REMOTE_CLIENT)  // max <br>                ); <br> <br>    OsVersionInfo.dwOSVersionInfoSize = sizeof OsVersionInfo; <br>    b = GetVersionEx(&amp;OsVersionInfo); <br>    ASSERT( b ); <br> <br>    printf("**************************************\n"); <br>    printf("***********     REMOTE    ************\n"); <br>    printf("***********     SERVER    ************\n"); <br>    printf("**************************************\n"); <br>    fflush(stdout); <br> <br> <br>    // <br>    // Setup the ACLs we need, taking into account any /u switches <br>    // <br> <br>    SetupSecurityDescriptors(); <br> <br> <br>    printf("To Connect: Remote /C %s %s\n\n", HostName, pszPipeName); <br>    fflush(stdout); <br> <br> <br>    // <br>    // runtime link to NT-only kernel32 APIs so we can <br>    // load on Win95 for client use. <br>    // <br> <br>    RuntimeLinkAPIs(); <br> <br> <br>    // <br>    // Setup our three lists of clients:  handshaking, <br>    // connected, and closing/closed. <br>    // <br> <br>    InitializeClientLists(); <br> <br> <br>    // <br>    // set _REMOTE environment variable to the pipe name (why?) <br>    // <br> <br>    SetEnvironmentVariable("_REMOTE", pszPipeName); <br> <br> <br>    // <br>    // Create a tempfile for storing Child process output. <br>    // <br> <br>    { <br>        char szTempDirectory[MAX_PATH + 1]; <br> <br>        GetTempPath(sizeof(szTempDirectory), szTempDirectory); <br> <br>        // <br>        // Before we litter the temp directory with more REMnnn.TMP <br>        // files, let's delete all the orphaned ones we can.  This <br>        // will fail for temp files open by other remote servers. <br>        // <br> <br>        CleanupTempFiles(szTempDirectory); <br> <br>        GetTempFileName(szTempDirectory, "REM", 0, SaveFileName); <br>    } <br> <br>    if ( ! (hWriteTempFile = <br>            CreateFile( <br>                SaveFileName,                       /* name of the file  */ <br>                GENERIC_READ | GENERIC_WRITE,       /* access (read/write) mode */ <br>                FILE_SHARE_READ | FILE_SHARE_WRITE, /* share mode   */ <br>                NULL,                               /* security descriptor  */ <br>                CREATE_ALWAYS,                      /* how to create    */ <br>                FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, <br>                NULL <br>                ))) { <br> <br>        ErrorExit("Could not Create Temp File"); <br>    } <br> <br> <br>    // <br>    // We don't want to have multiple IN pipes created and <br>    // awaiting connection simultaneously if there are <br>    // multiple remote server processes sharing different <br>    // sessions under the same pipe name.  This would be <br>    // hairy for several reasons including breaking the <br>    // current round-robin behavior of connections, since <br>    // the oldest server pipe is connected first.  So <br>    // we create/open a named event based on the pipe name and <br>    // set the event so that any other remote servers on the <br>    // same pipe will fall back to a single IN pipe listening. <br>    // <br> <br>    { <br>        char szPerPipeEventName[1024]; <br> <br>        sprintf( <br>            szPerPipeEventName, <br>            "MSRemoteSrv%s", <br>            pszPipeName <br>            ); <br> <br>        rghWait[WAITIDX_PER_PIPE_EVENT] = <br>            CreateEvent( <br>                    &amp;saPublic,  // security <br>                    TRUE,       // manual reset (synchronization) <br>                    FALSE,      // initially nonsignaled <br>                    szPerPipeEventName <br>                    ); <br> <br>        if (! rghWait[WAITIDX_PER_PIPE_EVENT]) { <br> <br>            ErrorExit("Unable to create per-pipe event."); <br>        } <br> <br>        if (ERROR_ALREADY_EXISTS == GetLastError()) { <br> <br>            TRACE(CONNECT, ("Found previous server on '%s', using 1 listening pipe.\n", pszPipeName)); <br> <br>            SetEvent(rghWait[WAITIDX_PER_PIPE_EVENT]); <br> <br>            for (i = 1; i &lt; (int) cConnectIns; i++) { <br> <br>                rghPipeIn[i] = INVALID_HANDLE_VALUE; <br>            } <br> <br>            cWait = MAX_WAIT_HANDLES - cConnectIns + 1; <br>            cConnectIns = 1; <br> <br>            // <br>            // We don't want to wait on the event handle, but it's easier <br>            // to have a handle in its slot, so dupe a handle to our own <br>            // process.  Note we toss the value of the created event handle <br>            // without closing it -- we want it to stay around but we're <br>            // done with it. <br>            // <br> <br>            DuplicateHandle( <br>                GetCurrentProcess(), <br>                GetCurrentProcess(), <br>                GetCurrentProcess(), <br>                &amp;rghWait[WAITIDX_PER_PIPE_EVENT], <br>                0, <br>                FALSE, <br>                DUPLICATE_SAME_ACCESS <br>                ); <br> <br>        } <br>    } <br> <br> <br>    // <br>    // Create the event for the OVERLAPPED structure <br>    // used by the main server thread for WriteFileSynch calls. <br>    // <br> <br>    olMainThread.hEvent = <br>        CreateEvent( <br>            NULL,      // security <br>            TRUE,      // auto-reset <br>            FALSE,     // initially nonsignaled <br>            NULL       // unnamed <br>            ); <br> <br> <br>    // <br>    // Create the events for the OVERLAPPED structures <br>    // used for ConnectNamedPipe operations. <br>    // <br> <br>    olConnectOut.hEvent = <br>        rghWait[WAITIDX_CONNECT_OUT] = <br>            CreateEvent( <br>                NULL,    // security <br>                TRUE,    // manual reset as ConnectNamedPipe demands <br>                FALSE,   // initially nonsignaled <br>                NULL <br>                ); <br> <br>    for (i = 0; <br>         i &lt; (int) cConnectIns; <br>         i++) { <br> <br>        rgolConnectIn[i].hEvent = <br>            rghWait[WAITIDX_CONNECT_IN_BASE + i] = <br>                CreateEvent( <br>                    NULL,    // security <br>                    TRUE,    // manual reset as ConnectNamedPipe demands <br>                    FALSE,   // initially nonsignaled <br>                    NULL <br>                    ); <br> <br>    } <br> <br> <br>    // <br>    // Create a timer we'll use to detect 2-pipe clients connected to <br>    // OUT without ever connecting to IN so we can recycle our single <br>    // OUT instance and allow other two-pipe clients in again. <br>    // NT 3.51 doesn't have waitable timers, so we don't do that <br>    // error handling on that OS.  Same as old remote.exe. <br>    // <br> <br>    if (pfnCreateWaitableTimer) { <br>        hConnectOutTimer = <br>            pfnCreateWaitableTimer( <br>                NULL,               // security <br>                FALSE,              // bManualReset, we want auto-reset <br>                NULL                // unnamed <br>                ); <br>    } else { <br>        hConnectOutTimer = INVALID_HANDLE_VALUE; <br>    } <br> <br> <br>    // <br>    // Start the command as a child process <br>    // <br> <br>    if (hAttachedProcess != INVALID_HANDLE_VALUE) { <br> <br>        ChldProc = hAttachedProcess; <br>        hWriteChildStdIn = hAttachedWriteChildStdIn; <br>        hReadChildOutput = hAttachedReadChildStdOut; <br> <br>    } else { <br> <br>        ChldProc = <br>             ForkChildProcess( <br>                 ChildCmd, <br>                 &amp;hWriteChildStdIn, <br>                 &amp;hReadChildOutput <br>                 ); <br>    } <br> <br>    rghWait[WAITIDX_CHILD_PROCESS] = ChldProc; <br> <br>    // <br>    // Set ^c/^break handler.  It will kill the child process on <br>    // ^break and pass ^c through to it. <br>    // <br> <br>    SetConsoleCtrlHandler(SrvCtrlHand, TRUE); <br> <br> <br>    // <br>    // Setup local session and start first read against its input. <br>    // This starts a chain of completion routines that continues <br>    // until this server exits. <br>    // <br> <br>    StartLocalSession(); <br> <br> <br>    // <br>    // Start a read operation on the child output pipe. <br>    // This starts a chain of completion routines that continues <br>    // until the child terminates. <br>    // <br> <br>    StartChildOutPipeRead(); <br> <br> <br>    // <br>    // Start several async ConnectNamedPipe operations, to reduce the chance <br>    // of a client getting pipe busy errors.  Since there is no <br>    // completion port version of ConnectNamedPipe, we'll wait on the <br>    // events in the main loop below that indicate completion. <br>    // <br> <br>    CreatePipeAndIssueConnect(OUT_PIPE); <br> <br>    for (i = 0; <br>         i &lt; (int) cConnectIns; <br>         i++) { <br> <br>        CreatePipeAndIssueConnect(i); <br>    } <br> <br> <br>    InitAd(IsAdvertise); <br> <br> <br>    // <br>    // We may need to service the query pipe for remote /q clients. <br>    // <br> <br>    InitializeQueryServer(); <br> <br> <br>    // <br>    // main loop of thread, waits for ConnectNamedPipe completions <br>    // and handles them while remaining alertable for completion <br>    // routines to get called. <br>    // <br> <br>    while (1) { <br> <br>        dwWait = <br>            WaitForMultipleObjectsEx( <br>                cWait, <br>                rghWait, <br>                FALSE,          // wait on any handle, not all <br>                30 * 1000,      // ms <br>                TRUE            // alertable (completion routines) <br>                ); <br> <br> <br>        if (WAIT_IO_COMPLETION == dwWait) { <br> <br>            // <br>            // A completion routine was called. <br>            // <br> <br>            continue; <br>        } <br> <br> <br>        if (WAIT_TIMEOUT == dwWait) { <br> <br>            // <br>            // Presumably since we've timed out for 30 seconds <br>            // with no IO completion, closing clients have <br>            // finished any pending IOs and the memory can be <br>            // released. <br>            // <br> <br>            while (pClientRemove = RemoveFirstClientFromClosingList()) { <br> <br>                HeapFree(hHeap, 0, pClientRemove); <br>            } <br> <br>            continue; <br>        } <br> <br> <br>        if (WAITIDX_CONNECT_OUT == dwWait) { <br> <br>            HandleOutPipeConnected(); <br>            continue; <br>        } <br> <br> <br>        if (WAITIDX_CONNECT_IN_BASE &lt;= dwWait &amp;&amp; <br>            (WAITIDX_CONNECT_IN_BASE + CONNECT_COUNT) &gt; dwWait) { <br> <br>            HandleInPipeConnected( dwWait - WAITIDX_CONNECT_IN_BASE ); <br>            continue; <br>        } <br> <br> <br>        if (WAITIDX_QUERYSRV_WAIT == dwWait || <br>            WAITIDX_QUERYSRV_WAIT + WAIT_ABANDONED_0 == dwWait ) { <br> <br>            // <br>            // The remote server which was handling the query pipe <br>            // has gone away.  We'll try to take over. <br>            // <br> <br>            QueryWaitCompleted(); <br> <br>            continue; <br>        } <br> <br> <br>        if (WAITIDX_PER_PIPE_EVENT == dwWait) { <br> <br>            // <br>            // Another server is starting on this same <br>            // pipename.  To be most compatible we need <br>            // to fall back to listening on only one <br>            // IN pipe instance. <br>            // <br> <br>            if (1 != cConnectIns) { <br> <br>                TRACE(CONNECT, <br>                      ("Another server starting on '%s', falling back to 1 IN listening pipe.\n", <br>                       pszPipeName <br>                       )); <br> <br>                for (i = 1; i &lt; (int) cConnectIns; i++) { <br> <br>                    CANCELIO( rghPipeIn[i] ); <br>                    DisconnectNamedPipe( rghPipeIn[i] ); <br>                    CloseHandle( rghPipeIn[i] ); <br>                    rghPipeIn[i] = INVALID_HANDLE_VALUE; <br> <br>                } <br> <br>                cWait = MAX_WAIT_HANDLES - cConnectIns + 1; <br> <br>                cConnectIns = 1; <br> <br>                // <br>                // We don't want to wait on the event handle, but it's easier <br>                // to have a handle in its slot, so dupe a handle to our own <br>                // process.  We toss the event handle without closing it so <br>                // it will stay around for future remote servers on the same <br>                // pipe name. <br>                // <br> <br>                DuplicateHandle( <br>                    GetCurrentProcess(), <br>                    GetCurrentProcess(), <br>                    GetCurrentProcess(), <br>                    &amp;rghWait[WAITIDX_PER_PIPE_EVENT], <br>                    0, <br>                    FALSE, <br>                    DUPLICATE_SAME_ACCESS <br>                    ); <br>            } <br> <br>            continue; <br>        } <br> <br>        if (WAITIDX_CHILD_PROCESS == dwWait || <br>            WAITIDX_READ_STDIN_DONE == dwWait) { <br> <br>            if (INVALID_HANDLE_VALUE != hConnectOutTimer) { <br> <br>                CloseHandle(hConnectOutTimer); <br>                hConnectOutTimer = INVALID_HANDLE_VALUE; <br>            } <br> <br>            // <br>            // Cancel ConnectNamedPipe operations and close <br>            // the pipes <br>            // <br> <br>            if (INVALID_HANDLE_VALUE != hPipeOut) { <br> <br>                DisconnectNamedPipe( hPipeOut ); <br>                CANCELIO( hPipeOut ); <br>                CloseHandle( rghWait[WAITIDX_CONNECT_OUT] ); <br>                rghWait[WAITIDX_CONNECT_OUT] = INVALID_HANDLE_VALUE; <br>            } <br> <br>            for (i = 0; <br>                 i &lt; (int) cConnectIns; <br>                 i++) { <br> <br>                if (INVALID_HANDLE_VALUE != rghPipeIn[i]) { <br> <br>                    TRACE(CONNECT, ("Tearing down listening IN pipe #%d.\n", i + 1)); <br> <br>                    DisconnectNamedPipe( rghPipeIn[i] ); <br>                    CANCELIO( rghPipeIn[i] ); <br>                    CloseHandle( rghPipeIn[i] ); <br>                    rghPipeIn[i] = INVALID_HANDLE_VALUE; <br>                } <br> <br>            } <br> <br>            // <br>            // Cancel read against child process in/out pipes <br>            // <br> <br>            if (INVALID_HANDLE_VALUE != hWriteChildStdIn) { <br> <br>                CANCELIO( hWriteChildStdIn ); <br>                CloseHandle( hWriteChildStdIn ); <br>                hWriteChildStdIn = INVALID_HANDLE_VALUE; <br>            } <br> <br>            if (INVALID_HANDLE_VALUE != hReadChildOutput) { <br> <br>                CANCELIO( hReadChildOutput ); <br>                CloseHandle( hReadChildOutput ); <br>                hReadChildOutput = INVALID_HANDLE_VALUE; <br>            } <br> <br>            // <br>            // Cancel client I/Os <br>            // <br> <br>            bShuttingDownServer = TRUE; <br> <br>            // <br>            // Note that CloseClient will remove entries from this list, <br>            // so we walk it starting at the head at each step. <br>            // <br> <br>            for (pClientRemove = (PREMOTE_CLIENT) ClientListHead.Flink; <br>                 pClientRemove != (PREMOTE_CLIENT) &amp;ClientListHead; <br>                 pClientRemove = (PREMOTE_CLIENT)  ClientListHead.Flink ) { <br> <br>                CloseClient(pClientRemove); <br>            } <br> <br>            // <br>            // on our way out... <br>            // <br> <br>            break; <br>        } <br> <br>        // <br>        // Unexpected WaitForMulipleObjectsEx return <br>        // <br> <br>        printf("Remote: unknown wait return %d\n", dwWait); <br>        ErrorExit("fix srvmain.c"); <br> <br>    } // endless loop <br> <br> <br>    ShutAd(IsAdvertise); <br> <br>    while (i = 0, GetExitCodeProcess(ChldProc, &amp;i) &amp;&amp; <br>           STILL_ACTIVE == i) { <br> <br>        printf("\nRemote: Waiting for child to exit.\n"); <br>        WaitForSingleObjectEx(ChldProc, 10 * 1000, TRUE); <br>    } <br> <br>    // <br>    // For some interesting reason when we're attached to <br>    // a debugger like ntsd and it exits, our printf <br>    // below comes out *after* the cmd.exe prompt, making <br>    // it look like we hung on exit even though cmd.exe is <br>    // patiently awaiting a command.  So suppress it. <br>    // <br> <br>    if (hAttachedProcess == INVALID_HANDLE_VALUE) { <br>        printf("\nRemote exiting. Child (%s) exit code was %d.\n", ChildCmd, i); <br>    } <br> <br>    CANCELIO(hWriteTempFile); <br>    CloseHandle(hWriteTempFile); <br>    hWriteTempFile = INVALID_HANDLE_VALUE; <br> <br>    // <br>    // Flush any pending completion routines. <br>    // <br> <br>    while (WAIT_IO_COMPLETION == SleepEx(50, TRUE)) { <br>        ; <br>    } <br> <br>    if (!DeleteFile(SaveFileName)) { <br> <br>        printf("Remote: Temp File %s not deleted..\n",SaveFileName); <br>    } <br> <br>    return i; <br>} <br> <br> <br> <br>VOID <br>FASTCALL <br>StartLocalSession( <br>    VOID <br>    ) <br>{ <br>    DWORD dwThreadId; <br>    char szHexAsciiId[9]; <br> <br>    pLocalClient = HeapAlloc( <br>                       hHeap, <br>                       HEAP_ZERO_MEMORY, <br>                       sizeof(*pLocalClient) <br>                       ); <br> <br>    if (!pLocalClient) { <br> <br>        SetLastError(ERROR_NOT_ENOUGH_MEMORY); <br>        ErrorExit("Unable to allocate local client."); <br>    } <br> <br>    pLocalClient-&gt;dwID = dwNextClientID++; <br>    sprintf(szHexAsciiId, "%08x", pLocalClient-&gt;dwID); <br>    CopyMemory(pLocalClient-&gt;HexAsciiId, szHexAsciiId, sizeof(pLocalClient-&gt;HexAsciiId)); <br> <br>    strcpy(pLocalClient-&gt;Name, "Local"); <br>    pLocalClient-&gt;ServerFlags = SFLG_LOCAL; <br> <br> <br>    // <br>    // we need overlapped handles to stdin/stdout, <br>    // and woefully DuplicateHandle can't do it. <br>    // So we'll create two anonymous pipes and two <br>    // threads to shuffle data between stdin/stdout <br>    // and the pipes.  The server end of the pipes <br>    // is opened overlapped, the "client" end (used <br>    // by the threads) is not overlapped. <br>    // <br> <br> <br>    rgCopyPipe[0].hRead = GetStdHandle(STD_INPUT_HANDLE); <br>    if ( ! MyCreatePipeEx(&amp;pLocalClient-&gt;PipeReadH, &amp;rgCopyPipe[0].hWrite, NULL, 0, FILE_FLAG_OVERLAPPED, 0)) { <br>        ErrorExit("Cannot create local input pipe"); <br>    } <br> <br>    rgCopyPipe[1].hWrite = GetStdHandle(STD_OUTPUT_HANDLE); <br>    if ( ! MyCreatePipeEx(&amp;rgCopyPipe[1].hRead, &amp;pLocalClient-&gt;PipeWriteH, NULL, 0, 0, FILE_FLAG_OVERLAPPED)) { <br>        ErrorExit("Cannot create local output pipe"); <br>    } <br> <br>    rghWait[WAITIDX_READ_STDIN_DONE] = (HANDLE) <br>        _beginthreadex( <br>            NULL,                    // security <br>            0,                       // default stack size <br>            CopyPipeToPipe,          // proc <br>            (LPVOID) &amp;rgCopyPipe[0], // parm <br>            0,                       // flags <br>            &amp;dwThreadId <br>            ); <br> <br>    CloseHandle( (HANDLE) <br>        _beginthreadex( <br>            NULL,                    // security <br>            0,                       // default stack size <br>            CopyPipeToPipe,          // proc <br>            (LPVOID) &amp;rgCopyPipe[1], // parm <br>            0,                       // flags <br>            &amp;dwThreadId <br>            ) <br>        ); <br> <br> <br>    StartSession( pLocalClient ); <br>} <br> <br> <br>// <br>// Two of these threads to deal with non-overlapped stdin/stdout. <br>// CRT is OK. <br>// <br> <br>DWORD <br>WINAPI <br>CopyPipeToPipe( <br>    LPVOID   lpCopyPipeData <br>    ) <br>{ <br>    PCOPYPIPE psd = (PCOPYPIPE) lpCopyPipeData; <br>    DWORD cb; <br>    char achBuffer[BUFFSIZE]; <br> <br>    while (1) { <br>        if ( ! ReadFile( <br>                   psd-&gt;hRead, <br>                   achBuffer, <br>                   sizeof(achBuffer), <br>                   &amp;cb, <br>                   NULL <br>                   )) { <br> <br>            TRACE(COPYPIPE, ("CopyPipeToPipe ReadFile %s failed, exiting thread.\n", <br>                             (psd == &amp;rgCopyPipe[0]) <br>                                 ? "stdin" <br>                                 : "local client output pipe")); <br>            break; <br>        } <br> <br>        if ( ! WriteFile( <br>                   psd-&gt;hWrite, <br>                   achBuffer, <br>                   cb, <br>                   &amp;cb, <br>                   NULL <br>                   )) { <br> <br>            TRACE(COPYPIPE, ("CopyPipeToPipe WriteFile %s failed, exiting thread.\n", <br>                             (psd == &amp;rgCopyPipe[0]) <br>                                 ? "local client input pipe" <br>                                 : "stdout")); <br>            break; <br>        } <br>    } <br> <br>    return 0; <br>} <br> <br> <br>VOID <br>FASTCALL <br>StartSession( <br>    PREMOTE_CLIENT pClient <br>    ) <br>{ <br>    pClient-&gt;rSaveFile = <br>        CreateFile( <br>            SaveFileName, <br>            GENERIC_READ, <br>            FILE_SHARE_READ | FILE_SHARE_WRITE, <br>            NULL, <br>            OPEN_EXISTING, <br>            FILE_FLAG_OVERLAPPED, <br>            NULL <br>            ); <br> <br>    if ( ! pClient-&gt;rSaveFile) { <br> <br>        printf("Remote:Cannot open ReadHandle to temp file:%d\n",GetLastError()); <br> <br>    } else { <br> <br>        pClient-&gt;UserName[0] = 0; <br> <br>        GetNamedPipeHandleState( <br>            pClient-&gt;PipeReadH, <br>            NULL, <br>            NULL, <br>            NULL, <br>            NULL, <br>            pClient-&gt;UserName, <br>            sizeof(pClient-&gt;UserName) <br>            ); <br> <br>        // <br>        // For every client except the local <br>        // stdin/stdout client, there's a copy of remote.exe <br>        // running in client mode on the other side.  Do <br>        // handshaking with it to setup options and check <br>        // versions.  HandshakeWithRemoteClient will start <br>        // the "normal" I/O cycle once the handshake cycle is <br>        // done.  Note it returns as soon as the first handshake <br>        // I/O is submitted. <br>        // <br> <br>        if (pClient-&gt;ServerFlags &amp; SFLG_LOCAL) { <br> <br>            AddClientToHandshakingList(pClient); <br>            MoveClientToNormalList(pClient); <br> <br>            // <br>            // Start read operation against this client's input. <br>            // <br> <br>            StartReadClientInput(pClient); <br> <br>            // <br>            // Start write cycle for client output from the temp <br>            // file. <br>            // <br> <br>            StartReadTempFile(pClient); <br> <br>        } else { <br> <br>            HandshakeWithRemoteClient(pClient); <br>        } <br>    } <br>} <br> <br> <br> <br> <br>VOID <br>FASTCALL <br>CreatePipeAndIssueConnect( <br>    int  nIndex   // IN pipe index or OUT_PIPE <br>    ) <br>{ <br>    BOOL b; <br>    DWORD dwError; <br>    char szPipeName[BUFFSIZE]; <br> <br> <br>    if (OUT_PIPE == nIndex) { <br>        TRACE(CONNECT, ("Creating listening OUT pipe.\n")); <br>    } else { <br>        TRACE(CONNECT, ("Creating listening IN pipe #%d.\n", nIndex + 1)); <br>    } <br> <br>    if (OUT_PIPE == nIndex) { <br> <br>        sprintf(szPipeName, SERVER_WRITE_PIPE, ".", pszPipeName); <br> <br>        hPipeOut = <br>            CreateNamedPipe( <br>                szPipeName, <br>                PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED, <br>                PIPE_TYPE_BYTE, <br>                PIPE_UNLIMITED_INSTANCES, <br>                0, <br>                0, <br>                0, <br>                &amp;saPipe <br>                ); <br> <br>        if (INVALID_HANDLE_VALUE == hPipeOut) { <br> <br>            ErrorExit("Unable to CreateNamedPipe OUT"); <br>        } <br> <br>        b = ConnectNamedPipe(hPipeOut, &amp;olConnectOut); <br> <br> <br>        if ( ! b ) { <br> <br>            dwError = GetLastError(); <br> <br>            if (ERROR_PIPE_CONNECTED == dwError) { <br> <br>                b = TRUE; <br>            } <br>        } <br> <br>        if ( b ) { <br> <br>            TRACE(CONNECT, ("Quick connect on OUT pipe.\n")); <br> <br>            HandleOutPipeConnected(); <br> <br>        } else { <br> <br>            if (ERROR_IO_PENDING != dwError) { <br> <br>                ErrorExit("ConnectNamedPipe out failed"); <br>            } <br>        } <br> <br>    } else { <br> <br>        sprintf(szPipeName, SERVER_READ_PIPE, ".", pszPipeName); <br> <br>        rghPipeIn[nIndex] = <br>            CreateNamedPipe( <br>                szPipeName, <br>                PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED, <br>                PIPE_TYPE_BYTE, <br>                PIPE_UNLIMITED_INSTANCES, <br>                0, <br>                0, <br>                0, <br>                &amp;saPipe <br>                ); <br> <br>        if (INVALID_HANDLE_VALUE == rghPipeIn[nIndex]) { <br> <br>            if (ERROR_ACCESS_DENIED == GetLastError()) { <br>                if (DaclNameCount) { <br>                    ErrorExit("Unable to CreateNamedPipe, are YOU in the list of permitted users?"); <br>                } else { <br>                    ErrorExit("Unable to CreateNamedPipe, maybe old remote server on same pipe name?"); <br>                } <br>            } else { <br>                ErrorExit("Unable to CreateNamedPipe IN"); <br>            } <br>        } <br> <br>        b = ConnectNamedPipe(rghPipeIn[nIndex], &amp;rgolConnectIn[nIndex]); <br> <br>        if ( ! b ) { <br> <br>            dwError = GetLastError(); <br> <br>            if (ERROR_PIPE_CONNECTED == dwError) { <br>                b = TRUE; <br>            } <br>        } <br> <br>        if ( b ) { <br> <br>            TRACE(CONNECT, ("Quick connect on IN pipe #%d.\n", nIndex)); <br> <br>            HandleInPipeConnected(nIndex); <br> <br>        } else { <br> <br>            if (ERROR_IO_PENDING != dwError) { <br> <br>                ErrorExit("ConnectNamedPipe in failed"); <br>            } <br>        } <br> <br>    } <br> <br>    if (OUT_PIPE == nIndex) { <br>        TRACE(CONNECT, ("Listening OUT pipe handle %x.\n", hPipeOut)); <br>    } else { <br>        TRACE(CONNECT, ("Listening IN pipe #%d handle %x.\n", nIndex + 1, rghPipeIn[nIndex])); <br>    } <br>} <br> <br> <br>VOID <br>FASTCALL <br>HandleOutPipeConnected( <br>    VOID <br>    ) <br>{ <br>    LARGE_INTEGER DueTime; <br> <br>    ResetEvent(rghWait[WAITIDX_CONNECT_OUT]); <br> <br>    bOutPipeConnected = TRUE; <br> <br>    TRACE(CONNECT, ("Two-pipe caller connected to OUT pipe %x.\n", <br>                    hPipeOut)); <br> <br>    // <br>    // Start a 1 minute timer in case we don't get a connection <br>    // on an IN pipe from this client, we'll recycle the OUT <br>    // pipe. <br>    // <br> <br>    if (INVALID_HANDLE_VALUE != hConnectOutTimer) { <br> <br>        DueTime.QuadPart = Int32x32To64(60 * 1000, -10000); <br> <br>        pfnSetWaitableTimer( <br>            hConnectOutTimer, <br>            &amp;DueTime, <br>            0,                     // not periodic, single-fire <br>            ConnectOutTimerFired, <br>            0,                     // arg to compl. rtn <br>            TRUE <br>            ); <br>    } <br>} <br> <br> <br>VOID <br>APIENTRY <br>ConnectOutTimerFired( <br>    LPVOID pArg, <br>    DWORD  dwTimerLo, <br>    DWORD  dwTimerHi <br>    ) <br>{ <br>    UNREFERENCED_PARAMETER( pArg ); <br>    UNREFERENCED_PARAMETER( dwTimerLo ); <br>    UNREFERENCED_PARAMETER( dwTimerHi ); <br> <br>    // <br>    // We've had a connected OUT pipe for a minute now, <br>    // only two-pipe clients connect to that and they <br>    // immediately connect to IN afterwards.  Presumably <br>    // the client died between these two operations.  Until <br>    // we recycle the OUT pipe all two-pipe clients are <br>    // unable to connect getting pipe busy errors. <br>    // <br> <br>    if ( ! bOutPipeConnected ) { <br> <br>        TRACE(CONNECT, ("ConnectOut timer fired but Out pipe not connected.\n")); <br>        return; <br>    } <br> <br>    TRACE(CONNECT, ("Two-pipe caller hung for 1 minute, recycling OUT pipe %x.\n", <br>                    hPipeOut)); <br> <br>    bOutPipeConnected = FALSE; <br> <br>    CANCELIO(hPipeOut); <br>    DisconnectNamedPipe(hPipeOut); <br>    CloseHandle(hPipeOut); <br>    hPipeOut = INVALID_HANDLE_VALUE; <br> <br>    CreatePipeAndIssueConnect(OUT_PIPE); </code></pre>
<p>
</p>
<pre><code><br>    // <br>    // In order for things to work reliably for 2-pipe clients <br>    // when there are multiple remote servers on the same pipename, <br>    // we need to tear down the listening IN pipe and recreate it so <br>    // that the oldest listening OUT pipe will be from the same process <br>    // as the oldest listening IN pipe. <br>    // <br> <br>    if (1 == cConnectIns) { <br> <br>        TRACE(CONNECT, ("Recycling IN pipe %x as well for round-robin behavior.\n", <br>                        rghPipeIn[0])); <br> <br>        CANCELIO(rghPipeIn[0]); <br>        DisconnectNamedPipe(rghPipeIn[0]); <br>        CloseHandle(rghPipeIn[0]); <br>        rghPipeIn[0] = INVALID_HANDLE_VALUE; <br> <br>        CreatePipeAndIssueConnect(0); <br>    } <br>} <br> <br> <br>VOID <br>FASTCALL <br>HandleInPipeConnected( <br>    int nIndex <br>    ) <br>{ <br>    PREMOTE_CLIENT pClient; <br>    char szHexAsciiId[9]; <br> <br>    ResetEvent(rghWait[WAITIDX_CONNECT_IN_BASE + nIndex]); <br> <br>    if (nIndex &gt;= (int) cConnectIns) { <br> <br>        // <br>        // The I/O was cancelled on the excess <br>        // listening pipes, causing the event to <br>        // fire. <br>        // <br> <br>        ASSERT(INVALID_HANDLE_VALUE == rghPipeIn[nIndex]); <br> <br>        TRACE(CONNECT, ("IN pipe #%d, handle %x listen cancelled.\n", <br>                        nIndex + 1, rghPipeIn[nIndex])); <br> <br>        return; <br>    } <br> <br> <br>    TRACE(CONNECT, ("Caller connected to IN pipe #%d, handle %x.\n", <br>                    nIndex + 1, rghPipeIn[nIndex])); <br> <br>    // <br>    // A client is fully connected, but we don't know if <br>    // it's a single-pipe or two-pipe client.  Until <br>    // we do its PipeWriteH will be invalid.  We'll figure <br>    // it out in ReadClientNameCompleted. <br>    // <br> <br>    pClient = HeapAlloc( <br>                  hHeap, <br>                  HEAP_ZERO_MEMORY, <br>                  sizeof(*pClient) <br>                  ); <br> <br>    if ( ! pClient) { <br> <br>        printf("Out of memory connecting client, hanging up.\n"); <br> <br>        CloseHandle( rghPipeIn[nIndex] ); <br>        rghPipeIn[nIndex] = INVALID_HANDLE_VALUE; <br>        CreatePipeAndIssueConnect( nIndex ); <br> <br> <br>        if (bOutPipeConnected) { <br> <br>             // <br>             // Hang up on the two-pipe caller connected to the <br>             // OUT pipe as well -- it may be this client or it <br>             // may be another, no way to tell, and really no <br>             // great need to because if it's another caller <br>             // we probably wouldn't be able to allocate memory <br>             // for it either. <br>             // <br>             // Also if we're using a single IN pipe for <br>             // multiple-server round-robin behavior we <br>             // want to recycle both pipes at the same time. <br>             // <br> <br>            TRACE(CONNECT, ("Also hanging up on connected two-pipe caller on OUT pipe %x.\n", <br>                            hPipeOut)); <br> <br>            bOutPipeConnected = FALSE; <br> <br>            if (INVALID_HANDLE_VALUE != hConnectOutTimer) { <br>                 pfnCancelWaitableTimer(hConnectOutTimer); <br>            } <br> <br>            DisconnectNamedPipe(hPipeOut); <br>            CloseHandle(hPipeOut); <br>            hPipeOut = INVALID_HANDLE_VALUE; <br> <br>            CreatePipeAndIssueConnect( OUT_PIPE ); <br>        } <br> <br>    } else { <br> <br>        // <br>        // Initialize the Client <br>        // <br> <br>        pClient-&gt;dwID = dwNextClientID++; <br>        sprintf(szHexAsciiId, "%08x", pClient-&gt;dwID); <br>        CopyMemory(pClient-&gt;HexAsciiId, szHexAsciiId, sizeof(pClient-&gt;HexAsciiId)); <br> <br>        pClient-&gt;PipeReadH   = rghPipeIn[nIndex]; <br>        rghPipeIn[nIndex] = INVALID_HANDLE_VALUE; <br> <br>        pClient-&gt;PipeWriteH  = INVALID_HANDLE_VALUE; <br> <br>        TRACE(CONNECT, ("Handshaking new client %d (%x) on IN pipe handle %x.\n", <br>                        pClient-&gt;dwID, pClient, pClient-&gt;PipeReadH)); <br> <br>        // <br>        // Start another connect operation to replace this completed one. <br>        // <br> <br>        CreatePipeAndIssueConnect( nIndex ); <br> <br>        // <br>        // Start session I/Os with the new client.  This will link it <br>        // into the handshaking list. <br>        // <br> <br>        StartSession( pClient ); <br> <br>    } <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
