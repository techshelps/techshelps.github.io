<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5729"></a>CLIENT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1992 - 1997 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Copyright 1992 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    Client.c <br> <br>Abstract: <br> <br>    The Client component of Remote. Connects to the remote <br>    server using named pipes. It sends its stdin to <br>    the server and output everything from server to <br>    its stdout. <br> <br>Author: <br> <br>    Rajivendra Nath  2-Jan-1992 <br>    Dave Hart        Summer 1997   single-pipe operation <br> <br>Environment: <br> <br>    Console App. User mode. <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;process.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;string.h&gt; <br>#include "Remote.h" <br> <br>BOOL fAsyncPipe = TRUE;    // need this so server has it TRUE <br> <br> <br>HANDLE* <br>EstablishSession( <br>    char *server, <br>    char *pipe <br>    ); <br> <br>DWORD <br>WINAPI <br>SendServerInp( <br>    LPVOID pvParam <br>    ); <br> <br>BOOL <br>FilterClientInp( <br>    char *buff, <br>    int count <br>    ); <br> <br> <br>BOOL <br>Mych( <br>    DWORD ctrlT <br>    ); <br> <br>VOID <br>SendMyInfo( <br>    PHANDLE Pipes <br>    ); <br> <br> <br>#define ZERO_LENGTH_READ_LIMIT  200 <br> <br>HANDLE MyStdInp; <br>HANDLE MyStdOut; <br> <br>// <br>// ReadPipe and WritePipe are referenced by multiple <br>// threads so need to be volatile. <br>// <br> <br>volatile HANDLE ReadPipe; <br>volatile HANDLE WritePipe; <br> <br> <br>CONSOLE_SCREEN_BUFFER_INFO csbi; <br> <br>char   MyEchoStr[30]; <br>BOOL   CmdSent; <br>DWORD  LinesToSend=LINESTOSEND; <br> <br>VOID <br>Client( <br>    char* Server, <br>    char* Pipe <br>    ) <br>{ <br>    HANDLE *Connection; <br>    DWORD  dwThreadID; <br>    HANDLE hThread; <br>    DWORD  cb; <br>    OVERLAPPED ol; <br>    char   rgchBuf[1024]; <br>    DWORD  dwZeroCount = 0; <br> <br> <br>    MyStdInp=GetStdHandle(STD_INPUT_HANDLE); <br>    MyStdOut=GetStdHandle(STD_OUTPUT_HANDLE); <br> <br>    printf("**************************************\n"); <br>    printf("***********     REMOTE    ************\n"); <br>    printf("***********     CLIENT    ************\n"); <br>    printf("**************************************\n"); <br> <br>    if ((Connection=EstablishSession(Server,Pipe))==NULL) <br>        return; <br> <br> <br>    ReadPipe=Connection[0]; <br>    WritePipe=Connection[1]; <br> <br>    SetConsoleCtrlHandler((PHANDLER_ROUTINE)Mych,TRUE); <br> <br>    // Start Thread For Client --&gt; Server Flow <br>    hThread = (HANDLE) <br>        _beginthreadex( <br>            NULL,             // security <br>            0,                // default stack size <br>            SendServerInp,    // thread proc <br>            NULL,             // parm <br>            0,                // not suspended <br>            &amp;dwThreadID <br>            ); <br> <br>    if ( ! hThread) <br>    { <br> <br>        Errormsg("REMOTE /C Could Not Create Thread."); <br>        return; <br>    } <br> <br> <br>    ZeroMemory(&amp;ol, sizeof(ol)); <br> <br>    ol.hEvent = <br>        CreateEvent( <br>            NULL,      // security <br>            TRUE,      // auto-reset <br>            FALSE,     // initially nonsignaled <br>            NULL       // unnamed <br>            ); <br> <br>    while (ReadFileSynch(ReadPipe, rgchBuf, sizeof rgchBuf, &amp;cb, 0, &amp;ol)) { <br> <br>        if (cb) { <br>           if ( ! WriteFile(MyStdOut, rgchBuf, cb, &amp;cb, NULL)) { <br>               break; <br>           } <br>           dwZeroCount = 0; <br>        } else { <br>            if (++dwZeroCount &gt; ZERO_LENGTH_READ_LIMIT) { <br> <br>                // <br>                // If we get a bunch of zero length reads in a row, <br>                // something's broken, don't loop forever. <br>                // (bug #115866). <br>                // <br> <br>                printf("\nREMOTE: bailing out, server must have gone away.\n"); <br>                break; <br>            } <br>        } <br> <br>    } <br> <br>    CloseHandle(ol.hEvent); <br> <br>    printf("*** SESSION OVER ***"); <br>    fflush(stdout); <br> <br>    // <br>    // Terminate the keyboard reading thread. <br>    // <br> <br>    TerminateThread(hThread, 0); <br>    CloseHandle(hThread); <br>    CloseClientPipes(); <br> <br>    printf("\n"); <br>    fflush(stdout); <br> <br>} <br> <br> <br>DWORD <br>WINAPI <br>SendServerInp( <br>    LPVOID pvParam <br>    ) <br>{ <br>    DWORD  dread,dwrote; <br>    OVERLAPPED ol; <br>    char buff[512]; <br> <br>    UNREFERENCED_PARAMETER(pvParam); <br> <br>    ZeroMemory(&amp;ol, sizeof(ol)); <br> <br>    ol.hEvent = <br>        CreateEvent( <br>            NULL,      // security <br>            TRUE,      // auto-reset <br>            FALSE,     // initially nonsignaled <br>            NULL       // unnamed <br>            ); <br> <br> <br>    while(ReadFile(MyStdInp,buff,sizeof buff,&amp;dread,NULL)) <br>    { <br>        if (FilterClientInp(buff,dread)) <br>            continue; <br>        if (!WriteFileSynch(WritePipe,buff,dread,&amp;dwrote,0,&amp;ol)) <br>            break; <br>    } <br> <br>    CloseClientPipes(); <br> <br>    return 0; <br>} <br> <br> <br> <br>BOOL <br>FilterClientInp( <br>    char *buff, <br>    int count <br>    ) <br>{ <br> <br>    if (count==0) <br>        return(TRUE); <br> <br>    if (buff[0]==2)     // Adhoc screening of ^B so that i386kd/mipskd <br>        return(TRUE);   // do not terminate. <br> <br>    if (buff[0]==COMMANDCHAR) <br>    { <br>        switch (buff[1]) <br>        { <br>        case 'k': <br>        case 'K': <br>        case 'q': <br>        case 'Q': <br>              CloseClientPipes(); <br>              return(FALSE); <br> <br>        case 'h': <br>        case 'H': <br>              printf("%cM : Send Message\n",COMMANDCHAR); <br>              printf("%cP : Show Popup on Server\n",COMMANDCHAR); <br>              printf("%cS : Status of Server\n",COMMANDCHAR); <br>              printf("%cQ : Quit client\n",COMMANDCHAR); <br>              printf("%cH : This Help\n",COMMANDCHAR); <br>              return(TRUE); <br> <br>        default: <br>              return(FALSE); <br>        } <br> <br>    } <br>    return(FALSE); <br>} <br> <br>BOOL <br>Mych( <br>   DWORD ctrlT <br>   ) <br> <br>{ <br>    char  c[2]; <br>    DWORD tmp; <br>    OVERLAPPED ol; <br> <br>    c[0]=CTRLC; <br> <br>    if (ctrlT==CTRL_C_EVENT) <br>    { <br>        ZeroMemory(&amp;ol, sizeof(ol)); <br> <br>        ol.hEvent = <br>            CreateEvent( <br>                NULL,      // security <br>                TRUE,      // auto-reset <br>                FALSE,     // initially nonsignaled <br>                NULL       // unnamed <br>                ); <br> <br>        if (INVALID_HANDLE_VALUE != WritePipe &amp;&amp; <br>            !WriteFileSynch(WritePipe,c,1,&amp;tmp,0,&amp;ol)) <br>        { <br>            CloseHandle(ol.hEvent); <br>            Errormsg("Error Sending ^c"); <br>            return(FALSE); <br>        } <br>        CloseHandle(ol.hEvent); <br>        return(TRUE); <br>    } <br>    if ((ctrlT==CTRL_BREAK_EVENT)|| <br>        (ctrlT==CTRL_CLOSE_EVENT)|| <br>        (ctrlT==CTRL_LOGOFF_EVENT)|| <br>        (ctrlT==CTRL_SHUTDOWN_EVENT) <br>       ) { <br> <br>       CloseClientPipes(); <br>    } <br>    return(FALSE); <br>} <br> <br>VOID <br>CloseClientPipes( <br>    VOID <br>    ) <br>{ <br>    HANDLE WriteHandle, ReadHandle; <br> <br>    WriteHandle = (HANDLE) InterlockedExchange( <br>        (LPLONG) &amp;WritePipe, <br>        (LONG)   INVALID_HANDLE_VALUE <br>        ); <br> <br>    if (INVALID_HANDLE_VALUE != WriteHandle) { <br> <br>        CloseHandle(WriteHandle); <br> <br>        ReadHandle = (HANDLE) InterlockedExchange( <br>            (LPLONG) &amp;ReadPipe, <br>            (LONG)   INVALID_HANDLE_VALUE <br>            ); <br> <br>        if (INVALID_HANDLE_VALUE != ReadHandle &amp;&amp; <br>            WriteHandle != ReadHandle) { <br> <br>            CloseHandle(ReadHandle); <br>        } <br>    } <br>} <br> <br> <br>VOID <br>HandleConnectError( <br>    char *server, <br>    char *srvpipename <br>    ) <br>{ <br>    DWORD Err = GetLastError(); <br>    char  msg[128]; <br> <br>    Errormsg("*** Unable to Connect ***"); <br> <br>    // <br>    // Print a helpful message <br>    // <br> <br>    switch(Err) <br>    { <br>        case ERROR_FILE_NOT_FOUND: <br>            sprintf(msg,"invalid pipe name %s", srvpipename); <br>            break; <br> <br>        case ERROR_BAD_NETPATH: <br>            sprintf(msg,"\\\\%s not found", server); <br>            break; <br> <br>        default: <br>            FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM| <br>                           FORMAT_MESSAGE_IGNORE_INSERTS, <br>                           NULL, Err, 0, msg, sizeof(msg), NULL); <br>            break; <br> <br>    } <br> <br>    printf("Diagnosis: %s\n",msg); <br> <br>    // <br>    // If the machine exists but the pipe doesn't do an <br>    // automatic remote /q to list pipes available on <br>    // that machine. <br>    // <br> <br>    if (ERROR_FILE_NOT_FOUND == Err) { <br> <br>        printf("\nREMOTE /Q %s\n", server); <br>        fflush(stdout); <br>        QueryRemotePipes(server); <br>    } <br>} <br> <br> <br> <br>HANDLE* <br>EstablishSession( <br>    char *server, <br>    char *srvpipename <br>    ) <br>{ <br>    extern BOOL bForceTwoPipes; <br>    static HANDLE PipeH[2]; <br>    char   pipenameSrvIn[200]; <br>    char   pipenameSrvOut[200]; <br>    BOOL   fOldServer; <br>    DWORD  dwError; <br>    DWORD  RetryCount = 0; <br> <br>    // <br>    // Since in single-pipe operation we'll be using the same <br>    // pipe in two threads, we have to open the handles for <br>    // overlapped operation, even though we always want <br>    // synchronous operation. <br>    // <br> <br>    sprintf(pipenameSrvIn ,SERVER_READ_PIPE ,server,srvpipename); <br>    sprintf(pipenameSrvOut,SERVER_WRITE_PIPE,server,srvpipename); <br> <br>    if (bForceTwoPipes) { <br> <br>        dwError = ERROR_NOT_SUPPORTED; <br> <br>    } else { <br> <br>      RetrySrvBidi: <br> <br>        if (INVALID_HANDLE_VALUE == <br>               (PipeH[1] = <br>                    CreateFile( <br>                        pipenameSrvIn, <br>                        GENERIC_READ | GENERIC_WRITE, <br>                        0, <br>                        NULL, <br>                        OPEN_EXISTING, <br>                        FILE_FLAG_OVERLAPPED, <br>                        NULL <br>                        ))) { <br> <br>            dwError = GetLastError(); <br> <br>            if (ERROR_PIPE_BUSY == dwError) { <br> <br>                printf( "All pipe instances busy, waiting for another...\n"); <br> <br>                WaitNamedPipe( <br>                    pipenameSrvIn, <br>                    15000 <br>                    ); <br> <br>                if (RetryCount++ &lt; 6) { <br>                    goto RetrySrvBidi; <br>                } <br>            } <br> <br>            if (ERROR_ACCESS_DENIED != dwError &amp;&amp; <br>                ERROR_NOT_SUPPORTED != dwError) { <br> <br>                HandleConnectError(server, srvpipename); <br>                return NULL; <br>            } <br> <br>        } else { <br> <br>            PipeH[0] = PipeH[1]; <br>            fAsyncPipe = TRUE; <br> <br>            printf("Connected...\n\n"); <br> <br>            SendMyInfo(PipeH); <br> <br>            return PipeH; <br>        } <br>    } <br> <br> <br>    // <br>    // Old remote servers don't allow you to open the <br>    // server IN pipe for READ access, so go down the <br>    // old path, notably opening OUT first so the <br>    // server knows we'll be using both pipes.  We'll <br>    // also come down this path on Win95 because <br>    // it doesn't allow you to open an overlapped <br>    // pipe handle.  Or if remote /c mach pipe /2 is used. <br>    // <br> <br>    fOldServer = (ERROR_ACCESS_DENIED == dwError); <br> <br>  RetrySrvOut: <br> <br>    if (INVALID_HANDLE_VALUE == <br>            (PipeH[0] = <br>                CreateFile( <br>                    pipenameSrvOut, <br>                    GENERIC_READ, <br>                    0, <br>                    NULL, <br>                    OPEN_EXISTING, <br>                    0, <br>                    NULL <br>                    ))) { <br> <br>        if (ERROR_PIPE_BUSY == GetLastError()) { <br> <br>            printf( "All OUT pipe instances busy, waiting for another...\n"); <br> <br>            WaitNamedPipe( <br>                pipenameSrvOut, <br>                32000              // server recycles abandoned <br>                );                 // OUT pipe after two minutes <br> <br>            if (RetryCount++ &lt; 6) { <br>                goto RetrySrvOut; <br>            } <br>        } <br> <br>        HandleConnectError(server, srvpipename); <br>        return NULL; <br> <br>    } <br> <br> <br>  RetrySrvIn: <br> <br>    if (INVALID_HANDLE_VALUE == <br>           (PipeH[1] = <br>               CreateFile( <br>                    pipenameSrvIn, <br>                    GENERIC_WRITE, <br>                    0, <br>                    NULL, <br>                    OPEN_EXISTING, <br>                    0, <br>                    NULL <br>                    ))) { <br> <br>        dwError = GetLastError(); <br> <br>        if (ERROR_PIPE_BUSY == dwError) { <br> <br>            printf( "All IN pipe instances busy, waiting for another...\n"); <br> <br>            WaitNamedPipe( <br>                pipenameSrvIn, <br>                15000 <br>                ); <br> <br>            if (RetryCount++ &lt; 6) { <br>                goto RetrySrvIn; <br>           } <br>        } <br> <br>        HandleConnectError(server, srvpipename); <br>        return NULL; <br> <br>    } <br> <br>    fAsyncPipe = FALSE; <br> <br>    printf("Connected... %s\n\n", <br>           fOldServer <br>               ? "to two-pipe remote server." <br>               : "using two pipes." <br>           ); <br> <br>    SendMyInfo(PipeH); <br> <br>    return PipeH; <br>} <br> <br> <br> <br>VOID <br>SendMyInfo( <br>    PHANDLE pipeH <br>    ) <br>{ <br>    HANDLE rPipe=pipeH[0]; <br>    HANDLE wPipe=pipeH[1]; <br> <br>    DWORD  hostlen; <br>    WORD   BytesToSend=sizeof(SESSION_STARTUPINFO); <br>    DWORD  tmp; <br>    OVERLAPPED ol; <br>    SESSION_STARTUPINFO ssi; <br>    SESSION_STARTREPLY  ssr; <br> <br>    ol.hEvent = <br>        CreateEvent( <br>            NULL,      // security <br>            TRUE,      // auto-reset <br>            FALSE,     // initially nonsignaled <br>            NULL       // unnamed <br>            ); <br> <br>    ssi.Size=BytesToSend; <br>    ssi.Version=VERSION; <br> <br>    hostlen = sizeof(ssi.ClientName) / sizeof(ssi.ClientName[0]); <br>    GetComputerName(ssi.ClientName, &amp;hostlen); <br>    ssi.LinesToSend=LinesToSend; <br>    ssi.Flag=ClientToServerFlag; <br> <br>    { <br>        DWORD NewCode=MAGICNUMBER; <br>        char  Name[MAX_COMPUTERNAME_LENGTH+1]; <br> <br>        strcpy(Name,(char *)ssi.ClientName); <br>        memcpy(&amp;Name[11],(char *)&amp;NewCode,sizeof(NewCode)); <br> <br>        // <br>        // The server needs to know if we're doing single-pipe <br>        // operation so it can complete the connection properly. <br>        // So if we are, change the first byte of the first <br>        // send (the computername, which is later superceded <br>        // by the one in the SESSION_STARTUPINFO structure) <br>        // to an illegal computername character, question mark. <br>        // <br> <br>        if (wPipe == rPipe) { <br> <br>             Name[0] = '?'; <br>        } <br> <br>        WriteFileSynch(wPipe,(char *)Name,HOSTNAMELEN-1,&amp;tmp,0,&amp;ol); <br>        ReadFileSynch(rPipe ,(char *)&amp;ssr.MagicNumber,sizeof(ssr.MagicNumber),&amp;tmp,0,&amp;ol); <br> <br>        if (ssr.MagicNumber!=MAGICNUMBER) <br>        { <br>            SetLastError(ERROR_INVALID_PARAMETER); <br>            ErrorExit("Pipe connected but server not recognized.\n"); <br>        } <br> <br>        //Get Rest of the info-its not the old server <br> <br>        ReadFileSynch( <br>            rPipe, <br>            (char *)&amp;ssr + sizeof(ssr.MagicNumber), <br>            sizeof(ssr)-sizeof(ssr.MagicNumber), <br>            &amp;tmp, <br>            0, <br>            &amp;ol <br>            ); <br> <br>    } <br> <br>    if (!WriteFileSynch(wPipe,(char *)&amp;ssi,BytesToSend,&amp;tmp,0,&amp;ol)) <br>    { <br>       Errormsg("INFO Send Error"); <br>    } <br> <br>    CloseHandle(ol.hEvent); <br>} <br> <br> <br>VOID <br>QueryRemotePipes( <br>    char* pszServer <br>    ) <br>{ <br>    HANDLE hQPipe; <br>    DWORD  dwRead; <br>    DWORD  dwError; <br>    char   fullname[400]; <br>    char*  msg; <br>    int    msgLen; <br> <br>    if (pszServer[0] == '\\' &amp;&amp; pszServer[1] == '\\') { <br>        pszServer += 2; <br>    } <br> <br>    printf("Querying server \\\\%s\n", pszServer); <br> <br>    sprintf(fullname, QUERY_DEBUGGERS_PIPE, pszServer); <br>         <br>    //   <br>    // Send request and display the query result <br>    //                                                                                 <br>                                                                                    <br>    hQPipe = CreateFile(fullname, <br>        GENERIC_READ | GENERIC_WRITE, <br>        0, <br>        NULL, <br>        OPEN_EXISTING, <br>        FILE_ATTRIBUTE_NORMAL, <br>        NULL); <br>     <br>    if(hQPipe == INVALID_HANDLE_VALUE) { <br> <br>        dwError = GetLastError(); <br> <br>        if (ERROR_FILE_NOT_FOUND == dwError) { <br> <br>            printf("No Remote servers running on \\\\%s\n", pszServer); <br> <br>        } else if (ERROR_BAD_NETPATH == dwError) { <br> <br>            printf("\\\\%s not found on the network\n", pszServer); <br> <br>        } else { <br> <br>            FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | <br>                           FORMAT_MESSAGE_IGNORE_INSERTS, <br>                           NULL, dwError, 0, <br>                           fullname, sizeof(fullname), NULL); <br> <br>            printf("Can't query server %s: %s\n", pszServer, fullname); <br>        } <br> <br>        return; <br>    }                                                                                   <br>     <br>    //  Send Query Command <br>    if(!WriteFile(hQPipe, "q", 1, &amp;dwRead, NULL) <br>        || (dwRead != 1)) <br>    { <br>        printf("\nError: Can't send command\n"); <br>        goto failure; <br>    } <br> <br>    if(!ReadFile(hQPipe,  <br>             &amp;msgLen, <br>             sizeof(int),      // read msg dimension <br>             &amp;dwRead,                                     <br>             NULL)  <br>        || (dwRead != sizeof(int))) <br>    { <br>        printf("\nError: Can't read message\n"); <br>        goto failure; <br>    } <br> <br>    if(!msgLen) <br>    { <br>        printf("\nNo visible sessions on server %s", pszServer); <br>        goto failure; <br>    } <br> <br>    if(msgLen &gt; 65535)        // error <br>    { <br>        printf("Error querying server %s, got %d for msg length, 65535 max.\n", <br>               pszServer, <br>               msgLen <br>               ); <br>        goto failure; <br>    } <br>     <br>    if((msg = (char*)malloc(msgLen*sizeof(char))) == NULL) <br>    { <br>        printf("\nOut of memory\n"); <br>        goto failure;     <br>    } <br> <br>    ReadFile(hQPipe,  <br>             msg, <br>             msgLen * sizeof(char),      // read msg <br>             &amp;dwRead,                                     <br>             NULL);                                                                 <br> <br>    printf("\nVisible sessions on server %s:\n\n", pszServer); <br>     <br>    printf("%s\n", msg); <br>    free(msg); <br> <br> failure: <br> <br>    CloseHandle(hQPipe); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
