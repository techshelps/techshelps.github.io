<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SRVHSHAK.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5738"></a>SRVHSHAK.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1995 - 1997 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    SrvHShak.c <br> <br>Abstract: <br> <br>    The server component of Remote.  Handshake with <br>    client at start of session. <br> <br> <br>Author: <br> <br>    Dave Hart  30 May 1997 <br> <br>Environment: <br> <br>    Console App. User mode. <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;string.h&gt; <br>#include "Remote.h" <br>#include "Server.h" <br> <br> <br> <br> <br>VOID <br>FASTCALL <br>HandshakeWithRemoteClient( <br>    PREMOTE_CLIENT pClient <br>    ) <br>{ <br>    pClient-&gt;ServerFlags |= SFLG_HANDSHAKING; <br> <br>    AddClientToHandshakingList(pClient); <br> <br>    // <br>    // Read hostname from client <br>    // <br> <br>    ZeroMemory( <br>        &amp;pClient-&gt;ReadOverlapped, <br>        sizeof(pClient-&gt;ReadOverlapped) <br>        ); <br> <br>    if ( ! ReadFileEx( <br>               pClient-&gt;PipeReadH, <br>               pClient-&gt;Name, <br>               HOSTNAMELEN - 1, <br>               &amp;pClient-&gt;ReadOverlapped, <br>               ReadClientNameCompleted <br>               )) { <br> <br>        CloseClient(pClient); <br>    } <br>} <br> <br>VOID <br>WINAPI <br>ReadClientNameCompleted( <br>    DWORD dwError, <br>    DWORD cbRead, <br>    LPOVERLAPPED lpO <br>    ) <br>{ <br>    PREMOTE_CLIENT pClient; <br>    SESSION_STARTREPLY ssr; <br> <br>    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped); <br> <br>    if (pClient-&gt;ServerFlags &amp; SFLG_CLOSING) { <br> <br>        return; <br>    } <br> <br>    if (dwError) { <br>        CloseClient(pClient); <br>        return; <br>    } <br> <br>    if ((HOSTNAMELEN - 1) != cbRead) { <br>        printf("ReadClientNameCompleted read %d s/b %d.\n", cbRead, (HOSTNAMELEN - 1)); <br>        CloseClient(pClient); <br>        return; <br>    } <br> <br>    // <br>    // The client name read is 15 bytes always.  The last four <br>    // should match MAGICNUMBER, which conveniently has the <br>    // low byte zeroed to terminate the client name after 11 <br>    // characters. <br>    // <br> <br>    if (MAGICNUMBER != *(DWORD *)&amp;pClient-&gt;Name[11]) { <br> <br>        pClient-&gt;Name[11] = 0; <br>        CloseClient(pClient); <br>        return; <br>    } <br> <br>    // <br>    // Now we can tell if this is a single-pipe or two-pipe <br>    // client, because single-pipe clients replace the <br>    // first byte of the computername with the illegal <br>    // character '?'. <br>    // <br> <br>    if ('?' == pClient-&gt;Name[0]) { <br> <br>        pClient-&gt;PipeWriteH = pClient-&gt;PipeReadH; <br> <br>        TRACE(CONNECT, ("Client %d pipe %x is single-pipe.\n", pClient-&gt;dwID, pClient-&gt;PipeWriteH)); <br> <br>        // <br>        // In order for things to work reliably for 2-pipe clients <br>        // when there are multiple remote servers on the same pipename, <br>        // we need to tear down the listening OUT pipe and recreate it so <br>        // that the oldest listening IN pipe will be from the same process <br>        // as the oldest listening OUT pipe. <br>        // <br> <br>        if (1 == cConnectIns) { <br> <br>            TRACE(CONNECT, ("Recycling OUT pipe %x as well for round-robin behavior.\n", <br>                            hPipeOut)); <br> <br>            CANCELIO(hPipeOut); <br>            DisconnectNamedPipe(hPipeOut); <br>            CloseHandle(hPipeOut); <br>            hPipeOut = INVALID_HANDLE_VALUE; <br>            bOutPipeConnected = FALSE; <br> <br>            CreatePipeAndIssueConnect(OUT_PIPE); <br>        } <br> <br>    } else { <br> <br>        if ( ! bOutPipeConnected ) { <br> <br>            printf("Remote: %x two-pipe client connected to IN pipe but not OUT?\n", pClient); <br>            CloseClient(pClient); <br>            return; <br>        } <br> <br>        bOutPipeConnected = FALSE; <br> <br>        if (INVALID_HANDLE_VALUE != hConnectOutTimer) { <br>            pfnCancelWaitableTimer(hConnectOutTimer); <br>        } <br> <br>        pClient-&gt;PipeWriteH = hPipeOut; <br>        hPipeOut = INVALID_HANDLE_VALUE; <br> <br>        TRACE(CONNECT, ("Client %d is dual-pipe IN %x OUT %x.\n", pClient-&gt;dwID, pClient-&gt;PipeReadH, pClient-&gt;PipeWriteH)); <br> <br>        CreatePipeAndIssueConnect(OUT_PIPE); <br>    } <br> <br>    TRACE(SHAKE, ("Read client name %s\n", pClient-&gt;Name)); <br> <br>    // <br>    // Send our little pile of goodies to the client <br>    // <br> <br>    ssr.MagicNumber = MAGICNUMBER; <br>    ssr.Size = sizeof(ssr); <br>    ssr.FileSize = dwWriteFilePointer; <br> <br>    // <br>    // Copy ssr structure to a buffer that will be around <br>    // for the entire I/O. <br>    // <br> <br>    CopyMemory(pClient-&gt;WriteBuffer, &amp;ssr, sizeof(ssr)); <br> <br>    if ( ! WriteFileEx( <br>               pClient-&gt;PipeWriteH, <br>               pClient-&gt;WriteBuffer, <br>               sizeof(ssr), <br>               &amp;pClient-&gt;WriteOverlapped, <br>               WriteServerReplyCompleted <br>               )) { <br> <br>        CloseClient(pClient); <br>    } <br>} <br> <br> <br>VOID <br>WINAPI <br>WriteServerReplyCompleted( <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED lpO <br>    ) <br>{ <br>    PREMOTE_CLIENT pClient; <br> <br>    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped); <br> <br>    if (pClient-&gt;ServerFlags &amp; SFLG_CLOSING) { <br> <br>        return; <br>    } <br> <br>    if (HandleSessionError(pClient, dwError)) { <br>        return; <br>    } <br> <br>    TRACE(SHAKE, ("Wrote server reply\n")); <br> <br>    // <br>    // Read the size of the SESSION_STARTUPINFO the client is <br>    // sending us, to deal gracefully with different versions <br>    // on client and server. <br>    // <br> <br>    if ( ! ReadFileEx( <br>               pClient-&gt;PipeReadH, <br>               pClient-&gt;ReadBuffer, <br>               sizeof(DWORD), <br>               &amp;pClient-&gt;ReadOverlapped, <br>               ReadClientStartupInfoSizeCompleted <br>               )) { <br> <br>        CloseClient(pClient); <br>    } <br>} <br> <br> <br>VOID <br>WINAPI <br>ReadClientStartupInfoSizeCompleted( <br>    DWORD dwError, <br>    DWORD cbRead, <br>    LPOVERLAPPED lpO <br>    ) <br>{ <br>    PREMOTE_CLIENT pClient; <br>    DWORD dwSize; <br> <br>    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped); <br> <br>    if (HandleSessionError(pClient, dwError)) { <br> <br>        return; <br>    } <br> <br>    if (cbRead != sizeof(DWORD)) { <br> <br>        CloseClient(pClient); <br>        return; <br>    } <br> <br>    // <br>    // Sanity check the size <br>    // <br> <br>    dwSize = *(DWORD *)pClient-&gt;ReadBuffer; <br> <br>    if (dwSize &gt; 1024) { <br>        CloseClient(pClient); <br>        return; <br>    } <br> <br>    // <br>    // Squirrel away the size in the write buffer, <br>    // since during handshaking we never have both a <br>    // read and write pending this is OK. <br>    // <br> <br>    *(DWORD *)pClient-&gt;WriteBuffer = dwSize; <br> <br>    TRACE(SHAKE, ("Read client reply size %d\n", dwSize)); <br> <br>    // <br>    // Read the rest of the SESSION_STARTUPINFO into the read buffer <br>    // after the size. <br>    // <br> <br>    RtlZeroMemory( <br>        &amp;pClient-&gt;ReadOverlapped, <br>        sizeof(pClient-&gt;ReadOverlapped) <br>        ); <br> <br>    if ( ! ReadFileEx( <br>               pClient-&gt;PipeReadH, <br>               pClient-&gt;ReadBuffer + sizeof(DWORD), <br>               dwSize - sizeof(DWORD), <br>               &amp;pClient-&gt;ReadOverlapped, <br>               ReadClientStartupInfoCompleted <br>               )) { <br> <br>        CloseClient(pClient); <br>    } <br>} <br> <br> <br>VOID <br>WINAPI <br>ReadClientStartupInfoCompleted( <br>    DWORD dwError, <br>    DWORD cbRead, <br>    LPOVERLAPPED lpO <br>    ) <br>{ <br>    PREMOTE_CLIENT pClient; <br>    DWORD dwSize; <br>    SESSION_STARTUPINFO ssi; <br>    char  Buf[256]; <br> <br>    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped); <br> <br>    if (HandleSessionError(pClient, dwError)) { <br> <br>        return; <br>    } <br> <br>    dwSize = *(DWORD *)pClient-&gt;WriteBuffer; <br> <br>    if (cbRead != (dwSize - sizeof(ssi.Size))) { <br> <br>        CloseClient(pClient); <br>        return; <br>    } <br> <br>    CopyMemory(&amp;ssi, pClient-&gt;ReadBuffer, min(dwSize, sizeof(ssi))); <br> <br>    CopyMemory(pClient-&gt;Name, ssi.ClientName, sizeof(pClient-&gt;Name)); <br>    pClient-&gt;Flag = ssi.Flag; <br> <br>    if (ssi.Version != VERSION) { <br> <br>        printf("Remote Warning: Server Version=%d Client Version=%d for %s\n", VERSION, ssi.Version, pClient-&gt;Name); <br>    } <br> <br>    TRACE(SHAKE, ("Read client info, new name %s, %d lines\n", pClient-&gt;Name, ssi.LinesToSend)); <br> <br> <br>    // <br>    // Set temp file position according to the client's <br>    // requested lines to send.  The heuristic of 45 chars <br>    // per average line is used by the client.  However since old clients <br>    // hardcode this knowledge and sit and spin trying to read that many <br>    // bytes before completing initialization, and because we might not send <br>    // that many due to stripping BEGINMARK and ENDMARK characters, we <br>    // use 50 chars per line to calculate the temp file position in hopes <br>    // the extra bytes will overcome the missing MARK characters. <br>    // <br> <br>    pClient-&gt;dwFilePos = dwWriteFilePointer &gt; (ssi.LinesToSend * 50) <br>                             ? dwWriteFilePointer - (ssi.LinesToSend * 50) <br>                             : 0; <br> <br>    // <br>    // This client's ready to roll. <br>    // <br> <br>    pClient-&gt;ServerFlags &amp;= ~SFLG_HANDSHAKING; <br> <br>    MoveClientToNormalList(pClient); <br> <br>    // <br>    // Start read operation against this client's input. <br>    // <br> <br>    StartReadClientInput(pClient); <br> <br>    // <br>    // Announce the connection. <br>    // <br> <br>    sprintf(Buf, <br>            "\n**Remote: Connected to %s %s%s [%s]\n", <br>            pClient-&gt;Name, <br>            pClient-&gt;UserName, <br>            (pClient-&gt;PipeReadH != pClient-&gt;PipeWriteH) <br>              ? " (two pipes)" <br>              : "", <br>            GetFormattedTime(TRUE)); <br> <br>    if (WriteFileSynch(hWriteTempFile,Buf,strlen(Buf),&amp;dwSize,dwWriteFilePointer,&amp;olMainThread)) { <br>        dwWriteFilePointer += dwSize; <br>        StartServerToClientFlow(); <br>    } <br> <br>    // <br>    // Start write cycle for client output from the temp <br>    // file. <br>    // not needed because of StartServerToClientFlow() just above <br>    // StartReadTempFile(pClient); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
