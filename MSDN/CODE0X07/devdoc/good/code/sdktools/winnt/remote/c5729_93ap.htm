<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REMOTE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5731"></a>REMOTE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1997 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Copyright 1993 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    Remote.c <br> <br>Abstract: <br> <br>    This module contains the main() entry point for Remote. <br>    Calls the Server or the Client depending on the first parameter. <br> <br> <br>Author: <br> <br>    Rajivendra Nath  2-Jan-1993 <br> <br>Environment: <br> <br>    Console App. User mode. <br> <br>Revision History: <br> <br>--*/ <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "Remote.h" <br> <br>char   HostName[HOSTNAMELEN]; <br>char*  ChildCmd; <br>char*  PipeName; <br>char*  ServerName; <br>char * DaclNames[ MAX_DACL_NAMES ]; <br>DWORD  DaclNameCount = 0; <br>char * DaclDenyNames[ MAX_DACL_NAMES ]; <br>DWORD  DaclDenyNameCount = 0 ; <br>HANDLE MyStdOut; <br>HANDLE hAttachedProcess = INVALID_HANDLE_VALUE; <br>HANDLE hAttachedWriteChildStdIn = INVALID_HANDLE_VALUE; <br>HANDLE hAttachedReadChildStdOut = INVALID_HANDLE_VALUE; <br> <br>BOOL   IsAdvertise; <br>DWORD  ClientToServerFlag; <br>BOOL   bForceTwoPipes; <br> <br>char* ColorList[]={"black" ,"blue" ,"green" ,"cyan" ,"red" ,"purple" ,"yellow" ,"white", <br>                   "lblack","lblue","lgreen","lcyan","lred","lpurple","lyellow","lwhite"}; <br> <br>WORD <br>GetColorNum( <br>    char* color <br>    ); <br> <br>VOID <br>SetColor( <br>    WORD attr <br>    ); <br> <br>BOOL <br>GetNextConnectInfo( <br>    char** SrvName, <br>    char** PipeName <br>    ); <br> <br> <br> <br>CONSOLE_SCREEN_BUFFER_INFO csbiOriginal; <br> <br>main( <br>    int    argc, <br>    char** argv <br>    ) <br>{ <br>    WORD  RunType;              // Server or Client end of Remote <br>    DWORD len=HOSTNAMELEN; <br>    int   i, FirstArg; <br> <br>    char  sTitle[120];          // New Title <br>    char  orgTitle[200];        // Old Title <br>    BOOL  bPromptForArgs=FALSE; // Is /P option <br>    WORD  wAttrib;              // Console Attributes <br>    int   privacy;              // Allows exposing or hidng sessions to remote /q <br>    BOOL  Deny ; <br> <br>    GetComputerName((LPTSTR)HostName,&amp;len); <br> <br>    MyStdOut = GetStdHandle(STD_OUTPUT_HANDLE); <br> <br>    if (GetConsoleScreenBufferInfo(MyStdOut,&amp;csbiOriginal)) { <br> <br>        wAttrib = csbiOriginal.wAttributes; <br>        if (!GetConsoleTitle(orgTitle,sizeof(orgTitle))) { <br>            orgTitle[0] = 0; <br>        } <br> <br>    } else { <br> <br>        // <br>        // either stdout is a pipe, or it wasn't opened for <br>        // GENERIC_READ along with GENERIC_WRITE, in which <br>        // case our color manipulations will work so we need <br>        // to pick default colors. <br>        // <br> <br>        wAttrib = FOREGROUND_GREEN | <br>                  FOREGROUND_INTENSITY; <br> <br>        orgTitle[0] = 0; <br>    } <br> <br>    privacy = PRIVACY_DEFAULT; <br> <br> <br> <br>    // <br>    // Parameter Processing <br>    // <br>    // For Server: <br>    // Remote /S &lt;Executable&gt;  &lt;PipeName&gt; [Optional Params] <br>    // <br>    // For Client: <br>    // Remote /C &lt;Server Name&gt; &lt;PipeName&gt; [Optional Params] <br>    // or <br>    // Remote /P <br>    // This will loop continously prompting for different <br>    // Servers and Pipename <br> <br> <br>    if ((argc&lt;2)||((argv[1][0]!='/')&amp;&amp;(argv[1][0]!='-'))) <br>    { <br> <br>        DisplayServerHlp(); <br>        DisplayClientHlp(); <br>        return(1); <br>    } <br> <br>    switch(argv[1][1]) <br>    { <br>    case 'c': <br>    case 'C': <br> <br>        // <br>        // Is Client End of Remote <br>        // <br> <br>        if ((argc&lt;4)||((argv[1][0]!='/')&amp;&amp;(argv[1][0]!='-'))) <br>        { <br> <br>            DisplayServerHlp(); <br>            DisplayClientHlp(); <br>            return(1); <br>        } <br> <br>        ServerName=argv[2]; <br>        PipeName=argv[3]; <br>        FirstArg=4; <br>        RunType=RUNTYPE_CLIENT; <br>        break; <br> <br> <br>    case 'q': <br>    case 'Q': <br> <br>        // <br>        //  Query for possible conexions <br>        // <br> <br> <br>        if ((argc != 3)||((argv[1][0]!='/')&amp;&amp;(argv[1][0]!='-'))) <br>        { <br> <br>            DisplayServerHlp(); <br>            DisplayClientHlp(); <br>            return(1); <br>        } <br> <br>        QueryRemotePipes(argv[2]);  //  Send ServerName as a param <br>        return(0); <br> <br> <br>    case 'p': <br>    case 'P': <br> <br>        // <br>        // Is Client End of Remote <br>        // <br> <br>        bPromptForArgs=TRUE; <br>        RunType=RUNTYPE_CLIENT; <br>        FirstArg=2; <br>        break; <br> <br> <br>    case 's': <br>    case 'S': <br>        // <br>        // Is Server End of Remote <br>        // <br>        if ((argc&lt;4)||((argv[1][0]!='/')&amp;&amp;(argv[1][0]!='-'))) <br>        { <br> <br>            DisplayServerHlp(); <br>            DisplayClientHlp(); <br>            return(1); <br>        } <br> <br>        ChildCmd=argv[2]; <br>        PipeName=argv[3]; <br>        FirstArg=4; <br> <br>        RunType=REMOTE_SERVER; <br>        break; <br> <br> <br>    case 'a': <br>    case 'A': <br>        // <br>        // Is Server End of Remote Attaching to existing process. <br>        // <br>        if ((argc&lt;7)||((argv[1][0]!='/')&amp;&amp;(argv[1][0]!='-'))) <br>        { <br> <br>            DisplayServerHlp(); <br>            DisplayClientHlp(); <br>            return(1); <br>        } <br> <br>        hAttachedProcess = (HANDLE) atoi(argv[2]); <br>        hAttachedWriteChildStdIn = (HANDLE) atoi(argv[3]); <br>        hAttachedReadChildStdOut = (HANDLE) atoi(argv[4]); <br>        ChildCmd=argv[5]; // for display only <br>        PipeName=argv[6]; <br>        FirstArg=7; <br> <br>        RunType = REMOTE_SERVER; <br>        privacy = PRIVACY_VISIBLE;  // presumably ntsd/*kd <br>        break; <br> <br> <br>    default: <br>        DisplayServerHlp(); <br>        DisplayClientHlp(); <br>        return(1); <br>    } <br> <br>    if (RunType==REMOTE_SERVER) <br>    { <br>        // <br>        // Base Name of Executable <br>        // For setting the title <br>        // <br> <br>        char *tcmd=ChildCmd; <br> <br>        while ((*tcmd!=' ')      &amp;&amp; (*tcmd!=0))    tcmd++; <br>        while ((tcmd &gt; ChildCmd) &amp;&amp; (*tcmd!='\\')) tcmd--; <br>        if (*tcmd=='\\') tcmd++; <br>        sprintf(sTitle,"%-41.40s [Remote /C %s %.30s]",tcmd,HostName,PipeName); <br>    } <br> <br>    // <br>    //Process Common (Optional) Parameters <br>    // <br> <br>    for (i=FirstArg;i&lt;argc;i++) <br>    { <br> <br>        if ((argv[i][0]!='/')&amp;&amp;(argv[i][0]!='-')) <br>        { <br>            printf("Invalid parameter %s:Ignoring\n",argv[i]); <br>            continue; <br>        } <br> <br>        switch(argv[i][1]) <br>        { <br>        case 'l':    // Only Valid for client End <br>        case 'L':    // Max Number of Lines to recieve from Server <br>            i++; <br>            if (i&gt;=argc) <br>            { <br>                printf("Incomplete Param %s..Ignoring\n",argv[i-1]); <br>                break; <br>            } <br>            LinesToSend=(DWORD)atoi(argv[i])+1; <br>            break; <br> <br>        case 't':    // Title to be set instead of the default <br>        case 'T': <br>            i++; <br>            if (i&gt;=argc) <br>            { <br>                printf("Incomplete Param %s..Ignoring\n",argv[i-1]); <br>                break; <br>            } <br>            sprintf(sTitle,"%s",argv[i]); <br>            break; <br> <br>        case 'b':    // Background color <br>        case 'B': <br>            i++; <br>            if (i&gt;=argc) <br>            { <br>                printf("Incomplete Param %s..Ignoring\n",argv[i-1]); <br>                break; <br>            } <br>            { <br>                WORD col=GetColorNum(argv[i]); <br>                if (col!=0xffff) <br>                { <br>                    wAttrib=col&lt;&lt;4|(wAttrib&amp;0x000f); <br>                } <br>                break; <br>            } <br> <br>        case 'f':    // Foreground color <br>        case 'F': <br>            i++; <br>            if (i&gt;=argc) <br>            { <br>                printf("Incomplete Param %s..Ignoring\n",argv[i-1]); <br>                break; <br>            } <br>            { <br>                WORD col=GetColorNum(argv[i]); <br>                if (col!=0xffff) <br>                { <br>                    wAttrib=col|(wAttrib&amp;0x00f0); <br>                } <br>                break; <br>            } <br> <br>        case 'v': <br>        case 'V': <br>            privacy = PRIVACY_VISIBLE; <br>            break; <br> <br>        case '-': <br>            if( (argv[i][2] == 'v') <br>                || (argv[i][2] == 'V')) <br>                privacy = PRIVACY_NOT_VISIBLE; <br>            else <br>                printf("Unknown Parameter=%s %s\n",argv[i-1],argv[i]); <br>            break; <br> <br>        case 'q': <br>        case 'Q': <br>            ClientToServerFlag|=0x80000000; <br>            break; <br> <br>        case 'u': <br>        case 'U': <br>            if ( (argv[i][2] == 'd') || <br>                 (argv[i][2] == 'D' ) ) <br>            { <br>                Deny = TRUE ; <br>            } <br>            else <br>            { <br>                Deny = FALSE ; <br>            } <br> <br>            i++ ; <br> <br>            if ( i &gt;= argc ) <br>            { <br>                printf( "Incomplete Param %s..Ignoring\n", argv[i-1] ); <br>                break; <br>            } <br> <br>            if ( Deny ) <br>            { <br>                if (DaclDenyNameCount == MAX_DACL_NAMES ) <br>                { <br>                    printf("Too many names specified (max %d).  Ignoring user %s\n", <br>                            MAX_DACL_NAMES, argv[i] ); <br> <br>                    break; <br>                } <br> <br>                DaclDenyNames[ DaclDenyNameCount++ ] = argv[i]; <br> <br>            } <br>            else <br>            { <br>                if (DaclNameCount == MAX_DACL_NAMES ) <br>                { <br>                    printf("Too many names specified (max %d).  Ignoring user %s\n", <br>                            MAX_DACL_NAMES, argv[i] ); <br> <br>                    break; <br>                } <br> <br>                DaclNames[ DaclNameCount++ ] = argv[i]; <br> <br>            } <br> <br>            break; <br> <br>        case '2': <br>            bForceTwoPipes = TRUE; <br>            break; <br> <br>        default: <br>            printf("Unknown Parameter=%s %s\n",argv[i-1],argv[i]); <br>            break; <br> <br>        } <br> <br>    } <br> <br>    // <br>    //Now Set various Parameters <br>    // <br> <br>    // <br>    //Colors <br>    // <br> <br>    SetColor(wAttrib); <br> <br>    if (RunType==RUNTYPE_CLIENT) <br>    { <br>        BOOL done=FALSE; <br>        BOOL gotinfo; <br> <br>        // <br>        // Set Client end defaults and start client <br>        // <br> <br>        while(!done) <br>        { <br>            if (!bPromptForArgs || <br>                (gotinfo = GetNextConnectInfo(&amp;ServerName,&amp;PipeName)) <br>               ) <br>            { <br>                sprintf(sTitle,"Remote /C %s %s",ServerName,PipeName); <br>                SetConsoleTitle(sTitle); <br> <br>                // <br>                // Start Client (Client.C) <br>                // <br>                Client(ServerName,PipeName); <br>            } <br>            done = !bPromptForArgs || !gotinfo; <br>        } <br>    } <br> <br>    if (RunType==REMOTE_SERVER) <br>    { <br>        if (privacy == PRIVACY_VISIBLE || <br>             (privacy == PRIVACY_DEFAULT &amp;&amp; IsKdString(ChildCmd))) { <br> <br>            strcat(sTitle, " visible"); <br>            IsAdvertise = TRUE; <br>        } <br> <br>        SetConsoleTitle(sTitle); <br> <br>        i = OverlappedServer(ChildCmd, PipeName); <br>    } <br> <br>    // <br>    //Reset Colors <br>    // <br>    SetColor(csbiOriginal.wAttributes); <br>    SetConsoleTitle(orgTitle); <br> <br>    return i; <br>} <br> <br>/*************************************************************/ <br>VOID <br>ErrorExit( <br>    char* str <br>    ) <br>{ <br>    extern PSZ pszPipeName; <br>    DWORD dwErr; <br> <br>    dwErr = GetLastError(); <br> <br>    printf("REMOTE error %d: %s\n", dwErr, str); <br> <br>    #if DBG <br>    { <br>        char szMsg[1024]; <br> <br>        sprintf(szMsg, "REMOTE error %d: %s\n", dwErr, str); <br>        OutputDebugString(szMsg); <br> <br>        if (pszPipeName) {               // ad-hoc:  if server <br>            if (IsDebuggerPresent()) { <br>                DebugBreak(); <br>            } <br>        } <br>    } <br>    #endif <br> <br>    exit(1); <br>} <br> <br>/*************************************************************/ <br>VOID <br>DisplayClientHlp() <br>{ <br>    printf("\n" <br>           "   To Start the CLIENT end of REMOTE\n" <br>           "   ---------------------------------\n" <br>           "   Syntax : REMOTE /C &lt;ServerName&gt; &lt;Unique Id&gt; [Param]\n" <br>           "   Example: REMOTE /C %s imbroglio\n" <br>           "            This would connect to a server session on %s with Id\n" <br>           "            \"imbroglio\" if there is a REMOTE /S &lt;\"Cmd\"&gt; imbroglio\n" <br>           "            running on %s.\n\n" <br>           "   To Exit: %cQ (Leaves the Remote Server Running)\n" <br>           "   [Param]: /L &lt;# of Lines to Get&gt;\n" <br>           "   [Param]: /F &lt;Foreground color eg blue, lred..&gt;\n" <br>           "   [Param]: /B &lt;Background color eg cyan, lwhite..&gt;\n" <br>           "\n" <br>           "   To Query the visible sessions on a server\n" <br>           "   -----------------------------------------\n" <br>           "   Syntax:  REMOTE /Q %s\n" <br>           "            This would retrieve the available &lt;Unique Id&gt;s\n" <br>           "            visible connections on the computer named %s.\n" <br>           "\n", <br>           HostName, HostName, HostName, COMMANDCHAR, HostName, HostName); <br>} <br>/*************************************************************/ <br> <br>VOID <br>DisplayServerHlp() <br>{ <br>    printf("\n" <br>           "   To Start the SERVER end of REMOTE\n" <br>           "   ---------------------------------\n" <br>           "   Syntax : REMOTE /S &lt;\"Cmd\"&gt;     &lt;Unique Id&gt; [Param]\n" <br>           "   Example: REMOTE /S \"i386kd -v\" imbroglio\n" <br>           "            To interact with this \"Cmd\" from some other machine,\n" <br>           "            start the client end using:  REMOTE /C %s imbroglio\n\n" <br>           "   To Exit: %cK \n" <br>           "   [Param]: /F  &lt;Foreground color eg yellow, black..&gt;\n" <br>           "   [Param]: /B  &lt;Background color eg lblue, white..&gt;\n" <br>           "   [Param]: /U  username or groupname\n" <br>           "                specifies which users or groups may connect\n" <br>           "                may be specified more than once, e.g\n" <br>           "                /U user1 /U group2 /U user2\n" <br>           "   [Param]: /UD username or groupname\n" <br>           "                specifically denies access to that user or group\n" <br>           "   [Param]: /V  Makes this session visible to remote /Q\n" <br>           "   [Param]: /-V Hides this session from remote /q (invisible)\n" <br>           "                By default, if \"Cmd\" looks like a debugger,\n" <br>           "                the session is visible, otherwise not\n" <br>           "\n", <br>           HostName, COMMANDCHAR); <br>} <br> <br>WORD <br>GetColorNum( <br>    char *color <br>    ) <br>{ <br>    int i; <br> <br>    _strlwr(color); <br>    for (i=0;i&lt;16;i++) <br>    { <br>        if (strcmp(ColorList[i],color)==0) <br>        { <br>            return(i); <br>        } <br>    } <br>    return ((WORD)atoi(color)); <br>} <br> <br>VOID <br>SetColor( <br>    WORD attr <br>    ) <br>{ <br>    COORD  origin={0,0}; <br>    DWORD  dwrite; <br>    FillConsoleOutputAttribute <br>    ( <br>        MyStdOut,attr,csbiOriginal.dwSize. <br>        X*csbiOriginal.dwSize.Y,origin,&amp;dwrite <br>    ); <br>    SetConsoleTextAttribute(MyStdOut,attr); <br>} <br> <br>BOOL <br>GetNextConnectInfo( <br>    char** SrvName, <br>    char** PipeName <br>    ) <br>{ <br>    char *s; <br>    static char szServerName[64]; <br>    static char szPipeName[32]; <br> <br>    try <br>    { <br>        ZeroMemory(szServerName,64); <br>        ZeroMemory(szPipeName,32); <br>        SetConsoleTitle("Remote - Prompting for next Connection"); <br>        printf("Debugger machine (server): "); <br>        fflush(stdout); <br> <br>        if (((*SrvName=gets(szServerName))==NULL)|| <br>             (strlen(szServerName)==0)) <br>        { <br>            return(FALSE); <br>        } <br> <br>        if (szServerName[0] == COMMANDCHAR &amp;&amp; <br>            (szServerName[1] == 'q' || szServerName[1] == 'Q') <br>           ) <br>        { <br>            return(FALSE); <br>        } <br> <br>        if (s = strchr( szServerName, ' ' )) { <br>            *s++ = '\0'; <br>            while (*s == ' ') { <br>                s += 1; <br>            } <br>            *PipeName=strcpy(szPipeName, s); <br>            printf(szPipeName); <br>            fflush(stdout); <br>        } <br>        if (strlen(szPipeName) == 0) { <br>            printf("Target machine (pipe)    : "); <br>            fflush(stdout); <br>            if ((*PipeName=gets(szPipeName))==NULL) <br>            { <br>                return(FALSE); <br>            } <br>        } <br> <br>        if (s = strchr(szPipeName, ' ')) { <br>            *s++ = '\0'; <br>        } <br> <br>        if (szPipeName[0] == COMMANDCHAR &amp;&amp; <br>            (szPipeName[1] == 'q' || szPipeName[1] == 'Q') <br>           ) <br>        { <br>            return(FALSE); <br>        } <br>        printf("\n\n"); <br>    } <br> <br>    except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        return(FALSE);  // Ignore exceptions <br>    } <br>    return(TRUE); <br>} <br> <br> <br>/*************************************************************/ <br> <br>VOID <br>Errormsg( <br>    char* str <br>    ) <br>{ <br>    printf("Error (%d) - %s\n",GetLastError(),str); <br>} <br> <br>/*************************************************************/ <br> <br>BOOL <br>IsKdString( <br>    char* string <br>    ) <br>{ <br> <br>    char* start; <br> <br>    // <br>    // some heuristic for uninvented yet platforms <br>    // if the first word has "kd" in it ok <br>    // <br> <br>    if(    ((start = strstr(string, "kd")) != NULL) <br>        || ((start = strstr(string, "dbg")) != NULL) <br>        || ((start = strstr(string, "remoteds")) != NULL) <br>        || ((start = strstr(string, "ntsd")) != NULL) <br>        || ((start = strstr(string, "cdb")) != NULL) ) <br>    { <br>        // is it in the first word? <br>        while(--start &gt; string) <br>        { <br>            if((*start == ' ') || (*start == '\t')) <br>            { <br>                while(--start &gt; string) <br>                    if((*start != '\t') || (*start != ' ')) <br>                        return(FALSE); <br>            } <br>        } <br>        return TRUE; <br>    } <br>    return(FALSE); <br>} <br> <br> <br>// <br>// WriteFileSynch is a synchronous WriteFile for overlapped <br>// file handles.  As a special case, two-pipe client operation <br>// sets fAsyncPipe FALSE and this routine then passes NULL <br>// for lpOverlapped. <br>// <br> <br>BOOL <br>FASTCALL <br>WriteFileSynch( <br>    HANDLE  hFile, <br>    LPVOID  lpBuffer, <br>    DWORD   cbWrite, <br>    LPDWORD lpNumberOfBytesWritten, <br>    DWORD   dwFileOffset, <br>    LPOVERLAPPED lpO <br>    ) <br>{ <br>    BOOL Success; <br> <br> <br>    lpO-&gt;OffsetHigh = 0; <br>    lpO-&gt;Offset = dwFileOffset; <br> <br>    Success = <br>        WriteFile( <br>            hFile, <br>            lpBuffer, <br>            cbWrite, <br>            lpNumberOfBytesWritten, <br>            fAsyncPipe ? lpO : NULL <br>            ); <br> <br>    if ( ! Success ) { <br> <br>        if (ERROR_IO_PENDING == GetLastError()) { <br> <br>            Success = <br>                GetOverlappedResult( <br>                    hFile, <br>                    lpO, <br>                    lpNumberOfBytesWritten, <br>                    TRUE <br>                    ); <br>        } <br>    } <br> <br>    return Success; <br>} <br> <br> <br>BOOL <br>FASTCALL <br>ReadFileSynch( <br>    HANDLE  hFile, <br>    LPVOID  lpBuffer, <br>    DWORD   cbRead, <br>    LPDWORD lpNumberOfBytesRead, <br>    DWORD   dwFileOffset, <br>    LPOVERLAPPED lpO <br>    ) <br>{ <br>    BOOL Success; <br> <br>    lpO-&gt;OffsetHigh = 0; <br>    lpO-&gt;Offset = dwFileOffset; <br> <br>    Success = <br>        ReadFile( <br>            hFile, <br>            lpBuffer, <br>            cbRead, <br>            lpNumberOfBytesRead, <br>            fAsyncPipe ? lpO : NULL <br>            ); <br> <br>    if ( ! Success ) { <br> <br>        if (ERROR_IO_PENDING == GetLastError()) { <br> <br>            Success = <br>                GetOverlappedResult( <br>                    hFile, <br>                    lpO, <br>                    lpNumberOfBytesRead, <br>                    TRUE <br>                    ); <br>        } <br>    } <br> <br>    return Success; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
