<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SRVUTIL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5744"></a>SRVUTIL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1995 - 1997 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    SrvUtil.c <br> <br>Abstract: <br> <br>    The server component of Remote. It spawns a child process <br>    and redirects the stdin/stdout/stderr of child to itself. <br>    Waits for connections from clients - passing the <br>    output of child process to client and the input from clients <br>    to child process. <br> <br>Author: <br> <br>    Rajivendra Nath  2-Jan-1992 <br>    Dave Hart  30 May 1997 split from Server.c <br> <br>Environment: <br> <br>    Console App. User mode. <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;process.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;string.h&gt; <br>#include "Remote.h" <br>#include "Server.h" <br> <br> <br>#define COMMANDFORMAT     "%c%-20s    [%-12s %s]\n%08x%c" <br>#define CMDSTRING(OutBuff,OutSize,InpBuff,Client,szTime,ForceShow) \ <br>{                                                                  \ <br>    char *pch;                                                     \ <br>                                                                   \ <br>    for (pch = InpBuff;                                            \ <br>         *pch;                                                     \ <br>         pch++) {                                                  \ <br>                                                                   \ <br>        if (ENDMARK == *pch ||                                     \ <br>            BEGINMARK == *pch) {                                   \ <br>                                                                   \ <br>            *pch = '`';                                            \ <br>        }                                                          \ <br>    }                                                              \ <br>                                                                   \ <br>    OutSize =                                                      \ <br>        sprintf(                                                   \ <br>            (OutBuff),                                             \ <br>            COMMANDFORMAT,                                         \ <br>            BEGINMARK,                                             \ <br>            (InpBuff),                                             \ <br>            (Client)-&gt;Name,                                        \ <br>            (szTime),                                              \ <br>            (ForceShow) ? 0 : (Client)-&gt;dwID,                      \ <br>            ENDMARK                                                \ <br>            );                                                     \ <br>} <br> <br> <br>/*************************************************************/ <br>// GetFormattedTime -- returns pointer to formatted time <br>// <br>// returns pointer to static buffer, only the main thread <br>// should use this. <br>// <br> <br>PCHAR <br>GetFormattedTime( <br>    BOOL bDateToo <br>    ) <br>{ <br>    static char szTime[64]; <br>    int cch = 0; <br> <br>    if (bDateToo) { <br> <br>        cch = <br>            GetDateFormat( <br>                LOCALE_USER_DEFAULT, <br>                0, <br>                NULL,    // current date <br>                "ddd",   // short day of week <br>                szTime, <br>                sizeof szTime <br>                ); <br> <br>        // cch includes null terminator, change it to <br>        // a space to separate from time. <br> <br>        szTime[ cch - 1 ] = ' '; <br>    } <br> <br>    // <br>    // Get time and format to characters <br>    // <br> <br>    GetTimeFormat( <br>        LOCALE_USER_DEFAULT, <br>        TIME_NOSECONDS, <br>        NULL,   // use current time <br>        NULL,   // use default format <br>        szTime + cch, <br>        (sizeof szTime) - cch ); <br> <br>    return szTime; <br>} <br> <br>/*************************************************************/ <br> <br>BOOL <br>FilterCommand( <br>    REMOTE_CLIENT *cl, <br>    char *buff, <br>    int dread <br>    ) <br>{ <br>    char       tmpchar; <br>    DWORD      tmp; <br>    int        len; <br>    DWORD      ThreadID; <br>    char       inp_buff[2048]; <br>    char       ch[3]; <br> <br>    if (dread==0) <br>        return(FALSE); <br> <br>    buff[dread]=0; <br> <br>    if (buff[0]==COMMANDCHAR) <br>    { <br> <br>        switch(buff[1]) <br>        { <br>        case 'k': <br>        case 'K': <br> <br>                if (INVALID_HANDLE_VALUE != hWriteChildStdIn) { <br> <br>                    printf("Remote: killing child softly, @K again to be more convincing.\n"); <br> <br>                    CANCELIO( hWriteChildStdIn ); <br>                    CloseHandle( hWriteChildStdIn ); <br>                    hWriteChildStdIn = INVALID_HANDLE_VALUE; <br> <br>                    GenerateConsoleCtrlEvent(CTRL_CLOSE_EVENT, 0); <br>                    SleepEx(200, TRUE); <br>                    cPendingCtrlCEvents++; <br>                    GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0); <br>                    SleepEx(20, TRUE); <br>                    GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, 0); <br> <br>                } else { <br> <br>                    printf("Remote: Resorting to TerminateProcess.\n"); <br> <br>                    TerminateProcess(ChldProc, ERROR_PROCESS_ABORTED); <br>                } <br> <br> <br>                 break; <br>        case 's': <br>        case 'S': <br>                CloseHandle( (HANDLE) <br>                    _beginthreadex( <br>                        NULL,             // security <br>                        0,                // default stack size <br>                        SendStatus, <br>                        (void *) cl-&gt;PipeWriteH, <br>                        0,                // not suspended <br>                        &amp;ThreadID <br>                        )); <br>                break; <br> <br>        case 'p': <br>        case 'P': <br>            { <br>                char  *msg; <br> <br>                msg = HeapAlloc(                    // freed by ShowPopup <br>                          hHeap, <br>                          HEAP_ZERO_MEMORY, <br>                          4096 <br>                          ); <br> <br> <br>                if ( ! msg) { <br>                    break; <br>                } <br> <br>                sprintf(msg,"From %s %s [%s]\n\n%s\n",cl-&gt;Name,cl-&gt;UserName,GetFormattedTime(TRUE),&amp;buff[2]); <br> <br>                if (WriteFileSynch(hWriteTempFile,msg,strlen(msg),&amp;tmp,dwWriteFilePointer,&amp;olMainThread)) { <br>                    dwWriteFilePointer += tmp; <br>                    StartServerToClientFlow(); <br>                } <br> <br>                CloseHandle( (HANDLE) <br>                    CreateThread(                              // no CRT for ShowPopup <br>                        NULL,             // security <br>                        0,                // default stack size <br>                        ShowPopup, <br>                        (void *) msg, <br>                        0,                // not suspended <br>                        &amp;ThreadID <br>                        )); <br> <br>                break; <br>             } <br> <br>        case 'm': <br>        case 'M': <br>                buff[dread-2]=0; <br>                CMDSTRING(inp_buff,len,buff,cl,GetFormattedTime(TRUE),TRUE); <br> <br>                if (WriteFileSynch(hWriteTempFile,inp_buff,len,&amp;tmp,dwWriteFilePointer,&amp;olMainThread)) { <br>                    dwWriteFilePointer += tmp; <br>                    StartServerToClientFlow(); <br>                } <br>                break; <br> <br>        case '@': <br>                buff[dread-2]=0; <br>                CMDSTRING(inp_buff,len,&amp;buff[1],cl,GetFormattedTime(FALSE),FALSE); <br>                if (WriteFileSynch(hWriteTempFile,inp_buff,len,&amp;tmp,dwWriteFilePointer,&amp;olMainThread)) { <br>                    dwWriteFilePointer += tmp; <br>                    StartServerToClientFlow(); <br>                } <br>                // <br>                // Remove the first @ sign <br>                // <br>                MoveMemory(buff,&amp;buff[1],dread-1); <br>                buff[dread-1]=' '; <br>                return(FALSE); //Send it it to the chile process <br> <br> <br>        default : <br>                sprintf(inp_buff,"%s","** Unknown Command **\n"); <br>                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&amp;tmp,dwWriteFilePointer,&amp;olMainThread)) { <br>                    dwWriteFilePointer += tmp; <br>                    // we do this below // StartServerToClientFlow(); <br>                } <br>        case 'h': <br>        case 'H': <br>                sprintf(inp_buff,"%cM: To Send Message\n",COMMANDCHAR); <br>                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&amp;tmp,dwWriteFilePointer,&amp;olMainThread)) { <br>                    dwWriteFilePointer += tmp; <br>                } <br>                sprintf(inp_buff,"%cP: To Generate popup\n",COMMANDCHAR); <br>                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&amp;tmp,dwWriteFilePointer,&amp;olMainThread)) { <br>                    dwWriteFilePointer += tmp; <br>                } <br>                sprintf(inp_buff,"%cK: To kill the server\n",COMMANDCHAR); <br>                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&amp;tmp,dwWriteFilePointer,&amp;olMainThread)) { <br>                    dwWriteFilePointer += tmp; <br>                } <br>                sprintf(inp_buff,"%cH: This Help\n",COMMANDCHAR); <br>                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&amp;tmp,dwWriteFilePointer,&amp;olMainThread)) { <br>                    dwWriteFilePointer += tmp; <br>                } <br>                StartServerToClientFlow(); <br>                break; <br>        } <br>        return(TRUE); <br>    } <br> <br> <br>    if ((buff[0]&lt;26)) <br>    { <br>        BOOL ret=FALSE; <br> <br>        sprintf(ch, "^%c", buff[0] + 'A' - 1); <br> <br> <br>        if (buff[0]==CTRLC) <br>        { <br>            // show this even to this client <br>            CMDSTRING(inp_buff,len,ch,cl,GetFormattedTime(FALSE),TRUE); <br> <br>            cPendingCtrlCEvents++; <br>            GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0); <br>            ret = TRUE;  // Already sent to child <br> <br>        } else { <br> <br>            CMDSTRING(inp_buff,len,ch,cl,GetFormattedTime(FALSE),FALSE); <br>        } <br> <br>        if (WriteFileSynch(hWriteTempFile,inp_buff,len,&amp;tmp,dwWriteFilePointer,&amp;olMainThread)) { <br>            dwWriteFilePointer += tmp; <br>            StartServerToClientFlow(); <br>        } <br>        return(ret); //FALSE:send it to child StdIn <br>    } <br> <br> <br>    tmpchar=buff[dread-2]; //must be 13;but just incase <br>    buff[dread-2]=0; <br>    CMDSTRING(inp_buff,len,buff,cl,GetFormattedTime(FALSE),FALSE); <br>    buff[dread-2]=tmpchar; <br>    if (WriteFileSynch(hWriteTempFile,inp_buff,len,&amp;tmp,dwWriteFilePointer,&amp;olMainThread)) { <br>        dwWriteFilePointer += tmp; <br>        StartServerToClientFlow(); <br>    } <br>    return(FALSE); <br>} <br> <br>/*************************************************************/ <br>HANDLE <br>ForkChildProcess(           // Creates a new process <br>    char *cmd,              // Redirects its stdin,stdout <br>    PHANDLE inH,            // and stderr - returns the <br>    PHANDLE outH            // corresponding pipe ends. <br>    ) <br> <br>{ <br>    SECURITY_ATTRIBUTES lsa; <br>    STARTUPINFO         si; <br>    PROCESS_INFORMATION pi; <br>    HANDLE ChildIn; <br>    HANDLE ChildOut, ChildOutDup; <br>    HANDLE hWriteChild; <br>    HANDLE hReadChild; <br>    BOOL Success; <br> <br>    BOOL                                     // pipeex.c <br>    APIENTRY <br>    MyCreatePipeEx( <br>        OUT LPHANDLE lpReadPipe, <br>        OUT LPHANDLE lpWritePipe, <br>        IN LPSECURITY_ATTRIBUTES lpPipeAttributes, <br>        IN DWORD nSize, <br>        DWORD dwReadMode, <br>        DWORD dwWriteMode <br>        ); <br> <br> <br> <br>    lsa.nLength=sizeof(SECURITY_ATTRIBUTES); <br>    lsa.lpSecurityDescriptor=NULL; <br>    lsa.bInheritHandle=TRUE; <br> <br>    // <br>    // Create Parent_Write to ChildStdIn Pipe.  Then <br>    // duplicate the parent copy to a noninheritable <br>    // handle and close the inheritable one so that <br>    // the child won't be holding open a handle to <br>    // the server end of its stdin pipe when we try <br>    // to nuke that pipe to close the child. <br>    // <br> <br>    Success = MyCreatePipeEx( <br>                  &amp;ChildIn, <br>                  &amp;hWriteChild, <br>                  &amp;lsa, <br>                  0, <br>                  0, <br>                  FILE_FLAG_OVERLAPPED) &amp;&amp; <br> <br>              DuplicateHandle( <br>                  GetCurrentProcess(), <br>                  hWriteChild, <br>                  GetCurrentProcess(), <br>                  inH, <br>                  0,                       // ignored b/c SAME_ACCESS <br>                  FALSE,                   // not inheritable <br>                  DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE <br>                  ); <br> <br>    if (!Success) { <br>        ErrorExit("Could Not Create Parent--&gt;Child Pipe"); <br>    } <br> <br>    // <br>    //Create ChildStdOut/stderr to Parent_Read pipe <br>    // <br> <br>    Success = MyCreatePipeEx( <br>                  &amp;hReadChild, <br>                  &amp;ChildOut, <br>                  &amp;lsa, <br>                  0, <br>                  FILE_FLAG_OVERLAPPED, <br>                  0) &amp;&amp; <br> <br>              DuplicateHandle( <br>                  GetCurrentProcess(), <br>                  hReadChild, <br>                  GetCurrentProcess(), <br>                  outH, <br>                  0,                       // ignored b/c SAME_ACCESS <br>                  FALSE,                   // not inheritable <br>                  DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE <br>                  ) &amp;&amp; <br> <br>              DuplicateHandle( <br>                  GetCurrentProcess(), <br>                  ChildOut, <br>                  GetCurrentProcess(), <br>                  &amp;ChildOutDup, <br>                  0,                       // ignored b/c SAME_ACCESS <br>                  TRUE,                    // inheritable <br>                  DUPLICATE_SAME_ACCESS <br>                  ); <br> <br>    if (!Success) { <br>        ErrorExit("Could Not Create Child--&gt;Parent Pipe"); <br>    } <br> <br>    ZeroMemory(&amp;si, sizeof(si)); <br>    si.cb            = sizeof(STARTUPINFO); <br>    si.dwFlags       = STARTF_USESTDHANDLES; <br>    si.hStdInput     = ChildIn; <br>    si.hStdOutput    = ChildOut; <br>    si.hStdError     = ChildOutDup; <br>    si.wShowWindow   = SW_SHOW; <br> <br>    // <br>    // Create Child Process <br>    // <br> <br>    if ( ! CreateProcess( <br>               NULL, <br>               cmd, <br>               NULL, <br>               NULL, <br>               TRUE, <br>               GetPriorityClass( GetCurrentProcess() ), <br>               NULL, <br>               NULL, <br>               &amp;si, <br>               &amp;pi)) { <br> <br>        if (GetLastError()==2) { <br>            printf("Executable %s not found\n",cmd); <br>        } else { <br>            printf("CreateProcess(%s) failed, error %d.\n", cmd, GetLastError()); <br>        } <br>        ErrorExit("Could Not Create Child Process"); <br>    } <br> <br>    // <br>    // Close unneccesary Handles <br>    // <br> <br>    CloseHandle(ChildIn); <br>    CloseHandle(ChildOut); <br>    CloseHandle(ChildOutDup); <br>    CloseHandle(pi.hThread); <br> <br>    pidChild = pi.dwProcessId; <br> <br>    return(pi.hProcess); <br>} <br> <br>// <br>// SendStatus runs as its own thread, with C runtime available. <br>// <br> <br>DWORD <br>WINAPI <br>SendStatus( <br>    LPVOID   lpSendStatusParm <br>    ) <br>{ <br>    HANDLE hClientPipe = (HANDLE) lpSendStatusParm; <br>    char *pch; <br>    DWORD tmp; <br>    PREMOTE_CLIENT pClient; <br>    OVERLAPPED ol; <br>    char  buff[2048]; <br>    char szSep[] = " ------------------------------\n"; <br> <br>    // <br>    // Since we're in our own thread we need our own <br>    // overlapped structure for our client pipe writes. <br>    // <br> <br>    ZeroMemory(&amp;ol, sizeof(ol)); <br> <br>    ol.hEvent = <br>        CreateEvent( <br>            NULL,      // security <br>            TRUE,      // auto-reset <br>            FALSE,     // initially nonsignaled <br>            NULL       // unnamed <br>            ); <br> <br> <br>    // <br>    // Dump the closing client list <br>    // <br> <br>    pch = buff; <br> <br>    EnterCriticalSection(&amp;csClosingClientList); <br> <br>    for (pClient = (PREMOTE_CLIENT) ClosingClientListHead.Flink; <br>         pClient != (PREMOTE_CLIENT) &amp;ClosingClientListHead; <br>         pClient = (PREMOTE_CLIENT) pClient-&gt;Links.Flink ) { <br> <br>         if (pch + 60 &gt; buff + sizeof(buff)) { <br> <br>            break; <br>         } <br> <br>         pch += sprintf(pch, "%d: %s %s (Disconnected)\n", pClient-&gt;dwID, pClient-&gt;Name, pClient-&gt;UserName); <br>    } <br> <br>    LeaveCriticalSection(&amp;csClosingClientList); <br> <br>    WriteFileSynch(hClientPipe, buff, pch - buff, &amp;tmp, 0, &amp;ol); <br> <br>    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &amp;tmp, 0, &amp;ol); <br> <br> <br>    // <br>    // Dump the normal client list <br>    // <br> <br>    pch = buff; <br> <br>    EnterCriticalSection(&amp;csClientList); <br> <br>    for (pClient = (PREMOTE_CLIENT) ClientListHead.Flink; <br>         pClient != (PREMOTE_CLIENT) &amp;ClientListHead; <br>         pClient = (PREMOTE_CLIENT) pClient-&gt;Links.Flink ) { <br> <br>         if (pch + 60 &gt; buff + sizeof(buff)) { <br> <br>            break; <br>         } <br> <br>         pch += sprintf(pch, "%d: %s %s\n", pClient-&gt;dwID, pClient-&gt;Name, pClient-&gt;UserName); <br>    } <br> <br>    LeaveCriticalSection(&amp;csClientList); <br> <br>    WriteFileSynch(hClientPipe, buff, pch - buff, &amp;tmp, 0, &amp;ol); <br> <br>    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &amp;tmp, 0, &amp;ol); <br> <br> <br> <br>    // <br>    // Dump the handshaking client list <br>    // <br> <br>    pch = buff; <br> <br>    EnterCriticalSection(&amp;csHandshakingList); <br> <br>    for (pClient = (PREMOTE_CLIENT) HandshakingListHead.Flink; <br>         pClient != (PREMOTE_CLIENT) &amp;HandshakingListHead; <br>         pClient = (PREMOTE_CLIENT) pClient-&gt;Links.Flink ) { <br> <br>         if (pch + 60 &gt; buff + sizeof(buff)) { <br> <br>            break; <br>         } <br> <br>         pch += sprintf(pch, "%d: %s %s (Connecting)\n", pClient-&gt;dwID, pClient-&gt;Name, pClient-&gt;UserName); <br>    } <br> <br>    LeaveCriticalSection(&amp;csHandshakingList); <br> <br>    WriteFileSynch(hClientPipe, buff, pch - buff, &amp;tmp, 0, &amp;ol); <br> <br>    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &amp;tmp, 0, &amp;ol); <br> <br> <br>    // <br>    // Dump summary information. <br>    // <br> <br>    pch = buff; <br> <br>    pch += sprintf(pch, "REMOTE /C %s %s\n", HostName, PipeName); <br>    pch += sprintf(pch, "Command: %s\n", ChildCmd); <br>    pch += sprintf(pch, "Windows NT %d.%d build %d \n", <br>                   OsVersionInfo.dwMajorVersion, <br>                   OsVersionInfo.dwMinorVersion, <br>                   OsVersionInfo.dwBuildNumber); <br> <br>    WriteFileSynch(hClientPipe, buff, pch - buff, &amp;tmp, 0, &amp;ol); <br> <br>    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &amp;tmp, 0, &amp;ol); <br> <br>    CloseHandle(ol.hEvent); <br> <br>    return 0; <br>} <br> <br>/*************************************************************/ <br> <br>DWORD                // NO CRT for ShowPopup <br>WINAPI <br>ShowPopup( <br>    void *vpArg <br>    ) <br>{ <br>    char *msg = (char *) vpArg; <br> <br>    MessageBox(GetActiveWindow(),msg,"** REMOTE.EXE **",MB_OK|MB_SETFOREGROUND); <br>    HeapFree(hHeap, 0, msg); <br>    return(0); <br> <br>} <br> <br>/*************************************************************/ <br> <br>// <br>// SrvCtrlHand is the console event handler for the server side <br>// of remote.  If our stdin is a console handle, we've disabled <br>// generation of ^C events by the console code.  Therefore <br>// any we see are either generated by us for the benefit of <br>// our child processes sharing the console, or generated by <br>// some other process.  We want to ignore the ones we generate <br>// (since we're already done with everything that needs to be <br>// done at that point), and also ignore ^C's generated by <br>// other processes since we don't need to do anything with those. <br>// For example if someone runs: <br>// <br>// remote /s "remote /s cmd inner" outer <br>// <br>// Then local keyboard ^C's will be read by the outer remote.exe <br>// from its stdin handle, then it will generate a CTRL_C_EVENT that <br>// all processes in the console will see, including both remote.exe's <br>// and the child cmd.exe.  So the handler needs do nothing but indicate <br>// the event was handled by returning TRUE so the default handler <br>// won't kill us.  For ^BREAK we want to specifically kill our child <br>// process so that cmd.exe and others that ignore ^BREAK will go away. <br>// Of course this won't kill our grandchildren and so on.  Oh well. <br>// <br>// For all other events we return FALSE and let the default handler <br>// have it. <br>// <br> <br>BOOL <br>WINAPI <br>SrvCtrlHand( <br>    DWORD event <br>    ) <br>{ <br>    BOOL bRet = FALSE; <br>    DWORD cb; <br>    DWORD dwTempFileOffset; <br>    OVERLAPPED ol; <br>    char szTime[64]; <br>    char szCmd[128]; <br> <br>    if (event == CTRL_BREAK_EVENT) { <br> <br>        TerminateProcess(ChldProc, 3); <br>        bRet = TRUE; <br> <br>    } else if (event == CTRL_C_EVENT) { <br> <br>        if ( ! cPendingCtrlCEvents ) { <br> <br>            // <br>            // This came from the local keyboard or <br>            // was generated by another process in <br>            // this console.  Echo it as a local <br>            // command.  We have use GetTimeFormat <br>            // here not our GetFormattedTime since <br>            // the latter is for the use of the <br>            // main thread only. <br>            // <br> <br>            GetTimeFormat( <br>                LOCALE_USER_DEFAULT, <br>                TIME_NOSECONDS, <br>                NULL,   // use current time <br>                NULL,   // use default format <br>                szTime, <br>                sizeof(szTime) <br>                ); <br> <br>            CMDSTRING(szCmd, cb, "^C", pLocalClient, szTime, TRUE); <br> <br>            ZeroMemory(&amp;ol, sizeof(ol)); <br>            ol.hEvent = <br>                CreateEvent( <br>                    NULL,      // security <br>                    TRUE,      // auto-reset <br>                    FALSE,     // initially nonsignaled <br>                    NULL       // unnamed <br>                    ); <br> <br>            // <br>            // Practically all writes to the tempfile are happening on <br>            // the primary server thread.  We're on a Ctrl-C thread. <br>            // We can't start the server to client I/O going after <br>            // writing because we're on the wrong thread, so we <br>            // punt.  To fix this we need an event we can signal <br>            // that causes the main thread to call StartServerToClientFlow. <br>            // <br> <br>            dwTempFileOffset = dwWriteFilePointer; <br>            dwWriteFilePointer += cb; <br>            WriteFileSynch(hWriteTempFile, szCmd, cb, &amp;cb, dwTempFileOffset, &amp;ol); <br>            // wrong thread // StartServerToClientFlow(); <br> <br>            CloseHandle(ol.hEvent); <br> <br>        } else { <br> <br>            // <br>            // We generated this event in response to a ^C received from <br>            // a client, it's already been displayed to all clients. <br>            // <br> <br>            cPendingCtrlCEvents--; <br>        } <br> <br>        bRet = TRUE; <br> <br>    } <br> <br>    return bRet; <br>} <br> <br> <br>/*************************************************************/ <br> <br>PSECURITY_DESCRIPTOR <br>FormatSecurityDescriptor( <br>    CHAR * * DenyNames, <br>    DWORD    DenyCount, <br>    CHAR * * Names, <br>    DWORD    Count) <br>{ <br>    PSECURITY_DESCRIPTOR    Sd; <br>    PACL    Acl; <br>    DWORD   i; <br>    PSID    Sids; <br>    DWORD   SidLength ; <br>    CHAR    ReferencedDomain[ MAX_PATH ]; <br>    UCHAR   SidBuffer[ 8 * sizeof(DWORD) + 8 ]; <br>    DWORD   DomainLen ; <br>    SID_NAME_USE    Use; <br>    DWORD   SdLen; <br> <br> <br>    SdLen = sizeof(SECURITY_DESCRIPTOR) + <br>                        DenyCount * (sizeof( ACCESS_DENIED_ACE ) ) + <br>                        DenyCount * GetSidLengthRequired( 8 ) + <br>                        Count * (sizeof( ACCESS_ALLOWED_ACE ) ) + sizeof(ACL) + <br>                        (Count * GetSidLengthRequired( 8 ) ); <br> <br>    Sd = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, SdLen ); <br> <br>    if ( !Sd ) <br>    { <br>        ErrorExit("Could not allocate SD"); <br>    } <br> <br>    InitializeSecurityDescriptor( Sd, SECURITY_DESCRIPTOR_REVISION ); <br> <br>    Acl = (PACL)( (PUCHAR) Sd + sizeof( SECURITY_DESCRIPTOR) ); <br> <br>    InitializeAcl( Acl, SdLen - sizeof( SECURITY_DESCRIPTOR) , <br>                    ACL_REVISION ); <br> <br>    Sids = SidBuffer; <br>    for (i = 0 ; i &lt; DenyCount ; i ++ ) <br>    { <br>        SidLength = sizeof( SidBuffer ); <br> <br>        DomainLen = MAX_PATH ; <br> <br>        if (! LookupAccountName(NULL, <br>                                DenyNames[ i ], <br>                                Sids, <br>                                &amp;SidLength, <br>                                ReferencedDomain, <br>                                &amp;DomainLen, <br>                                &amp;Use ) ) <br>        { <br>            _snprintf( ReferencedDomain, MAX_PATH, "Unable to find account %s", DenyNames[ i ]); <br>            ErrorExit( ReferencedDomain ); <br>        } <br> <br>        // <br>        // Got the sid.  Now, add it as an access denied ace: <br>        // <br> <br>        AddAccessDeniedAce( Acl, <br>                            ACL_REVISION, <br>                            FILE_GENERIC_READ | <br>                                FILE_GENERIC_WRITE | <br>                                FILE_CREATE_PIPE_INSTANCE, <br>                            Sids ); <br> <br> <br>    } <br> <br>    for (i = 0 ; i &lt; Count ; i ++ ) <br>    { <br>        SidLength = sizeof( SidBuffer ); <br> <br>        DomainLen = MAX_PATH ; <br> <br>        if (! LookupAccountName(NULL, <br>                                Names[ i ], <br>                                Sids, <br>                                &amp;SidLength, <br>                                ReferencedDomain, <br>                                &amp;DomainLen, <br>                                &amp;Use ) ) <br>        { <br>            _snprintf( ReferencedDomain, MAX_PATH, "Unable to find account %s", Names[ i ]); <br>            ErrorExit( ReferencedDomain ); <br>        } <br> <br>        // <br>        // Got the sid.  Now, add it as an access allowed ace: <br>        // <br> <br>        AddAccessAllowedAce(Acl, <br>                            ACL_REVISION, <br>                            FILE_GENERIC_READ | <br>                                FILE_GENERIC_WRITE | <br>                                FILE_CREATE_PIPE_INSTANCE, <br>                            Sids ); <br> <br> <br>    } <br> <br>    // <br>    // Now the ACL should be complete, so set it into the SD and return: <br>    // <br> <br>    SetSecurityDescriptorDacl( Sd, TRUE, Acl, FALSE ); <br> <br>    return Sd ; <br> <br>} <br> <br> <br>/*************************************************************/ <br> <br>VOID <br>CloseClient( <br>    REMOTE_CLIENT *pClient <br>    ) <br>{ <br>    DWORD tmp; <br>    char  Buf[200]; <br> <br>    #if DBG <br>        if (pClient-&gt;ServerFlags &amp; ~SFLG_VALID) { <br> <br>            printf("pClient %x looks nasty in CloseClient.\n", pClient); <br>            ErrorExit("REMOTE_CLIENT structure corrupt."); <br>        } <br>    #endif <br> <br> <br>    // <br>    // If we're still active (on the normal client list) <br>    // start tearing things down and move to the closing <br>    // list. <br>    // <br> <br>    if (pClient-&gt;ServerFlags &amp; SFLG_CLOSING) { <br> <br>        return; <br>    } <br> <br> <br>    if (pClient-&gt;ServerFlags &amp; SFLG_HANDSHAKING) { <br> <br>        MoveClientToNormalList(pClient); <br>    } <br> <br>    MoveClientToClosingList(pClient); <br> <br>    pClient-&gt;ServerFlags |= SFLG_CLOSING; <br> <br> <br>    if (pClient-&gt;PipeWriteH != INVALID_HANDLE_VALUE) { <br> <br>        TRACE(CONNECT, ("Disconnecting %d PipeWriteH (%x).\n", pClient-&gt;dwID, pClient-&gt;PipeWriteH)); <br>        CANCELIO(pClient-&gt;PipeWriteH); <br>        DisconnectNamedPipe(pClient-&gt;PipeWriteH); <br>        CloseHandle(pClient-&gt;PipeWriteH); <br>    } <br> <br> <br>    if (pClient-&gt;PipeReadH != INVALID_HANDLE_VALUE &amp;&amp; <br>        pClient-&gt;PipeReadH != pClient-&gt;PipeWriteH) { <br> <br>        TRACE(CONNECT, ("Disconnecting %d PipeReadH (%x).\n", pClient-&gt;dwID, pClient-&gt;PipeReadH)); <br>        CANCELIO(pClient-&gt;PipeReadH); <br>        DisconnectNamedPipe(pClient-&gt;PipeReadH); <br>        CloseHandle(pClient-&gt;PipeReadH); <br>    } <br> <br> <br>    if (pClient-&gt;rSaveFile != INVALID_HANDLE_VALUE) { <br> <br>        CANCELIO(pClient-&gt;rSaveFile); <br>        CloseHandle(pClient-&gt;rSaveFile); <br>    } <br> <br>    pClient-&gt;rSaveFile = <br>        pClient-&gt;PipeWriteH = <br>            pClient-&gt;PipeReadH = <br>                INVALID_HANDLE_VALUE; <br> <br> <br>    if ( ! bShuttingDownServer ) { <br> <br>        sprintf(Buf, "\n**Remote: Disconnected from %s %s [%s]\n", pClient-&gt;Name, pClient-&gt;UserName, GetFormattedTime(TRUE)); <br> <br>        if (WriteFileSynch(hWriteTempFile,Buf,strlen(Buf),&amp;tmp,dwWriteFilePointer,&amp;olMainThread)) { <br>            dwWriteFilePointer += tmp; <br>            StartServerToClientFlow(); <br>        } <br>    } <br> <br>    return; <br>} <br> <br>BOOL <br>FASTCALL <br>HandleSessionError( <br>    PREMOTE_CLIENT pClient, <br>    DWORD         dwError <br>    ) <br>{ <br> <br>    if (pClient-&gt;ServerFlags &amp; SFLG_CLOSING) { <br> <br>        return TRUE; <br>    } <br> <br>    if (dwError) { <br> <br>        if (ERROR_BROKEN_PIPE == dwError || <br>            ERROR_OPERATION_ABORTED == dwError || <br>            ERROR_NO_DATA == dwError ) { <br> <br>            CloseClient(pClient); <br>            return TRUE; <br>        } <br> <br>        SetLastError(dwError); <br>        ErrorExit("Unhandled session error."); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>VOID <br>FASTCALL <br>CleanupTempFiles( <br>    PSZ pszTempDir <br>    ) <br>{ <br>    HANDLE          hSearch; <br>    WIN32_FIND_DATA FindData; <br>    char            szPath[MAX_PATH + 1]; </code></pre>
<p>
</p>
<pre><code>char            szFile[MAX_PATH + 1]; <br> <br>    // <br>    // pszTempDir, from GetTempPath, has a trailing backslash. <br>    // <br> <br>    sprintf(szPath, "%sREM*.tmp", pszTempDir); <br> <br>    hSearch = FindFirstFile( <br>                  szPath, <br>                  &amp;FindData <br>                  ); <br> <br>    if (INVALID_HANDLE_VALUE != hSearch) { <br> <br>        do { <br> <br>            sprintf(szFile, "%s%s", pszTempDir, FindData.cFileName); <br> <br>            DeleteFile(szFile); <br> <br>        } while (FindNextFile(hSearch, &amp;FindData)); <br> <br>        FindClose(hSearch); <br>    } <br> <br>} <br> <br> <br>VOID <br>FASTCALL <br>SetupSecurityDescriptors( <br>    VOID <br>    ) <br>{ <br>    int i; <br> <br>    // <br>    // Initialize the wide-open security descriptor. <br>    // <br> <br>    InitializeSecurityDescriptor( <br>        &amp;sdPublic, <br>        SECURITY_DESCRIPTOR_REVISION <br>        ); <br> <br>    SetSecurityDescriptorDacl( <br>        &amp;sdPublic, <br>        TRUE, <br>        NULL, <br>        FALSE <br>        ); <br> <br>    saPublic.nLength = sizeof(saPublic); <br>    saPublic.lpSecurityDescriptor = &amp;sdPublic; <br> <br> <br>    // <br>    // if /u was specified once or more, build the security descriptor to <br>    // enforce it. <br>    // <br> <br>    saPipe.nLength = sizeof(saPipe); <br> <br>    if ( DaclNameCount  || DaclDenyNameCount ) { <br> <br>        saPipe.lpSecurityDescriptor = <br>            FormatSecurityDescriptor( <br>                DaclDenyNames, <br>                DaclDenyNameCount, <br>                DaclNames, <br>                DaclNameCount <br>                ); <br> <br>        if (DaclNameCount) { <br> <br>            printf( "\nProtected Server!  Only the following users or groups can connect:\n" ); <br> <br>            for (i = 0 ; i &lt; (int) DaclNameCount ; i++) { <br> <br>                printf( "    %s\n", DaclNames[i] ); <br>            } <br>        } <br> <br>        if (DaclDenyNameCount) { <br> <br>            printf( "The following users or groups explicitly cannot connect:\n" ); <br> <br>            for (i = 0 ; i &lt; (int) DaclDenyNameCount ; i++) { <br> <br>                printf("    %s\n", DaclDenyNames[i] ); <br>            } <br>        } <br> <br> <br>    } else { <br> <br>        saPipe.lpSecurityDescriptor = &amp;sdPublic; <br>    } <br>} <br> <br> <br>VOID <br>FASTCALL <br>RuntimeLinkAPIs( <br>    VOID <br>    ) <br>{ <br>    HANDLE hmodKernel32; <br>    HANDLE hmodNetApi32; <br> <br> <br>    hmodKernel32 = LoadLibrary("kernel32"); <br>    hmodNetApi32 = LoadLibrary("netapi32"); <br> <br>    pfnCreateWaitableTimer = (void *) <br>        GetProcAddress( <br>            hmodKernel32, <br>            "CreateWaitableTimerA" <br>            ); <br> <br>    pfnSetWaitableTimer = (void *) <br>        GetProcAddress( <br>            hmodKernel32, <br>            "SetWaitableTimer" <br>            ); <br> <br>    pfnCancelWaitableTimer = (void *) <br>        GetProcAddress( <br>            hmodKernel32, <br>            "CancelWaitableTimer" <br>            ); <br> <br>    pfnCancelIo = (void *) <br>        GetProcAddress( <br>            hmodKernel32, <br>            "CancelIo" <br>            ); <br> <br>    pfnNetWkstaGetInfo = (void *) <br>        GetProcAddress( <br>            hmodNetApi32, <br>            "NetWkstaGetInfo" <br>            ); <br> <br>    pfnNetApiBufferFree = (void *) <br>        GetProcAddress( <br>            hmodNetApi32, <br>            "NetApiBufferFree" <br>            ); <br> <br>    // <br>    // We do without Waitable Timers and CancelIo on 3.51 <br>    // <br> <br>    if (!pfnNetWkstaGetInfo || <br>        !pfnNetApiBufferFree) { <br> <br>        SetLastError(ERROR_CALL_NOT_IMPLEMENTED); <br>        ErrorExit("Remote server requires Windows NT."); <br>    } <br> <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
