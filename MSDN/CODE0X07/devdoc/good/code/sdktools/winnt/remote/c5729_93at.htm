<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SRVAD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5735"></a>SRVAD.C</h2>
<pre><code>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include "Remote.h" <br>#include "Server.h" <br> <br>// <br>// This module uses mailslots to broadcast the existence of <br>// this remote server to allow a form of browsing for <br>// remote server instances.  This is disabled in the <br>// customer version of remote.exe, and can be disabled <br>// in the internal version using the /v- switch to <br>// remote /s. <br>// <br>// remoteds.c implements a listener that allows searching. <br>// <br> <br>#define  INITIAL_SLEEP_PERIOD (35 * 1000)          // 35 seconds before first <br>#define  INITIAL_AD_RATE      (10 * 60 * 1000)     // 10 minutes between 1 &amp; 2, <br>#define  MAXIMUM_AD_RATE      (120 * 60 * 1000)    // doubling until 120 minutes max <br> <br> <br>OVERLAPPED olMailslot; <br>HANDLE     hAdTimer = INVALID_HANDLE_VALUE; <br>HANDLE     hMailslot = INVALID_HANDLE_VALUE; <br>DWORD      dwTimerInterval;      // milliseconds <br>BOOL       bSynchAdOnly; <br>BOOL       bSendingToMailslot; <br>char       szMailslotName[64];    // netbios names are short <br>char       szSend[1024]; <br> <br> <br>#define MAX_MAILSLOT_SPEWS 2 <br>DWORD      dwMailslotErrors; <br> <br> <br>VOID <br>InitAd( <br>   BOOL IsAdvertise <br>   ) <br>{ <br>    DWORD           cb; <br>    PWKSTA_INFO_101 pwki101; <br>    LARGE_INTEGER   DueTime; <br> <br>    if (IsAdvertise) { <br> <br>        // Unless Win32s or Win9x support named pipe servers... <br> <br>        ASSERT(OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT); <br> <br>        // Problems with overlapped writes to a mailslot sometimes <br>        // cause remote.exe to zombie on exit on NT4, undebuggable <br>        // and unkillable because of an abandoned RDR1 IRP which <br>        // never completes. <br>        // <br>        // So on NT4 we only send messages at startup and shutdown <br>        // and send them synchronously using a nonoverlapped handle. <br>        // <br> <br>        bSynchAdOnly = (OsVersionInfo.dwMajorVersion &lt;= 4); <br> <br>        // <br>        // Get currently active computername and browser/mailslot <br>        // domain/workgroup using one call to NetWkstaGetInfo. <br>        // This is unicode-only, we'll use wsprintf's %ls to <br>        // convert to 8-bit characters. <br>        // <br>        // remoteds.exe needs to be run on a workstation that is <br>        // part of the domain or workgroup of the same name, <br>        // and be in broadcast range, to receive our sends. <br>        // <br> <br>        if (pfnNetWkstaGetInfo(NULL, 101, (LPBYTE *) &amp;pwki101)) { <br>            printf("REMOTE: unable to get computer/domain name, not advertising.\n"); <br>            return; <br>        } <br> <br>        wsprintf( <br>            szMailslotName, <br>            "\\\\%ls\\MAILSLOT\\REMOTE\\DEBUGGERS", <br>            pwki101-&gt;wki101_langroup <br>            ); <br> <br>        wsprintf( <br>            szSend, <br>            "%ls\t%d\t%s\t%s", <br>            pwki101-&gt;wki101_computername, <br>            GetCurrentProcessId(), <br>            PipeName, <br>            ChildCmd <br>            ); <br> <br>        pfnNetApiBufferFree(pwki101); <br>        pwki101 = NULL; <br> <br>        // <br>        // Broadcast mailslots are limited to 400 message bytes <br>        // <br> <br>        szSend[399] = 0; <br> <br>        if (bSynchAdOnly) { <br> <br>            hMailslot = <br>                CreateFile( <br>                    szMailslotName, <br>                    GENERIC_WRITE, <br>                    FILE_SHARE_WRITE, <br>                    NULL, <br>                    OPEN_EXISTING, <br>                    0, <br>                    NULL <br>                    ); <br> <br>            if ( ! WriteFile( <br>                       hMailslot, <br>                       szSend, <br>                       strlen(szSend) + 1, <br>                       &amp;cb, <br>                       NULL <br>                       )) { <br> <br>                printf("REMOTE: WriteFile Failed on mailslot, error %d\n", GetLastError()); <br>            } <br> <br>        } else {  // we can do async mailslot I/O <br> <br>            // <br>            // Create a waitable timer and set it to fire first in <br>            // INITIAL_SLEEP_PERIOD milliseconds by calling the <br>            // completion routine AdvertiseTimerFired.  It will <br>            // be given an inital period of INITIAL_AD_RATE ms. <br>            // <br> <br>            hAdTimer = <br>                pfnCreateWaitableTimer( <br>                    NULL,               // security <br>                    FALSE,              // bManualReset, we want auto-reset <br>                    NULL                // unnamed <br>                    ); <br> <br>            DueTime.QuadPart = Int32x32To64(INITIAL_SLEEP_PERIOD, -10000); <br>            dwTimerInterval = INITIAL_AD_RATE; <br> <br>            pfnSetWaitableTimer( <br>                hAdTimer, <br>                &amp;DueTime, <br>                dwTimerInterval, <br>                AdvertiseTimerFired, <br>                0,                     // arg to compl. rtn <br>                TRUE <br>                ); <br> <br>        } <br>    } <br>} <br> <br> <br>VOID <br>ShutAd( <br>   BOOL IsAdvertise <br>   ) <br>{ <br>    DWORD cb; <br>    BOOL  b; <br> <br>    if (IsAdvertise) { <br> <br>        if (INVALID_HANDLE_VALUE != hAdTimer) { <br> <br>            pfnCancelWaitableTimer(hAdTimer); <br>            CloseHandle(hAdTimer); <br>            hAdTimer = INVALID_HANDLE_VALUE; <br>        } <br> <br>        if (INVALID_HANDLE_VALUE != hMailslot &amp;&amp; <br>            ! bSendingToMailslot) { <br> <br>            // <br>            // Tell any listening remoteds's we're <br>            // outta here.  Do this by tacking on <br>            // a ^B at the end of the string (as <br>            // in Bye). <br>            // <br> <br>            strcat(szSend, "\x2"); <br> <br> <br>            if (bSynchAdOnly) {   // overlapped handle or not? <br>                b = WriteFile( <br>                        hMailslot, <br>                        szSend, <br>                        strlen(szSend) + 1, <br>                        &amp;cb, <br>                        NULL <br>                        ); <br>            } else { <br>                b = WriteFileSynch( <br>                        hMailslot, <br>                        szSend, <br>                        strlen(szSend) + 1, <br>                        &amp;cb, <br>                        0, <br>                        &amp;olMainThread <br>                        ); <br>            } <br> <br>            if ( ! b ) { <br> <br>                printf("REMOTE: WriteFile Failed on mailslot, error %d\n", GetLastError()); <br>            } <br> <br>        } <br> <br>        if (INVALID_HANDLE_VALUE != hMailslot) { <br> <br>            printf("\rREMOTE: closing mailslot...       "); <br>            fflush(stdout); <br>            CloseHandle(hMailslot); <br>            hMailslot = INVALID_HANDLE_VALUE; <br>            printf("\r                                  \r"); <br>            fflush(stdout); <br>        } <br>    } <br>} <br> <br> <br>VOID <br>APIENTRY <br>AdvertiseTimerFired( <br>    LPVOID pArg, <br>    DWORD  dwTimerLo, <br>    DWORD  dwTimerHi <br>    ) <br>{ <br>    UNREFERENCED_PARAMETER( pArg ); <br>    UNREFERENCED_PARAMETER( dwTimerLo ); <br>    UNREFERENCED_PARAMETER( dwTimerHi ); <br> <br> <br>    if (INVALID_HANDLE_VALUE == hMailslot) { <br> <br>        hMailslot = <br>            CreateFile( <br>                szMailslotName, <br>                GENERIC_WRITE, <br>                FILE_SHARE_WRITE, <br>                NULL, <br>                OPEN_EXISTING, <br>                FILE_FLAG_OVERLAPPED, <br>                NULL <br>                ); <br>    } <br> <br>    if (INVALID_HANDLE_VALUE != hMailslot) { <br> <br>        ZeroMemory(&amp;olMailslot, sizeof(olMailslot)); <br> <br>        bSendingToMailslot = TRUE; <br> <br>        if ( ! WriteFileEx( <br>                   hMailslot, <br>                   szSend, <br>                   strlen(szSend) + 1, <br>                   &amp;olMailslot, <br>                   WriteMailslotCompleted <br>                   )) { <br> <br>            bSendingToMailslot = FALSE; <br> <br>            if (++dwMailslotErrors &lt;= MAX_MAILSLOT_SPEWS) { <br> <br>                DWORD dwError; <br>                char szErrorText[512]; <br> <br>                dwError = GetLastError(); <br> <br>                FormatMessage( <br>                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, <br>                    NULL, <br>                    dwError, <br>                    0, <br>                    szErrorText, <br>                    sizeof szErrorText, <br>                    NULL <br>                    ); <br> <br>                // <br>                // FormatMessage has put a newline at the end of szErrorText <br>                // <br> <br>                printf( <br>                    "REMOTE: Advertisement failed, mailslot error %d:\n%s", <br>                    dwError, <br>                    szErrorText <br>                    ); <br>            } <br> <br>            // <br>            // Try reopening the mailslot next time, can't hurt. <br>            // <br> <br>            CloseHandle(hMailslot); <br>            hMailslot = INVALID_HANDLE_VALUE; <br>        } <br>    } <br>} <br> <br> <br>VOID <br>WINAPI <br>WriteMailslotCompleted( <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED lpO <br>    ) <br>{ <br>    LARGE_INTEGER DueTime; <br> <br>    bSendingToMailslot = FALSE; <br> <br>    if (dwError || <br>        (strlen(szSend) + 1) != cbWritten) { <br> <br>            if (++dwMailslotErrors &lt;= MAX_MAILSLOT_SPEWS) { <br>                printf("REMOTE: write failed on mailslot, error %d cb %d (s/b %d)\n", <br>                    dwError, cbWritten, (strlen(szSend) + 1)); <br>            } <br>        return; <br>    } <br> <br>    // <br>    // If we succeeded in writing the mailslot, double the timer interval <br>    // up to the limit. <br>    // <br> <br>    if (dwTimerInterval &lt; MAXIMUM_AD_RATE) { <br> <br>        dwTimerInterval = max(dwTimerInterval * 2, MAXIMUM_AD_RATE); <br> <br>        DueTime.QuadPart = Int32x32To64(dwTimerInterval, -10000); <br> <br>        if (INVALID_HANDLE_VALUE != hAdTimer) { <br> <br>            pfnSetWaitableTimer( <br>                hAdTimer, <br>                &amp;DueTime, <br>                dwTimerInterval, <br>                AdvertiseTimerFired, <br>                0,                     // arg to compl. rtn <br>                TRUE <br>                ); <br>        } <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
