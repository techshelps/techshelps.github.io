<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SERVER.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5734"></a>SERVER.H</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1995 - 1997 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    Server.h <br> <br>Abstract: <br> <br>    The server component of Remote, rewritten using <br>    ReadFileEx/WriteFileEx completion routines. <br> <br>Author: <br> <br>    Dave Hart  30 May 1997 <br> <br>Environment: <br> <br>    Console App. User mode. <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;lm.h&gt;                // needed for NET_API_STATUS below <br> <br>#if !defined(SERVER_H_NOEXTERN) <br>#define SRVEXTERN extern <br>#else <br>#define SRVEXTERN <br>#endif <br> <br> <br>#if DBG <br>  DWORD Trace;         // bits set in here trigger trace printfs <br> <br>  #define TR_SESSION            (0x01) <br>  #define TR_CHILD              (0x02) <br>  #define TR_SHAKE              (0x04) <br>  #define TR_CONNECT            (0x08) <br>  #define TR_QUERY              (0x10) <br>  #define TR_COPYPIPE           (0x20) <br>#endif <br> <br> <br>#if DBG <br>  #define TRACE(tracebit, printfargs)                        \ <br>              ((Trace &amp; (TR_##tracebit)                      \ <br>                   ? (printf printfargs, fflush(stdout), 0)  \ <br>                   : 0)) <br>#else <br>  #define TRACE(tracebit, printfargs)    (0) <br>#endif <br> <br>#if defined(ASSERT) <br>#undef ASSERT <br>#endif <br> <br>#if DBG <br>  #define ASSERT(exp)  ((exp) || (ErrorExit("Assertion failed in " __FILE__ ": " #exp ),0)) <br>#else <br>  #define ASSERT(exp)  (0) <br>#endif <br> <br> <br>// <br>// Size of transfer buffers <br>// <br> <br>#define BUFFSIZE      (4 * 1024) <br> <br>// <br>// ServerFlags bit values in REMOTE_CLIENT below <br>// <br> <br>#define SFLG_CLOSING               0x01 <br>#define SFLG_HANDSHAKING           0x02 <br>#define SFLG_READINGCOMMAND        0x04 <br>#define SFLG_LOCAL                 0x08 <br> <br>#define SFLG_VALID                 \ <br>            (SFLG_CLOSING        | \ <br>             SFLG_HANDSHAKING    | \ <br>             SFLG_READINGCOMMAND | \ <br>             SFLG_LOCAL) <br> <br> <br>// <br>// Per-client state <br>// <br> <br>typedef struct tagREMOTE_CLIENT { <br>    LIST_ENTRY Links; <br>    DWORD   dwID;           // 1, 2, ... <br>    DWORD   ServerFlags; <br>    DWORD   Flag;           //from Client's ClientToServerFlag <br>    DWORD   cbWrite;        //zero if no read temp/write client ops pending <br>    HANDLE  PipeReadH;      //Client sends its StdIn  through this <br>    HANDLE  PipeWriteH;     //Client gets  its StdOut through this <br>    DWORD   dwFilePos;      //offset of temp file where next read begins <br>    OVERLAPPED ReadOverlapped; <br>    OVERLAPPED WriteOverlapped; <br>    HANDLE  rSaveFile;      //Sessions read handle to SaveFile <br>    DWORD   cbReadTempBuffer; <br>    DWORD   cbWriteBuffer; <br>    DWORD   cbCommandBuffer; <br>    char    HexAsciiId[8];         // dwID as 8 hex chars -- no terminator <br>    char    Name[HOSTNAMELEN];     //Name of client Machine; <br>    char    UserName[16];          //Name of user on client machine. <br>    BYTE    ReadBuffer[BUFFSIZE]; <br>    BYTE    ReadTempBuffer[BUFFSIZE]; <br>    BYTE    WriteBuffer[BUFFSIZE]; <br>    BYTE    CommandBuffer[BUFFSIZE]; <br>} REMOTE_CLIENT, *PREMOTE_CLIENT; <br> <br>// <br>// Client lists, see srvlist.c <br>// <br> <br>SRVEXTERN LIST_ENTRY       HandshakingListHead; <br>SRVEXTERN CRITICAL_SECTION csHandshakingList; <br> <br>SRVEXTERN LIST_ENTRY       ClientListHead; <br>SRVEXTERN CRITICAL_SECTION csClientList; <br> <br>SRVEXTERN LIST_ENTRY       ClosingClientListHead; <br>SRVEXTERN CRITICAL_SECTION csClosingClientList; <br> <br> <br>SRVEXTERN DWORD   dwNextClientID; <br>SRVEXTERN LPSTR   pszPipeName; <br>SRVEXTERN HANDLE  ChldProc; <br>SRVEXTERN DWORD   pidChild; <br>SRVEXTERN HANDLE  hWriteChildStdIn; <br>SRVEXTERN BOOL    bShuttingDownServer; <br>SRVEXTERN HANDLE  hHeap; <br> <br>SRVEXTERN volatile DWORD cPendingCtrlCEvents; <br> <br>SRVEXTERN OSVERSIONINFO OsVersionInfo; <br> <br>// File containing all that was output by child process. <br>// Each connection opens a handle to this file <br>// and sends its contents through PipeWriteH. <br> <br>SRVEXTERN HANDLE  hWriteTempFile; <br> <br>SRVEXTERN char    SaveFileName[64]; //Name of above file - all new sessions need <br> <br> <br>// <br>// Generic "wide-open" security descriptor as well <br>// as the possibly-restricted pipe SD. <br>// <br> <br>SRVEXTERN SECURITY_DESCRIPTOR sdPublic; <br>SRVEXTERN SECURITY_ATTRIBUTES saPublic; <br>SRVEXTERN SECURITY_ATTRIBUTES saPipe; <br> <br> <br>// <br>// To minimize client "all pipe instances are busy" errors, <br>// we wait on connection to several instances of the IN pipe, <br>// the sole pipe used by single-pipe clients.  Because of the <br>// requirement to support two-pipe clients (old software as <br>// well as new software on Win95), we cannot easily create <br>// and wait for connection on several instances of the OUT pipe. <br>// This is because two-pipe clients connect to both pipes before <br>// handshaking commences, and they connect to OUT first.  If we <br>// had several OUT pipe instances waiting, when an IN pipe was <br>// connected by the two-pipe client, we wouldn't know which of <br>// the possibly several connected OUT pipe instances to pair <br>// it with.  With only one OUT pipe, at IN connect time we need <br>// to distinguish two-pipe from one-pipe clients so a one-pipe <br>// client doesn't sneak in between the OUT and IN connects of <br>// a two-pipe client and wrongly be paired with the OUT pipe. <br>// To do so we look at the first byte of the initial write <br>// from the client (of the computername and magic value), if <br>// it's a question mark we know we have a new client and won't <br>// accidentally link it to a connected OUT instance. <br>// <br> <br>#define CONNECT_COUNT  3 <br> <br>SRVEXTERN DWORD      cConnectIns; <br>SRVEXTERN OVERLAPPED rgolConnectIn[CONNECT_COUNT]; <br>SRVEXTERN HANDLE     rghPipeIn[CONNECT_COUNT]; <br> <br>SRVEXTERN OVERLAPPED olConnectOut; <br>SRVEXTERN BOOL       bOutPipeConnected; <br>SRVEXTERN HANDLE     hPipeOut; <br>SRVEXTERN HANDLE     hConnectOutTimer; <br> <br>// <br>// Indexes into rghWait array for multiple-wait <br>// <br> <br>#define WAITIDX_CHILD_PROCESS           0 <br>#define WAITIDX_READ_STDIN_DONE         1 <br>#define WAITIDX_QUERYSRV_WAIT           2 <br>#define WAITIDX_PER_PIPE_EVENT          3 <br>#define WAITIDX_CONNECT_OUT             4 <br>#define WAITIDX_CONNECT_IN_BASE         5 <br>#define MAX_WAIT_HANDLES                (WAITIDX_CONNECT_IN_BASE + CONNECT_COUNT) <br> <br>SRVEXTERN HANDLE rghWait[MAX_WAIT_HANDLES]; <br> <br>SRVEXTERN OVERLAPPED ReadChildOverlapped; <br>SRVEXTERN HANDLE     hReadChildOutput; <br>SRVEXTERN BYTE       ReadChildBuffer[BUFFSIZE]; <br> <br>SRVEXTERN PREMOTE_CLIENT pLocalClient; <br> <br>typedef struct tagCOPYPIPE { <br>    HANDLE     hRead; <br>    HANDLE     hWrite; <br>} COPYPIPE, *PCOPYPIPE; <br> <br>SRVEXTERN COPYPIPE rgCopyPipe[2]; <br> <br>SRVEXTERN volatile DWORD dwWriteFilePointer;   // used by SrvCtrlHand (thread) <br> <br>SRVEXTERN OVERLAPPED QueryOverlapped; <br>SRVEXTERN HANDLE hQPipe; <br> <br>SRVEXTERN OVERLAPPED olMainThread; <br> <br> <br>BOOL <br>APIENTRY <br>MyCreatePipeEx( <br>    OUT LPHANDLE lpReadPipe, <br>    OUT LPHANDLE lpWritePipe, <br>    IN LPSECURITY_ATTRIBUTES lpPipeAttributes, <br>    IN DWORD nSize, <br>    DWORD dwReadMode, <br>    DWORD dwWriteMode <br>    ); <br> <br>DWORD <br>WINAPI <br>CopyPipeToPipe( <br>    LPVOID   lpCopyPipeData <br>    ); <br> <br>DWORD <br>WINAPI <br>CopyStdInToPipe( <br>    LPVOID   lpCopyPipeData <br>    ); <br> <br>VOID <br>FASTCALL <br>StartSession( <br>    PREMOTE_CLIENT pClient <br>    ); <br> <br>VOID <br>FASTCALL <br>StartLocalSession( <br>    VOID <br>    ); <br> <br>VOID <br>FASTCALL <br>StartReadClientInput( <br>    PREMOTE_CLIENT pClient <br>    ); <br> <br>VOID <br>WINAPI <br>ReadClientInputCompleted( <br>    DWORD dwError, <br>    DWORD cbRead, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>VOID <br>WINAPI <br>WriteChildStdInCompleted( <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>#define OUT_PIPE -1 <br> <br>VOID <br>FASTCALL <br>CreatePipeAndIssueConnect( <br>    int  nIndex   // IN pipe index or OUT_PIPE <br>    ); <br> <br>VOID <br>FASTCALL <br>HandleOutPipeConnected( <br>    VOID <br>    ); <br> <br>VOID <br>APIENTRY <br>ConnectOutTimerFired( <br>    LPVOID pArg, <br>    DWORD  dwTimerLo, <br>    DWORD  dwTimerHi <br>    ); <br> <br>VOID <br>FASTCALL <br>HandleInPipeConnected( <br>    int nIndex <br>    ); <br> <br>VOID <br>FASTCALL <br>HandshakeWithRemoteClient( <br>    PREMOTE_CLIENT pClient <br>    ); <br> <br>VOID <br>FASTCALL <br>StartChildOutPipeRead( <br>    VOID <br>    ); <br> <br>VOID <br>WINAPI <br>ReadChildOutputCompleted( <br>    DWORD dwError, <br>    DWORD cbRead, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>VOID <br>WINAPI <br>WriteTempFileCompleted( <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>VOID <br>FASTCALL <br>StartServerToClientFlow( <br>    VOID <br>    ); <br> <br>VOID <br>FASTCALL <br>StartReadTempFile( <br>    PREMOTE_CLIENT pClient <br>    ); <br> <br>VOID <br>WINAPI <br>ReadTempFileCompleted( <br>    DWORD dwError, <br>    DWORD cbRead, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>VOID <br>FASTCALL <br>StartWriteSessionOutput( <br>    PREMOTE_CLIENT pClient <br>    ); <br> <br>BOOL <br>FASTCALL <br>WriteSessionOutputCompletedCommon( <br>    PREMOTE_CLIENT pClient, <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine <br>    ); <br> <br>VOID <br>WINAPI <br>WriteSessionOutputCompletedWriteNext( <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>VOID <br>WINAPI <br>WriteSessionOutputCompletedReadNext( <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>VOID <br>FASTCALL <br>HandshakeWithRemoteClient( <br>    PREMOTE_CLIENT pClient <br>    ); <br> <br> <br>VOID <br>WINAPI <br>ReadClientNameCompleted( <br>    DWORD dwError, <br>    DWORD cbRead, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>VOID <br>WINAPI <br>WriteServerReplyCompleted( <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>VOID <br>WINAPI <br>ReadClientStartupInfoSizeCompleted( <br>    DWORD dwError, <br>    DWORD cbRead, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>VOID <br>WINAPI <br>ReadClientStartupInfoCompleted( <br>    DWORD dwError, <br>    DWORD cbRead, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>PCHAR <br>GetFormattedTime( <br>    BOOL bDate <br>    ); <br> <br>HANDLE <br>ForkChildProcess(          // Creates a new process <br>    char *cmd,             // Redirects its stdin,stdout <br>    PHANDLE in,            // and stderr - returns the <br>    PHANDLE out            // corresponding pipe ends. <br>    ); <br> <br>BOOL <br>FilterCommand(             //Filters input from client <br>    REMOTE_CLIENT *cl,      //for commands intended for REMOTE <br>    char *buff, <br>    int dread <br>    ); <br> <br>BOOL <br>WINAPI <br>SrvCtrlHand( <br>    DWORD event <br>    ); <br> <br>DWORD <br>WINAPI <br>SendStatus( <br>    LPVOID   lpSendStatusParm <br>    ); <br> <br>DWORD <br>WINAPI <br>ShowPopup( <br>    void *vpArg <br>    ); <br> <br>VOID <br>RemoveInpMark( <br>    char* Buff, <br>    DWORD Size <br>    ); <br> <br>VOID <br>CloseClient( <br>    REMOTE_CLIENT *Client <br>    ); <br> <br>PSECURITY_DESCRIPTOR <br>FormatSecurityDescriptor( <br>    CHAR * * DenyNames, <br>    DWORD    DenyCount, <br>    CHAR * * Names, <br>    DWORD    Count <br>    ); <br> <br>BOOL <br>FASTCALL <br>HandleSessionError( <br>    PREMOTE_CLIENT pClient, <br>    DWORD         dwError <br>    ); <br> <br>VOID <br>FASTCALL <br>CleanupTempFiles( <br>    PSZ pszTempDir <br>    ); <br> <br>VOID <br>FASTCALL <br>SetupSecurityDescriptors( <br>    VOID <br>    ); <br> <br>VOID <br>FASTCALL <br>RuntimeLinkAPIs( <br>    VOID <br>    ); <br> <br>VOID <br>FASTCALL <br>InitializeClientLists( <br>    VOID <br>    ); <br> <br>VOID <br>FASTCALL <br>AddClientToHandshakingList( <br>    PREMOTE_CLIENT pClient <br>    ); <br> <br>VOID <br>FASTCALL <br>MoveClientToNormalList( <br>    PREMOTE_CLIENT pClient <br>    ); <br> <br>VOID <br>FASTCALL <br>MoveClientToClosingList( <br>    PREMOTE_CLIENT pClient <br>    ); <br> <br>PREMOTE_CLIENT <br>FASTCALL <br>RemoveFirstClientFromClosingList( <br>    VOID <br>    ); <br> <br> <br>VOID <br>InitAd( <br>   BOOL IsAdvertise <br>   ); <br> <br>VOID <br>ShutAd( <br>   BOOL IsAdvertise <br>   ); <br> <br>VOID <br>APIENTRY <br>AdvertiseTimerFired( <br>    LPVOID pArg, <br>    DWORD  dwTimerLo, <br>    DWORD  dwTimerHi <br>    ); <br> <br>VOID <br>WINAPI <br>WriteMailslotCompleted( <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED lpO <br>    ); <br> <br>VOID <br>FASTCALL <br>InitializeQueryServer( <br>    VOID <br>    ); <br> <br>VOID <br>FASTCALL <br>QueryWaitCompleted( <br>    VOID <br>    ); <br> <br>VOID <br>FASTCALL <br>StartServingQueryPipe( <br>    VOID <br>    ); <br> <br>DWORD <br>WINAPI <br>QueryHandlerThread( <br>    LPVOID   lpUnused <br>    ); <br> <br>BOOL <br>CALLBACK <br>EnumWindowProc( <br>    HWND hWnd, <br>    LPARAM lParam <br>    ); <br> <br>// <br>// Declare pointers to runtime-linked functions <br>// <br> <br>HANDLE <br>(WINAPI *pfnCreateWaitableTimer)( <br>    LPSECURITY_ATTRIBUTES lpTimerAttributes, <br>    BOOL bManualReset, <br>    LPCSTR lpTimerName <br>    ); <br> <br>BOOL <br>(WINAPI *pfnSetWaitableTimer)( <br>    HANDLE hTimer, <br>    const LARGE_INTEGER *lpDueTime, <br>    LONG lPeriod, <br>    PTIMERAPCROUTINE pfnCompletionRoutine, <br>    LPVOID lpArgToCompletionRoutine, <br>    BOOL fResume <br>    ); <br> <br>BOOL <br>(WINAPI *pfnCancelWaitableTimer)( <br>    HANDLE hTimer <br>    ); <br> <br>BOOL <br>(WINAPI *pfnCancelIo)( <br>    HANDLE hFile <br>    ); <br> <br>#define CANCELIO(hFile)  (pfnCancelIo) ? ( pfnCancelIo(hFile) ) : 0; <br> <br>NET_API_STATUS <br>(NET_API_FUNCTION *pfnNetWkstaGetInfo)( <br>    IN  LPTSTR  servername OPTIONAL, <br>    IN  DWORD   level, <br>    OUT LPBYTE  *bufptr <br>    ); <br> <br>NET_API_STATUS <br>(NET_API_FUNCTION *pfnNetApiBufferFree)( <br>    IN LPVOID Buffer <br>    ); </code></pre>
<p>&nbsp;</p></body>
</HTML>
