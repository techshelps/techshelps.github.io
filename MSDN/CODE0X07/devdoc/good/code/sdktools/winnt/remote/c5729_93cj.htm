<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SRVSTOC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5743"></a>SRVSTOC.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1995 - 1997 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Copyright (c) 1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    SrvStoC.c <br> <br>Abstract: <br> <br>    This file implements the server-to-client flow <br>    of data for remote server.  The data is the output <br>    of the child program intermingled with client input. <br> <br>Author: <br> <br>    Dave Hart  30 May 1997 <br> <br>Environment: <br> <br>    Console App. User mode. <br> <br>Revision History: <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;string.h&gt; <br>#include "Remote.h" <br>#include "Server.h" <br> <br> <br>VOID <br>FASTCALL <br>StartServerToClientFlow( <br>    VOID <br>    ) <br>{ <br>    PREMOTE_CLIENT pClient; <br> <br>    // <br>    // Start read operations against the temp file for <br>    // all active clients that aren't currently doing <br>    // read temp/write client operations and that are <br>    // fully connected. <br>    // <br> <br>    for (pClient = (PREMOTE_CLIENT) ClientListHead.Flink; <br>         pClient != (PREMOTE_CLIENT) &amp;ClientListHead; <br>         pClient = (PREMOTE_CLIENT) pClient-&gt;Links.Flink ) { <br> <br> <br>        if (! pClient-&gt;cbWrite) { <br> <br>            StartReadTempFile( pClient ); <br>        } <br>    } <br>} <br> <br> <br>VOID <br>FASTCALL <br>StartReadTempFile( <br>    PREMOTE_CLIENT pClient <br>    ) <br>{ <br>    // <br>    // pClient-&gt;cbWrite is used dually.  WriteSessionOutputCompleted <br>    // uses it when 0 bytes are written to know how much to ask <br>    // to write when it resubmits the request.  We use it to <br>    // indicate whether a read temp/write session chain of I/Os <br>    // is currently active for this client. <br>    // <br> <br>    if (pClient-&gt;cbWrite) { <br> <br>        ErrorExit("StartReadTempFile entered with nonzero cbWrite."); <br>    } <br> <br>    if (dwWriteFilePointer &gt; pClient-&gt;dwFilePos) { <br> <br>        pClient-&gt;cbWrite = min(BUFFSIZE, <br>                               dwWriteFilePointer - pClient-&gt;dwFilePos); <br> <br>        pClient-&gt;WriteOverlapped.OffsetHigh = 0; <br>        pClient-&gt;WriteOverlapped.Offset = pClient-&gt;dwFilePos; <br> <br>        if ( ! ReadFileEx( <br>                   pClient-&gt;rSaveFile, <br>                   pClient-&gt;ReadTempBuffer, <br>                   pClient-&gt;cbWrite, <br>                   &amp;pClient-&gt;WriteOverlapped, <br>                   ReadTempFileCompleted <br>                   )) { <br> <br>            if (ERROR_HANDLE_EOF == GetLastError()) { <br> <br>                pClient-&gt;cbWrite = 0; <br> <br>            } else { <br> <br>                TRACE(SESSION, ("ReadFileEx for temp file failed error %d, closing client.\n", GetLastError())); <br> <br>                CloseClient(pClient); <br>            } <br>        } <br> <br>    } <br>} <br> <br>VOID <br>WINAPI <br>ReadTempFileCompleted( <br>    DWORD dwError, <br>    DWORD cbRead, <br>    LPOVERLAPPED lpO <br>    ) <br>{ <br>    PREMOTE_CLIENT pClient; <br> <br>    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped); <br> <br>    if (HandleSessionError(pClient, dwError)) { <br> <br>        return; <br>    } <br> <br> <br>    if (cbRead != pClient-&gt;cbWrite) { <br> <br>        TRACE(SESSION, ("Read %d from temp file asked for %d\n", cbRead, pClient-&gt;cbWrite)); <br>    } <br> <br>    if (cbRead) { <br> <br>        pClient-&gt;cbReadTempBuffer = cbRead; <br>        pClient-&gt;dwFilePos += cbRead; <br> <br>        StartWriteSessionOutput(pClient); <br> <br>    } else { <br> <br>        // <br>        // Note that the server to client flow is halting for now <br>        // for this client. <br>        // <br> <br>        pClient-&gt;cbWrite = 0; <br>    } <br>} <br> <br> <br>VOID <br>FASTCALL <br>StartWriteSessionOutput( <br>    PREMOTE_CLIENT pClient <br>    ) <br>{ <br>    DWORD cbRead; <br>    char *pch; <br> <br>    cbRead = pClient-&gt;cbReadTempBuffer; <br> <br>    // <br>    // We need to split commands from other text read <br>    // from the temp file and hold off on writing them <br>    // to the client until we make sure we're not the <br>    // client that submitted it.  This isn't perfect <br>    // since we match on client name which can be <br>    // duplicated but it solves the problem of <br>    // duplicated input most of the time. <br>    // <br> <br>    for (pch = pClient-&gt;ReadTempBuffer; <br>         pch &lt; pClient-&gt;ReadTempBuffer + cbRead; <br>         pch++) { <br> <br>        if ( ! (pClient-&gt;ServerFlags &amp; SFLG_READINGCOMMAND) ) { <br> <br>            if (BEGINMARK == *pch) { <br> <br>                pClient-&gt;ServerFlags |= SFLG_READINGCOMMAND; <br> <br>                if (pch != pClient-&gt;ReadTempBuffer &amp;&amp; <br>                    pClient-&gt;cbWriteBuffer) { <br> <br>                    // <br>                    // Start a write of everything we've come across <br>                    // before the start of this command, with <br>                    // WriteSessionOutputCompletedWriteNext specified <br>                    // so we can continue processing the remainder <br>                    // of pReadTempBuffer. <br>                    // <br> <br>                    pClient-&gt;cbReadTempBuffer -= ( pch - pClient-&gt;ReadTempBuffer) + 1; <br>                    cbRead = pClient-&gt;cbReadTempBuffer; <br> <br>                    #if DBG <br>                        if (pClient-&gt;cbReadTempBuffer == (DWORD)-1) { <br>                            ErrorExit("cbReadTempBuffer underflow."); <br>                        } <br>                    #endif <br> <br>                    MoveMemory(pClient-&gt;ReadTempBuffer, pch + 1, cbRead); <br> <br>                    pClient-&gt;cbWrite = pClient-&gt;cbWriteBuffer; <br> <br>                    pClient-&gt;WriteOverlapped.OffsetHigh = 0; <br>                    pClient-&gt;WriteOverlapped.Offset = 0; <br> <br>                    if ( ! WriteFileEx( <br>                               pClient-&gt;PipeWriteH, <br>                               pClient-&gt;WriteBuffer, <br>                               pClient-&gt;cbWrite, <br>                               &amp;pClient-&gt;WriteOverlapped, <br>                               WriteSessionOutputCompletedWriteNext <br>                               )) { <br> <br>                        CloseClient(pClient); <br>                    } <br> <br>                    TRACE(SESSION, ("%x Wrote %d bytes pre-command output\n", pClient, pClient-&gt;cbWrite)); <br> <br>                    pClient-&gt;cbWriteBuffer = 0; <br> <br>                    return; <br>                } <br> <br>            } else { <br> <br>                if (pClient-&gt;cbWriteBuffer == BUFFSIZE) { <br> <br>                    ErrorExit("cbWriteBuffer overflow"); <br>                } <br> <br>                pClient-&gt;WriteBuffer[ pClient-&gt;cbWriteBuffer++ ] = *pch; <br>            } <br> <br>        } else { <br> <br>            if (ENDMARK == *pch || <br>                pClient-&gt;cbCommandBuffer == BUFFSIZE) { <br> <br>                pClient-&gt;ServerFlags &amp;= ~SFLG_READINGCOMMAND; <br> <br>                // <br>                // Preceding ENDMARK is the pClient in hex ascii of the <br>                // client that generated the command, not null terminated. <br>                // <br> <br>                if (ENDMARK == *pch) { <br> <br>                    pClient-&gt;cbCommandBuffer -= <br>                        min(pClient-&gt;cbCommandBuffer, sizeof(pClient-&gt;HexAsciiId)); <br> <br>                } <br> <br>                // <br>                // We hide each client's input from their output pipe <br>                // because their local remote.exe has already displayed it. <br>                // <br> <br>                if ( pClient-&gt;cbCommandBuffer &amp;&amp; <br>                     ! (ENDMARK == *pch &amp;&amp; <br>                        ! memcmp( <br>                              pch - sizeof(pClient-&gt;HexAsciiId), <br>                              pClient-&gt;HexAsciiId, <br>                              sizeof(pClient-&gt;HexAsciiId)))) { <br> <br>                    // <br>                    // Start a write of the accumulated command with <br>                    // WriteSessionOutputCompletedWriteNext specified <br>                    // so we can continue processing the remainder <br>                    // of pReadTempBuffer. <br>                    // <br> <br>                    pClient-&gt;cbReadTempBuffer -= (pch - pClient-&gt;ReadTempBuffer) + 1; <br>                    MoveMemory(pClient-&gt;ReadTempBuffer, pch + 1, pClient-&gt;cbReadTempBuffer); <br> <br>                    pClient-&gt;cbWrite = pClient-&gt;cbCommandBuffer; <br>                    pClient-&gt;cbCommandBuffer = 0; <br> <br>                    pClient-&gt;WriteOverlapped.OffsetHigh = 0; <br>                    pClient-&gt;WriteOverlapped.Offset = 0; <br> <br>                    if ( ! WriteFileEx( <br>                               pClient-&gt;PipeWriteH, <br>                               pClient-&gt;CommandBuffer, <br>                               pClient-&gt;cbWrite, <br>                               &amp;pClient-&gt;WriteOverlapped, <br>                               WriteSessionOutputCompletedWriteNext <br>                               )) { <br> <br>                        CloseClient(pClient); <br>                        return; <br> <br>                    } else { <br> <br>                        TRACE(SESSION, ("%x Wrote %d bytes command\n", pClient, pClient-&gt;cbWrite)); <br> <br>                        return; <br> <br>                    } <br> <br>                } else { <br> <br>                    // <br>                    // We're eating this command for this session. <br>                    // <br> <br>                    pClient-&gt;cbCommandBuffer = 0; <br>                } <br> <br>            } else { <br> <br>                pClient-&gt;CommandBuffer[ pClient-&gt;cbCommandBuffer++ ] = *pch; <br> <br>            } <br>        } <br>    } <br> <br>    // <br>    // We're done with the ReadTempBuffer. <br>    // <br> <br>    pClient-&gt;cbReadTempBuffer = 0; <br> <br>    if (pClient-&gt;cbWriteBuffer) { <br> <br>        pClient-&gt;cbWrite = pClient-&gt;cbWriteBuffer; <br> <br>        pClient-&gt;WriteOverlapped.OffsetHigh = 0; <br>        pClient-&gt;WriteOverlapped.Offset = 0; <br> <br>        if ( ! WriteFileEx( <br>                   pClient-&gt;PipeWriteH, <br>                   pClient-&gt;WriteBuffer, <br>                   pClient-&gt;cbWrite, <br>                   &amp;pClient-&gt;WriteOverlapped, <br>                   WriteSessionOutputCompletedReadNext <br>                   )) { <br> <br>            CloseClient(pClient); <br>            return; <br> <br>        } else { <br> <br>            TRACE(SESSION, ("%x Wrote %d bytes normal\n", pClient, pClient-&gt;cbWrite)); <br> <br>            pClient-&gt;cbWriteBuffer = 0; <br>        } <br> <br>    } else { <br> <br>        // <br>        // Write buffer is empty. <br>        // <br> <br>        pClient-&gt;cbWrite = 0; <br> <br>        StartReadTempFile(pClient); <br> <br>    } <br>} <br> <br> <br>BOOL <br>FASTCALL <br>WriteSessionOutputCompletedCommon( <br>    PREMOTE_CLIENT pClient, <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine <br>    ) <br>{ <br>    if (HandleSessionError(pClient, dwError)) { <br> <br>        return TRUE; <br>    } <br> <br>    if (!pClient-&gt;cbWrite) { <br> <br>        ErrorExit("Zero cbWrite in WriteSessionOutputCompletedCommon"); <br>    } <br> <br>    if (!cbWritten &amp;&amp; pClient-&gt;cbWrite) { <br> <br>        printf("WriteSessionOutput zero bytes written of %d.\n", pClient-&gt;cbWrite); <br>        ErrorExit("WriteSessionOutputCompletedCommon failure"); <br> <br>        return TRUE; <br>    } <br> <br>    #if DBG <br>        if (cbWritten != pClient-&gt;cbWrite) { <br>            printf("%x cbWritten %d cbWrite %d\n", pClient, cbWritten, pClient-&gt;cbWrite); <br>        } <br>    #endif <br> <br>    return FALSE; <br>} <br> <br> <br>VOID <br>WINAPI <br>WriteSessionOutputCompletedWriteNext( <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED lpO <br>    ) <br>{ <br>    PREMOTE_CLIENT pClient; <br> <br>    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped); <br> <br>    if (WriteSessionOutputCompletedCommon( <br>            pClient, <br>            dwError, <br>            cbWritten, <br>            WriteSessionOutputCompletedWriteNext <br>            )) { <br> <br>        return; <br>    } <br> <br>    StartWriteSessionOutput(pClient); <br>} <br> <br> <br>VOID <br>WINAPI <br>WriteSessionOutputCompletedReadNext( <br>    DWORD dwError, <br>    DWORD cbWritten, <br>    LPOVERLAPPED lpO <br>    ) <br>{ <br>    PREMOTE_CLIENT pClient; <br> <br>    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped); <br> <br>    if (WriteSessionOutputCompletedCommon( <br>            pClient, <br>            dwError, <br>            cbWritten, <br>            WriteSessionOutputCompletedReadNext <br>            )) { <br> <br>        return; <br>    } <br> <br>    // <br>    // Start another temp file read. <br>    // <br> <br>    pClient-&gt;cbWrite = 0; <br> <br>    StartReadTempFile(pClient); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
