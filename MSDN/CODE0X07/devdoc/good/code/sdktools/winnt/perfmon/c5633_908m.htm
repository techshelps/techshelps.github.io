<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILEUTIL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5656"></a>FILEUTIL.C</h2>
<pre><code><br> <br>//#include &lt;string.h&gt; <br>//#include &lt;tchar.h&gt; <br> <br>#include &lt;stdio.h&gt; <br>#include "perfmon.h" <br>#include "fileutil.h" <br>#include "utils.h" <br> <br>#include &lt;string.h&gt;     // for strncpy <br>#ifdef UNICODE <br>#define _tcsrchrwcsrchr <br>#else <br>#define _tcsrchrstrrchr <br>#endif <br> <br>#define DRIVE_DELIMITER          TEXT(':') <br>#define DIRECTORY_DELIMITER      TEXT('\\') <br>#define EXTENSION_DELIMITER      TEXT('.') <br> <br> <br>#if 0 <br>VOID FileErrorMessageBox(HWND hWnd, LPTSTR lpszFileName, DWORD ErrorCode) <br>   { <br>   TCHAR szErrorMessage[FILE_ERROR_MESSAGE_SIZE] ; <br>   TCHAR szErrorMessageTemplate[FILE_ERROR_MESSAGE_SIZE] ; <br> <br>   StringLoad (IDS_FILE_ERROR, szErrorMessageTemplate) ; <br>   TSPRINTF((LPTSTR)szErrorMessage, <br>            (LPTSTR)szErrorMessageTemplate, <br>            lpszFileName, <br>            ErrorCode) ; <br> <br>   MessageBox (hWnd, (LPTSTR)szErrorMessage, NULL, <br>              MB_OK | MB_ICONSTOP | MB_TASKMODAL); <br>   return ; <br>   } <br>#endif <br> <br> <br>BOOL FileRead (HANDLE hFile, <br>               LPMEMORY lpMemory, <br>               DWORD nAmtToRead) <br>   {  // FileRead <br>   BOOL           bSuccess ; <br>   DWORD          nAmtRead ; <br> <br>   bSuccess = ReadFile (hFile, lpMemory, nAmtToRead, &amp;nAmtRead, NULL) ; <br>   return (bSuccess &amp;&amp; (nAmtRead == nAmtToRead)) ; <br>   }  // FileRead <br> <br> <br> <br>BOOL FileWrite (HANDLE hFile, <br>                LPMEMORY lpMemory, <br>                DWORD nAmtToWrite) <br>   {  // FileWrite <br>   BOOL           bSuccess ; <br>   DWORD          nAmtWritten ; <br> <br>   bSuccess = WriteFile (hFile, lpMemory, nAmtToWrite, &amp;nAmtWritten, NULL) ; <br>   return (bSuccess &amp;&amp; (nAmtWritten == nAmtToWrite)) ; <br>   }  // FileWrite <br> <br>                 <br>#if 0 <br>HANDLE FileHandleOpen (LPTSTR lpszFilePath) <br>   {  // FileHandleOpen <br>   return ((HANDLE) CreateFile (lpszFilePath, <br>                                GENERIC_READ | <br>                                GENERIC_WRITE, <br>                                FILE_SHARE_READ | <br>                                FILE_SHARE_WRITE, <br>                                NULL,  <br>                                OPEN_EXISTING, <br>                                0, <br>                                NULL)) ; <br>   }  // FileHandleOpen <br> <br> <br>HANDLE FileHandleCreate (LPTSTR lpszFilePath) <br>   {  // FileHandleCreate <br>   return ((HANDLE) CreateFile (lpszFilePath,  <br>                               GENERIC_READ | GENERIC_WRITE, <br>                               FILE_SHARE_READ, <br>                               NULL, <br>                               CREATE_ALWAYS, <br>                               FILE_ATTRIBUTE_NORMAL, <br>                               NULL)) ; <br>   }  // FileHandleCreate <br> <br> <br> <br>long FileSeekEnd (HANDLE hFile, <br>                  long lAmtToMove) <br>   {  // FileSeekEnd <br>   return (SetFilePointer (hFile, lAmtToMove, NULL, FILE_END)) ; <br>   }  // FileSeekEnd <br> <br> <br>long FileSeekBegin (HANDLE hFile, <br>                    long lAmtToMove) <br>   {  // FileSeekBegin <br>   return (SetFilePointer (hFile, lAmtToMove, NULL, FILE_BEGIN)) ; <br>   }  // FileSeekBegin <br> <br> <br>long FileSeekCurrent (HANDLE hFile, <br>                      long lAmtToMove) <br>   {  // FileSeekCurrent <br>   return  (SetFilePointer (hFile, lAmtToMove, NULL, FILE_CURRENT)) ; <br>   }  // FileSeekCurrent <br>    <br> <br> <br>long FileTell (HANDLE hFile) <br>   {  // FileTell <br>   return (SetFilePointer (hFile, 0, NULL, FILE_CURRENT)) ; <br>   }  // FileTell <br>#endif <br> <br> <br> <br>LPMEMORY FileMap (HANDLE hFile, HANDLE *phMapHandle) <br>/* <br>   To Do:         Error reporting!! <br>*/ <br>   {  // FileMap <br>   HANDLE         hMapping ; <br> <br> <br>   *phMapHandle = 0 ; <br>   hMapping = CreateFileMapping (hFile, NULL, PAGE_READONLY, <br>                                 0, 0, NULL) ; <br>   if (!hMapping) <br>      return (NULL) ; <br> <br>   *phMapHandle = hMapping ; <br>   return (MapViewOfFile (hMapping, FILE_MAP_READ, 0, 0, 0)) ; <br>   }  // FileMap <br> <br> <br> <br>BOOL FileUnMap (LPVOID pBase, HANDLE hMapping) <br>/* <br>   To Do:         Error reporting!! <br>*/ <br>   {  // FileUnMap <br>   UnmapViewOfFile(pBase) ; <br>   CloseHandle (hMapping) ; <br>   return (TRUE) ; <br>   }  // FileUnMap <br> <br> <br> <br>void FileNameExtension (LPTSTR lpszSpec, <br>                        LPTSTR lpszFileNameExtension) <br>/* <br>   Effect:        Return the name and extension portion only of lpszSpec <br>                  int lpszFileNameExtension. <br> <br>   Assert:        lpszFileNameExtension is large enough to hold a name, <br>                  delimiter, extension, and terminating null character. <br>*/ <br>   {  // FileNameExtension <br>   LPTSTR          lpszDelimiter ; <br> <br>   lpszDelimiter = _tcsrchr ((LPCTSTR)lpszSpec, (TCHAR)DIRECTORY_DELIMITER) ; <br>   if (!lpszDelimiter) <br>      lpszDelimiter = _tcsrchr ((LPCTSTR)lpszSpec, (TCHAR)DRIVE_DELIMITER) ; <br> <br>   lstrcpy (lpszFileNameExtension,  <br>           lpszDelimiter ? ++lpszDelimiter : lpszSpec) ; <br>   }  // FileNameExtension <br> <br> <br> <br>void FileDriveDirectory (LPTSTR lpszFileSpec, <br>                         LPTSTR lpszDirectory) <br>/* <br>   Effect:        Extract the drive and directory from the file  <br>                  specification lpszFileSpec, and return the it in <br>                  lpszDirectory. <br> <br>   Internals:     Copy the the whole spec to lpszDirectory. Use lstrrchr <br>                  to find the *last* directory delimiter ('\') and  <br>                  truncate the string right after that.  <br> <br>   Note:          This function assumes that the specification lpszFileSpec <br>                  is fairly complete, in that it contains both a directory <br>                  and a file name. <br>*/ <br>   {  // FileDriveDirectory <br>   LPTSTR          lpszDelimiter ; <br> <br>   lstrcpy (lpszDirectory, lpszFileSpec) ; <br>   lpszDelimiter = _tcsrchr ((LPCTSTR)lpszDirectory, (TCHAR)DIRECTORY_DELIMITER) ; <br>   if (lpszDelimiter) <br>      *(++lpszDelimiter) = TEXT('\0') ; <br>   }  // FileDriveDirectory <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
