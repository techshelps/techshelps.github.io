<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5665"></a>INIT.C</h2>
<pre><code>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br>#include &lt;string.h&gt;     // strupr <br>#include &lt;stdio.h&gt;      // for sprintf. <br> <br> <br>#include "perfmon.h" <br>#include "init.h"       // external declarations for this file <br> <br>#include "alert.h"      // for AlertIitializeApplication <br>#include "command.h"    // for ViewChart <br>#include "grafdata.h"   // for QuerySaveChart <br>#include "graph.h"      // for GraphInitializeApplication <br>#include "legend.h"     // for LegendInitializeApplication <br>#include "log.h"        // for LogInitializeApplication <br>#include "intrline.h"   // for ILineInitializeApplication <br>#include "perfdata.h"   // for PerfDataInitializeInstance <br>#include "perfmops.h"   // for OpenFileHandler, for now <br>#include "status.h"     // for StatusInitializeApplication <br>#include "timeline.h"   // for TLineInitializeApplication <br>#include "playback.h"   // for PlaybackInitializeInstance <br>#include "registry.h"   // for Load/SaveMainWindowPlacement <br>#include "report.h"     // for ReportInitializeApplication <br>#include "toolbar.h"    // for ToolbarInitializeApplication <br>#include "utils.h" <br>#include "fileopen.h"   // for FileOpen <br>#include "pmemory.h"    // for MemoryFree <br> <br>extern   TCHAR          DefaultLangId[] ; <br>extern   TCHAR          EnglishLangId[] ; <br> <br>static   LPSTR         lpszCommandLine ; <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br> <br>#define szPerfmonMainClass TEXT("PerfmonMainClass") <br> <br>HHOOK   lpMsgFilterProc ; <br>DWORD FAR PASCAL MessageFilterProc (int nCode, WPARAM wParam, <br>      LPARAM lParam) ; <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br> <br>void GetScalesFonts (void) <br>   { <br>   LOGFONT        lf ; <br> <br>   memset (&amp;lf, 0, sizeof (lf)) ; <br> <br>   lstrcpy (lf.lfFaceName, szScalesFontFace) ; <br>   lf.lfHeight = iScalesFontHeight ; <br>   lf.lfWeight = FW_REGULAR ; <br> <br> <br>   if (PRIMARYLANGID(GetUserDefaultLangID ()) == LANG_JAPANESE) <br>     lf.lfCharSet = SHIFTJIS_CHARSET; <br> <br>   hFontScales = CreateFontIndirect (&amp;lf) ; <br> <br>   if (PRIMARYLANGID(GetUserDefaultLangID ()) != LANG_JAPANESE) <br>     lf.lfWeight = FW_BOLD ; <br> <br>   hFontScalesBold = CreateFontIndirect (&amp;lf) ; <br>   } <br> <br> <br>BOOL InitializeSystemValues (void) <br>/* <br>   Effect:        Read and store in variables the various system values, <br>                  such as the width and height of the screen and icons, <br>                  the width of scroll bars, etc. <br> <br>   Called By:     PerfmonInitialize only. <br> <br>   Returns:       Whether this function was successful in getting all <br>                  needed system values. <br>*/ <br>   {  // InitializeSystemValues <br>   xScreenWidth =  GetSystemMetrics (SM_CXSCREEN) ; <br>   yScreenHeight = GetSystemMetrics (SM_CYSCREEN) ; <br> <br>   xBorderWidth = GetSystemMetrics (SM_CXBORDER) ; <br>   yBorderHeight = GetSystemMetrics (SM_CYBORDER) ; <br> <br>   xScrollWidth = GetSystemMetrics (SM_CXVSCROLL) ; <br>   yScrollHeight = GetSystemMetrics (SM_CYHSCROLL) ; <br> <br>   xScrollThumbWidth = GetSystemMetrics (SM_CXHTHUMB) ; <br>   yScrollThumbHeight = GetSystemMetrics (SM_CYVTHUMB) ; <br> <br>   xDlgBorderWidth = GetSystemMetrics (SM_CXDLGFRAME) ; <br>   yDlgBorderHeight = GetSystemMetrics (SM_CYDLGFRAME) ; <br> <br>   MinimumSize = yScrollHeight + <br>                 GetSystemMetrics (SM_CYMENU) + <br>                 GetSystemMetrics (SM_CYCAPTION) ; <br> <br>   //================================================================// <br>   // create all the brushes and pens for performance improvement    // <br>   //================================================================// <br>   CreatePerfmonSystemObjects () ; <br>   hWhitePen = CreatePen (PS_SOLID, 3, crWhite) ; <br> <br>   return (TRUE) ; <br>   }  // InitializeSystemValues <br> <br> <br>BOOL InitializeApplication (void) <br>/* <br>   Effect:        Perform all initializations required for the FIRST <br>                  instance of the Perfmon application. In particular, <br>                  register all of Perfmon's window classes. <br> <br>   Note:          There is no background brush set for the MainWindow <br>                  class so that the main window is never erased. The <br>                  client area of MainWindow is always covered by one <br>                  of the view windows. If we erase it, it would just <br>                  flicker needlessly. <br> <br>   Called By:     PerfmonInitialize only. <br> <br>   Returns:       Whether this function was successful in initializing. <br>*/ <br>   {  // InitializeApplication <br>   BOOL           bSuccess ; <br>   WNDCLASS       wc ; <br>   TCHAR          LocalHelpFileName [ShortTextLen] ; <br>   LPTSTR         pFileName ; <br> <br>   hIcon = LoadIcon (hInstance, idIcon) ; <br> <br>   //=============================// <br>   // Register Main window class  // <br>   //=============================// <br> <br>   wc.style         = CS_DBLCLKS | CS_BYTEALIGNCLIENT; <br>   wc.lpfnWndProc   = (WNDPROC) MainWndProc; <br>   wc.hInstance     = hInstance; <br>   wc.cbClsExtra    = 0 ; <br>   wc.cbWndExtra    = 0; <br>   wc.hIcon         = hIcon ; <br>   wc.hCursor       = LoadCursor(NULL, IDI_APPLICATION); <br>   wc.hbrBackground = NULL ;                             // see note above <br>   wc.lpszMenuName  = idMenuChart ; <br>   wc.lpszClassName = szPerfmonMainClass ; <br> <br>   bSuccess = RegisterClass (&amp;wc) ; <br> <br>   //=============================// <br>   // Register Abstract "Systems" // <br>   //=============================// <br>   hbLightGray = GetStockObject (LTGRAY_BRUSH) ; <br> <br>   if (bSuccess) <br>      bSuccess = StatusInitializeApplication () ; <br> <br>   if (bSuccess) <br>      bSuccess = GraphInitializeApplication () ; <br> <br>#ifdef ADVANCED_PERFMON <br>   if (bSuccess) <br>      bSuccess = LogInitializeApplication () ; <br> <br>   if (bSuccess) <br>      bSuccess = AlertInitializeApplication () ; <br> <br>   if (bSuccess) <br>      bSuccess = ReportInitializeApplication () ; <br> <br>   if (bSuccess) <br>      bSuccess = ILineInitializeApplication () ; <br> <br>   if (bSuccess) <br>      bSuccess = TLineInitializeApplication () ; <br>#endif <br> <br>   // setup messagehook to handle F1 as help <br>   lpMsgFilterProc = SetWindowsHookEx (WH_MSGFILTER, <br>          (HOOKPROC) MessageFilterProc, <br>          hInstance, <br>          GetCurrentThreadId()) ; <br> <br>   // get the help file full path name <br>   LoadString (hInstance, IDS_HELPFILE_NAME, <br>      (LPTSTR)LocalHelpFileName, ShortTextLen-1); <br> <br> <br>   if (LocalHelpFileName[0]) <br>      { <br>      pszHelpFile = (LPTSTR) MemoryAllocate (FilePathLen * sizeof (TCHAR)) ; <br>      SearchPath (NULL, LocalHelpFileName, NULL, <br>            FilePathLen - 1, pszHelpFile, &amp;pFileName) ; <br>      } <br>   else <br>      { <br>      // no help file <br>      pszHelpFile = (LPTSTR) MemoryAllocate (sizeof (TCHAR)) ; <br>      *pszHelpFile = TEXT('\0') ; <br>      } <br> <br>   return (bSuccess) ; <br>   }  // InitializeApplication <br> <br> <br> <br>BOOL InitializeInstance (int nCmdShow, LPCSTR lpszCmdLine) <br>/* <br>   Effect:        Perform all initializations required for EACH instance <br>                  of the Perfmon application. In particular, create all <br>                  of Perfmon's initial windows, and perform any other <br>                  initializations except registering classes (done in <br>                  InitializeApplication). <br> <br>   Called By:     PerfmonInitialize only. <br> <br>   Note:          This function has multiple return points. <br> <br>   Returns:       Whether this function was successful in initalizing. <br>*/ <br>   {  // InitializeInstance <br>   DWORD          ComputerNameLength; <br>   TCHAR          szApplication [WindowCaptionLen] ; <br> <br> <br>   //=============================// <br>   // Set Priority high           // <br>   //=============================// <br> <br>   SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS) ; <br>   SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST) ; <br> <br>   //=============================// <br>   // Load Resources              // <br>   //=============================// <br> <br>   GetScalesFonts () ; <br> <br>   hMenuChart = LoadMenu (hInstance, idMenuChart) ; <br> <br>#ifdef ADVANCED_PERFMON <br>   hMenuAlert = LoadMenu (hInstance, idMenuAlert) ; <br>   hMenuLog = LoadMenu (hInstance, idMenuLog) ; <br>   hMenuReport = LoadMenu (hInstance, idMenuReport) ; <br>#endif <br> <br>   hAccelerators = LoadAccelerators (hInstance, idAccelerators) ; <br> <br> <br>   //=============================// <br>   // Initialize Systems          // <br>   //=============================// <br> <br>   iLanguage = GetUserDefaultLangID() ; <br>   iEnglishLanguage = MAKELANGID (LANG_ENGLISH, LANG_NEUTRAL) ; <br>//   iEnglishLanguage = MAKELANGID (iLanguage &amp; 0x0ff, LANG_NEUTRAL) ; <br>   TSPRINTF (DefaultLangId, TEXT("%03x"), iLanguage) ; <br>   TSPRINTF (EnglishLangId, TEXT("%03x"), iEnglishLanguage) ; <br> <br>   // GetComputerName returns the name without the "\\" prefix. We add <br>   // the prefix before even calling the routine. This is so that all our <br>   // computer names have the prefix and are therefore compatible with <br>   // I_SetSystemFocus (see perfmops.c). <br> <br>   ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1; <br>   lstrcpy (LocalComputerName, szComputerPrefix) ; <br>   GetComputerName (LocalComputerName + lstrlen (szComputerPrefix),  <br>                    &amp;ComputerNameLength); <br> <br>   PlaybackInitializeInstance () ; <br>   PerfDataInitializeInstance () ; <br> <br>//Copy command line into buffer for modification <br>lpszCommandLine = (LPSTR)MemoryAllocate (strlen (lpszCmdLine) + sizeof(CHAR)) ; <br>   if(lpszCommandLine) <br>   strcpy(lpszCommandLine, lpszCmdLine) ; <br>else <br>return (FALSE) ; <br> <br> <br>   StringLoad (IDS_APPNAME, szApplication) ; <br> <br>//Insure CmdLineComputerName starts out NULL <br>CmdLineComputerName[0] = TEXT('\0') ; <br> <br>//Check to see if there is a computer name specified on the command <br>//line (indicated by /c, or /C).  If there is, get it and <br>//null out the command line string so that it is not mistaken for  <br>//startup file.  This assumes that specifying a computer and a startup <br>//file on the command line are mutually exclusive.  If the /c option <br>//is on the command line, anything else on the command line is discarded. <br>if (!strempty (lpszCommandLine)) { <br>LPSTRlpszNewCL ; <br> <br>//Preserve initial command line pointer position <br>lpszNewCL = (LPSTR)lpszCommandLine ; <br>while (*lpszNewCL != '\0' &amp;&amp; *lpszCommandLine) { <br>if (*lpszNewCL== '/' || *lpszNewCL== '-') { <br>lpszNewCL++ ; <br>if (*lpszNewCL == 'c' || *lpszNewCL == 'C') { <br>int i = 0; <br> <br>lpszNewCL++ ; <br>//ignore leading backslashes * spaces <br>while (*lpszNewCL == '\\' || *lpszNewCL == ' ') <br>lpszNewCL++ ; <br> <br>//Terminate at first blank space if there is one. <br>//We don't allow anything else on the command line <br>//if a computer name is specified. <br>while (lpszNewCL[i] != ' ' &amp;&amp; lpszNewCL[i] != '\0') <br>i++ ; <br>lpszNewCL[i] = '\0' ; <br> <br>if ((*lpszNewCL != '\0') &amp;&amp; (strlen(lpszNewCL) &lt;= MAX_COMPUTERNAME_LENGTH)) { <br>int nSizePrefix ; <br> <br>nSizePrefix = lstrlen (szComputerPrefix) ; <br>lstrcpy( CmdLineComputerName, szComputerPrefix ) ; <br>MultiByteToWideChar (CP_ACP, <br>MB_PRECOMPOSED, <br>lpszNewCL, <br>-1, <br>CmdLineComputerName + nSizePrefix, <br>sizeof(CmdLineComputerName) - nSizePrefix) ; <br>//prevent lpszCommandLine from being used as input file &amp; stop while loop <br>*lpszCommandLine = '\0' ; <br>} else { <br>LPTSTRlpszErrMsg ; <br>TCHARlpszFormat[80] ; <br> <br>LoadString(hInstance, ERR_BADCOMPUTERNAME, lpszFormat, sizeof(lpszFormat)/sizeof(TCHAR)) ; <br>lpszErrMsg = (LPTSTR)MemoryAllocate ((strlen (lpszNewCL) + 1)*sizeof(TCHAR) + sizeof(lpszFormat)) ; <br>//If memory allocation failed, don't display error message <br>   if (lpszErrMsg) { <br>//lpszFormat uses %S specifier so lpszNewCL can be ansi string <br>wsprintf (lpszErrMsg, lpszFormat, lpszNewCL) ; <br>MessageBox (NULL, lpszErrMsg, szApplication, MB_OK | MB_ICONSTOP | MB_TASKMODAL) ;  <br>} <br> <br>//prevent lpszCommandLine from being used as input file &amp; stop while loop <br>*lpszCommandLine = '\0' ; <br>} <br>} <br>} <br>lpszNewCL++ ; <br>} <br>} <br> <br>   //=============================// <br>   // Create Window               // <br>   //=============================// <br> <br> <br>   hWndMain = CreateWindow (szPerfmonMainClass, <br>                            szApplication, <br>                          WS_OVERLAPPEDWINDOW | WS_BORDER, <br>                      CW_USEDEFAULT, CW_USEDEFAULT,  <br>                      CW_USEDEFAULT, CW_USEDEFAULT,  <br>                      NULL, <br>                            NULL, <br>                            NULL, <br>                            NULL); <br> <br>   if (!hWndMain) <br>      return (FALSE) ; <br> <br>   ViewChart (hWndMain) ; <br> <br>   LoadMainWindowPlacement (hWndMain) ; <br> <br>   //=============================// <br>   // Setup for event logging     // <br>   //=============================// <br>   hEventLog = RegisterEventSource ( <br>      (LPTSTR)NULL,            // Use Local Machine <br>      TEXT("PerfMon"));        // event log app name to find in registry <br> <br>   return (TRUE) ; <br>   }  // InitializeInstance <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br>BOOL PerfmonInitialize (HINSTANCE hCurrentInstance, <br>                        HINSTANCE hPrevInstance, <br>                        LPCSTR lpszCmdLine, <br>                        int nCmdShow) <br>/* <br>   Effect:        Performa all initializations required when Perfmon is <br>                  started. In particular, initialize all "systems", register <br>                  all window classes, create needed windows, read in and <br>                  process font and Perfmon lists. <br> <br>   Called By:     WinMain only, at the start of the application. <br> <br>   Assert:        There are no other instances of Perfmon currently <br>                  executing. <br> <br>   Returns:       Whether initialization was successful. If this function <br>                  returns FALSE, Perfmon should exit immediately. <br> <br>   Internals:     The bSuccess variable is used to conditionalize each <br>                  successive initialization step. <br>*/ <br>   {  // PerfmonInitialize <br>   BOOL           bSuccess ; <br>   TCHAR          szFilePath [FilePathLen + 1] ; <br>   LPTSTR         pFileNameStart ; <br>   HANDLE         hFindFile ; <br>   WIN32_FIND_DATA FindFileInfo ; <br>   CHAR           QuoteChar ; <br>   LPSTR          pCmdLine ; <br>   LPSTR          lpszCmdLineStart = NULL ; <br>   int            NameOffset ; <br>   int            StringLen ; <br> <br> <br>   hInstance = hCurrentInstance ; <br>   bSuccess = InitializeSystemValues () ; <br> <br>   if (bSuccess &amp;&amp; !hPrevInstance) <br>      bSuccess = InitializeApplication () ; <br> <br>   if (bSuccess) <br>      bSuccess = InitializeInstance (nCmdShow, lpszCmdLine) ; <br> <br>   GetDateTimeFormats() ; <br> <br>   lpszCmdLineStart = lpszCommandLine ; <br> <br> <br>   if (bSuccess) <br>      { <br> <br>      if (strempty (lpszCommandLine)) <br>         StringLoad (IDS_DEFAULTPATH, szFilePath) ; <br>      else <br>         { <br>         // check for single or double quote <br>         QuoteChar = *lpszCommandLine ; <br>         if (QuoteChar == '\'' || QuoteChar == '\"') <br>            { <br>            lpszCommandLine++ ; <br> <br>            // remove the matching QuoteChar if found <br>            pCmdLine = (LPSTR) lpszCommandLine ; <br>            while (*pCmdLine != '\0') <br>               { <br>               if (*pCmdLine == QuoteChar) <br>                  { <br>                  *pCmdLine = '\0' ; <br>                  break ; <br>                  } <br>               else <br>                  { <br>                  pCmdLine++ ; <br>                  } <br>               } <br>            } <br> <br>         // convert the LPSTR to LPTSTR <br> <br>         StringLen = strlen(lpszCommandLine) + 1 ; <br>         if (StringLen &gt; sizeof(szFilePath)) <br>            { <br>            StringLen = sizeof (szFilePath) - sizeof (TEXT('\0')) ; <br>            } <br>         szFilePath[FilePathLen] = TEXT('\0') ; <br> <br>         mbstowcs (szFilePath, lpszCommandLine, StringLen) ; <br> <br>         if (!(QuoteChar == '\'' || QuoteChar == '\"')) <br>            { <br>            // if there is no quote, then looking for trailing space <br>            LPTSTR   lpTempStr = szFilePath ; <br> <br>            while (*lpTempStr != TEXT('\0')) <br>               { <br>               if (*lpTempStr == TEXT(' ')) <br>                  { <br>                  *lpTempStr = TEXT('\0') ; <br>                  break ; <br>                  } <br>               lpTempStr++ ; <br>               } <br>            } <br> <br>         pFileNameStart = ExtractFileName (szFilePath) ; <br>         NameOffset = pFileNameStart - szFilePath ; <br> <br>         // convert short filename to long NTFS filename if necessary <br>         hFindFile = FindFirstFile (szFilePath, &amp;FindFileInfo) ; <br>         if (hFindFile &amp;&amp; hFindFile != INVALID_HANDLE_VALUE) <br>            { <br>            // append the file name back to the path name <br>            lstrcpy (&amp;szFilePath[NameOffset], FindFileInfo.cFileName) ; <br>            FindClose (hFindFile) ; <br>            } <br>         } <br>       <br>//      OpenFileHandler (hWndMain, szFilePath) ; <br>      FileOpen (hWndMain, (int)0, (LPTSTR)szFilePath) ; <br>      PrepareMenu (GetMenu (hWndMain)); <br>      } <br> <br>   if (lpszCmdLineStart) <br>      { <br>      MemoryFree (lpszCmdLineStart) ; <br>      lpszCommandLine = NULL ; <br>      } <br> <br>   return (bSuccess) ; <br>   }  // PerfmonInitialize <br> <br> <br> <br>void PerfmonClose (HWND hWndMain) <br>   { <br>   // close the log file for now. <br>   // need to query the user later..!! <br>#if 0 <br>   if (LogCollecting (hWndLog)) <br>      { <br>      PLOG pLog = LogData (hWndLog) ; <br>       <br>      if (pLog) <br>         { <br>         CloseLog (hWndLog, pLog) ; <br>         } <br>      } <br>#endif <br>       <br> <br>   // reset all views - will free all systems as well <br>   ResetGraphView (hWndGraph) ; <br>   ResetAlertView (hWndAlert) ; <br>   ResetLogView (hWndLog) ; <br>   ResetReportView (hWndReport) ; <br> <br>   // close the local machine <br>   if (bCloseLocalMachine) <br>      { <br>      RegCloseKey (HKEY_PERFORMANCE_DATA) ; <br>      } <br> <br> <br>   // free all the filenames <br>   if (pChartFullFileName) <br>      { <br>      MemoryFree (pChartFullFileName) ; <br>      pChartFullFileName = NULL ; <br>      } <br>   if (pAlertFullFileName) <br>      { <br>      MemoryFree (pAlertFullFileName) ; <br>      pAlertFullFileName = NULL ; <br>      } <br>   if (pLogFullFileName) <br>      { <br>      MemoryFree (pLogFullFileName) ; <br>      pLogFullFileName = NULL ; <br>      } <br>   if (pReportFullFileName) <br>      { <br>      MemoryFree (pReportFullFileName) ; <br>      pReportFullFileName = NULL ; <br>      } <br> <br>   // free all the GDI resources <br>   DeletePen (hWhitePen) ; <br>   DeletePerfmonSystemObjects () ; <br> <br>   // close event log <br>   DeregisterEventSource (hEventLog); <br> <br>   SaveMainWindowPlacement (hWndMain) ; <br>   DestroyWindow (hWndMain) ; <br>   }  // PerfmonClose </code></pre>
<p>&nbsp;</p></body>
</HTML>
