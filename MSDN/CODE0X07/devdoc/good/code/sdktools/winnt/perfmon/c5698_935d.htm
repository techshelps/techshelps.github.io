<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STATUS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5701"></a>STATUS.C</h2>
<pre><code>#include "perfmon.h" <br>#include "status.h"  // External declarations for this file <br>#include &lt;stdio.h&gt;   // for sprintf. <br>#include &lt;stdarg.h&gt;  // For ANSI variable args. Dont use UNIX &lt;varargs.h&gt; <br> <br>#include "log.h"        // for LogCollecting <br>#include "perfmops.h"   // for SmallFileSizeString <br>#include "playback.h"   // for PlayingBackLog <br>#include "utils.h" <br> <br>//================================// <br>// Options for PaintStatusBar     // <br>//================================// <br>#define     PaintText         1 <br>#define     PaintIcons        2 <br>#define     PaintBoundary     4 <br>#define     PaintAll          (PaintText + PaintIcons + PaintBoundary) <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br>#define szStatusClass          TEXT("PerfmonStatusClass") <br>#define dwStatusClassStyle     (CS_HREDRAW | CS_VREDRAW | CS_OWNDC) <br>#define iStatusClassExtra      (0) <br>#define iStatusWindowExtra     (0) <br>#define dwStatusWindowStyle    (WS_CHILD | WS_VISIBLE)  <br> <br> <br>#define szAlertMax            TEXT(" 99 ") <br>#define szAlertFormat         TEXT(" %2d ") <br>#define szAlertOverflow       TEXT(" ++") <br> <br>#define szLogMax              TEXT(" 9,999.9M ") <br> <br>//==========================================================================// <br>//                                Local Data                                // <br>//==========================================================================// <br> <br> <br>HDC            hStatusDC ;                   // for OWN_DC <br> <br>HDC            hLogBitmapDC ; <br>int            xLogBitmapWidth ;      <br>int            yLogBitmapHeight ; <br> <br>HDC            hAlertBitmapDC ; <br>int            xAlertBitmapWidth ;      <br>int            yAlertBitmapHeight ;      <br> <br>int            yStatusHeight ; <br>int            xStatusAlertWidth ;           // of alert bm and num alerts <br>int            xStatusLogWidth ;             // of log bitmap and file size <br> <br>int            szStatusLineLen ;             // no. of char. in szStatusLine <br>TCHAR          szStatusLine [MessageLen+ResourceStringLen] ; <br>TCHAR          szCurrentActivity [ResourceStringLen] ; <br>TCHAR          szStatusFormat  [ResourceStringLen] ; <br>TCHAR          szStatusFormat2 [ResourceStringLen] ; <br> <br>HBITMAP        hBitmapAlertStatus ; <br>HBITMAP        hBitmapLogStatus ; <br> <br> <br> <br>//==========================================================================// <br>//                                   Macros                                 // <br>//==========================================================================// <br> <br> <br>#define StatusTopMargin()     (2) <br>#define StatusLeftMargin()    (2) <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br> <br>void DrawAlerts (HDC hDC, <br>                 LPRECT lpRect) <br>   { <br>   TCHAR          szText [10] ; <br>   RECT           rectText ; <br>   int            yBitmapTop ;      <br> <br>   if (!iUnviewedAlerts) <br>      return ; <br> <br>   yBitmapTop = lpRect-&gt;top + <br>                (lpRect-&gt;bottom -  <br>                 lpRect-&gt;top -  <br>                 yAlertBitmapHeight) / 2 ; <br> <br>   SetTextColor (hDC, crLastUnviewedAlert) ; <br> <br>   BitBlt (hDC,                           // DC for Destination surface <br>      lpRect-&gt;right - xStatusAlertWidth,  // x pos for Destination surface <br>      yBitmapTop,                         // y for Destination surface <br>      xAlertBitmapWidth,                  // width of bitmap <br>      yAlertBitmapHeight,                 // height of bitmap <br>      hAlertBitmapDC,                     // DC for source surface <br>      0, 0,                               // location in source surface <br>      SRCCOPY) ;                          // ROP code <br>    <br>   SetTextColor (hDC, crBlack) ; <br> <br>   if (iUnviewedAlerts &gt; 99) <br>      lstrcpy (szText, szAlertOverflow) ; <br>   else <br>      TSPRINTF (szText, szAlertFormat, iUnviewedAlerts) ; <br> <br>   rectText.left = lpRect-&gt;right - xStatusAlertWidth + xAlertBitmapWidth ; <br>   rectText.top = lpRect-&gt;top + 1 ; <br>   rectText.right = lpRect-&gt;right - 1 ; <br>   rectText.bottom = lpRect-&gt;bottom - 1 ; <br> <br>   ExtTextOut (hDC, rectText.left, rectText.top, ETO_CLIPPED | ETO_OPAQUE, <br>      &amp;rectText, szText, lstrlen (szText), NULL) ; <br> <br>   lpRect-&gt;right -= (xStatusAlertWidth + (xAlertBitmapWidth &gt;&gt; 2)) ; <br>   }  // DrawAlerts <br> <br> <br>void DrawLog (HDC hDC, <br>              LPRECT lpRect) <br>   { <br>   TCHAR          szText [10] ; <br>   RECT           rectText ; <br>   int            yBitmapTop ;      <br> <br>   if (!LogCollecting (hWndLog)) <br>      return ; <br> <br>   yBitmapTop = lpRect-&gt;top + <br>                (lpRect-&gt;bottom -  <br>                 lpRect-&gt;top -  <br>                 yLogBitmapHeight) / 2 ; <br>   BitBlt (hDC,                           // DC for Destination surface <br>      lpRect-&gt;right - xStatusLogWidth,    // x pos for Destination surface <br>      yBitmapTop,                         // y for Destination surface <br>      xLogBitmapWidth,                    // width of bitmap <br>      yLogBitmapHeight,                   // height of bitmap <br>      hLogBitmapDC,                       // DC for source surface <br>      0, 0,                               // location in source surface <br>      SRCCOPY) ;                          // ROP code <br> <br> <br>   SmallFileSizeString (LogFileSize (hWndLog), szText) ; <br> <br>   rectText.left = lpRect-&gt;right - xStatusLogWidth + <br>      xLogBitmapWidth + 1 ; <br>   rectText.top = lpRect-&gt;top + 1 ; <br>   rectText.right = lpRect-&gt;right - 1 ; <br>   rectText.bottom = lpRect-&gt;bottom - 1 ; <br> <br>   ExtTextOut (hDC, rectText.left, rectText.top, ETO_CLIPPED | ETO_OPAQUE, <br>      &amp;rectText, szText, lstrlen (szText), NULL) ; <br> <br>   lpRect-&gt;right -= xStatusLogWidth ; <br>   }  // DrawLog <br> <br> <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br> <br>void static OnCreate (HWND hWnd) <br>/* <br>   Effect:        Perform any actions needed when a status window is created. <br>                  In particular, set the instance data to initial values, <br>                  determine the size and placement of the various elements <br>                  of the status display. <br> <br>   Called By:     StatusWndProc only, in response to a WM_CREATE message. <br>*/ <br>   {  // OnCreate <br>   HDC            hDC ; <br> <br> <br>   hBitmapAlertStatus = LoadBitmap (hInstance, idBitmapAlertStatus) ; <br>   hBitmapLogStatus = LoadBitmap (hInstance, idBitmapLogStatus) ; <br> <br>   hDC = hStatusDC = GetDC (hWnd) ; <br>   SelectFont (hDC, hFontScales) ; <br>   SetBkColor (hDC, ColorBtnFace) ; <br>   SetTextAlign (hDC, TA_LEFT) ; <br>   SetBkMode (hDC, OPAQUE) ; <br> <br>   yStatusHeight = 2 * StatusTopMargin () +  <br>                   FontHeight (hDC, TRUE) + <br>                   2 * ThreeDPad ; <br>    <br>   BitmapDimemsion (hBitmapLogStatus, &amp;yLogBitmapHeight, &amp;xLogBitmapWidth) ; <br>   BitmapDimemsion (hBitmapAlertStatus, &amp;yAlertBitmapHeight, &amp;xAlertBitmapWidth) ; <br> <br>   // pre-load the log and alert bitmaps for perfmormance <br> <br>   hLogBitmapDC = CreateCompatibleDC (hDC) ; <br>   SelectObject (hLogBitmapDC, hBitmapLogStatus) ; <br> <br>   hAlertBitmapDC = CreateCompatibleDC (hDC) ; <br>   SelectObject (hAlertBitmapDC, hBitmapAlertStatus) ; <br> <br> <br>   xStatusAlertWidth = xAlertBitmapWidth + 1 + <br>                       TextWidth (hDC, szAlertMax) ; <br>   xStatusLogWidth = xLogBitmapWidth + <br>                     TextWidth (hDC, szLogMax) ; <br> <br> <br>   StringLoad (IDS_CURRENTACTIVITY, szCurrentActivity) ; <br>   StringLoad (IDS_STATUSFORMAT, szStatusFormat) ; <br>   StringLoad (IDS_STATUSFORMAT2, szStatusFormat2) ; <br> <br>   StatusLineReady (hWnd) ; <br>   }  // OnCreate <br> <br>void static OnDestroy (HWND hWnd) <br>   { <br>   if (hBitmapAlertStatus) <br>      { <br>      DeleteObject (hBitmapAlertStatus) ; <br>      hBitmapAlertStatus = 0 ; <br>      } <br> <br>   if (hBitmapLogStatus) <br>      { <br>      DeleteObject (hBitmapLogStatus) ; <br>      hBitmapLogStatus = 0 ; <br>      } <br>   ReleaseDC (hWnd, hStatusDC) ; <br> <br>   }  // OnDestroy <br> <br>void static PaintStatusBar (HWND hWnd, HDC hDC, int PaintOptions) <br>/* <br>   Effect:        Paint the invalid surface of hWnd. Draw each label, each <br>                  recessed value box, and each value. <br> <br>   Called By:     StatusWndProc only, in response to a WM_PAINT message. <br>*/ <br>   { <br>   RECT           rectClient ; <br> <br>   if (bPerfmonIconic) <br>      { <br>      // no need to draw anything if iconic <br>      return ; <br>      } <br> <br>   GetClientRect (hWnd, &amp;rectClient) ; <br> <br>   RectContract (&amp;rectClient, StatusTopMargin (), StatusLeftMargin ()) ; <br>    <br>   if (PaintOptions == PaintAll) <br>      { <br>      ThreeDConcave1 (hDC, <br>                     rectClient.left, rectClient.top, <br>                     rectClient.right, rectClient.bottom) ; <br>      } <br> <br>   rectClient.left += StatusLeftMargin () ; <br> <br>   // Always draw the icons and need to draw log before Alerts! <br>   DrawLog (hDC, &amp;rectClient) ; <br>   DrawAlerts (hDC, &amp;rectClient) ; <br> <br>   if (PaintOptions &amp; PaintText) <br>      { <br>      rectClient.left += 1 ; <br>      rectClient.top += 1 ; <br>      rectClient.right -= 1 ; <br>      rectClient.bottom -= 1 ; <br>      ExtTextOut (hDC, rectClient.left, rectClient.top, ETO_CLIPPED | ETO_OPAQUE, <br>         &amp;rectClient, szStatusLine, szStatusLineLen, NULL) ; <br>      } <br> <br>   }  // PaintStatusBar <br> <br> <br> <br> <br>LRESULT APIENTRY StatusWndProc (HWND hWnd, <br>                                WORD wMsg, <br>                                WPARAM wParam, <br>                                LPARAM lParam) <br>   {  // StatusWndProc <br>   BOOL           bCallDefProc ; <br>   LRESULT        lReturnValue ; <br>   HDC            hDC ; <br>   PAINTSTRUCT    ps ; <br> <br> <br>   bCallDefProc = FALSE ; <br>   lReturnValue = 0L ; <br> <br>   switch (wMsg) <br>      {  // switch <br>      case WM_PAINT: <br>         hDC = BeginPaint (hWnd, &amp;ps) ; <br>         PaintStatusBar (hWnd, hDC, PaintAll) ; <br>         EndPaint (hWnd, &amp;ps) ; <br>         break ; <br> <br>      case WM_CREATE: <br>         OnCreate (hWnd) ; <br>         break ; <br> <br>      case WM_DESTROY: <br>         OnDestroy (hWnd) ; <br>         break ; <br> <br>      default: <br>         bCallDefProc = TRUE ; <br>      }  // switch <br> <br> <br>   if (bCallDefProc) <br>      lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ; <br> <br>   return (lReturnValue); <br>   }  // StatusWndProc <br> <br> <br>int StatusHeight (HWND hWnd) <br>/* <br>   Effect:        A status window has a preferred height, based on the font <br>                  used in its display. Return the preferred height, determined <br>                  when the window was created. <br> <br>   Assert:        OnCreate has already been called, and it set  <br>                  StatusData.yHeight. <br>*/   <br>   { <br>   return (yStatusHeight) ; <br>   } <br> <br> <br> <br> <br>HWND CreatePMStatusWindow (HWND hWnd) <br>   { <br>   return (CreateWindow (szStatusClass,       // class <br>                         NULL,                // caption <br>                         dwStatusWindowStyle, // window style <br>                         0, 0,                // position <br>                         0, 0,                // size <br>                         hWnd,                // parent window <br>                         NULL,                // menu <br>                         hInstance,           // program instance <br>                         NULL)) ;             // user-supplied data <br>   }  // CreateStatusWindow <br> <br> <br> <br> <br>BOOL StatusInitializeApplication (void) <br>/* <br>   Called By:     InitializeApplication only <br>*/ <br>   { <br>   WNDCLASS       wc ; <br> <br>   wc.style          = dwStatusClassStyle ; <br>   wc.lpfnWndProc    = (WNDPROC) StatusWndProc ; <br>   wc.hInstance      = hInstance ; <br>   wc.cbClsExtra     = iStatusClassExtra ; <br>   wc.cbWndExtra     = iStatusWindowExtra ; <br>   wc.hIcon          = NULL ; <br>   wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ; <br>   wc.hbrBackground  = hbLightGray ; <br>   wc.lpszMenuName   = NULL ; <br>   wc.lpszClassName  = szStatusClass ; <br> <br>   return (RegisterClass (&amp;wc)) ; <br>   } <br>    <br>BOOL _cdecl StatusLine (HWND hWnd, <br>                        WORD wStringID, ...) <br>   { <br>   TCHAR          szFormat [MessageLen] ; <br>   va_list        vaList ; <br> <br>   if (wStringID == 0) <br>      { <br>      return (TRUE) ; <br>      } <br> <br>   strclr (szStatusLine) ; <br> <br>   if (LoadString (hInstance, wStringID, szFormat, MessageLen)) <br>      { <br>      va_start (vaList, wStringID) ; <br>      TSPRINTF (szStatusLine, szFormat, vaList) ; <br>//      wvsprintf (szStatusLine, szFormat, vaList) ; <br>      va_end (vaList) ; <br>      dwCurrentMenuID = MenuIDToHelpID (wStringID) ; <br>      szStatusLineLen = lstrlen (szStatusLine) ; <br>      } <br>   else <br>      { <br>      dwCurrentMenuID = 0 ; <br>      szStatusLineLen = 0 ; <br>      } <br>   PaintStatusBar (hWndStatus, hStatusDC, PaintText + PaintIcons) ; <br> <br>   return (TRUE) ; <br>   }  // StatusLine <br> <br> <br> <br>void StatusLineReady (HWND hWnd) <br>   { <br>   int         stringLen ; <br>   LPTSTR      pFileName = NULL ; <br> <br>   TSPRINTF (szStatusLine, szStatusFormat,  <br>             PlayingBackLog () ?  <br>               PlaybackLog.szFileTitle : szCurrentActivity) ; <br> <br>   switch (iPerfmonView) <br>      { <br>      case IDM_VIEWCHART: <br>         pFileName = pChartFileName ; <br>         break ; <br> <br>      case IDM_VIEWALERT: <br>         pFileName = pAlertFileName ; <br>         break ; <br> <br>      case IDM_VIEWLOG: <br>         pFileName = pLogFileName ; <br>         break ; <br> <br>      case IDM_VIEWREPORT: <br>         pFileName = pReportFileName ; <br>         break ; <br>      } <br> <br>   if (pFileName) <br>      { <br>      stringLen = lstrlen (szStatusLine) ; <br>      TSPRINTF (&amp;szStatusLine[stringLen], szStatusFormat2, pFileName) ; <br>      } <br> <br>   szStatusLineLen = lstrlen (szStatusLine) ; <br> <br>   PaintStatusBar (hWndStatus, hStatusDC, PaintText + PaintIcons) ; <br>   } <br> <br> <br>void StatusUpdateIcons (HWND hWndStatus) <br>   {   <br>   PaintStatusBar (hWndStatus, hStatusDC, PaintIcons) ; <br>   } <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
