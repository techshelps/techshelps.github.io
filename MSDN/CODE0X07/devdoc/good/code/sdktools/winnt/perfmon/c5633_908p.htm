<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GRAFDATA.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5659"></a>GRAFDATA.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  Grafdata.c - This module handles the non-drawing functions of the graph, <br> *      such as allocating linked structures and their memory, freeing it, <br> *      unlinking, starting and stopping the timer, <br> *      setting up the first graph (CPU), and all the numeric functions for <br> *      the different counter types. <br> * <br> *  Microsoft Confidential <br> *  Copyright 1992 - 1998 Microsoft Corporation <br> * <br> * <br> ****************************************************************************/ <br> <br> <br>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br>#include &lt;stdio.h&gt;      // for sprintf <br> <br>#include "perfmon.h"       // main perfmon declarations <br>#include "grafdata.h"      // external declarations for this file <br>#include &lt;float.h&gt;         // for FLT_MAX constant <br> <br>#include "addline.h"       // for AddLine, EditLine <br>#include "counters.h"      // for CounterEntry <br>#include "graph.h"         // for SizeGraphComponents <br>#include "pmemory.h"       // for MemoryXXX (mallloc-type) routines <br>#include "perfdata.h"      // for UpdateLines <br>#include "playback.h"      // for PlayingBackLog, PlaybackLines <br>#include "legend.h" <br>#include "system.h"        // for SystemGet <br>#include "utils.h" <br>#include "line.h"          // for LineFree <br>#include "valuebar.h"      // for StatusTimer <br> <br>#include "fileopen.h"      // for FileGetName <br>#include "fileutil.h"      // for FileRead... <br>#include "menuids.h"       // for IDM_VIEWCHART <br>#include "perfmops.h"      // for ExportFileHeader <br>#include "status.h"        // for StatusLineReady <br> <br>extern BOOL SaveFileHandler(HWND hWnd,DWORD type) ; <br> <br>// this macro is used in doing a simple DDA (Digital Differential Analyzer) <br>// * 10 + 5 is to make the result round up with .5 <br>#define DDA_DISTRIBUTE(TotalTics, numOfData) \ <br>   ((TotalTics * 10 / numOfData) + 5) / 10 <br> <br>#define szSmallValueFormat         TEXT("%10.3f") <br>#define szLargeValueFormat         TEXT("%10.0f") <br> <br>//==========================================================================// <br>//                                Local Data                                // <br>//==========================================================================// <br> <br> <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br> <br>/**************************************************************************** <br> * eUpdateMinMaxAve - <br> ****************************************************************************/ <br>void eUpdateMinMaxAve (FLOAT eValue, PLINESTRUCT pLineStruct, INT iValidValues, <br>   INT iTotalValidPoints, INT iDataPoint, INT gMaxPoints) <br>{ <br>INT     i ; <br>INT     iDataNum = iTotalValidPoints ; <br>FLOAT   eMin, <br>        eMax, <br>        eSum, <br>        eNewValue ; <br> <br> <br>   eMax = eMin = eValue ; <br> <br>   if (PlayingBackLog()) <br>      { <br>      eSum = (FLOAT) 0.0 ; <br>      } <br>   else <br>      { <br>      eSum = eValue ; <br>      } <br> <br>   if (iValidValues == iTotalValidPoints) <br>      { <br>      for (i=0 ; i &lt; iValidValues ; i++) <br>         { <br>         if (i == iDataPoint) <br>            { <br>            // skip the data point we are going to replace <br>            continue ; <br>            } <br> <br>         eNewValue = pLineStruct-&gt;lnValues[i] ; <br>          <br>         eSum += eNewValue ; <br> <br>         if (eNewValue &gt; eMax) <br>            { <br>            eMax = eNewValue ; <br>            } <br> <br>         if (eNewValue &lt; eMin) <br>            { <br>            eMin = eNewValue ; <br>            } <br>         } <br>      } <br>   else <br>      { <br>      // special case when we start the new line in the middle of the chart <br>      for (i = iDataPoint, iTotalValidPoints-- ; <br>          iTotalValidPoints &gt; 0 ; <br>          iTotalValidPoints-- ) <br>         { <br>         i-- ; <br>         if (i &lt; 0) <br>            { <br>            // for the wrap-around case.. <br>            i = gMaxPoints - 1 ; <br>            } <br> <br>         if (i == iDataPoint) <br>            { <br>            // skip the data point we are going to replace <br>            continue ; <br>            } <br>         eNewValue = pLineStruct-&gt;lnValues[i] ; <br> <br>         eSum += eNewValue ; <br> <br>         if (eNewValue &gt; eMax) <br>            { <br>            eMax = eNewValue ; <br>            } <br> <br>         if (eNewValue &lt; eMin) <br>            { <br>            eMin = eNewValue ; <br>            } <br>         } <br>      } <br> <br>   pLineStruct-&gt;lnMinValue = eMin ; <br>   pLineStruct-&gt;lnMaxValue = eMax ; <br> <br>   if (iDataNum) <br>      { <br>      pLineStruct-&gt;lnAveValue = eSum / (FLOAT) iDataNum ; <br>      } <br>   else <br>      { <br>      pLineStruct-&gt;lnAveValue = (FLOAT) 0.0 ; <br>      } <br>} <br> <br> <br>// UpdateValueBarData is used to update the value bar data <br>// It is called when the user switches to a diff. line from <br>// the legned window. <br>VOID UpdateValueBarData (PGRAPHSTRUCT pGraph) <br>   { <br>   PLINESTRUCT    pCurrentGraphLine ;    <br>   INT            KnownValue, <br>                  MaxValues, <br>                  iValidValues, <br>                  iDataPoint ; <br>   FLOAT          eValue ; <br>   pCurrentGraphLine = CurrentGraphLine (hWndGraph) ; <br> <br>   if (!pCurrentGraphLine || pCurrentGraphLine-&gt;bFirstTime) <br>      { <br>      // we have not collect enough samples <br>      return ; <br>      } <br> <br>   KnownValue = pGraph-&gt;gKnownValue ; <br>   MaxValues = pGraph-&gt;gMaxValues ; <br> <br>   // The valid values is the number of valid entries in the <br>   // data buffer.  After we wrap the buffer, all the values are <br>   // valid. <br>   iValidValues = pGraph-&gt;gTimeLine.iValidValues ; <br> <br>   // Get the index to the data point we are updating. <br> <br>   iDataPoint = KnownValue % MaxValues ; <br>   eValue = pCurrentGraphLine-&gt;lnValues[iDataPoint] ; <br> <br>   // get the statistical data for this line <br>   eUpdateMinMaxAve(eValue, pCurrentGraphLine, <br>      iValidValues, pCurrentGraphLine-&gt;lnValidValues, <br>      iDataPoint, MaxValues) ; <br>   }  // UpdateValueBarData <br> <br> <br>VOID UpdateLGData (PGRAPHSTRUCT pGraph) <br>   { <br>   PLINESTRUCT    pLine ;                <br>   PLINESTRUCT    pCurrentGraphLine ;    <br>   INT            KnownValue, <br>                  MaxValues, <br>                  iValidValues, <br>                  iDataPoint ; <br>   FLOAT          eValue ; <br>   // Known Value is the where data is placed in the buffer. <br>   pGraph-&gt;gKnownValue++; <br> <br>   KnownValue = pGraph-&gt;gKnownValue ; <br> <br>   // Update the high water mark for valid data in the lnValues <br>   // (aka DataPoint) buffer. <br> <br> <br>   MaxValues = pGraph-&gt;gMaxValues ; <br> <br>   // The valid values is the number of valid entries in the <br>   // data buffer.  After we wrap the buffer, all the values are <br>   // valid. <br>   iValidValues = pGraph-&gt;gTimeLine.iValidValues ; <br> <br>   if (iValidValues &lt; MaxValues) <br>       iValidValues = (KnownValue % MaxValues) + 1 ; <br> <br>   pGraph-&gt;gTimeLine.iValidValues = iValidValues ; <br> <br>   // Get the index to the data point we are updating. <br> <br>   iDataPoint = KnownValue % MaxValues ; <br> <br>   // loop through lines, <br>   // If one of the lines is highlighted then do the calculations <br>   // for average, min, &amp; max on that line. <br> <br>   pCurrentGraphLine = CurrentGraphLine (hWndGraph) ; <br> <br>   for (pLine=pGraph-&gt;pLineFirst; pLine; pLine=pLine-&gt;pLineNext) <br>     { // for <br> <br>     if (pLine-&gt;bFirstTime) <br>         { <br>         // skip until we have collect enough samples to plot the first data <br>         continue ; <br>         } <br> <br>     if (pLine-&gt;lnValidValues &lt; MaxValues) <br>         {    <br>         (pLine-&gt;lnValidValues)++ ; <br>         } <br>    <br>     // Get the new value for this line. <br>     eValue = CounterEntry (pLine) ; <br> <br>     if (pLine == pCurrentGraphLine) <br>        {  // if <br>        // get the statistical data for this line <br>        eUpdateMinMaxAve (eValue, pLine,  <br>                                 iValidValues, pLine-&gt;lnValidValues, <br>                                 iDataPoint, MaxValues) ; <br>        }  // if <br>       <br>     // Now put the new value into the data array <br>     pLine-&gt;lnValues[iDataPoint] = eValue ; <br>     } <br>    <br>   GetLocalTime (&amp;(pGraph-&gt;pDataTime[iDataPoint])) ;  <br>   }  // UpdateLGData <br> <br> <br> <br>BOOL HandleGraphTimer (void) <br>   { <br>   PGRAPHSTRUCT pGraph; <br> <br>   //NOTE: get a strategy for these "no-go" states <br>   if (!(pGraph = pGraphs) || !pGraphs-&gt;pSystemFirst) <br>       return(FALSE); <br> <br> <br>   if (!UpdateLines(&amp;(pGraphs-&gt;pSystemFirst), pGraphs-&gt;pLineFirst)) <br>        return (TRUE) ; <br> <br>   UpdateLGData(pGraph); <br> <br>   return(TRUE); <br>   } <br> <br> <br>VOID ClearGraphTimer(PGRAPHSTRUCT pGraph) <br>   { <br>   KillTimer(pGraph-&gt;hWnd, GRAPH_TIMER_ID); <br>   } <br> <br> <br>VOID SetGraphTimer(PGRAPHSTRUCT pGraph) <br>   { <br>   SetTimer(pGraph-&gt;hWnd, GRAPH_TIMER_ID, pGraph-&gt;gInterval, NULL) ; <br>   } <br> <br>VOID ResetGraphTimer(PGRAPHSTRUCT pGraph) <br>{ <br>    KillTimer(pGraph-&gt;hWnd, GRAPH_TIMER_ID); <br>    SetGraphTimer(pGraph); <br>} <br> <br> <br>VOID GetGraphConfig(PGRAPHSTRUCT pGraph) <br>{ <br> <br>    LoadRefreshSettings(pGraph); <br>    LoadLineGraphSettings(pGraph); <br> <br> <br>    // Init the structure <br>    pGraph-&gt;pLineFirst = NULL; <br> <br>    //NOTE: put the rest of this in Config <br> <br>    pGraph-&gt;gOptions.bLegendChecked    = TRUE; <br>    pGraph-&gt;gOptions.bMenuChecked      = TRUE; <br>    pGraph-&gt;gOptions.bLabelsChecked    = TRUE; <br>    pGraph-&gt;gOptions.bVertGridChecked  = FALSE; <br>    pGraph-&gt;gOptions.bHorzGridChecked  = FALSE; <br>    pGraph-&gt;gOptions.bStatusBarChecked = TRUE; <br>    pGraph-&gt;gOptions.GraphVGrid        = TRUE; <br>    pGraph-&gt;gOptions.GraphHGrid        = TRUE; <br>    pGraph-&gt;gOptions.HistVGrid         = TRUE; <br>    pGraph-&gt;gOptions.HistHGrid         = TRUE; <br> <br>    pGraph-&gt;gOptions.iGraphOrHistogram = LINE_GRAPH;       // vs. BAR_GRAPH <br>    pGraph-&gt;gOptions.iVertMax = DEF_GRAPH_VMAX; <br> <br>    return; <br>} <br> <br> <br>BOOL InsertGraph (HWND hWnd) <br>   { <br>   PGRAPHSTRUCT    pGraph; <br> <br>   pGraph = MemoryAllocate (sizeof (GRAPHSTRUCT)) ; <br>   if (!pGraph) <br>      return (FALSE) ; <br> <br> <br>   pGraphs = pGraph; <br> <br>    <br>   GetGraphConfig(pGraph); <br>   pGraph-&gt;bManualRefresh = FALSE ; <br> <br>   pGraph-&gt;gMaxValues = DEFAULT_MAX_VALUES; <br>   pGraph-&gt;pptDataPoints =  <br>      (PPOINT) MemoryAllocate (sizeof (POINT) * pGraph-&gt;gMaxValues) ; <br> <br>   pGraph-&gt;pDataTime = <br>      (SYSTEMTIME *) MemoryAllocate (sizeof(SYSTEMTIME) * pGraph-&gt;gMaxValues) ; <br> <br>   pGraph-&gt;hWnd = hWnd ; <br>   pGraph-&gt;bModified = FALSE ; <br> <br>   pGraph-&gt;Visual.iColorIndex = 0 ; <br>   pGraph-&gt;Visual.iWidthIndex = 0 ; <br>   pGraph-&gt;Visual.iStyleIndex = 0 ; <br> <br>   return(TRUE) ; <br>   } <br> <br> <br> <br>void PlaybackSetGraphLines (HWND hWndChart,  <br>                            PLINE pLineFirst,  <br>                            int iDisplayTic, <br>                            int iLogTic, <br>                            BOOL CalcData) <br>   { <br>   PLINE          pLine ; <br>   FLOAT          eValue ; <br> <br>   for (pLine = pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineNext) <br>      {  // for <br>      eValue = CounterEntry (pLine) ; <br>      pLine-&gt;lnValues[iDisplayTic] = eValue ; <br>      pLine-&gt;aiLogIndexes[iDisplayTic] = iLogTic ; <br> <br>      // only need to do this on request. <br>      if (CalcData) <br>         { <br>         eUpdateMinMaxAve (eValue, pLine, iDisplayTic, iDisplayTic, <br>            iDisplayTic, iDisplayTic) ; <br>         }  // if <br>      }  // for <br>   }  // PlaybackSetGraphLines <br> <br> <br> <br>BOOL ChartInsertLine (PGRAPHSTRUCT pGraph,  <br>                      PLINE pLine) <br>/* <br>   Effect:        Insert the line pLine into the graph pGraph and  <br>                  allocate space for the graph's number of values. <br> <br>   Returns:       Whether the line could be added and space allocated. <br> <br>   See Also:      LineAllocate (line.c), ChartDeleteLine. <br>*/ <br>   {  // ChartInsertLine <br>   PLINE          pLineEquivalent ; <br>   INT            i ; <br>   FLOAT          *pTempPts; <br>   HPEN           tempPen ; <br> <br>   pGraph-&gt;bModified = TRUE ; <br> <br>   pLineEquivalent = FindEquivalentLine (pLine, pGraph-&gt;pLineFirst) ; <br>   if (pLineEquivalent) <br>      { <br>      pLineEquivalent-&gt;Visual = pLine-&gt;Visual ; <br>      pLineEquivalent-&gt;iScaleIndex = pLine-&gt;iScaleIndex ; <br>      pLineEquivalent-&gt;eScale = pLine-&gt;eScale ; <br> <br>      tempPen = pLineEquivalent-&gt;hPen ; <br>      pLineEquivalent-&gt;hPen =  pLine-&gt;hPen ; <br>      pLine-&gt;hPen = tempPen ; <br>      return FALSE ; <br>      } <br>   else <br>      { <br>      if (!pGraph-&gt;pLineFirst &amp;&amp; !PlayingBackLog()) <br>         { <br>         SetGraphTimer (pGraph) ; <br>         } <br> <br>      if (!SystemAdd (&amp;pGraph-&gt;pSystemFirst, pLine-&gt;lnSystemName)) <br>        return FALSE; <br> <br>      LineAppend (&amp;pGraph-&gt;pLineFirst, pLine) ; <br> <br>      pLine-&gt;lnMinValue = FLT_MAX ; <br>      pLine-&gt;lnMaxValue = - FLT_MAX ; <br>      pLine-&gt;lnAveValue = 0.0F ; <br>      pLine-&gt;lnValidValues = 0 ; <br> <br>      pLine-&gt;lnValues =  <br>         (FLOAT *) MemoryAllocate (sizeof (FLOAT) * pGraph-&gt;gMaxValues) ; <br>       <br>      for (i = pGraph-&gt;gMaxValues, pTempPts = pLine-&gt;lnValues ; <br>           i &gt; 0 ; <br>           i-- ) <br>         { <br>         *pTempPts++ = (FLOAT) 0.0 ; <br>         } <br> <br>      if (PlayingBackLog ()) <br>         { <br>         pLine-&gt;aiLogIndexes = <br>            (int *) MemoryAllocate (sizeof (LONG) * pGraph-&gt;gMaxValues) ; <br>         } <br> <br>      // Add the line to the legend, resize the legend window, and then <br>      // select the new line as the current legend item. Do it in this  <br>      // sequence to avoid the legend scroll bar momentarily appearing and <br>      // then disappearing, since the resize will obviate the scroll bar. <br> <br>      LegendAddItem (hWndGraphLegend, pLine) ; <br> <br>      if (!bDelayAddAction) <br>         { <br>         SizeGraphComponents (hWndGraph) ; <br>         LegendSetSelection (hWndGraphLegend,  <br>                          LegendNumItems (hWndGraphLegend) - 1) ; <br> <br>         if (PlayingBackLog ()) <br>            PlaybackChart (pGraph-&gt;hWnd) ; <br>         } <br>      } <br> <br>   return (TRUE) ; <br>   }  // ChartInsertLine <br> <br> <br>VOID ChartDeleteLine (PGRAPHSTRUCT pGraph,  <br>                      PLINESTRUCT pLine) <br>   { <br>   PLINESTRUCT npLine; <br> <br> <br>   pGraph-&gt;bModified = TRUE ; <br> <br>   if (pGraph-&gt;pLineFirst == pLine) <br>       pGraph-&gt;pLineFirst = pLine-&gt;pLineNext; <br>   else <br>   { <br>       for (npLine = pGraph-&gt;pLineFirst; npLine; npLine = npLine-&gt;pLineNext) <br>       { <br>           if (npLine-&gt;pLineNext == pLine) <br>               npLine-&gt;pLineNext = pLine-&gt;pLineNext; <br>       } <br>   } <br> <br>   if (!pGraph-&gt;pLineFirst) <br>      { <br>      ResetGraph (pGraph) ; <br>      } <br>   else <br>      { <br>      BuildValueListForSystems ( <br>         pGraph-&gt;pSystemFirst, <br>         pGraph-&gt;pLineFirst) ; <br>      } <br> <br>   // Delete the legend entry for this line. <br>   // If the line was highlighted then this will undo the highlight. <br> <br>   LegendDeleteItem (hWndGraphLegend, pLine) ; <br> <br>   LineFree (pLine) ; <br> <br>   SizeGraphComponents (hWndGraph) ; <br> <br> <br>   } <br> <br> <br>FLOAT Counter_Queuelen(PLINESTRUCT pLine) <br>{ <br> <br>    return((FLOAT)0.0); <br>//    pLine; <br>} <br> <br> <br>void ClearGraphDisplay (PGRAPHSTRUCT pGraph) <br>   { <br>   PLINESTRUCT    pLine; <br> <br>   // reset the timeline data <br>//   pGraph-&gt;gKnownValue = -1 ; <br>   pGraph-&gt;gKnownValue = 0 ; <br>   pGraph-&gt;gTimeLine.iValidValues = 0 ; <br>   pGraph-&gt;gTimeLine.xLastTime = 0 ; <br>   memset (pGraph-&gt;pDataTime, 0, sizeof(SYSTEMTIME) * pGraph-&gt;gMaxValues) ; <br> <br>   // loop through lines, <br>   // If one of the lines is highlighted then do the calculations <br>   // for average, min, &amp; max on that line. <br> <br>   for (pLine=pGraph-&gt;pLineFirst; pLine; pLine=pLine-&gt;pLineNext) <br>      { // for <br> <br>      pLine-&gt;bFirstTime = 2 ; <br>      pLine-&gt;lnMinValue = FLT_MAX ; <br>      pLine-&gt;lnMaxValue = - FLT_MAX ; <br>      pLine-&gt;lnAveValue = 0.0F ; <br>      pLine-&gt;lnValidValues = 0 ; <br>      memset (pLine-&gt;lnValues, 0, sizeof(FLOAT) * pGraph-&gt;gMaxValues) ; <br>      } <br> <br>   StatusTimer (hWndGraphStatus, TRUE) ; <br>   WindowInvalidate (hWndGraphDisplay) ; <br>   } <br> <br>void ResetGraphView (HWND hWndGraph) <br>   { <br>   PGRAPHSTRUCT      pGraph ; <br> <br>   pGraph = GraphData (hWndGraph) ; <br> <br> <br>   if (!pGraph) <br>      { <br>      return ; <br>      } <br> <br>   ChangeSaveFileName (NULL, IDM_VIEWCHART) ; <br> <br>   if (pGraph-&gt;pSystemFirst) <br>      { <br>      ResetGraph (pGraph) ; <br>      } <br>   }  // ResetGraphView <br> <br>void ResetGraph (PGRAPHSTRUCT pGraph) <br>   { <br>   ClearGraphTimer (pGraph) ; <br>   ClearLegend (hWndGraphLegend) ; <br>   if (pGraph-&gt;pLineFirst) <br>      { <br>      FreeLines (pGraph-&gt;pLineFirst) ; <br>      pGraph-&gt;pLineFirst = NULL ; <br>      } <br> <br>   if (pGraph-&gt;pSystemFirst) <br>      { <br>      FreeSystems (pGraph-&gt;pSystemFirst) ; <br>      pGraph-&gt;pSystemFirst = NULL ; <br>      } <br>//   pGraph-&gt;gKnownValue = -1 ; <br>   pGraph-&gt;gKnownValue = 0 ; <br>   pGraph-&gt;gTimeLine.iValidValues = 0 ; <br>   pGraph-&gt;gTimeLine.xLastTime = 0 ; <br> <br>   // reset visual data <br>   pGraph-&gt;Visual.iColorIndex = 0 ; <br>   pGraph-&gt;Visual.iWidthIndex = 0 ; <br>   pGraph-&gt;Visual.iStyleIndex = 0 ; <br> <br>   memset (pGraph-&gt;pDataTime, 0, sizeof(SYSTEMTIME) * pGraph-&gt;gMaxValues) ; <br> <br>   SizeGraphComponents (hWndGraph) ; <br>   InvalidateRect(hWndGraph, NULL, TRUE) ; <br>   } <br> <br> <br> <br>void PlaybackChart (HWND hWndChart) <br>   {  // PlaybackChart <br>   int            iDisplayTics ;       // num visual points to display <br>   int            iDisplayTic ; <br>   int            iLogTic ; <br>   int            iLogTicsMove ; <br>   BOOL           bFirstTime = TRUE; <br>   int            iLogTicsRemaining ; <br> <br>   if (!pGraphs-&gt;pLineFirst) <br>      { <br>      // no line to playback <br>      return ; <br>      } <br> <br>   iLogTicsRemaining = PlaybackLog.iSelectedTics ; <br> <br> <br>   // we only have iDisplayTics-1 points since <br>   // we have to use the first two sample points to <br>   // get the first data points. <br>   if (iLogTicsRemaining &lt;= pGraphs-&gt;gMaxValues) <br>      { <br>      iDisplayTics = iLogTicsRemaining ; <br>      pGraphs-&gt;gTimeLine.iValidValues = iDisplayTics - 1 ; <br>      } <br>   else <br>      { <br>      iDisplayTics = pGraphs-&gt;gMaxValues ; <br>      pGraphs-&gt;gTimeLine.iValidValues = iDisplayTics ; <br>      } <br> <br>   iDisplayTic = -1 ; <br>   iLogTic = PlaybackLog.StartIndexPos.iPosition ; <br> <br>   while (iDisplayTics) <br>      { <br> <br>      PlaybackLines (pGraphs-&gt;pSystemFirst,  <br>                     pGraphs-&gt;pLineFirst,  <br>                     iLogTic) ; <br> <br>      if (bFirstTime) <br>         { <br>         bFirstTime = FALSE ; <br> <br>         // get the second sample data to form the first data point <br>         iLogTic++ ; <br>         iLogTicsRemaining-- ; <br>         PlaybackLines (pGraphs-&gt;pSystemFirst,  <br>                        pGraphs-&gt;pLineFirst,  <br>                        iLogTic) ; <br>         } <br>      iDisplayTic++ ; <br>      PlaybackSetGraphLines (hWndChart, pGraphs-&gt;pLineFirst,  <br>         iDisplayTic, iLogTic, (iDisplayTics == 1)) ; <br> <br>      // setup DDA to get the index of the next sample point <br>      iLogTicsMove = DDA_DISTRIBUTE (iLogTicsRemaining, iDisplayTics) ; <br>      iLogTicsRemaining -= iLogTicsMove ; <br>      iLogTic += iLogTicsMove ; <br> <br>      iDisplayTics-- ; <br> <br>      }  // while <br> <br>   // point to the last value for valuebar display <br>   pGraphs-&gt;gKnownValue = iDisplayTic ; <br> <br>   }  // PlaybackChart <br> <br> <br> <br>#if 0 <br>PLINESTRUCT CurrentGraphLine (HWND hWndGraph) <br>   {  // CurrentGraphLine <br>   UNREFERENCED_PARAMETER (hWndGraph) ; <br> <br>   return (LegendCurrentLine (hWndGraphLegend)) ; <br>   } <br>#endif <br> <br> <br>BOOL AddChart (HWND hWndParent) <br>   { <br>   PLINE pCurrentLine = CurrentGraphLine (hWndGraph) ; <br> <br>   return (AddLine (hWndParent,  <br>                    &amp;(pGraphs-&gt;pSystemFirst),  <br>                    &amp;(pGraphs-&gt;Visual),  <br>                    pCurrentLine ? pCurrentLine-&gt;lnSystemName : NULL, <br>                    LineTypeChart)) ; <br>   } <br> <br> <br>BOOL EditChart (HWND hWndParent) <br>   {  // EditChart <br>   return (EditLine (hWndParent,  <br>                     &amp;(pGraphs-&gt;pSystemFirst),  <br>                     CurrentGraphLine (hWndGraph), <br>                     LineTypeChart)) ; <br>   } <br> <br>void GraphAddAction () <br>   { <br>   PGRAPHSTRUCT      pGraph ; <br> <br>   pGraph = GraphData (hWndGraph) ; <br> <br>   SizeGraphComponents (hWndGraph) ; <br>    <br>   LegendSetSelection (hWndGraphLegend, <br>      LegendNumItems (hWndGraphLegend) - 1) ; <br> <br>   if (PlayingBackLog ()) <br>      PlaybackChart (pGraph-&gt;hWnd) ; <br>   } <br> <br>BOOL OpenChartVer1 (HANDLE hFile, <br>                    DISKCHART *pDiskChart, <br>                    PGRAPHSTRUCT pGraph) <br>   {  // OpenChartVer1 <br>   bDelayAddAction = TRUE ; <br>   pGraph-&gt;Visual = pDiskChart-&gt;Visual ; <br>   pGraph-&gt;gOptions = pDiskChart-&gt;gOptions ; <br>   pGraph-&gt;gMaxValues = pDiskChart-&gt;gMaxValues ; <br>   pGraph-&gt;bManualRefresh = pDiskChart-&gt;bManualRefresh ; <br>   pGraphs-&gt;gInterval = (INT) (pGraph-&gt;gOptions.eTimeInterval * (FLOAT) 1000.0) ; <br>   ReadLines (hFile, pDiskChart-&gt;dwNumLines, <br>               &amp;(pGraph-&gt;pSystemFirst), &amp;(pGraph-&gt;pLineFirst), IDM_VIEWCHART) ; <br>    <br>   bDelayAddAction = FALSE ; <br> <br>   GraphAddAction () ; <br> <br>   return (TRUE) ; <br>   }  // OpenChartVer1 <br> <br> <br> <br>BOOL OpenChart (HWND hWndGraph, <br>                HANDLE hFile, <br>                DWORD dwMajorVersion, <br>                DWORD dwMinorVersion, <br>                BOOL bChartFile) <br>   {  // OpenChart <br>   PGRAPHSTRUCT   pGraph ; <br>   DISKCHART      DiskChart ; <br>   BOOL           bSuccess = TRUE ; <br> <br>   pGraph = pGraphs ; <br>   if (!pGraph) <br>      { <br>      bSuccess = FALSE ; <br>      goto Exit0 ; <br>      } <br> <br>   if (!FileRead (hFile, &amp;DiskChart, sizeof (DISKCHART))) <br>      { <br>      bSuccess = FALSE ; <br>      goto Exit0 ; <br>      } <br> <br> <br>   switch (dwMajorVersion) <br>      { <br>      case (1): <br> <br>         SetHourglassCursor() ; <br>          <br>         ResetGraphView (hWndGraph) ; <br> <br>         OpenChartVer1 (hFile, &amp;DiskChart, pGraph) ; <br> <br>         // change to chart view if we are opening a  <br>         // chart file <br>         if (bChartFile &amp;&amp; iPerfmonView != IDM_VIEWCHART) <br>            { <br>            SendMessage (hWndMain, WM_COMMAND, (LONG)IDM_VIEWCHART, 0L) ; <br>            } <br> <br>         if (iPerfmonView == IDM_VIEWCHART) <br>            { <br>            SetPerfmonOptions (&amp;DiskChart.perfmonOptions) ; <br>            } <br>          <br>         SetArrowCursor() ; <br> <br>         break ; <br>      }  // switch <br> <br>Exit0: <br> <br>   if (bChartFile) <br>      { <br>      CloseHandle (hFile) ; <br>      } <br> <br>   return (bSuccess) ; <br>   }  // OpenChart <br> <br>BOOL SaveChart (HWND hWndGraph, HANDLE hInputFile, BOOL bGetFileName) <br>   { <br>   PGRAPHSTRUCT   pGraph ; <br>   PLINE          pLine ; <br>   HANDLE         hFile ; <br>   DISKCHART      DiskChart ; <br>   PERFFILEHEADER FileHeader ; <br>   TCHAR          szFileName [256] ; <br>   BOOL           newFileName = FALSE ; <br> <br>   if (hInputFile) <br>      { <br>      // use the input file handle if it is available <br>      // this is the case for saving workspace data <br>      hFile = hInputFile ; <br>      } <br>   else <br>      { <br>      if (pChartFullFileName) <br>         { <br>         lstrcpy (szFileName, pChartFullFileName) ; <br>         } <br>      if (bGetFileName || pChartFullFileName == NULL) <br>         { <br>//         if (!pChartFullFileName) <br>//            { <br>//            StringLoad (IDS_GRAPH_FNAME, szFileName) ; <br>//            } <br> <br>         if (!FileGetName (hWndGraph, IDS_CHARTFILE, szFileName)) <br>            { <br>            return (FALSE) ; <br>            } <br>         newFileName = TRUE ; <br>         } <br> <br>      hFile = FileHandleCreate (szFileName) ; <br> <br>      if (hFile &amp;&amp; newFileName) <br>         { <br>         ChangeSaveFileName (szFileName, IDM_VIEWCHART) ; <br>         } <br>      else if (!hFile) <br>         { <br>         DlgErrorBox (hWndGraph, ERR_CANT_OPEN, szFileName) ; <br>         } <br>      } <br> <br>   if (!hFile) <br>      return (FALSE) ; <br> <br>   pGraph = pGraphs ; <br>   if (!pGraph) <br>      { <br>      if (!hInputFile) <br>         { <br>         CloseHandle (hFile) ; <br>         } <br>      return (FALSE) ; <br>      } <br> <br>   if (!hInputFile) <br>      { <br>      // only need to write file header if not workspace  <br>      memset (&amp;FileHeader, 0, sizeof (FileHeader)) ; <br>      lstrcpy (FileHeader.szSignature, szPerfChartSignature) ; <br>      FileHeader.dwMajorVersion = ChartMajorVersion ; <br>      FileHeader.dwMinorVersion = ChartMinorVersion ; <br>    <br>      if (!FileWrite (hFile, &amp;FileHeader, sizeof (PERFFILEHEADER))) <br>         { <br>         goto Exit0 ; <br>         } <br>      } <br> <br>   DiskChart.Visual = pGraph-&gt;Visual ; <br>   DiskChart.gOptions = pGraph-&gt;gOptions ; <br>   DiskChart.gMaxValues = pGraph-&gt;gMaxValues ; <br>   DiskChart.dwNumLines = NumLines (pGraph-&gt;pLineFirst) ; <br>   DiskChart.bManualRefresh = pGraph-&gt;bManualRefresh ; <br>   DiskChart.perfmonOptions = Options ; <br> <br>   if (!FileWrite (hFile, &amp;DiskChart, sizeof (DISKCHART))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   for (pLine = pGraph-&gt;pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineNext) <br>      {  // for <br>      if (!WriteLine (pLine, hFile)) <br>         { <br>         goto Exit0 ; <br>         } <br>      }  // for <br> <br>   if (!hInputFile) <br>      { <br>      CloseHandle (hFile) ; <br>      } <br> <br>   return (TRUE) ; <br> <br>Exit0: <br>   if (!hInputFile) <br>      { <br>      CloseHandle (hFile) ; <br> <br>      // only need to report error if not workspace  <br>      DlgErrorBox (hWndGraph, ERR_SETTING_FILE, szFileName) ; <br>      } <br>   return (FALSE) ; <br> <br>   }  // SaveChart <br> <br>#define TIME_TO_WRITE 2 <br>BOOL ExportChartLabels (HANDLE hFile, PGRAPHSTRUCT pGraph) <br>{ <br>   TCHAR          UnicodeBuff [LongTextLen] ; <br>   CHAR           TempBuff [LongTextLen * 2] ; <br>   int            StringLen ; <br>   PLINESTRUCT    pLine; <br>   int            TimeToWriteFile ; <br>   int            iIndex ; <br>   LPTSTR         lpItem ; <br> <br>   for (iIndex = 0 ; iIndex &lt; 5 ; iIndex++) <br>      { <br>      // for iIndex == 0, get counter name  <br>      // for iIndex == 1, get instance name <br>      // for iIndex == 2, get parent name <br>      // for iIndex == 3, get object name  <br>      // for iIndex == 4, get computer name <br>      if (iIndex == 4) <br>         { <br>         // the last label field, write date/time labels <br>         strcpy (TempBuff, LineEndStr) ; <br>         StringLen = strlen (TempBuff) ; <br>         StringLoad (IDS_EXPORT_DATE, UnicodeBuff) ; <br>         ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>         strcat (TempBuff, pDelimiter) ; <br>         StringLen = strlen (TempBuff) ; <br>       <br>         StringLoad (IDS_EXPORT_TIME, UnicodeBuff) ; <br>         ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>         strcat (TempBuff, pDelimiter) ; <br>         StringLen = strlen (TempBuff) ; <br>         } <br>      else <br>         { <br>         strcpy (TempBuff, LineEndStr) ; <br>         strcat (TempBuff, pDelimiter) ; <br>         strcat (TempBuff, pDelimiter) ; <br>         StringLen = strlen (TempBuff) ; <br>         } <br> <br>      TimeToWriteFile = 0 ; <br> <br>      for (pLine=pGraph-&gt;pLineFirst; pLine; pLine=pLine-&gt;pLineNext) <br>         { <br>         switch (iIndex) <br>            { <br>            case 0: <br>               lpItem = (LPTSTR) pLine-&gt;lnCounterName ; <br>               break ; <br> <br>            case 1: <br>               lpItem = (LPTSTR) pLine-&gt;lnInstanceName ; <br>               break ; <br> <br>            case 2: <br>               lpItem = (LPTSTR) pLine-&gt;lnPINName ; <br>               break ; <br> <br>            case 3: <br>               lpItem = (LPTSTR) pLine-&gt;lnObjectName ; <br>               break ; <br> <br>            case 4: <br>               lpItem = (LPTSTR) pLine-&gt;lnSystemName ; <br>               break ; <br>            } <br> <br>         if (lpItem) <br>            { <br>            ConvertUnicodeStr (&amp;TempBuff[StringLen], lpItem) ; <br>            } <br>         else <br>            { <br>            TempBuff[StringLen] = '\0' ; <br>            } <br>         strcat (TempBuff, pDelimiter); <br>         StringLen = strlen (TempBuff) ; <br>    <br>         if (++TimeToWriteFile &gt; TIME_TO_WRITE) <br>            { <br>            // better write the buffers before they overflow. <br>            // there are better ways to check for overflow  <br>            // but this is good enough <br>    <br>            if (!FileWrite (hFile, TempBuff, StringLen)) <br>               { <br>               goto Exit0 ; <br>               } <br>            StringLen = TimeToWriteFile = 0 ; <br>            } <br>         }     // for each line <br> <br>      if (StringLen) <br>         { <br>         // write the last block of data <br>         if (!FileWrite (hFile, TempBuff, StringLen)) <br>            { <br>            goto Exit0 ; <br>            } <br>         } <br>      }     // for iIndex <br> <br>   return (TRUE) ; <br> <br>Exit0: <br>   return (FALSE) ; <br> <br>}  // ExportChartLabels <br> <br>BOOL ExportLogChart (HANDLE hFile, PGRAPHSTRUCT pGraph) <br>{ <br>   TCHAR          UnicodeBuff [LongTextLen] ; <br>   CHAR           TempBuff [LongTextLen * 2] ; <br>   int            StringLen ; <br>   PLINESTRUCT    pLine; <br>   int            TimeToWriteFile ; <br>   FLOAT          eValue ; <br>   int            iLogTic ; <br>   BOOL           bFirstTime = TRUE ; <br>   SYSTEMTIME     LogSystemTime ; <br>   LOGPOSITION    LogPosition ; <br> <br>   iLogTic = PlaybackLog.StartIndexPos.iPosition ; <br> <br>   // we have to export every point from the log file  <br> <br>   for ( ; iLogTic &lt;= PlaybackLog.StopIndexPos.iPosition ; iLogTic++) <br>      { </code></pre>
<p>
</p>
<pre><code><br>      PlaybackLines (pGraphs-&gt;pSystemFirst,  <br>                     pGraphs-&gt;pLineFirst,  <br>                     iLogTic) ; <br> <br>      if (!bFirstTime) <br>         { <br>         // export the values <br>         TimeToWriteFile = 0 ; <br> <br>          <br>         if (!LogPositionN (iLogTic, &amp;LogPosition)) <br>            { <br>            goto Exit0 ; <br>            } <br> <br>         LogPositionSystemTime (&amp;LogPosition, &amp;LogSystemTime) ; <br> <br>         strcpy (TempBuff, LineEndStr) ; <br>         StringLen = strlen (TempBuff) ; <br> <br>         SystemTimeDateString (&amp;LogSystemTime, UnicodeBuff) ; <br>         ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>         strcat (TempBuff, pDelimiter) ; <br>         StringLen = strlen (TempBuff) ; <br> <br>         SystemTimeTimeString (&amp;LogSystemTime, UnicodeBuff, FALSE) ; <br>         ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>         strcat (TempBuff, pDelimiter) ; <br>         StringLen = strlen (TempBuff) ; <br> <br>         for (pLine=pGraph-&gt;pLineFirst; pLine; pLine=pLine-&gt;pLineNext) <br>            { <br>       <br>            eValue = CounterEntry (pLine) ; <br> <br>            TSPRINTF (UnicodeBuff, <br>                      eValue &gt; (FLOAT)999999.0 ? <br>                           szLargeValueFormat : szSmallValueFormat, <br>                      eValue) ; <br>            ConvertDecimalPoint (UnicodeBuff) ; <br>            ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>            strcat (TempBuff, pDelimiter) ; <br>            StringLen = strlen (TempBuff) ; <br> <br>            if (++TimeToWriteFile &gt; TIME_TO_WRITE) <br>               { <br>               if (!FileWrite (hFile, TempBuff, StringLen)) <br>                  { <br>                  goto Exit0 ; <br>                  } <br>               StringLen = TimeToWriteFile = 0 ; <br>               TempBuff[0] = '\0' ; <br>               } <br>            } <br> <br>         if (StringLen) <br>            { <br>            if (!FileWrite (hFile, TempBuff, StringLen)) <br>               { <br>               goto Exit0 ; <br>               } <br>            } <br>         } <br>      else <br>         { <br>         // skip the first data point since we <br>         // need 2 points to form the first value <br>         bFirstTime = FALSE ; <br>         } <br>      } <br> <br>   return (TRUE) ; <br> <br>Exit0: <br>   return (FALSE) ; <br> <br>}  // ExportLogChart <br> <br>BOOL ExportLineValue (HANDLE hFile, PGRAPHSTRUCT pGraph, <br>   int CurrentIndex, int iDataPoint) <br>{ <br>   TCHAR          UnicodeBuff [MiscTextLen] ; <br>   CHAR           TempBuff [LongTextLen] ; <br>   int            StringLen ; <br>   PLINESTRUCT    pLine; <br>   int            MaxValues ; <br>   int            TimeToWriteFile ; <br>   SYSTEMTIME     *pSystemTime ; <br>   BOOL           ValidValue ; <br> <br>   pSystemTime = pGraph-&gt;pDataTime ; <br>   pSystemTime += CurrentIndex ; <br> <br>   if (pSystemTime-&gt;wYear == 0 &amp;&amp; pSystemTime-&gt;wYear == 0) <br>      { <br>      // ignore value that has 0 system time <br>      return (TRUE) ; <br>      } <br> <br>   MaxValues = pGraph-&gt;gMaxValues ; <br>   strcpy (TempBuff, LineEndStr) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   SystemTimeDateString (pSystemTime, UnicodeBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   SystemTimeTimeString (pSystemTime, UnicodeBuff, FALSE) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   TimeToWriteFile = 0 ; <br>   for (pLine=pGraph-&gt;pLineFirst; pLine; pLine=pLine-&gt;pLineNext) <br>      { <br>      if (!pLine-&gt;bFirstTime) <br>         { <br>         ValidValue = FALSE ; <br>         // check if this is a valid value <br>         if (pLine-&gt;lnValidValues == MaxValues) <br>            { <br>            // this is the simple case where we have filled up  <br>            // the whole buffer <br>            ValidValue = TRUE ; <br>            } <br>         else if (pLine-&gt;lnValidValues &lt;= iDataPoint) <br>            { <br>            if (CurrentIndex &lt;= iDataPoint &amp;&amp; <br>               CurrentIndex &gt; iDataPoint - pLine-&gt;lnValidValues) <br>               { <br>               ValidValue = TRUE ; <br>               } <br>            } <br>         else <br>            { <br>            if (CurrentIndex &lt;= iDataPoint || <br>               CurrentIndex &gt; (MaxValues - pLine-&gt;lnValidValues + iDataPoint)) <br>               { <br>               // this is the case when we start the new line in the middle <br>               // and data buffer has been wrap-around. <br>               ValidValue = TRUE ; <br>               } <br>            } <br> <br>         // only export the data when we determine it is valid <br>         if (ValidValue) <br>            { <br>            TSPRINTF (UnicodeBuff, <br>               pLine-&gt;lnValues[CurrentIndex] &gt; (FLOAT)999999.0 ? <br>               szLargeValueFormat : szSmallValueFormat, <br>               pLine-&gt;lnValues[CurrentIndex]) ; <br>            ConvertDecimalPoint (UnicodeBuff) ; <br>            ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>            } <br>         } <br>      strcat (TempBuff, pDelimiter) ; <br>      StringLen = strlen (TempBuff) ; <br> <br>      if (++TimeToWriteFile &gt; TIME_TO_WRITE) <br>         { <br>         // better write the buffers before they overflow. <br>         // there are better ways to check for overflow  <br>         // but this is good enough <br>    <br>         if (!FileWrite (hFile, TempBuff, StringLen)) <br>            { <br>            goto Exit0 ; <br>            } <br>         StringLen = TimeToWriteFile = 0 ; <br>         TempBuff[0] = '\0' ; <br>         } <br>      } <br> <br>   if (StringLen) <br>      { <br>      // write the last block of data <br>      if (!FileWrite (hFile, TempBuff, StringLen)) <br>         { <br>         goto Exit0 ; <br>         } <br>      } <br> <br>   return (TRUE) ; <br> <br>Exit0: <br>   return (FALSE) ; <br> <br>}     // ExportLineValue <br> <br>BOOL ExportCurrentChart (HANDLE hFile, PGRAPHSTRUCT pGraph) <br>{ <br>   int            KnownValue, <br>                  MaxValues, <br>                  iValidValues, <br>                  iDataPoint ; <br>   BOOL           SimpleCase = FALSE ; <br>   int            iIndex ; <br> <br>   MaxValues = pGraph-&gt;gMaxValues ; <br>   KnownValue = pGraph-&gt;gKnownValue ; <br>   iValidValues = pGraph-&gt;gTimeLine.iValidValues ; <br> <br>   if (iValidValues &lt; MaxValues) <br>      { <br>      // data have not wrapped around, so the oldest time <br>      // is started at 0. <br>      SimpleCase = TRUE ; <br>      iValidValues = (KnownValue % MaxValues) + 1 ; <br>      } <br> <br>   iDataPoint = KnownValue % MaxValues ; <br> <br>   if (!SimpleCase) <br>      { <br>      for (iIndex = iDataPoint+1 ; iIndex &lt; MaxValues ; iIndex++) <br>         { <br>         if (!ExportLineValue (hFile, pGraph, iIndex, iDataPoint)) <br>            { <br>            goto Exit0 ; <br>            } <br>         } <br>      } <br> <br>   for (iIndex = 0 ; iIndex &lt;= iDataPoint ; iIndex++) <br>      { <br>      if (!ExportLineValue (hFile, pGraph, iIndex, iDataPoint)) <br>         { <br>         goto Exit0 ; <br>         } <br>      } <br> <br>   return (TRUE) ; <br> <br>Exit0: <br>   return (FALSE) ; <br> <br>}  // ExportCurrentChart <br> <br> <br>void ExportChart (void) <br>{ <br> <br>   PGRAPHSTRUCT   pGraph ; <br>   HANDLE         hFile = 0 ; <br>   LPTSTR         pFileName = NULL ; <br>   INT            ErrCode = 0 ; <br> <br>   if (!(pGraph = pGraphs)) <br>      { <br>      return ; <br>      } <br> <br>   // see if there is anything to export.. <br>   if (!(pGraph-&gt;pLineFirst)) <br>      { <br>      return ; <br>      } <br> <br>   SetHourglassCursor() ; <br>    <br>   if (ErrCode = ExportFileOpen (hWndGraph, &amp;hFile, pGraph-&gt;gInterval, &amp;pFileName)) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   if (!pFileName) <br>      { <br>      // this is the case when user cancel. <br>      goto Exit0 ; <br>      } <br> <br>   // export the column labels <br>   if (!ExportChartLabels (hFile, pGraph)) <br>      { <br>    <br>      ErrCode = ERR_EXPORT_FILE ; <br>      goto Exit0 ; <br>      } <br> <br>   // export the lines <br>   if (PlayingBackLog()) <br>      { <br>      if (!ExportLogChart (hFile, pGraph)) <br>         { <br>         ErrCode = ERR_EXPORT_FILE ; <br>         goto Exit0 ; <br>         } <br>      } <br>   else <br>      { <br>      if (!ExportCurrentChart (hFile, pGraph)) <br>         { <br>         ErrCode = ERR_EXPORT_FILE ; <br>         goto Exit0 ; <br>         } <br>      } <br>Exit0: <br> <br>   SetArrowCursor() ; <br> <br>   if (hFile) <br>      { <br>      CloseHandle (hFile) ; <br>      } <br> <br>   if (pFileName) <br>      { <br>      if (ErrCode) <br>         { <br>         DlgErrorBox (hWndGraph, ErrCode, pFileName) ; <br>         } <br> <br>      MemoryFree (pFileName) ; <br>      } <br> <br>}     // ExportChart <br> <br> <br>typedef struct CHARTDATAPOINTSTRUCT <br>   { <br>   int         iLogIndex ; <br>   int         xDispDataPoint ; <br>   } CHARTDATAPOINT, *PCHARTDATAPOINT ; <br> <br>void PlaybackChartDataPoint (PCHARTDATAPOINT pChartDataPoint) <br>   {  // PlaybackChartDataPoint <br>   int            iDisplayTics ;       // num visual points to display <br>   int            iDisplayTic ; <br>   int            iLogTic ; <br>   int            iLogTicsMove ; <br>   BOOL           bFirstTime = TRUE; <br>   int            iLogTicsRemaining ; <br>   int            numOfData, xDispDataPoint, rectWidth, xPos ; <br>   PGRAPHSTRUCT   pGraph ; <br> <br>   pGraph = GraphData (hWndGraph) ; <br> <br>   iLogTicsRemaining = PlaybackLog.iSelectedTics ; <br> <br> <br>   // we only have iDisplayTics-1 points since <br>   // we have to use the first two sample points to <br>   // get the first data points. <br>   if (iLogTicsRemaining &lt;= pGraphs-&gt;gMaxValues) <br>      { <br>      iDisplayTics = iLogTicsRemaining ; <br>      } <br>   else <br>      { <br>      iDisplayTics = pGraphs-&gt;gMaxValues ; <br>      } <br> <br>   iDisplayTic = -1 ; <br>   iLogTic = PlaybackLog.StartIndexPos.iPosition ; <br> <br>   numOfData      = pGraph-&gt;gMaxValues - 1 ; <br>   rectWidth      = pGraph-&gt;rectData.right - pGraph-&gt;rectData.left ; <br>   xDispDataPoint = pGraph-&gt;rectData.left ; <br> <br>   while (iDisplayTics &amp;&amp; numOfData) <br>      { <br> <br>      if (!bFirstTime) <br>         { <br>         iDisplayTic++ ; <br>         } <br>      else <br>         { <br>         bFirstTime = FALSE ; <br> <br>         // get the second sample data to form the first data point <br>         iLogTic++ ; <br>         iLogTicsRemaining-- ; <br> <br>         iDisplayTic++ ; <br>         } <br> <br>      pChartDataPoint[iDisplayTic].iLogIndex = iLogTic ; <br>      pChartDataPoint[iDisplayTic].xDispDataPoint = xDispDataPoint ; <br> <br>      // setup DDA to get the index of the next sample point <br>      iLogTicsMove = DDA_DISTRIBUTE (iLogTicsRemaining, iDisplayTics) ; <br>      iLogTicsRemaining -= iLogTicsMove ; <br>      iLogTic += iLogTicsMove ; <br> <br> <br>      xPos = DDA_DISTRIBUTE (rectWidth, numOfData) ; <br>      xDispDataPoint += xPos ; <br>      numOfData-- ; <br>      rectWidth -= xPos ; <br> <br>      iDisplayTics-- ; <br> <br>      }  // while <br> <br>   }  // PlaybackChartDataPoint </code></pre>
<p>&nbsp;</p></body>
</HTML>
