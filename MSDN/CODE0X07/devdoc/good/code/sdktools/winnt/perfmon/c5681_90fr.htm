<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RPTFCT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5697"></a>RPTFCT.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  RptFct.c - This file contains support routines for the Report view. <br> *       They are moved here because Report.c is getting too big. <br> * <br> *  Microsoft Confidential <br> *  Copyright 1992 - 1998 Microsoft Corporation <br> * <br> *  Author - <br> * <br> *       Hon-Wah Chan <br> * <br> ****************************************************************************/ <br> <br>#include "perfmon.h" <br>#include &lt;stdio.h&gt;      // for sprintf <br>#include "report.h"     // Exported declarations for this file <br> <br>#include "line.h"       // for LineAppend <br>#include "pmemory.h"    // for MemoryXXX (mallloc-type) routines <br>#include "system.h"     // for SystemGet <br>#include "utils.h" <br>#include "perfmops.h"   // for BuildValueListForSystems <br> <br>// extern defined in Report.c <br> <br>extern TCHAR          szSystemFormat [] ; <br>extern TCHAR          szObjectFormat [] ; <br> <br> <br>#define szValuePlaceholder          TEXT("-999999999.999") <br>#define szLargeValueFormat          TEXT("%12.0f") <br>#define eStatusLargeValueMax        ((FLOAT) 999999999.0) <br>#define szValueFormat               TEXT("%12.3f") <br> <br>//======================== <br>// Local routines prototypes <br>//======================== <br> <br>void ColumnRemoveOne (PREPORT pReport, <br>                      POBJECTGROUP pObjectGroup, <br>                      int iColumnNumber) ; <br> <br>BOOL CounterGroupRemove (PCOUNTERGROUP *ppCounterGroupFirst, <br>                        PCOUNTERGROUP pCounterGroupRemove) ; <br> <br>BOOL ObjectGroupRemove (POBJECTGROUP *ppObjectGroupFirst, <br>                        POBJECTGROUP pObjectGroupRemove) ; <br> <br>BOOL SystemGroupRemove (PSYSTEMGROUP *ppSystemGroupFirst, <br>                        PSYSTEMGROUP pSystemGroupRemove) ; <br> <br>PCOUNTERGROUP GetNextCounter (PSYSTEMGROUP   pSystemGroup, <br>                              POBJECTGROUP   pObjectGroup, <br>                              PCOUNTERGROUP  pCounterGroup) ; <br> <br>// CheckColumnGroupRemove is used to check if the given <br>// column is empty.  If it is empty, it is removed from  <br>// the column link list <br>void CheckColumnGroupRemove (PREPORT      pReport, <br>                             POBJECTGROUP pObjectGroup, <br>                             int          iReportColumn) <br>   { <br>   // check if we need to remove the this column <br>   PLINE          pCounterLine ; <br>   PCOUNTERGROUP  pCounterGrp ; <br>   BOOL           bColumnFound = FALSE ; <br> <br>   if (iReportColumn &lt; 0 || pObjectGroup-&gt;pCounterGroupFirst == NULL) <br>      { <br>      // no column for this Counter group, forget it <br>      return ; <br>      } <br> <br> <br>   // go thru each Counter group and check if any line in the <br>   // group matches the given column number <br>   for (pCounterGrp = pObjectGroup-&gt;pCounterGroupFirst ; <br>        pCounterGrp ; <br>        pCounterGrp = pCounterGrp-&gt;pCounterGroupNext ) <br>      { <br>      for (pCounterLine = pCounterGrp-&gt;pLineFirst ; <br>           pCounterLine ; <br>           pCounterLine = pCounterLine-&gt;pLineCounterNext) <br>         { <br>         if (pCounterLine-&gt;iReportColumn == iReportColumn) <br>            { <br>            // found one, this column is not empty <br>            bColumnFound = TRUE ; <br>            break ; <br>            } <br>         }  // for pCounterLine <br>      if (bColumnFound) <br>         { <br>         break ; <br>         } <br>      }  // for pCounterGrp <br> <br>   if (bColumnFound == FALSE) <br>      { <br>      // we have deleted the last column item, remove this column <br>      ColumnRemoveOne (pReport, <br>         pObjectGroup, <br>         iReportColumn) ; <br>      } <br>   }  // CheckColumnGroupRemove <br> <br> <br>//================================ <br>// Line routine <br>//================================ <br> <br>void ReportLineValueRect (PREPORT pReport, <br>                          PLINE pLine, <br>                          LPRECT lpRect) <br>   {  // ReportLineValueRect <br>   lpRect-&gt;left = ValueMargin (pReport) + pLine-&gt;xReportPos ; <br>   lpRect-&gt;top = pLine-&gt;yReportPos ; <br>   lpRect-&gt;right = lpRect-&gt;left + pReport-&gt;xValueWidth ; <br>   lpRect-&gt;bottom = lpRect-&gt;top + pReport-&gt;yLineHeight ; <br>   }  // ReportLineValueRect <br> <br>PLINE LineRemoveItem (PREPORT pReport, <br>                      enum REPORT_ITEM_TYPE  *pNewItemType) <br>   { <br>   PLINE          pLine ; <br>   PLINE          pNextLine = NULL ; <br>   PLINE          pReturnLine = NULL ; <br>   PLINE          pLeftLine = NULL ; <br>   PSYSTEMGROUP   pSystemGroup ; <br>   POBJECTGROUP   pObjectGroup ; <br>   PCOUNTERGROUP  pCounterGroup ; <br>   PCOUNTERGROUP  pNextCounterGroup ; <br>   BOOL           bCreatNewCounterGroup ; <br> <br> <br>   //=============================// <br>   // Remove line, line's system  // <br>   //=============================// <br> <br>   pLine = pReport-&gt;CurrentItem.pLine ; <br>   LineRemove (&amp;pReport-&gt;pLineFirst, pLine) ; <br> <br>   // no more line, no more timer... <br>   if (!pReport-&gt;pLineFirst) <br>      { <br>      pReport-&gt;xWidth = 0 ; <br>      pReport-&gt;yHeight = 0 ; <br>      pReport-&gt;xMaxCounterWidth = 0 ; <br>      ClearReportTimer (pReport) ; <br>      } <br> <br>   //=============================// <br>   // Get correct spot; remove line // <br>   //=============================// <br> <br>   pSystemGroup = GetSystemGroup (pReport, pLine-&gt;lnSystemName) ; <br>   pObjectGroup = GetObjectGroup (pSystemGroup, pLine-&gt;lnObjectName) ; <br>   pCounterGroup = GetCounterGroup (pObjectGroup, <br>      pLine-&gt;lnCounterDef.CounterNameTitleIndex, <br>      &amp;bCreatNewCounterGroup, <br>      pLine-&gt;lnCounterName) ; <br> <br>   if (!pCounterGroup) <br>      return (NULL) ; <br> <br>   LineCounterRemove (&amp;pCounterGroup-&gt;pLineFirst, pLine) ; <br> <br>   // check which line to get the focus <br>   if (pCounterGroup-&gt;pLineFirst) <br>      { <br>      // simple case, we still have line in the same counter group <br>      // get the one right after this delete line. <br>      for (pNextLine = pCounterGroup-&gt;pLineFirst ; <br>           pNextLine ; <br>           pNextLine = pNextLine-&gt;pLineCounterNext) <br>         { <br>         if (pNextLine-&gt;xReportPos &gt; pLine-&gt;xReportPos) <br>            { <br>            if (pReturnLine == NULL ||  <br>                pReturnLine-&gt;xReportPos &gt; pNextLine-&gt;xReportPos) <br>               { <br>               pReturnLine = pNextLine ; <br>               } <br>            } <br>         else <br>            { <br>            if (pLeftLine == NULL || <br>                pLeftLine-&gt;xReportPos &lt; pNextLine-&gt;xReportPos) <br>               { <br>               pLeftLine = pNextLine ; <br>               } <br>            } <br>         } <br> <br>      if (!pReturnLine &amp;&amp; pLeftLine) <br>         { <br>         // the delete line is the last column, then use the line  <br>         // to its left <br>         pReturnLine = pLeftLine ; <br>         } <br>      } <br>   else <br>      { <br>      pNextCounterGroup = GetNextCounter ( <br>            pSystemGroup, <br>            pObjectGroup, <br>            pCounterGroup) ; <br> <br>      if (pNextCounterGroup) <br>         { <br>         pLeftLine = NULL ; <br>         for (pNextLine = pNextCounterGroup-&gt;pLineFirst ; <br>              pNextLine ; <br>              pNextLine = pNextLine-&gt;pLineCounterNext) <br>            { <br>            // get the line in the first column <br>            if (pLeftLine == NULL || <br>                pNextLine-&gt;xReportPos &lt; pLeftLine-&gt;xReportPos) <br>               { <br>               pLeftLine = pNextLine ; <br>               } <br>            } <br>         pReturnLine = pLeftLine ; <br>         } <br> <br>      // remove this counter group if there is no line <br>      CounterGroupRemove (&amp;pObjectGroup-&gt;pCounterGroupFirst, pCounterGroup) ; <br>      } <br>       <br>   // check if we need to remove any empty column <br>   CheckColumnGroupRemove (pReport, pObjectGroup, pLine-&gt;iReportColumn) ; <br> <br>   if (!(pObjectGroup-&gt;pCounterGroupFirst)) <br>      ObjectGroupRemove (&amp;pSystemGroup-&gt;pObjectGroupFirst, pObjectGroup) ; <br> <br>   if (!(pSystemGroup-&gt;pObjectGroupFirst)) <br>      SystemGroupRemove (&amp;pReport-&gt;pSystemGroupFirst, pSystemGroup) ; <br> <br> <br>   LineFree (pLine) ; <br> <br>   if (pReturnLine &amp;&amp; pNewItemType) <br>      { <br>      *pNewItemType = REPORT_TYPE_LINE ; <br>      } <br> <br>   return (pReturnLine) ; <br>   }  // LineRemoveItem <br> <br>//======================================// <br>// Column Group routines                // <br>//======================================// <br> <br>void ReportColumnRect (PREPORT pReport, <br>                       PCOLUMNGROUP pColumnGroup, <br>                       LPRECT  lpRect) <br>   {  // ReportColumnRect <br>   lpRect-&gt;left = ValueMargin (pReport) + pColumnGroup-&gt;xPos ; <br>   lpRect-&gt;top = pColumnGroup-&gt;yFirstLine ; <br>   lpRect-&gt;right = lpRect-&gt;left + pColumnGroup-&gt;xWidth ; <br>   lpRect-&gt;bottom = lpRect-&gt;top + pReport-&gt;yLineHeight ; <br>   if (pColumnGroup-&gt;lpszParentName) <br>      { <br>      lpRect-&gt;top -= pReport-&gt;yLineHeight ; <br>      } <br>   }  // ReportColumnRect <br> <br> <br>BOOL ColumnSame (PCOLUMNGROUP pColumnGroup, <br>                 LPTSTR lpszParentName, <br>                 LPTSTR lpszInstanceName) <br>   {  // ColumnSame <br>   BOOL           bParentSame ; <br>   BOOL           bInstanceSame ; <br> <br>   bParentSame = (!lpszParentName &amp;&amp; !pColumnGroup-&gt;lpszParentName) || <br>                 strsame (lpszParentName, pColumnGroup-&gt;lpszParentName) ; <br>   bInstanceSame = (!lpszInstanceName &amp;&amp; !pColumnGroup-&gt;lpszInstanceName) || <br>                 strsame (lpszInstanceName, pColumnGroup-&gt;lpszInstanceName) ; <br> <br>   return (bParentSame &amp;&amp; bInstanceSame) ;                  <br>   }  // ColumnSame <br> <br> <br>PCOLUMNGROUP ColumnGroupCreate (PREPORT pReport, <br>                                int xPos, <br>                                LPTSTR lpszParentName, <br>                                LPTSTR lpszInstanceName, <br>                                int PreviousColumnNumber, <br>                                int yFirstLine) <br>   {  // ColumnGroupCreate <br>   PCOLUMNGROUP   pColumnGroup ; <br>   HDC            hDC ; <br> <br>   hDC = GetDC (pReport-&gt;hWnd) ; <br>   pColumnGroup = MemoryAllocate (sizeof (COLUMNGROUP)) ; <br> <br>   if (pColumnGroup) <br>      { <br>      pColumnGroup-&gt;pColumnGroupNext = NULL ; <br>      pColumnGroup-&gt;lpszParentName = StringAllocate (lpszParentName) ; <br>      pColumnGroup-&gt;lpszInstanceName = StringAllocate (lpszInstanceName) ; <br>      pColumnGroup-&gt;ParentNameTextWidth = TextWidth (hDC, lpszParentName) ; <br>      pColumnGroup-&gt;InstanceNameTextWidth = TextWidth (hDC, lpszInstanceName) ; <br>      pColumnGroup-&gt;xPos = xPos ; <br>      pColumnGroup-&gt;yFirstLine = yFirstLine ; <br>      pColumnGroup-&gt;ColumnNumber = PreviousColumnNumber + 1 ; <br>      pColumnGroup-&gt;xWidth = max (max (pColumnGroup-&gt;ParentNameTextWidth, <br>                                       pColumnGroup-&gt;InstanceNameTextWidth), <br>                                  pReport-&gt;xValueWidth) ; <br> <br>      pReport-&gt;xWidth = max (pReport-&gt;xWidth, <br>                             RightHandMargin + <br>                             ValueMargin (pReport) +  <br>                             pColumnGroup-&gt;xPos + pColumnGroup-&gt;xWidth +  <br>                             xColumnMargin) ; <br>      }  // if <br> <br>   ReleaseDC (pReport-&gt;hWnd, hDC) ; <br>   return (pColumnGroup) ; <br>   }  // ColumnGroupCreate <br> <br>PCOLUMNGROUP GetColumnGroup (PREPORT pReport, <br>                          POBJECTGROUP pObjectGroup, <br>                          PLINE pLine) <br>/* <br>   Effect:        Return a pointer to the appropriate column group from <br>                  within the groups of pObject. If the line is a counter <br>                  without instances, return NULL. Otherwise, determine <br>                  if the counter's parent/instance pair is already found <br>                  in an existing column and return a pointer to that column. <br> <br>                  If a column with the appropriate parent/instance isn't <br>                  found, add a new column *at the end*, and return that <br>                  column. <br> <br>   Note:          This function has multiple return points. <br>*/ <br>   {  // GetColumnGroup <br>   PCOLUMNGROUP   pColumnGroup ; <br>   LPTSTR         lpszParentName ; <br>   LPTSTR         lpszInstanceName ; <br> <br> <br>   if (!LineInstanceName (pLine)) <br>      return (NULL) ; <br> <br> <br>   lpszParentName = LineParentName (pLine) ; <br>   lpszInstanceName = LineInstanceName (pLine) ; <br>       <br>   if (!pObjectGroup-&gt;pColumnGroupFirst) <br>      { <br>      pObjectGroup-&gt;pColumnGroupFirst =  <br>         ColumnGroupCreate (pReport, <br>            0, <br>            lpszParentName, <br>            lpszInstanceName, <br>            -1, <br>            pObjectGroup-&gt;yFirstLine) ; <br> <br>      if (pObjectGroup-&gt;pColumnGroupFirst) <br>         { <br>         pObjectGroup-&gt;pColumnGroupFirst-&gt;pParentObject = <br>            pObjectGroup ; <br>         } <br> <br>      return (pObjectGroup-&gt;pColumnGroupFirst) ; <br>      } <br> <br>   for (pColumnGroup = pObjectGroup-&gt;pColumnGroupFirst ; <br>        pColumnGroup ; <br>        pColumnGroup = pColumnGroup-&gt;pColumnGroupNext) <br>      {  // for <br>      if (ColumnSame (pColumnGroup, lpszParentName, lpszInstanceName)) <br>         return (pColumnGroup) ; <br> <br>      else if (!pColumnGroup-&gt;pColumnGroupNext) <br>         {  // if <br>         pColumnGroup-&gt;pColumnGroupNext =  <br>            ColumnGroupCreate (pReport, <br>                               pColumnGroup-&gt;xPos + pColumnGroup-&gt;xWidth + <br>                               xColumnMargin, <br>                               lpszParentName, <br>                               lpszInstanceName, <br>                               pColumnGroup-&gt;ColumnNumber, <br>                               pObjectGroup-&gt;yFirstLine) ; <br> <br>         if (pColumnGroup-&gt;pColumnGroupNext) <br>            { <br>            (pColumnGroup-&gt;pColumnGroupNext)-&gt;pParentObject = <br>               pObjectGroup ; <br> <br>            // build the double link-list <br>            (pColumnGroup-&gt;pColumnGroupNext)-&gt;pColumnGroupPrevious = <br>               pColumnGroup ; <br>            } <br> <br>         return (pColumnGroup-&gt;pColumnGroupNext) ; <br>         }  // if <br>      }  // for <br> <br>   return (NULL) ; <br>   }  // GetColumnGroup <br> <br>// ColumnRemoveOne removes the column with the specified column number <br>void ColumnRemoveOne (PREPORT pReport, <br>                      POBJECTGROUP pObjectGroup, <br>                      int iColumnNumber) <br>   { <br>   PCOLUMNGROUP   pColumnGroup ; <br>   PCOLUMNGROUP   pNextColumnGroup ; <br> <br>   if (pObjectGroup-&gt;pColumnGroupFirst == NULL) <br>      { <br>      // no column group, forget it <br>      return ; <br>      } <br> <br>   // Find the head list <br>   if (pObjectGroup-&gt;pColumnGroupFirst-&gt;ColumnNumber == iColumnNumber) <br>      { <br>      pColumnGroup = pObjectGroup-&gt;pColumnGroupFirst ; <br>      pObjectGroup-&gt;pColumnGroupFirst = pColumnGroup-&gt;pColumnGroupNext ; <br>      if (pColumnGroup-&gt;pColumnGroupNext) <br>         { <br>         // set up head of backward link list <br>         (pColumnGroup-&gt;pColumnGroupNext)-&gt;pColumnGroupPrevious = NULL ; <br>         } <br> <br>      // free memory for this column group <br>      MemoryFree (pColumnGroup-&gt;lpszParentName) ; <br>      MemoryFree (pColumnGroup-&gt;lpszInstanceName) ; <br>      MemoryFree (pColumnGroup) ; <br> <br>      return ; <br>      } <br>    <br>   // go thru the double link list to look for the right column <br>   for (pColumnGroup = pObjectGroup-&gt;pColumnGroupFirst ; <br>        pColumnGroup ; <br>        pColumnGroup = pNextColumnGroup) <br>      { <br>      pNextColumnGroup = pColumnGroup-&gt;pColumnGroupNext ; <br> <br>      if (pNextColumnGroup == NULL) <br>         { <br>         // forget it if we can't find this column for some reson. <br>         break ; <br>         } <br> <br>      if (pNextColumnGroup-&gt;ColumnNumber == iColumnNumber) <br>         { <br>         pColumnGroup-&gt;pColumnGroupNext = pNextColumnGroup-&gt;pColumnGroupNext ; <br> <br>         // build backward link iff it is not the end of list <br>         if (pColumnGroup-&gt;pColumnGroupNext) <br>            { <br>            (pColumnGroup-&gt;pColumnGroupNext)-&gt;pColumnGroupPrevious = <br>               pColumnGroup ; <br>            } <br> <br>         // free memory for this column group <br>         MemoryFree (pNextColumnGroup-&gt;lpszParentName) ; <br>         MemoryFree (pNextColumnGroup-&gt;lpszInstanceName) ; <br>         MemoryFree (pNextColumnGroup) ; <br> <br>         // Done <br>         break ; <br>         } <br>      } <br>   }  // ColumnRemoveOne <br> <br>// ColumnGroupRemove removes all the columns for a given column list <br>void ColumnGroupRemove (PCOLUMNGROUP pColumnGroupFirst) <br>   { <br>   PCOLUMNGROUP   pColumnGroup ; <br>   PCOLUMNGROUP   pNextColumnGroup ; <br> <br>   for (pColumnGroup = pColumnGroupFirst ; <br>        pColumnGroup ; <br>        pColumnGroup = pNextColumnGroup) <br>      { <br>      pNextColumnGroup = pColumnGroup-&gt;pColumnGroupNext ; <br> <br>      // free memory for this column group <br>      MemoryFree (pColumnGroup-&gt;lpszParentName) ; <br>      MemoryFree (pColumnGroup-&gt;lpszInstanceName) ; <br>      MemoryFree (pColumnGroup) ; <br>      } <br>   }  // ColumnGroupRemove <br> <br>// ColumnRemoveItem  is called when user wants to delete a <br>// selected column. <br>PCOLUMNGROUP ColumnRemoveItem (PREPORT      pReport, <br>                               PCOLUMNGROUP pColumnGroup, <br>                               BOOL         bCleanUpLink, <br>                               enum REPORT_ITEM_TYPE  *pNewItemType) <br>   { <br>   PLINE          pLine, pNextLine ; <br>   PSYSTEMGROUP   pSystemGroup ; <br>   POBJECTGROUP   pObjectGroup ; <br>   PCOUNTERGROUP  pCounterGroup, pNextCounterGroup ; <br>   BOOL           bColumnFound ; <br>   PCOLUMNGROUP   pRetColumnGroup = NULL ; <br> <br>   pObjectGroup = pColumnGroup-&gt;pParentObject ; <br>   pSystemGroup = pObjectGroup-&gt;pParentSystem ; <br> <br>   // first, get rid of all the counter lines with this column number <br>   // Note - each Counter group has only 1 line (or 0) with this <br>   // column number <br>   for (pCounterGroup = pObjectGroup-&gt;pCounterGroupFirst ; <br>        pCounterGroup ; <br>        pCounterGroup = pNextCounterGroup ) <br>      { <br>      pNextCounterGroup = pCounterGroup-&gt;pCounterGroupNext ; <br>      bColumnFound = FALSE ; <br> <br>      for (pLine = pCounterGroup-&gt;pLineFirst ; <br>           pLine ; <br>           pLine = pNextLine) <br>         { <br>         pNextLine = pLine-&gt;pLineCounterNext ; <br>         if (pLine-&gt;iReportColumn == pColumnGroup-&gt;ColumnNumber) <br>            { <br>            bColumnFound = TRUE ; <br>            // delete this line <br>            LineRemove (&amp;pReport-&gt;pLineFirst, pLine) ; <br>            LineCounterRemove (&amp;pCounterGroup-&gt;pLineFirst, pLine) ; <br>            LineFree (pLine) ; <br>            break ; <br>            } <br>         } <br> <br>      if (bColumnFound) <br>         { <br>         // check if we need delete this counter group <br>         if (!(pCounterGroup-&gt;pLineFirst)) <br>            { <br>            CounterGroupRemove (&amp;pObjectGroup-&gt;pCounterGroupFirst, pCounterGroup) ; <br>            } <br>         } <br>      } <br> <br>       <br>   // determine which column group to go after deleting this <br>   if (pColumnGroup-&gt;pColumnGroupNext) <br>      { <br>      // get the Column group after this delete one <br>      pRetColumnGroup = pColumnGroup-&gt;pColumnGroupNext ; <br>      } <br>   else <br>      { <br>      // get the Counter group before this delete one <br>      pRetColumnGroup = pColumnGroup-&gt;pColumnGroupPrevious ; <br>      } <br> <br>   if (pNewItemType) <br>      { <br>      if (pRetColumnGroup) <br>         { <br>         *pNewItemType = REPORT_TYPE_COLUMN ; <br>         } <br>      else <br>         { <br>         // get next counter group <br>         pNextCounterGroup = GetNextCounter ( <br>            pSystemGroup, <br>            pObjectGroup, <br>            NULL) ; <br> <br>         if (pNextCounterGroup) <br>            { <br>            // we have to return Counter group, so we have to do the <br>            // dirty casting.. <br>            *pNewItemType = REPORT_TYPE_COUNTER ; <br>            pRetColumnGroup = (PCOLUMNGROUP) pNextCounterGroup ; <br>            } <br>         } <br>      } <br> <br> <br>   // remove this column group <br>   ColumnRemoveOne (pReport, pObjectGroup, pColumnGroup-&gt;ColumnNumber) ; <br> <br>   // check for further cleanup <br>   if (bCleanUpLink) <br>      { <br>      if (!(pObjectGroup-&gt;pCounterGroupFirst)) <br>         ObjectGroupRemove (&amp;pSystemGroup-&gt;pObjectGroupFirst, pObjectGroup) ; <br> <br>      if (!(pSystemGroup-&gt;pObjectGroupFirst)) <br>         SystemGroupRemove (&amp;pReport-&gt;pSystemGroupFirst, pSystemGroup) ; <br>      } <br>   return (pRetColumnGroup) ; <br>   }  // ColumnRemoveItem <br> <br> <br>//======================================// <br>// Counter Group routines               // <br>//======================================// <br> <br>void ReportCounterRect (PREPORT        pReport, <br>                        PCOUNTERGROUP  pCounterGroup, <br>                        LPRECT         lpRect) <br>   {  // ReportCounterRect <br>   lpRect-&gt;left = xCounterMargin ; <br>   lpRect-&gt;top = pCounterGroup-&gt;yLine ; <br>   lpRect-&gt;right = lpRect-&gt;left + pCounterGroup-&gt;xWidth + yScrollHeight / 2 ; <br>   lpRect-&gt;bottom = lpRect-&gt;top + pReport-&gt;yLineHeight ; <br>   }  // ReportCounterRect <br> <br> <br>PCOUNTERGROUP CounterGroupCreate (DWORD  dwCounterIndex, <br>                                  LPTSTR pCounterName)  <br>   {  // CounterGroupCreate <br>   PCOUNTERGROUP  pCounterGroup ; <br>   HDC            hDC ; <br>   PREPORT        pReport ; <br> <br>   pCounterGroup = MemoryAllocate (sizeof (COUNTERGROUP)) ; <br> <br>   if (pCounterGroup) <br>      { <br>      pCounterGroup-&gt;pCounterGroupNext = NULL ; <br>      pCounterGroup-&gt;pLineFirst = NULL ; <br>      pCounterGroup-&gt;dwCounterIndex = dwCounterIndex ; <br> <br>      if (pCounterName) <br>         { <br>         hDC = GetDC (hWndReport) ; <br>         pReport = ReportData (hWndReport) ; <br>         SelectFont (hDC, pReport-&gt;hFont) ; <br>         pCounterGroup-&gt;xWidth = TextWidth (hDC, pCounterName) ; <br>         ReleaseDC (hWndReport, hDC) ; <br>         } <br>      }  // if <br> <br>   return (pCounterGroup) ; <br>   }  // CounterGroupCreate <br> <br> <br>PCOUNTERGROUP GetCounterGroup (POBJECTGROUP pObjectGroup, <br>                            DWORD dwCounterIndex, <br>                            BOOL *pbCounterGroupCreated, <br>                            LPTSTR pCounterName)  <br>   {  // GetCounterGroup <br>   PCOUNTERGROUP   pCounterGroup ; <br> <br>   *pbCounterGroupCreated = FALSE ; <br>   if (!pObjectGroup) <br>      return (FALSE) ; <br> <br>   if (!pObjectGroup-&gt;pCounterGroupFirst) <br>      { <br>      pObjectGroup-&gt;pCounterGroupFirst = <br>         CounterGroupCreate (dwCounterIndex, pCounterName) ; <br> <br>      if (pObjectGroup-&gt;pCounterGroupFirst) <br>         { <br>         *pbCounterGroupCreated = TRUE ; <br>         pObjectGroup-&gt;pCounterGroupFirst-&gt;pParentObject = <br>            pObjectGroup ; <br>         } <br> <br>      return (pObjectGroup-&gt;pCounterGroupFirst) ; <br>      } <br> <br>   for (pCounterGroup = pObjectGroup-&gt;pCounterGroupFirst ; <br>        pCounterGroup ; <br>        pCounterGroup = pCounterGroup-&gt;pCounterGroupNext) <br>      {  // for <br>      if (dwCounterIndex &amp;&amp; pCounterGroup-&gt;dwCounterIndex == dwCounterIndex) <br>         { <br>         return (pCounterGroup) ; <br>         } <br>      else if (!dwCounterIndex &amp;&amp; <br>         pCounterGroup-&gt;pLineFirst &amp;&amp; <br>         pstrsame (pCounterGroup-&gt;pLineFirst-&gt;lnCounterName, pCounterName)) <br>         { <br>         return (pCounterGroup) ; <br>         } <br>      else if (!pCounterGroup-&gt;pCounterGroupNext) <br>         {  // if <br>         pCounterGroup-&gt;pCounterGroupNext =  <br>            CounterGroupCreate (dwCounterIndex, pCounterName) ; <br>         if (pCounterGroup-&gt;pCounterGroupNext) <br>            { <br>            *pbCounterGroupCreated = TRUE ; <br>            (pCounterGroup-&gt;pCounterGroupNext)-&gt;pParentObject = <br>               pObjectGroup ; <br> <br>            // build backward link <br>            (pCounterGroup-&gt;pCounterGroupNext)-&gt;pCounterGroupPrevious = <br>               pCounterGroup ; <br>            } <br>         return (pCounterGroup-&gt;pCounterGroupNext) ; <br>         }  // if <br>      }  // for <br> <br>   return (NULL) ; <br>   }  // GetCounterGroup <br> <br>BOOL CounterGroupRemove (PCOUNTERGROUP *ppCounterGroupFirst, <br>                        PCOUNTERGROUP pCounterGroupRemove) <br>   { <br>   PCOUNTERGROUP  pCounterGroup ; <br> <br>   if (*ppCounterGroupFirst == pCounterGroupRemove) <br>      { <br>      *ppCounterGroupFirst = (*ppCounterGroupFirst)-&gt;pCounterGroupNext ; <br> <br>      if (*ppCounterGroupFirst) <br>         { <br>         // set up head of backward link list <br>         (*ppCounterGroupFirst)-&gt;pCounterGroupPrevious = NULL ; <br>         } <br> <br>      MemoryFree (pCounterGroupRemove) ; <br>      return (TRUE) ; <br>      } <br> <br>   for (pCounterGroup = *ppCounterGroupFirst ; <br>        pCounterGroup-&gt;pCounterGroupNext ; <br>        pCounterGroup = pCounterGroup-&gt;pCounterGroupNext) <br>      {   // for <br>      if (pCounterGroup-&gt;pCounterGroupNext == pCounterGroupRemove) <br>         { <br>         pCounterGroup-&gt;pCounterGroupNext = pCounterGroupRemove-&gt;pCounterGroupNext ; <br>         if (pCounterGroup-&gt;pCounterGroupNext) <br>            { <br>            (pCounterGroup-&gt;pCounterGroupNext)-&gt;pCounterGroupPrevious <br>               = pCounterGroup ; <br>            } <br>         MemoryFree (pCounterGroupRemove) ; <br>         return (TRUE) ; <br>         }  // if <br>      }  // for <br> <br>   return (FALSE) ; <br>   }  // CounterGroupRemove <br> <br> <br>// CounterRemoveItem is called when user wants to delete a <br>// selected counter (row)                         <br>PCOUNTERGROUP CounterRemoveItem (PREPORT        pReport, <br>                                 PCOUNTERGROUP  pCounterGroup, <br>                                 BOOL           bCleanUpLink, <br>                                 enum REPORT_ITEM_TYPE  *pNewItemType) <br>   { <br>   PLINE          pLine, pNextLine ; <br>   POBJECTGROUP   pObjectGroup ; <br>   PSYSTEMGROUP   pSystemGroup ; <br>   PCOLUMNGROUP   pColumnGroup ; <br>   PCOLUMNGROUP   pNextColumnGroup ; <br>   PCOUNTERGROUP  pRetCounterGroup = NULL ; <br> <br>   pObjectGroup = pCounterGroup-&gt;pParentObject ; <br>   pSystemGroup = pObjectGroup-&gt;pParentSystem ; <br> <br>   // first, remove all the counter lines from this counter group <br>   // and from the Report line link-list <br>   for (pLine = pCounterGroup-&gt;pLineFirst ; <br>        pLine ; <br>        pLine = pNextLine) <br>      { <br>      pNextLine = pLine-&gt;pLineCounterNext ; <br>      LineRemove (&amp;pReport-&gt;pLineFirst, pLine) ; <br>      LineFree (pLine) ; <br>      } <br> <br>   // we only need to delete the counter group iff we are deleting <br>   // this selected Counter. <br>   if (bCleanUpLink) <br>      { <br>      // determine which counter group to go after deleting this <br>      pRetCounterGroup = GetNextCounter ( <br>         pSystemGroup , <br>         pObjectGroup, <br>         pCounterGroup) ; <br> <br>      // remove this counter group from its parent object group <br>      CounterGroupRemove (&amp;pObjectGroup-&gt;pCounterGroupFirst, pCounterGroup) ; <br> <br>      if (!(pObjectGroup-&gt;pCounterGroupFirst)) <br>         ObjectGroupRemove (&amp;pSystemGroup-&gt;pObjectGroupFirst, pObjectGroup) ; <br>      else <br>         { <br>         // Object group not empty, check for any empty column <br>         for (pColumnGroup = pObjectGroup-&gt;pColumnGroupFirst ; <br>            pColumnGroup ; <br>            pColumnGroup = pNextColumnGroup) <br>            { <br>            pNextColumnGroup = pColumnGroup-&gt;pColumnGroupNext ; <br>            CheckColumnGroupRemove (pReport, pObjectGroup, pColumnGroup-&gt;ColumnNumber) ; <br>            } <br>         } <br> <br>      if (!(pSystemGroup-&gt;pObjectGroupFirst)) <br>         { <br>         SystemGroupRemove (&amp;pReport-&gt;pSystemGroupFirst, pSystemGroup) ; <br>         } <br>      } <br>   else <br>      { <br>      // get rid of this counter's memory <br>      MemoryFree (pCounterGroup) ; <br>      } <br> <br>   if (pRetCounterGroup &amp;&amp; pNewItemType) <br>      { <br>      *pNewItemType = REPORT_TYPE_COUNTER ; <br>      } <br>   return (pRetCounterGroup) ; <br>   }  // CounterRemoveItem <br> <br> <br>// GetNextCounter is used to get: <br>// If the current system is not empty, then get the  <br>//    (next object first counter) or <br>//    (previous object last counter. ) <br>// If the current system is empty, then get the  <br>//    (next system first object first counter) or  <br>//    (previous system last object last counter) <br>// Note - Any of the input pointers could be NULL pointer. <br>PCOUNTERGROUP GetNextCounter (PSYSTEMGROUP   pSystemGroup, <br>                              POBJECTGROUP   pObjectGroup, <br>                              PCOUNTERGROUP  pCounterGroup) <br>   { <br>   PCOUNTERGROUP  pRetCounter = NULL ; <br>   PCOUNTERGROUP  pCounterGrp ; <br>   POBJECTGROUP   pObjectGrp ; <br> <br>   if (pCounterGroup &amp;&amp; pCounterGroup-&gt;pCounterGroupNext) <br>      { <br>      pRetCounter = pCounterGroup-&gt;pCounterGroupNext ; <br>      } <br>   else if (pCounterGroup &amp;&amp; pCounterGroup-&gt;pCounterGroupPrevious) <br>      { <br>      pRetCounter = pCounterGroup-&gt;pCounterGroupPrevious ; <br>      } <br>   else if (pObjectGroup &amp;&amp; pObjectGroup-&gt;pObjectGroupNext) <br>      { <br>      // get the next Object first Counter <br>      pRetCounter = pObjectGroup-&gt;pObjectGroupNext-&gt;pCounterGroupFirst ; <br>      } <br>   else if (pObjectGroup &amp;&amp; pObjectGroup-&gt;pObjectGroupPrevious) <br>      { <br>      // get the previous object last counter <br>      pCounterGrp = (pObjectGroup-&gt;pObjectGroupPrevious)-&gt;pCounterGroupFirst ; <br>      if (pCounterGrp) <br>         { <br>         // get the last counter group of this object <br>         for (; <br>              pCounterGrp-&gt;pCounterGroupNext ; <br>              pCounterGrp = pCounterGrp-&gt;pCounterGroupNext ) <br>            { <br>            ; <br>            } <br>         } <br>      pRetCounter = pCounterGrp ; <br> <br>      } <br>   else if (pSystemGroup &amp;&amp; pSystemGroup-&gt;pSystemGroupNext) <br>      { <br>      // get next system first object first counter <br>      pObjectGrp = pSystemGroup-&gt;pSystemGroupNext-&gt;pObjectGroupFirst ; <br>      pRetCounter = pObjectGrp-&gt;pCounterGroupFirst ; <br>      } <br>   else if (pSystemGroup &amp;&amp; pSystemGroup-&gt;pSystemGroupPrevious) <br>      { <br>      // get previous system last object last counter <br>      pObjectGrp = pSystemGroup-&gt;pSystemGroupPrevious-&gt;pObjectGroupFirst ; <br>      if (pObjectGrp) <br>         { <br>         // get the last object group of this system <br>         for (; <br>              pObjectGrp-&gt;pObjectGroupNext ; <br>              pObjectGrp = pObjectGrp-&gt;pObjectGroupNext ) <br>            { <br>            ; <br>            } <br>         } <br>       <br>      if (pObjectGrp) <br>         { <br>         pCounterGrp = pObjectGrp-&gt;pCounterGroupFirst ; </code></pre>
<p>
</p>
<pre><code>if (pCounterGrp) <br>            { <br>            // get the last counter group of this object <br>            for (; <br>                 pCounterGrp-&gt;pCounterGroupNext ; <br>                 pCounterGrp = pCounterGrp-&gt;pCounterGroupNext ) <br>               { <br>               ; <br>               } <br>            } <br>         pRetCounter = pCounterGrp ; <br>         } <br>      } <br> <br>   return (pRetCounter) ; <br> <br>   }  // GetNextCounter <br> <br> <br>//======================================// <br>// Object Group routines                // <br>//======================================// <br> <br>void ReportObjectRect (PREPORT        pReport, <br>                       POBJECTGROUP   pObjectGroup, <br>                       LPRECT         lpRect) <br>   {  // ReportObjectRect <br>   lpRect-&gt;left = xObjectMargin ; <br>   lpRect-&gt;top = pObjectGroup-&gt;yFirstLine ; <br>   lpRect-&gt;right = lpRect-&gt;left + pObjectGroup-&gt;xWidth ; <br>   lpRect-&gt;bottom = lpRect-&gt;top + pReport-&gt;yLineHeight ; <br>   }  // ReportObjectRect <br> <br> <br>POBJECTGROUP ObjectGroupCreate (LPTSTR lpszObjectName) <br>   {  // ObjectGroupCreate <br>   POBJECTGROUP   pObjectGroup ; <br>   HDC            hDC ; <br>   PREPORT        pReport ; <br>   int            OldCounterWidth ; <br>   TCHAR          szLine [LongTextLen] ; <br> <br>   pObjectGroup = MemoryAllocate (sizeof (OBJECTGROUP)) ; <br> <br>   if (pObjectGroup) <br>      { <br>      pObjectGroup-&gt;pObjectGroupNext = NULL ; <br>      pObjectGroup-&gt;pCounterGroupFirst = NULL ; <br>      pObjectGroup-&gt;pColumnGroupFirst = NULL ; <br>      pObjectGroup-&gt;lpszObjectName = StringAllocate (lpszObjectName) ; <br> <br>      hDC = GetDC (hWndReport) ; <br>      pReport = ReportData (hWndReport) ; <br>      SelectFont (hDC, pReport-&gt;hFontHeaders) ; <br> <br>      TSPRINTF (szLine, szObjectFormat, lpszObjectName) ; <br>      pObjectGroup-&gt;xWidth = TextWidth (hDC, szLine) ; <br> <br>      // re-calc. the max. counter group width <br>      OldCounterWidth = pReport-&gt;xMaxCounterWidth ; <br>      pReport-&gt;xMaxCounterWidth = <br>            max (pReport-&gt;xMaxCounterWidth, <br>                 pObjectGroup-&gt;xWidth + xObjectMargin) ; <br> <br>      if (OldCounterWidth &lt; pReport-&gt;xMaxCounterWidth) <br>          { <br>          // adjust the report width with the new counter width <br>          pReport-&gt;xWidth += <br>               (pReport-&gt;xMaxCounterWidth - OldCounterWidth); <br>          } <br> <br>      ReleaseDC (hWndReport, hDC) ; <br>      }  // if <br>   return (pObjectGroup) ; <br>   }  // ObjectGroupCreate <br> <br> <br> <br>POBJECTGROUP GetObjectGroup (PSYSTEMGROUP pSystemGroup, <br>                          LPTSTR lpszObjectName) <br>   { <br>   POBJECTGROUP   pObjectGroup ; <br> <br>   if (!pSystemGroup) <br>      return (FALSE) ; <br> <br>   if (!pSystemGroup-&gt;pObjectGroupFirst) <br>      { <br>      pSystemGroup-&gt;pObjectGroupFirst = ObjectGroupCreate (lpszObjectName) ; <br>      if (pSystemGroup-&gt;pObjectGroupFirst) <br>         { <br>         pSystemGroup-&gt;pObjectGroupFirst-&gt;pParentSystem = <br>            pSystemGroup ; <br>         } <br>      return (pSystemGroup-&gt;pObjectGroupFirst) ; <br>      } <br> <br>   for (pObjectGroup = pSystemGroup-&gt;pObjectGroupFirst ; <br>        pObjectGroup ; <br>        pObjectGroup = pObjectGroup-&gt;pObjectGroupNext) <br>      {  // for <br>      if (strsame (pObjectGroup-&gt;lpszObjectName, lpszObjectName)) <br>         { <br>         return (pObjectGroup) ; <br>         } <br>      else if (!pObjectGroup-&gt;pObjectGroupNext) <br>         {  // if <br>         pObjectGroup-&gt;pObjectGroupNext =  <br>            ObjectGroupCreate (lpszObjectName) ; <br> <br>         if (pObjectGroup-&gt;pObjectGroupNext) <br>            { <br>            (pObjectGroup-&gt;pObjectGroupNext)-&gt;pParentSystem = <br>               pSystemGroup ; <br>            (pObjectGroup-&gt;pObjectGroupNext)-&gt;pObjectGroupPrevious = <br>               pObjectGroup ; <br>            } <br> <br>         return (pObjectGroup-&gt;pObjectGroupNext) ; <br>         }  // if <br>      }  // for <br>   }  // GetObjectGroup <br> <br>// ObjectGroupRemove removes the specified Object group <br>// from the Object double link list <br>BOOL ObjectGroupRemove (POBJECTGROUP *ppObjectGroupFirst, <br>                        POBJECTGROUP pObjectGroupRemove) <br>   { <br>   POBJECTGROUP  pObjectGroup ; <br> <br>   if (*ppObjectGroupFirst == pObjectGroupRemove) <br>      { <br>      *ppObjectGroupFirst = (*ppObjectGroupFirst)-&gt;pObjectGroupNext ; <br>      if (*ppObjectGroupFirst) <br>         { <br>         // set up head of backward link list <br>         (*ppObjectGroupFirst)-&gt;pObjectGroupPrevious = NULL ; <br>         } <br> <br>      // clean up the allocated memory <br>      ColumnGroupRemove (pObjectGroupRemove-&gt;pColumnGroupFirst) ; <br>      MemoryFree (pObjectGroupRemove-&gt;lpszObjectName) ; <br>      MemoryFree (pObjectGroupRemove) ; <br>      return (TRUE) ; <br>      } <br> <br>   for (pObjectGroup = *ppObjectGroupFirst ; <br>        pObjectGroup-&gt;pObjectGroupNext ; <br>        pObjectGroup = pObjectGroup-&gt;pObjectGroupNext) <br>      {   // for <br>      if (pObjectGroup-&gt;pObjectGroupNext == pObjectGroupRemove) <br>         { <br>         pObjectGroup-&gt;pObjectGroupNext = pObjectGroupRemove-&gt;pObjectGroupNext ; <br>         if (pObjectGroup-&gt;pObjectGroupNext) <br>            { <br>            (pObjectGroup-&gt;pObjectGroupNext)-&gt;pObjectGroupPrevious = <br>               pObjectGroup ; <br>            } <br> <br>         // clean up this object allocated memory and its column groups <br>         ColumnGroupRemove (pObjectGroupRemove-&gt;pColumnGroupFirst) ; <br>         MemoryFree (pObjectGroupRemove-&gt;lpszObjectName) ; <br>         MemoryFree (pObjectGroupRemove) ; <br>         return (TRUE) ; <br>         }  // if <br>      }  // for <br> <br>   return (FALSE) ; <br>   }  // ObjectGroupRemove <br> <br> <br>// ObjectRemoveItem is called when user delete the selected object <br>PCOUNTERGROUP ObjectRemoveItem (PREPORT      pReport, <br>                                POBJECTGROUP pObjectGroup, <br>                                BOOL         bCleanUpLink, <br>                                enum REPORT_ITEM_TYPE  *pNewItemType) <br>   { <br>   PCOUNTERGROUP  pCounterGroup, pNextCounterGroup ; <br>   PSYSTEMGROUP   pSystemGroup ; <br>   PCOUNTERGROUP  pRetCounterGroup = NULL ; <br> <br>   pSystemGroup = pObjectGroup-&gt;pParentSystem ; <br> <br>   // remove all counter groups from this object <br>   for (pCounterGroup = pObjectGroup-&gt;pCounterGroupFirst ; <br>        pCounterGroup ; <br>        pCounterGroup = pNextCounterGroup ) <br>      { <br>      pNextCounterGroup = pCounterGroup-&gt;pCounterGroupNext ; <br>      CounterRemoveItem (pReport, pCounterGroup, FALSE, NULL) ; <br>      } <br> <br>   // remove all column groups from this group <br>   ColumnGroupRemove (pObjectGroup-&gt;pColumnGroupFirst) ; <br>    <br>   if (bCleanUpLink) <br>      { <br>       <br>      // get next counter group to get the focus <br>      if (pNewItemType) <br>         { <br>         pRetCounterGroup = GetNextCounter ( <br>            pSystemGroup, <br>            pObjectGroup, <br>            NULL) ; <br> <br>         if (pRetCounterGroup) <br>            { <br>            *pNewItemType = REPORT_TYPE_COUNTER ; <br>            } <br>         } <br> <br> <br>      // remove this object from its parent system group <br>      ObjectGroupRemove (&amp;pSystemGroup-&gt;pObjectGroupFirst, pObjectGroup) ; <br> <br>      if (!(pSystemGroup-&gt;pObjectGroupFirst)) <br>         { <br>         SystemGroupRemove (&amp;pReport-&gt;pSystemGroupFirst, pSystemGroup) ; <br>         } <br>      } <br>   else <br>      { <br>      // get rid of this object <br>      MemoryFree (pObjectGroup-&gt;lpszObjectName) ; <br>      MemoryFree (pObjectGroup) ; <br>      } <br> <br>   return (pRetCounterGroup) ; <br> <br>   }  // ObjectRemoveItem <br> <br> <br>//======================================// <br>// System Group routines                // <br>//======================================// <br>void ReportSystemRect (PREPORT        pReport, <br>                       PSYSTEMGROUP   pSystemGroup, <br>                       LPRECT         lpRect) <br>   {  // ReportSystemRect <br>   lpRect-&gt;left = xSystemMargin ; <br>   lpRect-&gt;top = pSystemGroup-&gt;yFirstLine ; <br>   lpRect-&gt;right = lpRect-&gt;left + pSystemGroup-&gt;xWidth ; <br>   lpRect-&gt;bottom = lpRect-&gt;top + pReport-&gt;yLineHeight ; <br>   }  // ReportSystemRect <br> <br>PSYSTEMGROUP SystemGroupCreate (LPTSTR lpszSystemName) <br>   {  // SystemGroupCreate <br>   PSYSTEMGROUP   pSystemGroup ; <br>   HDC            hDC ; <br>   PREPORT        pReport ; <br>   TCHAR          szLine [LongTextLen] ; <br> <br>   pSystemGroup = MemoryAllocate (sizeof (SYSTEMGROUP)) ; <br> <br>   if (pSystemGroup) <br>      { <br>      pSystemGroup-&gt;pSystemGroupNext = NULL ; <br>      pSystemGroup-&gt;pObjectGroupFirst = NULL ; <br>      pSystemGroup-&gt;lpszSystemName = StringAllocate (lpszSystemName) ; <br> <br>      // get width of system name <br>      hDC = GetDC (hWndReport) ; <br>      pReport = ReportData (hWndReport) ; <br>      SelectFont (hDC, pReport-&gt;hFontHeaders) ; <br> <br>      TSPRINTF (szLine, szSystemFormat, lpszSystemName) ; <br>      pSystemGroup-&gt;xWidth = TextWidth (hDC, szLine) ; <br>      ReleaseDC (hWndReport, hDC) ; <br>      }  // if <br> <br>   return (pSystemGroup) ; <br>   }  // SystemGroupCreate <br>  <br>PSYSTEMGROUP GetSystemGroup (PREPORT pReport, <br>                          LPTSTR lpszSystemName) <br>/* <br>   Effect;        Return a pointer to the system group of pReport with <br>                  a system name of lpszSystemName. If no system group <br>                  has that name, add a new system group. <br>*/ <br>   {  // GetSystemGroup <br>   PSYSTEMGROUP   pSystemGroup ; <br> <br>   if (!pReport-&gt;pSystemGroupFirst) <br>      { <br>      pReport-&gt;pSystemGroupFirst = SystemGroupCreate (lpszSystemName) ; <br>      return (pReport-&gt;pSystemGroupFirst) ; <br>      } <br> <br>   for (pSystemGroup = pReport-&gt;pSystemGroupFirst ; <br>        pSystemGroup ; <br>        pSystemGroup = pSystemGroup-&gt;pSystemGroupNext) <br>      {  // for <br>      if (strsamei (pSystemGroup-&gt;lpszSystemName, lpszSystemName)) <br>         return (pSystemGroup) ; <br>      else if (!pSystemGroup-&gt;pSystemGroupNext) <br>         {  // if <br>         pSystemGroup-&gt;pSystemGroupNext =  <br>            SystemGroupCreate (lpszSystemName) ; <br>         if (pSystemGroup-&gt;pSystemGroupNext) <br>            { <br>            (pSystemGroup-&gt;pSystemGroupNext)-&gt;pSystemGroupPrevious = <br>               pSystemGroup ; <br>            } <br>         return (pSystemGroup-&gt;pSystemGroupNext) ; <br>         }  // if <br>      }  // for <br>   }  // GetSystemGroup <br> <br> <br>BOOL SystemGroupRemove (PSYSTEMGROUP *ppSystemGroupFirst, <br>                        PSYSTEMGROUP pSystemGroupRemove) <br>   { <br>   PSYSTEMGROUP  pSystemGroup ; <br> <br>   if (*ppSystemGroupFirst == pSystemGroupRemove) <br>      { <br>      *ppSystemGroupFirst = (*ppSystemGroupFirst)-&gt;pSystemGroupNext ; <br>      if (*ppSystemGroupFirst) <br>         { <br>         (*ppSystemGroupFirst)-&gt;pSystemGroupPrevious = NULL ; <br>         } <br>      MemoryFree (pSystemGroupRemove-&gt;lpszSystemName) ; <br>      MemoryFree (pSystemGroupRemove) ; <br>      return (TRUE) ; <br>      } <br> <br>   for (pSystemGroup = *ppSystemGroupFirst ; <br>        pSystemGroup-&gt;pSystemGroupNext ; <br>        pSystemGroup = pSystemGroup-&gt;pSystemGroupNext) <br>      {   // for <br>      if (pSystemGroup-&gt;pSystemGroupNext == pSystemGroupRemove) <br>         { <br>         pSystemGroup-&gt;pSystemGroupNext = pSystemGroupRemove-&gt;pSystemGroupNext ; <br>         if (pSystemGroup-&gt;pSystemGroupNext) <br>            { <br>            (pSystemGroup-&gt;pSystemGroupNext)-&gt;pSystemGroupPrevious = <br>               pSystemGroup ; <br>            } <br>         MemoryFree (pSystemGroupRemove-&gt;lpszSystemName) ; <br>         MemoryFree (pSystemGroupRemove) ; <br>         return (TRUE) ; <br>         }  // if <br>      }  // for <br> <br>   return (FALSE) ; <br>   }  // SystemGroupRemove <br> <br> <br>// SystemRemoveItem is called when user deletes the selected System <br>PCOUNTERGROUP SystemRemoveItem (PREPORT      pReport, <br>                                PSYSTEMGROUP pSystemGroup, <br>                                BOOL         bCleanUpLink, <br>                                enum REPORT_ITEM_TYPE  *pNewItemType) <br>   { <br>   POBJECTGROUP   pObjectGroup, pNextObjectGroup ; <br>   PCOUNTERGROUP  pRetCounterGroup = NULL ; <br>    <br>   // remove all object groups from this system       <br>   for (pObjectGroup = pSystemGroup-&gt;pObjectGroupFirst ; <br>        pObjectGroup ; <br>        pObjectGroup = pNextObjectGroup ) <br>      { <br>      pNextObjectGroup = pObjectGroup-&gt;pObjectGroupNext ; <br>      ObjectRemoveItem (pReport, pObjectGroup, FALSE, NULL) ; <br>      } <br> <br> <br>   if (bCleanUpLink) <br>      { <br>      if (pNewItemType) <br>         { <br>         pRetCounterGroup = GetNextCounter ( <br>            pSystemGroup, <br>            NULL, <br>            NULL) ; <br> <br>         if (pRetCounterGroup) <br>            { <br>            *pNewItemType = REPORT_TYPE_COUNTER ; <br>            } <br>         } <br> <br>      SystemGroupRemove (&amp;pReport-&gt;pSystemGroupFirst, pSystemGroup) ; <br>      } <br>   else <br>      { <br>      // delete data from this system <br>      MemoryFree (pSystemGroup-&gt;lpszSystemName) ; <br>      MemoryFree (pSystemGroup) ; <br>      } <br> <br>   return (pRetCounterGroup) ; <br>    <br>   }  // SystemRemoveItem <br> <br>                       <br>BOOL  ReportChangeFocus (HWND                   hWnd, <br>                         PREPORT                pReport, <br>                         REPORT_ITEM            SelectedItem, <br>                         enum REPORT_ITEM_TYPE  SelectedItemType, <br>                         int                    xOffset, <br>                         int                    yOffset, <br>                         RECT                   *pRect) <br>   { <br>   HDC         hDC ; <br>   BOOL        RetCode = FALSE ; // FALSE ==&gt; same item being hit <br>   RECT        Rect ; <br>   REPORT_ITEM            PreviousItem ; <br>   enum REPORT_ITEM_TYPE  PreviousItemType ; <br>    <br>   if (pReport-&gt;CurrentItem.pLine != SelectedItem.pLine) <br>      { <br>      // not the same item <br>      RetCode = TRUE ; <br> <br>      PreviousItemType = pReport-&gt;CurrentItemType ; <br>      PreviousItem.pLine = pReport-&gt;CurrentItem.pLine ; <br> <br>      pReport-&gt;CurrentItemType = SelectedItemType ; <br>      pReport-&gt;CurrentItem.pLine = SelectedItem.pLine ; <br> <br>      hDC = GetDC (hWnd) ; <br> <br>      if (SelectedItemType == REPORT_TYPE_LINE) <br>         { <br>         SetWindowOrgEx (hDC, xOffset, yOffset, NULL) ; <br>         SelectFont (hDC, pReport-&gt;hFont) ; <br>         SetTextAlign (hDC, TA_RIGHT) ; <br>         SetBkColor (hDC, GetSysColor(COLOR_WINDOW)) ; <br>         DrawReportValue (hDC, pReport, SelectedItem.pLine) ; <br>         SetWindowOrgEx (hDC, -xOffset, -yOffset, NULL) ; <br>         } <br>      else <br>         { <br>         Rect = *pRect ; <br>         Rect.top -= yOffset ; <br>         Rect.bottom -= yOffset ; <br>         Rect.right -= xOffset ; <br>         Rect.left -= xOffset ; <br>         InvalidateRect (hWnd, &amp;Rect, TRUE) ; <br>         } <br> <br>      if (PreviousItemType == REPORT_TYPE_LINE) <br>         { <br>         SetWindowOrgEx (hDC, xOffset, yOffset, NULL) ; <br>         SelectFont (hDC, pReport-&gt;hFont) ; <br>         SetTextAlign (hDC, TA_RIGHT) ; <br>         SetBkColor (hDC, GetSysColor(COLOR_WINDOW)) ; <br>         DrawReportValue (hDC, pReport, PreviousItem.pLine) ; <br>         } <br>      else if (PreviousItemType != REPORT_TYPE_NOTHING) <br>         { <br>         if (PreviousItemType == REPORT_TYPE_SYSTEM) <br>            { <br>            ReportSystemRect (pReport, PreviousItem.pSystem, &amp;Rect) ; <br>            } <br>         else if (PreviousItemType == REPORT_TYPE_OBJECT) <br>            { <br>            ReportObjectRect (pReport, PreviousItem.pObject, &amp;Rect) ; <br>            } <br>         else if (PreviousItemType == REPORT_TYPE_COUNTER) <br>            { <br>            ReportCounterRect (pReport, PreviousItem.pCounter, &amp;Rect) ; <br>            } <br>         else if (PreviousItemType == REPORT_TYPE_COLUMN) <br>            { <br>            ReportColumnRect (pReport, PreviousItem.pColumn, &amp;Rect) ; <br>            } <br>         Rect.top -= yOffset ; <br>         Rect.bottom -= yOffset ; <br>         Rect.right -= xOffset ; <br>         Rect.left -= xOffset ; <br>         InvalidateRect (hWnd, &amp;Rect, TRUE) ; <br>         } <br>      ReleaseDC (hWnd, hDC) ; <br>      } <br> <br>   return (RetCode) ; <br>   }  // ReportChangeFocus <br> <br>  <br>BOOL  OnReportLButtonDown (HWND hWnd,  <br>                           WORD xPos, <br>                           WORD yPos) <br>   { <br>   PREPORT     pReport ; <br>   PLINE       pLine ; <br>   REPORT_ITEM PreviousItem ; <br>   REPORT_ITEM CurrentSelectedItem ; <br>   enum REPORT_ITEM_TYPE PreviousItemType ; <br>   RECT        rect ; <br>   POINT       pt ; <br>   int         xOffset, yOffset ; <br>   PSYSTEMGROUP   pSystemGroup ; <br>   POBJECTGROUP   pObjectGroup ; <br>   PCOUNTERGROUP  pCounterGroup ; <br>   PCOLUMNGROUP   pColumnGroup ; <br>    <br> <br>   pReport = ReportData (hWnd) ; <br>   if (!pReport) <br>      return (FALSE) ; <br> <br>   xOffset = GetScrollPos (hWnd, SB_HORZ) ; <br>   yOffset = GetScrollPos (hWnd, SB_VERT) ; <br>   pt.x = xPos + xOffset ; <br>   pt.y = yPos + yOffset ; <br>   PreviousItem = pReport-&gt;CurrentItem ; <br>   PreviousItemType = pReport-&gt;CurrentItemType ; <br> <br>   for (pLine = pReport-&gt;pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineNext) <br>      {  // for <br>      ReportLineValueRect (pReport, pLine, &amp;rect) ; <br>      if (PtInRect (&amp;rect, pt)) <br>         { <br>         CurrentSelectedItem.pLine = pLine ; <br>         return (ReportChangeFocus ( <br>            hWnd, <br>            pReport, <br>            CurrentSelectedItem, <br>            REPORT_TYPE_LINE, <br>            xOffset, <br>            yOffset, <br>            &amp;rect)) ; <br>         } <br>      }  // for <br> <br>   // check on hit on system, object, counter, column (parent+isntance names) <br>   for (pSystemGroup = pReport-&gt;pSystemGroupFirst ; <br>        pSystemGroup ; <br>        pSystemGroup = pSystemGroup-&gt;pSystemGroupNext) <br>      {  // for System... <br> <br>      ReportSystemRect (pReport, pSystemGroup, &amp;rect) ; <br>      if (PtInRect (&amp;rect, pt)) <br>         { <br>         CurrentSelectedItem.pSystem = pSystemGroup ; <br>         return (ReportChangeFocus ( <br>            hWnd, <br>            pReport, <br>            CurrentSelectedItem, <br>            REPORT_TYPE_SYSTEM, <br>            xOffset, <br>            yOffset, <br>            &amp;rect)) ; <br>         } <br> <br> <br>      for (pObjectGroup = pSystemGroup-&gt;pObjectGroupFirst ; <br>           pObjectGroup ; <br>           pObjectGroup = pObjectGroup-&gt;pObjectGroupNext) <br>         {  // for Object... <br> <br>         ReportObjectRect (pReport, pObjectGroup, &amp;rect) ; <br>         if (PtInRect (&amp;rect, pt)) <br>            { <br>            CurrentSelectedItem.pObject = pObjectGroup ; <br>            return (ReportChangeFocus ( <br>               hWnd, <br>               pReport, <br>               CurrentSelectedItem, <br>               REPORT_TYPE_OBJECT, <br>               xOffset, <br>               yOffset, <br>               &amp;rect)) ; <br>            } <br> <br>         for (pColumnGroup = pObjectGroup-&gt;pColumnGroupFirst ; <br>              pColumnGroup ; <br>              pColumnGroup = pColumnGroup-&gt;pColumnGroupNext) <br>            {  // for Column... <br>            ReportColumnRect (pReport, pColumnGroup, &amp;rect) ; <br>            if (PtInRect (&amp;rect, pt)) <br>               { <br>               CurrentSelectedItem.pColumn = pColumnGroup ; <br>               return (ReportChangeFocus ( <br>                  hWnd, <br>                  pReport, <br>                  CurrentSelectedItem, <br>                  REPORT_TYPE_COLUMN, <br>                  xOffset, <br>                  yOffset, <br>                  &amp;rect)) ; <br>               } <br>            }  // for Column <br> <br>         for (pCounterGroup = pObjectGroup-&gt;pCounterGroupFirst ; <br>              pCounterGroup ; <br>              pCounterGroup = pCounterGroup-&gt;pCounterGroupNext) <br>            {  // for Counter... <br>            ReportCounterRect (pReport, pCounterGroup, &amp;rect) ; <br>            if (PtInRect (&amp;rect, pt)) <br>               { <br>               CurrentSelectedItem.pCounter = pCounterGroup ; <br>               return (ReportChangeFocus ( <br>                  hWnd, <br>                  pReport, <br>                  CurrentSelectedItem, <br>                  REPORT_TYPE_COUNTER, <br>                  xOffset, <br>                  yOffset, <br>                  &amp;rect)) ; <br> <br>               } <br>            }  // for Counter... <br>         }  // for Object... <br>      }  // for System... <br> <br>   // nothing hit <br>   return (FALSE) ; <br>   }  // OnReportLButtonDown <br> <br>BOOL ReportDeleteItem (HWND hWnd) <br>/* <br>   Effect:        Delete the current selected item. <br> <br>*/ <br>   {  // ReportDeleteItem <br> <br>   HDC                     hDC ; <br>   PREPORT                 pReport ; <br>   REPORT_ITEM             NextItem ; <br>   enum  REPORT_ITEM_TYPE  NextItemType ; <br> <br>   NextItemType = REPORT_TYPE_NOTHING ; <br>   NextItem.pLine = NULL ; <br> <br>   pReport = ReportData (hWnd) ; <br>   if (pReport-&gt;CurrentItemType == REPORT_TYPE_NOTHING) <br>      { <br>      // nothing to delete... <br>      return (TRUE) ; <br>      } <br>   else if (pReport-&gt;CurrentItemType == REPORT_TYPE_LINE) <br>      { <br>      NextItem.pLine = LineRemoveItem (pReport, &amp;NextItemType) ; <br>      } <br>   else if (pReport-&gt;CurrentItemType == REPORT_TYPE_SYSTEM) <br>      { <br>      NextItem.pCounter = SystemRemoveItem ( <br>            pReport, <br>            pReport-&gt;CurrentItem.pSystem, <br>            TRUE, <br>            &amp;NextItemType) ; <br>      } <br>   else if (pReport-&gt;CurrentItemType == REPORT_TYPE_OBJECT) <br>      { <br>      NextItem.pCounter = ObjectRemoveItem ( <br>            pReport, <br>            pReport-&gt;CurrentItem.pObject, <br>            TRUE, <br>            &amp;NextItemType) ; <br>      } <br>   else if (pReport-&gt;CurrentItemType == REPORT_TYPE_COUNTER) <br>      { <br>      NextItem.pCounter = CounterRemoveItem ( <br>            pReport, <br>            pReport-&gt;CurrentItem.pCounter, <br>            TRUE, <br>            &amp;NextItemType) ; <br>      } <br>   else if (pReport-&gt;CurrentItemType == REPORT_TYPE_COLUMN) <br>      { <br>      NextItem.pColumn = ColumnRemoveItem ( <br>            pReport, <br>            pReport-&gt;CurrentItem.pColumn, <br>            TRUE, <br>            &amp;NextItemType) ; <br>      } <br>    <br>   if (NextItemType != REPORT_TYPE_NOTHING) <br>      { <br>      pReport-&gt;CurrentItem.pLine = NextItem.pLine ; <br>      pReport-&gt;CurrentItemType = NextItemType ; <br>      } <br>   else <br>      { <br>      pReport-&gt;CurrentItem.pLine = pReport-&gt;pLineFirst ; <br>      pReport-&gt;CurrentItemType = REPORT_TYPE_LINE ; <br>      } <br> <br>   if (pReport-&gt;pLineFirst) <br>      { <br>      BuildValueListForSystems ( <br>         pReport-&gt;pSystemFirst, <br>         pReport-&gt;pLineFirst) ; <br>      } <br>   else <br>      { <br>      // no more line, no more timer... <br>      pReport-&gt;xWidth = 0 ; <br>      pReport-&gt;yHeight = 0 ; <br>      pReport-&gt;xMaxCounterWidth = 0 ; <br>      ClearReportTimer (pReport) ; <br> <br>      FreeSystems (pReport-&gt;pSystemFirst) ; <br>      pReport-&gt;pSystemFirst = NULL ; <br>      pReport-&gt;pSystemGroupFirst = NULL ; <br>      pReport-&gt;CurrentItemType = REPORT_TYPE_NOTHING ; <br>      pReport-&gt;CurrentItem.pLine = NULL ; <br> <br>      } <br> <br>   //=============================// <br>   // Calculate report positions  // <br>   //=============================// <br>    <br>   hDC = GetDC (hWnd) ; <br>   SetReportPositions (hDC, pReport) ; <br> <br>   if (!pReport-&gt;pLineFirst) <br>      { <br>      SelectFont (hDC, pReport-&gt;hFont) ; <br>      pReport-&gt;xValueWidth = TextWidth (hDC, szValuePlaceholder) ; <br>      } <br> <br>   ReleaseDC (hWnd, hDC) ; <br>   WindowInvalidate (hWnd) ; <br> <br>   return (TRUE) ; <br>   }  // ReportDeleteItem <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
