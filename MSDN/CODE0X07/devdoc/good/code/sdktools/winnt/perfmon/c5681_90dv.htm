<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PERFMON.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5683"></a>PERFMON.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  Perfmon.c - This is the WinMain module. It creates the main window and <br> *              the threads, and contains the main MainWndProc. <br> * <br> *  Microsoft Confidential <br> *  Copyright 1992 - 1998 Microsoft Corporation <br> * <br> *  Authors - <br> * <br> *       Russ Blake <br> *       Mike Moskowitz <br> *       Hon-Wah Chan <br> *       Bob Watson <br> * <br> ****************************************************************************/ <br> <br> <br>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br>#undef NOSYSCOMMANDS <br> <br>// DEFINE_GLOBALS will define all the globals listed in globals.h <br>#define DEFINE_GLOBALS <br> <br>#include "perfmon.h" <br> <br>#include "command.h" <br> <br>#include "graph.h" <br>#include "log.h" <br>#include "alert.h" <br>#include "report.h"     // for CreateReportWindow <br>#include "legend.h" <br>#include "init.h" <br>#include "perfmops.h" <br>#include "toolbar.h"    // for CreateToolbar <br>#include "status.h"     // for CreatePMStatusWindow <br>#include "utils.h" <br> <br>#include "fileopen.h"   // for FileOpen <br> <br> <br>#define dwToolbarStyle     (WS_CHILD | WS_VISIBLE | TBS_NOCAPTION) <br> <br>extern TCHAR szInternational[] ; <br> <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br>void static OnSize (HWND hWnd, <br>                    WORD xWidth, <br>                    WORD yHeight) <br>/* <br>   Effect:        Perform any actions needed when the main window is <br>                  resized. In particular, size the four data windows, <br>                  only one of which is visible right now. <br>*/ <br>   {  // OnSize <br>   SizePerfmonComponents () ; <br>   } <br> <br> <br>void static OnCreate (HWND hWnd) <br>/* <br>   Effect:        Perform all actions needed when the main window is <br>                  created. In particular, create the three data windows, <br>                  and show one of them. <br> <br>   To Do:         Check for proper creation. If not possible, we will <br>                  need to abort creation of the program. <br> <br>   Called By:     MainWndProc only, in response to a WM_CREATE message. <br>*/ <br>   {  // OnCreate <br>   hWndGraph = CreateGraphWindow (hWnd) ; <br> <br>#ifdef ADVANCED_PERFMON <br>   hWndLog = CreateLogWindow (hWnd) ; <br>   hWndAlert = CreateAlertWindow (hWnd) ; <br>   hWndReport = CreateReportWindow (hWnd) ; <br>#endif <br> <br>   hWndStatus = CreatePMStatusWindow (hWnd) ; <br> <br>   CreateToolbarWnd (hWnd) ; <br>   MinimumSize += WindowHeight (hWndToolbar) ; <br> <br>   Options.bMenubar = TRUE ; <br>   Options.bToolbar = TRUE ; <br>   Options.bStatusbar = TRUE; <br>   Options.bAlwaysOnTop = FALSE ; <br> <br>   // initialize to chart view - HWC <br>   iPerfmonView = IDM_VIEWCHART; <br> <br> <br>   ShowWindow (PerfmonViewWindow (), SW_SHOWNORMAL) ; <br>   }  // OnCreate <br> <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br>void MenuBarHit (DWORD wParam) <br>{ <br>   if (wParam == MENUCLOSING) <br>      { <br>      StatusLineReady (hWndStatus) ; <br>      dwCurrentMenuID = 0 ; <br>      } <br>   else if (HIWORD(wParam) &amp; MF_SYSMENU) <br>      { <br>      WORD   SystemMenuItem = 0 ; <br>      switch (LOWORD (wParam)) <br>         { <br>         case SC_RESTORE: <br>            SystemMenuItem = IDM_SYSTEMRESTORE ; <br>            break ; <br> <br>         case SC_SIZE: <br>            SystemMenuItem = IDM_SYSTEMSIZE ; <br>            break ; <br> <br>         case SC_MOVE: <br>            SystemMenuItem = IDM_SYSTEMMOVE ; <br>            break ; <br> <br>         case SC_MINIMIZE: <br>            SystemMenuItem = IDM_SYSTEMMINIMIZE ; <br>            break ; <br> <br>         case SC_MAXIMIZE: <br>            SystemMenuItem = IDM_SYSTEMMAXIMIZE ; <br>            break ; <br> <br>         case SC_CLOSE: <br>            SystemMenuItem = IDM_SYSTEMCLOSE ; <br>            break ; <br> <br>         case SC_TASKLIST: <br>            SystemMenuItem = IDM_SYSTEMSWITCHTO ; <br>            break ; <br>         } <br> <br>      if (SystemMenuItem) <br>         { <br>         StatusLine (hWndStatus, SystemMenuItem) ; <br>         dwCurrentMenuID = MenuIDToHelpID (SystemMenuItem) ; <br>         } <br>      } <br>   else <br>      { <br>      StatusLine (hWndStatus, LOWORD (wParam)) ; <br>      } <br>} <br> <br>void OnDropFile (DWORD wParam) <br>   { <br>   TCHAR FileName [FilePathLen + 1] ; <br>   LPTSTR         pFileNameStart ; <br>   HANDLE         hFindFile ; <br>   WIN32_FIND_DATA FindFileInfo ; <br>   int            NameOffset ; <br>   int            NumOfFiles = 0 ; <br> <br>   NumOfFiles = DragQueryFile ((HDROP) wParam, 0xffffffff, NULL, 0) ; <br>   if (NumOfFiles &gt; 0) <br>      { <br>      // we only open the first file for now <br>      DragQueryFile((HDROP) wParam, 0, FileName, FilePathLen) ; <br> <br>      pFileNameStart = ExtractFileName (FileName) ; <br>      NameOffset = pFileNameStart - FileName ; <br> <br>      // convert short filename to long NTFS filename if necessary <br>      hFindFile = FindFirstFile (FileName, &amp;FindFileInfo) ; <br>      if (hFindFile &amp;&amp; hFindFile != INVALID_HANDLE_VALUE) <br>         { <br>         // append the file name back to the path name <br>         lstrcpy (&amp;FileName[NameOffset], FindFileInfo.cFileName) ; <br>         FindClose (hFindFile) ; <br>         } <br> <br>      FileOpen (hWndMain, (int)0, (LPTSTR)FileName) ; <br>      PrepareMenu (GetMenu (hWndMain)); <br>      } <br> <br>   DragFinish ((HDROP) wParam) ; <br>   } <br> <br>LRESULT APIENTRY MainWndProc (HWND hWnd,  <br>                              UINT message,  <br>                              DWORD wParam,  <br>                              LONG lParam) <br>   { <br>   LONG     lRetCode = 0L ; <br>   BOOL     bCallDefWinProc = FALSE ; <br> <br>   switch (LOWORD (message)) <br>      {  // switch <br>      case WM_LBUTTONDBLCLK: <br>         ShowPerfmonMenu (!Options.bMenubar) ; <br>         if (Options.bMenubar) <br>            { <br>            PrepareMenu (GetMenu (hWnd)) ; <br>            } <br>         break ; <br> <br>   case WM_COMMAND: <br>      if (PerfmonCommand (hWnd,wParam,lParam)) <br>         return(0); <br>         else <br>            bCallDefWinProc = TRUE ; <br>         break; <br> <br>      case WM_MENUSELECT: <br>         MenuBarHit (wParam) ; <br>         break ; <br> <br>      case WM_NCHITTEST: <br>        /* if we have no title/menu bar, clicking and dragging the client <br>         * area moves the window. To do this, return HTCAPTION. <br>         * Note dragging not allowed if window maximized, or if caption <br>         * bar is present. <br>         */ <br>        wParam = DefWindowProc(hWnd, message, wParam, lParam); <br>        if (!Options.bMenubar &amp;&amp;  <br>            (wParam == HTCLIENT) &amp;&amp; <br>            !IsZoomed (hWndMain)) <br>           return HTCAPTION ; <br>        else <br>           return wParam ; <br>        break ; <br> <br>       <br>      case WM_SHOWWINDOW: <br>         PrepareMenu (GetMenu (hWnd)) ; <br>         break ; <br> <br>      case WM_SIZE: <br>         OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ; <br>         break ; <br> <br>      case WM_GETMINMAXINFO: <br>         { <br>         MINMAXINFO   *pMinMax ; <br> <br>         pMinMax = (MINMAXINFO *) lParam ; <br>         pMinMax-&gt;ptMinTrackSize.x = MinimumSize ; <br>         pMinMax-&gt;ptMinTrackSize.y = MinimumSize ; <br>         } <br>         break ; <br> <br>      case WM_F1DOWN: <br>         if (dwCurrentDlgID) <br>            { <br>            CallWinHelp (dwCurrentDlgID) ; <br>            } <br>         else if (dwCurrentMenuID) <br>            { <br>            CallWinHelp (dwCurrentMenuID) ; <br>            dwCurrentMenuID = 0 ; <br>            } <br>         break ; <br> <br>      case WM_CREATE: <br>         OnCreate (hWnd) ; <br>         ViewChart (hWnd) ; <br>         PrepareMenu (GetMenu (hWnd)) ; <br>         break ; <br> <br>      case WM_DESTROY: <br>         WinHelp (hWndMain, pszHelpFile, HELP_QUIT, 0) ; <br>         PostQuitMessage (0); <br>         break ; <br> <br>      case WM_QUERYENDSESSION: <br>         // please shut it down <br>         return (1) ; <br>         break ; <br> <br>      case WM_ENDSESSION: <br>         if (wParam == TRUE) <br>            { <br>            // close any log file before closing down <br>            PerfmonClose (hWnd) ; <br>            return (1) ; <br>            } <br>         else <br>            bCallDefWinProc = TRUE ; <br>         break ; <br> <br>      case WM_CLOSE: <br>         PerfmonClose (hWnd) ; <br>         break ; <br> <br>      case WM_ACTIVATE: <br>         { <br>         int   fActivate = LOWORD (wParam) ; <br> <br>         bPerfmonIconic = (BOOL) HIWORD (wParam) ; <br>         if (bPerfmonIconic == 0 &amp;&amp; fActivate != WA_INACTIVE) <br>            { <br>            // set focus on the Legend window <br>            if (iPerfmonView == IDM_VIEWCHART) <br>               { <br>               SetFocus (hWndGraphLegend) ; <br>               } <br>            else if (iPerfmonView == IDM_VIEWALERT) <br>               { <br>               SetFocus (hWndAlertLegend) ; <br>               } <br>            else if (iPerfmonView == IDM_VIEWLOG) <br>               { <br>               SetFocus (hWndLogEntries) ; <br>               } <br>            else if (iPerfmonView == IDM_VIEWREPORT) <br>               { <br>               SetFocus (hWndReport) ; <br>               } <br>            } <br>         } <br>         break ; <br> <br>      case WM_SYSCOLORCHANGE: <br>         DeletePerfmonSystemObjects () ; <br>         CreatePerfmonSystemObjects () ; <br>         WindowInvalidate (PerfmonViewWindow()) ; <br>         break ; <br> <br>      case WM_WININICHANGE: <br>         if (!lParam || strsamei((LPTSTR)lParam, szInternational)) <br>            { <br>            GetDateTimeFormats () ; <br>            } <br>         break ; <br> <br>      case WM_DROPFILES: <br>         OnDropFile (wParam) ; <br>         return (0) ; <br>         break ; <br> <br>      default: <br>         bCallDefWinProc = TRUE ; <br>      break; <br> <br>      }  // switch <br> <br>   if (bCallDefWinProc) <br>      { <br>      lRetCode = DefWindowProc (hWnd, message, wParam, lParam) ; <br>      } <br>   return (lRetCode); <br>   }  // MainWndProc <br> <br> <br>int PASCAL WinMain (HINSTANCE hCurrentInstance, <br>            HINSTANCE hPrevInstance, <br>                    LPSTR lpszCmdLine,  <br>                    int nCmdShow) <br>   {  // WinMain <br>   MSG      msg; <br> <br>   if (!PerfmonInitialize (hCurrentInstance, hPrevInstance,  <br>                           lpszCmdLine, nCmdShow)) <br>      return (FALSE) ; <br> <br>   DragAcceptFiles (hWndMain, TRUE) ; <br> <br>   while (GetMessage (&amp;msg, NULL, 0, 0)) <br>      { <br>      if (!TranslateAccelerator(hWndMain, hAccelerators, &amp;msg)) <br>         { <br>         TranslateMessage (&amp;msg) ; <br>         DispatchMessage (&amp;msg) ; <br>         } <br>      }  // while <br> <br>   return(msg.wParam); <br>   } <br> <br>DWORD FAR PASCAL MessageFilterProc (int nCode, <br>                                    WPARAM wParam, <br>                                    LPARAM lParam) <br>   { <br>   LPMSG lpMsg = (LPMSG)lParam ; <br>   extern HHOOK lpMsgFilterProc ; <br> <br>   if (nCode &lt; 0) <br>      { <br>      return FALSE ; <br>      } <br> <br>   if (nCode == MSGF_DIALOGBOX || nCode == MSGF_MENU) <br>      { <br>      if (lpMsg-&gt;message == WM_KEYDOWN &amp;&amp; lpMsg-&gt;wParam == VK_F1) <br>          { <br>          PostMessage (hWndMain, WM_F1DOWN, nCode, 0L) ; <br>          return TRUE ; <br>          } <br>      } <br> <br>   return (DefHookProc (nCode, wParam, <br>              (DWORD)lpMsg, <br>              &amp;lpMsgFilterProc)) ; <br>   } <br> <br> <br>#if 0 <br>/***************************************/ <br>VOID ErrorExit(LPTSTR pszError,HWND hwnd) <br>/***************************************/ <br>{ <br>    // NOTE: make sure all lgraph calls set StopQuerying. <br> <br>    if (hwnd) <br>    { <br>        MessageBox(NULL, pszError, nm_buf, MB_ICONHAND | MB_OK | MB_SYSTEMMODAL); <br>        DestroyWindow(hwnd); <br>    } <br>    return; <br>} <br>#endif <br> <br> <br> <br>void SizePerfmonComponents (void)  <br>   { <br>   RECT           rectClient ; <br>   int            xWidth, yHeight ; <br>   int            yToolbarHeight ; <br>   int            yStatusHeight ; <br>   int            yViewHeight ; <br> <br>   GetClientRect (hWndMain, &amp;rectClient) ; <br>   xWidth = rectClient.right - rectClient.left ; <br>   yHeight = rectClient.bottom - rectClient.top ; <br> <br>   if (Options.bToolbar) <br>      { <br>      SendMessage (hWndToolbar, WM_SIZE, 0, 0L) ; <br>      } <br> <br>   yToolbarHeight = Options.bToolbar ? (WindowHeight (hWndToolbar) - 1) : 0 ; <br>   yStatusHeight = Options.bStatusbar ? StatusHeight (hWndStatus) : 0 ; <br> <br>   if (Options.bStatusbar) <br>      { <br>      if (yToolbarHeight + yStatusHeight &gt; yHeight) <br>         { <br>         // too small to display both toolbar and status bar <br>         // just display part of the status bar <br>         yStatusHeight = yHeight - yToolbarHeight ; <br>         } <br> <br>      MoveWindow (hWndStatus,  <br>                  0, yHeight - yStatusHeight, xWidth, yStatusHeight, TRUE) ; <br>      //WindowInvalidate (hWndStatus) ; <br>      } <br>   //WindowInvalidate (hWndMain) ; <br>   WindowShow (hWndStatus, Options.bStatusbar) ; <br>   WindowShow (hWndToolbar, Options.bToolbar) ; <br> <br>   yViewHeight = yHeight - yStatusHeight - yToolbarHeight ; <br> <br>   MoveWindow (hWndGraph,  <br>               0, yToolbarHeight,  <br>               xWidth, yViewHeight,  <br>               TRUE) ; <br>   MoveWindow (hWndAlert,  <br>               0, yToolbarHeight,  <br>               xWidth, yViewHeight,  <br>               TRUE) ; <br>   MoveWindow (hWndLog,  <br>               0, yToolbarHeight,  <br>               xWidth, yViewHeight,  <br>               TRUE) ; <br>   MoveWindow (hWndReport,  <br>               0, yToolbarHeight,  <br>               xWidth, yViewHeight,  <br>               TRUE) ; <br> <br> <br>   }  // SizePerfmonComponents <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
